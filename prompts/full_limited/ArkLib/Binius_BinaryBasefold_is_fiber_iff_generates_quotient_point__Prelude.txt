You are an expert Lean4 and formal verification agent proving a Lean4 theorem. Your output **must** strictly adhere to the specified format.

### Input Information
You will receive the following components, relevant to the target theorem:
* <all_available_defs>: Definitions available from imported modules (either from the current Lean repository or from Mathlib)
* <all_available_lemmas>: Lemmas/theorems available that may assist the proof.
* <local_ctx>...</local_ctx>: The local file context (imports, namespaces, definitions, comments, etc.) from the top of the file up to‚Äîbut not including‚Äîthe target theorem or any previously defined local lemmas/theorems.
* <target_theorem>...</target_theorem>: The target theorem statement, ending with `:=`.

**Notes**
1. Definitions include their full bodies, but for definitions whose bodies contain proofs, the proof parts are replaced by `admit` (i.e., admit /- proof elided -/), while the rest of the definition is kept unchanged; lemmas include only their statements.
2. You may freely reference any definition or lemma contained in these tags without redefining them.
3. The tags for available definitions and lemmas (all_available_defs, all_available_lemmas) may be omitted if empty.

### Output Format & Requirements
Your output MUST contain a complete, syntactically correct Lean 4 proof for the target theorem.

**Strict Output Structure:**
<reasoning> 
...
</reasoning> 

<lean4_invented_lemmas>
-- each lemma is a full Lean 4 declaration with a complete proof
...
</lean4_invented_lemmas>

<lean4_proof>
-- Lean 4 proof body of the target theorem
...
</lean4_proof>

**Requirements:**
1. <reasoning> and <lean4_invented_lemmas> are OPTIONAL. Include them only if they aid proof construction.
2. <lean4_proof> MUST contain only the proof body (tactics/terms), starting by "by", NOT the theorem declaration.
3. <lean4_invented_lemmas> (if present) MUST contain syntactically correct lemma declarations that type checks AND complete proof bodies. Defining a lemma using `axiom` is NOT allowed.
4. <reasoning> contains high-level proof planning.
5. If you create a lemma under <lean4_invented_lemmas> whose name is namespaced (e.g., X.Y.Z), you MUST always refer to it using its fully qualified name. Do NOT rely on shortened names. For example, write rw [X.Y.Z], not rw [Z] for invented lemmas.
6. All Lean 4 code MUST be syntactically correct. No `sorry`, `admit`, or non-Lean text. Comments allowed using `--` or `/- ... -/`.
7. Follow the tags and structure EXACTLY. No extra text before, between, or after the sections.
8. Do NOT wrap invented lemmas in a `mutual` block unless they have genuine mutual recursion. Declare each lemma independently.

### Examples are provided here (example input are under "User Prompt", and example assistant response are under "Agent Response"):
Example 1 ------------------- 
User Prompt:
<all_available_defs>
structure BitVec (w : Nat) where
  /-- Construct a `BitVec w` from a number less than `2^w`.
  O(1), because we use `Fin` as the internal representation of a bitvector. -/
  ofFin ::

  /-- Interpret a bitvector as a number less than `2^w`.
  O(1), because we use `Fin` as the internal representation of a bitvector. -/
  toFin : Fin (hPow 2 w)
</all_available_defs>

<all_available_lemmas>
theorem List.getElem_append_left{Œ± : Type u_1} {l‚ÇÅ l‚ÇÇ : List Œ±} {i : Nat} (hn : i < l‚ÇÅ.length) : (l‚ÇÅ ++ l‚ÇÇ)[i] = l‚ÇÅ[i]
theorem getElem_eq_testBit_toNat (x : BitVec w) (i : Nat) (h : i < w) :
  x[i] = x.toNat.testBit i := rfl
@[simp, grind =] theorem toNat_cons (b : Bool) (x : BitVec w) :
    (cons b x).toNat = (b.toNat <<< w) ||| x.toNat
@[simp, grind =] theorem getLsbD_of_ge (x : BitVec w) (i : Nat) (ge : w ‚â§ i) : getLsbD x i = false
theorem testBit_toNat (x : BitVec w) : x.toNat.testBit i = x.getLsbD i
</all_available_lemmas>

<local_ctx>
import Mathlib.Computability.NFA
import Mathlib.Data.FinEnum
import Mathlib.Data.Rel
import Mathlib.Data.Vector.Basic
import Blase.AutoStructs.ForLean

open Set
open Mathlib
open SetRel

-- this is better because card is defeq to n
instance (Œ± : Type) : Inter (Language Œ±) := ‚ü®Set.inter‚ü©
instance (Œ± : Type) : Union (Language Œ±) := ‚ü®Set.union‚ü©

/--
The set of `n`-tuples of bit vectors of an arbitrary width.
-/
structure BitVecs (n : Nat) where
  w : Nat
  bvs : List.Vector (BitVec w) n

def BitVecs.cast (bvs : BitVecs n) (h : n = n') : BitVecs n' :=
  { w := bvs.w, bvs := h ‚ñ∏ bvs.bvs }

abbrev BitVecs.empty : BitVecs n := ‚ü®0, List.Vector.replicate n .nil‚ü©
abbrev BitVecs.singleton {w : Nat} (bv : BitVec w) : BitVecs 1 := ‚ü®w, bv ::·µ• .nil‚ü©
abbrev BitVecs.pair {w : Nat} (bv1 bv2 : BitVec w) : BitVecs 2 := ‚ü®w, bv1 ::·µ• bv2 ::·µ• .nil‚ü©

/--
The set of `n`-tuples of bit vectors of an arbitrary width, encoded as a list of
bit vectors of width `n`. The width of the encoded bit vectors is the length of
the list.
-/
abbrev BitVecs' (n : Nat) := List (BitVec n)

@[simps]
def dec (bvs' : BitVecs' n) : BitVecs n where
  w := bvs'.length
  bvs := List.Vector.ofFn fun k => BitVec.ofFn fun i => bvs'[i].getLsbD k

@[simp]
</local_ctx>

<target_theorem>
lemma dec_snoc n (bvs' : BitVecs' n) (a : BitVec n) :
  dec (bvs' ++ [a]) =
    { w := bvs'.length + 1
      bvs := List.Vector.ofFn fun k =>
        BitVec.cons (a.getLsbD k) ((dec bvs').bvs.get k) } :=
</target_theorem>

Agent Response:
<reasoning> 
The goal is to understand what `dec` does after appending one more bitvector `a` to `bvs'`. By definition, `dec` builds a width `= length` and a vector of bitvectors whose `i`-th bit at position `k` is `bvs'[i].getLsbD k`. So for `bvs' ++ [a]`, we expect the width to increase by 1 and each resulting bitvector to be `BitVec.cons` of the new bit coming from `a`.

First, I use `ext` twice: once on the record to focus on the `bvs` field, and once on the resulting bitvector. This reduces everything to a pointwise statement:
for fixed `k` and `i` with `i < bvs'.length + 1`,
the bit `(bvs' ++ [a])[i].getLsbD k` should match the bit at index `i` of `BitVec.cons (a.getLsbD k) ((dec bvs').bvs.get k)`.

At this point I need a clean description of indexing into `BitVec.cons`: if we have `x : BitVec n`, then `(cons b x)[i]` should give `b` at the new ‚Äúlast‚Äù index `n` and `x[i]` otherwise. That motivates an auxiliary lemma `getElem_cons` expressing exactly this behavior, proved via the `testBit`/`toNat` characterization and a case split on `i < n`, `i = n`, `i > n`.

Using `getElem_cons`, the RHS becomes an `if` on whether `i = bvs'.length`. So I split into cases:
- If `i = bvs'.length`, then `(bvs' ++ [a])[i]` is the appended `a`, so both sides reduce to `a.getLsbD k`.
- If `i ‚â† bvs'.length`, the bound `i < bvs'.length + 1` forces `i < bvs'.length`. Then `(bvs' ++ [a])[i] = bvs'[i]` by `List.getElem_append_left`, and the RHS takes the ‚Äúelse‚Äù branch and likewise gives the bit from `bvs'[i]`. In both subcases, `simp` (plus the definition of `dec`) finishes.

So the whole proof is: `ext` to bit level, unfold `dec` with `simp_all`, rewrite with `getElem_cons`, split on the boundary index `i = length bvs'`, and in the ‚Äú< length‚Äù branch use `List.getElem_append_left` and bounds to line up both sides.
</reasoning> 

<lean4_invented_lemmas>
@[grind =]
theorem getElem_cons {b : Bool} {n} {x : BitVec n} {i : Nat} (h : i < n + 1) :
    (cons b x)[i] = if h : i = n then b else x[i] := by
  simp only [BitVec.getElem_eq_testBit_toNat, BitVec.toNat_cons, Nat.testBit_or]
  rw [Nat.testBit_shiftLeft]
  rcases Nat.lt_trichotomy i n with i_lt_n | i_eq_n | n_lt_i
  ¬∑ have p1 : ¬¨(n ‚â§ i) := by omega
    have p2 : i ‚â† n := by omega
    simp [p1, p2]
  ¬∑ simp only [i_eq_n, ge_iff_le, Nat.le_refl, decide_true, Nat.sub_self, Nat.testBit_zero,
    Bool.true_and, BitVec.testBit_toNat, BitVec.getLsbD_of_ge, Bool.or_false]
    cases b <;> trivial
  ¬∑ have p1 : i ‚â† n := by omega
    have p2 : i - n ‚â† 0 := by omega
    simp [p1, p2, Nat.testBit_bool_toNat]
</lean4_invented_lemmas>

<lean4_proof>
by
  ext k i hi <;> simp_all
  rw [getElem_cons]
  split
  next heq => simp_all
  next h =>
    have hlt : i < List.length bvs' := by simp at hi; omega
    rw [List.getElem_append_left hlt]
    simp
</lean4_proof>

### Your task:
<all_available_defs>
Nat in Init.Prelude
Fin in Init.Prelude
Subspace in Mathlib.Algebra.Module.Submodule.Basic
Set in Mathlib.Data.Set.Defs
Set.Ico in Mathlib.Order.Interval.Set.Defs
Submodule in Mathlib.Algebra.Module.Submodule.Defs
Submodule.span in Mathlib.LinearAlgebra.Span.Defs
Polynomial.C in Mathlib.Algebra.Polynomial.Basic
Algebra in Mathlib.Algebra.Algebra.Defs
Field in Mathlib.Algebra.Field.Defs
IsLinearMap in Mathlib.Algebra.Module.LinearMap.Defs
toFun in ToMathlib.Control.Monad.Hom
Submodule.map in Mathlib.Algebra.Module.Submodule.Map
Module.Basis in Mathlib.LinearAlgebra.Basis.Defs
Disjoint in Mathlib.Order.Disjoint
Fact in Mathlib.Logic.Basic
LinearEquiv in Mathlib.Algebra.Module.Equiv.Defs
LinearEquiv.ofBijective in Mathlib.Algebra.Module.Submodule.Equiv
LinearIndependent in Mathlib.LinearAlgebra.LinearIndependent.Defs
LinearMap in Mathlib.Algebra.Module.LinearMap.Defs
LinearMap.codRestrict in Mathlib.Algebra.Module.Submodule.LinearMap
LinearMap.ker in Mathlib.Algebra.Module.Submodule.Ker
Module.Basis.span in Mathlib.LinearAlgebra.Basis.Basic
Set.range in Mathlib.Data.Set.Operations
Submodule.subtype in Mathlib.Algebra.Module.Submodule.LinearMap
Subtype in Init.Prelude
Finsupp in Mathlib.Data.Finsupp.Defs
Finsupp.equivFunOnFinite in Mathlib.Data.Finsupp.Defs
Finset in Mathlib.Data.Finset.Defs
Finset.univ in Mathlib.Data.Fintype.Defs
Ne in Init.Core
NeZero in Init.Data.NeZero
DecidableEq in Init.Prelude
Inhabited in Init.Prelude
Repr in Init.Data.Repr
Fin.cast in Init.Data.Fin.Basic
Fintype in Mathlib.Data.Fintype.Defs
Fintype.card in Mathlib.Data.Fintype.Card
algebraMap in Mathlib.Algebra.Algebra.Defs
Fin.foldl in Init.Data.Fin.Fold
context in Examples.FrankingProtocol
Polynomial in Mathlib.Algebra.Polynomial.Basic
Decidable in Init.Prelude
Eq in Init.Prelude
id in Init.Prelude
reduceDIte in Lean.Meta.Tactic.Simp.BuiltinSimprocs.Core
Module in Mathlib.Algebra.Module.Defs
Nat.succ in Init.Prelude
Polynomial.eval in Mathlib.Algebra.Polynomial.Eval.Defs

def getBit (k n : Nat) : Nat := (n >>> k) &&& 1

noncomputable def sDomain (i : Fin r) : Subspace ùîΩq L :=
  let W_i_norm := normalizedW ùîΩq Œ≤ i
  let h_W_i_norm_is_additive : IsLinearMap ùîΩq (fun x : L => W_i_norm.eval x) :=
    AdditiveNTT.normalizedW_is_additive ùîΩq Œ≤ i
  Submodule.map (polyEvalLinearMap W_i_norm h_W_i_norm_is_additive)
    (U ùîΩq Œ≤ ‚ü®‚Ñì + R_rate, h_‚Ñì_add_R_rate‚ü©)

noncomputable def normalizedW (i : Fin r) : L[X] :=
  C (1 / (W ùîΩq Œ≤ i).eval (Œ≤ i)) * W ùîΩq Œ≤ i

noncomputable def W (i : Fin r) : L[X] :=
  ‚àè u : U ùîΩq Œ≤ i, (X - C u.val)

def U (i : Fin r) : Subspace ùîΩq L := Submodule.span ùîΩq (Œ≤ '' (Set.Ico 0 i))

noncomputable def polyEvalLinearMap {L ùîΩq : Type*} [Field L] [Field ùîΩq] [Algebra ùîΩq L]
  (p : L[X]) (hp_add : IsLinearMap ùîΩq (fun x : L => p.eval x)) : L ‚Üí‚Çó[ùîΩq] L :=
{
  toFun    := fun x => p.eval x,
  map_add' := hp_add.map_add,
  map_smul' := hp_add.map_smul
}

noncomputable def sDomain_basis (i : Fin r) (h_i : i < ‚Ñì + R_rate) :
    Basis (Fin (‚Ñì + R_rate - i)) ùîΩq (
      sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i) :=

def sBasis (i : Fin r) (h_i : i < ‚Ñì + R_rate) : Fin (‚Ñì + R_rate - i) ‚Üí L :=
  fun k => Œ≤ ‚ü®i + k.val, by admit /- proof elided -/
  ‚ü©

def binaryFinMapToNat {n : ‚Ñï} (m : Fin n ‚Üí ‚Ñï) (h_binary : ‚àÄ j: Fin n, m j ‚â§ 1) : Fin (2^n) :=

def symm (eqv : Equiv pSpec pSpec') : Equiv pSpec' pSpec where
  round_eq := eqv.round_eq.symm
  dir_eq := fun i => by admit /- proof elided -/

@[ext]
structure Equiv {m n : ‚Ñï} (pSpec : ProtocolSpec m) (pSpec' : ProtocolSpec n) where
  round_eq : m = n
  dir_eq : ‚àÄ i, pSpec.dir i = pSpec'.dir (Fin.cast round_eq i)
  typeEquiv : ‚àÄ i, pSpec.¬´Type¬ª i ‚âÉ pSpec'.¬´Type¬ª (Fin.cast round_eq i)

@[ext]
structure ProtocolSpec (n : ‚Ñï) where
   
  dir : Fin n ‚Üí Direction
   
  ¬´Type¬ª : Fin n ‚Üí Type
deriving Inhabited

inductive Direction where
  | P_to_V  
  | V_to_P 
deriving DecidableEq, Inhabited, Repr

noncomputable def iteratedQuotientMap (i : Fin ‚Ñì) (k : ‚Ñï)
    (h_bound : i.val + k ‚â§ ‚Ñì) (x : (sDomain ùîΩq Œ≤
    h_‚Ñì_add_R_rate) ‚ü®i, by omega‚ü©) :
    (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®i.val + k, by omega‚ü© :=

noncomputable def intermediateNormVpoly
    
    (i: Fin (‚Ñì+1)) (k : Fin (‚Ñì - i + 1)) : L[X] :=
  
  Fin.foldl (n:=k) (fun acc j =>
    (qMap ùîΩq Œ≤ ‚ü®(i : ‚Ñï) + (j : ‚Ñï), by admit /- proof elided -/
    ‚ü©).comp acc) (X)

noncomputable def qMap (i : Fin r) : L[X] :=
  let constMultiplier := ((W ùîΩq Œ≤ i).eval (Œ≤ i))^(Fintype.card ùîΩq)
    / ((W ùîΩq Œ≤ (i + 1)).eval (Œ≤ (i + 1)))
  C constMultiplier * ‚àè c: ùîΩq, (X - C (algebraMap ùîΩq L c))

noncomputable def qCompositionChain (i : Fin r) : L[X] :=
  match i with
  | ‚ü®0, _‚ü© => X
  | ‚ü®k + 1, h_k_add_1‚ü© => (qMap ùîΩq Œ≤ ‚ü®k, by admit /- proof elided -/
  ‚ü©).comp (qCompositionChain ‚ü®k, by admit /- proof elided -/
  ‚ü©)

@[elab_as_elim] def Fin.succRecOnSameFinType {motive : Fin r ‚Üí Sort _}
    (zero : motive (0 : Fin r))
    (succ : ‚àÄ i : Fin r, i + 1 < r ‚Üí motive i ‚Üí motive (i + 1)) : ‚àÄ (i : Fin r), motive i
  | ‚ü®0, _‚ü© => by admit /- proof elided -/
  | ‚ü®Nat.succ i_val, h‚ü© => by admit /- proof elided -/

def proximityListDecodingCondition (C : LinearCode Œπ F)
  [Fintype Œπ] [Nonempty Œπ]
  (r : par‚Ñì ‚Üí F) [Fintype par‚Ñì]
  (Œ¥ : ‚Ñù) (fs : Matrix par‚Ñì Œπ F)
  (IC : InterleavedCode par‚Ñì Œπ F) : Prop :=
      let f_r := fun x => ‚àë j, r j * fs j x
      let listHamming := relHammingBall C f_r Œ¥
      let listIC := { fun x => ‚àë j, r j * us j x | us ‚àà Œõ·µ¢(fs, IC.MF, Œ¥)}
      listHamming ‚â† listIC

Polynomial.reverse in Mathlib.Algebra.Polynomial.Reverse

def oracleReduction : OracleReduction oSpec (StmtIn R) (OStmtIn R deg) Unit
                                            (StmtOut R) (OStmtOut R deg) Unit (pSpec R deg) where
  prover := prover R deg oSpec
  verifier := oracleVerifier R deg D oSpec

instance [VerifierFirst pSpec] [h : VCVCompatible (pSpec.¬´Type¬ª 0)] :
    ‚àÄ i, VCVCompatible (pSpec.Challenge i)
  | ‚ü®0, _‚ü© => inferInstance

head in ToMathlib.Control.Comonad.Instances

abbrev CoeffVecSpace (L : Type u) (‚Ñì : Nat) := Fin (2^‚Ñì) ‚Üí L

def Œ∂ (R : F[X][X][Y]) (x‚ÇÄ : F) (H : F[X][Y]) [H_irreducible : Fact (Irreducible H)] : ùïÉ H :=
  let W  : ùïÉ H := liftToFunctionField (H.leadingCoeff);
  let T : ùïÉ H := liftToFunctionField (Polynomial.X);
    Polynomial.eval‚ÇÇ liftToFunctionField (T / W)
      (Bivariate.evalX (Polynomial.C x‚ÇÄ) R.derivative)

@[reducible]
def pSpec : ProtocolSpec (Fin.vsum (fun _ : Fin n => 2)) :=
  ProtocolSpec.seqCompose (fun _ => SingleRound.pSpec R deg)

def duplexSpongeToBasicFSQueryImpl :
    QueryImpl (duplexSpongeChallengeOracle StmtIn U)
      (OracleComp (fsChallengeOracle StmtIn pSpec)) :=
  sorry

alias d2SQueryImpl := duplexSpongeToBasicFSQueryImpl

partial def factor (n : ‚Ñï) : Option (List ‚Ñï) :=
  if deterministicMillerRabin n then
    [n]
  else do
    let f ‚Üê rho n
    let lhs ‚Üê factor f
    let rhs ‚Üê factor (n / f)
    return (lhs ++ rhs)

noncomputable def foldingDistRange
   (degree : ‚Ñï) [Fintype Œπ] [Nonempty Œπ] (œÜ : Œπ ‚Ü™ F) (f : Œπ ‚Üí F) : ‚Ñù :=
    let C : Set (Œπ ‚Üí F) := code œÜ degree
    min Œ¥·µ£(f, C) (1 - Bstar (LinearCode.rate (code œÜ degree)))

noncomputable instance {s : Set (Œπ ‚Üí F)} : Fintype (affineSpan F s) :=
  Fintype.ofFinite ‚Ü•(affineSpan F s)

@[reducible]
def foldRelayOracleVerifier (i : Fin ‚Ñì)
    (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
  OracleVerifier []‚Çí
    (StmtIn := Statement (L := L) Context i.castSucc)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.succ)
    (pSpec := pSpecFoldRelay (L:=L)) :=
  OracleVerifier.append
        (pSpec‚ÇÅ := pSpecFold (L:=L))
    (pSpec‚ÇÇ := pSpecRelay)
    (foldOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)
    (relayOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hNCR)

instance : LawfulHasSucc Nat where
  succ'_eq_add_one := Nat.succ_eq_add_one

def powContraction :
  MvPolynomial (Fin m) F ‚Üí‚Çó[F] Polynomial F :=
  powAlgHom.toLinearMap

List.mapM' in Init.Data.List.Monadic

instance [ProverFirst pSpec] : Unique (pSpec.MessageIdx) where
  default := ‚ü®0, by admit /- proof elided -/
  ‚ü©
  uniq := fun ‚ü®i, _‚ü© => by admit /- proof elided -/

@[simp]
def ùïè (k : ‚Ñï) : BTField (k+1) := Z (k+1)

class VCVCompatible (Œ± : Type*) extends Fintype Œ±, Inhabited Œ± where
  [type_decidableEq' : DecidableEq Œ±]

Set.offDiag in Mathlib.Data.Set.Operations

instance : Coe (‚àÄ a : Œ±, Œ≤ a) F where
  coe := DFunEquiv.equiv.invFun

Subsingleton in Init.Core

noncomputable def towerRingHomBackwardMap (k : ‚Ñï) : BTField k ‚Üí ConcreteBTField k :=

Polynomial.resultant in Mathlib.RingTheory.Polynomial.Resultant.Basic

@[reducible, simp] def OStmtIn := fun _ : Fin 2 => OStatement

@[inline]
def seqCompose {m : ‚Ñï} (Stmt : Fin (m + 1) ‚Üí Type) (Wit : Fin (m + 1) ‚Üí Type)
    {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (R : (i : Fin m) ‚Üí
      Reduction oSpec (Stmt i.castSucc) (Wit i.castSucc) (Stmt i.succ) (Wit i.succ) (pSpec i)) :
    Reduction oSpec (Stmt 0) (Wit 0) (Stmt (Fin.last m)) (Wit (Fin.last m)) (seqCompose pSpec) where
  prover := Prover.seqCompose Stmt Wit (fun i => (R i).prover)
  verifier := Verifier.seqCompose Stmt (fun i => (R i).verifier)

BitVec.toNat in Init.Prelude

@[inline] def mod [Zero T] [DecidableEq T] [ToNat T]
    (dividend divisor : Cayley T) : Cayley T :=
  
  letI fuel := (‚Üëdividend : Nat) + 1
  modNat dividend divisor fuel

def SumFunEquivProd (Œ± Œ≤ Œ≥ : Type) : ((Œ± ‚äï Œ≤) ‚Üí Œ≥) ‚âÉ (Œ± ‚Üí Œ≥) √ó (Œ≤ ‚Üí Œ≥) :=
{ toFun := fun f => (fun a => f (.inl a), fun b => f (.inr b))
  , invFun := fun p x => match x with | .inl a => p.fst a | .inr b => p.snd b
  , left_inv := by admit /- proof elided -/

Polynomial.erase in Mathlib.Algebra.Polynomial.Basic

def Z (k : ‚Ñï) : ConcreteBTField k :=
  if h_k : k = 0 then one
  else
    „Ää one (k:=k-1), zero (k:=k-1) „Äã

def domainComplement (œÜ : Œπ ‚Ü™ F) : Finset F :=
  Finset.univ \ Finset.image œÜ.toFun Finset.univ

def Fin.traverseM {Œ≤ : Fin n ‚Üí Type u}
    (f : (i : Fin n) ‚Üí m (Œ≤ i)) : m ((i : Fin n) ‚Üí Œ≤ i) :=
  let rec aux (k : ‚Ñï) (h : k ‚â§ n) : m ((i : Fin k) ‚Üí Œ≤ (Fin.castLE h i)) :=
    match k with
    | 0 => pure (fun i => i.elim0)
    | k' + 1 => do
      let tail ‚Üê aux k' (Nat.le_of_succ_le h)
      let head ‚Üê f (Fin.castLE h (Fin.last k'))
      return (Fin.snoc tail head)
  aux n (le_refl n)

instance (priority := low) : DCast‚ÇÇ Œ± Œ≤ Œ≥ where
  dcast‚ÇÇ ha hb c := by admit /- proof elided -/

EmbeddingLike in Mathlib.Data.FunLike.Embedding

abbrev ScalarField := ZMod scalarFieldSize

Prod in Init.Prelude

instance [Inhabited OuterWitOut]
    [instKS : lens.IsKnowledgeSound
                outerRelIn innerRelIn
                outerRelOut innerRelOut
                compatStmt (fun _ _ => True)] :
    lens.stmt.IsSound
      outerRelIn.language outerRelOut.language
      innerRelIn.language innerRelOut.language
      compatStmt where
  proj_sound := fun outerStmtIn hCompat => by admit /- proof elided -/

@[simp]
abbrev Witness.AfterFirstMessage : Type := Unit

structure KnowledgeStateFunctionOneShot
    (langIn : Set StmtIn) (langOut : Set StmtOut)
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    where
  toFun : (m : Fin (n + 1)) ‚Üí StmtIn ‚Üí Transcript m pSpec ‚Üí Prop
   
  toFun_empty : ‚àÄ stmtIn, ¬¨ toFun 0 stmtIn default
   
  toFun_next : ‚àÄ m, pSpec.dir m = .P_to_V ‚Üí
    ‚àÄ stmt tr msg, ¬¨ toFun m.castSucc stmt tr ‚Üí ¬¨ toFun m.succ stmt (tr.concat msg)
   
  toFun_full : ‚àÄ stmt tr, ¬¨ toFun (.last n) stmt tr ‚Üí
    [(¬∑ ‚àà langOut) | do (simulateQ impl (verifier.run stmt tr)).run' (‚Üê init)] = 0

@[reducible, simp]
def toRelInput : Set ((Statement √ó (‚àÄ i, OStatement i)) √ó Unit) :=
  { ‚ü®‚ü®stmt, oStmt‚ü©, _‚ü© | simulateQ' (toOracleImpl OStatement oStmt) (pred stmt) (hPred stmt) }

BitVec.extractLsb' in Init.Data.BitVec.Basic

def numQueries (stmt : StmtIn) (challenges : ‚àÄ i, pSpec.Challenge i)
    (verifier : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec) :
  OracleComp (oSpec ++‚Çí ([OStmtIn]‚Çí ++‚Çí [pSpec.Message]‚Çí)) ‚Ñï := sorry

def quotient (f g : F[X][Y]) : Prop := ‚àÉ q : F[X][Y], g = q * f

instance : Zero (DuplexSponge U C) where
  zero := {
    state := 0,
    absorbPos := 0,
    squeezePos := 0
  }

@[reducible, simp]
def soundness (langIn : Set Statement)
    (verifier : Verifier oSpec Statement Bool pSpec)
    (soundnessError : ‚Ñù‚â•0) : Prop :=
  verifier.soundness init impl langIn acceptRejectRel.language soundnessError

instance (k : ‚Ñï) : AddCommGroup (ConcreteBTField k) := mkAddCommGroupInstance

noncomputable def towerEquiv_zero : RingEquiv (R:=GF(2)) (S:=ConcreteBTField 0) :=  {
  toFun := fun x => if x = 0 then 0 else 1,
  invFun := fun x => if x = 0 then 0 else 1,
  left_inv := fun x => by admit /- proof elided -/

map_pure in ToMathlib.Control.Monad.Hom

@[inline] def succ (n : AssocNat) : AssocNat :=
  add n one

structure Gate (ùì° : Type*) (numWires : ‚Ñï) extends Selector ùì°, WireIndices numWires
deriving DecidableEq

instance coeFunctionFin2 [NatCast R] : Coe (œÉ ‚Üí Fin 2) (œÉ ‚Üí R) where
  coe := fun vec i => vec i

def Verifier.duplexSpongeFiatShamir (V : Verifier oSpec StmtIn StmtOut pSpec) :
    NonInteractiveVerifier (‚àÄ i, pSpec.Message i) (oSpec ++‚Çí duplexSpongeChallengeOracle StmtIn U)
      StmtIn StmtOut where
  verify := fun stmtIn proof => do
    
    let messages : pSpec.Messages := proof 0
    
    let ‚ü®_, transcript‚ü© ‚Üê messages.deriveTranscriptDSFS stmtIn
    V.verify stmtIn transcript

@[inline, reducible]
def lift : OuterStmtIn ‚Üí InnerStmtOut ‚Üí OuterStmtOut :=
  lens.toFunB

def millerRabinBases : List ‚Ñï :=
  [2, 325, 9375, 28178, 450775, 9780504, 1795265022]

def acceptRejectRel : Set (Bool √ó Unit) :=
  { (true, ()) }

@[inline, reducible]
def Witness.Lens (OuterStmtIn InnerStmtOut OuterWitIn OuterWitOut InnerWitIn InnerWitOut : Type)
    := PFunctor.Lens ((OuterStmtIn √ó OuterWitIn) X^ OuterWitOut)
                     (InnerWitIn X^ (InnerStmtOut √ó InnerWitOut))

def Œ±' (x‚ÇÄ : F) (R : F[X][X][Y]) (H_irreducible : Irreducible H) (t : ‚Ñï) : ùïÉ H :=
  Œ± x‚ÇÄ R _ (œÜ := ‚ü®H_irreducible‚ü©) t

@[reducible, inline]
instance instPolynomial : OracleInterface R[X] where
  Query := R
  Response := R
  answer := fun poly point => poly.eval point

AdjoinRoot.powerBasis' in Mathlib.RingTheory.AdjoinRoot

UInt64 in Init.Prelude

instance : ‚àÄ j, OracleInterface ((pSpec F).Message j)
  | ‚ü®0, h‚ü© => nomatch h
  | ‚ü®1, _‚ü© => by admit /- proof elided -/

def foldKStateProp {i : Fin ‚Ñì} (m : Fin (2 + 1))
    (tr : Transcript m (pSpecFold (L := L))) (stmt : Statement (L := L) Context i.castSucc)
    (witMid : Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j) :
    Prop :=
  
  let h_star : ‚Ü•L‚¶É‚â§ 2‚¶Ñ[X] := getSumcheckRoundPoly ‚Ñì ùìë (i := i) (h := witMid.H)
  
  let get_H·µ¢ := fun (m: Fin (2 + 1)) (tr: Transcript m pSpecFold) (hm: 1 ‚â§ m.val) =>
    let ‚ü®msgsUpTo, _‚ü© := Transcript.equivMessagesChallenges (k := m)
      (pSpec := pSpecFold (L := L)) tr
    let i_msg1 : ((pSpecFold (L := L)).take m m.is_le).MessageIdx :=
      ‚ü®‚ü®0, Nat.lt_of_succ_le hm‚ü©, by admit /- proof elided -/
      ‚ü©
    let h_i : L‚¶É‚â§ 2‚¶Ñ[X] := msgsUpTo i_msg1
    h_i

  let get_r·µ¢' := fun (m: Fin (2 + 1)) (tr: Transcript m pSpecFold) (hm: 2 ‚â§ m.val) =>
    let ‚ü®msgsUpTo, chalsUpTo‚ü© := Transcript.equivMessagesChallenges (k := m)
      (pSpec := pSpecFold (L := L)) tr
    let i_msg1 : ((pSpecFold (L := L)).take m m.is_le).MessageIdx :=
      ‚ü®‚ü®0, Nat.lt_of_succ_le (Nat.le_trans (by admit /- proof elided -/
      ) hm)‚ü©, by admit /- proof elided -/
      ‚ü©
    let h_i : L‚¶É‚â§ 2‚¶Ñ[X] := msgsUpTo i_msg1
    let i_msg2 : ((pSpecFold (L := L)).take m m.is_le).ChallengeIdx :=
      ‚ü®‚ü®1, Nat.lt_of_succ_le hm‚ü©, by admit /- proof elided -/
      ‚ü©
    let r_i' : L := chalsUpTo i_msg2
    r_i'

  match m with
  | ‚ü®0, _‚ü© => 
    masterKStateProp (mp := mp) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (stmtIdx := i.castSucc) (oracleIdx := i.castSucc)
      (h_le := le_refl _)
      (stmt := stmt) (wit := witMid) (oStmt := oStmt)
      (localChecks := True)
  | ‚ü®1, h1‚ü© => 
    masterKStateProp (mp := mp) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (stmtIdx := i.castSucc) (oracleIdx := i.castSucc)
      (h_le := le_refl _)
      (stmt := stmt) (wit := witMid) (oStmt := oStmt)
      (localChecks :=
        let h_i := get_H·µ¢ (m := ‚ü®1, h1‚ü©) (tr := tr) (hm := by admit /- proof elided -/
        )
        let explicitVCheck := h_i.val.eval 0 + h_i.val.eval 1 = stmt.sumcheck_target
        let localizedRoundPolyCheck := h_i = h_star
        explicitVCheck ‚àß localizedRoundPolyCheck
      )
  | ‚ü®2, h2‚ü© => 
    
    masterKStateProp (mp := mp) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (stmtIdx := i.castSucc) (oracleIdx := i.castSucc)
      (h_le := le_refl _)
      (stmt := stmt) (wit := witMid) (oStmt := oStmt)
      (localChecks :=
        let h_i := get_H·µ¢ (m := ‚ü®2, h2‚ü©) (tr := tr) (hm := by admit /- proof elided -/
        )
        let r_i' := get_r·µ¢' (m := ‚ü®2, h2‚ü©) (tr := tr) (hm := by admit /- proof elided -/
        )
        let localizedRoundPolyCheck := h_i = h_star
        let nextSumcheckTargetCheck := 
          h_i.val.eval r_i' = h_star.val.eval r_i'
        localizedRoundPolyCheck ‚àß nextSumcheckTargetCheck
      ) 

def distEq (mx my : OracleComp spec Œ±) : Prop :=
  evalDist mx = evalDist my

@[inline, specialize]
def Reduction.run (stmt : StmtIn) (wit : WitIn)
    (reduction : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí)
        ((FullTranscript pSpec √ó StmtOut √ó WitOut) √ó StmtOut) := do
  
  let proverResult ‚Üê reduction.prover.run stmt wit
  let stmtOut ‚Üê liftM (reduction.verifier.run stmt proverResult.1)
  return ‚ü®proverResult, stmtOut‚ü©

protected def cast (hIdx : k.val = l.val) (hSpec : pSpec‚ÇÅ.cast hn = pSpec‚ÇÇ)
    (T : pSpec‚ÇÅ.Transcript k) : pSpec‚ÇÇ.Transcript l :=
  fun i => _root_.cast (by admit /- proof elided -/
  ) (T (Fin.cast hIdx.symm i))

@[reducible]
def SimOracle.Impl (spec : OracleSpec Œπ) := SimOracle.Stateless spec []‚Çí

Pow in Init.Prelude

Set.finrank in Mathlib.LinearAlgebra.Dimension.Constructions

def range (n : ‚Ñï) : Fin n ‚Üí ‚Ñï := fun i => i

def findImports (path : System.FilePath) : IO (Array Lean.Name) := do
  return (‚Üê Lean.parseImports' (‚Üê IO.FS.readFile path) path.toString)
    |>.map (fun imp ‚Ü¶ imp.module) |>.erase `Init

@[simp]
abbrev Statement := R1CS.Statement R pp.toSizeR1CS

@[inline, reducible]
def lift : OuterStmtIn √ó OuterWitIn ‚Üí InnerStmtOut √ó InnerWitOut ‚Üí OuterStmtOut √ó OuterWitOut :=
  fun ctxIn ctxOut =>
    ‚ü®lens.stmt.toFunB ctxIn.1 ctxOut.1, lens.wit.toFunB ctxIn ctxOut‚ü©

NeZero in Init.Data.NeZero

@[reducible]
def MlPoly (R : Type*) (n : ‚Ñï) := Vector R (2 ^ n) 

toList in ToMathlib.ProbabilityTheory.FinRatPMF

@[inline, specialize]
def oracleVerifier : OracleVerifier oSpec
    Statement OStatement Statement (OStatement ‚äï·µ• (fun _ : Fin 1 => Witness))
    (oraclePSpec Witness) where
  verify := fun stmt _ => pure stmt
  embed := .sumMap (.refl _)
    <| Equiv.toEmbedding
    <|.symm (subtypeUnivEquiv (by admit /- proof elided -/
    ))
  hEq := by admit /- proof elided -/

@[inline]
def nsmul [SMul ‚Ñï R] (m : ‚Ñï) (p : MlPolyEval R n) : MlPolyEval R n := p.map (fun a => m ‚Ä¢ a)

MonomialOrder in Mathlib.Data.Finsupp.MonomialOrder

def domainEmb {i : ‚Ñï} : evalDomain D i ‚Ü™ F :=
  ‚ü®
    fun x => x.1.1,
    by admit /- proof elided -/
  ‚ü©

@[reducible, simp]
def completeness (relation : Set (Statement √ó Witness)) (completenessError : ‚Ñù‚â•0)
    (proof : Proof oSpec Statement Witness pSpec) : Prop :=
  Reduction.completeness init impl relation acceptRejectRel proof completenessError

LawfulMonad in Init.Control.Lawful.Basic

def foldMatrix (i : Fin r) (steps : Fin (‚Ñì + 1)) (h_i_add_steps : i.val + steps < ‚Ñì + ùì°)
    (y : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate)
      ‚ü®‚Üëi + steps, by apply Nat.lt_trans (m := ‚Ñì + ùì°) (h_i_add_steps) h_‚Ñì_add_R_rate‚ü©)
    : Matrix (Fin (2 ^ steps.val)) (Fin (2 ^ steps.val)) L :=

instance [DecidableEq Œπ] : Memory Œπ Œ± (‚àÄ i, Œ± i) where
  read m i := m i
  write m i v := Function.update m i v

@[inline]
def zsmul [SMul ‚Ñ§ R] (m : ‚Ñ§) (p : MlPolyEval R n) : MlPolyEval R n := p.map (fun a => m ‚Ä¢ a)

Fin.take in Mathlib.Data.Fin.Tuple.Take

Lean.Expr in Lean.Expr

def witnessStructuralInvariant {i : Fin (‚Ñì + 1)} (stmt : Statement (L := L) Context i)
    (wit : Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i): Prop :=
  wit.H = projectToMidSumcheckPoly ‚Ñì wit.t (m:=mp.multpoly stmt.ctx) i stmt.challenges ‚àß
  wit.f = getMidCodewords ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) wit.t stmt.challenges

instance : ‚àÄ i, SelectableType ((pSpecCoreInteraction ùîΩq Œ≤ (œë:=œë)
  (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).Challenge i) := instSelectableTypeChallengeAppend

@[inline, specialize]
def OracleReduction.run [‚àÄ i, OracleInterface (pSpec.Message i)]
    (stmt : StmtIn) (oStmt : ‚àÄ i, OStmtIn i) (wit : WitIn)
    (reduction : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec) :
      OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí)
        ((FullTranscript pSpec √ó (StmtOut √ó ‚àÄ i, OStmtOut i) √ó WitOut) √ó
          (StmtOut √ó ‚àÄ i, OStmtOut i)) := do
  let proverResult ‚Üê reduction.prover.run ‚ü®stmt, oStmt‚ü© wit
  let stmtOut ‚Üê liftM (reduction.verifier.run stmt oStmt proverResult.1)
  return ‚ü®proverResult, stmtOut‚ü©

def firstOracleWitnessConsistencyProp (t : MultilinearPoly L ‚Ñì)
    (f‚ÇÄ : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate 0 ‚Üí L) : Prop :=
  let P‚ÇÄ: L[X]_(2 ^ ‚Ñì) := polynomialFromNovelCoeffsF‚ÇÇ ùîΩq Œ≤ ‚Ñì (by admit /- proof elided -/
  ) (fun œâ => t.val.eval œâ)
  
  2 * hammingDist (fun x => P‚ÇÄ.val.eval x.val) f‚ÇÄ < BBF_CodeDistance ‚Ñì ùì° ‚ü®0, by admit /- proof elided -/
  ‚ü©

def concrete_mul {k : ‚Ñï} (a b : ConcreteBTField k) : ConcreteBTField k :=
  if h_k_zero : k = 0 then
    if a = zero then zero
    else if b = zero then zero
    else if a = one then b
    else if b = one then a
    else zero 
  else
    have h_k_gt_0 : k > 0 := by admit /- proof elided -/

cast in Init.Prelude

def oracleVerifier : OracleVerifier oSpec (StmtIn R) (OStmtIn R deg) (StmtOut R) (OStmtOut R deg)
    (pSpec R deg) where
  verify := fun target chal => do
    let evals : Vector R m ‚Üê (Vector.finRange m).mapM
      (fun i => query (spec := [OStmtIn R deg]‚Çí) () (D i))
    guard (evals.sum = target)
    
    pure (sorry, chal default)
  embed := .inl
  hEq := fun i => by admit /- proof elided -/

def findFinIdxIfTrue (p : Œ± ‚Üí Bool) (l : List Œ±) (h : ‚àÉ x ‚àà l, p x) : Fin l.length :=
  ‚ü®List.findIdx' p l, by admit /- proof elided -/
  ‚ü©

def toOracleSpec {Œπ : Type u} (v : Œπ ‚Üí Type v) [O : ‚àÄ i, OracleInterface (v i)] :
    OracleSpec Œπ := fun i => ((O i).Query, (O i).Response)

Fin.cast in Init.Data.Fin.Basic

inductive VectorOp where | dotProd

@[inline, reducible]
def proj : OuterStmtIn √ó OuterWitIn ‚Üí InnerStmtIn √ó InnerWitIn :=
  fun ctxIn => ‚ü®lens.stmt.toFunA ctxIn.1, lens.wit.toFunA ctxIn‚ü©

PowerSeries.mk in Mathlib.RingTheory.PowerSeries.Basic

@[inline, specialize]
def OracleReduction.runWithLog [‚àÄ i, OracleInterface (pSpec.Message i)]
    (stmt : StmtIn) (oStmt : ‚àÄ i, OStmtIn i) (wit : WitIn)
    (reduction : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec) :
      OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí)
        ((FullTranscript pSpec √ó (StmtOut √ó ‚àÄ i, OStmtOut i) √ó WitOut) √ó
          (StmtOut √ó ‚àÄ i, OStmtOut i) √ó
            QueryLog (oSpec ++‚Çí [pSpec.Challenge]‚Çí) √ó QueryLog oSpec) := do
  let ‚ü®proverResult, proveQueryLog‚ü© ‚Üê
    (simulateQ loggingOracle (reduction.prover.run ‚ü®stmt, oStmt‚ü© wit)).run
  let ‚ü®stmtOut, verifyQueryLog‚ü© ‚Üê
    liftM (simulateQ loggingOracle (reduction.verifier.run stmt oStmt proverResult.1)).run
  return ‚ü®proverResult, stmtOut, proveQueryLog, verifyQueryLog‚ü©

instance [inst : ‚àÄ i, OracleInterface (pSpec‚ÇÅ.Message i)] :
    ‚àÄ i, OracleInterface ((pSpec‚ÇÅ.cast hn).Message i) :=
  fun i => inst (dcast‚ÇÇ hn.symm (by admit /- proof elided -/
  ) i)

@[reducible]
def rateSegment (state : CanonicalSpongeState U) : Vector U SpongeSize.R :=
  
  (Vector.take state SpongeSize.R).cast (by admit /- proof elided -/
  )

structure ParamConditions (P : Params Œπ F) where
  m : ‚Ñï 
  h_m : m = P.varCount 0
  h_sumkLt : ‚àë i : Fin (M + 1), P.foldingParam i ‚â§ m
  h_varCount_i : ‚àÄ i : Fin (M + 1),
    P.varCount i = m - ‚àë j : Fin i, P.foldingParam (Fin.castLT j (Nat.lt_trans j.isLt i.isLt))
  h_smooth : ‚àÄ i : Fin (M + 1), Smooth (P.œÜ i)
  h_repeatPLt : ‚àÄ i : Fin (M + 1), P.repeatParam i ‚â§ Fintype.card (Œπ i)

Array.rightpad in Init.Data.Array.Basic

Fin.val in Init.Prelude

def fullRound (params : Params) (state : Vector KoalaBear.Field params.width)
    (roundConstants : Vector KoalaBear.Field params.width) : Vector KoalaBear.Field params.width :=
  
  let stateWithConstants := state.zipWith (¬∑+¬∑) roundConstants
  
  let stateAfterSbox := stateWithConstants.map (fun x => x ^ sBoxDegree)
  
  externalLinearLayer params stateAfterSbox

def toMvPolynomialDeg1 (p : MlPoly R n) : R‚¶É‚â§ 1‚¶Ñ[X Fin n] :=
  ‚ü®toMvPolynomial p, by admit /- proof elided -/
  ‚ü©

instance : Field ScalarField := ZMod.instField SCALAR_FIELD_CARD

noncomputable def relayOracleProver (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
  OracleProver (oSpec := []‚Çí)
    
    (StmtIn := Statement (L := L) Context i.succ)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) i.succ)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) i.succ)
    (pSpec := pSpecRelay) where
  PrvState := relayPrvState ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i
  input := fun ‚ü®‚ü®stmtIn, oStmtIn‚ü©, witIn‚ü© => (stmtIn, oStmtIn, witIn)
  sendMessage | ‚ü®x, h‚ü© => by admit /- proof elided -/
| ‚ü®x, h‚ü© => by admit /- proof elided -/

@[reducible]
def fieldSize : Nat := 2 ^ 31 - 2 ^ 24 + 1

Polynomial.aeval in Mathlib.Algebra.Polynomial.AlgebraMap

def churchAnd (p q : ChurchBool Œ±) : ChurchBool Œ± :=
  fun x y => p (q x y) y

class IsComplete (relIn : Set (StmtIn √ó WitIn)) (relOut : Set (StmtOut √ó WitOut))
    (reduction : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec)
    where
  completenessError : ‚Ñù‚â•0
  is_complete : completeness init impl relIn relOut reduction completenessError

protected def cast (i : MessageIdx pSpec‚ÇÅ) : MessageIdx pSpec‚ÇÇ :=
  ‚ü®Fin.cast hn i.1, by admit /- proof elided -/
  ‚ü©

@[inline]
def ofOutputOnly
    (stmtLift : OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i) ‚Üí InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i) ‚Üí
                OuterStmtOut √ó (‚àÄ i, OuterOStmtOut i))
    (witLift : (OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i)) √ó OuterWitIn ‚Üí
               (InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i)) √ó InnerWitOut ‚Üí OuterWitOut) :
    OracleContext.Lens OuterStmtIn OuterStmtOut OuterStmtIn InnerStmtOut
                OuterOStmtIn OuterOStmtOut OuterOStmtIn InnerOStmtOut
                OuterWitIn OuterWitOut OuterWitIn InnerWitOut where
  stmt := OracleStatement.Lens.ofOutputOnly stmtLift
  wit := Witness.Lens.ofOutputOnly witLift

@[reducible]
def batchSpec (F : Type) (m : ‚Ñï) : ProtocolSpec 1 := ‚ü®!v[.V_to_P], !v[Fin m ‚Üí F]‚ü©

structure NonAdaptive {Œπ : Type} (oSpec : OracleSpec Œπ)
    (StmtIn : Type) {Œπ‚Çõ·µ¢ : Type} (OStmtIn : Œπ‚Çõ·µ¢ ‚Üí Type)
    (StmtOut : Type) {Œπ‚Çõ‚Çí : Type} (OStmtOut : Œπ‚Çõ‚Çí ‚Üí Type)
    {n : ‚Ñï} (pSpec : ProtocolSpec n)
    [O‚Çõ·µ¢ : ‚àÄ i, OracleInterface (OStmtIn i)]
    [O‚Çò : ‚àÄ i, OracleInterface (pSpec.Message i)]
    where

   
  queryOStmt : StmtIn ‚Üí (‚àÄ i, pSpec.Challenge i) ‚Üí List ((i : Œπ‚Çõ·µ¢) √ó (O‚Çõ·µ¢ i).Query)

   
  queryMsg : StmtIn ‚Üí (‚àÄ i, pSpec.Challenge i) ‚Üí List ((i : pSpec.MessageIdx) √ó (O‚Çò i).Query)

   
  verify : StmtIn ‚Üí (‚àÄ i, pSpec.Challenge i) ‚Üí
    List ((i : Œπ‚Çõ·µ¢) √ó ((O‚Çõ·µ¢ i).Query √ó (O‚Çõ·µ¢ i).Response)) ‚Üí
    List ((i : pSpec.MessageIdx) √ó ((O‚Çò i).Query √ó (O‚Çò i).Response)) ‚Üí OracleComp oSpec StmtOut

  embed : Œπ‚Çõ‚Çí ‚Ü™ Œπ‚Çõ·µ¢ ‚äï pSpec.MessageIdx

  hEq : ‚àÄ i, OStmtOut i = match embed i with
    | Sum.inl j => OStmtIn j
    | Sum.inr j => pSpec.Message j

instance {Œπ : Type u} (v : Œπ ‚Üí Type v) [O : ‚àÄ i, OracleInterface (v i)]
    [h : ‚àÄ i, Fintype (Response (v i))]
    [h' : ‚àÄ i, Inhabited (Response (v i))] :
    [v]‚Çí.FiniteRange where
  range_fintype' := h
  range_inhabited' := h'

@[reducible, simp] def OStmtAfterSendClaim : Unit ‚äï Unit ‚Üí Type := fun _ => R‚¶É‚â§ deg‚¶Ñ[X]

noncomputable def liftBivariate {H : F[X][Y]} : F[X][Y] ‚Üí+* ùïÉ H :=
  RingHom.comp (Ideal.Quotient.mk (Ideal.span {H_tilde H})) bivPolyHom

def toChallengesUpTo (transcript : Transcript k pSpec) : ChallengesUpTo k pSpec :=
  fun ‚ü®i, _‚ü© => transcript i

instance : ‚àÄ j, SelectableType ((pSpecFoldRelay (L:=L)).Challenge j) :=
  instSelectableTypeChallengeAppend

def totalNumPermQueries : Nat :=
  pSpec.totalNumPermQueriesMessage + pSpec.totalNumPermQueriesChallenge

def Reduction.liftContext
    (lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut)
    (R : Reduction oSpec InnerStmtIn InnerWitIn InnerStmtOut InnerWitOut pSpec) :
      Reduction oSpec OuterStmtIn OuterWitIn OuterStmtOut OuterWitOut pSpec where
  prover := R.prover.liftContext lens
  verifier := R.verifier.liftContext lens.stmt

def instDefault {Message : Type u} : OracleInterface Message where
  Query := Unit
  Response := Message
  answer := fun m _ => m

def SkeletonLeafIndex.depth {s : Skeleton} : SkeletonLeafIndex s ‚Üí Nat
  | SkeletonLeafIndex.ofLeaf => 0
  | SkeletonLeafIndex.ofLeft idxLeft => idxLeft.depth + 1
  | SkeletonLeafIndex.ofRight idxRight => idxRight.depth + 1

def queryCodeword (k : ‚Ñï) (s : Fin (k + 1) ‚Üí ‚Ñï+) {i : Fin (k + 1)}
      (w : evalDomain D x (‚àë j' ‚àà (List.take i.1 (List.finRange (k + 1))).toFinset, (s j').1)) :
    OracleComp [FinalOracleStatement D x s]‚Çí F :=
      OracleComp.lift <| by
        simpa using
          OracleSpec.query
            (spec := [FinalOracleStatement D x s]‚Çí)
            ‚ü®i.1, Nat.lt_succ_of_lt i.2‚ü©
            (by admit /- proof elided -/
            )

PMF in Mathlib.Probability.ProbabilityMassFunction.Basic

@[inline]
def ofOutputOnly
    (liftWit : OuterStmtIn √ó OuterWitIn ‚Üí InnerStmtOut √ó InnerWitOut ‚Üí OuterWitOut) :
    Witness.Lens OuterStmtIn InnerStmtOut OuterWitIn OuterWitOut OuterWitIn InnerWitOut :=
  ‚ü®Prod.snd, liftWit‚ü©

def Reduction.addSalt (R : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec)
    (saltComp : (i : pSpec.MessageIdx) ‚Üí R.prover.PrvState i.1.castSucc ‚Üí
      OracleComp oSpec (Salt i)) :
    Reduction oSpec StmtIn WitIn StmtOut WitOut (pSpec.addSalt Salt) where
  prover := R.prover.addSalt Salt saltComp
  verifier := R.verifier.addSalt Salt

Polynomial.div in Mathlib.Algebra.Polynomial.FieldDivision

Set.Ioo in Mathlib.Order.Interval.Set.Defs

def canonical (p : UniPoly R) := p.trim = p

instance : SMul ‚Ñï (UniPoly R) := ‚ü®nsmul‚ü©

Array.foldlM in Init.Data.Array.Basic

noncomputable def fiber_coeff
    (i : Fin r) (steps : ‚Ñï)
    (j : Fin (‚Ñì + ùì° - i)) (elementIdx : Fin (2 ^ steps))
    (y_coeffs : Fin (‚Ñì + ùì° - (i + steps)) ‚Üí‚ÇÄ ùîΩq) : ùîΩq :=
  if hj : j.val < steps then
    if Nat.getBit (k := j) (n := elementIdx) = 0 then 0 else 1
  else y_coeffs ‚ü®j.val - steps, by admit /- proof elided -/
    ‚ü©

MvPolynomial.eval‚ÇÇHom in Mathlib.Algebra.MvPolynomial.Eval

noncomputable def novelToMonomialCoeffs

  (‚Ñì : ‚Ñï) (h_‚Ñì : ‚Ñì ‚â§ r) (novel_coeffs : Fin (2 ^ ‚Ñì) ‚Üí L) : Fin (2^‚Ñì) ‚Üí L :=
  let A := changeOfBasisMatrix ùîΩq Œ≤ ‚Ñì h_‚Ñì
  Matrix.vecMul novel_coeffs A

And in Init.Prelude

IsCyclic in Mathlib.Algebra.Group.Defs

Vector.ofFn in Init.Data.Vector.Basic

@[reducible, inline, specialize]
def Transcript (k : Fin (n + 1)) (pSpec : ProtocolSpec n) : Type :=
  (pSpec‚ü¶:k.val‚üß).FullTranscript

BitVec.getLsb in Init.Data.BitVec.Basic

def JohnsonConditionWeak (B : Finset (Fin n ‚Üí F)) (e : ‚Ñï) : Prop :=
  let d := sInf { d | ‚àÉ u ‚àà B, ‚àÉ v ‚àà B, u ‚â† v ‚àß hammingDist u v = d }
  let q : ‚Ñö := Fintype.card F
  (e : ‚Ñö) / n < J q (d / n)

@[simp]
def innerRelIn_Test : Set (InnerStmtIn_Test √ó Unit) :=
  setOf (fun ‚ü®‚ü®f, t‚ü©, _‚ü© => ‚àë x ‚àà {0, 1}, f.eval x = t)

instance {n : ‚Ñï} : ‚àÄ j, OracleInterface ((pSpecFoldRelaySequence (L:=L) n).Message j) :=
  instOracleInterfaceMessageSeqCompose

def churchVecFold (xs : ChurchVec Œ±) (f : Œ± ‚Üí List Œ± ‚Üí List Œ±) (base : List Œ±) : List Œ± :=
  xs f base

noncomputable def fold_k
  {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F} {k m : ‚Ñï}
  [‚àÄ j : ‚Ñï, Neg (indexPowT S œÜ j)]
  (f : (indexPowT S œÜ 0) ‚Üí F) (Œ±s : Fin k ‚Üí F) (_hk : k ‚â§ m): indexPowT S œÜ k ‚Üí F :=
  fold_k_core f k Œ±s

SMulZeroClass in Mathlib.Algebra.GroupWithZero.Action.Defs

idOracle in VCVio.OracleComp.SimSemantics.SimulateQ

noncomputable def intermediateNovelBasisX (i : Fin (‚Ñì + 1)) (j : Fin (2 ^ (‚Ñì - i))) : L[X] :=
  (Finset.univ: Finset (Fin (‚Ñì - i)) ).prod (fun k =>
    (intermediateNormVpoly ùîΩq Œ≤ h_‚Ñì_add_R_rate i (k:=‚ü®k, by admit /- proof elided -/
    ‚ü©)) ^ (Nat.getBit k j))

QueryImpl in VCVio.OracleComp.SimSemantics.SimulateQ

def seqComposeChallengeIdxToSigma {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (k : (seqCompose pSpec).ChallengeIdx) : (i : Fin m) √ó (pSpec i).ChallengeIdx :=
  let ij := Fin.splitSum k.1
  ‚ü®ij.1, ‚ü®ij.2, by admit /- proof elided -/
    ‚ü©‚ü©

Fin.natAdd in Init.Data.Fin.Basic

def verifier : Verifier oSpec (StmtIn R √ó (‚àÄ i, OStmtIn R deg i))
                              (StmtOut R √ó (‚àÄ i, OStmtOut R deg i)) (pSpec R deg) where
  verify := fun ‚ü®target, oStmt‚ü© transcript => do
    letI polyLE := transcript 0
    guard (‚àë x ‚àà (univ.map D), polyLE.val.eval x = target)
    letI chal := transcript 1
    pure ‚ü®‚ü®(oStmt ()).val.eval chal, chal‚ü©, fun _ => oStmt ()‚ü©

def implGroupExpOracle : QueryImpl (GroupExpOracle Œπ p) (StateT (GroupValTable Œπ G) Option) where
  impl | query _ ‚ü®i, a, j‚ü© => fun table =>
    match table i with
    | some g => some ((), table.update j (some (g ^ a.val)))
    | none => none

def FullData.Equiv {Œ±} (s : Skeleton) :
    FullData Œ± s ‚âÉ InternalData Œ± s √ó LeafData Œ± s :=

instance {s} : Functor (fun Œ± => InternalData Œ± s) where
  map f x := x.map f

PFunctor.X in ToMathlib.PFunctor.Basic

@[inline, specialize]
def Prover.processRoundDSFS [‚àÄ i, VCVCompatible (pSpec.Challenge i)] (j : Fin n)
    (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec)
    (currentResult : OracleComp (oSpec ++‚Çí duplexSpongeChallengeOracle StmtIn U)
      (pSpec.MessagesUpTo j.castSucc √ó
        CanonicalDuplexSponge U √ó prover.PrvState j.castSucc)) :
      OracleComp (oSpec ++‚Çí duplexSpongeChallengeOracle StmtIn U)
        (pSpec.MessagesUpTo j.succ √ó
          CanonicalDuplexSponge U √ó prover.PrvState j.succ) := do
  let ‚ü®messages, sponge, state‚ü© ‚Üê currentResult
  match hDir : pSpec.dir j with
  | .V_to_P => do
    let f ‚Üê prover.receiveChallenge ‚ü®j, hDir‚ü© state
    let (challenge, newSponge) ‚Üê
      liftM (DuplexSponge.squeeze sponge (challengeSize ‚ü®j, hDir‚ü©))
    
    let deserializedChallenge : pSpec.Challenge ‚ü®j, hDir‚ü© := Deserialize.deserialize challenge
    return ‚ü®messages.extend hDir, newSponge, f deserializedChallenge‚ü©
  | .P_to_V => do
    let ‚ü®msg, newState‚ü© ‚Üê prover.sendMessage ‚ü®j, hDir‚ü© state
    let serializedMessage : Vector U (messageSize ‚ü®j, hDir‚ü©) := Serialize.serialize msg
    let newSponge ‚Üê liftM (DuplexSponge.absorb sponge serializedMessage.toList)
    return ‚ü®messages.concat hDir msg, newSponge, newState‚ü©

Nat.testBit in Init.Data.Nat.Bitwise.Basic

Subgroup in Mathlib.Algebra.Group.Subgroup.Defs

def partialEval {k : ‚Ñï} (f : MvPolynomial (Fin m) F) (Œ± : Fin k ‚Üí F) (h : k ‚â§ m) :
    MvPolynomial (Fin (m - k)) F :=
  let œÜ : Fin m ‚Üí MvPolynomial (Fin (m - k)) F := fun i =>
    if h' : i.val < k then
      C (Œ± ‚ü®i.val, h'‚ü©)
    else
      let j := i.val - k
      let j' : Fin (m - k) := ‚ü®j, sorry‚ü©
      X j'
  eval‚ÇÇ C œÜ f

def Verifier.StateFunction.id {lang : Set Statement} :
    (Verifier.id : Verifier oSpec Statement _ _).StateFunction init impl lang lang where
  toFun | ‚ü®0, _‚ü© => fun stmtIn _ => stmtIn ‚àà lang
  toFun_empty := fun _ => by admit /- proof elided -/

instance : Slice (ProtocolSpec n) ‚Ñï ‚Ñï
    (fun _ start stop => start ‚â§ stop ‚àß stop ‚â§ n)
    (fun _ start stop _ => ProtocolSpec (stop - start))
    where
  slice := fun v start stop h => extract start stop h.1 h.2 v

String in Init.Prelude

@[reducible]
def Witness := Fin sz.n_w ‚Üí R

class Prover.IsPure (P : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) where
    is_pure : ‚àÉ sendMessage : ‚àÄ _, _ ‚Üí _, ‚àÄ i st,
      P.sendMessage i st = pure (sendMessage i st)

@[reducible]
def Statement := Fin sz.n_x ‚Üí R

@[reducible, simp] def WitIn := Unit

def internalLinearLayer (state : Vector KoalaBear.Field params.width) :
    Vector KoalaBear.Field params.width :=
  
  
  let sumAll := state.foldl (fun acc x => acc + x) 0

  
  
  state.zipWith (fun s d => sumAll + d * s) params.internalDiagVectors

instance {Œ± : Type*} {n : ‚Ñï} [VCVCompatible Œ±] : VCVCompatible (Vector Œ± n) where

@[reducible, simp] def OStmtOut := fun _ : Fin 2 => OStatement

inductive PrattPartList : (p : ‚Ñï) ‚Üí (a : ZMod p) ‚Üí ‚Ñï ‚Üí Prop
  | prime : {p : ‚Ñï} ‚Üí {a : ZMod p} ‚Üí (n k nk : ‚Ñï) ‚Üí n.Prime ‚Üí
      a ^ ((p - 1) / n) ‚â† 1 ‚Üí n ^ k = nk ‚Üí PrattPartList p a nk
  | split : {p : ‚Ñï} ‚Üí {a : ZMod p} ‚Üí {n : ‚Ñï} ‚Üí (list : List ‚Ñï) ‚Üí
      (‚àÄ r ‚àà list, PrattPartList p a r) ‚Üí list.prod = n ‚Üí PrattPartList p a n

def oracleReduction.checkClaim : OracleReduction oSpec
    (StmtAfterSendClaim R) (OStmtAfterSendClaim R deg) Unit
    (StmtAfterCheckClaim R) (OStmtAfterCheckClaim R deg) Unit !p[] :=
  sorry

@[reducible, inline, specialize, simp]
def Message' (pSpec : ProtocolSpec n) (i : Fin n) (_ : pSpec.dir i = .P_to_V) := pSpec.¬´Type¬ª i

protected def cast (pSpec : ProtocolSpec n‚ÇÅ) : ProtocolSpec n‚ÇÇ :=
  ‚ü®pSpec.dir ‚àò (Fin.cast hn.symm), pSpec.¬´Type¬ª ‚àò (Fin.cast hn.symm)‚ü©

def FullData.EquivIndexFun {Œ± : Type} (s : Skeleton) :
    FullData Œ± s ‚âÉ (SkeletonNodeIndex s ‚Üí Œ±) where
  toFun := fun tree idx => tree.get idx
  invFun := fun f => FullData.ofFun s f
  left_inv := by admit /- proof elided -/

def SkeletonNodeIndex.leftChild {s : Skeleton} (idx : SkeletonNodeIndex s) :
    Option (SkeletonNodeIndex s) :=
  match idx with
  | SkeletonNodeIndex.ofLeaf => none
  | @SkeletonNodeIndex.ofInternal left right =>
    some (SkeletonNodeIndex.ofLeft (getRootIndex left))
  | SkeletonNodeIndex.ofLeft idxLeft =>
    idxLeft.leftChild.map (SkeletonNodeIndex.ofLeft)
  | SkeletonNodeIndex.ofRight idxRight =>
    idxRight.leftChild.map (SkeletonNodeIndex.ofRight)

def fappend {A : Sort u} {F : A ‚Üí Sort v} {m n : ‚Ñï} {Œ± : Fin m ‚Üí A} {Œ≤ : Fin n ‚Üí A}
    (u : (i : Fin m) ‚Üí F (Œ± i)) (v : (i : Fin n) ‚Üí F (Œ≤ i)) :
    (i : Fin (m + n)) ‚Üí F (Fin.vappend Œ± Œ≤ i) :=
  match n with
  | 0 => u
  | k + 1 => fconcat (fappend u (fun i => v (Fin.castSucc i))) (v (Fin.last k))

Equiv.toEmbedding in Mathlib.Logic.Embedding.Basic

Units.mk0 in Mathlib.Algebra.GroupWithZero.Units.Basic

@[reducible]
noncomputable def fullOracleProof :
  OracleProof []‚Çí
    (Statement := Statement (L := L) (‚Ñì:=‚Ñì) (SumcheckBaseContext L ‚Ñì) 0)
    (OStatement := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë 0)
    (Witness := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) 0)
    (pSpec:=fullPSpec ùîΩq Œ≤ Œ≥_repetitions (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)) :=
  fullOracleReduction ùîΩq Œ≤ Œ≥_repetitions (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë)

@[reducible]
def GroupEqOracle : OracleSpec Unit := fun _ => (Œπ √ó Œπ, Bool)

instance {Œ± : Type*} {s : Finset Œ±} [inst : Nonempty s] : Nonempty (s.toSet) :=

Fin.foldl in Init.Data.Fin.Fold

@[reducible, simp] def OStmtAfterCheckClaim : Unit ‚äï Unit ‚Üí Type := fun _ => R‚¶É‚â§ deg‚¶Ñ[X]

Set.Ioc in Mathlib.Order.Interval.Set.Defs

instance {bIdx : Fin (‚Ñì / œë - 1)} : ‚àÄ j, OracleInterface ((pSpecFullNonLastBlock ùîΩq Œ≤
  (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) bIdx).Message j) :=
  instOracleInterfaceMessageAppend

instance : Unique (ChallengesUpTo 0 pSpec) where
  default := fun ‚ü®i, _‚ü© => Fin.elim0 i
  uniq := fun T => by admit /- proof elided -/

def oracleVerifier (i : Fin n) : OracleVerifier oSpec (StatementRound R n i.castSucc)
    (OracleStatement R n deg) (StatementRound R n i.succ) (OracleStatement R n deg) (pSpec R deg) :=
  (Simple.oracleVerifier R deg D oSpec).liftContext (oStmtLens R n deg D i)

def rowRank : ‚Ñï :=
  Module.finrank F (rowSpan U)

def concreteCanonicalEmbedding (k : ‚Ñï)
    (prevBTFieldProps : ConcreteBTFieldProps (k := (k)))
    (curBTFieldProps : ConcreteBTFieldProps (k := (k + 1))) :
  letI := mkFieldInstance prevBTFieldProps
  letI := mkFieldInstance curBTFieldProps
  ConcreteBTField k ‚Üí+* ConcreteBTField (k + 1) :=

instance instDCast‚ÇÇForall :
    DCast‚ÇÇ Œ± (fun a => ‚àÄ b : Œ≤ a, Œ≥ a b) (fun a f => ‚àÄ b : Œ≤ a, Œ¥ a b (f b)) where
  dcast‚ÇÇ ha hb c := fun b => dcast‚ÇÉ ha (by admit /- proof elided -/
  )
    (by admit /- proof elided -/
    ) (c (dcast ha.symm b))
  dcast‚ÇÇ_id := by admit /- proof elided -/

Nat.reduceAdd in Lean.Meta.Tactic.Simp.BuiltinSimprocs.Nat

@[inline] def add (a b : AssocNat) : AssocNat :=
  ‚ü®a ‚àò b, by admit /- proof elided -/
  ‚ü©

@[reducible, simp]
def pSpec : ProtocolSpec 1 := ‚ü®!v[.P_to_V], !v[Witness]‚ü©

def generateSrs (n : ‚Ñï) (a : ZMod p) : Vector G‚ÇÅ (n + 1) √ó Vector G‚ÇÇ 2 :=
  (towerOfExponents g‚ÇÅ a n, towerOfExponents g‚ÇÇ a 1)

def Cache (n : ‚Ñï) := (layer : Fin (n + 1)) ‚Üí List.Vector Œ± (2 ^ layer.val)

Equiv in Mathlib.Logic.Equiv.Defs

def codeOfLinearCode (Œ∫ : Type*) [Fintype Œ∫] (LC : LinearCode Œπ F) : InterleavedCode Œ∫ Œπ F :=
  { MF := matrixSubmoduleOfLinearCode Œ∫ LC, LC := LC }

instance {langIn : Set StmtIn} {langOut : Set StmtOut}
    {verifier : Verifier oSpec StmtIn StmtOut pSpec} :
    CoeFun (verifier.StateFunction init impl langIn langOut)
    (fun _ => (m : Fin (n + 1)) ‚Üí StmtIn ‚Üí Transcript m pSpec ‚Üí Prop) := ‚ü®fun f => f.toFun‚ü©

def implGroupEqOracle [BEq G] :
    QueryImpl (GroupEqOracle Œπ) (StateT (GroupValTable Œπ G) Option) where
  impl | query _ ‚ü®i, j‚ü© => fun table =>
    match table i, table j with
    | some g‚ÇÅ, some g‚ÇÇ => some (g‚ÇÅ == g‚ÇÇ, table)
    | _, _ => none

LawfulFunctor in Init.Control.Lawful.Basic

@[reducible]
def index (op : MemoryWrite Œπ Œ±) := op.1

@[reducible]
def oSpec (Œ± Œ≤ Œ≥ : Type) : OracleSpec (Unit ‚äï Unit) := randSpec Œ≤ ++‚Çí ROspec Œ± Œ≤ Œ≥

List.replicate in Init.Data.List.Basic

@[reducible, simp]
def rbrKnowledgeSoundness (relation : Set (Statement √ó Bool))
    (verifier : Verifier oSpec Statement Bool pSpec)
    (rbrKnowledgeError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) : Prop :=
  verifier.rbrKnowledgeSoundness init impl relation acceptRejectRel rbrKnowledgeError

def InternalData.ofFun {Œ± : Type} (s : Skeleton)
    (f : SkeletonInternalIndex s ‚Üí Œ±) : InternalData Œ± s :=
  match s with
  | .leaf => InternalData.leaf
  | .internal l r =>
      InternalData.internal
        (f SkeletonInternalIndex.ofInternal)
        (InternalData.ofFun l (fun idx => f (SkeletonInternalIndex.ofLeft idx)))
        (InternalData.ofFun r (fun idx => f (SkeletonInternalIndex.ofRight idx)))

Nat.and_distrib_right in Init.Data.Nat.Bitwise.Lemmas

def D_YZ (Q : F[Z][X][Y]) : ‚Ñï :=
  Option.getD (dflt := 0) <| Finset.max
    (Finset.image
            (
              fun j =>
                Option.getD (
                  Finset.max (
                    Finset.image
                      (fun k => j + (Bivariate.coeff Q j k).natDegree)
                      (Q.coeff j).support
                  )
                ) 0
            )
            Q.support
    )

@[simp]
def BTFieldCard (k : ‚Ñï) : Fintype.card (BTField k) = 2^(2^k)
  := (BinaryTowerAux k).2.fieldFintypeCard

structure PrimeWithMultiplicity : Type where
  prime : ‚Ñï
  multiplicity : ‚Ñï
deriving Repr

@[inline, reducible]
def lift : OuterStmtIn √ó OuterWitOut ‚Üí InnerWitIn ‚Üí OuterWitIn :=
  lens.toFunB

Function.update in Mathlib.Logic.Function.Basic

def matrixSubmoduleOfLinearCode (Œ∫ : Type*) [Fintype Œ∫]
                                (LC : LinearCode Œπ F) : MatrixSubmodule Œ∫ Œπ F :=
  Submodule.span F { V | ‚àÄ i, V i ‚àà LC }

def deterministicMillerRabin (n : ‚Ñï) : Bool := Id.run do
  if n ‚â§ 2 ‚à® n % 2 = 0 then
    return n = 2

  let ‚ü®s, d‚ü© := factorOutTwos (n - 1)
  for a in millerRabinBases do
    if a % n == 0 then
      continue

    let mut x := powMod a d n
    if x = 1 ‚à® x = n - 1 then
      continue

    for _ in [0:s] do
      x := (x * x) % n
      if x == n - 1 ‚à® x ‚â§ 1 then
        break
    if x ‚â† n - 1 then
      return false

  return true

def vflatten {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (v : (i : Fin m) ‚Üí Fin (n i) ‚Üí Œ±) :
    Fin (vsum n) ‚Üí Œ± :=
  dflatten v

def div [Field R] (p q : UniPoly R) : UniPoly R :=
  (C (q.leadingCoeff)‚Åª¬π ‚Ä¢ p).divByMonic (C (q.leadingCoeff)‚Åª¬π * q)

@[reducible]
def scalarFieldSize : Nat :=
  8444461749428370424248824938781546531375899335154063827935233455917409239041

def proximityCondition (f : par‚Ñì ‚Üí Œπ ‚Üí F) (Œ¥ : ‚Ñù‚â•0) (r : par‚Ñì ‚Üí F)
    (C : LinearCode Œπ F) : Prop :=
  ‚àÉ S : Finset Œπ,
    (S.card : ‚Ñù‚â•0) ‚â• (1-Œ¥) * Fintype.card Œπ ‚àß
    ‚àÉ u ‚àà C, ‚àÄ s ‚àà S, u s = ‚àë j : par‚Ñì, r j * f j s ‚àß
    ‚àÉ i : par‚Ñì, ‚àÄ u' ‚àà C, ‚àÉ s ‚àà S, u' s ‚â† f i s

System.FilePath.fileName in Init.System.FilePath

abbrev SEP_CHAR : Char := Char.ofNat 0

@[reducible, inline, specialize]
instance challengeOracleInterface {pSpec : ProtocolSpec n} :
    ‚àÄ i, OracleInterface (pSpec.Challenge i) := fun i =>
  { Query := Unit
    Response := pSpec.Challenge i
    answer := fun c _ => c }

def ranges {n : ‚Ñï} (a : Fin n ‚Üí ‚Ñï) : (i : Fin n) ‚Üí Fin (a i) ‚Üí ‚Ñï :=
  match n with
  | 0 => fun i => elim0 i
  | n + 1 => fun i => by admit /- proof elided -/

noncomputable def fromColGenMat [CommRing F] (G : Matrix Œπ Œ∫ F) : LinearCode Œπ F :=
  LinearMap.range G.mulVecLin

instance (s : Finset œÉ) : Fintype { x : œÉ | x ‚àà s } :=

def computableBasisExplicit (k : ‚Ñï) (i : Fin (2 ^ k)) : ConcreteBTField k :=
  (Finset.univ : Finset (Fin k)).prod fun j =>
    if Nat.getBit (n := i.val) (k := j.val) == 1 then
      concreteTowerAlgebraMap (j.val + 1) k (by admit /- proof elided -/
      ) (Z (j.val + 1))
    else
      1

Int in Init.Data.Int.Basic

noncomputable def oddPart (f : Polynomial F) : Polynomial F :=
    C (2‚Åª¬π : F) * (f - f.comp (-X)) /‚Çò X

MvPolynomial.eval in Mathlib.Algebra.MvPolynomial.Eval

List.ranges in Mathlib.Data.List.Range

def monomialXY (n m : ‚Ñï) : F ‚Üí‚Çó[F] F[X][Y] where
  toFun t := ‚ü®Finsupp.single m ‚ü®(Finsupp.single n t)‚ü©‚ü©
  map_add' x y := by admit /- proof elided -/

def fiberwiseClose (i : Fin ‚Ñì) (steps : ‚Ñï) [NeZero steps] (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
    (f : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      ‚ü®i, by admit /- proof elided -/
      ‚ü©) : Prop :=
  2 * fiberwiseDistance ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := i) steps
    (h_i_add_steps := h_i_add_steps) (f := f) < (BBF_CodeDistance ‚Ñì ùì° ‚ü®i + steps, by admit /- proof elided -/
    ‚ü© : ‚Ñï‚àû)

def foldingBadEvent (i : Fin ‚Ñì) (steps : ‚Ñï) [NeZero steps] (h_i_add_steps : i + steps ‚â§ ‚Ñì)
  (f_i : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i, by admit /- proof elided -/
  ‚ü©)
  (challenges : Fin steps ‚Üí L) : Prop :=
  let d_i_plus_steps := BBF_CodeDistance ‚Ñì ùì° ‚ü®i + steps, by admit /- proof elided -/
  ‚ü©
  if h_is_close : 2 * fiberwiseDistance ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := i)
      steps h_i_add_steps f_i < (d_i_plus_steps : ‚Ñï‚àû) then
    
    
    
    let h_dist_curr_lt := fiberwise_dist_lt_imp_dist_lt_unique_decoding_radius ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := i) (steps := steps) h_i_add_steps f_i h_is_close

    let f_bar_i := uniqueClosestCodeword ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (i := ‚ü®i, by admit /- proof elided -/
      ‚ü©) (h_i := by admit /- proof elided -/
      ) f_i
      h_dist_curr_lt
    let folded_f_i := iterated_fold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (steps := ‚ü®steps, by admit /- proof elided -/
      ‚ü©) (i := ‚ü®i, by admit /- proof elided -/
      ‚ü©)
      (h_i_add_steps := by admit /- proof elided -/
      ) f_i challenges
    let folded_f_bar_i := iterated_fold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (steps := ‚ü®steps, by admit /- proof elided -/
      ‚ü©) (i := ‚ü®i, by admit /- proof elided -/
      ‚ü©)
      (h_i_add_steps := by admit /- proof elided -/
      ) f_bar_i challenges

    let fiberwise_disagreements := fiberwiseDisagreementSet ùîΩq Œ≤ i steps h_i_add_steps
      f_i f_bar_i
    let folded_disagreements := disagreementSet ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i steps
      h_i_add_steps folded_f_i folded_f_bar_i
    
    ¬¨ (fiberwise_disagreements ‚äÜ folded_disagreements)
  else
    
    
    
    let folded_f_i := iterated_fold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (steps := ‚ü®steps, by admit /- proof elided -/
      ‚ü©) (i := ‚ü®i, by admit /- proof elided -/
      ‚ü©)
      (h_i_add_steps := by admit /- proof elided -/
      ) f_i challenges
    let dist_to_code := distFromCode folded_f_i
      (BBF_Code ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i + steps, by admit /- proof elided -/
      ‚ü©)
    2 * dist_to_code < (d_i_plus_steps : ‚Ñï‚àû)

class Deserialize (Œ± : Type u) (Œ≤ : Type v) where
  deserialize : Œ≤ ‚Üí Œ±

instance instAlgebraTowerConcreteBTF : AlgebraTower (ConcreteBTField) where
  algebraMap := concreteTowerAlgebraMap
  commutes' := by admit /- proof elided -/

def QuotientUniPoly (R : Type*) [Ring R] [BEq R] := Quotient (@instSetoidUniPoly R _)

@[reducible]
def pBits : Nat := 31

private abbrev K (B : Finset (Fin n ‚Üí F)) (i : Fin n) (Œ± : F) : ‚Ñï :=
  (Fi B i Œ±).card

@[reducible]
def VectorIOP
    (Statement : Type) {Œπ‚Çõ : Type} (OStatement : Œπ‚Çõ ‚Üí Type) (Witness : Type)
    (vPSpec : ProtocolSpec.VectorSpec n) (A : Type)
    [‚àÄ i, OracleInterface (OStatement i)] :=
  OracleProof []‚Çí Statement OStatement Witness (vPSpec.toProtocolSpec A)

@[inline, specialize]
def smul (r : R) (p : UniPoly R) : UniPoly R :=
  .mk (Array.map (fun a => r * a) p)

Fin.succAbove in Mathlib.Data.Fin.SuccPred

def twoLevelSkel (k0 k1 : ‚Ñï) :
    ArityTree.Skeleton 2 (ar2 k0 k1) :=
  ArityTree.Skeleton.node (fun _ =>
    ArityTree.Skeleton.node (fun _ => ArityTree.Skeleton.leaf))

def rootMultiplicity.{u} {F : Type u} [CommSemiring F] [DecidableEq F]
  (f : F[X][Y]) (x y : F) : Option ‚Ñï :=
  let X := (Polynomial.X : Polynomial F)
  rootMultiplicity‚ÇÄ (F := F) ((f.comp (Y + (C (C y)))).map (Polynomial.compRingHom (X + C x)))

Polynomial.degree in Mathlib.Algebra.Polynomial.Degree.Definitions

def relHammingDist (u v : Œπ ‚Üí F) : ‚Ñö‚â•0 :=
  hammingDist u v / Fintype.card Œπ

def evalX (a : F) (f : F[X][Y]) : Polynomial F :=
  ‚ü®Finsupp.mapRange (Polynomial.eval a) eval_zero f.toFinsupp‚ü©

noncomputable def fixFirstVariablesOfMQP (v : Fin (‚Ñì + 1))
  (H : MvPolynomial (Fin ‚Ñì) L) (challenges : Fin v ‚Üí L) : MvPolynomial (Fin (‚Ñì - v)) L :=
  have h_l_eq : ‚Ñì = (‚Ñì - v) + v := by rw [Nat.add_comm]; exact (Nat.add_sub_of_le v.is_le).symm
  -- Step 1 : Rename L[X Fin ‚Ñì] to L[X (Fin (‚Ñì - v) ‚äï Fin v)]
  let finEquiv := finSumFinEquiv (m := ‚Ñì - v) (n := v).symm
  let H_sum : L[X (Fin (‚Ñì - v) ‚äï Fin v)] :=

abbrev take (m : ‚Ñï) (h : m ‚â§ n)
    (transcript : FullTranscript pSpec) : FullTranscript (pSpec.take m h) :=
  Fin.take m h transcript

MvPolynomial.degreeOf in Mathlib.Algebra.MvPolynomial.Degrees

Real.sqrt in Mathlib.Data.Real.Sqrt

@[inline, reducible]
def proj : OuterStmtIn √ó OuterWitOut ‚Üí InnerWitOut :=
  lens.toFunA

instance [VCVCompatible A] : ‚àÄ i, VCVCompatible ((vPSpec.toProtocolSpec A).Challenge i) :=
  fun _ => by admit /- proof elided -/

structure SpecialElementRelation {F_prev : Type*} [Field F_prev] (t1 : F_prev)
  {F_cur : Type*} [Field F_cur] (u : F_cur) [Algebra F_prev F_cur] : Prop where
    sum_inv_eq : u + u‚Åª¬π = algebraMap F_prev F_cur t1
    h_u_square : u^2 = u * (algebraMap F_prev F_cur t1) + 1

IsField.toField in Mathlib.Algebra.Field.IsField

instance : curve.IsShortNF :=

def intCast_negSucc {k : ‚Ñï} (n : ‚Ñï) : intCast (k:=k) (Int.negSucc n)
  = - (‚Üë(n + 1) : ConcreteBTField k) :=

def powFiber (S : Finset Œπ) (œÜ : Œπ ‚Ü™ F) (k : ‚Ñï) (y : indexPow S œÜ k) : Finset Œπ :=
  S.filter (fun x => (œÜ x) ^ k = y)

@[reducible]
def MlPolyEval (R : Type*) (n : ‚Ñï) := Vector R (2 ^ n) 

def subNat [Zero T] [ToNat T] (a : Cayley T) : Nat ‚Üí Cayley T
  | 0        => a
  | .succ k  => pred (subNat a k)

def fappend‚ÇÇ {A : Sort u} {B : Sort v} {F : A ‚Üí B ‚Üí Sort w} {m n : ‚Ñï}
    {Œ±‚ÇÅ : Fin m ‚Üí A} {Œ≤‚ÇÅ : Fin n ‚Üí A} {Œ±‚ÇÇ : Fin m ‚Üí B} {Œ≤‚ÇÇ : Fin n ‚Üí B}
    (u : (i : Fin m) ‚Üí F (Œ±‚ÇÅ i) (Œ±‚ÇÇ i)) (v : (i : Fin n) ‚Üí F (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) :
    (i : Fin (m + n)) ‚Üí F (Fin.vappend Œ±‚ÇÅ Œ≤‚ÇÅ i) (Fin.vappend Œ±‚ÇÇ Œ≤‚ÇÇ i) :=
  match n with
  | 0 => u
  | k + 1 => fconcat‚ÇÇ (fappend‚ÇÇ u (fun i => v (Fin.castSucc i))) (v (Fin.last k))

class PolynomialLike.LawfulCoeff (R : Type u) [CommSemiring R] (P : Type v) [CommSemiring P]
    [PolynomialLike R P] (coeff : P ‚Üí ‚Ñï ‚Üí R) where
  coeff_finite (p : P) : Set.Finite {n | coeff p n ‚â† 0}

@[reducible]
def pSpec : ProtocolSpec 1 := ‚ü®!v[.P_to_V], !v[OStatement default]‚ü©

def OracleSpec.proverOracle (StmtIn : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n) :
    OracleSpec pSpec.MessageIdx :=
  fun i => (StmtIn √ó pSpec.Transcript i.val.castSucc, pSpec.Message i)

def findSumIdx' (l : List ‚Ñï) (j : Fin l.sum) : Fin l.length := ‚ü®findSumIdx l j, sorry‚ü©

@[simp]
abbrev Witness.AfterLinearCombination : Type := Unit

UInt16.ofFin in Init.Data.UInt.Basic

@[inline]
def nsmul [SMul ‚Ñï R] (m : ‚Ñï) (p : MlPoly R n) : MlPoly R n := p.map (fun a => m ‚Ä¢ a)

def bool (j : Fin numWires) : Gate ùì° numWires :=
  { qL := -1, qR := 0, qO := 0, qM := 1, qC := 0, a := j, b := j, c := j }

protected def cast (R : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec‚ÇÅ) :
    OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec‚ÇÇ where
  prover := R.prover.cast hn hSpec
  verifier := R.verifier.cast hn hSpec hO‚Çò

Finset.max in Mathlib.Data.Finset.Max

LT in Init.Prelude

@[reducible, inline]
instance instMvPolynomial : OracleInterface (R[X œÉ]) where
  Query := œÉ ‚Üí R
  Response := R
  answer := fun poly point => eval point poly

structure CodeParams (P : Params Œπ F) (Dist : Distances M) where
  C : ‚àÄ i : Fin (M + 1), Set ((Œπ i) ‚Üí F)
  h_code : ‚àÄ i : Fin (M + 1), C i = code (P.œÜ i) (degree Œπ P i)
  h_listDecode : ‚àÄ i : Fin (M + 1), i ‚â† 0 ‚Üí listDecodable (C i) (Dist.Œ¥ i) (Dist.l i)

noncomputable def towerRingHomForwardMap (k : ‚Ñï) : ConcreteBTField k ‚Üí BTField k :=

def HList.toDVec (l : HList) : DVec (m := Fin l.length) (fun i => l[i].1) := fun i => l[i].2

OrderDual.toDual in Mathlib.Order.Synonym

Equiv.sumComm in Mathlib.Logic.Equiv.Sum

def verifyProof {Œ±} [DecidableEq Œ±] {s}
    (idx : BinaryTree.SkeletonLeafIndex s) (leafValue : Œ±) (rootValue : Œ±)
    (proof : List Œ±) : OracleComp (spec Œ±) Unit := do
  let putative_root ‚Üê getPutativeRoot idx leafValue proof
  guard (putative_root = rootValue)

Sum in Init.Core

def implGroupOpOracle : QueryImpl (GroupOpOracle Œπ) (StateT (GroupValTable Œπ G) Option) where
  impl | query _ ‚ü®i, j, k‚ü© => fun table =>
    match table i, table j with
    | some g‚ÇÅ, some g‚ÇÇ => some ((), table.update k (some (g‚ÇÅ * g‚ÇÇ)))
    | _, _ => none

def deriveTranscriptDSFSAux {Œπ : Type} {oSpec : OracleSpec Œπ} {StmtIn : Type}
    (sponge : CanonicalDuplexSponge U)
    (messages : pSpec.Messages) (i : Fin (n + 1)) :
      OracleComp (oSpec ++‚Çí duplexSpongeChallengeOracle StmtIn U)
        (CanonicalDuplexSponge U √ó pSpec.Transcript i) :=
  Fin.induction
    (pure (sponge, fun i => i.elim0))
    (fun i ih => do
      let ‚ü®curSponge, prevTranscript‚ü© ‚Üê ih
      match hDir : pSpec.dir i with
      | .V_to_P =>
        let ‚ü®challenge, newSponge‚ü© ‚Üê liftM (curSponge.squeeze (challengeSize ‚ü®i, hDir‚ü©))
        let deserializedChallenge : pSpec.Challenge ‚ü®i, hDir‚ü© :=
          Deserialize.deserialize challenge
        return (newSponge, prevTranscript.concat deserializedChallenge)
      | .P_to_V =>
        let serializedMessage : Vector U (messageSize ‚ü®i, hDir‚ü©) :=
          Serialize.serialize (messages ‚ü®i, hDir‚ü©)
        let newSponge ‚Üê liftM (DuplexSponge.absorb curSponge serializedMessage.toList)
        return (newSponge, prevTranscript.concat (messages ‚ü®i, hDir‚ü©)))
    i

def hiding' (scheme : Scheme oSpec Data Randomness Commitment pSpec) : Prop := sorry

def lagrangeBasis (w : Vector R n) : Vector R (2 ^ n) :=
  Vector.ofFn (fun i => ‚àè j : Fin n, if (BitVec.ofFin i).getLsb j then w[j] else 1 - w[j])

noncomputable def sDomain.lift (i j : Fin r) (h_j : j < ‚Ñì + R_rate) (h_le : i ‚â§ j)
    (y : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate j) :
    sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i :=

instance : ‚àÄ j, OracleInterface (OracleStatement D x m j) :=
  fun _ => inferInstance

@[reducible]
noncomputable def reductionFold :
  OracleReduction []‚Çí
    (Statement F (0 : Fin (k + 1))) (OracleStatement D x s (0 : Fin (k + 1)))
      (Witness F s d (0 : Fin (k + 2)))
    (FinalStatement F k) (FinalOracleStatement D x s)
      (Witness F s d (Fin.last (k + 1)))
    (pSpecFold D x k s ++‚Çö FinalFoldPhase.pSpec F)
 := OracleReduction.append
      (OracleReduction.seqCompose _ _ (fun (i : Fin (k + 1)) => Witness F s d i.castSucc)
        (FoldPhase.foldOracleReduction D x s d))
      (FinalFoldPhase.finalFoldOracleReduction D x (k := k) s d)

@[ext]
structure Cayley (T : Type u) [HasSucc T] where
   
  toFun : T ‚Üí T
   
  toFun_succ : ‚àÄ (t : T), toFun (succ' t) = succ' (toFun t)

class Serialize (Œ± : Type u) (Œ≤ : Type v) where
  serialize : Œ± ‚Üí Œ≤

@[reducible, simp]
def knowledgeSoundness
    (relation : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (verifier : OracleVerifier oSpec Statement OStatement Bool (fun _ : Empty => Unit) pSpec)
    (knowledgeError : ‚Ñù‚â•0) : Prop :=
  verifier.toVerifier.knowledgeSoundness init impl relation acceptRejectOracleRel knowledgeError

class VerifierLast (pSpec : ProtocolSpec n) [NeZero n] where
  verifier_last' : pSpec.dir ‚ü®n - 1, by admit /- proof elided -/
  ‚ü© = .V_to_P

Prod.mk in Init.Prelude

@[simp]
def ùïè (k : ‚Ñï) : ConcreteBTField (k + 1) := Z (k + 1)

def modSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (k : Fin (‚àë j, n j)) : Fin (n (divSum k)) :=
  ‚ü®k - ‚àë j, n (Fin.castLE (divSum k).isLt.le j), by admit /- proof elided -/
    ‚ü©

instance [Zero T] [ToNat T] : DecidableEq (Cayley T) := fun a b =>
  if h : (‚Üëa : Nat) = (‚Üëb : Nat) then
    isTrue (by admit /- proof elided -/
      )
  else
    isFalse (fun heq => h (by admit /- proof elided -/
    ))

structure RoundByRound
    (oSpec : OracleSpec Œπ) (StmtIn WitIn WitOut : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n)
    (WitMid : Fin (n + 1) ‚Üí Type) where
   
  eqIn : WitMid 0 = WitIn
   
  extractMid : (m : Fin n) ‚Üí StmtIn ‚Üí Transcript m.succ pSpec ‚Üí WitMid m.succ ‚Üí WitMid m.castSucc
   
  extractOut : StmtIn ‚Üí FullTranscript pSpec ‚Üí WitOut ‚Üí WitMid (.last n)

noncomputable def basisVectors (‚Ñì : Nat) (h_‚Ñì : ‚Ñì ‚â§ r) :
  Fin (2 ^ ‚Ñì) ‚Üí L‚¶É<2^‚Ñì‚¶Ñ[X] :=
  fun j => ‚ü®X‚±º ùîΩq Œ≤ ‚Ñì h_‚Ñì j, by admit /- proof elided -/
  ‚ü©

def StateFunction.append
    (V‚ÇÅ : Verifier oSpec Stmt‚ÇÅ Stmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : Verifier oSpec Stmt‚ÇÇ Stmt‚ÇÉ pSpec‚ÇÇ)
    (S‚ÇÅ : V‚ÇÅ.StateFunction init impl lang‚ÇÅ lang‚ÇÇ)
    (S‚ÇÇ : V‚ÇÇ.StateFunction init impl lang‚ÇÇ lang‚ÇÉ)
    
    (verify : Stmt‚ÇÅ ‚Üí pSpec‚ÇÅ.FullTranscript ‚Üí Stmt‚ÇÇ)
    (hVerify : V‚ÇÅ = ‚ü®fun stmt tr => pure (verify stmt tr)‚ü©) :
      (V‚ÇÅ.append V‚ÇÇ).StateFunction init impl lang‚ÇÅ lang‚ÇÉ where
  toFun := fun roundIdx stmt‚ÇÅ transcript =>
    if h : roundIdx.val ‚â§ m then
    
      S‚ÇÅ ‚ü®roundIdx, by admit /- proof elided -/
      ‚ü© stmt‚ÇÅ (by admit /- proof elided -/
      )
    else
    
    
    
      S‚ÇÅ ‚ü®m, by admit /- proof elided -/
      ‚ü© stmt‚ÇÅ (by admit /- proof elided -/
      ) ‚àß
      S‚ÇÇ ‚ü®roundIdx - m, by admit /- proof elided -/
      ‚ü© (verify stmt‚ÇÅ
        (by admit /- proof elided -/
        ))
        (by admit /- proof elided -/
        )
  toFun_empty := sorry
  toFun_next := sorry
  toFun_full := sorry

def processMemoryOps (ops : List (MemoryOp Œπ Œ±)) (startMem : M) : Option M :=
  ops.foldlM (fun m op =>
    match op with
    | .read ‚ü®i, v‚ü© => if Memory.read m i = v then some m else none
    | .write ‚ü®i, v‚ü© => some (Memory.write m i v)
  ) startMem

noncomputable def liftToFunctionField {H : F[X][Y]} : F[X] ‚Üí+* ùïÉ H :=
  RingHom.comp (Ideal.Quotient.mk (Ideal.span {H_tilde H})) coeffAsRatFunc

def mulVec [Zero Œ±] [Add Œ±] [Mul Œ±] {numRows numCols : Nat}
    (M : Vector (Vector Œ± numCols) numRows)
    (x : Vector Œ± numCols) : Vector Œ± numRows :=
  M.map (fun row => row *·µ• x)

structure TraceMapProperty (F : Type*) [Field F] (u : F) (k : ‚Ñï) : Prop where
  element_trace : ‚àë i ‚àà Finset.range (2 ^ k), u ^ (2 ^ i) = 1
  inverse_trace : ‚àë i ‚àà Finset.range (2 ^ k), (u‚Åª¬π) ^ (2 ^ i) = 1

abbrev SEP_BYTE : String := ‚ü®[SEP_CHAR]‚ü©

NoZeroDivisors in Mathlib.Algebra.GroupWithZero.Defs

Context in Examples.FrankingProtocol

noncomputable def monomialToNovelCoeffs

  (‚Ñì : ‚Ñï) (h_‚Ñì : ‚Ñì ‚â§ r) (monomial_coeffs : Fin (2 ^ ‚Ñì) ‚Üí L) : Fin (2^‚Ñì) ‚Üí L :=
  let A := changeOfBasisMatrix ùîΩq Œ≤ ‚Ñì h_‚Ñì
  
  
  Matrix.vecMul monomial_coeffs A‚Åª¬π

IO.FS.Stream.write in Init.System.IO

def finOneEquiv : MvPolynomial (Fin 1) R ‚âÉ‚Çê[R] Polynomial R :=
  (finSuccEquiv R 0).trans (Polynomial.mapAlgEquiv (isEmptyAlgEquiv R (Fin 0)))

@[inline]
def zero [Zero R] : MlPolyEval R n := Vector.replicate (2 ^ n) 0

Exists in Init.Core

def interleaveCode [Semiring F] [DecidableEq F] (C : Submodule F (n ‚Üí F)) (Œπ : Type*)
  : Submodule F ((Œπ √ó n) ‚Üí F) :=
  Submodule.span F {v | ‚àÄ i, ‚àÉ c ‚àà C, c = fun j => v (i, j)}

def split {k : ‚Ñï} (h : k > 0) (x : ConcreteBTField k) :
    ConcreteBTField (k - 1) √ó ConcreteBTField (k - 1) :=
  let lo_bits : BitVec (2 ^ (k - 1) - 1 - 0 + 1) :=
    BitVec.extractLsb (hi := 2 ^ (k - 1) - 1) (lo := 0) x
  let hi_bits : BitVec (2 ^ k - 1 - 2 ^ (k - 1) + 1) :=
    BitVec.extractLsb (hi := 2 ^ k - 1) (lo := 2 ^ (k - 1)) x
  have h_lo : 2 ^ (k - 1) - 1 - 0 + 1 = 2 ^ (k - 1) := by admit /- proof elided -/

def hflatten {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {Œ± : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí Sort*}
    (v : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí Œ± i j) : (k : Fin (vsum n)) ‚Üí Fin.vflatten Œ± k :=
  fflatten (F := id) v

def zeroCheckVirtualPolynomial (ùï© : Statement.AfterFirstMessage R pp)
    
    (oStmt : ‚àÄ i, OracleStatement.AfterFirstMessage R pp i) :
      MvPolynomial (Fin pp.‚Ñì_m) R :=
  letI ùï´ := R1CS.ùï´ ùï© (oStmt (.inr 0))
  ‚àë x : Fin (2 ^ pp.‚Ñì_m),
    (eqPolynomial (finFunctionFinEquiv.symm x : Fin pp.‚Ñì_m ‚Üí R)) *
      C ((oStmt (.inl .A) *·µ• ùï´) x * (oStmt (.inl .B) *·µ• ùï´) x - (oStmt (.inl .C) *·µ• ùï´) x)

def NBlockMessages := 2 * (œë - 1) + 3

finSuccEquiv in Mathlib.Logic.Equiv.Fin.Basic

def Reduction.duplexSpongeFiatShamir (R : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec) :
    NonInteractiveReduction (‚àÄ i, pSpec.Message i) (oSpec ++‚Çí duplexSpongeChallengeOracle StmtIn U)
      StmtIn WitIn StmtOut WitOut where
  prover := R.prover.duplexSpongeFiatShamir
  verifier := R.verifier.duplexSpongeFiatShamir

abbrev OutputStatement := StatementRound R _ (.last n)

def FullData.getRootValue {s} {Œ± : Type} (tree : FullData Œ± s) :=
  tree.get (getRootIndex s)

noncomputable def foldOracleReduction :
  OracleReduction []‚Çí
    (Statement F i.castSucc) (OracleStatement D x s i.castSucc) (Witness F s d i.castSucc.castSucc)
    (Statement F i.succ) (OracleStatement D x s i.succ) (Witness F s d i.succ.castSucc)
    (pSpec D x s i) where
  prover := foldProver D x s d i
  verifier := foldVerifier D x s i

Fin.subNat in Init.Data.Fin.Basic

instance [NeZero k] {f : Fin k ‚Üí Œπ ‚Üí F} : Nonempty (Finset.univ.image f) :=

instance [Zero T] [ToNat T] : Mul (Cayley T) where
  mul := mul

@[simp]
def outerRelIn_Test : Set (OuterStmtIn_Test √ó Unit) :=
  setOf (fun ‚ü®‚ü®p, q, t‚ü©, _‚ü© => ‚àë x ‚àà {0, 1}, (p * q).eval x = t)

instance {n : ‚Ñï} : OfNat (Cayley T) n where
  ofNat := ofNat n

instance [ProverFirst pSpec] : ProverLast pSpec where
  prover_last' := by admit /- proof elided -/

noncomputable def polyQ (P q : Polynomial F) : MvPolynomial (Fin 2) F :=
  
  let Pbi : MvPolynomial (Fin 2) F := uni2bi P
  
  let P' : MvPolynomial (Fin 2) F := (MvPolynomial.X 1) - uni2bi q
  
  have h_unit : IsUnit ((MonomialOrder.lex).leadingCoeff P') := sorry
  modBivar Pbi P' h_unit

@[reducible]
def OracleStatement (Œπ F : Type) : Unit ‚Üí Type :=
    fun _ => Œπ ‚Üí F

def getUElements (i : Fin r) : List L :=
  (List.finRange (2^i.val)).map fun k =>
    (Finset.univ : Finset (Fin i)).sum fun j =>
      if Nat.getBit (n := k.val) (k := j.val) == 1 then
        Œ≤ ‚ü®j.val, by admit /- proof elided -/
        ‚ü©
      else 0

Subtype in Init.Prelude

def collisionBwdFwd : Prop :=
  let ‚ü®baseTrace, _‚ü© := removeRedundantEntryDS trace
  ‚àÉ stateIn stateOut stateOut',
    (stateIn, stateOut) ‚àà baseTrace.getQ (.inr .Bwd) ‚àß
    (stateOut', stateIn) ‚àà baseTrace.getQ (.inr .Fwd) ‚àß
    stateOut ‚â† stateOut'

alias E_col_pinv_p := collisionBwdFwd

instance instOneConcreteBTField (k : ‚Ñï) : One (ConcreteBTField k) where
  one := one

def ConstraintSystem (ùì° : Type) (numWires numGates : ‚Ñï) := Fin numGates ‚Üí Gate ùì° numWires

MvPolynomial.C in Mathlib.Algebra.MvPolynomial.Basic

def binding (scheme : Scheme oSpec Data Randomness Commitment pSpec)
    (bindingError : ‚Ñù‚â•0) : Prop :=
  ‚àÄ AuxState : Type,
  ‚àÄ adversary : BindingAdversary oSpec Data Commitment AuxState,
  ‚àÄ prover : Prover oSpec (Commitment √ó O.Query √ó O.Response) AuxState Bool Unit pSpec,
    False

Semiring in Mathlib.Algebra.Ring.Defs

@[reducible, inline, specialize, simp]
def MessageIdx (vPSpec : VectorSpec n) := {i : Fin n // vPSpec.dir i = .P_to_V}

@[reducible, simp]
def MessageIdxUpTo (k : Fin (n + 1)) (pSpec : ProtocolSpec n) : Type :=
  (pSpec‚ü¶:k.val‚üß).MessageIdx

Equivalence in Init.Core

noncomputable def byCheckMatrix [CommRing F] (H : Matrix Œπ Œ∫ F) : LinearCode Œ∫ F :=
  LinearMap.ker H.mulVecLin

instance : SliceGE (FullTranscript pSpec) ‚Ñï
    (fun _ start => start ‚â§ n)
    (fun _ start _ => FullTranscript (pSpec‚ü¶start:‚üß))
    where
  sliceGE := fun v start h => drop start h v

class PrimeOrderWith (G : Type*) [Group G] (p : outParam ‚Ñï) [Fact (Nat.Prime p)] where
  hCard : Nat.card G = p

def rootsOfUnity (n s : ‚Ñï) : List (Domain.evalDomain D (n - s)) :=
  List.map
    (fun i =>
      ‚ü®
        (DIsCyclicC.gen.1 ^ (2 ^ (n - s))) ^ i,
        by admit /- proof elided -/
      ‚ü©
    )
    (List.range (2 ^ s))

Fin.modNat in Batteries.Data.Fin.Basic

def coeffsOfPolynomial (p : F[X]) : Fin deg ‚Üí F :=
  fun ‚ü®x, _‚ü© ‚Ü¶ p.coeff x

Vector.head in Init.Data.Vector.Basic

def churchRec {Œ± : Type} (n : ChurchNat Œ±) (step : Œ± ‚Üí Œ±) (base : Œ±) : Œ± :=
  n step base

def oracleProver : OracleProver oSpec
    Statement OStatement Unit
    Unit (OStatement ‚äï·µ• OStatement) Unit
    (pSpec OStatement) where
  PrvState := fun _ => OStatement default

  input := fun ‚ü®‚ü®_, oStmt‚ü©, _‚ü© => oStmt default

  sendMessage | ‚ü®0, _‚ü© => fun st => pure (st, st)

  receiveChallenge | ‚ü®0, h‚ü© => nomatch h

  output := fun st => pure
    (‚ü®(), fun x => match x with
      | .inl _ => by admit /- proof elided -/
      ‚ü©,
     ())

@[inline]
def seqCompose {m : ‚Ñï}
    (Stmt : Fin (m + 1) ‚Üí Type) {Œπ‚Çõ : Fin (m + 1) ‚Üí Type} (OStmt : (i : Fin (m + 1)) ‚Üí Œπ‚Çõ i ‚Üí Type)
    (Wit : Fin (m + 1) ‚Üí Type) {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (P : (i : Fin m) ‚Üí
      OracleProver oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Wit i.castSucc)
        (Stmt i.succ) (OStmt i.succ) (Wit i.succ) (pSpec i)) :
    OracleProver oSpec (Stmt 0) (OStmt 0) (Wit 0) (Stmt (Fin.last m)) (OStmt (Fin.last m))
      (Wit (Fin.last m)) (seqCompose pSpec) :=
  Prover.seqCompose (fun i => Stmt i √ó (‚àÄ j, OStmt i j)) Wit P

def redundantQuery (log : QueryLog spec) (i : Œπ) (q : spec.domain i) (r : spec.range i) : Prop :=
  (log.getQ i).count (q, r) > 1

def D_Y (Q : F[Z][X][Y]) : ‚Ñï := Bivariate.natDegreeY Q

def completeness (relIn : Set (StmtIn √ó WitIn))
    (relOut : Set (StmtOut √ó WitOut))
    (reduction : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec)
    (completenessError : ‚Ñù‚â•0) : Prop :=
  ‚àÄ stmtIn : StmtIn,
  ‚àÄ witIn : WitIn,
  (stmtIn, witIn) ‚àà relIn ‚Üí
    [fun ‚ü®‚ü®_, (prvStmtOut, witOut)‚ü©, stmtOut‚ü© => (stmtOut, witOut) ‚àà relOut ‚àß prvStmtOut = stmtOut
    | do (simulateQ (impl ++‚Çõ‚Çí challengeQueryImpl : QueryImpl _ (StateT œÉ ProbComp))
          <| reduction.run stmtIn witIn).run' (‚Üê init)] ‚â• 1 - completenessError

def secondSumCheckVirtualPolynomial
    (stmt : Statement.AfterLinearCombination R pp)
    (oStmt : ‚àÄ i, OracleStatement.AfterLinearCombination R pp i) :
      MvPolynomial (Fin pp.‚Ñì_n) R := sorry

noncomputable def liftedFRI [DecidableEq F] :
  OracleReduction []‚Çí
    ((Fin m ‚Üí F) √ó Fri.Spec.Statement F (0 : Fin (k + 1)))
      (OracleStatement D x m) (Fri.Spec.Witness F s d 0)
    (Fri.Spec.FinalStatement F k)
      (Fri.Spec.FinalOracleStatement D x s) (Fri.Spec.Witness F s d (Fin.last (k + 1)))
    (
      Fri.Spec.pSpecFold D x k s ++‚Çö
      Fri.Spec.FinalFoldPhase.pSpec F ++‚Çö
      Fri.Spec.QueryRound.pSpec D x l
    ) :=
    OracleReduction.liftContext
      (liftingLens D x k s d m)
      (Fri.Spec.reduction D x k s d dom_size_cond l)

private noncomputable def Q (œâs : Fin n ‚Üí F)
  (f : Fin n ‚Üí F) (p : Polynomial F) (e : ‚Ñï) : Polynomial F :=
  p * (E œâs f p e)

Nat.mod in Init.Prelude

Real in Mathlib.Data.Real.Basic

instance : Fact (Nat.Prime scalarFieldSize) := ‚ü®ScalarField_is_prime‚ü©

class Extractor.Straightline.IsMonotone
    (relIn : Set (StmtIn √ó WitIn))
    (E : Extractor.Straightline oSpec StmtIn WitIn WitOut pSpec)
    [oSpec.FiniteRange]
    where
  is_monotone : ‚àÄ witOut stmtIn transcript, ‚àÄ proveQueryLog‚ÇÅ proveQueryLog‚ÇÇ : oSpec.QueryLog,
    ‚àÄ verifyQueryLog‚ÇÅ verifyQueryLog‚ÇÇ : oSpec.QueryLog,
    proveQueryLog‚ÇÅ.Sublist proveQueryLog‚ÇÇ ‚Üí
    verifyQueryLog‚ÇÅ.Sublist verifyQueryLog‚ÇÇ ‚Üí
    
    [fun witIn => (stmtIn, witIn) ‚àà relIn |
      E stmtIn witOut transcript proveQueryLog‚ÇÅ verifyQueryLog‚ÇÅ] ‚â§
    [fun witIn => (stmtIn, witIn) ‚àà relIn |
      E stmtIn witOut transcript proveQueryLog‚ÇÇ verifyQueryLog‚ÇÇ]

instance {Œπ : Type} : OracleInterface (OracleStatement Œπ F ()) := OracleInterface.instFunction

def AlgebraTowerEquiv.toAlgEquivOverRight (e : AlgebraTowerEquiv A B) (i j : Œπ) (h : i ‚â§ j) :
  letI : Algebra (B i) (B j) :=

structure Size where
  m : ‚Ñï 
  n : ‚Ñï 
  n_w : ‚Ñï 
  n_w_le_n : n_w ‚â§ n := by admit /- proof elided -/

noncomputable def finalSumcheckVerifier :
  OracleVerifier
    (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì))
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (StmtOut := FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì))
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (pSpec := pSpecFinalSumcheckStep (L := L)) where
  verify := fun stmtIn _ => do
    
    let c : L ‚Üê query (spec := [(pSpecFinalSumcheckStep (L := L)).Message]‚Çí) ‚ü®0, rfl‚ü© ()

    
    let eq_tilde_eval : L := eqTilde (r := stmtIn.ctx.t_eval_point) (r' := stmtIn.challenges)
    unless stmtIn.sumcheck_target = eq_tilde_eval * c do
      return { 
        ctx := {t_eval_point := 0, original_claim := 0},
        sumcheck_target := 0,
        challenges := 0,
        final_constant := 0
      }

    
    let stmtOut : FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì) := {
      ctx := stmtIn.ctx,
      sumcheck_target := eq_tilde_eval * c, 
      challenges := stmtIn.challenges,
      final_constant := c
    }
    pure stmtOut

  embed := ‚ü®fun j => by admit /- proof elided -/
  ‚ü©
  hEq := fun oracleIdx => by admit /- proof elided -/

UInt32.ofFin in Init.Data.UInt.Basic

noncomputable def batchVerifier :
  OracleVerifier []‚Çí
    Unit (OracleStatement D x m)
    ((Fin m ‚Üí F) √ó Fri.Spec.Statement F (0 : Fin (k + 1)))
    (OracleStatement D x m)
    (batchSpec F m) where
  verify := fun _ chals => pure ‚ü®chals ‚ü®0, by admit /- proof elided -/
  ‚ü©, Fin.elim0‚ü©
  embed :=
    ‚ü®
      fun i => Sum.inl i,
      by admit /- proof elided -/
    ‚ü©
  hEq := by admit /- proof elided -/

IO in Init.System.IO

instance : Initialize (DuplexSponge U C) (Vector UInt8 32) where
  new iv := {
    state := Initialize.new iv,
    absorbPos := 0,
    squeezePos := Fin.last SpongeSize.R
  }

Id.run in Init.Control.Id

Fin.castLE in Init.Data.Fin.Basic

structure Witness (i : Fin (‚Ñì + 1)) where
  t : L‚¶É‚â§ 1‚¶Ñ[X Fin ‚Ñì]  
  H : L‚¶É‚â§ 2‚¶Ñ[X Fin (‚Ñì - i)] 
  f: (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®i, by admit /- proof elided -/
  ‚ü© ‚Üí L 

noncomputable def decode : (ReedSolomon.code domain deg) ‚Üí‚Çó[F] F[X] :=
  domRestrict
    (interpolate (domain := domain))
    (ReedSolomon.code domain deg)

List.findIdx in Init.Data.List.Basic

instance : Fact (Nat.Prime baseFieldSize) := ‚ü®BaseField_is_prime‚ü©

abbrev rdrop (m : ‚Ñï) (h : m ‚â§ n)
    (transcript : FullTranscript pSpec) : FullTranscript (pSpec.rdrop m h) :=
  Fin.rdrop m h transcript

def finalSumcheckKStateProp {m : Fin (1 + 1)} (tr : Transcript m (pSpecFinalSumcheckStep (L := L)))
    (stmt : Statement (L := L) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì))
    (witMid : FinalSumcheckWit (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) m)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì) j) : Prop :=
  match m with
  | ‚ü®0, _‚ü© => 
    masterKStateProp ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (mp := BBF_SumcheckMultiplierParam)
      (stmtIdx := Fin.last ‚Ñì) (oracleIdx := Fin.last ‚Ñì) (h_le := le_refl _)
      (stmt := stmt) (wit := witMid) (oStmt := oStmt) (localChecks := True)
  | ‚ü®1, _‚ü© => 
    let tr_so_far := (pSpecFinalSumcheckStep (L := L)).take 1 (by admit /- proof elided -/
    )
    let i_msg0 : tr_so_far.MessageIdx := ‚ü®‚ü®0, by admit /- proof elided -/
    ‚ü©, rfl‚ü©
    let c : L := (ProtocolSpec.Transcript.equivMessagesChallenges (k := 1)
      (pSpec := pSpecFinalSumcheckStep (L := L)) tr).1 i_msg0

    let stmtOut : FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì) := {
      ctx := stmt.ctx,
      sumcheck_target := stmt.sumcheck_target,
      challenges := stmt.challenges,
      final_constant := c
    }

    let sumcheckFinalCheck : Prop := stmt.sumcheck_target = eqTilde r stmt.challenges * c
    let finalFoldingProp := finalNonDoomedFoldingProp ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (h_le := by admit /- proof elided -/
        ) (input := ‚ü®stmtOut, oStmt‚ü©)

    sumcheckFinalCheck ‚àß finalFoldingProp 

Finset.zero in Mathlib.Algebra.Group.Pointwise.Finset.Basic

@[reducible, simp]
def mapOStmt (oStmtIn : ‚àÄ i, OStmtIn i) : ‚àÄ i, OStmtOut i := fun i => (hEq i) ‚ñ∏ oStmtIn (embedIdx i)

def proximityMeasure (u v : n ‚Üí F) (d : ‚Ñï) : ‚Ñï :=
  Fintype.card {r : F | Œî‚ÇÄ'(r ‚Ä¢ u + (1 - r) ‚Ä¢ v, C) ‚â§ d}

AddSubmonoidClass in Mathlib.Algebra.Group.Submonoid.Defs

MulOneClass in Mathlib.Algebra.Group.Defs

instance instDCastPSigma : DCast ((a : Œ±) √ó' Œ≤ a) (fun a => Œ≥ a.1 a.2) where
  dcast hab c := dcast‚ÇÇ (by admit /- proof elided -/
  ) (by admit /- proof elided -/
  ) c
  dcast_id := by admit /- proof elided -/

@[ext]
structure ProverOutput {Œπ : Type} (oSpec : OracleSpec Œπ) (Output PrvState : Type) where
  output : PrvState ‚Üí OracleComp oSpec Output

def Transcript.removeSalt {k : Fin (n + 1)} (transcript : (pSpec.addSalt Salt).Transcript k) :
    pSpec.Transcript k :=

  fun i => by admit /- proof elided -/

instance [h : VerifierFirst pSpec] : IsEmpty (pSpec.MessageIdx) where
  false | ‚ü®0, h'‚ü© => by admit /- proof elided -/

instance instDecidableEqOption {Œ± : Type*} [DecidableEq Œ±] :
    DecidableEq (Option Œ±) := inferInstance

def SkeletonNodeIndex.isLeaf {s : Skeleton} (idx : SkeletonNodeIndex s) : Bool :=
  match idx with
  | SkeletonNodeIndex.ofLeaf => true
  | SkeletonNodeIndex.ofInternal => false
  | SkeletonNodeIndex.ofLeft _ => false
  | SkeletonNodeIndex.ofRight _ => false

def Option.doubleBind {Œ± Œ≤ Œ≥ : Type} (f : Œ± ‚Üí Œ≤ ‚Üí Option Œ≥)
    (x : Option Œ±) (y : Option Œ≤) : Option Œ≥ :=
  match x, y with
  | none, _ => none
  | _, none => none
  | some a, some b => f a b

def SkeletonNodeIndex.path {s : Skeleton} (idx : SkeletonNodeIndex s) :
    List (SkeletonNodeIndex s) := sorry

FiniteDimensional in Mathlib.LinearAlgebra.FiniteDimensional.Defs

def addCast {n : ‚Ñï} (m : ‚Ñï) (i : Fin n) : Fin (m + n) := ‚ü®i, Nat.lt_add_left m i.2‚ü©

def regularElms_set (H : F[X][Y]) : Set (ùïÉ H) :=
  {a : ùïÉ H | ‚àÉ b : ùí™ H, a = embeddingOfùí™IntoùïÉ _ b}

def leq {Œ± : Type} (m n : ChurchNat Œ±) : ChurchBool Œ± :=
  isZero (ChurchNat.sub m n)

@[simp]
instance BTFieldIsDomain (k : ‚Ñï) : IsDomain (BTField k) := inferInstance

def listDecodable (C : Code Œπ F) (r : ‚Ñù) (‚Ñì : ‚Ñù) : Prop :=
  ‚àÄ y : Œπ ‚Üí F, listOfCloseCodewordsRel C y r ‚â§ ‚Ñì

@[app_unexpander Fin.dempty]
def demptyUnexpander : Lean.PrettyPrinter.Unexpander
  | `($_:ident) => `(!h[])
  | _ => throw ()

def reduction (i : Fin n) : Reduction oSpec
    ((StatementRound R n i.castSucc) √ó (‚àÄ i, OracleStatement R n deg i)) Unit
    ((StatementRound R n i.succ) √ó (‚àÄ i, OracleStatement R n deg i)) Unit (pSpec R deg) :=
  (Simple.reduction R deg D oSpec).liftContext (oCtxLens R n deg D i).toContext

instance instEquivalenceEquiv : Equivalence (equiv (R := R)) where
  refl := equiv_refl
  symm := equiv_symm
  trans := equiv_trans

Finset.range in Mathlib.Data.Finset.Range

Set.Finite in Mathlib.Data.Finite.Defs

@[inline]
def smul [Mul R] (r : R) (p : MlPolyEval R n) : MlPolyEval R n := p.map (fun a => r * a)

abbrev BaseField := ZMod BASE_FIELD_CARD

@[inline, specialize]
def neg (p : UniPoly R) : UniPoly R := p.map (fun a => -a)

instDecidableEqOfLawfulBEq in Init.Core

@[reducible, simp]
def knowledgeSoundness (relation : Set (Statement √ó Bool))
    (verifier : Verifier oSpec Statement Bool pSpec)
    (knowledgeError : ‚Ñù‚â•0) : Prop :=
  verifier.knowledgeSoundness init impl relation acceptRejectRel knowledgeError

Fin.snoc in Mathlib.Data.Fin.Tuple.Basic

Trans in Init.Prelude

def mapOStmtOutRelayStep (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j) :
    ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.succ j := fun j => by admit /- proof elided -/

@[inline]
def ofInputOnly
    (liftWit : OuterStmtIn √ó OuterWitOut ‚Üí InnerWitIn ‚Üí OuterWitIn) :
    Witness.InvLens OuterStmtIn OuterWitIn OuterWitOut InnerWitIn OuterWitOut :=
  ‚ü®Prod.snd, liftWit‚ü©

USize.ofNat in Init.Data.UInt.BasicAux

Preorder in Mathlib.Order.Defs.PartialOrder

List.repr in Init.Data.Repr

OracleSpec.range in VCVio.OracleComp.OracleSpec

noncomputable def disFromHammingNorm [Semiring F] [DecidableEq F] (LC : LinearCode Œπ F) : ‚Ñï :=
  sInf {d | ‚àÉ u ‚àà LC, u ‚â† 0 ‚àß hammingNorm u ‚â§ d}

Or.inr in Init.Prelude

toFun in ToMathlib.Control.Monad.Hom

@[inline] def mul [Zero T] [ToNat T] (a b : Cayley T) : Cayley T :=
  mulNat a ‚Üëb

def degCor
  (œÜ : Œπ ‚Ü™ F) (dstar degree : ‚Ñï) (r : F) (f : Œπ ‚Üí F) (x : Œπ) : F :=
    f x * ‚àë l ‚àà range (dstar - degree + 1), ((œÜ x) * r) ^ l

instance (k : ‚Ñï) : Add (ConcreteBTField k) where
  add := add

@[simp]
def extractorLens (i : Fin n) : Extractor.Lens
    (StatementRound R n i.castSucc √ó (‚àÄ i, OracleStatement R n deg i))
    (StatementRound R n i.succ √ó (‚àÄ i, OracleStatement R n deg i))
    (Simple.StmtIn R √ó (‚àÄ i, Simple.OStmtIn R deg i))
    (Simple.StmtOut R √ó (‚àÄ i, Simple.OStmtOut R deg i))
    Unit Unit Unit Unit where
  stmt := oStmtLens R n deg D i
  wit := Witness.InvLens.trivial

noncomputable def vanishingPoly (S : Finset F) : Polynomial F :=
  ‚àè s ‚àà S, (Polynomial.X - Polynomial.C s)

def oracleVerifier (i : Fin n) : OracleVerifier oSpec
    (StatementRound R n i.castSucc) (OracleStatement R n deg)
    (StatementRound R n i.succ) (OracleStatement R n deg) (pSpec R deg) where
  
  
  
  
  verify := fun ‚ü®target, challenges‚ü© chal => do
    let evals : List R ‚Üê (List.finRange m).mapM
      (fun i => do
        return ‚Üê query
          (spec := (oSpec ++‚Çí ([OracleStatement R n deg]‚Çí ++‚Çí [(pSpec R deg).Message]‚Çí)))
            (Sum.inr <| Sum.inr default) (D i))
    guard (evals.sum = target)
    let newTarget ‚Üê query
      (spec := (oSpec ++‚Çí ([OracleStatement R n deg]‚Çí ++‚Çí [(pSpec R deg).Message]‚Çí)))
        (Sum.inr <| Sum.inr default) (by admit /- proof elided -/
        )
    letI newTarget : R := by admit /- proof elided -/

@[reducible]
def combineMap : StmtIn √ó WitIn ‚Üí OracleComp oSpec (StmtOut √ó WitOut) :=
  fun ‚ü®stmt, wit‚ü© => do return (‚Üê mapStmt stmt, ‚Üê mapWit stmt wit)

minpoly in Mathlib.FieldTheory.Minpoly.Basic

instance : SliceGE (ProtocolSpec n) ‚Ñï
    (fun _ start => start ‚â§ n)
    (fun _ start _ => ProtocolSpec (n - start))
    where
  sliceGE := fun v start h => drop start h v

BitVec.setWidth in Init.Data.BitVec.Basic

noncomputable def polyQuotient (S : Finset F) (fPoly : F[X]) : F[X] :=
    (fPoly - (ansPoly S (fun s => fPoly.eval s))) / (vanishingPoly S)

instance {Œ± : Type} {s : Skeleton} :
    CoeFun (LeafData Œ± s) fun (_ : LeafData Œ± s) => SkeletonLeafIndex s ‚Üí Œ± where
  coe := fun tree idx => tree.get idx

@[reducible, inline, specialize]
def challengeOracleInterfaceSR (StmtIn : Type) (pSpec : ProtocolSpec n) :
    ‚àÄ i, OracleInterface (pSpec.Challenge i) := fun i =>
  { Query := StmtIn √ó pSpec.MessagesUpTo i.1.castSucc
    Response := pSpec.Challenge i
    answer := fun c _ => c }

alias challengeOracleInterfaceFS := challengeOracleInterfaceSR

class DCast‚ÇÇ (Œ± : Sort*) (Œ≤ : Œ± ‚Üí Sort*) (Œ≥ : (a : Œ±) ‚Üí Œ≤ a ‚Üí Sort*) [DCast Œ± Œ≤] where
  dcast‚ÇÇ : ‚àÄ {a a' : Œ±} {b : Œ≤ a} {b' : Œ≤ a'},
    (ha : a = a') ‚Üí (dcast ha b = b') ‚Üí Œ≥ a b ‚Üí Œ≥ a' b'
  dcast‚ÇÇ_id : ‚àÄ {a : Œ±} {b : Œ≤ a}, dcast‚ÇÇ (Eq.refl a) dcast_eq = (id : Œ≥ a b ‚Üí Œ≥ a b)

def perfectCompleteness (relIn : Set (StmtIn √ó WitIn)) (relOut : Set (StmtOut √ó WitOut))
    (reduction : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec) : Prop :=
  completeness init impl relIn relOut reduction 0

@[reducible]
def oracleReduction : OracleReduction oSpec
    (StatementRound R n 0) (OracleStatement R n deg) Unit
    (StatementRound R n (.last n)) (OracleStatement R n deg) Unit
    (pSpec R deg n) :=
  OracleReduction.seqCompose (oSpec := oSpec)
    (Stmt := StatementRound R n)
    (OStmt := fun _ => OracleStatement R n deg)
    (Wit := fun _ => Unit)
    (pSpec := fun _ => SingleRound.pSpec R deg)
    (SingleRound.oracleReduction R n deg D oSpec)

def relation : Set (M √ó M √ó List (MemoryOp Œπ Œ±)) :=
  { ‚ü®startMem, finalMem, ops‚ü© | processMemoryOps ops startMem = some finalMem }

noncomputable def Pz
  {k : ‚Ñï}
  {z : F}
  (hS : z ‚àà coeffs_of_close_proximity k œâs Œ¥ u‚ÇÄ u‚ÇÅ)
  :
  F[X]
  := (exists_Pz_of_coeffs_of_close_proximity (n := n) (k := k) hS).choose

def Option.doubleBind_v3 {Œ± Œ≤ Œ≥ : Type} (f : Œ± ‚Üí Œ≤ ‚Üí Option Œ≥)
    (x : Option Œ±) (y : Option Œ≤) : Option Œ≥ := do f (‚Üê x) (‚Üê y)

def succ (n : ChurchNat Œ±) : ChurchNat Œ± := fun f x => f (n f x)

def computeInitialSumcheckPoly (t : MultilinearPoly L ‚Ñì)
    (m : MultilinearPoly L ‚Ñì) : MultiquadraticPoly L ‚Ñì :=
  ‚ü®m * t, by
    rw [MvPolynomial.mem_restrictDegree_iff_degreeOf_le]
    intro i
    have h_t_deg: degreeOf i t.val ‚â§ 1 :=
      degreeOf_le_iff.mpr fun term a ‚Ü¶ (t.property) a i
    have h_m_deg: degreeOf i m.val ‚â§ 1 :=
      degreeOf_le_iff.mpr fun term a ‚Ü¶ (m.property) a i
    calc
      _ ‚â§ (degreeOf i m.val) + (degreeOf i t.val) :=
        degreeOf_mul_le i m.val t.val
      _ ‚â§ 2 :=

@[simp]
abbrev OracleStatement.AfterFirstChallenge : R1CS.MatrixIdx ‚äï Fin 1 ‚Üí Type :=
  OracleStatement.AfterFirstMessage R pp

def nonLastBlockOracleVerifier (bIdx : Fin (‚Ñì / œë - 1)) :=
  let stmt : Fin (œë - 1 + 1) ‚Üí Type :=
    fun i => Statement (L := L) Context ‚ü®bIdx * œë + i, bIdx_mul_œë_add_i_cast_lt_‚Ñì_succ bIdx i‚ü©
  let oStmt := fun i: Fin (œë - 1 + 1) => OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë
    ‚ü®bIdx * œë + i, bIdx_mul_œë_add_i_cast_lt_‚Ñì_succ bIdx i‚ü©
  let firstFoldRelayRoundsOracleVerifier :=
    OracleVerifier.seqCompose (oSpec := []‚Çí)
      (Stmt := stmt)
      (OStmt := oStmt)
      (pSpec := fun i => pSpecFoldRelay (L:=L))
      (V := fun i => by admit /- proof elided -/
      )
  let h1 : ‚ÜëbIdx * œë + (œë - 1) < ‚Ñì := by admit /- proof elided -/

instance : Field BaseField := ZMod.instField baseFieldSize

HMod.hMod in Init.Prelude

Set.Nonempty in Mathlib.Data.Set.Defs

noncomputable def proximityError (F : Type*) [Fintype F] (d : ‚Ñï) (œÅ : ‚Ñù) (Œ¥ : ‚Ñù) (m : ‚Ñï) : ‚Ñù :=
  if Œ¥ ‚â§ (1 - œÅ) / 2 then
    ((m - 1) * d) / (œÅ * (Fintype.card F))
  else
    let min_val := min (1 - (Real.sqrt œÅ) - Œ¥ ) ((Real.sqrt œÅ) / 20)
    ((m - 1) * d^2) / ((Fintype.card F) * (2 * min_val)^7)

def equivBool : Direction ‚âÉ Bool where
  toFun := fun dir => match dir with | .V_to_P => false | .P_to_V => true
  invFun := fun b => match b with | false => .V_to_P | true => .P_to_V
  left_inv := fun dir => match dir with | .P_to_V => rfl | .V_to_P => rfl
  right_inv := fun b => match b with | false => rfl | true => rfl

instance : HasSucc Nat where
  succ' := Nat.succ

def StateRestoration.Soundness (oSpec : OracleSpec Œπ) (StmtIn : Type)
    {n : ‚Ñï} (pSpec : ProtocolSpec n) :=
  OracleComp (oSpec ++‚Çí (srChallengeOracle StmtIn pSpec)) (StmtIn √ó pSpec.Messages)

instance : ‚àÄ i, SelectableType ((pSpecNonLastBlocks ùîΩq Œ≤ (œë:=œë)
  (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).Challenge i) := instSelectableTypeChallengeSeqCompose

Array.replicate in Init.Data.Array.Basic

def pSpecQuery : ProtocolSpec 1 :=
  ‚ü®![Direction.V_to_P],
    ![Fin Œ≥_repetitions ‚Üí sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate 0]‚ü©

noncomputable instance : Algebra Left (Left ‚äó[K] Right) := Algebra.TensorProduct.leftAlgebra

BitVec.ofNat in Init.Prelude

def commitKStateProp (i : Fin ‚Ñì) (m : Fin (1 + 1))
  (stmtIn : Statement (L := L) Context i.succ)
  (witMid : Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
  (oStmtIn : (i_1 : Fin (toOutCodewordsCount ‚Ñì œë i.castSucc)) ‚Üí
    OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc i_1)
  : Prop :=

  match m with
  | ‚ü®0, _‚ü© => 
    masterKStateProp (mp := mp) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (stmtIdx := i.succ) (oracleIdx := i.castSucc)
      (h_le := by admit /- proof elided -/
      )
      (stmt := stmtIn) (wit := witMid) (oStmt := oStmtIn)
      (localChecks := True)
  | ‚ü®1, _‚ü© => 
    let ‚ü®_, stmtOut, oStmtOut, witOut‚ü© := getCommitProverFinalOutput ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i ‚ü®stmtIn, oStmtIn, witMid‚ü©
    masterKStateProp (mp := mp) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (stmtIdx := i.succ) (oracleIdx := i.succ)
      (h_le := le_refl _)
      (stmt := stmtOut) (wit := witOut) (oStmt := oStmtOut)
      (localChecks := True)

def findSumIdx (l : List Œ±) (j : Œ±) : ‚Ñï := l.partialSum.findIdx (j < ¬∑)

@[inline, specialize]
def oracleReduction :
  OracleReduction oSpec Unit (fun _ : Fin 2 => OStatement) Unit
    (Query OStatement) (fun _ : Fin 2 => OStatement) Unit (pSpec OStatement) where
  prover := oracleProver oSpec OStatement
  verifier := oracleVerifier oSpec OStatement

def basisSucc (k : ‚Ñï) : Basis (Fin 2) (ConcreteBTField k) (ConcreteBTField (k + 1)) :=

def ratchet (sponge : DuplexSponge U C) :
    OracleComp (forwardPermutationOracle C) (DuplexSponge U C) := do
  let permutedState : C ‚Üê query (spec := forwardPermutationOracle C) () sponge.state
  
  let vecState : Vector U SpongeSize.N := SpongeState.get permutedState
  
  let zeroed : Vector U SpongeSize.N :=
    Vector.ofFn (fun i => if i < SpongeSize.R then 0 else vecState[i])
  
  let newVecState := SpongeState.update permutedState zeroed
  
  return { sponge with
    state := newVecState,
    squeezePos := Fin.last SpongeSize.R }

BitVec.cast in Init.Data.BitVec.Basic

@[inline, specialize, simp]
def verifier : Verifier oSpec Statement Statement !p[] := Verifier.id

instance [O‚Çò : ‚àÄ i, OracleInterface (pSpec.Message i)] :
    ‚àÄ i, OracleInterface ((pSpec.addSalt Salt).Message i) :=
  fun i => {
    Query := (O‚Çò i).Query
    Response := (O‚Çò i).Response
    answer := fun msg => (O‚Çò i).answer (by admit /- proof elided -/
      )
  }

def StateRestoration (oSpec : OracleSpec Œπ)
    (StmtIn WitIn WitOut : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n) :=
  StmtIn ‚Üí 
  WitOut ‚Üí 
  pSpec.FullTranscript ‚Üí 
  QueryLog (oSpec ++‚Çí (srChallengeOracle StmtIn pSpec)) ‚Üí 
  QueryLog oSpec ‚Üí 
  OracleComp oSpec WitIn 

Fin.reduceLast in Lean.Meta.Tactic.Simp.BuiltinSimprocs.Fin

instance : AlgebraTower (BTField) where
  algebraMap := towerAlgebraMap
  commutes' := by admit /- proof elided -/

Polynomial.toFinsupp in Mathlib.Algebra.Polynomial.Basic

def verifier (i : Fin n) : Verifier oSpec
    (StatementRound R n i.castSucc √ó (‚àÄ i, OracleStatement R n deg i))
    (StatementRound R n i.succ √ó (‚àÄ i, OracleStatement R n deg i)) (pSpec R deg) :=
  (Simple.verifier R deg D oSpec).liftContext (oStmtLens R n deg D i)

@[inline, reducible]
protected def id :
    Witness.InvLens OuterStmtIn OuterWitIn OuterWitOut OuterWitIn OuterWitOut :=
  ‚ü®Prod.snd, fun _ => id‚ü©

alias trivial := Witness.InvLens.id

def Mymotive : Fin 3 ‚Üí Type := !v[‚Ñï, Bool, String]

example : !d‚ü®Mymotive‚ü©[(1 : ‚Ñï), (true : Bool), ("hello" : String)] =
  (Fin.dcons (1 : ‚Ñï) (Fin.dcons (true : Bool) (Fin.dcons ("hello" : String) Fin.dempty)) :
   (i : Fin 3) ‚Üí Mymotive i) := rfl


example : !v[1, 2] ++·µõ !v[3, 4] = !v[1, 2, 3, 4] := rfl
example : (0 : ‚Ñï) ::·µõ !v[1, 2] = !v[0, 1, 2] := rfl
example : !v[1, 2] :+·µõ (3 : ‚Ñï) = !v[1, 2, 3] := rfl


example : (1 : ‚Ñï) :: ∞ (Fin.dempty : (i : Fin 0) ‚Üí Fin.vempty i) =
  (!h[(1 : ‚Ñï)] : (i : Fin 1) ‚Üí !v[‚Ñï] i) := rfl


example : !h[(1 : ‚Ñï), (true : Bool), ("hello" : String)] =
  Fin.hcons 1 (Fin.hcons true ("hello" :: ∞‚ü®String ; !v[]‚ü© !h[])) := rfl

noncomputable def sDomainFinEquiv (i : Fin r) (h_i : i < ‚Ñì + R_rate)
:
  (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i) ‚âÉ
  Fin (2^(‚Ñì + R_rate - i.val)) :=

structure BinaryTowerResult (F : Type _) (k : ‚Ñï) where
  vec : (List.Vector F (k + 1))
  instField : (Field F)
  instFintype : Fintype F
  specialElement : F
  specialElementNeZero : NeZero specialElement
  firstElementOfVecIsSpecialElement [Inhabited F] : vec.1.headI = specialElement
  instIrreduciblePoly : (Irreducible (p := (definingPoly specialElement)))
  sumZeroIffEq : ‚àÄ (x y : F), x + y = 0 ‚Üî x = y
  fieldFintypeCard : Fintype.card F = 2^(2^k)
  traceMapEvalAtRootsIs1 : TraceMapProperty F specialElement k

Polynomial.mapAlgEquiv in Mathlib.Algebra.Polynomial.AlgebraMap

instance : ‚àÄ i, VCVCompatible (Challenge ‚ü®!v[.P_to_V], !v[Msg]‚ü© i)
  | ‚ü®0, h‚ü© => nomatch h

@[reducible, simp]
def oraclePSpec : ProtocolSpec 1 := ‚ü®!v[.P_to_V], !v[Witness]‚ü©

def toNat (f : ValidChurchNat) : ‚Ñï :=
  ChurchNat.toNat f.1

class Smooth
  (domain : Œπ ‚Ü™ F) where
    H : Subgroup (Units F)
    a           : Units F
    h_coset     : Finset.image domain Finset.univ
                  = (fun h : Units F => (a : F) * (h : F)) '' (H : Set (Units F))
    h_card_pow2 : ‚àÉ k : ‚Ñï, Fintype.card Œπ = 2 ^ k

def toCoeffsVec (‚Ñì : Nat) : L‚¶É<2^‚Ñì‚¶Ñ[X] ‚Üí‚Çó[L] CoeffVecSpace L ‚Ñì where
  toFun := fun p => fun i => p.val.coeff i.val
  map_add' := fun p q => by admit /- proof elided -/

Finset.add in Mathlib.Algebra.Group.Pointwise.Finset.Basic

Vector.tail in Init.Data.Vector.Basic

instance [AddCommMonoid R] : AddCommMonoid (MlPoly R n) where
  add := add
  add_assoc a b c := by admit /- proof elided -/

noncomputable def evaluationPointœâ (i : Fin (‚Ñì + 1))
    (x : Fin (2 ^ (‚Ñì + R_rate - i))) : L := 
    
  ‚àë (‚ü®k, hk‚ü©: Fin (‚Ñì + R_rate - i)),
    if Nat.getBit k x.val = 1 then
      (normalizedW ùîΩq Œ≤ ‚ü®i, by admit /- proof elided -/
      ‚ü©).eval (Œ≤ ‚ü®i + k, by admit /- proof elided -/
      ‚ü©)
    else
      0

noncomputable def AffSpanFinset [NeZero k] (U : Fin k ‚Üí Œπ ‚Üí F) : Finset (Œπ ‚Üí F) :=
  (AffSpanSet.instFinite U).toFinset

RingEquiv in Mathlib.Algebra.Ring.Equiv

LinearEquiv in Mathlib.Algebra.Module.Equiv.Defs

@[reducible, inline, specialize]
def Challenges' (pSpec : ProtocolSpec n) : Type :=
  ‚àÄ i, (hi : pSpec.dir i = .V_to_P) ‚Üí pSpec.¬´Type¬ª i

@[simp]
def AlgebraTower.toAlgebra {i j : Œπ} (h : i ‚â§ j) : Algebra (A i) (A j) :=
  (AlgebraTower.algebraMap (i:=i) (j:=j) (h:=h)).toAlgebra

@[reducible]
def forwardPermutationOracle (Œ± : Type*) : OracleSpec Unit := Œ± ‚Üí‚Çí Œ±

instance {s} : LawfulFunctor (fun Œ± => FullData Œ± s) :=

def numberOfClosePts (u v : Œπ ‚Üí F) (deg : ‚Ñï) (Œ± : Œπ ‚Ü™ F) (e : ‚Ñï) : ‚Ñï :=
  Fintype.card (closePtsOnAffineLine u v deg Œ± e)

def BTField.isScalarTower_succ_right (l r : ‚Ñï) (h_le : l ‚â§ r) :=
  instAlgebraTowerNatBTField.toIsScalarTower (i:=l) (j:=r) (k:=r+1)
  (h1:=by admit /- proof elided -/
  ) (h2:=by admit /- proof elided -/
  )

def absorbUnchecked [Permute C] (sponge : DuplexSponge U C) (arr : Array U) : DuplexSponge U C :=
  simulateQ' forwardPermutationOracleImpl (absorbFast sponge arr) (by admit /- proof elided -/
  )

@[inline, specialize]
def run (stmt : StmtIn) (wit : WitIn)
    (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí) (FullTranscript pSpec √ó StmtOut √ó WitOut) := do
  let ‚ü®transcript, state‚ü© ‚Üê prover.runToRound (Fin.last n) stmt wit
  return ‚ü®transcript, ‚Üê prover.output state‚ü©

def implGroupEncodeOracle [Serialize G (BitVec bitLength)] :
    QueryImpl (GroupEncodeOracle Œπ bitLength) (StateT (GroupValTable Œπ G) Option) where
  impl | query _ i => fun table =>
    match table i with
    | some g => some (serialize g, table)
    | none => none

@[simps!]
def MessageIdx.sumEquiv :
    MessageIdx pSpec‚ÇÅ ‚äï MessageIdx pSpec‚ÇÇ ‚âÉ MessageIdx (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ) where
  toFun := Sum.elim (MessageIdx.inl) (MessageIdx.inr)
  invFun := fun ‚ü®i, h‚ü© => by admit /- proof elided -/

RatFunc in Mathlib.FieldTheory.RatFunc.Defs

instance : CommGroup G := IsCyclic.commGroup

instance [IsSingleRound pSpec] [h : OracleInterface (pSpec.Message default)] :
    (i : pSpec.MessageIdx) ‚Üí OracleInterface (pSpec.Message i) := fun i => by admit /- proof elided -/

def Cache.cons (n : ‚Ñï) (leaves : List.Vector Œ± (2 ^ (n + 1))) (cache : Cache Œ± n) :
    Cache Œ± (n + 1) :=
  Fin.snoc cache leaves

def partition (cs : ConstraintSystem ùì° numWires numGates) :
    Fin numWires ‚Üí Finset (Fin (3 * numGates)) :=
  
  
  
  
  fun i => Finset.map (Equiv.toEmbedding finProdFinEquiv)
    (Finset.filter (fun j => if j.1 = 0 then (cs j.2).a = i
      else if j.1 = 1 then (cs j.2).b = i else (cs j.2).c = i)
    (Finset.univ : Finset (Fin 3 √ó Fin numGates)))

abbrev CNat (n : ‚Ñï) : Type := (CayleyTower n).1

instance instHPowConcreteBTF‚Ñ§ {k : ‚Ñï} : HPow (ConcreteBTField k) ‚Ñ§ (ConcreteBTField k) where
  hPow a n :=
    match n with
    | Int.ofNat m => concrete_pow_nat a m
    | Int.negSucc m =>
      
      if a = 0 then 0
      else concrete_pow_nat (concrete_inv a) (m + 1) 

Set.InjOn in Mathlib.Data.Set.Operations

Algebra.id in Mathlib.Algebra.Algebra.Defs

def churchFalse : ChurchBool Œ± := fun _ y => y

def degreeX (f : F[X][Y]) : ‚Ñï := f.support.sup (fun n => (f.coeff n).natDegree)

@[reducible]
def FinalOracleStatement : Fin (k + 2) ‚Üí Type :=
  fun j =>
    if j.1 = k + 1
    then (Unit ‚Üí F[X])
    else (evalDomain D x (‚àë j' ‚àà finRangeTo j.1, s j') ‚Üí F)

Algebra.TensorProduct.instCommSemiring in Mathlib.RingTheory.TensorProduct.Basic

instance : Mul AssocNat where
  mul := mul

def finUInt32Equiv : Fin (2 ^ 32) ‚âÉ UInt32 where
  toFun := fun i => UInt32.ofFin i
  invFun := fun u => u.toFin
  left_inv _ := rfl
  right_inv _ := rfl

@[ext]
class OracleInterface (Message : Type u) where
  Query : Type v
  Response : Type w
  answer : Message ‚Üí Query ‚Üí Response

IO.throwServerError in Lean.Server.Utils

Nat.digits in Mathlib.Data.Nat.Digits.Defs

Fin.consInduction in Mathlib.Data.Fin.Tuple.Basic

Array.reverse in Init.Data.Array.Basic

Quotient.lift‚ÇÇ in Init.Core

Polynomial.degreeLT in Mathlib.RingTheory.Polynomial.Basic

def binaryAlgebraTower {l r : ‚Ñï} (h_le : l ‚â§ r) : Algebra (BTField l) (BTField r) :=

OracleSpec.QueryLog in VCVio.OracleComp.QueryTracking.Structures

Mathlib.Meta.NormNum.mkOfNat in Mathlib.Tactic.NormNum.Result

instance : SubSpec [pSpec‚ÇÇ.Challenge]‚Çí ([(pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).Challenge]‚Çí) where
  monadLift | query i t => instSubSpecOfProtocolSpecAppendChallenge.monadLift (query (Sum.inr i) t)

abbrev PermuteDir := Unit ‚äï Unit

@[reducible] def NonInteractiveProver (Message : Type) {Œπ : Type} (oSpec : OracleSpec Œπ)
    (StmtIn WitIn StmtOut WitOut : Type) :=
  Prover oSpec StmtIn WitIn StmtOut WitOut ‚ü®!v[.P_to_V], !v[Message]‚ü©

def drop {n : ‚Ñï} {Œ± : Fin n ‚Üí Sort*} (m : ‚Ñï) (h : m ‚â§ n) (v : (i : Fin n) ‚Üí Œ± i) :
    (i : Fin (n - m)) ‚Üí Œ± (Fin.cast (Nat.sub_add_cancel h) (addNat i m)) :=
  fun i ‚Ü¶ v (Fin.cast (Nat.sub_add_cancel h) (addNat i m))

Eq.mpr in Init.Core

evalDist in VCVio.EvalDist.Basic

guard in Init.Control.Basic

Equiv.ofBijective in Mathlib.Logic.Equiv.Defs

@[simp]
abbrev Witness.AfterSecondSumcheck : Type := Unit

def canonicalAlgMap (k : ‚Ñï) := concreteCanonicalEmbedding (k:=k)
  (prevBTFieldProps:= ((getBTFResult k).toConcreteBTFieldProps))
  (curBTFieldProps:= ((getBTFResult (k + 1)).toConcreteBTFieldProps))

@[ext]
structure VectorSpec (n : ‚Ñï) where
  dir : Fin n ‚Üí Direction
  length : Fin n ‚Üí Nat

def nil {Œ±} : Vector Œ± 0 := ‚ü®#[], rfl‚ü© 

@[inline] def sub [Zero T] [ToNat T] (a b : Cayley T) : Cayley T :=
  subNat a ‚Üëb

Module.Basis.reindex in Mathlib.LinearAlgebra.Basis.Defs

instance : NatCast (UniPoly R) := ‚ü®fun n => UniPoly.C (n : R)‚ü©

Polynomial.compRingHom in Mathlib.Algebra.Polynomial.Eval.Defs

noncomputable def ofPolynomialAlgHom : R[X] ‚Üí‚Çê[R] P := Polynomial.aeval PolynomialLike.X

noncomputable def relayOracleVerifier (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
  OracleVerifier
    (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) Context i.succ)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (pSpec := pSpecRelay) where
  verify := fun stmtIn _ => pure stmtIn
  embed := ‚ü®fun j => by admit /- proof elided -/
  ‚ü©
  hEq := fun oracleIdx => by admit /- proof elided -/

instance instDCastSigma {Œ± : Type*} {Œ≤ : Œ± ‚Üí Type*} {Œ≥ : (a : Œ±) ‚Üí Œ≤ a ‚Üí Type*}
    [DCast Œ± Œ≤] [DCast‚ÇÇ Œ± Œ≤ Œ≥] : DCast ((a : Œ±) √ó Œ≤ a) (fun a => Œ≥ a.1 a.2) where
  dcast hab c := dcast‚ÇÇ (by admit /- proof elided -/
  ) (by admit /- proof elided -/
  ) c
  dcast_id := by admit /- proof elided -/

def lastBlockOracleVerifier :=
  let bIdx := ‚Ñì / œë - 1
  let stmt : Fin (œë + 1) ‚Üí Type := fun i => Statement (L := L) (‚Ñì:=‚Ñì) Context
    ‚ü®bIdx * œë + i, by admit /- proof elided -/
    ‚ü©
  let oStmt := fun i: Fin (œë + 1) => OracleStatement ùîΩq Œ≤ œë
    ‚ü®bIdx * œë + i, by admit /- proof elided -/
    ‚ü©
  let V:  OracleVerifier []‚Çí (StmtIn := Statement (L := L) (‚Ñì := ‚Ñì) Context
      ‚ü®bIdx * œë, by admit /- proof elided -/
      ‚ü©)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë
      ‚ü®bIdx * œë, by admit /- proof elided -/
      ‚ü©)
    (StmtOut := Statement (L := L) (‚Ñì := ‚Ñì) Context (Fin.last ‚Ñì))
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (pSpec := pSpecLastBlock (L:=L) (œë:=œë)) := by admit /- proof elided -/

abbrev MultiquadraticPoly (L : Type) [CommSemiring L] (‚Ñì : ‚Ñï) := L‚¶É‚â§ 2‚¶Ñ[X Fin ‚Ñì]

instance instDCast‚ÇÇOracleProver : DCast‚ÇÇ Nat ProtocolSpec
    (fun _ pSpec => OracleProver oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec) where
  dcast‚ÇÇ := OracleProver.cast
  dcast‚ÇÇ_id := OracleProver.cast_id

Module.Basis.baseChange in Mathlib.LinearAlgebra.TensorProduct.Basis

Finset.card in Mathlib.Data.Finset.Card

def powAlgHom :
  MvPolynomial (Fin m) F ‚Üí‚Çê[F] Polynomial F :=
   aeval fun j => Polynomial.X ^ (2 ^ (j : ‚Ñï))

Nat.decLe in Init.Prelude

noncomputable def commitRbrExtractor (i : Fin ‚Ñì) :
  Extractor.RoundByRound []‚Çí
    (StmtIn := (Statement (L := L) Context i.succ) √ó (‚àÄ j, OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc j))
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (pSpec := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)
    (WitMid := fun _messageIdx => Witness (L := L) ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ) where
  eqIn := rfl
  extractMid := fun _ _ _ witMidSucc => witMidSucc
  extractOut := fun _ _ witOut => witOut

inductive FullData (Œ± : Type) : Skeleton ‚Üí Type
  | leaf (value : Œ±) : FullData Œ± Skeleton.leaf
  | internal {left right} (value : Œ±)
      (leftData : FullData Œ± left)
      (rightData : FullData Œ± right) :
      FullData Œ± (Skeleton.internal left right)
  deriving Repr

def JohnsonConditionStrong (B : Finset (Fin n ‚Üí F)) (v : Fin n ‚Üí F) : Prop :=
  let e := e B v
  let d := d B
  let q : ‚Ñö := Fintype.card F
  let frac := q / (q - 1)
  (1 - frac * d/n) < (1- frac * e/n) ^ 2

IsEmpty in Mathlib.Logic.IsEmpty

instance [ProverFirst pSpec] : ‚àÄ i, VCVCompatible (pSpec.Challenge i) := isEmptyElim

@[reducible]
def OracleStatement (i : Fin (k + 1)) : Fin (i.val + 1) ‚Üí Type :=
  fun j =>
    evalDomain D x (‚àë j' ‚àà finRangeTo j.1, s j')
      ‚Üí F

def oStmtLens (i : Fin n) : OracleStatement.Lens
    (StatementRound R n i.castSucc) (StatementRound R n i.succ) (Simple.StmtIn R) (Simple.StmtOut R)
    (OracleStatement R n deg) (OracleStatement R n deg)
    (Simple.OStmtIn R deg) (Simple.OStmtOut R deg) where

  toFunA := fun ‚ü®‚ü®target, challenges‚ü©, oStmt‚ü© =>
    ‚ü®target, fun _ =>
      match h : n with
      | 0 => ‚ü®Polynomial.C <| MvPolynomial.isEmptyAlgEquiv R (Fin 0) (oStmt ()), by admit /- proof elided -/
        ‚ü©
      | n + 1 =>
      ‚ü®‚àë x ‚àà (univ.map D) ^·∂† (n - i), (oStmt ()).val ‚∏®X ‚¶Éi‚¶Ñ, challenges, x‚∏©'(by admit /- proof elided -/
      ),
        sumcheck_roundPoly_degreeLE R n deg D i (oStmt ()).property‚ü©‚ü©

  toFunB := fun ‚ü®‚ü®_oldTarget, challenges‚ü©, oStmt‚ü© ‚ü®‚ü®newTarget, chal‚ü©, oStmt'‚ü© =>
    ‚ü®‚ü®newTarget, Fin.snoc challenges chal‚ü©, oStmt‚ü©

instance : Fintype ((pSpec OStatement).Challenge ‚ü®0, by simp‚ü©) :=

def OracleProver.addSalt (P : OracleProver oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec)
    (saltComp : (i : pSpec.MessageIdx) ‚Üí P.PrvState i.1.castSucc ‚Üí OracleComp oSpec (Salt i)) :
  OracleProver oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut (pSpec.addSalt Salt) :=
  Prover.addSalt Salt P saltComp

def append (T‚ÇÅ : FullTranscript pSpec‚ÇÅ) (T‚ÇÇ : FullTranscript pSpec‚ÇÇ) :
    FullTranscript (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ) :=
  Fin.happend T‚ÇÅ T‚ÇÇ

Finset.image in Mathlib.Data.Finset.Image

@[reducible]
def spec : OracleSpec Unit := fun _ => (Œ± √ó Œ±, Œ±)

noncomputable def finalSumcheckProver :
  OracleProver
    (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì))
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì))
    (StmtOut := FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì))
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (WitOut := Unit)
    (pSpec := pSpecFinalSumcheckStep (L := L)) where
  PrvState := fun
    | 0 => Statement (L := L) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì) √ó (‚àÄ j, OracleStatement ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì) j)
        √ó Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì)
    | _ => Statement (L := L) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì) √ó (‚àÄ j, OracleStatement ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì) j)
        √ó Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì) √ó L
  input := fun ‚ü®‚ü®stmt, oStmt‚ü©, wit‚ü© => (stmt, oStmt, wit)

  sendMessage
  | ‚ü®0, _‚ü© => fun ‚ü®stmtIn, oStmtIn, witIn‚ü© => do
    let f‚Ñì : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := ‚ü®‚Ñì, by admit /- proof elided -/
    ‚ü©)
      := witIn.f
    
    let c : L := f‚Ñì ‚ü®0, by admit /- proof elided -/
    ‚ü© 
    pure ‚ü®c, (stmtIn, oStmtIn, witIn, c)‚ü©

  receiveChallenge
  | ‚ü®0, h‚ü© => nomatch h 

  output := fun ‚ü®stmtIn, oStmtIn, witIn, c‚ü© => do
    let stmtOut : FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì) := {
      ctx := stmtIn.ctx,
      
      sumcheck_target := stmtIn.sumcheck_target,
      challenges := stmtIn.challenges,
      final_constant := c
    }

    pure (‚ü®stmtOut, oStmtIn‚ü©, ())

Polynomial.C in Mathlib.Algebra.Polynomial.Basic

def multiConstrainedCode
  (domain : Œπ ‚Ü™ F) [Smooth domain] (m t : ‚Ñï)
  (w : Fin t ‚Üí MvPolynomial (Fin (m + 1)) F)
  (œÉ : Fin t ‚Üí F) : Set (Œπ ‚Üí F) :=
    { f |
      ‚àÉ (h : f ‚àà smoothCode domain m),
        ‚àÄ i : Fin t, weightConstraint (mVdecode (‚ü®f, h‚ü© : smoothCode domain m)) (w i) (œÉ i)}

Submodule.span in Mathlib.LinearAlgebra.Span.Defs

def snd (T : (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).Transcript k) : pSpec‚ÇÇ.Transcript ‚ü®k - m, by admit /- proof elided -/
‚ü© :=
  if hk : k ‚â§ m then
    fun i => Fin.elim0 (by admit /- proof elided -/
    )
  else
    fun i => sorry

class SmoothPowerOfTwo (n : ‚Ñï) (G : Type) [Pow G ‚Ñ§] [Monoid G] [inst : IsCyclicWithGen G] where
  smooth : orderOf inst.gen = 2 ^ n

@[reducible]
def pSpec : ProtocolSpec 2 :=
  ‚ü®
    !v[.V_to_P, .P_to_V],
    !v[
        F,
        (evalDomain D x (‚àë j' ‚àà (List.take (i.1 + 1) (List.finRange (k + 1))).toFinset, s j')) ‚Üí F
      ]
  ‚ü©

def fconcat {A : Sort u} {F : A ‚Üí Sort v} {n : ‚Ñï} {Œ± : Fin n ‚Üí A} {Œ≤ : A}
    (u : (i : Fin n) ‚Üí F (Œ± i)) (a : F Œ≤) : (i : Fin (n + 1)) ‚Üí F (Fin.vconcat Œ± Œ≤ i) :=
  match n with
  | 0 => fun i => match i with | 0 => a
  | _ + 1 => fcons (u 0) (fconcat (fun i => u (Fin.succ i)) a)

Nat.iterate in Mathlib.Logic.Function.Iterate

@[reducible]
def OracleStatement : Unit ‚Üí Type := fun _ => R‚¶É‚â§ deg‚¶Ñ[X Fin n]

@[reducible, simp]
def relIn : Set (Statement √ó Unit) := { ‚ü®stmt, _‚ü© | pred stmt }

instance : ‚àÄ i, SelectableType (Challenge ‚ü®!v[.P_to_V], !v[Msg]‚ü© i)
  | ‚ü®0, h‚ü© => nomatch h

noncomputable def queryVerifier (k_le_n : (‚àë j', (s j').1) ‚â§ n) (l : ‚Ñï) [DecidableEq F] :
  OracleVerifier []‚Çí
    (FinalStatement F k) (FinalOracleStatement D x s)
    (FinalStatement F k) (FinalOracleStatement D x s)
    (pSpec D x l) where
  verify := fun prevChallenges roundChallenge => do
    let (p : F[X]) ‚Üê getConst D x k s
    for m in (List.finRange l) do
      let s‚ÇÄ := roundChallenge ‚ü®1, by admit /- proof elided -/
      ‚ü© m
      discard <|
        (List.finRange (k + 1)).mapM
              (fun i =>
                do
                  let x‚ÇÄ := prevChallenges i
                  let s‚ÇÄ :
                    evalDomain D x
                      (‚àë j' ‚àà finRangeTo i.1, (s j').1) :=
                    ‚ü®_, pow_2_pow_i_mem_Di_of_mem_D _ s‚ÇÄ.2‚ü©
                  let queries :
                    List (
                      evalDomain D x
                        (‚àë j' ‚àà finRangeTo i.1, (s j').1)
                    ) :=
                    List.map
                      (fun r =>
                        ‚ü®
                          _,
                          CosetDomain.mul_root_of_unity D (roots_of_unity_lem k_le_n) s‚ÇÄ.2 r.2
                        ‚ü©
                      )
                      (Domain.rootsOfUnity D n (s i))
                  let (pts : List (F √ó F)) ‚Üê
                    List.mapM
                      (fun q => queryCodeword D x k s q >>= fun v => pure (q.1.1, v))
                      queries
                  let Œ≤ ‚Üê
                    if h : i.1 < k
                    then
                      have := CosetDomain.pow_lift D x (s i).1 s‚ÇÄ.2
                      queryCodeword D x k s (i := ‚ü®i.1.succ, Order.lt_add_one_iff.mpr h‚ü©)
                        ‚ü®_, by admit /- proof elided -/
                        ‚ü©
                    else
                      pure (p.eval (s‚ÇÄ.1.1 ^ (2 ^ (s (Fin.last k)).1)))
                  guard (RoundConsistency.roundConsistencyCheck x‚ÇÄ pts Œ≤)
              )
    pure prevChallenges
  embed :=
    ‚ü®
      fun j => Sum.inl j,
      by admit /- proof elided -/
    ‚ü©
  hEq := by admit /- proof elided -/

instance : Fact (Nat.Prime BASE_FIELD_CARD) := ‚ü®BaseField_is_prime‚ü©

def sumPartial (m : ‚Ñï) (n : ‚Ñï) (D : Fin n ‚Üí Finset R) :
    MvPolynomial (Fin (m + n)) R ‚Üí‚Çó[R] MvPolynomial (Fin m) R where
  toFun := fun p => ‚àë x ‚àà Fintype.piFinset D, peval (Fin.sumCommEquiv m n) x p
  map_add' := fun p q => by admit /- proof elided -/

noncomputable def toPoly' (p : UniPoly R) : Polynomial R :=
  Polynomial.ofFinsupp (Finsupp.onFinset (Finset.range p.size) p.coeff (by admit /- proof elided -/
  ))

abbrev BTF‚ÇÉ := ConcreteBTField 3 

noncomputable def finalSumcheckRbrExtractor :
  Extractor.RoundByRound []‚Çí
    (StmtIn := (Statement (L := L) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì)) √ó (‚àÄ j, OracleStatement ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë  (Fin.last ‚Ñì) j))
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì))
    (WitOut := Unit)
    (pSpec := pSpecFinalSumcheckStep (L := L))
    (WitMid := FinalSumcheckWit (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì)) where
  eqIn := rfl
  extractMid := fun m ‚ü®stmtMid, oStmtMid‚ü© trSucc witMidSucc => by admit /- proof elided -/
    | none => 
      exact dummyLastWitness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
    | some tpoly =>
      
      exact {
        t := tpoly,
        H := projectToMidSumcheckPoly (L := L) (‚Ñì := ‚Ñì) (t := tpoly)
          (m := BBF_SumcheckMultiplierParam.multpoly stmtMid.ctx)
          (i := Fin.last ‚Ñì) (challenges := stmtMid.challenges),
        f := getMidCodewords ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) tpoly stmtMid.challenges
      }
  extractOut := fun ‚ü®stmtIn, oStmtIn‚ü© tr witOut => ()

def InnerStmtOut_Test := ‚Ñ§[X] √ó ‚Ñ§ √ó ‚Ñ§

def inputRelation : Set ((StmtIn R √ó (‚àÄ i, OStmtIn R deg i)) √ó Unit) :=
  { ‚ü®‚ü®target, oStmt‚ü©, _‚ü© | ‚àë x ‚àà (univ.map D), (oStmt ()).1.eval x = target }

def monoToLagrange_segment (n : ‚Ñï) (r : Fin n) (l : Fin (r.val + 1)) :
    Vector R (2 ^ n) ‚Üí Vector R (2 ^ n) :=
  let range := forwardRange n r l
  (range.foldl (fun acc h => monoToLagrangeLevel h acc))

def minDist [DecidableEq F] (IC : MatrixSubmodule Œ∫ Œπ F) : ‚Ñï :=
  sInf { d : ‚Ñï | ‚àÉ U ‚àà IC, ‚àÉ V ‚àà IC, distCodewords U V = d }

Int.ofNat in Init.Data.Int.Basic

def extractNextSuffixFromChallenge (v : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®0, by omega‚ü©)
    (i : ‚Ñï) (h_i_add_œë_le_‚Ñì : i + œë ‚â§ ‚Ñì) :
    (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®i + œë, by omega‚ü© :=

noncomputable def fold_k_core {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F} (f : (indexPowT S œÜ 0) ‚Üí F)
  [‚àÄ i : ‚Ñï, Neg (indexPowT S œÜ i)] : (i : ‚Ñï) ‚Üí (Œ±s : Fin i ‚Üí F) ‚Üí
    indexPowT S œÜ i ‚Üí F
| 0, _ => fun x‚ÇÄ => f x‚ÇÄ
| k+1, Œ±s => fun y =>
    let Œ± := Œ±s 0
    let Œ±s' : Fin k ‚Üí F := fun i => Œ±s (Fin.succ i)
    let fk := fold_k_core f k Œ±s'
    foldf S œÜ y fk Œ±

def params24 : Params where
  width := 24
  numFullRounds := 8
  numPartialRounds := 23
  internalDiagVectors := #v[
        -2,
        1,
        2,
        1 / 2,
        3,
        4,
        -1 / 2,
        -3,
        -4,
        1 / (2 ^ 8),
        1 / 4,
        1 / 8,
        1 / 16,
        1 / 32,
        1 / 64,
        1 / (2 ^ 24),
        -1 / (2 ^ 8),
        -1 / 8,
        -1 / 16,
        -1 / 32,
        -1 / 64,
        -1 / (2 ^ 7),
        -1 / (2 ^ 9),
        -1 / (2 ^ 24)
    ]
  roundConstants := RAW_CONSTANTS_24
  width_dvd_by_4 := by admit /- proof elided -/

def perfectCompleteness
    (relIn : Set ((StmtIn √ó ‚àÄ i, OStmtIn i) √ó WitIn))
    (relOut : Set ((StmtOut √ó ‚àÄ i, OStmtOut i) √ó WitOut))
    (oracleReduction : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec) :
      Prop :=
  Reduction.perfectCompleteness init impl relIn relOut oracleReduction.toReduction

noncomputable def modBivar (P P' : MvPolynomial (Fin 2) F)
    (hlg : IsUnit ((MonomialOrder.lex).leadingCoeff P')) : MvPolynomial (Fin 2) F :=
      
      let ord : MonomialOrder (Fin 2) := MonomialOrder.lex
      
      let b : Unit ‚Üí MvPolynomial (Fin 2) F := fun _ => P'
      
      have hb : ‚àÄ i : Unit, IsUnit (ord.leadingCoeff (b i)) := by admit /- proof elided -/

def commit (v : Œ±) : OracleComp (oSpec Œ± Œ≤ Œ≥) Œ≥ := do
  let r : Œ≤ ‚Üê liftComp
    (query (spec := randSpec Œ≤) () () : OracleComp (randSpec Œ≤) Œ≤) _
  let cm : Œ≥ ‚Üê liftComp
    (query (spec := ROspec Œ± Œ≤ Œ≥) () (v, r) : OracleComp (ROspec Œ± Œ≤ Œ≥) Œ≥) _
  return cm

protected def basis : F := sorry

AffineSubspace.pointwiseVAdd in Mathlib.LinearAlgebra.AffineSpace.Pointwise

def natWeightedDegree.{u} {F : Type u} [Semiring F] (f : F[X][Y]) (u v : ‚Ñï) : ‚Ñï :=
  f.support.sup (fun m => u * (f.coeff m).natDegree + v * m)

Fintype.decidablePiFintype in Mathlib.Data.Fintype.Defs

def rbrKnowledgeSoundnessOneShot (relIn : Set (StmtIn √ó WitIn)) (relOut : Set (StmtOut √ó WitOut))
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    (rbrKnowledgeError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) : Prop :=
  ‚àÉ stateFunction : verifier.KnowledgeStateFunctionOneShot init impl relIn.language relOut.language,
  ‚àÉ extractor : Extractor.RoundByRoundOneShot oSpec StmtIn WitIn pSpec,
  ‚àÄ stmtIn : StmtIn,
  ‚àÄ witIn : WitIn,
  ‚àÄ prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec,
  ‚àÄ i : pSpec.ChallengeIdx,
    [fun ‚ü®transcript, challenge, proveQueryLog‚ü© =>
      letI extractedWitIn := extractor i.1.castSucc stmtIn transcript proveQueryLog.fst
      (stmtIn, extractedWitIn) ‚àâ relIn ‚àß
        ¬¨ stateFunction i.1.castSucc stmtIn transcript ‚àß
          stateFunction i.1.succ stmtIn (transcript.concat challenge)
    | do
      (simulateQ (impl ++‚Çõ‚Çí challengeQueryImpl : QueryImpl _ (StateT œÉ ProbComp))
        (do
          let ‚ü®‚ü®transcript, _‚ü©, proveQueryLog‚ü© ‚Üê prover.runWithLogToRound i.1.castSucc stmtIn witIn
          let challenge ‚Üê liftComp (pSpec.getChallenge i) _
          return (transcript, challenge, proveQueryLog))).run' (‚Üê init)] ‚â§
      rbrKnowledgeError i

instance : Zero AssocNat where
  zero := zero

class IsSecureWithGap
    (completeRelation : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (soundRelation : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (Œµ_rbr : vPSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0)
    (vectorIOP : VectorIOP Statement OStatement Witness vPSpec A) where

   
  is_complete : vectorIOP.perfectCompleteness (pure ()) ‚ü®isEmptyElim‚ü© completeRelation

   
  is_rbr_knowledge_sound :
    OracleProof.rbrKnowledgeSoundness (pure ()) ‚ü®isEmptyElim‚ü© soundRelation vectorIOP.verifier Œµ_rbr

Finsupp in Mathlib.Data.Finsupp.Defs

@[reducible]
def permutationOracle (Œ± : Type*) : OracleSpec PermuteDir :=
  forwardPermutationOracle Œ± ++‚Çí backwardPermutationOracle Œ±

Vector.replicate in Init.Data.Vector.Basic

protected def cast (T : FullTranscript pSpec‚ÇÅ) :
    FullTranscript pSpec‚ÇÇ :=
  Transcript.cast (k := Fin.last n‚ÇÅ) (l := Fin.last n‚ÇÇ) hn hn hSpec T

def StateRestoration.KnowledgeSoundness (oSpec : OracleSpec Œπ) (StmtIn WitOut : Type)
    {n : ‚Ñï} (pSpec : ProtocolSpec n) :=
  OracleComp (oSpec ++‚Çí (srChallengeOracle StmtIn pSpec)) (StmtIn √ó pSpec.Messages √ó WitOut)

instance instCharP2 {k : ‚Ñï} : CharP (ConcreteBTField k) 2 :=
  charP_eq_2_of_add_self_eq_zero (F:=(ConcreteBTField k)) (sumZeroIffEq:=add_eq_zero_iff_eq)

instance [Inhabited C] [Permute C] : DuplexSpongeInterface U (DuplexSponge U C) where
  absorbUnchecked := fun (sponge, arr) => absorbUnchecked sponge arr
  squeezeUnchecked := fun (sponge, arr) => squeezeUnchecked sponge arr
  ratchetUnchecked := ratchetUnchecked

@[simp]
abbrev OracleStatement.AfterFirstMessage : R1CS.MatrixIdx ‚äï Fin 1 ‚Üí Type :=
  Sum.rec (OracleStatement R pp) (fun _ => Witness R pp)

noncomputable def œÄ_z_lift {H : F[X][Y]} (z : F) (root : rationalRoot (H_tilde' H) z) :
  F[X][Y] ‚Üí+* F := Polynomial.evalEvalRingHom z root.1

@[inline]
def add [Add R] (p q : MlPolyEval R n) : MlPolyEval R n := Vector.zipWith (¬∑ + ¬∑) p q

Nat.max in Init.Data.Nat.Basic

def finUInt8Equiv : Fin (2 ^ 8) ‚âÉ UInt8 where
  toFun := fun i => UInt8.ofFin i
  invFun := fun u => u.toFin
  left_inv _ := rfl
  right_inv _ := rfl

@[inline, specialize]
def mul (p q : UniPoly R) : UniPoly R :=
  p.zipIdx.foldl (fun acc ‚ü®a, i‚ü© => acc.add <| (smul a q).mulPowX i) (C 0)

noncomputable def J (q Œ¥ : ‚Ñö) : ‚Ñù :=
  let frac := q / (q - 1)
  (1 / frac) * (1 - Real.sqrt (1 - frac * Œ¥))

class IsSound (langIn : Set StmtIn) (langOut : Set StmtOut)
    (verifier : Verifier oSpec StmtIn StmtOut pSpec) where
  soundnessError : ‚Ñù‚â•0
  is_sound : soundness init impl langIn langOut verifier soundnessError

Units.val in Mathlib.Algebra.Group.Units.Defs

def someValues : HList' (fun x => x) someTypes :=
  HList'.cons 1 (HList'.cons "bad" (HList'.cons 3 HList'.nil))

def Reduction.append (R‚ÇÅ : Reduction oSpec Stmt‚ÇÅ Wit‚ÇÅ Stmt‚ÇÇ Wit‚ÇÇ pSpec‚ÇÅ)
    (R‚ÇÇ : Reduction oSpec Stmt‚ÇÇ Wit‚ÇÇ Stmt‚ÇÉ Wit‚ÇÉ pSpec‚ÇÇ) :
      Reduction oSpec Stmt‚ÇÅ Wit‚ÇÅ Stmt‚ÇÉ Wit‚ÇÉ (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ) where
  prover := Prover.append R‚ÇÅ.prover R‚ÇÇ.prover
  verifier := Verifier.append R‚ÇÅ.verifier R‚ÇÇ.verifier

instance {i : Fin (n + 1)} : OfNat (evalDomain D i) 1 where
  ofNat := ‚ü®1, one_in_doms D i‚ü©

MonadLift.monadLift in Init.Prelude

noncomputable def relayRbrExtractor (i : Fin ‚Ñì) :
  Extractor.RoundByRound []‚Çí
    (StmtIn := (Statement (L := L) Context i.succ) √ó (‚àÄ j, OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc j))
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (pSpec := pSpecRelay)
    (WitMid := fun _messageIdx => Witness (L := L) ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ) where
  eqIn := rfl
  extractMid := fun _ _ _ witMidSucc => witMidSucc
  extractOut := fun _ _ witOut => witOut

List.IsPrefix in Init.Data.List.Basic

instance : DecidableEq BTF‚ÇÉ := (inferInstance : DecidableEq (ConcreteBTField 3))

Polynomial.rootMultiplicity in Mathlib.Algebra.Polynomial.Div

Nat.floor in Mathlib.Algebra.Order.Floor.Defs

def rightpad {m : ‚Ñï} {Œ± : Sort*} (n : ‚Ñï) (a : Œ±) (v : Fin m ‚Üí Œ±) : Fin n ‚Üí Œ± :=
  fun i => if h : i < m then v ‚ü®i, h‚ü© else a

def singleHash (left : Œ±) (right : Œ±) : OracleComp (spec Œ±) Œ± := do
  let out ‚Üê query (spec := spec Œ±) () ‚ü®left, right‚ü©
  return out

instance : ‚àÄ i, OracleInterface (Message !p[] i) :=
  fun ‚ü®i, h‚ü© =>
    (Fin.elim0 i : (h' : !p[].dir i = .P_to_V) ‚Üí OracleInterface (!p[].Message ‚ü®i, h'‚ü©)) h

protected def Reduction.id : Reduction oSpec Statement Witness Statement Witness !p[] where
  prover := Prover.id
  verifier := Verifier.id

structure Opening where
  opening : Proof oSpec (Commitment √ó O.Query √ó O.Response) (Data √ó Randomness) pSpec

instance finiteDimensional_degreeLT {n : ‚Ñï} (h_n_pos : 0 < n) :
  FiniteDimensional L L‚¶É< n‚¶Ñ[X] :=

def lift {Œπ‚ÇÅ Œπ‚ÇÇ Œπ : Type} {œÉ : Type} (oSpec‚ÇÅ : OracleSpec Œπ‚ÇÅ) (oSpec‚ÇÇ : OracleSpec Œπ‚ÇÇ)
    (oSpec : OracleSpec Œπ) (so : SimOracle.Stateful oSpec‚ÇÅ oSpec‚ÇÇ œÉ) :
      SimOracle.Stateful (oSpec ++‚Çí oSpec‚ÇÅ) (oSpec ++‚Çí oSpec‚ÇÇ) œÉ where
  impl := fun q s => match q with
    | query (.inl i) q => do return ‚ü®‚Üê query i q, s‚ü©
    | query (.inr i) q => so.impl (query (spec := oSpec‚ÇÅ) i q) s

slice in Mathlib.Tactic.CategoryTheory.Slice

def InternalData.leftSubtree {Œ± : Type} {s_left s_right : Skeleton}
    (tree : InternalData Œ± (Skeleton.internal s_left s_right)) :
    InternalData Œ± s_left :=
  match tree with
  | InternalData.internal _ left _right =>
    left

noncomputable def blockRelDistance
  (i k : ‚Ñï) {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F}
  [DecidableEq F] [DecidableEq Œπ] [Smooth œÜ]
  (f : (indexPowT S œÜ i) ‚Üí F) (S' : Finset (indexPowT S œÜ i))
  (œÜ' : (indexPowT S œÜ i) ‚Ü™ F) [‚àÄ i : ‚Ñï, Fintype (indexPowT S œÜ i)]
  [h : DecidableBlockDisagreement i k f S' œÜ'] :
  (g : (indexPowT S œÜ i) ‚Üí F) ‚Üí ‚Ñù‚â•0 :=
  fun g =>
    (disagreementSet i k f S' œÜ' g).card / (Fintype.card (indexPowT S œÜ k) : ‚Ñù‚â•0)

System.FilePath in Init.System.FilePath

instance instHDivConcreteBTF {k : ‚Ñï} : HDiv (ConcreteBTField k) (ConcreteBTField k)
  (ConcreteBTField k) where hDiv a b := a * (concrete_inv b)

Algebra.TensorProduct.includeRight in Mathlib.RingTheory.TensorProduct.Basic

instance (i : Fin 0) : OracleInterface i.elim0 := Fin.elim0 i

def perm (cs : ConstraintSystem ùì° numWires numGates) : Equiv.Perm (Fin (3 * numGates)) := sorry

Fin.add in Init.Data.Fin.Basic

def trans (eqv : Equiv pSpec pSpec') (eqv' : Equiv pSpec' pSpec'') : Equiv pSpec pSpec'' where
  round_eq := eqv.round_eq.trans eqv'.round_eq
  dir_eq := fun i => by admit /- proof elided -/

def BerlekampWelchMatrix
  (e k : ‚Ñï)
  (œâs f : Fin n ‚Üí F) : Matrix (Fin n) (Fin (2 * e + k)) F :=
  Matrix.of fun i j =>
    let Œ±·µ¢ := œâs i
    if ‚Üëj < e then -Rhs j.1 œâs f i else -Œ±·µ¢^(j - e)

def badEventExistsProp
    (stmtIdx : Fin (‚Ñì + 1)) (oracleIdx : Fin (‚Ñì + 1))
    (oStmt : ‚àÄ j, (OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (i := oracleIdx) j))
    (challenges : Fin stmtIdx ‚Üí L) : Prop :=
  ‚àÉ j, foldingBadEventAtBlock ùîΩq Œ≤ (stmtIdx := stmtIdx) (oracleIdx := oracleIdx)
    (oStmt := oStmt) (challenges := challenges) j

def forwardPermutationOracleImpl {Œ± : Type*} [Permute Œ±] :
    QueryImpl (forwardPermutationOracle Œ±) Id where
  impl | query () q => Permute.permute (Œ± := Œ±) q

@[inline, specialize]
def oracleProver : OracleProver oSpec
    Statement OStatement (‚àÄ i, Witness i)
    Statement (OStatement ‚äï·µ• Witness) Unit
    (oraclePSpec Witness) where
  PrvState := fun _ => (Statement √ó (‚àÄ i, OStatement i)) √ó (‚àÄ i, Witness i)
  input := id
  sendMessage | ‚ü®0, _‚ü© => fun ‚ü®stmt, wit‚ü© => pure (wit, ‚ü®stmt, wit‚ü©)
  
  receiveChallenge | ‚ü®0, h‚ü© => nomatch h
  output := fun ‚ü®‚ü®stmt, oStmt‚ü©, wit‚ü© => pure (‚ü®stmt, Sum.rec oStmt wit‚ü©, ())

def choose_2 (x : ‚Ñö) : ‚Ñö := x * (x-1)/2

def intCast_ofNat {k : ‚Ñï} (n : ‚Ñï) : intCast (k:=k) (n : ‚Ñ§) = natCast n :=

def LeafData.get {s} {Œ± : Type}
    (tree : LeafData Œ± s) (idx : SkeletonLeafIndex s) : Œ± :=
  match tree, idx with
  | LeafData.leaf value, SkeletonLeafIndex.ofLeaf => value
  | LeafData.internal left _, SkeletonLeafIndex.ofLeft idxLeft =>
    LeafData.get left idxLeft
  | LeafData.internal _ right, SkeletonLeafIndex.ofRight idxRight =>
    LeafData.get right idxRight

def twoAdicGenerators : List Field :=
  [
    (0x1 : Field),
    (0x7F000000 : Field),
    (0x7E010002 : Field),
    (0x6832FE4A : Field),
    (0x8DBD69C : Field),
    (0xA28F031 : Field),
    (0x5C4A5B99 : Field),
    (0x29B75A80 : Field),
    (0x17668B8A : Field),
    (0x27AD539B : Field),
    (0x334D48C7 : Field),
    (0x7744959C : Field),
    (0x768FC6FA : Field),
    (0x303964B2 : Field),
    (0x3E687D4D : Field),
    (0x45A60E61 : Field),
    (0x6E2F4D7A : Field),
    (0x163BD499 : Field),
    (0x6C4A8A45 : Field),
    (0x143EF899 : Field),
    (0x514DDCAD : Field),
    (0x484EF19B : Field),
    (0x205D63C3 : Field),
    (0x68E7DD49 : Field),
    (0x6AC49F88 : Field)
  ]

@[reducible]
def pSpec : ProtocolSpec 1 := ‚ü®!v[.V_to_P], !v[Query OStatement]‚ü©

def params16 : Params where
  width := 16
  numFullRounds := 8
  numPartialRounds := 20
  internalDiagVectors := #v[
       -2,
        1,
        2,
        1 / 2,
        3,
        4,
        -1 / 2,
        -3,
        -4,
        1 / (2 ^ 8),
        1 / 8,
        1 / (2 ^ 24),
        -1 / (2 ^ 8),
        -1 / 8,
        -1 / 16,
        -1 / (2 ^ 24),
    ]
  roundConstants := rawConstants16
  width_dvd_by_4 := by admit /- proof elided -/

def concrete_pow_nat {k : ‚Ñï} (x : ConcreteBTField k) (n : ‚Ñï) : ConcreteBTField k :=
  if n = 0 then one
  else if n % 2 = 0 then concrete_pow_nat (concrete_mul x x) (n / 2)
  else concrete_mul x (concrete_pow_nat (concrete_mul x x) (n / 2))

def e (B : Finset (Fin n ‚Üí F)) (v : Fin n ‚Üí F) : ‚Ñö :=
  (1 : ‚Ñö)/B.card * ‚àë x ‚àà B, Œî‚ÇÄ(v, x)

Neg.neg in Init.Prelude

tail in ToMathlib.Control.Comonad.Instances

def getTypes {Œ±s : List Type} (_ : HList Œ±s) : List Type := Œ±s

structure InterleavedCode (Œ∫ Œπ : Type*) [Fintype Œ∫] [Fintype Œπ] (F : Type*) [Semiring F] where
  MF : MatrixSubmodule Œ∫ Œπ F
  LC : LinearCode Œπ F

def possibleDistsToCode (w : Œπ ‚Üí F) (C : Set (Œπ ‚Üí F)) (Œ¥f : (Œπ ‚Üí F) ‚Üí (Œπ ‚Üí F) ‚Üí Œ±) : Set Œ± :=
  {d : Œ± | ‚àÉ c ‚àà C, c ‚â† w ‚àß Œ¥f w c = d}

Group in Mathlib.Algebra.Group.Defs

Module.finrank in Mathlib.LinearAlgebra.Dimension.Finrank

multiplicity in Mathlib.RingTheory.Multiplicity

def distToCode [DecidableEq F] (U : Matrix Œ∫ Œπ F) (IC : MatrixSubmodule Œ∫ Œπ F) : ‚Ñï :=
 sInf { d : ‚Ñï | ‚àÉ V ‚àà IC, distCodewords U V = d }

abbrev contract (m : ‚Ñï) (f : Fin n ‚Üí Œ±) := liftF (liftF' (n := m) (liftF f))

Quotient.mk in Init.Core

structure Selector (ùì° : Type*) where
   
  qL : ùì°
   
  qR : ùì°
   
  qO : ùì°
   
  qM : ùì°
   
  qC : ùì°
deriving DecidableEq

def toMessagesChallenges (transcript : Transcript k pSpec) :
    MessagesUpTo k pSpec √ó ChallengesUpTo k pSpec :=
  (transcript.toMessagesUpTo, transcript.toChallengesUpTo)

noncomputable def foldf (S : Finset Œπ) (œÜ : Œπ ‚Ü™ F)
  {k : ‚Ñï} [Neg (indexPowT S œÜ k)] (y : indexPowT S œÜ (k + 1))
  (f : indexPowT S œÜ k ‚Üí F) (Œ± : F) : F :=
  let xPow := extract_x S œÜ k y
  let fx := f xPow
  let f_negx := f (-xPow)
  (fx + f_negx) / 2 + Œ± * ((fx - f_negx) / (2 * (xPow.val : F)))

SetLike in Mathlib.Data.SetLike.Basic

@[inline]
def ofOutputOnly
    (witLift :
      OuterStmtIn √ó OuterWitIn ‚Üí InnerStmtOut √ó InnerWitOut ‚Üí OuterWitOut)
    (stmtLift : OuterStmtIn ‚Üí InnerStmtOut ‚Üí OuterStmtOut) :
    Context.Lens OuterStmtIn OuterStmtOut OuterStmtIn InnerStmtOut
                OuterWitIn OuterWitOut OuterWitIn InnerWitOut where
  wit := Witness.Lens.ofOutputOnly witLift
  stmt := Statement.Lens.ofOutputOnly stmtLift

@[reducible, simp] def StmtIn : Type := R

instance [IsSingleRound pSpec] : Unique (pSpec.MessageIdx) where
  default := ‚ü®0, by admit /- proof elided -/
  ‚ü©
  uniq := fun ‚ü®i, hi‚ü© => by admit /- proof elided -/

def Prover.addSalt (P : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec)
    (saltComp : (i : pSpec.MessageIdx) ‚Üí P.PrvState i.1.castSucc ‚Üí OracleComp oSpec (Salt i)) :
  Prover oSpec StmtIn WitIn StmtOut WitOut (pSpec.addSalt Salt) where
  PrvState := P.PrvState
  input := P.input
  sendMessage := fun i st => by admit /- proof elided -/

Algebra.TensorProduct.instAlgebra in Mathlib.RingTheory.TensorProduct.Basic

def evalWAt (i : Fin r) (x : L) : L :=
  ((getUElements (Œ≤ := Œ≤) (‚Ñì := ‚Ñì) (R_rate := R_rate) i).map (fun u => x - u)).prod

instance [Repr Œ±] (Œ±s : List Type) [HListRepr (HList Œ±s)] : HListRepr (HList (Œ± :: Œ±s)) where
  repr
  | HList.cons x xs =>
    match xs with
    | HList.nil => reprPrec x 0
    | HList.cons _ _ => reprPrec x 0 ++ ", " ++ HListRepr.repr xs

Membership in Init.Prelude

def ri (dstar : ‚Ñï) (degs : Fin m ‚Üí ‚Ñï) (r : F) (i : Fin m) : F :=
          match i.1 with
          | 0 => 1
          | .succ i' =>
            let exp := i' + ‚àë j < i, (dstar - degs j)
            r ^ exp

List.mergeSort in Init.Data.List.Sort.Basic

@[reducible, simp] def WitOut := Unit

def eval‚ÇÇ [Semiring S] (f : R ‚Üí+* S) (x : S) (p : UniPoly R) : S :=
  p.zipIdx.foldl (fun acc ‚ü®a, i‚ü© => acc + f a * x ^ i) 0

AdjoinRoot in Mathlib.RingTheory.AdjoinRoot

Quotient.lift in Init.Core

inductive Skeleton :
    (n : ‚Ñï) ‚Üí (ar : Fin n ‚Üí ‚Ñï) ‚Üí Type where
  | leaf {ar0 : Fin 0 ‚Üí ‚Ñï} : Skeleton 0 ar0
  | node {n : ‚Ñï} {ar : Fin (n+1) ‚Üí ‚Ñï}
      (children : Fin (ar 0) ‚Üí
        Skeleton n (fun i => ar i.succ)) :
      Skeleton (n+1) ar

instance {n : ‚Ñï} : ToString (UnverifiedPrattCertificate n) where
  toString := fun c => s!"{repr c}"

def KnowledgeStateFunction.toStateFunction
    {relIn : Set (StmtIn √ó WitIn)} {relOut : Set (StmtOut √ó WitOut)}
    {verifier : Verifier oSpec StmtIn StmtOut pSpec} {WitMid : Fin (n + 1) ‚Üí Type}
    {extractor : Extractor.RoundByRound oSpec StmtIn WitIn WitOut pSpec WitMid}
    (kSF : KnowledgeStateFunction init impl relIn relOut verifier extractor) :
      verifier.StateFunction init impl relIn.language relOut.language where
  toFun := fun m stmtIn tr => ‚àÉ witMid, kSF.toFun m stmtIn tr witMid
  toFun_empty := by admit /- proof elided -/

GroupWithZero in Mathlib.Algebra.GroupWithZero.Defs

def erase_even (s : Finset ‚Ñï) : Finset ‚Ñï := s.filter Odd

def getFirstOracle {i : Fin (‚Ñì + 1)}
    (oStmt : (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i j)) :
    sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate 0 ‚Üí L :=

def rtake {n : ‚Ñï} {Œ± : Fin n ‚Üí Sort*} (m : ‚Ñï) (h : m ‚â§ n) (v : (i : Fin n) ‚Üí Œ± i) :
    (i : Fin m) ‚Üí Œ± (Fin.cast (Nat.sub_add_cancel h) (natAdd (n - m) i)) :=
  fun i => v (Fin.cast (Nat.sub_add_cancel h) (natAdd (n - m) i))

instance : Unique (MessagesUpTo 0 pSpec) where
  default := fun ‚ü®i, _‚ü© => Fin.elim0 i
  uniq := fun T => by admit /- proof elided -/

Equiv.optionCongr in Mathlib.Logic.Equiv.Option

instance {i : Fin (k + 1)} : ‚àÄ j, OracleInterface (OracleStatement D x s i j) :=
  fun _ => inferInstance

def Reduction.fiatShamir (R : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec) :
    NonInteractiveReduction (‚àÄ i, pSpec.Message i) (oSpec ++‚Çí fsChallengeOracle StmtIn pSpec)
      StmtIn WitIn StmtOut WitOut where
  prover := R.prover.fiatShamir
  verifier := R.verifier.fiatShamir

instance [inst : ‚àÄ i, SelectableType (pSpec.Challenge i)] :
    ‚àÄ i, SelectableType ((pSpec.addSalt Salt).Challenge i) :=
  fun i => by admit /- proof elided -/

instance : MonadLift (StateT œÑ m) (StateT (œÉ √ó œÑ) m) where
  monadLift := fun x st => do let y ‚Üê x st.2; return (y.1, st.1, y.2)

def mulNat [Zero T] (a : Cayley T) : Nat ‚Üí Cayley T
  | 0        => zero
  | .succ k  => add (mulNat a k) a

structure BinaryTowerInductiveStepResult (k : ‚Ñï) (prevBTField : Type _)
  (prevBTResult : BinaryTowerResult prevBTField k) [instPrevBTFieldIsField : Field prevBTField]
  (prevPoly : Polynomial prevBTField) (F : Type _) where
  binaryTowerResult : BinaryTowerResult F (k+1)
  eq_adjoin : F = AdjoinRoot prevPoly
  u_is_root : Eq.mp (eq_adjoin) binaryTowerResult.specialElement = AdjoinRoot.root prevPoly
  eval_defining_poly_at_root : Eq.mp (eq_adjoin) binaryTowerResult.specialElement^2 +
    Eq.mp (eq_adjoin) binaryTowerResult.specialElement * (of prevPoly) prevBTResult.specialElement
    + 1 = 0

class ProverLast (pSpec : ProtocolSpec n) [inst : NeZero n] where
  prover_last' : pSpec.dir ‚ü®n - 1, by admit /- proof elided -/
  ‚ü© = .P_to_V

def instTestLensKnowledgeSound : testLensE.IsKnowledgeSound
      outerRelIn_Test innerRelIn_Test outerRelOut_Test innerRelOut_Test
      (fun ‚ü®p, q, _‚ü© ‚ü®f, _‚ü© => p * q = f) (fun _ _ => True) where
  proj_knowledgeSound := fun ‚ü®p, q, t‚ü© ‚ü®f, t', r‚ü© _ h h' => by admit /- proof elided -/

Eq in Init.Prelude

def ofMvPolynomialDeg1 (p : R‚¶É‚â§ 1‚¶Ñ[X Fin n]) : MlPoly R n :=
  Vector.ofFn (fun i : Fin (2 ^ n) => p.val.coeff (monomialOfNat i))

def Polynomial.toImpl {R : Type*} [Semiring R] (p : R[X]) : UniPoly R :=
  match p.degree with
  | ‚ä• => #[]
  | some d  => .ofFn (fun i : Fin (d + 1) => p.coeff i)

inductive ScalarVectorOp where | scale

cond in Init.Prelude

structure BerlekampWelchCondition (e k : ‚Ñï) (œâs f : Fin n ‚Üí F) (E Q : Polynomial F) : Prop where
  cond: ‚àÄ i : Fin n, Q.eval (œâs i) = (f i) * E.eval (œâs i)
  E_natDegree : E.natDegree = e
  E_leadingCoeff : E.coeff e = 1
  Q_natDegree : Q.natDegree ‚â§ e + k - 1

Mathlib.Linter.TextBased.lintModules in Mathlib.Tactic.Linter.TextBased

instance oCtxLens_complete :
    (oCtxLens R n deg D i).toContext.IsComplete
      (relationRound R n deg D i.castSucc) (Simple.inputRelation R deg D)
      (relationRound R n deg D i.succ) (Simple.outputRelation R deg)
      ((Simple.oracleReduction R deg D oSpec).toReduction.compatContext
        (oCtxLens R n deg D i).toContext)
where
  proj_complete := by admit /- proof elided -/

@[inline]
def ofArray [Zero R] (coeffs : Array R) (n : ‚Ñï) : MlPoly R n :=
  .ofFn (fun i => if h : i.1 < coeffs.size then coeffs[i] else 0)

Finset.map in Mathlib.Data.Finset.Image

instance : Fact (Nat.Prime scalarFieldSize) := ‚ü®ScalarField_is_prime‚ü©

noncomputable instance {i : Fin r} (x : L) : Decidable (x ‚àà (U ùîΩq Œ≤ i : Set L)) :=

def Rhs (e : ‚Ñï) (œâs f : Fin n ‚Üí F) (i : Fin n) : F :=
  let Œ±·µ¢ := œâs i
  (-(f i) * Œ±·µ¢^e)

structure WireIndices (numWires : ‚Ñï) where
   
  a : Fin numWires
   
  b : Fin numWires
   
  c : Fin numWires
deriving DecidableEq

CommRing in Mathlib.Algebra.Ring.Defs

@[reducible, inline]
instance instMvPolynomialDegreeLE : OracleInterface (R‚¶É‚â§ d‚¶Ñ[X œÉ]) where
  Query := œÉ ‚Üí R
  Response := R
  answer := fun ‚ü®poly, _‚ü© point => eval point poly

RingHom.id in Mathlib.Algebra.Ring.Hom.Defs

def FullData.rightSubtree {Œ± : Type} {s_left s_right : Skeleton}
    (tree : FullData Œ± (Skeleton.internal s_left s_right)) :
    FullData Œ± s_right :=
  match tree with
  | FullData.internal _ _left right =>
    right

outParam in Init.Prelude

def FullData.toLeafData {Œ± : Type} {s : Skeleton}
    (tree : FullData Œ± s) : LeafData Œ± s :=
  match tree with
  | FullData.leaf value => LeafData.leaf value
  | FullData.internal _ left right =>
    LeafData.internal (left.toLeafData) (right.toLeafData)

noncomputable def distToCode [LinearOrder Œ±] [Zero Œ±]
                             (w : Œπ ‚Üí F) (C : Set (Œπ ‚Üí F))
                             (Œ¥f : (Œπ ‚Üí F) ‚Üí (Œπ ‚Üí F) ‚Üí Œ±)
                             (h : (possibleDistsToCode w C Œ¥f).Finite) : WithTop Œ± :=
  haveI := @Fintype.ofFinite _ h
  (possibleDistsToCode w C Œ¥f).toFinset.min

@[reducible]
def pSpecFold : ProtocolSpec 2 := ‚ü®![Direction.P_to_V, Direction.V_to_P], ![L‚¶É‚â§ 2‚¶Ñ[X], L]‚ü©

Finset.sup in Mathlib.Data.Finset.Lattice.Fold

instance : Slice (FullTranscript pSpec) ‚Ñï ‚Ñï
    (fun _ start stop => start ‚â§ stop ‚àß stop ‚â§ n)
    (fun _ start stop _ => FullTranscript (pSpec‚ü¶start:stop‚üß))
    where
  slice := fun v start stop h => extract start stop h.1 h.2 v

noncomputable def D_X (rho : ‚Ñö) (n m : ‚Ñï) : ‚Ñù := (m + 1/2) * (Real.sqrt rho) * n

def bivPolyHom {F : Type} [CommRing F] [IsDomain F] :
  Polynomial (F[X]) ‚Üí+* Polynomial (RatFunc F) := Polynomial.mapRingHom (univPolyHom)

def snoc (s : Fin n ‚Üí‚ÇÄ M) (y : M) : Fin (n + 1) ‚Üí‚ÇÄ M :=
  Finsupp.equivFunOnFinite.symm (Fin.snoc s y : Fin (n + 1) ‚Üí M)

Nat.decLt in Init.Prelude

instance instDCast‚ÇÇ : DCast‚ÇÇ Nat ProtocolSpec
    (fun _ pSpec => Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) where
  dcast‚ÇÇ := Prover.cast
  dcast‚ÇÇ_id := Prover.cast_id

def rightpad (m‚ÇÇ n‚ÇÇ : ‚Ñï) (a : Œ±) {m‚ÇÅ n‚ÇÅ : ‚Ñï} (M : Matrix (Fin m‚ÇÅ) (Fin n‚ÇÅ) Œ±) :
    Matrix (Fin m‚ÇÇ) (Fin n‚ÇÇ) Œ± :=
  Fin.rightpad m‚ÇÇ (fun _ => a) (Fin.rightpad n‚ÇÇ a ‚àò M)

@[reducible, simp] def WitOut := Unit

def exSkel0 : ArityTree.Skeleton 0 (fun i => nomatch i) :=
  ArityTree.Skeleton.leaf

instance AffSpanSet.instFinite [NeZero k] (u : Fin k ‚Üí Œπ ‚Üí F) : (AffSpanSet u).Finite :=

def toOracleVerifier
    (naVerifier : OracleVerifier.NonAdaptive oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec) :
    OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec where
  verify := fun stmt challenges => do
    let queryResponsesOStmt : List ((i : Œπ‚Çõ·µ¢) √ó ((O‚Çõ·µ¢ i).Query √ó (O‚Çõ·µ¢ i).Response)) ‚Üê
      (naVerifier.queryOStmt stmt challenges).mapM
      (fun q => do
        let resp ‚Üê liftM <| query (spec := [OStmtIn]‚Çí) q.1 q.2
        return ‚ü®q.1, (q.2, by admit /- proof elided -/
        )‚ü©)
    let queryResponsesOMsg : List ((i : pSpec.MessageIdx) √ó ((O‚Çò i).Query √ó (O‚Çò i).Response)) ‚Üê
      (naVerifier.queryMsg stmt challenges).mapM
      (fun q => do
        let resp ‚Üê liftM <| query (spec := [pSpec.Message]‚Çí) q.1 q.2
        return ‚ü®q.1, ‚ü®q.2, by admit /- proof elided -/
        ‚ü©‚ü©)
    let stmtOut ‚Üê liftM <| naVerifier.verify stmt challenges queryResponsesOStmt queryResponsesOMsg
    return stmtOut

  embed := naVerifier.embed

  hEq := naVerifier.hEq

@[inline, reducible]
def lift : OuterStmtIn √ó OuterWitIn ‚Üí InnerStmtOut √ó InnerWitOut ‚Üí OuterWitOut :=
  lens.toFunB

def BinaryTowerAux (k : ‚Ñï) : (Œ£' (F : Type 0), BinaryTowerResult F k) :=
  match k with
  | 0 => 
    let curBTField := GF(2)
    let newList : List.Vector (GF(2)) 1 := List.Vector.cons (1 : GF(2)) List.Vector.nil
    let specialElement : GF(2) := newList.1.headI
    let firstElementOfVecIsSpecialElement : newList.1.headI = specialElement := rfl
    let specialElementIs1 : specialElement = 1 := by admit /- proof elided -/

noncomputable def P
  (Œ¥ : ‚Ñö) (x‚ÇÄ : F)
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  :
  F[Z][X] :=
  let v‚ÇÄ := Classical.choose (solution_gamma_is_linear_in_Z k (Œ¥ := Œ¥) (x‚ÇÄ := x‚ÇÄ) h_gs)
  let v‚ÇÅ := Classical.choose 
    (Classical.choose_spec <| solution_gamma_is_linear_in_Z k (Œ¥ := Œ¥) (x‚ÇÄ := x‚ÇÄ) h_gs)
  (
    (Polynomial.map Polynomial.C v‚ÇÄ) +
    (Polynomial.C Polynomial.X) * (Polynomial.map Polynomial.C v‚ÇÅ)
  )

abbrev singleEqPolynomial (r : R) (x : MvPolynomial œÉ R) : MvPolynomial œÉ R :=
  (1 - C r) * (1 - x) + C r * x

def proverInput (i : Fin n) : ProverInput
    ((StatementRound R n i.castSucc) √ó (‚àÄ i, OracleStatement R n deg i))
    Unit ((proverState R n deg i).PrvState 0) where
  input := Prod.fst

Matrix.det in Mathlib.LinearAlgebra.Matrix.Determinant.Basic

inductive Data :
    {n : ‚Ñï} ‚Üí (pSpec : ProtocolSpec n) ‚Üí
    {ar : Fin n ‚Üí ‚Ñï} ‚Üí ArityTree.Skeleton n ar ‚Üí Type 1 where
  | leaf {pSpec : ProtocolSpec 0} {ar0 : Fin 0 ‚Üí ‚Ñï} :
      Data pSpec (ArityTree.Skeleton.leaf (ar0 := ar0))
  | msgNode {n : ‚Ñï}
      {pSpec : ProtocolSpec (n + 1)} {ar : Fin (n + 1) ‚Üí ‚Ñï}
      (h : pSpec.dir 0 = Direction.P_to_V)
      (val : pSpec.Message' 0 h)
      {children : Fin (ar 0) ‚Üí
        ArityTree.Skeleton n (fun i => ar i.succ)}
      (childrenData : (i : Fin (ar 0)) ‚Üí
        Data (pSpec := pSpec.drop 1 (Nat.succ_le_succ (Nat.zero_le n))) (children i)) :
      Data pSpec (ArityTree.Skeleton.node children)
  | chalNode {n : ‚Ñï}
      {pSpec : ProtocolSpec (n + 1)} {ar : Fin (n + 1) ‚Üí ‚Ñï}
      (h : pSpec.dir 0 = Direction.V_to_P)
      (val : pSpec.Challenge' 0 h)
      {children : Fin (ar 0) ‚Üí
        ArityTree.Skeleton n (fun i => ar i.succ)}
      (childrenData : (i : Fin (ar 0)) ‚Üí
        Data (pSpec := pSpec.drop 1 (Nat.succ_le_succ (Nat.zero_le n))) (children i)) :
      Data pSpec (ArityTree.Skeleton.node children)

instance [Zero T] [ToNat T] : HasPred (Cayley T) where
  pred' := pred

def closePtsOnAffineLine {Œπ : Type*} [Fintype Œπ]
                         (u v : Œπ ‚Üí F) (deg : ‚Ñï) (Œ± : Œπ ‚Ü™ F) (e : ‚Ñï) : Set (Œπ ‚Üí F) :=
  {x : Œπ ‚Üí F | x ‚àà Affine.line u v ‚àß distFromCode x (ReedSolomon.code Œ± deg) ‚â§ e}

def dfoldrM' {m : Type u ‚Üí Type v} [Monad m]
    (n : ‚Ñï) (Œ± : Fin (n + 1) ‚Üí Type u)
    (f : (i : Fin n) ‚Üí Œ± i.succ ‚Üí m (Œ± i.castSucc)) (init : Œ± (last n)) : m (Œ± 0) :=
  match n with
  | 0 => pure init
  | n + 1 => do
    let x ‚Üê dfoldrM' n (Œ± ‚àò succ) (fun i => f i.succ) init
    f 0 x

@[reducible]
def reduction : Reduction oSpec StmtIn WitIn StmtOut WitOut !p[] where
  prover := prover mapStmt mapWit
  verifier := verifier mapStmt

def dfoldl' (n : ‚Ñï) (Œ± : Fin (n + 1) ‚Üí Type u)
    (f : (i : Fin n) ‚Üí Œ± i.castSucc ‚Üí Œ± i.succ) (init : Œ± 0) : Œ± (last n) :=
  dfoldlM' (m := Id) n Œ± f init

noncomputable def finalSumcheckKnowledgeStateFunction {œÉ : Type} (init : ProbComp œÉ)
    (impl : QueryImpl []‚Çí (StateT œÉ ProbComp)) :
    (finalSumcheckVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).KnowledgeStateFunction init impl
    (relIn := roundRelation ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (ùìë := ùìë) (mp := BBF_SumcheckMultiplierParam) (Fin.last ‚Ñì))
    (relOut := finalSumcheckRelOut ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (extractor := finalSumcheckRbrExtractor ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
  where
  toFun := fun m ‚ü®stmt, oStmt‚ü© tr witMid =>
    finalSumcheckKStateProp ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (ùìë := ùìë) (tr := tr) (stmt := stmt) (witMid := witMid) (oStmt := oStmt)
  toFun_empty := fun stmt witMid => by admit /- proof elided -/

def MlPoly.mk {R : Type*} (n : ‚Ñï) (v : Vector R (2 ^ n)) : MlPoly R n := v

noncomputable def queryOracleProver :
  OracleProver
    (oSpec := []‚Çí)
    (StmtIn := FinalSumcheckStatementOut (L:=L) (‚Ñì:=‚Ñì))
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (
    Fin.last ‚Ñì))
    (WitIn := Unit)
    (StmtOut := Bool)
    (OStmtOut := fun _ : Empty => Unit)
    (WitOut := Unit)
    (pSpec := pSpecQuery ùîΩq Œ≤ Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)) where
  PrvState := fun
    | 0 => Unit
    | 1 => Unit
  input := fun _ => ()

  sendMessage
  | ‚ü®0, h‚ü© => nomatch h

  receiveChallenge
  | ‚ü®0, _‚ü© => fun _ => do
    
    pure (fun _challenges => ())

  output := fun _ => do 
    pure (‚ü®true, fun _ => ()‚ü©, ())

noncomputable def verifyOpening (verifySrs : Vector G‚ÇÇ 2) (commitment : G‚ÇÅ) (opening : G‚ÇÅ)
    (z : ZMod p) (v : ZMod p) : Prop :=
  pairing (commitment / g‚ÇÅ ^ v.val) (verifySrs[0]) = pairing opening (verifySrs[1] / g‚ÇÇ ^ z.val)

orderOf in Mathlib.GroupTheory.OrderOfElement

protected def OracleReduction.id :
    OracleReduction oSpec Statement OStatement Witness Statement OStatement Witness !p[] :=
  ‚ü®OracleProver.id, OracleVerifier.id‚ü©

alias Prover.trivial := Prover.id
alias Verifier.trivial := Verifier.id
alias Reduction.trivial := Reduction.id
alias OracleProver.trivial := OracleProver.id
alias OracleVerifier.trivial := OracleVerifier.id
alias OracleReduction.trivial := OracleReduction.id

def LeafData.map {Œ± Œ≤ : Type} (f : Œ± ‚Üí Œ≤) {s : Skeleton}
    (tree : LeafData Œ± s) : LeafData Œ≤ s :=
  match tree with
  | LeafData.leaf value => LeafData.leaf (f value)
  | LeafData.internal left right =>
    LeafData.internal (left.map f) (right.map f)

@[inline] def one : AssocNat :=
  ‚ü®Nat.succ, by admit /- proof elided -/
  ‚ü©

Algebra.TensorProduct.leftAlgebra in Mathlib.RingTheory.TensorProduct.Basic

@[reducible, inline, specialize]
def getChallenge (pSpec : ProtocolSpec n) (i : pSpec.ChallengeIdx) :
    OracleComp ([pSpec.Challenge]‚Çí'challengeOracleInterface) (pSpec.Challenge i) :=
  (query i () : OracleQuery ([pSpec.Challenge]‚Çí'challengeOracleInterface) (pSpec.Challenge i))

def init (s : Fin (n + 1) ‚Üí‚ÇÄ M) : Fin n ‚Üí‚ÇÄ M :=
  Finsupp.equivFunOnFinite.symm (Fin.init s)

instance : Unique (Fin 0 ‚Üí Œ±) where
  uniq v := by admit /- proof elided -/

structure PowTwoRepr where
  two_exp : ‚Ñï
  odd_part : ‚Ñï

@[reducible]
def capacitySegment (state : CanonicalSpongeState U) : Vector U SpongeSize.C :=
  Vector.drop state SpongeSize.R

ringChar in Mathlib.Algebra.CharP.Defs

instance extractorLens_rbr_knowledge_soundness :
    Extractor.Lens.IsKnowledgeSound
      (relationRound R n deg D i.castSucc) (Simple.inputRelation R deg D)
      (relationRound R n deg D i.succ) (Simple.outputRelation R deg)
      ((Simple.oracleVerifier R deg D oSpec).toVerifier.compatStatement (oStmtLens R n deg D i))
      (fun _ _ => True)
      ‚ü®oStmtLens R n deg D i, Witness.InvLens.trivial‚ü© where
  proj_knowledgeSound := by admit /- proof elided -/

def modByMonic [Field R] (p : UniPoly R) (q : UniPoly R) :
    UniPoly R :=
  (divModByMonicAux p q).2

def domainEnum (i : Fin (n + 1)) : Fin (2 ^ (n - i)) ‚Ü™ evalDomain D i :=
  ‚ü®domain D n i.1, domain_injective D i.1 (by admit /- proof elided -/
  )‚ü©

noncomputable def monomialBasisOfDegreeLT {n : ‚Ñï} : Basis (Fin n) L (L‚¶É< n‚¶Ñ[X]) :=

noncomputable def toPoly (p : UniPoly R) : Polynomial R :=
  p.eval‚ÇÇ Polynomial.C Polynomial.X

def RoundByRoundOneShot
    (oSpec : OracleSpec Œπ) (StmtIn WitIn : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n) :=
  (m : Fin (n + 1)) ‚Üí StmtIn ‚Üí Transcript m pSpec ‚Üí QueryLog oSpec ‚Üí WitIn

Inhabited in Init.Prelude

def accepts (x : Fin numWires ‚Üí ùì°) (g : Gate ùì° numWires) : Prop :=
  g.eval x = 0

def AlgebraTowerEquiv.algebraMapRightUp (e : AlgebraTowerEquiv A B) (i j : Œπ)
    (h : i ‚â§ j) : (A i) ‚Üí+* (B j) :=

def rho (n : ‚Ñï) : Option ‚Ñï := Id.run do
  for st in [2:n] do
    for c in [1:n] do
      if let some d := rho' n st c then
        return some d

  return none

structure OracleContext.Lens (OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut : Type)
    {Outer_Œπ‚Çõ·µ¢ : Type} (OuterOStmtIn : Outer_Œπ‚Çõ·µ¢ ‚Üí Type) [‚àÄ i, OracleInterface (OuterOStmtIn i)]
    {Outer_Œπ‚Çõ‚Çí : Type} (OuterOStmtOut : Outer_Œπ‚Çõ‚Çí ‚Üí Type) [‚àÄ i, OracleInterface (OuterOStmtOut i)]
    {Inner_Œπ‚Çõ·µ¢ : Type} (InnerOStmtIn : Inner_Œπ‚Çõ·µ¢ ‚Üí Type) [‚àÄ i, OracleInterface (InnerOStmtIn i)]
    {Inner_Œπ‚Çõ‚Çí : Type} (InnerOStmtOut : Inner_Œπ‚Çõ‚Çí ‚Üí Type) [‚àÄ i, OracleInterface (InnerOStmtOut i)]
    (OuterWitIn OuterWitOut InnerWitIn InnerWitOut : Type) where
  stmt : OracleStatement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                                  OuterOStmtIn OuterOStmtOut InnerOStmtIn InnerOStmtOut
  wit : Witness.Lens (OuterStmtIn √ó ‚àÄ i, OuterOStmtIn i) (InnerStmtOut √ó ‚àÄ i, InnerOStmtOut i)
                          OuterWitIn OuterWitOut InnerWitIn InnerWitOut

@[ext]
structure ProverInput (StmtIn WitIn PrvState : Type) where
  input : StmtIn √ó WitIn ‚Üí PrvState

@[reducible]
def pSpec : ProtocolSpec 1 :=
  ‚ü®!v[.V_to_P], !v[Fin l ‚Üí evalDomain D x 0]‚ü©

List in Init.Prelude

def matchSize (l‚ÇÅ : List Œ±) (l‚ÇÇ : List Œ±) (unit : Œ±) : List Œ± √ó List Œ± :=
  (l‚ÇÅ.rightpad (l‚ÇÇ.length) unit, l‚ÇÇ.rightpad (l‚ÇÅ.length) unit)

Polynomial.derivative in Mathlib.Algebra.Polynomial.Derivative

def toFinMatrix {m n : ‚Ñï} (matrix : Matrix Œ± m n) : _root_.Matrix (Fin m) (Fin n) Œ± :=
  fun i j => (matrix.get i).get j

@[reducible, simp]
def perfectCompleteness (relation : Set (Statement √ó Witness))
    (proof : Proof oSpec Statement Witness pSpec) : Prop :=
  Reduction.perfectCompleteness init impl relation acceptRejectRel proof

noncomputable def H
  (Œ¥ : ‚Ñö) (x‚ÇÄ : F)
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  : F[Z][X] := (exists_factors_with_large_common_root_set k Œ¥ x‚ÇÄ h_gs).choose_spec.choose

Nat.gcd in Init.Data.Nat.Gcd

@[inline, specialize]
def runToRound (i : Fin (n + 1))
    (stmt : StmtIn) (wit : WitIn) (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí) (pSpec.Transcript i √ó prover.PrvState i) :=
  Fin.induction
    (pure ‚ü®default, prover.input (stmt, wit)‚ü©)
    (prover.processRound)
    i

AdjoinRoot.root in Mathlib.RingTheory.AdjoinRoot

def renameMessage (pSpec : ProtocolSpec n) (NewMessage : pSpec.MessageIdx ‚Üí Type) :
    ProtocolSpec n :=
  ‚ü® pSpec.dir,
    fun i => if h : pSpec.dir i = Direction.P_to_V then NewMessage ‚ü®i, h‚ü© else pSpec.¬´Type¬ª i‚ü©

def divNat [Zero T] [DecidableEq T] [ToNat T]
    (dividend divisor : Cayley T) : Nat ‚Üí Cayley T
  | 0        => zero  
  | .succ fuel =>
    
    if (‚Üëdivisor : Nat) = 0 then
      zero
    else
      
      if (‚Üëdivisor : Nat) ‚â§ (‚Üëdividend : Nat) then
        
        add one (divNat (sub dividend divisor) divisor fuel)
      else
        zero

List.length in Init.Prelude

HomogeneousPow in Init.Prelude

protected noncomputable def ElocPoly (n : ‚Ñï) (œâs f : ‚Ñï ‚Üí F) (p : Polynomial F) : Polynomial F :=
  List.prod <| (List.range n).map fun i =>
    if f i = p.eval (œâs i)
    then 1
    else X - C (œâs i)

def sigmaMessageIdxToSeqCompose {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (i : Fin m) (j : (pSpec i).MessageIdx) : (seqCompose pSpec).MessageIdx :=
  ‚ü®Fin.embedSum i j.1, by admit /- proof elided -/
  ‚ü©

AddMonoidAlgebra in Mathlib.Algebra.MonoidAlgebra.Defs

def toNat (n : ChurchNat ‚Ñï) : ‚Ñï := n Nat.succ 0

noncomputable def proximity_gap_johnson (rho : ‚Ñö) (m : ‚Ñï) : ‚Ñù :=
  (1 : ‚Ñù) - Real.sqrt rho - Real.sqrt rho / (2 * m)

instance inhabited [Inhabited R] : Inhabited (MlPolyEval R n) :=

@[app_unexpander Fin.fcons‚ÇÇ]
def fcons‚ÇÇUnexpander : Lean.PrettyPrinter.Unexpander
  | `($_ $a !h‚¶É$F‚¶Ñ‚ü®$Œ±‚ÇÅ‚ü©‚ü®$Œ±‚ÇÇ‚ü©[$b, $bs,*]) => `(!h‚¶É$F‚¶Ñ‚ü®$Œ±‚ÇÅ‚ü©‚ü®$Œ±‚ÇÇ‚ü©[$a, $b, $bs,*])
  | `($_ $a !h‚¶É$F‚¶Ñ‚ü®$Œ±‚ÇÅ‚ü©‚ü®$Œ±‚ÇÇ‚ü©[$b]) => `(!h‚¶É$F‚¶Ñ‚ü®$Œ±‚ÇÅ‚ü©‚ü®$Œ±‚ÇÇ‚ü©[$a, $b])
  | `($_ $a !h‚¶É$F‚¶Ñ‚ü®$Œ±‚ÇÅ‚ü©‚ü®$Œ±‚ÇÇ‚ü©[]) => `(!h‚¶É$F‚¶Ñ‚ü®$Œ±‚ÇÅ‚ü©‚ü®$Œ±‚ÇÇ‚ü©[$a])
  | _ => throw ()

class OracleInterfaces (pSpec : ProtocolSpec n) where
  oracleInterfaces : ‚àÄ i, Option (OracleInterface (pSpec.Message i))

System.FilePath.walkDir in Init.System.IO

@[simp]
def outerRelOut_Test : Set (OuterStmtOut_Test √ó Unit) :=
  setOf (fun ‚ü®‚ü®p, q, t, r‚ü©, _‚ü© => (p * q).eval r = t)

instance : ‚àÄ i, SelectableType (Challenge !p[] i) :=
  fun ‚ü®i, h‚ü© =>
    (Fin.elim0 i : (h' : !p[].dir i = .V_to_P) ‚Üí SelectableType (!p[].Challenge ‚ü®i, h'‚ü©)) h

def last_nonzero_prop {p : UniPoly R} (k : Fin p.size) : Prop :=
  p[k] ‚â† 0 ‚àß (‚àÄ j, (hj : j < p.size) ‚Üí j > k ‚Üí p[j] = 0)

def EvenPoly (f : Polynomial F) : Prop := ‚àÄ n, Odd n ‚Üí f.coeff n = 0

structure Context.Lens (OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                          OuterWitIn OuterWitOut InnerWitIn InnerWitOut : Type) where
  stmt : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
  wit : Witness.Lens OuterStmtIn InnerStmtOut OuterWitIn OuterWitOut InnerWitIn InnerWitOut

@[inline]
def neg [Neg R] (p : MlPoly R n) : MlPoly R n := p.map (fun a => -a)

def relHammingBall (C : Code Œπ F) (y : Œπ ‚Üí F) (r : ‚Ñù) : Code Œπ F :=
  { c | c ‚àà C ‚àß Code.relHammingDist y c ‚â§ r }

class SliceGE (coll : Type u) (start : Type v) (valid : outParam (coll ‚Üí start ‚Üí Prop))
    (subcoll : outParam ((xs : coll) ‚Üí (start : start) ‚Üí (h : valid xs start) ‚Üí Type w)) where
  sliceGE : (xs : coll) ‚Üí (start : start) ‚Üí (h : valid xs start) ‚Üí subcoll xs start h

inductive MemoryOp (Œπ : Type u) (Œ± : Œπ ‚Üí Type v) where
  | read (op : MemoryRead Œπ Œ±)
  | write (op : MemoryWrite Œπ Œ±)

BitVec.xor in Init.Data.BitVec.Basic

@[inline, specialize, simp]
def reduction : Reduction oSpec Statement Witness Statement Witness !p[] := Reduction.id

Sum.isLeft in Init.Data.Sum.Basic

Lagrange.basis in Mathlib.LinearAlgebra.Lagrange

def verifyProof {n : ‚Ñï} (i : Fin (2 ^ n)) (leaf : Œ±) (root : Œ±) (proof : List.Vector Œ± n) :
    OracleComp (spec Œ±) Unit := do
  let putative_root ‚Üê getPutativeRoot Œ± i leaf proof
  guard (putative_root = root)

@[reducible]
def CanonicalDuplexSponge (U : Type) [SpongeUnit U] [SpongeSize] :=
  DuplexSponge U (CanonicalSpongeState U)

def sumcheckFoldKnowledgeError := fun j : (pSpecSumcheckFold ùîΩq Œ≤ (œë:=œë)
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).ChallengeIdx =>
    if hj: (j.val % NBlockMessages (œë:=œë)) % 2 = 1 then
      foldKnowledgeError ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        ‚ü®j / NBlockMessages (œë:=œë) * œë + ((j % NBlockMessages (œë:=œë)) / 2 + 1), by admit /- proof elided -/
        ‚ü© ‚ü®1, rfl‚ü©
    else 0 

noncomputable def foldProver :
  OracleProver []‚Çí
    (Statement F i.castSucc) (OracleStatement D x s i.castSucc) (Witness F s d i.castSucc.castSucc)
    (Statement F i.succ) (OracleStatement D x s i.succ) (Witness F s d i.castSucc.succ)
    (pSpec D x s i) where
  PrvState
  | 0 =>
    (Statement F i.castSucc √ó ((j : Fin (‚Üëi.castSucc + 1)) ‚Üí OracleStatement D x s i.castSucc j)) √ó
      Witness F s d i.castSucc.castSucc
  | _ =>
    (Statement F i.succ √ó ((j : Fin (‚Üëi.castSucc + 1)) ‚Üí OracleStatement D x s i.castSucc j)) √ó
      Witness F s d i.castSucc.succ

  input := id

  sendMessage
  | ‚ü®0, h‚ü© => nomatch h
  | ‚ü®1, _‚ü© => fun ‚ü®‚ü®chals, o‚ü©, p‚ü© =>
    pure ‚ü®fun x => p.1.eval x.1.1, ‚ü®‚ü®chals, o‚ü©, p‚ü©‚ü©

  receiveChallenge
  | ‚ü®0, _‚ü© => fun ‚ü®‚ü®chals, o‚ü©, p‚ü© => pure <|
    fun (Œ± : F) =>
      ‚ü®
        ‚ü®Fin.append chals (fun (_ : Fin 1) => Œ±), o‚ü©,
        ‚ü®p.1.foldNth (2 ^ (s i.castSucc).1) Œ±, witness_lift p.2‚ü©
      ‚ü©
  | ‚ü®1, h‚ü© => nomatch h

  output := fun ‚ü®‚ü®chals, o‚ü©, p‚ü© => pure <|
    ‚ü®
      ‚ü®
        chals,
        fun j =>
          if h : j.1 < i.1
          then by admit /- proof elided -/
      ‚ü©,
      p
    ‚ü©

def sub_descending (p q : UniPoly R) : QuotientUniPoly R :=
  Quotient.mk _ (sub p q)

@[reducible]
def pSpecCommit (i : Fin ‚Ñì) : ProtocolSpec 1 :=
  ‚ü®![Direction.P_to_V],
   ![OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i.val + 1, by admit /- proof elided -/
   ‚ü©]‚ü©

noncomputable def proximityCondition
   (f : par‚Ñì ‚Üí Œπ ‚Üí F) (Œ¥ : ‚Ñù) (r : par‚Ñì ‚Üí F) (C : LinearCode Œπ F) : Prop :=
  Œ¥·µ£( (fun x => ‚àë j : par‚Ñì, (r j) * f j x) , C ) ‚â§ (Œ¥ : ‚Ñù)

Fin.tail in Mathlib.Data.Fin.Tuple.Basic

def new (domainSeparator : DomainSeparator U H) : HashStateWithInstructions U H :=
  letI stack := domainSeparator.finalize
  letI tag := generateTag domainSeparator.asBytes
  { ds := Initialize.new tag, stack := stack }

def BBF_CodeDistance (‚Ñì ùì° : ‚Ñï) (i : Fin (‚Ñì + 1)) : ‚Ñï :=
  2^(‚Ñì + ùì° - i.val) - 2^(‚Ñì - i.val) + 1

Function.Embedding.subtype in Mathlib.Logic.Embedding.Basic

def bitsToU (i : Fin r) (k : Fin (2 ^ i.val)) :
    AdditiveNTT.U (L := L) (ùîΩq := ùîΩq) (Œ≤ := Œ≤) i :=
  let val := (Finset.univ : Finset (Fin i)).sum fun j =>
    if (Nat.getBit (n := k.val) (k := j.val) == 1) then
      Œ≤ ‚ü®j, by admit /- proof elided -/
      ‚ü©
    else 0

  
  ‚ü®val, by admit /- proof elided -/
  ‚ü©

def relayKnowledgeError (m : pSpecRelay.ChallengeIdx) : ‚Ñù‚â•0 :=
  match m with
  | ‚ü®j, _‚ü© => j.elim0

structure TowerEquivResult (k : ‚Ñï) where
  ringEquiv : ConcreteBTField k ‚âÉ+* BTField k
  ringEquivForwardMapEq : ringEquiv = towerRingHomForwardMap k

def MLE (evals : (œÉ ‚Üí Fin 2) ‚Üí R) : MvPolynomial œÉ R :=
    ‚àë x : œÉ ‚Üí Fin 2, (eqPolynomial (x : œÉ ‚Üí R)) * C (evals x)

@[elab_as_elim] def Fin.predRecOnSameFinType {motive : Fin r ‚Üí Sort _}
    (last : motive (‚ü®r - 1, by
      have h_r_ne_0: r ‚â† 0 := by exact NeZero.ne r
      omega
    ‚ü© : Fin r))
    (succ : ‚àÄ i : Fin r, i.val > 0 ‚Üí motive i ‚Üí motive (‚ü®i.val - 1, by omega‚ü© : Fin r))
    (i : Fin r): motive i :=

def testNTTBTF‚ÇÉ : Fin (2 ^ (2 + 2)) ‚Üí BTF‚ÇÉ :=

def finSum'FinEquiv' {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} : (i : Fin m) √ó Fin (n i) ‚âÉ Fin (vsum n) where
  toFun := fun ij => embedSum ij.1 ij.2
  invFun := splitSum
  left_inv := fun ij => splitSum_embedSum ij.1 ij.2
  right_inv := embedSum_splitSum

def last_nonzero (p : UniPoly R) : Option (Fin p.size) :=
  p.findIdxRev? (¬∑ != 0)

def Verifier.liftContext
    (lens : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut)
    (V : Verifier oSpec InnerStmtIn InnerStmtOut pSpec) :
      Verifier oSpec OuterStmtIn OuterStmtOut pSpec where
  verify := fun stmtIn transcript => do
    let innerStmtIn := lens.proj stmtIn
    let innerStmtOut ‚Üê V.verify innerStmtIn transcript
    return lens.lift stmtIn innerStmtOut

inductive Expr where
  | lit (a : Lit F)
  | var (name : String)
  | sOp (op : ScalarOp) (a : Lit F) (b : Lit F)
  | svOp (op : ScalarVectorOp) (a : Lit F) (v : Lit F)
  | vOp (op : VectorOp) (v1 : Lit F) (v2 : Lit F)

def Œ≤ (R : F[X][X][Y]) (t : ‚Ñï) : ùí™ H :=
  (Œ≤_regular R H (Nat.le_refl _) t).choose

noncomputable def genRSC
  [Nonempty F] (par‚Ñì : Type) [h‚Ñì : Fintype par‚Ñì] (œÜ : Œπ ‚Ü™ F) [Smooth œÜ]
  (m : ‚Ñï) (exp : par‚Ñì ‚Ü™ ‚Ñï) : ProximityGenerator Œπ F :=
    let r := LinearCode.rate (smoothCode œÜ m);
    { C := smoothCode œÜ m,
      par‚Ñì := par‚Ñì,
      h‚Ñì := h‚Ñì,
      rate := r,
      Gen := Finset.image (fun r => (fun j => r ^ (exp j))) (Finset.univ : Finset F),
      Gen_nonempty := by admit /- proof elided -/

noncomputable def errorBound (Œ¥ : ‚Ñù‚â•0) (deg : ‚Ñï) (domain : Œπ ‚Ü™ F) : ‚Ñù‚â•0 :=
  letI œÅ : ‚Ñù‚â•0 := œÅ (ReedSolomon.code domain deg)
  if Œ¥ ‚àà Set.Ioc 0 ((1 - œÅ)/2)
  then Fintype.card Œπ / Fintype.card F
  else if Œ¥ ‚àà Set.Ioo ((1 - œÅ)/2) (1 - œÅ.sqrt)
       then letI m := min (1 - œÅ.sqrt - Œ¥) (œÅ.sqrt / 20)
            ‚ü®(deg ^ 2 : ‚Ñù‚â•0) / ((2 * m) ^ 7 * (Fintype.card F : ‚Ñù)), by admit /- proof elided -/
            ‚ü©
       else 0

@[simp]
abbrev Witness.AfterFirstSumcheck : Type := Unit

def implGroupDecodeOracle [DeserializeOption G (BitVec bitLength)] :
    QueryImpl (GroupDecodeOracle Œπ bitLength) (StateT (GroupValTable Œπ G) Option) where
  impl | query _ (b, i) => fun table =>
    match DeserializeOption.deserialize b with
    | some g => some ((), table.update i (some g))
    | none => none

def ofMessagesChallenges (messages : MessagesUpTo k pSpec)
    (challenges : ChallengesUpTo k pSpec) : Transcript k pSpec :=
  fun i => match h : pSpec.dir (i.castLE (by admit /- proof elided -/
  )) with
  | Direction.P_to_V => messages ‚ü®i.castLE (by admit /- proof elided -/
  ), h‚ü©
  | Direction.V_to_P => challenges ‚ü®i.castLE (by admit /- proof elided -/
  ), h‚ü©

Subtype.fintype in Mathlib.Data.Fintype.Sets

instance {pSpec : ProtocolSpec n} : CoeHead (MessageIdx pSpec) (Fin n) where
  coe := fun i => i.1

@[reducible, inline, specialize]
def Challenges (pSpec : ProtocolSpec n) : Type := ‚àÄ i, pSpec.Challenge i

instance polyMonic (n : ‚Ñï) : Monic (poly n) := definingPoly_is_monic (Z n)

@[reducible, inline, specialize]
def Messages (pSpec : ProtocolSpec n) : Type := ‚àÄ i, pSpec.Message i

@[inline, specialize]
def Prover.runToRoundDSFS [‚àÄ i, VCVCompatible (pSpec.Challenge i)] (i : Fin (n + 1))
    (stmt : StmtIn) (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec)
    (state : prover.PrvState 0) :
        OracleComp (oSpec ++‚Çí duplexSpongeChallengeOracle StmtIn U)
          (pSpec.MessagesUpTo i √ó
            DuplexSponge U (Vector U SpongeSize.N) √ó prover.PrvState i) :=
  Fin.induction
    (do
      
      let sponge ‚Üê liftM (DuplexSponge.start stmt)
      return ‚ü®default, sponge, state‚ü©
    )
    (prover.processRoundDSFS)
    i

def finalNonDoomedFoldingProp {h_le : œë ‚â§ ‚Ñì}
    (input : (FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì) √ó
      (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì) j))) :
    Prop :=
  let stmt := input.1
  let oStmt := input.2
  let f_‚Ñì: (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®‚Ñì, by admit /- proof elided -/
  ‚ü© ‚Üí L := fun x => stmt.final_constant
  let j := mkLastOracleIndex ‚Ñì œë (Fin.last ‚Ñì) 
  let k := j.val * œë
  have h_k: k = ‚Ñì - œë := by admit /- proof elided -/

Set.image in Mathlib.Data.Set.Defs

def ofFinMatrix {m n : ‚Ñï} (matrix : _root_.Matrix (Fin m) (Fin n) Œ±) : Matrix Œ± m n :=
  Vector.ofFn (fun i => Vector.ofFn (fun j => matrix i j))

Polynomial.evalEvalRingHom in Mathlib.Algebra.Polynomial.Bivariate

@[reducible]
def Witness (F : Type) [Semiring F] {k : ‚Ñï} (s : Fin (k + 1) ‚Üí ‚Ñï+) (d : ‚Ñï+) (m : ‚Ñï) :=
  Fin (m + 1) ‚Üí F‚¶É< 2 ^ (‚àë i, (s i).1) * d‚¶Ñ[X]

def Verifier.StateFunction.liftContext
    {œÉ : Type} {init : ProbComp œÉ} {impl : QueryImpl oSpec (StateT œÉ ProbComp)}
    (lens : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut)
    (V : Verifier oSpec InnerStmtIn InnerStmtOut pSpec)
    (outerLangIn : Set OuterStmtIn) (outerLangOut : Set OuterStmtOut)
    (innerLangIn : Set InnerStmtIn) (innerLangOut : Set InnerStmtOut)
    [lensSound : lens.IsSound outerLangIn outerLangOut innerLangIn innerLangOut
      (V.compatStatement lens)]
    (stF : V.StateFunction init impl innerLangIn innerLangOut) :
      (V.liftContext lens).StateFunction init impl outerLangIn outerLangOut
where
  toFun := fun m outerStmtIn transcript =>
    stF m (lens.proj outerStmtIn) transcript
  toFun_empty := fun stmt => by admit /- proof elided -/

def coeffs [DecidableEq F] (f : F[X][Y]) : Finset F[X] := f.support.image f.coeff

def three : ChurchNat Œ± := succ two

instance : ‚àÄ j, OracleInterface ((pSpec D x l).Message j) := fun j =>
  match j with
  | ‚ü®0, h‚ü© => nomatch h

@[inline] def min [Zero T] [ToNat T] (a b : Cayley T) : Cayley T :=
  if (a : Nat) ‚â§ (b : Nat) then a else b

Polynomial.mapRingHom in Mathlib.Algebra.Polynomial.Eval.Defs

def leftpad {m : ‚Ñï} {Œ± : Sort*} (n : ‚Ñï) (a : Œ±) (v : Fin m ‚Üí Œ±) : Fin n ‚Üí Œ± :=
  fun i => if h : n - m ‚â§ i then v ‚ü®i - (n - m), by admit /- proof elided -/
  ‚ü© else a

def capacitySegmentDup : Prop :=
  capacitySegmentDupHash trace ‚à® capacitySegmentDupPerm trace ‚à® capacitySegmentDupPermInv trace

alias E_dup := capacitySegmentDup

instance {_ : Empty} : OracleInterface (Unit) := OracleInterface.instDefault

def LeafData.optionComposeBuild {Œ± : Type} {s : Skeleton} (leaf_data_tree : LeafData Œ± s)
    (compose : Œ± ‚Üí Œ± ‚Üí Option Œ±) :
    FullData (Option Œ±) s :=
  (leaf_data_tree.map (.some)).composeBuild (Option.doubleBind compose)

DecidableRel in Init.Prelude

HMul.hMul in Init.Prelude

instance (k : ‚Ñï) : NeZero (2^k) :=

@[ext]
structure OracleVerifier {Œπ : Type} (oSpec : OracleSpec Œπ)
    (StmtIn : Type) {Œπ‚Çõ·µ¢ : Type} (OStmtIn : Œπ‚Çõ·µ¢ ‚Üí Type)
    (StmtOut : Type) {Œπ‚Çõ‚Çí : Type} (OStmtOut : Œπ‚Çõ‚Çí ‚Üí Type)
    {n : ‚Ñï} (pSpec : ProtocolSpec n)
    [O‚Çõ·µ¢ : ‚àÄ i, OracleInterface (OStmtIn i)]
    [O‚Çò : ‚àÄ i, OracleInterface (pSpec.Message i)]
    where
    
    

   
  verify : StmtIn ‚Üí pSpec.Challenges ‚Üí
    OracleComp (oSpec ++‚Çí ([OStmtIn]‚Çí ++‚Çí [pSpec.Message]‚Çí)) StmtOut

  
  
  

  

   
  embed : Œπ‚Çõ‚Çí ‚Ü™ Œπ‚Çõ·µ¢ ‚äï pSpec.MessageIdx

   
  hEq : ‚àÄ i, OStmtOut i = match embed i with
    | Sum.inl j => OStmtIn j
    | Sum.inr j => pSpec.Message j

def outputRelation :
    Set (((StmtOut R) √ó (‚àÄ i, OStmtOut R deg i)) √ó Unit) :=
  { ‚ü®‚ü®‚ü®newTarget, chal‚ü©, oStmt‚ü©, _‚ü© | (oStmt ()).1.eval chal = newTarget }

def Œ≥' (x‚ÇÄ : F) (R : F[X][X][Y]) (H_irreducible : Irreducible H) : PowerSeries (ùïÉ H) :=
  Œ≥ x‚ÇÄ R H (œÜ := ‚ü®H_irreducible‚ü©)

structure Simulator (oSpec : OracleSpec Œπ) (StmtIn : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n) where
  SimState : Type
  oracleSim : SimOracle.Stateful oSpec oSpec SimState
  proverSim : StmtIn ‚Üí StateT SimState (OracleComp oSpec) pSpec.FullTranscript

instance instDCast : DCast Nat ProtocolSpec where
  dcast h := ProtocolSpec.cast h
  dcast_id := cast_id

def fold (i : Fin r) (h_i : i + 1 < ‚Ñì + ùì°) (f : (sDomain ùîΩq Œ≤
    h_‚Ñì_add_R_rate) i ‚Üí L) (r_chal : L) :
    (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) (‚ü®i + 1, by admit /- proof elided -/
    ‚ü©) ‚Üí L :=
  fun y => by admit /- proof elided -/

def makeZero (Œπ : ‚Ñï) (F : Type*) [Zero F] : Fin Œπ ‚Üí F := fun _ ‚Ü¶ 0

instance {s} : LawfulFunctor (fun Œ± => LeafData Œ± s) :=

def hammingClose (i : Fin (‚Ñì + 1)) (f : OracleFunction ùîΩq Œ≤
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) : Prop :=
  2 * Code.distFromCode (u := f)
    (C := BBF_Code ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) <
    (BBF_CodeDistance ‚Ñì ùì° i : ‚Ñï‚àû)

List.prod in Batteries.Data.List.Basic

Fin.castLT in Init.Data.Fin.Basic

IsField in Mathlib.Algebra.Field.IsField

instance : LE AssocNat where
  le a b := a 0 ‚â§ b 0

List.ofFn in Init.Data.List.OfFn

abbrev AffSpanSet [NeZero k] (U : Fin k ‚Üí Œπ ‚Üí F) : Set (Œπ ‚Üí F) :=
  (affineSpan F (Finset.univ.image U : Set (Œπ ‚Üí F))).carrier

@[reducible, simp] def WitIn := Unit

DFunLike in Mathlib.Data.FunLike.Basic

  inductive UnverifiedPrattPart : Type
    | prime : (p : ‚Ñï) ‚Üí (k : ‚Ñï) ‚Üí (hp : UnverifiedPrattCertificate p) ‚Üí UnverifiedPrattPart
    | split : UnverifiedPrattPart ‚Üí UnverifiedPrattPart ‚Üí UnverifiedPrattPart
  deriving Repr

instance instDCastSigmaSigma {Œ± : Type*} {Œ≤ : Œ± ‚Üí Type*} {Œ≥ : (a : Œ±) ‚Üí Œ≤ a ‚Üí Type*}
    {Œ¥ : (a : Œ±) ‚Üí (b : Œ≤ a) ‚Üí Œ≥ a b ‚Üí Type*}
    [DCast Œ± Œ≤] [DCast‚ÇÇ Œ± Œ≤ Œ≥] [DCast‚ÇÉ Œ± Œ≤ Œ≥ Œ¥] :
    DCast ((a : Œ±) √ó (b : Œ≤ a) √ó Œ≥ a b) (fun a => Œ¥ a.1 a.2.1 a.2.2) where
  dcast hc d := dcast‚ÇÉ (by admit /- proof elided -/
  ) (by admit /- proof elided -/
  ) (by admit /- proof elided -/
  ) d
  dcast_id := by admit /- proof elided -/

def inputRelation : Set (((StmtIn R) √ó (‚àÄ i, OStmtIn R deg i)) √ó Unit) :=
  { ‚ü®‚ü®target, oStmt‚ü©, _‚ü© | ‚àë x ‚àà (univ.map D), (oStmt ()).1.eval x = target }

def computeLookaheadSequenceFamily
    (trace : QueryLog (forwardPermutationOracle (CanonicalSpongeState U)))
    (state : CanonicalSpongeState U) (i : pSpec.ChallengeIdx) :
    LookaheadSequenceFamily trace state i :=
  sorry

def toStatement (stmt : FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì)) :
  Statement (L := L) (Context := SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì)  :=
  {
    sumcheck_target := stmt.sumcheck_target,
    challenges := stmt.challenges,
    ctx := stmt.ctx
  }

@[simp]
def evalDomain (i : ‚Ñï) : Set FÀ£ :=
  (x ^ (2 ^ i)) ‚Ä¢ (Domain.evalDomain D i)

instance : ‚àÄ j, SelectableType ((fullPSpec ùîΩq Œ≤ Œ≥_repetitions (œë:=œë)
  (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).Challenge j) := instSelectableTypeChallengeAppend

@[reducible, simp] def StmtAfterSendClaim : Type := R

noncomputable def batchOracleReduction :
  OracleReduction []‚Çí
    Unit (OracleStatement D x m) (Witness F s d m)
    ((Fin m ‚Üí F) √ó Fri.Spec.Statement F (0 : Fin (k + 1)))
    (OracleStatement D x m)
    (Fri.Spec.Witness F s d (0 : Fin (k + 2)))
    (batchSpec F m) where
  prover := batchProver D x s d m
  verifier := batchVerifier (k := k) D x m

instance {i : Fin ‚Ñì} :
    ‚àÄ j, OracleInterface ((pSpecFoldCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i).Message j) :=
  instOracleInterfaceMessageAppend

instance (n : AssocNat) : DecidableEq (AssocFin n) :=

@[reducible, inline, specialize, simp]
def ChallengeIdx (vPSpec : VectorSpec n) := {i : Fin n // vPSpec.dir i = .V_to_P}

def oracleReduction : OracleReduction oSpec (StmtIn R) (OStmtIn R deg) Unit
    (StmtOut R) (OStmtOut R deg) Unit (pSpec R deg) :=
  ((oracleReduction.sendClaim R deg oSpec)
  |>.append (oracleReduction.checkClaim R deg oSpec)
  |>.append (oracleReduction.randomQuery R deg oSpec)
  |>.append (oracleReduction.reduceClaim R deg oSpec))

instance : Dist (n ‚Üí R) where
  dist := fun u v => hammingDist u v

Nat.bodd in Mathlib.Data.Nat.Bits

def rbrKnowledgeSoundness
    (relIn : Set ((StmtIn √ó ‚àÄ i, OStmtIn i) √ó WitIn))
    (relOut : Set ((StmtOut √ó ‚àÄ i, OStmtOut i) √ó WitOut))
    (verifier : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec)
    (rbrKnowledgeError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) : Prop :=
  verifier.toVerifier.rbrKnowledgeSoundness init impl relIn relOut rbrKnowledgeError

Quotient in Init.Core

def append {Œπ‚ÇÅ : Type u} {T‚ÇÅ : Œπ‚ÇÅ ‚Üí Type v} [‚àÄ i, OracleInterface (T‚ÇÅ i)]
    {Œπ‚ÇÇ : Type u} {T‚ÇÇ : Œπ‚ÇÇ ‚Üí Type v} [‚àÄ i, OracleInterface (T‚ÇÇ i)] : OracleSpec (Œπ‚ÇÅ ‚äï Œπ‚ÇÇ) :=
  [Sum.rec T‚ÇÅ T‚ÇÇ]‚Çí

@[reducible, inline, specialize]
def PlainMessage (i : pSpec.PlainMessageIdx) := pSpec.Message i.1

instance [Zero T] [ToNat T] : DecidableRel (@LT.lt (Cayley T) _) := fun a b =>
  Nat.decLt (‚Üëa) (‚Üëb)

Repr in Init.Data.Repr

private def k [Zero F] (B : Finset (Fin n ‚Üí F)) : ‚Ñö :=
  (1 : ‚Ñö) / n * ‚àë i, K B i 0

@[inline] def succ (a : Cayley T) : Cayley T := add a one

@[simp]
abbrev FirstSumcheckChallenge : Type := Fin pp.‚Ñì_m ‚Üí R

CanLift in Mathlib.Tactic.Lift

def isRead : MemoryOp Œπ Œ± ‚Üí Prop
  | read _ => True
  | _ => False

instance : IsCyclic G :=
  isCyclic_of_prime_card PrimeOrder.hCard

def foldKnowledgeError (i : Fin ‚Ñì) (_ : (pSpecFold (L := L)).ChallengeIdx) : ‚Ñù‚â•0 :=
  let err_SC := (1 : ‚Ñù‚â•0) / (Fintype.card L)
  
  let err_BE := if hi : œë ‚à£ (i.val + 1) then
    
    œë * (Fintype.card ((sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate)
      ‚ü®i.val + 1, by admit /- proof elided -/
        ‚ü©) : ‚Ñù‚â•0) / (Fintype.card L)
  else 0
  err_SC + err_BE

def inputRelation [DecidableEq F] (Œ¥ : ‚Ñù‚â•0) :
    Set
      (
        (Statement (k := k) F 0 √ó (‚àÄ j, OracleStatement (k := k) D x s 0 j)) √ó
        Witness F s d (0 : Fin (k + 2))
      ) :=
  match k with
  | 0 => FinalFoldPhase.inputRelation D x s d (round_bound dom_size_cond) Œ¥
  | .succ _ => FoldPhase.inputRelation D x s d 0 (round_bound dom_size_cond) Œ¥

protected def OracleVerifier.id :
    OracleVerifier oSpec Statement OStatement Statement OStatement !p[] where
  verify := fun stmt _ => pure stmt
  embed := Function.Embedding.inl
  hEq := fun _ => rfl

def ConcreteBTFieldAlgebra {l r : ‚Ñï} (h_le : l ‚â§ r) :
    Algebra (ConcreteBTField l) (ConcreteBTField r) := instAlgebraTowerConcreteBTF.toAlgebra h_le

local instance {Œ± : Type*} : Zero (Option Œ±) where
  zero := none

inductive Program where

OracleComp.simulateQ in VCVio.OracleComp.SimSemantics.SimulateQ

def computableNTTStage [Fact (LinearIndependent ùîΩq Œ≤)]
  (i : Fin ‚Ñì) (b : Fin (2 ^ (‚Ñì + R_rate)) ‚Üí L) : Fin (2^(‚Ñì + R_rate)) ‚Üí L :=
  have h_2_pow_i_lt_2_pow_‚Ñì_add_R_rate: 2^i.val < 2^(‚Ñì + R_rate) := by admit /- proof elided -/

ZeroMemClass in Mathlib.Algebra.Group.Submonoid.Defs

def factorOutTwos (n : ‚Ñï) : PowTwoRepr := Id.run do
  let mut two_exp := 0
  let mut odd_part := n

  while odd_part % 2 = 0 do
    two_exp := two_exp + 1
    odd_part := odd_part / 2

  return ‚ü®two_exp, odd_part‚ü©

def MLE' {n : ‚Ñï} (evals : Fin (2 ^ n) ‚Üí R) : MvPolynomial (Fin n) R :=
  MLE (evals ‚àò finFunctionFinEquiv)

instance instDCast‚ÇÇ : DCast‚ÇÇ Nat ProtocolSpec (fun _ pSpec => FullTranscript pSpec) where
  dcast‚ÇÇ h h' T := FullTranscript.cast h h' T
  dcast‚ÇÇ_id := cast_id

@[inline] def lagrangeToMonoLevel {n : ‚Ñï} (j : Fin n) : Vector R (2 ^ n) ‚Üí Vector R (2 ^ n) :=
  fun v =>
    let stride : ‚Ñï := 2 ^ j.val  
    Vector.ofFn (fun i : Fin (2 ^ n) =>
      if (BitVec.ofFin i).getLsb j then
        v[i] - v[i - stride]'(Nat.sub_lt_of_lt i.isLt)
      else
        v[i])

instance : OracleInterfaces (vPSpec.toProtocolSpec A) where
  oracleInterfaces := fun _ => some OracleInterface.instVector

Infinite in Mathlib.Data.Finite.Defs

class IsSecure
    (relation : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (Œµ_rbr : vPSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0)
    (vectorIOP : VectorIOP Statement OStatement Witness vPSpec A) where

   
  is_complete : vectorIOP.perfectCompleteness (pure ()) ‚ü®isEmptyElim‚ü© relation

   
  is_rbr_knowledge_sound :
    OracleProof.rbrKnowledgeSoundness (pure ()) ‚ü®isEmptyElim‚ü© relation vectorIOP.verifier Œµ_rbr

Neg in Init.Prelude

instance : HasSucc (Cayley T) where
  succ' := succ

Mathlib.Meta.NormNum.IsNat in Mathlib.Tactic.NormNum.Result

def finUInt16Equiv : Fin (2 ^ 16) ‚âÉ UInt16 where
  toFun := fun i => UInt16.ofFin i
  invFun := fun u => u.toFin
  left_inv _ := rfl
  right_inv _ := rfl

@[reducible]
def coreInteractionOracleReduction :=
  OracleReduction.append (oSpec:=[]‚Çí)
    (Stmt‚ÇÅ := Statement (L := L) (‚Ñì:=‚Ñì) (SumcheckBaseContext L ‚Ñì) 0)
    (Stmt‚ÇÇ := Statement (L := L) (‚Ñì:=‚Ñì) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì))
    (Stmt‚ÇÉ := FinalSumcheckStatementOut (L:=L) (‚Ñì:=‚Ñì))
    (Wit‚ÇÅ := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) 0)
    (Wit‚ÇÇ := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) (Fin.last ‚Ñì))
    (Wit‚ÇÉ := Unit)
    (OStmt‚ÇÅ := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë 0)
    (OStmt‚ÇÇ := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (OStmt‚ÇÉ := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (pSpec‚ÇÅ := pSpecSumcheckFold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (pSpec‚ÇÇ := pSpecFinalSumcheckStep (L:=L))
    (R‚ÇÅ := sumcheckFoldOracleReduction ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë))
    (R‚ÇÇ := finalSumcheckOracleReduction ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))

structure SumcheckMultiplierParam (L : Type) [CommRing L] (‚Ñì : ‚Ñï) (Context : Type := Unit) where
  multpoly : (ctx: Context) ‚Üí MultilinearPoly L ‚Ñì

instance instTestLensComplete : testLens.IsComplete
      outerRelIn_Test innerRelIn_Test outerRelOut_Test innerRelOut_Test
      (fun ‚ü®‚ü®p, q, _‚ü©, _‚ü© ‚ü®‚ü®f, _‚ü©, _‚ü© => p * q = f) where
  proj_complete := fun ‚ü®p, q, t‚ü© () hRelIn => by admit /- proof elided -/

@[reducible]
def messageLength (vPSpec : VectorSpec n) (i : MessageIdx vPSpec) : Nat := vPSpec.length i

noncomputable def E_and_Q_to_a_solution (e : ‚Ñï) (E Q : Polynomial F) (i : Fin n) : F :=
  if i < e then E.toFinsupp i else Q.toFinsupp (i - e)

List.cons in Init.Prelude

@[inline]
def ofInputOnly (projStmt : OuterStmtIn ‚Üí InnerStmtIn) :
    Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn OuterStmtOut :=
  ‚ü®projStmt, fun _ => id‚ü©

def FullData.map {Œ± Œ≤ : Type} (f : Œ± ‚Üí Œ≤) {s : Skeleton}
    (tree : FullData Œ± s) : FullData Œ≤ s :=
  match tree with
  | FullData.leaf value => FullData.leaf (f value)
  | FullData.internal value left right =>
    FullData.internal (f value) (left.map f) (right.map f)

def statelessOracle (baseSpec : OracleSpec Œπ‚Çú) (spec : OracleSpec Œπ)
    (f : (i : Œπ) ‚Üí spec.domain i ‚Üí spec.range i) :
    SimOracle.Stateless (baseSpec ++‚Çí spec) baseSpec where
  impl
  | query (.inl i) t => query i t
  | query (.inr i) t => pure (f i t)

def fflatten {A : Sort u} {F : A ‚Üí Sort v} {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï}
    {Œ± : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí A}
    (v : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí F (Œ± i j)) : (k : Fin (vsum n)) ‚Üí F (Fin.vflatten Œ± k) :=
  match m with
  | 0 => !h[]
  | _ + 1 => fappend (v 0) (fflatten (fun i => v i.succ))

@[reducible, simp] def OStmtIn := fun _ : Fin 2 => OStatement

HPow in Init.Prelude

def ExtractabilityAdversary (oSpec : OracleSpec Œπ) (Data Commitment AuxState : Type)
    [O : OracleInterface Data] :=
  OracleComp oSpec (Commitment √ó O.Query √ó O.Response √ó AuxState)

noncomputable def getFoldProverFinalOutput (i : Fin ‚Ñì)
    (finalPrvState : foldPrvState ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      i 2 (Context := Context)) :
  ((Statement (L := L) Context i.succ √ó ((j : Fin (toOutCodewordsCount ‚Ñì œë i.castSucc)) ‚Üí
    OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j))
      √ó Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ) :=

def relayPrvState (i : Fin ‚Ñì) : Fin (0 + 1) ‚Üí Type := fun
  | ‚ü®0, _‚ü© => Statement (L := L) Context i.succ √ó
    (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j) √ó
    Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ

def new (domainSeparator : DomainSeparator U H) (csrng : R) : FSProverState U H R :=
  let hashState := HashStateWithInstructions.new domainSeparator
  
  let rng : ProverPrivateRng R := { ds := (), csrng := csrng }
  { rng := rng, hashState := hashState, nargString := ByteArray.empty }

def relation (cs : ConstraintSystem ùì° numWires numGates) (‚Ñì : ‚Ñï) (h‚Ñì : ‚Ñì ‚â§ numWires) :
    (publicInputs : Fin ‚Ñì ‚Üí ùì°) ‚Üí (privateWitness : Fin (numWires - ‚Ñì) ‚Üí ùì°) ‚Üí Prop :=
  fun (x : Fin ‚Ñì ‚Üí ùì°) (œâ : Fin (numWires - ‚Ñì) ‚Üí ùì°) =>
    let combined := Fin.append x œâ ‚àò Fin.cast (by admit /- proof elided -/
    )
    cs.accepts combined

@[reducible]
def C : R ‚Üí+* P := algebraMap R P

partial def verifyCertificate (n' : Q(‚Ñï)) (n : ‚Ñï) :
    UnverifiedPrattCertificate n ‚Üí MetaM Q(Nat.Prime $n')
  | .knownPrime n => verifySmallPrime n'
  | .of n a part => do
      let cert ‚Üê generateCertificate n' n a part
      return q(PrattCertificate.out $cert)
  where
  generateCertificate (n' : Q(‚Ñï)) (_ : ‚Ñï) (a : ‚Ñï) (part : UnverifiedPrattPart) :
      MetaM Q(PrattCertificate $n') := do
    have alit : Q(‚Ñï) := mkRawNatLit a
    let ‚ü®a', pa'‚ü© ‚Üê mkOfNat q(ZMod $n') q(instAddMonoidWithOne) alit
    let hpow : Q($a' ^ ($n' - 1) = 1) ‚Üê verifyEqOne n' alit a' pa'
    let result ‚Üê generatePart n' a' alit pa' part
    haveI : $(result.1) =Q $n' - 1 := ‚ü®‚ü©
    return q(PrattCertificate.mk $a' $hpow $(result.2))
  generatePart (n' : Q(‚Ñï)) (a : Q(ZMod $n')) (a' : Q(‚Ñï)) (pa' : Q(($a' : ZMod $n') = $a)) :
      UnverifiedPrattPart ‚Üí MetaM ((nn : Q(‚Ñï)) √ó Q(PrattPart $n' $a $nn))
    | .prime p k hp => do
      
      have plit : Q(‚Ñï) := mkRawNatLit p
      let inner ‚Üê verifyCertificate plit p hp
      have pklit : Q(‚Ñï) := mkRawNatLit (p ^ k)
      have klit : Q(‚Ñï) := mkRawNatLit k
      let hpow ‚Üê verifyNeOne n' a' plit a pa'
      haveI : $pklit =Q $plit ^ $klit := ‚ü®‚ü©
      return ‚ü®pklit, q(PrattPart.prime $plit $klit _ $inner $hpow (.refl _))‚ü©
    | .split left right => do
      let ‚ü®nleft, pleft‚ü© ‚Üê generatePart n' a a' pa' left
      let ‚ü®nright, pright‚ü© ‚Üê generatePart n' a a' pa' right
      
      have nn : Q(‚Ñï) := mkRawNatLit (nleft.natLit! * nright.natLit!)
      haveI : $nn =Q $nleft * $nright := ‚ü®‚ü©
      return ‚ü®nn, q(PrattPart.split $nleft $nright $pleft $pright (.refl _))‚ü©

Submodule.map in Mathlib.Algebra.Module.Submodule.Map

HEq in Init.Prelude

abbrev Field := ZMod fieldSize

@[inline] def ofNat' (k : Nat) : AssocNat :=
  ‚ü®fun m => k + m, fun m => Nat.add_assoc k m 1‚ü©

OracleSpec.append in VCVio.OracleComp.OracleSpec

instance : ‚àÄ j, OracleInterface ((pSpecRelay).Message j)
  | ‚ü®x, h‚ü© => by admit /- proof elided -/

def Function.extendDomain {Œ± Œ≤ : Type*} [DecidableEq Œ±] [Zero Œ≤] {s : Finset Œ±}
    (f : (x : Œ±) ‚Üí (x ‚àà s) ‚Üí Œ≤) : Œ± ‚Üí Œ≤ :=
  fun x ‚Ü¶ if hx : x ‚àà s then f x hx else 0

class VerifierOnly (pSpec : ProtocolSpec 1) extends VerifierFirst pSpec

def take (j : Fin (k + 1)) (messages : MessagesUpTo k pSpec) :
    MessagesUpTo (j.castLE (by admit /- proof elided -/
    )) pSpec :=
  fun i => messages ‚ü®i.val.castLE (by admit /- proof elided -/
  ), i.property‚ü©

List.splitBy in Init.Data.List.Basic

def finIdxOfIfTrue [BEq Œ±] [LawfulBEq Œ±] (a : Œ±) (l : List Œ±) (h : a ‚àà l) : Fin l.length :=
  ‚ü®List.idxOf' a l, by admit /- proof elided -/
  ‚ü©

@[reducible, inline, specialize]
def UniPoly (R : Type*) := Array R

System.FilePath.addExtension in Init.System.FilePath

instance : Field ScalarField := ZMod.instField scalarFieldSize

def srSoundnessGame (P : Prover.StateRestoration.Soundness oSpec StmtIn pSpec) :
    OracleComp (oSpec ++‚Çí (srChallengeOracle StmtIn pSpec))
      (pSpec.FullTranscript √ó StmtIn) := do
  let ‚ü®stmtIn, messages‚ü© ‚Üê P
  let transcript ‚Üê messages.deriveTranscriptSR stmtIn
  return ‚ü®transcript, stmtIn‚ü©

def getNargString (state : FSProverState U H R) : ByteArray := state.nargString

def projectToMidSumcheckPoly (t : MultilinearPoly L ‚Ñì)
    (m : MultilinearPoly L ‚Ñì) (i : Fin (‚Ñì + 1))
    (challenges : Fin i ‚Üí L)
    : MultiquadraticPoly L (‚Ñì-i) :=
  let H‚ÇÄ: MultiquadraticPoly L ‚Ñì := computeInitialSumcheckPoly (‚Ñì:=‚Ñì) t m
  let H·µ¢ := fixFirstVariablesOfMQP (‚Ñì := ‚Ñì) (v := ‚ü®i, by admit /- proof elided -/
  ‚ü©)
    (H := H‚ÇÄ) (challenges := challenges)
  ‚ü®H·µ¢, by admit /- proof elided -/
  ‚ü©

def sumcheckConsistencyProp {k : ‚Ñï} (sumcheckTarget : L) (H : L‚¶É‚â§ 2‚¶Ñ[X Fin (k)]) : Prop :=
  sumcheckTarget = ‚àë x ‚àà (univ.map ùìë) ^·∂† (k), H.val.eval x

def ratchetUnchecked [Permute C] (sponge : DuplexSponge U C) : DuplexSponge U C :=
  simulateQ' forwardPermutationOracleImpl (ratchet sponge) (by admit /- proof elided -/
  )

Set.range in Mathlib.Data.Set.Operations

@[reducible]
def foldCommitOracleVerifier (i : Fin ‚Ñì) (hCR : isCommitmentRound ‚Ñì œë i) :
  OracleVerifier []‚Çí
    (StmtIn := Statement (L := L) Context i.castSucc)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.succ)
    (pSpec := pSpecFoldCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) :=
    OracleVerifier.append (oSpec:=[]‚Çí)
      (pSpec‚ÇÅ := pSpecFold (L:=L))
      (pSpec‚ÇÇ := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)
      (V‚ÇÅ := foldOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)
      (V‚ÇÇ := commitOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hCR)

structure Rewinding (oSpec : OracleSpec Œπ)
    (StmtIn StmtOut WitIn WitOut : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n) where
   
  ExtState : Type
   
  simChallenge : SimOracle.Stateful [pSpec.Challenge]‚Çí [pSpec.Challenge]‚Çí ExtState
   
  simOracle : SimOracle.Stateful oSpec oSpec ExtState
   
  runExt : StmtOut ‚Üí WitOut ‚Üí StmtIn ‚Üí
    StateT ExtState (OracleComp (OracleSpec.proverOracle StmtIn pSpec)) WitIn

@[simp]
def finRangeTo {k : ‚Ñï} (i : ‚Ñï) : Finset (Fin k) :=
  (List.take i (List.finRange k)).toFinset

@[inline, specialize]
def neg {R : Type*} [Ring R] [BEq R] (p : QuotientUniPoly R) : QuotientUniPoly R :=
  Quotient.lift neg_descending neg_descends p

instance : IsEmpty (OracleQuery []‚Çí Œ±) where
  false := by admit /- proof elided -/

def finSuccEquivNth' (i : Fin n) : Fin n ‚âÉ Option (Fin (n - 1)) :=

instance polyIrreducible (n : ‚Ñï) : Irreducible (poly n) := (BinaryTowerAux n).2.instIrreduciblePoly

MvPolynomial.monomial in Mathlib.Algebra.MvPolynomial.Basic

@[reducible, inline]
instance instPolynomialDegreeLT : OracleInterface (R‚¶É< d‚¶Ñ[X]) where
  Query := R
  Response := R
  answer := fun ‚ü®poly, _‚ü© point => poly.eval point

instance (priority := high) : MonadLiftT (OracleComp []‚Çí) (OracleComp spec) where
  monadLift := OracleComp.construct pure (fun a => by admit /- proof elided -/
  ) failure

instance instDCast‚ÇÅ‚ÇÇ : DCast (Œ≤ a) (Œ≥ a) where
  dcast hb c := dcast‚ÇÇ (Eq.refl a) (by admit /- proof elided -/
  ) c
  dcast_id := by admit /- proof elided -/

def checkSrs (proveSrs : Vector G‚ÇÅ (n + 1)) (verifySrs : Vector G‚ÇÇ 2) : Prop :=
  ‚àÄ i : Fin n,
    pairing (proveSrs[i.succ]) (verifySrs[0]) = pairing (proveSrs[i.castSucc]) (verifySrs[1])

@[inline] def lt [Zero T] [ToNat T] (a b : Cayley T) : Prop :=
  (‚Üëa : Nat) < (‚Üëb : Nat)

Nat.Prime in Mathlib.Data.Nat.Prime.Defs

Fin.removeNth in Mathlib.Data.Fin.Tuple.Basic

class GenMutualCorrParams (P : Params Œπ F) (S : ‚àÄ i : Fin (M + 1), Finset (Œπ i)) where

  Œ¥ : Fin (M + 1) ‚Üí ‚Ñù‚â•0
  dist : (i : Fin (M + 1)) ‚Üí Fin ((P.foldingParam i) + 1) ‚Üí ‚Ñù‚â•0


  œÜ : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), (indexPowT (S i) (P.œÜ i) j) ‚Ü™ F

  inst1 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Fintype (indexPowT (S i) (P.œÜ i) j)
  inst2 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    Nonempty (indexPowT (S i) (P.œÜ i) j)
  inst3 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    DecidableEq (indexPowT (S i) (P.œÜ i) j)
  inst4 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Smooth (œÜ i j)

  par‚Ñì_type : ‚àÄ i : Fin (M + 1), ‚àÄ _ : Fin ((P.foldingParam i) + 1), Type
  inst5 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Fintype (par‚Ñì_type i j)

  exp : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), (par‚Ñì_type i j) ‚Ü™ ‚Ñï



  Gen_Œ± : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    ProximityGenerator (indexPowT (S i) (P.œÜ i) j) F :=
      fun i j => RSGenerator.genRSC (par‚Ñì_type i j) (œÜ i j) (P.varCount i - j) (exp i j)

  inst6 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Fintype (Gen_Œ± i j).par‚Ñì

  BStar : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    (Set ((indexPowT (S i) (P.œÜ i) j) ‚Üí F)) ‚Üí Type ‚Üí ‚Ñù‚â•0
  errStar : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    (Set ((indexPowT (S i) (P.œÜ i) j) ‚Üí F)) ‚Üí Type ‚Üí ‚Ñù ‚Üí ENNReal

  C : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Set ((indexPowT (S i) (P.œÜ i) j) ‚Üí F)
  hcode : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), (C i j) = (Gen_Œ± i j).C

  h : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    hasMutualCorrAgreement (Gen_Œ± i j)
      (BStar i j (C i j) (Gen_Œ± i j).par‚Ñì)
      (errStar i j (C i j) (Gen_Œ± i j).par‚Ñì)

  h‚Ñì_bound : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    Fintype.card (Gen_Œ± i j).par‚Ñì = 2
  h‚Ñì_bound' : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    Fintype.card (par‚Ñì_type i j) = 2

  hŒ¥Le : ‚àÄ i : Fin (M + 1),
    (Œ¥ i) ‚â§ 1 - Finset.univ.sup (fun j => BStar i j (C i j) (Gen_Œ± i j).par‚Ñì)

  hlistDecode : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    listDecodable (C i j) (Œ¥ i) (dist i j)

structure FSVerifierState (U : Type) [SpongeUnit U] (H : Type*) [DuplexSpongeInterface U H] where
   
  hashState : HashStateWithInstructions U H
   
  nargString : ByteArray
deriving Repr

def toRoundByRound (E : RoundByRoundOneShot oSpec StmtIn WitIn pSpec) :
    RoundByRound oSpec StmtIn WitIn WitOut pSpec (fun _ => WitIn) where
  eqIn := rfl
  extractMid := fun m stmtIn tr witIn =>
    if m.castSucc = 0 then witIn else E m.castSucc stmtIn (Fin.init tr) default
  extractOut := fun stmtIn tr _ => E (.last n) stmtIn tr default

noncomputable def relayOracleReduction (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
  OracleReduction (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) Context i.succ)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (pSpec := pSpecRelay) where
  prover := relayOracleProver ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hNCR
  verifier := relayOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hNCR

def vconcat {n : ‚Ñï} (v : Fin n ‚Üí Œ±) (a : Œ±) : Fin (n + 1) ‚Üí Œ± :=
  dconcat v a

@[inline, reducible]
protected def id :
    Statement.Lens OuterStmtIn OuterStmtOut OuterStmtIn OuterStmtOut :=
  PFunctor.Lens.id _

alias trivial := Statement.Lens.id

def eval (p : MlPolyEval R n) (x : Vector R n) : R :=
  Vector.dotProduct p (lagrangeBasis x)

@[inline, specialize]
def prover : Prover oSpec Statement Witness (Statement √ó Witness) Unit (pSpec Witness) where
  PrvState
  | 0 => Statement √ó Witness
  | 1 => Statement √ó Witness
  input := id
  sendMessage | ‚ü®0, _‚ü© => fun ‚ü®stmt, wit‚ü© => pure (wit, ‚ü®stmt, wit‚ü©)
  receiveChallenge | ‚ü®0, h‚ü© => nomatch h
  output := fun ‚ü®stmt, wit‚ü© => pure (‚ü®stmt, wit‚ü©, ())

def widthDiv4 : Nat := params.width / 4

Polynomial.eval‚ÇÇRingHom in Mathlib.Algebra.Polynomial.Eval.Defs

def AlgebraTowerEquiv.toAlgebraOverRight (e : AlgebraTowerEquiv A B) (i j : Œπ)
    (h : i ‚â§ j) : Algebra (B i) (A j) :=

def baseFoldMatrix (i : Fin r) (h_i : i + 1 < ‚Ñì + ùì°)
    (y : ‚Ü•(sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®‚Üëi + 1, by admit /- proof elided -/
    ‚ü©)) : Matrix (Fin 2) (Fin 2) L :=
  let fiberMap := qMap_total_fiber ùîΩq Œ≤ (i := i) (steps := 1)
      (h_i_add_steps := h_i) (y := y)
  let x‚ÇÄ := fiberMap 0
  let x‚ÇÅ := fiberMap 1
  fun i j => match i, j with
  | 0, 0 => x‚ÇÅ
  | 0, 1 => -x‚ÇÄ
  | 1, 0 => -1
  | 1, 1 => 1

String.intercalate in Init.Data.String.Defs

def outputRelation (cond : ‚àë i, (s i).1 ‚â§ n) [DecidableEq F] (Œ¥ : ‚Ñù‚â•0) :
    Set
      (
        (FinalStatement F k √ó ‚àÄ j, FinalOracleStatement D x s j) √ó
        Witness F s d (Fin.last (k + 1))
      ) := sorry

UInt8.size in Init.Prelude

def removeRedundantEntryDS (log : QueryLog (duplexSpongeChallengeOracle StmtIn U)) :
    {log : QueryLog (duplexSpongeChallengeOracle StmtIn U) | log.NoRedundantEntryDS} :=
  sorry

def BTField_succ_alg_equiv_adjoinRoot (k : ‚Ñï) :
  AdjoinRoot (poly k) ‚âÉ‚Çê[BTField k] BTField (k + 1) :=

Fin.addNat in Init.Data.Fin.Basic

Submodule.module in Mathlib.Algebra.Module.Submodule.Defs

def AlgebraTowerEquiv.algebraMapLeftUp (e : AlgebraTowerEquiv A B) (i j : Œπ)
    (h : i ‚â§ j) : (B i) ‚Üí+* (A j) :=

def RAW_CONSTANTS_24 : Vector KoalaBear.Field 215 := #v[
    487143900,
    1829048205,
    1652578477,
    646002781,
    1044144830,
    53279448,
    1519499836,
    22697702,
    1768655004,
    230479744,
    1484895689,
    705130286,
    1429811285,
    1695785093,
    1417332623,
    1115801016,
    1048199020,
    878062617,
    738518649,
    249004596,
    1601837737,
    24601614,
    245692625,
    364803730,
    1857019234,
    1906668230,
    1916890890,
    835590867,
    557228239,
    352829675,
    515301498,
    973918075,
    954515249,
    1142063750,
    1795549558,
    608869266,
    1850421928,
    2028872854,
    1197543771,
    1027240055,
    1976813168,
    963257461,
    652017844,
    2113212249,
    213459679,
    90747280,
    1540619478,
    324138382,
    1377377119,
    294744504,
    512472871,
    668081958,
    907306515,
    518526882,
    1907091534,
    1152942192,
    1572881424,
    720020214,
    729527057,
    1762035789,
    86171731,
    205890068,
    453077400,
    1201344594,
    986483134,
    125174298,
    2050269685,
    1895332113,
    749706654,
    40566555,
    742540942,
    1735551813,
    162985276,
    1943496073,
    1469312688,
    703013107,
    1979485151,
    1278193166,
    548674995,
    2118718736,
    749596440,
    1476142294,
    1293606474,
    918523452,
    890353212,
    1691895663,
    1932240646,
    1180911992,
    86098300,
    1592168978,
    895077289,
    724819849,
    1697986774,
    1608418116,
    1083269213,
    691256798,
    328586442,
    1572520009,
    1375479591,
    322991001,
    967600467,
    1172861548,
    1973891356,
    1503625929,
    1881993531,
    40601941,
    1155570620,
    571547775,
    1361622243,
    1495024047,
    1733254248,
    964808915,
    763558040,
    1887228519,
    994888261,
    718330940,
    213359415,
    603124968,
    1038411577,
    2099454809,
    949846777,
    630926956,
    1168723439,
    222917504,
    1527025973,
    1009157017,
    2029957881,
    805977836,
    1347511739,
    540019059,
    589807745,
    440771316,
    1530063406,
    761076336,
    87974206,
    1412686751,
    1230318064,
    514464425,
    1469011754,
    1770970737,
    1510972858,
    965357206,
    209398053,
    778802532,
    40567006,
    1984217577,
    1545851069,
    879801839,
    1611910970,
    1215591048,
    330802499,
    1051639108,
    321036,
    511927202,
    591603098,
    1775897642,
    115598532,
    278200718,
    233743176,
    525096211,
    1335507608,
    830017835,
    1380629279,
    560028578,
    598425701,
    302162385,
    567434115,
    1859222575,
    958294793,
    1582225556,
    1781487858,
    1570246000,
    1067748446,
    526608119,
    1666453343,
    1786918381,
    348203640,
    1860035017,
    1489902626,
    1904576699,
    860033965,
    1954077639,
    1685771567,
    971513929,
    1877873770,
    137113380,
    520695829,
    806829080,
    1408699405,
    1613277964,
    793223662,
    648443918,
    893435011,
    403879071,
    1363789863,
    1662900517,
    2043370,
    2109755796,
    931751726,
    2091644718,
    606977583,
    185050397,
    946157136,
    1350065230,
    1625860064,
    122045240,
    880989921,
    145137438,
    1059782436,
    1477755661,
    335465138,
    1640704282,
    1757946479,
    1551204074,
    681266718,
]

Nat.clog in Mathlib.Data.Nat.Log

@[inline, specialize]
def add {R : Type*} [Ring R] [BEq R] [LawfulBEq R] (p q : QuotientUniPoly R) : QuotientUniPoly R :=
  Quotient.lift‚ÇÇ add_descending add_descends p q

instance : MvPolynomialLike œÉ R (MvPolynomial œÉ R) where
  X := MvPolynomial.X
  eval‚ÇÇ := fun f g => eval‚ÇÇHom f g
  eval‚ÇÇ_C := fun f g r => by admit /- proof elided -/

instance : ‚àÄ i, VCVCompatible ((pSpec Witness).Challenge i) | ‚ü®0, h‚ü© => nomatch h

OracleComp.inductionOn in VCVio.OracleComp.OracleComp

def intCast {k : ‚Ñï} (n : ‚Ñ§) : ConcreteBTField k := if n % 2 = 0 then zero else one

Polynomial.eval‚ÇÇ in Mathlib.Algebra.Polynomial.Eval.Defs

zsmulRec in Mathlib.Algebra.Group.Defs

@[reducible, simp]
def relIn : Set ((StmtIn √ó ‚àÄ i, OStmtIn OStatement i) √ó WitIn) :=
  { ‚ü®‚ü®(), oracles‚ü©, ()‚ü© | oracles 0 = oracles 1 }

instance : Add (Cayley T) where
  add := add

OracleComp in VCVio.OracleComp.OracleComp

Unit in Init.Prelude

abbrev MatrixSubmodule.{u, v, w} (Œ∫ : Type u) [Fintype Œ∫] (Œπ : Type v) [Fintype Œπ]
                                 (F : Type w) [Semiring F] : Type (max u v w) :=
  Submodule F (Matrix Œ∫ Œπ F)

@[reducible, simp] def OStmtOut : Unit ‚Üí Type := fun _ => R‚¶É‚â§ deg‚¶Ñ[X]

instance {Œ± : Type u} : Slice (List Œ±) Nat Nat (fun _ _ _ => True) (fun _ _ _ _ => List Œ±) where
  slice xs start stop _ := xs.extract start stop

Sum.inr in Init.Core

def proximityChecksSpec (Œ≥_challenges :
    Fin Œ≥_repetitions ‚Üí sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®0, by omega‚ü©)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì) j)
    (fold_challenges : Fin ‚Ñì ‚Üí L) (final_constant : L) : Prop :=
  ‚àÄ rep : Fin Œ≥_repetitions,
    let v := Œ≥_challenges rep
    -- For all folding levels k = 0, ..., ‚Ñì/œë - 1, we track c_cur through the iterations
    ‚àÄ k_val : Fin (‚Ñì / œë),
      let i := k_val.val * œë
      have h_k: k_val ‚â§ (‚Ñì/œë - 1) := by omega
      have h_i_add_œë_le_‚Ñì : i + œë ‚â§ ‚Ñì := by
        calc i + œë = k_val * œë + œë := by omega
          _ ‚â§ (‚Ñì/œë - 1) * œë + œë := by
            apply Nat.add_le_add_right; apply Nat.mul_le_mul_right; omega
          _ = ‚Ñì/œë * œë :=

def challengeQueryImpl {pSpec : ProtocolSpec n} [‚àÄ i, SelectableType (pSpec.Challenge i)] :
    QueryImpl ([pSpec.Challenge]‚Çí'challengeOracleInterface) ProbComp where
  impl | query i () => uniformOfFintype (pSpec.Challenge i)

noncomputable instance changeOfBasisMatrix_invertible
  (‚Ñì : Nat) (h_‚Ñì : ‚Ñì ‚â§ r) :
  Invertible (changeOfBasisMatrix ùîΩq Œ≤ ‚Ñì h_‚Ñì) :=

noncomputable def finalFoldProver :
  OracleProver []‚Çí
    (Statement F (Fin.last k)) (OracleStatement D x s (Fin.last k))
      (Witness F s d (Fin.last k).castSucc)
    (FinalStatement F k) (FinalOracleStatement D x s)
      (Witness F s d (Fin.last (k + 1)))
    (pSpec F) where
  PrvState
  | 0 =>
    (Statement F (Fin.last k) √ó ((j : Fin (k + 1)) ‚Üí OracleStatement D x s (Fin.last k) j)) √ó
      Witness F s d (Fin.last k).castSucc
  | _ =>
    (FinalStatement F k √ó ((j : Fin (k + 1)) ‚Üí OracleStatement D x s (Fin.last k) j)) √ó
      Witness F s d (Fin.last (k + 1))

  input := id

  sendMessage
  | ‚ü®0, h‚ü© => nomatch h
  | ‚ü®1, _‚ü© => fun ‚ü®‚ü®chals, o‚ü©, p‚ü© =>
    pure ‚ü®fun x => p.1, ‚ü®‚ü®chals, o‚ü©, p‚ü©‚ü©

  receiveChallenge
  | ‚ü®0, _‚ü© => fun ‚ü®‚ü®chals, o‚ü©, p‚ü© => pure <|
    fun (Œ± : F) =>
      ‚ü®
        ‚ü®Fin.vappend chals !v[Œ±], o‚ü©,
        ‚ü®
          p.1.foldNth (2 ^ (s (Fin.last k)).1) Œ±,
          by admit /- proof elided -/
        ‚ü©
      ‚ü©
  | ‚ü®1, h‚ü© => nomatch h

  output := fun ‚ü®‚ü®chals, o‚ü©, p‚ü© => pure <|
    ‚ü®
      ‚ü®
        chals,
        fun j => by admit /- proof elided -/
      ‚ü©,
      p
    ‚ü©

Finset.Ico in Mathlib.Order.Interval.Finset.Defs

@[simp]
def BTField (k : ‚Ñï) := (BinaryTowerAux k).1

structure InitialStatement where
  
  t_eval_point : Fin ‚Ñì ‚Üí L         
  original_claim : L               

@[simp]
abbrev Statement.AfterFirstSumcheck : Type :=
  FirstSumcheckChallenge R pp √ó Statement.AfterFirstChallenge R pp

private def toWeightAssignment
  (p : MvPolynomial (Fin m) F)
  (b : Fin m ‚Üí Fin 2) : Fin (m+1) ‚Üí F :=
    let b' : Fin m ‚Üí F := fun i => ‚Üë(b i : ‚Ñï)
    Fin.cases (MvPolynomial.eval b' p)
              (fun i => ‚Üë(b i : ‚Ñï))

@[reducible, simp]
def toRelOut : Set ((Statement √ó Witness) √ó Unit) :=
  Prod.fst ‚Åª¬π' relIn

@[inline, reducible]
def OracleStatement.Lens (OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut : Type)
    {Outer_Œπ‚Çõ·µ¢ : Type} (OuterOStmtIn : Outer_Œπ‚Çõ·µ¢ ‚Üí Type) [‚àÄ i, OracleInterface (OuterOStmtIn i)]
    {Outer_Œπ‚Çõ‚Çí : Type} (OuterOStmtOut : Outer_Œπ‚Çõ‚Çí ‚Üí Type) [‚àÄ i, OracleInterface (OuterOStmtOut i)]
    {Inner_Œπ‚Çõ·µ¢ : Type} (InnerOStmtIn : Inner_Œπ‚Çõ·µ¢ ‚Üí Type) [‚àÄ i, OracleInterface (InnerOStmtIn i)]
    {Inner_Œπ‚Çõ‚Çí : Type} (InnerOStmtOut : Inner_Œπ‚Çõ‚Çí ‚Üí Type) [‚àÄ i, OracleInterface (InnerOStmtOut i)]
  :=
    Statement.Lens (OuterStmtIn √ó ‚àÄ i, OuterOStmtIn i) (OuterStmtOut √ó ‚àÄ i, OuterOStmtOut i)
                  (InnerStmtIn √ó ‚àÄ i, InnerOStmtIn i) (InnerStmtOut √ó ‚àÄ i, InnerOStmtOut i)

def LeafData.leftSubtree {Œ± : Type} {s_left s_right : Skeleton}
    (tree : LeafData Œ± (Skeleton.internal s_left s_right)) :
    LeafData Œ± s_left :=
  match tree with
  | LeafData.internal left _right =>
    left

@[reducible, simp]
def rbrSoundness
    (langIn : Set (Statement √ó ‚àÄ i, OStatement i))
    (verifier : OracleVerifier oSpec Statement OStatement Bool (fun _ : Empty => Unit) pSpec)
    (rbrSoundnessError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) : Prop :=
  verifier.rbrSoundness init impl langIn acceptRejectOracleRel.language rbrSoundnessError

def canonicalEmbedding (k : ‚Ñï) : BTField k ‚Üí+* BTField (k+1) :=
  AdjoinRoot.of (poly k)

instance [Zero T] [ToNat T] : LT (Cayley T) where
  lt := lt

noncomputable def commitOracleReduction (i : Fin ‚Ñì) (hCR : isCommitmentRound ‚Ñì œë i) :
  OracleReduction (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) Context i.succ)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (pSpec := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) where
  prover := commitOracleProver ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i
  verifier := commitOracleVerifier ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hCR

@[reducible, inline, specialize]
def ChallengeUpTo (k : Fin (n + 1)) (pSpec : ProtocolSpec n) (i : pSpec.ChallengeIdxUpTo k) :=
  (pSpec‚ü¶:k.val‚üß).Challenge i

instance {n : ‚Ñï} {Œ± : Fin n ‚Üí Type*} : SliceGE ((i : Fin n) ‚Üí Œ± i) ‚Ñï
    (fun _ start => start ‚â§ n)
    (fun _ start h =>
      (i : Fin (n - start)) ‚Üí Œ± (Fin.cast (Nat.sub_add_cancel h) (i.addNat start)))
    where
  sliceGE := fun v start h => drop start h v

Mathlib.Meta.NormNum.instAddMonoidWithOne in Mathlib.Tactic.NormNum.Result

@[reducible]
def addSalt (pSpec : ProtocolSpec n) (Salt : pSpec.MessageIdx ‚Üí Type) :
    ProtocolSpec n :=
  ‚ü®pSpec.dir, fun i => match hDir : pSpec.dir i with
    | .P_to_V => (pSpec.¬´Type¬ª i) √ó Salt ‚ü®i, hDir‚ü©
    | .V_to_P => pSpec.¬´Type¬ª i‚ü©

def ar2 (k0 k1 : ‚Ñï) : Fin 2 ‚Üí ‚Ñï
  | ‚ü®0, _‚ü© => k0
  | ‚ü®1, _‚ü© => k1

def divide_by_2 (s : Finset ‚Ñï) : Finset ‚Ñï :=
  (erase_odd s).image (fun n => n / 2)

def hintBytes (state : FSProverState U H R) (hint : ByteArray) :
    Except DomainSeparatorMismatch (FSProverState U H R) :=
  match state.hashState.hint with
  | .ok newHashState =>
    
    
    .ok { rng := state.rng, hashState := newHashState, nargString := state.nargString }
  | .error e => .error e

Polynomial.Monic in Mathlib.Algebra.Polynomial.Degree.Definitions

def checkInitImports : IO Bool := do
  \n\
      The `header` linter is included in Mathlib.Init, and every file in Mathlib \
      should import Mathlib.Init.\nPlease adjust the imports accordingly."
    return true

  e

def InputStatement := R

instance {Œ± : Type u} : SliceLT (List Œ±) Nat (fun _ _ => True) (fun _ _ _ => List Œ±) where
  sliceLT xs stop _ := List.take stop xs

structure PrattCertificate (p : ‚Ñï) : Type where
  a : ZMod p
  pow_eq_one : a ^ (p - 1) = 1
  part : PrattPart p a (p - 1)

def sub (a b : AssocNat) : AssocNat :=
  subNat a b.toNat

def neg_descending (p : UniPoly R) : QuotientUniPoly R :=
  Quotient.mk _ (neg p)

instance instToNat {n : ‚Ñï} : ToNat (CNat n) := match n with
  | 0 => by admit /- proof elided -/
  | .succ n => @Cayley.instToNatOfZero (CNat n) instHasSucc instZero instToNat

def foldStepRelOutProp (i : Fin ‚Ñì)
    (input : (Statement (L := L) Context i.succ √ó
      (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j)) √ó
      Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ) : Prop :=
  let stmt := input.1.1
  let oStmt := input.1.2
  let wit := input.2
  masterKStateProp (mp := mp) (ùìë := ùìë) ùîΩq Œ≤
    (stmtIdx := i.succ) (oracleIdx := i.castSucc)
    (h_le := Nat.le_of_lt (Fin.castSucc_lt_succ i)) stmt wit oStmt (localChecks := True)

def ratchet (ds : DomainSeparator U H) : DomainSeparator U H :=
  { io := ds.io ++ SEP_BYTE ++ "R" }

def oracleReduction : OracleReduction oSpec
      Statement OStatement Unit
      Unit (OStatement ‚äï·µ• OStatement) Unit (pSpec OStatement) where
  prover := oracleProver oSpec Statement OStatement
  verifier := oracleVerifier oSpec Statement OStatement relComp

def rightpadPowerOfTwo (unit : Œ±) (a : Array Œ±) : Array Œ± :=
  a.rightpad (2 ^ (Nat.clog 2 a.size)) unit

Finset.Ici in Mathlib.Order.Interval.Finset.Defs

@[reducible]
def MemoryRead (Œπ : Type u) (Œ± : Œπ ‚Üí Type v) := (index : Œπ) √ó (Œ± index)

def concreteTowerAlgebraMap (l r : ‚Ñï) (h_le : l ‚â§ r) :
    ConcreteBTField l ‚Üí+* ConcreteBTField r :=

@[reducible]
def GroupEncodeOracle : OracleSpec Unit := fun _ => (Œπ, BitVec bitLength)

noncomputable instance fintype_sDomain (i : Fin r) :
  Fintype (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i) :=

IsDomain in Mathlib.Algebra.Ring.Defs

noncomputable def uni2bi (p : Polynomial F) : MvPolynomial (Fin 2) F :=
  Polynomial.eval‚ÇÇ MvPolynomial.C (MvPolynomial.X 0) p

PowerSeries in Mathlib.RingTheory.PowerSeries.Basic

def Œ± (x‚ÇÄ : F) (R : F[X][X][Y]) (H : F[X][Y]) [œÜ : Fact (Irreducible H)] (t : ‚Ñï) : ùïÉ H :=
  let W : ùïÉ H := liftToFunctionField (H.leadingCoeff)
  embeddingOfùí™IntoùïÉ _ (Œ≤ R t) / (W ^ (t + 1) * (embeddingOfùí™IntoùïÉ _ (Œæ x‚ÇÄ R H)) ^ (2*t - 1))

List.Vector.mmap in Mathlib.Data.Vector.Basic

Finsupp.single in Mathlib.Data.Finsupp.Single

instance [h : VerifierFirst pSpec] : VerifierFirst pSpec where
  verifier_first' := by admit /- proof elided -/

instance : HListRepr (HList []) where
  repr := fun _ => ""

WeierstrassCurve in Mathlib.AlgebraicGeometry.EllipticCurve.Weierstrass

noncomputable def toPolynomialAlgHom : P ‚Üí‚Çê[R] R[X] := PolynomialLike.aeval Polynomial.X

structure ModifiedGuruswami
  (m n k : ‚Ñï)
  (œâs : Fin n ‚Ü™ F)
  (Q : F[Z][X][Y])
  (u‚ÇÄ u‚ÇÅ : Fin n ‚Üí F)
  where
  Q_ne_0 : Q ‚â† 0
   
  Q_deg : natWeightedDegree Q 1 k < D_X ((k + 1) / (n : ‚Ñö)) n m
   
  Q_multiplicity : ‚àÄ i, rootMultiplicity Q
              (Polynomial.C <| œâs i)
              ((Polynomial.C <| u‚ÇÄ i) + Polynomial.X * (Polynomial.C <| u‚ÇÅ i))
            ‚â• m
   
  Q_deg_X :
    degreeX Q < D_X ((k + 1) / (n : ‚Ñö)) n m
   
  Q_D_Y :
    D_Y Q < D_X (k + 1 / (n : ‚Ñö)) n m / k
   
  Q_D_YZ :
    D_YZ Q ‚â§ n * (m + 1/(2 : ‚Ñö))^3 / (6 * Real.sqrt ((k + 1) / n))

def queryRbrKnowledgeError := fun _ : (pSpecQuery ùîΩq Œ≤ Œ≥_repetitions
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).ChallengeIdx =>
  ((1/2 : ‚Ñù‚â•0) + (1 : ‚Ñù‚â•0) / (2 * 2^ùì°))^Œ≥_repetitions

PMF.uniformOfFintype in Mathlib.Probability.Distributions.Uniform

@[inline, reducible]
def Witness.InvLens (OuterStmtIn OuterWitIn OuterWitOut InnerWitIn InnerWitOut : Type)
    := PFunctor.Lens ((OuterStmtIn √ó OuterWitOut) X^ OuterWitIn)
                     (InnerWitOut X^ InnerWitIn)

inductive Lit where
  | scalar (val : F)
  
  
  | vector (len : Nat) (v : Fin len ‚Üí F)

instance : ‚àÄ i, OracleInterface (Message ‚ü®!v[.V_to_P], !v[Chal]‚ü© i)
  | ‚ü®0, h‚ü© => nomatch h

@[inline]
def neg [Neg R] (p : MlPolyEval R n) : MlPolyEval R n := p.map (fun a => -a)

instance : ‚àÄ j, OracleInterface ((batchSpec F m).Message j)
  | ‚ü®0, h‚ü© => nomatch h

@[reducible]
noncomputable def reduction [DecidableEq F] :
  OracleReduction []‚Çí
    (Statement F (0 : Fin (k + 1))) (OracleStatement D x s (0 : Fin (k + 1)))
      (Witness F s d (0 : Fin (k + 2)))
    (FinalStatement F k) (FinalOracleStatement D x s) (Witness F s d (Fin.last (k + 1)))
    (pSpecFold D x k s ++‚Çö FinalFoldPhase.pSpec F ++‚Çö QueryRound.pSpec D x l) :=
  OracleReduction.append (reductionFold D x k s d)
    (QueryRound.queryOracleReduction (k := k) D x s d dom_size_cond l)

Fin.rev in Init.Data.Fin.Basic

def squeezeUnchecked [Permute C] (sponge : DuplexSponge U C) (arr : Array U) :
    DuplexSponge U C √ó Array U :=
  simulateQ' (m := Id) forwardPermutationOracleImpl (squeezeInto sponge arr) (by admit /- proof elided -/
  )

finFunctionFinEquiv in Mathlib.Algebra.BigOperators.Fin

def collisionFwdBwd : Prop :=
  let ‚ü®baseTrace, _‚ü© := removeRedundantEntryDS trace
  ‚àÉ stateIn stateOut stateOut',
    (stateIn, stateOut) ‚àà baseTrace.getQ (.inr .Fwd) ‚àß
    (stateOut', stateIn) ‚àà baseTrace.getQ (.inr .Bwd) ‚àß
    stateOut ‚â† stateOut'

alias E_col_p_pinv := collisionFwdBwd

instance (priority := 1000) algebra_adjacent_tower (l : ‚Ñï) :
  Algebra (ConcreteBTField l) (ConcreteBTField (l + 1)) :=

def getLast (a : Array Œ±) (h : a.size > 0) : Œ± := a[a.size - 1]

Fin.castSucc in Init.Data.Fin.Basic

Polynomial.IsRoot in Mathlib.Algebra.Polynomial.Eval.Defs

abbrev Fwd : PermuteDir := Sum.inl ()

def queryKStateProp {m : Fin (1 + 1)}
  (tr : ProtocolSpec.Transcript m
    (pSpecQuery ùîΩq Œ≤ Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)))
  (stmt : FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì))
  (witMid : Unit)
  (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤ (œë := œë)
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì) j) : Prop :=
if h0 : m.val = 0 then
  
  Binius.BinaryBasefold.finalSumcheckRelOutProp ùîΩq Œ≤ (input:=‚ü®‚ü®stmt, oStmt‚ü©, witMid‚ü©)
else
    let r := stmt.ctx.t_eval_point
    let s := stmt.ctx.original_claim
    let challenges : Fin ‚Ñì ‚Üí L := stmt.challenges
    let tr_so_far := (pSpecQuery ùîΩq Œ≤ Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).take m m.is_le
    let chalIdx : tr_so_far.ChallengeIdx := ‚ü®‚ü®0,
      Nat.lt_of_succ_le (by admit /- proof elided -/
      )‚ü©, by admit /- proof elided -/
      ‚ü©
    let Œ≥_challenges : Fin Œ≥_repetitions ‚Üí sDomain ùîΩq
      Œ≤ h_‚Ñì_add_R_rate ‚ü®0, by admit /- proof elided -/
      ‚ü© := ((ProtocolSpec.Transcript.equivMessagesChallenges (k:=m)
        (pSpec:=pSpecQuery ùîΩq Œ≤ Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
        tr).2 chalIdx)
    let fold_challenges := stmt.challenges
    
    let proximityTestsCheck : Prop :=
      proximityChecksSpec ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (œë:=œë) Œ≥_repetitions Œ≥_challenges oStmt fold_challenges stmt.final_constant
    proximityTestsCheck

def dummyLastWitness :
    Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì) := {
  t := ‚ü®0, by admit /- proof elided -/
  ‚ü©,
  H := ‚ü®0, by admit /- proof elided -/
  ‚ü©,
  f := fun _ => 0
}

noncomputable instance {v : Œπ ‚Üí F} {s : AffineSubspace F (Œπ ‚Üí F)} [inst : Nonempty s] :
    Nonempty (v +·µ• s) :=

Nat.card in Mathlib.SetTheory.Cardinal.Finite

@[reducible, inline, specialize]
def MessagesUpTo (k : Fin (n + 1)) (pSpec : ProtocolSpec n) : Type :=
  ‚àÄ i, pSpec.MessageUpTo k i

instance coe_field_adjoinRoot (k : ‚Ñï) : Coe (AdjoinRoot (poly k)) (BTField (k+1)) where
  coe := Eq.mp (BTField_succ_eq_adjoinRoot k)

def singleHash (left : Œ±) (right : Œ±) : OracleComp (spec Œ±) Œ± := do
  let out ‚Üê query (spec := spec Œ±) () ‚ü®left, right‚ü©
  return out

WithTop in Mathlib.Order.TypeTags

@[reducible] def Proof {Œπ : Type} (oSpec : OracleSpec Œπ)
    (Statement Witness : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n) :=
  Reduction oSpec Statement Witness Bool Unit pSpec

structure SparseMatrix (m n Œ± : Type*) where
  numEntries : ‚Ñï
  row : Fin numEntries ‚Üí m
  col : Fin numEntries ‚Üí n
  val : Fin numEntries ‚Üí Œ±
deriving Inhabited, DecidableEq

DivisionSemiring in Mathlib.Algebra.Field.Defs

def toMessagesUpTo (transcript : Transcript k pSpec) : MessagesUpTo k pSpec :=
  fun ‚ü®i, _‚ü© => transcript i

SMul in Init.Prelude

noncomputable def decoder (e k : ‚Ñï) [NeZero n] (œâs f : Fin n ‚Üí F) : Option (Polynomial F) :=
  if ‚Äñf‚Äñ‚ÇÄ ‚â§ e
  then some 0
  else
    let x := linsolve (BerlekampWelchMatrix e k œâs f) (Rhs e œâs f)
    match x with
    | none => none
    | some x =>
      let E := solutionToE e k x
      let Q := solutionToQ e k x
      if Q % E = 0 then
        let p := Q / E
        if Œî‚ÇÄ(f, p.eval ‚àò œâs) ‚â§ e then
          some p
        else
          none
      else
        none

class ProverFirst (pSpec : ProtocolSpec n) [NeZero n] where
  prover_first' : pSpec.dir 0 = .P_to_V

instance [ToString Œ±] (Œ±s : List Type) [HListString (HList Œ±s)] :
    HListString (HList (Œ± :: Œ±s)) where
  toString
  | HList.cons x xs =>
    match xs with
    | HList.nil => toString x
    | HList.cons _ _ => toString x ++ ", " ++ HListString.toString xs

def finalSumcheckRelOut :
    Set ((FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì) √ó
      (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì) j)) √ó
      (Unit)) :=
  { input | finalSumcheckRelOutProp ùîΩq Œ≤ (input := input) }

@[elab_as_elim]
def dappend {m n : ‚Ñï} {motive : Fin (m + n) ‚Üí Sort u}
    (u : (i : Fin m) ‚Üí motive (Fin.castAdd n i))
    (v : (i : Fin n) ‚Üí motive (Fin.natAdd m i))
    (i : Fin (m + n)) : motive i :=
  match n with
  | 0 => u i
  | k + 1 => dconcat (dappend u (fun i => v (Fin.castSucc i))) (v (Fin.last k)) i

noncomputable def toMLE (A : Matrix (Fin (2 ^ m)) (Fin (2 ^ n)) R) : R[X Fin n][X Fin m] :=
  MLE' (MLE' ‚àò A)

instance {Œ± : Type} [Sampleable Œ±] : DecidableEq Œ± := inferInstance

@[reducible]
def sumcheckFoldOracleVerifier :=
  let stmt : Fin (‚Ñì / œë - 1 + 1) ‚Üí Type :=
    fun i => Statement (L := L) (‚Ñì := ‚Ñì) Context ‚ü®i * œë, blockIdx_mul_œë_lt_‚Ñì_succ i‚ü©
  let oStmt :=
    fun i: Fin (‚Ñì / œë - 1 + 1) => OracleStatement ùîΩq Œ≤ œë ‚ü®i * œë, blockIdx_mul_œë_lt_‚Ñì_succ i‚ü©
  let nonLastBlocksOracleVerifier :=
  OracleVerifier.seqCompose (oSpec := []‚Çí)
      (Stmt := stmt)
      (OStmt := oStmt)
      (pSpec := fun (bIdx: Fin (‚Ñì / œë - 1)) => pSpecFullNonLastBlock ùîΩq Œ≤ bIdx)
      (V := fun bIdx => nonLastBlockOracleVerifier (L:=L) ùîΩq Œ≤ (œë:=œë) (bIdx:=bIdx))

  let lastOracleVerifier := lastBlockOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)

  let sumcheckFoldOV: OracleVerifier []‚Çí
    (StmtIn := Statement (L := L) (‚Ñì := ‚Ñì) Context 0)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë 0)
    (StmtOut := Statement (L := L) (‚Ñì := ‚Ñì) Context (Fin.last ‚Ñì))
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (pSpec := pSpecSumcheckFold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
     := by admit /- proof elided -/

def LeafData.rightSubtree {Œ± : Type} {s_left s_right : Skeleton}
    (tree : LeafData Œ± (Skeleton.internal s_left s_right)) :
    LeafData Œ± s_right :=
  match tree with
  | LeafData.internal _left right =>
    right

instance {k : Fin 1} : Unique (Transcript k (default : ProtocolSpec 0)) where
  default := fun i => ()
  uniq := by admit /- proof elided -/

OracleSpec.QueryLog.inr in VCVio.OracleComp.QueryTracking.Structures

def FullData.get {s} {Œ± : Type}
    (tree : FullData Œ± s) (idx : SkeletonNodeIndex s) : Œ± :=
  match tree, idx with
  | FullData.leaf value, SkeletonNodeIndex.ofLeaf => value
  | FullData.internal value _ _, SkeletonNodeIndex.ofInternal => value
  | FullData.internal _ left _, SkeletonNodeIndex.ofLeft idxLeft =>
    FullData.get left idxLeft
  | FullData.internal _ _ right, SkeletonNodeIndex.ofRight idxRight =>
    FullData.get right idxRight

BEq in Init.Prelude

structure AlgebraTowerEquiv (A : Œπ ‚Üí Type*) [‚àÄ i, CommSemiring (A i)] [a : AlgebraTower A]
  (B : Œπ ‚Üí Type*) [‚àÄ i, CommSemiring (B i)] [b : AlgebraTower B]
  where
    toRingEquiv : ‚àÄ i, (A i ‚âÉ+* B i)
    commutesLeft' : ‚àÄ (i j : Œπ) (h : i ‚â§ j) (r : A i),
      (b.algebraMap (i:=i) (j:=j) (h:=h)) ((toRingEquiv i) r) =
      (toRingEquiv j) (a.algebraMap (i:=i) (j:=j) (h:=h) r)

class Serde (Œ± : Type u) (Œ≤ : Type v) extends Serialize Œ± Œ≤, DeserializeOption Œ± Œ≤

noncomputable def disagreementSet (f : Œπ ‚Üí F) (S : Finset F) (Ans : S ‚Üí F) : Finset F :=
  Set.toFinset ({x : Œπ | x.val ‚àà S ‚àß (ansPoly S Ans).eval x.val ‚â† f x}.image Subtype.val)

def extend {k : Fin n} (messages : MessagesUpTo k.castSucc pSpec)
    (h : pSpec.dir k = .V_to_P) : MessagesUpTo k.succ pSpec :=
  fun ‚ü®i, h‚ü© => (concat' (pSpec := pSpec) (fun i hi => messages ‚ü®i, hi‚ü©) (fun h' => by admit /- proof elided -/
  )) i h

@[reducible]
def spec : OracleSpec Unit := fun _ => (Œ± √ó Œ±, Œ±)

@[inline, specialize]
def oracleProver : OracleProver oSpec
    Statement OStatement Unit Statement OStatement Unit !p[] where
  PrvState := fun _ => Statement √ó (‚àÄ i, OStatement i)
  input := Prod.fst
  sendMessage := fun i => nomatch i
  receiveChallenge := fun i => nomatch i
  output := fun stmt => pure (stmt, ())

def whirRelation
    {F : Type} [Field F] [Fintype F] [DecidableEq F]
    {Œπ : Type} [Fintype Œπ] [Nonempty Œπ]
    (varCount : ‚Ñï) (œÜ : Œπ ‚Ü™ F) [Smooth œÜ] (err : ‚Ñù)
    : Set ((Unit √ó ‚àÄ i, (OracleStatement Œπ F i)) √ó Unit) :=
  { ‚ü®‚ü®_, oracle‚ü©, _‚ü© | Œ¥·µ£(oracle (), smoothCode œÜ varCount) ‚â§ err }

@[simp]
instance CommRing (k : ‚Ñï) : CommRing (BTField k) := Field.toCommRing

Fin.init in Mathlib.Data.Fin.Tuple.Basic

def nonDoomedFoldingProp (i : Fin (‚Ñì + 1)) (challenges : Fin i ‚Üí L)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i j)
    : Prop :=
  let oracleFoldingConsistency := oracleFoldingConsistencyProp ùîΩq Œ≤ i (challenges := challenges)
    (oStmt := oStmt)
  let foldingBadEventExists := badEventExistsProp ùîΩq Œ≤ i (challenges := challenges)
    (oStmt := oStmt)
  oracleFoldingConsistency ‚à® foldingBadEventExists

def BindingAdversary (oSpec : OracleSpec Œπ) (Data Commitment AuxState : Type)
    [O : OracleInterface Data] :=
  OracleComp oSpec (Commitment √ó O.Query √ó O.Response √ó O.Response √ó AuxState)

def erase_odd (s : Finset ‚Ñï) : Finset ‚Ñï := s.filter Even

instance (Œ±s : List Type) [HListRepr (HList Œ±s)] : Repr (HList Œ±s) where
  reprPrec
  | v, _ => "[" ++ HListRepr.repr v ++ "]"

def knowledgeSoundness
    (relIn : Set ((StmtIn √ó ‚àÄ i, OStmtIn i) √ó WitIn))
    (relOut : Set ((StmtOut √ó ‚àÄ i, OStmtOut i) √ó WitOut))
    (verifier : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec)
    (knowledgeError : ‚Ñù‚â•0) : Prop :=
  verifier.toVerifier.knowledgeSoundness init impl relIn relOut knowledgeError

@[simps]
def subtypeSumComplEquiv {Œ± : Type*} {p : Œ± ‚Üí Prop} [DecidablePred p] :
    {a // p a} ‚äï {a // ¬¨ p a} ‚âÉ Œ± where
  toFun := fun x => match x with
    | Sum.inl a => a.1
    | Sum.inr a => a.1
  invFun := fun x =>
    if h : p x then Sum.inl ‚ü®x, h‚ü© else Sum.inr ‚ü®x, h‚ü©
  left_inv := fun x => match x with
    | Sum.inl a => by admit /- proof elided -/
    | Sum.inr a => by admit /- proof elided -/

Char.ofNat in Init.Prelude

instance : ‚àÄ i, SelectableType ((pSpecLastBlock (L:=L) (œë:=œë)).Challenge i) :=
  instSelectableTypeChallengeSeqCompose

@[simp]
abbrev OracleStatement.AfterFirstSumcheck : R1CS.MatrixIdx ‚äï Fin 1 ‚Üí Type :=
  OracleStatement.AfterFirstChallenge R pp

instance {k : Fin (n + 1)} : Fintype (pSpec.ChallengeIdxUpTo k) :=
  inferInstanceAs (Fintype <| ChallengeIdx (pSpec.take k k.is_le))

structure Scheme extends
    Commit oSpec Data Randomness Commitment,
    Opening oSpec Data Randomness Commitment pSpec

class LawfulPermute (Œ± : Type*) [Permute Œ±] where
  permuteInv : Œ± ‚Üí Œ±
  left_inv : Function.LeftInverse permuteInv Permute.permute
  right_inv : Function.RightInverse permuteInv Permute.permute

def simulateQ' (oa : OracleComp spec Œ±) (h : oa.neverFails) : m Œ± :=

def composeM {m' : Type u ‚Üí Type v} [Monad m'] (hom : m ‚Üí·µê m') (so : QueryImpl spec m) :
    QueryImpl spec m' where
  impl | query i t => hom (so.impl (query i t))

MvPolynomial.optionEquivLeft in Mathlib.Algebra.MvPolynomial.Equiv

affineSpan in Mathlib.LinearAlgebra.AffineSpace.AffineSubspace.Defs

def shift_left (s : Finset ‚Ñï) : Finset ‚Ñï :=
  s.filterMap
    (fun n => match n with
      | 0 => .none
      | n + 1 => .some n
      )
    (by admit /- proof elided -/
    )

instance [Zero T] [DecidableEq T] [ToNat T] : Mod (Cayley T) where
  mod := mod

instance : Neg (UniPoly R) := ‚ü®UniPoly.neg‚ü©

instance : Mul (UniPoly R) := ‚ü®UniPoly.mul‚ü©

def Function.interleave‚ÇÇ {Œ± Œ≤ : Type*} (u v : Œ± ‚Üí Œ≤) : (Fin 2) √ó Œ± ‚Üí Œ≤ :=
  Function.uncurry (fun a => if a = 0 then u else v)

def RoundByRound.append
    {WitMid‚ÇÅ : Fin (m + 1) ‚Üí Type} {WitMid‚ÇÇ : Fin (n + 1) ‚Üí Type}
    (E‚ÇÅ : Extractor.RoundByRound oSpec Stmt‚ÇÅ Wit‚ÇÅ Wit‚ÇÇ pSpec‚ÇÅ WitMid‚ÇÅ)
    (E‚ÇÇ : Extractor.RoundByRound oSpec Stmt‚ÇÇ Wit‚ÇÇ Wit‚ÇÉ pSpec‚ÇÇ WitMid‚ÇÇ) :
      Extractor.RoundByRound oSpec Stmt‚ÇÅ Wit‚ÇÅ Wit‚ÇÉ (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ)
        (Fin.append (m := m + 1) WitMid‚ÇÅ (Fin.tail WitMid‚ÇÇ) ‚àò Fin.cast (by admit /- proof elided -/
        )) where
  eqIn := by admit /- proof elided -/

@[reducible]
def pSpecFoldCommit (i : Fin ‚Ñì) : ProtocolSpec (3) :=
  pSpecFold (L:=L) ++‚Çö pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i

instance {k : Fin 1} : Unique (ChallengesUpTo k (default : ProtocolSpec 0)) where
  default := fun i => ()
  uniq := by admit /- proof elided -/

noncomputable def weight_Œõ_over_ùí™ {H : F[X][Y]} (f : ùí™ H) (D : ‚Ñï)
  : WithBot ‚Ñï := weight_Œõ (canonicalRepOfùí™ f) H D

Array.zipWith in Init.Data.Array.Basic

DivisionRing in Mathlib.Algebra.Field.Defs

Subtype.mk in Init.Prelude

def relationRound (i : Fin (n + 1)) :
    Set (((StatementRound R n i) √ó (‚àÄ i, OracleStatement R n deg i)) √ó Unit) :=
  { ‚ü®‚ü®‚ü®target, challenges‚ü©, polyOracle‚ü©, _‚ü© |
    ‚àë x ‚àà (univ.map D) ^·∂† (n - i), (polyOracle ()).val ‚∏®challenges, x‚∏© = target }

@[inline, reducible]
def lift : (OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i)) √ó OuterWitIn ‚Üí
    (InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i)) √ó InnerWitOut ‚Üí
    (OuterStmtOut √ó (‚àÄ i, OuterOStmtOut i)) √ó OuterWitOut :=
  fun ctxIn ctxOut => ‚ü®lens.stmt.lift ctxIn.1 ctxOut.1, lens.wit.lift ctxIn ctxOut‚ü©

UInt16 in Init.Prelude

def OuterStmtOut_Test := ‚Ñ§[X] √ó ‚Ñ§[X] √ó ‚Ñ§ √ó ‚Ñ§

def oracleReduction.sendEvalClaim :
    OracleReduction oSpec
      (Statement.AfterFirstSumcheck R pp) (OracleStatement.AfterFirstSumcheck R pp) (Witness R pp)
      (Statement.AfterSendEvalClaim R pp) (OracleStatement.AfterSendEvalClaim R pp) Unit
      ‚ü®!v[.P_to_V], !v[‚àÄ i, EvalClaim R i]‚ü© :=
  sorry

def IsBerlekampWelchSolution
  (e k : ‚Ñï)
  (œâs f : Fin n ‚Üí F)
  (v : Fin (2 * e + k) ‚Üí F)
  : Prop
  := Matrix.mulVec (BerlekampWelchMatrix e k œâs f) v = Rhs e œâs f

OracleSpec.SubSpec in VCVio.OracleComp.Coercions.SubSpec

def prover : OracleProver oSpec (StmtIn R) (OStmtIn R deg) Unit (StmtOut R) (OStmtOut R deg) Unit
    (pSpec R deg) where
  PrvState
    | 0 => R‚¶É‚â§ deg‚¶Ñ[X]
    | 1 => R‚¶É‚â§ deg‚¶Ñ[X]
    | 2 => R‚¶É‚â§ deg‚¶Ñ[X] √ó R

  input := fun ‚ü®‚ü®_, oStmt‚ü©, _‚ü© => oStmt ()

  sendMessage
  | ‚ü®0, _‚ü© => fun polyLE => pure ‚ü®polyLE, polyLE‚ü©
  | ‚ü®1, h‚ü© => nomatch h

  receiveChallenge
  | ‚ü®0, h‚ü© => nomatch h
  | ‚ü®1, _‚ü© => fun polyLE => pure fun chal => ‚ü®polyLE, chal‚ü©

  output := fun ‚ü®polyLE, chal‚ü© => pure (((polyLE.val.eval chal, chal), fun _ => polyLE), ())

@[inline, specialize, simp]
def oracleReduction : OracleReduction oSpec
    Statement OStatement Witness Statement OStatement Witness !p[] := OracleReduction.id

LinearEquiv.ofBijective in Mathlib.Algebra.Module.Submodule.Equiv

@[reducible]
def value (op : MemoryWrite Œπ Œ±) := op.2

@[simp]
def poly (k : ‚Ñï) : Polynomial (BTField k) := definingPoly (s:=(Z k))

instance [inst : VCVCompatible Chal] : ‚àÄ i, VCVCompatible (Challenge ‚ü®!v[.V_to_P], !v[Chal]‚ü© i)
  | ‚ü®0, _‚ü© => inst

def roundRelation (i : Fin (‚Ñì + 1)) :
    Set ((Statement (L := L) Context i √ó
      (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i j)) √ó
      Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) :=
  { input | roundRelationProp (mp := mp) (ùìë := ùìë) ùîΩq Œ≤ i input}

noncomputable def canonicalRepOfùí™ {H : F[X][Y]} (Œ≤ : ùí™ H) : F[X][Y] :=
  Polynomial.modByMonic Œ≤.out (H_tilde' H)

@[reducible]
def coeffs {R : Type*} (p : UniPoly R) : Array R := p

Vector.map in Init.Data.Vector.Basic

structure LookaheadSequence (trace : QueryLog (forwardPermutationOracle (CanonicalSpongeState U)))
    (state : CanonicalSpongeState U) where
   
  inputState : List (CanonicalSpongeState U)
   
  outputState : List (CanonicalSpongeState U)

   
  inputState_length_eq_outputState_length : inputState.length = outputState.length

   
  first_inputState_eq_state : inputState[0]? = state

   
  inputOutput_in_trace : ‚àÄ i : Fin inputState.length,
    (inputState[i], outputState[i]) ‚àà trace.getQ ()

   
  outputState_eq_next_inputState : ‚àÄ i : Fin (outputState.length - 1),
    outputState[i] = inputState[i.val + 1]

   
  capacitySegment_inputState_ne_outputState : ‚àÄ i : Fin inputState.length,
    inputState[i].capacitySegment ‚â† outputState[i].capacitySegment

GaloisField.equivZmodP in Mathlib.FieldTheory.Finite.GaloisField

def eval‚ÇÇAlgHom {A B : Type*} [CommSemiring A] [CommSemiring B] [MvPolynomialLike œÉ A P]
    [Algebra R A] [IsScalarTower R A P] [Algebra R B]
    (f : A ‚Üí‚Çê[R] B) (g : œÉ ‚Üí B) : P ‚Üí‚Çê[R] B where
  toRingHom := eval‚ÇÇ f g
  commutes' r := by admit /- proof elided -/

@[reducible]
def Statement (F : Type) (i : Fin (k + 1)) : Type := Fin i.val ‚Üí F

class DuplexSpongeInterface (U : Type) [SpongeUnit U] (Œ± : Type*)
    extends Inhabited Œ±, Zero Œ±, Initialize Œ± (Vector UInt8 32) where
   
  absorbUnchecked : Œ± √ó Array U ‚Üí Œ±

   
  squeezeUnchecked : Œ± √ó Array U ‚Üí Œ± √ó Array U

   
  ratchetUnchecked : Œ± ‚Üí Œ±

@[reducible, simp]
def OracleStatement.Lens.IsSound {OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut : Type}
    {Outer_Œπ‚Çõ·µ¢ : Type} {OuterOStmtIn : Outer_Œπ‚Çõ·µ¢ ‚Üí Type} [‚àÄ i, OracleInterface (OuterOStmtIn i)]
    {Outer_Œπ‚Çõ‚Çí : Type} {OuterOStmtOut : Outer_Œπ‚Çõ‚Çí ‚Üí Type} [‚àÄ i, OracleInterface (OuterOStmtOut i)]
    {Inner_Œπ‚Çõ·µ¢ : Type} {InnerOStmtIn : Inner_Œπ‚Çõ·µ¢ ‚Üí Type} [‚àÄ i, OracleInterface (InnerOStmtIn i)]
    {Inner_Œπ‚Çõ‚Çí : Type} {InnerOStmtOut : Inner_Œπ‚Çõ‚Çí ‚Üí Type} [‚àÄ i, OracleInterface (InnerOStmtOut i)]
    (outerLangIn : Set (OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i)))
    (outerLangOut : Set (OuterStmtOut √ó (‚àÄ i, OuterOStmtOut i)))
    (innerLangIn : Set (InnerStmtIn √ó (‚àÄ i, InnerOStmtIn i)))
    (innerLangOut : Set (InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i)))
    (compatStmt :
      OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i) ‚Üí InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i) ‚Üí Prop)
    (lens : OracleStatement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                                    OuterOStmtIn OuterOStmtOut InnerOStmtIn InnerOStmtOut) :=
  Statement.Lens.IsSound outerLangIn outerLangOut innerLangIn innerLangOut compatStmt lens

def rbrSoundness (langIn : Set StmtIn) (langOut : Set StmtOut)
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    (rbrSoundnessError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) : Prop :=
  ‚àÉ stateFunction : verifier.StateFunction init impl langIn langOut,
  ‚àÄ stmtIn ‚àâ langIn,
  ‚àÄ WitIn WitOut : Type,
  ‚àÄ witIn : WitIn,
  ‚àÄ prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec,
  ‚àÄ i : pSpec.ChallengeIdx,
    [fun ‚ü®transcript, challenge‚ü© =>
      ¬¨ stateFunction i.1.castSucc stmtIn transcript ‚àß
        stateFunction i.1.succ stmtIn (transcript.concat challenge)
    | do
      (simulateQ (impl ++‚Çõ‚Çí challengeQueryImpl : QueryImpl _ (StateT œÉ ProbComp))
        (do
          let ‚ü®transcript, _‚ü© ‚Üê prover.runToRound i.1.castSucc stmtIn witIn
          let challenge ‚Üê liftComp (pSpec.getChallenge i) _
          return (transcript, challenge))).run' (‚Üê init)] ‚â§
      rbrSoundnessError i

class LawfulHasPred (T : Type u) [HasSucc T] [HasPred T] : Prop where
   
  pred'_succ : ‚àÄ x : T, pred' (succ' x) = x

def join {k : ‚Ñï} (h_pos : k > 0) (hi lo : ConcreteBTField (k - 1)) : ConcreteBTField k :=

def Straightline.append (E‚ÇÅ : Extractor.Straightline oSpec Stmt‚ÇÅ Wit‚ÇÅ Wit‚ÇÇ pSpec‚ÇÅ)
    (E‚ÇÇ : Extractor.Straightline oSpec Stmt‚ÇÇ Wit‚ÇÇ Wit‚ÇÉ pSpec‚ÇÇ)
    (V‚ÇÅ : Verifier oSpec Stmt‚ÇÅ Stmt‚ÇÇ pSpec‚ÇÅ) :
      Extractor.Straightline oSpec Stmt‚ÇÅ Wit‚ÇÅ Wit‚ÇÉ (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ) :=
  fun stmt‚ÇÅ wit‚ÇÉ transcript proveQueryLog verifyQueryLog => do
    let stmt‚ÇÇ ‚Üê V‚ÇÅ.verify stmt‚ÇÅ transcript.fst
    let wit‚ÇÇ ‚Üê E‚ÇÇ stmt‚ÇÇ wit‚ÇÉ transcript.snd proveQueryLog verifyQueryLog
    let wit‚ÇÅ ‚Üê E‚ÇÅ stmt‚ÇÅ wit‚ÇÇ transcript.fst proveQueryLog verifyQueryLog
    return wit‚ÇÅ

instance Vector.instFintype {Œ± : Type*} {n : ‚Ñï} [VCVCompatible Œ±] : Fintype (Vector Œ± n) :=
  Fintype.ofEquiv _ (Equiv.rootVectorEquivFin).symm

def inputRelation (cond : ‚àë i, (s i).1 ‚â§ n) [DecidableEq F] (Œ¥ : ‚Ñù‚â•0) :
    Set
      (
        (
          Statement F (Fin.last k) √ó
          (‚àÄ j, OracleStatement D x s (Fin.last k) j)
        ) √ó
        Witness F s d (Fin.last k).castSucc
      ) := sorry

instance : EDist (n ‚Üí R) where
  edist := fun u v => hammingDist u v

instance irreducible_quadratic_defining_poly_of_traceMap_eq_1
  {F : Type*} [Field F] [Fintype F] [CharP F 2] (s : F) [NeZero s] (k : ‚Ñï)
  (trace_map_prop : TraceMapProperty F s k)
  (fintypeCard : Fintype.card F = 2 ^ (2 ^ k))
  : Irreducible (definingPoly s) :=

abbrev BaseField := ZMod baseFieldSize

def pred (n : ChurchNat Œ±) : ChurchNat Œ± := sorry

noncomputable def fold_k_set
  {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F} {k m : ‚Ñï}
  [‚àÄ j : ‚Ñï, Neg (indexPowT S œÜ j)]
  (set : Set ((indexPowT S œÜ 0) ‚Üí F)) (Œ±s : Fin k ‚Üí F) (hk : k ‚â§ m): Set (indexPowT S œÜ k ‚Üí F) :=
    { g | ‚àÉ f ‚àà set, g = fold_k f Œ±s hk}

noncomputable def ansPoly (S : Finset F) (Ans : S ‚Üí F) : Polynomial F :=
  Lagrange.interpolate S.attach (fun i => (i : F)) Ans

@[simp]
def evalDomain (i : ‚Ñï) : Subgroup FÀ£ :=
  Subgroup.zpowers (DIsCyclicC.gen ^ (2 ^ i))

BitVec.ofFin in Init.Prelude

def commitKnowledgeError {i : Fin ‚Ñì}
    (m : (pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i).ChallengeIdx) : ‚Ñù‚â•0 :=
  match m with
  | ‚ü®j, hj‚ü© => by admit /- proof elided -/

Fin.dfoldr in Batteries.Data.Fin.Basic

instance : ‚àÄ i, OracleInterface ((pSpecCoreInteraction ùîΩq Œ≤ (œë:=œë)
  (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).Message i) := instOracleInterfaceMessageAppend

@[inline, specialize]
def add_raw (p q : UniPoly R) : UniPoly R :=
  let ‚ü®p', q'‚ü© := Array.matchSize p q 0
  .mk (Array.zipWith (¬∑ + ¬∑) p' q' )

instance : _root_.Field Field := ZMod.instField fieldSize

instance instSelectableTypeChallengePSpec [SelectableType R] :
    ‚àÄ i, SelectableType ((pSpec R deg).Challenge i) :=
  instSelectableTypeChallengeAppend

Finset.filterMap in Mathlib.Data.Finset.Image

inductive PrattPart : (p : ‚Ñï) ‚Üí (a : ZMod p) ‚Üí ‚Ñï ‚Üí Prop
  | prime : {p : ‚Ñï} ‚Üí {a : ZMod p} ‚Üí (n k nk : ‚Ñï) ‚Üí n.Prime ‚Üí
      a ^ ((p - 1) / n) ‚â† 1 ‚Üí n ^ k = nk ‚Üí PrattPart p a nk
  | split : {p : ‚Ñï} ‚Üí {a : ZMod p} ‚Üí {n : ‚Ñï} ‚Üí (l r : ‚Ñï) ‚Üí
      PrattPart p a l ‚Üí PrattPart p a r ‚Üí l * r = n ‚Üí PrattPart p a n

instance {s} : LawfulFunctor (fun Œ± => InternalData Œ± s) :=

Functor in Init.Prelude

@[inline] def ge [Zero T] [ToNat T] (a b : Cayley T) : Prop :=
  (a : Nat) ‚â• (b : Nat)

Algebra.TensorProduct.comm in Mathlib.RingTheory.TensorProduct.Maps

def OracleReduction.liftContext
    (lens : OracleContext.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                              OuterOStmtIn OuterOStmtOut InnerOStmtIn InnerOStmtOut
                              OuterWitIn OuterWitOut InnerWitIn InnerWitOut)
    (R : OracleReduction oSpec InnerStmtIn InnerOStmtIn InnerWitIn
                            InnerStmtOut InnerOStmtOut InnerWitOut pSpec) :
      OracleReduction oSpec OuterStmtIn OuterOStmtIn OuterWitIn
                      OuterStmtOut OuterOStmtOut OuterWitOut pSpec where
  prover := R.prover.liftContext lens
  verifier := R.verifier.liftContext lens.stmt

instance : Repr ByteArray where
  reprPrec b n := List.repr b.toList n

def SkeletonInternalIndex.toNodeIndex {s : Skeleton} (idx : SkeletonInternalIndex s) :
    SkeletonNodeIndex s :=
  match idx with
  | SkeletonInternalIndex.ofInternal => SkeletonNodeIndex.ofInternal
  | SkeletonInternalIndex.ofLeft idxLeft =>
    SkeletonNodeIndex.ofLeft (SkeletonInternalIndex.toNodeIndex idxLeft)
  | SkeletonInternalIndex.ofRight idxRight =>
    SkeletonNodeIndex.ofRight (SkeletonInternalIndex.toNodeIndex idxRight)

def relayKnowledgeStateFunction (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
    (relayOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        i hNCR).KnowledgeStateFunction init impl
      (relIn := foldStepRelOut (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i.succ)
      (extractor := relayRbrExtractor ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) where
  toFun := fun m ‚ü®stmtIn, oStmtIn‚ü© tr witMid =>
    relayKStateProp (mp:=mp) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (ùìë := ùìë) i hNCR stmtIn witMid oStmtIn
  toFun_empty := fun ‚ü®stmtIn, oStmtIn‚ü© witIn => by admit /- proof elided -/

instance [h : ProverLast pSpec] : ProverFirst pSpec where
  prover_first' := by admit /- proof elided -/

def relHammingBallInterleavedCode [DecidableEq F] (U : Matrix Œ∫ Œπ F)
  (IC : MatrixSubmodule Œ∫ Œπ F) (r : ‚Ñù) :=
    {V | V ‚àà IC ‚àß relDistCodewords U V < r}

def InnerStmtIn_Test := ‚Ñ§[X] √ó ‚Ñ§

BitVec.extractLsb in Init.Data.BitVec.Basic

def mul_by_2 (s : Finset ‚Ñï) : Finset ‚Ñï :=
  s.map ‚ü®fun n => 2 * n, by admit /- proof elided -/
  ‚ü©

def oracleVerifier : OracleVerifier oSpec Statement OStatement Unit (OStatement ‚äï·µ• OStatement)
    (pSpec OStatement) where

  verify := fun stmt _ => relComp stmt

  embed := sorry

  hEq := sorry

Ideal.Quotient.mk in Mathlib.RingTheory.Ideal.Quotient.Defs

@[reducible, inline]
instance instProdForall {Œπ : Type u} (v : Œπ ‚Üí Type v) [O : ‚àÄ i, OracleInterface (v i)] :
    OracleInterface (‚àÄ i, v i) where
  Query := (i : Œπ) √ó (O i).Query
  Response := (i : Œπ) √ó (O i).Response
  answer := fun f ‚ü®i, q‚ü© => ‚ü®i, (O i).answer (f i) q‚ü©

noncomputable def X‚±º (‚Ñì : ‚Ñï) (h_‚Ñì : ‚Ñì ‚â§ r) (j : Fin (2 ^ ‚Ñì)) : L[X] :=
  (Finset.univ : Finset (Fin ‚Ñì)).prod
    (fun i => (normalizedW ùîΩq Œ≤ (Fin.castLE h_‚Ñì i))^(Nat.getBit i j))

def computableAdditiveNTT (a : Fin (2 ^ ‚Ñì) ‚Üí L) : Fin (2^(‚Ñì + R_rate)) ‚Üí L :=
  let b: Fin (2^(‚Ñì + R_rate)) ‚Üí L := tileCoeffs a 
  Fin.foldl (n:=‚Ñì) (f:= fun current_b i  =>
    computableNTTStage (ùîΩq := ùîΩq) (Œ≤ := Œ≤) (‚Ñì := ‚Ñì) (R_rate := R_rate)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := ‚ü®‚Ñì - 1 - i, by admit /- proof elided -/
      ‚ü©) (b:=current_b)
  ) (init:=b)

OracleSpec.DecidableEq in VCVio.OracleComp.OracleSpec

class ProverOnly (pSpec : ProtocolSpec 1) extends ProverFirst pSpec

 
alias NonInteractive := ProverOnly

class DecidableBlockDisagreement
  (i k : ‚Ñï) {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F}
  [DecidableEq F] [DecidableEq Œπ] [Smooth œÜ]
  (f : (indexPowT S œÜ i) ‚Üí F) (S' : Finset (indexPowT S œÜ i))
  (œÜ' : (indexPowT S œÜ i) ‚Ü™ F) where
  dec_inst :
    ‚àÄ z : indexPowT S œÜ k, ‚àÄ g : (indexPowT S œÜ i) ‚Üí F,
      Decidable (‚àÉ y : block i S' œÜ' z, f y.val ‚â† g y.val)

instance instInvConcreteBTF {k : ‚Ñï} : Inv (ConcreteBTField k) where
  inv := concrete_inv

Polynomial in Mathlib.Algebra.Polynomial.Basic

def commitKState (i : Fin ‚Ñì) (hCR : isCommitmentRound ‚Ñì œë i) :
    (commitOracleVerifier ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      i hCR).KnowledgeStateFunction init impl
      (relIn := foldStepRelOut (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i.succ)
      (extractor := commitRbrExtractor ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) where
  toFun := fun m ‚ü®stmtIn, oStmtIn‚ü© tr witMid =>
    commitKStateProp ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (i := i) (m := m) (stmtIn := stmtIn) (witMid := witMid) (oStmtIn := oStmtIn) (mp:=mp)
  toFun_empty := fun stmtIn witMid => by admit /- proof elided -/

Units.mulAction' in Mathlib.Algebra.Group.Action.Units
</all_available_defs>

<all_available_lemmas>
Fin.eta in Init.Data.Fin.Lemmas
add_zero in Mathlib.Algebra.Group.Defs
Module.Basis.repr_linearCombination in Mathlib.LinearAlgebra.Basis.Defs
Module.Basis.repr_symm_apply in Mathlib.LinearAlgebra.Basis.Defs
Nat.add_zero in Init.Core
cast_eq in Init.Core
eq_mp_eq_cast in Init.PropLemmas
not_lt_zero' in Mathlib.Algebra.Order.GroupWithZero.Canonical
tsub_zero in Mathlib.Algebra.Order.Sub.Defs
nonpos_iff_eq_zero in Mathlib.Algebra.Order.Monoid.Canonical.Defs
not_lt in Mathlib.Order.Defs.LinearOrder
Polynomial.ext in Mathlib.Algebra.Polynomial.Basic
add_lt_iff_neg_right in Mathlib.Algebra.Order.Monoid.Unbundled.Basic
add_tsub_cancel_right in Mathlib.Algebra.Order.Sub.Defs
Decidable.not_not in Init.PropLemmas
Nat.le_of_not_lt in Init.Data.Nat.Basic
Nat.sub_lt_sub_right in Init.Data.Nat.Basic
Nat.sub_sub in Init.Data.Nat.Basic
dite_eq_right_iff in Init.PropLemmas
false_or in Init.SimpLemmas
forall_const in Init.PropLemmas
imp_false in Init.Core
ite_eq_left_iff in Init.PropLemmas
one_ne_zero in Mathlib.Algebra.NeZero

lemma X‚±º_zero_eq_one (‚Ñì : ‚Ñï) (h_‚Ñì : ‚Ñì ‚â§ r) :
  X‚±º ùîΩq Œ≤ ‚Ñì h_‚Ñì ‚ü®0, by exact Nat.two_pow_pos ‚Ñì‚ü© = 1

@[simp]
lemma lt_add_of_pos_right_of_le (a b c : ‚Ñï) [NeZero c] (h : a ‚â§ b) : a < b + c

omit [DecidableEq ùîΩq] hF‚ÇÇ in
lemma getSDomainBasisCoeff_of_iteratedQuotientMap
    [NeZero R_rate] (i : Fin ‚Ñì) (k : ‚Ñï)
    (h_bound : i.val + k ‚â§ ‚Ñì) (x : (sDomain ùîΩq Œ≤
    h_‚Ñì_add_R_rate) ‚ü®i, by omega‚ü©) :
    let y

theorem base_intermediateNormVpoly
  (k : Fin (‚Ñì + 1)) :
  intermediateNormVpoly ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®0, by
    by_contra ht
    simp only [not_lt, nonpos_iff_eq_zero] at ht
    contradiction
  ‚ü© ‚ü®k, by simp only [tsub_zero]; omega‚ü© =
  normalizedW ùîΩq Œ≤ ‚ü®k, by omega‚ü©

lemma normalizedW_eq_qMap_composition (‚Ñì R_rate : ‚Ñï) (i : Fin r) :
    normalizedW ùîΩq Œ≤ i = qCompositionChain ùîΩq Œ≤ (‚Ñì:=‚Ñì) (R_rate:=R_rate) i

lemma qMap_comp_normalizedW (i : Fin r) (h_i_add_1 : i + 1 < r) :
  (qMap ùîΩq Œ≤ i).comp (normalizedW ùîΩq Œ≤ i) = normalizedW ùîΩq Œ≤ (i + 1)

lemma qCompositionChain_eq_foldl (i : Fin r) :
  qCompositionChain ùîΩq Œ≤ (‚Ñì:=‚Ñì) (R_rate:=R_rate) i =
  Fin.foldl (n:=i) (fun acc j =>
    (qMap ùîΩq Œ≤ ‚ü®j, by omega‚ü©).comp acc) (X)

omit [DecidableEq ùîΩq] hF‚ÇÇ h_Œ≤‚ÇÄ_eq_1 in
lemma getSDomainBasisCoeff_of_sum_repr [NeZero R_rate] (i : Fin (‚Ñì + 1))
    (x : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®i, by omega‚ü©)
    (x_coeffs : Fin (‚Ñì + R_rate - i) ‚Üí ùîΩq)
    (hx : x = ‚àë j_x, (x_coeffs j_x) ‚Ä¢ (sDomain_basis ùîΩq Œ≤
      h_‚Ñì_add_R_rate (i := ‚ü®i, by omega‚ü©) (h_i := by
        simp only; apply Nat.lt_add_of_pos_right_of_le; omega) j_x).val) :
    ‚àÄ (j: Fin (‚Ñì + R_rate - i)), ((sDomain_basis ùîΩq Œ≤
      h_‚Ñì_add_R_rate (i := ‚ü®i, by omega‚ü©) (h_i := by
        simp only; apply Nat.lt_add_of_pos_right_of_le; omega)).repr x) j = x_coeffs j

omit [DecidableEq ùîΩq] hF‚ÇÇ h_Œ≤‚ÇÄ_eq_1 in
lemma get_sDomain_basis (i : Fin r) (h_i : i < ‚Ñì + R_rate) :
    ‚àÄ (k : Fin (‚Ñì + R_rate - i)),
    (sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate
      i (by omega)) k = eval (Œ≤ ‚ü®i + k.val, by omega‚ü©) (normalizedW ùîΩq Œ≤ i)

omit [DecidableEq L] [DecidableEq ùîΩq] h_Fq_char_prime hF‚ÇÇ hŒ≤_lin_indep h_Œ≤‚ÇÄ_eq_1 in
theorem intermediateNormVpoly_comp (i : Fin ‚Ñì) (k : Fin (‚Ñì - i + 1))
  (l : Fin (‚Ñì - (i.val + k.val) + 1)) :
  intermediateNormVpoly ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i, by omega‚ü©) (k:=‚ü®k + l, by
      simp only; omega‚ü©) =
    (intermediateNormVpoly ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i+k, by omega‚ü©) (k:=‚ü®l, by
      simp only; omega‚ü©)).comp (
  intermediateNormVpoly ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i, by omega‚ü©) (k:=‚ü®k, by
      simp only; omega‚ü©)
  )

omit [DecidableEq L] [DecidableEq ùîΩq] hF‚ÇÇ hŒ≤_lin_indep h_Œ≤‚ÇÄ_eq_1 in
lemma intermediateNormVpoly_eval_is_linear_map (i : Fin (‚Ñì + 1)) (k : Fin (‚Ñì - i + 1)) :
  IsLinearMap ùîΩq (fun x : L =>
    (intermediateNormVpoly ùîΩq Œ≤ h_‚Ñì_add_R_rate i k).eval x)

theorem qMap_is_linear_map (i : Fin r) :
  IsLinearMap ùîΩq (f:=fun inner_p ‚Ü¶ (qMap ùîΩq Œ≤ i).comp inner_p)

omit h_Fq_char_prime in
lemma ùîΩq_element_eq_zero_or_eq_one : ‚àÄ c: ùîΩq, c = 0 ‚à® c = 1

lemma getBit_of_binaryFinMapToNat {n : ‚Ñï} (m : Fin n ‚Üí ‚Ñï) (h_binary: ‚àÄ j: Fin n, m j ‚â§ 1) :
    ‚àÄ k: ‚Ñï, Nat.getBit k (binaryFinMapToNat m h_binary).val
      = if h_k: k < n then m ‚ü®k, by omega‚ü© else 0

lemma and_two_pow_eq_zero_of_getBit_0 {n i : ‚Ñï} (h_getBit : getBit i n = 0)
    : n &&& (2 ^ i) = 0

lemma and_eq_zero_iff_and_each_getBit_eq_zero {n m : ‚Ñï} :
    n &&& m = 0 ‚Üî ‚àÄ k, Nat.getBit k n &&& Nat.getBit k m = 0

lemma eq_iff_eq_all_getBits {n m : ‚Ñï} : n = m ‚Üî ‚àÄ k, getBit k n = getBit k m

lemma shiftRight_and_one_distrib {n m k : ‚Ñï} :
    Nat.getBit k (n &&& m) = Nat.getBit k n &&& Nat.getBit k m

lemma getBit_two_pow {i k : ‚Ñï} : (getBit k (2^i) = if i == k then 1 else 0)

lemma getBit_of_lt_two_pow {n: ‚Ñï} (a: Fin (2^n)) (k: ‚Ñï) :
  getBit k a = if k < n then getBit k a else 0

lemma getBit_eq_testBit (k n : Nat) : getBit k n = if n.testBit k then 1 else 0

lemma getBit_lt_2 {k n : Nat} : getBit k n < 2

lemma getBit_of_xor {n m k: ‚Ñï} : getBit k (n ^^^ m) = getBit k n ^^^ getBit k m

lemma getBit_zero_eq_zero {k : Nat} : getBit k 0 = 0

lemma sum_of_and_eq_zero_is_xor {n m : ‚Ñï} (h_n_AND_m : n &&& m = 0) : n + m = n ^^^ m

lemma sum_eq_xor_plus_twice_and (n : Nat) : ‚àÄ m : ‚Ñï, n + m = (n ^^^ m) + 2 * (n &&& m)

lemma and_by_split_lowBits {n m n1 m1 bn bm : ‚Ñï} (h_bn : bn < 2) (h_bm : bm < 2)
  (h_n : n = n1 * 2 + bn) (h_m : m = m1 * 2 + bm):
  n &&& m = (n1 &&& m1) * 2 + (bn &&& bm)

lemma div_2_form {nD2 b : ‚Ñï} (h_b : b < 2):
  (nD2 * 2 + b) / 2 = nD2

lemma or_by_split_lowBits {n m n1 m1 bn bm : ‚Ñï} (h_bn : bn < 2) (h_bm : bm < 2)
  (h_n : n = n1 * 2 + bn) (h_m : m = m1 * 2 + bm):
  n ||

lemma xor_by_split_lowBits {n m n1 m1 bn bm : ‚Ñï} (h_bn : bn < 2) (h_bm : bm < 2)
  (h_n : n = n1 * 2 + bn) (h_m : m = m1 * 2 + bm):
  n ^^^ m = (n1 ^^^ m1) * 2 + (bn ^^^ bm)

theorem congrArg‚ÇÉ {Œ± Œ≤ Œ≥ Œ¥ : Sort*} {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥ ‚Üí Œ¥} {a a' : Œ±} {b b' : Œ≤} {c c' : Œ≥}
    (h : a = a') (h' : b = b') (h'' : c = c') : f a b c = f a' b' c'

lemma concrete_mul_one
  (prevBTFieldProps : ConcreteBTFieldProps (k := k - 1))
  (a : ConcreteBTField k) : concrete_mul a (one (k:=k)) = a

@[simp]
theorem seqCompose_succ_dir {m : ‚Ñï} {n : Fin (m + 1) ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)} :
    (seqCompose pSpec).dir = Fin.vflatten (fun i => (pSpec i).dir)

@[csimp]
theorem dcons_eq_cons : @dcons = @cons

theorem mul_one {a : CNat 50} : a * 1 = a

Finset.sup_lt_iff in Mathlib.Data.Finset.Lattice.Fold

theorem append_rbrSoundness {lang‚ÇÅ : Set Stmt‚ÇÅ} {lang‚ÇÇ : Set Stmt‚ÇÇ} {lang‚ÇÉ : Set Stmt‚ÇÉ}
    (V‚ÇÅ : Verifier oSpec Stmt‚ÇÅ Stmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : Verifier oSpec Stmt‚ÇÇ Stmt‚ÇÉ pSpec‚ÇÇ)
    {rbrSoundnessError‚ÇÅ : pSpec‚ÇÅ.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    {rbrSoundnessError‚ÇÇ : pSpec‚ÇÇ.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    (h‚ÇÅ : V‚ÇÅ.rbrSoundness init impl lang‚ÇÅ lang‚ÇÇ rbrSoundnessError‚ÇÅ)
    (h‚ÇÇ : V‚ÇÇ.rbrSoundness init impl lang‚ÇÇ lang‚ÇÉ rbrSoundnessError‚ÇÇ) :
      (V‚ÇÅ.append V‚ÇÇ).rbrSoundness init impl lang‚ÇÅ lang‚ÇÉ
        (Sum.elim rbrSoundnessError‚ÇÅ rbrSoundnessError‚ÇÇ ‚àò ChallengeIdx.sumEquiv.symm)

theorem dcast‚ÇÇ_eq_dcast‚ÇÇ_iff (ha : a = a'') (ha' : a' = a'')
    (hb : dcast ha b = b'') (hb' : dcast ha' b' = b'') :
    dcast‚ÇÇ ha hb c = dcast‚ÇÇ ha' hb' c' ‚Üî
      c = dcast‚ÇÇ (ha'.trans ha.symm)
        ((dcast_eq_dcast_iff ha ha').mp (hb.trans hb'.symm)).symm c'

theorem take_drop_append {Œ± : Sort*} (m : ‚Ñï) (h : m ‚â§ n) (v : Fin n ‚Üí Œ±) :
    Fin.append (take m h v) (drop m h v) = fun i => v (i.cast (by omega))

@[grind ‚Üê]
lemma mul_ne_zero [IsDomain F] (f g : F[X][Y]) (hf : f ‚â† 0) (hg : g ‚â† 0) :
  f * g ‚â† 0

lemma degree_definingPoly {F : Type*} [Field F] [Fintype F] (s : F) [NeZero s] :
  (definingPoly s).degree = 2

@[simp]
theorem fconcat_zero {Œ± : Fin 0 ‚Üí A} {Œ≤ : A} (a : F Œ≤) : !h‚¶ÉF‚¶Ñ‚ü®Œ±‚ü©[] :+ ∞ a =
  fun i => match i with

@[simp]
theorem fflatten_splitSum {A : Sort u} {F : A ‚Üí Sort v} {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï}
    {Œ± : (i : Fin (vsum n)) ‚Üí A}
    (v : (k : Fin (vsum n)) ‚Üí F (Œ± k)) (k : Fin (vsum n)) :
    fflatten (fun i j => v (embedSum i j)) k = cast (by simp) (v k)

lemma not_inv_of_not_combined (h : ¬¨ E trace) : ¬¨ E_inv trace state

@[simp] theorem toNat_succ (t : AssocNat) : toNat (succ t) = (toNat t).succ

private lemma oddPart_eq_oddPart'_aux' {f : Polynomial F}
  : (f - f.comp (-Polynomial.X)) = (Polynomial.C 2) * x_times_oddPart' f

@[simp]
lemma seqCompose_toVerifier {m : ‚Ñï}
    (Stmt : Fin (m + 1) ‚Üí Type)
    {Œπ‚Çõ : Fin (m + 1) ‚Üí Type} (OStmt : (i : Fin (m + 1)) ‚Üí Œπ‚Çõ i ‚Üí Type)
    [O‚Çõ : ‚àÄ i, ‚àÄ j, OracleInterface (OStmt i j)]
    {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    [O‚Çò : ‚àÄ i, ‚àÄ j, OracleInterface ((pSpec i).Message j)]
    (V : (i : Fin m) ‚Üí
      OracleVerifier oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Stmt i.succ) (OStmt i.succ)
        (pSpec i)) :
    (seqCompose Stmt OStmt V).toVerifier =
      Verifier.seqCompose (fun i => Stmt i √ó (‚àÄ j, OStmt i j)) (fun i => (V i).toVerifier)

theorem hcons_injective2 {Œ± : Sort u} {Œ≤ : Fin n ‚Üí Sort u} :
    Function.Injective2 (@hcons n Œ± Œ≤)

lemma getBit_of_add_distrib {n m k : ‚Ñï}
  (h_n_AND_m : n &&& m = 0) : getBit k (n + m) = getBit k n + getBit k m

@[simp] theorem popWhile_nil_or_last_false (p : Œ± ‚Üí Bool) (as : Array Œ±)
    (h : (as.popWhile p).size > 0) : ¬¨ (p <| (as.popWhile p).getLast h)

lemma join_via_add_smul_one {k : ‚Ñï} (h_pos : k > 0) :
  ‚ãò 0, 1 ‚ãô = 1

theorem vext_iff {v w : Fin n ‚Üí Œ±} : v = w ‚Üî ‚àÄ i, v i = w i

theorem linsolve_none {A : Matrix (Fin n) (Fin m) F} {b : Fin n ‚Üí F}
  (h : linsolve A b = none)
  : ¬¨‚àÉ x, A.mulVec x = b

lemma eval_normalizedW_succ_at_beta_prev (i : Fin r) (h_i_add_1 : i + 1 < r) :
  (normalizedW ùîΩq Œ≤ (i + 1)).eval (Œ≤ i) = 0

@[simp]
lemma finite_offDiag [Finite F] : C.offDiag.Finite

theorem two_eq_zero_in_char2_field {F : Type*} [Field F]
  (sumZeroIffEq : ‚àÄ (x y : F), x + y = 0 ‚Üî x = y) : (2 : F) = 0

@[simp]
theorem dist'_empty : ‚Äñ(‚àÖ : Set (n ‚Üí R))‚Äñ‚ÇÄ' = ‚ä§

theorem degree_finSuccEquivNth {f : MvPolynomial (Fin (n + 1)) R} (h : f ‚â† 0) :
    (finSuccEquivNth R p f).degree = degreeOf p f

theorem rbrKnowledgeSoundness_implies_knowledgeSoundness
    (relIn : Set (StmtIn √ó WitIn)) (relOut : Set (StmtOut √ó WitOut))
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    (rbrKnowledgeError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) :
      rbrKnowledgeSoundness init impl relIn relOut verifier rbrKnowledgeError ‚Üí
        knowledgeSoundness init impl relIn relOut verifier (‚àë i, rbrKnowledgeError i)

theorem singletonBound [CommRing F] [StrongRankCondition F]
  (LC : LinearCode Œπ F) :
  dim LC ‚â§ length LC - Code.minDist (LC : Set (Œπ ‚Üí F)) + 1

private lemma natDegree_E
  (h : (Œî‚ÇÄ(f, p.eval ‚àò œâs) : ‚Ñï) ‚â§ e) :
  (E (œâs := œâs) f p e).natDegree = e

theorem natDegree_finSuccEquivNth (f : MvPolynomial (Fin (n + 1)) R) :
    (finSuccEquivNth R p f).natDegree = degreeOf p f

@[simp]
theorem fcons_zero {Œ≤ : Fin n ‚Üí A} (a : F Œ±) (b : (i : Fin n) ‚Üí F (Œ≤ i)) :
    fcons a b 0 = cast (by simp [vcons_zero]) a

theorem dcast_fun‚ÇÇ {a‚ÇÅ a‚ÇÇ a‚ÇÅ' a‚ÇÇ' : Œ±} {h‚ÇÅ : a‚ÇÅ = a‚ÇÅ'} {h‚ÇÇ : a‚ÇÇ = a‚ÇÇ'} {f : Œ± ‚Üí Œ± ‚Üí Œ±}
    {g : (a‚ÇÅ : Œ±) ‚Üí (a‚ÇÇ : Œ±) ‚Üí Œ≤ a‚ÇÅ ‚Üí Œ≤ a‚ÇÇ ‚Üí Œ≤ (f a‚ÇÅ a‚ÇÇ)} {b‚ÇÅ : Œ≤ a‚ÇÅ} {b‚ÇÇ : Œ≤ a‚ÇÇ} :
    dcast (by cases h‚ÇÅ; cases h‚ÇÇ; rfl) (g a‚ÇÅ a‚ÇÇ b‚ÇÅ b‚ÇÇ) = g a‚ÇÅ' a‚ÇÇ' (dcast h‚ÇÅ b‚ÇÅ) (dcast h‚ÇÇ b‚ÇÇ)

theorem mul_distrib_add {a b : CNat 1} : a * (b + 1) = a * b + a

@[simp]
theorem LeafData.get_ofFun {Œ±} {s} (f : SkeletonLeafIndex s ‚Üí Œ±) :
    (LeafData.ofFun s f).get = f

theorem mobius_apply_zeta_apply_eq_id (n : ‚Ñï) [NeZero n] (r : Fin n) (l : Fin (r.val + 1))
    (v : Vector R (2 ^ n)) : lagrangeToMono_segment n r l (monoToLagrange_segment n r l v) = v

lemma take_eq_take : transcript‚ü¶:m‚üß = transcript.take m h

@[simp]
theorem fappend‚ÇÇ_left {Œ±‚ÇÅ : Fin m ‚Üí A} {Œ±‚ÇÇ : Fin m ‚Üí B} {Œ≤‚ÇÅ : Fin n ‚Üí A} {Œ≤‚ÇÇ : Fin n ‚Üí B}
    (u : (i : Fin m) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i)) (v : (i : Fin n) ‚Üí F‚ÇÇ (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) (i : Fin m) :
    fappend‚ÇÇ (F := F‚ÇÇ) u v (castAdd n i) =
      cast (by simp [vappend_left]) (u i)

@[simp]
lemma degree_polynomialOfCoeffs_deg_lt_deg :
  (polynomialOfCoeffs coeffs).degree < deg

@[simp]
theorem splitSum_zero {n : Fin 0 ‚Üí ‚Ñï} {k : Fin (vsum n)} : splitSum k = Fin.elim0 k

theorem FullData.toLeafData_rightSubtree {Œ±} {s_left s_right : Skeleton}
    (tree : FullData Œ± (Skeleton.internal s_left s_right)) :
    tree.toLeafData.rightSubtree =
      tree.rightSubtree.toLeafData

@[simp]
lemma bIdx_mul_œë_add_i_fin_‚Ñì_pred_lt_‚Ñì (bIdx : Fin (‚Ñì / œë - 1)) (i : Fin (œë - 1))
    : ‚ÜëbIdx * œë + ‚Üëi < ‚Ñì

lemma galois_eval_in_BTField
    {curBTField : Type*} [Field curBTField]
    (u : curBTField) (t1 : curBTField) -- here t1 is already lifted to curBTField
    (k : ‚Ñï)
    (sumZeroIffEq : ‚àÄ (x y : curBTField), x + y = 0 ‚Üî x = y)
    (prevSpecialElementNeZero : t1 ‚â† 0)
    (u_plus_inv_eq_t1 : u + u‚Åª¬π = t1)
    (h_u_square : u^2 = u*t1 + 1)
    (h_t1_pow : t1^(2^(2^k)-1) = 1 ‚àß (t1‚Åª¬π)^(2^(2^k)-1) = 1)
    (h_t1_pow_2_pow_2_pow_k :  t1^(2^(2^k)) = t1)
    (h_t1_inv_pow_2_pow_2_pow_k :  (t1‚Åª¬π)^(2^(2^k)) = t1‚Åª¬π)
    (trace_map_at_inv : ‚àë i ‚àà Finset.range (2 ^ k), t1‚Åª¬π ^ (2 ^ i) = 1) :
    u^(2^(2^k)) = u‚Åª¬π

theorem LeafData.composeBuild_leaf {Œ±} (a : Œ±)
    (compose : Œ± ‚Üí Œ± ‚Üí Œ±) :
    (LeafData.leaf a).composeBuild compose = FullData.leaf a

theorem trim_equiv [LawfulBEq R] (p : UniPoly R) : equiv p.trim p

@[simp]
theorem finSuccEquivNth_X_above {i : Fin n} (h : p < i.succ) :
    finSuccEquivNth R p (X i.succ) = Polynomial.C (X i)

@[simp]
lemma halfNumFullRounds_mul_2_eq_numFullRounds :
    params.halfNumFullRounds * 2 = params.numFullRounds

theorem oracleVerifier_rbrKnowledgeSoundness [Fintype R] :
    (oracleVerifier R n deg D oSpec i).rbrKnowledgeSoundness init impl
    (relationRound R n deg D i.castSucc) (relationRound R n deg D i.succ)
    (fun _ => (deg : ‚Ñù‚â•0) / Fintype.card R)

theorem monomialBasis_getElem {w : Vector R n} (i : Fin (2 ^ n)) :
    (monomialBasis w)[i] = ‚àè j : Fin n, if (BitVec.ofFin i).getLsb j then w[j] else 1

theorem fold_advances_evaluation_poly
  (i : Fin (‚Ñì)) (h_i_succ_lt : i + 1 < ‚Ñì + ùì°)
  (coeffs : Fin (2 ^ (‚Ñì - ‚Üëi)) ‚Üí L) (r_chal : L) :
  let P_i : L[X] := intermediateEvaluationPoly ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i, by
    exact Nat.lt_trans (n := i) (k := ‚Ñì+1) (m := ‚Ñì) (h‚ÇÅ := i.isLt) (by exact Nat.lt_add_one ‚Ñì)
  ‚ü©) coeffs
  let f_i

theorem reduction_perfectCompleteness (hInit : init.neverFails) :
    (reduction R deg D n oSpec).perfectCompleteness init impl
      (relationRound R n deg D 0) (relationRound R n deg D (.last n))

@[simp]
theorem dappend_left {motive : Fin (m + n) ‚Üí Sort u} (u : (i : Fin m) ‚Üí motive (castAdd n i))
    (v : (i : Fin n) ‚Üí motive (natAdd m i)) (i : Fin m) :
    dappend (motive := motive) u v (castAdd n i) = u i

@[simp]
theorem fappend‚ÇÇ_succ {Œ±‚ÇÅ : Fin m ‚Üí A} {Œ±‚ÇÇ : Fin m ‚Üí B}
    {Œ≤‚ÇÅ : Fin (n + 1) ‚Üí A} {Œ≤‚ÇÇ : Fin (n + 1) ‚Üí B}
    (u : (i : Fin m) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i)) (v : (i : Fin (n + 1)) ‚Üí F‚ÇÇ (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) :
    fappend‚ÇÇ (F := F‚ÇÇ) u v =
      fconcat‚ÇÇ (F := F‚ÇÇ) (fappend‚ÇÇ (F := F‚ÇÇ) u (fun i => v (castSucc i))) (v (last n))

@[simp]
theorem Basis_cast_dest_apply {Œπ : Type*} (Œ± Œ≤ Œ≥ : ‚Ñï)
    (h_le1 : Œ± ‚â§ Œ≤) (h_le2 : Œ± ‚â§ Œ≥)
    (h_eq : Œ≤ = Œ≥) {k : Œπ} (b : @Basis Œπ (ConcreteBTField Œ±) (ConcreteBTField Œ≤) _ _
    (@ConcreteBTFieldAlgebra (l := Œ±) (r := Œ≤) (h_le := h_le1)).toModule) :
    let castBasis : @Basis Œπ (ConcreteBTField Œ±) (ConcreteBTField Œ≥) _ _
      (@ConcreteBTFieldAlgebra (l := Œ±) (r := Œ≥) (h_le := h_le2)).toModule :=
      cast (by
        exact Basis_cast_dest_eq Œ± Œ≥ Œ≤ h_le2 h_le1 h_eq
      ) b
    (castBasis k) = cast (by
      exact cast_ConcreteBTField_eq Œ≤ Œ≥ h_eq) (b k)

@[simp]
lemma eval‚ÇÇ_comp_C {S : Type w} [CommSemiring S] (f : R ‚Üí+* S) (x : S) :
    (eval‚ÇÇ f x).comp (C : R ‚Üí+* P) = f

theorem eval‚ÇÇ_quadratic_prevField_coeff
  {prevBTField : Type*} [CommRing prevBTField]
  {curBTField : Type*} [CommRing curBTField]
  (of_prev : prevBTField ‚Üí+* curBTField)
  (t1 : prevBTField)
  (x : curBTField) :
  eval‚ÇÇ of_prev x (X^2 + (C t1 * X + 1)) = x^2 + of_prev t1 * x + 1

lemma natDegree_lt_of_mem_degreeLT [NeZero deg] (h : p ‚àà degreeLT F deg) : p.natDegree < deg

@[simp]
theorem oracleVerifier_rbrKnowledgeSoundness (hRel : ‚àÄ stmtIn oStmtIn witOut,
      ((mapStmt stmtIn, mapOStmt embedIdx hEq oStmtIn), witOut) ‚àà relOut ‚Üí
      ((stmtIn, oStmtIn), mapWitInv (stmtIn, oStmtIn) witOut) ‚àà relIn) :
    (oracleVerifier oSpec mapStmt embedIdx hEq).rbrKnowledgeSoundness init impl relIn relOut 0

theorem srKnowledgeSoundness_addSalt_implies_srKnowledgeSoundness_original
    (relIn : Set (StmtIn √ó WitIn)) (relOut : Set (StmtOut √ó WitOut))
    (Salt : pSpec.MessageIdx ‚Üí Type) [‚àÄ i, Nonempty (Salt i)] [‚àÄ i, Fintype (Salt i)]
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    (srInit : ProbComp (srChallengeOracle StmtIn (pSpec.addSalt Salt)).FunctionType)
    (srImpl : QueryImpl oSpec
      (StateT (srChallengeOracle StmtIn (pSpec.addSalt Salt)).FunctionType ProbComp))
    (srKnowledgeError : ‚Ñù‚â•0) :
      Verifier.StateRestoration.knowledgeSoundness srInit srImpl relIn relOut
        (verifier.addSalt Salt) srKnowledgeError ‚Üí
        Verifier.StateRestoration.knowledgeSoundness sorry sorry relIn relOut
          verifier srKnowledgeError

theorem oracleVerifier_toVerifier_run {stmt : Statement} {oStmt : ‚àÄ i, OStatement i}
    {tr : (oraclePSpec Witness).FullTranscript} :
    (oracleVerifier oSpec Statement OStatement Witness).toVerifier.run ‚ü®stmt, oStmt‚ü© tr =
      pure ‚ü®stmt, Sum.rec oStmt (fun i => match i with | 0 => tr 0)‚ü©

theorem liftContext_perfectCompleteness
    (h : R.perfectCompleteness init impl innerRelIn innerRelOut) :
      (R.liftContext lens).perfectCompleteness init impl outerRelIn outerRelOut

theorem induction_append_left {m n : ‚Ñï} {motive : Fin (m + n + 1) ‚Üí Sort*} {zero : motive 0}
    {succ : ‚àÄ i : Fin (m + n), motive i.castSucc ‚Üí motive i.succ} {i : Fin (m + 1)} :
      induction (motive := motive) zero succ ‚ü®i, by omega‚ü© =
        @induction m (fun j => motive ‚ü®j, by omega‚ü©) zero (fun j x => succ ‚ü®j, by omega‚ü© x) i

@[simp]
theorem fappend_succ {Œ± : Fin m ‚Üí A} {Œ≤ : Fin (n + 1) ‚Üí A}
    (u : (i : Fin m) ‚Üí F (Œ± i)) (v : (i : Fin (n + 1)) ‚Üí F (Œ≤ i)) :
    fappend u v = fconcat (fappend u (fun i => v (castSucc i))) (v (last n))

lemma towerRingHomForwardMap_one {k : ‚Ñï} :
  (towerRingHomForwardMap k) 1 = 1

@[simp, grind _=_]
lemma degreeX_mul [IsDomain F] (f g : F[X][Y]) (hf : f ‚â† 0) (hg : g ‚â† 0) :
  degreeX (f * g) = degreeX f + degreeX g

@[simp]
lemma concrete_natCast_one_eq_one {k : ‚Ñï} : natCast 1 = (1 : ConcreteBTField k)

@[simp]
theorem dappend_right {motive : Fin (m + n) ‚Üí Sort u} (u : (i : Fin m) ‚Üí motive (castAdd n i))
    (v : (i : Fin n) ‚Üí motive (natAdd m i)) (i : Fin n) :
    dappend (motive := motive) u v (natAdd m i) = v i

@[simp]
theorem simulateQ'_bind (oa : OracleComp spec Œ±) (ob : Œ± ‚Üí OracleComp spec Œ≤)
    -- Could potentially be weakened to `‚àÄ x ‚àà oa.support, (ob x).neverFails`
    -- Would require `bindOnSupport` instead of just `bind`
    (ha : oa.neverFails) (hb : ‚àÄ x, (ob x).neverFails) :
      simulateQ' so (oa >>= ob) (by simp; exact ‚ü®ha, fun x _ => hb x‚ü©) =
      simulateQ' so oa ha >>= fun x ‚Ü¶ simulateQ' so (ob x) (hb x)

lemma bwm_of_pos [NeZero n] (h : j.1 < e) :
  BerlekampWelchMatrix e k œâs f i j = -Rhs j.1 œâs f i

Nat.pos_of_neZero in Init.Data.Nat.Basic

theorem image_support_finSuccEquivNth {f : MvPolynomial (Fin (n + 1)) R} {i : ‚Ñï} :
    Finset.image (Finsupp.insertNth p i) (Polynomial.coeff ((finSuccEquivNth R p) f) i).support =
      f.support.filter fun m => m p = i

lemma smul_Z_eq_zero_x {k : ‚Ñï} (h_pos : k > 0) (x : ConcreteBTField (k - 1)) :
  letI instAlgebra := ConcreteBTFieldAlgebra (l:=k-1) (r:=k) (h_le:=by omega)
  x ‚Ä¢ Z k = „Ää x, 0 „Äã

@[simp]
lemma shift_left_empty :
    shift_left ‚àÖ = ‚àÖ

lemma H_tilde_equiv_H_tilde' (H : F[X][Y]) : (H_tilde' H).map univPolyHom = H_tilde H

omit hF‚ÇÇ in
theorem kernel_W_eq_U (i : Fin r) :
  LinearMap.ker (polyEvalLinearMap (W ùîΩq Œ≤ i)
    (W_is_additive ùîΩq Œ≤ i)) = U ùîΩq Œ≤ i

theorem PowerBasis_cast_dest_eq (k n m : ‚Ñï) (h_k_le_n : k ‚â§ n)
  (h_k_le_m : k ‚â§ m) (h_eq : m = n) :
  letI instLeftAlgebra := ConcreteBTFieldAlgebra (l:=k) (r:=m) (h_le:=h_k_le_m)
  letI instRightAlgebra := ConcreteBTFieldAlgebra (l:=k) (r:=n) (h_le:=h_k_le_n)
  @PowerBasis (ConcreteBTField k) (ConcreteBTField m) _ _ instLeftAlgebra =
  @PowerBasis (ConcreteBTField k) (ConcreteBTField n) _ _ instRightAlgebra

omit [NeZero ‚Ñì] [NeZero r] [NeZero ùì°] in
lemma fin_‚Ñì_add_one_lt_r {h_‚Ñì_add_R_rate : ‚Ñì + ùì° < r} (i : Fin (‚Ñì + 1))
    : i.val < r

theorem rsum_eq_t1_square_aux
  {curBTField : Type*} [Field curBTField] -- curBTField ‚âÉ ùîΩ_{2^{2^k}}
  (u : curBTField) -- here u is already lifted to curBTField
  (k : ‚Ñï)
  (x_pow_card : ‚àÄ (x : curBTField), x ^ (2 ^ (2 ^ (k))) = x)
  (u_ne_zero : u ‚â† 0)
  (trace_map_prop : TraceMapProperty curBTField u k):
   ‚àë j ‚àà Finset.Icc 1 (2 ^ (k)), u ^ (2 ^ 2 ^ (k) - 2 ^ j) = u

Nat.zero_add in Init.Data.Nat.Basic

@[simp]
lemma rank_nonsquare_rows_eq_min (inj : Function.Injective Œ±) :
  (Vandermonde.nonsquare (Œπ' := n) Œ±).rank = min m n

@[simp]
theorem insertNth_removeNth : insertNth p y (removeNth p t) = update t p y

lemma inv_eq_pow (a : Field) (ha : a ‚â† 0) : a‚Åª¬π = a ^ (fieldSize - 2)

theorem challengeOracleInterface_cast {h : n‚ÇÅ = n‚ÇÇ} {hSpec : pSpec‚ÇÅ.cast h = pSpec‚ÇÇ}
    {i : pSpec‚ÇÅ.ChallengeIdx} :
    pSpec‚ÇÅ.challengeOracleInterface i =
      dcast (by simp) (pSpec‚ÇÇ.challengeOracleInterface (i.cast hn hSpec))

@[simp]
theorem cons_toList_eq_List_cons {Œ±} {n : ‚Ñï} (hd : Œ±) (tl : Vector Œ± n) :
    (cons hd tl).toList = hd :: tl.toList

lemma isPrimitiveRoot_twoAdicGenerator (bits : Fin (twoAdicity + 1)) :
    IsPrimitiveRoot (twoAdicGenerators[bits]) (2 ^ (bits : Nat))

lemma even_eval {f : Polynomial F} {s : F} (hEven : EvenPoly f) :
  f.eval (-s) = f.eval s

omit [DecidableEq L] h_Fq_char_prime hF‚ÇÇ hŒ≤_lin_indep in
lemma Prod_W_comp_X_sub_C_ne_zero (i : Fin r) :
    (univ : Finset ùîΩq).prod (fun c => (W ùîΩq Œ≤ i).comp (X - C (c ‚Ä¢ Œ≤ i))) ‚â† 0

@[simp]
lemma finite_possibleDeltas : (possibleDeltas U V).Finite

lemma getBit_of_two_pow_sub_one {i k: ‚Ñï} : getBit k (2^i - 1) =
    if k < i then 1 else 0

omit [Finite F] in
lemma minus_one_in_doms {i : ‚Ñï} (h : i < n) :
    -1 ‚àà evalDomain D i

@[simp]
lemma not_V_to_P_eq_P_to_V {x : Direction} (h : x ‚â† .P_to_V) : x = .V_to_P

lemma getLowBits_eq_mod_two_pow {numLowBits : ‚Ñï} (n : ‚Ñï) :
  getLowBits numLowBits n = n % (2 ^ numLowBits)

theorem vcons_injective2 : Function.Injective2 (@vcons Œ± n)

omit [Finite F] in
@[simp]
lemma domain_lem‚ÇÇ :
  [FinalOracleStatement D x s]‚Çí.domain (Fin.last (k + 1)) = Unit

@[simp]
lemma length_nil : nil.length = 0

theorem cast_symm {hn} (hSpec : pSpec‚ÇÅ.cast hn = pSpec‚ÇÇ) : pSpec‚ÇÇ.cast hn.symm = pSpec‚ÇÅ

lemma Basis.baseChangeRight_repr_tmul (b : Basis Œπ K Left) (x y i) :
    (Basis.baseChangeRight (b:=b) (Right:=Right)).repr (x ‚äó‚Çú y) i = b.repr x i ‚Ä¢ y

@[simp]
theorem reduction_completeness (h : init.neverFails)
    (hRel : ‚àÄ stmtIn witIn, (stmtIn, witIn) ‚àà relIn ‚Üî
      (mapStmt stmtIn, mapWit stmtIn witIn) ‚àà relOut) :
    (reduction oSpec mapStmt mapWit).perfectCompleteness init impl relIn relOut

@[simp]
theorem dcons_succ {motive : Fin (n + 1) ‚Üí Sort u} (a : motive 0)
    (v : (i : Fin n) ‚Üí motive i.succ) (i : Fin n) : (a ::·µà‚ü®motive‚ü© v) i.succ = v i

@[simp] lemma extract_dir : pSpec‚ü¶start:stop‚üß.dir = pSpec.dir‚ü¶start:stop‚üß

theorem BitVec.eq_append_iff_extract {lo_size hi_size : ‚Ñï} (lo : BitVec lo_size)
  (hi : BitVec hi_size) (h_hi_gt_0 : hi_size > 0) (h_lo_gt_0 : lo_size > 0)
  (x : BitVec (hi_size + lo_size)) : x = dcast (by rfl) (BitVec.append (msbs:=hi) (lsbs:=lo)) ‚Üî
  hi = dcast (by omega) (BitVec.extractLsb (hi:=hi_size + lo_size - 1) (lo:=lo_size) x) ‚àß
  lo = dcast (by omega) (BitVec.extractLsb (hi:=lo_size - 1) (lo:=0) x)

@[simp]
lemma possibleRelHammingDistsToC_subset_relHammingDistRange [DecidableEq F] :
  possibleDistsToCode w C relHammingDist ‚äÜ relHammingDistRange Œπ

theorem foldl_eq_toList_foldl {Œ± Œ≤} {n : ‚Ñï} (f : Œ≤ ‚Üí Œ± ‚Üí Œ≤) (init : Œ≤) (v : Vector Œ± n) :
  v.foldl (f:=f) (b:=init) = v.toList.foldl (f:=f) (init:=init)

theorem cast_symm {Œ± Œ≤ : Sort u} {h : Œ± = Œ≤} {a : Œ±} {b : Œ≤} :
    cast h a = b ‚Üî a = cast h.symm b

lemma degreeCor_eq {F : Type u_1} [Field F] [DecidableEq F] {Œπ : Type u_2} (œÜ : Œπ ‚Ü™ F)
  (dstar degree : ‚Ñï) (r : F) (f : Œπ ‚Üí F) (hd : degree ‚â§ dstar) (x : Œπ) :
  let q := œÜ x * r
  degCor œÜ dstar degree r f x =
    if q ‚â† 1
    then f x * (1 - q^(dstar - degree + 1)) / (1 - q)
    else f x * (dstar - degree + 1)

lemma BTField.coe_one_succ (l : ‚Ñï) :
  (@binaryAlgebraTower (l:=l) (r:=l+1) (h_le:=by omega)).algebraMap (1 : BTField l) =
    (1 : BTField (l+1))

omit [Finite F] in
lemma D_def : evalDomain D x 0 = x ‚Ä¢ D

private lemma johnson_unrefined_by_M' [Zero F]
  (h_n : 0 < n)
  (h_B : 2 ‚â§ B.card)
  (h_card : 2 ‚â§ (Fintype.card F))
  :
  B.card * (Fintype.card F / (Fintype.card F - 1)) *
           ((1 - e B 0 / n) ^ 2  + e B 0 ^ 2 / ((Fintype.card F - 1) * n^2) - 1 + d B/n)
  ‚â§
  (Fintype.card F / (Fintype.card F - 1)) * d B/n

@[simp]
theorem fappend‚ÇÇ_zero {Œ±‚ÇÅ : Fin m ‚Üí A} {Œ±‚ÇÇ : Fin m ‚Üí B} {Œ≤‚ÇÅ : Fin 0 ‚Üí A} {Œ≤‚ÇÇ : Fin 0 ‚Üí B}
    (u : (i : Fin m) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i)) :
    fappend‚ÇÇ (F := F‚ÇÇ) u (!h‚¶ÉF‚ÇÇ‚¶Ñ‚ü®Œ≤‚ÇÅ‚ü©‚ü®Œ≤‚ÇÇ‚ü©[] : (i : Fin 0) ‚Üí F‚ÇÇ (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) = u

theorem last_nonzero_last_iff [LawfulBEq R] {p : UniPoly R} (hp : p.size > 0) :
  p.last_nonzero = some ‚ü® p.size - 1, Nat.pred_lt_self hp ‚ü© ‚Üî p.getLast hp ‚â† 0

theorem setWidth_eq_ofNat_mod {n num_bits : Nat} (x : BitVec n) :
  BitVec.setWidth num_bits x = BitVec.ofNat num_bits (x.toNat % 2 ^ num_bits)

lemma irreducible_H
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  :
  Irreducible (H k Œ¥ x‚ÇÄ h_gs)

@[simp]
theorem happend_empty {Œ± : Fin m ‚Üí Sort u} {Œ≤ : Fin 0 ‚Üí Sort u} (v : (i : Fin m) ‚Üí Œ± i) :
    happend v !h‚ü®Œ≤‚ü©[] = v

@[simp]
lemma addSalt_dir : (pSpec.addSalt Salt).dir = pSpec.dir

theorem cast_eq_dcast‚ÇÇ {hn} {hSpec : pSpec‚ÇÅ.cast hn = pSpec‚ÇÇ} {i : ChallengeIdx pSpec‚ÇÅ}:
    i.cast hn hSpec = dcast‚ÇÇ hn hSpec i

lemma blockRelDistance_eq_relHammingDist_of_k_eq_i -- Renamed for clarity
  (i : ‚Ñï) {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F}
  [DecidableEq F] [DecidableEq Œπ] [Smooth œÜ]
  -- The Fintype instance is now declared before it is needed by `hS'`.
  [h_fintype : ‚àÄ i : ‚Ñï, Fintype (indexPowT S œÜ i)]
  (f g : (indexPowT S œÜ i) ‚Üí F) (S' : Finset (indexPowT S œÜ i))
  (hS' : S' = Finset.univ) -- This now works.
  (œÜ' : (indexPowT S œÜ i) ‚Ü™ F)
  [h_dec : DecidableBlockDisagreement i i f S' œÜ'] [DecidableEq (indexPowT S œÜ i)] :
  Œî·µ£(i, i, f, S', œÜ', g) = Œ¥·µ£(f, g)

lemma NTTStage_correctness (i : Fin (‚Ñì))
    (input_buffer : Fin (2 ^ (‚Ñì + R_rate)) ‚Üí L) (original_coeffs : Fin (2 ^ ‚Ñì) ‚Üí L) :
    additiveNTTInvariant ùîΩq Œ≤ h_‚Ñì_add_R_rate (evaluation_buffer:=input_buffer)
      (original_coeffs:=original_coeffs) (i := ‚ü®i.val+1, by omega‚ü©) ‚Üí
    additiveNTTInvariant ùîΩq Œ≤ h_‚Ñì_add_R_rate (evaluation_buffer:=NTTStage ùîΩq Œ≤ h_‚Ñì_add_R_rate
      ‚ü®i, by omega‚ü© input_buffer) (original_coeffs:=original_coeffs) ‚ü®i, by omega‚ü©

@[simp]
theorem fcons‚ÇÇ_one {Œ±‚ÇÅ : A} {Œ±‚ÇÇ : B} {Œ≤‚ÇÅ : Fin (n + 1) ‚Üí A} {Œ≤‚ÇÇ : Fin (n + 1) ‚Üí B}
    (a : F‚ÇÇ Œ±‚ÇÅ Œ±‚ÇÇ) (b : (i : Fin (n + 1)) ‚Üí F‚ÇÇ (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) :
    fcons‚ÇÇ (F := F‚ÇÇ) a b 1 = b 0

theorem dcast_symm (ha : a = a') (hb : dcast ha b = b') : dcast (ha.symm) b' = b

theorem prime_2 : Nat.Prime 2

lemma lin_shift_e [Field F] [Fintype F]
  (h_B : B.card ‚â† 0)
  :
  e B v = e ({ x - v | x ‚àà B} : Finset _) 0

lemma zero_is_0 {k : ‚Ñï} : (zero (k:=k)) = (0 : ConcreteBTField k)

lemma getBit_of_lowBits {n: ‚Ñï} (numLowBits : ‚Ñï) : ‚àÄ k, getBit k (getLowBits numLowBits n) =
    if k < numLowBits then getBit k n else 0

theorem succ_succ {T : Type u} [HasSucc T] [Add T] [One T] [LawfulHasSucc T] (x : T) :
    succ' (succ' x) = x + 1 + 1

theorem oracleReduction_perfectCompleteness (hInit : init.neverFails) :
    (oracleReduction R n deg D oSpec i).perfectCompleteness init impl
      (relationRound R n deg D i.castSucc) (relationRound R n deg D i.succ)

@[simp]
lemma polynomialOfCoeffs_mem_degreeLT [NeZero deg] :
  polynomialOfCoeffs coeffs ‚àà degreeLT F deg

@[simp]
lemma getTypes_nil : getTypes [] = []

protected theorem heq_fun_iff' {k l : ‚Ñï} {Œ± : Fin k ‚Üí Sort u} {Œ≤ : Fin l ‚Üí Sort u} (h : k = l)
    (h' : ‚àÄ i : Fin k, (Œ± i) = (Œ≤ (Fin.cast h i))) {f : (i : Fin k) ‚Üí Œ± i} {g : (j : Fin l) ‚Üí Œ≤ j} :
    HEq f g ‚Üî ‚àÄ i : Fin k, HEq (f i) (g (Fin.cast h i))

protected lemma errors_are_roots_of_elocPoly {i : ‚Ñï}
  (hi : i < n) (h : f i ‚â† p.eval (œâs i)) : (ElocPoly n œâs f p).eval (œâs i) = 0

theorem functional_completeness (Œ± : Type) {s : Skeleton}
  (idx : SkeletonLeafIndex s)
  (leaf_data_tree : LeafData Œ± s)
  (hash : Œ± ‚Üí Œ± ‚Üí Œ±) :
  (getPutativeRoot_with_hash
    idx
    (leaf_data_tree.get idx)
    (generateProof
      (buildMerkleTree_with_hash leaf_data_tree hash) idx)
    (hash)) =
  (buildMerkleTree_with_hash leaf_data_tree hash).getRootValue

@[simp]
theorem init_apply : init s i = s i.castSucc

@[simp]
lemma list_eq (k : ‚Ñï) :
  list (k+1) = (Z (k+1)) ::·µ• (list k).map (AdjoinRoot.of (poly k))

theorem drop_tail {Œ± : Fin (n + 1) ‚Üí Sort*} (m : ‚Ñï) (h : m ‚â§ n) (v : (i : Fin (n + 1)) ‚Üí Œ± i) :
    (drop m h (tail v)) =
      fun i => dcast (by simp [Fin.cast, add_assoc])
        (drop m.succ (Nat.succ_le_succ h) v (i.cast (by omega)))

theorem neg_trim [LawfulBEq R] (p : UniPoly R) : p.trim = p ‚Üí (-p).trim = -p

theorem bitsToU_bijective (i : Fin r) :
  Function.Bijective (bitsToU (ùîΩq := ùîΩq) (Œ≤ := Œ≤) (‚Ñì := ‚Ñì) (R_rate := R_rate) i)

lemma rounds_sub_steps_lt : ‚Ñì - œë < ‚Ñì :=
  Nat.sub_lt (pos_of_neZero ‚Ñì) (folding_steps_pos)

lemma œë_sub_one_le_self : œë - 1 < œë

@[simp]
theorem BTField.RingHom_cast_dest_AdjoinRoot_apply (k m : ‚Ñï)
  (f : BTField k ‚Üí+* AdjoinRoot (poly m)) (x : BTField k) :
  (cast (BTField.RingHom_eq_of_dest_AdjoinRoot_eq (k:=k) (m:=m)).symm f) x
  = cast (BTField_succ_eq_adjoinRoot m) (f x)

@[simp]
theorem acceptRejectOracleRel_language :
    acceptRejectOracleRel.language = { (true, isEmptyElim) }

Nat.lt_of_le_of_lt in Init.Prelude

@[to_additive]
theorem prod_Iic_eq_univ (i : Fin (n + 1)) :
    ‚àè j ‚àà Iic i, v j = ‚àè j : Fin (i + 1), v (Fin.castLE i.isLt j)

omit [SelectableType R] in
@[simp]
lemma oracleReduction_verifier_eq_oracleVerifier :
    (oracleReduction R deg D n oSpec).verifier = oracleVerifier R deg D n oSpec

theorem verifier_rbr_knowledge_soundness :
    (verifier oSpec Statement pred).rbrKnowledgeSoundness init impl
      (relIn Statement pred) (relOut Statement) 0

theorem eval_toPoly_eq_eval (x : Q) (p : UniPoly Q) : p.toPoly.eval x = p.eval x

@[simp]
theorem LeafData.optionComposeBuild_internal {Œ±} {s_left s_right : Skeleton}
    (left : LeafData Œ± s_left) (right : LeafData Œ± s_right)
    (compose : Œ± ‚Üí Œ± ‚Üí Option Œ±) :
    (LeafData.internal left right).optionComposeBuild compose =
      FullData.internal
        (Option.doubleBind compose
          (left.optionComposeBuild compose).getRootValue
          (right.optionComposeBuild compose).getRootValue)
        (left.optionComposeBuild compose)
        (right.optionComposeBuild compose)

@[simp]
lemma divide_by_2_empty :
    divide_by_2 ‚àÖ = ‚àÖ

@[simp]
theorem join_eq_join_via_add_smul {k : ‚Ñï} (h_pos : k > 0)
    (hi_btf lo_btf : ConcreteBTField (k - 1)) :
    „Ää hi_btf, lo_btf „Äã = join_via_add_smul k h_pos hi_btf lo_btf

theorem GF_2_pow_card (x : GF(2)) : x ^ Fintype.card (GF(2)) = x

lemma aeval_eq {A : Type w} [CommSemiring A] [Algebra R A] (f : P ‚Üí‚Çê[R] A) : f = aeval (f X)

theorem dext_iff {Œ± : Fin n ‚Üí Sort u} {v w : (i : Fin n) ‚Üí Œ± i} :
    v = w ‚Üî ‚àÄ i, v i = w i

@[simp]
lemma dotProduct_cons (a : R) (b : Vector R n) (c : R) (d : Vector R n) :
    _root_.dotProduct (cons a b).get (cons c d).get = a * c + _root_.dotProduct b.get d.get

theorem dconcat_dcons_eq_dcons_dconcat {motive : Fin (n + 2) ‚Üí Sort u} (a : motive 0)
    (v : (i : Fin n) ‚Üí motive (succ (castSucc i))) (b : motive (last (n + 1))) :
    (a ::·µà v) :+·µà‚ü®motive‚ü© b = a ::·µà‚ü®motive‚ü© (v :+·µà b)

theorem singleton_bound_linear [CommRing F] [StrongRankCondition F]
    (LC : LinearCode Œπ F) :
    Module.finrank F LC ‚â§ card Œπ - (Code.dist LC.carrier) + 1

@[simp]
theorem Reduction.id_perfectCompleteness {rel : Set (StmtIn √ó WitIn)} (hInit : init.neverFails) :
    (Reduction.id : Reduction oSpec _ _ _ _ _).perfectCompleteness init impl rel rel

theorem nsmul_raw_succ (n : ‚Ñï) (p : UniPoly Q) :
  nsmul_raw (n + 1) p = add_raw (nsmul_raw n p) p

theorem towerAlgebraMap_assoc : ‚àÄ r mid l : ‚Ñï, (h_l_le_mid : l ‚â§ mid) ‚Üí (h_mid_le_r : mid ‚â§ r) ‚Üí
    towerAlgebraMap (l:=l) (r:=r) (h_le:=by exact Nat.le_trans h_l_le_mid h_mid_le_r) =
    (towerAlgebraMap (l:=mid) (r:=r) (h_le:=h_mid_le_r)).comp
    (towerAlgebraMap (l:=l) (r:=mid) (h_le:=h_l_le_mid))

lemma one_bitvec_shiftRight {d : ‚Ñï} (h_d : d > 0) : 1 >>> d = 0

theorem append_completeness (R‚ÇÅ : Reduction oSpec Stmt‚ÇÅ Wit‚ÇÅ Stmt‚ÇÇ Wit‚ÇÇ pSpec‚ÇÅ)
    (R‚ÇÇ : Reduction oSpec Stmt‚ÇÇ Wit‚ÇÇ Stmt‚ÇÉ Wit‚ÇÉ pSpec‚ÇÇ)
    {completenessError‚ÇÅ completenessError‚ÇÇ : ‚Ñù‚â•0}
    (h‚ÇÅ : R‚ÇÅ.completeness init impl rel‚ÇÅ rel‚ÇÇ completenessError‚ÇÅ)
    (h‚ÇÇ : R‚ÇÇ.completeness init impl rel‚ÇÇ rel‚ÇÉ completenessError‚ÇÇ) :
      (R‚ÇÅ.append R‚ÇÇ).completeness init impl
        rel‚ÇÅ rel‚ÇÉ (completenessError‚ÇÅ + completenessError‚ÇÇ)

lemma Lemma_A_1 {H : F[X][Y]} (Œ≤ : ùí™ H) (D : ‚Ñï) (hD : D ‚â• Bivariate.totalDegree H)
    (S_Œ≤_card : Set.ncard (S_Œ≤ Œ≤) > (weight_Œõ_over_ùí™ Œ≤ D) * H.natDegree) :
  embeddingOfùí™IntoùïÉ _ Œ≤ = 0

theorem prime_31 : Nat.Prime 31

@[simp]
lemma constantCode_mem_code [NeZero n] :
  constantCode x Œπ ‚àà ReedSolomon.code Œ± n

theorem reduction_perfectCompleteness (hInit : init.neverFails) :
    (reduction R n deg D oSpec i).perfectCompleteness init impl
    (relationRound R n deg D i.castSucc) (relationRound R n deg D i.succ)

@[simp]
theorem dcast‚ÇÉ_trans (ha : a = a') (ha' : a' = a'')
    (hb : dcast ha b = b') (hb' : dcast ha' b' = b'')
    (hc : dcast‚ÇÇ ha hb c = c') (hc' : dcast‚ÇÇ ha' hb' c' = c'') :
    dcast‚ÇÉ ha' hb' hc' (dcast‚ÇÉ ha hb hc d) =
    dcast‚ÇÉ (ha.trans ha') (by simp [‚Üê hb', ‚Üê hb]) (by simp [‚Üê hc', ‚Üê hc]) d

@[simp]
lemma Rhs_add_one : Rhs (e + 1) œâs f = fun i ‚Ü¶ Rhs e œâs f i * œâs i

lemma mulVec_BerlekampWelchMatrix_eq :
  (BerlekampWelchMatrix e k œâs f).mulVec v i =
  ‚àë x : Fin (2 * e + k), v x * if x < e then f i * œâs i ^ x.1 else -œâs i ^ (x - e)

theorem hammingDist_le_of_decoder_eq_some [NeZero n] {œâs f : Fin n ‚Üí F}
  (h : decoder e k œâs f = some p) : Œî‚ÇÄ(f, p.eval ‚àò œâs) ‚â§ e

lemma exist_bit_diff_if_diff {n: ‚Ñï} (a: Fin (2^n)) (b: Fin (2^n)) (h_a_ne_b: a ‚â† b):
  ‚àÉ k: Fin n, getBit k a ‚â† getBit k b

@[simp]
theorem fconcat‚ÇÇ_castSucc {Œ±‚ÇÅ : Fin n ‚Üí A} {Œ±‚ÇÇ : Fin n ‚Üí B} {Œ≤‚ÇÅ : A} {Œ≤‚ÇÇ : B}
    (v : (i : Fin n) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i)) (a : F‚ÇÇ Œ≤‚ÇÅ Œ≤‚ÇÇ) (i : Fin n) :
    fconcat‚ÇÇ (F := F‚ÇÇ) v a (castSucc i) =
      cast (by simp [vconcat_castSucc]) (v i)

theorem vflatten_eq_vappend_last {m : ‚Ñï} {n : Fin (m + 1) ‚Üí ‚Ñï}
    {v : (i : Fin (m + 1)) ‚Üí Fin (n i) ‚Üí Œ±} :
    vflatten v =
      vappend (vflatten (fun i => v i.castSucc)) (v (last _)) ‚àò Fin.cast vsum_castSucc

@[simp]
lemma foldl'_succ {n : ‚Ñï} {Œ± : Type u} (f : (i : Fin (n + 1)) ‚Üí Œ± ‚Üí Œ±) (x : Œ±) :
    foldl' (n + 1) f x = f (last n) (foldl' n (fun i => f i.castSucc) x)

lemma gamma_eq_P
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  :
  Œ≥' x‚ÇÄ (R k Œ¥ x‚ÇÄ h_gs) (irreducible_H k (x‚ÇÄ := x‚ÇÄ) (Œ¥ := Œ¥) h_gs) =
  AppendixA.polyToPowerSeriesùïÉ _ 
    (P k Œ¥ x‚ÇÄ h_gs)

@[grind _=_]
lemma degreeX_as_weighted_deg :
  degreeX f = natWeightedDegree f 1 0

@[simp]
lemma dist_le_length [DecidableEq F] (inj : Function.Injective Œ±) :
    minDist ((ReedSolomon.code ‚ü®Œ±, inj‚ü© n) : Set (Fin m ‚Üí F)) ‚â§ m

theorem distanceLE_mvPolynomial_degreeLE {œÉ : Type*} [Fintype œÉ] [DecidableEq œÉ] :
    distanceLE (R‚¶É‚â§ d‚¶Ñ[X œÉ]) (Fintype.card œÉ * d)

Nat.mul_le_mul_right in Init.Data.Nat.Basic

@[simp]
theorem InternalData.rightSubtree_internal {Œ±} {s_left s_right : Skeleton}
    (value : Œ±) (left : InternalData Œ± s_left) (right : InternalData Œ± s_right) :
    (InternalData.internal value left right).rightSubtree = right

lemma join_via_add_smul_zero {k : ‚Ñï} (h_pos : k > 0) :
  ‚ãò 0, 0 ‚ãô = 0

theorem seqCompose_rbrKnowledgeSoundness
    (rel : ‚àÄ i, Set ((Stmt i √ó ‚àÄ j, OStmt i j) √ó Wit i))
    (V : (i : Fin m) ‚Üí OracleVerifier oSpec (Stmt i.castSucc) (OStmt i.castSucc)
      (Stmt i.succ) (OStmt i.succ) (pSpec i))
    (rbrKnowledgeError : ‚àÄ i, (pSpec i).ChallengeIdx ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (V i).rbrKnowledgeSoundness init impl
      (rel i.castSucc) (rel i.succ) (rbrKnowledgeError i)) :
    (OracleVerifier.seqCompose Stmt OStmt V).rbrKnowledgeSoundness
        init impl (rel 0) (rel (Fin.last m))
        (fun combinedIdx =>
          letI ij := seqComposeChallengeIdxToSigma combinedIdx
          rbrKnowledgeError ij.1 ij.2)

lemma sum_inv_Z_next_eq
  (k : ‚Ñï)
  (prev : ConcreteBTFStepResult (k := k)) :
  letI : Field (ConcreteBTField k) := mkFieldInstance (prev.toConcreteBTFieldProps)
  letI : Field (ConcreteBTField (k + 1)) := mkFieldInstance (k:=k+1)
    (props:=liftBTFieldProps (k:=k) (prevBTFResult:=prev))
  letI : Algebra (ConcreteBTField k) (ConcreteBTField (k + 1)) :=
    instAlgebraLiftConcreteBTField k prev
  Z (k + 1) + (Z (k + 1))‚Åª¬π = (algebraMap (ConcreteBTField k) (ConcreteBTField (k + 1))) (Z k)

theorem two_le_two_pow_n_plus_1 (n : ‚Ñï) : 2 ‚â§ 2 ^ (n + 1)

@[simp]
theorem prover_first (pSpec : ProtocolSpec n) [NeZero n] [h : ProverFirst pSpec] :
    pSpec.dir 0 = .P_to_V

@[simp]
lemma seqCompose_zero
    (Stmt : Fin 1 ‚Üí Type) (Wit : Fin 1 ‚Üí Type) {n : Fin 0 ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (P : (i : Fin 0) ‚Üí
      Prover oSpec (Stmt i.castSucc) (Wit i.castSucc) (Stmt i.succ) (Wit i.succ) (pSpec i)) :
    seqCompose Stmt Wit P = Prover.id

lemma sDomainBasisVectors_mem_sDomain (i : Fin r) (k : Fin (‚Ñì + R_rate - i)) :
  sDomainBasisVectors ùîΩq Œ≤ h_‚Ñì_add_R_rate i k
    ‚àà sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i

lemma lt_two_pow_of_lt_two_pow_exp_le (x i j: ‚Ñï)
    (h_x_lt_2_pow_i: x < 2^i) (h_i_le_j: i ‚â§ j): x < 2^j

theorem is_prime : Nat.Prime fieldSize

@[simp]
lemma polynomialOfCoeffs_eq_zero :
  polynomialOfCoeffs coeffs = 0 ‚Üî ‚àÄ (x : ‚Ñï) (h : x < deg), coeffs ‚ü®x, h‚ü© = 0

theorem foldl_split_inner {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤ ‚Üí Œ±) (init : Œ±)
    (l : List Œ≤) (h : l ‚â† []): foldl (f:=f) (init:=init) (l)
    = foldl (f:=f) (init:=f (init) (l.head (by omega))) (l.tail)

omit [Fintype L] [Fintype ùîΩq] h_Fq_char_prime in
lemma finrank_U (i : Fin r) :
  Module.finrank ùîΩq (U ùîΩq Œ≤ i) = i

@[simp]
theorem card_prod_self_eq :
  #(((s √óÀ¢ s : Finset _) ‚à© ({x : Œ± √ó Œ± | x.1 = x.2} : Finset _)) : Finset _) = #s

theorem nsmul_zero : nsmul 0 p = 0

lemma normalizedW·µ¢_eval_Œ≤·µ¢_eq_1 {i : Fin r} :
    (normalizedW (ùîΩq := ùîΩq) (Œ≤ := Œ≤) (i :=i)).eval (Œ≤ i) = 1

Polynomial.degree_sum_le in Mathlib.Algebra.Polynomial.Degree.Definitions

theorem BitVec.extractLsb_eq_shift_ofNat {n : Nat} (x : BitVec n) (l r : Nat) :
    BitVec.extractLsb r l x = BitVec.ofNat (r - l + 1) (x.toNat >>> l)

lemma join_zero_zero {k : ‚Ñï} (h_k : k > 0) :
  „Ää zero (k:=k - 1), zero (k:=k - 1) „Äã = zero (k:=k)

@[simp]
lemma OracleVerifier.append_toVerifier
    (V‚ÇÅ : OracleVerifier oSpec Stmt‚ÇÅ OStmt‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : OracleVerifier oSpec Stmt‚ÇÇ OStmt‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ pSpec‚ÇÇ) :
      (OracleVerifier.append V‚ÇÅ V‚ÇÇ).toVerifier =
        Verifier.append V‚ÇÅ.toVerifier V‚ÇÇ.toVerifier

@[simp]
theorem append_cast_right {n m : ‚Ñï} (pSpec : ProtocolSpec n) (pSpec' : ProtocolSpec m) (m' : ‚Ñï)
    (h : n + m = n + m') :
      dcast h (pSpec ++‚Çö pSpec') = pSpec ++‚Çö (dcast (Nat.add_left_cancel h) pSpec')

beq_iff_eq in Init.Core

lemma coeff_eq_zero {p : UniPoly Q} :
    (‚àÄ i, (hi : i < p.size) ‚Üí p[i] = 0) ‚Üî ‚àÄ i, p.coeff i = 0

lemma qMap_total_fiber_basis_sum_repr (i : Fin ‚Ñì) (steps : ‚Ñï) (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
    (y : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) (i := ‚ü®i + steps, by omega‚ü©))
    (k : Fin (2 ^ steps)) :
    let x : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i, by omega‚ü©) := qMap_total_fiber ùîΩq Œ≤
      (i := ‚ü®i, by omega‚ü©) (steps := steps) (h_i_add_steps := by
        apply Nat.lt_add_of_pos_right_of_le; omega) (y := y) (k)
    let basis_x := sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i, by omega‚ü©
      (by simp only; apply Nat.lt_add_of_pos_right_of_le; omega)
    let basis_y := sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i + steps, by omega‚ü©
      (h_i := by apply Nat.lt_add_of_pos_right_of_le; omega)
    let y_coeffs := basis_y.repr y
    x = ‚àë j : Fin (‚Ñì + ùì° - i), (
      fiber_coeff (i := i) (steps := steps) (j := j) (elementIdx := k) (y_coeffs := y_coeffs)
    ) ‚Ä¢ (basis_x j)

@[simp, grind =]
lemma totalDegree_monomialXY {n m : ‚Ñï} {a : F} (ha : a ‚â† 0) :
  totalDegree (monomialXY n m a) = n + m

theorem cast_eq_dcast‚ÇÇ {T : FullTranscript pSpec‚ÇÅ} :
    dcast‚ÇÇ hn hSpec T = FullTranscript.cast hn hSpec T

@[simp]
lemma bIdx_mul_œë_add_i_cast_lt_‚Ñì_succ (bIdx : Fin (‚Ñì / œë - 1)) (i : Fin (œë - 1 + 1))
    : ‚ÜëbIdx * œë + i < ‚Ñì + 1

theorem lagrangeToMonoLevel_monoToLagrangeLevel_id (v : Vector R (2 ^ n)) (i : Fin n) :
  lagrangeToMonoLevel i (monoToLagrangeLevel i v) = v

@[simp]
lemma coe_fn_of_coe (f : ‚àÄ a, Œ≤ a) : (f : F) = inst.equiv.invFun f

@[simp]
lemma coeff_polynomialOfCoeffs_eq_coeffs'' :
  (polynomialOfCoeffs coeffs).coeff = Fin.liftF coeffs

@[simp]
lemma length_cons (x : Œ£ Œ± : Type u, Œ±) (xs : HList) : (x ::‚Çï xs).length = xs.length + 1

theorem finalSumcheckOracleReduction_perfectCompleteness {œÉ : Type}
  (init : ProbComp œÉ)
  (impl : QueryImpl []‚Çí (StateT œÉ ProbComp))
  (hInit : init.neverFails) :
  OracleReduction.perfectCompleteness
    (pSpec := pSpecFinalSumcheckStep (L := L))
    (relIn := roundRelation ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (ùìë := ùìë) (mp := BBF_SumcheckMultiplierParam) (Fin.last ‚Ñì))
    (relOut := finalSumcheckRelOut ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (oracleReduction := finalSumcheckOracleReduction ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)) (init := init) (impl := impl)

theorem hcons_eq_hcons_iff {Œ≤ : Fin n ‚Üí Sort u} (a‚ÇÅ a‚ÇÇ : Œ±) (v‚ÇÅ v‚ÇÇ : (i : Fin n) ‚Üí Œ≤ i) :
    hcons a‚ÇÅ v‚ÇÅ = hcons a‚ÇÇ v‚ÇÇ ‚Üî a‚ÇÅ = a‚ÇÇ ‚àß v‚ÇÅ = v‚ÇÇ

lemma HList.toDVec_eq_getValue (l : HList) (i : Fin l.length) : l.toDVec i = l.getValue i

@[simp]
theorem vconcat_castSucc (v : Fin n ‚Üí Œ±) (a : Œ±) (i : Fin n) :
    vconcat v a (castSucc i) = v i

theorem vconcat_left_injective {n : ‚Ñï} (a : Œ±) :
    Function.Injective (fun v : Fin n ‚Üí Œ± => vconcat v a)

theorem fconcat‚ÇÇ_injective2 {Œ±‚ÇÅ : Fin n ‚Üí A} {Œ±‚ÇÇ : Fin n ‚Üí B} {Œ≤‚ÇÅ : A} {Œ≤‚ÇÇ : B} :
    Function.Injective2 (@fconcat‚ÇÇ A B F‚ÇÇ n Œ±‚ÇÅ Œ≤‚ÇÅ Œ±‚ÇÇ Œ≤‚ÇÇ)

lemma Fin.val_add_one' (a : Fin r) (h_a_add_1 : a + 1 < r) : (a + 1).val = a.val + 1

@[simp]
lemma seqCompose_succ {m : ‚Ñï}
    (Stmt : Fin (m + 2) ‚Üí Type) (Wit : Fin (m + 2) ‚Üí Type)
    {n : Fin (m + 1) ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (P : (i : Fin (m + 1)) ‚Üí
      Prover oSpec (Stmt i.castSucc) (Wit i.castSucc) (Stmt i.succ) (Wit i.succ) (pSpec i)) :
    seqCompose Stmt Wit P =
      append (P 0) (seqCompose (Stmt ‚àò Fin.succ) (Wit ‚àò Fin.succ) (fun i => P (Fin.succ i)))

theorem cast_eq_cast_iff {Œ± Œ≤ Œ≥ : Sort u} {h : Œ± = Œ≥} {h' : Œ≤ = Œ≥} {a : Œ±} {b : Œ≤} :
    cast h a = cast h' b ‚Üî a = cast (h'.trans h.symm) b

private lemma errors_are_roots_of_E {i : Fin n}
  (h : f i ‚â† p.eval (œâs i)) : (E œâs f p e).eval (œâs i) = 0

omit [DecidableEq F] in
@[simp]
lemma isBerlekampWelchSolution_zero_zero [NeZero n] {v : Fin (2 * 0 + 0) ‚Üí F} :
  IsBerlekampWelchSolution 0 0 œâs f v ‚Üî f = 0

lemma add_equiv_raw [LawfulBEq R] (p q : UniPoly R) : Trim.equiv (p.add q) (p.add_raw q)

lemma nonsquare_mulVecLin [CommSemiring F] {Œπ' : ‚Ñï} {Œ±‚ÇÅ : Œπ ‚Ü™ F} {Œ±‚ÇÇ : Fin Œπ' ‚Üí F} {i : Œπ} :
  (nonsquare Œπ' Œ±‚ÇÅ).mulVecLin Œ±‚ÇÇ i = ‚àë x, Œ±‚ÇÇ x * Œ±‚ÇÅ i ^ x.1

theorem ZMod.powNeOfPowMod :
    ‚àÄ {n a' q c : ‚Ñï} (a : ZMod n), (a' : ZMod n) = a ‚Üí decide (n ‚â• 2) = true ‚Üí
      Nat.mod (Nat.pow a' ((n - 1) / q)) n = c ‚Üí decide (c ‚â† 1) = true ‚Üí a ^ ((n - 1) / q) ‚â† 1

theorem zero_lt_pow_n (m : ‚Ñï) (n : ‚Ñï) (h_m : m > 0): 0 < m^n

theorem cast_eq_dcast‚ÇÇ {hn} {hSpec : pSpec‚ÇÅ.cast hn = pSpec‚ÇÇ} {i : MessageIdx pSpec‚ÇÅ}:
    i.cast hn hSpec = dcast‚ÇÇ hn hSpec i

@[simp]
theorem fflatten‚ÇÇ_one {A : Sort u} {B : Sort v} {F : A ‚Üí B ‚Üí Sort w} {n : Fin 1 ‚Üí ‚Ñï}
    {Œ± : (i : Fin 1) ‚Üí (j : Fin (n i)) ‚Üí A}
    {Œ≤ : (i : Fin 1) ‚Üí (j : Fin (n i)) ‚Üí B}
    {v : (i : Fin 1) ‚Üí (j : Fin (n i)) ‚Üí F (Œ± i j) (Œ≤ i j)} :
    fflatten‚ÇÇ v = v 0

private theorem toNat_mulNat (a : AssocNat) (k : Nat) : toNat (mulNat a k) = toNat a * k

@[simp, grind] lemma N_pos : 0 < sz.N

theorem toPoly_toImpl {p : Q[X]} : p.toImpl.toPoly = p

theorem GF_2_one_add_one_eq_zero : (1 + 1 : GF(2)) = 0

@[simp, grind] lemma R_pos : 0 < sz.R

lemma division_by_conjugate {a b : ‚Ñù} (hpos : 0 ‚â§ b) (hnonzero : a + b.sqrt ‚â† 0) :
  a - (b).sqrt = (a^2 - b)/(a + b.sqrt)

lemma add_self_cancel {k : ‚Ñï} (a : ConcreteBTField k) : a + a = 0

theorem basisVectors_span (‚Ñì : Nat) (h_‚Ñì : ‚Ñì ‚â§ r) :
    Submodule.span L (Set.range (basisVectors ùîΩq Œ≤ ‚Ñì h_‚Ñì)) = ‚ä§

@[simp]
lemma probFailure_bind_eq_zero_iff [spec.FiniteRange]
    (oa : OracleComp spec Œ±) (ob : Œ± ‚Üí OracleComp spec Œ≤) :
    [‚ä• | oa >>= ob] = 0 ‚Üî [‚ä• | oa] = 0 ‚àß ‚àÄ x ‚àà oa.support, [‚ä• | ob x] = 0

theorem BitVec.dcast_bitvec_extractLsb_eq {w hi1 lo1 hi2 lo2 : ‚Ñï}
    (x : BitVec w) (h_lo_eq : lo1 = lo2)
    (h_width_eq : hi1 - lo1 + 1 = hi2 - lo2 + 1) :
    dcast h_width_eq (BitVec.extractLsb (hi:=hi1) (lo:=lo1) x)
      = BitVec.extractLsb (hi:=hi2) (lo:=lo2) (x)

Nat.lt_trans in Init.Prelude

theorem vconcat_init_self (v : Fin (n + 1) ‚Üí Œ±) :
    vconcat (fun i => v (Fin.castSucc i)) (v (Fin.last n)) = v

theorem rtake_rev_eq_take_of_rev {Œ± : Sort*} (m : ‚Ñï) (h : m ‚â§ n) (v : Fin n ‚Üí Œ±) :
    rtake m h v ‚àò Fin.rev = (take m h (v ‚àò Fin.rev))

@[simp]
theorem InternalData.leftSubtree_internal {Œ±} {s_left s_right : Skeleton}
    (value : Œ±) (left : InternalData Œ± s_left) (right : InternalData Œ± s_right) :
    (InternalData.internal value left right).leftSubtree = left

lemma getLowBits_joinBits {n m : ‚Ñï} (low : Fin (2 ^ n)) (high : Fin (2 ^ m)) :
  getLowBits n (joinBits low high).val = low.val

lemma zero_add {k : ‚Ñï} (a : ConcreteBTField k) : 0 + a = a

Nat.le_of_succ_le in Init.Data.Nat.Basic

private lemma aux_sum [Zero F]
  (h_n : 0 < n)
  : n * choose_2 (aux_frac B (k B)) ‚â§ ‚àë i, choose_2 (aux_frac B (K B i 0))

theorem verifier_rbrKnowledgeSoundness [Fintype R] :
    (verifier R deg D oSpec).rbrKnowledgeSoundness init impl
    (inputRelation R deg D) (outputRelation R deg) (fun _ => (deg : ‚Ñù‚â•0) / (Fintype.card R))

theorem matchSize_eq_iff_forall_eq (l‚ÇÅ l‚ÇÇ : List Œ±) (unit : Œ±) :
    (fun (x, y) => x = y) (matchSize l‚ÇÅ l‚ÇÇ unit) ‚Üî ‚àÄ i : Nat, l‚ÇÅ.getD i unit = l‚ÇÇ.getD i unit

@[simp]
theorem LeafData.get_internal_ofLeft {Œ±} {s_left s_right : Skeleton}
    (left : LeafData Œ± s_left) (right : LeafData Œ± s_right)
    (idxLeft : SkeletonLeafIndex s_left) :
    (LeafData.internal left right).get (SkeletonLeafIndex.ofLeft idxLeft) =
      left.get idxLeft

@[simp]
theorem addCases'_right {m n : ‚Ñï} {Œ± : Fin m ‚Üí Sort u} {Œ≤ : Fin n ‚Üí Sort u}
    (left : (i : Fin m) ‚Üí Œ± i) (right : (j : Fin n) ‚Üí Œ≤ j) (i : Fin n) :
      addCases' left right (Fin.natAdd m i) = (Fin.append_right Œ± Œ≤ i) ‚ñ∏ (right i)

omit h_Fq_char_prime hF‚ÇÇ in
lemma inductive_rec_form_W_comp (i : Fin r) (h_i_add_1 : i + 1 < r)
    (h_prev_linear_map : IsLinearMap (R := ùîΩq) (M := L[X]) (M‚ÇÇ := L[X])
      (f := fun inner_p ‚Ü¶ (W ùîΩq Œ≤ i).comp inner_p))
    : ‚àÄ p: L[X], (W ùîΩq Œ≤ (i + 1)).comp p =
      ((W ùîΩq Œ≤ i).comp p) ^ Fintype.card ùîΩq -
        C (eval (Œ≤ i) (W ùîΩq Œ≤ i)) ^ (Fintype.card ùîΩq - 1) * ((W ùîΩq Œ≤ i).comp p)

theorem two_pow_ne_zero (n : ‚Ñï) : 2 ^ n ‚â† 0

theorem folding_listdecoding_if_genMutualCorrAgreement
  {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F} [Smooth œÜ] {k m : ‚Ñï}
  {S' : Finset (indexPowT S œÜ 0)} {œÜ' : (indexPowT S œÜ 0) ‚Ü™ F}
  [‚àÄ i : ‚Ñï, Fintype (indexPowT S œÜ i)] [DecidableEq (indexPowT S œÜ 0)] [Smooth œÜ']
  [h : ‚àÄ {f : (indexPowT S œÜ 0) ‚Üí F}, DecidableBlockDisagreement 0 k f S' œÜ']
  [‚àÄ i : ‚Ñï, Neg (indexPowT S œÜ i)]
  {C : Set ((indexPowT S œÜ 0) ‚Üí F)} (hcode : C = smoothCode œÜ' m) (hLe : k ‚â§ m)
  {Œ¥ : ‚Ñù‚â•0}
  {params : GenMutualCorrParams S œÜ k} :

  -- necessary typeclasses of underlying domain (Œπ·µ¢)^2 ≤ regarding finiteness,
  -- non-emptiness and smoothness
    let _ : ‚àÄ j : Fin (k + 1), Fintype (indexPowT S œÜ j) := params.inst1
    let _ : ‚àÄ j : Fin (k + 1), Nonempty (indexPowT S œÜ j) := params.inst2

    Pr_{let Œ±s ‚Üê$·µñ (Fin k ‚Üí F)}[ -- for every function `f : Œπ ‚Üí F` and
                      ‚àÄ (f : (indexPowT S œÜ 0) ‚Üí F),
                      -- `hŒ¥Le` : `Œ¥ ‚àà (0, max_{j ‚àà [0,k]} BStar(C‚±º, par‚Ñì = 2))`
                       (0 < Œ¥ ‚àß Œ¥ < 1 - Finset.univ.sup
                        (fun j => params.BStar j (params.Gen_Œ± j).C (params.Gen_Œ± j).par‚Ñì)) ‚Üí

                      let listBlock : Set ((indexPowT S œÜ 0) ‚Üí F) := Œõ·µ£(0, k, f, S', C, hcode, Œ¥)
                      let fold := fold_k f Œ±s hLe
                      let foldSet := fold_k_set listBlock Œ±s hLe
                      let kFin : Fin (k + 1) := ‚ü®k, Nat.lt_succ_self k‚ü©
                      let C‚Çñ := (params.Gen_Œ± kFin).C
                      let listHamming := relHammingBall C‚Çñ fold Œ¥

                      foldSet ‚â† listHamming
                    ] < (‚àë i : Fin (k + 1),
                          params.errStar i (params.Gen_Œ± i).C (params.Gen_Œ± i).par‚Ñì Œ¥)

theorem append_right' {u : Fin m ‚Üí Œ±} {v : Fin n ‚Üí Œ±} {i : Fin n}
    (j : Fin (m + n)) (h : j = natAdd m i) : append u v j = v i

lemma polynomialAlgEquiv_unique (f : P ‚âÉ‚Çê[R] R[X]) : f = polynomialAlgEquiv

theorem non_trivial_factors_of_non_trivial_poly_have_deg_ge_1 {R : Type*} [Field R]
    {p a b : R[X]}
    (h_prod : p = a * b)
    (h_p_nonzero : p ‚â† 0)
    (h_a_non_unit : ¬¨IsUnit a)
    (h_b_non_unit : ¬¨IsUnit b) :
    1 ‚â§ a.degree ‚àß 1 ‚â§ b.degree

List.length_drop in Init.Data.List.TakeDrop

@[csimp, grind =]
theorem findIdx'_eq_findIdx : @findIdx' = @findIdx

omit O‚Çò in
theorem seqCompose_perfectCompleteness (hInit : init.neverFails)
    (rel : (i : Fin (m + 1)) ‚Üí Set (Stmt i √ó Wit i))
    (R : ‚àÄ i, Reduction oSpec (Stmt i.castSucc) (Wit i.castSucc) (Stmt i.succ) (Wit i.succ)
      (pSpec i))
    (h : ‚àÄ i, (R i).perfectCompleteness init impl (rel i.castSucc) (rel i.succ)) :
      (Reduction.seqCompose Stmt Wit R).perfectCompleteness
        init impl (rel 0) (rel (Fin.last m))

lemma mkLastOracleIndex_last : mkLastOracleIndex ‚Ñì œë (Fin.last ‚Ñì) = ‚Ñì / œë - 1

private lemma evenPart_eq_evenPart' {f : Polynomial F} : evenPart f = evenPart' f

lemma getLowBits_zero_eq_zero {n : ‚Ñï} : getLowBits 0 n = 0

theorem split_sum_eq_sum_split {k : ‚Ñï} (h_pos : k > 0) (x‚ÇÄ x‚ÇÅ : ConcreteBTField k)
  (hi‚ÇÄ lo‚ÇÄ hi‚ÇÅ lo‚ÇÅ : ConcreteBTField (k - 1))
  (h_split_x‚ÇÄ : split h_pos x‚ÇÄ = (hi‚ÇÄ, lo‚ÇÄ))
  (h_split_x‚ÇÅ : split h_pos x‚ÇÅ = (hi‚ÇÅ, lo‚ÇÅ)) :
  split h_pos (x‚ÇÄ + x‚ÇÅ) = (hi‚ÇÄ + hi‚ÇÅ, lo‚ÇÄ + lo‚ÇÅ)

theorem happend_ext {Œ± : Fin m ‚Üí Sort u} {Œ≤ : Fin n ‚Üí Sort u}
    (u‚ÇÅ u‚ÇÇ : (i : Fin m) ‚Üí Œ± i) (v‚ÇÅ v‚ÇÇ : (i : Fin n) ‚Üí Œ≤ i) :
    happend u‚ÇÅ v‚ÇÅ = happend u‚ÇÇ v‚ÇÇ ‚Üî u‚ÇÅ = u‚ÇÇ ‚àß v‚ÇÅ = v‚ÇÇ

Fin.isLt in Init.Prelude

private lemma choose_2_eq_half_f :
  choose_2 = (1/2) * f

omit [Fintype ùîΩq] h_Fq_char_prime hŒ≤_lin_indep in
lemma eval_W_eq_zero_iff_in_U (i : Fin r) (a : L) :
  (W ùîΩq Œ≤ i).eval a = 0 ‚Üî a ‚àà U ùîΩq Œ≤ i

omit [NeZero œë] hdiv in
lemma toOutCodewordsCountOf0 : toOutCodewordsCount ‚Ñì œë 0 = 1

theorem ofFn_rtake_eq_rtake_ofFn {Œ± : Type*} {m : ‚Ñï} (h : m ‚â§ n) (v : Fin n ‚Üí Œ±) :
    List.ofFn (rtake m h v) = (List.ofFn v).rtake m

lemma getBit_of_and {n m k: ‚Ñï} : getBit k (n &&& m) = getBit k n &&& getBit k m

lemma oddPart_def :
  oddPart f =
  C (2‚Åª¬π : F) * (f - f.comp (-X)) /‚Çò X

@[simp]
theorem hcons_succ {Œ≤ : Fin n ‚Üí Sort u} (a : Œ±) (v : (i : Fin n) ‚Üí Œ≤ i) (i : Fin n) :
    hcons a v i.succ = cast (vcons_succ Œ± Œ≤ i).symm (v i)

omit [NeZero ‚Ñì] [NeZero r] [NeZero ùì°] in
lemma fin_‚Ñì_lt_‚Ñì_add_R (i : Fin ‚Ñì)
    : i.val < ‚Ñì + ùì°

theorem castSum_castAdd {n m : ‚Ñï} (i : Fin n) : castSum [n, m] (by simp) i = castAdd m i

@[simp]
lemma zero_le_relHammingDist : 0 ‚â§ Œ¥·µ£(u, v)

theorem Nat.shiftRight_eq_sub_mod_then_div_two_pow {n lo_len : ‚Ñï} :
  n >>> lo_len = (n - n % 2 ^ lo_len) / 2 ^ lo_len

@[simp]
lemma blockIdx_mul_œë_lt_‚Ñì_succ (i : Fin (‚Ñì / œë - 1 + 1)) : ‚Üëi * œë < ‚Ñì + 1

@[simp]
lemma seqCompose_zero
    (Stmt : Fin 1 ‚Üí Type)
    {Œπ‚Çõ : Fin 1 ‚Üí Type} (OStmt : (i : Fin 1) ‚Üí Œπ‚Çõ i ‚Üí Type)
    [O‚Çõ : ‚àÄ i, ‚àÄ j, OracleInterface (OStmt i j)]
    {n : Fin 0 ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    [O‚Çò : ‚àÄ i, ‚àÄ j, OracleInterface ((pSpec i).Message j)]
    (V : (i : Fin 0) ‚Üí OracleVerifier oSpec
      (Stmt i.castSucc) (OStmt i.castSucc) (Stmt i.succ) (OStmt i.succ) (pSpec i)) :
    seqCompose Stmt OStmt V = OracleVerifier.id

@[simp]
theorem dcast_eq : dcast (Eq.refl a) b = b

lemma guruswami_sudan_for_proximity_gap_property {k m : ‚Ñï} {œâs : Fin n ‚Ü™ F}
  {w : Fin n ‚Üí F}
  {Q : F[X][Y]}
  (cond : Condition (k + 1) m (proximity_gap_degree_bound ((k + 1 : ‚Ñö) / n) m n) œâs w Q)
  {p : ReedSolomon.code œâs n}
  (h : Œ¥·µ£(w, p) ‚â§ proximity_gap_johnson ((k + 1 : ‚Ñö) / n) m)
  :
  (X - Polynomial.C (ReedSolomon.codewordToPoly p)) ‚à£ Q

theorem vappend_assoc {p : ‚Ñï} (u : Fin m ‚Üí Œ±) (v : Fin n ‚Üí Œ±) (w : Fin p ‚Üí Œ±) :
    (vappend (vappend u v) w) = (vappend u (vappend v w)) ‚àò Fin.cast (add_assoc m n p)

omit [CharP L 2] [DecidableEq ùîΩq] hF‚ÇÇ h_Œ≤‚ÇÄ_eq_1 [NeZero ‚Ñì] in
theorem card_qMap_total_fiber (i : Fin ‚Ñì) (steps : ‚Ñï) (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
    (y : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i.val + steps, by omega‚ü©)) :
    Fintype.card (Set.image (qMap_total_fiber ùîΩq Œ≤ (i := ‚ü®i, by omega‚ü©) (steps := steps)
      (h_i_add_steps := by simp only; exact fin_‚Ñì_steps_lt_‚Ñì_add_R i steps h_i_add_steps)
      (y := y)) Set.univ) = 2 ^ steps

@[simp] theorem mul_zero {a : AssocNat} : a * 0 = 0

lemma coeff_vectors_linear_independent
  (‚Ñì : Nat) (h_‚Ñì : ‚Ñì ‚â§ r) :
    LinearIndependent L (toCoeffsVec (‚Ñì := ‚Ñì) ‚àò (basisVectors ùîΩq Œ≤ ‚Ñì h_‚Ñì))

@[simp]
lemma append_last_of_succ_right {u : Fin m ‚Üí Œ±} {v : Fin (n + 1) ‚Üí Œ±} :
    (append u v) (last (m + n)) = v (last n)

@[simp]
theorem OracleSpec.append_range_left {Œπ‚ÇÅ Œπ‚ÇÇ : Type} {spec‚ÇÅ : OracleSpec Œπ‚ÇÅ} {spec‚ÇÇ : OracleSpec Œπ‚ÇÇ}
    (i : Œπ‚ÇÅ) : (spec‚ÇÅ ++‚Çí spec‚ÇÇ).range (Sum.inl i) = spec‚ÇÅ.range i

@[simp]
theorem eval_mapped_poly_at_root (k : ‚Ñï) :
    eval‚ÇÇ (AdjoinRoot.of (poly k)) (Z (k+1)) (poly k) = 0

lemma evenPart_def :
  evenPart f = C (2‚Åª¬π : F) * (f + f.comp (-X))

@[simp, grind] lemma squeezePos_lt_N (sponge : DuplexSponge U C) :
    sponge.squeezePos < SpongeSize.N

lemma encode_mem_ReedSolomon_code [DecidableEq F] [NeZero deg]
    {msg : Fin deg ‚Üí F} {domain : Fin m ‚Ü™ F} :
  encode msg domain ‚àà ReedSolomon.code domain deg

@[simp]
theorem take_append_left :
    (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).take m (Nat.le_add_right m n) = pSpec‚ÇÅ

theorem runWithOracle_succeeds_iff_simulateQ_randomOracle_neverFails
     {Œ≤}
    [DecidableEq Œπ] [spec.DecidableEq] [(i : Œπ) ‚Üí SelectableType (OracleSpec.range spec i)]
    (oa : OracleComp (spec) Œ≤) (f : spec.FunctionType) :
    (runWithOracle f oa).isSome ‚Üî
    ((oa.simulateQ randomOracle).run (fun i q => some (f i q))).neverFails

lemma zipWith_const {Œ± Œ≤ : Type _} {f : Œ± ‚Üí Œ≤ ‚Üí Œ≤} {l‚ÇÅ : List Œ±} {l‚ÇÇ : List Œ≤}
  (h‚ÇÅ : l‚ÇÅ.length = l‚ÇÇ.length) (h‚ÇÇ : ‚àÄ a b, f a b = b) : l‚ÇÅ.zipWith f l‚ÇÇ = l‚ÇÇ

theorem withBot_lt_one_cases (x : WithBot ‚Ñï) (h : x < (1 : ‚Ñï)) : x = ‚ä• ‚à® x = (0 : ‚Ñï)

theorem coreInteractionOracleVerifier_rbrKnowledgeSoundness :
    (coreInteractionOracleVerifier ùîΩq Œ≤).rbrKnowledgeSoundness init impl
      (pSpec := pSpecCoreInteraction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
      (relIn := roundRelation (mp := BBF_SumcheckMultiplierParam) ùîΩq Œ≤ (œë:=œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) 0)
      (relOut := finalSumcheckRelOut ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
      (rbrKnowledgeError := coreInteractionOracleRbrKnowledgeError ùîΩq Œ≤ (œë:=œë))

lemma aeval_eq' {A : Type w} [CommSemiring A] [Algebra R A] (f : P ‚Üí‚Çê[R] A) (p : P) :
    f p = aeval (f X) p

theorem vcons_inj (a b : Œ±) (v w : Fin n ‚Üí Œ±) : a ::·µõ v = b ::·µõ w ‚Üî a = b ‚àß v = w

private lemma solutionToE_from_E
  (h_p_deg : p.natDegree < k)
  (h_dist : (Œî‚ÇÄ(f, p.eval ‚àò œâs) : ‚Ñï) ‚â§ e)
  : solutionToE e k (E_and_Q_to_a_solution e (E œâs f p e) (Q œâs f p e)) = E œâs f p e

theorem add_zero : p + 0 = p

@[simp]
lemma foldl'_zero {Œ± : Type u} (f : (i : Fin 0) ‚Üí Œ± ‚Üí Œ±) (x : Œ±) :
    foldl' 0 f x = x

lemma join_split_eq_join {k : ‚Ñï} (h_pos : k > 0) (x : ConcreteBTField k) :
  „Ää (split h_pos x).fst, (split h_pos x).snd „Äã = x

theorem sum_join_via_add_smul (k : ‚Ñï) (h_pos : k > 0) (a‚ÇÅ a‚ÇÄ b‚ÇÅ b‚ÇÄ : BTField (k - 1)) :
  ‚ãò a‚ÇÅ, a‚ÇÄ ‚ãô + ‚ãò b‚ÇÅ, b‚ÇÄ ‚ãô = ‚ãò a‚ÇÅ + b‚ÇÅ, a‚ÇÄ + b‚ÇÄ ‚ãô

private lemma johnson_bound‚ÇÄ [Zero F]
  (h_n : 0 < n)
  (h_B : 2 ‚â§ B.card)
  (h_card : 2 ‚â§ (Fintype.card F))
  :
  B.card *
    ((1 - ((Fintype.card F : ‚Ñö) / (Fintype.card F - 1)) * (e B 0 / n)) ^ 2
      - (1 - ((Fintype.card F : ‚Ñö) / (Fintype.card F - 1)) * (d B/n)))  ‚â§
  ((Fintype.card F : ‚Ñö) / (Fintype.card F - 1)) * d B/n

lemma forwardRange_dropLast (n : ‚Ñï) (r : Fin (n - 1)) (l : Fin (r.val + 1)) :
    (forwardRange n ‚ü®r + 1, by omega‚ü© ‚ü®l, by simp only; omega‚ü©).dropLast
    = forwardRange n ‚ü®r, by omega‚ü© ‚ü®l, by simp only [Fin.is_lt]‚ü©

@[simp]
lemma OracleReduction.id_toReduction :
    (OracleReduction.id : OracleReduction oSpec Statement OStatement Witness _ _ _ _).toReduction =
      Reduction.id

theorem unique_repr {R : Type*} [CommRing R] {S : Type*} [CommRing S] [Algebra R S]
    (pb : PowerBasis R S) (repr1 repr2 : Fin pb.dim ‚Üí‚ÇÄ R)
    (h : ‚àë i : Fin pb.dim, repr1 i ‚Ä¢ pb.basis i = ‚àë i : Fin pb.dim, repr2 i ‚Ä¢ pb.basis i) :
    repr1 = repr2

lemma h_sub_middle {k : ‚Ñï} (h_pos : k > 0) : 2 ^ k - 1 - 2 ^ (k - 1) + 1 = 2 ^ (k - 1)

theorem happend_assoc {Œ± : Fin m ‚Üí Sort u} {Œ≤ : Fin n ‚Üí Sort u} {p : ‚Ñï} {Œ≥ : Fin p ‚Üí Sort u}
    (u : (i : Fin m) ‚Üí Œ± i) (v : (i : Fin n) ‚Üí Œ≤ i) (w : (i : Fin p) ‚Üí Œ≥ i) :
    happend (happend u v) w =
      fun i => cast (by simp [vappend_assoc])
        (happend u (happend v w) (i.cast (by omega)))

lemma getLowBits_succ {n: ‚Ñï} (numLowBits: ‚Ñï) :
    getLowBits (numLowBits + 1) n = getLowBits numLowBits n
    + (getBit numLowBits n) <<< numLowBits

@[simp]
lemma evalDist_cast (h : Œ± = Œ≤) [spec.FiniteRange] :
    evalDist (cast (congrArg (OracleComp spec) h) oa) =
      cast (congrArg (PMF ‚àò Option) h) (evalDist oa)

theorem commitOracleVerifier_rbrKnowledgeSoundness (i : Fin ‚Ñì)
    (hCR : isCommitmentRound ‚Ñì œë i) :
    (commitOracleVerifier ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      i hCR).rbrKnowledgeSoundness init impl
      (relIn := foldStepRelOut (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i.succ)
      (commitKnowledgeError ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))

lemma getMiddleBits_eq_mod {n offset len : ‚Ñï} :
  getMiddleBits offset len n = (n >>> offset) % (2 ^ len)

lemma round_bound {n k : ‚Ñï} {s : Fin (k + 1) ‚Üí ‚Ñï+} {d : ‚Ñï+}
    (domain_size_cond : (2 ^ (‚àë i, (s i).1)) * d ‚â§ 2 ^ n) :
  (‚àë i, (s i).1) ‚â§ n

theorem zero_add (hp : p.canonical) : 0 + p = p

theorem galois_automorphism_power
    {curBTField : Type*} [Field curBTField]
    (u : curBTField) (t1 : curBTField) -- here t1 is already lifted to curBTField
    (k : ‚Ñï)
    (sumZeroIffEq : ‚àÄ (x y : curBTField), x + y = 0 ‚Üî x = y)
    (specialElementNeZero : u ‚â† 0)
    (prevSpecialElementNeZero : t1 ‚â† 0)
    (u_plus_inv_eq_t1 : u + u‚Åª¬π = t1)
    (h_u_square : u ^ 2 = u * t1 + 1)
    (h_t1_pow : t1 ^ (2 ^ (2 ^ k) - 1) = 1 ‚àß (t1‚Åª¬π) ^ (2 ^ (2 ^ k) - 1) = 1)
    (trace_map_roots : ‚àë i ‚àà Finset.range (2 ^ k), t1 ^ (2 ^ i) = 1 ‚àß
                      ‚àë i ‚àà Finset.range (2 ^ k), t1‚Åª¬π ^ (2 ^ i) = 1) :
    u^(2^(2^k)) = u‚Åª¬π ‚àß (u‚Åª¬π)^(2^(2^k)) = u

lemma deevenize_comp_x_squared {f : Polynomial F} (hEven : EvenPoly f) :
    (deevenize f).comp (Polynomial.X * Polynomial.X) = f

@[simp]
theorem acceptRejectRel_language : acceptRejectRel.language = { true }

@[simp]
lemma dfoldrM'_zero {Œ± : Fin 1 ‚Üí Type u}
    (f : (i : Fin 0) ‚Üí Œ± i.succ ‚Üí m (Œ± i.castSucc)) (x : Œ± (last 0)) :
    dfoldrM' 0 Œ± f x = pure x

lemma rateOfLinearCode_eq_div [NeZero n] (inj : Function.Injective Œ±) (h : n ‚â§ m) :
  rate (ReedSolomon.code ‚ü®Œ±, inj‚ü© n) = n / m

@[simp]
theorem PowerBasis.dim_of_eq_rec
    (r1 r : ‚Ñï)
    (h_r : r = r1 + 1)
    (b : PowerBasis (ConcreteBTField r1) (ConcreteBTField (r1 + 1))) :
    letI instAlgebra : Algebra (ConcreteBTField r1) (ConcreteBTField r) :=
      ConcreteBTFieldAlgebra (l:=r1) (r:=r) (h_le:=by omega)
    ((Eq.rec (motive:=fun (x : ‚Ñï) (_ : r1 + 1 = x) => by
      letI instAlgebraCur : Algebra (ConcreteBTField r1) (ConcreteBTField x) :=
        ConcreteBTFieldAlgebra (l:=r1) (r:=x) (h_le:=by omega)
      exact PowerBasis (ConcreteBTField r1) (ConcreteBTField x)) (refl:=b) (t:=h_r.symm)) :
        PowerBasis (ConcreteBTField r1) (ConcreteBTField r)).dim
    = b.dim

theorem monoToLagrangeLevel_lagrangeToMonoLevel_id (v : Vector R (2 ^ n)) (i : Fin n) :
  monoToLagrangeLevel i (lagrangeToMonoLevel i v) = v

theorem foldl_succ
 {Œ± Œ≤} {n : ‚Ñï} [NeZero n] (f : Œ≤ ‚Üí Œ± ‚Üí Œ≤) (init : Œ≤) (v : Vector Œ± n) :
  v.foldl (f:=f) (b:=init) = v.tail.foldl (f:=f) (b:=f init v.head)

@[simp] theorem one_mul {a : AssocNat} : 1 * a = a

theorem fcons_inj {Œ≤ : Fin n ‚Üí A} (a‚ÇÅ a‚ÇÇ : F Œ±) (b‚ÇÅ b‚ÇÇ : (i : Fin n) ‚Üí F (Œ≤ i)) :
    fcons a‚ÇÅ b‚ÇÅ = fcons a‚ÇÇ b‚ÇÇ ‚Üî a‚ÇÅ = a‚ÇÇ ‚àß b‚ÇÅ = b‚ÇÇ

Nat.add_left_cancel in Init.Data.Nat.Basic

theorem FullData.toLeafData_eq_leaf {Œ±} (a : Œ±) (tree)
    (h : LeafData.leaf a = tree.toLeafData) :
    tree = FullData.leaf a

theorem drop_append_right {n' : ‚Ñï} {Œ± : Sort*} (m : ‚Ñï) (h : m ‚â§ n') (u : (i : Fin n) ‚Üí Œ±)
    (v : (i : Fin n') ‚Üí Œ±) :
      drop (n + m) (Nat.add_le_add_left h n) (append u v) =
        fun i => (drop m h v (i.cast (by omega)))

lemma getBit_eq_succ_getBit_of_mul_two {n k : ‚Ñï} : getBit (k+1) (2*n) = getBit k n

lemma and_eq_zero_iff {n m : ‚Ñï} : n &&& m = 0 ‚Üî ‚àÄ k, (n >>> k) &&& (m >>> k) = 0

@[to_additive]
theorem prod_Iio_eq_univ (i : Fin (n + 1)) :
    ‚àè j ‚àà Iio i, v j = ‚àè j : Fin i, v (Fin.castLE i.isLt.le j)

@[simp]
theorem OracleReduction.id_perfectCompleteness
    {rel : Set ((StmtIn √ó ‚àÄ i, OStmtIn i) √ó WitIn)}
    (hInit : init.neverFails) :
    (OracleReduction.id : OracleReduction oSpec _ _ _ _ _ _ _).perfectCompleteness
      init impl rel rel

private lemma f_convex {x‚ÇÅ x‚ÇÇ : ‚Ñö} {Œ±‚ÇÅ Œ±‚ÇÇ : ‚Ñö}
  (h_noneg_1 : 0 ‚â§ Œ±‚ÇÅ)
  (h_noneg_2 : 0 ‚â§ Œ±‚ÇÇ)
  (h_conv : Œ±‚ÇÅ + Œ±‚ÇÇ = 1)
  :
  f (Œ±‚ÇÅ * x‚ÇÅ + Œ±‚ÇÇ * x‚ÇÇ) ‚â§ Œ±‚ÇÅ * f x‚ÇÅ + Œ±‚ÇÇ * f x‚ÇÇ

@[simp]
lemma dfoldrM'_succ {n : ‚Ñï} {Œ± : Fin (n + 1 + 1) ‚Üí Type u}
    (f : (i : Fin (n + 1)) ‚Üí Œ± i.succ ‚Üí m (Œ± i.castSucc)) (x : Œ± (last (n + 1))) :
    dfoldrM' (n + 1) Œ± f x = (do
      let y ‚Üê dfoldrM' n (Œ± ‚àò succ) (fun i => f i.succ) x
      f 0 y)

lemma split_one {k : ‚Ñï} (h_k : k > 0) :
    split h_k (one (k:=k)) = (zero (k:=k - 1), one (k:=k - 1))

private lemma Fis_pairwise_disjoint : Set.PairwiseDisjoint Set.univ (Fi B i)

theorem distFromCode_eq_top_iff_empty (u : n ‚Üí R) (C : Set (n ‚Üí R)) : Œî‚ÇÄ(u, C) = ‚ä§ ‚Üî C = ‚àÖ

theorem oracleVerifier_eq_verifier :
    (oracleVerifier R deg D oSpec).toVerifier = verifier R deg D oSpec

@[simp]
lemma challengeOracleInterface_append_range_inl (j : pSpec‚ÇÅ.ChallengeIdx) :
    [(pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).Challenge]‚Çí.range (.inl j) = pSpec‚ÇÅ.Challenge j

theorem vconcat_injective2 : Function.Injective2 (@vconcat Œ± n)

@[simp]
theorem tail_cons {Œ±} {n : ‚Ñï} (hd : Œ±) (tl : Vector Œ± n) : (cons hd tl).tail = tl

@[simp]
lemma challengeOracleInterface_append_range_inr (j : pSpec‚ÇÇ.ChallengeIdx) :
    [(pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).Challenge]‚Çí.range (.inr j) = pSpec‚ÇÇ.Challenge j

lemma algebraMap_ConcreteBTFieldAlgebra_def (l r : ‚Ñï) (h_le : l ‚â§ r) :
    (@ConcreteBTFieldAlgebra (l:=l) (r:=r) (h_le:=h_le)).algebraMap
    = concreteTowerAlgebraMap l r h_le

theorem degrees_mul_C_le (p : MvPolynomial œÉ R) (c : R) : (p * C c).degrees ‚â§ p.degrees

theorem GF_2_card : Fintype.card (GF(2)) = 2^(2^0)

lemma definingPoly_is_not_unit {F : Type*} [Field F] [Fintype F] (s : F) [NeZero s] :
  ¬¨IsUnit (definingPoly s)

theorem append_getLast_dropLast {Œ± : Type u} (l : List Œ±) (h : l ‚â† []) :
  l.dropLast ++ [l.getLast h] = l

theorem castSum_castLT {l' : List ‚Ñï} {i : ‚Ñï} (j : Fin i) :
    castSum (i :: l') (by simp) j =
      castLT j (Nat.lt_of_lt_of_le j.isLt (List.le_sum_of_mem (by simp)))

@[simp] theorem join_cons : (l :: ls).join = l ++ ls.join

@[simp]
theorem cast_id : ProtocolSpec.cast (Eq.refl n‚ÇÅ) = id

@[simp] theorem rightpad_suffix (n : Nat) (unit : Œ±) (l : List Œ±) :
    replicate (n - l.length) unit <:+ rightpad n unit l

@[simp]
lemma length_getTypes (l : HList) : l.getTypes.length = l.length

lemma concrete_mul_left_distrib0 (a b c : ConcreteBTField 0) :
  concrete_mul a (b + c) = concrete_mul a b + concrete_mul a c

@[simp]
theorem fconcat_last {Œ± : Fin n ‚Üí A} {Œ≤ : A} (v : (i : Fin n) ‚Üí F (Œ± i)) (b : F Œ≤) :
    fconcat v b (last n) = cast (by simp [vconcat_last]) b

omit h_Œ≤‚ÇÄ_eq_1 in
lemma finToBinaryCoeffs_sDomainToFin (i : Fin r) (h_i : i < ‚Ñì + R_rate)
    (x : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i) :
    let pointFinIdx := (sDomainToFin ùîΩq Œ≤ h_‚Ñì_add_R_rate i h_i) x
    finToBinaryCoeffs ùîΩq (i := i) (idx :=pointFinIdx) =
    (sDomain_basis ùîΩq Œ≤
    h_‚Ñì_add_R_rate i h_i).repr x

private lemma oddPart_eq_oddPart' {f : Polynomial F} : oddPart f = oddPart' f

@[simp]
lemma seqCompose_zero (Stmt : Fin 1 ‚Üí Type) (Wit : Fin 1 ‚Üí Type)
    {n : Fin 0 ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (R : (i : Fin 0) ‚Üí
      Reduction oSpec (Stmt i.castSucc) (Wit i.castSucc) (Stmt i.succ) (Wit i.succ) (pSpec i)) :
    seqCompose Stmt Wit R = Reduction.id

lemma evenPart_even {f : Polynomial F} :
    EvenPoly (evenPart f)

theorem canonical_of_size_zero {p : UniPoly R} : p.size = 0 ‚Üí p.trim = p

@[simp]
lemma invFun_toFun (f : F) : inst.equiv.invFun (inst.equiv.toFun f) = f

theorem Nat.reconstruct_from_hi_and_lo_parts_or_ver (n hi_len lo_len : ‚Ñï)
  (h_n : n < 2 ^ (hi_len + lo_len)) :
    n = (((n >>> lo_len) % (2 ^ hi_len)) <<< lo_len) ||

theorem support_coeff_finSuccEquivNth {f : MvPolynomial (Fin (n + 1)) R} {i : ‚Ñï} {m : Fin n ‚Üí‚ÇÄ ‚Ñï} :
    m ‚àà (Polynomial.coeff ((finSuccEquivNth R p) f) i).support ‚Üî m.insertNth p i ‚àà f.support

omit [Fintype F] in
private lemma hamming_dist_eq_sum {x y : Fin n ‚Üí F} :
  Œî‚ÇÄ(x, y) = ‚àë i, if x i = y i then 0 else 1

theorem comp_x_square_coeff {f : Polynomial F} {n : ‚Ñï} :
  (f.comp (X * X)).coeff n = if Even n then f.coeff (n / 2) else 0

private lemma sum_choose_K' [Zero F]
  (h_card : 2 ‚â§ (Fintype.card F))
  :
  (Fintype.card (Œ± := F) - 1) * choose_2 ((B.card - K B i 0) / (Fintype.card (Œ± := F) - 1)) ‚â§
  ‚àë (Œ± : F) with Œ± ‚â† 0, choose_2 (K B i Œ±)

lemma lifted_trace_map_eval_at_roots_prev_BTField
  {curBTField : Type*} [Field curBTField]
  (u : curBTField) (t1 : curBTField) -- here t1 is already lifted to curBTField
  (k : ‚Ñï)
  (sumZeroIffEq : ‚àÄ (x y : curBTField), x + y = 0 ‚Üî x = y)
  (u_plus_inv_eq_t1 : u + u‚Åª¬π = t1)
  (galois_automorphism : u^(2^(2^k)) = u‚Åª¬π ‚àß (u‚Åª¬π)^(2^(2^k)) = u)
  (trace_map_at_prev_root : ‚àë i ‚àà Finset.range (2 ^ k), t1 ^ (2 ^ i) = 1) :
  ‚àë i ‚àà Finset.range (2 ^ (k+1)), u ^ (2 ^ i) = 1

theorem is_fiber_iff_generates_quotient_point (i : Fin ‚Ñì) (steps : ‚Ñï)
    (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
    (x : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i, by omega‚ü©))
    (y : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i.val + steps, by omega‚ü©)) :
    let qMapFiber := qMap_total_fiber ùîΩq Œ≤ (i := ‚ü®i, by omega‚ü©) (steps := steps)
      (h_i_add_steps := by simp only; exact fin_‚Ñì_steps_lt_‚Ñì_add_R i steps h_i_add_steps) (y := y)
    let k := pointToIterateQuotientIndex (i := ‚ü®i, by omega‚ü©) (steps := steps)
      (h_i_add_steps := h_i_add_steps) (x := x)
    y = iteratedQuotientMap ùîΩq Œ≤ h_‚Ñì_add_R_rate i (k := steps) (h_bound := h_i_add_steps) x ‚Üî
    qMapFiber k = x

theorem generates_quotient_point_if_is_fiber_of_y
    (i : Fin ‚Ñì) (steps : ‚Ñï) (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
    (x : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i, by omega‚ü©))
    (y : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i.val + steps, by omega‚ü©))
    (hx_is_fiber : ‚àÉ (k : Fin (2 ^ steps)), x = qMap_total_fiber ùîΩq Œ≤ (i := ‚ü®i, by omega‚ü©)
      (steps := steps) (h_i_add_steps := by
        simp only; exact fin_‚Ñì_steps_lt_‚Ñì_add_R i steps h_i_add_steps) (y := y) k) :
    y = iteratedQuotientMap ùîΩq Œ≤ h_‚Ñì_add_R_rate i (k := steps) (h_bound := h_i_add_steps) x

@[simp]
lemma relHammingDist_mem_relHammingDistRange [DecidableEq F] : Œ¥·µ£(u, v) ‚àà relHammingDistRange Œπ

@[simp]
theorem verifier_rbrKnowledgeSoundness (hRel : ‚àÄ stmtIn witOut,
      (mapStmt stmtIn, witOut) ‚àà relOut ‚Üí (stmtIn, mapWitInv stmtIn witOut) ‚àà relIn) :
    (verifier oSpec mapStmt).rbrKnowledgeSoundness init impl relIn relOut 0

lemma lastBlockIdx_isNeCommitmentRound (i : Fin œë) :
    ¬¨isCommitmentRound ‚Ñì œë ‚ü®(‚Ñì / œë - 1) * œë + ‚Üëi, lastBlockIdx_mul_œë_add_fin_lt_‚Ñì i‚ü©

lemma lin_shift_card [Field F] [Fintype F]
  :
  B.card = ({ x - v | x ‚àà B} : Finset _).card

@[simp]
theorem verifier_last (pSpec : ProtocolSpec n) [NeZero n] [h : VerifierLast pSpec] :
    pSpec.dir ‚ü®n - 1, by simp [Nat.pos_of_neZero]‚ü© = .V_to_P

lemma bIdx_succ_mul_œë_le_‚Ñì_succ (bIdx : Fin (‚Ñì / œë - 1)) : (‚ÜëbIdx + 1) * œë ‚â§ ‚Ñì + 1

lemma twoAdicity_maximal : ¬¨ (2 ^ (twoAdicity + 1)) ‚à£ (fieldSize - 1)

@[simp]
theorem oracleReduction_completeness (h : init.neverFails) :
    (oracleReduction oSpec Statement OStatement Witness).perfectCompleteness init impl oRelIn
    (toORelOut oRelIn)

@[simp]
lemma runWithLogToRound_discard_log_eq_runToRound (i : Fin (n + 1))
    (stmt : StmtIn) (wit : WitIn) (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      Prod.fst <$> prover.runWithLogToRound i stmt wit =
        prover.runToRound i stmt wit

lemma guruswami_sudan_for_proximity_gap_property {k m : ‚Ñï} {œâs : Fin n ‚Ü™ F}
  {f : Fin n ‚Üí F}
  {Q : F[X][X]}
  {p : ReedSolomon.code œâs n}
  (h : Œî‚ÇÄ(f, (ReedSolomon.codewordToPoly p).eval ‚àò f) ‚â§ proximity_gap_johnson (n := n) k m)
  :
  ((X : F[X][X]) - C (ReedSolomon.codewordToPoly p)) ‚à£ Q

lemma genMatIsVandermonde [Fintype Œπ] [Field F] [DecidableEq F] [inst : NeZero m] {Œ± : Œπ ‚Ü™ F} :
  fromColGenMat (Vandermonde.nonsquare (Œπ' := m) Œ±) = ReedSolomon.code Œ± m

@[simp]
theorem finSuccEquivNth_X_below {i : Fin n} (h : i.castSucc < p) :
    finSuccEquivNth R p (X i.castSucc) = Polynomial.C (X i)

theorem hcons_left_injective {Œ± : Sort u} {Œ≤ : Fin n ‚Üí Sort u} (b : (i : Fin n) ‚Üí Œ≤ i) :
    Function.Injective (fun (a : Œ±) => hcons a b)

Nat.succ_le_succ in Init.Prelude

@[simp]
lemma seqCompose_dir {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)} :
    (seqCompose pSpec).dir = Fin.vflatten (fun i => (pSpec i).dir)

theorem cast_Type_idx {hn} (hSpec : pSpec‚ÇÅ.cast hn = pSpec‚ÇÇ) {i : Fin n‚ÇÅ} :
    pSpec‚ÇÇ.¬´Type¬ª (Fin.cast hn i) = pSpec‚ÇÅ.¬´Type¬ª i

theorem randomOracle_cache_neverFails_iff_runWithOracle_neverFails {Œ≤}
    [DecidableEq Œπ] [spec.DecidableEq] [(i : Œπ) ‚Üí SelectableType (OracleSpec.range spec i)]
    (oa : OracleComp (spec) Œ≤) (preexisting_cache : spec.QueryCache)
    :
    ((oa.simulateQ randomOracle).run preexisting_cache).neverFails
    ‚Üî
    (‚àÄ (f : spec.FunctionType),
      Oracle.containsCache f preexisting_cache ‚Üí
      (runWithOracle f oa).isSome)

@[simp]
lemma dotProduct_cons [AddCommMonoid R] [Mul R] (a : R) (b : Vector R n) (c : R) (d : Vector R n) :
  dotProduct (cons a b) (cons c d) = a * c + dotProduct b d

theorem iteratedQuotientMap_k_eq_1_is_qMap (i : Fin ‚Ñì)
    (h_i_add_1 : i.val + 1 ‚â§ ‚Ñì) (x : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®i, by omega‚ü©) :
    iteratedQuotientMap ùîΩq Œ≤ h_‚Ñì_add_R_rate i 1 h_i_add_1 x =
    ‚ü®(qMap ùîΩq Œ≤ ‚ü®i.val, by omega‚ü©).eval (x.val : L),
      qMap_eval_mem_sDomain_succ ùîΩq Œ≤   h_‚Ñì_add_R_rate i h_i_add_1 x‚ü©

lemma cons_get_eq {Œ±} {n : ‚Ñï} (hd : Œ±) (tl : Vector Œ± n) (i : Fin (n + 1)) :
    (cons hd tl).get i =
      if hi: i.val == 0 then hd else tl.get (‚ü®i.val - 1, by
        simp only [beq_iff_eq, Fin.val_eq_zero_iff] at hi
        apply Nat.sub_lt_left_of_lt_add
        ¬∑ by_contra hi_ne_gt_1
          simp only [not_le, Nat.lt_one_iff, Fin.val_eq_zero_iff] at hi_ne_gt_1
          contradiction
        ¬∑ have hi_lt:= i.isLt; omega
      ‚ü©)

lemma erase_odd_def {s : Finset ‚Ñï} :
    erase_odd s = s.filter Even

theorem completeness_relIn_mono {Œµ : ‚Ñù‚â•0} {relIn' : Set (StmtIn √ó WitIn)}
    (hrelIn : relIn' ‚äÜ relIn) :
      completeness init impl relIn relOut reduction Œµ ‚Üí
        completeness init impl relIn' relOut reduction Œµ

@[simp]
lemma ConcreteBTField_add_eq (k n m) :
      ConcreteBTField (k + n + m) = ConcreteBTField (k + (n + m))

lemma binaryTowerAlgebra_def (l r : ‚Ñï) (h_le : l ‚â§ r) :
    @binaryAlgebraTower (l:=l) (r:=r) (h_le:=h_le)
    = (towerAlgebraMap l r h_le).toAlgebra

theorem verifier_rbrKnowledgeSoundness [Fintype R] :
    (verifier R n deg D oSpec i).rbrKnowledgeSoundness init impl
    (relationRound R n deg D i.castSucc) (relationRound R n deg D i.succ)
    (fun _ => (deg : ‚Ñù‚â•0) / Fintype.card R)

@[simp]
theorem cast_val {m n : ‚Ñï} (h : m = n) (a : Fin m) : (Fin.cast h a).val = a.val

theorem dfoldl_dcast {Œπ : Type v} {Œ≤ : Œπ ‚Üí Type u} [DCast Œπ Œ≤]
    {n : ‚Ñï} {Œ± Œ±' : Fin (n + 1) ‚Üí Œπ}
    {f : (i : Fin n) ‚Üí Œ≤ (Œ± i.castSucc) ‚Üí Œ≤ (Œ± i.succ)} {init : Œ≤ (Œ± 0)}
    (hŒ± : ‚àÄ i, Œ± i = Œ±' i) :
      dcast (hŒ± (last n)) (dfoldl n (fun i => Œ≤ (Œ± i)) f init) =
        dfoldl n (fun i => Œ≤ (Œ±' i))
          (fun i a => dcast (hŒ± _) (f i (dcast (hŒ± _).symm a))) (dcast (hŒ± 0) init)

theorem simulateQ'_eq_simulateQ [AlternativeMonad m] [LawfulMonad m]
    {so : QueryImpl spec m} (oa : OracleComp spec Œ±) (h : oa.neverFails) :
      simulateQ' so oa h = simulateQ so oa

theorem evalNormalizedWAt_eq_normalizedW (i : Fin r) (x : L) :
  evalNormalizedWAt (Œ≤ := Œ≤) (‚Ñì := ‚Ñì) (R_rate := R_rate) (i := i) x
    = (normalizedW (ùîΩq := ùîΩq) (Œ≤ := Œ≤) (i := i)).eval x

@[simp]
theorem leftpad_apply_ge (n : ‚Ñï) (a : Œ±) (v : Fin m ‚Üí Œ±) (i : Fin n)
    (h : n - m ‚â§ i.val) : leftpad n a v i = v ‚ü®i.val - (n - m), by omega‚ü©

theorem non_zero_divisors_iff (M‚ÇÄ : Type*) [Mul M‚ÇÄ] [Zero M‚ÇÄ] :
    NoZeroDivisors M‚ÇÄ ‚Üî ‚àÄ {a b : M‚ÇÄ}, a * b = 0 ‚Üí a = 0 ‚à® b = 0

omit [NeZero ‚Ñì] [NeZero r] [NeZero ùì°] in
lemma fin_‚Ñì_steps_lt_r {h_‚Ñì_add_R_rate : ‚Ñì + ùì° < r} (i : Fin ‚Ñì) (steps : ‚Ñï)
    (h : i.val + steps ‚â§ ‚Ñì) : i.val + steps < r

theorem SkeletonNodeIndex.parent_of_depth_zero {s : Skeleton}
    (idx : SkeletonNodeIndex s) (h : idx.depth = 0) :
    parent idx = none

lemma neverFails_map_iff' (oa : OracleComp spec Œ±) (f : Œ± ‚Üí Œ≤) :
    neverFails (f <$> oa) ‚Üî neverFails oa

theorem decoder_eq_some {e k : ‚Ñï} [NeZero n] {œâs f : Fin n ‚Üí F} {p : Polynomial F}
  (he : 2 * e < n - k + 1)
  (hn : k ‚â§ n)
  (h_inj : Function.Injective œâs)
  (h_deg : p.natDegree < k)
  (h_dist : Œî‚ÇÄ(f, p.eval ‚àò œâs) ‚â§ e)
  : decoder e k œâs f = some p

lemma coeff_toPoly {p : UniPoly Q} {n : ‚Ñï} : p.toPoly.coeff n = p.coeff n

omit [NoZeroDivisors ùîΩ] in
lemma splitNth_degree_le {n : ‚Ñï} {f : ùîΩ[X]} [inst : NeZero n] :
  ‚àÄ {i}, (splitNth f n i).natDegree ‚â§ f.natDegree / n

theorem sum_Icc_split {Œ± : Type*} [AddCommMonoid Œ±] (f : ‚Ñï ‚Üí Œ±) (a b c : ‚Ñï)
    (h‚ÇÅ : a ‚â§ b) (h‚ÇÇ : b ‚â§ c):
    ‚àë i ‚àà Finset.Icc a c, f i = ‚àë i ‚àà Finset.Icc a b, f i + ‚àë i ‚àà Finset.Icc (b+1) c, f i

@[simp]
theorem fflatten_zero {A : Sort u} {F : A ‚Üí Sort v} {n : Fin 0 ‚Üí ‚Ñï}
    {Œ± : (i : Fin 0) ‚Üí (j : Fin (n i)) ‚Üí A}
    {v : (i : Fin 0) ‚Üí (j : Fin (n i)) ‚Üí F (Œ± i j)} : fflatten v = !h[]

@[simp]
theorem dflatten_splitSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {motive : (k : Fin (vsum n)) ‚Üí Sort*}
    (v : (k : Fin (vsum n)) ‚Üí motive k) (k : Fin (vsum n)) :
    dflatten (motive := motive) (fun i j => v (embedSum i j)) k = v k

lemma list_0 : list 0 = List.Vector.cons (1 : GF(2)) List.Vector.nil

Fin.is_le in Init.Data.Fin.Lemmas

theorem eq_join_via_add_smul_eq_iff_split (k : ‚Ñï) (h_pos : k > 0)
    (x : BTField k) (hi_btf lo_btf : BTField (k - 1)) :
    x = ‚ãò hi_btf, lo_btf ‚ãô ‚Üî
  split (k:=k) (h_k:=h_pos) x = (hi_btf, lo_btf)

@[grind =_]
lemma ne_zero_iff_coeffs_ne_zero (f : F[X][Y]) : f ‚â† 0 ‚Üî f.coeff ‚â† 0

@[simp]
theorem cast_id : Transcript.cast rfl rfl rfl = (id : pSpec‚ÇÅ.Transcript k ‚Üí _)

@[simp]
theorem seqCompose_one {n : Fin 1 ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)} :
    seqCompose pSpec = pSpec 0

@[simp]
theorem FullData.map_leaf {Œ± Œ≤} (f : Œ± ‚Üí Œ≤) (a : Œ±) :
    (FullData.leaf a).map f = FullData.leaf (f a)

theorem stir_rbr_soundness
    [SelectableType F] {s : ‚Ñï}
    {P : Params Œπ F} {œÜ : (i : Fin (M + 1)) ‚Üí (Œπ i ‚Ü™ F)}
    [h_nonempty : ‚àÄ i : Fin (M + 1), Nonempty (Œπ i)]
    {hParams : ParamConditions Œπ P} {Dist : Distances M}
    {Codes : CodeParams Œπ P Dist}
    (h_not_code : ‚àÄ f‚ÇÄ : (Œπ 0) ‚Üí F, f‚ÇÄ ‚àâ (Codes.C 0))
    (hŒ¥‚ÇÄLe : ‚àÄ f‚ÇÄ : (Œπ 0) ‚Üí F, Dist.Œ¥ 0 ‚â§ (Œ¥·µ£(f‚ÇÄ, (Codes.C 0)) : ‚Ñù) ‚àß
      Dist.Œ¥ 0 < (1 - Bstar (rate (code (P.œÜ 0) P.deg))))
    (hŒ¥·µ¢ : ‚àÄ {j : Fin (M + 1)}, j ‚â† 0 ‚Üí
        Dist.Œ¥ j < (1 - rate (code (P.œÜ j) (degree Œπ P j))
          - 1 / Fintype.card (Œπ j) : ‚Ñù) ‚àß
        Dist.Œ¥ j < (1 - Bstar (rate (code (P.œÜ j) (degree Œπ P j)))))
    (Œµ_fold : ‚Ñù‚â•0) (Œµ_out : Fin M ‚Üí ‚Ñù‚â•0) (Œµ_shift : Fin M ‚Üí ‚Ñù‚â•0) (Œµ_fin : ‚Ñù‚â•0) :
    ‚àÉ n : ‚Ñï,
    -- There exists an `n`-message vector IOPP,
    ‚àÉ vPSpec : ProtocolSpec.VectorSpec n,
    -- such that there are `2 * M + 2` challenges from the verifier to the prover,
    Fintype.card (vPSpec.ChallengeIdx) = 2 * M + 2 ‚àß
    -- ‚àÉ vector IOPP œÄ with the aforementioned `vPSpec`, and for
    -- `Statement = Unit, Witness = Unit, OracleStatement(Œπ‚ÇÄ, F)` such that
    ‚àÉ œÄ : VectorIOP Unit (OracleStatement (Œπ 0) F) Unit vPSpec F,
    let Œµ_rbr : vPSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0

@[simp]
private lemma leadingCoeff_E : (E œâs f p e).leadingCoeff = 1

lemma W_is_additive
  (i : Fin r) :
  IsLinearMap (R := ùîΩq) (M := L) (M‚ÇÇ := L) (f := fun x ‚Ü¶ (W ùîΩq Œ≤ i).eval x)

theorem coeff_eq_getElem_of_lt [LawfulBEq R] {p : UniPoly R} {i} (hi : i < p.size) :
  p.trim.coeff i = p[i]

omit [Finite F] in
lemma mul_root_of_unity {x : FÀ£} :
  ‚àÄ {a b : FÀ£} {i j : ‚Ñï},
    i ‚â§ j ‚Üí a ‚àà evalDomain D x i ‚Üí b ‚àà Domain.evalDomain D j ‚Üí
      a * b ‚àà evalDomain D x i

theorem vcons_eq_const (a : Œ±) : a ::·µõ (fun _ : Fin n => a) = fun _ => a

lemma eq_zero_or_eq_one_of_lt_two {n : ‚Ñï} (h_lt : n < 2) : n = 0 ‚à® n = 1

theorem canonical_empty : (UniPoly.mk (R:=R) #[]).trim = #[]

@[simp]
theorem append_left_cancel_iff {pSpec : ProtocolSpec n} {p1 p2 : ProtocolSpec m} :
    p1 ++‚Çö pSpec = p2 ++‚Çö pSpec ‚Üî p1 = p2

lemma Z_square_eq (k : ‚Ñï) (prevBTFieldProps : ConcreteBTFieldProps (k := k))
    (curBTFieldProps : ConcreteBTFieldProps (k := (k + 1))) :
  letI : Field (ConcreteBTField (k + 1)) := mkFieldInstance curBTFieldProps
  (Z (k + 1)) ^ 2 = „Ää Z (k), 1 „Äã

lemma getHighBits_no_shl_joinBits {n m : ‚Ñï} (low : Fin (2 ^ n)) (high : Fin (2 ^ m)) :
  getHighBits_no_shl n (joinBits low high).val = high.val

theorem rightpad_getElem_eq_getD {a b : List Œ±} {unit : Œ±} {i : Nat}
  (h : i < (a.rightpad b.length unit).length) :
    (a.rightpad b.length unit)[i] = a.getD i unit

omit hF‚ÇÇ in
theorem W_linear_comp_decomposition (i : Fin r) (h_i_add_1 : i + 1 < r) :
    ‚àÄ p: L[X], (W ùîΩq Œ≤ (i + 1)).comp p =
      ((W ùîΩq Œ≤ i).comp p) ^ Fintype.card ùîΩq -
        C (eval (Œ≤ i) (W ùîΩq Œ≤ i)) ^ (Fintype.card ùîΩq - 1) * ((W ùîΩq Œ≤ i).comp p)

lemma sDomain_card (i : Fin r) (h_i : i < ‚Ñì + R_rate) :
    Fintype.card (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i) = (Fintype.card ùîΩq)^(‚Ñì + R_rate - i)

theorem GF_2_value_eq_zero_or_one (x : GF(2)) : x = 0 ‚à® x = 1

protected lemma a_lemma_im_not_proud_of_OLD {v a : Fin n ‚Üí F}
  (h_card : 2 ‚â§ Fintype.card F)
  :
  |(1 : ‚Ñö) - ((1 : ‚Ñö) + (1 : ‚Ñö) / ((Fintype.card F : ‚Ñö) - 1)) * ‚ÜëŒî‚ÇÄ(v, a) / ‚Üën

lemma rtake_eq_rtake : transcript‚ü¶m:‚üß = transcript.drop m h

private lemma johnson_condition_strong_implies_2_le_B_card
  (h_johnson : JohnsonConditionStrong B v)
  :
  2 ‚â§ B.card

omit [NeZero ‚Ñì] [NeZero r] [NeZero ùì°] in
lemma ‚Ñì_lt_r {h_‚Ñì_add_R_rate : ‚Ñì + ùì° < r}
    : ‚Ñì < r

lemma Fin.lt_iff_le_pred (a b : Fin r) (h_b : b > 0) : a < b ‚Üî a ‚â§ b - 1

Nat.sub_mul in Init.Data.Nat.Basic

@[simp]
lemma concrete_natCast_zero_eq_zero {k : ‚Ñï} : natCast 0 = (0 : ConcreteBTField k)

lemma degree_X‚±º (‚Ñì : ‚Ñï) (h_‚Ñì : ‚Ñì ‚â§ r) (j : Fin (2 ^ ‚Ñì)) :
  (X‚±º ùîΩq Œ≤ ‚Ñì h_‚Ñì j).degree = j

theorem prime_43 : Nat.Prime 43

theorem commit_eq {a : ZMod p} (hpG1 : Nat.card G‚ÇÅ = p)
    (poly : degreeLT (ZMod p) (n + 1)) :
    commit (towerOfExponents g‚ÇÅ a n) (degreeLTEquiv _ _ poly) = g‚ÇÅ ^ (poly.1.eval a).val

theorem MLE_mem_restrictDegree (evals : (œÉ ‚Üí Fin 2) ‚Üí R) : (MLE evals) ‚àà R‚¶É‚â§ 1‚¶Ñ[X œÉ]

lemma wt_eq_zero_iff [Zero F] {v : Œπ ‚Üí F} :
  wt v = 0 ‚Üî Fintype.card Œπ = 0 ‚à® ‚àÄ i, v i = 0

@[simp]
theorem erase_odd_mem
  {s : Finset ‚Ñï}
  {n : ‚Ñï}
  : n ‚àà (erase_odd s) ‚Üî Even n ‚àß n ‚àà s

theorem funext‚ÇÇ_heq_iff {Œ± Œ±' : Sort u} {Œ≤ : Œ± ‚Üí Sort v} {Œ≤' : Œ±' ‚Üí Sort v}
    {Œ≥ : (a : Œ±) ‚Üí Œ≤ a ‚Üí Sort w} {Œ≥' : (a : Œ±') ‚Üí Œ≤' a ‚Üí Sort w}
    {f : (a : Œ±) ‚Üí (b : Œ≤ a) ‚Üí Œ≥ a b} {g : (a : Œ±') ‚Üí (b : Œ≤' a) ‚Üí Œ≥' a b}
    (ha : Œ± = Œ±') (hb : ‚àÄ a, Œ≤ a = Œ≤' (cast ha a))
    (hc : ‚àÄ a b, Œ≥ a b = Œ≥' (cast ha a) (cast (hb a) b)) :
      HEq f g ‚Üî ‚àÄ a b, HEq (f a b) (g (cast ha a) (cast (hb a) b))

@[simp]
theorem Iio_zero : Iio (0 : Fin (n + 1)) = ‚àÖ

theorem findIdxRev?_eq_some {cond} {as : Array Œ±} (h : ‚àÉ i, ‚àÉ hi : i < as.size, cond as[i]) :
  ‚àÉ k : Fin as.size, findIdxRev? cond as = some k

theorem OracleVerifier.liftContext_toVerifier_comm
    {lens : OracleStatement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                              OuterOStmtIn OuterOStmtOut InnerOStmtIn InnerOStmtOut}
    {V : OracleVerifier oSpec InnerStmtIn InnerOStmtIn InnerStmtOut InnerOStmtOut pSpec} :
      (V.liftContext lens).toVerifier = V.toVerifier.liftContext lens

lemma toPoly_trim [LawfulBEq R] {p : UniPoly R} : p.trim.toPoly = p.toPoly

@[simp]
theorem add_accepts_iff : (add a b c).accepts x ‚Üî x c = x a + x b

private lemma johnson_condition_strong_implies_2_le_F_card
  (h_johnson : JohnsonConditionStrong B v)
  :
  2 ‚â§ Fintype.card F

theorem support_finSuccEquivNth (f : MvPolynomial (Fin (n + 1)) R) :
    (finSuccEquivNth R p f).support = Finset.image (fun m : Fin (n + 1) ‚Üí‚ÇÄ ‚Ñï => m p) f.support

@[grind =]
theorem monomialXY_eq_monomialXY_iff {n m p q : ‚Ñï} {a b : F} :
  monomialXY n m a = monomialXY p q b ‚Üî n = p ‚àß m = q ‚àß a = b ‚à® a = 0 ‚àß b = 0

@[simp]
theorem ConcreteBTFieldAlgebra_id {l r : ‚Ñï} (h_eq : l = r) :
    @ConcreteBTFieldAlgebra l r (h_le:=by omega) =
    (h_eq ‚ñ∏ (Algebra.id (ConcreteBTField l)) :
      Algebra (ConcreteBTField l) (ConcreteBTField r))

@[simp]
theorem leftpad_apply_lt (n : ‚Ñï) (a : Œ±) (v : Fin m ‚Üí Œ±) (i : Fin n)
    (h : i.val < n - m) : leftpad n a v i = a

@[simp]
theorem seqCompose_embedSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    {T : ‚àÄ i, FullTranscript (pSpec i)} (i : Fin m) (j : Fin (n i)) :
    seqCompose T (Fin.embedSum i j) = cast (by simp) (T i j)

lemma getBit_of_highBits {n: ‚Ñï} (numLowBits : ‚Ñï) : ‚àÄ k, getBit k (getHighBits numLowBits n) =
    if k < numLowBits then 0 else getBit (k) (n)

theorem cast_eq_dcast {h : n‚ÇÅ = n‚ÇÇ} {pSpec : ProtocolSpec n‚ÇÅ} :
    pSpec.cast h = dcast h pSpec

lemma exists_factors_with_large_common_root_set
  (Œ¥ : ‚Ñö) (x‚ÇÄ : F)
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  :
  ‚àÉ R H, R ‚àà (irreducible_factorization_of_gs_solution h_gs).choose_spec.choose ‚àß
    Irreducible H ‚àß H ‚à£ (Bivariate.evalX (Polynomial.C x‚ÇÄ) R) ‚àß
    #(@Set.toFinset _ { z : coeffs_of_close_proximity (F := F) k œâs Œ¥ u‚ÇÄ u‚ÇÅ |
        letI Pz := Pz z.2
        (Trivariate.eval_on_Z R z.1).eval Pz = 0 ‚àß
        (Bivariate.evalX z.1 H).eval (Pz.eval x‚ÇÄ) = 0} sorry)
    ‚â• #(coeffs_of_close_proximity k œâs Œ¥ u‚ÇÄ u‚ÇÅ) / (Bivariate.natDegreeY Q)
    ‚àß #(coeffs_of_close_proximity k œâs Œ¥ u‚ÇÄ u‚ÇÅ) / (Bivariate.natDegreeY Q) >
      2 * D_Y Q ^ 2 * (D_X ((k + 1 : ‚Ñö) / n) n m) * D_YZ Q

lemma towerRingHomForwardMap0_eq :
  towerRingEquivFromConcrete0.toFun = towerRingHomForwardMap 0

@[simp]
theorem bit_revFinProdFinEquiv_symm_2_pow_succ {n : ‚Ñï} (j : Fin (2 ^ (n + 1))) (i : Fin (n + 1)):
  let e : Fin (2 ^ n * 2) ‚âÉ Fin (2 ^ n) √ó Fin 2 :=revFinProdFinEquiv (m:=2^(n)) (n:=2)
    (h_m:=by exact Nat.two_pow_pos n).symm
  let msb : Fin 2 := (e j).2
  let lsbs : Fin (2 ^ n) := (e j).1
  Nat.getBit (i) j = if i.val < n then Nat.getBit (i.val) lsbs else msb

@[simp]
theorem dconcat_last {motive : Fin (n + 1) ‚Üí Sort u} (v : (i : Fin n) ‚Üí motive (castSucc i))
    (a : motive (last n)) : (v :+·µà‚ü®motive‚ü© a) (last n) = a

lemma runWithOracle_buildMerkleTree {s} (leaf_data_tree : LeafData Œ± s) (f) :
    (runWithOracle f (buildMerkleTree leaf_data_tree))
    = buildMerkleTree_with_hash leaf_data_tree fun (left right : Œ±) =>
      (f () ‚ü®left, right‚ü©)

@[to_additive (attr := simp) vsum_succ]
lemma vprod_succ [CommMonoid Œ±] {a : Fin (n + 1) ‚Üí Œ±} : vprod a = a 0 * vprod (a ‚àò Fin.succ)

lemma mca_rsc
  [DecidableEq Œπ]
  (Œ± : F) (œÜ : Œπ ‚Ü™ F) (m : ‚Ñï) [Smooth œÜ]
  (par‚Ñì_type : Type) [Fintype par‚Ñì_type] (exp : par‚Ñì_type ‚Ü™ ‚Ñï) :
  let Gen := RSGenerator.genRSC par‚Ñì_type œÜ m exp
  let : Fintype Gen.par‚Ñì := Gen.h‚Ñì
  hasMutualCorrAgreement
    -- Generator
    Gen
    -- BStar
    ((1 + Gen.rate) / 2)
    -- errStar
    (fun Œ¥ => ENNReal.ofReal
        ((Fintype.card par‚Ñì_type - 1) * (2^m / (Gen.rate * (Fintype.card F)))))

theorem nsmul_zero [LawfulBEq R] (p : UniPoly R) : nsmul 0 p = 0

lemma testBit_true_eq_getBit_eq_1 (k n : Nat) : n.testBit k = ((Nat.getBit k n) = 1)

private lemma really_glorious_lemma {f f' : Polynomial F} (h : 2 * f = 2 * f') :
    f = f'

lemma bIdx_succ_mul_œë_lt_‚Ñì_succ (bIdx : Fin (‚Ñì / œë - 1)) :
    (‚ÜëbIdx + 1) * œë < ‚Ñì + 1

omit [Finite F] in
lemma neg_mem_dom_of_mem_dom : ‚àÄ {a : FÀ£} (i : Fin n),
    a ‚àà evalDomain D x i ‚Üí - a ‚àà evalDomain D x i

lemma eval‚ÇÇ_induction_on : True

@[simp]
theorem runWithOracle_failure (f : spec.FunctionType) :
    runWithOracle f (failure : OracleComp spec Œ±) = none

lemma degreesY_nonempty {f : F[X][Y]} (hf : f ‚â† 0) : (f.toFinsupp.support).Nonempty

@[simp]
theorem embedSum_splitSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (k : Fin (vsum n)) :
    embedSum (splitSum k).1 (splitSum k).2 = k

lemma AlgebraTowerEquiv.commutesRight' (e : AlgebraTowerEquiv A B)
    {i j : Œπ} (h : i ‚â§ j) (r : B i) :
  AlgebraTower.algebraMap (AT:=A) (i:=i) (j:=j) (h:=h) ((e.toRingEquiv i).symm r) =
  (e.toRingEquiv j).symm (AlgebraTower.algebraMap (AT:=B) (i:=i) (j:=j) (h:=h) r)

@[simp]
lemma dfoldlM'_succ {n : ‚Ñï} {Œ± : Fin (n + 2) ‚Üí Type u}
    (f : (i : Fin (n + 1)) ‚Üí Œ± i.castSucc ‚Üí m (Œ± i.succ)) (x : Œ± 0) :
    dfoldlM' (n + 1) Œ± f x = (do
      let y ‚Üê dfoldlM' n (Œ± ‚àò castSucc) (fun i => f i.castSucc) x
      f (last n) y)

lemma rank_eq_colRank : U.rank = colRank U

@[simp]
theorem cast_id : FullTranscript.cast rfl rfl = (id : pSpec‚ÇÅ.FullTranscript ‚Üí _)

@[simp]
theorem card_univ_filter_eq {e : Œ±} :
  #{x : Œ± | x ‚â† e} = #(Finset.univ (Œ± := Œ±)) - 1

@[simp]
theorem vcons_one (a : Œ±) (v : Fin (n + 1) ‚Üí Œ±) : (a ::·µõ v) 1 = v 0

@[simp]
private lemma E_ne_zero : (E œâs f p e) ‚â† 0

Nat.le_add_left in Init.Data.Nat.Basic

@[simp]
private lemma K_le_card {Œ± : F} : K B i Œ± ‚â§ B.card

lemma rank_nonsquare_eq_deg_of_deg_le (inj : Function.Injective Œ±) (h : n ‚â§ m) :
  (Vandermonde.nonsquare (Œπ' := n) Œ±).rank = n

lemma rowRank_eq_colRank : rowRank U = colRank U

theorem hconcat_right_injective {Œ± : Fin n ‚Üí Sort u} {Œ≤ : Sort u} (v : (i : Fin n) ‚Üí Œ± i) :
    Function.Injective (hconcat v : Œ≤ ‚Üí (i : Fin (n + 1)) ‚Üí vconcat Œ± Œ≤ i)

@[grind _=_]
lemma degreeY_as_weighted_deg (hf : f ‚â† 0) :
  natDegreeY f = natWeightedDegree f 0 1

omit h_Œ≤‚ÇÄ_eq_1 in
theorem sDomainFin_bijective (i : Fin r) (h_i : i < ‚Ñì + R_rate)
: Function.Bijective
  (sDomainFinEquiv ùîΩq Œ≤ h_‚Ñì_add_R_rate i h_i)

theorem add_zero {n : ‚Ñï} (a : CNat (n + 1)) : a + 0 = a

lemma degree_normalizedW (i : Fin r) :
  (normalizedW ùîΩq Œ≤ i).degree = (Fintype.card ùîΩq)^(i.val)

@[simp] theorem equiv_refl (p : UniPoly Q) : equiv p p

theorem vcons_eq_cons (a : Œ±) (v : Fin n ‚Üí Œ±) : a ::·µõ v = cons a v

private lemma Bi_biUnion_F2i :
  Bi B i = Finset.univ.biUnion (F2i B i)

theorem liftContext_rbr_knowledgeSoundness [Inhabited InnerStmtOut] [Inhabited InnerWitIn]
    {outerRelIn : Set (OuterStmtIn √ó OuterWitIn)} {outerRelOut : Set (OuterStmtOut √ó OuterWitOut)}
    {innerRelIn : Set (InnerStmtIn √ó InnerWitIn)} {innerRelOut : Set (InnerStmtOut √ó InnerWitOut)}
    {rbrKnowledgeError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    {stmtLens : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut}
    {witLens : Witness.InvLens OuterStmtIn OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    (V : Verifier oSpec InnerStmtIn InnerStmtOut pSpec)
    [lensKS : Extractor.Lens.IsKnowledgeSound outerRelIn innerRelIn outerRelOut innerRelOut
      (V.compatStatement stmtLens) (fun _ _ => True) ‚ü®stmtLens, witLens‚ü©]
    (h : V.rbrKnowledgeSoundness init impl innerRelIn innerRelOut rbrKnowledgeError) :
      (V.liftContext stmtLens).rbrKnowledgeSoundness init impl outerRelIn outerRelOut
        rbrKnowledgeError

@[simp]
theorem divide_by_2_mem {s : Finset ‚Ñï} {d : ‚Ñï} :
  d ‚àà divide_by_2 s ‚Üî 2 * d ‚àà s

Fin.coe_castSucc in Init.Data.Fin.Lemmas

theorem finSigmaFinEquiv'_pair {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (i : Fin m) (k : Fin (n i)) :
    (finSigmaFinEquiv' ‚ü®i, k‚ü© : ‚Ñï) = ‚àë j, n (Fin.castLE i.isLt.le j) + k

theorem cast_idx {i : MessageIdx pSpec‚ÇÅ} :
    pSpec‚ÇÇ.Message (i.cast hn hSpec) = pSpec‚ÇÅ.Message i

theorem succ'_ne_zero (n : Nat) : succ' n ‚â† 0

@[simp]
theorem vflatten_one {n : Fin 1 ‚Üí ‚Ñï} {v : (i : Fin 1) ‚Üí Fin (n i) ‚Üí Œ±} :
    vflatten v = v 0

theorem rightpad_eq_self (v : Fin n ‚Üí Œ±) (a : Œ±) : rightpad n a v = v

@[simp]
theorem fappend_zero {Œ≤ : Fin m ‚Üí A} {Œ± : Fin 0 ‚Üí A}
    (u : (i : Fin m) ‚Üí F (Œ≤ i)) :
    fappend u (!h‚¶ÉF‚¶Ñ‚ü®Œ±‚ü©[] : (i : Fin 0) ‚Üí F (Œ± i)) = u

private lemma x_times_oddPart'_eq_x_times_oddPart' {f : Polynomial F} :
    Polynomial.X * (oddPart' f) = x_times_oddPart' f

theorem liftContext_runWithLog
    {lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    {outerStmtIn : OuterStmtIn} {outerWitIn : OuterWitIn}
    {P : Prover oSpec InnerStmtIn InnerWitIn InnerStmtOut InnerWitOut pSpec} :
      (P.liftContext lens).runWithLog outerStmtIn outerWitIn
      = do
        let ‚ü®‚ü®fullTranscript, innerCtxOut‚ü©, queryLog‚ü© ‚Üê
          P.runWithLog.uncurry (lens.proj (outerStmtIn, outerWitIn))
        return ‚ü®‚ü®fullTranscript, lens.lift (outerStmtIn, outerWitIn) innerCtxOut‚ü©, queryLog‚ü©

theorem binaryTowerAlgebra_apply_assoc (l mid r : ‚Ñï) (h_l_le_mid : l ‚â§ mid) (h_mid_le_r : mid ‚â§ r) :
    ‚àÄ x : BTField l,
    (@binaryAlgebraTower (l:=l) (r:=r) (h_le:=by
      exact Nat.le_trans h_l_le_mid h_mid_le_r)).algebraMap x =
    (@binaryAlgebraTower (l:=mid) (r:=r) (h_le:=h_mid_le_r)).algebraMap
      ((@binaryAlgebraTower (l:=l) (r:=mid) (h_le:=h_l_le_mid)).algebraMap x)

@[simp]
theorem hflatten_splitSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {Œ± : (k : Fin (vsum n)) ‚Üí Sort*}
    (v : (k : Fin (vsum n)) ‚Üí Œ± k) (k : Fin (vsum n)) :
    hflatten (fun i j => v (embedSum i j)) k = cast (vflatten_splitSum Œ± k).symm (v k)

@[simp] theorem fromNat_toNat_eq_self {k : ‚Ñï} (bv : BitVec (2 ^ k)) :
  (fromNat (BitVec.toNat bv) : ConcreteBTField k) = bv

theorem dconcat_inj {motive : Fin (n + 1) ‚Üí Sort u} (v w : (i : Fin n) ‚Üí motive (castSucc i))
    (a b : motive (last n)) :
    (v :+·µà‚ü®motive‚ü© a) = (w :+·µà‚ü®motive‚ü© b) ‚Üî v = w ‚àß a = b

theorem johnson_bound_alphabet_free [Field F] [DecidableEq F]
  {B : Finset (Fin n ‚Üí F)}
  {v : Fin n ‚Üí F}
  {e : ‚Ñï}
  :
  let d := sInf { d | ‚àÉ u ‚àà B, ‚àÉ v ‚àà B, u ‚â† v ‚àß hammingDist u v = d }
  let q : ‚Ñö := Fintype.card F
  let frac := q / (q - 1)
  e ‚â§ n - ((n * (n - d)) : ‚Ñù).sqrt
  ‚Üí
  (B ‚à© ({ x | Œî‚ÇÄ(x, v) ‚â§ e } : Finset _)).card ‚â§ q * d * n

lemma getBit_of_highBits_no_shl {n: ‚Ñï} (numLowBits : ‚Ñï) :
    ‚àÄ k, getBit k (getHighBits_no_shl numLowBits n)
  = getBit (k + numLowBits) (n)

lemma dist_UB [CommRing F] {LC : LinearCode Œπ F} :
    Code.minDist (LC : Set (Œπ ‚Üí F)) ‚â§ length LC

theorem dcast_eq_dcast_iff (h : a = a'') (h' : a' = a'') :
    dcast h b = dcast h' b' ‚Üî b = dcast (h'.trans h.symm) b'

theorem finSuccEquivNth_comp_C_eq_C :
    (‚Üë(finSuccEquivNth R p).symm : Polynomial (MvPolynomial (Fin n) R) ‚Üí+* _).comp
        (Polynomial.C.comp C) = (C : R ‚Üí+* MvPolynomial (Fin n.succ) R)

theorem coeff_eq_coeff [LawfulBEq R] (p : UniPoly R) (i : ‚Ñï) :
  p.trim.coeff i = p.coeff i

theorem mulVecLin_coeff_vandermondens_eq_eval_matrixOfPolynomials
  {n : ‚Ñï} [NeZero n] {v : Œπ ‚Ü™ F} {p : F[X]} (h_deg : p.natDegree < n) :
  (Vandermonde.nonsquare (Œπ' := n) v).mulVecLin (Fin.liftF' p.coeff) =
  fun i => p.eval (v i)

lemma is_berlekamp_welch_solution_ext
  (h : ‚àÄ i, (Matrix.mulVec (BerlekampWelchMatrix e k œâs f) v) i = -(f i) * (œâs i) ^ e)
  : IsBerlekampWelchSolution e k œâs f v

theorem neg_add_cancel [LawfulBEq R] (p : UniPoly R) : -p + p = 0

@[csimp]
theorem vappend_eq_append : @vappend = @append

lemma domain_injective {i : ‚Ñï} : i ‚â§ n ‚Üí Function.Injective (domain D x n i)

theorem concrete_mul_eq
  (prevBTFieldProps : ConcreteBTFieldProps (k := k - 1))
  (a b : ConcreteBTField k) {a‚ÇÅ a‚ÇÄ b‚ÇÅ b‚ÇÄ : ConcreteBTField (k - 1)}
  (h_a : (a‚ÇÅ, a‚ÇÄ) = split h_k a) (h_b : (b‚ÇÅ, b‚ÇÄ) = split h_k b) :
  concrete_mul a b =
    „Ää concrete_mul a‚ÇÄ b‚ÇÅ + concrete_mul b‚ÇÄ a‚ÇÅ + concrete_mul (concrete_mul a‚ÇÅ b‚ÇÅ) (Z (k - 1)),
      concrete_mul a‚ÇÄ b‚ÇÄ + concrete_mul a‚ÇÅ b‚ÇÅ „Äã

@[simp]
theorem vempty_vappend (v : Fin n ‚Üí Œ±) : vappend !v[] v = v ‚àò Fin.cast (Nat.zero_add n)

lemma powerBasisSucc_gen (k : ‚Ñï) :
  (powerBasisSucc k).gen = (Z (k+1))

@[simp]
theorem rdrop_eq_take (m : ‚Ñï) (h : m ‚â§ n) (v : (i : Fin n) ‚Üí Œ± i) :
    rdrop m h v = take (n - m) (by omega) v

@[simp]
lemma liftF'_liftF_succ {f : Fin (n + 1) ‚Üí Œ±} {x : Fin n} :
  liftF' (liftF (n := n + 1) f) x = f x.castSucc

theorem append_comp {a : Fin m ‚Üí Œ±} {b : Fin n ‚Üí Œ±} (f : Œ± ‚Üí Œ≤) :
    append (f ‚àò a) (f ‚àò b) = f ‚àò append a b

@[simp]
theorem binaryTowerAlgebra_id {l r : ‚Ñï} (h_eq : l = r) :
    @binaryAlgebraTower l r (h_le:=by omega) =
    (h_eq ‚ñ∏ (Algebra.id (BTField l)) : Algebra (BTField l) (BTField r))

omit [NeZero r] [Field L] [Fintype L] [DecidableEq L] [Field ùîΩq] [Algebra ùîΩq L] in
lemma sBasis_range_eq (i : Fin r) (h_i : i < ‚Ñì + R_rate) :
    Œ≤ '' Set.Ico i ‚ü®‚Ñì + R_rate, h_‚Ñì_add_R_rate‚ü©
    = Set.range (sBasis Œ≤ h_‚Ñì_add_R_rate i h_i)

theorem get_rtake_ofFn_eq_rtake_comp_cast {Œ± : Type*} {m : ‚Ñï} (v : Fin n ‚Üí Œ±) (h : m ‚â§ n) :
    ((List.ofFn v).rtake m).get =
      rtake m h v ‚àò Fin.cast (by simp [List.rtake]; omega)

congrArg in Init.Prelude

lemma out_of_dom_smpl_2
  {Œ¥ l : ‚Ñù‚â•0} {s : ‚Ñï} {f : Œπ ‚Üí F} {degree : ‚Ñï} {œÜ : Œπ ‚Ü™ F}
  (C : Set (Œπ ‚Üí F)) (hC : C = code œÜ degree)
  (h_decodable : listDecodable C Œ¥ l)
  (h_nonempty : Nonempty (domainComplement œÜ)) :
  listDecodingCollisionProbability œÜ f Œ¥ s degree h_nonempty ‚â§
    ((l^2 / 2)) * (degree / (Fintype.card F - Fintype.card Œπ))^s

@[simp]
theorem verifier_last_of_two (pSpec : ProtocolSpec 2) [VerifierLast pSpec] :
    pSpec.dir 1 = .V_to_P

lemma towerRingHomForwardMap_add_eq (k : ‚Ñï) (x y : ConcreteBTField k) :
    towerRingHomForwardMap (k:=k) (x + y)
    = towerRingHomForwardMap (k:=k) x + towerRingHomForwardMap (k:=k) y

theorem induction_heq {n n' : ‚Ñï} {motive : Fin (n + 1) ‚Üí Sort u} {motive' : Fin (n' + 1) ‚Üí Sort u}
    {zero : motive 0} {zero' : motive' 0}
    {succ : ‚àÄ i : Fin n, motive i.castSucc ‚Üí motive i.succ}
    {succ' : ‚àÄ i : Fin n', motive' i.castSucc ‚Üí motive' i.succ}
    {i : Fin (n + 1)} {i' : Fin (n' + 1)}
    (hn : n = n') (hmotive : HEq motive motive') (hzero : HEq zero zero')
    (hsucc : HEq succ succ') (hi : HEq i i') :
      HEq (induction (motive := motive) zero succ i)
        (induction (motive := motive') zero' succ' i')

@[simp]
theorem LeafData.map_leaf {Œ± Œ≤} (f : Œ± ‚Üí Œ≤) (a : Œ±) :
    (LeafData.leaf a).map f = LeafData.leaf (f a)

@[simp]
theorem OracleReduction.runWithLog_eq_runWithLog_reduction [‚àÄ i, OracleInterface (pSpec.Message i)]
    {stmt : StmtIn} {oStmt : ‚àÄ i, OStmtIn i} {wit : WitIn}
    {oracleReduction : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec} :
      oracleReduction.run stmt oStmt wit =
        oracleReduction.toReduction.run ‚ü®stmt, oStmt‚ü© wit

lemma neg_descends (a b : UniPoly R) : equiv a b ‚Üí neg_descending a = neg_descending b

theorem evenRefinement_eq_novel_poly_of_0_leading_suffix (i : Fin ‚Ñì) (v : Fin (2 ^ i.val))
    (original_coeffs : Fin (2 ^ ‚Ñì) ‚Üí L) :
    have h_v: v.val < 2 ^ (i.val + 1) := by
      calc v.val < 2 ^ i.val := by omega
        _ < 2 ^ (i.val + 1) := by apply Nat.pow_lt_pow_right (by omega) (by omega)
    evenRefinement ùîΩq Œ≤ h_‚Ñì_add_R_rate i (coeffsBySuffix (r:=r)
      (R_rate:=R_rate) (a:=original_coeffs) ‚ü®i, by omega‚ü© v) =
    intermediateEvaluationPoly ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i + 1, by omega‚ü©
      (coeffsBySuffix (r:=r) (R_rate:=R_rate) original_coeffs ‚ü®i + 1, by omega‚ü© ‚ü®v, h_v‚ü©)

omit [Finite F] in
private lemma witness_lift {F : Type} [NonBinaryField F]
  {k : ‚Ñï} {s : Fin (k + 1) ‚Üí ‚Ñï+} {d : ‚Ñï+} {p : F[X]} {Œ± : F} {i : Fin (k + 1)} :
    p ‚àà Witness F s d i.castSucc ‚Üí
      p.foldNth (2 ^ (s i).1) Œ± ‚àà Witness F s d i.succ

theorem intermediateNormVpoly_comp_qmap (i : Fin (‚Ñì))
    (k : Fin (‚Ñì - i - 1)) : -- corresponds to intermediateNormVpoly_comp

@[simp]
lemma toPolynomialAlgHom_X : toPolynomialAlgHom (X : P) = Polynomial.X

lemma addSalt_Message (i : pSpec.MessageIdx) :
    (pSpec.addSalt Salt).Message i = (pSpec.Message i √ó Salt i)

@[simp] theorem add_zero {a : AssocNat} : a + 0 = a

private lemma k_and_e' [Zero F]
  (h_n : n ‚â† 0)
  (h_B : B.card ‚â† 0)
  :
  k B / B.card = (n - e B 0) / n

@[simp]
theorem cast_perfectCompleteness (hComplete : R.perfectCompleteness init impl relIn relOut) :
    (R.cast hn hSpec).perfectCompleteness init impl relIn relOut

@[simp]
lemma possibleRelHammingDists_subset_relHammingDistRange :
  possibleRelHammingDists C ‚äÜ relHammingDistRange Œπ

theorem liftContext_knowledgeSoundness [Inhabited InnerStmtOut] [Inhabited InnerWitIn]
    {outerRelIn : Set (OuterStmtIn √ó OuterWitIn)} {outerRelOut : Set (OuterStmtOut √ó OuterWitOut)}
    {innerRelIn : Set (InnerStmtIn √ó InnerWitIn)} {innerRelOut : Set (InnerStmtOut √ó InnerWitOut)}
    {knowledgeError : ‚Ñù‚â•0}
    {stmtLens : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut}
    {witLens : Witness.InvLens OuterStmtIn OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    (V : Verifier oSpec InnerStmtIn InnerStmtOut pSpec)
    [lensKS : Extractor.Lens.IsKnowledgeSound outerRelIn innerRelIn outerRelOut innerRelOut
      (V.compatStatement stmtLens) (fun _ _ => True) ‚ü®stmtLens, witLens‚ü©]
    (h : V.knowledgeSoundness init impl innerRelIn innerRelOut knowledgeError) :
      (V.liftContext stmtLens).knowledgeSoundness init impl outerRelIn outerRelOut
        knowledgeError

@[simp]
lemma erase_odd_empty :
    erase_odd ‚àÖ = ‚àÖ

theorem append_soundness {lang‚ÇÅ : Set Stmt‚ÇÅ} {lang‚ÇÇ : Set Stmt‚ÇÇ} {lang‚ÇÉ : Set Stmt‚ÇÉ}
    (V‚ÇÅ : Verifier oSpec Stmt‚ÇÅ Stmt‚ÇÇ pSpec‚ÇÅ) (V‚ÇÇ : Verifier oSpec Stmt‚ÇÇ Stmt‚ÇÉ pSpec‚ÇÇ)
    {soundnessError‚ÇÅ soundnessError‚ÇÇ : ‚Ñù‚â•0}
    (h‚ÇÅ : V‚ÇÅ.soundness init impl lang‚ÇÅ lang‚ÇÇ soundnessError‚ÇÅ)
    (h‚ÇÇ : V‚ÇÇ.soundness init impl lang‚ÇÇ lang‚ÇÉ soundnessError‚ÇÇ) :
      (V‚ÇÅ.append V‚ÇÇ).soundness init impl lang‚ÇÅ lang‚ÇÉ (soundnessError‚ÇÅ + soundnessError‚ÇÇ)

theorem not_exists_of_decoder_eq_none {e k : ‚Ñï} [NeZero n] {œâs f : Fin n ‚Üí F}
  (he : 2 * e < n - k + 1)
  (hn : k ‚â§ n)
  (h_inj : Function.Injective œâs)
  (h_none : decoder e k œâs f = none)
  : ¬¨‚àÉp : F[X], Œî‚ÇÄ(f, p.eval ‚àò œâs) ‚â§ e ‚àß p.natDegree < k

@[simp]
theorem happend_succ {Œ± : Fin m ‚Üí Sort u} {Œ≤ : Fin (n + 1) ‚Üí Sort u}
    (u : (i : Fin m) ‚Üí Œ± i) (v : (i : Fin (n + 1)) ‚Üí Œ≤ i) :
    happend u v = hconcat (happend u (fun i => v (castSucc i))) (v (last n))

theorem iterated_fold_eq_matrix_form (i : Fin ‚Ñì) (steps : ‚Ñï) (h_i_add_steps : i + steps ‚â§ ‚Ñì)
    (f : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®i, by omega‚ü© ‚Üí L)
    (r_challenges : Fin steps ‚Üí L)
    (y : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®‚Üëi + steps, by omega‚ü©) :
    (iterated_fold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (steps := ‚ü®steps, by apply Nat.lt_succ_of_le; exact Nat.le_of_add_left_le h_i_add_steps‚ü©)
      (i := ‚ü®i, by omega‚ü©)
      (h_i_add_steps := by simp only; exact fin_‚Ñì_steps_lt_‚Ñì_add_R i steps h_i_add_steps) f
      r_challenges ‚ü®y, by exact Submodule.coe_mem y‚ü©) =
    localized_fold_eval ùîΩq Œ≤ i (steps := steps) (h_i_add_steps := h_i_add_steps) f
      r_challenges (y := ‚ü®y, by exact Submodule.coe_mem y‚ü©)

@[simp]
lemma eval_solutionToE {x : F} :
  eval x (solutionToE e k v) = x ^ e + ‚àë y : Fin e, v ‚ü®y, by omega‚ü© * x ^ y.1

theorem completeness [SelectableType Œ±] {n : ‚Ñï}
    (leaves : List.Vector Œ± (2 ^ n)) (i : Fin (2 ^ n)) (hash : Œ± √ó Œ± -> Œ±)
    (preexisting_cache : (spec Œ±).QueryCache) :
    (((do
      let cache ‚Üê buildMerkleTree Œ± n leaves
      let proof := generateProof Œ± i cache
      let verif ‚Üê verifyProof Œ± i leaves[i] (getRoot Œ± cache) proof).simulateQ
      (randomOracle)).run preexisting_cache).neverFails

theorem dfoldl_congr {n : ‚Ñï}
    {Œ± Œ±' : Fin (n + 1) ‚Üí Type u}
    {f : (i : Fin n) ‚Üí Œ± i.castSucc ‚Üí Œ± i.succ}
    {f' : (i : Fin n) ‚Üí Œ±' i.castSucc ‚Üí Œ±' i.succ}
    {init : Œ± 0} {init' : Œ±' 0}
    (hŒ± : ‚àÄ i, Œ± i = Œ±' i)
    (hf : ‚àÄ i a, f i a = (cast (hŒ± _).symm (f' i (cast (hŒ± _) a))))
    (hinit : init = cast (hŒ± 0).symm init') :
      dfoldl n Œ± f init = cast (hŒ± (last n)).symm (dfoldl n Œ±' f' init')

Nat.add_sub_cancel in Init.Data.Nat.Basic

@[simp]
theorem dconcat_zero {motive : Fin 1 ‚Üí Sort u} (a : motive (last 0)) :
    !d‚ü®fun _ : Fin 0 => motive (castSucc _)‚ü©[] :+·µà‚ü®motive‚ü© a = !d‚ü®motive‚ü©[a]

@[simp]
theorem partialSum_nil : [].partialSum = [0]

lemma decoded_polynomial_lt_deg (c : ReedSolomon.code domain deg) :
  decode c ‚àà (degreeLT F deg : Submodule F F[X])

theorem seqCompose_rbrKnowledgeSoundness
    (rel : ‚àÄ i, Set (Stmt i √ó Wit i))
    (V : ‚àÄ i, Verifier oSpec (Stmt i.castSucc) (Stmt i.succ) (pSpec i))
    (rbrKnowledgeError : ‚àÄ i, (pSpec i).ChallengeIdx ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (V i).rbrKnowledgeSoundness init impl
      (rel i.castSucc) (rel i.succ) (rbrKnowledgeError i)) :
      (Verifier.seqCompose Stmt V).rbrKnowledgeSoundness init impl (rel 0) (rel (Fin.last m))
        (fun combinedIdx =>
          letI ij := seqComposeChallengeIdxToSigma combinedIdx
          rbrKnowledgeError ij.1 ij.2)

lemma linearIndependent_rows_of_lower_triangular_ne_zero_diag
  {n : ‚Ñï} {R : Type*} [Field R] (A : Matrix (Fin n) (Fin n) R)
  (h_lower_triangular : A.BlockTriangular ‚áëOrderDual.toDual) (h_diag : ‚àÄ i, A i i ‚â† 0) :
  LinearIndependent R A

lemma neg_add_cancel {k : ‚Ñï} (a : ConcreteBTField k) : neg a + a = 0

theorem insertNth_zero_eq_cases {n : ‚Ñï} {Œ± : Fin (n + 1) ‚Üí Sort u} :
    insertNth 0 = cases (motive := Œ±)

theorem rename_eq_zero_of_injective {œÑ : Type*} {f : œÉ ‚Üí œÑ} (hf : Function.Injective f)
    {p : MvPolynomial œÉ R} (h : rename f p = 0) : p = 0

@[simp]
theorem simulateQ'_query_bind (q : OracleQuery spec Œ±)
    (ob : Œ± ‚Üí OracleComp spec Œ≤) (h : ‚àÄ x, (ob x).neverFails) :
    simulateQ' so (liftM q >>= ob) (by simp [h]) =
      so.impl q >>= (fun x => simulateQ' so (ob x) (h x))

theorem fappend_ext {Œ± : Fin m ‚Üí A} {Œ≤ : Fin n ‚Üí A}
    (u‚ÇÅ u‚ÇÇ : (i : Fin m) ‚Üí F (Œ± i)) (v‚ÇÅ v‚ÇÇ : (i : Fin n) ‚Üí F (Œ≤ i)) :
    fappend u‚ÇÅ v‚ÇÅ = fappend u‚ÇÇ v‚ÇÇ ‚Üî u‚ÇÅ = u‚ÇÇ ‚àß v‚ÇÅ = v‚ÇÇ

lemma toCodewordsCount_mul_œë_lt_‚Ñì (‚Ñì œë : ‚Ñï) [NeZero œë] [NeZero ‚Ñì] (i : Fin (‚Ñì + 1)) :
  ‚àÄ j: Fin (toOutCodewordsCount ‚Ñì œë i), j.val * œë < ‚Ñì

theorem liftContext_soundness [Inhabited InnerStmtOut]
    {outerLangIn : Set OuterStmtIn} {outerLangOut : Set OuterStmtOut}
    {innerLangIn : Set InnerStmtIn} {innerLangOut : Set InnerStmtOut}
    {soundnessError : ‚Ñù‚â•0}
    {lens : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut}
    (V : Verifier oSpec InnerStmtIn InnerStmtOut pSpec)
    -- TODO: figure out the right compatibility relation for the IsSound condition
    [lensSound : lens.IsSound outerLangIn outerLangOut innerLangIn innerLangOut
      (V.compatStatement lens)]
    (h : V.soundness init impl innerLangIn innerLangOut soundnessError) :
      (V.liftContext lens).soundness init impl outerLangIn outerLangOut soundnessError

lemma rank_eq_dim_fromColGenMat [CommRing F] {G : Matrix Œ∫ Œπ F} :
  G.rank = dim (fromColGenMat G)

@[grind]
lemma degreeX_le_degreeX_sub_degreeX [IsDomain F] {f q : F[X][Y]} (hf : f ‚â† 0) (hg : q * f ‚â† 0) :
  degreeX q ‚â§ degreeX (q * f) - degreeX f

@[simp]
theorem toNat_zero : toNat zero = 0

theorem cast_Type_idx_symm {hn} (hSpec : pSpec‚ÇÅ.cast hn = pSpec‚ÇÇ) {i : Fin n‚ÇÇ} :
    pSpec‚ÇÅ.¬´Type¬ª (Fin.cast hn.symm i) = pSpec‚ÇÇ.¬´Type¬ª i

lemma distInterleavedCodeToCodeLB
  {IC : LawfulInterleavedCode Œ∫ Œπ F} {U : Matrix Œ∫ Œπ F} {e : ‚Ñï}
  (hF : Fintype.card F ‚â• e)
  (he : (e : ‚Ñö) ‚â§ (minDist (IC.1.LC : Set (Œπ ‚Üí F)) / 3)) (hU : e < Œî(U,IC.1.MF)) :
  ‚àÉ v ‚àà Matrix.rowSpan U , e < distFromCode v IC.1.LC

theorem insertNth_ne_zero_of_left (h : y ‚â† 0) : insertNth p y s ‚â† 0

@[simp]
theorem vflatten_two_eq_append {n : Fin 2 ‚Üí ‚Ñï} {v : (i : Fin 2) ‚Üí Fin (n i) ‚Üí Œ±} :
    vflatten v = vappend (v 0) (v 1)

@[simp]
theorem fflatten_two_eq_append {A : Sort u} {F : A ‚Üí Sort v} {n : Fin 2 ‚Üí ‚Ñï}
    {Œ± : (i : Fin 2) ‚Üí (j : Fin (n i)) ‚Üí A}
    {v : (i : Fin 2) ‚Üí (j : Fin (n i)) ‚Üí F (Œ± i j)} :
    fflatten v = fappend (F := F) (v 0) (v 1)

omit [Finite F] in
lemma sqr_mem_D_succ_i_of_mem_D_i : ‚àÄ {a : FÀ£} {i : ‚Ñï},
    a ‚àà evalDomain D x i ‚Üí a ^ 2 ‚àà evalDomain D x (i + 1)

@[to_additive]
lemma prod_univ_twos {M : Type*} [CommMonoid M] {n : ‚Ñï} (hn : n = 2) (f : Fin n ‚Üí M) :
    (‚àè i, f i) = f (Fin.cast hn.symm 0) * f (Fin.cast hn.symm 1)

theorem happend_left_eq_hcons {Œ± : Fin 1 ‚Üí Sort u} {Œ≤ : Fin n ‚Üí Sort u}
    (a : (i : Fin 1) ‚Üí Œ± i) (v : (i : Fin n) ‚Üí Œ≤ i) :
    True

private lemma F2i_card {Œ± : F} :
  (F2i B i Œ±).card = 2 * choose_2 (K B i Œ±)

lemma getBit_eq_succ_getBit_of_mul_two_add_one {n k : ‚Ñï} : getBit (k+1) (2*n + 1) = getBit k n

@[ext]
theorem ext' {a b : AssocNat} (h : a 0 = b 0) : a = b

theorem finSuccEquivNth_rename_finSuccEquivNth (e : œÉ ‚âÉ Fin n) (œÜ : MvPolynomial (Option œÉ) R) :
    ((finSuccEquivNth R p) ((rename ((Equiv.optionCongr e).trans (_root_.finSuccEquiv' p).symm)) œÜ))
      = Polynomial.map (rename e).toRingHom (optionEquivLeft R œÉ œÜ)

theorem BitVec.eq_mp_eq_dcast {w w2 : ‚Ñï} (x : BitVec w) (h_width_eq : w = w2)
  (h_bitvec_eq : BitVec w = BitVec w2 := by rw [h_width_eq]) :
  Eq.mp (h:=h_bitvec_eq) (a:=x) = dcast (h_width_eq) (x)

@[simp]
lemma eval‚ÇÇAlgHom_apply {A B : Type*} [CommSemiring A] [CommSemiring B] [MvPolynomialLike œÉ A P]
    [Algebra R A] [IsScalarTower R A P] [Algebra R B]
    (f : A ‚Üí‚Çê[R] B) (g : œÉ ‚Üí B) (p : P) :
    (eval‚ÇÇAlgHom f g) p = eval‚ÇÇ f g p

lemma pow_inj {i : ‚Ñï} {a b : Fin (2 ^ (n - i))} :
    i ‚â§ n ‚Üí (DIsCyclicC.gen.1 ^ 2 ^ i) ^ a.1 = (DIsCyclicC.gen.1 ^ 2 ^ i) ^ b.1 ‚Üí a = b

theorem srSoundness_implies_soundness
    (langIn : Set StmtIn) (langOut : Set StmtOut)
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    (srInit : ProbComp (srChallengeOracle StmtIn pSpec).FunctionType)
    (srImpl : QueryImpl oSpec (StateT (srChallengeOracle StmtIn pSpec).FunctionType ProbComp))
    (srSoundnessError : ‚Ñù‚â•0) :
      Verifier.StateRestoration.soundness srInit srImpl langIn langOut verifier srSoundnessError ‚Üí
        soundness init impl langIn langOut verifier srSoundnessError

theorem singleEqPolynomial_zeroOne_C (r : Fin 2) (x : Fin 2) :
    (singleEqPolynomial (r : R) (C x) : MvPolynomial œÉ R) = if x = r then 1 else 0

lemma forwardRange_pred_le_ne_empty (n : ‚Ñï) (r : Fin n) (l : Fin (r.val + 1))
    (h_l_gt_0 : l.val > 0) : forwardRange n r ‚ü®l.val - 1, by omega‚ü© ‚â† []

theorem rbrKnowledgeSoundnessOneShot_implies_rbrKnowledgeSoundness
    {relIn : Set (StmtIn √ó WitIn)} {relOut : Set (StmtOut √ó WitOut)}
    {verifier : Verifier oSpec StmtIn StmtOut pSpec}
    {rbrKnowledgeError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    (hInit : init.neverFails)
    (h : verifier.rbrKnowledgeSoundnessOneShot init impl relIn relOut rbrKnowledgeError) :
    verifier.rbrKnowledgeSoundness init impl relIn relOut rbrKnowledgeError

@[simp]
lemma two_mul_inv_two : (2 : F) * 2‚Åª¬π = 1

theorem eqPolynomial_zeroOne (r : œÉ ‚Üí Fin 2) : (eqPolynomial r : MvPolynomial œÉ R) =
    ‚àè i : œÉ, if r i = 0 then 1 - X i else X i

lemma bwm_of_neg [NeZero n] (h : e ‚â§ j.1) :
  BerlekampWelchMatrix e k œâs f i j = -(œâs i)^(j - e)

omit [Finite F] in
lemma D_def : D = evalDomain D 0

theorem insertNth_ne_zero_iff : insertNth p y s ‚â† 0 ‚Üî y ‚â† 0 ‚à® s ‚â† 0

theorem distFromCode_eq_of_lt_half_dist (C : Set (n ‚Üí R)) (u : n ‚Üí R) {v w : n ‚Üí R}
    (hv : v ‚àà C) (hw : w ‚àà C) (huv : Œî‚ÇÄ(u, v) < ‚ÄñC‚Äñ‚ÇÄ / 2) (hvw : Œî‚ÇÄ(u, w) < ‚ÄñC‚Äñ‚ÇÄ / 2) : v = w

@[simp]
theorem hflatten_two_eq_append {n : Fin 2 ‚Üí ‚Ñï} {Œ± : (i : Fin 2) ‚Üí (j : Fin (n i)) ‚Üí Sort*}
    {v : (i : Fin 2) ‚Üí (j : Fin (n i)) ‚Üí Œ± i j} : hflatten v = happend (v 0) (v 1)

@[simp]
theorem rtake_apply (v : (i : Fin n) ‚Üí Œ± i) (m : ‚Ñï) (h : m ‚â§ n)
    (i : Fin m) : rtake m h v i = v (Fin.cast (Nat.sub_add_cancel h) (natAdd (n - m) i))

theorem sumcheckFoldOracleReduction_perfectCompleteness (hInit : init.neverFails) :
    OracleReduction.perfectCompleteness
      (pSpec := pSpecSumcheckFold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
      (relIn := roundRelation (mp := mp) ùîΩq Œ≤ (œë:=œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) 0)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë:=œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) (Fin.last ‚Ñì))
      (oracleReduction := sumcheckFoldOracleReduction ùîΩq Œ≤ (œë:=œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë))
      (init := init)
      (impl := impl)

lemma johnson_denominator_def :
  JohnsonDenominator B v = ((1 - ((Fintype.card F) / (Fintype.card F - 1)) * (e B v / n)) ^ 2
      - (1 - ((Fintype.card F) / (Fintype.card F - 1)) * (d B/n)))

Nat.lt_succ_of_lt in Init.Data.Nat.Basic

@[simp]
theorem init_update_last : init (update s (Fin.last n) y) = init s

nonpos_iff_eq_zero in Mathlib.Algebra.Order.Monoid.Canonical.Defs

omit [NeZero ‚Ñì] [NeZero r] [NeZero ùì°] in
lemma fin_‚Ñì_lt_r {h_‚Ñì_add_R_rate : ‚Ñì + ùì° < r} (i : Fin ‚Ñì)
    : i.val < r

@[simp]
theorem list_nonempty (k : ‚Ñï) : (list k).1 ‚â† []

lemma deevenize_evenize {f : Polynomial F} :
    deevenize (evenize f) = f

@[simp]
lemma dfoldr'_zero {Œ± : Fin 1 ‚Üí Type u}
    (f : (i : Fin 0) ‚Üí Œ± i.succ ‚Üí Œ± i.castSucc) (x : Œ± (last 0)) :
    dfoldr' 0 Œ± f x = x

theorem fconcat‚ÇÇ_right_injective {Œ±‚ÇÅ : Fin n ‚Üí A} {Œ±‚ÇÇ : Fin n ‚Üí B} {Œ≤‚ÇÅ : A} {Œ≤‚ÇÇ : B}
    (v : (i : Fin n) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i)) :
    Function.Injective (fconcat‚ÇÇ (F := F‚ÇÇ) v :
      F‚ÇÇ Œ≤‚ÇÅ Œ≤‚ÇÇ ‚Üí (i : Fin (n + 1)) ‚Üí F‚ÇÇ (Fin.vconcat Œ±‚ÇÅ Œ≤‚ÇÅ i) (Fin.vconcat Œ±‚ÇÇ Œ≤‚ÇÇ i))

lemma foldl_NTTStage_inductive_aux (h_‚Ñì : ‚Ñì ‚â§ r) (k : Fin (‚Ñì + 1))
    (original_coeffs : Fin (2 ^ ‚Ñì) ‚Üí L) :
    additiveNTTInvariant ùîΩq Œ≤ h_‚Ñì_add_R_rate
    (Fin.foldl k (fun current_b i ‚Ü¶ NTTStage ùîΩq Œ≤ h_‚Ñì_add_R_rate
      ‚ü®‚Ñì - i -1, by omega‚ü© current_b) (tileCoeffs original_coeffs))
    original_coeffs ‚ü®‚Ñì - k, by omega‚ü©

lemma algebraMap_adjacent_tower_succ_eq_Adjoin_of (k : ‚Ñï) :
  (algebraMap (BTField k) (BTField (k + 1))) = of (poly k)

@[simp]
theorem insertNth_apply_succAbove : insertNth p y s (p.succAbove i) = s i

@[ext] theorem UniPolyC.ext {p q : UniPolyC R} (h : p.val = q.val) : p = q

@[simp]
lemma length_eq_domain_size (inj : Function.Injective Œ±) :
  length (ReedSolomon.code ‚ü®Œ±, inj‚ü© deg) = m

@[local grind _=_]
private lemma support_eq_support_toFinsupp {f : F[X][Y]} : f.support = f.toFinsupp.support

private lemma sum_of_not_equals :
  ‚àë x ‚àà B √óÀ¢ B with x.1 ‚â† x.2, (if x.1 i ‚â† x.2 i then 1 else 0)
  =
  2 * choose_2 #B - 2 * ‚àë Œ±, choose_2 (K B i Œ±)

@[simp, grind =]
theorem monomialXY_eq_zero_iff {n m : ‚Ñï} {a : F} : monomialXY n m a = 0 ‚Üî a = 0

theorem fconcat_inj {Œ± : Fin n ‚Üí A} {Œ≤ : A}
    (v‚ÇÅ v‚ÇÇ : (i : Fin n) ‚Üí F (Œ± i)) (a‚ÇÅ a‚ÇÇ : F Œ≤) :
    fconcat v‚ÇÅ a‚ÇÅ = fconcat v‚ÇÇ a‚ÇÇ ‚Üî v‚ÇÅ = v‚ÇÇ ‚àß a‚ÇÅ = a‚ÇÇ

@[simp]
lemma ofPolynomialAlgHom_X : ofPolynomialAlgHom (Polynomial.X : R[X]) = (X : P)

theorem finalSumcheckOracleVerifier_rbrKnowledgeSoundness [Fintype L] {œÉ : Type}
    (init : ProbComp œÉ) (impl : QueryImpl []‚Çí (StateT œÉ ProbComp)) :
    (finalSumcheckVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).rbrKnowledgeSoundness init impl
      (relIn := roundRelation ùîΩq Œ≤ (œë := œë) (ùìë := ùìë)
        (mp := BBF_SumcheckMultiplierParam) (Fin.last ‚Ñì))
      (relOut := finalSumcheckRelOut ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
      (rbrKnowledgeError := finalSumcheckKnowledgeError)

theorem rightpad_eq_rightpad_max (l : List Œ±) (n : Nat) :
    rightpad n unit l = rightpad (max n l.length) unit l

@[simp] theorem toNat_add (a b : AssocNat) : toNat (add a b) = toNat a + toNat b

theorem eval_zeroOne_eq_MLE_toEvalsZeroOne (p : MvPolynomial œÉ R) (x : œÉ ‚Üí Fin 2) :
    eval (x : œÉ ‚Üí R) p = eval (x : œÉ ‚Üí R) (MLE p.toEvalsZeroOne)

theorem induction_append_right {m n : ‚Ñï} {motive : Fin (m + n + 1) ‚Üí Sort*} {zero : motive 0}
  {succ : ‚àÄ i : Fin (m + n), motive i.castSucc ‚Üí motive i.succ} {i : Fin (n + 1)} :
    induction zero succ (i.natAdd m) =
      @induction n (fun i => motive (i.natAdd m))
        (@induction m (fun j => motive (Fin.cast (by omega) (j.castAdd n)))
          zero (fun j x => succ (j.castAdd n) x) (last m))
        (fun i x => succ (i.natAdd m) x) i

@[simp]
theorem init_update_castSucc : init (update s i.castSucc y) = update (init s) i y

theorem whir_rbr_soundness
    [SelectableType F] {d dstar : ‚Ñï}
  -- P : set of M + 1 parameters including foldingParam·µ¢, varCount·µ¢, œÜ·µ¢, repeatParam·µ¢,
  --

lemma resultant_is_divisible_by_leadingCoeff {F : Type} [CommRing F] [Inhabited F] (f : F[X])
  : ‚àÉ r',
    Polynomial.resultant f (Polynomial.derivative f) = f.leadingCoeff * r'

lemma Fin.val_sub_one (a : Fin r) (h_a_sub_1 : a > 0) : (a - 1).val = a.val - 1

lemma one_le_sub_middle_of_pow2 {k : ‚Ñï} (h_k : 1 ‚â§ k) : 1 ‚â§ 2 ^ k - 2 ^ (k - 1)

@[simp]
lemma seqCompose_succ {m : ‚Ñï}
    (Stmt : Fin (m + 2) ‚Üí Type) (Wit : Fin (m + 2) ‚Üí Type)
    {n : Fin (m + 1) ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (R : (i : Fin (m + 1)) ‚Üí
      Reduction oSpec (Stmt i.castSucc) (Wit i.castSucc) (Stmt i.succ) (Wit i.succ) (pSpec i)) :
    seqCompose Stmt Wit R =
      append (R 0) (seqCompose (Stmt ‚àò Fin.succ) (Wit ‚àò Fin.succ) (fun i => R (Fin.succ i)))

lemma algebraMap_succ_eq_zero_x {k : ‚Ñï} (h_pos : k > 0) (x : BTField (k - 1)) :
  letI instAlgebra := binaryAlgebraTower (l:=k-1) (r:=k) (h_le:=by omega)
  algebraMap (BTField (k - 1)) (BTField k) x = ‚ãò 0, x ‚ãô

theorem foldr_split_inner {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤ ‚Üí Œ≤) (init : Œ≤)
    (l : List Œ±) (h : l ‚â† []): foldr (f:=f) (init:=init) (l)
    = foldr (f:=f) (init:=f (l.getLast (by omega)) (init)) (l.dropLast)

theorem vappend_succ (u : Fin m ‚Üí Œ±) (v : Fin (n + 1) ‚Üí Œ±) :
    vappend u v = vconcat (vappend u (v ‚àò castSucc)) (v (last n))

lemma rank_eq_if_subUpFull_eq (h : n ‚â§ m) :
   (subUpFull U (Fin.castLE h)).rank = n  ‚Üí U.rank = n

Fin.val_injective in Mathlib.Data.Fin.Basic

theorem mca_capacity_bound_CONJECTURE
  [DecidableEq Œπ]
  (Œ± : F) (œÜ : Œπ ‚Ü™ F) (m : ‚Ñï) [Smooth œÜ]
  (par‚Ñì_type : Type) [Fintype par‚Ñì_type] (exp : par‚Ñì_type ‚Ü™ ‚Ñï) :
  let Gen := RSGenerator.genRSC par‚Ñì_type œÜ m exp
  let : Fintype Gen.par‚Ñì := Gen.h‚Ñì
  haveI := Gen.Gen_nonempty
  ‚àÉ (c‚ÇÅ c‚ÇÇ : ‚Ñï),
    ‚àÄ (f : Gen.par‚Ñì ‚Üí Œπ ‚Üí F) (Œ∑ : ‚Ñù) (_hŒ∑ : 0 < Œ∑) (Œ¥ : ‚Ñù‚â•0)
      (_hŒ¥ : 0 < Œ¥ ‚àß Œ¥ < 1 - Gen.rate - Œ∑),
      Pr_{let r ‚Üê$·µñ Gen.Gen}[ proximityCondition f Œ¥ r Gen.C ] ‚â§
        ENNReal.ofReal (
          (((Fintype.card par‚Ñì_type - 1) : ‚Ñù)^c‚ÇÇ * ((2^m) : ‚Ñù)^c‚ÇÇ) /
          (Œ∑^c‚ÇÅ * Gen.rate^(c‚ÇÅ+c‚ÇÇ) * (Fintype.card F))
        )

lemma separable_iff_discr_eq_zero {F : Type} [Field F] [Inhabited F] (f : F[X]) :
  f.Separable ‚Üî discriminant f ‚â† 0

omit [NeZero ‚Ñì] in
lemma fin_‚Ñì_lt_‚Ñì_add_one (i : Fin ‚Ñì) : i < ‚Ñì + 1

theorem embedSum_succ {m : ‚Ñï} {n : Fin (m + 1) ‚Üí ‚Ñï} {i : Fin (m + 1)} (j : Fin (n i)) :
    embedSum i j = (match i with
    | 0 => Fin.castAdd _ j
    | ‚ü®i + 1, h‚ü© => Fin.natAdd _ (embedSum ‚ü®i, Nat.succ_lt_succ_iff.mp h‚ü© j))

theorem LeafData.composeBuild_internal {Œ±} {s_left s_right : Skeleton}
    (left : LeafData Œ± s_left) (right : LeafData Œ± s_right)
    (compose : Œ± ‚Üí Œ± ‚Üí Œ±) :
    (LeafData.internal left right).composeBuild compose =
      FullData.internal
        (compose (left.composeBuild compose).getRootValue (right.composeBuild compose).getRootValue)
        (left.composeBuild compose)
        (right.composeBuild compose)

@[simp]
theorem vflatten_zero {n : Fin 0 ‚Üí ‚Ñï} {v : (i : Fin 0) ‚Üí Fin (n i) ‚Üí Œ±} : vflatten v = !v[]

lemma comp_sub_C_of_linear_eval (p : L[X])
  (h_lin : IsLinearMap ùîΩq (f := fun inner_p ‚Ü¶ p.comp inner_p)) (a : L) :
    p.comp (X - C a) = p - C (eval a p)

theorem simulateQ_bind_fst_comp (oa : OracleComp spec Œ±) (f : Œ± ‚Üí OracleComp spec Œ≤) :
    (do let a ‚Üê (simulateQ loggingOracle oa).run; f a.1) = (do let a ‚Üê oa; f a)

theorem sum_fromNat_eq_from_xor_Nat {k : ‚Ñï} (x y : Nat) :
  fromNat (k:=k) (x ^^^ y) = fromNat (k:=k) x + fromNat (k:=k) y

@[simp]
theorem hflatten_zero {n : Fin 0 ‚Üí ‚Ñï} {Œ± : (i : Fin 0) ‚Üí (j : Fin (n i)) ‚Üí Sort*}
    {v : (i : Fin 0) ‚Üí (j : Fin (n i)) ‚Üí Œ± i j} : hflatten v = !h[]

lemma W·µ¢_eval_Œ≤·µ¢_neq_zero
    (i : Fin r): (W ùîΩq Œ≤ i).eval (Œ≤ i) ‚â† 0

@[csimp] lemma dfoldr_eq_dfoldr' : @dfoldr = @dfoldr'

lemma irreducibleHTildeOfIrreducible {H : Polynomial (Polynomial F)} :
    (Irreducible H ‚Üí Irreducible (H_tilde H))

lemma twoAdicGenerators_pow_twoPow_eq_one (bits : Fin (twoAdicity + 1)) :
    (twoAdicGenerators[bits]) ^ (2 ^ (bits : Nat)) = (1 : Field)

theorem pow_exp_of_2_repr_given_x_square_repr {F : Type*} [instField : Field F]
  (sumZeroIffEq : ‚àÄ (x y : F), x + y = 0 ‚Üî x = y) (x z : F) (h_z_non_zero : z ‚â† 0)
  (h_x_square : x ^ 2 = x * z + 1)
  : ‚àÄ i : ‚Ñï, x^(2^i) = x * z^(2^i - 1) + ‚àë j ‚àà Finset.Icc 1 i, z^(2^i - 2^j)

theorem unique_linear_decomposition_succ (k : ‚Ñï) :
  letI : Algebra (ConcreteBTField k) (ConcreteBTField (k+1)) :=
    ConcreteBTFieldAlgebra (l:=k) (r:=k+1) (h_le:=by omega)
  ‚àÄ (x : ConcreteBTField (k+1)), ‚àÉ! (p : ConcreteBTField k √ó ConcreteBTField k),
    x = join_via_add_smul (k+1) (by omega) p.1 p.2

@[simp]
lemma lin_shift_hamming_distance [Field F] {x‚ÇÅ x‚ÇÇ v : Fin n ‚Üí F}
  :
  Œî‚ÇÄ(x‚ÇÅ - v, x‚ÇÇ - v) = Œî‚ÇÄ(x‚ÇÅ, x‚ÇÇ)

lemma num_eq_highBits_add_lowBits {n: ‚Ñï} (numLowBits: ‚Ñï) :
  n = getHighBits numLowBits n + getLowBits numLowBits n

lemma min_dist_le_d [Field F] {B : Finset (Fin n ‚Üí F)} (v : Fin n ‚Üí F)
  :
  sInf { d | ‚àÉ u ‚àà B, ‚àÉ v ‚àà B, u ‚â† v ‚àß hammingDist u v = d } ‚â§ d B

theorem changeOfBasisMatrix_det_ne_zero
  (‚Ñì : Nat) (h_‚Ñì : ‚Ñì ‚â§ r) :
  (changeOfBasisMatrix ùîΩq Œ≤ ‚Ñì h_‚Ñì).det ‚â† 0

theorem mul_one (n : ChurchNat Œ±) : mul n one = n

lemma and_one_eq_of_eq {a b : ‚Ñï} : a = b ‚Üí a &&& 1 = b &&& 1

@[simp]
theorem Z_succ_eq_adjointRoot_root (k : ‚Ñï) : Z (k+1) = AdjoinRoot.root (poly k)

theorem toNatInRange {k : ‚Ñï} (b : ConcreteBTField k) :
  BitVec.toNat b ‚â§ 2 ^ (2 ^ k) * 1

lemma fold_f_g
  {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F} {k m : ‚Ñï}
  {œÜ_0 : (indexPowT S œÜ 0) ‚Ü™ F} {œÜ_k : (indexPowT S œÜ k) ‚Ü™ F}
  [Fintype (indexPowT S œÜ 0)] [DecidableEq (indexPowT S œÜ 0)] [Smooth œÜ_0]
  [Fintype (indexPowT S œÜ k)] [DecidableEq (indexPowT S œÜ k)] [Smooth œÜ_k]
  [‚àÄ i : ‚Ñï, Neg (indexPowT S œÜ i)]
  (Œ±s : Fin k ‚Üí F) (hk : k ‚â§ m)
  (f : smoothCode œÜ_0 m) :
  let f_fun := (f : (indexPowT S œÜ 0) ‚Üí F)
  let g := fold_k f_fun Œ±s hk
  g ‚àà smoothCode œÜ_k (m - k)

lemma qMap_total_fiber_one_level_eq (i : Fin ‚Ñì) (h_i_add_1 : i.val + 1 ‚â§ ‚Ñì)
    (y : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i + 1, by omega‚ü©)) (k : Fin 2) :
    let basis_x := sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i, by omega‚ü© (by simp only; omega)
    let x : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i, by omega‚ü© := qMap_total_fiber ùîΩq Œ≤ (i := ‚ü®i, by omega‚ü©)
      (steps := 1) (h_i_add_steps := by apply Nat.lt_add_of_pos_right_of_le; omega) (y := y) k
    let y_lifted : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i, by omega‚ü© := sDomain.lift ùîΩq Œ≤ h_‚Ñì_add_R_rate
      (i := ‚ü®i, by omega‚ü©) (j := ‚ü®i.val + 1, by omega‚ü©)
      (h_j := by apply Nat.lt_add_of_pos_right_of_le; omega)
      (h_le := by apply Fin.mk_le_mk.mpr (by omega)) y
    let free_coeff_term : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i, by omega‚ü© :=
      (Fin2ToF2 ùîΩq k) ‚Ä¢ (basis_x ‚ü®0, by simp only; omega‚ü©)
    x = free_coeff_term + y_lifted

theorem reduction_completeness {Œµ : ‚Ñù‚â•0}
    (hRel : ‚àÄ stmtIn witIn, (stmtIn, witIn) ‚àà relIn ‚Üí
      [fun ‚ü®stmtOut, witOut‚ü© => (stmtOut, witOut) ‚àà relOut|do
        (simulateQ impl <| combineMap mapStmt mapWit ‚ü®stmtIn, witIn‚ü©).run' (‚Üê init)] ‚â• 1 - Œµ) :
    Reduction.completeness init impl relIn relOut (reduction mapStmt mapWit) Œµ

lemma testBit_of_sub_two_pow_of_bit_1 {n i : ‚Ñï} (h_testBit_eq_1 : (n).testBit i = true) :
  (n - 2^i).testBit i = false

lemma W_monic (i : Fin r) : (W ùîΩq Œ≤ i).Monic

theorem knowledgeSoundness_implies_soundness (relIn : Set (StmtIn √ó WitIn))
    (relOut : Set (StmtOut √ó WitOut))
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    (knowledgeError : ‚Ñù‚â•0) (hLt : knowledgeError < 1) :
      knowledgeSoundness init impl relIn relOut verifier knowledgeError ‚Üí
        soundness init impl relIn.language relOut.language verifier knowledgeError

@[simp]
lemma OracleVerifier.id_rbrKnowledgeSoundness
    {rel : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness)} :
    (OracleVerifier.id : OracleVerifier oSpec Statement OStatement _ _ _).rbrKnowledgeSoundness
      init impl rel rel 0

@[simp] lemma natCast_eq {k : ‚Ñï} (n : ‚Ñï) : (‚Üën : ConcreteBTField k) = natCast n

@[simp]
theorem OracleVerifier.run_eq_run_verifier [O‚Çò : ‚àÄ i, OracleInterface (pSpec.Message i)]
    {stmt : StmtIn} {oStmt : ‚àÄ i, OStmtIn i} {transcript : FullTranscript pSpec}
    {verifier : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec} :
      verifier.run stmt oStmt transcript =
        verifier.toVerifier.run ‚ü®stmt, oStmt‚ü© transcript

protected lemma johnson_bound_lemma [Field F] {v : Fin n ‚Üí F}
  (h_n : 0 < n)
  (h_B : 2 ‚â§ B.card)
  (h_card : 2 ‚â§ (Fintype.card F))
  :
  B.card *
    ((1 - ((Fintype.card F : ‚Ñö) / (Fintype.card F - 1)) * (e B v / n)) ^ 2
      - (1 - ((Fintype.card F : ‚Ñö) / (Fintype.card F - 1)) * (d B/n)))  ‚â§
  ((Fintype.card F : ‚Ñö) / (Fintype.card F - 1)) * d B/n

theorem trim_twice [LawfulBEq R] (p : UniPoly R) : p.trim.trim = p.trim

Nat.lt_of_add_right_lt in Init.Data.Nat.Basic

@[simp]
protected lemma elocPolyF_eq_elocPoly :
  ElocPolyF (n := n) (liftF' œâs) (liftF' f) = ElocPoly n œâs f

lemma last_nonzero_unique {p : UniPoly Q} {k k' : Fin p.size} :
  last_nonzero_prop k ‚Üí last_nonzero_prop k' ‚Üí k = k'

theorem generator_on_curve : let (x, y) := generator
  y^2 = x^3 + 3

@[simp]
theorem vconcat_last (v : Fin n ‚Üí Œ±) (a : Œ±) : vconcat v a (Fin.last n) = a

lemma concrete_inv_one :
  concrete_inv (k:=k) 1 = 1

@[simp]
theorem cast_dir_idx {hn} (hSpec : pSpec‚ÇÅ.cast hn = pSpec‚ÇÇ) {i : Fin n‚ÇÅ} :
    pSpec‚ÇÇ.dir (Fin.cast hn i) = pSpec‚ÇÅ.dir i

lemma sub_middle_of_pow2_with_one_canceled {k : ‚Ñï} (h_k : 1 ‚â§ k) : 2 ^ k - 1 - 2 ^ (k - 1) + 1
  = 2 ^ (k - 1)

theorem dcast‚ÇÉ_eq_dcast‚ÇÉ_iff (ha : a = a') (hb : dcast ha b = b') (hc : dcast‚ÇÇ ha hb c = c') :
    dcast‚ÇÉ ha hb hc d = d' ‚Üî d = dcast‚ÇÉ ha.symm (dcast_symm ha hb) (dcast‚ÇÇ_symm ha hb hc) d'

theorem oracleVerifier_rbrKnowledgeSoundness [Fintype R] :
    (oracleReduction R deg oSpec).verifier.rbrKnowledgeSoundness init impl
      (inputRelation R deg D) (outputRelation R deg)
        (fun _ => (deg : ‚Ñù‚â•0) / (Fintype.card R))

@[simp]
theorem cast_toVerifier (V : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec‚ÇÅ) :
    (OracleVerifier.cast hn hSpec hO‚Çò V).toVerifier = Verifier.cast hn hSpec V.toVerifier

lemma U_card (i : Fin r) :
    Fintype.card (U ùîΩq Œ≤ i) = (Fintype.card ùîΩq)^i.val

omit [DecidableEq ùîΩq] hF‚ÇÇ in
lemma initial_tiled_coeffs_correctness (h_‚Ñì : ‚Ñì ‚â§ r) (a : Fin (2 ^ ‚Ñì) ‚Üí L) :
    let b: Fin (2^(‚Ñì + R_rate)) ‚Üí L := tileCoeffs a
    additiveNTTInvariant ùîΩq Œ≤ h_‚Ñì_add_R_rate b a (i := ‚ü®‚Ñì, by omega‚ü©)

lemma xor_eq_sub_iff_submask {n m : ‚Ñï} (h: m ‚â§ n) : n ^^^ m = n - m ‚Üî n &&& m = m

theorem Reduction.run_of_prover_first [ProverOnly pSpec] (stmt : StmtIn) (wit : WitIn)
    (reduction : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      reduction.run stmt wit = (do
        let state := reduction.prover.input (stmt, wit)
        let ‚ü®msg, state‚ü© ‚Üê liftComp (reduction.prover.sendMessage ‚ü®0, by simp‚ü© state) _
        let ctxOut ‚Üê reduction.prover.output state
        let transcript : pSpec.FullTranscript := fun i => match i with | ‚ü®0, _‚ü© => msg
        let stmtOut ‚Üê reduction.verifier.verify stmt transcript
        return (‚ü®transcript, ctxOut‚ü©, stmtOut))

lemma getBit_of_middleBits {n offset len k : ‚Ñï} :
  getBit k (getMiddleBits offset len n) =
    if k < len then getBit (k + offset) n else 0

lemma h_sum_two_same_pow2 {k : ‚Ñï} (h_pos : k > 0) : 2 ^ (k - 1) + 2 ^ (k - 1) = 2 ^ k

theorem reduction_rbr_knowledge_soundness : True

private lemma coeffs_of_comp_minus_x_pos_degree {f : Polynomial F} {n : ‚Ñï} (h : 0 < f.degree) :
    (f.comp (-X)).coeff n = if Even n then f.coeff n else -f.coeff n

@[simp]
theorem oracleReduction_completeness (h : init.neverFails)
    (hRel : ‚àÄ stmtIn oStmtIn witIn,
      ((stmtIn, oStmtIn), witIn) ‚àà relIn ‚Üí
      ((mapStmt stmtIn, mapOStmt embedIdx hEq oStmtIn), mapWit stmtIn witIn) ‚àà relOut) :
    (oracleReduction oSpec mapStmt mapWit embedIdx hEq).perfectCompleteness init impl
      relIn relOut

Nat.zero_le in Init.Prelude

lemma sDomain_eq_image_of_upper_span (i : Fin r) (h_i : i < ‚Ñì + R_rate) :
    let V_i := Submodule.span ùîΩq (Set.range (sBasis Œ≤ h_‚Ñì_add_R_rate i h_i))
    let W_i_map := polyEvalLinearMap (normalizedW ùîΩq Œ≤ i)
      (normalizedW_is_additive ùîΩq Œ≤ i)
    sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i
    = Submodule.map W_i_map V_i

@[simp]
theorem partialSum_succ {a : Œ±} {l : List Œ±} :
    (a :: l).partialSum = [0] ++ (partialSum l).map (a + ¬∑)

@[simp]
lemma inv_two_mul_two : 2‚Åª¬π * (2 : F) = 1

theorem seqCompose_knowledgeSoundness
    (rel : (i : Fin (m + 1)) ‚Üí Set (Stmt i √ó Wit i))
    (V : (i : Fin m) ‚Üí Verifier oSpec (Stmt i.castSucc) (Stmt i.succ) (pSpec i))
    (knowledgeError : Fin m ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (V i).knowledgeSoundness init impl (rel i.castSucc) (rel i.succ) (knowledgeError i)) :
      (Verifier.seqCompose Stmt V).knowledgeSoundness init impl (rel 0) (rel (Fin.last m))
        (‚àë i, knowledgeError i)

private lemma sum_add_one {i : Fin (k + 1)} :
  ‚àë j' ‚àà finRangeTo (i.1 + 1), (s j').1 = (‚àë j' ‚àà finRangeTo i.1, (s j').1) + (s i).1

@[simp]
theorem codeDist'_subsingleton [Subsingleton C] : ‚ÄñC‚Äñ‚ÇÄ' = ‚ä§

lemma towerAlgebraMap_id (k : ‚Ñï) : towerAlgebraMap (h_le:=by omega) = RingHom.id (BTField k)

@[simp]
theorem Reduction.id_runWithLog (stmt : StmtIn) (wit : WitIn) :
    (Reduction.id : Reduction oSpec StmtIn WitIn _ _ _).runWithLog stmt wit =
      pure ‚ü®‚ü®‚ü®default, stmt, wit‚ü©, stmt‚ü©, [], []‚ü©

@[simp, grind _=_]
theorem monomialXY_pow {n m k : ‚Ñï} {a : F} :
  monomialXY n m a ^ k = monomialXY (n * k) (m * k) (a ^ k)

lemma minDist_eq_minDist [DecidableEq F] {IC : LawfulInterleavedCode Œ∫ Œπ F} :
  Code.minDist (IC.1.LC : Set (Œπ ‚Üí F)) = minDist IC.1.MF

theorem succ'_injective : Function.Injective (succ' : Nat ‚Üí Nat)

@[simp, grind _=_]
lemma degreeY_mul [IsDomain F] (f g : F[X][Y]) (hf : f ‚â† 0) (hg : g ‚â† 0)
  : natDegreeY (f * g) = natDegreeY f + natDegreeY g

@[simp]
theorem vcons_fin_zero (a : Œ±) (v : Fin 0 ‚Üí Œ±) : a ::·µõ v = fun i => match i with

@[simp]
theorem hcons_fin_zero {Œ± : Sort u} {Œ≤ : Fin 0 ‚Üí Sort u} (a : Œ±) (v : (i : Fin 0) ‚Üí Œ≤ i) :
    hcons a v = fun i => match i with

@[simp]
theorem removeNth_apply : removeNth p s i = s (p.succAbove i)

theorem stir_main
  (secpar : ‚Ñï) [SelectableType F]
  {Œπ : Type} [Fintype Œπ] [Nonempty Œπ] [DecidableEq Œπ]
  {œÜ : Œπ ‚Ü™ F} {degree : ‚Ñï} [hsmooth : Smooth œÜ]
  {k proofLen qNumtoInput qNumtoProofstr : ‚Ñï}
  (hk : ‚àÉ p, k = 2 ^ p) (hkGe : k ‚â• 4)
  (Œ¥ : ‚Ñù‚â•0) (hŒ¥ub : Œ¥ < 1 - 1.05 * Real.sqrt (degree / Fintype.card Œπ))
  (hF : Fintype.card F ‚â§
        secpar * 2 ^ secpar * degree ^ 2 * (Fintype.card Œπ) ^ (7 / 2) /
          Real.log (1 / rate (code œÜ degree))) :
  ‚àÉ n : ‚Ñï,
  ‚àÉ vPSpec : ProtocolSpec.VectorSpec n,
  ‚àÉ Œµ_rbr : vPSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0,
  ‚àÉ œÄ : VectorIOP Unit (OracleStatement Œπ F) Unit vPSpec F,
  IsSecureWithGap (stirRelation degree œÜ 0)
                  (stirRelation degree œÜ Œ¥)
                  Œµ_rbr œÄ
  ‚àß ‚àÄ i, Œµ_rbr i ‚â§ (1 : ‚Ñö‚â•0) / (2 ^ secpar)
  ‚àß ‚àÉ c > 0, M ‚â§ c * (Real.log degree / Real.log k)
  ‚àß ‚àÉ c‚Çñ : ‚Ñï ‚Üí ‚Ñù, proofLen ‚â§ (Fintype.card Œπ) + (c‚Çñ k) * (Real.log degree)
  ‚àß qNumtoInput = secpar / (- Real.log (1 - Œ¥))
  ‚àß ‚àÉ c‚Çñ : ‚Ñï ‚Üí ‚Ñù, qNumtoProofstr ‚â§
    (c‚Çñ k) * ((Real.log degree) +
      secpar * (Real.log ((Real.log degree) / Real.log (1/rate (code œÜ degree)))))

@[simp]
theorem sumExceptFirst'_degree_le (n : ‚Ñï) (h : n > 0) (D : Fin (n - 1) ‚Üí Finset R)
    (p : MvPolynomial (Fin n) R) : (sumExceptFirst' n h D p).degree ‚â§ p.degreeOf ‚ü®0, h‚ü©

lemma num_eq_highBits_xor_lowBits {n: ‚Ñï} (numLowBits: ‚Ñï) :
  n = getHighBits numLowBits n ^^^ getLowBits numLowBits n

theorem foldCommitOracleReduction_perfectCompleteness
    (hInit : init.neverFails) (i : Fin ‚Ñì) (hCR : isCommitmentRound ‚Ñì œë i) :
    OracleReduction.perfectCompleteness
      (pSpec := pSpecFoldCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)
      (relIn := roundRelation (mp := mp) ùîΩq Œ≤ (œë:=œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) i.castSucc)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë:=œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) i.succ)
      (oracleReduction := foldCommitOracleReduction ùîΩq Œ≤ (œë:=œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) i hCR) (init := init) (impl := impl)

lemma johnson_condition_weak_implies_strong {B : Finset (Fin n ‚Üí F)} {v : Fin n ‚Üí F} {e : ‚Ñï}
  (h : JohnsonConditionWeak B e)
  :
  JohnsonConditionStrong (B ‚à© ({ x | Œî‚ÇÄ(x, v) ‚â§ e } : Finset _)) v

theorem computableTwiddleFactor_eq_twiddleFactor (i : Fin ‚Ñì) :
  computableTwiddleFactor (r := r) (‚Ñì := ‚Ñì) (Œ≤ := Œ≤) (L := L)
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := ‚ü®i, by omega‚ü©) =
  twiddleFactor (ùîΩq := ùîΩq) (L := L) (Œ≤ := Œ≤) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
    (i := ‚ü®i, by omega‚ü©)

private lemma solution_to_BerlekampWelch_condition {e k : ‚Ñï}
  [NeZero n]
  {œâs f : Fin n ‚Üí F}
  {v : Fin (2 * e + k) ‚Üí F}
  (h_sol : IsBerlekampWelchSolution e k œâs f v)
  : BerlekampWelchCondition e k œâs f (solutionToE e k v) (solutionToQ e k v)

lemma concrete_one_ne_zero {k : ‚Ñï} : (one (k:=k)) ‚â† (zero (k:=k))

omit [NoZeroDivisors ùîΩ] in
lemma foldNth_zero {s : ‚Ñï} {Œ± : ùîΩ} : foldNth (2 ^ s) 0 Œ± = 0

@[simp]
theorem cast_id : MessageIdx.cast (Eq.refl n‚ÇÅ) rfl = (id : pSpec‚ÇÅ.MessageIdx ‚Üí _)

lemma concrete_mul_comm
  {h_k : k > 0} (prevBTFieldProps : ConcreteBTFieldProps (k := k - 1))
  (a b : ConcreteBTField k) :
  concrete_mul a b = concrete_mul b a

lemma mul_trans_inequality {k : ‚Ñï} (x : ‚Ñï) (h_k : k ‚â§ 2) (h_x : x ‚â§ 2 ^ (2 ^ k) - 1) : x < 16

Nat.succ_lt_succ_iff in Init.Data.Nat.Basic

theorem nsmul_succ [LawfulBEq R] (n : ‚Ñï) {p : UniPoly R} : nsmul (n + 1) p = nsmul n p + p

@[simp] theorem rightpad_twice_eq_rightpad_max (m n : Nat) (unit : Œ±) (l : List Œ±) :
    rightpad n unit (rightpad m unit l) = rightpad (max m n) unit l

lemma monoToLagrange_eq_monoToLagrange_segment (n : ‚Ñï) [NeZero n] (v : Vector R (2 ^ n)) :
  have h_n_ne_zero: n ‚â† 0

@[simp]
theorem cast_run (stmt : StmtIn) (transcript : FullTranscript pSpec‚ÇÅ) :
    V.run stmt transcript = (V.cast hn hSpec).run stmt (transcript.cast hn hSpec)

lemma subLeftFull_of_vandermonde_is_vandermonde (h : m ‚â§ n) :
  Matrix.vandermonde Œ± = Matrix.subLeftFull (nonsquare n Œ±) (Fin.castLE h)

@[simp]
theorem getRoot_single (a b : Œ±) :
    getRoot Œ± <$> buildMerkleTree Œ± 1 ‚ü®[a, b], rfl‚ü© = (query (spec := spec Œ±) () (a, b))

lemma algebraMap_succ_eq_zero_x {k : ‚Ñï} (h_pos : k > 0) (x : ConcreteBTField (k - 1)) :
  letI instAlgebra := ConcreteBTFieldAlgebra (l:=k-1) (r:=k) (h_le:=by omega)
  algebraMap (ConcreteBTField (k - 1)) (ConcreteBTField k) x = „Ää 0, x „Äã

lemma oracle_block_k_next_le (i : Fin (‚Ñì + 1)) (j : Fin (toOutCodewordsCount ‚Ñì œë i))
    (hj : j.val + 1 < toOutCodewordsCount ‚Ñì œë i) : j.val * œë + œë ‚â§ i

theorem support_C_mul_le (p : MvPolynomial œÉ R) (r : R) : (C r * p).support ‚äÜ p.support

theorem fcons_right_injective {Œ≤ : Fin n ‚Üí A} (a : F Œ±) :
    Function.Injective (fcons a : ((i : Fin n) ‚Üí F (Œ≤ i)) ‚Üí (i : Fin (n + 1)) ‚Üí _)

theorem prime_3 : Nat.Prime 3

omit [Finite F] in
private lemma op_der_eq : Monoid.toMulAction FÀ£ = Units.mulAction'

@[simp]
theorem snoc_zero_zero : snoc (0 : Fin n ‚Üí‚ÇÄ M) 0 = 0

theorem oracleReduction_rbr_knowledge_soundness : True

@[simp]
lemma degreeX_monomialXY {n m : ‚Ñï} {a : F} (ha : a ‚â† 0) :
    degreeX (monomialXY n m a) = n

theorem vappend_singleton (u : Fin m ‚Üí Œ±) (a : Œ±) :
    vappend u (vcons a !v[]) = vconcat u a

theorem range_vcons {Œ± : Type*} (a : Œ±) (v : Fin n ‚Üí Œ±) :
    Set.range (a ::·µõ v) = insert a (Set.range v)

theorem heq_of_dcast (ha : a = a') (hb : dcast ha b = b') : HEq b b'

@[simp]
private lemma evenPart'_coeffs {f : Polynomial F} {n : ‚Ñï} :
    (evenPart' f).coeff n = if Even n then f.coeff n else 0

theorem tail_init_eq_init_tail (s : Fin (n + 2) ‚Üí‚ÇÄ M) : tail (init s) = init (tail s)

lemma towerRingHomForwardMap_mul_eq (k : ‚Ñï) (x y : ConcreteBTField k) :
    towerRingHomForwardMap (k:=k) (x * y)
    = towerRingHomForwardMap (k:=k) x * towerRingHomForwardMap (k:=k) y

theorem completeness_relOut_mono {Œµ : ‚Ñù‚â•0} {relOut' : Set (StmtOut √ó WitOut)}
    (hrelOut : relOut ‚äÜ relOut') :
      completeness init impl relIn relOut reduction Œµ ‚Üí
        completeness init impl relIn relOut' reduction Œµ

lemma eval_liftF_of_lt {f : Fin m ‚Üí F} (h : n < m) :
  eval (liftF f n) p = eval (f ‚ü®n, h‚ü©) p

@[simp]
theorem FullData.get_leaf {Œ±} (a : Œ±) :
    (FullData.leaf a).get SkeletonNodeIndex.ofLeaf = a

lemma concrete_inv_zero {k : ‚Ñï} : concrete_inv (k:=k) 0 = 0

theorem append_rbrKnowledgeSoundness (V‚ÇÅ : OracleVerifier oSpec Stmt‚ÇÅ OStmt‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : OracleVerifier oSpec Stmt‚ÇÇ OStmt‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ pSpec‚ÇÇ)
    {rbrKnowledgeError‚ÇÅ : pSpec‚ÇÅ.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    {rbrKnowledgeError‚ÇÇ : pSpec‚ÇÇ.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    (h‚ÇÅ : V‚ÇÅ.rbrKnowledgeSoundness init impl rel‚ÇÅ rel‚ÇÇ rbrKnowledgeError‚ÇÅ)
    (h‚ÇÇ : V‚ÇÇ.rbrKnowledgeSoundness init impl rel‚ÇÇ rel‚ÇÉ rbrKnowledgeError‚ÇÇ) :
      (V‚ÇÅ.append V‚ÇÇ).rbrKnowledgeSoundness init impl rel‚ÇÅ rel‚ÇÉ
        (Sum.elim rbrKnowledgeError‚ÇÅ rbrKnowledgeError‚ÇÇ ‚àò ChallengeIdx.sumEquiv.symm)

lemma eval_trim_eq_eval [LawfulBEq R] (x : R) (p : UniPoly R) : p.trim.eval x = p.eval x

@[simp]
theorem cast_id :
    OracleProver.cast rfl rfl =
      (id : OracleProver oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec‚ÇÅ ‚Üí _)

@[simp]
lemma Fintype.zero_lt_card {Œπ : Type*} [Fintype Œπ] [Nonempty Œπ] : 0 < Fintype.card Œπ

lemma eval‚ÇÇ_f_eq_C (r : R) (x : P) : eval‚ÇÇ (P := P) (C : R ‚Üí+* P) x (C r) = C r

lemma oddPart_even {f : Polynomial F} :
    EvenPoly (oddPart f)

@[simp] lemma ofMvPolynomialAlgHom_X (s : œÉ) :
    ofMvPolynomialAlgHom (MvPolynomial.X s : MvPolynomial œÉ R) = (X s : P)

@[simp, grind =] lemma R_plus_C_eq_N : sz.R + sz.C = sz.N

lemma add_comm {k : ‚Ñï} (a b : ConcreteBTField k) : a + b = b + a

theorem degrees_peval {x : œÉ‚ÇÅ ‚Üí R} {f : œÉ ‚Üí œÉ‚ÇÅ ‚äï œÉ‚ÇÇ} {p : MvPolynomial œÉ R} :
    (peval f x p).degrees ‚â§ (p.degrees.map f).filterMap Sum.getRight?

lemma degree_W (i : Fin r) : (W ùîΩq Œ≤ i).degree = (Fintype.card ùîΩq)^i.val

theorem add_assoc (a b c : AssocNat) : (a + b) + c = a + (b + c)

theorem decoder_dist_impl_mem
  {k r D e : ‚Ñï}
  (h_e : e ‚â§ n - Real.sqrt (k * n))
  {œâs : Fin n ‚Ü™ F}
  {f : Fin n ‚Üí F}
  {p : F[X]}
  (h_dist : Œî‚ÇÄ(f, p.eval ‚àò œâs) ‚â§ e)
  :
  p ‚àà decoder k r D e œâs f

theorem insertNth_self_removeNth : insertNth p (t p) (removeNth p t) = t

theorem toPoly_add {p q : UniPoly Q} : (add_raw p q).toPoly = p.toPoly + q.toPoly

@[simp]
theorem cast_id :
    Prover.cast rfl rfl = (id : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec‚ÇÅ ‚Üí _)

theorem append_knowledgeSoundness (V‚ÇÅ : OracleVerifier oSpec Stmt‚ÇÅ OStmt‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : OracleVerifier oSpec Stmt‚ÇÇ OStmt‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ pSpec‚ÇÇ)
    {knowledgeError‚ÇÅ knowledgeError‚ÇÇ : ‚Ñù‚â•0}
    (h‚ÇÅ : V‚ÇÅ.knowledgeSoundness init impl rel‚ÇÅ rel‚ÇÇ knowledgeError‚ÇÅ)
    (h‚ÇÇ : V‚ÇÇ.knowledgeSoundness init impl rel‚ÇÇ rel‚ÇÉ knowledgeError‚ÇÇ) :
      (V‚ÇÅ.append V‚ÇÇ).knowledgeSoundness init impl rel‚ÇÅ rel‚ÇÉ
        (knowledgeError‚ÇÅ + knowledgeError‚ÇÇ)

omit [DecidableEq L] [Fintype ùîΩq] hŒ≤_lin_indep in
lemma W‚ÇÄ_eq_X : W ùîΩq Œ≤ 0 = X

lemma rank_nonsquare_eq_deg_of_Œπ_le (inj : Function.Injective Œ±) (h : m ‚â§ n) :
  (Vandermonde.nonsquare (Œπ' := n) Œ±).rank = m

omit [Finite F] in
lemma dom_n_eq_triv : evalDomain D n = ‚ä•

@[simp]
theorem simulateQ'_query (q : OracleQuery spec Œ±) :
    simulateQ' so q (by simp) = so.impl q

@[simp]
theorem zero_vappend {u : Fin 0 ‚Üí Œ±} (v : Fin n ‚Üí Œ±) :
    vappend u v = v ‚àò Fin.cast (Nat.zero_add n)

lemma natDeg_sum_eq_of_unique {Œ± : Type} {s : Finset Œ±} {f : Œ± ‚Üí F[X]} {deg : ‚Ñï}
  (mx : Œ±) (h : mx ‚àà s) :
    (f mx).natDegree = deg ‚Üí
    (‚àÄ y ‚àà s, y ‚â† mx ‚Üí (f y).natDegree < deg ‚à® f y = 0) ‚Üí
    (‚àë x ‚àà s, f x).natDegree = deg

private lemma eval_solutionToQ_aux {i : Fin ((solutionToQ e k v).natDegree + 1)} [NeZero e]
  : e + i < 2 * e + k

@[simp]
lemma zero_mem_relHammingDistRange : 0 ‚àà relHammingDistRange Œπ

theorem liftContext_rbr_soundness [Inhabited InnerStmtOut]
    {outerLangIn : Set OuterStmtIn} {outerLangOut : Set OuterStmtOut}
    {innerLangIn : Set InnerStmtIn} {innerLangOut : Set InnerStmtOut}
    {rbrSoundnessError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    {lens : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut}
    (V : Verifier oSpec InnerStmtIn InnerStmtOut pSpec)
    -- TODO: figure out the right compatibility relation for the IsSound condition
    [lensSound : lens.IsSound outerLangIn outerLangOut innerLangIn innerLangOut
      (V.compatStatement lens)]
    (h : V.rbrSoundness init impl innerLangIn innerLangOut rbrSoundnessError) :
      (V.liftContext lens).rbrSoundness init impl outerLangIn outerLangOut rbrSoundnessError

lemma degree_s_smul_X_add_1 {F : Type*} [Field F] [Fintype F] (s : F) [NeZero s] :
  (C s * (X : (F)[X]) + 1).degree = 1

@[simp]
theorem eq_accepts (i : Fin numWires) (c : ùì°) (x : Fin numWires ‚Üí ùì°) :
    (eq i c).accepts x ‚Üî x i = c

lemma sub_descends [LawfulBEq R] (a‚ÇÅ b‚ÇÅ a‚ÇÇ b‚ÇÇ : UniPoly R) :
  equiv a‚ÇÅ a‚ÇÇ ‚Üí equiv b‚ÇÅ b‚ÇÇ ‚Üí sub_descending a‚ÇÅ b‚ÇÅ = sub_descending a‚ÇÇ b‚ÇÇ

@[to_additive /-- A variant of `Finset.add_sum_erase` with the addition swapped.--/]
theorem prod_mul_erase {Œ± Œ≤ : Type*} [CommMonoid Œ≤] [DecidableEq Œ±] (s : Finset Œ±) (f : Œ± ‚Üí Œ≤)
{a : Œ±} (h : a ‚àà s) : f a * (‚àè x ‚àà s.erase a, f x) = ‚àè x ‚àà s, f x

lemma forwardRange_0_eq_finRange (n : ‚Ñï) [NeZero n] : forwardRange n ‚ü®n - 1, by
    have h_ne

lemma nonDoomedFoldingProp_relay_preserved (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i)
    (challenges : Fin i.succ ‚Üí L)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j)
    :
    nonDoomedFoldingProp ùîΩq Œ≤ i.castSucc (Fin.init challenges) oStmt ‚Üî
    nonDoomedFoldingProp ùîΩq Œ≤ i.succ challenges (mapOStmtOutRelayStep ùîΩq Œ≤ i hNCR oStmt)

lemma Nat.Prime.dvd_mul_list {p : ‚Ñï} {l : List ‚Ñï} (h : p.Prime) :
    p ‚à£ l.prod ‚Üî ‚àÉ r ‚àà l, p ‚à£ r

lemma combine_eq_cases {F Œπ : Type*} [Field F] [DecidableEq F]
  (œÜ : Œπ ‚Ü™ F) (dstar : ‚Ñï) (r : F) (fs : Fin m ‚Üí Œπ ‚Üí F) (degs : Fin m ‚Üí ‚Ñï)
    (hdegs : ‚àÄ i, degs i ‚â§ dstar) (œÜ_neq_0 : ‚àÄ i, œÜ i ‚â† 0) :
  combine œÜ dstar r fs degs =
    fun x =>
      let q := œÜ x * r
      if q ‚â† 1
      then ‚àë i, (ri dstar degs r i) * (fs i x) * (1 - q^(dstar - degs i + 1)) / (1 - q)
      else ‚àë i, (ri dstar degs r i) * (fs i x) *  (dstar - degs i + 1)

omit [Fintype L] [DecidableEq L] [Fintype ùîΩq] h_Fq_char_prime hŒ≤_lin_indep in
lemma Œ≤_lt_mem_U (i : Fin r) (j : Fin i) :
  Œ≤ ‚ü®j, by omega‚ü© ‚àà U ùîΩq Œ≤ (i:=i)

@[simp]
lemma coe_toFun_of_coe_apply (f : ‚àÄ a, Œ≤ a) (a : Œ±) : (f : F) a = f a

lemma relHammingDist_le_blockRelDistance
  (i k : ‚Ñï) {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F} {œÜ' : (indexPowT S œÜ i) ‚Ü™ F}
  [DecidableEq F] [DecidableEq Œπ] [Smooth œÜ]
  (f g : (indexPowT S œÜ i) ‚Üí F) (S' : Finset (indexPowT S œÜ i))
  [h_fintype : ‚àÄ i : ‚Ñï, Fintype (indexPowT S œÜ i)]
  [DecidableEq (indexPowT S œÜ i)] [Smooth œÜ']
  [h_dec : DecidableBlockDisagreement i k f S' œÜ'] :
  Œ¥·µ£(f, g) ‚â§ Œî·µ£(i, k, f, S', œÜ', g)

theorem fcons‚ÇÇ_left_injective {Œ±‚ÇÅ : A} {Œ±‚ÇÇ : B} {Œ≤‚ÇÅ : Fin n ‚Üí A} {Œ≤‚ÇÇ : Fin n ‚Üí B}
    (b : (i : Fin n) ‚Üí F‚ÇÇ (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) :
    Function.Injective (fun a : F‚ÇÇ Œ±‚ÇÅ Œ±‚ÇÇ => fcons‚ÇÇ (F := F‚ÇÇ) a b)

theorem empty_unique (v : Fin 0 ‚Üí Œ±) : v = !v[]

lemma getBit_of_multiple_of_power_of_two {n p : ‚Ñï}: ‚àÄ k,
  getBit (k) (2^p * n) = if k < p then 0 else getBit (k-p) n

lemma Polishchuk_Spielman {F : Type} [Field F]
  (a_x a_y b_x b_y : ‚Ñï) (n_x n_y : ‚Ñï+)
  (h_bx_ge_ax : b_x ‚â• a_x) (h_by_ge_ay : b_y ‚â• a_y)
  (A B : F[X][Y])
  (h_f_degX : a_x ‚â• Bivariate.degreeX A) (h_g_degX : b_x ‚â• Bivariate.degreeX B)
  (h_f_degY : a_y ‚â• natDegreeY A) (h_g_degY : b_y ‚â• natDegreeY B)
  (P_x P_y : Finset F) [Nonempty P_x] [Nonempty P_y]
  (quot_X : F ‚Üí F[X]) (quot_Y : F ‚Üí F[X])
  (h_card_Px : n_x ‚â§ P_x.card) (h_card_Py : n_y ‚â§ P_y.card)
  (h_quot_X : ‚àÄ y ‚àà P_y,
    (quot_X y).natDegree ‚â§ (b_x - a_x) ‚àß Bivariate.evalY y B = (quot_X y) * (Bivariate.evalY y A))
  (h_quot_Y : ‚àÄ x ‚àà P_x,
    (quot_Y x).natDegree ‚â§ (b_y - a_y) ‚àß Bivariate.evalX x B = (quot_Y x) * (Bivariate.evalX x A))
  (h_le_1 : 1 > (b_x : ‚Ñö) / (n_x : ‚Ñö) + (b_y : ‚Ñö) / (n_y : ‚Ñö))
  : ‚àÉ P : F[X][Y], B = P * A
    ‚àß Bivariate.degreeX P ‚â§ b_x - a_x ‚àß natDegreeY P ‚â§ b_y - a_y
    ‚àß (‚àÉ Q_x : Finset F, Q_x.card ‚â• n_x - a_x ‚àß Q_x ‚äÜ P_x ‚àß
        ‚àÄ x ‚àà Q_x, Bivariate.evalX x P = quot_Y x)
    ‚àß (‚àÉ Q_y : Finset F, Q_y.card ‚â• n_y - a_y ‚àß Q_y ‚äÜ P_y ‚àß
        ‚àÄ y ‚àà Q_y, Bivariate.evalX y P = quot_X y)

theorem liftContext_run
    {lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    {outerStmtIn : OuterStmtIn} {outerWitIn : OuterWitIn}
    {P : Prover oSpec InnerStmtIn InnerWitIn InnerStmtOut InnerWitOut pSpec} :
      (P.liftContext lens).run outerStmtIn outerWitIn
      = do
        let ‚ü®fullTranscript, innerCtxOut‚ü© ‚Üê
          P.run.uncurry (lens.proj (outerStmtIn, outerWitIn))
        return ‚ü®fullTranscript, lens.lift (outerStmtIn, outerWitIn) innerCtxOut‚ü©

@[simp]
theorem dflatten_succ {m : ‚Ñï} {n : Fin (m + 1) ‚Üí ‚Ñï} {motive : (k : Fin (vsum n)) ‚Üí Sort*}
    {v : (i : Fin (m + 1)) ‚Üí (j : Fin (n i)) ‚Üí motive (embedSum i j)} :
    dflatten (motive := motive) v = dappend (v 0) (dflatten (fun i => v i.succ))

theorem foldr_split_outer {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤ ‚Üí Œ≤) (init : Œ≤)
    (l : List Œ±) (h : l ‚â† []): foldr (f:=f) (init:=init) (l)
    = f (l.head (by omega)) (foldr (f:=f) (init:=init) (l.tail))

Fin.append_right in Mathlib.Data.Fin.Tuple.Basic

@[simp]
theorem OracleSpec.append_range_right {Œπ‚ÇÅ Œπ‚ÇÇ : Type} {spec‚ÇÅ : OracleSpec Œπ‚ÇÅ} {spec‚ÇÇ : OracleSpec Œπ‚ÇÇ}
    (i : Œπ‚ÇÇ) : (spec‚ÇÅ ++‚Çí spec‚ÇÇ).range (Sum.inr i) = spec‚ÇÇ.range i

lemma oodSampling_rs_le_bound
    {f : Œπ ‚Üí F} {m s : ‚Ñï} {œÜ : Œπ ‚Ü™ F} [Smooth œÜ]
    (Œ¥ l : ‚Ñù‚â•0) (hŒ¥Le : Œ¥ ‚â§ 1)
    (C : Set (Œπ ‚Üí F)) (hcode : C = smoothCode œÜ m ‚àß listDecodable C Œ¥ l) :
    Pr_{ let rs ‚Üê$·µñ (Fin s ‚Üí F) }[ ‚àÉ u u' : smoothCode œÜ m,
                        u.val ‚â† u'.val ‚àß
                        u.val ‚àà relHammingBall C f Œ¥ ‚àß
                        u'.val ‚àà relHammingBall C f Œ¥ ‚àß
                        ‚àÄ i : Fin s,
                          let ri := rs i
                          let rVec := fun j : Fin m => ri ^ (2^(j : ‚Ñï))
                          (mVdecode u).eval (rVec) = (mVdecode u').eval (rVec)
                      ] ‚â§ ENNReal.ofReal (((l : ‚Ñù)^2 / 2) * (((2^m : ‚Ñù) / Fintype.card F)^s))

lemma probOfBadPts {deg : ‚Ñï} {Œ± : Œπ ‚Ü™ F} {e : ‚Ñï} {U : Matrix Œ∫ Œπ F}
  (he : (e : ‚Ñö) < (Code.minDist (RScodeSet Œ± deg) : ‚Ñö) / 3)
  (hU : e < Œî(U, matrixSubmoduleOfLinearCode Œ∫ (ReedSolomon.code Œ± deg))) :
  (PMF.uniformOfFintype (Matrix.rowSpan U)).toOuterMeasure
    { w | distFromCode (n := Œπ) (R := F) w (ReedSolomon.code Œ± deg) ‚â§ e }
  ‚â§ (Code.minDist (RScodeSet Œ± deg) : ‚Ñù‚â•0) /(Fintype.card F : ‚Ñù‚â•0)

theorem is_prime : Nat.Prime fieldSize

theorem linear_map_of_comp_to_linear_map_of_eval (f : L[X])
  (h_f_linear : IsLinearMap (R := Fq) (M := L[X]) (M‚ÇÇ := L[X])
    (f := fun inner_p ‚Ü¶ f.comp inner_p)) :
    IsLinearMap (R := Fq) (M := L) (M‚ÇÇ := L) (f := fun x ‚Ü¶ f.eval x)

lemma divide_by_2_def {s : Finset ‚Ñï} :
    divide_by_2 s = (erase_odd s).image (fun n => n / 2)

theorem hconcat_eq_snoc {Œ± : Fin n ‚Üí Sort u} {Œ≤ : Sort u} (v : (i : Fin n) ‚Üí Œ± i) (b : Œ≤) :
    hconcat v b = snoc (Œ± := vconcat Œ± Œ≤)
      (fun i => cast (vconcat_castSucc _ _ i).symm (v i))
      (cast (vconcat_last _ _).symm b)

theorem fconcat‚ÇÇ_left_injective {Œ±‚ÇÅ : Fin n ‚Üí A} {Œ±‚ÇÇ : Fin n ‚Üí B} {Œ≤‚ÇÅ : A} {Œ≤‚ÇÇ : B} (a : F‚ÇÇ Œ≤‚ÇÅ Œ≤‚ÇÇ) :
    Function.Injective (fun v : (i : Fin n) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i) => fconcat‚ÇÇ (F := F‚ÇÇ) v a)

theorem getBit_repr {‚Ñì : Nat} : ‚àÄ j, j < 2^‚Ñì ‚Üí
  j = ‚àë k ‚àà Finset.Icc 0 (‚Ñì-1), (getBit k j) * 2^k

@[simp]
theorem fappend‚ÇÇ_right {Œ±‚ÇÅ : Fin m ‚Üí A} {Œ±‚ÇÇ : Fin m ‚Üí B} {Œ≤‚ÇÅ : Fin n ‚Üí A} {Œ≤‚ÇÇ : Fin n ‚Üí B}
    (u : (i : Fin m) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i)) (v : (i : Fin n) ‚Üí F‚ÇÇ (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) (i : Fin n) :
    fappend‚ÇÇ (F := F‚ÇÇ) u v (natAdd m i) =
      cast (by simp [vappend_right]) (v i)

lemma rootMultiplicity_W (i : Fin r) (a : L) :
    rootMultiplicity a (W ùîΩq Œ≤ i) = if a ‚àà (U ùîΩq Œ≤ i : Set L) then 1 else 0

theorem append_run (stmt : Stmt‚ÇÅ) (wit : Wit‚ÇÅ) :
      (P‚ÇÅ.append P‚ÇÇ).run stmt wit = (do
        let ‚ü®transcript‚ÇÅ, stmt‚ÇÇ, wit‚ÇÇ‚ü© ‚Üê liftM (P‚ÇÅ.run stmt wit)
        let ‚ü®transcript‚ÇÇ, stmt‚ÇÉ, wit‚ÇÉ‚ü© ‚Üê liftM (P‚ÇÇ.run stmt‚ÇÇ wit‚ÇÇ)
        return ‚ü®transcript‚ÇÅ ++‚Çú transcript‚ÇÇ, stmt‚ÇÉ, wit‚ÇÉ‚ü©)

lemma if_zero_then_zero_else_self (x : ConcreteBTField 0) :
  (if x = zero then zero else x) = x

@[simp]
theorem ranges_nil : List.ranges [] = []

@[simp]
theorem dcast_trans (h : a = a') (h' : a' = a'') :
    dcast h' (dcast h b) = dcast (h.trans h') b

lemma split_algebraMap_eq_zero_x {k : ‚Ñï} (h_pos : k > 0) (x : BTField (k - 1)) :
  letI instAlgebra := binaryAlgebraTower (l:=k-1) (r:=k) (h_le:=by omega)
  split (k:=k) (h_k:=h_pos) (algebraMap (BTField (k - 1)) (BTField k) x) = (0, x)

@[simp]
protected lemma elocPoly_zero : ElocPoly 0 œâs f p = 1

lemma neg_mod_2_eq_0_iff_mod_2_eq_0 {n : ‚Ñ§} : ( - n) % 2 = 0 ‚Üî n % 2 = 0

@[simp]
lemma seqCompose_succ {m : ‚Ñï}
    (Stmt : Fin (m + 2) ‚Üí Type)
    {Œπ‚Çõ : Fin (m + 2) ‚Üí Type} (OStmt : (i : Fin (m + 2)) ‚Üí Œπ‚Çõ i ‚Üí Type)
    [O‚Çõ : ‚àÄ i, ‚àÄ j, OracleInterface (OStmt i j)]
    {n : Fin (m + 1) ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    [O‚Çò : ‚àÄ i, ‚àÄ j, OracleInterface ((pSpec i).Message j)]
    (V : (i : Fin (m + 1)) ‚Üí OracleVerifier oSpec
      (Stmt i.castSucc) (OStmt i.castSucc) (Stmt i.succ) (OStmt i.succ) (pSpec i)) :
    seqCompose Stmt OStmt V =
      append (V 0) (seqCompose (Stmt ‚àò Fin.succ) (fun i => OStmt (Fin.succ i))
        (O‚Çõ := fun i => O‚Çõ (Fin.succ i)) (O‚Çò := fun i => O‚Çò (Fin.succ i))
          (fun i => V (Fin.succ i)))

lemma roots_W (i : Fin r) : -- converts root Multiset into (univ: U·µ¢.val.map)
  (W ùîΩq Œ≤ i).roots = (univ : Finset (U ùîΩq Œ≤ i)).val.map (fun u => u.val)

theorem prime_11 : Nat.Prime 11

pow_one in Mathlib.Algebra.Group.Defs

Nat.pow_lt_pow_right in Init.Data.Nat.Lemmas

theorem split_of_join {k : ‚Ñï} (h_pos : k > 0) (x : ConcreteBTField k)
    (hi_btf lo_btf : ConcreteBTField (k - 1))
    (h_join : x = „Äähi_btf, lo_btf„Äã) :
    (hi_btf, lo_btf) = split h_pos x

@[simp]
theorem removeNth_zero : removeNth 0 s = tail s

lemma towerRingHomForwardMap_split_eq (k : ‚Ñï) (h_pos : k > 0) (x : ConcreteBTField k) :
  let p := split (k:=k) (h:=h_pos) x
  towerRingHomForwardMap (k:=k) (x) =
    BinaryTower.join_via_add_smul (k:=k) (h_pos:=h_pos)
      (hi_btf := towerRingHomForwardMap (k:=k-1) (p.1))
      (lo_btf := towerRingHomForwardMap (k:=k-1) (p.2))

theorem is_prime : Nat.Prime fieldSize

@[simp]
theorem LeafData.get_ofLeft {s_left s_right : Skeleton} {Œ± : Type}
    (tree : LeafData Œ± (Skeleton.internal s_left s_right))
    (idxLeft : SkeletonLeafIndex s_left) :
    tree.get (SkeletonLeafIndex.ofLeft idxLeft) =
      tree.leftSubtree.get idxLeft

lemma extract_stop_last_eq_drop {n : ‚Ñï} {Œ± : Fin n ‚Üí Sort*} (start : ‚Ñï) (h : start ‚â§ n)
    (v : (i : Fin n) ‚Üí Œ± i) : extract start n h (Nat.le_refl _) v = drop start h v

theorem join_eq_join_iff {k : ‚Ñï} (h_pos : k > 0) (hi‚ÇÄ lo‚ÇÄ hi‚ÇÅ lo‚ÇÅ : ConcreteBTField (k - 1)) :
  „Ää hi‚ÇÄ, lo‚ÇÄ „Äã = „Ää hi‚ÇÅ, lo‚ÇÅ „Äã ‚Üî (hi‚ÇÄ = hi‚ÇÅ ‚àß lo‚ÇÄ = lo‚ÇÅ)

@[simp]
lemma liftF_succ {f : Fin (n + 1) ‚Üí Œ±} : liftF f n = f ‚ü®n, Nat.lt_add_one _‚ü©

@[simp, grind _=_]
theorem totalDegree_mul {f g : F[X][Y]} (hf : f ‚â† 0) (hg : g ‚â† 0) :
    totalDegree (f * g) = totalDegree f + totalDegree g

@[simp]
theorem embedSum_zero {n : Fin 0 ‚Üí ‚Ñï} {i : Fin 0} (j : Fin (n i)) : embedSum i j = i

theorem BitVec.extractLsb_eq_and_pow_2_minus_1_ofNat {n num_bits : Nat}
  (h_num_bits : num_bits > 0) (x : BitVec n) :
  BitVec.extractLsb (hi:= num_bits - 1) (lo := 0) x =
    BitVec.ofNat (num_bits - 1 - 0 + 1) (x.toNat &&& (2 ^ num_bits - 1))

theorem sum_le_of_divSum?_eq_some {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {k : Fin (‚àë j, n j)} {i : Fin m}
    (hi : divSum? n k = some i) : ‚àë j : Fin i, n (castLE i.isLt.le j) ‚â§ k

@[simp]
theorem runWithOracle_freeMonad_pure (f : spec.FunctionType) (a : Option Œ±) :
    runWithOracle f (FreeMonad.pure a) = a

private lemma k_choose_2 [Zero F] {B : Finset (Fin n ‚Üí F)}
  (h_n : n ‚â† 0)
  (h_B : B.card ‚â† 0)
  :
  n * choose_2 (k B) ‚â§ ‚àë i, choose_2 (K B i 0)

lemma xor_of_and_eq_zero_is_or {n m : ‚Ñï} (h_n_AND_m : n &&& m = 0) : n ^^^ m = n ||

theorem split_bitvec_eq_iff_fromNat {k : ‚Ñï} (h_pos : k > 0) (x : ConcreteBTField k)
  (hi_btf lo_btf : ConcreteBTField (k - 1)) :
  split h_pos x = (hi_btf, lo_btf) ‚Üî
  (hi_btf = fromNat (k:=k - 1) (x.toNat >>> 2 ^ (k - 1)) ‚àß
  lo_btf = fromNat (k:=k - 1) (x.toNat &&& (2 ^ (2 ^ (k - 1)) - 1)))

lemma cast_join {k n : ‚Ñï} (h_pos : k > 0) (hi lo : ConcreteBTField (k - 1)) (heq : k = n) :
  join (k:=k) h_pos hi lo = cast (by rw [heq])
    (join (k:=n) (by omega) (cast (by subst heq; rfl) hi) (lo:=cast (by subst heq; rfl) lo))

theorem hconcat_inj {Œ± : Fin n ‚Üí Sort u} {Œ≤ : Sort u} (v‚ÇÅ v‚ÇÇ : (i : Fin n) ‚Üí Œ± i) (a‚ÇÅ a‚ÇÇ : Œ≤) :
    hconcat v‚ÇÅ a‚ÇÅ = hconcat v‚ÇÇ a‚ÇÇ ‚Üî v‚ÇÅ = v‚ÇÇ ‚àß a‚ÇÅ = a‚ÇÇ

List.le_sum_of_mem in Mathlib.Algebra.Order.BigOperators.Group.List

theorem base_intermediateNovelBasisX (j : Fin (2 ^ ‚Ñì)) :
  intermediateNovelBasisX ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®0, by
    by_contra ht
    simp only [not_lt, nonpos_iff_eq_zero] at ht
    contradiction
  ‚ü© j =
  X‚±º ùîΩq Œ≤ ‚Ñì (by omega) j

@[simp]
theorem rtake_append_right (T : FullTranscript pSpec‚ÇÅ) (T' : FullTranscript pSpec‚ÇÇ) :
    (T ++‚Çú T').rtake n (Nat.le_add_left n m) =
      T'.cast rfl (by simp [ProtocolSpec.append])

@[simp]
lemma liftF_zero_eq_zero
  : liftF (fun (_ : Fin n) ‚Ü¶ (0 : Œ±)) = (fun _ ‚Ü¶ (0 : Œ±))

@[simp]
theorem dist_subsingleton {C : Set (n ‚Üí R)} [Subsingleton C] : ‚ÄñC‚Äñ‚ÇÄ = 0

theorem sumcheck_roundPoly_degreeLE (i : Fin (n + 1)) {challenges : Fin i.castSucc ‚Üí R}
    {poly : R[X Fin (n + 1)]} (hp : poly ‚àà R‚¶É‚â§ deg‚¶Ñ[X Fin (n + 1)]) :
      ‚àë x ‚àà (univ.map D) ^·∂† (n - i), poly ‚∏®X ‚¶Éi‚¶Ñ, challenges, x‚∏©'
        (by simp; omega) ‚àà R‚¶É‚â§ deg‚¶Ñ[X]

@[simp]
lemma evenPart_by_2 :
  2 * (evenPart f) = f + f.comp (-X)

theorem happend_eq_addCases {Œ± : Fin m ‚Üí Sort u} {Œ≤ : Fin n ‚Üí Sort u}
    (u : (i : Fin m) ‚Üí Œ± i) (v : (i : Fin n) ‚Üí Œ≤ i) :
    happend u v = addCases (motive := vappend Œ± Œ≤)
      (fun i => cast (vappend_left Œ± Œ≤ i).symm (u i))
      (fun i => cast (vappend_right Œ± Œ≤ i).symm (v i))

protected lemma elocPolyF_ne_zero {œâs f : Fin m ‚Üí F} :
  ElocPolyF œâs f p ‚â† 0

@[simp]
theorem MLE_eval_zeroOne (x : œÉ ‚Üí Fin 2) (evals : (œÉ ‚Üí Fin 2) ‚Üí R) :
    MvPolynomial.eval (x : œÉ ‚Üí R) (MLE evals) = evals x

private lemma k_and_e [Zero F]
  (h_n : n ‚â† 0)
  (h_B : B.card ‚â† 0)
  :
  k B = B.card * (n - e B 0) / n

@[simp]
lemma range_def : (spec Œ±).range () = Œ±

theorem dinit_hconcat {Œ± : Fin n ‚Üí Sort u} {Œ≤ : Sort u} (v : (i : Fin n) ‚Üí Œ± i) (b : Œ≤) :
    True

lemma rank_eq_rowRank : U.rank = rowRank U

theorem support_C {r : R} [h : Decidable (r = 0)] :
    (@C R œÉ _ r).support = if r = 0 then ‚àÖ else { 0 }

Fin.is_le' in Init.Data.Fin.Lemmas

@[simp]
lemma Verifier.id_rbrSoundness {lang : Set Statement} :
    (Verifier.id : Verifier oSpec Statement _ _).rbrSoundness init impl lang lang 0

theorem srKnowledgeSoundness_implies_knowledgeSoundness
    (relIn : Set (StmtIn √ó WitIn)) (relOut : Set (StmtOut √ó WitOut))
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    (srInit : ProbComp (srChallengeOracle StmtIn pSpec).FunctionType)
    (srImpl : QueryImpl oSpec (StateT (srChallengeOracle StmtIn pSpec).FunctionType ProbComp))
    (srKnowledgeError : ‚Ñù‚â•0) :
      Verifier.StateRestoration.knowledgeSoundness srInit srImpl relIn relOut
        verifier srKnowledgeError ‚Üí
      knowledgeSoundness init impl relIn relOut verifier srKnowledgeError

@[simp]
theorem choose_2_convex : ConvexOn ‚Ñö Set.univ choose_2

theorem induction_init {n : ‚Ñï} {motive : Fin (n + 2) ‚Üí Sort*} {zero : motive 0}
    {succ : ‚àÄ i : Fin (n + 1), motive i.castSucc ‚Üí motive i.succ} {i : Fin (n + 1)} :
      induction (motive := motive) zero succ i.castSucc =
        induction (motive := Fin.init motive) zero (fun j x => succ j.castSucc x) i

@[simp]
lemma getTypes_hcons (x : Œ£ Œ± : Type u, Œ±) (xs : HList) :
    (x ::‚Çï xs).getTypes = x.1 :: xs.getTypes

omit [Fintype L] [DecidableEq L] in
theorem Polynomial.comp_same_inner_eq_if_same_outer (f g : L[X]) (h_f_eq_g : f = g) :
  ‚àÄ x, f.comp x = g.comp x

theorem pred_succ {T : Type u} [HasSucc T] [Zero T] [ToNat T] (x : Cayley T) :
    pred (succ x) = x

lemma cube_map_bijective :
    Function.Bijective (fun x : (Field)À£ => x ^ (3 : Nat))

@[simp]
theorem dcast‚ÇÇ_eq : dcast‚ÇÇ (Eq.refl a) dcast_eq c = c

theorem one_le_sub_consecutive_two_pow (n : ‚Ñï): 1 ‚â§ 2^(n+1) - 2^n

theorem qMap_total_fiber_disjoint
  (i : Fin ‚Ñì) (steps : ‚Ñï) (h_i_add_steps : i + steps ‚â§ ‚Ñì)
  {y‚ÇÅ y‚ÇÇ : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i.val + steps, by omega‚ü©}
  (hy_ne : y‚ÇÅ ‚â† y‚ÇÇ) :
  Disjoint
    ((qMap_total_fiber ùîΩq Œ≤ (i := ‚ü®i, by omega‚ü©) (steps := steps)
      (h_i_add_steps := fin_‚Ñì_steps_lt_‚Ñì_add_R i steps h_i_add_steps) y‚ÇÅ '' Set.univ).toFinset)
    ((qMap_total_fiber ùîΩq Œ≤ (i := ‚ü®i, by omega‚ü©) (steps := steps)
      (h_i_add_steps := fin_‚Ñì_steps_lt_‚Ñì_add_R i steps h_i_add_steps) y‚ÇÇ '' Set.univ).toFinset)

theorem ofFn_rtake_get {Œ± : Type*} {m : ‚Ñï} (l : List Œ±) (h : m ‚â§ l.length) :
    List.ofFn (rtake m h l.get) = l.rtake m

private lemma almost_johnson_choose_2_elimed [Zero F]
  (h_n : 0 < n)
  (h_B : 2 ‚â§ B.card)
  (h_card : 2 ‚â§ Fintype.card F)
  :
  (k B * (k B - 1)  +
    (B.card - k B) * ((B.card - k B)/(Fintype.card F-1) - 1))
  ‚â§
  B.card * (B.card - 1) * (n - d B)/n

@[simp]
theorem oracleReduction_completeness (h : init.neverFails) :
    (oracleReduction oSpec Statement OStatement pred).perfectCompleteness init impl
    (toRelInput pred hPred) Set.univ

@[simp]
theorem rtake_append_right :
    (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).rtake n (Nat.le_add_left n m) = pSpec‚ÇÇ

lemma toImpl_elim (p : Q[X]) :
    (p = 0 ‚àß p.toImpl = #[])
  ‚à® (p ‚â† 0 ‚àß p.toImpl = .ofFn (fun i : Fin (p.natDegree + 1) => p.coeff i))

@[simp, grind =]
theorem leadingCoeffY_eq_zero (f : F[X][Y]) : leadingCoeffY f = 0 ‚Üî f = 0
</all_available_lemmas>

<local_ctx>
import ArkLib.Data.CodingTheory.BerlekampWelch.BerlekampWelch

import ArkLib.Data.CodingTheory.ReedSolomon

import ArkLib.Data.FieldTheory.AdditiveNTT.AdditiveNTT

import ArkLib.Data.MvPolynomial.Multilinear

import ArkLib.Data.Vector.Basic

import ArkLib.ProofSystem.Sumcheck.Spec.SingleRound

namespace Binius.BinaryBasefold

open OracleSpec OracleComp ProtocolSpec Finset AdditiveNTT Polynomial MvPolynomial
  Binius.BinaryBasefold

open scoped NNReal

open ReedSolomon Code BerlekampWelch

open Finset AdditiveNTT Polynomial MvPolynomial Nat Matrix

section Preliminaries

variable {L : Type} [CommRing L] (‚Ñì : ‚Ñï) [NeZero ‚Ñì]

variable (ùìë : Fin 2 ‚Ü™ L)

end Preliminaries

noncomputable section       -- expands with ùîΩq in front

variable {r : ‚Ñï} [NeZero r]

variable {L : Type} [Field L] [Fintype L] [DecidableEq L] [CharP L 2]

variable (ùîΩq : Type) [Field ùîΩq] [Fintype ùîΩq] [DecidableEq ùîΩq]
  [h_Fq_char_prime : Fact (Nat.Prime (ringChar ùîΩq))] [hF‚ÇÇ : Fact (Fintype.card ùîΩq = 2)]

variable [Algebra ùîΩq L]

variable (Œ≤ : Fin r ‚Üí L) [hŒ≤_lin_indep : Fact (LinearIndependent ùîΩq Œ≤)]
  [h_Œ≤‚ÇÄ_eq_1 : Fact (Œ≤ 0 = 1)]

variable {‚Ñì ùì° œë : ‚Ñï} (Œ≥_repetitions : ‚Ñï) [NeZero ‚Ñì] [NeZero ùì°] [NeZero œë] -- Should we allow ‚Ñì = 0?

variable {h_‚Ñì_add_R_rate : ‚Ñì + ùì° < r} -- ‚Ñì ‚àà {1, ..., r-1}

variable {ùìë : Fin 2 ‚Ü™ L}

section Essentials

noncomputable def fiber_coeff
    (i : Fin r) (steps : ‚Ñï)
    (j : Fin (‚Ñì + ùì° - i)) (elementIdx : Fin (2 ^ steps))
    (y_coeffs : Fin (‚Ñì + ùì° - (i + steps)) ‚Üí‚ÇÄ ùîΩq) : ùîΩq :=
  if hj : j.val < steps then
    if Nat.getBit (k := j) (n := elementIdx) = 0 then 0 else 1
  else y_coeffs ‚ü®j.val - steps, by admit /- proof elided -/
    ‚ü©

noncomputable def qMap_total_fiber
    
      (i : Fin r) (steps : ‚Ñï) (h_i_add_steps : i.val + steps < ‚Ñì + ùì°)
        (y : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i.val + steps, by admit /- proof elided -/
        ‚ü©)) :
    Fin (2 ^ steps) ‚Üí sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i :=
  if h_steps : steps = 0 then by
    
    subst h_steps
    simp only [add_zero, Fin.eta] at y
    exact fun _ => y
  else by
    
    let basis_y := sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i+steps,by admit /- proof elided -/
    ‚ü©) (by admit /- proof elided -/
    )
    let y_coeffs : Fin (‚Ñì + ùì° - (‚Üëi + steps)) ‚Üí‚ÇÄ ùîΩq := basis_y.repr y

    let basis_x := sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i, by admit /- proof elided -/
    ‚ü© (by admit /- proof elided -/
    )
    exact fun elementIdx => by admit /- proof elided -/

def pointToIterateQuotientIndex (i : Fin (‚Ñì + 1)) (steps : ‚Ñï) (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
    (x : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i, by omega‚ü©)) : Fin (2 ^ steps) :=
</local_ctx>

<target_theorem>
theorem is_fiber_iff_generates_quotient_point (i : Fin ‚Ñì) (steps : ‚Ñï)
    (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
    (x : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i, by omega‚ü©))
    (y : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i.val + steps, by omega‚ü©)) :
    let qMapFiber :=
</target_theorem>

