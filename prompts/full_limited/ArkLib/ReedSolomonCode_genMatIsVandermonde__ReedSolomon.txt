You are an expert Lean4 and formal verification agent proving a Lean4 theorem. Your output **must** strictly adhere to the specified format.

### Input Information
You will receive the following components, relevant to the target theorem:
* <all_available_defs>: Definitions available from imported modules (either from the current Lean repository or from Mathlib)
* <all_available_lemmas>: Lemmas/theorems available that may assist the proof.
* <local_ctx>...</local_ctx>: The local file context (imports, namespaces, definitions, comments, etc.) from the top of the file up to‚Äîbut not including‚Äîthe target theorem or any previously defined local lemmas/theorems.
* <target_theorem>...</target_theorem>: The target theorem statement, ending with `:=`.

**Notes**
1. Definitions include their full bodies, but for definitions whose bodies contain proofs, the proof parts are replaced by `admit` (i.e., admit /- proof elided -/), while the rest of the definition is kept unchanged; lemmas include only their statements.
2. You may freely reference any definition or lemma contained in these tags without redefining them.
3. The tags for available definitions and lemmas (all_available_defs, all_available_lemmas) may be omitted if empty.

### Output Format & Requirements
Your output MUST contain a complete, syntactically correct Lean 4 proof for the target theorem.

**Strict Output Structure:**
<reasoning> 
...
</reasoning> 

<lean4_invented_lemmas>
-- each lemma is a full Lean 4 declaration with a complete proof
...
</lean4_invented_lemmas>

<lean4_proof>
-- Lean 4 proof body of the target theorem
...
</lean4_proof>

**Requirements:**
1. <reasoning> and <lean4_invented_lemmas> are OPTIONAL. Include them only if they aid proof construction.
2. <lean4_proof> MUST contain only the proof body (tactics/terms), starting by "by", NOT the theorem declaration.
3. <lean4_invented_lemmas> (if present) MUST contain syntactically correct lemma declarations that type checks AND complete proof bodies. Defining a lemma using `axiom` is NOT allowed.
4. <reasoning> contains high-level proof planning.
5. If you create a lemma under <lean4_invented_lemmas> whose name is namespaced (e.g., X.Y.Z), you MUST always refer to it using its fully qualified name. Do NOT rely on shortened names. For example, write rw [X.Y.Z], not rw [Z] for invented lemmas.
6. All Lean 4 code MUST be syntactically correct. No `sorry`, `admit`, or non-Lean text. Comments allowed using `--` or `/- ... -/`.
7. Follow the tags and structure EXACTLY. No extra text before, between, or after the sections.
8. Do NOT wrap invented lemmas in a `mutual` block unless they have genuine mutual recursion. Declare each lemma independently.

### Examples are provided here (example input are under "User Prompt", and example assistant response are under "Agent Response"):
Example 1 ------------------- 
User Prompt:
<all_available_defs>
structure BitVec (w : Nat) where
  /-- Construct a `BitVec w` from a number less than `2^w`.
  O(1), because we use `Fin` as the internal representation of a bitvector. -/
  ofFin ::

  /-- Interpret a bitvector as a number less than `2^w`.
  O(1), because we use `Fin` as the internal representation of a bitvector. -/
  toFin : Fin (hPow 2 w)
</all_available_defs>

<all_available_lemmas>
theorem List.getElem_append_left{Œ± : Type u_1} {l‚ÇÅ l‚ÇÇ : List Œ±} {i : Nat} (hn : i < l‚ÇÅ.length) : (l‚ÇÅ ++ l‚ÇÇ)[i] = l‚ÇÅ[i]
theorem getElem_eq_testBit_toNat (x : BitVec w) (i : Nat) (h : i < w) :
  x[i] = x.toNat.testBit i := rfl
@[simp, grind =] theorem toNat_cons (b : Bool) (x : BitVec w) :
    (cons b x).toNat = (b.toNat <<< w) ||| x.toNat
@[simp, grind =] theorem getLsbD_of_ge (x : BitVec w) (i : Nat) (ge : w ‚â§ i) : getLsbD x i = false
theorem testBit_toNat (x : BitVec w) : x.toNat.testBit i = x.getLsbD i
</all_available_lemmas>

<local_ctx>
import Mathlib.Computability.NFA
import Mathlib.Data.FinEnum
import Mathlib.Data.Rel
import Mathlib.Data.Vector.Basic
import Blase.AutoStructs.ForLean

open Set
open Mathlib
open SetRel

-- this is better because card is defeq to n
instance (Œ± : Type) : Inter (Language Œ±) := ‚ü®Set.inter‚ü©
instance (Œ± : Type) : Union (Language Œ±) := ‚ü®Set.union‚ü©

/--
The set of `n`-tuples of bit vectors of an arbitrary width.
-/
structure BitVecs (n : Nat) where
  w : Nat
  bvs : List.Vector (BitVec w) n

def BitVecs.cast (bvs : BitVecs n) (h : n = n') : BitVecs n' :=
  { w := bvs.w, bvs := h ‚ñ∏ bvs.bvs }

abbrev BitVecs.empty : BitVecs n := ‚ü®0, List.Vector.replicate n .nil‚ü©
abbrev BitVecs.singleton {w : Nat} (bv : BitVec w) : BitVecs 1 := ‚ü®w, bv ::·µ• .nil‚ü©
abbrev BitVecs.pair {w : Nat} (bv1 bv2 : BitVec w) : BitVecs 2 := ‚ü®w, bv1 ::·µ• bv2 ::·µ• .nil‚ü©

/--
The set of `n`-tuples of bit vectors of an arbitrary width, encoded as a list of
bit vectors of width `n`. The width of the encoded bit vectors is the length of
the list.
-/
abbrev BitVecs' (n : Nat) := List (BitVec n)

@[simps]
def dec (bvs' : BitVecs' n) : BitVecs n where
  w := bvs'.length
  bvs := List.Vector.ofFn fun k => BitVec.ofFn fun i => bvs'[i].getLsbD k

@[simp]
</local_ctx>

<target_theorem>
lemma dec_snoc n (bvs' : BitVecs' n) (a : BitVec n) :
  dec (bvs' ++ [a]) =
    { w := bvs'.length + 1
      bvs := List.Vector.ofFn fun k =>
        BitVec.cons (a.getLsbD k) ((dec bvs').bvs.get k) } :=
</target_theorem>

Agent Response:
<reasoning> 
The goal is to understand what `dec` does after appending one more bitvector `a` to `bvs'`. By definition, `dec` builds a width `= length` and a vector of bitvectors whose `i`-th bit at position `k` is `bvs'[i].getLsbD k`. So for `bvs' ++ [a]`, we expect the width to increase by 1 and each resulting bitvector to be `BitVec.cons` of the new bit coming from `a`.

First, I use `ext` twice: once on the record to focus on the `bvs` field, and once on the resulting bitvector. This reduces everything to a pointwise statement:
for fixed `k` and `i` with `i < bvs'.length + 1`,
the bit `(bvs' ++ [a])[i].getLsbD k` should match the bit at index `i` of `BitVec.cons (a.getLsbD k) ((dec bvs').bvs.get k)`.

At this point I need a clean description of indexing into `BitVec.cons`: if we have `x : BitVec n`, then `(cons b x)[i]` should give `b` at the new ‚Äúlast‚Äù index `n` and `x[i]` otherwise. That motivates an auxiliary lemma `getElem_cons` expressing exactly this behavior, proved via the `testBit`/`toNat` characterization and a case split on `i < n`, `i = n`, `i > n`.

Using `getElem_cons`, the RHS becomes an `if` on whether `i = bvs'.length`. So I split into cases:
- If `i = bvs'.length`, then `(bvs' ++ [a])[i]` is the appended `a`, so both sides reduce to `a.getLsbD k`.
- If `i ‚â† bvs'.length`, the bound `i < bvs'.length + 1` forces `i < bvs'.length`. Then `(bvs' ++ [a])[i] = bvs'[i]` by `List.getElem_append_left`, and the RHS takes the ‚Äúelse‚Äù branch and likewise gives the bit from `bvs'[i]`. In both subcases, `simp` (plus the definition of `dec`) finishes.

So the whole proof is: `ext` to bit level, unfold `dec` with `simp_all`, rewrite with `getElem_cons`, split on the boundary index `i = length bvs'`, and in the ‚Äú< length‚Äù branch use `List.getElem_append_left` and bounds to line up both sides.
</reasoning> 

<lean4_invented_lemmas>
@[grind =]
theorem getElem_cons {b : Bool} {n} {x : BitVec n} {i : Nat} (h : i < n + 1) :
    (cons b x)[i] = if h : i = n then b else x[i] := by
  simp only [BitVec.getElem_eq_testBit_toNat, BitVec.toNat_cons, Nat.testBit_or]
  rw [Nat.testBit_shiftLeft]
  rcases Nat.lt_trichotomy i n with i_lt_n | i_eq_n | n_lt_i
  ¬∑ have p1 : ¬¨(n ‚â§ i) := by omega
    have p2 : i ‚â† n := by omega
    simp [p1, p2]
  ¬∑ simp only [i_eq_n, ge_iff_le, Nat.le_refl, decide_true, Nat.sub_self, Nat.testBit_zero,
    Bool.true_and, BitVec.testBit_toNat, BitVec.getLsbD_of_ge, Bool.or_false]
    cases b <;> trivial
  ¬∑ have p1 : i ‚â† n := by omega
    have p2 : i - n ‚â† 0 := by omega
    simp [p1, p2, Nat.testBit_bool_toNat]
</lean4_invented_lemmas>

<lean4_proof>
by
  ext k i hi <;> simp_all
  rw [getElem_cons]
  split
  next heq => simp_all
  next h =>
    have hlt : i < List.length bvs' := by simp at hi; omega
    rw [List.getElem_append_left hlt]
    simp
</lean4_proof>

### Your task:
<all_available_defs>
Fin in Init.Prelude
Matrix in Mathlib.LinearAlgebra.Matrix.Defs
Semiring in Mathlib.Algebra.Ring.Defs
Matrix.of in Mathlib.LinearAlgebra.Matrix.Defs
Polynomial.X in Mathlib.Algebra.Polynomial.Basic
toFun in ToMathlib.Control.Monad.Hom
Submodule in Mathlib.Algebra.Module.Submodule.Defs
Polynomial in Mathlib.Algebra.Polynomial.Basic
Polynomial.degreeLT in Mathlib.RingTheory.Polynomial.Basic
Fin.val in Init.Prelude
Finset in Mathlib.Data.Finset.Defs
Finset.map in Mathlib.Data.Finset.Image
Finset.max in Mathlib.Data.Finset.Max
Fintype in Mathlib.Data.Fintype.Defs
CommRing in Mathlib.Algebra.Ring.Defs
LinearMap in Mathlib.Algebra.Module.LinearMap.Defs
LinearMap.range in Mathlib.Algebra.Module.Submodule.Range
DecidableEq in Init.Prelude
Field in Mathlib.Algebra.Field.Defs
NeZero in Init.Data.NeZero
Matrix.add in Mathlib.LinearAlgebra.Matrix.Defs
Finset.range in Mathlib.Data.Finset.Range
CommSemiring in Mathlib.Algebra.Ring.Defs
Polynomial.coeff in Mathlib.Algebra.Polynomial.Basic

def polynomialOfCoeffs (coeffs : Fin deg ‚Üí F) : F[X] :=
  ‚ü®
    Finset.map ‚ü®Fin.val, Fin.val_injective‚ü© {i | coeffs i ‚â† 0},
    fun i ‚Ü¶ if h : i < deg then coeffs ‚ü®i, h‚ü© else 0,
    fun a ‚Ü¶ by admit /- proof elided -/
  ‚ü©

def liftF' (f : ‚Ñï ‚Üí Œ±) : Fin n ‚Üí Œ± :=
  fun m ‚Ü¶ f m.1

noncomputable def fromColGenMat [CommRing F] (G : Matrix Œπ Œ∫ F) : LinearCode Œπ F :=
  LinearMap.range G.mulVecLin

abbrev LinearCode.{u, v} (Œπ : Type u) [Fintype Œπ] (F : Type v) [Semiring F] : Type (max u v) :=
  Submodule F (Œπ ‚Üí F)

def coeff.{u} {F : Type u} [Semiring F] (f : F[X][Y]) (i j : ‚Ñï) : F := (f.coeff j).coeff i

@[reducible]
def oSpec (Œ± Œ≤ Œ≥ : Type) : OracleSpec (Unit ‚äï Unit) := randSpec Œ≤ ++‚Çí ROspec Œ± Œ≤ Œ≥

instance : MonadLift (StateT œÉ m) (StateT (œÉ √ó œÑ) m) where
  monadLift := fun x st => do let y ‚Üê x st.1; return (y.1, y.2, st.2)

class PrimeOrder (G : Type*) [Group G] where
  p : ‚Ñï
  [hPrime : Fact (Nat.Prime p)]
  hCard : Nat.card G = p

Std.Format in Init.Data.Format.Basic

MvPolynomial in Mathlib.Algebra.MvPolynomial.Basic

@[inline, specialize]
def OracleVerifier.run [O‚Çò : ‚àÄ i, OracleInterface (pSpec.Message i)]
    (stmt : StmtIn) (oStmtIn : ‚àÄ i, OStmtIn i) (transcript : FullTranscript pSpec)
    (verifier : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec) :
      OracleComp oSpec (StmtOut √ó (‚àÄ i, OStmtOut i)) := do
  let f := OracleInterface.simOracle2 oSpec oStmtIn transcript.messages
  let stmtOut ‚Üê simulateQ f (verifier.verify stmt transcript.challenges)
  let oStmtOut : ‚àÄ i, OStmtOut i := fun i => match h : verifier.embed i with
  | .inl j => by admit /- proof elided -/
  | .inr j => by admit /- proof elided -/

Option.bind in Init.Data.Option.Basic

GaloisField in Mathlib.FieldTheory.Finite.GaloisField

def processMemoryOps (ops : List (MemoryOp Œπ Œ±)) (startMem : M) : Option M :=
  ops.foldlM (fun m op =>
    match op with
    | .read ‚ü®i, v‚ü© => if Memory.read m i = v then some m else none
    | .write ‚ü®i, v‚ü© => some (Memory.write m i v)
  ) startMem

noncomputable def polyEvalLinearMap {L ùîΩq : Type*} [Field L] [Field ùîΩq] [Algebra ùîΩq L]
  (p : L[X]) (hp_add : IsLinearMap ùîΩq (fun x : L => p.eval x)) : L ‚Üí‚Çó[ùîΩq] L :=
{
  toFun    := fun x => p.eval x,
  map_add' := hp_add.map_add,
  map_smul' := hp_add.map_smul
}

@[simp]
def evalDomain (i : ‚Ñï) : Subgroup FÀ£ :=
  Subgroup.zpowers (DIsCyclicC.gen ^ (2 ^ i))

instance : SMul R (UniPoly R) := ‚ü®UniPoly.smul‚ü©

def Cache (n : ‚Ñï) := (layer : Fin (n + 1)) ‚Üí List.Vector Œ± (2 ^ layer.val)

List.range in Init.Data.List.Basic

private def k [Zero F] (B : Finset (Fin n ‚Üí F)) : ‚Ñö :=
  (1 : ‚Ñö) / n * ‚àë i, K B i 0

instance : ‚àÄ i, SelectableType ((pSpecLastBlock (L:=L) (œë:=œë)).Challenge i) :=
  instSelectableTypeChallengeSeqCompose

structure StatementRound (i : Fin (n + 1)) where
  
  target : R
  
  challenges : Fin i ‚Üí R

def rationalRoot (H : F[X][Y]) (z : F) : Type :=
  {t_z : F // evalEval z t_z H = 0}

instance {n : ‚Ñï} : ‚àÄ j, SelectableType ((pSpecFoldRelaySequence (L:=L) n).Challenge j) :=
  instSelectableTypeChallengeSeqCompose

def reduction : Reduction oSpec (StmtIn R √ó (‚àÄ i, OStmtIn R deg i)) Unit
                                (StmtOut R √ó (‚àÄ i, OStmtOut R deg i)) Unit (pSpec R deg) where
  prover := prover R deg oSpec
  verifier := verifier R deg D oSpec

LinearMap.ker in Mathlib.Algebra.Module.Submodule.Ker

def toVerifier : Verifier oSpec (StmtIn √ó ‚àÄ i, OStmtIn i) (StmtOut √ó (‚àÄ i, OStmtOut i)) pSpec where
  verify := fun ‚ü®stmt, oStmt‚ü© transcript => do
    let stmtOut ‚Üê simulateQ (OracleInterface.simOracle2 oSpec oStmt transcript.messages)
      (verifier.verify stmt transcript.challenges)
    letI oStmtOut := fun i => match h : verifier.embed i with
      | Sum.inl j => by admit /- proof elided -/
      | Sum.inr j => by admit /- proof elided -/

instance [Zero T] [ToNat T] : Mul (Cayley T) where
  mul := mul

noncomputable instance (‚Ñì : Nat) : AddCommGroup (CoeffVecSpace L ‚Ñì) :=

@[reducible, simp]
def relOut : (StmtOut OStatement √ó ‚àÄ i, OStmtOut OStatement i) ‚Üí WitOut ‚Üí Prop :=
  fun ‚ü®‚ü®q, r‚ü©, oStmt‚ü© () => answer (oStmt 0) q = r

Vector.head in Init.Data.Vector.Basic

noncomputable def hasMutualCorrAgreement
  (Gen : ProximityGenerator Œπ F) [Fintype Gen.par‚Ñì]
  (BStar : ‚Ñù) (errStar : ‚Ñù ‚Üí ENNReal) :=
    haveI := Gen.Gen_nonempty
    ‚àÄ (f : Gen.par‚Ñì ‚Üí Œπ ‚Üí F) (Œ¥ : ‚Ñù‚â•0) (_hŒ¥ : 0 < Œ¥ ‚àß Œ¥ < 1 - BStar),
    Pr_{let r ‚Üê$·µñ Gen.Gen}[ proximityCondition f Œ¥ r Gen.C ] ‚â§ errStar Œ¥

@[reducible, simp] def StmtOut := Query OStatement

instance [Zero T] [ToNat T] : Sub (Cayley T) where
  sub := sub

def deriveTranscriptDSFS {Œπ : Type} {oSpec : OracleSpec Œπ} {StmtIn : Type}
    (stmtIn : StmtIn) (messages : pSpec.Messages) :
    OracleComp (oSpec ++‚Çí duplexSpongeChallengeOracle StmtIn U)
      (CanonicalDuplexSponge U √ó pSpec.FullTranscript) := do
  let sponge ‚Üê liftM (DuplexSponge.start stmtIn)
  deriveTranscriptDSFSAux sponge messages (Fin.last n)

ByteArray in Init.Prelude

class IsSecureWithGap
    (completeRelation : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (soundRelation : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (Œµ_rbr : vPSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0)
    (vectorIOP : VectorIOP Statement OStatement Witness vPSpec A) where

   
  is_complete : vectorIOP.perfectCompleteness (pure ()) ‚ü®isEmptyElim‚ü© completeRelation

   
  is_rbr_knowledge_sound :
    OracleProof.rbrKnowledgeSoundness (pure ()) ‚ü®isEmptyElim‚ü© soundRelation vectorIOP.verifier Œµ_rbr

@[reducible]
def scalarFieldSize : Nat :=
  21888242871839275222246405745257275088548364400416034343698204186575808495617

def StateRestoration.Soundness (oSpec : OracleSpec Œπ) (StmtIn : Type)
    {n : ‚Ñï} (pSpec : ProtocolSpec n) :=
  OracleComp (oSpec ++‚Çí (srChallengeOracle StmtIn pSpec)) (StmtIn √ó pSpec.Messages)

def powAlgHom :
  MvPolynomial (Fin m) F ‚Üí‚Çê[F] Polynomial F :=
   aeval fun j => Polynomial.X ^ (2 ^ (j : ‚Ñï))

structure Gate (ùì° : Type*) (numWires : ‚Ñï) extends Selector ùì°, WireIndices numWires
deriving DecidableEq

instance : Serialize UInt8 ByteArray where
  serialize byte := ByteArray.mk #[byte]

@[reducible, simp]
def soundness
    (langIn : Set (Statement √ó ‚àÄ i, OStatement i))
    (verifier : OracleVerifier oSpec Statement OStatement Bool (fun _ : Empty => Unit) pSpec)
    (soundnessError : ‚Ñù‚â•0) : Prop :=
  verifier.toVerifier.soundness init impl langIn acceptRejectOracleRel.language soundnessError

@[inline]
def seqCompose {m : ‚Ñï} (Stmt : Fin (m + 1) ‚Üí Type)
    {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (V : (i : Fin m) ‚Üí Verifier oSpec (Stmt i.castSucc) (Stmt i.succ) (pSpec i)) :
    Verifier oSpec (Stmt 0) (Stmt (Fin.last m)) (seqCompose pSpec) := match m with
  | 0 => Verifier.id
  | _ + 1 => append (V 0) (seqCompose (Stmt ‚àò Fin.succ) (fun i => V (Fin.succ i)))

instance {i : Fin ‚Ñì} :
    ‚àÄ j, OracleInterface ((pSpecFoldCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i).Message j) :=
  instOracleInterfaceMessageAppend

toList in ToMathlib.ProbabilityTheory.FinRatPMF

@[reducible]
def capacitySegment (state : CanonicalSpongeState U) : Vector U SpongeSize.C :=
  Vector.drop state SpongeSize.R

@[inline]
def smul [Mul R] (r : R) (p : MlPolyEval R n) : MlPolyEval R n := p.map (fun a => r * a)

Fin.take in Mathlib.Data.Fin.Tuple.Take

noncomputable def extractMLP (i : Fin ‚Ñì) (f : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®i, by omega‚ü© ‚Üí L) :
    Option (L‚¶É‚â§ 1‚¶Ñ[X Fin (‚Ñì - i)]) :=

noncomputable def genRSC
  [Nonempty F] (par‚Ñì : Type) [h‚Ñì : Fintype par‚Ñì] (œÜ : Œπ ‚Ü™ F) [Smooth œÜ]
  (m : ‚Ñï) (exp : par‚Ñì ‚Ü™ ‚Ñï) : ProximityGenerator Œπ F :=
    let r := LinearCode.rate (smoothCode œÜ m);
    { C := smoothCode œÜ m,
      par‚Ñì := par‚Ñì,
      h‚Ñì := h‚Ñì,
      rate := r,
      Gen := Finset.image (fun r => (fun j => r ^ (exp j))) (Finset.univ : Finset F),
      Gen_nonempty := by admit /- proof elided -/

Inv in Init.Prelude

instance [Zero T] [DecidableEq T] [ToNat T] : Mod (Cayley T) where
  mod := mod

def JohnsonConditionStrong (B : Finset (Fin n ‚Üí F)) (v : Fin n ‚Üí F) : Prop :=
  let e := e B v
  let d := d B
  let q : ‚Ñö := Fintype.card F
  let frac := q / (q - 1)
  (1 - frac * d/n) < (1- frac * e/n) ^ 2

@[inline, specialize]
def OracleReduction.run [‚àÄ i, OracleInterface (pSpec.Message i)]
    (stmt : StmtIn) (oStmt : ‚àÄ i, OStmtIn i) (wit : WitIn)
    (reduction : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec) :
      OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí)
        ((FullTranscript pSpec √ó (StmtOut √ó ‚àÄ i, OStmtOut i) √ó WitOut) √ó
          (StmtOut √ó ‚àÄ i, OStmtOut i)) := do
  let proverResult ‚Üê reduction.prover.run ‚ü®stmt, oStmt‚ü© wit
  let stmtOut ‚Üê liftM (reduction.verifier.run stmt oStmt proverResult.1)
  return ‚ü®proverResult, stmtOut‚ü©

Monad in Init.Prelude

@[ext]
class OracleInterface (Message : Type u) where
  Query : Type v
  Response : Type w
  answer : Message ‚Üí Query ‚Üí Response

@[reducible]
def Set.language {Œ± Œ≤} (rel : Set (Œ± √ó Œ≤)) : Set Œ± :=
  Prod.fst '' rel

Polynomial.mapAlgEquiv in Mathlib.Algebra.Polynomial.AlgebraMap

instance (k : ‚Ñï) : HAdd (ConcreteBTField k) (ConcreteBTField k) (ConcreteBTField k)
  where hAdd := add

inductive PrattPartList : (p : ‚Ñï) ‚Üí (a : ZMod p) ‚Üí ‚Ñï ‚Üí Prop
  | prime : {p : ‚Ñï} ‚Üí {a : ZMod p} ‚Üí (n k nk : ‚Ñï) ‚Üí n.Prime ‚Üí
      a ^ ((p - 1) / n) ‚â† 1 ‚Üí n ^ k = nk ‚Üí PrattPartList p a nk
  | split : {p : ‚Ñï} ‚Üí {a : ZMod p} ‚Üí {n : ‚Ñï} ‚Üí (list : List ‚Ñï) ‚Üí
      (‚àÄ r ‚àà list, PrattPartList p a r) ‚Üí list.prod = n ‚Üí PrattPartList p a n

def Rhs (e : ‚Ñï) (œâs f : Fin n ‚Üí F) (i : Fin n) : F :=
  let Œ±·µ¢ := œâs i
  (-(f i) * Œ±·µ¢^e)

structure SumcheckMultiplierParam (L : Type) [CommRing L] (‚Ñì : ‚Ñï) (Context : Type := Unit) where
  multpoly : (ctx: Context) ‚Üí MultilinearPoly L ‚Ñì

def hconcat {n : ‚Ñï} {Œ± : Fin n ‚Üí Sort u} {Œ≤ : Sort u} (u : (i : Fin n) ‚Üí Œ± i) (a : Œ≤) :
    (i : Fin (n + 1)) ‚Üí Fin.vconcat Œ± Œ≤ i :=
  fconcat (F := id) u a

RatFunc.eval in Mathlib.FieldTheory.RatFunc.AsPolynomial

def findIdxRev?_def {cond} {as : Array Œ±} {k : Fin as.size} :
  findIdxRev? cond as = some k ‚Üí cond as[k] :=

instance instDCast‚ÇÇ : DCast‚ÇÇ Nat ProtocolSpec (fun _ pSpec => ChallengeIdx pSpec) where
  dcast‚ÇÇ h := ChallengeIdx.cast h
  dcast‚ÇÇ_id := cast_id

finCongr in Mathlib.Data.Fin.SuccPred

noncomputable def J (q Œ¥ : ‚Ñö) : ‚Ñù :=
  let frac := q / (q - 1)
  (1 / frac) * (1 - Real.sqrt (1 - frac * Œ¥))

def commitPrvState (i : Fin ‚Ñì) : Fin (1 + 1) ‚Üí Type := fun
  | ‚ü®0, _‚ü© => Statement (L := L) Context i.succ √ó
    (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j) √ó
    Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ
  | ‚ü®1, _‚ü© => Statement (L := L) Context i.succ √ó
    (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.succ j) √ó
    Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ

Nat.ceil in Mathlib.Algebra.Order.Floor.Defs

noncomputable def evaluationPointœâ (i : Fin (‚Ñì + 1))
    (x : Fin (2 ^ (‚Ñì + R_rate - i))) : L := 
    
  ‚àë (‚ü®k, hk‚ü©: Fin (‚Ñì + R_rate - i)),
    if Nat.getBit k x.val = 1 then
      (normalizedW ùîΩq Œ≤ ‚ü®i, by admit /- proof elided -/
      ‚ü©).eval (Œ≤ ‚ü®i + k, by admit /- proof elided -/
      ‚ü©)
    else
      0

Fin.cast in Init.Data.Fin.Basic

@[inline] def one : AssocNat :=
  ‚ü®Nat.succ, by admit /- proof elided -/
  ‚ü©

def pointToIterateQuotientIndex (i : Fin (‚Ñì + 1)) (steps : ‚Ñï) (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
    (x : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i, by omega‚ü©)) : Fin (2 ^ steps) :=

def oracleReduction.firstMessage :
    OracleReduction oSpec
      (Statement R pp) (OracleStatement R pp) (Witness R pp)
      (Statement.AfterFirstMessage R pp) (OracleStatement.AfterFirstMessage R pp) Unit
      ‚ü®!v[.P_to_V], !v[Witness R pp]‚ü© :=
  SendSingleWitness.oracleReduction oSpec
    (Statement R pp) (OracleStatement R pp) (Witness R pp)

@[reducible, simp] def StmtOut : Type := R √ó R

def OracleReduction.addSalt
    (R : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec)
    (saltComp : (i : pSpec.MessageIdx) ‚Üí R.prover.PrvState i.1.castSucc ‚Üí
      OracleComp oSpec (Salt i)) :
    OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut (pSpec.addSalt Salt) where
  prover := R.prover.addSalt Salt saltComp
  verifier := R.verifier.addSalt Salt

def NestedList (n : ‚Ñï) : Type := dfoldr' n (fun _ => Type) (fun _ T => List T) Nat

example : NestedList 0 = Nat := rfl
example (n : ‚Ñï) : NestedList (n + 1) = List (NestedList n) := rfl

@[reducible, inline, specialize]
def MessagesUpTo (k : Fin (n + 1)) (pSpec : ProtocolSpec n) : Type :=
  ‚àÄ i, pSpec.MessageUpTo k i

def coeffsOfPolynomial (p : F[X]) : Fin deg ‚Üí F :=
  fun ‚ü®x, _‚ü© ‚Ü¶ p.coeff x

class DCast‚ÇÇ (Œ± : Sort*) (Œ≤ : Œ± ‚Üí Sort*) (Œ≥ : (a : Œ±) ‚Üí Œ≤ a ‚Üí Sort*) [DCast Œ± Œ≤] where
  dcast‚ÇÇ : ‚àÄ {a a' : Œ±} {b : Œ≤ a} {b' : Œ≤ a'},
    (ha : a = a') ‚Üí (dcast ha b = b') ‚Üí Œ≥ a b ‚Üí Œ≥ a' b'
  dcast‚ÇÇ_id : ‚àÄ {a : Œ±} {b : Œ≤ a}, dcast‚ÇÇ (Eq.refl a) dcast_eq = (id : Œ≥ a b ‚Üí Œ≥ a b)

noncomputable def toPolynomialAlgHom : P ‚Üí‚Çê[R] R[X] := PolynomialLike.aeval Polynomial.X

def divSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (k : Fin (‚àë j, n j)) : Fin m :=
  (divSum? n k).get (divSum?_is_some_iff_lt_sum.mpr k.isLt)

def Reduction.liftContext
    (lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut)
    (R : Reduction oSpec InnerStmtIn InnerWitIn InnerStmtOut InnerWitOut pSpec) :
      Reduction oSpec OuterStmtIn OuterWitIn OuterStmtOut OuterWitOut pSpec where
  prover := R.prover.liftContext lens
  verifier := R.verifier.liftContext lens.stmt

@[reducible]
def Witness (F : Type) [Semiring F] {k : ‚Ñï} (s : Fin (k + 1) ‚Üí ‚Ñï+) (d : ‚Ñï+) (m : ‚Ñï) :=
  Fin (m + 1) ‚Üí F‚¶É< 2 ^ (‚àë i, (s i).1) * d‚¶Ñ[X]

def internalLinearLayer (state : Vector KoalaBear.Field params.width) :
    Vector KoalaBear.Field params.width :=
  
  
  let sumAll := state.foldl (fun acc x => acc + x) 0

  
  
  state.zipWith (fun s d => sumAll + d * s) params.internalDiagVectors

class VCVCompatible (Œ± : Type*) extends Fintype Œ±, Inhabited Œ± where
  [type_decidableEq' : DecidableEq Œ±]

def quotient (f g : F[X][Y]) : Prop := ‚àÉ q : F[X][Y], g = q * f

Algebra.TensorProduct.comm in Mathlib.RingTheory.TensorProduct.Maps

instance [VerifierFirst pSpec] : VerifierLast pSpec where
  verifier_last' := by admit /- proof elided -/

structure Context.Lens (OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                          OuterWitIn OuterWitOut InnerWitIn InnerWitOut : Type) where
  stmt : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
  wit : Witness.Lens OuterStmtIn InnerStmtOut OuterWitIn OuterWitOut InnerWitIn InnerWitOut

@[reducible]
def Extractor.Straightline.id : Extractor.Straightline oSpec StmtIn WitIn WitIn !p[] :=
  fun _ witOut _ _ _ => pure witOut

instance (k : ‚Ñï) : AddCommGroup (ConcreteBTField k) := mkAddCommGroupInstance

def powFiber (S : Finset Œπ) (œÜ : Œπ ‚Ü™ F) (k : ‚Ñï) (y : indexPow S œÜ k) : Finset Œπ :=
  S.filter (fun x => (œÜ x) ^ k = y)

Finset.map in Mathlib.Data.Finset.Image

Matrix.submatrix in Mathlib.LinearAlgebra.Matrix.Defs

noncomputable def decodeLT : (ReedSolomon.code domain deg) ‚Üí‚Çó[F] (Polynomial.degreeLT F deg) :=
  codRestrict
    (Polynomial.degreeLT F deg)
    decode
    (fun c => decoded_polynomial_lt_deg c)

def rootsOfUnity (n s : ‚Ñï) : List (Domain.evalDomain D (n - s)) :=
  List.map
    (fun i =>
      ‚ü®
        (DIsCyclicC.gen.1 ^ (2 ^ (n - s))) ^ i,
        by admit /- proof elided -/
      ‚ü©
    )
    (List.range (2 ^ s))

AdjoinRoot.instAlgebra in Mathlib.RingTheory.AdjoinRoot

def linearMvExtension :
  Polynomial.degreeLT F (2^m) ‚Üí‚Çó[F] MvPolynomial (Fin m) F where
    
    toFun p := (p : Polynomial F).sum fun i a =>
      MvPolynomial.monomial (bitExpo i) a
    map_add' := by admit /- proof elided -/

Int.negSucc in Init.Data.Int.Basic

@[inline, specialize]
def oracleVerifier : OracleVerifier oSpec
    Statement OStatement Statement (OStatement ‚äï·µ• (fun _ : Fin 1 => Witness))
    (oraclePSpec Witness) where
  verify := fun stmt _ => pure stmt
  embed := .sumMap (.refl _)
    <| Equiv.toEmbedding
    <|.symm (subtypeUnivEquiv (by admit /- proof elided -/
    ))
  hEq := by admit /- proof elided -/

noncomputable def foldRbrExtractor (i : Fin ‚Ñì) :
  Extractor.RoundByRound []‚Çí
    (StmtIn := (Statement (L := L) Context i.castSucc) √ó (‚àÄ j,
      OracleStatement ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc j))
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (pSpec := pSpecFold (L := L))
    (WitMid := fun _messageIdx => Witness (L := L) ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc) where
  eqIn := rfl
  extractMid := fun _ _ _ witMidSucc => witMidSucc
  extractOut := fun ‚ü®stmtIn, oStmtIn‚ü© fullTranscript witOut => by admit /- proof elided -/

Vector.foldl in Init.Data.Vector.Basic

def range (n : ‚Ñï) : Fin n ‚Üí ‚Ñï := fun i => i

def churchOr (p q : ChurchBool Œ±) : ChurchBool Œ± :=
  fun x y => p x (q x y)

ZMod.instField in Mathlib.Algebra.Field.ZMod

def start {Œ± : Type} (a : Œ±) : OracleComp (Œ± ‚Üí‚Çí Vector U SpongeSize.C) (DuplexSponge U C) := do
  let capacitySegment : Vector U SpongeSize.C ‚Üê query (spec := Œ± ‚Üí‚Çí Vector U SpongeSize.C) () a
  let vecSponge := (Vector.replicate SpongeSize.R (0 : U)) ++ capacitySegment
  return {
    state := SpongeState.update (Œ± := C) (0 : C) (vecSponge.cast (by admit /- proof elided -/
    )),
    absorbPos := 0,
    squeezePos := Fin.last SpongeSize.R
  }

@[reducible]
def GroupExpOracle : OracleSpec Unit := fun _ => (Œπ √ó ZMod p √ó Œπ, Unit)

BitVec.append in Init.Data.BitVec.Basic

def fold (i : Fin r) (h_i : i + 1 < ‚Ñì + ùì°) (f : (sDomain ùîΩq Œ≤
    h_‚Ñì_add_R_rate) i ‚Üí L) (r_chal : L) :
    (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) (‚ü®i + 1, by admit /- proof elided -/
    ‚ü©) ‚Üí L :=
  fun y => by admit /- proof elided -/

def knowledgeSoundness
    (relIn : Set ((StmtIn √ó ‚àÄ i, OStmtIn i) √ó WitIn))
    (relOut : Set ((StmtOut √ó ‚àÄ i, OStmtOut i) √ó WitOut))
    (verifier : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec)
    (knowledgeError : ‚Ñù‚â•0) : Prop :=
  verifier.toVerifier.knowledgeSoundness init impl relIn relOut knowledgeError

def queryKStateProp {m : Fin (1 + 1)}
  (tr : ProtocolSpec.Transcript m
    (pSpecQuery ùîΩq Œ≤ Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)))
  (stmt : FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì))
  (witMid : Unit)
  (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤ (œë := œë)
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì) j) : Prop :=
if h0 : m.val = 0 then
  
  Binius.BinaryBasefold.finalSumcheckRelOutProp ùîΩq Œ≤ (input:=‚ü®‚ü®stmt, oStmt‚ü©, witMid‚ü©)
else
    let r := stmt.ctx.t_eval_point
    let s := stmt.ctx.original_claim
    let challenges : Fin ‚Ñì ‚Üí L := stmt.challenges
    let tr_so_far := (pSpecQuery ùîΩq Œ≤ Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).take m m.is_le
    let chalIdx : tr_so_far.ChallengeIdx := ‚ü®‚ü®0,
      Nat.lt_of_succ_le (by admit /- proof elided -/
      )‚ü©, by admit /- proof elided -/
      ‚ü©
    let Œ≥_challenges : Fin Œ≥_repetitions ‚Üí sDomain ùîΩq
      Œ≤ h_‚Ñì_add_R_rate ‚ü®0, by admit /- proof elided -/
      ‚ü© := ((ProtocolSpec.Transcript.equivMessagesChallenges (k:=m)
        (pSpec:=pSpecQuery ùîΩq Œ≤ Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
        tr).2 chalIdx)
    let fold_challenges := stmt.challenges
    
    let proximityTestsCheck : Prop :=
      proximityChecksSpec ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (œë:=œë) Œ≥_repetitions Œ≥_challenges oStmt fold_challenges stmt.final_constant
    proximityTestsCheck

def checkSrs (proveSrs : Vector G‚ÇÅ (n + 1)) (verifySrs : Vector G‚ÇÇ 2) : Prop :=
  ‚àÄ i : Fin n,
    pairing (proveSrs[i.succ]) (verifySrs[0]) = pairing (proveSrs[i.castSucc]) (verifySrs[1])

noncomputable def dim [Semiring F] (LC : LinearCode Œπ F) : ‚Ñï :=
  Module.finrank F LC

Finite in Mathlib.Data.Finite.Defs

def oracleReduction.linearCombination :
    OracleReduction oSpec
      (Statement.AfterFirstSumcheck R pp) (OracleStatement.AfterFirstSumcheck R pp) (Witness R pp)
      (Statement.AfterLinearCombination R pp) (OracleStatement.AfterLinearCombination R pp) Unit
      ‚ü®!v[.V_to_P], !v[LinearCombinationChallenge R]‚ü© :=
  sorry

noncomputable def finalFoldProver :
  OracleProver []‚Çí
    (Statement F (Fin.last k)) (OracleStatement D x s (Fin.last k))
      (Witness F s d (Fin.last k).castSucc)
    (FinalStatement F k) (FinalOracleStatement D x s)
      (Witness F s d (Fin.last (k + 1)))
    (pSpec F) where
  PrvState
  | 0 =>
    (Statement F (Fin.last k) √ó ((j : Fin (k + 1)) ‚Üí OracleStatement D x s (Fin.last k) j)) √ó
      Witness F s d (Fin.last k).castSucc
  | _ =>
    (FinalStatement F k √ó ((j : Fin (k + 1)) ‚Üí OracleStatement D x s (Fin.last k) j)) √ó
      Witness F s d (Fin.last (k + 1))

  input := id

  sendMessage
  | ‚ü®0, h‚ü© => nomatch h
  | ‚ü®1, _‚ü© => fun ‚ü®‚ü®chals, o‚ü©, p‚ü© =>
    pure ‚ü®fun x => p.1, ‚ü®‚ü®chals, o‚ü©, p‚ü©‚ü©

  receiveChallenge
  | ‚ü®0, _‚ü© => fun ‚ü®‚ü®chals, o‚ü©, p‚ü© => pure <|
    fun (Œ± : F) =>
      ‚ü®
        ‚ü®Fin.vappend chals !v[Œ±], o‚ü©,
        ‚ü®
          p.1.foldNth (2 ^ (s (Fin.last k)).1) Œ±,
          by admit /- proof elided -/
        ‚ü©
      ‚ü©
  | ‚ü®1, h‚ü© => nomatch h

  output := fun ‚ü®‚ü®chals, o‚ü©, p‚ü© => pure <|
    ‚ü®
      ‚ü®
        chals,
        fun j => by admit /- proof elided -/
      ‚ü©,
      p
    ‚ü©

noncomputable def proximity_gap_degree_bound (rho : ‚Ñö) (m n : ‚Ñï) : ‚Ñï :=
  let b := D_X rho m n
  if h : ‚àÉ n : ‚Ñï, b = n
  then h.choose - 1
  else Nat.floor b

def getFirstOracle {i : Fin (‚Ñì + 1)}
    (oStmt : (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i j)) :
    sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate 0 ‚Üí L :=

@[inline, specialize]
def oracleReduction : OracleReduction oSpec
    Statement OStatement Unit Statement OStatement Unit !p[] where
  prover := oracleProver oSpec Statement OStatement
  verifier := oracleVerifier oSpec Statement OStatement pred

structure Commit where
  commit : Data ‚Üí Randomness ‚Üí OracleComp oSpec Commitment

def checkInitImports : IO Bool := do
  \n\
      The `header` linter is included in Mathlib.Init, and every file in Mathlib \
      should import Mathlib.Init.\nPlease adjust the imports accordingly."
    return true

  e

instance {Œπ : Type u} (v : Œπ ‚Üí Type v) [O : ‚àÄ i, OracleInterface (v i)]
    [h : ‚àÄ i, DecidableEq (Query (v i))]
    [h' : ‚àÄ i, DecidableEq (Response (v i))] :
    [v]‚Çí.DecidableEq where
  domain_decidableEq' := h
  range_decidableEq' := h'

instance {langIn : Set StmtIn} {langOut : Set StmtOut}
    {verifier : Verifier oSpec StmtIn StmtOut pSpec} :
    CoeFun (KnowledgeStateFunctionOneShot init impl langIn langOut verifier)
    (fun _ => (m : Fin (n + 1)) ‚Üí StmtIn ‚Üí Transcript m pSpec ‚Üí Prop) := ‚ü®fun f => f.toFun‚ü©

instance : PrimeOrder G where
  p := p
  hCard := PrimeOrderWith.hCard

@[inline, specialize]
def Reduction.runWithLog (stmt : StmtIn) (wit : WitIn)
    (reduction : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí)
        (((FullTranscript pSpec √ó StmtOut √ó WitOut) √ó StmtOut) √ó
          QueryLog (oSpec ++‚Çí [pSpec.Challenge]‚Çí) √ó QueryLog oSpec) := do
  
  let ‚ü®proverResult, proveQueryLog‚ü© ‚Üê reduction.prover.runWithLog stmt wit
  let ‚ü®stmtOut, verifyQueryLog‚ü© ‚Üê
    liftM (simulateQ loggingOracle (reduction.verifier.run stmt proverResult.1)).run
  return ‚ü®‚ü®proverResult, stmtOut‚ü©, proveQueryLog, verifyQueryLog‚ü©

@[simp]
abbrev Statement.AfterFirstChallenge : Type :=
  FirstChallenge R pp √ó Statement.AfterFirstMessage R pp

def map {Œ± Œ≤ : Fin n ‚Üí Sort*} (f : (i : Fin n) ‚Üí Œ± i ‚Üí Œ≤ i) (a : (i : Fin n) ‚Üí Œ± i) :
    (i : Fin n) ‚Üí Œ≤ i := fun i => f i (a i)

@[reducible]
def proverState (i : Fin n) : ProverState 2 where
  PrvState
  | 0 => (StatementRound R n i.castSucc) √ó (‚àÄ i, OracleStatement R n deg i)
  | 1 => (StatementRound R n i.castSucc) √ó (‚àÄ i, OracleStatement R n deg i)
  | 2 => (StatementRound R n i.succ) √ó (‚àÄ i, OracleStatement R n deg i)

def take_snoc_oracle (i : Fin ‚Ñì)
    (oStmtIn : (j : Fin (toOutCodewordsCount ‚Ñì œë i.castSucc)) ‚Üí
      OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j)
    (newOracleFn : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ) :
    (j : Fin (toOutCodewordsCount ‚Ñì œë i.castSucc)) ‚Üí 
      OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j
    := fun j => snoc_oracle ùîΩq Œ≤ oStmtIn newOracleFn ‚ü®j, by admit /- proof elided -/
    ‚ü©

noncomputable def monomialBasisOfDegreeLT {n : ‚Ñï} : Basis (Fin n) L (L‚¶É< n‚¶Ñ[X]) :=

Function.Bijective in Mathlib.Logic.Function.Defs

def fnOracle (spec : OracleSpec Œπ) (f : (i : Œπ) ‚Üí spec.domain i ‚Üí spec.range i) :
    SimOracle.Impl spec where
  impl | query i t => pure (f i t)

instance instDCast‚ÇÇ : DCast‚ÇÇ Nat ProtocolSpec (fun _ pSpec => MessageIdx pSpec) where
  dcast‚ÇÇ h := MessageIdx.cast h
  dcast‚ÇÇ_id := cast_id

instance : DFunLike F Œ± Œ≤ where
  coe := DFunEquiv.equiv.toFun
  coe_injective' := DFunEquiv.equiv.injective

structure ParamConditions (P : Params Œπ F) where
  m : ‚Ñï 
  h_m : m = P.varCount 0
  h_sumkLt : ‚àë i : Fin (M + 1), P.foldingParam i ‚â§ m
  h_varCount_i : ‚àÄ i : Fin (M + 1),
    P.varCount i = m - ‚àë j : Fin i, P.foldingParam (Fin.castLT j (Nat.lt_trans j.isLt i.isLt))
  h_smooth : ‚àÄ i : Fin (M + 1), Smooth (P.œÜ i)
  h_repeatPLt : ‚àÄ i : Fin (M + 1), P.repeatParam i ‚â§ Fintype.card (Œπ i)

def findFinIdx (p : Œ± ‚Üí Bool) (l : List Œ±) : Fin (l.length + 1) :=
  ‚ü®List.findIdx' p l,
    Nat.lt_succ_of_le (by admit /- proof elided -/
    )‚ü©

Matrix.rank in Mathlib.LinearAlgebra.Matrix.Rank

instance : Fintype (pSpec.MessageIdx) := Subtype.fintype (fun i => pSpec.dir i = .P_to_V)

def new (domainSeparator : DomainSeparator U H) (csrng : R) : FSProverState U H R :=
  let hashState := HashStateWithInstructions.new domainSeparator
  
  let rng : ProverPrivateRng R := { ds := (), csrng := csrng }
  { rng := rng, hashState := hashState, nargString := ByteArray.empty }

instance instDCast : DCast Nat ProtocolSpec where
  dcast h := ProtocolSpec.cast h
  dcast_id := cast_id

def implGroupEqOracle [BEq G] :
    QueryImpl (GroupEqOracle Œπ) (StateT (GroupValTable Œπ G) Option) where
  impl | query _ ‚ü®i, j‚ü© => fun table =>
    match table i, table j with
    | some g‚ÇÅ, some g‚ÇÇ => some (g‚ÇÅ == g‚ÇÇ, table)
    | _, _ => none

def intCast_negSucc {k : ‚Ñï} (n : ‚Ñï) : intCast (k:=k) (Int.negSucc n)
  = - (‚Üë(n + 1) : ConcreteBTField k) :=

MvPolynomial.eval in Mathlib.Algebra.MvPolynomial.Eval

DecidableEq in Init.Prelude

Field in Mathlib.Algebra.Field.Defs

@[reducible]
def relation :
    (Fin sz.n_x ‚Üí R) ‚Üí 
    (MatrixIdx ‚Üí Matrix (Fin sz.m) (Fin sz.n) R) ‚Üí 
    (Fin sz.n_w ‚Üí R) ‚Üí 
    Prop :=
  fun stmt matrix wit =>
    letI ùï´ := ùï´ stmt wit
    (matrix .A *·µ• ùï´) * (matrix .B *·µ• ùï´) = (matrix .C *·µ• ùï´)

def divX (p : UniPoly R) : UniPoly R := p.extract 1 p.size

noncomputable def uni2bi (p : Polynomial F) : MvPolynomial (Fin 2) F :=
  Polynomial.eval‚ÇÇ MvPolynomial.C (MvPolynomial.X 0) p

instance [h : ProverFirst pSpec] : IsEmpty (pSpec.ChallengeIdx) where
  false | ‚ü®0, h'‚ü© => by admit /- proof elided -/

instance instHDivConcreteBTF {k : ‚Ñï} : HDiv (ConcreteBTField k) (ConcreteBTField k)
  (ConcreteBTField k) where hDiv a b := a * (concrete_inv b)

Sum in Init.Core

def Fin.sumCommEquiv (m : ‚Ñï) (n : ‚Ñï) : Fin (m + n) ‚âÉ (Fin n) ‚äï (Fin m) :=
  (@finSumFinEquiv m n).symm.trans (Equiv.sumComm (Fin m) (Fin n))

HSMul in Init.Prelude

def distanceLE (Message : Type*) [O : OracleInterface Message]
    [Fintype (O.Query)] [DecidableEq (O.Response)] (d : ‚Ñï) : Prop :=
  ‚àÄ a b : Message, a ‚â† b ‚Üí #{q | OracleInterface.answer a q = OracleInterface.answer b q} ‚â§ d

def implGroupExpOracle : QueryImpl (GroupExpOracle Œπ p) (StateT (GroupValTable Œπ G) Option) where
  impl | query _ ‚ü®i, a, j‚ü© => fun table =>
    match table i with
    | some g => some ((), table.update j (some (g ^ a.val)))
    | none => none

instance {Message : Type u} : Inhabited (OracleInterface Message) :=
  ‚ü®instDefault‚ü©

def oracleReduction.reduceClaim : OracleReduction oSpec
    (StmtAfterRandomQuery R) (OStmtAfterRandomQuery R deg) Unit
    (StmtOut R) (OStmtOut R deg) Unit !p[] :=

def fappend {A : Sort u} {F : A ‚Üí Sort v} {m n : ‚Ñï} {Œ± : Fin m ‚Üí A} {Œ≤ : Fin n ‚Üí A}
    (u : (i : Fin m) ‚Üí F (Œ± i)) (v : (i : Fin n) ‚Üí F (Œ≤ i)) :
    (i : Fin (m + n)) ‚Üí F (Fin.vappend Œ± Œ≤ i) :=
  match n with
  | 0 => u
  | k + 1 => fconcat (fappend u (fun i => v (Fin.castSucc i))) (v (Fin.last k))

AddMonoid in Mathlib.Algebra.Group.Defs

HEq in Init.Prelude

abbrev SEP_CHAR : Char := Char.ofNat 0

noncomputable def finalSumcheckRbrExtractor :
  Extractor.RoundByRound []‚Çí
    (StmtIn := (Statement (L := L) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì)) √ó (‚àÄ j, OracleStatement ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë  (Fin.last ‚Ñì) j))
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì))
    (WitOut := Unit)
    (pSpec := pSpecFinalSumcheckStep (L := L))
    (WitMid := FinalSumcheckWit (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì)) where
  eqIn := rfl
  extractMid := fun m ‚ü®stmtMid, oStmtMid‚ü© trSucc witMidSucc => by admit /- proof elided -/
    | none => 
      exact dummyLastWitness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
    | some tpoly =>
      
      exact {
        t := tpoly,
        H := projectToMidSumcheckPoly (L := L) (‚Ñì := ‚Ñì) (t := tpoly)
          (m := BBF_SumcheckMultiplierParam.multpoly stmtMid.ctx)
          (i := Fin.last ‚Ñì) (challenges := stmtMid.challenges),
        f := getMidCodewords ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) tpoly stmtMid.challenges
      }
  extractOut := fun ‚ü®stmtIn, oStmtIn‚ü© tr witOut => ()

def duplexSpongeToBasicFSAlgo
    (P : OracleComp (oSpec ++‚Çí duplexSpongeChallengeOracle StmtIn U)
    (StmtIn √ó pSpec.Messages)) :
    OracleComp (oSpec ++‚Çí fsChallengeOracle StmtIn pSpec) (StmtIn √ó pSpec.Messages) :=
  sorry

alias d2SAlgo := duplexSpongeToBasicFSAlgo

structure PrimeWithMultiplicity : Type where
  prime : ‚Ñï
  multiplicity : ‚Ñï
deriving Repr

instance : Fact (Nat.Prime baseFieldSize) := ‚ü®BaseField_is_prime‚ü©

def FullData.ofFun {Œ± : Type} (s : Skeleton)
    (f : SkeletonNodeIndex s ‚Üí Œ±) : FullData Œ± s :=
  match s with
  | .leaf => FullData.leaf (f SkeletonNodeIndex.ofLeaf)
  | .internal l r =>
      FullData.internal
        (f SkeletonNodeIndex.ofInternal)
        (FullData.ofFun l (fun idx => f (SkeletonNodeIndex.ofLeft idx)))
        (FullData.ofFun r (fun idx => f (SkeletonNodeIndex.ofRight idx)))

@[reducible, simp]
def rbrSoundness
    (langIn : Set (Statement √ó ‚àÄ i, OStatement i))
    (verifier : OracleVerifier oSpec Statement OStatement Bool (fun _ : Empty => Unit) pSpec)
    (rbrSoundnessError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) : Prop :=
  verifier.rbrSoundness init impl langIn acceptRejectOracleRel.language rbrSoundnessError

Mathlib.Meta.NormNum.instAddMonoidWithOne in Mathlib.Tactic.NormNum.Result

def sBasis (i : Fin r) (h_i : i < ‚Ñì + R_rate) : Fin (‚Ñì + R_rate - i) ‚Üí L :=
  fun k => Œ≤ ‚ü®i + k.val, by admit /- proof elided -/
  ‚ü©

Polynomial.eval‚ÇÇRingHom in Mathlib.Algebra.Polynomial.Eval.Defs

def challengeQueryImpl {pSpec : ProtocolSpec n} [‚àÄ i, SelectableType (pSpec.Challenge i)] :
    QueryImpl ([pSpec.Challenge]‚Çí'challengeOracleInterface) ProbComp where
  impl | query i () => uniformOfFintype (pSpec.Challenge i)

def AlgebraTowerEquiv.toAlgEquivOverLeft (e : AlgebraTowerEquiv A B) (i j : Œπ) (h : i ‚â§ j) :
  letI : Algebra (A i) (A j) :=

def binaryAlgebraTower {l r : ‚Ñï} (h_le : l ‚â§ r) : Algebra (BTField l) (BTField r) :=

instance {s} : Functor (fun Œ± => LeafData Œ± s) where
  map f x := x.map f

Nat.card in Mathlib.SetTheory.Cardinal.Finite

@[reducible, simp]
def OStmtOut : Unit ‚Üí Type := fun _ => R‚¶É‚â§ deg‚¶Ñ[X]

noncomputable instance instAlgebraTowerEquiv : AlgebraTowerEquiv
  (ConcreteBTField) (BTField) where
  toRingEquiv := fun i => (towerEquiv i).ringEquiv
  commutesLeft' := fun i j h r => by admit /- proof elided -/

noncomputable def batchProver :
  OracleProver []‚Çí
    Unit (OracleStatement D x m) (Witness F s d m)
    ((Fin m ‚Üí F) √ó Fri.Spec.Statement F (0 : Fin (k + 1)))
      (OracleStatement D x m) (Fri.Spec.Witness F s d (0 : Fin (k + 2)))
    (batchSpec F m) where
  PrvState
  | 0 => (‚àÄj, OracleStatement D x m j) √ó Witness F s d m
  | 1 => (Fin m ‚Üí F) √ó (‚àÄj, OracleStatement D x m j) √ó Fri.Spec.Witness F s d (0 : Fin (k + 2))

  input := fun i => ‚ü®i.1.2, i.2‚ü©

  sendMessage
  | ‚ü®0, h‚ü© => nomatch h

  receiveChallenge
  | ‚ü®0, _‚ü© => fun ‚ü®os, ps‚ü© => pure <|
    fun (cs : Fin m ‚Üí F) =>
      ‚ü®cs, os,
        ‚ü®
          ps 0 + ‚àë i, Polynomial.C (cs i) * (ps i.succ).1,
          by admit /- proof elided -/
        ‚ü©
      ‚ü©

  output := fun ‚ü®cs, os, p‚ü© => pure <|
    ‚ü®‚ü®‚ü®cs, Fin.elim0‚ü©, os‚ü©, p‚ü©

def getPutativeRoot {n : ‚Ñï} (i : Fin (2 ^ n)) (leaf : Œ±) (proof : List.Vector Œ± n) :
    OracleComp (spec Œ±) Œ± := do
  match h : n with
  | 0 => do
    
    return leaf
  | n + 1 => do
    
    let signBit := i.val % 2
    
    let i' : Fin (2 ^ n) := ‚ü®i.val / 2, by admit /- proof elided -/
    ‚ü©
    if signBit = 0 then
      
      let newLeaf ‚Üê query (spec := spec Œ±) () ‚ü®leaf, proof.get (Fin.last n)‚ü©
      getPutativeRoot i' newLeaf (proof.drop 1)
    else
      
      let newLeaf ‚Üê query (spec := spec Œ±) () ‚ü®proof.get (Fin.last n), leaf‚ü©
      getPutativeRoot i' newLeaf (proof.drop 1)

def sumExceptFirst' (n : ‚Ñï) (h : n > 0) (D : Fin (n - 1) ‚Üí Finset R) :
    MvPolynomial (Fin n) R ‚Üí‚Çó[R] Polynomial R :=

instance : ‚àÄ j, OracleInterface ((pSpecFinalSumcheckStep (L := L)).Message j) := fun j =>
  match j with
  | ‚ü®0, _‚ü© => OracleInterface.instDefault

instance [inst : ‚àÄ i, SelectableType (pSpec.Challenge i)] :
    ‚àÄ i, SelectableType ((pSpec.addSalt Salt).Challenge i) :=
  fun i => by admit /- proof elided -/

instance {Œ± : Type u} [ToNat Œ±] : CoeHead Œ± Nat where
  coe := ToNat.toNat

def coreInteractionOracleRbrKnowledgeError (j : (pSpecCoreInteraction ùîΩq Œ≤ (œë := œë)
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).ChallengeIdx) : ‚Ñù‚â•0 :=
    Sum.elim
      (f := fun i => sumcheckFoldKnowledgeError ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)
      (g := fun i => finalSumcheckKnowledgeError (L := L) i)
      (ChallengeIdx.sumEquiv.symm j)

def getMiddleBits (offset len n : ‚Ñï) : ‚Ñï :=
  getLowBits (numLowBits:=len) (n:=n >>> offset)

def externalLinearLayer (state : Vector KoalaBear.Field params.width) :
    Vector KoalaBear.Field params.width :=
  
  let chunks := Vector.Matrix.ofFlatten (state.cast (params.widthDiv4_mul_4_eq_width).symm)
  let chunksAfterM4 := chunks.map (fun chunk => applyM4 chunk)

  
  

  
  let transposedMatrix := Vector.Matrix.transpose chunksAfterM4

  
  let columnSums := transposedMatrix.map (fun col => col.foldl (¬∑ + ¬∑) 0)

  
  let chunksAfterDiffusion := chunksAfterM4.map (fun row => row.zipWith (¬∑ + ¬∑) columnSums)

  
  (Vector.flatten chunksAfterDiffusion).cast (params.widthDiv4_mul_4_eq_width)

instance {Œ± : Type*} {n : ‚Ñï} [VCVCompatible Œ±] : VCVCompatible (Vector Œ± n) where

@[reducible, simp] def OStmtIn := fun _ : Fin 2 => OStatement

def FinalSumcheckWit := fun (m : Fin (1 + 1)) =>
 match m with
 | ‚ü®0, _‚ü© => Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì)
 | ‚ü®1, _‚ü© => Unit

AddGroup in Mathlib.Algebra.Group.Defs

IO.FS.Stream.read in Init.System.IO

def fiberwiseClose (i : Fin ‚Ñì) (steps : ‚Ñï) [NeZero steps] (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
    (f : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      ‚ü®i, by admit /- proof elided -/
      ‚ü©) : Prop :=
  2 * fiberwiseDistance ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := i) steps
    (h_i_add_steps := h_i_add_steps) (f := f) < (BBF_CodeDistance ‚Ñì ùì° ‚ü®i + steps, by admit /- proof elided -/
    ‚ü© : ‚Ñï‚àû)

instance : Fact (Nat.Prime BASE_FIELD_CARD) := ‚ü®BaseField_is_prime‚ü©

Array.zipIdx in Init.Data.Array.Basic

def numQueries (stmt : StmtIn) (challenges : ‚àÄ i, pSpec.Challenge i)
    (verifier : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec) :
  OracleComp (oSpec ++‚Çí ([OStmtIn]‚Çí ++‚Çí [pSpec.Message]‚Çí)) ‚Ñï := sorry

def verifier (i : Fin n) : Verifier oSpec
    ((StatementRound R n i.castSucc) √ó (‚àÄ i, OracleStatement R n deg i))
    (StatementRound R n i.succ √ó (‚àÄ i, OracleStatement R n deg i)) (pSpec R deg) where
  verify := fun ‚ü®‚ü®target, challenges‚ü©, oStmt‚ü© transcript => do
    let ‚ü®p_i, _‚ü© : R‚¶É‚â§ deg‚¶Ñ[X] := transcript 0
    let r_i : R := transcript 1
    guard (‚àë x ‚àà (univ.map D), p_i.eval x = target)
    pure ‚ü®‚ü®p_i.eval r_i, Fin.snoc challenges r_i‚ü©, oStmt‚ü©

def FullData.Equiv {Œ±} (s : Skeleton) :
    FullData Œ± s ‚âÉ InternalData Œ± s √ó LeafData Œ± s :=

@[inline, reducible]
def proj : OuterStmtIn ‚Üí InnerStmtIn :=
  lens.toFunA

def implGroupOpOracle : QueryImpl (GroupOpOracle Œπ) (StateT (GroupValTable Œπ G) Option) where
  impl | query _ ‚ü®i, j, k‚ü© => fun table =>
    match table i, table j with
    | some g‚ÇÅ, some g‚ÇÇ => some ((), table.update k (some (g‚ÇÅ * g‚ÇÇ)))
    | _, _ => none

Finset.Ici in Mathlib.Order.Interval.Finset.Defs

class ProverOnly (pSpec : ProtocolSpec 1) extends ProverFirst pSpec

 
alias NonInteractive := ProverOnly

def ratchet (state : HashStateWithInstructions U H) :
    Except DomainSeparatorMismatch (HashStateWithInstructions U H) := do
  
  sorry

def extend {k : Fin n} (messages : MessagesUpTo k.castSucc pSpec)
    (h : pSpec.dir k = .V_to_P) : MessagesUpTo k.succ pSpec :=
  fun ‚ü®i, h‚ü© => (concat' (pSpec := pSpec) (fun i hi => messages ‚ü®i, hi‚ü©) (fun h' => by admit /- proof elided -/
  )) i h

@[inline, specialize]
def mulX (p : UniPoly R) : UniPoly R := p.mulPowX 1

def extractability (scheme : Scheme oSpec Data Randomness Commitment pSpec)
    (extractabilityError : ‚Ñù‚â•0) : Prop :=
  ‚àÉ extractor : StraightlineExtractor oSpec Data Commitment,
  ‚àÄ AuxState : Type,
  ‚àÄ adversary : ExtractabilityAdversary oSpec Data Commitment AuxState,
  ‚àÄ prover : Prover oSpec (Commitment √ó O.Query √ó O.Response) AuxState Bool Unit pSpec,
    False

Fin in Init.Prelude

@[simp]
abbrev OracleStatement.AfterFirstMessage : R1CS.MatrixIdx ‚äï Fin 1 ‚Üí Type :=
  Sum.rec (OracleStatement R pp) (fun _ => Witness R pp)

def toList (xs : ChurchVec Œ±) : List Œ± :=
  churchVecFold xs (fun x acc => x :: acc) []

instance : Coe (‚àÄ a : Œ±, Œ≤ a) F where
  coe := DFunEquiv.equiv.invFun

def nonLastBlockOracleVerifier (bIdx : Fin (‚Ñì / œë - 1)) :=
  let stmt : Fin (œë - 1 + 1) ‚Üí Type :=
    fun i => Statement (L := L) Context ‚ü®bIdx * œë + i, bIdx_mul_œë_add_i_cast_lt_‚Ñì_succ bIdx i‚ü©
  let oStmt := fun i: Fin (œë - 1 + 1) => OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë
    ‚ü®bIdx * œë + i, bIdx_mul_œë_add_i_cast_lt_‚Ñì_succ bIdx i‚ü©
  let firstFoldRelayRoundsOracleVerifier :=
    OracleVerifier.seqCompose (oSpec := []‚Çí)
      (Stmt := stmt)
      (OStmt := oStmt)
      (pSpec := fun i => pSpecFoldRelay (L:=L))
      (V := fun i => by admit /- proof elided -/
      )
  let h1 : ‚ÜëbIdx * œë + (œë - 1) < ‚Ñì := by admit /- proof elided -/

instance instDCast‚ÇÇSigma {Œ± : Type*} {Œ≤ : Œ± ‚Üí Type*} {Œ≥ : (a : Œ±) ‚Üí Œ≤ a ‚Üí Type*}
    {Œ¥ : (a : Œ±) ‚Üí (b : Œ≤ a) ‚Üí Œ≥ a b ‚Üí Type*}
    [DCast Œ± Œ≤] [DCast‚ÇÇ Œ± Œ≤ Œ≥] [DCast‚ÇÉ Œ± Œ≤ Œ≥ Œ¥] :
    DCast‚ÇÇ ((a : Œ±) √ó Œ≤ a) (fun a => Œ≥ a.1 a.2) (fun a => Œ¥ a.1 a.2) where
  dcast‚ÇÇ ha hb c := dcast‚ÇÉ (by admit /- proof elided -/
  ) (by admit /- proof elided -/
  ) (by admit /- proof elided -/
  ) c
  dcast‚ÇÇ_id := by admit /- proof elided -/

@[inline, reducible]
def FullTranscript.mk2 {pSpec : ProtocolSpec 2} (msg0 : pSpec.¬´Type¬ª 0) (msg1 : pSpec.¬´Type¬ª 1) :
    FullTranscript pSpec := fun | ‚ü®0, _‚ü© => msg0 | ‚ü®1, _‚ü© => msg1

inductive Expr where
  | lit (a : Lit F)
  | var (name : String)
  | sOp (op : ScalarOp) (a : Lit F) (b : Lit F)
  | svOp (op : ScalarVectorOp) (a : Lit F) (v : Lit F)
  | vOp (op : VectorOp) (v1 : Lit F) (v2 : Lit F)

@[reducible, simp]
def pSpec : ProtocolSpec 1 := ‚ü®!v[.P_to_V], !v[Witness]‚ü©

instance : LawfulHasPred Nat where
  pred'_succ := Nat.pred_succ

IntCast in Init.Data.Int.Basic

def KnowledgeStateFunctionOneShot.toKnowledgeStateFunction
    {relIn : Set (StmtIn √ó WitIn)} {relOut : Set (StmtOut √ó WitOut)}
    {verifier : Verifier oSpec StmtIn StmtOut pSpec}
    (stF : KnowledgeStateFunctionOneShot init impl relIn.language relOut.language verifier)
    (oneShotE : Extractor.RoundByRoundOneShot oSpec StmtIn WitIn pSpec) :
    verifier.KnowledgeStateFunction init impl relIn relOut oneShotE.toRoundByRound where
  toFun := fun m stmtIn tr witIn => if m = 0 then (stmtIn, witIn) ‚àà relIn else
    stF.toFun m stmtIn tr ‚à® (stmtIn, oneShotE m stmtIn tr default) ‚àà relIn
  toFun_empty := fun stmtIn witIn => by admit /- proof elided -/

Repr in Init.Data.Repr

def LeafData.composeBuild {Œ± : Type} {s : Skeleton} (leaf_data_tree : LeafData Œ± s)
    (compose : Œ± ‚Üí Œ± ‚Üí Œ±) :
    FullData Œ± s :=
  match s, leaf_data_tree with
  | Skeleton.leaf, LeafData.leaf value =>
    FullData.leaf value
  | Skeleton.internal _ _, LeafData.internal left right =>
    let left_tree := LeafData.composeBuild left compose
    let right_tree := LeafData.composeBuild right compose
    FullData.internal
      (compose left_tree.getRootValue right_tree.getRootValue)
      left_tree
      right_tree

def matrixSubmoduleOfLinearCode (Œ∫ : Type*) [Fintype Œ∫]
                                (LC : LinearCode Œπ F) : MatrixSubmodule Œ∫ Œπ F :=
  Submodule.span F { V | ‚àÄ i, V i ‚àà LC }

abbrev BTF‚ÇÉ := ConcreteBTField 3 

instance : HasSucc Nat where
  succ' := Nat.succ

@[simp]
def finRangeTo {k : ‚Ñï} (i : ‚Ñï) : Finset (Fin k) :=
  (List.take i (List.finRange k)).toFinset

NNRat in Mathlib.Data.Rat.Init

@[simp]
abbrev OracleStatement.AfterSecondSumcheck : R1CS.MatrixIdx ‚äï R1CS.MatrixIdx ‚äï Fin 1 ‚Üí Type :=
  Sum.elim (EvalClaim R) (OracleStatement.AfterFirstSumcheck R pp)

def correlatedAgreement (C : Set (n ‚Üí F)) (Œ¥ : ‚Ñù‚â•0) {k : ‚Ñï} (W : Fin k ‚Üí n ‚Üí F) : Prop :=
  ‚àÉ S : Finset n, #(S) ‚â• (1 - Œ¥) * (Fintype.card n) ‚àß
    ‚àÉ v : Fin k ‚Üí n ‚Üí F, ‚àÄ i, v i ‚àà C ‚àß {j | v i j = W i j} = S

@[inline, reducible]
def Witness.InvLens (OuterStmtIn OuterWitIn OuterWitOut InnerWitIn InnerWitOut : Type)
    := PFunctor.Lens ((OuterStmtIn √ó OuterWitOut) X^ OuterWitIn)
                     (InnerWitOut X^ InnerWitIn)

def modByMonic [Field R] (p : UniPoly R) (q : UniPoly R) :
    UniPoly R :=
  (divModByMonicAux p q).2

liftM in Init.Prelude

noncomputable def ElocPolyF (œâs f : Fin n ‚Üí F) (p : Polynomial F) : Polynomial F :=
  ElocPoly n (liftF œâs) (liftF f) p

def smoothCode
  (domain : Œπ ‚Ü™ F) [Smooth domain]
  (m : ‚Ñï) : Submodule F (Œπ ‚Üí F) := ReedSolomon.code domain (2^m)

structure ProverPrivateRng (R : Type*) where
   
  ds : Unit 
   
  csrng : R
deriving Repr

inductive InternalData (Œ± : Type) : Skeleton ‚Üí Type
  | leaf : InternalData Œ± Skeleton.leaf
  | internal {left right} (value : Œ±)
      (leftData : InternalData Œ± left)
      (rightData : InternalData Œ± right) : InternalData Œ± (Skeleton.internal left right)
  deriving Repr

instance : ‚àÄ j, OracleInterface (((pSpecFold D x k s ++‚Çö FinalFoldPhase.pSpec F)).Message j) :=
  instOracleInterfaceMessageAppend

instance (k : ‚Ñï) : Fintype (ConcreteBTField k) := (getBTFResult k).instFintype

Irreducible in Mathlib.Algebra.Group.Irreducible.Defs

def computeInitialSumcheckPoly (t : MultilinearPoly L ‚Ñì)
    (m : MultilinearPoly L ‚Ñì) : MultiquadraticPoly L ‚Ñì :=
  ‚ü®m * t, by
    rw [MvPolynomial.mem_restrictDegree_iff_degreeOf_le]
    intro i
    have h_t_deg: degreeOf i t.val ‚â§ 1 :=
      degreeOf_le_iff.mpr fun term a ‚Ü¶ (t.property) a i
    have h_m_deg: degreeOf i m.val ‚â§ 1 :=
      degreeOf_le_iff.mpr fun term a ‚Ü¶ (m.property) a i
    calc
      _ ‚â§ (degreeOf i m.val) + (degreeOf i t.val) :=
        degreeOf_mul_le i m.val t.val
      _ ‚â§ 2 :=

def Function.interleave‚ÇÇ {Œ± Œ≤ : Type*} (u v : Œ± ‚Üí Œ≤) : (Fin 2) √ó Œ± ‚Üí Œ≤ :=
  Function.uncurry (fun a => if a = 0 then u else v)

@[inline]
def ofOutputOnly (projWit : OuterStmtIn √ó OuterWitOut ‚Üí InnerWitOut) :
    Witness.InvLens OuterStmtIn OuterWitIn OuterWitOut OuterWitIn InnerWitOut :=
  ‚ü®projWit, fun _ => id‚ü©

Option.getD in Init.Prelude

noncomputable instance finiteDimensionalCoeffVecSpace (‚Ñì : ‚Ñï) :
  FiniteDimensional (K := L) (V := CoeffVecSpace L ‚Ñì) :=

@[inline, reducible]
def lift : OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i) ‚Üí InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i) ‚Üí
    OuterStmtOut √ó (‚àÄ i, OuterOStmtOut i) :=
  lens.toFunB

LinearIndepOn in Mathlib.LinearAlgebra.LinearIndependent.Defs

def seqComposeChallengeIdxToSigma {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (k : (seqCompose pSpec).ChallengeIdx) : (i : Fin m) √ó (pSpec i).ChallengeIdx :=
  let ij := Fin.splitSum k.1
  ‚ü®ij.1, ‚ü®ij.2, by admit /- proof elided -/
    ‚ü©‚ü©

instance {i : Fin ‚Ñì} :
    ‚àÄ j, OracleInterface ((pSpecFoldCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i).Message j) :=
  instOracleInterfaceMessageAppend (pSpec‚ÇÅ := pSpecFold (L := L))
    (pSpec‚ÇÇ := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)

MulOneClass in Mathlib.Algebra.Group.Defs

def evalX (a : F) (f : F[X][Y]) : Polynomial F :=
  ‚ü®Finsupp.mapRange (Polynomial.eval a) eval_zero f.toFinsupp‚ü©

head in ToMathlib.Control.Comonad.Instances

structure Distances (M : ‚Ñï) where
  Œ¥ : Fin (M + 1) ‚Üí ‚Ñù‚â•0
  l : Fin (M + 1) ‚Üí ‚Ñù‚â•0

structure GaloisAutomorphism (F : Type*) [Field F] (u : F) (k : ‚Ñï) : Prop where
  forward : u ^ (2 ^ (2 ^ k)) = u‚Åª¬π
  reverse : (u‚Åª¬π) ^ (2 ^ (2 ^ k)) = u

instance instSetoidUniPoly : Setoid (UniPoly R) where
  r := equiv
  iseqv := instEquivalenceEquiv

protected def OracleProver.id :
    OracleProver oSpec Statement OStatement Witness Statement OStatement Witness !p[] :=
  Prover.id

instance : CommGroup G := IsCyclic.commGroup

private def Fi (B : Finset (Fin n ‚Üí F)) (i : Fin n) (Œ± : F) : Finset (Fin n ‚Üí F) :=
  { x | x ‚àà B ‚àß x i = Œ± }

@[reducible]
def VectorIOP
    (Statement : Type) {Œπ‚Çõ : Type} (OStatement : Œπ‚Çõ ‚Üí Type) (Witness : Type)
    (vPSpec : ProtocolSpec.VectorSpec n) (A : Type)
    [‚àÄ i, OracleInterface (OStatement i)] :=
  OracleProof []‚Çí Statement OStatement Witness (vPSpec.toProtocolSpec A)

Equiv.toEmbedding in Mathlib.Logic.Embedding.Basic

@[inline, specialize]
def add (p q : UniPoly R) : UniPoly R :=
  add_raw p q |> trim

noncomputable def AffSpanFinsetCollection {t : ‚Ñï} [NeZero k] [NeZero t]
  (C : Fin t ‚Üí (Fin k ‚Üí (Œπ ‚Üí F))) : Set (Finset (Œπ ‚Üí F)) :=
  Set.range (fun i => AffSpanFinset (C i))

instance {Œ± : Type} {s : Skeleton} :
    CoeFun (InternalData Œ± s) fun (_ : InternalData Œ± s) => SkeletonInternalIndex s ‚Üí Œ± where
  coe := fun tree idx => tree.get idx

noncomputable def disagreementSet (f : Œπ ‚Üí F) (S : Finset F) (Ans : S ‚Üí F) : Finset F :=
  Set.toFinset ({x : Œπ | x.val ‚àà S ‚àß (ansPoly S Ans).eval x.val ‚â† f x}.image Subtype.val)

def ofNat (n : ‚Ñï) : ValidChurchNat :=
  ‚ü®ChurchNat.ofNat n, n, by admit /- proof elided -/
      ‚ü©

FiniteDimensional in Mathlib.LinearAlgebra.FiniteDimensional.Defs

def singleHash (left : Œ±) (right : Œ±) : OracleComp (spec Œ±) Œ± := do
  let out ‚Üê query (spec := spec Œ±) () ‚ü®left, right‚ü©
  return out

@[simp]
instance BTFieldIsDomain (k : ‚Ñï) : IsDomain (BTField k) := inferInstance

def oracleReduction (i : Fin n) : OracleReduction oSpec
    (StatementRound R n i.castSucc) (OracleStatement R n deg) Unit
    (StatementRound R n i.succ) (OracleStatement R n deg) Unit (pSpec R deg) :=
  (Simple.oracleReduction R deg D oSpec).liftContext (oCtxLens R n deg D i)

def init (s : Fin (n + 1) ‚Üí‚ÇÄ M) : Fin n ‚Üí‚ÇÄ M :=
  Finsupp.equivFunOnFinite.symm (Fin.init s)

PFunctor in Mathlib.Data.PFunctor.Univariate.Basic

Nat.and_distrib_right in Init.Data.Nat.Bitwise.Lemmas

instance : SliceLT (FullTranscript pSpec) ‚Ñï
    (fun _ stop => stop ‚â§ n)
    (fun _ stop _ => FullTranscript (pSpec‚ü¶:stop‚üß))
    where
  sliceLT := fun v stop h => take stop h v

instance [Zero T] [ToNat T] : DecidableRel (@LT.lt (Cayley T) _) := fun a b =>
  Nat.decLt (‚Üëa) (‚Üëb)

noncomputable def listDecodingCollisionProbability
  (œÜ : Œπ ‚Ü™ F) (f : Œπ ‚Üí F) (Œ¥ : ‚Ñù) (s degree : ‚Ñï)
  (h_nonempty : Nonempty (domainComplement œÜ)) : ENNReal :=
  Pr_{let r ‚Üê$·µñ (Fin s ‚Üí domainComplement œÜ)}[ ‚àÉ (u u' : code œÜ degree),
                                    u.val ‚â† u'.val ‚àß
                                    u.val ‚àà relHammingBall (code œÜ degree) f Œ¥ ‚àß
                                    u'.val ‚àà relHammingBall (code œÜ degree) f Œ¥ ‚àß
                                    ‚àÄ i : Fin s,
                                    let uPoly := decodeLT u
                                    let uPoly' := decodeLT u'
                                    (uPoly : F[X]).eval (r i).1
                                      = (uPoly' : F[X]).eval (r i).1
                                    ]

@[inline]
def ofOutputOnly
    (liftWit : OuterStmtIn √ó OuterWitIn ‚Üí InnerStmtOut √ó InnerWitOut ‚Üí OuterWitOut) :
    Witness.Lens OuterStmtIn InnerStmtOut OuterWitIn OuterWitOut OuterWitIn InnerWitOut :=
  ‚ü®Prod.snd, liftWit‚ü©

def BBF_eq_multiplier (r : Fin ‚Ñì ‚Üí L) : MultilinearPoly L ‚Ñì :=
  ‚ü®MvPolynomial.eqPolynomial r, by admit /- proof elided -/
  ‚ü©

RingHomCompTriple in Mathlib.Algebra.Ring.CompTypeclasses

@[inline]
def nsmul [SMul ‚Ñï R] (m : ‚Ñï) (p : MlPolyEval R n) : MlPolyEval R n := p.map (fun a => m ‚Ä¢ a)

instance [VCVCompatible A] : ‚àÄ i, VCVCompatible ((vPSpec.toProtocolSpec A).Challenge i) :=
  fun _ => by admit /- proof elided -/

structure TraceMapProperty (F : Type*) [Field F] (u : F) (k : ‚Ñï) : Prop where
  element_trace : ‚àë i ‚àà Finset.range (2 ^ k), u ^ (2 ^ i) = 1
  inverse_trace : ‚àë i ‚àà Finset.range (2 ^ k), (u‚Åª¬π) ^ (2 ^ i) = 1

noncomputable def towerRingEquivFromConcrete0 : ConcreteBTField 0 ‚âÉ+* BTField 0 :=

@[reducible]
def backwardPermutationOracle (Œ± : Type*) : OracleSpec Unit := Œ± ‚Üí‚Çí Œ±

CommRing in Mathlib.Algebra.Ring.Defs

def absorb (sponge : DuplexSponge U C) (ls : List U) :
    OracleComp (forwardPermutationOracle C) (DuplexSponge U C) :=
  match ls with
  
  
  | [] => pure { sponge with squeezePos := Fin.last SpongeSize.R }
  
  | x :: xs =>
    
    
    
    if sponge.absorbPos = SpongeSize.R then do
      let permutedState ‚Üê query (spec := forwardPermutationOracle _) () (sponge.state)
      let newSponge : DuplexSponge U C := {
        state := SpongeState.modify permutedState (Vector.set ¬∑ 0 x),
        absorbPos := 1
        squeezePos := Fin.last SpongeSize.R }
      
      absorb newSponge xs
    else do
      
      
      
      let newSponge : DuplexSponge U C := {
        state := SpongeState.modify sponge.state (Vector.set ¬∑ (sponge.absorbPos : Nat) x),
        absorbPos := sponge.absorbPos + 1,
        squeezePos := Fin.last SpongeSize.R }
      absorb newSponge xs

def MlPoly.mk {R : Type*} (n : ‚Ñï) (v : Vector R (2 ^ n)) : MlPoly R n := v

instance [Semiring R] : Module R (MlPolyEval R n) where
  smul := smul
  one_smul a := by admit /- proof elided -/

Finsupp.linearCombination in Mathlib.LinearAlgebra.Finsupp.LinearCombination

@[inline]
def ofArray [Zero R] (coeffs : Array R) (n : ‚Ñï) : MlPolyEval R n :=
  .ofFn (fun i => if h : i.1 < coeffs.size then coeffs[i] else 0)

private def Bi (B : Finset (Fin n ‚Üí F)) (i : Fin n) : Finset ((Fin n ‚Üí F) √ó (Fin n ‚Üí F)) :=
  { x | x ‚àà B √óÀ¢ B ‚àß x.1 i = x.2 i ‚àß x.1 ‚â† x.2 }

def monomialXY (n m : ‚Ñï) : F ‚Üí‚Çó[F] F[X][Y] where
  toFun t := ‚ü®Finsupp.single m ‚ü®(Finsupp.single n t)‚ü©‚ü©
  map_add' x y := by admit /- proof elided -/

def ar2 (k0 k1 : ‚Ñï) : Fin 2 ‚Üí ‚Ñï
  | ‚ü®0, _‚ü© => k0
  | ‚ü®1, _‚ü© => k1

@[simp]
instance BTFieldNoZeroDiv (k : ‚Ñï) : NoZeroDivisors (BTField k) :=

Trans in Init.Prelude

@[inline]
def smul [Mul R] (r : R) (p : MlPoly R n) : MlPoly R n := p.map (fun a => r * a)

noncomputable instance {v : Œπ ‚Üí F} {s : AffineSubspace F (Œπ ‚Üí F)} [Fintype s] :
    Fintype (v +·µ• s) := Fintype.ofFinite ‚Ü•(v +·µ• s)

def bool (j : Fin numWires) : Gate ùì° numWires :=
  { qL := -1, qR := 0, qO := 0, qM := 1, qC := 0, a := j, b := j, c := j }

def rootMultiplicity.{u} {F : Type u} [CommSemiring F] [DecidableEq F]
  (f : F[X][Y]) (x y : F) : Option ‚Ñï :=
  let X := (Polynomial.X : Polynomial F)
  rootMultiplicity‚ÇÄ (F := F) ((f.comp (Y + (C (C y)))).map (Polynomial.compRingHom (X + C x)))

noncomputable def finalSumcheckProver :
  OracleProver
    (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì))
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì))
    (StmtOut := FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì))
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (WitOut := Unit)
    (pSpec := pSpecFinalSumcheckStep (L := L)) where
  PrvState := fun
    | 0 => Statement (L := L) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì) √ó (‚àÄ j, OracleStatement ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì) j)
        √ó Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì)
    | _ => Statement (L := L) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì) √ó (‚àÄ j, OracleStatement ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì) j)
        √ó Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì) √ó L
  input := fun ‚ü®‚ü®stmt, oStmt‚ü©, wit‚ü© => (stmt, oStmt, wit)

  sendMessage
  | ‚ü®0, _‚ü© => fun ‚ü®stmtIn, oStmtIn, witIn‚ü© => do
    let f‚Ñì : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := ‚ü®‚Ñì, by admit /- proof elided -/
    ‚ü©)
      := witIn.f
    
    let c : L := f‚Ñì ‚ü®0, by admit /- proof elided -/
    ‚ü© 
    pure ‚ü®c, (stmtIn, oStmtIn, witIn, c)‚ü©

  receiveChallenge
  | ‚ü®0, h‚ü© => nomatch h 

  output := fun ‚ü®stmtIn, oStmtIn, witIn, c‚ü© => do
    let stmtOut : FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì) := {
      ctx := stmtIn.ctx,
      
      sumcheck_target := stmtIn.sumcheck_target,
      challenges := stmtIn.challenges,
      final_constant := c
    }

    pure (‚ü®stmtOut, oStmtIn‚ü©, ())

def findSumIdx (l : List Œ±) (j : Œ±) : ‚Ñï := l.partialSum.findIdx (j < ¬∑)

@[elab_as_elim]
def dflatten {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {motive : (k : Fin (vsum n)) ‚Üí Sort*}
    (v : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí motive (embedSum i j)) (k : Fin (vsum n)) : motive k :=
  match m with
  | 0 => Fin.elim0 k
  | _ + 1 =>
    dappend
      (fun j => v 0 j)
      (fun j => dflatten (motive := fun j => motive (natAdd _ j)) (fun i => v i.succ) j)
      k

@[reducible]
def sumcheckFoldOracleReduction :=
  let stmt : Fin (‚Ñì / œë - 1 + 1) ‚Üí Type :=
    fun i => Statement (L := L) (‚Ñì := ‚Ñì) Context ‚ü®i * œë, blockIdx_mul_œë_lt_‚Ñì_succ i‚ü©
  let oStmt := fun i: Fin (‚Ñì / œë - 1 + 1) =>
    OracleStatement ùîΩq Œ≤ œë ‚ü®i * œë, blockIdx_mul_œë_lt_‚Ñì_succ i‚ü©
  let wit := fun i: Fin (‚Ñì / œë - 1 + 1) =>
    Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì)
      ‚ü®i * œë, blockIdx_mul_œë_lt_‚Ñì_succ i‚ü©
  let nonLastBlocksOracleReduction :=
  OracleReduction.seqCompose (oSpec := []‚Çí)
      (Stmt := stmt)
      (OStmt := oStmt) (Wit := wit)
      (pSpec := fun (bIdx: Fin (‚Ñì / œë - 1)) => pSpecFullNonLastBlock ùîΩq Œ≤ bIdx)
      (R := fun bIdx => nonLastBlockOracleReduction (L:=L) ùîΩq Œ≤ (œë:=œë) (ùìë:=ùìë) (bIdx:=bIdx))

  let lastOracleReduction := lastBlockOracleReduction ùîΩq Œ≤ (œë:=œë) (ùìë:=ùìë)

  let coreInteractionOracleReduction: OracleReduction []‚Çí
    (StmtIn := Statement (L := L) (‚Ñì := ‚Ñì) Context 0)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë 0)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) 0)
    (StmtOut := Statement (L := L) (‚Ñì:=‚Ñì) Context (Fin.last ‚Ñì))
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) (Fin.last ‚Ñì))
    (pSpec := pSpecSumcheckFold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
     := by admit /- proof elided -/

UInt8.ofFin in Init.Data.UInt.Basic

Fin.succAboveEmb in Mathlib.Data.Fin.Embedding

def DVec {m : Type v} (Œ± : m ‚Üí Type u) : Type (max u v) := ‚àÄ i, Œ± i

def inputRelation [DecidableEq F] (Œ¥ : ‚Ñù‚â•0) :
    Set
      (
        (Statement (k := k) F 0 √ó (‚àÄ j, OracleStatement (k := k) D x s 0 j)) √ó
        Witness F s d (0 : Fin (k + 2))
      ) :=
  match k with
  | 0 => FinalFoldPhase.inputRelation D x s d (round_bound dom_size_cond) Œ¥
  | .succ _ => FoldPhase.inputRelation D x s d 0 (round_bound dom_size_cond) Œ¥

Fintype.card in Mathlib.Data.Fintype.Card

StateT in Init.Control.State

Polynomial.roots in Mathlib.Algebra.Polynomial.Roots

@[reducible, simp] def OStmtOut := fun _ : Fin 2 => OStatement

Polynomial.support in Mathlib.Algebra.Polynomial.Basic

List.leftpad in Init.Data.List.Basic

IsLinearMap in Mathlib.Algebra.Module.LinearMap.Defs

IsDomain in Mathlib.Algebra.Ring.Defs

IsField in Mathlib.Algebra.Field.IsField

def dist' (C : Set (n ‚Üí R)) [Fintype C] : ‚Ñï‚àû :=
  Finset.min <| ((@Finset.univ (C √ó C) _).filter (fun p => p.1 ‚â† p.2)).image
    (fun ‚ü®u, v‚ü© => hammingDist u.1 v.1)

Function.update in Mathlib.Logic.Function.Basic

def getLast (a : Array Œ±) (h : a.size > 0) : Œ± := a[a.size - 1]

instance [h : VerifierFirst pSpec] : IsEmpty (pSpec.MessageIdx) where
  false | ‚ü®0, h'‚ü© => by admit /- proof elided -/

instance instSelectableTypeChallengePSpec [SelectableType R] :
    ‚àÄ i, SelectableType ((pSpec R deg).Challenge i) :=
  instSelectableTypeChallengeAppend

structure DomainSeparator (U : Type) [SpongeUnit U] (H : Type*) [DuplexSpongeInterface U H] where
   
  io : String
deriving Repr

@[inline] def add (a b : AssocNat) : AssocNat :=
  ‚ü®a ‚àò b, by admit /- proof elided -/
  ‚ü©

def commitKnowledgeError {i : Fin ‚Ñì}
    (m : (pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i).ChallengeIdx) : ‚Ñù‚â•0 :=
  match m with
  | ‚ü®j, hj‚ü© => by admit /- proof elided -/

@[inline] def div [Zero T] [DecidableEq T] [ToNat T]
    (dividend divisor : Cayley T) : Cayley T :=
  
  letI fuel := (‚Üëdividend : Nat) + 1
  divNat dividend divisor fuel

def soundness (langIn : Set StmtIn) (langOut : Set StmtOut)
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    (soundnessError : ‚Ñù‚â•0) : Prop :=
  ‚àÄ WitIn WitOut : Type,
  ‚àÄ witIn : WitIn,
  ‚àÄ prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec,
  ‚àÄ stmtIn ‚àâ langIn,
    letI reduction := Reduction.mk prover verifier
    [fun ‚ü®_, stmtOut‚ü© => stmtOut ‚àà langOut
    | do (simulateQ (impl ++‚Çõ‚Çí challengeQueryImpl : QueryImpl _ (StateT œÉ ProbComp))
        <| reduction.run stmtIn witIn).run' (‚Üê init)] ‚â§ soundnessError

noncomputable def towerRingHomForwardMap (k : ‚Ñï) : ConcreteBTField k ‚Üí BTField k :=

def fflatten‚ÇÇ {A : Sort u} {B : Sort v} {F : A ‚Üí B ‚Üí Sort w} {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï}
    {Œ± : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí A} {Œ≤ : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí B}
    (v : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí F (Œ± i j) (Œ≤ i j)) :
    (k : Fin (vsum n)) ‚Üí F (Fin.vflatten Œ± k) (Fin.vflatten Œ≤ k) :=
  match m with
  | 0 => !h[]
  | _ + 1 => fappend‚ÇÇ (v 0) (fflatten‚ÇÇ (fun i => v i.succ))

Function.LeftInverse in Init.Data.Function

Nat.iterate in Mathlib.Logic.Function.Iterate

DecidableRel in Init.Prelude

Fin.dfoldr in Batteries.Data.Fin.Basic

Nat.clog in Mathlib.Data.Nat.Log

instance [ProverFirst pSpec] [h : OracleInterface (pSpec.¬´Type¬ª 0)] :
    ‚àÄ i, OracleInterface (pSpec.Message i)
  | ‚ü®0, _‚ü© => inferInstance

noncomputable def foldingBadEventAtBlock
    (stmtIdx : Fin (‚Ñì + 1)) (oracleIdx : Fin (‚Ñì + 1))
    (oStmt : ‚àÄ j, (OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (i := oracleIdx) j))
    (challenges : Fin stmtIdx ‚Üí L)
    (j : Fin (toOutCodewordsCount ‚Ñì œë oracleIdx)) : Prop :=
  have h_œë: œë > 0 := by admit /- proof elided -/

def subNat [Zero T] [ToNat T] (a : Cayley T) : Nat ‚Üí Cayley T
  | 0        => a
  | .succ k  => pred (subNat a k)

def Transcript.extractSalt {k : Fin (n + 1)} (transcript : (pSpec.addSalt Salt).Transcript k) :
    (i : pSpec.MessageIdxUpTo k) ‚Üí Salt ‚ü®i.val.castLE (by admit /- proof elided -/
    ), by admit /- proof elided -/
    ‚ü© :=
  fun i => by admit /- proof elided -/

noncomputable def changeOfBasisMatrix (‚Ñì : Nat) (h_‚Ñì : ‚Ñì ‚â§ r) : Matrix (Fin (2^‚Ñì)) (Fin (2^‚Ñì)) L :=
    fun j i => (toCoeffsVec (L := L) (‚Ñì := ‚Ñì) (
      basisVectors ùîΩq Œ≤ ‚Ñì h_‚Ñì j)) i

noncomputable def byCheckMatrix [CommRing F] (H : Matrix Œπ Œ∫ F) : LinearCode Œ∫ F :=
  LinearMap.ker H.mulVecLin

def churchAnd (p q : ChurchBool Œ±) : ChurchBool Œ± :=
  fun x y => p (q x y) y

instance : ‚àÄ i, SelectableType (Challenge !p[] i) :=
  fun ‚ü®i, h‚ü© =>
    (Fin.elim0 i : (h' : !p[].dir i = .V_to_P) ‚Üí SelectableType (!p[].Challenge ‚ü®i, h'‚ü©)) h

@[reducible, inline, specialize]
def Messages (pSpec : ProtocolSpec n) : Type := ‚àÄ i, pSpec.Message i

noncomputable def commitRbrExtractor (i : Fin ‚Ñì) :
  Extractor.RoundByRound []‚Çí
    (StmtIn := (Statement (L := L) Context i.succ) √ó (‚àÄ j, OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc j))
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (pSpec := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)
    (WitMid := fun _messageIdx => Witness (L := L) ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ) where
  eqIn := rfl
  extractMid := fun _ _ _ witMidSucc => witMidSucc
  extractOut := fun _ _ witOut => witOut

List.Vector.get in Mathlib.Data.Vector.Defs

ConvexOn in Mathlib.Analysis.Convex.Function

@[ext]
structure ProverState (n : ‚Ñï) where
  PrvState : Fin (n + 1) ‚Üí Type

Polynomial.natDegree in Mathlib.Algebra.Polynomial.Degree.Definitions

instance : NonBinaryField Field where
  char_neq_2 := by admit /- proof elided -/

def finUInt16Equiv : Fin (2 ^ 16) ‚âÉ UInt16 where
  toFun := fun i => UInt16.ofFin i
  invFun := fun u => u.toFin
  left_inv _ := rfl
  right_inv _ := rfl

def ConstraintSystem (ùì° : Type) (numWires numGates : ‚Ñï) := Fin numGates ‚Üí Gate ùì° numWires

Array.reverse in Init.Data.Array.Basic

def BindingAdversary (oSpec : OracleSpec Œπ) (Data Commitment AuxState : Type)
    [O : OracleInterface Data] :=
  OracleComp oSpec (Commitment √ó O.Query √ó O.Response √ó O.Response √ó AuxState)

Set.Ioo in Mathlib.Order.Interval.Set.Defs

class IsSingleRound (pSpec : ProtocolSpec 2) extends ProverFirst pSpec, VerifierLast pSpec

alias ProverThenVerifier := IsSingleRound

def ofMessagesChallenges (messages : Messages pSpec) (challenges : Challenges pSpec) :
    FullTranscript pSpec :=

@[reducible, inline, specialize, simp]
def MessageIdx (vPSpec : VectorSpec n) := {i : Fin n // vPSpec.dir i = .P_to_V}

instance : Unique (Transcript 0 pSpec) where
  default := fun i => Fin.elim0 i
  uniq := fun T => by admit /- proof elided -/

ToString in Init.Data.ToString.Basic

@[inline] def sub [Zero T] [ToNat T] (a b : Cayley T) : Cayley T :=
  subNat a ‚Üëb

noncomputable def Pz
  {k : ‚Ñï}
  {z : F}
  (hS : z ‚àà coeffs_of_close_proximity k œâs Œ¥ u‚ÇÄ u‚ÇÅ)
  :
  F[X]
  := (exists_Pz_of_coeffs_of_close_proximity (n := n) (k := k) hS).choose

instance {Œ± : Type} {s : Skeleton} :
    CoeFun (LeafData Œ± s) fun (_ : LeafData Œ± s) => SkeletonLeafIndex s ‚Üí Œ± where
  coe := fun tree idx => tree.get idx

noncomputable def embeddingOfùí™IntoùïÉ (H : F[X][Y]) : ùí™ H ‚Üí+* ùïÉ H :=
  Ideal.quotientMap
        (I := Ideal.span {H_tilde' H}) (Ideal.span {H_tilde H})
        bivPolyHom sorry

@[reducible]
def index (op : MemoryWrite Œπ Œ±) := op.1

def squeeze (sponge : DuplexSponge U C) (len : Nat) :
    OracleComp (forwardPermutationOracle C) (Vector U len √ó DuplexSponge U C) :=
  match len with
  
  | 0 => pure (#v[], sponge)
  
  | n + 1 => do
    
    let sponge1 : DuplexSponge U C := { sponge with absorbPos := 0 }
    let sponge2 ‚Üê if sponge1.squeezePos = SpongeSize.R then
      let permutedState ‚Üê query (spec := forwardPermutationOracle _) () (sponge1.state)
      let sponge2 : DuplexSponge U C := { sponge1 with state := permutedState, squeezePos := 0 }
      pure sponge2
    else
      pure sponge1
    let squeezedVal := (SpongeState.get sponge2.state)[sponge2.squeezePos]
    let sponge3 := { sponge2 with squeezePos := sponge2.squeezePos + 1 }
    
    let (restVec, sponge4) ‚Üê squeeze sponge3 n
    
    
    return (restVec.insertIdx 0 squeezedVal, sponge4)

@[simp]
def innerRelIn_Test : Set (InnerStmtIn_Test √ó Unit) :=
  setOf (fun ‚ü®‚ü®f, t‚ü©, _‚ü© => ‚àë x ‚àà {0, 1}, f.eval x = t)

class HasSize (Œ± : Type*) (Œ≤ : Type*) where
  size : Nat
  toFun : Œ± ‚Ü™ Vector Œ≤ size

structure BacktrackSequenceFamily (trace : QueryLog (duplexSpongeChallengeOracle StmtIn U))
    (state : CanonicalSpongeState U) where
   
  seqFamily : Finset (BacktrackSequence trace state)
   
  maximality : ‚àÄ s ‚àà seqFamily, ‚àÄ s' ‚àà seqFamily,
    (s.stmt ‚â† s'.stmt) ‚à® ¬¨ (s.inputState ‚äÜ s'.inputState) ‚à® ¬¨ (s'.outputState ‚äÜ s.outputState)

@[inline]
def seqCompose {m : ‚Ñï} (Stmt : Fin (m + 1) ‚Üí Type) (Wit : Fin (m + 1) ‚Üí Type)
    {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (R : (i : Fin m) ‚Üí
      Reduction oSpec (Stmt i.castSucc) (Wit i.castSucc) (Stmt i.succ) (Wit i.succ) (pSpec i)) :
    Reduction oSpec (Stmt 0) (Wit 0) (Stmt (Fin.last m)) (Wit (Fin.last m)) (seqCompose pSpec) where
  prover := Prover.seqCompose Stmt Wit (fun i => (R i).prover)
  verifier := Verifier.seqCompose Stmt (fun i => (R i).verifier)

instance [DecidableEq Œπ] : Memory Œπ Œ± (‚àÄ i, Œ± i) where
  read m i := m i
  write m i v := Function.update m i v

Subtype.val in Init.Prelude

Vector.tail in Init.Data.Vector.Basic

def domainEmb {i : ‚Ñï} : evalDomain D i ‚Ü™ F :=
  ‚ü®
    fun x => x.1.1,
    by admit /- proof elided -/
  ‚ü©

Subgroup.zpowers in Mathlib.Algebra.Group.Subgroup.ZPowers.Basic

instance : ‚àÄ j, OracleInterface ((pSpecSumcheckFold ùîΩq Œ≤ (œë:=œë)
  (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).Message j) := instOracleInterfaceMessageAppend

instance AffSpanSet.instFinite [NeZero k] (u : Fin k ‚Üí Œπ ‚Üí F) : (AffSpanSet u).Finite :=

instance {Œπ : Type} : OracleInterface (OracleStatement Œπ F ()) := OracleInterface.instFunction

noncomputable def fromConcreteBTF0 : ConcreteBTField 0 ‚Üí (GF(2)) :=
  fun x => if decide (x = zero) then 0 else 1

@[inline]
def ofInputOnly
    (stmtProj : OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i) ‚Üí InnerStmtIn √ó (‚àÄ i, InnerOStmtIn i))
    (witProj : (OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i)) √ó OuterWitIn ‚Üí InnerWitIn) :
    OracleContext.Lens OuterStmtIn OuterStmtOut InnerStmtIn OuterStmtOut
                OuterOStmtIn OuterOStmtOut InnerOStmtIn OuterOStmtOut
                OuterWitIn OuterWitOut InnerWitIn OuterWitOut where
  stmt := OracleStatement.Lens.ofInputOnly stmtProj
  wit := Witness.Lens.ofInputOnly witProj

MvPolynomial.coeff in Mathlib.Algebra.MvPolynomial.Basic

def forwardPermutationOracleImpl {Œ± : Type*} [Permute Œ±] :
    QueryImpl (forwardPermutationOracle Œ±) Id where
  impl | query () q => Permute.permute (Œ± := Œ±) q

def Extractor.RoundByRound.id :
    Extractor.RoundByRound oSpec Statement Witness Witness !p[] (fun _ => Witness) where
  eqIn := rfl
  extractMid := fun i => Fin.elim0 i
  extractOut := fun _ _ => _root_.id

Polynomial.reverse in Mathlib.Algebra.Polynomial.Reverse

def getRootIndex (s : Skeleton) : SkeletonNodeIndex s := match s with
  | Skeleton.leaf => SkeletonNodeIndex.ofLeaf
  | Skeleton.internal _ _ =>
    SkeletonNodeIndex.ofInternal

noncomputable def disagreementSet
  (i k : ‚Ñï) {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F}
  [DecidableEq F] [DecidableEq Œπ] [Smooth œÜ]
  (f : (indexPowT S œÜ i) ‚Üí F) (S' : Finset (indexPowT S œÜ i))
  (œÜ' : (indexPowT S œÜ i) ‚Ü™ F) [‚àÄ i : ‚Ñï, Fintype (indexPowT S œÜ i)]
  [h : DecidableBlockDisagreement i k f S' œÜ'] :
  (g : (indexPowT S œÜ i) ‚Üí F) ‚Üí Finset (indexPowT S œÜ k) :=
  fun g =>
    Finset.univ.filter (fun z => @decide _ (h.dec_inst z g))

@[simp]
def outerRelIn_Test : Set (OuterStmtIn_Test √ó Unit) :=
  setOf (fun ‚ü®‚ü®p, q, t‚ü©, _‚ü© => ‚àë x ‚àà {0, 1}, (p * q).eval x = t)

noncomputable def liftToFunctionField {H : F[X][Y]} : F[X] ‚Üí+* ùïÉ H :=
  RingHom.comp (Ideal.Quotient.mk (Ideal.span {H_tilde H})) coeffAsRatFunc

@[inline] def mul [Zero T] [ToNat T] (a b : Cayley T) : Cayley T :=
  mulNat a ‚Üëb

Submodule.span in Mathlib.LinearAlgebra.Span.Defs

  partial def computePrattPart (l : List PrimeWithMultiplicity) : Option UnverifiedPrattPart := do
    if let [‚ü®p, k‚ü©] := l then
      let cert ‚Üê computePrattCertificate p
      return .prime p k cert

    let ‚ü®left, right‚ü© := l.splitAt (l.length / 2)
    let lhs ‚Üê computePrattPart left
    let rhs ‚Üê computePrattPart right
    return .split lhs rhs

Polynomial.charP in Mathlib.Algebra.Polynomial.Coeff

abbrev Fwd : PermuteDir := Sum.inl ()

noncomputable def fullRbrKnowledgeError (i : (fullPSpec ùîΩq Œ≤ Œ≥_repetitions (œë := œë)
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).ChallengeIdx) : ‚Ñù‚â•0 :=
  Sum.elim (f := CoreInteraction.coreInteractionOracleRbrKnowledgeError ùîΩq Œ≤ (œë:=œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (g := QueryPhase.queryRbrKnowledgeError ùîΩq Œ≤ Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (ChallengeIdx.sumEquiv.symm i)

@[reducible]
def GroupDecodeOracle : OracleSpec Unit := fun _ => (BitVec bitLength √ó Œπ, Unit)

def evalWAt (i : Fin r) (x : L) : L :=
  ((getUElements (Œ≤ := Œ≤) (‚Ñì := ‚Ñì) (R_rate := R_rate) i).map (fun u => x - u)).prod

DFunLike in Mathlib.Data.FunLike.Basic

structure SumcheckBaseContext (L : Type) (‚Ñì : ‚Ñï) where
  t_eval_point : Fin ‚Ñì ‚Üí L         
  original_claim : L               

instance {i : Fin (n + 1)} : OfNat (evalDomain D i) 1 where
  ofNat := ‚ü®1, one_in_doms D i‚ü©

def knowledgeStateFunction (hRel : ‚àÄ stmtIn witOut,
      (mapStmt stmtIn, witOut) ‚àà relOut ‚Üí (stmtIn, mapWitInv stmtIn witOut) ‚àà relIn) :
    (verifier oSpec mapStmt).KnowledgeStateFunction
      init impl relIn relOut (extractor mapWitInv) where
  toFun | ‚ü®0, _‚ü© => fun stmtIn _ witIn => ‚ü®stmtIn, witIn‚ü© ‚àà relIn
  toFun_empty := fun stmtIn witIn => by admit /- proof elided -/

def curve : WeierstrassCurve BaseField := {
  a‚ÇÅ := 0,  
  a‚ÇÇ := 0,  
  a‚ÇÉ := 0,  
  a‚ÇÑ := 0,  
  a‚ÇÜ := 3   
}

Equiv.cast in Mathlib.Logic.Equiv.Defs

def perfectCompleteness (relIn : Set (StmtIn √ó WitIn)) (relOut : Set (StmtOut √ó WitOut))
    (reduction : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec) : Prop :=
  completeness init impl relIn relOut reduction 0

@[reducible]
def oracleVerifier : OracleVerifier oSpec (StatementRound R n 0) (OracleStatement R n deg)
    (StatementRound R n (.last n)) (OracleStatement R n deg) (pSpec R deg n) :=
  OracleVerifier.seqCompose (oSpec := oSpec)
    (Stmt := StatementRound R n)
    (OStmt := fun _ => OracleStatement R n deg)
    (pSpec := fun _ => SingleRound.pSpec R deg)
    (SingleRound.oracleVerifier R n deg D oSpec)

Nat.gcd in Init.Data.Nat.Gcd

instance instDCast‚ÇÅ‚ÇÇ : DCast (Œ≤ a) (Œ≥ a) where
  dcast hb c := dcast‚ÇÇ (Eq.refl a) (by admit /- proof elided -/
  ) c
  dcast_id := by admit /- proof elided -/

instance [IsSingleRound pSpec] : Unique (pSpec.ChallengeIdx) where
  default := ‚ü®1, by admit /- proof elided -/
  ‚ü©
  uniq := fun ‚ü®i, hi‚ü© => by admit /- proof elided -/

def relayPrvState (i : Fin ‚Ñì) : Fin (0 + 1) ‚Üí Type := fun
  | ‚ü®0, _‚ü© => Statement (L := L) Context i.succ √ó
    (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j) √ó
    Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ

def outputRelation :
    Set
      (
        (Fri.Spec.Statement F (0 : Fin (k + 1)) √ó
        (‚àÄ j, Fri.Spec.OracleStatement D x s (0 : Fin (k + 1)) j)) √ó
        Fri.Spec.Witness F s d (0 : Fin (k + 2))
      ) := sorry

instance instDecidableEqOption {Œ± : Type*} [DecidableEq Œ±] :
    DecidableEq (Option Œ±) := inferInstance

def relayKnowledgeError (m : pSpecRelay.ChallengeIdx) : ‚Ñù‚â•0 :=
  match m with
  | ‚ü®j, _‚ü© => j.elim0

noncomputable def additiveNTT (a : Fin (2 ^ ‚Ñì) ‚Üí L) : Fin (2^(‚Ñì + R_rate)) ‚Üí L :=
  let b: Fin (2^(‚Ñì + R_rate)) ‚Üí L := tileCoeffs a 
  Fin.foldl (n:=‚Ñì) (f:= fun current_b i  =>
    NTTStage ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®‚Ñì - 1 - i, by admit /- proof elided -/
    ‚ü©) current_b
  ) (init:=b)

@[reducible, inline, specialize]
def Transcript (k : Fin (n + 1)) (pSpec : ProtocolSpec n) : Type :=
  (pSpec‚ü¶:k.val‚üß).FullTranscript

instance [inst : ‚àÄ i, DecidableEq (pSpec.Message i)] {k : Fin (n + 1)} :
    DecidableEq (MessagesUpTo k pSpec) :=
  @Fintype.decidablePiFintype _ _ (fun i => inst ‚ü®i.1.castLE (by admit /- proof elided -/
  ), i.property‚ü©) _

def findIdxRev?_maximal {cond} {as : Array Œ±} {k : Fin as.size} :
  findIdxRev? cond as = some k ‚Üí ‚àÄ j : Fin as.size, j > k ‚Üí ¬¨ cond as[j] :=

IsCyclic in Mathlib.Algebra.Group.Defs

def uniqueDecodable (C : Code Œπ F) (r : ‚Ñù) : Prop :=
  listDecodable C r 1

def g (n : ‚Ñï) (c : ‚Ñï) (x : ‚Ñï) := (x * x + c) % n

Set.InjOn in Mathlib.Data.Set.Operations

def listOfCloseCodewordsRel (C : Code Œπ F) (y : Œπ ‚Üí F) (r : ‚Ñù) : ‚Ñï :=
  Nat.card (relHammingBall C y r)

instance {k : ‚Ñï} : NatCast (ConcreteBTField k) where
  natCast n:= natCast n

def rdrop (m : ‚Ñï) (h : m ‚â§ n) (pSpec : ProtocolSpec n) : ProtocolSpec (n - m) :=
  {dir := Fin.rdrop m h pSpec.dir, ¬´Type¬ª := Fin.rdrop m h pSpec.¬´Type¬ª}

noncomputable def UniPolyC.toPoly (p : UniPolyC R) : Polynomial R := p.val.toPoly

alias ofPoly := Polynomial.toImpl

OneHom in Mathlib.Algebra.Group.Hom.Defs

@[inline]
def neg [Neg R] (p : MlPolyEval R n) : MlPolyEval R n := p.map (fun a => -a)

œÜ in ToMathlib.Control.Monad.Relative

@[inline, specialize]
def nsmul (n : ‚Ñï) (p : UniPoly R) : UniPoly R :=
  nsmul_raw n p |> trim

@[reducible]
def foldCommitOracleReduction (i : Fin ‚Ñì)
    (hCR : isCommitmentRound ‚Ñì œë i) :
  OracleReduction []‚Çí
    (StmtIn := Statement (L := L) Context i.castSucc)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) i.castSucc)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) i.succ)
    (pSpec := pSpecFoldCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) :=
  OracleReduction.append (oSpec:=[]‚Çí)
    (pSpec‚ÇÅ := pSpecFold (L:=L))
    (pSpec‚ÇÇ := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)
    (R‚ÇÅ := foldOracleReduction ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) i)
    (R‚ÇÇ := commitOracleReduction ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hCR)

def main (args : List String) : IO UInt32 := do lintStyle.validate args

@[reducible, simp]
def soundness (langIn : Set Statement)
    (verifier : Verifier oSpec Statement Bool pSpec)
    (soundnessError : ‚Ñù‚â•0) : Prop :=
  verifier.soundness init impl langIn acceptRejectRel.language soundnessError

def codeOfLinearCode (Œ∫ : Type*) [Fintype Œ∫] (LC : LinearCode Œπ F) : InterleavedCode Œ∫ Œπ F :=
  { MF := matrixSubmoduleOfLinearCode Œ∫ LC, LC := LC }

OracleComp.liftComp in VCVio.OracleComp.Coercions.SubSpec

def squeeze (state : HashStateWithInstructions U H) (outputSize : Nat) :
    Except DomainSeparatorMismatch (HashStateWithInstructions U H √ó Array U) := do
  
  sorry

def getConst (k : ‚Ñï) (s : Fin (k + 1) ‚Üí ‚Ñï+) : OracleComp [FinalOracleStatement D x s]‚Çí F[X] :=
  OracleComp.lift
    (by admit /- proof elided -/
    )

Algebra.TensorProduct.includeLeftRingHom in Mathlib.RingTheory.TensorProduct.Basic

@[reducible, simp] def StmtAfterSendClaim : Type := R

PMF.uniformOfFintype in Mathlib.Probability.Distributions.Uniform

def concat {k : Fin n} (messages : MessagesUpTo k.castSucc pSpec)
    (h : pSpec.dir k = .P_to_V) (msg : pSpec.Message ‚ü®k, h‚ü©) : MessagesUpTo k.succ pSpec :=
  fun ‚ü®i, h‚ü© => (concat' (pSpec := pSpec) (fun i hi => messages ‚ü®i, hi‚ü©) (fun _ => msg)) i h

structure CodeParams (P : Params Œπ F) (Dist : Distances M) where
  C : ‚àÄ i : Fin (M + 1), Set ((Œπ i) ‚Üí F)
  h_code : ‚àÄ i : Fin (M + 1), C i = code (P.œÜ i) (degree Œπ P i)
  h_listDecode : ‚àÄ i : Fin (M + 1), i ‚â† 0 ‚Üí listDecodable (C i) (Dist.Œ¥ i) (Dist.l i)

def intCast_ofNat {k : ‚Ñï} (n : ‚Ñï) : intCast (k:=k) (n : ‚Ñ§) = natCast n :=

def relHammingBallInterleavedCode [DecidableEq F] (U : Matrix Œ∫ Œπ F)
  (IC : MatrixSubmodule Œ∫ Œπ F) (r : ‚Ñù) :=
    {V | V ‚àà IC ‚àß relDistCodewords U V < r}

@[ext]
structure ProverRound {Œπ : Type} (oSpec : OracleSpec Œπ) {n : ‚Ñï} (pSpec : ProtocolSpec n)
    extends ProverState n where
   
  sendMessage (i : MessageIdx pSpec) :
    PrvState i.1.castSucc ‚Üí OracleComp oSpec (pSpec.Message i √ó PrvState i.1.succ)
   
  receiveChallenge (i : ChallengeIdx pSpec) :
    PrvState i.1.castSucc ‚Üí OracleComp oSpec (pSpec.Challenge i ‚Üí PrvState i.1.succ)

instance {n : ‚Ñï} {Œ± : Fin n ‚Üí Type*} : Slice ((i : Fin n) ‚Üí Œ± i) ‚Ñï ‚Ñï
    (fun _ start stop => start ‚â§ stop ‚àß stop ‚â§ n)
    (fun _ start stop h =>
      (i : Fin (stop - start)) ‚Üí
        Œ± (castLE h.2 (Fin.cast (Nat.sub_add_cancel h.1) (i.addNat start))))
    where
  slice := fun v start stop h => Fin.drop start h.1 (Fin.take stop h.2 v)

@[reducible]
def combineMap : StmtIn √ó WitIn ‚Üí OracleComp oSpec (StmtOut √ó WitOut) :=
  fun ‚ü®stmt, wit‚ü© => do return (‚Üê mapStmt stmt, ‚Üê mapWit stmt wit)

@[reducible]
def OracleStatement : Fin (m + 1) ‚Üí Type :=
  fun _ => evalDomain D x 0 ‚Üí F

abbrev OutputStatement := StatementRound R _ (.last n)

protected def cast (P : OracleProver oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec‚ÇÅ) :
    OracleProver oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec‚ÇÇ :=
  Prover.cast hn hSpec P

instance coe_field_adjoinRoot (k : ‚Ñï) : Coe (AdjoinRoot (poly k)) (BTField (k+1)) where
  coe := Eq.mp (BTField_succ_eq_adjoinRoot k)

instance (priority := low) : DCast Œ± Œ≤ where
  dcast h := cast (congrArg Œ≤ h)
  dcast_id := by admit /- proof elided -/

@[inline] def toT [Zero T] (c : Cayley T) : T := c.toFun 0

noncomputable def fold
  {S : Finset Œπ} (œÜ : Œπ ‚Ü™ F) (f : Œπ ‚Üí F) (k : ‚Ñï) (Œ± : F) : indexPow S œÜ k ‚Üí F :=
    fun x => (xPoly f œÜ k x).eval Œ±

def relation : Set (M √ó M √ó List (MemoryOp Œπ Œ±)) :=
  { ‚ü®startMem, finalMem, ops‚ü© | processMemoryOps ops startMem = some finalMem }

instance : Field ScalarField := ZMod.instField scalarFieldSize

instance : ‚àÄ j, OracleInterface ((pSpecFoldRelay (L:=L)).Message j) :=
  instOracleInterfaceMessageAppend

def SkeletonNodeIndex.rightChild {s : Skeleton} (idx : SkeletonNodeIndex s) :
    Option (SkeletonNodeIndex s) :=
  match idx with
  | SkeletonNodeIndex.ofLeaf => none
  | @SkeletonNodeIndex.ofInternal left right =>
    some (SkeletonNodeIndex.ofRight (getRootIndex right))
  | SkeletonNodeIndex.ofLeft idxLeft =>
    idxLeft.rightChild.map (SkeletonNodeIndex.ofLeft)
  | SkeletonNodeIndex.ofRight idxRight =>
    idxRight.rightChild.map (SkeletonNodeIndex.ofRight)

def lt {Œ± : Type} (m n : ChurchNat Œ±) : ChurchBool Œ± :=
  ChurchBool.churchAnd (leq m n) (ChurchBool.churchNot (leq n m))

def sumAll (n : ‚Ñï) (D : Fin n ‚Üí Finset R) : MvPolynomial (Fin n) R ‚Üí‚Çó[R] R :=

class AlgebraTower {Œπ : Type*} [Preorder Œπ] (AT : Œπ ‚Üí Type*)
  [‚àÄ i, CommSemiring (AT i)] where
   
  protected algebraMap : ‚àÄ i j, (h : i ‚â§ j) ‚Üí (AT i ‚Üí+* AT j)
   
  commutes' : ‚àÄ (i j : Œπ) (h : i ‚â§ j) (r : AT i) (x : AT j),
    (algebraMap i j h r) * x = x * (algebraMap i j h r)
  coherence': ‚àÄ (i j k : Œπ) (h1 : i ‚â§ j) (h2 : j ‚â§ k),
    algebraMap i k (h1.trans h2) =
      (algebraMap j k h2).comp (algebraMap i j h1)

instance instDCast‚ÇÇReduction :
    DCast‚ÇÇ Nat ProtocolSpec (fun _ pSpec => Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec) where
  dcast‚ÇÇ := Reduction.cast
  dcast‚ÇÇ_id := Reduction.cast_id

OracleSpec.DecidableEq in VCVio.OracleComp.OracleSpec

structure PrattCertificate' (p : ‚Ñï) : Type where
  a : ZMod p
  pow_eq_one : a ^ (p - 1) = 1
  part : PrattPartList p a (p - 1)

def equivFin2 : Direction ‚âÉ Fin 2 where
  toFun := fun dir => match dir with | .V_to_P => ‚ü®0, by admit /- proof elided -/
  ‚ü© | .P_to_V => ‚ü®1, by admit /- proof elided -/
  ‚ü©
  invFun := fun n => match n with | ‚ü®0, _‚ü© => .V_to_P | ‚ü®1, _‚ü© => .P_to_V
  left_inv := fun dir => match dir with | .P_to_V => rfl | .V_to_P => rfl
  right_inv := fun n => match n with | ‚ü®0, _‚ü© => rfl | ‚ü®1, _‚ü© => rfl

LawfulFunctor in Init.Control.Lawful.Basic

noncomputable def Œ∑Star (U : Type) [SpongeUnit U] [Fintype U]
    (t‚Çï t‚Çö t‚Çö·µ¢ : ‚Ñï) (L : ‚Ñï) (Œµcodec : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) : ‚Ñù‚â•0 :=
  let tTotal : ‚Ñï := (t‚Çï + t‚Çö + t‚Çö·µ¢)
  
  
  
  
  let firstTermNumerator : ‚Ñù‚â•0 :=
    7 * tTotal ^2 + (28 * L + 25) * tTotal + (14 * L + 1) * (L + 1)
  let firstTermDenominator : ‚Ñù‚â•0 := 2 * ((Fintype.card U) ^ (SpongeSize.C + 1))
  
  let secondTerm : ‚Ñù‚â•0 := Œ∏Star t‚Çï t‚Çö t‚Çö·µ¢ * (iSup Œµcodec)
  
  let thirdTerm : ‚Ñù‚â•0 := ‚àë i, Œµcodec i
  
  firstTermNumerator / firstTermDenominator + secondTerm + thirdTerm

noncomputable instance {i : Fin r} (x : L) : Decidable (x ‚àà (U ùîΩq Œ≤ i : Set L)) :=

instance : curve.IsElliptic :=

Algebra.TensorProduct.instAlgebra in Mathlib.RingTheory.TensorProduct.Basic

noncomputable instance : Algebra K (Left ‚äó[K] Right) := Algebra.TensorProduct.instAlgebra

def Verifier.duplexSpongeFiatShamir (V : Verifier oSpec StmtIn StmtOut pSpec) :
    NonInteractiveVerifier (‚àÄ i, pSpec.Message i) (oSpec ++‚Çí duplexSpongeChallengeOracle StmtIn U)
      StmtIn StmtOut where
  verify := fun stmtIn proof => do
    
    let messages : pSpec.Messages := proof 0
    
    let ‚ü®_, transcript‚ü© ‚Üê messages.deriveTranscriptDSFS stmtIn
    V.verify stmtIn transcript

def pow (S : Finset Œπ) (œÜ : Œπ ‚Ü™ F) (k : ‚Ñï) : indexPow S œÜ k ‚Ü™ F :=
    Function.Embedding.subtype fun y => y ‚àà indexPow S œÜ k

@[inline, specialize]
def oracleVerifier : OracleVerifier oSpec
    Unit (fun _ : Fin 2 => OStatement)
    (Query OStatement) (fun _ : Fin 2 => OStatement) (pSpec OStatement) where

  verify := fun _ chal => do
    let q : Query OStatement := chal ‚ü®0, rfl‚ü©
    pure q

  embed := Function.Embedding.inl

  hEq := by admit /- proof elided -/

Finset.univ in Mathlib.Data.Fintype.Defs

@[inline, specialize, simp]
def prover : Prover oSpec Statement Witness Statement Witness !p[] := Prover.id

def inputRelation (cond : ‚àë i, (s i).1 ‚â§ n) [DecidableEq F] (Œ¥ : ‚Ñù‚â•0) :
    Set
      (
        (
          Statement F (Fin.last k) √ó
          (‚àÄ j, OracleStatement D x s (Fin.last k) j)
        ) √ó
        Witness F s d (Fin.last k).castSucc
      ) := sorry

@[ext]
structure ProtocolSpec (n : ‚Ñï) where
   
  dir : Fin n ‚Üí Direction
   
  ¬´Type¬ª : Fin n ‚Üí Type
deriving Inhabited

def RoundByRound.append
    {WitMid‚ÇÅ : Fin (m + 1) ‚Üí Type} {WitMid‚ÇÇ : Fin (n + 1) ‚Üí Type}
    (E‚ÇÅ : Extractor.RoundByRound oSpec Stmt‚ÇÅ Wit‚ÇÅ Wit‚ÇÇ pSpec‚ÇÅ WitMid‚ÇÅ)
    (E‚ÇÇ : Extractor.RoundByRound oSpec Stmt‚ÇÇ Wit‚ÇÇ Wit‚ÇÉ pSpec‚ÇÇ WitMid‚ÇÇ) :
      Extractor.RoundByRound oSpec Stmt‚ÇÅ Wit‚ÇÅ Wit‚ÇÉ (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ)
        (Fin.append (m := m + 1) WitMid‚ÇÅ (Fin.tail WitMid‚ÇÇ) ‚àò Fin.cast (by admit /- proof elided -/
        )) where
  eqIn := by admit /- proof elided -/

structure BinaryTowerInductiveStepResult (k : ‚Ñï) (prevBTField : Type _)
  (prevBTResult : BinaryTowerResult prevBTField k) [instPrevBTFieldIsField : Field prevBTField]
  (prevPoly : Polynomial prevBTField) (F : Type _) where
  binaryTowerResult : BinaryTowerResult F (k+1)
  eq_adjoin : F = AdjoinRoot prevPoly
  u_is_root : Eq.mp (eq_adjoin) binaryTowerResult.specialElement = AdjoinRoot.root prevPoly
  eval_defining_poly_at_root : Eq.mp (eq_adjoin) binaryTowerResult.specialElement^2 +
    Eq.mp (eq_adjoin) binaryTowerResult.specialElement * (of prevPoly) prevBTResult.specialElement
    + 1 = 0

@[reducible]
def Witness := Fin sz.n_w ‚Üí R

@[reducible, simp]
def oraclePSpec : ProtocolSpec 1 := ‚ü®!v[.P_to_V], !v[Witness]‚ü©

def rowSpan : Submodule F (Œπ' ‚Üí F) :=
  Submodule.span F {U i | i : Œπ}

instance : Field BaseField := ZMod.instField baseFieldSize

OptionT in Init.Control.Option

MonoidHom in Mathlib.Algebra.Group.Hom.Defs

noncomputable def NTTStage (i : Fin ‚Ñì) (b : Fin (2 ^ (‚Ñì + R_rate)) ‚Üí L) :
    Fin (2^(‚Ñì + R_rate)) ‚Üí L :=
  have h_2_pow_i_lt_2_pow_‚Ñì_add_R_rate: 2^i.val < 2^(‚Ñì + R_rate) := by admit /- proof elided -/

def finUInt64Equiv : Fin (2 ^ 64) ‚âÉ UInt64 where
  toFun := fun i => UInt64.ofFin i
  invFun := fun u => u.toFin
  left_inv _ := rfl
  right_inv _ := rfl

Fintype.ofIsEmpty in Mathlib.Data.Fintype.OfMap

@[inline]
def zsmul [SMul ‚Ñ§ R] (m : ‚Ñ§) (p : MlPoly R n) : MlPoly R n := p.map (fun a => m ‚Ä¢ a)

affineSpan in Mathlib.LinearAlgebra.AffineSpace.AffineSubspace.Defs

noncomputable def ansPoly (S : Finset F) (Ans : S ‚Üí F) : Polynomial F :=
  Lagrange.interpolate S.attach (fun i => (i : F)) Ans

class VerifierFirst (pSpec : ProtocolSpec n) [NeZero n] where
  verifier_first' : pSpec.dir 0 = .V_to_P

UInt8 in Init.Prelude

Module.Basis.baseChange in Mathlib.LinearAlgebra.TensorProduct.Basis

instance : ‚àÄ i, VCVCompatible (Challenge !p[] i) :=
  fun ‚ü®i, h‚ü© =>
    (Fin.elim0 i : (h' : !p[].dir i = .V_to_P) ‚Üí VCVCompatible (!p[].Challenge ‚ü®i, h'‚ü©)) h

@[inline, reducible]
def proj : OuterStmtIn √ó OuterWitOut ‚Üí InnerWitOut :=
  lens.toFunA

structure FSProverState (U : Type) [SpongeUnit U] (H : Type*) [DuplexSpongeInterface U H]
    (R : Type*) extends FSVerifierState U H where
   
  rng : ProverPrivateRng R
deriving Repr

def numberOfClosePts (u v : Œπ ‚Üí F) (deg : ‚Ñï) (Œ± : Œπ ‚Ü™ F) (e : ‚Ñï) : ‚Ñï :=
  Fintype.card (closePtsOnAffineLine u v deg Œ± e)

def multilinearBasis (l r : ‚Ñï) (h_le : l ‚â§ r) :
    letI instAlgebra : Algebra (BTField l) (BTField r) := binaryAlgebraTower (h_le:=h_le)
    Basis (Fin (2 ^ (r - l))) (BTField l) (BTField r) :=

def SkeletonLeafIndex.toNodeIndex {s : Skeleton} (idx : SkeletonLeafIndex s) :
    SkeletonNodeIndex s :=
  match idx with
  | SkeletonLeafIndex.ofLeaf => SkeletonNodeIndex.ofLeaf
  | SkeletonLeafIndex.ofLeft idxLeft =>
    SkeletonNodeIndex.ofLeft (SkeletonLeafIndex.toNodeIndex idxLeft)
  | SkeletonLeafIndex.ofRight idxRight =>
    SkeletonNodeIndex.ofRight (SkeletonLeafIndex.toNodeIndex idxRight)

noncomputable def relayOracleProver (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
  OracleProver (oSpec := []‚Çí)
    
    (StmtIn := Statement (L := L) Context i.succ)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) i.succ)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) i.succ)
    (pSpec := pSpecRelay) where
  PrvState := relayPrvState ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i
  input := fun ‚ü®‚ü®stmtIn, oStmtIn‚ü©, witIn‚ü© => (stmtIn, oStmtIn, witIn)
  sendMessage | ‚ü®x, h‚ü© => by admit /- proof elided -/
| ‚ü®x, h‚ü© => by admit /- proof elided -/

@[inline, specialize]
def runWithLogToRound (i : Fin (n + 1))
    (stmt : StmtIn) (wit : WitIn) (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí)
        ((pSpec.Transcript i √ó prover.PrvState i) √ó QueryLog (oSpec ++‚Çí [pSpec.Challenge]‚Çí)) :=
  (simulateQ loggingOracle (prover.runToRound i stmt wit)).run

@[reducible, simp]
def perfectCompleteness (relation : Set (Statement √ó Witness))
    (proof : Proof oSpec Statement Witness pSpec) : Prop :=
  Reduction.perfectCompleteness init impl relation acceptRejectRel proof

def extract {n : ‚Ñï} {Œ± : Fin n ‚Üí Sort*} (start stop : ‚Ñï) (h1 : start ‚â§ stop) (h2 : stop ‚â§ n)
    (v : (i : Fin n) ‚Üí Œ± i) : (i : Fin (stop - start)) ‚Üí Œ± ‚ü®i + start, by admit /- proof elided -/
    ‚ü© :=
  fun i ‚Ü¶ v ‚ü®i + start, by admit /- proof elided -/
  ‚ü©

@[simps!]
def MessageIdx.sumEquiv :
    MessageIdx pSpec‚ÇÅ ‚äï MessageIdx pSpec‚ÇÇ ‚âÉ MessageIdx (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ) where
  toFun := Sum.elim (MessageIdx.inl) (MessageIdx.inr)
  invFun := fun ‚ü®i, h‚ü© => by admit /- proof elided -/

  inductive UnverifiedPrattCertificate : ‚Ñï ‚Üí Type
    | knownPrime : (n : ‚Ñï) ‚Üí UnverifiedPrattCertificate n
    | of : (n : ‚Ñï) ‚Üí (a : ‚Ñï) ‚Üí (part : UnverifiedPrattPart) ‚Üí UnverifiedPrattCertificate n
  deriving Repr

noncomputable instance {v : Œπ ‚Üí F} {s : AffineSubspace F (Œπ ‚Üí F)} [inst : Nonempty s] :
    Nonempty (v +·µ• s) :=

class Initialize (Œ± : Type u) (Œ≤ : Type v) where
   
  new : Œ≤ ‚Üí Œ±

def JohnsonDenominator (B : Finset (Fin n ‚Üí F)) (v : Fin n ‚Üí F) : ‚Ñö :=
  let e := e B v
  let d := d B
  let q : ‚Ñö := Fintype.card F
  let frac := q / (q - 1)
  (1- frac * e/n) ^ 2 - (1 - frac * d/n)

noncomputable def definingPoly {F : Type*} [instField : Field F] (s : F)
  := X ^ 2 + C s * X + 1

@[reducible]
def spec : OracleSpec Unit := fun _ => (Œ± √ó Œ±, Œ±)

@[reducible, simp] def OStmtIn : Unit ‚Üí Type := fun _ => R‚¶É‚â§ deg‚¶Ñ[X]

def partition (cs : ConstraintSystem ùì° numWires numGates) :
    Fin numWires ‚Üí Finset (Fin (3 * numGates)) :=
  
  
  
  
  fun i => Finset.map (Equiv.toEmbedding finProdFinEquiv)
    (Finset.filter (fun j => if j.1 = 0 then (cs j.2).a = i
      else if j.1 = 1 then (cs j.2).b = i else (cs j.2).c = i)
    (Finset.univ : Finset (Fin 3 √ó Fin numGates)))

MvPolynomial.eval‚ÇÇHom in Mathlib.Algebra.MvPolynomial.Eval

LinearIndependent in Mathlib.LinearAlgebra.LinearIndependent.Defs

AffineSubspace in Mathlib.LinearAlgebra.AffineSpace.AffineSubspace.Defs

def degreeX (f : F[X][Y]) : ‚Ñï := f.support.sup (fun n => (f.coeff n).natDegree)

@[reducible]
def Witness (F : Type) [NonBinaryField F] {k : ‚Ñï}
    (s : Fin (k + 1) ‚Üí ‚Ñï+) (d : ‚Ñï+) (i : Fin (k + 2)) :=
  F‚¶É< 2^((‚àë j', (s j').1) - (‚àë j' ‚àà finRangeTo i.1, (s j').1)) * d‚¶Ñ[X]

instance instHasSucc {n : ‚Ñï} : HasSucc (CNat n) := (CayleyTower n).2

instance : Sub AssocNat where
  sub := sub

Submodule.module in Mathlib.Algebra.Module.Submodule.Defs

LE.le in Init.Prelude

instance instDCast : DCast Nat Fin where
  dcast h := Fin.cast h
  dcast_id := by admit /- proof elided -/

Array.rightpad in Init.Data.Array.Basic

Polynomial.compRingHom in Mathlib.Algebra.Polynomial.Eval.Defs

def binaryTowerModule {l r : ‚Ñï} (h_le : l ‚â§ r) : Module (BTField l) (BTField r) :=
  (binaryAlgebraTower (h_le:=h_le)).toModule

@[inline, reducible]
def proj : OuterStmtIn √ó OuterWitIn ‚Üí InnerStmtIn √ó InnerWitIn :=
  fun ctxIn => ‚ü®lens.stmt.toFunA ctxIn.1, lens.wit.toFunA ctxIn‚ü©

noncomputable def funcQuotient (f : Œπ ‚Üí F) (S : Finset F) (Ans Fill : S ‚Üí F) : Œπ ‚Üí F :=
  fun x =>
    if hx : x.val ‚àà S then Fill ‚ü®x.val, hx‚ü© 
    else (f x - (ansPoly S Ans).eval x.val) / (vanishingPoly S).eval x.val

Fin.dfoldl in Batteries.Data.Fin.Basic

instance : SubSpec [pSpec‚ÇÇ.Challenge]‚Çí ([(pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).Challenge]‚Çí) where
  monadLift | query i t => instSubSpecOfProtocolSpecAppendChallenge.monadLift (query (Sum.inr i) t)

Vector.take in Init.Data.Vector.Basic

instance {T} [HasSucc T] : CoeFun (Cayley T) (fun _ => T ‚Üí T) := ‚ü®Cayley.toFun‚ü©

class Serialize.IsInjective (Œ± : Type u) (Œ≤ : Type v) [inst : Serialize Œ± Œ≤] : Prop where
  serialize_inj : Function.Injective inst.serialize

def rtake {n : ‚Ñï} {Œ± : Fin n ‚Üí Sort*} (m : ‚Ñï) (h : m ‚â§ n) (v : (i : Fin n) ‚Üí Œ± i) :
    (i : Fin m) ‚Üí Œ± (Fin.cast (Nat.sub_add_cancel h) (natAdd (n - m) i)) :=
  fun i => v (Fin.cast (Nat.sub_add_cancel h) (natAdd (n - m) i))

Finset.product in Mathlib.Data.Finset.Prod

@[inline]
def ofInputOnly (projWit : OuterStmtIn √ó OuterWitIn ‚Üí InnerWitIn) :
    Witness.Lens OuterStmtIn OuterStmtOut OuterWitIn OuterWitOut InnerWitIn OuterWitOut :=
  ‚ü®projWit, fun _ => Prod.snd‚ü©

List in Init.Prelude

def totalNumPermQueriesChallenge : Nat :=
  ‚àë i, pSpec.L·µ•·µ¢ i

Units.mk0 in Mathlib.Algebra.GroupWithZero.Units.Basic

def distFromCode' (C : Set (n ‚Üí R)) [Fintype C] (u : n ‚Üí R) : ‚Ñï‚àû :=
  Finset.min <| (@Finset.univ C _).image (fun v => hammingDist u v.1)

def Œæ (x‚ÇÄ : F) (R : F[X][X][Y]) (H : F[X][Y]) [œÜ : Fact (Irreducible H)] : ùí™ H :=
  (Œæ_regular x‚ÇÄ R H).choose

@[ext]
structure VectorSpec (n : ‚Ñï) where
  dir : Fin n ‚Üí Direction
  length : Fin n ‚Üí Nat

protected def Verifier.id : Verifier oSpec Statement Statement !p[] where
  verify := fun stmt _ => pure stmt

ringChar.charP in Mathlib.Algebra.CharP.Defs

@[app_unexpander Fin.vempty]
def vemptyUnexpander : Lean.PrettyPrinter.Unexpander
  | `($_:ident) => `(!v[])
  | _ => throw ()

instance : Pow (UniPoly R) Nat := ‚ü®UniPoly.pow‚ü©

def canonicalAlgMap (k : ‚Ñï) := concreteCanonicalEmbedding (k:=k)
  (prevBTFieldProps:= ((getBTFResult k).toConcreteBTFieldProps))
  (curBTFieldProps:= ((getBTFResult (k + 1)).toConcreteBTFieldProps))

Function.Embedding.inl in Mathlib.Logic.Embedding.Basic

def toRoundByRound (E : RoundByRoundOneShot oSpec StmtIn WitIn pSpec) :
    RoundByRound oSpec StmtIn WitIn WitOut pSpec (fun _ => WitIn) where
  eqIn := rfl
  extractMid := fun m stmtIn tr witIn =>
    if m.castSucc = 0 then witIn else E m.castSucc stmtIn (Fin.init tr) default
  extractOut := fun stmtIn tr _ => E (.last n) stmtIn tr default

Fin.add in Init.Data.Fin.Basic

Polynomial.rootMultiplicity in Mathlib.Algebra.Polynomial.Div

def baseFoldMatrix (i : Fin r) (h_i : i + 1 < ‚Ñì + ùì°)
    (y : ‚Ü•(sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®‚Üëi + 1, by admit /- proof elided -/
    ‚ü©)) : Matrix (Fin 2) (Fin 2) L :=
  let fiberMap := qMap_total_fiber ùîΩq Œ≤ (i := i) (steps := 1)
      (h_i_add_steps := h_i) (y := y)
  let x‚ÇÄ := fiberMap 0
  let x‚ÇÅ := fiberMap 1
  fun i j => match i, j with
  | 0, 0 => x‚ÇÅ
  | 0, 1 => -x‚ÇÄ
  | 1, 0 => -1
  | 1, 1 => 1

@[reducible]
def ROspec (Œ± Œ≤ Œ≥ : Type) : OracleSpec Unit := fun _ => (Œ± √ó Œ≤, Œ≥)

instance instDCastPSigma : DCast ((a : Œ±) √ó' Œ≤ a) (fun a => Œ≥ a.1 a.2) where
  dcast hab c := dcast‚ÇÇ (by admit /- proof elided -/
  ) (by admit /- proof elided -/
  ) c
  dcast_id := by admit /- proof elided -/

def Option.doubleBind_v2 {Œ± Œ≤ Œ≥ : Type} (f : Œ± ‚Üí Œ≤ ‚Üí Option Œ≥)
    (x : Option Œ±) (y : Option Œ≤) : Option Œ≥ := do
  let a ‚Üê x
  let b ‚Üê y
  f a b

NeZero in Init.Data.NeZero

instance {k : ‚Ñï} : IntCast (ConcreteBTField k) where
  intCast n:= intCast n

def AlgebraTowerEquiv.symm (e : AlgebraTowerEquiv A B) : AlgebraTowerEquiv B A where
  toRingEquiv := fun i => (e.toRingEquiv i).symm
  commutesLeft' := fun i j h r => by admit /- proof elided -/

def SkeletonNodeIndex.sibling {s : Skeleton} (idx : SkeletonNodeIndex s) :
    Option (SkeletonNodeIndex s) :=
  match idx with
  
  | SkeletonNodeIndex.ofLeaf => none
  
  | SkeletonNodeIndex.ofInternal => none
  
  | @SkeletonNodeIndex.ofLeft left right idxLeft =>
    match idxLeft with
    
    | SkeletonNodeIndex.ofLeaf => some (getRootIndex right).ofRight
    
    | SkeletonNodeIndex.ofInternal => some (getRootIndex right).ofRight
    
    
    | SkeletonNodeIndex.ofLeft idxLeftLeft =>
      idxLeftLeft.ofLeft.sibling.map (SkeletonNodeIndex.ofLeft)
    | SkeletonNodeIndex.ofRight idxLeftRight =>
      idxLeftRight.ofRight.sibling.map (SkeletonNodeIndex.ofLeft)
  | @SkeletonNodeIndex.ofRight left right idxRight =>
    match idxRight with
    | SkeletonNodeIndex.ofLeaf => some (getRootIndex left).ofLeft
    | SkeletonNodeIndex.ofInternal => some (getRootIndex left).ofLeft
    | SkeletonNodeIndex.ofLeft idxRightLeft =>
      idxRightLeft.ofLeft.sibling.map (SkeletonNodeIndex.ofRight)
    | SkeletonNodeIndex.ofRight idxRightRight =>
      idxRightRight.ofRight.sibling.map (SkeletonNodeIndex.ofRight)

def partialEval {k : ‚Ñï} (f : MvPolynomial (Fin m) F) (Œ± : Fin k ‚Üí F) (h : k ‚â§ m) :
    MvPolynomial (Fin (m - k)) F :=
  let œÜ : Fin m ‚Üí MvPolynomial (Fin (m - k)) F := fun i =>
    if h' : i.val < k then
      C (Œ± ‚ü®i.val, h'‚ü©)
    else
      let j := i.val - k
      let j' : Fin (m - k) := ‚ü®j, sorry‚ü©
      X j'
  eval‚ÇÇ C œÜ f

Finset in Mathlib.Data.Finset.Defs

def someTypes : List Type := [Nat, String, Nat]

def Function.extendDomain {Œ± Œ≤ : Type*} [DecidableEq Œ±] [Zero Œ≤] {s : Finset Œ±}
    (f : (x : Œ±) ‚Üí (x ‚àà s) ‚Üí Œ≤) : Œ± ‚Üí Œ≤ :=
  fun x ‚Ü¶ if hx : x ‚àà s then f x hx else 0

List.Vector.mmap in Mathlib.Data.Vector.Basic

@[reducible]
def OracleStatement := fun _ : MatrixIdx => Matrix (Fin sz.m) (Fin sz.n) R

protected def OracleVerifier.id :
    OracleVerifier oSpec Statement OStatement Statement OStatement !p[] where
  verify := fun stmt _ => pure stmt
  embed := Function.Embedding.inl
  hEq := fun _ => rfl

@[reducible]
def FinalOracleStatement : Fin (k + 2) ‚Üí Type :=
  fun j =>
    if j.1 = k + 1
    then (Unit ‚Üí F[X])
    else (evalDomain D x (‚àë j' ‚àà finRangeTo j.1, s j') ‚Üí F)

def knowledgeStateFunction :
    (oracleVerifier oSpec OStatement).KnowledgeStateFunction init impl
    (relIn OStatement) (relOut OStatement) (rbrExtractor oSpec OStatement) where
  toFun
  | 0 => fun ‚ü®_, oracles‚ü© _ _ => oracles 0 = oracles 1
  | 1 => fun ‚ü®_, oracles‚ü© chal _ =>
    let q : Query OStatement := by admit /- proof elided -/

def Verifier.addSalt (V : Verifier oSpec StmtIn StmtOut pSpec) :
    Verifier oSpec StmtIn StmtOut (pSpec.addSalt Salt) where
  verify := fun stmtIn transcript => V.verify stmtIn transcript.removeSalt

def append (T‚ÇÅ : FullTranscript pSpec‚ÇÅ) (T‚ÇÇ : FullTranscript pSpec‚ÇÇ) :
    FullTranscript (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ) :=
  Fin.happend T‚ÇÅ T‚ÇÇ

def oracleReduction.sendClaim : OracleReduction oSpec (StmtIn R) (OStmtIn R deg) Unit
    (StmtAfterSendClaim R) (OStmtAfterSendClaim R deg) Unit ‚ü®!v[.P_to_V], !v[R‚¶É‚â§ deg‚¶Ñ[X]]‚ü© := sorry

noncomputable def toRatFuncPoly (p : F[Z][X][Y]) : (RatFunc F)[X][Y] :=
  p.map (Polynomial.mapRingHom (algebraMap F[X] (RatFunc F)))

def completeness
    (relIn : Set ((StmtIn √ó ‚àÄ i, OStmtIn i) √ó WitIn))
    (relOut : Set ((StmtOut √ó ‚àÄ i, OStmtOut i) √ó WitOut))
    (oracleReduction : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec)
    (completenessError : ‚Ñù‚â•0) : Prop :=
  Reduction.completeness init impl relIn relOut oracleReduction.toReduction completenessError

Polynomial.leadingCoeff in Mathlib.Algebra.Polynomial.Degree.Definitions

def snd (T : (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).Transcript k) : pSpec‚ÇÇ.Transcript ‚ü®k - m, by admit /- proof elided -/
‚ü© :=
  if hk : k ‚â§ m then
    fun i => Fin.elim0 (by admit /- proof elided -/
    )
  else
    fun i => sorry

def InnerStmtIn_Test := ‚Ñ§[X] √ó ‚Ñ§

class IsKnowledgeSound (relIn : Set (StmtIn √ó WitIn)) (relOut : Set (StmtOut √ó WitOut))
    (verifier : Verifier oSpec StmtIn StmtOut pSpec) where
  knowledgeError : ‚Ñù‚â•0
  is_knowledge_sound : knowledgeSoundness init impl relIn relOut verifier knowledgeError

instance {i : Fin k} : ‚àÄ j, OracleInterface ((pSpec D x s i).Message j)
  | ‚ü®0, h‚ü© => nomatch h
  | ‚ü®1, _‚ü© => by admit /- proof elided -/

repr in Init.Data.Repr

@[reducible]
noncomputable def batchedFRIreduction [DecidableEq F] :=
  OracleReduction.append
    (BatchingRound.batchOracleReduction D x s d m)
    (liftedFRI D x k s d dom_size_cond l m)

def hcons {n : ‚Ñï} {Œ± : Sort u} {Œ≤ : Fin n ‚Üí Sort u} (a : Œ±) (b : (i : Fin n) ‚Üí Œ≤ i) :
    (i : Fin (n + 1)) ‚Üí Fin.vcons Œ± Œ≤ i :=
  fcons (F := id) a b

def coeffsBySuffix (a : Fin (2 ^ ‚Ñì) ‚Üí L) (i : Fin (‚Ñì + 1)) (v : Fin (2 ^ i.val)) :
  Fin (2 ^ (‚Ñì - i)) ‚Üí L :=
  fun ‚ü®j, hj‚ü© => by admit /- proof elided -/

def Verifier.append (V‚ÇÅ : Verifier oSpec Stmt‚ÇÅ Stmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : Verifier oSpec Stmt‚ÇÇ Stmt‚ÇÉ pSpec‚ÇÇ) :
      Verifier oSpec Stmt‚ÇÅ Stmt‚ÇÉ (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ) where
  verify := fun stmt transcript => do
    return ‚Üê V‚ÇÇ.verify (‚Üê V‚ÇÅ.verify stmt transcript.fst) transcript.snd

@[inline, specialize]
def reduction : Reduction oSpec Statement Unit Statement Unit !p[] where
  prover := prover oSpec Statement
  verifier := verifier oSpec Statement pred

structure NonAdaptive {Œπ : Type} (oSpec : OracleSpec Œπ)
    (StmtIn : Type) {Œπ‚Çõ·µ¢ : Type} (OStmtIn : Œπ‚Çõ·µ¢ ‚Üí Type)
    (StmtOut : Type) {Œπ‚Çõ‚Çí : Type} (OStmtOut : Œπ‚Çõ‚Çí ‚Üí Type)
    {n : ‚Ñï} (pSpec : ProtocolSpec n)
    [O‚Çõ·µ¢ : ‚àÄ i, OracleInterface (OStmtIn i)]
    [O‚Çò : ‚àÄ i, OracleInterface (pSpec.Message i)]
    where

   
  queryOStmt : StmtIn ‚Üí (‚àÄ i, pSpec.Challenge i) ‚Üí List ((i : Œπ‚Çõ·µ¢) √ó (O‚Çõ·µ¢ i).Query)

   
  queryMsg : StmtIn ‚Üí (‚àÄ i, pSpec.Challenge i) ‚Üí List ((i : pSpec.MessageIdx) √ó (O‚Çò i).Query)

   
  verify : StmtIn ‚Üí (‚àÄ i, pSpec.Challenge i) ‚Üí
    List ((i : Œπ‚Çõ·µ¢) √ó ((O‚Çõ·µ¢ i).Query √ó (O‚Çõ·µ¢ i).Response)) ‚Üí
    List ((i : pSpec.MessageIdx) √ó ((O‚Çò i).Query √ó (O‚Çò i).Response)) ‚Üí OracleComp oSpec StmtOut

  embed : Œπ‚Çõ‚Çí ‚Ü™ Œπ‚Çõ·µ¢ ‚äï pSpec.MessageIdx

  hEq : ‚àÄ i, OStmtOut i = match embed i with
    | Sum.inl j => OStmtIn j
    | Sum.inr j => pSpec.Message j

noncomputable def queryOracleReduction [DecidableEq F] :
  OracleReduction []‚Çí
    (FinalStatement F k) (FinalOracleStatement D x s) (Witness F s d (Fin.last (k + 1)))
    (FinalStatement F k) (FinalOracleStatement D x s) (Witness F s d (Fin.last (k + 1)))
    (pSpec D x l) where
  prover := queryProver D x s d l
  verifier := queryVerifier D x s (round_bound domain_size_cond) l

AddMonoidAlgebra in Mathlib.Algebra.MonoidAlgebra.Defs

abbrev sqrtRate [Fintype Œπ] (deg : ‚Ñï) (domain : Œπ ‚Ü™ F) : ‚Ñù‚â•0 :=
  (LinearCode.rate (ReedSolomon.code domain deg) : ‚Ñù‚â•0).sqrt

noncomputable def toPoly (p : UniPoly R) : Polynomial R :=
  p.eval‚ÇÇ Polynomial.C Polynomial.X

Set.Finite in Mathlib.Data.Finite.Defs

instance : NeZero (2^3) := ‚ü®by admit /- proof elided -/
‚ü©

Module.Basis.mk in Mathlib.LinearAlgebra.Basis.Basic

def InnerStmtOut_Test := ‚Ñ§[X] √ó ‚Ñ§ √ó ‚Ñ§

Finset.Icc in Mathlib.Order.Interval.Finset.Defs

def Verifier.fiatShamir (V : Verifier oSpec StmtIn StmtOut pSpec) :
    NonInteractiveVerifier (‚àÄ i, pSpec.Message i) (oSpec ++‚Çí fsChallengeOracle StmtIn pSpec)
      StmtIn StmtOut where
  verify := fun stmtIn proof => do
    let messages : pSpec.Messages := proof 0
    let transcript ‚Üê messages.deriveTranscriptFS stmtIn
    V.verify stmtIn transcript

def forwardRange (n : ‚Ñï) (r : Fin (n)) (l : Fin (r.val + 1)) : List (Fin n) :=
  let len := r.val - l.val + 1
  List.ofFn (fun (k : Fin len) =>
    let val := l.val + k.val
    have h_bound : val < n := by admit /- proof elided -/
  )

def minDist [DecidableEq F] (IC : MatrixSubmodule Œ∫ Œπ F) : ‚Ñï :=
  sInf { d : ‚Ñï | ‚àÉ U ‚àà IC, ‚àÉ V ‚àà IC, distCodewords U V = d }

instance instDCast‚ÇÉ : DCast‚ÇÉ Nat (fun n => Fin (n + 1)) (fun n _ => ProtocolSpec n)
    (fun _ k pSpec => pSpec.Transcript k) where
  dcast‚ÇÉ h h' h'' T := Transcript.cast h
    (by admit /- proof elided -/
    )
    (by admit /- proof elided -/
    )
    T
  dcast‚ÇÉ_id := cast_id

abbrev rtake (m : ‚Ñï) (h : m ‚â§ n)
    (transcript : FullTranscript pSpec) : FullTranscript (pSpec.rtake m h) :=
  Fin.rtake m h transcript

def params16 : Params where
  width := 16
  numFullRounds := 8
  numPartialRounds := 20
  internalDiagVectors := #v[
       -2,
        1,
        2,
        1 / 2,
        3,
        4,
        -1 / 2,
        -3,
        -4,
        1 / (2 ^ 8),
        1 / 8,
        1 / (2 ^ 24),
        -1 / (2 ^ 8),
        -1 / 8,
        -1 / 16,
        -1 / (2 ^ 24),
    ]
  roundConstants := rawConstants16
  width_dvd_by_4 := by admit /- proof elided -/

Char in Init.Prelude

def SkeletonInternalIndex.isLeaf {s : Skeleton} (idx : SkeletonInternalIndex s) : Bool :=
  match idx with
  | SkeletonInternalIndex.ofInternal => false
  | SkeletonInternalIndex.ofLeft _ => false
  | SkeletonInternalIndex.ofRight _ => false

hammingNorm in Mathlib.InformationTheory.Hamming

def churchRecNat {Œ≤ : Type} (n : ChurchNat ‚Ñï) (step : Œ≤ ‚Üí Œ≤) (base : Œ≤) : Œ≤ :=
  Nat.iterate step (ChurchNat.toNat n) base

noncomputable def coeffAsRatFunc : F[X] ‚Üí+* Polynomial (RatFunc F) :=
  RingHom.comp bivPolyHom Polynomial.C

@[reducible, simp] def OStmtOut : Unit ‚Üí Type := fun _ => R‚¶É‚â§ deg‚¶Ñ[X]

def LeafData.optionComposeBuild {Œ± : Type} {s : Skeleton} (leaf_data_tree : LeafData Œ± s)
    (compose : Œ± ‚Üí Œ± ‚Üí Option Œ±) :
    FullData (Option Œ±) s :=
  (leaf_data_tree.map (.some)).composeBuild (Option.doubleBind compose)

OracleComp.SelectableType.probFailure_selectElem in VCVio.OracleComp.Constructions.UniformSelect

def mkLastOracleIndex (i : Fin (‚Ñì + 1)) : Fin (toOutCodewordsCount ‚Ñì œë i) :=

Option in Init.Prelude

Mathlib.Linter.TextBased.ErrorFormat in Mathlib.Tactic.Linter.TextBased

def natWeightedDegree.{u} {F : Type u} [Semiring F] (f : F[X][Y]) (u v : ‚Ñï) : ‚Ñï :=
  f.support.sup (fun m => u * (f.coeff m).natDegree + v * m)

def rbrKnowledgeSoundness (relIn : Set (StmtIn √ó WitIn)) (relOut : Set (StmtOut √ó WitOut))
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    (rbrKnowledgeError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) : Prop :=
  ‚àÉ WitMid : Fin (n + 1) ‚Üí Type,
  ‚àÉ extractor : Extractor.RoundByRound oSpec StmtIn WitIn WitOut pSpec WitMid,
  ‚àÉ kSF : verifier.KnowledgeStateFunction init impl relIn relOut extractor,
  ‚àÄ stmtIn : StmtIn,
  ‚àÄ witIn : WitIn,
  ‚àÄ prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec,
  ‚àÄ i : pSpec.ChallengeIdx,
    [fun ‚ü®transcript, challenge, _proveQueryLog‚ü© =>
      ‚àÉ witMid,
        ¬¨ kSF i.1.castSucc stmtIn transcript
          (extractor.extractMid i.1 stmtIn (transcript.concat challenge) witMid) ‚àß
          kSF i.1.succ stmtIn (transcript.concat challenge) witMid
    | do
      (simulateQ (impl ++‚Çõ‚Çí challengeQueryImpl : QueryImpl _ (StateT œÉ ProbComp))
        (do
          let ‚ü®‚ü®transcript, _‚ü©, proveQueryLog‚ü© ‚Üê prover.runWithLogToRound i.1.castSucc stmtIn witIn
          let challenge ‚Üê liftComp (pSpec.getChallenge i) _
          return (transcript, challenge, proveQueryLog))).run' (‚Üê init)] ‚â§
      rbrKnowledgeError i

def mul (a b : AssocNat) : AssocNat :=
  mulNat a b.toNat

def acceptRejectOracleRel : Set ((Bool √ó (‚àÄ _ : Empty, Unit)) √ó Unit) :=
  { ((true, isEmptyElim), ()) }

def getPutativeRoot_with_hash {s} (idx : BinaryTree.SkeletonLeafIndex s)
    (leafValue : Œ±) (proof : List Œ±) (hashFn : Œ± ‚Üí Œ± ‚Üí Œ±) : Œ± :=
  match proof with
  | [] => leafValue 
  | siblingBelowRootHash :: restProof =>
    match idx with
    | BinaryTree.SkeletonLeafIndex.ofLeaf =>
      
      
      
      leafValue
    | BinaryTree.SkeletonLeafIndex.ofLeft idxLeft =>
      
      hashFn (getPutativeRoot_with_hash idxLeft leafValue restProof hashFn) siblingBelowRootHash
    | BinaryTree.SkeletonLeafIndex.ofRight idxRight =>
      
      hashFn siblingBelowRootHash (getPutativeRoot_with_hash idxRight leafValue restProof hashFn)

abbrev AffSpanSet [NeZero k] (U : Fin k ‚Üí Œπ ‚Üí F) : Set (Œπ ‚Üí F) :=
  (affineSpan F (Finset.univ.image U : Set (Œπ ‚Üí F))).carrier

instance : Fact (Nat.Prime fieldSize) := ‚ü®is_prime‚ü©

def towerOfExponents (g : G) (a : ZMod p) (n : ‚Ñï) : Vector G (n + 1) :=
  .ofFn (fun i => g ^ (a.val ^ i.val))

instance : Fintype BTF‚ÇÉ := (inferInstance : Fintype (ConcreteBTField 3))

@[reducible] def OracleProof {Œπ : Type} (oSpec : OracleSpec Œπ)
    (Statement : Type) {Œπ‚Çõ·µ¢ : Type} (OStatement : Œπ‚Çõ·µ¢ ‚Üí Type) (Witness : Type)
    {n : ‚Ñï} (pSpec : ProtocolSpec n)
    [O‚Çõ·µ¢ : ‚àÄ i, OracleInterface (OStatement i)]
    [O‚Çò : ‚àÄ i, OracleInterface (pSpec.Message i)] :=
  OracleReduction oSpec Statement OStatement Witness Bool (fun _ : Empty => Unit) Unit pSpec

def completeness (relIn : Set (StmtIn √ó WitIn))
    (relOut : Set (StmtOut √ó WitOut))
    (reduction : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec)
    (completenessError : ‚Ñù‚â•0) : Prop :=
  ‚àÄ stmtIn : StmtIn,
  ‚àÄ witIn : WitIn,
  (stmtIn, witIn) ‚àà relIn ‚Üí
    [fun ‚ü®‚ü®_, (prvStmtOut, witOut)‚ü©, stmtOut‚ü© => (stmtOut, witOut) ‚àà relOut ‚àß prvStmtOut = stmtOut
    | do (simulateQ (impl ++‚Çõ‚Çí challengeQueryImpl : QueryImpl _ (StateT œÉ ProbComp))
          <| reduction.run stmtIn witIn).run' (‚Üê init)] ‚â• 1 - completenessError

@[reducible, inline]
instance (priority := low) instTensorForall {Œπ : Type u} (v : Œπ ‚Üí Type v)
    [O : ‚àÄ i, OracleInterface (v i)] : OracleInterface (‚àÄ i, v i) where
  Query := (i : Œπ) ‚Üí (O i).Query
  Response := (i : Œπ) ‚Üí (O i).Response
  answer := fun f q i => (O i).answer (f i) (q i)

def relayKStateProp (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i)
  (stmtIn : Statement (L := L) Context i.succ)
  (witMid : Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
  (oStmtIn : (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j))
  : Prop :=
  masterKStateProp (mp := mp) (œë := œë) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
    (stmtIdx := i.succ) (oracleIdx := i.succ)
    (h_le := le_refl _)
    (stmt := stmtIn) (wit := witMid) (oStmt := mapOStmtOutRelayStep
      ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hNCR oStmtIn)
    (localChecks := True)

@[reducible]
def StateRestoration.KnowledgeSoundness (oSpec : OracleSpec Œπ)
    (StmtIn : Type) {Œπ‚Çõ·µ¢ : Type} (OStmtIn : Œπ‚Çõ·µ¢ ‚Üí Type) (WitOut : Type)
    {n : ‚Ñï} {pSpec : ProtocolSpec n} :=
  Prover.StateRestoration.KnowledgeSoundness oSpec (StmtIn √ó (‚àÄ i, OStmtIn i)) WitOut pSpec

@[simp]
abbrev OracleStatement.AfterLinearCombination : R1CS.MatrixIdx ‚äï R1CS.MatrixIdx ‚äï Fin 1 ‚Üí Type :=
  Sum.elim (EvalClaim R) (OracleStatement.AfterFirstSumcheck R pp)

noncomputable def deevenize (f : Polynomial F) : Polynomial F :=
    match f with
      | ‚ü®‚ü®supp, g, h‚ü©‚ü© => ‚ü®‚ü®divide_by_2 supp, fun n => g (2 * n), by admit /- proof elided -/
      ‚ü©‚ü©

def ratchetUnchecked [Permute C] (sponge : DuplexSponge U C) : DuplexSponge U C :=
  simulateQ' forwardPermutationOracleImpl (ratchet sponge) (by admit /- proof elided -/
  )

instance {s} : LawfulFunctor (fun Œ± => LeafData Œ± s) :=

MvPolynomial.monomial in Mathlib.Algebra.MvPolynomial.Basic

noncomputable def eval_on_Z‚ÇÄ (p : (RatFunc F)) (z : F) : F :=
  RatFunc.eval (RingHom.id _) z p


notation3:max R "[Z][X]" => Polynomial (Polynomial R)

notation3:max R "[Z][X][Y]" => Polynomial (Polynomial (Polynomial (R)))

notation3:max "Y" => Polynomial.X
notation3:max "X" => Polynomial.C Polynomial.X
notation3:max "Z" => Polynomial.C (Polynomial.C Polynomial.X)

AddCommGroup in Mathlib.Algebra.Group.Defs

def liftLeftNil {Œπ : Type} {œÉ : Type} (oSpec : OracleSpec Œπ) :
    SimOracle.Stateful ([]‚Çí ++‚Çí oSpec) oSpec œÉ where impl
  | query (.inr i) q => fun s ‚Ü¶ do return ‚ü®‚Üê query i q, s‚ü©

def univPolyHom {F : Type} [CommRing F] [IsDomain F] : F[X] ‚Üí+* RatFunc F :=
  algebraMap (F[X]) (RatFunc F)

def concrete_inv {k : ‚Ñï} (a : ConcreteBTField k) : ConcreteBTField k :=
  if h_k_zero : k = 0 then
    if a = 0 then 0 else 1
  else
    if h_a_zero : a = 0 then 0
    else if h_a_one : a = 1 then 1
    else
      let h_k_gt_0 : k > 0 := Nat.zero_lt_of_ne_zero h_k_zero
      let (a_hi, a_lo) := split (k:=k) (h:=h_k_gt_0) a
      let prevZ := Z (k - 1)
      let a_lo_next := a_lo + concrete_mul a_hi prevZ
      let delta := concrete_mul a_lo a_lo_next + concrete_mul a_hi a_hi
      let delta_inverse := concrete_inv delta
      let out_hi := concrete_mul delta_inverse a_hi
      let out_lo := concrete_mul delta_inverse a_lo_next
      let res := „Ää out_hi, out_lo „Äã
      res

def LeafData.rightSubtree {Œ± : Type} {s_left s_right : Skeleton}
    (tree : LeafData Œ± (Skeleton.internal s_left s_right)) :
    LeafData Œ± s_right :=
  match tree with
  | LeafData.internal _left right =>
    right

instance {pSpec : ProtocolSpec n} : CoeHead (MessageIdx pSpec) (Fin n) where
  coe := fun i => i.1

def toOracleImpl {Œπ : Type u} (v : Œπ ‚Üí Type v) [O : ‚àÄ i, OracleInterface (v i)]
    (data : ‚àÄ i, v i) : QueryImpl [v]‚Çí Id where
  impl | query i t => (O i).answer (data i) t

def perm (cs : ConstraintSystem ùì° numWires numGates) : Equiv.Perm (Fin (3 * numGates)) := sorry

@[reducible]
def duplexSpongeChallengeOracle (StartType : Type) (U : Type) [SpongeUnit U] [SpongeSize] :
    OracleSpec (Unit ‚äï PermuteDir) :=
  (StartType ‚Üí‚Çí Vector U SpongeSize.C) ++‚Çí permutationOracle (CanonicalSpongeState U)

alias ùíü_ùîñ := duplexSpongeChallengeOracle

def symm (eqv : Equiv pSpec pSpec') : Equiv pSpec' pSpec where
  round_eq := eqv.round_eq.symm
  dir_eq := fun i => by admit /- proof elided -/

Nat.reducePow in Lean.Meta.Tactic.Simp.BuiltinSimprocs.Nat

def backwardPermutationOracleImpl {Œ± : Type*} [Permute Œ±] [LawfulPermute Œ±] :
    QueryImpl (backwardPermutationOracle Œ±) Id where
  impl | query () q => LawfulPermute.permuteInv (Œ± := Œ±) q

@[inline, specialize]
def oracleProver : OracleProver oSpec
    Statement OStatement (‚àÄ i, Witness i)
    Statement (OStatement ‚äï·µ• Witness) Unit
    (oraclePSpec Witness) where
  PrvState := fun _ => (Statement √ó (‚àÄ i, OStatement i)) √ó (‚àÄ i, Witness i)
  input := id
  sendMessage | ‚ü®0, _‚ü© => fun ‚ü®stmt, wit‚ü© => pure (wit, ‚ü®stmt, wit‚ü©)
  
  receiveChallenge | ‚ü®0, h‚ü© => nomatch h
  output := fun ‚ü®‚ü®stmt, oStmt‚ü©, wit‚ü© => pure (‚ü®stmt, Sum.rec oStmt wit‚ü©, ())

Equiv.optionCongr in Mathlib.Logic.Equiv.Option

class VerifierOnly (pSpec : ProtocolSpec 1) extends VerifierFirst pSpec

def FullData.rightSubtree {Œ± : Type} {s_left s_right : Skeleton}
    (tree : FullData Œ± (Skeleton.internal s_left s_right)) :
    FullData Œ± s_right :=
  match tree with
  | FullData.internal _ _left right =>
    right

noncomputable def disFromHammingNorm [Semiring F] [DecidableEq F] (LC : LinearCode Œπ F) : ‚Ñï :=
  sInf {d | ‚àÉ u ‚àà LC, u ‚â† 0 ‚àß hammingNorm u ‚â§ d}

@[reducible, simp]
def relOut : Set ((StmtOut OStatement √ó ‚àÄ i, OStmtOut OStatement i) √ó WitOut) :=
  { ‚ü®‚ü®q, oStmt‚ü©, ()‚ü© | answer (oStmt 0) q = answer (oStmt 1) q }

def halfNumFullRounds : Nat := params.numFullRounds / 2

def toMessagesChallenges (transcript : FullTranscript pSpec) : Messages pSpec √ó Challenges pSpec :=

noncomputable instance : Algebra Right (Left ‚äó[K] Right) := Algebra.TensorProduct.rightAlgebra


local notation "e" => Algebra.TensorProduct.comm K Right Left

def d (B : Finset (Fin n ‚Üí F)) : ‚Ñö :=
  (1 : ‚Ñö)/(2 * choose_2 B.card) * ‚àë x ‚àà (Finset.product B B) with x.1 ‚â† x.2, Œî‚ÇÄ(x.1, x.2)

Polynomial.ofFinsupp in Mathlib.Algebra.Polynomial.Basic

def dfoldrM' {m : Type u ‚Üí Type v} [Monad m]
    (n : ‚Ñï) (Œ± : Fin (n + 1) ‚Üí Type u)
    (f : (i : Fin n) ‚Üí Œ± i.succ ‚Üí m (Œ± i.castSucc)) (init : Œ± (last n)) : m (Œ± 0) :=
  match n with
  | 0 => pure init
  | n + 1 => do
    let x ‚Üê dfoldrM' n (Œ± ‚àò succ) (fun i => f i.succ) init
    f 0 x

Units.mulAction' in Mathlib.Algebra.Group.Action.Units

@[reducible]
def get {Œ±s : List (Type u)} : HList Œ±s ‚Üí (n : Fin Œ±s.length) ‚Üí Œ±s.get n
  | x ::‚Çï _, ‚ü®0, _‚ü© => x
  | _ ::‚Çï xs, ‚ü®n+1, h‚ü© => xs.get ‚ü®n, Nat.lt_of_succ_lt_succ h‚ü©

abbrev Field := ZMod fieldSize

structure InterleavedCode (Œ∫ Œπ : Type*) [Fintype Œ∫] [Fintype Œπ] (F : Type*) [Semiring F] where
  MF : MatrixSubmodule Œ∫ Œπ F
  LC : LinearCode Œπ F

Finset.max in Mathlib.Data.Finset.Max

MvPolynomial.sumAlgEquiv in Mathlib.Algebra.MvPolynomial.Equiv

Polynomial.IsRoot in Mathlib.Algebra.Polynomial.Eval.Defs

def distToCode [DecidableEq F] (U : Matrix Œ∫ Œπ F) (IC : MatrixSubmodule Œ∫ Œπ F) : ‚Ñï :=
 sInf { d : ‚Ñï | ‚àÉ V ‚àà IC, distCodewords U V = d }

List.product in Batteries.Data.List.Basic

structure Selector (ùì° : Type*) where
   
  qL : ùì°
   
  qR : ùì°
   
  qO : ùì°
   
  qM : ùì°
   
  qC : ùì°
deriving DecidableEq

instance instZeroConcreteBTField (k : ‚Ñï) : Zero (ConcreteBTField k) where
  zero := zero

def OracleProver.addSalt (P : OracleProver oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec)
    (saltComp : (i : pSpec.MessageIdx) ‚Üí P.PrvState i.1.castSucc ‚Üí OracleComp oSpec (Salt i)) :
  OracleProver oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut (pSpec.addSalt Salt) :=
  Prover.addSalt Salt P saltComp

def take (j : Fin (k + 1)) (messages : MessagesUpTo k pSpec) :
    MessagesUpTo (j.castLE (by admit /- proof elided -/
    )) pSpec :=
  fun i => messages ‚ü®i.val.castLE (by admit /- proof elided -/
  ), i.property‚ü©

def proximityChecksSpec (Œ≥_challenges :
    Fin Œ≥_repetitions ‚Üí sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®0, by omega‚ü©)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì) j)
    (fold_challenges : Fin ‚Ñì ‚Üí L) (final_constant : L) : Prop :=
  ‚àÄ rep : Fin Œ≥_repetitions,
    let v := Œ≥_challenges rep
    -- For all folding levels k = 0, ..., ‚Ñì/œë - 1, we track c_cur through the iterations
    ‚àÄ k_val : Fin (‚Ñì / œë),
      let i := k_val.val * œë
      have h_k: k_val ‚â§ (‚Ñì/œë - 1) := by omega
      have h_i_add_œë_le_‚Ñì : i + œë ‚â§ ‚Ñì := by
        calc i + œë = k_val * œë + œë := by omega
          _ ‚â§ (‚Ñì/œë - 1) * œë + œë := by
            apply Nat.add_le_add_right; apply Nat.mul_le_mul_right; omega
          _ = ‚Ñì/œë * œë :=

instance : HListRepr (HList []) where
  repr := fun _ => ""

private def f (x : ‚Ñö) : ‚Ñö := x^2 - x

finProdFinEquiv in Mathlib.Logic.Equiv.Fin.Basic

class ProverLast (pSpec : ProtocolSpec n) [inst : NeZero n] where
  prover_last' : pSpec.dir ‚ü®n - 1, by admit /- proof elided -/
  ‚ü© = .P_to_V

@[reducible, simp] def WitIn := Unit

instance : Inhabited (UniPolyC R) := ‚ü®#[], Trim.canonical_empty‚ü©

@[reducible, inline]
def OracleProver {Œπ : Type} (oSpec : OracleSpec Œπ)
    (StmtIn : Type) {Œπ‚Çõ·µ¢ : Type} (OStmtIn : Œπ‚Çõ·µ¢ ‚Üí Type) (WitIn : Type)
    (StmtOut : Type) {Œπ‚Çõ‚Çí : Type} (OStmtOut : Œπ‚Çõ‚Çí ‚Üí Type) (WitOut : Type)
    {n : ‚Ñï} (pSpec : ProtocolSpec n) :=
  Prover oSpec (StmtIn √ó (‚àÄ i, OStmtIn i)) WitIn (StmtOut √ó (‚àÄ i, OStmtOut i)) WitOut pSpec

def queryRbrKnowledgeError := fun _ : (pSpecQuery ùîΩq Œ≤ Œ≥_repetitions
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).ChallengeIdx =>
  ((1/2 : ‚Ñù‚â•0) + (1 : ‚Ñù‚â•0) / (2 * 2^ùì°))^Œ≥_repetitions

instance : LawfulToNat Nat where
  toNat_zero := rfl
  toNat_succ := fun _ => rfl

class PrimeOrderWith (G : Type*) [Group G] (p : outParam ‚Ñï) [Fact (Nat.Prime p)] where
  hCard : Nat.card G = p

structure KnowledgeStateFunctionOneShot
    (langIn : Set StmtIn) (langOut : Set StmtOut)
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    where
  toFun : (m : Fin (n + 1)) ‚Üí StmtIn ‚Üí Transcript m pSpec ‚Üí Prop
   
  toFun_empty : ‚àÄ stmtIn, ¬¨ toFun 0 stmtIn default
   
  toFun_next : ‚àÄ m, pSpec.dir m = .P_to_V ‚Üí
    ‚àÄ stmt tr msg, ¬¨ toFun m.castSucc stmt tr ‚Üí ¬¨ toFun m.succ stmt (tr.concat msg)
   
  toFun_full : ‚àÄ stmt tr, ¬¨ toFun (.last n) stmt tr ‚Üí
    [(¬∑ ‚àà langOut) | do (simulateQ impl (verifier.run stmt tr)).run' (‚Üê init)] = 0

class LawfulHasSucc (T : Type u) [HasSucc T] [Add T] [One T] : Prop where
   
  succ'_eq_add_one : ‚àÄ x : T, succ' x = x + 1

Fin.succ in Init.Data.Fin.Basic

def erase_odd (s : Finset ‚Ñï) : Finset ‚Ñï := s.filter Even

noncomputable def toMLE (A : Matrix (Fin (2 ^ m)) (Fin (2 ^ n)) R) : R[X Fin n][X Fin m] :=
  MLE' (MLE' ‚àò A)

class Extractor.Lens.IsKnowledgeSound
    {OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut : Type}
    {OuterWitIn OuterWitOut InnerWitIn InnerWitOut : Type}
    (outerRelIn : Set (OuterStmtIn √ó OuterWitIn))
    (innerRelIn : Set (InnerStmtIn √ó InnerWitIn))
    (outerRelOut : Set (OuterStmtOut √ó OuterWitOut))
    (innerRelOut : Set (InnerStmtOut √ó InnerWitOut))
    (compatStmt : OuterStmtIn ‚Üí InnerStmtOut ‚Üí Prop)
    (compatWit : OuterWitOut ‚Üí InnerWitIn ‚Üí Prop)
    (lens : Extractor.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                            OuterWitIn OuterWitOut InnerWitIn InnerWitOut) where

   
  proj_knowledgeSound : ‚àÄ outerStmtIn innerStmtOut outerWitOut,
    compatStmt outerStmtIn innerStmtOut ‚Üí
    (lens.stmt.lift outerStmtIn innerStmtOut, outerWitOut) ‚àà outerRelOut ‚Üí
    (innerStmtOut, lens.wit.proj (outerStmtIn, outerWitOut)) ‚àà innerRelOut

   
  lift_knowledgeSound : ‚àÄ outerStmtIn outerWitOut innerWitIn,
    compatWit outerWitOut innerWitIn ‚Üí
    (lens.stmt.proj outerStmtIn, innerWitIn) ‚àà innerRelIn ‚Üí
    (outerStmtIn, lens.wit.lift (outerStmtIn, outerWitOut) innerWitIn) ‚àà outerRelIn

Finset.Iic in Mathlib.Order.Interval.Finset.Defs

noncomputable def roundConsistencyCheck [Field ùîΩ] [DecidableEq ùîΩ]
    (Œ≥ : ùîΩ) (pts : List (ùîΩ √ó ùîΩ)) (Œ≤ : ùîΩ) : Bool :=
  let p := Lagrange.interpolate Finset.univ (fun i => (pts.get i).1) (fun i => (pts.get i).2)
  p.eval Œ≥ == Œ≤

instance : ‚àÄ j, OracleInterface (FinalOracleStatement D x s j) :=
  fun j =>
    if h : j = k + 1
    then {
           Query := Unit
           Response := F[X]
           answer := cast (by admit /- proof elided -/
           )
                          (id (Œ± := Unit ‚Üí F[X]))
         }
    else {
           Query :=
            ‚Üë(
              evalDomain D x
              (‚àë j' ‚àà finRangeTo j.1, s j')
            )
           Response := F
           answer := cast (by admit /- proof elided -/
           )
                          (id (Œ± := ‚Üë(evalDomain D x (‚àë j' ‚àà finRangeTo j.1, s j')) ‚Üí F))
         }

ENat in Mathlib.Data.ENat.Defs

def Prover.addSalt (P : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec)
    (saltComp : (i : pSpec.MessageIdx) ‚Üí P.PrvState i.1.castSucc ‚Üí OracleComp oSpec (Salt i)) :
  Prover oSpec StmtIn WitIn StmtOut WitOut (pSpec.addSalt Salt) where
  PrvState := P.PrvState
  input := P.input
  sendMessage := fun i st => by admit /- proof elided -/

noncomputable def P
  (Œ¥ : ‚Ñö) (x‚ÇÄ : F)
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  :
  F[Z][X] :=
  let v‚ÇÄ := Classical.choose (solution_gamma_is_linear_in_Z k (Œ¥ := Œ¥) (x‚ÇÄ := x‚ÇÄ) h_gs)
  let v‚ÇÅ := Classical.choose 
    (Classical.choose_spec <| solution_gamma_is_linear_in_Z k (Œ¥ := Œ¥) (x‚ÇÄ := x‚ÇÄ) h_gs)
  (
    (Polynomial.map Polynomial.C v‚ÇÄ) +
    (Polynomial.C Polynomial.X) * (Polynomial.map Polynomial.C v‚ÇÅ)
  )

def binary_tower_inductive_step
  (k : Nat)
  (prevBTField : Type _) [Field prevBTField]
  (prevBTResult : BinaryTowerResult prevBTField k)
: Œ£' (F : Type _), BinaryTowerInductiveStepResult (k:=k) (prevBTField:=prevBTField)
  (prevBTResult:=prevBTResult) (prevPoly:=definingPoly (F:=prevBTField)
    (instField:=prevBTResult.instField) (s:=prevBTResult.specialElement)) (F:=F)
  (instPrevBTFieldIsField:=prevBTResult.instField) :=

idOracle in VCVio.OracleComp.SimSemantics.SimulateQ

LinearEquiv.ofBijective in Mathlib.Algebra.Module.Submodule.Equiv

def instTestLensKnowledgeSound : testLensE.IsKnowledgeSound
      outerRelIn_Test innerRelIn_Test outerRelOut_Test innerRelOut_Test
      (fun ‚ü®p, q, _‚ü© ‚ü®f, _‚ü© => p * q = f) (fun _ _ => True) where
  proj_knowledgeSound := fun ‚ü®p, q, t‚ü© ‚ü®f, t', r‚ü© _ h h' => by admit /- proof elided -/

def fiberwiseDistance (i : Fin ‚Ñì) (steps : ‚Ñï) [NeZero steps] (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
  (f : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i.val, by admit /- proof elided -/
  ‚ü©) : ‚Ñï :=
  
  
  let C_i := BBF_Code ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i.val, by admit /- proof elided -/
  ‚ü©
  let disagreement_sizes := (fun (g : C_i) =>
    (fiberwiseDisagreementSet ùîΩq Œ≤ i steps h_i_add_steps f g).ncard) '' Set.univ
  sInf disagreement_sizes

MvPolynomial.degrees in Mathlib.Algebra.MvPolynomial.Degrees

def isCompliant (i : Fin (‚Ñì)) (steps : ‚Ñï) [NeZero steps]
  (h_i_add_steps : i + steps ‚â§ ‚Ñì)
  (f_i : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i, by admit /- proof elided -/
  ‚ü©)
  (f_i_plus_steps : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      ‚ü®i + steps, by admit /- proof elided -/
      ‚ü©)
  (challenges : Fin steps ‚Üí L) : Prop :=
  ‚àÉ (h_fw_dist_lt : 2 * fiberwiseDistance ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := i)
      (steps := steps) h_i_add_steps f_i < (BBF_CodeDistance ‚Ñì ùì° ‚ü®i + steps, by admit /- proof elided -/
      ‚ü© : ‚Ñï‚àû))
    (h_dist_next_lt : 2 * distFromCode f_i_plus_steps
      (BBF_Code ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i + steps, by admit /- proof elided -/
      ‚ü©)
      < (BBF_CodeDistance ‚Ñì ùì° ‚ü®i + steps, by admit /- proof elided -/
      ‚ü© : ‚Ñï‚àû)), 
    
    let h_dist_curr_lt := fiberwise_dist_lt_imp_dist_lt_unique_decoding_radius ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := i) steps h_i_add_steps f_i
      (h_fw_dist_lt := h_fw_dist_lt)
    let f_bar_i := uniqueClosestCodeword ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (i := ‚ü®i, by admit /- proof elided -/
      ‚ü©) (h_i := fin_‚Ñì_lt_‚Ñì_add_R i) f_i h_dist_curr_lt
    let f_bar_i_plus_steps := uniqueClosestCodeword ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := ‚ü®i + steps, by admit /- proof elided -/
      ‚ü©)
      (h_i := fin_‚Ñì_steps_lt_‚Ñì_add_R i steps h_i_add_steps)
      f_i_plus_steps h_dist_next_lt
    iterated_fold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (steps := ‚ü®steps, by admit /- proof elided -/
      ‚ü©)
      (i := ‚ü®i, by admit /- proof elided -/
      ‚ü©)
      (h_i_add_steps := by admit /- proof elided -/
      )
      f_bar_i challenges = f_bar_i_plus_steps

Mathlib.Linter.TextBased.ErrorFormat.github in Mathlib.Tactic.Linter.TextBased

@[reducible, inline, specialize]
def UniPoly (R : Type*) := Array R

Mod.mod in Init.Prelude

noncomputable def finalSumcheckKnowledgeStateFunction {œÉ : Type} (init : ProbComp œÉ)
    (impl : QueryImpl []‚Çí (StateT œÉ ProbComp)) :
    (finalSumcheckVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).KnowledgeStateFunction init impl
    (relIn := roundRelation ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (ùìë := ùìë) (mp := BBF_SumcheckMultiplierParam) (Fin.last ‚Ñì))
    (relOut := finalSumcheckRelOut ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (extractor := finalSumcheckRbrExtractor ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
  where
  toFun := fun m ‚ü®stmt, oStmt‚ü© tr witMid =>
    finalSumcheckKStateProp ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (ùìë := ùìë) (tr := tr) (stmt := stmt) (witMid := witMid) (oStmt := oStmt)
  toFun_empty := fun stmt witMid => by admit /- proof elided -/

def shift_left (s : Finset ‚Ñï) : Finset ‚Ñï :=
  s.filterMap
    (fun n => match n with
      | 0 => .none
      | n + 1 => .some n
      )
    (by admit /- proof elided -/
    )

def coeffsToBitVec {n : ‚Ñï} (coeffs : List (ZMod 2)) : BitVec n :=
  let val := List.foldr (fun c acc => acc * 2 + c.val) 0 (coeffs.take n)
  BitVec.ofNat n val

noncomputable def proximityCondition
   (f : par‚Ñì ‚Üí Œπ ‚Üí F) (Œ¥ : ‚Ñù) (r : par‚Ñì ‚Üí F) (C : LinearCode Œπ F) : Prop :=
  Œ¥·µ£( (fun x => ‚àë j : par‚Ñì, (r j) * f j x) , C ) ‚â§ (Œ¥ : ‚Ñù)

instance inhabited [Inhabited R] : Inhabited (MlPoly R n) :=

NNRat.castRec in Mathlib.Algebra.Field.Defs

structure BerlekampWelchCondition (e k : ‚Ñï) (œâs f : Fin n ‚Üí F) (E Q : Polynomial F) : Prop where
  cond: ‚àÄ i : Fin n, Q.eval (œâs i) = (f i) * E.eval (œâs i)
  E_natDegree : E.natDegree = e
  E_leadingCoeff : E.coeff e = 1
  Q_natDegree : Q.natDegree ‚â§ e + k - 1

structure WireIndices (numWires : ‚Ñï) where
   
  a : Fin numWires
   
  b : Fin numWires
   
  c : Fin numWires
deriving DecidableEq

ZeroMemClass in Mathlib.Algebra.Group.Submonoid.Defs

def hintBytes (state : FSProverState U H R) (hint : ByteArray) :
    Except DomainSeparatorMismatch (FSProverState U H R) :=
  match state.hashState.hint with
  | .ok newHashState =>
    
    
    .ok { rng := state.rng, hashState := newHashState, nargString := state.nargString }
  | .error e => .error e

@[reducible, inline]
instance instMvPolynomial : OracleInterface (R[X œÉ]) where
  Query := œÉ ‚Üí R
  Response := R
  answer := fun poly point => eval point poly

def FullData.leftSubtree {Œ± : Type} {s_left s_right : Skeleton}
    (tree : FullData Œ± (Skeleton.internal s_left s_right)) :
    FullData Œ± s_left :=
  match tree with
  | FullData.internal _ left _right =>
    left

class DFunEquiv (F : Sort*) (Œ± : outParam (Sort*)) (Œ≤ : outParam <| Œ± ‚Üí Sort*) where
  equiv : F ‚âÉ ‚àÄ a : Œ±, Œ≤ a

def FullData.get {s} {Œ± : Type}
    (tree : FullData Œ± s) (idx : SkeletonNodeIndex s) : Œ± :=
  match tree, idx with
  | FullData.leaf value, SkeletonNodeIndex.ofLeaf => value
  | FullData.internal value _ _, SkeletonNodeIndex.ofInternal => value
  | FullData.internal _ left _, SkeletonNodeIndex.ofLeft idxLeft =>
    FullData.get left idxLeft
  | FullData.internal _ _ right, SkeletonNodeIndex.ofRight idxRight =>
    FullData.get right idxRight

def new (domainSeparator : DomainSeparator U H) : HashStateWithInstructions U H :=
  letI stack := domainSeparator.finalize
  letI tag := generateTag domainSeparator.asBytes
  { ds := Initialize.new tag, stack := stack }

@[inline] def max [Zero T] [ToNat T] (a b : Cayley T) : Cayley T :=
  if (a : Nat) ‚â• (b : Nat) then a else b

PFunctor.Lens.id in ToMathlib.PFunctor.Lens.Basic

instance {k : Fin (n + 1)} : Fintype (pSpec.MessageIdxUpTo k) :=
  inferInstanceAs (Fintype <| MessageIdx (pSpec.take k k.is_le))

Set.image in Mathlib.Data.Set.Defs

def insertNth (p : Fin (n + 1)) (y : M) (s : Fin n ‚Üí‚ÇÄ M) : Fin (n + 1) ‚Üí‚ÇÄ M :=
  Finsupp.equivFunOnFinite.symm (Fin.insertNth p y s : Fin (n + 1) ‚Üí M)

class PolynomialLike (R : outParam (Type u)) [CommSemiring R] (P : Type v) [CommSemiring P]
    extends Algebra R P where

   
  X {R} : P

   
  eval‚ÇÇ {S : Type w} [CommSemiring S] (f : R ‚Üí+* S) (x : S) : P ‚Üí+* S

  eval‚ÇÇ_C {r : R} {S : Type w} [CommSemiring S] (f : R ‚Üí+* S) (x : S) :
    (eval‚ÇÇ f x) (_root_.algebraMap R P r) = f r

  eval‚ÇÇ_X {S : Type w} [CommSemiring S] (f : R ‚Üí+* S) (x : S) : eval‚ÇÇ f x X = x

  eval‚ÇÇ_eq {S : Type w} [CommSemiring S] (g : P ‚Üí+* S) :
    g = eval‚ÇÇ (g.comp (Algebra.ofId R P)) (g X)

protected def cast (P : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec‚ÇÅ) :
    Prover oSpec StmtIn WitIn StmtOut WitOut pSpec‚ÇÇ where
  PrvState := P.PrvState ‚àò Fin.cast (congrArg (¬∑ + 1) hn.symm)
  input := P.input
  sendMessage := fun i st => do
    let ‚ü®msg, newSt‚ü© ‚Üê P.sendMessage (i.cast hn.symm (cast_symm hSpec)) st
    return ‚ü®(Message.cast_idx_symm hSpec) ‚ñ∏ msg, newSt‚ü©
  receiveChallenge := fun i st => do
    let f ‚Üê P.receiveChallenge (i.cast hn.symm (cast_symm hSpec)) st
    return fun chal => f (Challenge.cast_idx hSpec ‚ñ∏ chal)
  output := P.output ‚àò (fun st => _root_.cast (by admit /- proof elided -/
  ) st)

def equivMonomialLagrangeRepr : MlPoly R n ‚âÉ MlPolyEval R n where
  toFun := monoToLagrange n
  invFun := lagrangeToMono n
  left_inv v := by admit /- proof elided -/

inductive Data (Œ± : Type) :
    {n : ‚Ñï} ‚Üí {ar : Fin n ‚Üí ‚Ñï} ‚Üí Skeleton n ar ‚Üí Type where
  | leaf {ar0 : Fin 0 ‚Üí ‚Ñï} (value : Œ±) :
      Data Œ± (Skeleton.leaf (ar0 := ar0))
  | node {n : ‚Ñï} {ar : Fin (n+1) ‚Üí ‚Ñï}
      {children : Fin (ar 0) ‚Üí
        Skeleton n (fun i => ar i.succ)}
      (value : Œ±)
      (childrenData : (i : Fin (ar 0)) ‚Üí
        Data Œ± (children i)) :
      Data Œ± (Skeleton.node children)

def prover : OracleProver oSpec (StmtIn R) (OStmtIn R deg) Unit (StmtOut R) (OStmtOut R deg) Unit
    (pSpec R deg) where
  PrvState
    | 0 => R‚¶É‚â§ deg‚¶Ñ[X]
    | 1 => R‚¶É‚â§ deg‚¶Ñ[X]
    | 2 => R‚¶É‚â§ deg‚¶Ñ[X] √ó R

  input := fun ‚ü®‚ü®_, oStmt‚ü©, _‚ü© => oStmt ()

  sendMessage
  | ‚ü®0, _‚ü© => fun polyLE => pure ‚ü®polyLE, polyLE‚ü©
  | ‚ü®1, h‚ü© => nomatch h

  receiveChallenge
  | ‚ü®0, h‚ü© => nomatch h
  | ‚ü®1, _‚ü© => fun polyLE => pure fun chal => ‚ü®polyLE, chal‚ü©

  output := fun ‚ü®polyLE, chal‚ü© => pure (((polyLE.val.eval chal, chal), fun _ => polyLE), ())

Fin.succEmb in Mathlib.Data.Fin.Embedding

@[inline, reducible]
def proj : OuterStmtIn √ó OuterWitIn ‚Üí InnerWitIn :=
  lens.toFunA

@[simp]
def BTField (k : ‚Ñï) := (BinaryTowerAux k).1

Submodule.map in Mathlib.Algebra.Module.Submodule.Map

def factor' (n : ‚Ñï) : Option (List PrimeWithMultiplicity) := do
  let facts := List.mergeSort (‚Üê factor n)
  let groups := List.splitBy (¬∑ = ¬∑) facts
  return groups.map (fun g => ‚ü®g[0]!, g.length‚ü©)

def toEvalsZeroOne (p : MvPolynomial œÉ R) : (œÉ ‚Üí Fin 2) ‚Üí R :=
  fun x => eval (x : œÉ ‚Üí R) p

OracleSpec.QueryLog in VCVio.OracleComp.QueryTracking.Structures

Nat.pred in Init.Prelude

Multiset.map in Mathlib.Data.Multiset.MapFold

def twoLevelData {Œ±} (k0 k1 : ‚Ñï)
    (root : Œ±)
    (lvl1 : Fin k0 ‚Üí Œ±)
    (lvl2 : (i : Fin k0) ‚Üí Fin k1 ‚Üí Œ±) :
    ArityTree.Data Œ± (twoLevelSkel k0 k1) :=

instance {i : Fin r} : Module (R := ùîΩq) (M := U ùîΩq Œ≤ i) := Submodule.module _

instance : Field BaseField := ZMod.instField BASE_FIELD_CARD

instance : ‚àÄ j, SelectableType ((pSpecFold (L:=L)).Challenge j)
  | ‚ü®j, hj‚ü© => by admit /- proof elided -/

def closePtsOnAffineLine {Œπ : Type*} [Fintype Œπ]
                         (u v : Œπ ‚Üí F) (deg : ‚Ñï) (Œ± : Œπ ‚Ü™ F) (e : ‚Ñï) : Set (Œπ ‚Üí F) :=
  {x : Œπ ‚Üí F | x ‚àà Affine.line u v ‚àß distFromCode x (ReedSolomon.code Œ± deg) ‚â§ e}

def SparseMatrix.toMatrix {m n Œ± : Type*} [DecidableEq m] [DecidableEq n] [AddCommMonoid Œ±]
    (A : SparseMatrix m n Œ±) : Matrix m n Œ± :=
  fun i j => ‚àë k : Fin A.numEntries, if A.row k = i ‚àß A.col k = j then A.val k else 0

def foldl' {Œ± : Type u} (n : ‚Ñï) (f : (i : Fin n) ‚Üí Œ± ‚Üí Œ±) (init : Œ±) : Œ± :=
  dfoldl' n (fun _ => Œ±) f init

noncomputable def proximityError (F : Type*) [Fintype F] (d : ‚Ñï) (œÅ : ‚Ñù) (Œ¥ : ‚Ñù) (m : ‚Ñï) : ‚Ñù :=
  if Œ¥ ‚â§ (1 - œÅ) / 2 then
    ((m - 1) * d) / (œÅ * (Fintype.card F))
  else
    let min_val := min (1 - (Real.sqrt œÅ) - Œ¥ ) ((Real.sqrt œÅ) / 20)
    ((m - 1) * d^2) / ((Fintype.card F) * (2 * min_val)^7)

def toSizeR1CS (pp : PublicParams) : R1CS.Size := {
  m := 2 ^ pp.‚Ñì_m
  n := 2 ^ pp.‚Ñì_n
  n_w := 2 ^ pp.‚Ñì_w
  n_w_le_n := Nat.pow_le_pow_of_le (by admit /- proof elided -/
  ) pp.‚Ñì_w_le_‚Ñì_n
}

@[reducible]
def reduction : Reduction oSpec StmtIn WitIn StmtOut WitOut !p[] where
  prover := prover mapStmt mapWit
  verifier := verifier mapStmt

def dfoldlM' (n : ‚Ñï) (Œ± : Fin (n + 1) ‚Üí Type u)
    (f : (i : Fin n) ‚Üí Œ± i.castSucc ‚Üí m (Œ± i.succ)) (init : Œ± 0) : m (Œ± (last n)) :=
  match n with
  | 0 => pure init
  | n + 1 => do
    let x ‚Üê dfoldlM' n (Œ± ‚àò castSucc) (fun i => f i.castSucc) init
    f (last n) x

@[reducible]
def MlPoly (R : Type*) (n : ‚Ñï) := Vector R (2 ^ n) 

partial def factor (n : ‚Ñï) : Option (List ‚Ñï) :=
  if deterministicMillerRabin n then
    [n]
  else do
    let f ‚Üê rho n
    let lhs ‚Üê factor f
    let rhs ‚Üê factor (n / f)
    return (lhs ++ rhs)

@[ext]
structure Equiv {m n : ‚Ñï} (pSpec : ProtocolSpec m) (pSpec' : ProtocolSpec n) where
  round_eq : m = n
  dir_eq : ‚àÄ i, pSpec.dir i = pSpec'.dir (Fin.cast round_eq i)
  typeEquiv : ‚àÄ i, pSpec.¬´Type¬ª i ‚âÉ pSpec'.¬´Type¬ª (Fin.cast round_eq i)

Unique in Mathlib.Logic.Unique

CommMonoid in Mathlib.Algebra.Group.Defs

def FullData.copath {Œ±} {s} (cache_tree : FullData Œ± s) :
    BinaryTree.SkeletonLeafIndex s ‚Üí List Œ±
  | .ofLeaf => []
  | .ofLeft idxLeft =>
    (cache_tree.rightSubtree).getRootValue ::
      (copath cache_tree.leftSubtree idxLeft)
  | .ofRight idxRight =>
    (cache_tree.leftSubtree).getRootValue ::
      (copath cache_tree.rightSubtree idxRight)

@[inline] def zero : AssocNat :=
  ‚ü®id, by admit /- proof elided -/
  ‚ü©

OrderDual in Mathlib.Order.Basic

Nat.Prime in Mathlib.Data.Nat.Prime.Defs

abbrev contract (m : ‚Ñï) (f : Fin n ‚Üí Œ±) := liftF (liftF' (n := m) (liftF f))

instance {pSpec : ProtocolSpec n} {Statement : Type} [‚àÄ i, VCVCompatible (pSpec.Challenge i)] :
    OracleSpec.FiniteRange (fsChallengeOracle Statement pSpec) :=
  inferInstanceAs (OracleSpec.FiniteRange (srChallengeOracle Statement pSpec))

SemilatticeSup in Mathlib.Order.Lattice

noncomputable def polynomialFromNovelCoeffsF‚ÇÇ
  (‚Ñì : ‚Ñï) (h_‚Ñì : ‚Ñì ‚â§ r) (a : Fin (2 ^ ‚Ñì) ‚Üí L) : L‚¶É<2^‚Ñì‚¶Ñ[X] :=
  ‚ü®polynomialFromNovelCoeffs ùîΩq Œ≤ ‚Ñì h_‚Ñì a, by
    simp only [mem_degreeLT, Nat.cast_pow, Nat.cast_ofNat]
    apply (Polynomial.degree_sum_le Finset.univ (fun j => C (a j) * X‚±º ùîΩq Œ≤ ‚Ñì h_‚Ñì j)).trans_lt
    apply (Finset.sup_lt_iff ?_).mpr ?_
    ¬∑ -- ‚ä¢ ‚ä• < 2 ^ ‚Ñì
      exact compareOfLessAndEq_eq_lt.mp rfl
    ¬∑ -- ‚àÄ b ‚àà univ, (C (a b) * X‚±º ùîΩq Œ≤ ‚Ñì h_‚Ñì b).degree < 2 ^ ‚Ñì
      intro j _
      -- ‚ä¢ (C (a j) * X‚±º ùîΩq Œ≤ ‚Ñì h_‚Ñì j).degree < 2 ^ ‚Ñì
      calc (C (a j) * X‚±º ùîΩq Œ≤ ‚Ñì h_‚Ñì j).degree
        _ ‚â§ (C (a j)).degree + (X‚±º ùîΩq Œ≤ ‚Ñì h_‚Ñì j).degree :=

noncomputable instance fintype_sDomain (i : Fin r) :
  Fintype (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i) :=

noncomputable def H
  (Œ¥ : ‚Ñö) (x‚ÇÄ : F)
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  : F[Z][X] := (exists_factors_with_large_common_root_set k Œ¥ x‚ÇÄ h_gs).choose_spec.choose

def removeNth (p : Fin (n + 1)) (s : Fin (n + 1) ‚Üí‚ÇÄ M) : Fin n ‚Üí‚ÇÄ M :=
  Finsupp.equivFunOnFinite.symm (Fin.removeNth p s : Fin n ‚Üí M)

pos in ToMathlib.Control.Comonad.Instances

noncomputable def evenPart (f : Polynomial F) : Polynomial F :=
    C (2‚Åª¬π : F) * (f + f.comp (-X))

instance {U : Type} [SpongeUnit U] [SpongeSize] :
    SpongeState U (Vector U SpongeSize.N) where
  
  new := fun _ => 0
  get := id
  update := fun _ v => v

abbrev MultilinearPoly (L : Type) [CommSemiring L] (‚Ñì : ‚Ñï) := L‚¶É‚â§ 1‚¶Ñ[X Fin ‚Ñì]

def divByMonic [Field R] (p : UniPoly R) (q : UniPoly R) :
    UniPoly R :=
  (divModByMonicAux p q).1

def domainEnum (i : Fin (n + 1)) : Fin (2 ^ (n - i)) ‚Ü™ evalDomain D i :=
  ‚ü®domain D n i.1, domain_injective D i.1 (by admit /- proof elided -/
  )‚ü©

instance instVector : OracleInterface (Vector Œ± n) where
  Query := Fin n
  Response := Œ±
  answer := fun vec i => vec[i]

instance [LawfulBEq R] : AddCommGroup (UniPolyC R) where
  add_assoc := add_assoc
  zero_add := zero_add
  add_zero := add_zero
  add_comm := add_comm
  neg_add_cancel := neg_add_cancel
  nsmul := nsmul 
  nsmul_zero := nsmul_zero
  nsmul_succ := nsmul_succ
  zsmul := zsmulRec 

class RoundByRoundOneShot.IsMonotone (E : RoundByRoundOneShot oSpec StmtIn WitIn pSpec)
    (relIn : Set (StmtIn √ó WitIn)) where
  is_monotone : ‚àÄ roundIdx stmtIn transcript,
    ‚àÄ proveQueryLog‚ÇÅ proveQueryLog‚ÇÇ : oSpec.QueryLog,
    
    proveQueryLog‚ÇÅ.Sublist proveQueryLog‚ÇÇ ‚Üí
    
    
    (stmtIn, E roundIdx stmtIn transcript proveQueryLog‚ÇÅ) ‚àà relIn ‚Üí
      (stmtIn, E roundIdx stmtIn transcript proveQueryLog‚ÇÇ) ‚àà relIn

def accepts (x : Fin numWires ‚Üí ùì°) (g : Gate ùì° numWires) : Prop :=
  g.eval x = 0

noncomputable def novelToMonomialCoeffs

  (‚Ñì : ‚Ñï) (h_‚Ñì : ‚Ñì ‚â§ r) (novel_coeffs : Fin (2 ^ ‚Ñì) ‚Üí L) : Fin (2^‚Ñì) ‚Üí L :=
  let A := changeOfBasisMatrix ùîΩq Œ≤ ‚Ñì h_‚Ñì
  Matrix.vecMul novel_coeffs A

@[inline, reducible]
def lift : OuterStmtIn √ó OuterWitIn ‚Üí InnerStmtOut √ó InnerWitOut ‚Üí OuterStmtOut √ó OuterWitOut :=
  fun ctxIn ctxOut =>
    ‚ü®lens.stmt.toFunB ctxIn.1 ctxOut.1, lens.wit.toFunB ctxIn ctxOut‚ü©

Finset.biUnion in Mathlib.Data.Finset.Union

@[simp]
abbrev Statement.AfterFirstMessage : Type := Statement R pp

Array.zipWith in Init.Data.Array.Basic

instance : ‚àÄ j, OracleInterface ((pSpec D x l).Message j) := fun j =>
  match j with
  | ‚ü®0, h‚ü© => nomatch h

def sumExceptFirst (n : ‚Ñï) (D : Fin n ‚Üí Finset R) :
    MvPolynomial (Fin (n + 1)) R ‚Üí‚Çó[R] Polynomial R :=

def MLEEquivFin {n : ‚Ñï} : R‚¶É‚â§ 1‚¶Ñ[X (Fin n)] ‚âÉ (Fin (2 ^ n) ‚Üí R) :=
  Equiv.trans MLEEquiv (Equiv.piCongr finFunctionFinEquiv (fun _ => Equiv.refl _))

structure ModifiedGuruswami
  (m n k : ‚Ñï)
  (œâs : Fin n ‚Ü™ F)
  (Q : F[Z][X][Y])
  (u‚ÇÄ u‚ÇÅ : Fin n ‚Üí F)
  where
  Q_ne_0 : Q ‚â† 0
   
  Q_deg : natWeightedDegree Q 1 k < D_X ((k + 1) / (n : ‚Ñö)) n m
   
  Q_multiplicity : ‚àÄ i, rootMultiplicity Q
              (Polynomial.C <| œâs i)
              ((Polynomial.C <| u‚ÇÄ i) + Polynomial.X * (Polynomial.C <| u‚ÇÅ i))
            ‚â• m
   
  Q_deg_X :
    degreeX Q < D_X ((k + 1) / (n : ‚Ñö)) n m
   
  Q_D_Y :
    D_Y Q < D_X (k + 1 / (n : ‚Ñö)) n m / k
   
  Q_D_YZ :
    D_YZ Q ‚â§ n * (m + 1/(2 : ‚Ñö))^3 / (6 * Real.sqrt ((k + 1) / n))

def sub (m n : ChurchNat Œ±) : ChurchNat Œ± := sorry 

@[reducible, simp]
def completeness (relation : Set (Statement √ó Witness)) (completenessError : ‚Ñù‚â•0)
    (proof : Proof oSpec Statement Witness pSpec) : Prop :=
  Reduction.completeness init impl relation acceptRejectRel proof completenessError

@[inline, specialize]
def processRound (j : Fin n)
    (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec)
    (currentResult : OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí)
      (pSpec.Transcript j.castSucc √ó prover.PrvState j.castSucc)) :
      OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí)
        (pSpec.Transcript j.succ √ó prover.PrvState j.succ) := do
  let ‚ü®transcript, state‚ü© ‚Üê currentResult
  match hDir : pSpec.dir j with
  | .V_to_P => do
    let challenge ‚Üê pSpec.getChallenge ‚ü®j, hDir‚ü©
    letI newState := (‚Üê prover.receiveChallenge ‚ü®j, hDir‚ü© state) challenge
    return ‚ü®transcript.concat challenge, newState‚ü©
  | .P_to_V => do
    let ‚ü®msg, newState‚ü© ‚Üê prover.sendMessage ‚ü®j, hDir‚ü© state
    return ‚ü®transcript.concat msg, newState‚ü©

MvPolynomial.aeval in Mathlib.Algebra.MvPolynomial.Eval

instance instST‚ÇÇ [SelectableType R] : ‚àÄ i, SelectableType
    ((‚ü®!v[.P_to_V], !v[R‚¶É‚â§ deg‚¶Ñ[X]]‚ü© ++‚Çö !p[] ++‚Çö ‚ü®!v[.V_to_P], !v[R]‚ü©).Challenge i) :=
  instSelectableTypeChallengeAppend

structure BinaryTowerResult (F : Type _) (k : ‚Ñï) where
  vec : (List.Vector F (k + 1))
  instField : (Field F)
  instFintype : Fintype F
  specialElement : F
  specialElementNeZero : NeZero specialElement
  firstElementOfVecIsSpecialElement [Inhabited F] : vec.1.headI = specialElement
  instIrreduciblePoly : (Irreducible (p := (definingPoly specialElement)))
  sumZeroIffEq : ‚àÄ (x y : F), x + y = 0 ‚Üî x = y
  fieldFintypeCard : Fintype.card F = 2^(2^k)
  traceMapEvalAtRootsIs1 : TraceMapProperty F specialElement k

def Fin2ToF2 (ùîΩq : Type*) [Ring ùîΩq] (k : Fin 2) : ùîΩq :=
  if k = 0 then 0 else 1

BitVec.setWidth in Init.Data.BitVec.Basic

List.IsSuffix in Init.Data.List.Basic

instance instDCast‚ÇÇ : DCast‚ÇÇ Nat ProtocolSpec (fun _ pSpec => FullTranscript pSpec) where
  dcast‚ÇÇ h h' T := FullTranscript.cast h h' T
  dcast‚ÇÇ_id := cast_id

def sigmaMessageIdxToSeqCompose {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (i : Fin m) (j : (pSpec i).MessageIdx) : (seqCompose pSpec).MessageIdx :=
  ‚ü®Fin.embedSum i j.1, by admit /- proof elided -/
  ‚ü©

def Œ≥ (x‚ÇÄ : F) (R : F[X][X][Y]) (H : F[X][Y]) [œÜ : Fact (Irreducible H)] : PowerSeries (ùïÉ H) :=
  let subst (t : ‚Ñï) : ùïÉ H :=
    match t with
    | 0 => fieldToùïÉ (-x‚ÇÄ)
    | 1 => 1
    | _ => 0
  PowerSeries.subst (PowerSeries.mk subst) (PowerSeries.mk (Œ± x‚ÇÄ R H))

multiplicity in Mathlib.RingTheory.Multiplicity

Multiset.ofList in Mathlib.Data.Multiset.Defs

def ofNat : ‚Ñï ‚Üí ChurchNat Œ±
  | 0 => zero
  | Nat.succ n => succ (ofNat n)

def eval‚ÇÇ (p : MlPoly R n) (f : R ‚Üí+* S) (x : Vector S n) : S := eval (map f p) x

def rtake (m : ‚Ñï) (h : m ‚â§ n) (pSpec : ProtocolSpec n) : ProtocolSpec m :=
  {dir := Fin.rtake m h pSpec.dir, ¬´Type¬ª := Fin.rtake m h pSpec.¬´Type¬ª}

IsEmpty in Mathlib.Logic.IsEmpty

@[simp]
def outerRelOut_Test : Set (OuterStmtOut_Test √ó Unit) :=
  setOf (fun ‚ü®‚ü®p, q, t, r‚ü©, _‚ü© => (p * q).eval r = t)

instance (s : Finset œÉ) : Fintype { x : œÉ | x ‚àà s } :=

def leadingCoeff (p : UniPoly R) : R := p.trim.getLastD 0

noncomputable instance {s : Set (Œπ ‚Üí F)} : Fintype (affineSpan F s) :=
  Fintype.ofFinite ‚Ü•(affineSpan F s)

@[inline, specialize]
def eval (x : R) (p : UniPoly R) : R :=
  p.eval‚ÇÇ (RingHom.id R) x

@[inline, reducible]
def lift : OuterStmtIn √ó OuterWitIn ‚Üí InnerStmtOut √ó InnerWitOut ‚Üí OuterWitOut :=
  lens.toFunB

Array in Init.Prelude

@[inline]
def add [Add R] (p q : MlPoly R n) : MlPoly R n := Vector.zipWith (¬∑ + ¬∑) p q

LT.lt in Init.Prelude

def hammingBall (C : Code Œπ F) (y : Œπ ‚Üí F) (r : ‚Ñï) : Set (Œπ ‚Üí F) :=
  { c | c ‚àà C ‚àß hammingDist y c ‚â§ r }

class SliceGE (coll : Type u) (start : Type v) (valid : outParam (coll ‚Üí start ‚Üí Prop))
    (subcoll : outParam ((xs : coll) ‚Üí (start : start) ‚Üí (h : valid xs start) ‚Üí Type w)) where
  sliceGE : (xs : coll) ‚Üí (start : start) ‚Üí (h : valid xs start) ‚Üí subcoll xs start h

inductive MemoryOp (Œπ : Type u) (Œ± : Œπ ‚Üí Type v) where
  | read (op : MemoryRead Œπ Œ±)
  | write (op : MemoryWrite Œπ Œ±)

@[inline, specialize, simp]
def verifier : Verifier oSpec Statement Statement !p[] := Verifier.id

def oracleReduction : OracleReduction oSpec (StmtIn R) (OStmtIn R deg) Unit
                                            (StmtOut R) (OStmtOut R deg) Unit (pSpec R deg) where
  prover := prover R deg oSpec
  verifier := oracleVerifier R deg D oSpec

Finset.sup in Mathlib.Data.Finset.Lattice.Fold

instance {k : Fin 1} : Unique (ChallengesUpTo k (default : ProtocolSpec 0)) where
  default := fun i => ()
  uniq := by admit /- proof elided -/

instance : Zero (DuplexSponge U C) where
  zero := {
    state := 0,
    absorbPos := 0,
    squeezePos := 0
  }

def NBlockMessages := 2 * (œë - 1) + 3

noncomputable def foldVerifier :
  OracleVerifier []‚Çí
    (Statement F i.castSucc) (OracleStatement D x s i.castSucc)
    (Statement F i.succ) (OracleStatement D x s i.succ)
    (pSpec D x s i) where
  verify := fun prevChallenges roundChallenge =>
    pure (Fin.vappend prevChallenges (fun _ => roundChallenge ‚ü®0, by admit /- proof elided -/
    ‚ü©))
  embed :=
    ‚ü®
      fun j =>
        if h : j.val = (i.val + 1)
        then Sum.inr ‚ü®1, by admit /- proof elided -/
        ‚ü©
        else Sum.inl ‚ü®j.val, by admit /- proof elided -/
        ‚ü©,
      by admit /- proof elided -/
    ‚ü©
  hEq := by admit /- proof elided -/

@[reducible]
def reduction : Reduction oSpec
    (StatementRound R n 0 √ó ‚àÄ i, OracleStatement R n deg i) Unit
    (StatementRound R n (.last n) √ó ‚àÄ i, OracleStatement R n deg i) Unit
    (pSpec R deg n) :=
  Reduction.seqCompose (oSpec := oSpec)
    (Stmt := fun i => StatementRound R n i √ó (‚àÄ j, OracleStatement R n deg j))
    (Wit := fun _ => Unit)
    (pSpec := fun _ => SingleRound.pSpec R deg)
    (SingleRound.reduction R n deg D oSpec)

Fin.succAbove in Mathlib.Data.Fin.SuccPred

def toCoeffsVec (‚Ñì : Nat) : L‚¶É<2^‚Ñì‚¶Ñ[X] ‚Üí‚Çó[L] CoeffVecSpace L ‚Ñì where
  toFun := fun p => fun i => p.val.coeff i.val
  map_add' := fun p q => by admit /- proof elided -/

@[simp]
def extractorLens (i : Fin n) : Extractor.Lens
    (StatementRound R n i.castSucc √ó (‚àÄ i, OracleStatement R n deg i))
    (StatementRound R n i.succ √ó (‚àÄ i, OracleStatement R n deg i))
    (Simple.StmtIn R √ó (‚àÄ i, Simple.OStmtIn R deg i))
    (Simple.StmtOut R √ó (‚àÄ i, Simple.OStmtOut R deg i))
    Unit Unit Unit Unit where
  stmt := oStmtLens R n deg D i
  wit := Witness.InvLens.trivial

def getUElements (i : Fin r) : List L :=
  (List.finRange (2^i.val)).map fun k =>
    (Finset.univ : Finset (Fin i)).sum fun j =>
      if Nat.getBit (n := k.val) (k := j.val) == 1 then
        Œ≤ ‚ü®j.val, by admit /- proof elided -/
        ‚ü©
      else 0

noncomputable def relayOracleReduction (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
  OracleReduction (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) Context i.succ)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (pSpec := pSpecRelay) where
  prover := relayOracleProver ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hNCR
  verifier := relayOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hNCR

CharP in Mathlib.Algebra.CharP.Defs

def oracleVerifier (i : Fin n) : OracleVerifier oSpec (StatementRound R n i.castSucc)
    (OracleStatement R n deg) (StatementRound R n i.succ) (OracleStatement R n deg) (pSpec R deg) :=
  (Simple.oracleVerifier R deg D oSpec).liftContext (oStmtLens R n deg D i)

abbrev eqPolynomial (r : œÉ ‚Üí R) : R[X œÉ] :=
  ‚àè i : œÉ, singleEqPolynomial (r i) (X i)

def finUInt8Equiv : Fin (2 ^ 8) ‚âÉ UInt8 where
  toFun := fun i => UInt8.ofFin i
  invFun := fun u => u.toFin
  left_inv _ := rfl
  right_inv _ := rfl

def splitSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (k : Fin (vsum n)) : (i : Fin m) √ó Fin (n i) := match m with
  | 0 => Fin.elim0 k
  | _ + 1 => Fin.dappend
    (fun k => ‚ü®0, k‚ü©)
    (fun k => ‚ü®(splitSum k).1.succ, (splitSum k).2‚ü©)
    k

Array.replicate in Init.Data.Array.Basic

def X : UniPoly R := #[0, 1]

def Verifier.liftContext
    (lens : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut)
    (V : Verifier oSpec InnerStmtIn InnerStmtOut pSpec) :
      Verifier oSpec OuterStmtIn OuterStmtOut pSpec where
  verify := fun stmtIn transcript => do
    let innerStmtIn := lens.proj stmtIn
    let innerStmtOut ‚Üê V.verify innerStmtIn transcript
    return lens.lift stmtIn innerStmtOut

List.Vector.ofFn in Mathlib.Data.Vector.Defs

noncomputable def dist (C : Set (n ‚Üí R)) : ‚Ñï :=
  sInf {d | ‚àÉ u ‚àà C, ‚àÉ v ‚àà C, u ‚â† v ‚àß Œî‚ÇÄ( u, v ) ‚â§ d}

Lean.Expr in Lean.Expr

@[simp]
abbrev OracleStatement.AfterFirstSumcheck : R1CS.MatrixIdx ‚äï Fin 1 ‚Üí Type :=
  OracleStatement.AfterFirstChallenge R pp

Module.finrank in Mathlib.LinearAlgebra.Dimension.Finrank

def implGroupEncodeOracle [Serialize G (BitVec bitLength)] :
    QueryImpl (GroupEncodeOracle Œπ bitLength) (StateT (GroupValTable Œπ G) Option) where
  impl | query _ i => fun table =>
    match table i with
    | some g => some (serialize g, table)
    | none => none

Finset.range in Mathlib.Data.Finset.Range

def canonicalEmbedding (k : ‚Ñï) : BTField k ‚Üí+* BTField (k+1) :=
  AdjoinRoot.of (poly k)

@[reducible, inline, specialize]
def ChallengesUpTo (k : Fin (n + 1)) (pSpec : ProtocolSpec n) : Type :=
  ‚àÄ i, (pSpec.take k k.is_le).Challenge i

@[inline, specialize]
def Prover.processRoundDSFS [‚àÄ i, VCVCompatible (pSpec.Challenge i)] (j : Fin n)
    (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec)
    (currentResult : OracleComp (oSpec ++‚Çí duplexSpongeChallengeOracle StmtIn U)
      (pSpec.MessagesUpTo j.castSucc √ó
        CanonicalDuplexSponge U √ó prover.PrvState j.castSucc)) :
      OracleComp (oSpec ++‚Çí duplexSpongeChallengeOracle StmtIn U)
        (pSpec.MessagesUpTo j.succ √ó
          CanonicalDuplexSponge U √ó prover.PrvState j.succ) := do
  let ‚ü®messages, sponge, state‚ü© ‚Üê currentResult
  match hDir : pSpec.dir j with
  | .V_to_P => do
    let f ‚Üê prover.receiveChallenge ‚ü®j, hDir‚ü© state
    let (challenge, newSponge) ‚Üê
      liftM (DuplexSponge.squeeze sponge (challengeSize ‚ü®j, hDir‚ü©))
    
    let deserializedChallenge : pSpec.Challenge ‚ü®j, hDir‚ü© := Deserialize.deserialize challenge
    return ‚ü®messages.extend hDir, newSponge, f deserializedChallenge‚ü©
  | .P_to_V => do
    let ‚ü®msg, newState‚ü© ‚Üê prover.sendMessage ‚ü®j, hDir‚ü© state
    let serializedMessage : Vector U (messageSize ‚ü®j, hDir‚ü©) := Serialize.serialize msg
    let newSponge ‚Üê liftM (DuplexSponge.absorb sponge serializedMessage.toList)
    return ‚ü®messages.concat hDir msg, newSponge, newState‚ü©

def collisionBwdFwd : Prop :=
  let ‚ü®baseTrace, _‚ü© := removeRedundantEntryDS trace
  ‚àÉ stateIn stateOut stateOut',
    (stateIn, stateOut) ‚àà baseTrace.getQ (.inr .Bwd) ‚àß
    (stateOut', stateIn) ‚àà baseTrace.getQ (.inr .Fwd) ‚àß
    stateOut ‚â† stateOut'

alias E_col_pinv_p := collisionBwdFwd

HasSum in Mathlib.Topology.Algebra.InfiniteSum.Defs

def deterministicMillerRabin (n : ‚Ñï) : Bool := Id.run do
  if n ‚â§ 2 ‚à® n % 2 = 0 then
    return n = 2

  let ‚ü®s, d‚ü© := factorOutTwos (n - 1)
  for a in millerRabinBases do
    if a % n == 0 then
      continue

    let mut x := powMod a d n
    if x = 1 ‚à® x = n - 1 then
      continue

    for _ in [0:s] do
      x := (x * x) % n
      if x == n - 1 ‚à® x ‚â§ 1 then
        break
    if x ‚â† n - 1 then
      return false

  return true

instance [h : VerifierFirst pSpec] : VerifierFirst pSpec where
  verifier_first' := by admit /- proof elided -/

def Verifier.StateFunction.liftContext
    {œÉ : Type} {init : ProbComp œÉ} {impl : QueryImpl oSpec (StateT œÉ ProbComp)}
    (lens : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut)
    (V : Verifier oSpec InnerStmtIn InnerStmtOut pSpec)
    (outerLangIn : Set OuterStmtIn) (outerLangOut : Set OuterStmtOut)
    (innerLangIn : Set InnerStmtIn) (innerLangOut : Set InnerStmtOut)
    [lensSound : lens.IsSound outerLangIn outerLangOut innerLangIn innerLangOut
      (V.compatStatement lens)]
    (stF : V.StateFunction init impl innerLangIn innerLangOut) :
      (V.liftContext lens).StateFunction init impl outerLangIn outerLangOut
where
  toFun := fun m outerStmtIn transcript =>
    stF m (lens.proj outerStmtIn) transcript
  toFun_empty := fun stmt => by admit /- proof elided -/

noncomputable def Basis.baseChangeRight (b : Basis Œπ K Left) : Basis Œπ Right (Left ‚äó[K] Right) :=

def ChurchBool (Œ± : Type) : Type := Œ± ‚Üí Œ± ‚Üí Œ±

instance : ‚àÄ j, OracleInterface ((pSpec D x l).Challenge j) := fun j =>
  by admit /- proof elided -/

noncomputable def commitOracleReduction (i : Fin ‚Ñì) (hCR : isCommitmentRound ‚Ñì œë i) :
  OracleReduction (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) Context i.succ)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (pSpec := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) where
  prover := commitOracleProver ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i
  verifier := commitOracleVerifier ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hCR

def rightpad {m : ‚Ñï} {Œ± : Sort*} (n : ‚Ñï) (a : Œ±) (v : Fin m ‚Üí Œ±) : Fin n ‚Üí Œ± :=
  fun i => if h : i < m then v ‚ü®i, h‚ü© else a

@[app_unexpander Fin.dcons]
def dconsUnexpander : Lean.PrettyPrinter.Unexpander
  | `($_ $term !d[$term2, $terms,*]) => `(!d[$term, $term2, $terms,*])
  | `($_ $term !d[$term2]) => `(!d[$term, $term2])
  | `($_ $term !d[]) => `(!d[$term])
  | _ => throw ()

@[reducible]
noncomputable def fullOracleVerifier :
  OracleVerifier (oSpec:=[]‚Çí)
    (StmtIn := Statement (L := L) (‚Ñì:=‚Ñì) (SumcheckBaseContext L ‚Ñì) 0)
    (OStmtIn:= OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë 0)
    (StmtOut := Bool)
    (OStmtOut := fun _ : Empty => Unit)
    (pSpec := fullPSpec ùîΩq Œ≤ Œ≥_repetitions (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)) :=
  OracleVerifier.append (oSpec:=[]‚Çí)
    (Stmt‚ÇÅ := Statement (L := L) (SumcheckBaseContext L ‚Ñì) 0)
    (Stmt‚ÇÇ := FinalSumcheckStatementOut (L:=L) (‚Ñì:=‚Ñì))
    (Stmt‚ÇÉ := Bool)
    (OStmt‚ÇÅ := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë 0)
    (OStmt‚ÇÇ := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (OStmt‚ÇÉ := fun _ : Empty => Unit)
    (pSpec‚ÇÅ := pSpecCoreInteraction ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (pSpec‚ÇÇ := pSpecQuery ùîΩq Œ≤ Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (V‚ÇÅ := CoreInteraction.coreInteractionOracleVerifier ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (œë:=œë))
    (V‚ÇÇ := QueryPhase.queryOracleVerifier ùîΩq Œ≤ Œ≥_repetitions
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (œë:=œë))

def Option.doubleBind_v3 {Œ± Œ≤ Œ≥ : Type} (f : Œ± ‚Üí Œ≤ ‚Üí Option Œ≥)
    (x : Option Œ±) (y : Option Œ≤) : Option Œ≥ := do f (‚Üê x) (‚Üê y)

Nat.decLt in Init.Prelude

List.idxOf in Init.Data.List.Basic

def verifyProof {n : ‚Ñï} (i : Fin (2 ^ n)) (leaf : Œ±) (root : Œ±) (proof : List.Vector Œ± n) :
    OracleComp (spec Œ±) Unit := do
  let putative_root ‚Üê getPutativeRoot Œ± i leaf proof
  guard (putative_root = root)

def computableBasisExplicit (k : ‚Ñï) (i : Fin (2 ^ k)) : ConcreteBTField k :=
  (Finset.univ : Finset (Fin k)).prod fun j =>
    if Nat.getBit (n := i.val) (k := j.val) == 1 then
      concreteTowerAlgebraMap (j.val + 1) k (by admit /- proof elided -/
      ) (Z (j.val + 1))
    else
      1

def mkAddCommGroupInstance {k : ‚Ñï} : AddCommGroup (ConcreteBTField k) := {
  zero := zero
  neg := neg
  sub := fun x y => add x y
  add_assoc := add_assoc
  add_comm := add_comm
  zero_add := zero_add
  add_zero := add_zero
  nsmul := fun n x => if n % 2 = (0 : ‚Ñï) then zero else x
  zsmul := fun (n : ‚Ñ§) x => if n % 2 = 0 then zero else x  
  neg_add_cancel := neg_add_cancel
  nsmul_succ := nsmul_succ
  zsmul_succ' := fun n a => zsmul_succ n a
  add := add
  zsmul_neg' := zsmul_neg' (k := k)
}

Fin.cons in Mathlib.Data.Fin.Tuple.Basic

def dummyLastWitness :
    Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì) := {
  t := ‚ü®0, by admit /- proof elided -/
  ‚ü©,
  H := ‚ü®0, by admit /- proof elided -/
  ‚ü©,
  f := fun _ => 0
}

class Extractor.Straightline.IsMonotone
    (relIn : Set (StmtIn √ó WitIn))
    (E : Extractor.Straightline oSpec StmtIn WitIn WitOut pSpec)
    [oSpec.FiniteRange]
    where
  is_monotone : ‚àÄ witOut stmtIn transcript, ‚àÄ proveQueryLog‚ÇÅ proveQueryLog‚ÇÇ : oSpec.QueryLog,
    ‚àÄ verifyQueryLog‚ÇÅ verifyQueryLog‚ÇÇ : oSpec.QueryLog,
    proveQueryLog‚ÇÅ.Sublist proveQueryLog‚ÇÇ ‚Üí
    verifyQueryLog‚ÇÅ.Sublist verifyQueryLog‚ÇÇ ‚Üí
    
    [fun witIn => (stmtIn, witIn) ‚àà relIn |
      E stmtIn witOut transcript proveQueryLog‚ÇÅ verifyQueryLog‚ÇÅ] ‚â§
    [fun witIn => (stmtIn, witIn) ‚àà relIn |
      E stmtIn witOut transcript proveQueryLog‚ÇÇ verifyQueryLog‚ÇÇ]

protected def cast (pSpec : ProtocolSpec n‚ÇÅ) : ProtocolSpec n‚ÇÇ :=
  ‚ü®pSpec.dir ‚àò (Fin.cast hn.symm), pSpec.¬´Type¬ª ‚àò (Fin.cast hn.symm)‚ü©

Fin.natAdd in Init.Data.Fin.Basic

abbrev ScalarField := ZMod scalarFieldSize

BitVec.extractLsb in Init.Data.BitVec.Basic

def inputRelation : Set (((StmtIn R) √ó (‚àÄ i, OStmtIn R deg i)) √ó Unit) :=
  { ‚ü®‚ü®target, oStmt‚ü©, _‚ü© | ‚àë x ‚àà (univ.map D), (oStmt ()).1.eval x = target }

Fin.subNat in Init.Data.Fin.Basic

instance {s} : Functor (fun Œ± => FullData Œ± s) where
  map f x := x.map f

Finsupp.update in Mathlib.Data.Finsupp.Single

reduceDIte in Lean.Meta.Tactic.Simp.BuiltinSimprocs.Core

Fintype.equivFin in Mathlib.Data.Fintype.EquivFin

instance : LT AssocNat where
  lt a b := a 0 < b 0

Matrix.vecMul in Mathlib.Data.Matrix.Mul

CommMonoidWithZero in Mathlib.Algebra.GroupWithZero.Defs

@[reducible, simp] def OStmtOut := fun _ : Fin 1 => OStatement

Even in Mathlib.Algebra.Group.Even

Set.fintypeMemFinset in Mathlib.Data.Set.Finite.Basic

Context in Examples.FrankingProtocol

instance instDCastPSigmaPSigma :
    DCast ((a : Œ±) √ó' (b : Œ≤ a) √ó' Œ≥ a b) (fun a => Œ¥ a.1 a.2.1 a.2.2) where
  dcast hc d := dcast‚ÇÉ (by admit /- proof elided -/
  ) (by admit /- proof elided -/
  ) (by admit /- proof elided -/
  ) d
  dcast_id := by admit /- proof elided -/

dotProduct in Mathlib.Data.Matrix.Mul

def factorOutTwos (n : ‚Ñï) : PowTwoRepr := Id.run do
  let mut two_exp := 0
  let mut odd_part := n

  while odd_part % 2 = 0 do
    two_exp := two_exp + 1
    odd_part := odd_part / 2

  return ‚ü®two_exp, odd_part‚ü©

structure LookaheadSequenceFamily
    (trace : QueryLog (forwardPermutationOracle (CanonicalSpongeState U)))
    (state : CanonicalSpongeState U) (i : pSpec.ChallengeIdx) where
   
  seqFamily : Finset (LookaheadSequence trace state)
   
  maximality : ‚àÄ s ‚àà seqFamily, ‚àÄ s' ‚àà seqFamily,
    ¬¨ (s.inputState ‚äÜ s'.inputState) ‚à® ¬¨ (s'.outputState ‚äÜ s.outputState)
   
  length_le_challengeSize : ‚àÄ s ‚àà seqFamily, s.inputState.length ‚â§ challengeSize i

def foldStepRelOut (i : Fin ‚Ñì) :
    Set ((Statement (L := L) Context i.succ √ó
      (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j)) √ó
      Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ) :=
  { input | foldStepRelOutProp (mp := mp) (ùìë := ùìë) ùîΩq Œ≤ i input}

Fin.rev in Init.Data.Fin.Basic

@[simp]
def evalDomain (i : ‚Ñï) : Set FÀ£ :=
  (x ^ (2 ^ i)) ‚Ä¢ (Domain.evalDomain D i)

Fact in Mathlib.Logic.Basic

def EvenPoly (f : Polynomial F) : Prop := ‚àÄ n, Odd n ‚Üí f.coeff n = 0

def BBF_Code (i : Fin (‚Ñì + 1)) : Submodule L ((sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate)
    ‚ü®i, by admit /- proof elided -/
        ‚ü© ‚Üí L) :=
  let domain : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®i, by admit /- proof elided -/
  ‚ü© ‚Ü™ L :=
    ‚ü®fun x => x.val, fun x y h => by admit /- proof elided -/
    ‚ü©
  ReedSolomon.code (domain := domain) (deg := 2^(‚Ñì - i.val))

noncomputable def finToSDomain (i : Fin r) (h_i : i < ‚Ñì + R_rate)
  (idx : Fin (2 ^ (‚Ñì + R_rate - i.val))) :
  sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i :=

instance : IsEmpty (AssocFin AssocNat.zero) :=

def eval‚ÇÇAlgHom {A B : Type*} [CommSemiring A] [CommSemiring B] [MvPolynomialLike œÉ A P]
    [Algebra R A] [IsScalarTower R A P] [Algebra R B]
    (f : A ‚Üí‚Çê[R] B) (g : œÉ ‚Üí B) : P ‚Üí‚Çê[R] B where
  toRingHom := eval‚ÇÇ f g
  commutes' r := by admit /- proof elided -/

LawfulMonad in Init.Control.Lawful.Basic

@[reducible]
def pSpec : ProtocolSpec 1 := ‚ü®!v[.P_to_V], !v[OStatement default]‚ü©

@[reducible, inline, specialize, simp]
def ChallengeIdx (vPSpec : VectorSpec n) := {i : Fin n // vPSpec.dir i = .V_to_P}

@[app_unexpander Fin.dempty]
def demptyUnexpander : Lean.PrettyPrinter.Unexpander
  | `($_:ident) => `(!h[])
  | _ => throw ()

OracleComp.neverFailsWhen in VCVio.OracleComp.Traversal

NatPow in Init.Prelude

@[reducible, simp]
def rbrSoundness (langIn : Set Statement)
    (verifier : Verifier oSpec Statement Bool pSpec)
    (rbrSoundnessError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) : Prop :=
  verifier.rbrSoundness init impl langIn acceptRejectRel.language rbrSoundnessError

@[reducible, inline]
instance instProdForall {Œπ : Type u} (v : Œπ ‚Üí Type v) [O : ‚àÄ i, OracleInterface (v i)] :
    OracleInterface (‚àÄ i, v i) where
  Query := (i : Œπ) √ó (O i).Query
  Response := (i : Œπ) √ó (O i).Response
  answer := fun f ‚ü®i, q‚ü© => ‚ü®i, (O i).answer (f i) q‚ü©

noncomputable def X‚±º (‚Ñì : ‚Ñï) (h_‚Ñì : ‚Ñì ‚â§ r) (j : Fin (2 ^ ‚Ñì)) : L[X] :=
  (Finset.univ : Finset (Fin ‚Ñì)).prod
    (fun i => (normalizedW ùîΩq Œ≤ (Fin.castLE h_‚Ñì i))^(Nat.getBit i j))

noncomputable def mVdecode :
  (smoothCode domain m) ‚Üí‚Çó[F] MvPolynomial (Fin m) F :=
    linearMvExtension.comp decodeLT

instance [Zero T] [ToNat T] : DecidableRel (@LE.le (Cayley T) _) := fun a b =>
  Nat.decLe (‚Üëa) (‚Üëb)

private def sum_choose_K_i (B : Finset (Fin n ‚Üí F)) (i : Fin n) : ‚Ñö :=
  ‚àë (Œ± : F), choose_2 (K B i Œ±)

FreeMonad.roll in ToMathlib.Control.Monad.Free

instance : Zero (Cayley T) where
  zero := zero

def oracleReduction.firstChallenge :
    OracleReduction oSpec
      (Statement.AfterFirstMessage R pp) (OracleStatement.AfterFirstMessage R pp) (Witness R pp)
      (Statement.AfterFirstChallenge R pp) (OracleStatement.AfterFirstChallenge R pp) Unit
      ‚ü®!v[.V_to_P], !v[FirstChallenge R pp]‚ü© :=
  sorry

def existPriorSameQuery (log : QueryLog spec) (idx : Fin log.length) : Prop :=
  ‚àÉ j' < idx, log[j'] = log[idx]

def isRead : MemoryOp Œπ Œ± ‚Üí Prop
  | read _ => True
  | _ => False

instance : ‚àÄ i, SelectableType (‚Üë(sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i)) := fun i => sorry

noncomputable def foldOracleReduction (i : Fin ‚Ñì) :
  OracleReduction (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) Context i.castSucc)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (pSpec := pSpecFold (L := L)) where
  prover := foldOracleProver ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i
  verifier := foldOracleVerifier ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i

def outOfOrderPerm : Prop :=
  
  trace = [] ‚àß state = 0

alias E_time_p := outOfOrderPerm

noncomputable def polyToPowerSeriesùïÉ (H : F[X][Y])
  (P : F[X][Y])
    : PowerSeries (ùïÉ H) :=
  PowerSeries.mk <| fun n =>
    liftToFunctionField (P.coeff n)

instance {i : Fin (‚Ñì / œë - 1)} : ‚àÄ j, SelectableType ((pSpecFullNonLastBlock ùîΩq Œ≤
  (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i).Challenge j) := instSelectableTypeChallengeAppend

@[ext]
structure GroupRepresentation {G : Type*} [Group G] {p : ‚Ñï} (prev : List G) (target : G) where
  exponents : List (ZMod p)
  hEq : (prev.zipWith (fun g a => g ^ a.val) exponents).prod = target

OracleSpec.QueryLog.inr in VCVio.OracleComp.QueryTracking.Structures

guard in Init.Control.Basic

def computableAdditiveNTT (a : Fin (2 ^ ‚Ñì) ‚Üí L) : Fin (2^(‚Ñì + R_rate)) ‚Üí L :=
  let b: Fin (2^(‚Ñì + R_rate)) ‚Üí L := tileCoeffs a 
  Fin.foldl (n:=‚Ñì) (f:= fun current_b i  =>
    computableNTTStage (ùîΩq := ùîΩq) (Œ≤ := Œ≤) (‚Ñì := ‚Ñì) (R_rate := R_rate)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := ‚ü®‚Ñì - 1 - i, by admit /- proof elided -/
      ‚ü©) (b:=current_b)
  ) (init:=b)

def millerRabinBases : List ‚Ñï :=
  [2, 325, 9375, 28178, 450775, 9780504, 1795265022]

Fintype.ofEquiv in Mathlib.Data.Fintype.OfMap

def MLE (evals : (œÉ ‚Üí Fin 2) ‚Üí R) : MvPolynomial œÉ R :=
    ‚àë x : œÉ ‚Üí Fin 2, (eqPolynomial (x : œÉ ‚Üí R)) * C (evals x)

protected def cast (T : FullTranscript pSpec‚ÇÅ) :
    FullTranscript pSpec‚ÇÇ :=
  Transcript.cast (k := Fin.last n‚ÇÅ) (l := Fin.last n‚ÇÇ) hn hn hSpec T

@[inline] def monoToLagrange (n : ‚Ñï) : MlPoly R n ‚Üí MlPolyEval R n :=
  (List.finRange n).foldl (fun acc level => monoToLagrangeLevel level acc)

instance : OracleInterfaces (vPSpec.toProtocolSpec A) where
  oracleInterfaces := fun _ => some OracleInterface.instVector

IO.eprintln in Init.System.IO

def dotProduct [Zero R] [Add R] [Mul R] (a b : Vector R n) : R :=
  a.zipWith (¬∑ * ¬∑) b |>.foldl (¬∑ + ¬∑) 0

class IsSecure
    (relation : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (Œµ_rbr : vPSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0)
    (vectorIOP : VectorIOP Statement OStatement Witness vPSpec A) where

   
  is_complete : vectorIOP.perfectCompleteness (pure ()) ‚ü®isEmptyElim‚ü© relation

   
  is_rbr_knowledge_sound :
    OracleProof.rbrKnowledgeSoundness (pure ()) ‚ü®isEmptyElim‚ü© relation vectorIOP.verifier Œµ_rbr

List.Vector.nil in Mathlib.Data.Vector.Defs

def findSum (l : List Œ±) (j : Œ±) : Option Œ± := l.partialSum.find? (j < ¬∑)

@[inline] def ofNat (n : Nat) : Cayley T :=
  ‚ü®fun t => succ'^[n] t, Function.iterate_succ_apply' succ' n‚ü©

def pSpecSumcheckFold := (pSpecNonLastBlocks ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)) ++‚Çö
  (pSpecLastBlock (L:=L) (œë:=œë))

def finUInt32Equiv : Fin (2 ^ 32) ‚âÉ UInt32 where
  toFun := fun i => UInt32.ofFin i
  invFun := fun u => u.toFin
  left_inv _ := rfl
  right_inv _ := rfl

@[reducible]
def coreInteractionOracleVerifier :=
  OracleVerifier.append (oSpec:=[]‚Çí)
    (Stmt‚ÇÅ := Statement (L := L) (‚Ñì:=‚Ñì) (SumcheckBaseContext L ‚Ñì) 0)
    (Stmt‚ÇÇ := Statement (L := L) (‚Ñì:=‚Ñì) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì))
    (Stmt‚ÇÉ := FinalSumcheckStatementOut (L:=L) (‚Ñì:=‚Ñì))
    (OStmt‚ÇÅ := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë 0)
    (OStmt‚ÇÇ := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (OStmt‚ÇÉ := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (pSpec‚ÇÅ := pSpecSumcheckFold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (pSpec‚ÇÇ := pSpecFinalSumcheckStep (L:=L))
    (V‚ÇÅ := sumcheckFoldOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (V‚ÇÇ := finalSumcheckVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))

abbrev ScalarField := ZMod scalarFieldSize

instance instTestLensComplete : testLens.IsComplete
      outerRelIn_Test innerRelIn_Test outerRelOut_Test innerRelOut_Test
      (fun ‚ü®‚ü®p, q, _‚ü©, _‚ü© ‚ü®‚ü®f, _‚ü©, _‚ü© => p * q = f) where
  proj_complete := fun ‚ü®p, q, t‚ü© () hRelIn => by admit /- proof elided -/

@[reducible]
def messageLength (vPSpec : VectorSpec n) (i : MessageIdx vPSpec) : Nat := vPSpec.length i

def IsBerlekampWelchSolution
  (e k : ‚Ñï)
  (œâs f : Fin n ‚Üí F)
  (v : Fin (2 * e + k) ‚Üí F)
  : Prop
  := Matrix.mulVec (BerlekampWelchMatrix e k œâs f) v = Rhs e œâs f

instance : Field ScalarField := ZMod.instField scalarFieldSize

@[inline, reducible]
protected def id :
    Statement.Lens OuterStmtIn OuterStmtOut OuterStmtIn OuterStmtOut :=
  PFunctor.Lens.id _

alias trivial := Statement.Lens.id

def InternalData.map {Œ± Œ≤ : Type} (f : Œ± ‚Üí Œ≤) {s : Skeleton}
    (tree : InternalData Œ± s) : InternalData Œ≤ s :=
  match tree with
  | InternalData.leaf => InternalData.leaf
  | InternalData.internal value left right =>
    InternalData.internal (f value) (left.map f) (right.map f)

def append' (so‚ÇÅ : SimOracle.Stateful spec‚ÇÅ spec‚Çú‚ÇÅ œÉ) (so‚ÇÇ : SimOracle.Stateful spec‚ÇÇ spec‚Çú‚ÇÇ œÑ) :
    SimOracle.Stateful (spec‚ÇÅ ++‚Çí spec‚ÇÇ) (spec‚Çú‚ÇÅ ++‚Çí spec‚Çú‚ÇÇ) (œÉ √ó œÑ) where
  impl
  | query (.inl i) t => fun (s‚ÇÅ, s‚ÇÇ) ‚Ü¶ do
      let (u, s‚ÇÅ') ‚Üê so‚ÇÅ.impl (query i t) s‚ÇÅ; return (u, s‚ÇÅ', s‚ÇÇ)
  | query (.inr i) t => fun (s‚ÇÅ, s‚ÇÇ) ‚Ü¶ do
      let (u, s‚ÇÇ') ‚Üê so‚ÇÇ.impl (query i t) s‚ÇÇ; return (u, s‚ÇÅ, s‚ÇÇ')

def vflatten {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (v : (i : Fin m) ‚Üí Fin (n i) ‚Üí Œ±) :
    Fin (vsum n) ‚Üí Œ± :=
  dflatten v

@[reducible, simp] def StmtOut := Query OStatement √ó Response OStatement

NatCast in Init.Data.Cast

def StraightlineExtractor (oSpec : OracleSpec Œπ) (Data Commitment : Type) :=
  Commitment ‚Üí QueryLog oSpec ‚Üí Data

def foldPrvState (i : Fin ‚Ñì) : Fin (2 + 1) ‚Üí Type := fun
  
  | ‚ü®0, _‚ü© => (Statement (L := L) Context i.castSucc √ó
    (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j) √ó
    Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
  
  | ‚ü®1, _‚ü© => Statement (L := L) Context i.castSucc √ó
    (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j) √ó
    Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc √ó L‚¶É‚â§ 2‚¶Ñ[X]
  
  | _ => Statement (L := L) Context i.castSucc √ó
    (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j) √ó
    Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc √ó L‚¶É‚â§ 2‚¶Ñ[X] √ó L

def commitKState (i : Fin ‚Ñì) (hCR : isCommitmentRound ‚Ñì œë i) :
    (commitOracleVerifier ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      i hCR).KnowledgeStateFunction init impl
      (relIn := foldStepRelOut (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i.succ)
      (extractor := commitRbrExtractor ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) where
  toFun := fun m ‚ü®stmtIn, oStmtIn‚ü© tr witMid =>
    commitKStateProp ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (i := i) (m := m) (stmtIn := stmtIn) (witMid := witMid) (oStmtIn := oStmtIn) (mp:=mp)
  toFun_empty := fun stmtIn witMid => by admit /- proof elided -/

Vector.zipWith in Init.Data.Vector.Basic

def relation (cs : ConstraintSystem ùì° numWires numGates) (‚Ñì : ‚Ñï) (h‚Ñì : ‚Ñì ‚â§ numWires) :
    (publicInputs : Fin ‚Ñì ‚Üí ùì°) ‚Üí (privateWitness : Fin (numWires - ‚Ñì) ‚Üí ùì°) ‚Üí Prop :=
  fun (x : Fin ‚Ñì ‚Üí ùì°) (œâ : Fin (numWires - ‚Ñì) ‚Üí ùì°) =>
    let combined := Fin.append x œâ ‚àò Fin.cast (by admit /- proof elided -/
    )
    cs.accepts combined

List.rtake in Mathlib.Data.List.DropRight

@[reducible, inline, specialize]
def Challenges (pSpec : ProtocolSpec n) : Type := ‚àÄ i, pSpec.Challenge i

class PolynomialLike.LawfulCoeff (R : Type u) [CommSemiring R] (P : Type v) [CommSemiring P]
    [PolynomialLike R P] (coeff : P ‚Üí ‚Ñï ‚Üí R) where
  coeff_finite (p : P) : Set.Finite {n | coeff p n ‚â† 0}

def evalOnPoints [Semiring F] : F[X] ‚Üí‚Çó[F] (Œπ ‚Üí F) where
  toFun := fun p => fun x => p.eval (domain x)
  map_add' := fun x y => by admit /- proof elided -/

def finalNonDoomedFoldingProp {h_le : œë ‚â§ ‚Ñì}
    (input : (FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì) √ó
      (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì) j))) :
    Prop :=
  let stmt := input.1
  let oStmt := input.2
  let f_‚Ñì: (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®‚Ñì, by admit /- proof elided -/
  ‚ü© ‚Üí L := fun x => stmt.final_constant
  let j := mkLastOracleIndex ‚Ñì œë (Fin.last ‚Ñì) 
  let k := j.val * œë
  have h_k: k = ‚Ñì - œë := by admit /- proof elided -/

TensorProduct in Mathlib.LinearAlgebra.TensorProduct.Basic

Infinite in Mathlib.Data.Finite.Defs

@[reducible]
def fieldSize : Nat := 2 ^ 31 - 2 ^ 27 + 1

@[inline] def ofNat (k : Nat) : AssocNat :=
  ‚ü®fun m => m + k, fun m => Nat.succ_add m k‚ü©

noncomputable def sDomain_basis (i : Fin r) (h_i : i < ‚Ñì + R_rate) :
    Basis (Fin (‚Ñì + R_rate - i)) ùîΩq (
      sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i) :=

def Œ≥' (x‚ÇÄ : F) (R : F[X][X][Y]) (H_irreducible : Irreducible H) : PowerSeries (ùïÉ H) :=
  Œ≥ x‚ÇÄ R H (œÜ := ‚ü®H_irreducible‚ü©)

Equiv in Mathlib.Logic.Equiv.Defs

def finIdxOf [BEq Œ±] [LawfulBEq Œ±] (a : Œ±) (l : List Œ±) : Fin (l.length + 1) :=
  ‚ü®List.idxOf' a l, Nat.lt_succ_of_le (by admit /- proof elided -/
  )‚ü©

@[inline]
def permute (params : Params) (state : Vector KoalaBear.Field params.width) :
    Vector KoalaBear.Field params.width :=
  letI rcs := params.roundConstants

  
  let st0 := externalLinearLayer params state

  
  let st1 : Vector KoalaBear.Field params.width :=
    Fin.foldl params.halfNumFullRounds (fun st_acc rc_idx =>
      let rc_chunk := (rcs.extract rc_idx (rc_idx + params.width)).cast (by admit /- proof elided -/
      )
      let st_new := fullRound params st_acc rc_chunk
      st_new) st0

  
  let rcs := rcs.drop (params.halfNumFullRounds * params.width)

  
  let st2 := Fin.foldl params.numPartialRounds (fun st_acc rc_idx =>
    let rc_val := rcs[rc_idx]'(sorry)
    let st_new := partialRound params st_acc rc_val
    st_new) st1

  
  let rcs := rcs.drop params.numPartialRounds

  
  let st3 := Fin.foldl params.halfNumFullRounds (fun st_acc rc_idx =>
    let rc_chunk := (rcs.extract rc_idx (rc_idx + params.width)).cast (by admit /- proof elided -/
    )
    let st_new := fullRound params st_acc rc_chunk
    st_new) st2

  st3

def Array.toFinVec {Œ± : Type _} (n : ‚Ñï) (arr : Array Œ±) (h : arr.size = n) : Fin n ‚Üí Œ± :=
  fun i => arr[i]

def StateRestoration (oSpec : OracleSpec Œπ)
    (StmtIn WitIn WitOut : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n) :=
  StmtIn ‚Üí 
  WitOut ‚Üí 
  pSpec.FullTranscript ‚Üí 
  QueryLog (oSpec ++‚Çí (srChallengeOracle StmtIn pSpec)) ‚Üí 
  QueryLog oSpec ‚Üí 
  OracleComp oSpec WitIn 

class MvPolynomialLike (œÉ : outParam (Type u)) (R : outParam (Type v)) [CommSemiring R]
    (P : Type w) [CommSemiring P] extends Algebra R P where
   
  X : œÉ ‚Üí P

   
  eval‚ÇÇ {S : Type y} [CommSemiring S] {F : Type z} [FunEquiv F œÉ S] (f : R ‚Üí+* S) (g : F) : P ‚Üí+* S

   
  eval‚ÇÇ_C {S : Type y} [CommSemiring S] {F : Type z} [FunEquiv F œÉ S]
    (f : R ‚Üí+* S) (g : F) (r : R) : (eval‚ÇÇ f g) (_root_.algebraMap R P r) = f r

   
  eval‚ÇÇ_X {S : Type y} [CommSemiring S] {F : Type z} [FunEquiv F œÉ S]
    (f : R ‚Üí+* S) (g : F) (s : œÉ) : (eval‚ÇÇ f g) (X s) = g s

   
  eval‚ÇÇ_eq {S : Type y} [CommSemiring S] {F : Type z} [FunEquiv F œÉ S] (h : P ‚Üí+* S) :
    h = eval‚ÇÇ (h.comp (Algebra.ofId R P)) (fun s => h (X s) : F)

instance : Unique (MessageIdx ‚ü®!v[.P_to_V], !v[Msg]‚ü©) where
  default := ‚ü®0, by admit /- proof elided -/
  ‚ü©
  uniq := fun i => by admit /- proof elided -/

def deriveTranscriptSR {Œπ : Type} {oSpec : OracleSpec Œπ} {StmtIn : Type}
    (stmt : StmtIn) (k : Fin (n + 1)) (messages : pSpec.MessagesUpTo k) :
    OracleComp (oSpec ++‚Çí fsChallengeOracle StmtIn pSpec) (pSpec.Transcript k) := do
  deriveTranscriptSRAux stmt k messages (Fin.last k)

alias deriveTranscriptFS := deriveTranscriptSR

instance [Inhabited C] [Permute C] : DuplexSpongeInterface U (DuplexSponge U C) where
  absorbUnchecked := fun (sponge, arr) => absorbUnchecked sponge arr
  squeezeUnchecked := fun (sponge, arr) => squeezeUnchecked sponge arr
  ratchetUnchecked := ratchetUnchecked

def drop (m : ‚Ñï) (h : m ‚â§ n) (pSpec : ProtocolSpec n) : ProtocolSpec (n - m) :=
  {dir := Fin.drop m h pSpec.dir, ¬´Type¬ª := Fin.drop m h pSpec.¬´Type¬ª}

PowerSeries.mk in Mathlib.RingTheory.PowerSeries.Basic

def OracleSpec.proverOracle (StmtIn : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n) :
    OracleSpec pSpec.MessageIdx :=
  fun i => (StmtIn √ó pSpec.Transcript i.val.castSucc, pSpec.Message i)

def divide_by_2 (s : Finset ‚Ñï) : Finset ‚Ñï :=
  (erase_odd s).image (fun n => n / 2)

def foldStepRelOutProp (i : Fin ‚Ñì)
    (input : (Statement (L := L) Context i.succ √ó
      (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j)) √ó
      Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ) : Prop :=
  let stmt := input.1.1
  let oStmt := input.1.2
  let wit := input.2
  masterKStateProp (mp := mp) (ùìë := ùìë) ùîΩq Œ≤
    (stmtIdx := i.succ) (oracleIdx := i.castSucc)
    (h_le := Nat.le_of_lt (Fin.castSucc_lt_succ i)) stmt wit oStmt (localChecks := True)

def neg_descending (p : UniPoly R) : QuotientUniPoly R :=
  Quotient.mk _ (neg p)

noncomputable def batchVerifier :
  OracleVerifier []‚Çí
    Unit (OracleStatement D x m)
    ((Fin m ‚Üí F) √ó Fri.Spec.Statement F (0 : Fin (k + 1)))
    (OracleStatement D x m)
    (batchSpec F m) where
  verify := fun _ chals => pure ‚ü®chals ‚ü®0, by admit /- proof elided -/
  ‚ü©, Fin.elim0‚ü©
  embed :=
    ‚ü®
      fun i => Sum.inl i,
      by admit /- proof elided -/
    ‚ü©
  hEq := by admit /- proof elided -/

instance (priority := high) : MonadLiftT (OracleComp []‚Çí) (OracleComp spec) where
  monadLift := OracleComp.construct pure (fun a => by admit /- proof elided -/
  ) failure

def sumCases {l : List ‚Ñï} {motive : Fin l.sum ‚Üí Sort*}
    (cases : ‚àÄ (n : ‚Ñï) (h : n ‚àà l) (i : Fin n), motive (castSum l h i))
    (i : Fin l.sum) : motive i := match l with
  | [] => by admit /- proof elided -/
  | n' :: l' => by admit /- proof elided -/

instance polyIrreducibleFact (n : ‚Ñï) : Fact (Irreducible (poly n)) := ‚ü®polyIrreducible n‚ü©

abbrev CoeffVecSpace (L : Type u) (‚Ñì : Nat) := Fin (2^‚Ñì) ‚Üí L

List.Vector.head in Mathlib.Data.Vector.Defs

def Œ± (x‚ÇÄ : F) (R : F[X][X][Y]) (H : F[X][Y]) [œÜ : Fact (Irreducible H)] (t : ‚Ñï) : ùïÉ H :=
  let W : ùïÉ H := liftToFunctionField (H.leadingCoeff)
  embeddingOfùí™IntoùïÉ _ (Œ≤ R t) / (W ^ (t + 1) * (embeddingOfùí™IntoùïÉ _ (Œæ x‚ÇÄ R H)) ^ (2*t - 1))

UInt64 in Init.Prelude

@[reducible, inline]
instance instPolynomialDegreeLE : OracleInterface (R‚¶É‚â§ d‚¶Ñ[X]) where
  Query := R
  Response := R
  answer := fun ‚ü®poly, _‚ü© point => poly.eval point

def simulateQ' (oa : OracleComp spec Œ±) (h : oa.neverFails) : m Œ± :=

instance (priority := low) : DCast‚ÇÇ Œ± Œ≤ Œ≥ where
  dcast‚ÇÇ ha hb c := by admit /- proof elided -/

def commit (srs : Vector G‚ÇÅ n) (coeffs : Fin n ‚Üí ZMod p) : G‚ÇÅ :=
  ‚àè i : Fin n, srs[i] ^ (coeffs i).val

instance [Zero T] [ToNat T] : LT (Cayley T) where
  lt := lt

Or.inr in Init.Prelude

@[reducible, simp] def StmtAfterCheckClaim : Type := R

class GenMutualCorrParams (P : Params Œπ F) (S : ‚àÄ i : Fin (M + 1), Finset (Œπ i)) where

  Œ¥ : Fin (M + 1) ‚Üí ‚Ñù‚â•0
  dist : (i : Fin (M + 1)) ‚Üí Fin ((P.foldingParam i) + 1) ‚Üí ‚Ñù‚â•0


  œÜ : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), (indexPowT (S i) (P.œÜ i) j) ‚Ü™ F

  inst1 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Fintype (indexPowT (S i) (P.œÜ i) j)
  inst2 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    Nonempty (indexPowT (S i) (P.œÜ i) j)
  inst3 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    DecidableEq (indexPowT (S i) (P.œÜ i) j)
  inst4 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Smooth (œÜ i j)

  par‚Ñì_type : ‚àÄ i : Fin (M + 1), ‚àÄ _ : Fin ((P.foldingParam i) + 1), Type
  inst5 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Fintype (par‚Ñì_type i j)

  exp : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), (par‚Ñì_type i j) ‚Ü™ ‚Ñï



  Gen_Œ± : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    ProximityGenerator (indexPowT (S i) (P.œÜ i) j) F :=
      fun i j => RSGenerator.genRSC (par‚Ñì_type i j) (œÜ i j) (P.varCount i - j) (exp i j)

  inst6 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Fintype (Gen_Œ± i j).par‚Ñì

  BStar : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    (Set ((indexPowT (S i) (P.œÜ i) j) ‚Üí F)) ‚Üí Type ‚Üí ‚Ñù‚â•0
  errStar : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    (Set ((indexPowT (S i) (P.œÜ i) j) ‚Üí F)) ‚Üí Type ‚Üí ‚Ñù ‚Üí ENNReal

  C : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Set ((indexPowT (S i) (P.œÜ i) j) ‚Üí F)
  hcode : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), (C i j) = (Gen_Œ± i j).C

  h : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    hasMutualCorrAgreement (Gen_Œ± i j)
      (BStar i j (C i j) (Gen_Œ± i j).par‚Ñì)
      (errStar i j (C i j) (Gen_Œ± i j).par‚Ñì)

  h‚Ñì_bound : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    Fintype.card (Gen_Œ± i j).par‚Ñì = 2
  h‚Ñì_bound' : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    Fintype.card (par‚Ñì_type i j) = 2

  hŒ¥Le : ‚àÄ i : Fin (M + 1),
    (Œ¥ i) ‚â§ 1 - Finset.univ.sup (fun j => BStar i j (C i j) (Gen_Œ± i j).par‚Ñì)

  hlistDecode : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    listDecodable (C i j) (Œ¥ i) (dist i j)

Nat.bit in Mathlib.Data.Nat.BinaryRec

structure StateFunction
    (langIn : Set StmtIn) (langOut : Set StmtOut)
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    where
  toFun : (m : Fin (n + 1)) ‚Üí StmtIn ‚Üí Transcript m pSpec ‚Üí Prop
   
  toFun_empty : ‚àÄ stmt, stmt ‚àà langIn ‚Üî toFun 0 stmt default
   
  toFun_next : ‚àÄ m, pSpec.dir m = .P_to_V ‚Üí
    ‚àÄ stmt tr, ¬¨ toFun m.castSucc stmt tr ‚Üí
    ‚àÄ msg, ¬¨ toFun m.succ stmt (tr.concat msg)
   
  toFun_full : ‚àÄ stmt tr, ¬¨ toFun (.last n) stmt tr ‚Üí
    [(¬∑ ‚àà langOut) | do (simulateQ impl (verifier.run stmt tr)).run' (‚Üê init)] = 0

noncomputable def relayOracleVerifier (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
  OracleVerifier
    (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) Context i.succ)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (pSpec := pSpecRelay) where
  verify := fun stmtIn _ => pure stmtIn
  embed := ‚ü®fun j => by admit /- proof elided -/
  ‚ü©
  hEq := fun oracleIdx => by admit /- proof elided -/

def vcons {n : ‚Ñï} (a : Œ±) (v : Fin n ‚Üí Œ±) : Fin (n + 1) ‚Üí Œ± :=
  dcons a v

instance [Inhabited OuterWitOut]
    [instKS : lens.IsKnowledgeSound
                outerRelIn innerRelIn
                outerRelOut innerRelOut
                compatStmt (fun _ _ => True)] :
    lens.stmt.IsSound
      outerRelIn.language outerRelOut.language
      innerRelIn.language innerRelOut.language
      compatStmt where
  proj_sound := fun outerStmtIn hCompat => by admit /- proof elided -/

Div in Init.Prelude

def map (f : R ‚Üí+* S) (p : MlPolyEval R n) : MlPolyEval S n :=
  Vector.map (fun a => f a) p

@[inline, specialize]
def prover : Prover oSpec Statement Witness (Statement √ó Witness) Unit (pSpec Witness) where
  PrvState
  | 0 => Statement √ó Witness
  | 1 => Statement √ó Witness
  input := id
  sendMessage | ‚ü®0, _‚ü© => fun ‚ü®stmt, wit‚ü© => pure (wit, ‚ü®stmt, wit‚ü©)
  receiveChallenge | ‚ü®0, h‚ü© => nomatch h
  output := fun ‚ü®stmt, wit‚ü© => pure (‚ü®stmt, wit‚ü©, ())

structure Params where
  
  width : Nat
  numFullRounds : Nat
  numPartialRounds : Nat
  internalDiagVectors : Vector KoalaBear.Field width
  roundConstants : Vector KoalaBear.Field (numFullRounds * width + numPartialRounds)

  

   
  [width_ne_zero : NeZero width]

   
  [numFullRounds_ne_zero : NeZero numFullRounds]

   
  [numPartialRounds_ne_zero : NeZero numPartialRounds]

   
  width_dvd_by_4 : 4 ‚à£ width
   
  numFullRounds_even : Even numFullRounds

Nat.cast in Init.Data.Cast

Module.Basis.span in Mathlib.LinearAlgebra.Basis.Basic

def AlgebraTowerEquiv.toAlgebraOverLeft (e : AlgebraTowerEquiv A B) (i j : Œπ)
    (h : i ‚â§ j) : Algebra (A i) (B j) :=

def binaryTowerModule {l r : ‚Ñï} (h_le : l ‚â§ r) :
    Module (ConcreteBTField l) (ConcreteBTField r) :=
  (ConcreteBTFieldAlgebra (h_le:=h_le)).toModule

MvPolynomial.degreeOf in Mathlib.Algebra.MvPolynomial.Degrees

noncomputable def normalizedW (i : Fin r) : L[X] :=
  C (1 / (W ùîΩq Œ≤ i).eval (Œ≤ i)) * W ùîΩq Œ≤ i

OracleComp.neverFails in VCVio.OracleComp.Traversal

@[reducible]
def pSpec (F : Type) [Semiring F] : ProtocolSpec 2 := ‚ü®!v[.V_to_P, .P_to_V], !v[F, Unit ‚Üí F[X]]‚ü©

@[reducible, inline, specialize, simp]
def srChallengeQueryImpl' {Statement : Type} {pSpec : ProtocolSpec n}
    [‚àÄ i, SelectableType (pSpec.Challenge i)] :
    QueryImpl (srChallengeOracle Statement pSpec)
      (StateT (srChallengeOracle Statement pSpec).FunctionType ProbComp)
    where
  impl | query i t => fun f => pure (f i t, f)

alias fsChallengeQueryImpl' := srChallengeQueryImpl'

noncomputable def towerRingHomBackwardMap (k : ‚Ñï) : BTField k ‚Üí ConcreteBTField k :=

def powerBasisSucc (k : ‚Ñï) :
    PowerBasis (BTField k) (BTField (k+1)) :=

def AlgebraTowerEquiv.algebraMapRightUp (e : AlgebraTowerEquiv A B) (i j : Œπ)
    (h : i ‚â§ j) : (A i) ‚Üí+* (B j) :=

def rawConstants16 : Vector KoalaBear.Field 148 := #v[
    2128964168,
    288780357,
    316938561,
    2126233899,
    426817493,
    1714118888,
    1045008582,
    1738510837,
    889721787,
    8866516,
    681576474,
    419059826,
    1596305521,
    1583176088,
    1584387047,
    1529751136,
    1863858111,
    1072044075,
    517831365,
    1464274176,
    1138001621,
    428001039,
    245709561,
    1641420379,
    1365482496,
    770454828,
    693167409,
    757905735,
    136670447,
    436275702,
    525466355,
    1559174242,
    1030087950,
    869864998,
    322787870,
    267688717,
    948964561,
    740478015,
    679816114,
    113662466,
    2066544572,
    1744924186,
    367094720,
    1380455578,
    1842483872,
    416711434,
    1342291586,
    1692058446,
    1493348999,
    1113949088,
    210900530,
    1071655077,
    610242121,
    1136339326,
    2020858841,
    1019840479,
    678147278,
    1678413261,
    1361743414,
    61132629,
    1209546658,
    64412292,
    1936878279,
    1980661727,
    1423960925,
    2101391318,
    1915532054,
    275400051,
    1168624859,
    1141248885,
    356546469,
    1165250474,
    1320543726,
    932505663,
    1204226364,
    1452576828,
    1774936729,
    926808140,
    1184948056,
    1186493834,
    843181003,
    185193011,
    452207447,
    510054082,
    1139268644,
    630873441,
    669538875,
    462500858,
    876500520,
    1214043330,
    383937013,
    375087302,
    636912601,
    307200505,
    390279673,
    1999916485,
    1518476730,
    1606686591,
    1410677749,
    1581191572,
    1004269969,
    143426723,
    1747283099,
    1016118214,
    1749423722,
    66331533,
    1177761275,
    1581069649,
    1851371119,
    852520128,
    1499632627,
    1820847538,
    150757557,
    884787840,
    619710451,
    1651711087,
    505263814,
    212076987,
    1482432120,
    1458130652,
    382871348,
    417404007,
    2066495280,
    1996518884,
    902934924,
    582892981,
    1337064375,
    1199354861,
    2102596038,
    1533193853,
    1436311464,
    2012303432,
    839997195,
    1225781098,
    2011967775,
    575084315,
    1309329169,
    786393545,
    995788880,
    1702925345,
    1444525226,
    908073383,
    1811535085,
    1531002367,
    1635653662,
    1585100155,
    867006515,
    879151050,
]

def pad (sz‚ÇÅ sz‚ÇÇ : Size)
    (stmt : Statement R sz‚ÇÅ)
    (matrices : MatrixIdx ‚Üí Matrix (Fin sz‚ÇÅ.m) (Fin sz‚ÇÅ.n) R)
    (wit : Witness R sz‚ÇÅ) :
    Statement R sz‚ÇÇ √ó (MatrixIdx ‚Üí Matrix (Fin sz‚ÇÇ.m) (Fin sz‚ÇÇ.n) R) √ó Witness R sz‚ÇÇ :=
  (Fin.rightpad sz‚ÇÇ.n_x 0 stmt,
    fun idx => Matrix.rightpad sz‚ÇÇ.m sz‚ÇÇ.n 0 (matrices idx),
    Fin.rightpad sz‚ÇÇ.n_w 0 wit)

def add_descending (p q : UniPoly R) : QuotientUniPoly R :=
  Quotient.mk _ (add p q)

Preorder in Mathlib.Order.Defs.PartialOrder

def concreteTowerAlgebraMap (l r : ‚Ñï) (h_le : l ‚â§ r) :
    ConcreteBTField l ‚Üí+* ConcreteBTField r :=

instance : ‚àÄ i, VCVCompatible ((pSpec Witness).Challenge i) | ‚ü®0, h‚ü© => nomatch h

structure InitialStatement where
  
  t_eval_point : Fin ‚Ñì ‚Üí L         
  original_claim : L               

class OracleInterfaces (pSpec : ProtocolSpec n) where
  oracleInterfaces : ‚àÄ i, Option (OracleInterface (pSpec.Message i))

List.ranges in Mathlib.Data.List.Range

gen in VCVio.CryptoFoundations.FiatShamir

Polynomial.modByMonic in Mathlib.Algebra.Polynomial.Div

@[reducible, simp] def WitOut := Unit

Finset.Nonempty in Mathlib.Data.Finset.Empty

instance : HasSucc (Cayley T) where
  succ' := succ

OracleSpec.QueryCache in VCVio.OracleComp.QueryTracking.Structures

MvPolynomial.eval‚ÇÇ in Mathlib.Algebra.MvPolynomial.Eval

Set.Ioc in Mathlib.Order.Interval.Set.Defs

abbrev MatrixSubmodule.{u, v, w} (Œ∫ : Type u) [Fintype Œ∫] (Œπ : Type v) [Fintype Œπ]
                                 (F : Type w) [Semiring F] : Type (max u v w) :=
  Submodule F (Matrix Œ∫ Œπ F)

instance {Œ± : Type u} : Slice (List Œ±) Nat Nat (fun _ _ _ => True) (fun _ _ _ _ => List Œ±) where
  slice xs start stop _ := xs.extract start stop

def combine
  (œÜ : Œπ ‚Ü™ F) (dstar : ‚Ñï) (r : F) (fs : Fin m ‚Üí Œπ ‚Üí F) (degs : Fin m ‚Üí ‚Ñï) (x : Œπ) : F :=
    ‚àë i, (ri dstar degs r i) * (fs i x) * (‚àë l ‚àà range (dstar - degs i + 1), ((œÜ x) * r)^l)

def getConst (F : Type) [NonBinaryField F] : OracleComp [(pSpec F).Message]‚Çí F[X] :=
  OracleComp.lift
    (by admit /- proof elided -/
    )

instance {i : OracleMessageIdx pSpec} : OracleInterface (pSpec.Message i) :=
  (inst.oracleInterfaces i).get i.2

CommRing.toRing in Mathlib.Algebra.Ring.Defs

@[simp]
instance BTFieldIsField (k : ‚Ñï) : Field (BTField k) := (BinaryTowerAux k).2.instField

RatFunc in Mathlib.FieldTheory.RatFunc.Defs

@[simp]
abbrev FirstSumcheckChallenge : Type := Fin pp.‚Ñì_m ‚Üí R

def weightConstraint
  (f : MvPolynomial (Fin m) F)
  (w : MvPolynomial (Fin (m + 1)) F) (œÉ : F) : Prop :=
    ‚àë b : Fin m ‚Üí Fin 2 , w.eval (toWeightAssignment f b) = œÉ

instance oCtxLens_complete :
    (oCtxLens R n deg D i).toContext.IsComplete
      (relationRound R n deg D i.castSucc) (Simple.inputRelation R deg D)
      (relationRound R n deg D i.succ) (Simple.outputRelation R deg)
      ((Simple.oracleReduction R deg D oSpec).toReduction.compatContext
        (oCtxLens R n deg D i).toContext)
where
  proj_complete := by admit /- proof elided -/

@[reducible, simp]
def toRelOut : Set ((Statement √ó Witness) √ó Unit) :=
  Prod.fst ‚Åª¬π' relIn

@[inline, reducible]
def lift : OuterStmtIn ‚Üí InnerStmtOut ‚Üí OuterStmtOut :=
  lens.toFunB

Subgroup in Mathlib.Algebra.Group.Subgroup.Defs

def rbrKnowledgeSoundness
    (relIn : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (verifier : OracleVerifier oSpec Statement OStatement Bool (fun _ : Empty => Unit) pSpec)
    (rbrKnowledgeError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) : Prop :=
  verifier.rbrKnowledgeSoundness init impl relIn acceptRejectOracleRel rbrKnowledgeError

@[inline] def le [Zero T] [ToNat T] (a b : Cayley T) : Prop :=
  (‚Üëa : Nat) ‚â§ (‚Üëb : Nat)

noncomputable def commitOracleVerifier (i : Fin ‚Ñì) (hCR : isCommitmentRound ‚Ñì œë i) :
  OracleVerifier
    (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) Context i.succ)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (O‚Çò := fun i => by admit /- proof elided -/
    )
    
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (pSpec := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) where

  
  
  verify := fun stmtIn pSpecChallenges => do
    pure stmtIn

  embed := ‚ü®fun j => by admit /- proof elided -/
  ‚ü©
  hEq := fun oracleIdx => by admit /- proof elided -/

def take (j : Fin (n + 1)) (challenges : Challenges pSpec) : ChallengesUpTo j pSpec :=

abbrev ùïÉ (H : F[X][Y]) : Type :=
  (Polynomial (RatFunc F)) ‚ß∏ (Ideal.span {H_tilde H})

Id.run in Init.Control.Id

@[reducible, inline, specialize]
def challenges (transcript : FullTranscript pSpec) (i : ChallengeIdx pSpec) :=
  transcript i.val

def Transcript.removeSalt {k : Fin (n + 1)} (transcript : (pSpec.addSalt Salt).Transcript k) :
    pSpec.Transcript k :=

  fun i => by admit /- proof elided -/

def starData {Œ±} (k : ‚Ñï) (root : Œ±) (leaves : Fin k ‚Üí Œ±) :
    ArityTree.Data Œ± (starSkel k) :=

instance instAlgebraTowerConcreteBTF : AlgebraTower (ConcreteBTField) where
  algebraMap := concreteTowerAlgebraMap
  commutes' := by admit /- proof elided -/

def D_Y (Q : F[Z][X][Y]) : ‚Ñï := Bivariate.natDegreeY Q

def mul_by_2 (s : Finset ‚Ñï) : Finset ‚Ñï :=
  s.map ‚ü®fun n => 2 * n, by admit /- proof elided -/
  ‚ü©

Nontrivial in Mathlib.Logic.Nontrivial.Defs

def allScriptsDocumented : IO Bool := do
  \n  \
      {String.intercalate "," undocumented.toList}"
  return undocumented.size == 0

def foldingBadEvent (i : Fin ‚Ñì) (steps : ‚Ñï) [NeZero steps] (h_i_add_steps : i + steps ‚â§ ‚Ñì)
  (f_i : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i, by admit /- proof elided -/
  ‚ü©)
  (challenges : Fin steps ‚Üí L) : Prop :=
  let d_i_plus_steps := BBF_CodeDistance ‚Ñì ùì° ‚ü®i + steps, by admit /- proof elided -/
  ‚ü©
  if h_is_close : 2 * fiberwiseDistance ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := i)
      steps h_i_add_steps f_i < (d_i_plus_steps : ‚Ñï‚àû) then
    
    
    
    let h_dist_curr_lt := fiberwise_dist_lt_imp_dist_lt_unique_decoding_radius ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := i) (steps := steps) h_i_add_steps f_i h_is_close

    let f_bar_i := uniqueClosestCodeword ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (i := ‚ü®i, by admit /- proof elided -/
      ‚ü©) (h_i := by admit /- proof elided -/
      ) f_i
      h_dist_curr_lt
    let folded_f_i := iterated_fold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (steps := ‚ü®steps, by admit /- proof elided -/
      ‚ü©) (i := ‚ü®i, by admit /- proof elided -/
      ‚ü©)
      (h_i_add_steps := by admit /- proof elided -/
      ) f_i challenges
    let folded_f_bar_i := iterated_fold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (steps := ‚ü®steps, by admit /- proof elided -/
      ‚ü©) (i := ‚ü®i, by admit /- proof elided -/
      ‚ü©)
      (h_i_add_steps := by admit /- proof elided -/
      ) f_bar_i challenges

    let fiberwise_disagreements := fiberwiseDisagreementSet ùîΩq Œ≤ i steps h_i_add_steps
      f_i f_bar_i
    let folded_disagreements := disagreementSet ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i steps
      h_i_add_steps folded_f_i folded_f_bar_i
    
    ¬¨ (fiberwise_disagreements ‚äÜ folded_disagreements)
  else
    
    
    
    let folded_f_i := iterated_fold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (steps := ‚ü®steps, by admit /- proof elided -/
      ‚ü©) (i := ‚ü®i, by admit /- proof elided -/
      ‚ü©)
      (h_i_add_steps := by admit /- proof elided -/
      ) f_i challenges
    let dist_to_code := distFromCode folded_f_i
      (BBF_Code ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i + steps, by admit /- proof elided -/
      ‚ü©)
    2 * dist_to_code < (d_i_plus_steps : ‚Ñï‚àû)

structure BacktrackSequence (trace : QueryLog (duplexSpongeChallengeOracle StmtIn U))
    (state : CanonicalSpongeState U) where
   
  stmt : StmtIn
   
  inputState : List (CanonicalSpongeState U)
   
  outputState : List (CanonicalSpongeState U)

   
  inputState_length_eq_outputState_length_succ : inputState.length = outputState.length + 1

   
  last_inputState_eq_state : inputState[inputState.length - 1] = state

   
  hash_in_trace : (stmt, (Vector.drop inputState[0] SpongeSize.R)) ‚àà trace.getQ (.inl ())

   
  permute_or_inv_in_trace : ‚àÄ i : Fin outputState.length,
    (inputState[i], outputState[i]) ‚àà trace.getQ (.inr .Fwd)
    ‚à® (outputState[i], inputState[i]) ‚àà trace.getQ (.inr .Bwd)

   
  capacitySegment_output_eq_input : ‚àÄ i : Fin outputState.length,
    outputState[i].capacitySegment = inputState[i.val + 1].capacitySegment

   
  capacitySegment_input_ne_output : ‚àÄ i : Fin outputState.length,
    inputState[i].capacitySegment ‚â† outputState[i].capacitySegment

instance {Œ± : Type u} : SliceLT (List Œ±) Nat (fun _ _ => True) (fun _ _ _ => List Œ±) where
  sliceLT xs stop _ := List.take stop xs

def powMod (a b m : ‚Ñï) : ‚Ñï := Id.run do
  let mut x := a
  let mut n := b
  let mut res := 1

  while n > 0 do
    if n % 2 == 1 then
      res := (x * res) % m
    x := (x * x) % m
    n := n / 2

  return res

List.mergeSort in Init.Data.List.Sort.Basic

def subNat (c : AssocNat) : Nat ‚Üí AssocNat
| 0            => c 
| Nat.succ k   => pred (subNat c k) 

@[inline, specialize]
def add {R : Type*} [Ring R] [BEq R] [LawfulBEq R] (p q : QuotientUniPoly R) : QuotientUniPoly R :=
  Quotient.lift‚ÇÇ add_descending add_descends p q

@[simp]
def oCtxLens (i : Fin n) : OracleContext.Lens
    (StatementRound R n i.castSucc) (StatementRound R n i.succ) (Simple.StmtIn R) (Simple.StmtOut R)
    (OracleStatement R n deg) (OracleStatement R n deg)
    (Simple.OStmtIn R deg) (Simple.OStmtOut R deg)
    Unit Unit Unit Unit where
  wit := Witness.Lens.trivial
  stmt := oStmtLens R n deg D i

instance instOfNat {n : ‚Ñï} : OfNat (CNat n) n := match n with
  | 0 => by admit /- proof elided -/
  | .succ n => by admit /- proof elided -/

def verifier (i : Fin n) : Verifier oSpec
    (StatementRound R n i.castSucc √ó (‚àÄ i, OracleStatement R n deg i))
    (StatementRound R n i.succ √ó (‚àÄ i, OracleStatement R n deg i)) (pSpec R deg) :=
  (Simple.verifier R deg D oSpec).liftContext (oStmtLens R n deg D i)

def squeeze (ds : DomainSeparator U H) (count : Nat) (label : String) : DomainSeparator U H :=
  
  
  
  
  { io := ds.io ++ SEP_BYTE ++ s!"S{count}" ++ label }

def liftConcreteBTField (k : ‚Ñï) (prevBTFResult : ConcreteBTFStepResult (k := k)) :
  Field (ConcreteBTField (k + 1)) :=

instance {Œ± : Fin 0 ‚Üí Sort u} : Unique ((i : Fin 0) ‚Üí Œ± i) where
  uniq := fun v => by admit /- proof elided -/

False.elim in Init.Prelude

Finset.filter in Mathlib.Data.Finset.Filter

Matrix.vandermonde in Mathlib.LinearAlgebra.Vandermonde

def redundantEntryDS (log : QueryLog (duplexSpongeChallengeOracle StmtIn U))
    (idx : Fin log.length) : Prop :=
  match log[idx] with
   
  | ‚ü®.inl _, ‚ü®stmt, state‚ü©‚ü© => ‚àÉ j' < idx, log[j'] = ‚ü®.inl _, ‚ü®stmt, state‚ü©‚ü©
   
  | ‚ü®.inr .Fwd, stateIn, stateOut‚ü© =>
    ‚àÉ j' < idx, log[j'] = ‚ü®.inr .Fwd, stateIn, stateOut‚ü© ‚à® log[j'] = ‚ü®.inr .Bwd, stateOut, stateIn‚ü©
  | ‚ü®.inr .Bwd, stateOut, stateIn‚ü© =>
    ‚àÉ j' < idx, log[j'] = ‚ü®.inr .Bwd, stateOut, stateIn‚ü© ‚à® log[j'] = ‚ü®.inr .Fwd, stateIn, stateOut‚ü©

@[reducible]
def MemoryRead (Œπ : Type u) (Œ± : Œπ ‚Üí Type v) := (index : Œπ) √ó (Œ± index)

@[reducible]
def GroupEqOracle : OracleSpec Unit := fun _ => (Œπ √ó Œπ, Bool)

def toFinMatrix {m n : ‚Ñï} (matrix : Matrix Œ± m n) : _root_.Matrix (Fin m) (Fin n) Œ± :=
  fun i j => (matrix.get i).get j

Polynomial.algEquivOfCompEqX in Mathlib.Algebra.Polynomial.AlgebraMap

noncomputable def modBivar (P P' : MvPolynomial (Fin 2) F)
    (hlg : IsUnit ((MonomialOrder.lex).leadingCoeff P')) : MvPolynomial (Fin 2) F :=
      
      let ord : MonomialOrder (Fin 2) := MonomialOrder.lex
      
      let b : Unit ‚Üí MvPolynomial (Fin 2) F := fun _ => P'
      
      have hb : ‚àÄ i : Unit, IsUnit (ord.leadingCoeff (b i)) := by admit /- proof elided -/

instance (priority := 1000) algebra_adjacent_tower (l : ‚Ñï) :
  Algebra (ConcreteBTField l) (ConcreteBTField (l + 1)) :=

def Œ≤ (R : F[X][X][Y]) (t : ‚Ñï) : ùí™ H :=
  (Œ≤_regular R H (Nat.le_refl _) t).choose

instance instFieldConcrete {k : ‚Ñï} : Field (ConcreteBTField k) :=
  mkFieldInstance (getBTFResult k).toConcreteBTFieldProps

inductive Lit where
  | scalar (val : F)
  
  
  | vector (len : Nat) (v : Fin len ‚Üí F)

def MyTypeVec : Fin 3 ‚Üí Type := !v[‚Ñï, Bool, String]

example : !d‚ü®MyTypeVec‚ü©[(1 : ‚Ñï), true, "hello"] =
  (!h[1, true, "hello"] : (i : Fin 3) ‚Üí MyTypeVec i) := rfl


example : !d‚ü®!v[]‚ü©[] = (Fin.dempty : (i : Fin 0) ‚Üí !v[] i) := rfl


example : !d‚ü® !v[‚Ñï, Bool, String] ‚ü©[(1 : ‚Ñï), (true : Bool), ("hello" : String)] =
  Fin.dcons (1 : ‚Ñï) (Fin.dcons true (Fin.dcons "hello" Fin.dempty)) := rfl


example : let motive : Fin 2 ‚Üí Type := fun i => if i = 0 then ‚Ñï else Bool
          !d‚ü®motive‚ü©[(1 : ‚Ñï), (true : Bool)] =
          (Fin.dcons (1 : ‚Ñï) (Fin.dcons (true : Bool) Fin.dempty) : (i : Fin 2) ‚Üí motive i) := rfl

instance [h : ProverLast pSpec] : ProverFirst pSpec where
  prover_first' := by admit /- proof elided -/

class HListRepr (Œ± : Type _) where
  repr: Œ± ‚Üí Std.Format

noncomputable instance {R : Type u} [CommSemiring R] : PolynomialLike R R[X] where
  X := Polynomial.X
  eval‚ÇÇ := Polynomial.eval‚ÇÇRingHom
  eval‚ÇÇ_C := Polynomial.eval‚ÇÇ_C
  eval‚ÇÇ_X := Polynomial.eval‚ÇÇ_X
  eval‚ÇÇ_eq f := by admit /- proof elided -/

structure PrattCertificate (p : ‚Ñï) : Type where
  a : ZMod p
  pow_eq_one : a ^ (p - 1) = 1
  part : PrattPart p a (p - 1)

OptionT.mk in Init.Control.Option

Algebra in Mathlib.Algebra.Algebra.Defs

@[inline, reducible]
def toContext :
    Context.Lens (OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i)) (OuterStmtOut √ó (‚àÄ i, OuterOStmtOut i))
                (InnerStmtIn √ó (‚àÄ i, InnerOStmtIn i)) (InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i))
                OuterWitIn OuterWitOut InnerWitIn InnerWitOut :=
  ‚ü®lens.stmt, lens.wit‚ü©

@[inline]
def add [Add R] (p q : MlPolyEval R n) : MlPolyEval R n := Vector.zipWith (¬∑ + ¬∑) p q

Matrix in Mathlib.LinearAlgebra.Matrix.Defs

@[reducible]
def batchSpec (F : Type) (m : ‚Ñï) : ProtocolSpec 1 := ‚ü®!v[.V_to_P], !v[Fin m ‚Üí F]‚ü©

instance {n : ‚Ñï} {Œ± : Fin n ‚Üí Type*} : SliceGE ((i : Fin n) ‚Üí Œ± i) ‚Ñï
    (fun _ start => start ‚â§ n)
    (fun _ start h =>
      (i : Fin (n - start)) ‚Üí Œ± (Fin.cast (Nat.sub_add_cancel h) (i.addNat start)))
    where
  sliceGE := fun v start h => drop start h v

Prod.snd in Init.Prelude

def ratchet (sponge : DuplexSponge U C) :
    OracleComp (forwardPermutationOracle C) (DuplexSponge U C) := do
  let permutedState : C ‚Üê query (spec := forwardPermutationOracle C) () sponge.state
  
  let vecState : Vector U SpongeSize.N := SpongeState.get permutedState
  
  let zeroed : Vector U SpongeSize.N :=
    Vector.ofFn (fun i => if i < SpongeSize.R then 0 else vecState[i])
  
  let newVecState := SpongeState.update permutedState zeroed
  
  return { sponge with
    state := newVecState,
    squeezePos := Fin.last SpongeSize.R }

inferInstanceAs in Init.Prelude

@[inline, specialize, simp]
def oracleReduction : OracleReduction oSpec
    Statement OStatement Witness Statement OStatement Witness !p[] := OracleReduction.id

EDist in Mathlib.Topology.EMetricSpace.Defs

instance : ‚àÄ i, SelectableType ((pSpecSumcheckFold ùîΩq Œ≤ (œë:=œë)
  (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).Challenge i) := instSelectableTypeChallengeAppend

@[inline] def succ (n : AssocNat) : AssocNat :=
  add n one

EmbeddingLike in Mathlib.Data.FunLike.Embedding

List.foldl in Init.Prelude

abbrev Bwd : PermuteDir := Sum.inr ()

BitVec.cast in Init.Data.BitVec.Basic

Function.Injective2 in Mathlib.Logic.Function.Basic

List.dropLast in Init.Data.List.Basic

instance [NeZero k] {f : Fin k ‚Üí Œπ ‚Üí F} : Nonempty (Finset.univ.image f) :=

instance {k : Fin 1} : Unique (MessagesUpTo k (default : ProtocolSpec 0)) where
  default := fun i => ()
  uniq := by admit /- proof elided -/

instance polyIrreducible (n : ‚Ñï) : Irreducible (poly n) := (BinaryTowerAux n).2.instIrreduciblePoly

@[reducible]
def spec : OracleSpec Unit := fun _ => (Œ± √ó Œ±, Œ±)

Fin.foldl in Init.Data.Fin.Fold

def OracleReduction.toReduction {Œπ : Type} {oSpec : OracleSpec Œπ}
    {StmtIn : Type} {Œπ‚Çõ·µ¢ : Type} {OStmtIn : Œπ‚Çõ·µ¢ ‚Üí Type} {WitIn : Type}
    {StmtOut : Type} {Œπ‚Çõ‚Çí : Type} {OStmtOut : Œπ‚Çõ‚Çí ‚Üí Type} {WitOut : Type}
    {n : ‚Ñï} {pSpec : ProtocolSpec n}
    [O‚Çõ·µ¢ : ‚àÄ i, OracleInterface (OStmtIn i)] [O‚Çò : ‚àÄ i, OracleInterface (pSpec.Message i)]
    (oracleReduction : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec) :
      Reduction oSpec (StmtIn √ó (‚àÄ i, OStmtIn i)) WitIn
        (StmtOut √ó (‚àÄ i, OStmtOut i)) WitOut pSpec :=
  ‚ü®oracleReduction.prover, oracleReduction.verifier.toVerifier‚ü©

Nat.reduceAdd in Lean.Meta.Tactic.Simp.BuiltinSimprocs.Nat

UInt16.ofFin in Init.Data.UInt.Basic

def deriveTranscriptSRAux {Œπ : Type} {oSpec : OracleSpec Œπ} {StmtIn : Type}
    (stmt : StmtIn) (k : Fin (n + 1)) (messages : pSpec.MessagesUpTo k)
    (j : Fin (k + 1)) :
    OracleComp (oSpec ++‚Çí fsChallengeOracle StmtIn pSpec)
      (pSpec.Transcript (j.castLE (by admit /- proof elided -/
      ))) := do
  Fin.induction (n := k)
    (pure (fun i => i.elim0))
    (fun i ih => do
      let prevTranscript ‚Üê ih
      match hDir : pSpec.dir (i.castLE (by admit /- proof elided -/
      )) with
      | .V_to_P =>
        let challenge : pSpec.Challenge ‚ü®i.castLE (by admit /- proof elided -/
        ), hDir‚ü© ‚Üê
          query (spec := fsChallengeOracle _ _) ‚ü®i.castLE (by admit /- proof elided -/
          ), hDir‚ü©
            (stmt, messages.take i.castSucc)
        return prevTranscript.concat challenge
      | .P_to_V => return prevTranscript.concat (messages ‚ü®i, hDir‚ü©))
    j

Setoid in Init.Core

def inputRelation [DecidableEq F] (Œ¥ : ‚Ñù‚â•0) :
    Set
      (
        Unit √ó (‚àÄ j, OracleStatement D x m j) √ó (Witness F s d m)
      ) := sorry

protected def OracleReduction.id :
    OracleReduction oSpec Statement OStatement Witness Statement OStatement Witness !p[] :=
  ‚ü®OracleProver.id, OracleVerifier.id‚ü©

alias Prover.trivial := Prover.id
alias Verifier.trivial := Verifier.id
alias Reduction.trivial := Reduction.id
alias OracleProver.trivial := OracleProver.id
alias OracleVerifier.trivial := OracleVerifier.id
alias OracleReduction.trivial := OracleReduction.id

instance : HListString (HList []) where
  toString
  | HList.nil => ""

@[elab_as_elim]
def dconcat {n : ‚Ñï} {motive : Fin (n + 1) ‚Üí Sort u}
    (u : (i : Fin n) ‚Üí motive i.castSucc) (a : motive (last n)) (i : Fin (n + 1)) : motive i :=
  match n with
  | 0 => match i with | 0 => a
  | _ + 1 => dcons (u 0) (dconcat (fun i => u (Fin.succ i)) a) i

Vector.replicate in Init.Data.Vector.Basic

def leftpad (m‚ÇÇ n‚ÇÇ : ‚Ñï) (a : Œ±) {m‚ÇÅ n‚ÇÅ : ‚Ñï} (M : Matrix (Fin m‚ÇÅ) (Fin n‚ÇÅ) Œ±) :
    Matrix (Fin m‚ÇÇ) (Fin n‚ÇÇ) Œ± :=
  Fin.leftpad m‚ÇÇ (fun _ => a) (Fin.leftpad n‚ÇÇ a ‚àò M)

instance {Œ± : Type} [Sampleable Œ±] : DecidableEq Œ± := inferInstance

def lastBlockOracleVerifier :=
  let bIdx := ‚Ñì / œë - 1
  let stmt : Fin (œë + 1) ‚Üí Type := fun i => Statement (L := L) (‚Ñì:=‚Ñì) Context
    ‚ü®bIdx * œë + i, by admit /- proof elided -/
    ‚ü©
  let oStmt := fun i: Fin (œë + 1) => OracleStatement ùîΩq Œ≤ œë
    ‚ü®bIdx * œë + i, by admit /- proof elided -/
    ‚ü©
  let V:  OracleVerifier []‚Çí (StmtIn := Statement (L := L) (‚Ñì := ‚Ñì) Context
      ‚ü®bIdx * œë, by admit /- proof elided -/
      ‚ü©)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë
      ‚ü®bIdx * œë, by admit /- proof elided -/
      ‚ü©)
    (StmtOut := Statement (L := L) (‚Ñì := ‚Ñì) Context (Fin.last ‚Ñì))
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (pSpec := pSpecLastBlock (L:=L) (œë:=œë)) := by admit /- proof elided -/

def LeafData.leftSubtree {Œ± : Type} {s_left s_right : Skeleton}
    (tree : LeafData Œ± (Skeleton.internal s_left s_right)) :
    LeafData Œ± s_left :=
  match tree with
  | LeafData.internal left _right =>
    left

@[reducible]
def C : R ‚Üí+* P := algebraMap R P

instance (k : ‚Ñï) : NeZero (2^k) :=

def InternalData.get {s} {Œ± : Type}
    (tree : InternalData Œ± s) (idx : SkeletonInternalIndex s) : Œ± :=
  match tree, idx with
  | InternalData.internal value _ _, SkeletonInternalIndex.ofInternal => value
  | InternalData.internal _ left _, SkeletonInternalIndex.ofLeft idxLeft =>
    InternalData.get left idxLeft
  | InternalData.internal _ _ right, SkeletonInternalIndex.ofRight idxRight =>
    InternalData.get right idxRight

Sum.inr in Init.Core

@[simp]
instance AlgebraTower.toIsScalarTower (a : AlgebraTower C) {i j k : Œπ}
    (h1 : i ‚â§ j) (h2 : j ‚â§ k) :
    letI : Algebra (C i) (C j) :=

class DeserializeOption (Œ± : Type u) (Œ≤ : Type v) where
  deserialize : Œ≤ ‚Üí Option Œ±

noncomputable def polyQuotient (S : Finset F) (fPoly : F[X]) : F[X] :=
    (fPoly - (ansPoly S (fun s => fPoly.eval s))) / (vanishingPoly S)

ByteArray.mk in Init.Prelude

def choose_2 (x : ‚Ñö) : ‚Ñö := x * (x-1)/2

instance {U : Type} {H : Type*} {R : Type*} [SpongeUnit U] [DuplexSpongeInterface U H] :
    UnitTranscript (FSProverState U H R) U where
  publicUnits state input := do
    
    
    let newState ‚Üê state.addUnits input
    .ok { rng := newState.rng, hashState := newState.hashState,
          nargString := state.nargString } 
  fillChallengeUnits state count :=
    match state.hashState.squeeze count with
    | .ok (newHashState, output) =>
      .ok ({ rng := state.rng, hashState := newHashState, nargString := state.nargString }, output)
    | .error e => .error e

def witnessStructuralInvariant {i : Fin (‚Ñì + 1)} (stmt : Statement (L := L) Context i)
    (wit : Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i): Prop :=
  wit.H = projectToMidSumcheckPoly ‚Ñì wit.t (m:=mp.multpoly stmt.ctx) i stmt.challenges ‚àß
  wit.f = getMidCodewords ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) wit.t stmt.challenges

def whirRelation
    {F : Type} [Field F] [Fintype F] [DecidableEq F]
    {Œπ : Type} [Fintype Œπ] [Nonempty Œπ]
    (varCount : ‚Ñï) (œÜ : Œπ ‚Ü™ F) [Smooth œÜ] (err : ‚Ñù)
    : Set ((Unit √ó ‚àÄ i, (OracleStatement Œπ F i)) √ó Unit) :=
  { ‚ü®‚ü®_, oracle‚ü©, _‚ü© | Œ¥·µ£(oracle (), smoothCode œÜ varCount) ‚â§ err }

@[simp]
instance Nontrivial (k : ‚Ñï) : Nontrivial (BTField k) := inferInstance

BitVec.ofNat in Init.Prelude

inline in Init.Core

def perfectCorrectness (scheme : Scheme oSpec Data Randomness Commitment pSpec) : Prop :=
  correctness scheme 0

def finIdxOfIfTrue [BEq Œ±] [LawfulBEq Œ±] (a : Œ±) (l : List Œ±) (h : a ‚àà l) : Fin l.length :=
  ‚ü®List.idxOf' a l, by admit /- proof elided -/
  ‚ü©

Id in Init.Control.Id

def sumPartial (m : ‚Ñï) (n : ‚Ñï) (D : Fin n ‚Üí Finset R) :
    MvPolynomial (Fin (m + n)) R ‚Üí‚Çó[R] MvPolynomial (Fin m) R where
  toFun := fun p => ‚àë x ‚àà Fintype.piFinset D, peval (Fin.sumCommEquiv m n) x p
  map_add' := fun p q => by admit /- proof elided -/

instance [Repr Œ±] (Œ±s : List Type) [HListRepr (HList Œ±s)] : HListRepr (HList (Œ± :: Œ±s)) where
  repr
  | HList.cons x xs =>
    match xs with
    | HList.nil => reprPrec x 0
    | HList.cons _ _ => reprPrec x 0 ++ ", " ++ HListRepr.repr xs

def soundness
    (langIn : Set (StmtIn √ó ‚àÄ i, OStmtIn i))
    (langOut : Set (StmtOut √ó ‚àÄ i, OStmtOut i))
    (verifier : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec)
    (soundnessError : ‚Ñù‚â•0) : Prop :=
  verifier.toVerifier.soundness init impl langIn langOut soundnessError

def somePairs : HList' (fun x => x √ó x) someTypes :=
  HList'.cons (1, 1) (HList'.cons ("good", "bad") (HList'.cons (5, 3) HList'.nil))

Fin.castLT in Init.Data.Fin.Basic

Algebra.TensorProduct.leftAlgebra in Mathlib.RingTheory.TensorProduct.Basic

propext in Init.Core

noncomputable def foldf (S : Finset Œπ) (œÜ : Œπ ‚Ü™ F)
  {k : ‚Ñï} [Neg (indexPowT S œÜ k)] (y : indexPowT S œÜ (k + 1))
  (f : indexPowT S œÜ k ‚Üí F) (Œ± : F) : F :=
  let xPow := extract_x S œÜ k y
  let fx := f xPow
  let f_negx := f (-xPow)
  (fx + f_negx) / 2 + Œ± * ((fx - f_negx) / (2 * (xPow.val : F)))

@[simp]
abbrev Statement.AfterFirstSumcheck : Type :=
  FirstSumcheckChallenge R pp √ó Statement.AfterFirstChallenge R pp

instance : Unique (FullTranscript (default : ProtocolSpec 0)) := inferInstance

structure Opening where
  opening : Proof oSpec (Commitment √ó O.Query √ó O.Response) (Data √ó Randomness) pSpec

def Permute.ofEquiv (Œ± : Type*) (e : Equiv Œ± Œ±) : Permute Œ± where
  permute := e.toFun

@[reducible]
def SimOracle.Stateful (spec : OracleSpec Œπ) (spec‚Çú : OracleSpec Œπ‚Çú) (œÉ : Type) :=
  QueryImpl spec (StateT œÉ (OracleComp spec‚Çú))

def Oracle.containsCache {Œπ : Type} {spec : OracleSpec Œπ}
    (f : spec.FunctionType) (cache : spec.QueryCache) :
    Prop :=
  ‚àÄ i q r, cache i q = some r ‚Üí f i q = r

Or.inl in Init.Prelude

Nat.div2 in Mathlib.Data.Nat.Bits

def erase_even (s : Finset ‚Ñï) : Finset ‚Ñï := s.filter Odd

@[inline] def lt [Zero T] [ToNat T] (a b : Cayley T) : Prop :=
  (‚Üëa : Nat) < (‚Üëb : Nat)

@[reducible, inline, specialize, simp]
def Challenge (pSpec : ProtocolSpec n) (i : ChallengeIdx pSpec) := pSpec.¬´Type¬ª i.val

instance : SMul ‚Ñï (UniPoly R) := ‚ü®nsmul‚ü©

instance : Sub (UniPoly R) := ‚ü®UniPoly.sub‚ü©

def linearCodeDist' {F} {Œπ} [Fintype Œπ] [Semiring F] [DecidableEq F] [Fintype F] [DecidableEq Œπ]
 (LC : LinearCode Œπ F) [DecidablePred (¬∑ ‚àà LC)] : ‚Ñï‚àû :=
  Finset.min <| ((Finset.univ (Œ± := LC)).filter (fun v => v ‚â† 0)).image (fun v => hammingNorm v.1)

def Straightline.append (E‚ÇÅ : Extractor.Straightline oSpec Stmt‚ÇÅ Wit‚ÇÅ Wit‚ÇÇ pSpec‚ÇÅ)
    (E‚ÇÇ : Extractor.Straightline oSpec Stmt‚ÇÇ Wit‚ÇÇ Wit‚ÇÉ pSpec‚ÇÇ)
    (V‚ÇÅ : Verifier oSpec Stmt‚ÇÅ Stmt‚ÇÇ pSpec‚ÇÅ) :
      Extractor.Straightline oSpec Stmt‚ÇÅ Wit‚ÇÅ Wit‚ÇÉ (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ) :=
  fun stmt‚ÇÅ wit‚ÇÉ transcript proveQueryLog verifyQueryLog => do
    let stmt‚ÇÇ ‚Üê V‚ÇÅ.verify stmt‚ÇÅ transcript.fst
    let wit‚ÇÇ ‚Üê E‚ÇÇ stmt‚ÇÇ wit‚ÇÉ transcript.snd proveQueryLog verifyQueryLog
    let wit‚ÇÅ ‚Üê E‚ÇÅ stmt‚ÇÅ wit‚ÇÇ transcript.fst proveQueryLog verifyQueryLog
    return wit‚ÇÅ

@[reducible]
def pSpecRelay : ProtocolSpec 0 := ‚ü®![], ![]‚ü© 

MonadLift in Init.Prelude

def weight_Œõ (f H : F[X][Y]) (D : ‚Ñï) : WithBot ‚Ñï :=
  Finset.sup
    f.support
    (fun deg =>
      WithBot.some <| deg * (D + 1 - Bivariate.natDegreeY H) + (f.coeff deg).natDegree
    )

RingHom.comp in Mathlib.Algebra.Ring.Hom.Defs

OracleComp.uniformOfFintype in VCVio.OracleComp.Constructions.UniformSelect

@[reducible]
def OracleStatement : Unit ‚Üí Type := fun _ => R‚¶É‚â§ deg‚¶Ñ[X Fin n]

Function.onFun in Mathlib.Logic.Function.Defs

@[inline, reducible]
def proj : (OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i)) √ó OuterWitIn ‚Üí
    (InnerStmtIn √ó (‚àÄ i, InnerOStmtIn i)) √ó InnerWitIn :=
  fun ctxIn => ‚ü®lens.stmt.proj ctxIn.1, lens.wit.proj ctxIn‚ü©

def OuterStmtOut_Test := ‚Ñ§[X] √ó ‚Ñ§[X] √ó ‚Ñ§ √ó ‚Ñ§

@[simp]
abbrev Witness.AfterSendEvalClaim : Type := Unit

def extractNextSuffixFromChallenge (v : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®0, by omega‚ü©)
    (i : ‚Ñï) (h_i_add_œë_le_‚Ñì : i + œë ‚â§ ‚Ñì) :
    (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®i + œë, by omega‚ü© :=

def BerlekampWelchMatrix
  (e k : ‚Ñï)
  (œâs f : Fin n ‚Üí F) : Matrix (Fin n) (Fin (2 * e + k)) F :=
  Matrix.of fun i j =>
    let Œ±·µ¢ := œâs i
    if ‚Üëj < e then -Rhs j.1 œâs f i else -Œ±·µ¢^(j - e)

Finsupp in Mathlib.Data.Finsupp.Defs

def outputRelation : Set ((StmtOut R √ó (‚àÄ i, OStmtOut R deg i)) √ó Unit) :=
  { ‚ü®‚ü®‚ü®newTarget, chal‚ü©, oStmt‚ü©, _‚ü© | (oStmt ()).1.eval chal = newTarget }

@[inline, specialize, simp]
def oracleVerifier : OracleVerifier oSpec Statement OStatement Statement OStatement !p[] :=
  OracleVerifier.id

def aeval {A : Type y} [CommSemiring A] [Algebra R A] {F : Type z} [FunEquiv F œÉ A] (g : F) :
    P ‚Üí‚Çê[R] A :=
  eval‚ÇÇAlgHom (Algebra.ofId R A) g

@[reducible]
def value (op : MemoryWrite Œπ Œ±) := op.2

@[simp]
def ùïè (k : ‚Ñï) : BTField (k+1) := Z (k+1)

def toMessagesChallenges (transcript : Transcript k pSpec) :
    MessagesUpTo k pSpec √ó ChallengesUpTo k pSpec :=
  (transcript.toMessagesUpTo, transcript.toChallengesUpTo)

def ofMvPolynomialDeg1 (p : R‚¶É‚â§ 1‚¶Ñ[X Fin n]) : MlPoly R n :=
  Vector.ofFn (fun i : Fin (2 ^ n) => p.val.coeff (monomialOfNat i))

noncomputable def œÄ_z {H : F[X][Y]} (z : F) (root : rationalRoot (H_tilde' H) z) : ùí™ H ‚Üí+* F :=
  Ideal.Quotient.lift (Ideal.span {H_tilde' H}) (œÄ_z_lift z root) sorry

@[reducible]
def mk {R : Type*} (coeffs : Array R) : UniPoly R := coeffs

Quotient.mk in Init.Core

def dropLastWhile (p : Œ± ‚Üí Bool) (l : List Œ±) : List Œ± :=
  (l.reverse.dropWhile p).reverse

HMul.hMul in Init.Prelude

def BBF_SumcheckMultiplierParam : SumcheckMultiplierParam L ‚Ñì (SumcheckBaseContext L ‚Ñì) :=
  { multpoly := fun ctx => BBF_eq_multiplier ctx.t_eval_point }

HMod in Init.Prelude

@[reducible]
def FinalStatement (F : Type) (k : ‚Ñï) : Type := Fin (k + 1) ‚Üí F

class SpongeSize where
   
  N : Nat
   
  R : Nat
   
  R_lt_N : R < N := by admit /- proof elided -/

class Statement.Lens.IsSound {OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut : Type}
    (outerLangIn : Set OuterStmtIn) (outerLangOut : Set OuterStmtOut)
    (innerLangIn : Set InnerStmtIn) (innerLangOut : Set InnerStmtOut)
    (compatStmt : OuterStmtIn ‚Üí InnerStmtOut ‚Üí Prop)
    (lens : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut) where

  proj_sound : ‚àÄ outerStmtIn,
    outerStmtIn ‚àâ outerLangIn ‚Üí lens.proj outerStmtIn ‚àâ innerLangIn

  lift_sound : ‚àÄ outerStmtIn innerStmtOut,
    compatStmt outerStmtIn innerStmtOut ‚Üí
    innerStmtOut ‚àâ innerLangOut ‚Üí
    lens.lift outerStmtIn innerStmtOut ‚àâ outerLangOut

class IsRBRSound (langIn : Set StmtIn) (langOut : Set StmtOut)
    (verifier : Verifier oSpec StmtIn StmtOut pSpec) where
  rbrSoundnessError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0
  is_rbr_sound : rbrSoundness init impl langIn langOut verifier rbrSoundnessError

class HasPred (T : Type u) where
   
  pred' : T ‚Üí T

def split {k : ‚Ñï} (h : k > 0) (x : ConcreteBTField k) :
    ConcreteBTField (k - 1) √ó ConcreteBTField (k - 1) :=
  let lo_bits : BitVec (2 ^ (k - 1) - 1 - 0 + 1) :=
    BitVec.extractLsb (hi := 2 ^ (k - 1) - 1) (lo := 0) x
  let hi_bits : BitVec (2 ^ k - 1 - 2 ^ (k - 1) + 1) :=
    BitVec.extractLsb (hi := 2 ^ k - 1) (lo := 2 ^ (k - 1)) x
  have h_lo : 2 ^ (k - 1) - 1 - 0 + 1 = 2 ^ (k - 1) := by admit /- proof elided -/

def OracleReduction.append (R‚ÇÅ : OracleReduction oSpec Stmt‚ÇÅ OStmt‚ÇÅ Wit‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ Wit‚ÇÇ pSpec‚ÇÅ)
    (R‚ÇÇ : OracleReduction oSpec Stmt‚ÇÇ OStmt‚ÇÇ Wit‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ Wit‚ÇÉ pSpec‚ÇÇ) :
      OracleReduction oSpec Stmt‚ÇÅ OStmt‚ÇÅ Wit‚ÇÅ Stmt‚ÇÉ OStmt‚ÇÉ Wit‚ÇÉ (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ) where
  prover := Prover.append R‚ÇÅ.prover R‚ÇÇ.prover
  verifier := OracleVerifier.append R‚ÇÅ.verifier R‚ÇÇ.verifier

instance Vector.instFintype {Œ± : Type*} {n : ‚Ñï} [VCVCompatible Œ±] : Fintype (Vector Œ± n) :=
  Fintype.ofEquiv _ (Equiv.rootVectorEquivFin).symm

def outputRelation (cond : ‚àë i, (s i).1 ‚â§ n) [DecidableEq F] (Œ¥ : ‚Ñù‚â•0) :
    Set
      (
        (FinalStatement F k √ó ‚àÄ j, FinalOracleStatement D x s j) √ó
        Witness F s d (Fin.last (k + 1))
      ) := sorry

def oracleVerifier : OracleVerifier oSpec (StmtIn R) (OStmtIn R deg) (StmtOut R) (OStmtOut R deg)
    (pSpec R deg) where
  verify := fun target chal => do
    let evals : Vector R m ‚Üê (Vector.finRange m).mapM
      (fun i => query (spec := [OStmtIn R deg]‚Çí) () (D i))
    guard (evals.sum = target)
    
    pure (sorry, chal default)
  embed := .inl
  hEq := fun i => by admit /- proof elided -/

def towerAlgebraMap (l r : ‚Ñï) (h_le : l ‚â§ r) : BTField l ‚Üí+* BTField r :=

@[reducible]
def fullPSpec := (pSpecCoreInteraction ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)) ++‚Çö
    (pSpecQuery ùîΩq Œ≤ Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))

def possibleDists (C : Set (Œπ ‚Üí F)) (Œ¥f : (Œπ ‚Üí F) ‚Üí (Œπ ‚Üí F) ‚Üí Œ±) : Set Œ± :=
  {d : Œ± | ‚àÉ p ‚àà Set.offDiag C, Œ¥f p.1 p.2 = d}

inductive FullData (Œ± : Type) : Skeleton ‚Üí Type
  | leaf (value : Œ±) : FullData Œ± Skeleton.leaf
  | internal {left right} (value : Œ±)
      (leftData : FullData Œ± left)
      (rightData : FullData Œ± right) :
      FullData Œ± (Skeleton.internal left right)
  deriving Repr

def oracleProver : OracleProver oSpec
    Statement OStatement Unit
    Unit (OStatement ‚äï·µ• OStatement) Unit
    (pSpec OStatement) where
  PrvState := fun _ => OStatement default

  input := fun ‚ü®‚ü®_, oStmt‚ü©, _‚ü© => oStmt default

  sendMessage | ‚ü®0, _‚ü© => fun st => pure (st, st)

  receiveChallenge | ‚ü®0, h‚ü© => nomatch h

  output := fun st => pure
    (‚ü®(), fun x => match x with
      | .inl _ => by admit /- proof elided -/
      ‚ü©,
     ())

def isCommitmentRound (i : Fin ‚Ñì) : Prop :=
  œë ‚à£ i.val + 1 ‚àß i.val + 1 ‚â† ‚Ñì

instance {s} : LawfulFunctor (fun Œ± => InternalData Œ± s) :=

@[reducible, inline]
instance instPolynomialDegreeLT : OracleInterface (R‚¶É< d‚¶Ñ[X]) where
  Query := R
  Response := R
  answer := fun ‚ü®poly, _‚ü© point => poly.eval point

@[inline]
def ofInputOnly
    (stmtProj : OuterStmtIn ‚Üí InnerStmtIn)
    (witProj : OuterStmtIn √ó OuterWitIn ‚Üí InnerWitIn) :
    Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn OuterStmtOut
                OuterWitIn OuterWitOut InnerWitIn OuterWitOut where
  stmt := Statement.Lens.ofInputOnly stmtProj
  wit := Witness.Lens.ofInputOnly witProj

Coe in Init.Coe

@[simp]
def ùïè (k : ‚Ñï) : ConcreteBTField (k + 1) := Z (k + 1)

@[reducible, simp]
def relOut : Set (Statement √ó Unit) := Set.univ

Polynomial.Monic in Mathlib.Algebra.Polynomial.Degree.Definitions

def evalNormalizedWAt (i : Fin r) (x : L) : L :=
  let W_x := evalWAt (r := r) (L := L) (‚Ñì := ‚Ñì) (Œ≤ := Œ≤) (R_rate := R_rate) (i := i) x
  let beta_i := Œ≤ i
  let W_beta := evalWAt (Œ≤ := Œ≤) (‚Ñì := ‚Ñì) (R_rate := R_rate) (i := i) beta_i
  W_x * W_beta‚Åª¬π

def multilinearBasis (l r : ‚Ñï) (h_le : l ‚â§ r) :
    letI instAlgebra := ConcreteBTFieldAlgebra (h_le:=h_le)
    Basis (Fin (2 ^ (r - l))) (ConcreteBTField l) (ConcreteBTField r) :=

@[inline] def pred [Zero T] [ToNat T] (a : Cayley T) : Cayley T :=
  match (‚Üëa : Nat) with
  | 0 => zero
  | Nat.succ n => ofNat n

def Prover.duplexSpongeFiatShamir (P : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) :
    NonInteractiveProver (‚àÄ i, pSpec.Message i) (oSpec ++‚Çí duplexSpongeChallengeOracle StmtIn U)
      StmtIn WitIn StmtOut WitOut where
  PrvState := fun i => match i with
    | 0 => StmtIn √ó P.PrvState 0
    | _ => P.PrvState (Fin.last n)
  input := fun ctx => ‚ü®ctx.1, P.input ctx‚ü©
  
  sendMessage | ‚ü®0, _‚ü© => fun ‚ü®stmtIn, state‚ü© => do
    let ‚ü®messages, _, state‚ü© ‚Üê P.runToRoundDSFS (Fin.last n) stmtIn state
    return ‚ü®messages, state‚ü©
  
  receiveChallenge | ‚ü®0, h‚ü© => nomatch h
  output := fun st => (P.output st).liftComp _

@[inline] def min [Zero T] [ToNat T] (a b : Cayley T) : Cayley T :=
  if (a : Nat) ‚â§ (b : Nat) then a else b

instance : SliceGE (ProtocolSpec n) ‚Ñï
    (fun _ start => start ‚â§ n)
    (fun _ start _ => ProtocolSpec (n - start))
    where
  sliceGE := fun v start h => drop start h v

@[inline]
def zero [Zero R] : MlPolyEval R n := Vector.replicate (2 ^ n) 0

class VerifierLast (pSpec : ProtocolSpec n) [NeZero n] where
  verifier_last' : pSpec.dir ‚ü®n - 1, by admit /- proof elided -/
  ‚ü© = .V_to_P

def block (i : ‚Ñï) {k : ‚Ñï} {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F}
  (S' : Finset (indexPowT S œÜ i))
  (œÜ' : (indexPowT S œÜ i) ‚Ü™ F) (z : indexPowT S œÜ k)
  [DecidableEq F] [DecidableEq Œπ] [Smooth œÜ] :=
    powFiberT i S' œÜ' z

instance (k : ‚Ñï) : Preorder (ConcreteBTField k) where
  le_refl := fun x => BitVec.le_refl x
  le_trans := fun x y z hxy hyz => BitVec.le_trans hxy hyz
  lt := fun x y => x < y
  lt_iff_le_not_ge := fun x y => by admit /- proof elided -/
| intro h_le_xy h_not_le_yx =>
      have x_lt_y:= mt bitvec_statement.mp h_not_le_yx
      push_neg at x_lt_y
      exact x_lt_y

Vector.get in Init.Data.Vector.Basic

def commitKStateProp (i : Fin ‚Ñì) (m : Fin (1 + 1))
  (stmtIn : Statement (L := L) Context i.succ)
  (witMid : Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
  (oStmtIn : (i_1 : Fin (toOutCodewordsCount ‚Ñì œë i.castSucc)) ‚Üí
    OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc i_1)
  : Prop :=

  match m with
  | ‚ü®0, _‚ü© => 
    masterKStateProp (mp := mp) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (stmtIdx := i.succ) (oracleIdx := i.castSucc)
      (h_le := by admit /- proof elided -/
      )
      (stmt := stmtIn) (wit := witMid) (oStmt := oStmtIn)
      (localChecks := True)
  | ‚ü®1, _‚ü© => 
    let ‚ü®_, stmtOut, oStmtOut, witOut‚ü© := getCommitProverFinalOutput ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i ‚ü®stmtIn, oStmtIn, witMid‚ü©
    masterKStateProp (mp := mp) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (stmtIdx := i.succ) (oracleIdx := i.succ)
      (h_le := le_refl _)
      (stmt := stmtOut) (wit := witOut) (oStmt := oStmtOut)
      (localChecks := True)

QueryImpl.impl in VCVio.OracleComp.SimSemantics.SimulateQ

def eval (x : Fin numWires ‚Üí ùì°) (g : Gate ùì° numWires) : ùì° :=
  g.qL * x g.a + g.qR * x g.b + g.qO * x g.c + g.qM * (x g.a * x g.b) + g.qC

Int.ofNat in Init.Data.Int.Basic

instance : IsEmpty (ChallengeIdx ‚ü®!v[.P_to_V], !v[Msg]‚ü©) :=
  ‚ü®fun ‚ü®i, h‚ü© => by admit /- proof elided -/
  ‚ü©

noncomputable def œÄ_z_lift {H : F[X][Y]} (z : F) (root : rationalRoot (H_tilde' H) z) :
  F[X][Y] ‚Üí+* F := Polynomial.evalEvalRingHom z root.1

instance {i : ‚Ñï} : IsCyclicWithGen (evalDomain D i) :=

inductive PrattPart : (p : ‚Ñï) ‚Üí (a : ZMod p) ‚Üí ‚Ñï ‚Üí Prop
  | prime : {p : ‚Ñï} ‚Üí {a : ZMod p} ‚Üí (n k nk : ‚Ñï) ‚Üí n.Prime ‚Üí
      a ^ ((p - 1) / n) ‚â† 1 ‚Üí n ^ k = nk ‚Üí PrattPart p a nk
  | split : {p : ‚Ñï} ‚Üí {a : ZMod p} ‚Üí {n : ‚Ñï} ‚Üí (l r : ‚Ñï) ‚Üí
      PrattPart p a l ‚Üí PrattPart p a r ‚Üí l * r = n ‚Üí PrattPart p a n

inductive HList' {Œ± : Type v} (Œ≤ : Œ± ‚Üí Type u) : List Œ± ‚Üí Type (max u v)
  | nil  : HList' Œ≤ []
  | cons : Œ≤ i ‚Üí HList' Œ≤ is ‚Üí HList' Œ≤ (i :: is)

class DCast‚ÇÉ (Œ± : Sort*) (Œ≤ : Œ± ‚Üí Sort*) (Œ≥ : (a : Œ±) ‚Üí Œ≤ a ‚Üí Sort*)
    (Œ¥ : (a : Œ±) ‚Üí (b : Œ≤ a) ‚Üí Œ≥ a b ‚Üí Sort*) [DCast Œ± Œ≤] [DCast‚ÇÇ Œ± Œ≤ Œ≥] where
  dcast‚ÇÉ : ‚àÄ {a a' : Œ±} {b : Œ≤ a} {b' : Œ≤ a'} {c : Œ≥ a b} {c' : Œ≥ a' b'},
    (ha : a = a') ‚Üí (hb : dcast ha b = b') ‚Üí (hc : dcast‚ÇÇ ha hb c = c') ‚Üí Œ¥ a b c ‚Üí Œ¥ a' b' c'
  dcast‚ÇÉ_id : ‚àÄ {a : Œ±} {b : Œ≤ a} {c : Œ≥ a b},
    dcast‚ÇÉ (Eq.refl a) dcast_eq dcast‚ÇÇ_eq = (id : Œ¥ a b c ‚Üí Œ¥ a b c)

def fiberEvaluationMapping (i : Fin r) (steps : ‚Ñï) (h_i_add_steps : i.val + steps < ‚Ñì + ùì°)
    (f : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) i ‚Üí L)
    (y : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate)
      ‚ü®‚Üëi + steps, by admit /- proof elided -/
      ‚ü©)
    : Fin (2 ^ steps) ‚Üí L :=
  
  let fiberMap := qMap_total_fiber ùîΩq Œ≤ (i := i) (steps := steps)
    (h_i_add_steps := h_i_add_steps) (y := y)

  
  fun idx => f (fiberMap idx)

def queryCodeword (j : Fin (toOutCodewordsCount ‚Ñì œë (Fin.last ‚Ñì)))
    (point : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®j.val * œë,
      by admit /- proof elided -/
          ‚ü©) :
  OracleComp ([OracleStatement ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (
  Fin.last ‚Ñì)]‚Çí) L :=
      OracleComp.lift <| by
        simpa using
          OracleSpec.query
            (spec := [OracleStatement ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì)]‚Çí)
            ‚ü®j, by admit /- proof elided -/
            ‚ü©
            (by admit /- proof elided -/
            )

AdjoinRoot.of in Mathlib.RingTheory.AdjoinRoot

structure ConcreteBTFDivisionRingProps (k : ‚Ñï) extends (ConcreteBTFRingProps k) where
  
  mul_inv_cancel : ‚àÄ a : ConcreteBTField k, a ‚â† zero ‚Üí concrete_mul a (concrete_inv a) = one

HDiv in Init.Prelude

LawfulBEq in Init.Core

@[reducible, inline, specialize]
def Challenges' (pSpec : ProtocolSpec n) : Type :=
  ‚àÄ i, (hi : pSpec.dir i = .V_to_P) ‚Üí pSpec.¬´Type¬ª i

Module.Basis.reindex in Mathlib.LinearAlgebra.Basis.Defs

def finalize (ds : DomainSeparator U H) : Array Op :=
  let parts := ds.io.splitOn SEP_BYTE
  
  let parseDigits (cs : List Char) : Nat √ó List Char :=
    let rec go : Nat ‚Üí List Char ‚Üí Nat √ó List Char
    | acc, [] => (acc, [])
    | acc, c :: rest =>
      if c.isDigit then
        let d := (c.toNat - '0'.toNat)
        go (acc * 10 + d) rest
      else
        (acc, c :: rest)
    go 0 cs
  let parsePart (s : String) : Option Op :=
    match s.data with
    | [] => none
    | id :: rest =>
      let (n, _rest) := parseDigits rest
      match id with
      | 'A' => if n = 0 then none else some (Op.Absorb n)
      | 'S' => if n = 0 then none else some (Op.Squeeze n)
      | 'R' => some Op.Ratchet
      | 'H' => some Op.Hint
      | _ => none
  let opsList := (parts.drop 1).foldl (fun acc p =>
      match parsePart p with
      | some op => acc.push op
      | none => acc) (#[] : Array Op)
  
  let simplify (acc : Array Op) (op : Op) : Array Op :=
    match acc.back? with
    | some (Op.Absorb a) =>
        match op with
        | Op.Absorb b => acc.pop.push (Op.Absorb (a + b))
        | _ => acc.push op
    | some (Op.Squeeze a) =>
        match op with
        | Op.Squeeze b => acc.pop.push (Op.Squeeze (a + b))
        | _ => acc.push op
    | _ => acc.push op
  opsList.foldl simplify (#[] : Array Op)

def getPutativeRoot {s} (idx : BinaryTree.SkeletonLeafIndex s) (leafValue : Œ±)
    (proof : List Œ±) : OracleComp (spec Œ±) Œ± :=
  match proof with
  | [] => return leafValue 
  | siblingBelowRootHash :: restProof => do
    match idx with
    | BinaryTree.SkeletonLeafIndex.ofLeaf =>
      
      
      
      return leafValue
    | BinaryTree.SkeletonLeafIndex.ofLeft idxLeft =>
      
      let ancestorBelowRootHash ‚Üê getPutativeRoot idxLeft leafValue restProof
      singleHash ancestorBelowRootHash siblingBelowRootHash
    | BinaryTree.SkeletonLeafIndex.ofRight idxRight =>
      
      let ancestorBelowRootHash ‚Üê getPutativeRoot idxRight leafValue restProof
      singleHash siblingBelowRootHash ancestorBelowRootHash

def idxOf' [BEq Œ±] (a : Œ±) (l : List Œ±) : ‚Ñï := findIdx' (¬∑ == a) l

def firstOracleWitnessConsistencyProp (t : MultilinearPoly L ‚Ñì)
    (f‚ÇÄ : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate 0 ‚Üí L) : Prop :=
  let P‚ÇÄ: L[X]_(2 ^ ‚Ñì) := polynomialFromNovelCoeffsF‚ÇÇ ùîΩq Œ≤ ‚Ñì (by admit /- proof elided -/
  ) (fun œâ => t.val.eval œâ)
  
  2 * hammingDist (fun x => P‚ÇÄ.val.eval x.val) f‚ÇÄ < BBF_CodeDistance ‚Ñì ùì° ‚ü®0, by admit /- proof elided -/
  ‚ü©

instance ConcreteBTField.instDCast_local : DCast ‚Ñï ConcreteBTField where
  dcast h_k_eq term_k1 := BitVec.cast (congrArg (fun n => 2 ^ n) h_k_eq) term_k1
  dcast_id := by admit /- proof elided -/

def testNTTBTF‚ÇÉ : Fin (2 ^ (2 + 2)) ‚Üí BTF‚ÇÉ :=

def pSpecCoreInteraction := (pSpecSumcheckFold ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)) ++‚Çö
  (pSpecFinalSumcheckStep (L:=L))

@[reducible, simp] def StmtIn := Unit

AlgHom in Mathlib.Algebra.Algebra.Hom
</all_available_defs>

<all_available_lemmas>
Polynomial.mem_degreeLT in Mathlib.RingTheory.Polynomial.Basic
Polynomial.natDegree_lt_iff_degree_lt in Mathlib.Algebra.Polynomial.Degree.Definitions
Matrix.mulVecLin_apply in Mathlib.LinearAlgebra.Matrix.ToLin
Matrix.mulVec_eq_sum in Mathlib.Data.Matrix.Mul
Finset.mem_range in Mathlib.Data.Finset.Range
Finset.sum_congr in Mathlib.Algebra.BigOperators.Group.Finset.Basic
Finset.sum_fin_eq_sum_range in Mathlib.Data.Fintype.BigOperators
Polynomial.eval_eq_sum_range' in Mathlib.Algebra.Polynomial.Eval.Degree
Polynomial.ext in Mathlib.Algebra.Polynomial.Basic
LinearMap.mem_range in Mathlib.Algebra.Module.Submodule.Range
Submodule.mem_map in Mathlib.Algebra.Module.Submodule.Map

@[simp]
lemma liftF'_p_coeff {p : F[X]} {k : ‚Ñï} {i : Fin k} : liftF' p.coeff i = p.coeff i

@[simp]
lemma coeff_polynomialOfCoeffs_eq_coeffs :
  Fin.liftF' (polynomialOfCoeffs coeffs).coeff = coeffs

@[simp]
theorem dflatten_one {n : Fin 1 ‚Üí ‚Ñï} {motive : (k : Fin (vsum n)) ‚Üí Sort*}
    {v : (i : Fin 1) ‚Üí (j : Fin (n i)) ‚Üí motive (embedSum i j)} :
    dflatten (motive := motive) v = v 0

theorem two_pow_ne_zero (n : ‚Ñï) : 2 ^ n ‚â† 0

theorem Fin.sum_univ_odd_even {n : ‚Ñï} {M : Type*} [AddCommMonoid M] (f : ‚Ñï ‚Üí M) :
    (‚àë i : Fin (2 ^ n), f (2 * i)) + (‚àë i : Fin (2 ^ n), f (2 * i + 1))
    = ‚àë i: Fin (2 ^ (n+1)), f i

lemma toImpl_toPoly_of_canonical [LawfulBEq R] (p : UniPolyC R) : p.toPoly.toImpl = p

@[simp]
theorem vappend_vempty (v : Fin m ‚Üí Œ±) : vappend v !v[] = v

@[simp]
lemma eval‚ÇÇAlgHom_apply {A : Type w} {B : Type*} [CommSemiring A] [CommSemiring B]
    [PolynomialLike A P] [Algebra R A] [IsScalarTower R A P] [Algebra R B]
    (f : A ‚Üí‚Çê[R] B) (b : B) (p : P) :
    (eval‚ÇÇAlgHom f b) p = eval‚ÇÇ f b p

theorem FullData.toLeafData_leftSubtree {Œ±} {s_left s_right : Skeleton}
    (tree : FullData Œ± (Skeleton.internal s_left s_right)) :
    tree.toLeafData.leftSubtree =
      tree.leftSubtree.toLeafData

@[to_additive (attr := simp)]
theorem prod_insertNth [CommMonoid Œ≤] {n : ‚Ñï} (x : Œ≤) (f : Fin n ‚Üí Œ≤) (p : Fin (n + 1)) :
    ‚àè i, insertNth p x f i = x * ‚àè i, f i

@[simp]
theorem fflatten_embedSum {A : Sort u} {F : A ‚Üí Sort v} {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï}
    {Œ± : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí A}
    (v : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí F (Œ± i j)) (i : Fin m) (j : Fin (n i)) :
    fflatten v (embedSum i j) = cast (by simp) (v i j)

theorem liftContext_run
    {lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    {outerStmtIn : OuterStmtIn} {outerWitIn : OuterWitIn}
    {R : Reduction oSpec InnerStmtIn InnerWitIn InnerStmtOut InnerWitOut pSpec} :
      (R.liftContext lens).run outerStmtIn outerWitIn = do
        let ‚ü®‚ü®fullTranscript, innerCtxOut‚ü©, verInnerStmtOut‚ü© ‚Üê
          R.run.uncurry (lens.proj (outerStmtIn, outerWitIn))
        return ‚ü®‚ü®fullTranscript, lens.lift (outerStmtIn, outerWitIn) innerCtxOut‚ü© ,
                lens.stmt.lift outerStmtIn verInnerStmtOut‚ü©

theorem is_fiber_iff_generates_quotient_point (i : Fin ‚Ñì) (steps : ‚Ñï)
    (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
    (x : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i, by omega‚ü©))
    (y : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i.val + steps, by omega‚ü©)) :
    let qMapFiber := qMap_total_fiber ùîΩq Œ≤ (i := ‚ü®i, by omega‚ü©) (steps := steps)
      (h_i_add_steps := by simp only; exact fin_‚Ñì_steps_lt_‚Ñì_add_R i steps h_i_add_steps) (y := y)
    let k := pointToIterateQuotientIndex (i := ‚ü®i, by omega‚ü©) (steps := steps)
      (h_i_add_steps := h_i_add_steps) (x := x)
    y = iteratedQuotientMap ùîΩq Œ≤ h_‚Ñì_add_R_rate i (k := steps) (h_bound := h_i_add_steps) x ‚Üî
    qMapFiber k = x

@[simp]
lemma evalDist_cast (h : Œ± = Œ≤) [spec.FiniteRange] :
    evalDist (cast (congrArg (OracleComp spec) h) oa) =
      cast (congrArg (PMF ‚àò Option) h) (evalDist oa)

theorem BaseField_is_prime : Nat.Prime BASE_FIELD_CARD

lemma nonsquare_mulVecLin [CommSemiring F] {Œπ' : ‚Ñï} {Œ±‚ÇÅ : Œπ ‚Ü™ F} {Œ±‚ÇÇ : Fin Œπ' ‚Üí F} {i : Œπ} :
  (nonsquare Œπ' Œ±‚ÇÅ).mulVecLin Œ±‚ÇÇ i = ‚àë x, Œ±‚ÇÇ x * Œ±‚ÇÅ i ^ x.1

lemma and_eq_zero_iff {n m : ‚Ñï} : n &&& m = 0 ‚Üî ‚àÄ k, (n >>> k) &&& (m >>> k) = 0

@[simp]
theorem cast_toReduction
    (R : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec‚ÇÅ) :
    (R.cast hn hSpec hO‚Çò).toReduction = Reduction.cast hn hSpec R.toReduction

@[simp]
private lemma E_ne_zero : (E œâs f p e) ‚â† 0

theorem insertNth_ne_zero_of_right (h : s ‚â† 0) : insertNth p y s ‚â† 0

lemma getBit_of_sub_two_pow_of_bit_1 {n i j: ‚Ñï} (h_getBit_eq_1: getBit i n = 1) :
  getBit j (n - 2^i) = (if j = i then 0 else getBit j n)

theorem drop_repeat {Œ± : Type*} {n' : ‚Ñï} (m : ‚Ñï) (h : m ‚â§ n) (a : Fin n' ‚Üí Œ±) :
    drop (m * n') (Nat.mul_le_mul_right n' h) (Fin.repeat n a) =
      fun i : Fin (n * n' - m * n') =>
          (Fin.repeat (n - m) a (i.cast (Nat.sub_mul n m n').symm))

lemma zero_def [Zero R] : zero = Vector.replicate (2 ^ n) 0

theorem finrank_degreeLT_n (n : ‚Ñï) : Module.finrank L (L‚¶É< n‚¶Ñ[X]) = n

lemma isInterleaved_codeOfLinearCode : (codeOfLinearCode Œ∫ LC).isInterleaved

@[simp]
theorem ranges_nil : List.ranges [] = []

lemma listOfCloseCodewords_eq_zero :
  listOfCloseCodewords C y n = 0 ‚Üî IsEmpty (hammingBall C y n) ‚à® Infinite (hammingBall C y n)

NeZero.ne in Init.Data.NeZero

@[csimp, grind =]
theorem findIdx'_eq_findIdx : @findIdx' = @findIdx

theorem cast_injective : Function.Injective (ChallengeIdx.cast hn hSpec)

@[simp]
lemma eval_solutionToQ_zero {x : F} {v} : eval x (solutionToQ 0 k v) =
                                          ‚àë a ‚àà Finset.range k, liftF v a * x ^ a

@[simp] theorem leftpad_eq_self (l : List Œ±) (n : Nat) (h : l.length ‚â• n) :
    leftpad n unit l = l

@[simp]
lemma finite_possibleDeltas : (possibleDeltas U V).Finite

@[simp]
lemma zero_mem_relHammingDistRange : 0 ‚àà relHammingDistRange Œπ

lemma towerAlgebraMap_succ (l r : ‚Ñï) (h_le : l ‚â§ r) :
  towerAlgebraMap (l:=l) (r:=r+1) (h_le:=by omega) =
  (towerAlgebraMap (l:=r) (r:=r+1) (h_le:=by omega)).comp
  (towerAlgebraMap (l:=l) (r:=r) (h_le:=by omega))

@[simp]
theorem seqCompose_zero {n : Fin 0 ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)} :
    seqCompose pSpec = !p[]

theorem toImpl_toPoly [LawfulBEq R] (p : UniPoly R) : p.toPoly.toImpl = p.trim

theorem matchSize_toList {a b : Array Œ±} {unit : Œ±} :
    matchSize a b unit =
      let (a', b') := List.matchSize a.toList b.toList unit
      (mk a', mk b')

theorem ZMod.powEqOfPowMod :
   ‚àÄ {n a' c : ‚Ñï} (a : ZMod n), (a' : ZMod n) = a ‚Üí
      Nat.mod (Nat.pow a' (n - 1)) n = c ‚Üí c = 1 ‚Üí a ^ (n - 1) = 1

theorem sum_Icc_split {Œ± : Type*} [AddCommMonoid Œ±] (f : ‚Ñï ‚Üí Œ±) (a b c : ‚Ñï)
    (h‚ÇÅ : a ‚â§ b) (h‚ÇÇ : b ‚â§ c):
    ‚àë i ‚àà Finset.Icc a c, f i = ‚àë i ‚àà Finset.Icc a b, f i + ‚àë i ‚àà Finset.Icc (b+1) c, f i

@[simp]
lemma mul_by_empty :
    mul_by_2 ‚àÖ = ‚àÖ

theorem zero_lt_pow_n (m : ‚Ñï) (n : ‚Ñï) (h_m : m > 0): 0 < m^n

lemma join_via_add_smul_zero {k : ‚Ñï} (h_pos : k > 0) :
  ‚ãò 0, 0 ‚ãô = 0

lemma E_and_Q_unique
  [NeZero n]
  {e k : ‚Ñï}
  {E Q E' Q' : Polynomial F}
  {œâs f : Fin n ‚Üí F}
  (he : 2 * e < n - k + 1)
  (hk_n : k ‚â§ n)
  (h_Q : Q ‚â† 0)
  (h_Q' : Q' ‚â† 0)
  (h_inj : Function.Injective œâs)
  (h_bw‚ÇÅ : BerlekampWelchCondition e k œâs f E Q)
  (h_bw‚ÇÇ : BerlekampWelchCondition e k œâs f E' Q')
: E * Q' = E' * Q

lemma sum_of_and_eq_zero_is_xor {n m : ‚Ñï} (h_n_AND_m : n &&& m = 0) : n + m = n ^^^ m

@[simp]
theorem OracleReduction.id_perfectCompleteness
    {rel : Set ((StmtIn √ó ‚àÄ i, OStmtIn i) √ó WitIn)}
    (hInit : init.neverFails) :
    (OracleReduction.id : OracleReduction oSpec _ _ _ _ _ _ _).perfectCompleteness
      init impl rel rel

Finset.sup_lt_iff in Mathlib.Data.Finset.Lattice.Fold

@[simp]
theorem join_eq_join_via_add_smul {k : ‚Ñï} (h_pos : k > 0)
    (hi_btf lo_btf : ConcreteBTField (k - 1)) :
    „Ää hi_btf, lo_btf „Äã = join_via_add_smul k h_pos hi_btf lo_btf

theorem fconcat_injective2 {Œ± : Fin n ‚Üí A} {Œ≤ : A} :
    Function.Injective2 (@fconcat A F n Œ± Œ≤)

@[simp]
theorem cast_id :
    OracleVerifier.cast rfl rfl (fun i => rfl) =
      (id : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec‚ÇÅ ‚Üí _)

theorem eq_iff_split_eq {k : ‚Ñï} (h_pos : k > 0) (x‚ÇÄ x‚ÇÅ : ConcreteBTField k) :
  x‚ÇÄ = x‚ÇÅ ‚Üî (split h_pos x‚ÇÄ = split h_pos x‚ÇÅ)

lemma runWithOracle_getPutativeRoot {s} (idx : BinaryTree.SkeletonLeafIndex s)
    (leafValue : Œ±) (proof : List Œ±) (f) :
    (runWithOracle f (getPutativeRoot idx leafValue proof))
      =
    getPutativeRoot_with_hash idx leafValue proof fun (left right : Œ±) => (f () ‚ü®left, right‚ü©)

@[coe]
theorem BTField_succ_eq_adjoinRoot (k : ‚Ñï) : AdjoinRoot (poly k) = BTField (k+1)

theorem range_vconcat {Œ± : Type*} (v : Fin n ‚Üí Œ±) (a : Œ±) :
    Set.range (vconcat v a) = insert a (Set.range v)

@[simp]
lemma evenPart_coeff {f : Polynomial F} {n : ‚Ñï} :
    (evenPart f).coeff n = if Even n then f.coeff n else 0

lemma forwardRange_eq_of_r_eq (n : ‚Ñï) (r1 r2 : Fin n) (h_r_eq : r1 = r2) (l : Fin (r1.val + 1)) :
  forwardRange n r1 l = forwardRange n r2 ‚ü®l, by omega‚ü©

theorem fcons_left_injective {Œ≤ : Fin n ‚Üí A} (b : (i : Fin n) ‚Üí F (Œ≤ i)) :
    Function.Injective (fun (a : F Œ±) => fcons a b)

@[simp]
lemma seqCompose_type {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)} :
    (seqCompose pSpec).Type = Fin.vflatten (fun i => (pSpec i).Type)

lemma add_shiftRight_distrib {n m k : ‚Ñï} (h_and_zero : n &&& m = 0):
  (n + m) >>> k = (n >>> k) + (m >>> k)

@[simp]
lemma seqCompose_succ {m : ‚Ñï}
    (Stmt : Fin (m + 2) ‚Üí Type) (Wit : Fin (m + 2) ‚Üí Type)
    {n : Fin (m + 1) ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (R : (i : Fin (m + 1)) ‚Üí
      Reduction oSpec (Stmt i.castSucc) (Wit i.castSucc) (Stmt i.succ) (Wit i.succ) (pSpec i)) :
    seqCompose Stmt Wit R =
      append (R 0) (seqCompose (Stmt ‚àò Fin.succ) (Wit ‚àò Fin.succ) (fun i => R (Fin.succ i)))

lemma concrete_one_ne_zero {k : ‚Ñï} : (one (k:=k)) ‚â† (zero (k:=k))

@[simp]
theorem fappend_zero {Œ≤ : Fin m ‚Üí A} {Œ± : Fin 0 ‚Üí A}
    (u : (i : Fin m) ‚Üí F (Œ≤ i)) :
    fappend u (!h‚¶ÉF‚¶Ñ‚ü®Œ±‚ü©[] : (i : Fin 0) ‚Üí F (Œ± i)) = u

Nat.mul_le_mul_right in Init.Data.Nat.Basic

lemma liftF_eval {f : Fin n ‚Üí Œ±} {i : Fin n} :
  liftF f i.val = f i

@[simp]
theorem OracleReduction.runWithLog_eq_runWithLog_reduction [‚àÄ i, OracleInterface (pSpec.Message i)]
    {stmt : StmtIn} {oStmt : ‚àÄ i, OStmtIn i} {wit : WitIn}
    {oracleReduction : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec} :
      oracleReduction.run stmt oStmt wit =
        oracleReduction.toReduction.run ‚ü®stmt, oStmt‚ü© wit

private lemma Monad.map_of_prod_fst_eq_prod_fst {m : Type u ‚Üí Type v} [Monad m] [LawfulMonad m]
    {Œ± Œ≤ Œ≥ : Type u} (ma : m (Œ± √ó Œ≤)) (c : Œ≥) :
    (fun a => (c, a.1)) <$> ma = Prod.mk c <$> Prod.fst <$> ma

Fin.append_left in Mathlib.Data.Fin.Tuple.Basic

lemma towerAlgebraMap_id (k : ‚Ñï) : towerAlgebraMap (h_le:=by omega) = RingHom.id (BTField k)

@[simp]
theorem hflatten_embedSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {Œ± : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí Sort*}
    (v : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí Œ± i j) (i : Fin m) (j : Fin (n i)) :
    hflatten v (embedSum i j) = cast (vflatten_embedSum Œ± i j).symm (v i j)

@[simp]
lemma toFun_invFun (f : ‚àÄ a, Œ≤ a) : inst.equiv.toFun (equiv.invFun f : F) = f

@[simp]
theorem LeafData.get_ofFun {Œ±} {s} (f : SkeletonLeafIndex s ‚Üí Œ±) :
    (LeafData.ofFun s f).get = f

lemma exists_Pz_of_coeffs_of_close_proximity
  {k : ‚Ñï}
  {z : F}
  (hS : z ‚àà coeffs_of_close_proximity (k := k) œâs Œ¥ u‚ÇÄ u‚ÇÅ)
  :
  ‚àÉ Pz : F[X], Pz.natDegree ‚â§ k ‚àß Œ¥·µ£(u‚ÇÄ + z ‚Ä¢ u‚ÇÅ, Pz.eval ‚àò œâs) ‚â§ Œ¥

@[simp]
theorem LeafData.get_internal_ofLeft {Œ±} {s_left s_right : Skeleton}
    (left : LeafData Œ± s_left) (right : LeafData Œ± s_right)
    (idxLeft : SkeletonLeafIndex s_left) :
    (LeafData.internal left right).get (SkeletonLeafIndex.ofLeft idxLeft) =
      left.get idxLeft

lemma lt_of_liftF_ne_zero {f : Fin n ‚Üí Œ±} {i : ‚Ñï}
  (h : liftF f i ‚â† 0)
  : i < n

theorem setWidth_eq_ofNat_mod {n num_bits : Nat} (x : BitVec n) :
  BitVec.setWidth num_bits x = BitVec.ofNat num_bits (x.toNat % 2 ^ num_bits)

private lemma evenPart_eq_evenPart' {f : Polynomial F} : evenPart f = evenPart' f

theorem canonical_nonempty_iff [LawfulBEq R] {p : UniPoly R} (hp : p.size > 0) :
  p.trim = p ‚Üî p.last_nonzero = some ‚ü® p.size - 1, Nat.pred_lt_self hp ‚ü©

Nat.add_zero in Init.Core

theorem congrArg‚ÇÉ {Œ± Œ≤ Œ≥ Œ¥ : Sort*} {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥ ‚Üí Œ¥} {a a' : Œ±} {b b' : Œ≤} {c c' : Œ≥}
    (h : a = a') (h' : b = b') (h'' : c = c') : f a b c = f a' b' c'

lemma vappend_right_of_not_lt {m n : ‚Ñï} {Œ± : Sort u}
    (u : Fin m ‚Üí Œ±) (v : Fin n ‚Üí Œ±) (i : Fin (m + n)) (h : ¬¨ i.val < m) :
      vappend u v i = v ‚ü®i - m, by omega‚ü©

theorem support_C_mul_le (p : MvPolynomial œÉ R) (r : R) : (C r * p).support ‚äÜ p.support

private lemma fold_max_lemma {Œπ : Type} {s : Finset Œπ} {f : Œπ ‚Üí ‚Ñï} {n : ‚Ñï} :
    (‚àÄ i ‚àà s, f i ‚â§ n) ‚Üí Finset.fold max 0 f s ‚â§ n

lemma concrete_mul_zero
  (prevBTFieldProps : ConcreteBTFieldProps (k := k - 1))
  (a : ConcreteBTField k) : concrete_mul a (zero (k:=k)) = zero (k:=k)

theorem eq_zero_or_eq_one {a : ConcreteBTField 0} : a = zero ‚à® a = one

theorem hconcat_injective2 {Œ± : Fin n ‚Üí Sort u} {Œ≤ : Sort u} :
    Function.Injective2 (@hconcat n Œ± Œ≤)

theorem is_multilinear_iff_eq_evals_zeroOne {p : MvPolynomial œÉ R} :
    p ‚àà R‚¶É‚â§ 1‚¶Ñ[X œÉ] ‚Üî MLE p.toEvalsZeroOne = p

theorem join_eq_bitvec_iff_fromNat {k : ‚Ñï} (h_pos : k > 0) (x : ConcreteBTField k)
  (hi_btf lo_btf : ConcreteBTField (k - 1)) :
  x = „Ää hi_btf, lo_btf „Äã ‚Üî
  (hi_btf = fromNat (k:=k - 1) (x.toNat >>> 2 ^ (k - 1)) ‚àß
  lo_btf = fromNat (k:=k - 1) (x.toNat &&& (2 ^ (2 ^ (k - 1)) - 1)))

@[simp]
lemma seqCompose_succ {m : ‚Ñï}
    (Stmt : Fin (m + 2) ‚Üí Type)
    {Œπ‚Çõ : Fin (m + 2) ‚Üí Type} (OStmt : (i : Fin (m + 2)) ‚Üí Œπ‚Çõ i ‚Üí Type)
    [O‚Çõ : ‚àÄ i, ‚àÄ j, OracleInterface (OStmt i j)]
    (Wit : Fin (m + 2) ‚Üí Type)
    {n : Fin (m + 1) ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    [O‚Çò : ‚àÄ i, ‚àÄ j, OracleInterface ((pSpec i).Message j)]
    (R : (i : Fin (m + 1)) ‚Üí
      OracleReduction oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Wit i.castSucc)
        (Stmt i.succ) (OStmt i.succ) (Wit i.succ) (pSpec i)) :
    seqCompose Stmt OStmt Wit R =
      append (R 0) (seqCompose (Stmt ‚àò Fin.succ) (fun i => OStmt (Fin.succ i)) (Wit ‚àò Fin.succ)
        (O‚Çõ := fun i => O‚Çõ (Fin.succ i)) (O‚Çò := fun i => O‚Çò (Fin.succ i))
          (fun i => R (Fin.succ i)))

theorem support_C {r : R} [h : Decidable (r = 0)] :
    (@C R œÉ _ r).support = if r = 0 then ‚àÖ else { 0 }

@[simp]
theorem dcons_zero {motive : Fin (n + 1) ‚Üí Sort u} (a : motive 0)
    (v : (i : Fin n) ‚Üí motive i.succ) : (a ::·µà‚ü®motive‚ü© v) 0 = a

theorem foldl_split_inner {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤ ‚Üí Œ±) (init : Œ±)
    (l : List Œ≤) (h : l ‚â† []): foldl (f:=f) (init:=init) (l)
    = foldl (f:=f) (init:=f (init) (l.head (by omega))) (l.tail)

@[simp]
theorem addCases'_right {m n : ‚Ñï} {Œ± : Fin m ‚Üí Sort u} {Œ≤ : Fin n ‚Üí Sort u}
    (left : (i : Fin m) ‚Üí Œ± i) (right : (j : Fin n) ‚Üí Œ≤ j) (i : Fin n) :
      addCases' left right (Fin.natAdd m i) = (Fin.append_right Œ± Œ≤ i) ‚ñ∏ (right i)

lemma coe_one_succ (l : ‚Ñï) :
    (@ConcreteBTFieldAlgebra (l:=l) (r:=l + 1) (h_le:=by omega)).algebraMap
    (1 : ConcreteBTField l) = (1 : ConcreteBTField (l + 1))

lemma proximity_gap
  {F : Type} [Field F] [Fintype F] [DecidableEq F]
  {Œπ : Type} [Fintype Œπ] [Nonempty Œπ] {œÜ : Œπ ‚Ü™ F}
  {degree m : ‚Ñï} {Œ¥ : ‚Ñù‚â•0} {f : Fin m ‚Üí Œπ ‚Üí F} {GenFun : F ‚Üí Fin m ‚Üí F}
  (h : ‚àÄ (hŒ¥Le : Œ¥ < 1 - Bstar (LinearCode.rate (code œÜ degree))) {f : Fin m ‚Üí Œπ ‚Üí F},
        Pr_{
          let r ‚Üê $·µñ F}[Œ¥·µ£((fun x => ‚àë j : Fin m, (GenFun r j) * f j x), code œÜ degree) ‚â§ (Œ¥ : ‚Ñù)]
            > ENNReal.ofReal (proximityError F degree (LinearCode.rate (code œÜ degree)) Œ¥ m)) :

        ‚àÉ S : Finset Œπ,
          S.card ‚â• (1 - Œ¥) * (Fintype.card Œπ) ‚àß
        ‚àÉ u : (Œπ ‚Üí F),
          u ‚àà (code œÜ degree) ‚àß ‚àÄ i : Fin m, ‚àÄ x ‚àà S, f i x = u x

@[simp, grind] lemma fin_chunkSize_lt_N (arrSize : Nat) (i : Fin (min arrSize SpongeSize.R)) :
    i < SpongeSize.N

@[simp]
theorem reduction_completeness (h : init.neverFails) :
    (reduction oSpec Statement Witness).perfectCompleteness init impl relIn (toRelOut relIn)

@[simp]
theorem FullData.toLeafData_leaf {Œ±} (a : Œ±) :
    (FullData.leaf a).toLeafData = LeafData.leaf a

theorem distEq_symm (mx my : OracleComp spec Œ±) : distEq mx my ‚Üí distEq my mx

theorem concrete_mul_eq
  (prevBTFieldProps : ConcreteBTFieldProps (k := k - 1))
  (a b : ConcreteBTField k) {a‚ÇÅ a‚ÇÄ b‚ÇÅ b‚ÇÄ : ConcreteBTField (k - 1)}
  (h_a : (a‚ÇÅ, a‚ÇÄ) = split h_k a) (h_b : (b‚ÇÅ, b‚ÇÄ) = split h_k b) :
  concrete_mul a b =
    „Ää concrete_mul a‚ÇÄ b‚ÇÅ + concrete_mul b‚ÇÄ a‚ÇÅ + concrete_mul (concrete_mul a‚ÇÅ b‚ÇÅ) (Z (k - 1)),
      concrete_mul a‚ÇÄ b‚ÇÄ + concrete_mul a‚ÇÅ b‚ÇÅ „Äã

theorem reduction_perfectCompleteness (hInit : init.neverFails) :
    (reduction R n deg D oSpec i).perfectCompleteness init impl
    (relationRound R n deg D i.castSucc) (relationRound R n deg D i.succ)

theorem support_finSuccEquivNth_nonempty {f : MvPolynomial (Fin (n + 1)) R} (h : f ‚â† 0) :
    (finSuccEquivNth R p f).support.Nonempty

lemma getLowBits_lt_two_pow {n : ‚Ñï} (numLowBits : ‚Ñï) :
    getLowBits numLowBits n < 2 ^ numLowBits

@[simp] theorem add_zero {a : AssocNat} : a + 0 = a

@[simp]
theorem cast_perfectCompleteness (hComplete : R.perfectCompleteness init impl relIn relOut) :
    (R.cast hn hSpec hO‚Çò).perfectCompleteness init impl relIn relOut

theorem init_vconcat (v : Fin n ‚Üí Œ±) (a : Œ±) :
    (fun i => vconcat v a (Fin.castSucc i)) = v

theorem mul_two_add_bit_lt_two_pow (a b c : ‚Ñï) (i : Fin 2)
    (h_a : a < 2 ^ b) (h_b : b < c) :
    a * 2 + i.val < 2^c

omit [NeZero r] [NeZero ùì°] in
lemma isNeCommitmentRound (bIdx : Fin (‚Ñì / œë - 1)) (x : ‚Ñï) {hx : x < œë - 1} :
    ¬¨isCommitmentRound ‚Ñì œë ‚ü®‚ÜëbIdx * œë + x, by
      conv_rhs => rw [‚ÜêNat.add_zero (n:=‚Ñì)]
      change bIdx.val * œë + (‚ü®x, by omega‚ü©: Fin œë).val < ‚Ñì + 0
      apply bIdx_mul_œë_add_i_lt_‚Ñì_succ (m:=0)
    ‚ü©

theorem natDegree_finSuccEquivNth (f : MvPolynomial (Fin (n + 1)) R) :
    (finSuccEquivNth R p f).natDegree = degreeOf p f

@[simp]
private lemma leadingCoeff_E : (E œâs f p e).leadingCoeff = 1

theorem cast_Type_idx {hn} (hSpec : pSpec‚ÇÅ.cast hn = pSpec‚ÇÇ) {i : Fin n‚ÇÅ} :
    pSpec‚ÇÇ.¬´Type¬ª (Fin.cast hn i) = pSpec‚ÇÅ.¬´Type¬ª i

theorem take_addCases'_left {n' : ‚Ñï} {Œ≤ : Fin n' ‚Üí Sort u} (m : ‚Ñï) (h : m ‚â§ n)
    (u : (i : Fin n) ‚Üí Œ± i) (v : (j : Fin n') ‚Üí Œ≤ j) (i : Fin m) :
    take m (Nat.le_add_right_of_le h) (addCases' u v) i =
      (append_left Œ± Œ≤ (castLE h i)) ‚ñ∏ (take m h u i)

@[simp]
protected lemma elocPolyF_eq_elocPoly :
  ElocPolyF (n := n) (liftF' œâs) (liftF' f) = ElocPoly n œâs f

theorem add_assoc : p + q + r = p + (q + r)

lemma rounds_sub_steps_lt : ‚Ñì - œë < ‚Ñì :=
  Nat.sub_lt (pos_of_neZero ‚Ñì) (folding_steps_pos)

lemma œë_sub_one_le_self : œë - 1 < œë

theorem linsolve_some {A : Matrix (Fin n) (Fin m) F} {b : Fin n ‚Üí F} {x : Fin m ‚Üí F}
  (h : linsolve A b = some x)
  : A.mulVec x = b

lemma irreducible_factorization_of_gs_solution
  {k : ‚Ñï}
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ) :
  ‚àÉ (C : F[Z][X]) (R : List F[Z][X][Y]) (f : List ‚Ñï) (e : List ‚Ñï),
    R.length = f.length ‚àß
    f.length = e.length ‚àß
    ‚àÄ e·µ¢ ‚àà e, 1 ‚â§ e·µ¢ ‚àß
    ‚àÄ R·µ¢ ‚àà R, R·µ¢.Separable ‚àß
    ‚àÄ R·µ¢ ‚àà R, Irreducible R·µ¢ ‚àß
    Q = (Polynomial.C C) *
        ‚àè (R·µ¢ ‚àà R.toFinset) (f·µ¢ ‚àà f.toFinset) (e·µ¢ ‚àà e.toFinset),
          (R·µ¢.comp ((Y : F[Z][X][Y]) ^ f·µ¢))^e·µ¢

@[simp]
lemma possibleDeltas_subset_relHammingDistRange :
  possibleDeltas U C ‚äÜ relHammingDistRange Œπ

lemma exists_unique_bivariate
  (qPoly : Polynomial F) (hdeg_q_min : qPoly.natDegree > 0)
  (hdeg_q_max : qPoly.natDegree < Fintype.card F) (fPoly : Polynomial F) :
    -- Q ‚àà ùîΩ[X,Y]
    ‚àÉ! Q : MvPolynomial (Fin 2) F,
      -- deg_x(Q) = Floor ( deg(fPoly) / deg(qPoly) )
      -- This is natural number division towards zero, which is floor
      (MvPolynomial.degreeOf 0 Q = (Polynomial.natDegree fPoly) / (Polynomial.natDegree qPoly)) ‚àß
      -- deg_y(Q) < deg (q)
      (MvPolynomial.degreeOf 1 Q < Polynomial.natDegree qPoly) ‚àß
      -- point‚Äëwise equality on F: f(z) = Q(q(z), z)
      (‚àÄ z : F, Polynomial.eval z fPoly = evalBivar Q (Polynomial.eval z qPoly) z) ‚àß
      (‚àÄ t : ‚Ñï, fPoly.natDegree < t * qPoly.natDegree ‚Üí MvPolynomial.degreeOf 0 Q < t)

theorem distanceLE_mvPolynomial_degreeLE {œÉ : Type*} [Fintype œÉ] [DecidableEq œÉ] :
    distanceLE (R‚¶É‚â§ d‚¶Ñ[X œÉ]) (Fintype.card œÉ * d)

theorem and_highBits_lowBits_eq_zero {n : ‚Ñï} (numLowBits : ‚Ñï) :
    getHighBits numLowBits n &&& getLowBits numLowBits n = 0

@[simp]
theorem embedSum_succ_succ {n : Fin (m + 1) ‚Üí ‚Ñï} {i : Fin m} (j : Fin (n i.succ)) :
    embedSum (i.succ) j = Fin.natAdd _ (embedSum i j)

@[simp]
lemma domain_def : (spec Œ±).domain () = (Œ± √ó Œ±)

private lemma almost_johnson_choose_2_elimed [Zero F]
  (h_n : 0 < n)
  (h_B : 2 ‚â§ B.card)
  (h_card : 2 ‚â§ Fintype.card F)
  :
  (k B * (k B - 1)  +
    (B.card - k B) * ((B.card - k B)/(Fintype.card F-1) - 1))
  ‚â§
  B.card * (B.card - 1) * (n - d B)/n

lemma full_row_rank_via_rank_subLeftFull (h : m ‚â§ n) :
   (subLeftFull U (Fin.castLE h)).rank = m ‚Üí U.rank = m

theorem prime_7 : Nat.Prime 7

@[simp]
lemma zero_le_relHammingDist : 0 ‚â§ Œ¥·µ£(u, v)

@[simp]
theorem add_accepts_iff : (add a b c).accepts x ‚Üî x c = x a + x b

@[simp]
protected lemma elocPoly_succ :
  ElocPoly (n + 1) œâs f p =
  ElocPoly n œâs f p *
    if f n = p.eval (œâs n)
    then 1
    else X - C (œâs n)

theorem monomialToNovel_novelToMonomial_inverse
  (‚Ñì : ‚Ñï) (h_‚Ñì : ‚Ñì ‚â§ r) :
  ‚àÄ coeffs : Fin (2^‚Ñì) ‚Üí L,
    novelToMonomialCoeffs ùîΩq Œ≤ ‚Ñì h_‚Ñì
    (monomialToNovelCoeffs ùîΩq Œ≤ ‚Ñì h_‚Ñì coeffs) = coeffs

@[simp]
theorem append_fst (T‚ÇÅ : FullTranscript pSpec‚ÇÅ) (T‚ÇÇ : FullTranscript pSpec‚ÇÇ) :
    (T‚ÇÅ ++‚Çú T‚ÇÇ).fst = T‚ÇÅ

lemma concrete_exists_pair_ne {k : ‚Ñï} : ‚àÉ x y : ConcreteBTField k, x ‚â† y

theorem support_finSuccEquivNth (f : MvPolynomial (Fin (n + 1)) R) :
    (finSuccEquivNth R p f).support = Finset.image (fun m : Fin (n + 1) ‚Üí‚ÇÄ ‚Ñï => m p) f.support

theorem MLE_expanded (evals : (œÉ ‚Üí Fin 2) ‚Üí R) : MLE evals =
    ‚àë x : œÉ ‚Üí Fin 2, (‚àè i : œÉ, ((1 - C (x i : R)) * (1 - X i) + C (x i : R) * X i))
      * C (evals x)

theorem coeffs_of_comp_minus_x {f : Polynomial F} {n : ‚Ñï} :
    (f.comp (-X)).coeff n = if Even n then f.coeff n else -f.coeff n

lemma exists_points_with_large_matching_subset
  {œâs : Fin n ‚Ü™ F}
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  {x : Fin n}
  {D : ‚Ñï}
  (hD : D ‚â• Bivariate.totalDegree (H k Œ¥ x‚ÇÄ h_gs))
  :
  ‚àÉ Dtop : Finset (Fin n),
    Dtop.card = k + 1 ‚àß
    ‚àÄ x ‚àà Dtop,
      (matching_set_at_x k Œ¥ h_gs x).card >
        (2 * k + 1)
        * (Bivariate.natDegreeY <| H k Œ¥ x‚ÇÄ h_gs)
        * (Bivariate.natDegreeY <| R k Œ¥ x‚ÇÄ h_gs)
        * D

lemma take_eq_take : transcript‚ü¶:m‚üß = transcript.take m h

private lemma le_sum_sum_choose_K [Zero F]
  (h_n : 0 < n)
  (h_B : B.card ‚â† 0)
  (h_card : 2 ‚â§ Fintype.card F)
  :
  n * (choose_2 (k B) + (Fintype.card (Œ± := F) - 1)
    * choose_2 ((B.card - k B) / ((Fintype.card (Œ± := F) - 1))))
  ‚â§ ‚àë i, sum_choose_K_i B i

lemma mkLastOracleIndex_last : mkLastOracleIndex ‚Ñì œë (Fin.last ‚Ñì) = ‚Ñì / œë - 1

private lemma BerlekampWelchCondition_to_Solution' [NeZero n]
  (h : BerlekampWelchCondition e k œâs f (solutionToE e k v) (solutionToQ e k v))
  : IsBerlekampWelchSolution e k œâs f v

lemma getLowBits_succ {n: ‚Ñï} (numLowBits: ‚Ñï) :
    getLowBits (numLowBits + 1) n = getLowBits numLowBits n
    + (getBit numLowBits n) <<< numLowBits

@[simp]
theorem insertNth_removeNth : insertNth p y (removeNth p t) = update t p y

@[simp]
theorem fflatten‚ÇÇ_one {A : Sort u} {B : Sort v} {F : A ‚Üí B ‚Üí Sort w} {n : Fin 1 ‚Üí ‚Ñï}
    {Œ± : (i : Fin 1) ‚Üí (j : Fin (n i)) ‚Üí A}
    {Œ≤ : (i : Fin 1) ‚Üí (j : Fin (n i)) ‚Üí B}
    {v : (i : Fin 1) ‚Üí (j : Fin (n i)) ‚Üí F (Œ± i j) (Œ≤ i j)} :
    fflatten‚ÇÇ v = v 0

theorem rtake_rev_eq_take_of_rev {Œ± : Sort*} (m : ‚Ñï) (h : m ‚â§ n) (v : Fin n ‚Üí Œ±) :
    rtake m h v ‚àò Fin.rev = (take m h (v ‚àò Fin.rev))

omit [Finite F] in
lemma dom_n_eq_triv : evalDomain D n = ‚ä•

@[grind]
lemma coeff_ne_zero {f q : F[X][Y]} (hg : q * f ‚â† 0) : q.coeff ‚â† 0

@[simp]
theorem vappend_vcons (a : Œ±) (u : Fin m ‚Üí Œ±) (v : Fin n ‚Üí Œ±) :
    vappend (vcons a u) v = (vcons a (vappend u v)) ‚àò Fin.cast (Nat.succ_add m n)

theorem verifier_rbr_knowledge_soundness :
    (verifier oSpec Statement pred).rbrKnowledgeSoundness init impl
      (relIn Statement pred) (relOut Statement) 0

theorem toPoly_add {p q : UniPoly Q} : (add_raw p q).toPoly = p.toPoly + q.toPoly

theorem vcons_inj (a b : Œ±) (v w : Fin n ‚Üí Œ±) : a ::·µõ v = b ::·µõ w ‚Üî a = b ‚àß v = w

theorem canonical_of_size_zero {p : UniPoly R} : p.size = 0 ‚Üí p.trim = p

theorem hcons_eq_cons {Œ≤ : Fin n ‚Üí Sort u} (a : Œ±) (v : (i : Fin n) ‚Üí Œ≤ i) :
    hcons a v = cons (Œ± := vcons Œ± Œ≤) (hcons a v 0) (fun i => hcons a v i.succ)

private lemma almost_johnson [Zero F]
  (h_n : 0 < n)
  (h_B : 2 ‚â§ B.card)
  (h_card : 2 ‚â§ (Fintype.card F))
  :
  n * (choose_2 (k B) + (Fintype.card F - 1)
    * choose_2 ((B.card - k B) / (Fintype.card F - 1)))
  ‚â§
  choose_2 B.card * (n - d B)

lemma zipWith_const {Œ± Œ≤ : Type _} {f : Œ± ‚Üí Œ≤ ‚Üí Œ≤} {l‚ÇÅ : List Œ±} {l‚ÇÇ : List Œ≤}
  (h‚ÇÅ : l‚ÇÅ.length = l‚ÇÇ.length) (h‚ÇÇ : ‚àÄ a b, f a b = b) : l‚ÇÅ.zipWith f l‚ÇÇ = l‚ÇÇ

lemma natDeg_sum_eq_of_unique {Œ± : Type} {s : Finset Œ±} {f : Œ± ‚Üí F[X]} {deg : ‚Ñï}
  (mx : Œ±) (h : mx ‚àà s) :
    (f mx).natDegree = deg ‚Üí
    (‚àÄ y ‚àà s, y ‚â† mx ‚Üí (f y).natDegree < deg ‚à® f y = 0) ‚Üí
    (‚àë x ‚àà s, f x).natDegree = deg

lemma lagrangeToMono_eq_lagrangeToMono_segment (n : ‚Ñï) [NeZero n] (v : Vector R (2 ^ n)) :
  have h_n_ne_zero: n ‚â† 0

lemma resultant_is_divisible_by_leadingCoeff {F : Type} [CommRing F] [Inhabited F] (f : F[X])
  : ‚àÉ r',
    Polynomial.resultant f (Polynomial.derivative f) = f.leadingCoeff * r'

lemma num_eq_highBits_add_lowBits {n: ‚Ñï} (numLowBits: ‚Ñï) :
  n = getHighBits numLowBits n + getLowBits numLowBits n

theorem cast_Type_idx_symm {hn} (hSpec : pSpec‚ÇÅ.cast hn = pSpec‚ÇÇ) {i : Fin n‚ÇÇ} :
    pSpec‚ÇÅ.¬´Type¬ª (Fin.cast hn.symm i) = pSpec‚ÇÇ.¬´Type¬ª i

List.length_drop in Init.Data.List.TakeDrop

theorem append_right' {u : Fin m ‚Üí Œ±} {v : Fin n ‚Üí Œ±} {i : Fin n}
    (j : Fin (m + n)) (h : j = natAdd m i) : append u v j = v i

@[simp]
theorem finSuccEquivNth_X_above {i : Fin n} (h : p < i.succ) :
    finSuccEquivNth R p (X i.succ) = Polynomial.C (X i)

theorem one_le_sub_consecutive_two_pow (n : ‚Ñï): 1 ‚â§ 2^(n+1) - 2^n

theorem oracleVerifier_rbrKnowledgeSoundness [Fintype R] :
    (oracleVerifier R n deg D oSpec i).rbrKnowledgeSoundness init impl
    (relationRound R n deg D i.castSucc) (relationRound R n deg D i.succ)
    (fun _ => (deg : ‚Ñù‚â•0) / Fintype.card R)

lemma solutionToE_eq_polynomialOfCoeffs
  (h : n < e) : (solutionToE e k v).coeff n = (polynomialOfCoeffs v).coeff n

@[simp]
theorem hcons_fin_zero {Œ± : Sort u} {Œ≤ : Fin 0 ‚Üí Sort u} (a : Œ±) (v : (i : Fin 0) ‚Üí Œ≤ i) :
    hcons a v = fun i => match i with

lemma concrete_mul_right_distrib
  {h_k : k > 0} (prevBTFieldProps : ConcreteBTFieldProps (k := k - 1))
  (a b c : ConcreteBTField k) :
    concrete_mul (a + b) c = concrete_mul a c + concrete_mul b c

@[simp]
protected lemma elocPoly_zero : ElocPoly 0 œâs f p = 1

lemma h_sub_middle {k : ‚Ñï} (h_pos : k > 0) : 2 ^ k - 1 - 2 ^ (k - 1) + 1 = 2 ^ (k - 1)

theorem SkeletonNodeIndex.leftChild_bind_parent {s : Skeleton}
    (idx : SkeletonNodeIndex s) :
    idx.leftChild >>= parent = idx.leftChild.map (fun _ => idx)

omit [Fintype L] [DecidableEq L] in
theorem Polynomial.foldl_comp (n : ‚Ñï) (f : Fin n ‚Üí L[X]) : ‚àÄ initInner initOuter: L[X],
    Fin.foldl (n:=n) (fun acc j => (f j).comp acc) (initOuter.comp initInner)
    = (Fin.foldl (n:=n) (fun acc j => (f j).comp acc) (initOuter)).comp initInner

@[simp]
lemma aeval_X {A : Type y} [CommSemiring A] [Algebra R A] {F : Type z} [FunEquiv F œÉ A] (g : F)
    (s : œÉ) : aeval g (X s : P) = g s

theorem sum_le_of_divSum?_eq_some {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {k : Fin (‚àë j, n j)} {i : Fin m}
    (hi : divSum? n k = some i) : ‚àë j : Fin i, n (castLE i.isLt.le j) ‚â§ k

@[simp]
lemma oddPart_by_2 :
    2 * (oddPart f) = (f - f.comp (-X)) /‚Çò X

@[simp]
theorem vflatten_embedSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (v : (i : Fin m) ‚Üí Fin (n i) ‚Üí Œ±) (i : Fin m)
    (j : Fin (n i)) : vflatten v (embedSum i j) = v i j

@[simp]
theorem ranges_length_eq_self_length {l : List ‚Ñï} : l.ranges.length = l.length

omit [NeZero ‚Ñì] [NeZero r] [NeZero ùì°] in
lemma fin_‚Ñì_add_one_lt_r {h_‚Ñì_add_R_rate : ‚Ñì + ùì° < r} (i : Fin (‚Ñì + 1))
    : i.val < r

lemma domain_injective {i : ‚Ñï} : i ‚â§ n ‚Üí Function.Injective (domain D x n i)

lemma deevenize_comp_x_squared {f : Polynomial F} (hEven : EvenPoly f) :
    (deevenize f).comp (Polynomial.X * Polynomial.X) = f

theorem binaryTowerAlgebra_apply_assoc (l mid r : ‚Ñï) (h_l_le_mid : l ‚â§ mid) (h_mid_le_r : mid ‚â§ r) :
    ‚àÄ x : BTField l,
    (@binaryAlgebraTower (l:=l) (r:=r) (h_le:=by
      exact Nat.le_trans h_l_le_mid h_mid_le_r)).algebraMap x =
    (@binaryAlgebraTower (l:=mid) (r:=r) (h_le:=h_mid_le_r)).algebraMap
      ((@binaryAlgebraTower (l:=l) (r:=mid) (h_le:=h_l_le_mid)).algebraMap x)

theorem seqCompose_rbrKnowledgeSoundness
    (rel : ‚àÄ i, Set (Stmt i √ó Wit i))
    (V : ‚àÄ i, Verifier oSpec (Stmt i.castSucc) (Stmt i.succ) (pSpec i))
    (rbrKnowledgeError : ‚àÄ i, (pSpec i).ChallengeIdx ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (V i).rbrKnowledgeSoundness init impl
      (rel i.castSucc) (rel i.succ) (rbrKnowledgeError i)) :
      (Verifier.seqCompose Stmt V).rbrKnowledgeSoundness init impl (rel 0) (rel (Fin.last m))
        (fun combinedIdx =>
          letI ij := seqComposeChallengeIdxToSigma combinedIdx
          rbrKnowledgeError ij.1 ij.2)

lemma div_2_form {nD2 b : ‚Ñï} (h_b : b < 2):
  (nD2 * 2 + b) / 2 = nD2

@[simp]
theorem removeNth_update : removeNth p (update s p y) = removeNth p s

theorem linear_sum_repr (R : Type*) [CommRing R] (S : Type*) [CommRing S] [Algebra R S]
    (pb : PowerBasis R S) (h_dim : pb.dim = (2 : ‚Ñï)) (s : S) :
    ‚àÉ a b : R, s = a ‚Ä¢ pb.gen + algebraMap R S b

@[simp]
protected lemma elocPoly_ne_zero : ElocPoly n œâs f p ‚â† 0

omit [Finite F] in
lemma dom_n_eq_triv : evalDomain D x n = {x ^ (2 ^ n)}

theorem foldl_eq_toList_foldl {Œ± Œ≤} {n : ‚Ñï} (f : Œ≤ ‚Üí Œ± ‚Üí Œ≤) (init : Œ≤) (v : Vector Œ± n) :
  v.foldl (f:=f) (b:=init) = v.toList.foldl (f:=f) (init:=init)

@[simp]
theorem toNat_succ (n : ChurchNat ‚Ñï) : toNat (succ n) = n.toNat.succ

theorem insertNth_ne_zero_iff : insertNth p y s ‚â† 0 ‚Üî y ‚â† 0 ‚à® s ‚â† 0

theorem getBit_repr_univ {‚Ñì : Nat} : ‚àÄ j, j < 2^‚Ñì ‚Üí
  j = ‚àë k ‚àà Finset.univ (Œ±:=Fin ‚Ñì), (getBit k j) * 2^k.val

@[simp]
theorem dflatten_succ {m : ‚Ñï} {n : Fin (m + 1) ‚Üí ‚Ñï} {motive : (k : Fin (vsum n)) ‚Üí Sort*}
    {v : (i : Fin (m + 1)) ‚Üí (j : Fin (n i)) ‚Üí motive (embedSum i j)} :
    dflatten (motive := motive) v = dappend (v 0) (dflatten (fun i => v i.succ))

@[simp]
theorem leftpad_apply_ge (n : ‚Ñï) (a : Œ±) (v : Fin m ‚Üí Œ±) (i : Fin n)
    (h : n - m ‚â§ i.val) : leftpad n a v i = v ‚ü®i.val - (n - m), by omega‚ü©

lemma concrete_mul_zero0 (a : ConcreteBTField 0) :
  concrete_mul a (zero (k:=0)) = zero (k:=0)

theorem oracleVerifier_rbrKnowledgeSoundness [Fintype R] :
    (oracleReduction R deg oSpec).verifier.rbrKnowledgeSoundness init impl
      (inputRelation R deg D) (outputRelation R deg)
        (fun _ => (deg : ‚Ñù‚â•0) / (Fintype.card R))

Nat.zero_le in Init.Prelude

theorem seqCompose_rbrSoundness
    (lang : (i : Fin (m + 1)) ‚Üí Set (Stmt i √ó ‚àÄ j, OStmt i j))
    (V : (i : Fin m) ‚Üí
      OracleVerifier oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Stmt i.succ) (OStmt i.succ)
        (pSpec i))
    (rbrSoundnessError : ‚àÄ i, (pSpec i).ChallengeIdx ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (V i).rbrSoundness init impl (lang i.castSucc) (lang i.succ) (rbrSoundnessError i)) :
      (OracleVerifier.seqCompose Stmt OStmt V).rbrSoundness
        init impl (lang 0) (lang (Fin.last m))
        (fun combinedIdx =>
          letI ij := seqComposeChallengeIdxToSigma combinedIdx
          rbrSoundnessError ij.1 ij.2)

@[simp]
theorem cast_rbrKnowledgeSoundness (Œµ : pSpec‚ÇÅ.ChallengeIdx ‚Üí ‚Ñù‚â•0)
    (hRbrKs : V.rbrKnowledgeSoundness init impl relIn relOut Œµ) :
    (V.cast hn hSpec hO‚Çò).rbrKnowledgeSoundness init impl relIn relOut
      (Œµ ‚àò (ChallengeIdx.cast hn.symm (cast_symm hSpec)))

@[simp]
lemma ofPolynomialAlgHom_toPolynomialAlgHom_C {r : R} :
    ofPolynomialAlgHom (toPolynomialAlgHom (C r : P)) = (Polynomial.C r : R[X])

@[simp]
lemma foldr'_succ {n : ‚Ñï} {Œ± : Type u} (f : (i : Fin (n + 1)) ‚Üí Œ± ‚Üí Œ±) (x : Œ±) :
    foldr' (n + 1) f x = f 0 (foldr' n (f ‚àò succ) x)

@[simp]
theorem rightpad_apply_ge (n : ‚Ñï) (a : Œ±) (v : Fin m ‚Üí Œ±) (i : Fin n)
    (h : m ‚â§ i.val) : rightpad n a v i = a

theorem fold_advances_evaluation_poly
  (i : Fin (‚Ñì)) (h_i_succ_lt : i + 1 < ‚Ñì + ùì°)
  (coeffs : Fin (2 ^ (‚Ñì - ‚Üëi)) ‚Üí L) (r_chal : L) :
  let P_i : L[X] := intermediateEvaluationPoly ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i, by
    exact Nat.lt_trans (n := i) (k := ‚Ñì+1) (m := ‚Ñì) (h‚ÇÅ := i.isLt) (by exact Nat.lt_add_one ‚Ñì)
  ‚ü©) coeffs
  let f_i

lemma round_bound {n k : ‚Ñï} {s : Fin (k + 1) ‚Üí ‚Ñï+} {d : ‚Ñï+}
    (domain_size_cond : (2 ^ (‚àë i, (s i).1)) * d ‚â§ 2 ^ n) :
  (‚àë i, (s i).1) ‚â§ n

omit [(i : Œπ‚Çõ) ‚Üí OracleInterface (OStatement i)] [OracleInterface Witness] in
theorem oracleProver_run {stmt : Statement} {oStmt : ‚àÄ i, OStatement i} {wit : Witness} :
    (oracleProver oSpec Statement OStatement Witness).run ‚ü®stmt, oStmt‚ü© wit =
      pure (fun i => by aesop, ‚ü®stmt, Sum.rec oStmt (fun _ => wit)‚ü©, ())

theorem vcons_eq_const (a : Œ±) : a ::·µõ (fun _ : Fin n => a) = fun _ => a

lemma lin_shift_e [Field F] [Fintype F]
  (h_B : B.card ‚â† 0)
  :
  e B v = e ({ x - v | x ‚àà B} : Finset _) 0

lemma Lemma_A_1 {H : F[X][Y]} (Œ≤ : ùí™ H) (D : ‚Ñï) (hD : D ‚â• Bivariate.totalDegree H)
    (S_Œ≤_card : Set.ncard (S_Œ≤ Œ≤) > (weight_Œõ_over_ùí™ Œ≤ D) * H.natDegree) :
  embeddingOfùí™IntoùïÉ _ Œ≤ = 0

@[simp] lemma mod_two_eq_zero (m : ‚Ñ§) : m % 2 = ( - m) % 2

theorem drop_append_left {n' : ‚Ñï} {Œ± : Sort*} (m : ‚Ñï) (h : m ‚â§ n) (u : (i : Fin n) ‚Üí Œ±)
    (v : (i : Fin n') ‚Üí Œ±) :
      drop m (Nat.le_add_right_of_le h) (append u v) =
          append (drop m h u) v ‚àò Fin.cast (by omega)

theorem pow_zero {a : CNat 50} : a ^ 0 = 1

@[simp]
theorem FullData.ofFun_get {Œ±} {s} (tree : FullData Œ± s) :
    FullData.ofFun s (fun idx => tree.get idx) = tree

lemma duplexSpongeToFSGameStatDist
    (maliciousProver : OracleComp (oSpec ++‚Çí duplexSpongeChallengeOracle StmtIn U)
      (StmtIn √ó pSpec.Messages))
    (t‚Çí : Œπ ‚Üí ‚Ñï) (t‚Çï t‚Çö t‚Çö·µ¢ : ‚Ñï)
    -- TODO: state query bound only for subset of the oracles
    (hQuery : IsQueryBound maliciousProver (t‚Çí ‚äï·µ• (t‚Çï ‚äï·µ• (t‚Çö ‚äï·µ• t‚Çö·µ¢)))) : True

@[simp]
theorem cast_idx_symm {i : ChallengeIdx pSpec‚ÇÇ} :
    pSpec‚ÇÅ.Challenge (i.cast hn.symm (cast_symm hSpec)) = pSpec‚ÇÇ.Challenge i

@[simp]
theorem cast_id : Transcript.cast rfl rfl rfl = (id : pSpec‚ÇÅ.Transcript k ‚Üí _)

lemma toOutCodewordsCount_mul_œë_eq_i_succ (i : Fin ‚Ñì) (hCR : isCommitmentRound ‚Ñì œë i) :
  (toOutCodewordsCount ‚Ñì œë i.castSucc) * œë = i.val + 1

omit O‚Çò in
theorem seqCompose_perfectCompleteness (hInit : init.neverFails)
    (rel : (i : Fin (m + 1)) ‚Üí Set (Stmt i √ó Wit i))
    (R : ‚àÄ i, Reduction oSpec (Stmt i.castSucc) (Wit i.castSucc) (Stmt i.succ) (Wit i.succ)
      (pSpec i))
    (h : ‚àÄ i, (R i).perfectCompleteness init impl (rel i.castSucc) (rel i.succ)) :
      (Reduction.seqCompose Stmt Wit R).perfectCompleteness
        init impl (rel 0) (rel (Fin.last m))

theorem findIdxRev?_eq_some {cond} {as : Array Œ±} (h : ‚àÉ i, ‚àÉ hi : i < as.size, cond as[i]) :
  ‚àÉ k : Fin as.size, findIdxRev? cond as = some k

theorem vconcat_left_injective {n : ‚Ñï} (a : Œ±) :
    Function.Injective (fun v : Fin n ‚Üí Œ± => vconcat v a)

@[simp] lemma extract_dir : pSpec‚ü¶start:stop‚üß.dir = pSpec.dir‚ü¶start:stop‚üß

omit [Finite F] in
lemma D_def : evalDomain D x 0 = x ‚Ä¢ D

omit [Finite F] in
private lemma witness_lift {F : Type} [NonBinaryField F]
  {k : ‚Ñï} {s : Fin (k + 1) ‚Üí ‚Ñï+} {d : ‚Ñï+} {p : F[X]} {Œ± : F} {i : Fin (k + 1)} :
    p ‚àà Witness F s d i.castSucc ‚Üí
      p.foldNth (2 ^ (s i).1) Œ± ‚àà Witness F s d i.succ

theorem prime_17 : Nat.Prime 17

@[simp]
lemma aeval_C {A : Type w} [CommSemiring A] [Algebra R A] (x : A) (r : R) :
    (aeval x) (C r : P) = algebraMap R A r

@[simp]
theorem singleEqPolynomial_zero (x : MvPolynomial œÉ R) : singleEqPolynomial (0 : R) x = 1 - x

Fin.is_le in Init.Data.Fin.Lemmas

private lemma choose_2_eq_half_f :
  choose_2 = (1/2) * f

private lemma sum_sum_K_i_eq_n_sub_d
  (h_B : 2 ‚â§ B.card)
  :
  ‚àë i, sum_choose_K_i B i = choose_2 B.card * (n - d B)

lemma and_eq_zero_iff_and_each_getBit_eq_zero {n m : ‚Ñï} :
    n &&& m = 0 ‚Üî ‚àÄ k, Nat.getBit k n &&& Nat.getBit k m = 0

theorem concreteTowerAlgebraMap_assoc :
    ‚àÄ r mid l : ‚Ñï, (h_l_le_mid : l ‚â§ mid) ‚Üí (h_mid_le_r : mid ‚â§ r) ‚Üí
    concreteTowerAlgebraMap (l:=l) (r:=r) (h_le:=by exact Nat.le_trans h_l_le_mid h_mid_le_r) =
    (concreteTowerAlgebraMap (l:=mid) (r:=r) (h_le:=h_mid_le_r)).comp
    (concreteTowerAlgebraMap (l:=l) (r:=mid) (h_le:=h_l_le_mid))

omit [NeZero ‚Ñì] in
lemma fin_‚Ñì_steps_lt_‚Ñì_add_one (i : Fin ‚Ñì) (steps : ‚Ñï)
    (h : i.val + steps ‚â§ ‚Ñì) : i.val + steps < ‚Ñì + 1

congrArg in Init.Prelude

Nat.sub_lt_left_of_lt_add in Init.Data.Nat.Basic

theorem MLE_mem_restrictDegree (evals : (œÉ ‚Üí Fin 2) ‚Üí R) : (MLE evals) ‚àà R‚¶É‚â§ 1‚¶Ñ[X œÉ]

@[simp]
theorem init_update_last : init (update s (Fin.last n) y) = init s

@[simp]
theorem fappend‚ÇÇ_succ {Œ±‚ÇÅ : Fin m ‚Üí A} {Œ±‚ÇÇ : Fin m ‚Üí B}
    {Œ≤‚ÇÅ : Fin (n + 1) ‚Üí A} {Œ≤‚ÇÇ : Fin (n + 1) ‚Üí B}
    (u : (i : Fin m) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i)) (v : (i : Fin (n + 1)) ‚Üí F‚ÇÇ (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) :
    fappend‚ÇÇ (F := F‚ÇÇ) u v =
      fconcat‚ÇÇ (F := F‚ÇÇ) (fappend‚ÇÇ (F := F‚ÇÇ) u (fun i => v (castSucc i))) (v (last n))

@[simp]
theorem InternalData.leftSubtree_internal {Œ±} {s_left s_right : Skeleton}
    (value : Œ±) (left : InternalData Œ± s_left) (right : InternalData Œ± s_right) :
    (InternalData.internal value left right).leftSubtree = left

theorem srSoundness_addSalt_implies_srSoundness_original
    (langIn : Set StmtIn) (langOut : Set StmtOut)
    (Salt : pSpec.MessageIdx ‚Üí Type) [‚àÄ i, Nonempty (Salt i)] [‚àÄ i, Fintype (Salt i)]
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    (srInit : ProbComp (srChallengeOracle StmtIn (pSpec.addSalt Salt)).FunctionType)
    (srImpl : QueryImpl oSpec
      (StateT (srChallengeOracle StmtIn (pSpec.addSalt Salt)).FunctionType ProbComp))
    (srSoundnessError : ‚Ñù‚â•0) :
      Verifier.StateRestoration.soundness srInit srImpl langIn langOut
        (verifier.addSalt Salt) srSoundnessError ‚Üí
        Verifier.StateRestoration.soundness sorry sorry langIn langOut
          verifier srSoundnessError

@[simp]
theorem Vector.ofFn_get {Œ± : Type*} {n : ‚Ñï} (v : Vector Œ± n) : Vector.ofFn (Vector.get v) = v

theorem induction_heq {n n' : ‚Ñï} {motive : Fin (n + 1) ‚Üí Sort u} {motive' : Fin (n' + 1) ‚Üí Sort u}
    {zero : motive 0} {zero' : motive' 0}
    {succ : ‚àÄ i : Fin n, motive i.castSucc ‚Üí motive i.succ}
    {succ' : ‚àÄ i : Fin n', motive' i.castSucc ‚Üí motive' i.succ}
    {i : Fin (n + 1)} {i' : Fin (n' + 1)}
    (hn : n = n') (hmotive : HEq motive motive') (hzero : HEq zero zero')
    (hsucc : HEq succ succ') (hi : HEq i i') :
      HEq (induction (motive := motive) zero succ i)
        (induction (motive := motive') zero' succ' i')

theorem prime_101 : Nat.Prime 101

@[simp]
theorem vappend_left (u : Fin m ‚Üí Œ±) (v : Fin n ‚Üí Œ±) (i : Fin m) :
    vappend u v (castAdd n i) = u i

theorem add_comm : p + q = q + p

theorem towerAlgebraMap_succ_last (r : ‚Ñï) : ‚àÄ l : ‚Ñï, (h_le : l ‚â§ r) ‚Üí
  towerAlgebraMap (l:=l) (r:=r+1) (h_le:=by
    exact Nat.le_trans (n:=l) (m:=r) (k:=r+1) (h_le) (by omega)) =
  (towerAlgebraMap (l:=l+1) (r:=r+1) (by omega)).comp (towerAlgebraMap
    (l:=l) (r:=l+1) (by omega))

@[simp]
theorem OracleSpec.append_range_right {Œπ‚ÇÅ Œπ‚ÇÇ : Type} {spec‚ÇÅ : OracleSpec Œπ‚ÇÅ} {spec‚ÇÇ : OracleSpec Œπ‚ÇÇ}
    (i : Œπ‚ÇÇ) : (spec‚ÇÅ ++‚Çí spec‚ÇÇ).range (Sum.inr i) = spec‚ÇÇ.range i

private lemma solutionToQ_from_Q
  (h_p_deg : p.natDegree < k)
  (h_dist : (Œî‚ÇÄ(f, p.eval ‚àò œâs) : ‚Ñï) ‚â§ e)
  : solutionToQ e k (E_and_Q_to_a_solution e (E œâs f p e) (Q œâs f p e)) = Q œâs f p e

@[simp]
lemma erase_odd_empty :
    erase_odd ‚àÖ = ‚àÖ

@[simp]
theorem LeafData.leftSubtree_internal {Œ±} {s_left s_right : Skeleton}
    (left : LeafData Œ± s_left) (right : LeafData Œ± s_right) :
    (LeafData.internal left right).leftSubtree = left

@[simp] theorem rightpadPowerOfTwo_size (unit : Œ±) (a : Array Œ±) :
    (a.rightpadPowerOfTwo unit).size = 2 ^ (Nat.clog 2 a.size)

omit [Finite F] in
lemma pow_lift : ‚àÄ {a : FÀ£} {i : ‚Ñï} (s : ‚Ñï),
    a ‚àà evalDomain D x i ‚Üí a ^ (2 ^ s) ‚àà evalDomain D x (i + s)

@[simp]
private lemma oddPart'_coeff {f : Polynomial F} {n : ‚Ñï} :
    (oddPart' f).coeff n = if Even n then f.coeff (n + 1) else 0

theorem rbrSoundness_implies_soundness (langIn : Set StmtIn) (langOut : Set StmtOut)
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    (rbrSoundnessError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) :
      rbrSoundness init impl langIn langOut verifier rbrSoundnessError ‚Üí
        soundness init impl langIn langOut verifier (‚àë i, rbrSoundnessError i)

@[simp, grind _=_]
lemma degreeY_mul [IsDomain F] (f g : F[X][Y]) (hf : f ‚â† 0) (hg : g ‚â† 0)
  : natDegreeY (f * g) = natDegreeY f + natDegreeY g

@[simp]
lemma Rhs_add_one : Rhs (e + 1) œâs f = fun i ‚Ü¶ Rhs e œâs f i * œâs i

theorem PrattCertificate'.out {p : ‚Ñï} (c : PrattCertificate' p) : p.Prime

theorem dconcat_right_injective {motive : Fin (n + 1) ‚Üí Sort u}
    (v : (i : Fin n) ‚Üí motive (castSucc i)) :
    Function.Injective (dconcat (motive := motive) v)

theorem append_knowledgeSoundness (V‚ÇÅ : Verifier oSpec Stmt‚ÇÅ Stmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : Verifier oSpec Stmt‚ÇÇ Stmt‚ÇÉ pSpec‚ÇÇ)
    {knowledgeError‚ÇÅ knowledgeError‚ÇÇ : ‚Ñù‚â•0}
    (h‚ÇÅ : V‚ÇÅ.knowledgeSoundness init impl rel‚ÇÅ rel‚ÇÇ knowledgeError‚ÇÅ)
    (h‚ÇÇ : V‚ÇÇ.knowledgeSoundness init impl rel‚ÇÇ rel‚ÇÉ knowledgeError‚ÇÇ) :
      (V‚ÇÅ.append V‚ÇÇ).knowledgeSoundness init impl
        rel‚ÇÅ rel‚ÇÉ (knowledgeError‚ÇÅ + knowledgeError‚ÇÇ)

lemma degree_bound_bivariate
  (qPoly : Polynomial F)
  (hdeg_q_min : qPoly.natDegree > 0)
  (hdeg_q_max : qPoly.natDegree < Fintype.card F)
  {t : ‚Ñï} (Q : MvPolynomial (Fin 2) F)
  (hdegX : MvPolynomial.degreeOf 0 Q < t)
  (hdegY : MvPolynomial.degreeOf 1 Q < qPoly.natDegree) :
  (MvPolynomial.eval‚ÇÇHom (Polynomial.C : F ‚Üí+* Polynomial F)
      (fun i : Fin 2 => if i = 0 then qPoly else Polynomial.X) Q).natDegree < t * qPoly.natDegree

theorem BitVec.eq_mp_eq_dcast {w w2 : ‚Ñï} (x : BitVec w) (h_width_eq : w = w2)
  (h_bitvec_eq : BitVec w = BitVec w2 := by rw [h_width_eq]) :
  Eq.mp (h:=h_bitvec_eq) (a:=x) = dcast (h_width_eq) (x)

theorem prime_13 : Nat.Prime 13

Nat.add_left_cancel in Init.Data.Nat.Basic

theorem snoc_ne_zero_iff : snoc s y ‚â† 0 ‚Üî s ‚â† 0 ‚à® y ‚â† 0

theorem degrees_C_mul_le (p : MvPolynomial œÉ R) (c : R) : (C c * p).degrees ‚â§ p.degrees

Nat.le_of_succ_le in Init.Data.Nat.Basic

theorem distanceLE_polynomial_degreeLE : distanceLE (R‚¶É‚â§ d‚¶Ñ[X]) d

theorem GF_2_value_eq_zero_or_one (x : GF(2)) : x = 0 ‚à® x = 1

lemma smul_Z_eq_zero_x {k : ‚Ñï} (h_pos : k > 0) (x : ConcreteBTField (k - 1)) :
  letI instAlgebra := ConcreteBTFieldAlgebra (l:=k-1) (r:=k) (h_le:=by omega)
  x ‚Ä¢ Z k = „Ää x, 0 „Äã

omit [NeZero ‚Ñì] [NeZero r] [NeZero ùì°] in
lemma ‚Ñì_lt_r {h_‚Ñì_add_R_rate : ‚Ñì + ùì° < r}
    : ‚Ñì < r

lemma fold_f_g_poly
  {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F} {k m : ‚Ñï}
  {œÜ_0 : (indexPowT S œÜ 0) ‚Ü™ F} {œÜ_k : (indexPowT S œÜ k) ‚Ü™ F}
  [Fintype (indexPowT S œÜ 0)] [DecidableEq (indexPowT S œÜ 0)] [Smooth œÜ_0]
  [Fintype (indexPowT S œÜ k)] [DecidableEq (indexPowT S œÜ k)] [Smooth œÜ_k]
  [‚àÄ i : ‚Ñï, Neg (indexPowT S œÜ i)]
  (Œ±s : Fin k ‚Üí F) (hk : k ‚â§ m)
  (f : smoothCode œÜ_0 m) (g : smoothCode œÜ_k (m-k)) :
  let fPoly

@[ext] theorem UniPolyC.ext {p q : UniPolyC R} (h : p.val = q.val) : p = q

private lemma sum_of_not_equals :
  ‚àë x ‚àà B √óÀ¢ B with x.1 ‚â† x.2, (if x.1 i ‚â† x.2 i then 1 else 0)
  =
  2 * choose_2 #B - 2 * ‚àë Œ±, choose_2 (K B i Œ±)

theorem add_assoc (m n p : ChurchNat Œ±) : add (add m n) p = add m (add n p)

lemma nonDoomedFoldingProp_relay_preserved (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i)
    (challenges : Fin i.succ ‚Üí L)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j)
    :
    nonDoomedFoldingProp ùîΩq Œ≤ i.castSucc (Fin.init challenges) oStmt ‚Üî
    nonDoomedFoldingProp ùîΩq Œ≤ i.succ challenges (mapOStmtOutRelayStep ùîΩq Œ≤ i hNCR oStmt)

theorem succ'_injective : Function.Injective (succ' : Nat ‚Üí Nat)

lemma oracle_block_k_next_le (i : Fin (‚Ñì + 1)) (j : Fin (toOutCodewordsCount ‚Ñì œë i))
    (hj : j.val + 1 < toOutCodewordsCount ‚Ñì œë i) : j.val * œë + œë ‚â§ i

theorem BaseField_is_prime : Nat.Prime baseFieldSize

Nat.lt_trans in Init.Prelude

@[simp]
theorem rightpad_apply_lt (n : ‚Ñï) (a : Œ±) (v : Fin m ‚Üí Œ±) (i : Fin n)
    (h : i.val < m) : rightpad n a v i = v ‚ü®i.val, h‚ü©

lemma concrete_mul_left_distrib
  {h_k : k > 0} (prevBTFieldProps : ConcreteBTFieldProps (k := k - 1))
  (a b c : ConcreteBTField k) :
    concrete_mul a (b + c) = concrete_mul a b + concrete_mul a c

theorem insertNth_zero_eq_cases {n : ‚Ñï} {Œ± : Fin (n + 1) ‚Üí Sort u} :
    insertNth 0 = cases (motive := Œ±)

omit [DecidableEq L] h_Fq_char_prime hF‚ÇÇ hŒ≤_lin_indep in
lemma Prod_W_comp_X_sub_C_ne_zero (i : Fin r) :
    (univ : Finset ùîΩq).prod (fun c => (W ùîΩq Œ≤ i).comp (X - C (c ‚Ä¢ Œ≤ i))) ‚â† 0

theorem foldOracleReduction_perfectCompleteness (hInit : init.neverFails) (i : Fin ‚Ñì) :
    OracleReduction.perfectCompleteness
      (pSpec := pSpecFold (L := L))
      (relIn := roundRelation ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        (ùìë := ùìë) i.castSucc (mp := mp))
      (relOut := foldStepRelOut ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        (ùìë := ùìë) i (mp := mp))
      (oracleReduction := foldOracleReduction ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i)
      (init := init)
      (impl := impl)

@[simp]
lemma degreeX_monomialXY {n m : ‚Ñï} {a : F} (ha : a ‚â† 0) :
    degreeX (monomialXY n m a) = n

@[simp]
theorem splitSum_succ {n : Fin (m + 1) ‚Üí ‚Ñï} {k : Fin (vsum n)} :
    splitSum k = Fin.dappend
      (fun k => ‚ü®0, k‚ü©)
      (fun k => ‚ü®(splitSum k).1.succ, (splitSum k).2‚ü©)
      k

lemma solutionToQ_ne_zero {e k : ‚Ñï}
  [NeZero n]
  {œâs f : Fin n ‚Üí F}
  {v : Fin (2 * e + k) ‚Üí F}
  (h_dist : e < Œî‚ÇÄ(f, 0))
  (h_sol : IsBerlekampWelchSolution e k œâs f v)
  (h_inj : Function.Injective œâs)
  : solutionToQ e k v ‚â† 0

lemma join_via_add_smul_one {k : ‚Ñï} (h_pos : k > 0) :
  ‚ãò 0, 1 ‚ãô = 1

theorem getBit_repr {‚Ñì : Nat} : ‚àÄ j, j < 2^‚Ñì ‚Üí
  j = ‚àë k ‚àà Finset.Icc 0 (‚Ñì-1), (getBit k j) * 2^k

@[to_additive]
theorem prod_Iio_succ (i : Fin n) :
    ‚àè j ‚àà Iio i.succ, v j = (‚àè j ‚àà Iio i.castSucc, v j) * v i.castSucc

lemma evenize_eval {f : Polynomial F} {s : F} :
    (evenize f).eval s = f.eval (s * s)

@[simp]
theorem getLastI_append_single [Inhabited Œ±] (x : Œ±) : (l ++ [x]).getLastI = x

lemma card_le_card_of_count_inj {Œ± Œ≤ : Type*} [DecidableEq Œ±] [DecidableEq Œ≤]
    {s : Multiset Œ±} {s' : Multiset Œ≤}
  {f : Œ± ‚Üí Œ≤} (inj : Function.Injective f) (h : ‚àÄ a : Œ±, s.count a ‚â§ s'.count (f a)) :
  s.card ‚â§ s'.card

lemma folding_steps_pos : (œë : ‚Ñï) > 0

theorem srKnowledgeSoundness_addSalt_implies_srKnowledgeSoundness_original
    (relIn : Set (StmtIn √ó WitIn)) (relOut : Set (StmtOut √ó WitOut))
    (Salt : pSpec.MessageIdx ‚Üí Type) [‚àÄ i, Nonempty (Salt i)] [‚àÄ i, Fintype (Salt i)]
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    (srInit : ProbComp (srChallengeOracle StmtIn (pSpec.addSalt Salt)).FunctionType)
    (srImpl : QueryImpl oSpec
      (StateT (srChallengeOracle StmtIn (pSpec.addSalt Salt)).FunctionType ProbComp))
    (srKnowledgeError : ‚Ñù‚â•0) :
      Verifier.StateRestoration.knowledgeSoundness srInit srImpl relIn relOut
        (verifier.addSalt Salt) srKnowledgeError ‚Üí
        Verifier.StateRestoration.knowledgeSoundness sorry sorry relIn relOut
          verifier srKnowledgeError

private lemma errors_are_roots_of_E {i : Fin n}
  (h : f i ‚â† p.eval (œâs i)) : (E œâs f p e).eval (œâs i) = 0

@[simp]
theorem verifier_last_of_two (pSpec : ProtocolSpec 2) [VerifierLast pSpec] :
    pSpec.dir 1 = .V_to_P

theorem zero_add {n : ‚Ñï} (a : CNat (n + 1)) : 0 + a = a

theorem liftContext_runWithLog
    {lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    {outerStmtIn : OuterStmtIn} {outerWitIn : OuterWitIn}
    {P : Prover oSpec InnerStmtIn InnerWitIn InnerStmtOut InnerWitOut pSpec} :
      (P.liftContext lens).runWithLog outerStmtIn outerWitIn
      = do
        let ‚ü®‚ü®fullTranscript, innerCtxOut‚ü©, queryLog‚ü© ‚Üê
          P.runWithLog.uncurry (lens.proj (outerStmtIn, outerWitIn))
        return ‚ü®‚ü®fullTranscript, lens.lift (outerStmtIn, outerWitIn) innerCtxOut‚ü©, queryLog‚ü©

@[simp, grind _=_]
lemma degreeX_mul [IsDomain F] (f g : F[X][Y]) (hf : f ‚â† 0) (hg : g ‚â† 0) :
  degreeX (f * g) = degreeX f + degreeX g

theorem induct [LawfulBEq R] {motive : UniPoly R ‚Üí Prop}
  (case1 : ‚àÄ p, p.trim = #[] ‚Üí (‚àÄ i, (hi : i < p.size) ‚Üí p[i] = 0) ‚Üí motive p)
  (case2 : ‚àÄ p : UniPoly R, ‚àÄ k : Fin p.size, p.trim = p.extract 0 (k + 1)
    ‚Üí p[k] ‚â† 0 ‚Üí (‚àÄ j : ‚Ñï, (hj : j < p.size) ‚Üí j > k ‚Üí p[j] = 0) ‚Üí motive p)
  (p : UniPoly R) : motive p

lemma out_of_dom_smpl_2
  {Œ¥ l : ‚Ñù‚â•0} {s : ‚Ñï} {f : Œπ ‚Üí F} {degree : ‚Ñï} {œÜ : Œπ ‚Ü™ F}
  (C : Set (Œπ ‚Üí F)) (hC : C = code œÜ degree)
  (h_decodable : listDecodable C Œ¥ l)
  (h_nonempty : Nonempty (domainComplement œÜ)) :
  listDecodingCollisionProbability œÜ f Œ¥ s degree h_nonempty ‚â§
    ((l^2 / 2)) * (degree / (Fintype.card F - Fintype.card Œπ))^s

theorem fcons_injective2 {Œ≤ : Fin n ‚Üí A} :
    Function.Injective2 (@fcons A F n Œ± Œ≤)

theorem seqCompose_perfectCompleteness (hInit : init.neverFails)
    (rel : (i : Fin (m + 1)) ‚Üí Set ((Stmt i √ó ‚àÄ j, OStmt i j) √ó Wit i))
    (R : ‚àÄ i, OracleReduction oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Wit i.castSucc)
      (Stmt i.succ) (OStmt i.succ) (Wit i.succ) (pSpec i))
    (h : ‚àÄ i, (R i).perfectCompleteness init impl (rel i.castSucc) (rel i.succ)) :
      (OracleReduction.seqCompose Stmt OStmt Wit R).perfectCompleteness
        init impl (rel 0) (rel (Fin.last m))

theorem PowerBasis_cast_dest_eq (k n m : ‚Ñï) (h_k_le_n : k ‚â§ n)
  (h_k_le_m : k ‚â§ m) (h_eq : m = n) :
  letI instLeftAlgebra := ConcreteBTFieldAlgebra (l:=k) (r:=m) (h_le:=h_k_le_m)
  letI instRightAlgebra := ConcreteBTFieldAlgebra (l:=k) (r:=n) (h_le:=h_k_le_n)
  @PowerBasis (ConcreteBTField k) (ConcreteBTField m) _ _ instLeftAlgebra =
  @PowerBasis (ConcreteBTField k) (ConcreteBTField n) _ _ instRightAlgebra

theorem correlatedAgreement_affine_curves [DecidableEq Œπ] {k : ‚Ñï} {u : Fin k ‚Üí Œπ ‚Üí F}
  {deg : ‚Ñï} {domain : Œπ ‚Ü™ F} {Œ¥ : ‚Ñù‚â•0}
  (hŒ¥ : Œ¥ ‚â§ 1 - ReedSolomonCode.sqrtRate deg domain)
  (hproximity :
    Pr_{let y ‚Üê $·µñ (Curve.parametrisedCurveFinite u)}[
      Code.relHammingDistToCode y.1 (ReedSolomon.code domain deg) ‚â§ Œ¥
    ] >
      k * (errorBound Œ¥ deg domain)) :
  correlatedAgreement (ReedSolomon.code domain deg) Œ¥ u

@[simp]
theorem fflatten_succ {A : Sort u} {F : A ‚Üí Sort v} {m : ‚Ñï} {n : Fin (m + 1) ‚Üí ‚Ñï}
    {Œ± : (i : Fin (m + 1)) ‚Üí (j : Fin (n i)) ‚Üí A}
    {v : (i : Fin (m + 1)) ‚Üí (j : Fin (n i)) ‚Üí F (Œ± i j)} :
    fflatten v = fappend (v 0) (fflatten (fun i => v i.succ))

theorem prime_29 : Nat.Prime 29

@[simp]
theorem tail_vcons (a : Œ±) (v : Fin n ‚Üí Œ±) : tail (a ::·µõ v) = v

@[simp]
theorem cast_id : Verifier.cast rfl rfl = (id : Verifier oSpec StmtIn StmtOut pSpec‚ÇÅ ‚Üí _)

@[simp]
theorem leftpad_apply_lt (n : ‚Ñï) (a : Œ±) (v : Fin m ‚Üí Œ±) (i : Fin n)
    (h : i.val < n - m) : leftpad n a v i = a

theorem basis_repr_of_sDomain_lift (i j : Fin r) (h_j : j < ‚Ñì + R_rate) (h_le : i ‚â§ j)
    (y : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := j)) :
    let x‚ÇÄ := sDomain.lift ùîΩq Œ≤ h_‚Ñì_add_R_rate i j (by omega) (by omega) y
    ‚àÄ k: Fin (‚Ñì + R_rate - i),
      (sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := i) (h_i := by omega)).repr x‚ÇÄ k =
        if hk: k < (j.val - i.val) then 0
        else (sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := j)
          (h_i := by omega)).repr y ‚ü®k - (j.val - i.val), by omega‚ü©

@[simp] lemma drop_dir : pSpec‚ü¶m:‚üß.dir = pSpec.dir‚ü¶m:‚üß

@[simp]
lemma shift_left_empty :
    shift_left ‚àÖ = ‚àÖ

@[simp]
theorem lagrangeBasis_zero {w : Vector R 0} : lagrangeBasis w = #v[1]

omit [Fintype L] [Fintype ùîΩq] h_Fq_char_prime in
lemma finrank_U (i : Fin r) :
  Module.finrank ùîΩq (U ùîΩq Œ≤ i) = i

lemma or_by_split_lowBits {n m n1 m1 bn bm : ‚Ñï} (h_bn : bn < 2) (h_bm : bm < 2)
  (h_n : n = n1 * 2 + bn) (h_m : m = m1 * 2 + bm):
  n ||

@[simp]
lemma lin_shift_hamming_distance [Field F] {x‚ÇÅ x‚ÇÇ v : Fin n ‚Üí F}
  :
  Œî‚ÇÄ(x‚ÇÅ - v, x‚ÇÇ - v) = Œî‚ÇÄ(x‚ÇÅ, x‚ÇÇ)

@[simp]
theorem oracleReduction_completeness (h : init.neverFails) :
    (oracleReduction oSpec Statement OStatement Witness).perfectCompleteness init impl oRelIn
    (toORelOut oRelIn)

theorem elim [LawfulBEq R] (p : UniPoly R) :
    (p.trim = #[] ‚àß  (‚àÄ i, (hi : i < p.size) ‚Üí p[i] = 0))
  ‚à® (‚àÉ k : Fin p.size,
        p.trim = p.extract 0 (k + 1)
      ‚àß p[k] ‚â† 0
      ‚àß (‚àÄ j : ‚Ñï, (hj : j < p.size) ‚Üí j > k ‚Üí p[j] = 0))

theorem dconcat_dcons_eq_dcons_dconcat {motive : Fin (n + 2) ‚Üí Sort u} (a : motive 0)
    (v : (i : Fin n) ‚Üí motive (succ (castSucc i))) (b : motive (last (n + 1))) :
    (a ::·µà v) :+·µà‚ü®motive‚ü© b = a ::·µà‚ü®motive‚ü© (v :+·µà b)

theorem singleEqPolynomial_zeroOne (r : Fin 2) (x : MvPolynomial œÉ R) :
    singleEqPolynomial (r : R) x = if r = 0 then 1 - x else x

@[simp]
theorem Verifier.id_soundness {lang : Set StmtIn} :
    (Verifier.id : Verifier oSpec _ _ _).soundness init impl lang lang 0

lemma addSalt_Challenge (i : pSpec.ChallengeIdx) :
    (pSpec.addSalt Salt).Challenge i = pSpec.Challenge i

theorem foldRelayOracleReduction_perfectCompleteness
    (hInit : init.neverFails) (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
  OracleReduction.perfectCompleteness
    (pSpec := pSpecFoldRelay (L:=L))
    (relIn := roundRelation (mp := mp) ùîΩq Œ≤ (œë:=œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) i.castSucc)
    (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë:=œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) i.succ)
    (oracleReduction := foldRelayOracleReduction ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (ùìë:=ùìë) i hNCR) (init := init) (impl := impl)

@[simp]
lemma challengeOracleInterface_append_domain_inl (j : pSpec‚ÇÅ.ChallengeIdx) :
    [(pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).Challenge]‚Çí.domain (.inl j) = Unit

theorem dfoldl_dcast {Œπ : Type v} {Œ≤ : Œπ ‚Üí Type u} [DCast Œπ Œ≤]
    {n : ‚Ñï} {Œ± Œ±' : Fin (n + 1) ‚Üí Œπ}
    {f : (i : Fin n) ‚Üí Œ≤ (Œ± i.castSucc) ‚Üí Œ≤ (Œ± i.succ)} {init : Œ≤ (Œ± 0)}
    (hŒ± : ‚àÄ i, Œ± i = Œ±' i) :
      dcast (hŒ± (last n)) (dfoldl n (fun i => Œ≤ (Œ± i)) f init) =
        dfoldl n (fun i => Œ≤ (Œ±' i))
          (fun i a => dcast (hŒ± _) (f i (dcast (hŒ± _).symm a))) (dcast (hŒ± 0) init)

@[simp]
lemma seqCompose_succ {m : ‚Ñï}
    (Stmt : Fin (m + 2) ‚Üí Type) (Wit : Fin (m + 2) ‚Üí Type)
    {n : Fin (m + 1) ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (P : (i : Fin (m + 1)) ‚Üí
      Prover oSpec (Stmt i.castSucc) (Wit i.castSucc) (Stmt i.succ) (Wit i.succ) (pSpec i)) :
    seqCompose Stmt Wit P =
      append (P 0) (seqCompose (Stmt ‚àò Fin.succ) (Wit ‚àò Fin.succ) (fun i => P (Fin.succ i)))

lemma nsmul_succ {k : ‚Ñï} (n : ‚Ñï) (x : ConcreteBTField k) :
  (if ‚Üën.succ % 2 = 0 then zero else x) = (if ‚Üën % 2 = 0 then zero else x) + x

@[simp]
lemma dfoldlM'_succ {n : ‚Ñï} {Œ± : Fin (n + 2) ‚Üí Type u}
    (f : (i : Fin (n + 1)) ‚Üí Œ± i.castSucc ‚Üí m (Œ± i.succ)) (x : Œ± 0) :
    dfoldlM' (n + 1) Œ± f x = (do
      let y ‚Üê dfoldlM' n (Œ± ‚àò castSucc) (fun i => f i.castSucc) x
      f (last n) y)

omit hF‚ÇÇ in
theorem W_linear_comp_decomposition (i : Fin r) (h_i_add_1 : i + 1 < r) :
    ‚àÄ p: L[X], (W ùîΩq Œ≤ (i + 1)).comp p =
      ((W ùîΩq Œ≤ i).comp p) ^ Fintype.card ùîΩq -
        C (eval (Œ≤ i) (W ùîΩq Œ≤ i)) ^ (Fintype.card ùîΩq - 1) * ((W ùîΩq Œ≤ i).comp p)

lemma forwardRange_getElem (n : ‚Ñï) (r : Fin n) (l : Fin (r.val + 1)) (k : Fin (r.val - l.val + 1)) :
    (forwardRange n r l).get ‚ü®k, by
      rw [forwardRange]; simp only [List.length_ofFn]; omega‚ü© = ‚ü®l.val + k, by omega‚ü©

theorem snoc_ne_zero_of_right (h : y ‚â† 0) : snoc s y ‚â† 0

theorem mul_zero (n : ChurchNat Œ±) : mul n zero = zero

@[simp]
theorem take_append_left :
    (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).take m (Nat.le_add_right m n) = pSpec‚ÇÅ

lemma schwartz_zippel' {p : MvPolynomial œÉ R} (hp : p ‚â† 0) (S : œÉ ‚Üí Finset R) :
    #{x ‚àà Finset.pi p.vars S | eval (extendDomain x) p = 0} / ‚àè i ‚àà p.vars, (#(S i) : ‚Ñö‚â•0)
      ‚â§ ‚àë i ‚àà p.vars, (p.degreeOf i / #(S i) : ‚Ñö‚â•0)

theorem insertNth_right_injective :
    Injective (Finsupp.insertNth p y : (Fin n ‚Üí‚ÇÄ M) ‚Üí Fin (n + 1) ‚Üí‚ÇÄ M)

theorem Iic_castSucc (i : Fin n) : Iic (castSucc i) = (Iic i).map Fin.castSuccEmb

@[simp]
theorem InternalData.rightSubtree_internal {Œ±} {s_left s_right : Skeleton}
    (value : Œ±) (left : InternalData Œ± s_left) (right : InternalData Œ± s_right) :
    (InternalData.internal value left right).rightSubtree = right

theorem split_Z {k : ‚Ñï} (h_pos : k > 0) :
    split h_pos (Z k) = (one (k:=k - 1), zero (k:=k - 1))

theorem fcons_right_injective {Œ≤ : Fin n ‚Üí A} (a : F Œ±) :
    Function.Injective (fcons a : ((i : Fin n) ‚Üí F (Œ≤ i)) ‚Üí (i : Fin (n + 1)) ‚Üí _)

@[simp, grind] lemma C_pos : 0 < sz.C

Fin.isLt in Init.Prelude

lemma fieldSize_sub_one_factorization : fieldSize - 1 = 2 ^ twoAdicity * 127

lemma add_eq_zero_iff_eq {k : ‚Ñï} (a b : ConcreteBTField k) : a + b = 0 ‚Üî a = b

theorem hcons_eq_hcons_iff {Œ≤ : Fin n ‚Üí Sort u} (a‚ÇÅ a‚ÇÇ : Œ±) (v‚ÇÅ v‚ÇÇ : (i : Fin n) ‚Üí Œ≤ i) :
    hcons a‚ÇÅ v‚ÇÅ = hcons a‚ÇÇ v‚ÇÇ ‚Üî a‚ÇÅ = a‚ÇÇ ‚àß v‚ÇÅ = v‚ÇÇ

Nat.lt_of_le_of_lt in Init.Prelude

@[simp]
theorem MLE_eval_zeroOne (x : œÉ ‚Üí Fin 2) (evals : (œÉ ‚Üí Fin 2) ‚Üí R) :
    MvPolynomial.eval (x : œÉ ‚Üí R) (MLE evals) = evals x

@[simp] theorem BitVec.cast_zero {n m : ‚Ñï} (h : n = m) : BitVec.cast h 0 = 0

theorem embedSum_succ {m : ‚Ñï} {n : Fin (m + 1) ‚Üí ‚Ñï} {i : Fin (m + 1)} (j : Fin (n i)) :
    embedSum i j = (match i with
    | 0 => Fin.castAdd _ j
    | ‚ü®i + 1, h‚ü© => Fin.natAdd _ (embedSum ‚ü®i, Nat.succ_lt_succ_iff.mp h‚ü© j))

@[simp]
theorem oracleReduction_completeness (h : init.neverFails)
    (hRel : ‚àÄ stmtIn oStmtIn witIn,
      ((stmtIn, oStmtIn), witIn) ‚àà relIn ‚Üí
      ((mapStmt stmtIn, mapOStmt embedIdx hEq oStmtIn), mapWit stmtIn witIn) ‚àà relOut) :
    (oracleReduction oSpec mapStmt mapWit embedIdx hEq).perfectCompleteness init impl
      relIn relOut

lemma mca_list_decoding
  [Fintype Œπ] [Nonempty Œπ]
  (Gen : ProximityGenerator Œπ F) [Fintype Gen.par‚Ñì]
  (Œ¥ BStar : ‚Ñù) (errStar : ‚Ñù ‚Üí ENNReal)
  (fs us : Matrix Gen.par‚Ñì Œπ F)
  (IC : InterleavedCode Gen.par‚Ñì Œπ F)
  (haveIC : IC = codeOfLinearCode Gen.par‚Ñì Gen.C)
      (hGen : hasMutualCorrAgreement Gen BStar errStar)
  (C : Set (Œπ ‚Üí F)) (hC : C = Gen.C) :
    haveI := Gen.Gen_nonempty
    ‚àÄ {fs : Matrix Gen.par‚Ñì Œπ F}
    (hŒ¥Pos : Œ¥ > 0) (hŒ¥Lt : Œ¥ < min (Œ¥·µ£ C : ‚Ñù) (1 - BStar)),
      Pr_{let r ‚Üê$·µñ Gen.Gen}[ proximityListDecodingCondition Gen.C r Œ¥ fs IC ]
        ‚â§ errStar Œ¥

theorem trim_equiv [LawfulBEq R] (p : UniPoly R) : equiv p.trim p

theorem one_mul (n : ChurchNat Œ±) : mul one n = n

lemma getBit_eq_succ_getBit_of_mul_two_add_one {n k : ‚Ñï} : getBit (k+1) (2*n + 1) = getBit k n

theorem generator_on_curve : let (x, y) := generator
  y^2 = x^3 + 3

theorem induction_append_left {m n : ‚Ñï} {motive : Fin (m + n + 1) ‚Üí Sort*} {zero : motive 0}
    {succ : ‚àÄ i : Fin (m + n), motive i.castSucc ‚Üí motive i.succ} {i : Fin (m + 1)} :
      induction (motive := motive) zero succ ‚ü®i, by omega‚ü© =
        @induction m (fun j => motive ‚ü®j, by omega‚ü©) zero (fun j x => succ ‚ü®j, by omega‚ü© x) i

@[simp] lemma twoAdicGenerators_length : twoAdicGenerators.length = twoAdicity + 1

theorem dotProduct_eq_root_dotProduct (a b : Vector R n) :
    dotProduct a b = _root_.dotProduct a.get b.get

Nat.sub_mul in Init.Data.Nat.Basic

@[csimp] lemma dfoldl_eq_dfoldl' : @dfoldl = @dfoldl'

theorem fconcat_left_injective {Œ± : Fin n ‚Üí A} {Œ≤ : A} (a : F Œ≤) :
    Function.Injective (fun v : (i : Fin n) ‚Üí F (Œ± i) => fconcat v a)

lemma not_inv_of_not_combined (h : ¬¨ E trace) : ¬¨ E_inv trace state

@[simp]
theorem oracleReduction_completeness (hInit : init.neverFails) :
    (oracleReduction oSpec OStatement).perfectCompleteness
      init impl (relIn OStatement) (relOut OStatement)

theorem nsmul_raw_succ (n : ‚Ñï) (p : UniPoly Q) :
  nsmul_raw (n + 1) p = add_raw (nsmul_raw n p) p

lemma and_by_split_lowBits {n m n1 m1 bn bm : ‚Ñï} (h_bn : bn < 2) (h_bm : bm < 2)
  (h_n : n = n1 * 2 + bn) (h_m : m = m1 * 2 + bm):
  n &&& m = (n1 &&& m1) * 2 + (bn &&& bm)

theorem inverse_is_root_of_prevPoly
    {prevBTField : Type*} [Field prevBTField]
    {curBTField : Type*} [Field curBTField]
    (of_prev : prevBTField ‚Üí+* curBTField)
    (u : curBTField) (t1 : prevBTField)
    (specialElementNeZero : u ‚â† 0)
    (eval_prevPoly_at_root : u ^ 2 + of_prev t1 * u + 1 = 0)
    (h_eval : ‚àÄ (x : curBTField),
      eval‚ÇÇ of_prev x (X ^ 2 + (C t1 * X + 1)) = x ^ 2 + of_prev t1 * x + 1) :
    eval‚ÇÇ of_prev u‚Åª¬π (X ^ 2 + (C t1 * X + 1)) = 0

theorem comp_x_square_coeff {f : Polynomial F} {n : ‚Ñï} :
  (f.comp (X * X)).coeff n = if Even n then f.coeff (n / 2) else 0

@[simp] theorem equiv_trans {p q r : UniPoly Q} : Trim.equiv p q ‚Üí equiv q r ‚Üí equiv p r

theorem append_knowledgeSoundness (V‚ÇÅ : OracleVerifier oSpec Stmt‚ÇÅ OStmt‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : OracleVerifier oSpec Stmt‚ÇÇ OStmt‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ pSpec‚ÇÇ)
    {knowledgeError‚ÇÅ knowledgeError‚ÇÇ : ‚Ñù‚â•0}
    (h‚ÇÅ : V‚ÇÅ.knowledgeSoundness init impl rel‚ÇÅ rel‚ÇÇ knowledgeError‚ÇÅ)
    (h‚ÇÇ : V‚ÇÇ.knowledgeSoundness init impl rel‚ÇÇ rel‚ÇÉ knowledgeError‚ÇÇ) :
      (V‚ÇÅ.append V‚ÇÇ).knowledgeSoundness init impl rel‚ÇÅ rel‚ÇÉ
        (knowledgeError‚ÇÅ + knowledgeError‚ÇÇ)

theorem liftContext_completeness
    (h : R.completeness init impl innerRelIn innerRelOut completenessError) :
      (R.liftContext lens).completeness init impl outerRelIn outerRelOut completenessError

lemma algebraMap_adjacent_tower_def (l : ‚Ñï) :
    (algebraMap (ConcreteBTField l) (ConcreteBTField (l + 1))) =
    canonicalAlgMap l

theorem cast_processRound (j : Fin n‚ÇÅ)
    (P : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec‚ÇÅ)
    (currentResult : OracleComp (oSpec ++‚Çí [pSpec‚ÇÅ.Challenge]‚Çí)
      (Transcript j.castSucc pSpec‚ÇÅ √ó P.PrvState j.castSucc)) :
    P.processRound j currentResult =
      cast (sorry) ((P.cast hn hSpec).processRound (Fin.cast hn j) sorry)

lemma toCodewordsCount_mul_œë_lt_‚Ñì (‚Ñì œë : ‚Ñï) [NeZero œë] [NeZero ‚Ñì] (i : Fin (‚Ñì + 1)) :
  ‚àÄ j: Fin (toOutCodewordsCount ‚Ñì œë i), j.val * œë < ‚Ñì

@[simp]
lemma foldr'_zero {Œ± : Type u} (f : (i : Fin 0) ‚Üí Œ± ‚Üí Œ±) (x : Œ±) :
    foldr' 0 f x = x

lemma fintype_card_gt_one_of_field (K : Type*) [Field K] [Fintype K] :
  1 < Fintype.card K

@[simp]
theorem dcast‚ÇÇ_eq : dcast‚ÇÇ (Eq.refl a) dcast_eq c = c

@[simp]
theorem dcons_succ {motive : Fin (n + 1) ‚Üí Sort u} (a : motive 0)
    (v : (i : Fin n) ‚Üí motive i.succ) (i : Fin n) : (a ::·µà‚ü®motive‚ü© v) i.succ = v i

@[simp]
private lemma K_le_card {Œ± : F} : K B i Œ± ‚â§ B.card

@[simp]
lemma eval‚ÇÇAlgHom_apply {A B : Type*} [CommSemiring A] [CommSemiring B] [MvPolynomialLike œÉ A P]
    [Algebra R A] [IsScalarTower R A P] [Algebra R B]
    (f : A ‚Üí‚Çê[R] B) (g : œÉ ‚Üí B) (p : P) :
    (eval‚ÇÇAlgHom f g) p = eval‚ÇÇ f g p

lemma U_i_is_union_of_cosets (i : Fin r) (hi : 0 < i) :
    (U ùîΩq Œ≤ i : Set L) = ‚ãÉ (c : ùîΩq), (fun u => c ‚Ä¢ Œ≤ (i-1) + u) '' (U ùîΩq Œ≤ (i - 1))

theorem oracleReduction_perfectCompleteness (hInit : init.neverFails) :
    (oracleReduction R n deg D oSpec i).perfectCompleteness init impl
      (relationRound R n deg D i.castSucc) (relationRound R n deg D i.succ)

lemma concrete_zero_mul0 (b : ConcreteBTField 0) :
  concrete_mul (zero (k:=0)) b = zero (k:=0)

theorem LeafData.composeBuild_getRootValue {Œ±} {s_left s_right : Skeleton}
    (left : LeafData Œ± s_left) (right : LeafData Œ± s_right)
    (compose : Œ± ‚Üí Œ± ‚Üí Œ±) :
    ((LeafData.internal left right).composeBuild compose).getRootValue =
      compose (left.composeBuild compose).getRootValue (right.composeBuild compose).getRootValue

theorem join_add_join {k : ‚Ñï} (h_pos : k > 0) (hi‚ÇÄ lo‚ÇÄ hi‚ÇÅ lo‚ÇÅ : ConcreteBTField (k - 1)) :
  „Ää hi‚ÇÄ, lo‚ÇÄ „Äã + „Ää hi‚ÇÅ, lo‚ÇÅ „Äã = „Ää hi‚ÇÄ + hi‚ÇÅ, lo‚ÇÄ + lo‚ÇÅ „Äã

theorem mem_restrictDegree_iff_degreeOf_le (p : MvPolynomial œÉ R) (n : ‚Ñï) :
    p ‚àà restrictDegree œÉ R n ‚Üî ‚àÄ i, p.degreeOf i ‚â§ n

private lemma cast_eq_cast_same_type {Œ± Œ≤ : Sort u} (h1 h2 : Œ± = Œ≤) {x y : Œ±}
    (h : cast h1 x = cast h2 y) : x = y

@[simp]
theorem dflatten_embedSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {motive : (k : Fin (vsum n)) ‚Üí Sort*}
    (v : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí motive (embedSum i j)) (i : Fin m) (j : Fin (n i)) :
    dflatten (motive := motive) v (embedSum i j) = v i j

theorem nsmul_succ [LawfulBEq R] (n : ‚Ñï) {p : UniPoly R} : nsmul (n + 1) p = nsmul n p + p

theorem queryOracleVerifier_rbrKnowledgeSoundness [Fintype L] {œÉ : Type} (init : ProbComp œÉ)
    (impl : QueryImpl []‚Çí (StateT œÉ ProbComp)) :
    (queryOracleVerifier ùîΩq Œ≤ (œë:=œë) Œ≥_repetitions).rbrKnowledgeSoundness init impl
    (relIn := finalSumcheckRelOut ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (relOut := acceptRejectOracleRel)
    (rbrKnowledgeError := queryRbrKnowledgeError ùîΩq Œ≤ Œ≥_repetitions
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))

@[simp]
theorem eq_accepts (i : Fin numWires) (c : ùì°) (x : Fin numWires ‚Üí ùì°) :
    (eq i c).accepts x ‚Üî x i = c

theorem reduction_completeness {Œµ : ‚Ñù‚â•0}
    (hRel : ‚àÄ stmtIn witIn, (stmtIn, witIn) ‚àà relIn ‚Üí
      [fun ‚ü®stmtOut, witOut‚ü© => (stmtOut, witOut) ‚àà relOut|do
        (simulateQ impl <| combineMap mapStmt mapWit ‚ü®stmtIn, witIn‚ü©).run' (‚Üê init)] ‚â• 1 - Œµ) :
    Reduction.completeness init impl relIn relOut (reduction mapStmt mapWit) Œµ

@[to_additive vsum_castSucc]
lemma vprod_castSucc [CommMonoid Œ±] {a : Fin (n + 1) ‚Üí Œ±} :
    vprod a = vprod (a ‚àò Fin.castSucc) * a (last n)

@[simp]
theorem Basis_cast_dest_apply {Œπ : Type*} (Œ± Œ≤ Œ≥ : ‚Ñï)
    (h_le1 : Œ± ‚â§ Œ≤) (h_le2 : Œ± ‚â§ Œ≥)
    (h_eq : Œ≤ = Œ≥) {k : Œπ} (b : @Basis Œπ (ConcreteBTField Œ±) (ConcreteBTField Œ≤) _ _
    (@ConcreteBTFieldAlgebra (l := Œ±) (r := Œ≤) (h_le := h_le1)).toModule) :
    let castBasis : @Basis Œπ (ConcreteBTField Œ±) (ConcreteBTField Œ≥) _ _
      (@ConcreteBTFieldAlgebra (l := Œ±) (r := Œ≥) (h_le := h_le2)).toModule :=
      cast (by
        exact Basis_cast_dest_eq Œ± Œ≥ Œ≤ h_le2 h_le1 h_eq
      ) b
    (castBasis k) = cast (by
      exact cast_ConcreteBTField_eq Œ≤ Œ≥ h_eq) (b k)

@[simp]
lemma getTypes_cons (x : Œ£ Œ± : Type u, Œ±) (xs : HList) :
    getTypes (x :: xs) = x.1 :: xs.getTypes

omit [NoZeroDivisors ùîΩ] in
lemma foldNth_degree_le {n : ‚Ñï} {f : ùîΩ[X]} {Œ± : ùîΩ} [inst : NeZero n] :
    (foldNth n f Œ±).natDegree ‚â§ f.natDegree / n

theorem support_C_subset {r : R} : (@C R œÉ _ r).support ‚äÜ { 0 }

lemma rank_eq_if_subUpFull_eq (h : n ‚â§ m) :
   (subUpFull U (Fin.castLE h)).rank = n  ‚Üí U.rank = n

lemma rootMultiplicity_W (i : Fin r) (a : L) :
    rootMultiplicity a (W ùîΩq Œ≤ i) = if a ‚àà (U ùîΩq Œ≤ i : Set L) then 1 else 0

@[simp]
lemma bIdx_mul_œë_add_i_fin_‚Ñì_pred_lt_‚Ñì (bIdx : Fin (‚Ñì / œë - 1)) (i : Fin (œë - 1))
    : ‚ÜëbIdx * œë + ‚Üëi < ‚Ñì

lemma aeval_eq' {A : Type w} [CommSemiring A] [Algebra R A] (f : P ‚Üí‚Çê[R] A) (p : P) :
    f p = aeval (f X) p

theorem vconcat_injective2 : Function.Injective2 (@vconcat Œ± n)

lemma concreteTowerAlgebraMap_id (k : ‚Ñï) :
    concreteTowerAlgebraMap (h_le:=by omega) = RingHom.id (ConcreteBTField k)

omit [Finite F] in
lemma one_in_doms (i : ‚Ñï) : 1 ‚àà evalDomain D i

theorem append_perfectCompleteness (R‚ÇÅ : Reduction oSpec Stmt‚ÇÅ Wit‚ÇÅ Stmt‚ÇÇ Wit‚ÇÇ pSpec‚ÇÅ)
    (R‚ÇÇ : Reduction oSpec Stmt‚ÇÇ Wit‚ÇÇ Stmt‚ÇÉ Wit‚ÇÉ pSpec‚ÇÇ)
    (h‚ÇÅ : R‚ÇÅ.perfectCompleteness init impl rel‚ÇÅ rel‚ÇÇ)
    (h‚ÇÇ : R‚ÇÇ.perfectCompleteness init impl rel‚ÇÇ rel‚ÇÉ) :
      (R‚ÇÅ.append R‚ÇÇ).perfectCompleteness init impl rel‚ÇÅ rel‚ÇÉ

lemma mem_image_support_coeff_finSuccEquivNth {f : MvPolynomial (Fin (n + 1)) R} {i : ‚Ñï} {x} :
    x ‚àà Finsupp.insertNth p i '' ((finSuccEquivNth R p f).coeff i).support ‚Üî
      x ‚àà f.support ‚àß x p = i

theorem hconcat_inj {Œ± : Fin n ‚Üí Sort u} {Œ≤ : Sort u} (v‚ÇÅ v‚ÇÇ : (i : Fin n) ‚Üí Œ± i) (a‚ÇÅ a‚ÇÇ : Œ≤) :
    hconcat v‚ÇÅ a‚ÇÅ = hconcat v‚ÇÇ a‚ÇÇ ‚Üî v‚ÇÅ = v‚ÇÇ ‚àß a‚ÇÅ = a‚ÇÇ

@[simp]
theorem hflatten_zero {n : Fin 0 ‚Üí ‚Ñï} {Œ± : (i : Fin 0) ‚Üí (j : Fin (n i)) ‚Üí Sort*}
    {v : (i : Fin 0) ‚Üí (j : Fin (n i)) ‚Üí Œ± i j} : hflatten v = !h[]

@[grind =] theorem idxOf'_cons [BEq Œ±] {a : Œ±} {x : Œ±} {xs : List Œ±} :
    idxOf' a (x :: xs) = bif x == a then 0 else idxOf' a xs + 1

@[simp]
private lemma x_times_oddPart'_coeff {f : Polynomial F} {n : ‚Ñï} :
    (x_times_oddPart' f).coeff n = if Odd n then f.coeff n else 0

Fin.append_right in Mathlib.Data.Fin.Tuple.Basic

lemma getBit_eq_testBit (k n : Nat) : getBit k n = if n.testBit k then 1 else 0

theorem two_le_two_pow_n_plus_1 (n : ‚Ñï) : 2 ‚â§ 2 ^ (n + 1)

lemma subLeftFull_of_vandermonde_is_vandermonde (h : m ‚â§ n) :
  Matrix.vandermonde Œ± = Matrix.subLeftFull (nonsquare n Œ±) (Fin.castLE h)

theorem OracleReduction.liftContext_toReduction_comm
    {lens : OracleContext.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                              OuterOStmtIn OuterOStmtOut InnerOStmtIn InnerOStmtOut
                              OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    {R : OracleReduction oSpec InnerStmtIn InnerOStmtIn InnerWitIn
                            InnerStmtOut InnerOStmtOut InnerWitOut pSpec} :
      (R.liftContext lens).toReduction = R.toReduction.liftContext lens.toContext

theorem liftContext_processRound
    {lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    {i : Fin n}
    {P : Prover oSpec InnerStmtIn InnerWitIn InnerStmtOut InnerWitOut pSpec}
    {resultRound : OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí)
      (pSpec.Transcript i.castSucc √ó (P.liftContext lens).PrvState i.castSucc)} :
      (P.liftContext lens).processRound i resultRound
      = do
        let ‚ü®transcript, prvState, outerStmtIn, outerWitIn‚ü© ‚Üê resultRound
        let ‚ü®newTranscript, newPrvState‚ü© ‚Üê P.processRound i (do return ‚ü®transcript, prvState‚ü©)
        return ‚ü®newTranscript, ‚ü®newPrvState, outerStmtIn, outerWitIn‚ü©‚ü©

theorem vcons_injective2 : Function.Injective2 (@vcons Œ± n)

lemma bIdx_succ_mul_œë_le_‚Ñì_succ (bIdx : Fin (‚Ñì / œë - 1)) : (‚ÜëbIdx + 1) * œë ‚â§ ‚Ñì + 1

@[simp] theorem rightpad_eq_self (l : List Œ±) (n : Nat) (h : n ‚â§ l.length) :
    rightpad n unit l = l

theorem mul_one (n : ChurchNat Œ±) : mul n one = n

theorem nsmul_zero [LawfulBEq R] (p : UniPoly R) : nsmul 0 p = 0

theorem join_eq_join_iff {k : ‚Ñï} (h_pos : k > 0) (hi‚ÇÄ lo‚ÇÄ hi‚ÇÅ lo‚ÇÅ : ConcreteBTField (k - 1)) :
  „Ää hi‚ÇÄ, lo‚ÇÄ „Äã = „Ää hi‚ÇÅ, lo‚ÇÅ „Äã ‚Üî (hi‚ÇÄ = hi‚ÇÅ ‚àß lo‚ÇÄ = lo‚ÇÅ)

theorem hcons_right_injective {Œ≤ : Fin n ‚Üí Sort u} (a : Œ±) :
    Function.Injective (hcons a : ((i : Fin n) ‚Üí Œ≤ i) ‚Üí (i : Fin (n + 1)) ‚Üí vcons Œ± Œ≤ i)

@[simp] lemma my_neg_mod_two (m : ‚Ñ§) : ( - m) % 2 = if m % 2 = 0 then 0 else 1

@[simp]
theorem Set.not_mem_language_iff {Œ± Œ≤} (rel : Set (Œ± √ó Œ≤)) (stmt : Œ±) :
    stmt ‚àâ rel.language ‚Üî ‚àÄ wit, (stmt, wit) ‚àâ rel

theorem is_prime : Nat.Prime fieldSize

@[simp]
theorem oracleVerifier_rbrKnowledgeSoundness [Nonempty (Query OStatement)]
    {d : ‚Ñï} (hDist : distanceLE OStatement d) :
    (oracleVerifier oSpec OStatement).rbrKnowledgeSoundness init impl
      (relIn OStatement)
      (relOut OStatement)
      (fun _ => (d : ‚Ñù‚â•0) / (Fintype.card (Query OStatement) : ‚Ñù‚â•0))

@[simp]
theorem cast_id : MessageIdx.cast (Eq.refl n‚ÇÅ) rfl = (id : pSpec‚ÇÅ.MessageIdx ‚Üí _)

theorem succ_succ {T : Type u} [HasSucc T] [Add T] [One T] [LawfulHasSucc T] (x : T) :
    succ' (succ' x) = x + 1 + 1

protected lemma abs_one_sub_div_le_one {v a : Fin n ‚Üí F}
  (h_card : 2 ‚â§ Fintype.card F)
  :
  |1 - (1 + 1 / ((Fintype.card F : ‚Ñö) - 1)) * Œî‚ÇÄ(v, a) / n

omit [DecidableEq L] [Fintype ùîΩq] hŒ≤_lin_indep in
lemma W‚ÇÄ_eq_X : W ùîΩq Œ≤ 0 = X

@[simp]
lemma seqCompose_toReduction {m : ‚Ñï}
    (Stmt : Fin (m + 1) ‚Üí Type)
    {Œπ‚Çõ : Fin (m + 1) ‚Üí Type} (OStmt : (i : Fin (m + 1)) ‚Üí Œπ‚Çõ i ‚Üí Type)
    [O‚Çõ : ‚àÄ i, ‚àÄ j, OracleInterface (OStmt i j)]
    (Wit : Fin (m + 1) ‚Üí Type)
    {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    [O‚Çò : ‚àÄ i, ‚àÄ j, OracleInterface ((pSpec i).Message j)]
    (R : (i : Fin m) ‚Üí
      OracleReduction oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Wit i.castSucc)
        (Stmt i.succ) (OStmt i.succ) (Wit i.succ) (pSpec i)) :
    (seqCompose Stmt OStmt Wit R).toReduction =
      Reduction.seqCompose (fun i => Stmt i √ó (‚àÄ j, OStmt i j)) Wit
        (fun i => (R i).toReduction)

@[grind _=_]
lemma degreeX_as_weighted_deg :
  degreeX f = natWeightedDegree f 1 0

theorem div_two_pow_lt_two_pow (x i j : ‚Ñï) (h_x_lt_2_pow_i : x < 2 ^ (i + j)): x / 2^j < 2^(i)

lemma testBit_true_eq_getBit_eq_1 (k n : Nat) : n.testBit k = ((Nat.getBit k n) = 1)

lemma mulVec_BerlekampWelchMatrix_eq :
  (BerlekampWelchMatrix e k œâs f).mulVec v i =
  ‚àë x : Fin (2 * e + k), v x * if x < e then f i * œâs i ^ x.1 else -œâs i ^ (x - e)

lemma getBit_of_lt_two_pow {n: ‚Ñï} (a: Fin (2^n)) (k: ‚Ñï) :
  getBit k a = if k < n then getBit k a else 0

Nat.zero_add in Init.Data.Nat.Basic

@[simp] lemma twoAdicGenerators_succ_square_eq' (idx : Fin twoAdicity) :
    twoAdicGenerators[idx.val + 1] ^ 2 = twoAdicGenerators[idx]

theorem append_left_injective (b : Fin n ‚Üí Œ±) : Function.Injective (@Fin.append m n Œ± ¬∑ b)

theorem dcast_eq_dcast_iff (h : a = a'') (h' : a' = a'') :
    dcast h b = dcast h' b' ‚Üî b = dcast (h'.trans h.symm) b'

lemma degree_s_smul_X {F : Type*} [Field F] [Fintype F] (s : F) [NeZero s] :
  (C s * (X : (F)[X])).degree = 1

@[simp]
theorem BTField.RingHom_cast_dest_apply (k m n : ‚Ñï) (h_eq : m = n)
  (f : BTField k ‚Üí+* BTField m) (x : BTField k) :
    (cast (BTField.RingHom_eq_of_dest_eq (k:=k) (m:=m) (n:=n) h_eq) f) x
    = cast (by apply cast_BTField_eq (h_eq:=h_eq)) (f x)

theorem finalSumcheckOracleVerifier_rbrKnowledgeSoundness [Fintype L] {œÉ : Type}
    (init : ProbComp œÉ) (impl : QueryImpl []‚Çí (StateT œÉ ProbComp)) :
    (finalSumcheckVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).rbrKnowledgeSoundness init impl
      (relIn := roundRelation ùîΩq Œ≤ (œë := œë) (ùìë := ùìë)
        (mp := BBF_SumcheckMultiplierParam) (Fin.last ‚Ñì))
      (relOut := finalSumcheckRelOut ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
      (rbrKnowledgeError := finalSumcheckKnowledgeError)

@[simp]
theorem drop_apply (m : ‚Ñï) (h : m ‚â§ n) (v : (i : Fin n) ‚Üí Œ± i) (i : Fin (n - m)) :
    (drop m h v) i = v (Fin.cast (Nat.sub_add_cancel h) (addNat i m))

lemma concentration_bounds {deg : ‚Ñï} {domain : Œπ ‚Ü™ F}
  {U : AffineSubspace F (Œπ ‚Üí F)} [Nonempty U]
  (hdiv_pos : 0 < (divergence U (RScodeSet domain deg) : ‚Ñù‚â•0))
  (hdiv_lt : (divergence U (RScodeSet domain deg) : ‚Ñù‚â•0) < 1 - ReedSolomonCode.sqrtRate deg domain)
  : let Œ¥' := divergence U (RScodeSet domain deg)
    Pr_{let u ‚Üê $·µñ U}[Code.relHammingDistToCode u (RScodeSet domain deg) ‚â† Œ¥']
    ‚â§ errorBound Œ¥' deg domain

theorem add_size {p q : UniPoly Q} : (add_raw p q).size = max p.size q.size

@[simp]
lemma Transcript.def_eq {k : Fin (n + 1)} {pSpec : ProtocolSpec n} :
    (pSpec.take k k.is_le).FullTranscript =
      ((i : Fin k) ‚Üí pSpec.¬´Type¬ª (Fin.castLE (by omega) i))

protected lemma roots_of_eloc_poly {x : F}
  (h : (ElocPoly n œâs f p).eval x = 0) :
  ‚àÉ i, i < n ‚àß f i ‚â† p.eval (œâs i)

theorem happend_hcons {Œ≤ : Fin m ‚Üí Sort u} {Œ≥ : Fin n ‚Üí Sort u}
    (a : Œ±) (u : (i : Fin m) ‚Üí Œ≤ i) (v : (i : Fin n) ‚Üí Œ≥ i) :
    True

@[simp]
lemma eval_solutionToQ {x : F} :
  eval x (solutionToQ e k v) =
  ‚àë i ‚àà Finset.range (e + k), liftF v (e + i) * x ^ i

@[simp]
theorem ofNat_succ (n : ‚Ñï) : @ofNat Œ± (n.succ) = succ (ofNat n)

Nat.pos_of_neZero in Init.Data.Nat.Basic

lemma binaryTowerAlgebra_def (l r : ‚Ñï) (h_le : l ‚â§ r) :
    @binaryAlgebraTower (l:=l) (r:=r) (h_le:=h_le)
    = (towerAlgebraMap l r h_le).toAlgebra

@[simp]
theorem reduction_completeness (h : init.neverFails)
    (hRel : ‚àÄ stmtIn witIn, (stmtIn, witIn) ‚àà relIn ‚Üî
      (mapStmt stmtIn, mapWit stmtIn witIn) ‚àà relOut) :
    (reduction oSpec mapStmt mapWit).perfectCompleteness init impl relIn relOut

@[simp] theorem equiv_symm {p q : UniPoly Q} : equiv p q ‚Üí equiv q p

theorem buildLayer_neverFails (Œ± : Type) [inst : DecidableEq Œ±] [inst_1 : SelectableType Œ±]
    (preexisting_cache : (spec Œ±).QueryCache) (n : ‚Ñï)
    (leaves : List.Vector Œ± (2 ^ (n + 1))) :
    ((simulateQ randomOracle (buildLayer Œ± n leaves)).run preexisting_cache).neverFails

theorem zero_canonical : (0 : UniPoly R).trim = 0

lemma cRank_rank_conversion :
  ‚Üë(U.rank) = U.cRank

@[simp]
theorem dcast_trans (h : a = a') (h' : a' = a'') :
    dcast h' (dcast h b) = dcast (h.trans h') b

lemma oodSampling_rs_le_bound
    {f : Œπ ‚Üí F} {m s : ‚Ñï} {œÜ : Œπ ‚Ü™ F} [Smooth œÜ]
    (Œ¥ l : ‚Ñù‚â•0) (hŒ¥Le : Œ¥ ‚â§ 1)
    (C : Set (Œπ ‚Üí F)) (hcode : C = smoothCode œÜ m ‚àß listDecodable C Œ¥ l) :
    Pr_{ let rs ‚Üê$·µñ (Fin s ‚Üí F) }[ ‚àÉ u u' : smoothCode œÜ m,
                        u.val ‚â† u'.val ‚àß
                        u.val ‚àà relHammingBall C f Œ¥ ‚àß
                        u'.val ‚àà relHammingBall C f Œ¥ ‚àß
                        ‚àÄ i : Fin s,
                          let ri := rs i
                          let rVec := fun j : Fin m => ri ^ (2^(j : ‚Ñï))
                          (mVdecode u).eval (rVec) = (mVdecode u').eval (rVec)
                      ] ‚â§ ENNReal.ofReal (((l : ‚Ñù)^2 / 2) * (((2^m : ‚Ñù) / Fintype.card F)^s))

theorem monoToLagrangeLevel_lagrangeToMonoLevel_id (v : Vector R (2 ^ n)) (i : Fin n) :
  monoToLagrangeLevel i (lagrangeToMonoLevel i v) = v

lemma coeff_eq_getElem {p : UniPoly Q} {i} (hp : i < p.size) :
  p.coeff i = p[i]

lemma schwartz_zippel_of_fintype {p : MvPolynomial œÉ R} (hp : p ‚â† 0) (S : œÉ ‚Üí Finset R) :
    #{x ‚àà S ^^ œÉ | eval x p = 0} / ‚àè i, (#(S i) : ‚Ñö‚â•0) ‚â§ ‚àë i, (p.degreeOf i / #(S i) : ‚Ñö‚â•0)

@[simp]
theorem fappend_left {Œ± : Fin m ‚Üí A} {Œ≤ : Fin n ‚Üí A}
    (u : (i : Fin m) ‚Üí F (Œ± i)) (v : (i : Fin n) ‚Üí F (Œ≤ i)) (i : Fin m) :
    fappend u v (castAdd n i) = cast (by simp [vappend_left]) (u i)

@[simp] theorem rightpad_prefix (n : Nat) (unit : Œ±) (l : List Œ±) :
    l <+: rightpad n unit l

lemma zero_def [Zero R] : zero = Vector.replicate (2 ^ n) 0

theorem mobius_apply_zeta_apply_eq_id (n : ‚Ñï) [NeZero n] (r : Fin n) (l : Fin (r.val + 1))
    (v : Vector R (2 ^ n)) : lagrangeToMono_segment n r l (monoToLagrange_segment n r l v) = v

theorem BitVec.dcast_bitvec_eq {l r val : ‚Ñï} (h_width_eq : l = r) :
    dcast h_width_eq (BitVec.ofNat l val) = BitVec.ofNat r val

omit [NeZero ‚Ñì] [NeZero r] [NeZero ùì°] in
lemma fin_‚Ñì_lt_r {h_‚Ñì_add_R_rate : ‚Ñì + ùì° < r} (i : Fin ‚Ñì)
    : i.val < r

theorem vconcat_right_injective (v : Fin n ‚Üí Œ±) : Function.Injective (vconcat v)

lemma vappend_left_of_lt {m n : ‚Ñï} {Œ± : Sort u}
    (u : Fin m ‚Üí Œ±) (v : Fin n ‚Üí Œ±) (i : Fin (m + n)) (h : i.val < m) :
      vappend u v i = u ‚ü®i, h‚ü©

theorem FullData.toLeafData_eq_leaf {Œ±} (a : Œ±) (tree)
    (h : LeafData.leaf a = tree.toLeafData) :
    tree = FullData.leaf a

@[simp]
theorem fappend‚ÇÇ_right {Œ±‚ÇÅ : Fin m ‚Üí A} {Œ±‚ÇÇ : Fin m ‚Üí B} {Œ≤‚ÇÅ : Fin n ‚Üí A} {Œ≤‚ÇÇ : Fin n ‚Üí B}
    (u : (i : Fin m) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i)) (v : (i : Fin n) ‚Üí F‚ÇÇ (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) (i : Fin n) :
    fappend‚ÇÇ (F := F‚ÇÇ) u v (natAdd m i) =
      cast (by simp [vappend_right]) (v i)

@[simp]
theorem FullData.get_ofFun {Œ±} {s} (f : SkeletonNodeIndex s ‚Üí Œ±) :
    (FullData.ofFun s f).get = f

@[simp]
theorem FullData.leftSubtree_internal {Œ±} {s_left s_right : Skeleton}
    (value : Œ±) (left : FullData Œ± s_left) (right : FullData Œ± s_right) :
    (FullData.internal value left right).leftSubtree = left

lemma concrete_div_eq_mul_inv {k : ‚Ñï} (a b : ConcreteBTField k) : a / b = a * (concrete_inv b)

@[simp]
lemma divide_by_2_empty :
    divide_by_2 ‚àÖ = ‚àÖ

theorem ZMod.powNeOfPowMod :
    ‚àÄ {n a' q c : ‚Ñï} (a : ZMod n), (a' : ZMod n) = a ‚Üí decide (n ‚â• 2) = true ‚Üí
      Nat.mod (Nat.pow a' ((n - 1) / q)) n = c ‚Üí decide (c ‚â† 1) = true ‚Üí a ^ ((n - 1) / q) ‚â† 1

theorem singleton_subset_Icc (n : ‚Ñï) : {1} ‚äÜ Finset.Icc 1 (n + 1)

@[simp]
lemma OracleReduction.append_toReduction
    (R‚ÇÅ : OracleReduction oSpec Stmt‚ÇÅ OStmt‚ÇÅ Wit‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ Wit‚ÇÇ pSpec‚ÇÅ)
    (R‚ÇÇ : OracleReduction oSpec Stmt‚ÇÇ OStmt‚ÇÇ Wit‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ Wit‚ÇÉ pSpec‚ÇÇ) :
      (OracleReduction.append R‚ÇÅ R‚ÇÇ).toReduction =
        Reduction.append R‚ÇÅ.toReduction R‚ÇÇ.toReduction

lemma Oracle.containsCache_of_cache {Œπ : Type} {spec : OracleSpec Œπ}
    [(i : Œπ) ‚Üí Inhabited (OracleSpec.range spec i)]
    (cache : spec.QueryCache) :
    ‚àÉ (f : spec.FunctionType), Oracle.containsCache f cache

@[simp]
theorem embedSum_zero {n : Fin 0 ‚Üí ‚Ñï} {i : Fin 0} (j : Fin (n i)) : embedSum i j = i

@[simp]
lemma seqCompose_succ {m : ‚Ñï} (Stmt : Fin (m + 2) ‚Üí Type)
    {n : Fin (m + 1) ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (V : (i : Fin (m + 1)) ‚Üí Verifier oSpec (Stmt i.castSucc) (Stmt i.succ) (pSpec i)) :
    seqCompose Stmt V = append (V 0) (seqCompose (Stmt ‚àò Fin.succ) (fun i => V (Fin.succ i)))

theorem reduction_perfectCompleteness (hInit : init.neverFails) :
    (reduction R deg D n oSpec).perfectCompleteness init impl
      (relationRound R n deg D 0) (relationRound R n deg D (.last n))

theorem commitOracleReduction_perfectCompleteness (hInit : init.neverFails) (i : Fin ‚Ñì)
    (hCR : isCommitmentRound ‚Ñì œë i) :
    OracleReduction.perfectCompleteness
      (pSpec := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)
      (relIn := foldStepRelOut (mp := mp) ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        (ùìë := ùìë) i)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        (ùìë := ùìë) i.succ)
      (oracleReduction := commitOracleReduction ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hCR)
      (init := init)
      (impl := impl)

@[simp]
lemma erase_even_empty :
    erase_even ‚àÖ = ‚àÖ

theorem append_perfectCompleteness
    (R‚ÇÅ : OracleReduction oSpec Stmt‚ÇÅ OStmt‚ÇÅ Wit‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ Wit‚ÇÇ pSpec‚ÇÅ)
    (R‚ÇÇ : OracleReduction oSpec Stmt‚ÇÇ OStmt‚ÇÇ Wit‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ Wit‚ÇÉ pSpec‚ÇÇ)
    (h‚ÇÅ : R‚ÇÅ.perfectCompleteness init impl rel‚ÇÅ rel‚ÇÇ)
    (h‚ÇÇ : R‚ÇÇ.perfectCompleteness init impl rel‚ÇÇ rel‚ÇÉ) :
      (R‚ÇÅ.append R‚ÇÇ).perfectCompleteness init impl rel‚ÇÅ rel‚ÇÉ

theorem split_mul_eq_mul_split {k : ‚Ñï} (h_pos : k > 0) (x‚ÇÄ x‚ÇÅ : ConcreteBTField k)
  (hi‚ÇÄ lo‚ÇÄ hi‚ÇÅ lo‚ÇÅ : ConcreteBTField (k - 1))
  (h_split_x‚ÇÄ : split h_pos x‚ÇÄ = (hi‚ÇÄ, lo‚ÇÄ))
  (h_split_x‚ÇÅ : split h_pos x‚ÇÅ = (hi‚ÇÅ, lo‚ÇÅ)) :
  split h_pos (x‚ÇÄ * x‚ÇÅ) =
    (lo‚ÇÄ * hi‚ÇÅ + lo‚ÇÅ * hi‚ÇÄ + hi‚ÇÄ * hi‚ÇÅ * Z (k - 1), lo‚ÇÄ * lo‚ÇÅ + hi‚ÇÄ * hi‚ÇÅ)

lemma folding
  [Nonempty Œπ] {S : Finset Œπ} [Fintype Œπ]
  (œÜ : Œπ ‚Ü™ F) (f : Œπ ‚Üí F) (k : ‚Ñï)
  [Nonempty (indexPow S œÜ k)]
  {degree : ‚Ñï} (Œ¥ : ‚Ñö) (hŒ¥Pos : Œ¥ > 0)
  (hŒ¥Lt : Œ¥ < foldingDistRange degree œÜ f) :
  let C : Set ((indexPow S œÜ k) ‚Üí F) := code (pow S œÜ k) (degree / k)
  Pr_{ let r ‚Üê $·µñ F }[ Œ¥·µ£((fold œÜ f k r), C) ‚â§ Œ¥]
    ‚â§ ENNReal.ofReal (proximityError F (degree / k) (LinearCode.rate (code œÜ degree)) Œ¥ k)

@[simp]
theorem dcast‚ÇÇ_eq' (h : a = a) (h' : dcast h b = b) : dcast‚ÇÇ h h' c = c

theorem Basis_cast_dest_eq {Œπ : Type*} (k n m : ‚Ñï) (h_k_le_n : k ‚â§ n)
  (h_k_le_m : k ‚â§ m) (h_eq : m = n) :
  letI instLeftAlgebra := ConcreteBTFieldAlgebra (l:=k) (r:=m) (h_le:=h_k_le_m)
  letI instRightAlgebra := ConcreteBTFieldAlgebra (l:=k) (r:=n) (h_le:=h_k_le_n)
  @Basis Œπ (ConcreteBTField k) (ConcreteBTField m) _ _ instLeftAlgebra.toModule =
  @Basis Œπ (ConcreteBTField k) (ConcreteBTField n) _ _ instRightAlgebra.toModule

omit hF‚ÇÇ in
lemma inductive_linear_map_W (i : Fin r) (h_i_add_1 : i + 1 < r)
    (h_prev_linear_map : IsLinearMap ùîΩq (f := fun inner_p ‚Ü¶ (W ùîΩq Œ≤ i).comp inner_p))
    : IsLinearMap ùîΩq (f := fun inner_p ‚Ü¶ (W ùîΩq Œ≤ (i + 1)).comp inner_p)

theorem johnson_bound_alphabet_free [Field F] [DecidableEq F]
  {B : Finset (Fin n ‚Üí F)}
  {v : Fin n ‚Üí F}
  {e : ‚Ñï}
  :
  let d := sInf { d | ‚àÉ u ‚àà B, ‚àÉ v ‚àà B, u ‚â† v ‚àß hammingDist u v = d }
  let q : ‚Ñö := Fintype.card F
  let frac := q / (q - 1)
  e ‚â§ n - ((n * (n - d)) : ‚Ñù).sqrt
  ‚Üí
  (B ‚à© ({ x | Œî‚ÇÄ(x, v) ‚â§ e } : Finset _)).card ‚â§ q * d * n

lemma getMiddleBits_eq_mod {n offset len : ‚Ñï} :
  getMiddleBits offset len n = (n >>> offset) % (2 ^ len)

@[simp]
lemma runWithLog_discard_log_eq_run (stmt : StmtIn) (wit : WitIn)
    (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      Prod.fst <$> prover.runWithLog stmt wit = prover.run stmt wit

theorem oracleVerifier_rbrKnowledgeSoundness [Fintype R] :
    (oracleVerifier R deg D oSpec).rbrKnowledgeSoundness init impl
    (inputRelation R deg D) (outputRelation R deg) (fun _ => (deg : ‚Ñù‚â•0) / (Fintype.card R))

@[simp]
theorem bool_accepts_iff : (bool j).accepts x ‚Üî x j * (x j - 1) = 0

theorem init_dconcat {motive : Fin (n + 1) ‚Üí Sort u} (v : (i : Fin n) ‚Üí motive (castSucc i))
    (a : motive (last n)) : (fun i => (v :+·µà‚ü®motive‚ü© a) (castSucc i)) = v

theorem functional_completeness (Œ± : Type) {s : Skeleton}
  (idx : SkeletonLeafIndex s)
  (leaf_data_tree : LeafData Œ± s)
  (hash : Œ± ‚Üí Œ± ‚Üí Œ±) :
  (getPutativeRoot_with_hash
    idx
    (leaf_data_tree.get idx)
    (generateProof
      (buildMerkleTree_with_hash leaf_data_tree hash) idx)
    (hash)) =
  (buildMerkleTree_with_hash leaf_data_tree hash).getRootValue

@[simp]
lemma bIdx_mul_œë_add_i_cast_lt_‚Ñì_succ (bIdx : Fin (‚Ñì / œë - 1)) (i : Fin (œë - 1 + 1))
    : ‚ÜëbIdx * œë + i < ‚Ñì + 1

lemma comm_map_smul_tmul (s s' : Right) (m : Left) :
    e (s ‚Ä¢ (s' ‚äó‚Çú[K] m)) = s ‚Ä¢ (e (s' ‚äó‚Çú[K] m))

lemma out_of_dom_smpl_1
  {Œ¥ l : ‚Ñù‚â•0} {s : ‚Ñï} {f : Œπ ‚Üí F} {degree : ‚Ñï} {œÜ : Œπ ‚Ü™ F}
  (C : Set (Œπ ‚Üí F)) (hC : C = code œÜ degree)
  (h_decodable : listDecodable C Œ¥ l)
  (h_nonempty : Nonempty (domainComplement œÜ)) :
  listDecodingCollisionProbability œÜ f Œ¥ s degree h_nonempty ‚â§
    ((l * (l-1) / 2)) * ((degree - 1) / (Fintype.card F - Fintype.card Œπ))^s

theorem append_comp' {a : Fin m ‚Üí Œ±} {b : Fin n ‚Üí Œ±} (f : Œ± ‚Üí Œ≤)
    (i : Fin (m + n)) : append (f ‚àò a) (f ‚àò b) i = f (append a b i)

@[simp]
theorem happend_right {Œ± : Fin m ‚Üí Sort u} {Œ≤ : Fin n ‚Üí Sort u}
    (u : (i : Fin m) ‚Üí Œ± i) (v : (i : Fin n) ‚Üí Œ≤ i) (i : Fin n) :
    happend u v (natAdd m i) = cast (vappend_right Œ± Œ≤ i).symm (v i)

@[simp]
lemma finite_possibleRelHammingDists : (possibleRelHammingDists C).Finite

@[simp]
theorem card_univ_filter_eq {e : Œ±} :
  #{x : Œ± | x ‚â† e} = #(Finset.univ (Œ± := Œ±)) - 1

lemma bIdx_succ_mul_œë_lt_‚Ñì_succ (bIdx : Fin (‚Ñì / œë - 1)) :
    (‚ÜëbIdx + 1) * œë < ‚Ñì + 1

lemma getBit_eq_zero_or_one {k n : Nat} :
  getBit k n = 0 ‚à® getBit k n = 1

@[simp]
theorem OracleVerifier.run_eq_run_verifier [O‚Çò : ‚àÄ i, OracleInterface (pSpec.Message i)]
    {stmt : StmtIn} {oStmt : ‚àÄ i, OStmtIn i} {transcript : FullTranscript pSpec}
    {verifier : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec} :
      verifier.run stmt oStmt transcript =
        verifier.toVerifier.run ‚ü®stmt, oStmt‚ü© transcript

lemma last_nonzero_unique {p : UniPoly Q} {k k' : Fin p.size} :
  last_nonzero_prop k ‚Üí last_nonzero_prop k' ‚Üí k = k'

@[simp]
theorem hflatten_two_eq_append {n : Fin 2 ‚Üí ‚Ñï} {Œ± : (i : Fin 2) ‚Üí (j : Fin (n i)) ‚Üí Sort*}
    {v : (i : Fin 2) ‚Üí (j : Fin (n i)) ‚Üí Œ± i j} : hflatten v = happend (v 0) (v 1)

omit [SelectableType R] in
@[simp]
lemma oracleReduction_verifier_eq_verifier {i : Fin n} :
    (oracleReduction R n deg D oSpec i).verifier = oracleVerifier R n deg D oSpec i

@[simp]
theorem fappend‚ÇÇ_zero {Œ±‚ÇÅ : Fin m ‚Üí A} {Œ±‚ÇÇ : Fin m ‚Üí B} {Œ≤‚ÇÅ : Fin 0 ‚Üí A} {Œ≤‚ÇÇ : Fin 0 ‚Üí B}
    (u : (i : Fin m) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i)) :
    fappend‚ÇÇ (F := F‚ÇÇ) u (!h‚¶ÉF‚ÇÇ‚¶Ñ‚ü®Œ≤‚ÇÅ‚ü©‚ü®Œ≤‚ÇÇ‚ü©[] : (i : Fin 0) ‚Üí F‚ÇÇ (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) = u

theorem liftContext_runToRound
    {lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    {outerStmtIn : OuterStmtIn} {outerWitIn : OuterWitIn} {i : Fin (n + 1)}
    (P : Prover oSpec InnerStmtIn InnerWitIn InnerStmtOut InnerWitOut pSpec) :
      (P.liftContext lens).runToRound i outerStmtIn outerWitIn
      = do
        let ‚ü®transcript, prvState‚ü© ‚Üê
          (P.runToRound i).uncurry (lens.proj (outerStmtIn, outerWitIn))
        return ‚ü®transcript, ‚ü®prvState, outerStmtIn, outerWitIn‚ü©‚ü©

lemma solution_gamma_is_linear_in_Z
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  :
  ‚àÉ (v‚ÇÄ v‚ÇÅ : F[X]),
    Œ≥' x‚ÇÄ (R k Œ¥ x‚ÇÄ h_gs) (irreducible_H k (x‚ÇÄ := x‚ÇÄ) (Œ¥ := Œ¥) h_gs) =
        AppendixA.polyToPowerSeriesùïÉ _
          (
            (Polynomial.map Polynomial.C v‚ÇÄ) +
            (Polynomial.C Polynomial.X) * (Polynomial.map Polynomial.C v‚ÇÅ)
          )

theorem decoder_dist_impl_mem
  {k r D e : ‚Ñï}
  (h_e : e ‚â§ n - Real.sqrt (k * n))
  {œâs : Fin n ‚Ü™ F}
  {f : Fin n ‚Üí F}
  {p : F[X]}
  (h_dist : Œî‚ÇÄ(f, p.eval ‚àò œâs) ‚â§ e)
  :
  p ‚àà decoder k r D e œâs f

private lemma sum_K_eq_card : ‚àë (Œ± : F), K B i Œ± = B.card

lemma coeff_eq_zero {p : UniPoly Q} :
    (‚àÄ i, (hi : i < p.size) ‚Üí p[i] = 0) ‚Üî ‚àÄ i, p.coeff i = 0

@[simp]
theorem erase_even_mem
  {s : Finset ‚Ñï}
  {n : ‚Ñï}
  : n ‚àà (erase_even s) ‚Üî Odd n ‚àß n ‚àà s

lemma le_sInf_of_LB {S : Set ‚Ñï} (hne : S.Nonempty) {i : ‚Ñï}
    (hLB : ‚àÄ s ‚àà S, i ‚â§ s) : i ‚â§ sInf S

@[simp]
lemma Verifier.id_rbrKnowledgeSoundness {rel : Set (Statement √ó Witness)} :
    (Verifier.id : Verifier oSpec Statement _ _).rbrKnowledgeSoundness
      init impl rel rel 0

Fin.is_le' in Init.Data.Fin.Lemmas

Nat.le_add_left in Init.Data.Nat.Basic

lemma definingPoly_coeffOf0 {F : Type*} [Field F] [Fintype F] (s : F) [NeZero s] :
    (definingPoly s).coeff 0 = 1

@[simp]
lemma Fintype.zero_lt_card {Œπ : Type*} [Fintype Œπ] [Nonempty Œπ] : 0 < Fintype.card Œπ

omit [DecidableEq L] [DecidableEq ùîΩq] hF‚ÇÇ hŒ≤_lin_indep h_Œ≤‚ÇÄ_eq_1 in
lemma intermediateNormVpoly_eval_is_linear_map (i : Fin (‚Ñì + 1)) (k : Fin (‚Ñì - i + 1)) :
  IsLinearMap ùîΩq (fun x : L =>
    (intermediateNormVpoly ùîΩq Œ≤ h_‚Ñì_add_R_rate i k).eval x)

@[simp]
theorem erase_odd_mem
  {s : Finset ‚Ñï}
  {n : ‚Ñï}
  : n ‚àà (erase_odd s) ‚Üî Even n ‚àß n ‚àà s

lemma AlgebraTowerEquiv.commutesRight' (e : AlgebraTowerEquiv A B)
    {i j : Œπ} (h : i ‚â§ j) (r : B i) :
  AlgebraTower.algebraMap (AT:=A) (i:=i) (j:=j) (h:=h) ((e.toRingEquiv i).symm r) =
  (e.toRingEquiv j).symm (AlgebraTower.algebraMap (AT:=B) (i:=i) (j:=j) (h:=h) r)

omit [DecidableEq L] [Fintype ùîΩq] h_Fq_char_prime hŒ≤_lin_indep in
lemma normalizedW‚ÇÄ_eq_1_div_Œ≤‚ÇÄ : normalizedW (ùîΩq := ùîΩq) (Œ≤ := Œ≤) (i :=0) = X * C (1 / (Œ≤ 0))

@[simp]
theorem poly_form (k : ‚Ñï) : poly k = X^2 + (C (Z k) * X + 1)

private lemma le_sum_choose_K [Zero F]
  (h_card : 2 ‚â§ (Fintype.card F)) :
  choose_2 (K B i 0) + (Fintype.card (Œ± := F) - 1) *
  choose_2 ((B.card - K B i 0) / (Fintype.card (Œ± := F) - 1)) ‚â§ sum_choose_K_i B i

theorem congrArg‚ÇÑ {Œ± Œ≤ Œ≥ Œ¥ Œµ : Sort*} {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥ ‚Üí Œ¥ ‚Üí Œµ} {a a' : Œ±} {b b' : Œ≤} {c c' : Œ≥}
    {d d' : Œ¥} (h : a = a') (h' : b = b') (h'' : c = c') (h''' : d = d') :
      f a b c d = f a' b' c' d'

omit [CharP L 2] [DecidableEq ùîΩq] h_Œ≤‚ÇÄ_eq_1 [NeZero ùì°] in
lemma firstOracleWitnessConsistencyProp_relay_preserved (i : Fin ‚Ñì)
    (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) (wit : Witness (L := L) ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j) :
    firstOracleWitnessConsistencyProp ùîΩq Œ≤ wit.t (getFirstOracle ùîΩq Œ≤ oStmt) =
    firstOracleWitnessConsistencyProp ùîΩq Œ≤ wit.t
      (getFirstOracle ùîΩq Œ≤ (mapOStmtOutRelayStep ùîΩq Œ≤ i hNCR oStmt))

@[simp, grind =]
lemma totalDegree_monomialXY {n m : ‚Ñï} {a : F} (ha : a ‚â† 0) :
  totalDegree (monomialXY n m a) = n + m

theorem succ'_ne_zero (n : Nat) : succ' n ‚â† 0

pow_one in Mathlib.Algebra.Group.Defs

private lemma k_and_e' [Zero F]
  (h_n : n ‚â† 0)
  (h_B : B.card ‚â† 0)
  :
  k B / B.card = (n - e B 0) / n

lemma wt_eq_hammingNorm [Zero F] {v : Œπ ‚Üí F} :
  wt v = hammingNorm v

@[simp]
lemma cons_empty_tail_eq_nil {Œ±} (hd : Œ±) (tl : Vector Œ± 0) :
    cons hd tl = ‚ü®#[hd], rfl‚ü©

theorem get_rtake_eq_rtake_get_comp_cast {Œ± : Type*} {m : ‚Ñï} (l : List Œ±) (h : m ‚â§ l.length) :
    (l.rtake m).get = rtake m h l.get ‚àò Fin.cast (by simp [List.rtake]; omega)

Nat.cast_pow in Mathlib.Data.Nat.Cast.Basic

lemma h_sum_two_same_pow2 {k : ‚Ñï} (h_pos : k > 0) : 2 ^ (k - 1) + 2 ^ (k - 1) = 2 ^ k

@[simp]
theorem zero_dappend {motive : Fin (0 + n) ‚Üí Sort u} {u : (i : Fin 0) ‚Üí motive (castAdd n i)}
    (v : (i : Fin n) ‚Üí motive (natAdd 0 i)) :
    dappend (motive := motive) u v = fun i => cast (by simp) (v (i.cast (by omega)))

theorem ZMod.bla : ‚àÄ {n c : ‚Ñï} (a : ZMod n), c = 1 ‚Üí IsNat (a ^ (n - 1)) c ‚Üí a ^ (n - 1) = 1

lemma Fin.le_iff_lt_succ (a b : Fin r) (h_b : b + 1 < r) : a ‚â§ b ‚Üî a < b + 1

lemma addSalt_Message (i : pSpec.MessageIdx) :
    (pSpec.addSalt Salt).Message i = (pSpec.Message i √ó Salt i)

theorem seqCompose_knowledgeSoundness
    (rel : (i : Fin (m + 1)) ‚Üí Set ((Stmt i √ó ‚àÄ j, OStmt i j) √ó Wit i))
    (V : (i : Fin m) ‚Üí
      OracleVerifier oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Stmt i.succ) (OStmt i.succ)
        (pSpec i))
    (knowledgeError : Fin m ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (V i).knowledgeSoundness init impl (rel i.castSucc) (rel i.succ) (knowledgeError i)) :
      (OracleVerifier.seqCompose Stmt OStmt V).knowledgeSoundness
        init impl (rel 0) (rel (Fin.last m)) (‚àë i, knowledgeError i)

theorem PrattPartList.out {p : ‚Ñï} {a : ZMod p} {n : ‚Ñï} (h : PrattPartList p a n) :
    ‚àÄ q : ‚Ñï, q.Prime ‚Üí q ‚à£ n ‚Üí a ^ ((p - 1) / q) ‚â† 1

@[simp]
lemma append_last_of_succ_right {u : Fin m ‚Üí Œ±} {v : Fin (n + 1) ‚Üí Œ±} :
    (append u v) (last (m + n)) = v (last n)

theorem intermediateNormVpoly_comp_qmap (i : Fin (‚Ñì))
    (k : Fin (‚Ñì - i - 1)) : -- corresponds to intermediateNormVpoly_comp

@[simp]
theorem vappend_right (u : Fin m ‚Üí Œ±) (v : Fin n ‚Üí Œ±) (i : Fin n) :
    vappend u v (natAdd m i) = v i

@[simp]
theorem perfectCompleteness_eq_prob_one :
    reduction.perfectCompleteness init impl relIn relOut ‚Üî
      ‚àÄ stmtIn witIn, (stmtIn, witIn) ‚àà relIn ‚Üí
        [fun ‚ü®‚ü®_, (prvStmtOut, witOut)‚ü©, stmtOut‚ü© =>
          (stmtOut, witOut) ‚àà relOut ‚àß prvStmtOut = stmtOut
        | do (simulateQ (impl ++‚Çõ‚Çí challengeQueryImpl : QueryImpl _ (StateT œÉ ProbComp))
            <| reduction.run stmtIn witIn).run' (‚Üê init)] = 1

lemma one_bitvec_shiftRight {d : ‚Ñï} (h_d : d > 0) : 1 >>> d = 0

theorem vappend_assoc {p : ‚Ñï} (u : Fin m ‚Üí Œ±) (v : Fin n ‚Üí Œ±) (w : Fin p ‚Üí Œ±) :
    (vappend (vappend u v) w) = (vappend u (vappend v w)) ‚àò Fin.cast (add_assoc m n p)

theorem generates_quotient_point_if_is_fiber_of_y
    (i : Fin ‚Ñì) (steps : ‚Ñï) (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
    (x : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i, by omega‚ü©))
    (y : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i.val + steps, by omega‚ü©))
    (hx_is_fiber : ‚àÉ (k : Fin (2 ^ steps)), x = qMap_total_fiber ùîΩq Œ≤ (i := ‚ü®i, by omega‚ü©)
      (steps := steps) (h_i_add_steps := by
        simp only; exact fin_‚Ñì_steps_lt_‚Ñì_add_R i steps h_i_add_steps) (y := y) k) :
    y = iteratedQuotientMap ùîΩq Œ≤ h_‚Ñì_add_R_rate i (k := steps) (h_bound := h_i_add_steps) x

theorem commit_eq {a : ZMod p} (hpG1 : Nat.card G‚ÇÅ = p)
    (poly : degreeLT (ZMod p) (n + 1)) :
    commit (towerOfExponents g‚ÇÅ a n) (degreeLTEquiv _ _ poly) = g‚ÇÅ ^ (poly.1.eval a).val

theorem multilinearBasis_apply (r : ‚Ñï) : ‚àÄ l : ‚Ñï, (h_le : l ‚â§ r) ‚Üí ‚àÄ (j : Fin (2  ^ (r - l))),
  multilinearBasis (l:=l) (r:=r) (h_le:=h_le) j =
    (Finset.univ : Finset (Fin (r - l))).prod (fun i =>
      (binaryAlgebraTower (l:=l + i + 1) (r:=r) (h_le:=by omega)).algebraMap (
        (ùïè (l + i)) ^ (Nat.getBit i j)))

@[simp]
lemma widthDiv4_mul_4_eq_width : params.widthDiv4 * 4 = params.width

@[simp]
lemma lastBlockIdx_mul_œë_add_x_lt_‚Ñì_succ (x : ‚Ñï) {hx : x ‚â§ œë} :
    (‚Ñì / œë - 1) * œë + x < ‚Ñì + 1

theorem computableNTTStage_eq_NTTStage (i : Fin ‚Ñì) :
  computableNTTStage (ùîΩq := ùîΩq) (r := r) (L := L) (‚Ñì := ‚Ñì) (Œ≤ := Œ≤) (R_rate := R_rate)
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := ‚ü®i, by omega‚ü©) =
  NTTStage (ùîΩq := ùîΩq) (L := L) (Œ≤ := Œ≤) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
    (i := ‚ü®i, by omega‚ü©)

lemma concrete_zero_mul
  (prevBTFieldProps : ConcreteBTFieldProps (k := k - 1))
  (a : ConcreteBTField k) : concrete_mul (zero (k:=k)) a = zero (k:=k)

@[simp]
lemma liftF_succ {f : Fin (n + 1) ‚Üí Œ±} : liftF f n = f ‚ü®n, Nat.lt_add_one _‚ü©

@[simp]
theorem list_nonempty (k : ‚Ñï) : (list k).1 ‚â† []

omit [DecidableEq ùîΩq] hF‚ÇÇ h_Œ≤‚ÇÄ_eq_1 in
lemma get_sDomain_basis (i : Fin r) (h_i : i < ‚Ñì + R_rate) :
    ‚àÄ (k : Fin (‚Ñì + R_rate - i)),
    (sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate
      i (by omega)) k = eval (Œ≤ ‚ü®i + k.val, by omega‚ü©) (normalizedW ùîΩq Œ≤ i)

theorem get_rtake_ofFn_eq_rtake_comp_cast {Œ± : Type*} {m : ‚Ñï} (v : Fin n ‚Üí Œ±) (h : m ‚â§ n) :
    ((List.ofFn v).rtake m).get =
      rtake m h v ‚àò Fin.cast (by simp [List.rtake]; omega)

lemma lastBlockIdx_isNeCommitmentRound (i : Fin œë) :
    ¬¨isCommitmentRound ‚Ñì œë ‚ü®(‚Ñì / œë - 1) * œë + ‚Üëi, lastBlockIdx_mul_œë_add_fin_lt_‚Ñì i‚ü©

@[simp]
theorem minPoly_of_powerBasisSucc_generator (k : ‚Ñï) :
  (minpoly (BTField k) (powerBasisSucc k).gen) = X^2 + (Z k) ‚Ä¢ X + 1

theorem liftContext_perfectCompleteness
    (h : R.perfectCompleteness init impl innerRelIn innerRelOut) :
      (R.liftContext lens).perfectCompleteness init impl outerRelIn outerRelOut

Fin.eta in Init.Data.Fin.Lemmas

lemma mca_rsc
  [DecidableEq Œπ]
  (Œ± : F) (œÜ : Œπ ‚Ü™ F) (m : ‚Ñï) [Smooth œÜ]
  (par‚Ñì_type : Type) [Fintype par‚Ñì_type] (exp : par‚Ñì_type ‚Ü™ ‚Ñï) :
  let Gen := RSGenerator.genRSC par‚Ñì_type œÜ m exp
  let : Fintype Gen.par‚Ñì := Gen.h‚Ñì
  hasMutualCorrAgreement
    -- Generator
    Gen
    -- BStar
    ((1 + Gen.rate) / 2)
    -- errStar
    (fun Œ¥ => ENNReal.ofReal
        ((Fintype.card par‚Ñì_type - 1) * (2^m / (Gen.rate * (Fintype.card F)))))

lemma linsolve_to_BerlekampWelch_condition {e k : ‚Ñï}
  [NeZero n]
  {œâs f : Fin n ‚Üí F}
  {v : Fin (2 * e + k) ‚Üí F}
  (h_sol : linsolve (BerlekampWelchMatrix e k œâs f) (Rhs e œâs f) = some v)
  : BerlekampWelchCondition e k œâs f (solutionToE e k v) (solutionToQ e k v)

Fin.coe_castSucc in Init.Data.Fin.Lemmas

omit [Fintype L] [DecidableEq L] in
theorem Polynomial.comp_same_inner_eq_if_same_outer (f g : L[X]) (h_f_eq_g : f = g) :
  ‚àÄ x, f.comp x = g.comp x

theorem unique_linear_form_of_elements_in_adjoined_commring
    {R : Type*} [CommRing R] (f : R[X]) (hf_deg : f.natDegree = 2)
    (hf_monic : Monic f) (c1 : AdjoinRoot f) :
    ‚àÉ! p : R √ó R, c1 = (AdjoinRoot.of f) p.1 * root f + (AdjoinRoot.of f) p.2

lemma eq_evenize_deevenize {f : Polynomial F} (hEven : EvenPoly f) :
    evenize (deevenize f) = f

@[to_additive]
theorem prod_Iio_eq_univ (i : Fin (n + 1)) :
    ‚àè j ‚àà Iio i, v j = ‚àè j : Fin i, v (Fin.castLE i.isLt.le j)

theorem hcons_happend_comm {Œ≤ : Fin m ‚Üí Sort u} {Œ≥ : Fin n ‚Üí Sort u}
    (a : Œ±) (u : (i : Fin m) ‚Üí Œ≤ i) (v : (i : Fin n) ‚Üí Œ≥ i) :
    True

@[simp]
lemma evenize_coeff {f : Polynomial F} {n : ‚Ñï} :
    (evenize f).coeff n = if Even n then f.coeff (n / 2) else 0

lemma forwardRange_succ_right_ne_empty (n : ‚Ñï) (r : Fin (n - 1)) (l : Fin (r.val + 1)) :
  forwardRange n ‚ü®r + 1, by omega‚ü© ‚ü®l, by simp only; omega‚ü© ‚â† []

@[simp]
theorem fflatten‚ÇÇ_zero {A : Sort u} {B : Sort v} {F : A ‚Üí B ‚Üí Sort w} {n : Fin 0 ‚Üí ‚Ñï}
    {Œ± : (i : Fin 0) ‚Üí (j : Fin (n i)) ‚Üí A}
    {Œ≤ : (i : Fin 0) ‚Üí (j : Fin (n i)) ‚Üí B}
    {v : (i : Fin 0) ‚Üí (j : Fin (n i)) ‚Üí F (Œ± i j) (Œ≤ i j)} : fflatten‚ÇÇ v = !h[]

@[simp]
theorem Reduction.id_runWithLog (stmt : StmtIn) (wit : WitIn) :
    (Reduction.id : Reduction oSpec StmtIn WitIn _ _ _).runWithLog stmt wit =
      pure ‚ü®‚ü®‚ü®default, stmt, wit‚ü©, stmt‚ü©, [], []‚ü©

@[simp]
theorem dist_subsingleton {C : Set (n ‚Üí R)} [Subsingleton C] : ‚ÄñC‚Äñ‚ÇÄ = 0

lemma exist_bit_diff_if_diff {n: ‚Ñï} (a: Fin (2^n)) (b: Fin (2^n)) (h_a_ne_b: a ‚â† b):
  ‚àÉ k: Fin n, getBit k a ‚â† getBit k b

theorem sum_zero_iff_eq_of_self_sum_zero {F : Type*} [AddGroup F]
  (h_self_sum_eq_zero : ‚àÄ (x : F), x + x = 0) : ‚àÄ (x y : F), x + y = 0 ‚Üî x = y

lemma liftF_ne_zero_of_lt {i : ‚Ñï} (h : i < n) : liftF f' i ‚â† 0 ‚Üî f' ‚ü®i, h‚ü© ‚â† 0

lemma add_self_cancel {k : ‚Ñï} (a : ConcreteBTField k) : a + a = 0

theorem seqCompose_completeness (hInit : init.neverFails)
    (rel : (i : Fin (m + 1)) ‚Üí Set ((Stmt i √ó ‚àÄ j, OStmt i j) √ó Wit i))
    (R : ‚àÄ i, OracleReduction oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Wit i.castSucc)
      (Stmt i.succ) (OStmt i.succ) (Wit i.succ) (pSpec i))
    (completenessError : Fin m ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (R i).completeness init impl (rel i.castSucc) (rel i.succ) (completenessError i)) :
      (OracleReduction.seqCompose Stmt OStmt Wit R).completeness
        init impl (rel 0) (rel (Fin.last m)) (‚àë i, completenessError i)

theorem vcons_right_injective (a : Œ±) :
    Function.Injective (vcons a : (Fin n ‚Üí Œ±) ‚Üí Fin (n + 1) ‚Üí Œ±)

theorem happend_hconcat {Œ± : Fin m ‚Üí Sort u} {Œ≤ : Fin n ‚Üí Sort u} {Œ≥ : Sort u}
    (u : (i : Fin m) ‚Üí Œ± i) (v : (i : Fin n) ‚Üí Œ≤ i) (c : Œ≥) :
    True

theorem rsum_eq_t1_square_aux
  {curBTField : Type*} [Field curBTField] -- curBTField ‚âÉ ùîΩ_{2^{2^k}}
  (u : curBTField) -- here u is already lifted to curBTField
  (k : ‚Ñï)
  (x_pow_card : ‚àÄ (x : curBTField), x ^ (2 ^ (2 ^ (k))) = x)
  (u_ne_zero : u ‚â† 0)
  (trace_map_prop : TraceMapProperty curBTField u k):
   ‚àë j ‚àà Finset.Icc 1 (2 ^ (k)), u ^ (2 ^ 2 ^ (k) - 2 ^ j) = u

lemma extract_stop_last_eq_drop {n : ‚Ñï} {Œ± : Fin n ‚Üí Sort*} (start : ‚Ñï) (h : start ‚â§ n)
    (v : (i : Fin n) ‚Üí Œ± i) : extract start n h (Nat.le_refl _) v = drop start h v

lemma eval‚ÇÇ_induction_on : True

lemma evenPart_even {f : Polynomial F} :
    EvenPoly (evenPart f)

Nat.add_sub_cancel in Init.Data.Nat.Basic

@[simp]
theorem vconcat_castSucc (v : Fin n ‚Üí Œ±) (a : Œ±) (i : Fin n) :
    vconcat v a (castSucc i) = v i

@[grind]
lemma quotient_nezero {f q : F[X][Y]} (hg : q * f ‚â† 0) : q ‚â† 0

@[simp]
theorem Set.mem_language_iff {Œ± Œ≤} (rel : Set (Œ± √ó Œ≤)) (stmt : Œ±) :
    stmt ‚àà rel.language ‚Üî ‚àÉ wit, (stmt, wit) ‚àà rel

lemma Z_square_eq (k : ‚Ñï) (prevBTFieldProps : ConcreteBTFieldProps (k := k))
    (curBTFieldProps : ConcreteBTFieldProps (k := (k + 1))) :
  letI : Field (ConcreteBTField (k + 1)) := mkFieldInstance curBTFieldProps
  (Z (k + 1)) ^ 2 = „Ää Z (k), 1 „Äã

lemma split_join_via_add_smul_eq_iff_split (k : ‚Ñï) (h_pos : k > 0)
    (hi_btf lo_btf : BTField (k - 1)) :
    split (k:=k) (h_k:=h_pos) (‚ãò hi_btf, lo_btf ‚ãô) = (hi_btf, lo_btf)

theorem unique_repr {R : Type*} [CommRing R] {S : Type*} [CommRing S] [Algebra R S]
    (pb : PowerBasis R S) (repr1 repr2 : Fin pb.dim ‚Üí‚ÇÄ R)
    (h : ‚àë i : Fin pb.dim, repr1 i ‚Ä¢ pb.basis i = ‚àë i : Fin pb.dim, repr2 i ‚Ä¢ pb.basis i) :
    repr1 = repr2

omit hF‚ÇÇ in
theorem kernel_normalizedW_eq_U (i : Fin r) :
    LinearMap.ker (polyEvalLinearMap (normalizedW ùîΩq Œ≤ i)
    (normalizedW_is_additive ùîΩq Œ≤ i))
    = U ùîΩq Œ≤ i

lemma zsmul_neg' {k : ‚Ñï} (n : ‚Ñï) (a : ConcreteBTField k) :
  (if ((Int.negSucc n) : ‚Ñ§) % (2 : ‚Ñ§) = (0 : ‚Ñ§) then zero else a) =
    neg (if (‚Üën.succ : ‚Ñ§) % (2 : ‚Ñ§) = (0 : ‚Ñ§) then zero else a)

theorem seqCompose_knowledgeSoundness
    (rel : (i : Fin (m + 1)) ‚Üí Set (Stmt i √ó Wit i))
    (V : (i : Fin m) ‚Üí Verifier oSpec (Stmt i.castSucc) (Stmt i.succ) (pSpec i))
    (knowledgeError : Fin m ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (V i).knowledgeSoundness init impl (rel i.castSucc) (rel i.succ) (knowledgeError i)) :
      (Verifier.seqCompose Stmt V).knowledgeSoundness init impl (rel 0) (rel (Fin.last m))
        (‚àë i, knowledgeError i)

Nat.add_le_add_left in Init.Data.Nat.Basic

omit [DecidableEq ùîΩq] hF‚ÇÇ in
lemma initial_tiled_coeffs_correctness (h_‚Ñì : ‚Ñì ‚â§ r) (a : Fin (2 ^ ‚Ñì) ‚Üí L) :
    let b: Fin (2^(‚Ñì + R_rate)) ‚Üí L := tileCoeffs a
    additiveNTTInvariant ùîΩq Œ≤ h_‚Ñì_add_R_rate b a (i := ‚ü®‚Ñì, by omega‚ü©)

theorem add_succ (m n : ChurchNat Œ±) : add (succ m) n = succ (add m n)

theorem oddRefinement_eq_novel_poly_of_1_leading_suffix (i : Fin ‚Ñì) (v : Fin (2 ^ i.val))
    (original_coeffs : Fin (2 ^ ‚Ñì) ‚Üí L) :
    have h_v: v.val ||

lemma qMap_total_fiber_basis_sum_repr (i : Fin ‚Ñì) (steps : ‚Ñï) (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
    (y : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) (i := ‚ü®i + steps, by omega‚ü©))
    (k : Fin (2 ^ steps)) :
    let x : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i, by omega‚ü©) := qMap_total_fiber ùîΩq Œ≤
      (i := ‚ü®i, by omega‚ü©) (steps := steps) (h_i_add_steps := by
        apply Nat.lt_add_of_pos_right_of_le; omega) (y := y) (k)
    let basis_x := sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i, by omega‚ü©
      (by simp only; apply Nat.lt_add_of_pos_right_of_le; omega)
    let basis_y := sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i + steps, by omega‚ü©
      (h_i := by apply Nat.lt_add_of_pos_right_of_le; omega)
    let y_coeffs := basis_y.repr y
    x = ‚àë j : Fin (‚Ñì + ùì° - i), (
      fiber_coeff (i := i) (steps := steps) (j := j) (elementIdx := k) (y_coeffs := y_coeffs)
    ) ‚Ä¢ (basis_x j)

@[simp]
lemma truncate_zero_eq_zero : (truncate p 0) = 0

@[simp]
theorem vcons_fin_zero (a : Œ±) (v : Fin 0 ‚Üí Œ±) : a ::·µõ v = fun i => match i with

lemma qMap_eval_mem_sDomain_succ (i : Fin ‚Ñì)
    (h_i_add_1 : i.val + 1 ‚â§ ‚Ñì) (x : (sDomain ùîΩq Œ≤
    h_‚Ñì_add_R_rate) ‚ü®i, by omega‚ü©) :
    (qMap ùîΩq Œ≤ ‚ü®i.val, by omega‚ü©).eval (x.val : L) ‚àà
    sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate
      ‚ü®i.val + 1, by omega‚ü©

private lemma johnson_unrefined [Zero F]
  (h_n : 0 < n)
  (h_B : 2 ‚â§ B.card)
  (h_card : 2 ‚â§ (Fintype.card F))
  :
  (1 - e B 0 / n) ^ 2 * B.card + B.card * (e B 0) ^ 2 / ((Fintype.card F - 1) * n^2) - 1
  ‚â§
  (B.card - 1) * (1 - d B/n)

theorem additiveNTT_correctness (h_‚Ñì : ‚Ñì ‚â§ r)
    (original_coeffs : Fin (2 ^ ‚Ñì) ‚Üí L)
    (output_buffer : Fin (2 ^ (‚Ñì + R_rate)) ‚Üí L)
    (h_alg : output_buffer = additiveNTT ùîΩq Œ≤ h_‚Ñì_add_R_rate original_coeffs) :
    let P := polynomialFromNovelCoeffs ùîΩq Œ≤ ‚Ñì h_‚Ñì original_coeffs
    ‚àÄ (j : Fin (2^(‚Ñì + R_rate))),
      output_buffer j = P.eval (evaluationPointœâ ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®0, by omega‚ü© j)

@[simp] theorem join_nil : List.join ([] : List (List Œ±)) = []

lemma sum_inv_Z_next_eq
  (k : ‚Ñï)
  (prev : ConcreteBTFStepResult (k := k)) :
  letI : Field (ConcreteBTField k) := mkFieldInstance (prev.toConcreteBTFieldProps)
  letI : Field (ConcreteBTField (k + 1)) := mkFieldInstance (k:=k+1)
    (props:=liftBTFieldProps (k:=k) (prevBTFResult:=prev))
  letI : Algebra (ConcreteBTField k) (ConcreteBTField (k + 1)) :=
    instAlgebraLiftConcreteBTField k prev
  Z (k + 1) + (Z (k + 1))‚Åª¬π = (algebraMap (ConcreteBTField k) (ConcreteBTField (k + 1))) (Z k)

@[simp]
theorem eqPolynomial_eval_zeroOne (r x : œÉ ‚Üí Fin 2) :
    eval (x : œÉ ‚Üí R) (eqPolynomial r) = if x = r then 1 else 0

theorem mca_johnson_bound_CONJECTURE
  [DecidableEq Œπ]
  (Œ± : F) (œÜ : Œπ ‚Ü™ F) (m : ‚Ñï) [Smooth œÜ]
  (par‚Ñì_type : Type) [Fintype par‚Ñì_type] (exp : par‚Ñì_type ‚Ü™ ‚Ñï) :
  let Gen := RSGenerator.genRSC par‚Ñì_type œÜ m exp
  let : Fintype Gen.par‚Ñì := Gen.h‚Ñì
  hasMutualCorrAgreement Gen
    -- Conjectured BStar = ‚àöœÅ
    (Real.sqrt Gen.rate)
    -- Conjectured errStar
    (fun Œ¥ =>
      let min_val := min (1 - Real.sqrt Gen.rate - (Œ¥ : ‚Ñù)) (Real.sqrt Gen.rate / 20)
      ENNReal.ofReal (
        ((Fintype.card par‚Ñì_type - 1) * 2^(2*m)) /
        ((Fintype.card F) * (2 * min_val)^7)
      )
    )

@[simp] theorem idxOf'_nil [BEq Œ±] {a : Œ±} : idxOf' a [] = 0

omit [Fintype œÉ] in
theorem singleEqPolynomial_degreeOf (r : R) (i j : œÉ) :
    degreeOf i (singleEqPolynomial r (X j)) ‚â§ if i = j then 1 else 0

lemma and_two_pow_eq_zero_of_getBit_0 {n i : ‚Ñï} (h_getBit : getBit i n = 0)
    : n &&& (2 ^ i) = 0

@[simp]
theorem take_append_left' : (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ)‚ü¶:m‚üß = pSpec‚ÇÅ

@[simp] theorem fromNat_toNat_eq_self {k : ‚Ñï} (bv : BitVec (2 ^ k)) :
  (fromNat (BitVec.toNat bv) : ConcreteBTField k) = bv

lemma getBit_lt_2 {k n : Nat} : getBit k n < 2

@[simp] lemma toMvPolynomialAlgHom_X (s : œÉ) :
    toMvPolynomialAlgHom (X s : P) = (MvPolynomial.X s : MvPolynomial œÉ R)

@[simp]
lemma deevenize_coeff {f : Polynomial F} {n : ‚Ñï} :
    (deevenize f).coeff n = f.coeff (2 * n)

Polynomial.degree_sum_le in Mathlib.Algebra.Polynomial.Degree.Definitions

lemma toPoly_trim [LawfulBEq R] {p : UniPoly R} : p.trim.toPoly = p.toPoly

@[simp]
theorem LeafData.map_leaf {Œ± Œ≤} (f : Œ± ‚Üí Œ≤) (a : Œ±) :
    (LeafData.leaf a).map f = LeafData.leaf (f a)

theorem cast_symm {hn} (hSpec : pSpec‚ÇÅ.cast hn = pSpec‚ÇÇ) : pSpec‚ÇÇ.cast hn.symm = pSpec‚ÇÅ

lemma wt_eq_zero_iff [Zero F] {v : Œπ ‚Üí F} :
  wt v = 0 ‚Üî Fintype.card Œπ = 0 ‚à® ‚àÄ i, v i = 0

private lemma k_choose_2 [Zero F] {B : Finset (Fin n ‚Üí F)}
  (h_n : n ‚â† 0)
  (h_B : B.card ‚â† 0)
  :
  n * choose_2 (k B) ‚â§ ‚àë i, choose_2 (K B i 0)

@[simp]
theorem Reduction.runWithLog_discard_logs_eq_run
    {stmt : StmtIn} {wit : WitIn}
    {reduction : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec} :
      Prod.fst <$>
        reduction.runWithLog stmt wit = reduction.run stmt wit

theorem W_linearity (i : Fin r)
    : IsLinearMap ùîΩq (f := fun inner_p ‚Ü¶ (W ùîΩq Œ≤ i).comp inner_p)

@[simp, grind =]
theorem monomialXY_add {n m : ‚Ñï} {a b : F} :
  monomialXY n m (a + b) = monomialXY n m a + monomialXY n m b

theorem finSigmaFinEquiv'_pair {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (i : Fin m) (k : Fin (n i)) :
    (finSigmaFinEquiv' ‚ü®i, k‚ü© : ‚Ñï) = ‚àë j, n (Fin.castLE i.isLt.le j) + k

@[simp]
lemma range_def : (spec Œ±).range () = Œ±

private lemma comp_x_square_coeff_pos_deg {f : Polynomial F} {n : ‚Ñï} (h : 0 < f.degree) :
  (f.comp (X * X)).coeff n = if Even n then f.coeff (n / 2) else 0

lemma dappend_left_of_lt {motive : Fin (m + n) ‚Üí Sort u}
    (u : (i : Fin m) ‚Üí motive (castAdd n i)) (v : (i : Fin n) ‚Üí motive (natAdd m i))
    (i : Fin (m + n)) (h : i.val < m) :
      dappend (motive := motive) u v i = cast (by simp) (u ‚ü®i, h‚ü©)

nonpos_iff_eq_zero in Mathlib.Algebra.Order.Monoid.Canonical.Defs

@[simp]
theorem mul_accepts_iff : (mul a b c).accepts x ‚Üî x c = x a * x b

@[simp]
lemma range_def : (spec Œ±).range () = Œ±

lemma cube_map_bijective :
    Function.Bijective (fun x : (Field)À£ => x ^ (3 : Nat))

@[simp]
theorem simulateQ'_query (q : OracleQuery spec Œ±) :
    simulateQ' so q (by simp) = so.impl q

lemma getBit_two_pow {i k : ‚Ñï} : (getBit k (2^i) = if i == k then 1 else 0)

@[simp]
lemma eval‚ÇÇ_C' {r : R} {S : Type w} [CommSemiring S] (f : R ‚Üí+* S) (x : S) :
    eval‚ÇÇ (P := P) f x (C r) = f r

theorem Nat.reconstruct_from_hi_and_lo_parts_or_ver (n hi_len lo_len : ‚Ñï)
  (h_n : n < 2 ^ (hi_len + lo_len)) :
    n = (((n >>> lo_len) % (2 ^ hi_len)) <<< lo_len) ||

theorem prime_11 : Nat.Prime 11

lemma aeval_eq {A : Type w} [CommSemiring A] [Algebra R A] (f : P ‚Üí‚Çê[R] A) : f = aeval (f X)

lemma e_ball_le_radius [Field F] [Fintype F] {B : Finset (Fin n ‚Üí F)} (v : Fin n ‚Üí F) (r : ‚Ñö)
  :
  e (B ‚à© ({ x | Œî‚ÇÄ(x, v) ‚â§ r} : Finset _)) v ‚â§ r

@[simp]
theorem BTField.Basis_cast_dest_apply {Œπ : Type*} (Œ± Œ≤ Œ≥ : ‚Ñï) (h_le1 : Œ± ‚â§ Œ≤) (h_le2 : Œ± ‚â§ Œ≥)
    (h_eq : Œ≤ = Œ≥) {k : Œπ} (b : @Basis Œπ (BTField Œ±) (BTField Œ≤) _ _
    (@binaryAlgebraTower (l := Œ±) (r := Œ≤) (h_le := h_le1)).toModule) :
    let castBasis : @Basis Œπ (BTField Œ±) (BTField Œ≥) _ _
      (@binaryAlgebraTower (l := Œ±) (r := Œ≥) (h_le := h_le2)).toModule :=
      cast (by
        exact Basis_cast_dest_eq Œ± Œ≥ Œ≤ h_le2 h_le1 h_eq
      ) b
    (castBasis k) = cast (by exact BTField.cast_BTField_eq Œ≤ Œ≥ h_eq) (b k)

@[simp]
theorem drop_zero (v : (i : Fin n) ‚Üí Œ± i) : drop 0 n.zero_le v = v

lemma cast_ConcreteBTField_eq (k m : ‚Ñï) (h_eq : k = m) :
  ConcreteBTField k = ConcreteBTField m

theorem liftContext_soundness [Inhabited InnerStmtOut]
    {outerLangIn : Set OuterStmtIn} {outerLangOut : Set OuterStmtOut}
    {innerLangIn : Set InnerStmtIn} {innerLangOut : Set InnerStmtOut}
    {soundnessError : ‚Ñù‚â•0}
    {lens : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut}
    (V : Verifier oSpec InnerStmtIn InnerStmtOut pSpec)
    -- TODO: figure out the right compatibility relation for the IsSound condition
    [lensSound : lens.IsSound outerLangIn outerLangOut innerLangIn innerLangOut
      (V.compatStatement lens)]
    (h : V.soundness init impl innerLangIn innerLangOut soundnessError) :
      (V.liftContext lens).soundness init impl outerLangIn outerLangOut soundnessError

theorem dcast_symm (ha : a = a') (hb : dcast ha b = b') : dcast (ha.symm) b' = b

omit [Finite F] in
private lemma op_der_eq : Monoid.toMulAction FÀ£ = Units.mulAction'

theorem fappend_ext {Œ± : Fin m ‚Üí A} {Œ≤ : Fin n ‚Üí A}
    (u‚ÇÅ u‚ÇÇ : (i : Fin m) ‚Üí F (Œ± i)) (v‚ÇÅ v‚ÇÇ : (i : Fin n) ‚Üí F (Œ≤ i)) :
    fappend u‚ÇÅ v‚ÇÅ = fappend u‚ÇÇ v‚ÇÇ ‚Üî u‚ÇÅ = u‚ÇÇ ‚àß v‚ÇÅ = v‚ÇÇ

lemma is_berlekamp_welch_solution_ext
  (h : ‚àÄ i, (Matrix.mulVec (BerlekampWelchMatrix e k œâs f) v) i = -(f i) * (œâs i) ^ e)
  : IsBerlekampWelchSolution e k œâs f v

lemma h_middle_sub {k : ‚Ñï} : 2 ^ (k - 1) - 1 - 0 + 1 = 2 ^ (k - 1)

theorem cast_symm {Œ± Œ≤ : Sort u} {h : Œ± = Œ≤} {a : Œ±} {b : Œ≤} :
    cast h a = b ‚Üî a = cast h.symm b

@[simp]
theorem rtake_append_right (T : FullTranscript pSpec‚ÇÅ) (T' : FullTranscript pSpec‚ÇÇ) :
    (T ++‚Çú T').rtake n (Nat.le_add_left n m) =
      T'.cast rfl (by simp [ProtocolSpec.append])

@[simp]
theorem hflatten_one {n : Fin 1 ‚Üí ‚Ñï} {Œ± : (i : Fin 1) ‚Üí (j : Fin (n i)) ‚Üí Sort*}
    {v : (i : Fin 1) ‚Üí (j : Fin (n i)) ‚Üí Œ± i j} : hflatten v = v 0

theorem neg_add_cancel : -p + p = 0

lemma algebraMap_adjacent_tower_succ_eq_Adjoin_of (k : ‚Ñï) :
  (algebraMap (BTField k) (BTField (k + 1))) = of (poly k)

@[simp]
lemma halfNumFullRounds_mul_2_eq_numFullRounds :
    params.halfNumFullRounds * 2 = params.numFullRounds

@[simp]
theorem PowerBasis.cast_basis_succ_of_eq_rec_apply
    (r1 r : ‚Ñï) (h_r : r = r1 + 1)
    (k : Fin 2) :
    letI instAlgebra : Algebra (ConcreteBTField r1) (ConcreteBTField r) :=
      ConcreteBTFieldAlgebra (l:=r1) (r:=r) (h_le:=by omega)
    letI instAlgebraSucc : Algebra (ConcreteBTField (r1 + 1)) (ConcreteBTField (r)) :=
      ConcreteBTFieldAlgebra (l:=r1 + 1) (r:=r) (h_le:=by omega)
    let b : PowerBasis (ConcreteBTField r1) (ConcreteBTField (r1 + 1))
      := powerBasisSucc (k:=r1)
    let bCast : PowerBasis (ConcreteBTField r1) (ConcreteBTField r) := Eq.rec (motive:=
      fun (x : ‚Ñï) (_ : r1 + 1 = x) => by
        letI instAlgebraCur : Algebra (ConcreteBTField r1) (ConcreteBTField x) :=
          ConcreteBTFieldAlgebra (l:=r1) (r:=x) (h_le:=by omega)
        exact PowerBasis (ConcreteBTField r1) (ConcreteBTField x)) (refl:=b) (t:=h_r.symm)
    have h_pb_dim : b.dim = 2 := by
      exact powerBasisSucc_dim r1

    have h_pb'_dim : bCast.dim = 2 := by
      dsimp [bCast]
      rw [PowerBasis.dim_of_eq_rec (r1:=r1) (r:=r) (h_r:=h_r) (b:=b)]
      exact h_pb_dim

    have h_pb_type_eq : Basis (Fin bCast.dim) (ConcreteBTField r1) (ConcreteBTField r) =
      Basis (Fin 2) (ConcreteBTField r1) (ConcreteBTField r) := by
      congr

   -- The `cast` needs a proof that `bCast.dim = 2`. We construct it here.
    let left : Basis (Fin 2) (ConcreteBTField r1) (ConcreteBTField r)
      := cast (by exact h_pb_type_eq) bCast.basis
    let right := (algebraMap (ConcreteBTField (r1 + 1)) (ConcreteBTField r))
      (b.basis (Fin.cast h_pb_dim.symm k))
    left k = right

private lemma johnson_unrefined_by_M' [Zero F]
  (h_n : 0 < n)
  (h_B : 2 ‚â§ B.card)
  (h_card : 2 ‚â§ (Fintype.card F))
  :
  B.card * (Fintype.card F / (Fintype.card F - 1)) *
           ((1 - e B 0 / n) ^ 2  + e B 0 ^ 2 / ((Fintype.card F - 1) * n^2) - 1 + d B/n)
  ‚â§
  (Fintype.card F / (Fintype.card F - 1)) * d B/n

lemma getBit_of_middleBits {n offset len k : ‚Ñï} :
  getBit k (getMiddleBits offset len n) =
    if k < len then getBit (k + offset) n else 0

@[simp]
theorem OracleReduction.id_run (stmt : StmtIn) (oStmt : ‚àÄ i, OStmtIn i) (wit : WitIn) :
    (OracleReduction.id : OracleReduction oSpec StmtIn OStmtIn WitIn _ _ _ _).run stmt oStmt wit =
      pure ‚ü®‚ü®default, ‚ü®stmt, oStmt‚ü©, wit‚ü©, ‚ü®stmt, oStmt‚ü©‚ü©

private lemma johnson_unrefined_by_M [Zero F]
  (h_n : 0 < n)
  (h_B : 2 ‚â§ B.card)
  (h_card : 2 ‚â§ (Fintype.card F))
  :
  B.card * ((1 - e B 0 / n) ^ 2  + (e B 0) ^ 2 / ((Fintype.card F - 1) * n^2) - 1 + d B/n)
  ‚â§
  d B/n

lemma domain_injective (i : ‚Ñï) : i ‚â§ n ‚Üí Function.Injective (domain D n i)

lemma testBit_false_eq_getBit_eq_0 (k n : Nat) :
  (n.testBit k = false) = ((Nat.getBit k n) = 0)

theorem hconcat_left_injective {Œ± : Fin n ‚Üí Sort u} {Œ≤ : Sort u} (a : Œ≤) :
    Function.Injective (fun v : (i : Fin n) ‚Üí Œ± i => hconcat v a)

Fin.val_injective in Mathlib.Data.Fin.Basic

@[simp] theorem rightpad_getD_eq_getD (l : List Œ±) (n : Nat) (unit : Œ±) (i : Nat) :
    (rightpad n unit l).getD i unit = l.getD i unit

@[simp]
theorem dflatten_splitSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {motive : (k : Fin (vsum n)) ‚Üí Sort*}
    (v : (k : Fin (vsum n)) ‚Üí motive k) (k : Fin (vsum n)) :
    dflatten (motive := motive) (fun i j => v (embedSum i j)) k = v k

theorem degreeOf_eval_C_finSuccEquiv (p : MvPolynomial (Fin (n + 1)) R) (j : Fin n) (x : R) :
    degreeOf j (Polynomial.eval (C x) (finSuccEquiv R n p)) ‚â§ degreeOf j.succ p

private theorem toNat_mulNat (a : AssocNat) (k : Nat) : toNat (mulNat a k) = toNat a * k

@[simp]
theorem insertNth_last : insertNth (Fin.last n) y s = snoc s y

@[simp]
lemma Basis.baseChangeRight_apply (b : Basis Œπ K Left) (i : Œπ) :
    (Basis.baseChangeRight (b:=b) (Right:=Right)) i = b i ‚äó‚Çú[K] 1

omit h_Fq_char_prime hF‚ÇÇ in
lemma rootMultiplicity_prod_W_comp_X_sub_C
    (i : Fin r) (h_i_add_1 : i + 1 < r) (a : L) :
    rootMultiplicity a ((univ : Finset ùîΩq).prod (fun c => (W ùîΩq Œ≤ i).comp (X - C (c ‚Ä¢ Œ≤ i)))) =
    if a ‚àà (U ùîΩq Œ≤ (i+1) : Set L) then 1 else 0

@[simp]
theorem addCases'_left {m n : ‚Ñï} {Œ± : Fin m ‚Üí Sort u} {Œ≤ : Fin n ‚Üí Sort u}
    (left : (i : Fin m) ‚Üí Œ± i) (right : (j : Fin n) ‚Üí Œ≤ j) (i : Fin m) :
      addCases' left right (Fin.castAdd n i) = (Fin.append_left Œ± Œ≤ i) ‚ñ∏ (left i)

lemma eqRec_fun_eqRec_sort_eq_self {Œ± : Sort*} {Œ≤ : Œ± ‚Üí Sort u} {a a' : Œ±}
    (h : a = a') (h' : Œ≤ a = Œ≤ a') (b : Œ≤ a) :
  b = h ‚ñ∏ h' ‚ñ∏ b

theorem rightpad_eq_rightpad_max (l : List Œ±) (n : Nat) :
    rightpad n unit l = rightpad (max n l.length) unit l

lemma W_monic (i : Fin r) : (W ùîΩq Œ≤ i).Monic

@[simp]
lemma liftF'_liftF_succ {f : Fin (n + 1) ‚Üí Œ±} {x : Fin n} :
  liftF' (liftF (n := n + 1) f) x = f x.castSucc

theorem oracleReduction_perfectCompleteness (hInit : init.neverFails) :
    (oracleReduction R deg D oSpec).perfectCompleteness init impl
      (inputRelation R deg D) (outputRelation R deg)

@[simp]
theorem Basis_cast_index_eq (i j k n : ‚Ñï) (h_le : k ‚â§ n) (h_eq : i = j) :
    letI instAlgebra : Algebra (ConcreteBTField k) (ConcreteBTField n) :=
      ConcreteBTFieldAlgebra (l:=k) (r:=n) (h_le:=h_le)
    letI : Module (ConcreteBTField k) (ConcreteBTField n) := instAlgebra.toModule
    (Basis (Fin (i)) (ConcreteBTField k) (ConcreteBTField n)) =
    (Basis (Fin (j)) (ConcreteBTField k) (ConcreteBTField n))

lemma dappend_right_of_not_lt {motive : Fin (m + n) ‚Üí Sort u}
    (u : (i : Fin m) ‚Üí motive (castAdd n i)) (v : (i : Fin n) ‚Üí motive (natAdd m i))
    (i : Fin (m + n)) (h : ¬¨ i.val < m) :
      dappend (motive := motive) u v i = dcast (by ext; simp; omega) (v ‚ü®i - m, by omega‚ü©)

@[csimp]
theorem dappend_eq_addCases : @dappend = @addCases

@[simp]
theorem init_apply : init s i = s i.castSucc

@[simp]
theorem init_update_castSucc : init (update s i.castSucc y) = update (init s) i y

lemma getMiddleBits_lt_two_pow {n offset len : ‚Ñï} :
  getMiddleBits offset len n < 2 ^ len

theorem cast_runToRound (j : Fin (n‚ÇÅ + 1)) (stmt : StmtIn) (wit : WitIn)
    (P : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec‚ÇÅ) :
    P.runToRound j stmt wit =
      cast (sorry) ((P.cast hn hSpec).runToRound (Fin.cast (congrArg (¬∑ + 1) hn) j) stmt wit)

theorem sum_fromNat_eq_from_xor_Nat {k : ‚Ñï} (x y : Nat) :
  fromNat (k:=k) (x ^^^ y) = fromNat (k:=k) x + fromNat (k:=k) y

@[simp]
lemma solutionToE_and_Q_E_and_Q_to_a_solution :
  E_and_Q_to_a_solution e (solutionToE e k v) (solutionToQ e k v) = v

theorem is_prime : Nat.Prime fieldSize

lemma getBit_of_multiple_of_power_of_two {n p : ‚Ñï}: ‚àÄ k,
  getBit (k) (2^p * n) = if k < p then 0 else getBit (k-p) n

Nat.lt_of_add_right_lt in Init.Data.Nat.Basic

omit [Finite F] in
lemma neg_mem_dom_of_mem_dom : ‚àÄ {a : FÀ£} (i : Fin n),
    a ‚àà evalDomain D x i ‚Üí - a ‚àà evalDomain D x i

lemma getBit_of_lowBits {n: ‚Ñï} (numLowBits : ‚Ñï) : ‚àÄ k, getBit k (getLowBits numLowBits n) =
    if k < numLowBits then getBit k n else 0

lemma powerBasisSucc_dim (k : ‚Ñï) :
  powerBasisSucc (k:=k).dim = 2

@[simp]
lemma solutionToQ_zero {v : Fin (2 * 0 + 0) ‚Üí F} :
  solutionToQ (F := F) 0 0 v = 0

@[simp]
theorem vconcat_zero (a : Œ±) : vconcat !v[] a = !v[a]

lemma fold_f_g
  {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F} {k m : ‚Ñï}
  {œÜ_0 : (indexPowT S œÜ 0) ‚Ü™ F} {œÜ_k : (indexPowT S œÜ k) ‚Ü™ F}
  [Fintype (indexPowT S œÜ 0)] [DecidableEq (indexPowT S œÜ 0)] [Smooth œÜ_0]
  [Fintype (indexPowT S œÜ k)] [DecidableEq (indexPowT S œÜ k)] [Smooth œÜ_k]
  [‚àÄ i : ‚Ñï, Neg (indexPowT S œÜ i)]
  (Œ±s : Fin k ‚Üí F) (hk : k ‚â§ m)
  (f : smoothCode œÜ_0 m) :
  let f_fun := (f : (indexPowT S œÜ 0) ‚Üí F)
  let g := fold_k f_fun Œ±s hk
  g ‚àà smoothCode œÜ_k (m - k)

theorem is_prime : Nat.Prime fieldSize

@[simp]
lemma Rhs_zero_eq_neg : Rhs 0 œâs f i = -f i

theorem dcast‚ÇÉ_eq_dcast‚ÇÉ_iff (ha : a = a') (hb : dcast ha b = b') (hc : dcast‚ÇÇ ha hb c = c') :
    dcast‚ÇÉ ha hb hc d = d' ‚Üî d = dcast‚ÇÉ ha.symm (dcast_symm ha hb) (dcast‚ÇÇ_symm ha hb hc) d'

lemma towerRingHomForwardMap_split_eq (k : ‚Ñï) (h_pos : k > 0) (x : ConcreteBTField k) :
  let p := split (k:=k) (h:=h_pos) x
  towerRingHomForwardMap (k:=k) (x) =
    BinaryTower.join_via_add_smul (k:=k) (h_pos:=h_pos)
      (hi_btf := towerRingHomForwardMap (k:=k-1) (p.1))
      (lo_btf := towerRingHomForwardMap (k:=k-1) (p.2))

lemma subUpFull_of_vandermonde_is_vandermonde (h : n ‚â§ m) :
  Matrix.vandermonde (Œ± ‚àò Fin.castLE h) =
  Matrix.subUpFull (nonsquare n Œ±) (Fin.castLE h)

@[simp]
lemma runWithLogToRound_discard_log_eq_runToRound (i : Fin (n + 1))
    (stmt : StmtIn) (wit : WitIn) (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      Prod.fst <$> prover.runWithLogToRound i stmt wit =
        prover.runToRound i stmt wit

@[simp]
lemma length_getTypes (l : HList) : l.getTypes.length = l.length

theorem frobenius_identity_in_algebra [Fact (Nat.Prime (ringChar Fq))]
  (f g : L[X]) : (f + g)^(Fintype.card Fq) = f^(Fintype.card Fq) + g^(Fintype.card Fq)

theorem degreeOf_X_of_ne (i j : œÉ) (h : i ‚â† j) : degreeOf i (X (R := R) j) = 0

lemma W_prod_comp_decomposition
    (i : Fin r) (hi : i > 0) :
    (W ùîΩq Œ≤ i) = ‚àè c: ùîΩq, (W ùîΩq Œ≤ (i-1)).comp (X - C (c ‚Ä¢ Œ≤ (i-1)))

theorem qMap_is_linear_map (i : Fin r) :
  IsLinearMap ùîΩq (f:=fun inner_p ‚Ü¶ (qMap ùîΩq Œ≤ i).comp inner_p)

lemma getBit_of_shiftLeft {n p : ‚Ñï}:
  ‚àÄ k, getBit (k) (n <<< p) = if k < p then 0 else getBit (k - p) n

theorem mul_distrib_add {a b : CNat 1} : a * (b + 1) = a * b + a

private lemma natDegree_E
  (h : (Œî‚ÇÄ(f, p.eval ‚àò œâs) : ‚Ñï) ‚â§ e) :
  (E (œâs := œâs) f p e).natDegree = e

theorem eval_toPoly_eq_eval (x : Q) (p : UniPoly Q) : p.toPoly.eval x = p.eval x

theorem evenRefinement_eq_novel_poly_of_0_leading_suffix (i : Fin ‚Ñì) (v : Fin (2 ^ i.val))
    (original_coeffs : Fin (2 ^ ‚Ñì) ‚Üí L) :
    have h_v: v.val < 2 ^ (i.val + 1) := by
      calc v.val < 2 ^ i.val := by omega
        _ < 2 ^ (i.val + 1) := by apply Nat.pow_lt_pow_right (by omega) (by omega)
    evenRefinement ùîΩq Œ≤ h_‚Ñì_add_R_rate i (coeffsBySuffix (r:=r)
      (R_rate:=R_rate) (a:=original_coeffs) ‚ü®i, by omega‚ü© v) =
    intermediateEvaluationPoly ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i + 1, by omega‚ü©
      (coeffsBySuffix (r:=r) (R_rate:=R_rate) original_coeffs ‚ü®i + 1, by omega‚ü© ‚ü®v, h_v‚ü©)

lemma isField_of_irreducible {H : F[X][Y]} : Irreducible H ‚Üí IsField (ùïÉ H)

lemma getLowBits_joinBits {n m : ‚Ñï} (low : Fin (2 ^ n)) (high : Fin (2 ^ m)) :
  getLowBits n (joinBits low high).val = low.val

theorem BitVec.bitvec_cast_eq_dcast {n m : Nat} (h : n = m) (bv : BitVec n) :
  BitVec.cast h bv = DCast.dcast h bv

omit [NoZeroDivisors ùîΩ] in
lemma splitNth_degree_le {n : ‚Ñï} {f : ùîΩ[X]} [inst : NeZero n] :
  ‚àÄ {i}, (splitNth f n i).natDegree ‚â§ f.natDegree / n

private lemma Fis_cover_B : B = Finset.univ.biUnion (Fi B i)

@[simp] -- main lemma for bIdx: Fin (‚Ñì / œë - 1) bounds
lemma bIdx_mul_œë_add_x_lt_‚Ñì_sub_œë (bIdx : Fin (‚Ñì / œë - 1)) (x : ‚Ñï) {hx : x ‚â§ œë} :
    ‚ÜëbIdx * œë + x ‚â§ ‚Ñì - œë

theorem one_le_two_pow_n (n : ‚Ñï) : 1 ‚â§ 2 ^ n

@[simp]
theorem acceptRejectOracleRel_language :
    acceptRejectOracleRel.language = { (true, isEmptyElim) }

omit [DecidableEq ùîΩq] hF‚ÇÇ h_Œ≤‚ÇÄ_eq_1 in
lemma get_sDomain_first_basis_eq_1 (i : Fin r) (h_i : i < ‚Ñì + R_rate) :
    (sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate
    i (by omega)) ‚ü®0, by omega‚ü© = (1: L)

lemma matching_set_is_a_sub_of_coeffs_of_close_proximity
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  : matching_set k œâs Œ¥ u‚ÇÄ u‚ÇÅ h_gs ‚äÜ coeffs_of_close_proximity k œâs Œ¥ u‚ÇÄ u‚ÇÅ

theorem non_trivial_factors_of_non_trivial_poly_have_deg_ge_1 {R : Type*} [Field R]
    {p a b : R[X]}
    (h_prod : p = a * b)
    (h_p_nonzero : p ‚â† 0)
    (h_a_non_unit : ¬¨IsUnit a)
    (h_b_non_unit : ¬¨IsUnit b) :
    1 ‚â§ a.degree ‚àß 1 ‚â§ b.degree

lemma coprime_three_fieldSize_sub_one : Nat.Coprime 3 (fieldSize - 1)

theorem eqPolynomial_symm (x : œÉ ‚Üí R) (y : œÉ ‚Üí R) :
    MvPolynomial.eval y (eqPolynomial x) = MvPolynomial.eval x (eqPolynomial y)

omit h_Fq_char_prime in
theorem changeOfBasisMatrix_lower_triangular
  (‚Ñì : Nat) (h_‚Ñì : ‚Ñì ‚â§ r) :
  (changeOfBasisMatrix ùîΩq Œ≤ ‚Ñì h_‚Ñì).BlockTriangular ‚áëOrderDual.toDual

theorem not_irreducible_of_isRoot_of_degree_gt_one
  (p : R[X]) (h_root : ‚àÉ r : R, IsRoot p r) (h_deg : p.degree > 1) :
  ¬¨ Irreducible p

omit [Finite F] in
lemma minus_one_in_doms {i : ‚Ñï} (h : i < n) :
    -1 ‚àà evalDomain D i

theorem insertNth_support :
    (insertNth p y s).support ‚äÜ insert p (s.support.map (Fin.succAboveEmb p))

theorem liftContext_perfectCompleteness
    (h : R.perfectCompleteness init impl innerRelIn innerRelOut) :
      (R.liftContext lens).perfectCompleteness init impl outerRelIn outerRelOut

@[simp]
theorem dconcat_last {motive : Fin (n + 1) ‚Üí Sort u} (v : (i : Fin n) ‚Üí motive (castSucc i))
    (a : motive (last n)) : (v :+·µà‚ü®motive‚ü© a) (last n) = a

lemma degree_s_smul_X_add_1 {F : Type*} [Field F] [Fintype F] (s : F) [NeZero s] :
  (C s * (X : (F)[X]) + 1).degree = 1

theorem eq_zero_of_degreeOf_lt_card_of_eval_eq_zero {p : R[X œÉ]} (S : œÉ ‚Üí Finset R)
    (hDegree : ‚àÄ i, p.degreeOf i < #(S i))
    (hEval : ‚àÄ x ‚àà piFinset fun i ‚Ü¶ S i, eval x p = 0) : p = 0

omit hF‚ÇÇ in
theorem kernel_W_eq_U (i : Fin r) :
  LinearMap.ker (polyEvalLinearMap (W ùîΩq Œ≤ i)
    (W_is_additive ùîΩq Œ≤ i)) = U ùîΩq Œ≤ i

theorem canonical_empty : (UniPoly.mk (R:=R) #[]).trim = #[]

lemma linearIndependent_rows_of_lower_triangular_ne_zero_diag
  {n : ‚Ñï} {R : Type*} [Field R] (A : Matrix (Fin n) (Fin n) R)
  (h_lower_triangular : A.BlockTriangular ‚áëOrderDual.toDual) (h_diag : ‚àÄ i, A i i ‚â† 0) :
  LinearIndependent R A

theorem drop_eq_rtake (m : ‚Ñï) (h : m ‚â§ n) (v : (i : Fin n) ‚Üí Œ± i) :
    drop m h v = fun i => dcast (by simp [Fin.cast]; omega) (rtake (n - m) (by omega) v i)

lemma rootMultiplicity_comp_X_sub_C (p : L[X]) (a x : L) :
    rootMultiplicity x (p.comp (X - C a)) = rootMultiplicity (x - a) p

theorem join_of_split {k : ‚Ñï} (h_pos : k > 0) (x : ConcreteBTField k)
    (hi_btf lo_btf : ConcreteBTField (k - 1))
    (h_split_eq : split h_pos x = (hi_btf, lo_btf)) :
    x = „Ää hi_btf, lo_btf „Äã

theorem linear_map_of_comp_to_linear_map_of_eval (f : L[X])
  (h_f_linear : IsLinearMap (R := Fq) (M := L[X]) (M‚ÇÇ := L[X])
    (f := fun inner_p ‚Ü¶ f.comp inner_p)) :
    IsLinearMap (R := Fq) (M := L) (M‚ÇÇ := L) (f := fun x ‚Ü¶ f.eval x)

private lemma johnson_condition_strong_implies_2_le_F_card
  (h_johnson : JohnsonConditionStrong B v)
  :
  2 ‚â§ Fintype.card F

@[simp]
theorem fconcat‚ÇÇ_last {Œ±‚ÇÅ : Fin n ‚Üí A} {Œ±‚ÇÇ : Fin n ‚Üí B} {Œ≤‚ÇÅ : A} {Œ≤‚ÇÇ : B}
    (v : (i : Fin n) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i)) (a : F‚ÇÇ Œ≤‚ÇÅ Œ≤‚ÇÇ) :
    fconcat‚ÇÇ (F := F‚ÇÇ) v a (last n) = cast (by simp [vconcat_last]) a

private lemma solutionToE_from_E
  (h_p_deg : p.natDegree < k)
  (h_dist : (Œî‚ÇÄ(f, p.eval ‚àò œâs) : ‚Ñï) ‚â§ e)
  : solutionToE e k (E_and_Q_to_a_solution e (E œâs f p e) (Q œâs f p e)) = E œâs f p e

lemma aeval_eq' {A : Type y} [CommSemiring A] [Algebra R A] {F : Type z} [FunEquiv F œÉ A]
    (f : P ‚Üí‚Çê[R] A) (p : P) : f p = aeval (fun s => f (X s) : F) p

theorem join_eq_iff_dcast_extractLsb {k : ‚Ñï} (h_pos : k > 0) (x : ConcreteBTField k)
  (hi_btf lo_btf : ConcreteBTField (k - 1)) :
  x = „Ää hi_btf, lo_btf „Äã ‚Üî
  (hi_btf = dcast (h_sub_middle h_pos) (BitVec.extractLsb (hi := 2 ^ k - 1) (lo := 2 ^ (k - 1)) x) ‚àß
  lo_btf = dcast (h_middle_sub) (BitVec.extractLsb (hi := 2 ^ (k - 1) - 1) (lo := 0) x))

@[simp]
theorem simulateQ_bind_fst (oa : OracleComp spec Œ±) (f : Œ± ‚Üí OracleComp spec Œ≤) :
    (do let a ‚Üê (simulateQ loggingOracle oa).run; f a.1) = oa >>= f

lemma mca_linearCode
  (Gen : ProximityGenerator Œπ F) [Fintype Gen.par‚Ñì] [Nonempty Gen.par‚Ñì]
  (C : LinearCode Œπ F) (hC : C = Gen.C) :
    hasMutualCorrAgreement
     -- Gen
      Gen
    -- BStar (using Œ¥·µ£ produced )
      (min (1 - (Œ¥·µ£ (C : Set (Œπ ‚Üí F))) / 2) (Gen.B Gen.C Gen.par‚Ñì))
    -- errStar
      (fun Œ¥ => Gen.err C Gen.par‚Ñì Œ¥)

theorem sum_of_root_and_inverse_is_t1
    {curBTField : Type*} [Field curBTField]
    (u : curBTField) (t1 : curBTField) -- here t1 is already lifted to curBTField
    (specialElementNeZero : u ‚â† 0)
    (eval_prevPoly_at_root : u ^ 2 + t1 * u + 1 = 0)
    (sumZeroIffEq : ‚àÄ (x y : curBTField), x + y = 0 ‚Üî x = y) :
    u + u‚Åª¬π = t1

@[simp]
theorem sum_degreeLT_monomial_eq_subtype {n : ‚Ñï} (p : L‚¶É< n‚¶Ñ[X]) :
  (‚ü®p.val.sum (fun n a => Polynomial.monomial n a), by
    -- degree of sum is degree of p.val, which is < n
    rw [Polynomial.sum_monomial_eq p.val]
    exact p.property
  ‚ü© : L‚¶É< n‚¶Ñ[X]) = p

lemma add_eq_one_iff (a b : ConcreteBTField 0) :
  a + b = 1 ‚Üî (a = 0 ‚àß b = 1) ‚à® (a = 1 ‚àß b = 0)

lemma blockRelDistance_eq_relHammingDist_of_k_eq_i -- Renamed for clarity
  (i : ‚Ñï) {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F}
  [DecidableEq F] [DecidableEq Œπ] [Smooth œÜ]
  -- The Fintype instance is now declared before it is needed by `hS'`.
  [h_fintype : ‚àÄ i : ‚Ñï, Fintype (indexPowT S œÜ i)]
  (f g : (indexPowT S œÜ i) ‚Üí F) (S' : Finset (indexPowT S œÜ i))
  (hS' : S' = Finset.univ) -- This now works.
  (œÜ' : (indexPowT S œÜ i) ‚Ü™ F)
  [h_dec : DecidableBlockDisagreement i i f S' œÜ'] [DecidableEq (indexPowT S œÜ i)] :
  Œî·µ£(i, i, f, S', œÜ', g) = Œ¥·µ£(f, g)

Nat.succ_lt_succ_iff in Init.Data.Nat.Basic

lemma ConcreteBTFieldAlgebra_def (l r : ‚Ñï) (h_le : l ‚â§ r) :
    @ConcreteBTFieldAlgebra (l:=l) (r:=r) (h_le:=h_le)
    = (concreteTowerAlgebraMap l r h_le).toAlgebra

@[simp]
theorem dcast_eq : dcast (Eq.refl a) b = b

theorem LeafData.composeBuild_internal {Œ±} {s_left s_right : Skeleton}
    (left : LeafData Œ± s_left) (right : LeafData Œ± s_right)
    (compose : Œ± ‚Üí Œ± ‚Üí Œ±) :
    (LeafData.internal left right).composeBuild compose =
      FullData.internal
        (compose (left.composeBuild compose).getRootValue (right.composeBuild compose).getRootValue)
        (left.composeBuild compose)
        (right.composeBuild compose)

theorem GF_2_pow_card (x : GF(2)) : x ^ Fintype.card (GF(2)) = x

theorem BitVec.eq_append_iff_extract {lo_size hi_size : ‚Ñï} (lo : BitVec lo_size)
  (hi : BitVec hi_size) (h_hi_gt_0 : hi_size > 0) (h_lo_gt_0 : lo_size > 0)
  (x : BitVec (hi_size + lo_size)) : x = dcast (by rfl) (BitVec.append (msbs:=hi) (lsbs:=lo)) ‚Üî
  hi = dcast (by omega) (BitVec.extractLsb (hi:=hi_size + lo_size - 1) (lo:=lo_size) x) ‚àß
  lo = dcast (by omega) (BitVec.extractLsb (hi:=lo_size - 1) (lo:=0) x)

theorem eq_join_via_add_smul_eq_iff_split (k : ‚Ñï) (h_pos : k > 0)
    (x : BTField k) (hi_btf lo_btf : BTField (k - 1)) :
    x = ‚ãò hi_btf, lo_btf ‚ãô ‚Üî
  split (k:=k) (h_k:=h_pos) x = (hi_btf, lo_btf)

@[simp]
private lemma evenPart'_coeffs {f : Polynomial F} {n : ‚Ñï} :
    (evenPart' f).coeff n = if Even n then f.coeff n else 0

@[simp]
theorem head_cons {Œ±} {n : ‚Ñï} (hd : Œ±) (tl : Vector Œ± n) : (cons hd tl).head = hd

@[simp]
theorem card_prod_self_eq :
  #(((s √óÀ¢ s : Finset _) ‚à© ({x : Œ± √ó Œ± | x.1 = x.2} : Finset _)) : Finset _) = #s

@[simp]
theorem prover_last_of_two (pSpec : ProtocolSpec 2) [ProverLast pSpec] :
    pSpec.dir 1 = .P_to_V

lemma xor_eq_sub_iff_submask {n m : ‚Ñï} (h: m ‚â§ n) : n ^^^ m = n - m ‚Üî n &&& m = m

theorem fcons‚ÇÇ_right_injective {Œ±‚ÇÅ : A} {Œ±‚ÇÇ : B} {Œ≤‚ÇÅ : Fin n ‚Üí A} {Œ≤‚ÇÇ : Fin n ‚Üí B}
    (a : F‚ÇÇ Œ±‚ÇÅ Œ±‚ÇÇ) :
    Function.Injective
      (fcons‚ÇÇ (F := F‚ÇÇ) a : ((i : Fin n) ‚Üí F‚ÇÇ (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) ‚Üí (i : Fin (n + 1)) ‚Üí _ )

theorem qMap_maps_sDomain (i : Fin r) (h_i_add_1 : i + 1 < r) :
  have q_comp_linear_map := qMap_is_linear_map ùîΩq Œ≤ i
  have q_eval_linear_map := linear_map_of_comp_to_linear_map_of_eval
    (f:=qMap ùîΩq Œ≤ i) q_comp_linear_map
  let q_i_map := polyEvalLinearMap (qMap ùîΩq Œ≤ i) q_eval_linear_map
  let S_i := sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i
  let S_i_plus_1 := sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i+1)
  Submodule.map q_i_map S_i = S_i_plus_1

lemma add_two_pow_of_getBit_eq_zero_lt_two_pow {n m i : ‚Ñï} (h_n: n < 2^m) (h_i: i < m)
  (h_getBit_at_i_eq_zero: getBit i n = 0) :
  n + 2^i < 2^m

lemma solution_gamma_matches_word_if_subset_large
  {œâs : Fin n ‚Ü™ F}
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  {x : Fin n}
  {D : ‚Ñï}
  (hD : D ‚â• Bivariate.totalDegree (H k Œ¥ x‚ÇÄ h_gs))
  (hx : (matching_set_at_x k Œ¥ h_gs x).card >
    (2 * k + 1)
      * (Bivariate.natDegreeY <| H k Œ¥ x‚ÇÄ h_gs)
      * (Bivariate.natDegreeY <| R k Œ¥ x‚ÇÄ h_gs)
      * D)
  : (P k Œ¥ x‚ÇÄ h_gs).eval (Polynomial.C (œâs x)) =
    (Polynomial.C <| u‚ÇÄ x) + u‚ÇÅ x ‚Ä¢ Polynomial.X

omit [Fintype F] in
private lemma d_eq_sum {B : Finset (Fin n ‚Üí F)}
  (h_B : 2 ‚â§ B.card)
  :
  2 * choose_2 B.card * d B =
  ‚àë i, ‚àë x ‚àà B √óÀ¢ B with x.1 ‚â† x.2, (if x.1 i ‚â† x.2 i then 1 else 0)

lemma algebra_adjacent_tower_def (l : ‚Ñï) :
  (algebra_adjacent_tower l) = (canonicalEmbedding l).toAlgebra

@[simp]
theorem BTField.PowerBasis.dim_of_eq_rec
    (r1 r : ‚Ñï)
    (h_r : r = r1 + 1)
    (b : PowerBasis (BTField r1) (BTField (r1 + 1))) :
    letI instAlgebra : Algebra (BTField r1) (BTField r) :=
      binaryAlgebraTower (l:=r1) (r:=r) (h_le:=by omega)
    ((Eq.rec (motive:=fun (x : ‚Ñï) (_ : r1 + 1 = x) => by
      letI instAlgebraCur : Algebra (BTField r1) (BTField x) :=
        binaryAlgebraTower (l:=r1) (r:=x) (h_le:=by omega)
      exact PowerBasis (BTField r1) (BTField x)) (refl:=b) (t:=h_r.symm)) :
        PowerBasis (BTField r1) (BTField r)).dim
    = b.dim

@[to_additive]
lemma prod_univ_twos {M : Type*} [CommMonoid M] {n : ‚Ñï} (hn : n = 2) (f : Fin n ‚Üí M) :
    (‚àè i, f i) = f (Fin.cast hn.symm 0) * f (Fin.cast hn.symm 1)

lemma towerRingHomForwardMap0_eq :
  towerRingEquivFromConcrete0.toFun = towerRingHomForwardMap 0

@[simp, grind] lemma R_pos : 0 < sz.R

lemma divide_by_2_def {s : Finset ‚Ñï} :
    divide_by_2 s = (erase_odd s).image (fun n => n / 2)

theorem dcast‚ÇÉ_dcast‚ÇÇ : dcast‚ÇÉ rfl rfl rfl d = dcast‚ÇÇ dcast_eq.symm dcast‚ÇÇ_dcast.symm d

Nat.pred_lt_self in Init.Data.Nat.Basic

lemma sDomainBasisVectors_mem_sDomain (i : Fin r) (k : Fin (‚Ñì + R_rate - i)) :
  sDomainBasisVectors ùîΩq Œ≤ h_‚Ñì_add_R_rate i k
    ‚àà sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i

theorem eval_eq_eval_mv_eval_finSuccEquivNth (s : Fin n ‚Üí R) (y : R)
    (f : MvPolynomial (Fin (n + 1)) R) :
      eval (Fin.insertNth p y s : Fin (n + 1) ‚Üí R) f =
        Polynomial.eval y (Polynomial.map (eval s) (finSuccEquivNth R p f))

@[simp] lemma ofMvPolynomialAlgHom_X (s : œÉ) :
    ofMvPolynomialAlgHom (MvPolynomial.X s : MvPolynomial œÉ R) = (X s : P)

@[simp] theorem zero_add {a : AssocNat} : 0 + a = a

theorem cast_idx {i : MessageIdx pSpec‚ÇÅ} :
    pSpec‚ÇÇ.Message (i.cast hn hSpec) = pSpec‚ÇÅ.Message i

@[csimp]
theorem vappend_eq_append : @vappend = @append

@[simp]
theorem fflatten‚ÇÇ_succ {A : Sort u} {B : Sort v} {F : A ‚Üí B ‚Üí Sort w} {m : ‚Ñï} {n : Fin (m + 1) ‚Üí ‚Ñï}
    {Œ± : (i : Fin (m + 1)) ‚Üí (j : Fin (n i)) ‚Üí A}
    {Œ≤ : (i : Fin (m + 1)) ‚Üí (j : Fin (n i)) ‚Üí B}
    {v : (i : Fin (m + 1)) ‚Üí (j : Fin (n i)) ‚Üí F (Œ± i j) (Œ≤ i j)} :
    fflatten‚ÇÇ v = fappend‚ÇÇ (v 0) (fflatten‚ÇÇ (fun i => v i.succ))

theorem coeff_eq_coeff [LawfulBEq R] (p : UniPoly R) (i : ‚Ñï) :
  p.trim.coeff i = p.coeff i

lemma galois_eval_in_BTField
    {curBTField : Type*} [Field curBTField]
    (u : curBTField) (t1 : curBTField) -- here t1 is already lifted to curBTField
    (k : ‚Ñï)
    (sumZeroIffEq : ‚àÄ (x y : curBTField), x + y = 0 ‚Üî x = y)
    (prevSpecialElementNeZero : t1 ‚â† 0)
    (u_plus_inv_eq_t1 : u + u‚Åª¬π = t1)
    (h_u_square : u^2 = u*t1 + 1)
    (h_t1_pow : t1^(2^(2^k)-1) = 1 ‚àß (t1‚Åª¬π)^(2^(2^k)-1) = 1)
    (h_t1_pow_2_pow_2_pow_k :  t1^(2^(2^k)) = t1)
    (h_t1_inv_pow_2_pow_2_pow_k :  (t1‚Åª¬π)^(2^(2^k)) = t1‚Åª¬π)
    (trace_map_at_inv : ‚àë i ‚àà Finset.range (2 ^ k), t1‚Åª¬π ^ (2 ^ i) = 1) :
    u^(2^(2^k)) = u‚Åª¬π

lemma folding_preserves_listdecoding_base_ne_subset
  {S : Finset Œπ} {k m : ‚Ñï} (hm : 1 ‚â§ m) {œÜ : Œπ ‚Ü™ F} [Smooth œÜ] {Œ¥ : ‚Ñù‚â•0}
  {S_0 : Finset (indexPowT S œÜ 0)} {S_1 : Finset (indexPowT S œÜ 1)}
  {œÜ_0 : (indexPowT S œÜ 0) ‚Ü™ F} {œÜ_1 : (indexPowT S œÜ 1) ‚Ü™ F}
  [‚àÄ i : ‚Ñï, Fintype (indexPowT S œÜ i)] [‚àÄ i : ‚Ñï, DecidableEq (indexPowT S œÜ i)]
  [Smooth œÜ_0] [Smooth œÜ_1]
  [h : ‚àÄ {f : (indexPowT S œÜ 0) ‚Üí F}, DecidableBlockDisagreement 0 k f S_0 œÜ_0]
  [h : ‚àÄ {f : (indexPowT S œÜ 1) ‚Üí F}, DecidableBlockDisagreement 1 k f S_1 œÜ_1]
  [‚àÄ i : ‚Ñï, Neg (indexPowT S œÜ i)]
  {C : Set ((indexPowT S œÜ 0) ‚Üí F)} (hcode : C = smoothCode œÜ_0 m)
  (C' : Set ((indexPowT S œÜ 1) ‚Üí F)) (hcode' : C' = smoothCode œÜ_1 (m-1))
  {BStar : (Set (indexPowT S œÜ 1 ‚Üí F)) ‚Üí ‚Ñï ‚Üí ‚Ñù‚â•0}
  {errStar : (Set (indexPowT S œÜ 1 ‚Üí F)) ‚Üí ‚Ñï ‚Üí ‚Ñù‚â•0 ‚Üí ‚Ñù‚â•0} :
    Pr_{let Œ± ‚Üê$·µñ F}[ ‚àÄ { f : (indexPowT S œÜ 0) ‚Üí F} (hŒ¥Le: Œ¥ ‚â§ 1 - (BStar C' 2)),
                      let listBlock : Set ((indexPowT S œÜ 0) ‚Üí F) := Œõ·µ£(0, k, f, S_0, C, hcode, Œ¥)
                      let vec_Œ± : Fin 1 ‚Üí F := (fun _ : Fin 1 => Œ±)
                      let foldSet := fold_k_set listBlock vec_Œ± hm
                      let fold := fold_k f vec_Œ± hm
                      let listBlock' : Set ((indexPowT S œÜ 1) ‚Üí F)
                        := Œõ·µ£(1, k, fold, S_1, C', hcode', Œ¥)
                      ¬¨ (listBlock' ‚äÜ foldSet)
                    ] < errStar C' 2 Œ¥

@[simp]
theorem append_cast_left {n m : ‚Ñï} {pSpec : ProtocolSpec n} {pSpec' : ProtocolSpec m} (n' : ‚Ñï)
    (h : n + m = n' + m) :
      dcast h (pSpec ++‚Çö pSpec') = (dcast (Nat.add_right_cancel h) pSpec) ++‚Çö pSpec'

theorem sum_of_pow_exp_of_2 {F : Type*} [Field F]
  (sumZeroIffEq : ‚àÄ (x y : F), x + y = 0 ‚Üî x = y)
  (i : ‚Ñï) : ‚àÄ (a b c : F), a + b = c ‚Üí a^(2^i) + b^(2^i) = c^(2^i)

theorem coeff_of_toMvPolynomial_eq_coeff_of_MlPoly (p : MlPoly R n) (m : Fin n ‚Üí‚ÇÄ ‚Ñï) :
  coeff m (toMvPolynomial p) =
    if h_binary: (‚àÄ j: Fin n, m j ‚â§ 1) then
      let i_of_m: ‚Ñï := Nat.binaryFinMapToNat (m:=m) (h_binary:=h_binary)
      p[i_of_m]
    else
      0

@[simp] theorem findIdx'_nil {p : Œ± ‚Üí Bool} : findIdx' p [] = 0

private lemma Bi_biUnion_F2i :
  Bi B i = Finset.univ.biUnion (F2i B i)

lemma getFoldingChallenges_init_succ_eq (i : Fin ‚Ñì)
    (j : Fin (toOutCodewordsCount ‚Ñì œë i.castSucc)) (challenges : Fin i.succ ‚Üí L)
    (h : ‚Üëj * œë + œë ‚â§ ‚Üëi.castSucc) :
    getFoldingChallenges (r := r) (ùì° := ùì°) (œë := œë) i.castSucc (Fin.init challenges) (‚Üëj * œë)
      (h := by omega) =
    getFoldingChallenges (r := r) (ùì° := ùì°) i.succ challenges (‚Üëj * œë)
      (h := by simp only [Fin.val_succ]; simp only [Fin.coe_castSucc] at h; omega)

@[simp]
theorem removeNth_apply : removeNth p s i = s (p.succAbove i)

theorem liftContext_knowledgeSoundness [Inhabited InnerStmtOut] [Inhabited InnerWitIn]
    {outerRelIn : Set (OuterStmtIn √ó OuterWitIn)} {outerRelOut : Set (OuterStmtOut √ó OuterWitOut)}
    {innerRelIn : Set (InnerStmtIn √ó InnerWitIn)} {innerRelOut : Set (InnerStmtOut √ó InnerWitOut)}
    {knowledgeError : ‚Ñù‚â•0}
    {stmtLens : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut}
    {witLens : Witness.InvLens OuterStmtIn OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    (V : Verifier oSpec InnerStmtIn InnerStmtOut pSpec)
    [lensKS : Extractor.Lens.IsKnowledgeSound outerRelIn innerRelIn outerRelOut innerRelOut
      (V.compatStatement stmtLens) (fun _ _ => True) ‚ü®stmtLens, witLens‚ü©]
    (h : V.knowledgeSoundness init impl innerRelIn innerRelOut knowledgeError) :
      (V.liftContext stmtLens).knowledgeSoundness init impl outerRelIn outerRelOut
        knowledgeError

theorem take_drop_append {Œ± : Sort*} (m : ‚Ñï) (h : m ‚â§ n) (v : Fin n ‚Üí Œ±) :
    Fin.append (take m h v) (drop m h v) = fun i => v (i.cast (by omega))

@[simp]
lemma probFailure_liftComp {Œπ' : Type w} {superSpec : OracleSpec Œπ'}
    [spec.FiniteRange] [superSpec.FiniteRange]
    [h : MonadLift (OracleQuery spec) (OracleQuery superSpec)]
    (oa : OracleComp spec Œ±) : [‚ä• | liftComp oa superSpec] = [‚ä• | oa]

omit [NeZero r] [Field L] [Fintype L] [DecidableEq L] [DecidableEq ùîΩq] [Field ùîΩq] [Algebra ùîΩq L] in
lemma base_coeffsBySuffix (a : Fin (2 ^ ‚Ñì) ‚Üí L) :
  coeffsBySuffix (r:=r) (R_rate := R_rate) a 0 0 = a

theorem BitVec.dcast_dcast_bitvec_extractLsb_eq {w hi lo : ‚Ñï} (x : BitVec w)
  (h_width_eq : w = hi - lo + 1) : dcast h_width_eq (dcast (h_width_eq.symm)
  (BitVec.extractLsb (hi:=hi) (lo:=lo) x)) = BitVec.extractLsb (hi:=hi) (lo:=lo) x

@[simp]
theorem dflatten_zero {n : Fin 0 ‚Üí ‚Ñï} {motive : (k : Fin (vsum n)) ‚Üí Sort*}
    {v : (i : Fin 0) ‚Üí (j : Fin (n i)) ‚Üí motive (embedSum i j)} :
    dflatten (motive := motive) v = fun k => Fin.elim0 k

lemma mul_by_2_def {s : Finset ‚Ñï} :
    mul_by_2 s = s.map ‚ü®fun n => 2 * n, by {
      intro a b
      simp
    }‚ü©

@[simp]
lemma seqCompose_zero
    (Stmt : Fin 1 ‚Üí Type) (Wit : Fin 1 ‚Üí Type) {n : Fin 0 ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (P : (i : Fin 0) ‚Üí
      Prover oSpec (Stmt i.castSucc) (Wit i.castSucc) (Stmt i.succ) (Wit i.succ) (pSpec i)) :
    seqCompose Stmt Wit P = Prover.id

private lemma f_convex {x‚ÇÅ x‚ÇÇ : ‚Ñö} {Œ±‚ÇÅ Œ±‚ÇÇ : ‚Ñö}
  (h_noneg_1 : 0 ‚â§ Œ±‚ÇÅ)
  (h_noneg_2 : 0 ‚â§ Œ±‚ÇÇ)
  (h_conv : Œ±‚ÇÅ + Œ±‚ÇÇ = 1)
  :
  f (Œ±‚ÇÅ * x‚ÇÅ + Œ±‚ÇÇ * x‚ÇÇ) ‚â§ Œ±‚ÇÅ * f x‚ÇÅ + Œ±‚ÇÇ * f x‚ÇÇ

@[simp]
lemma dfoldrM'_zero {Œ± : Fin 1 ‚Üí Type u}
    (f : (i : Fin 0) ‚Üí Œ± i.succ ‚Üí m (Œ± i.castSucc)) (x : Œ± (last 0)) :
    dfoldrM' 0 Œ± f x = pure x

@[simp]
lemma liftComp_support {Œπ' : Type w} {superSpec : OracleSpec Œπ'}
    [h : MonadLift (OracleQuery spec) (OracleQuery superSpec)]
    (oa : OracleComp spec Œ±) : (liftComp oa superSpec).support = oa.support

lemma generalised_round_consistency_completeness
  {ùîΩ : Type} [inst1 : Field ùîΩ] [DecidableEq ùîΩ] {f : Polynomial ùîΩ}
  {n : ‚Ñï} [inst : NeZero n]
  {Œ≥ : ùîΩ}
  {s‚ÇÄ : ùîΩ}
  {œâ : Fin n ‚Ü™ ùîΩ}
  (h : ‚àÄ i, (œâ i) ^ n = 1)
  (h‚ÇÅ : s‚ÇÄ ‚â† 0)
  :
    roundConsistencyCheck
      Œ≥
      (List.map (fun i => (œâ i * s‚ÇÄ, f.eval (œâ i * s‚ÇÄ))) (List.finRange n))
      ((foldNth n f Œ≥).eval (s‚ÇÄ^n)) = true

lemma combine_theorem
  {œÜ : Œπ ‚Ü™ F} {dstar m degree : ‚Ñï}
  (fs : Fin m ‚Üí Œπ ‚Üí F) (degs : Fin m ‚Üí ‚Ñï) (hdegs : ‚àÄ i, degs i ‚â§ dstar)
  (Œ¥ : ‚Ñù) (hŒ¥Pos : Œ¥ > 0)
  (hŒ¥Lt : Œ¥ < (min (1 - Bstar (rate (code œÜ degree)))
                   (1 - (rate (code œÜ degree)) - 1 / Fintype.card Œπ)))
  (hProb : Pr_{ let r ‚Üê $·µñ F}[Œ¥·µ£((combine œÜ dstar r fs degs), (code œÜ dstar)) ‚â§ Œ¥] >
    ENNReal.ofReal (proximityError F dstar (rate (code œÜ degree)) Œ¥ (m * (dstar + 1) - ‚àë i, degs i))) :
      ProximityGap.correlatedAgreement (code œÜ degree) ‚ü®Œ¥, by linarith‚ü© fs

lemma eval_normalizedW_succ_at_beta_prev (i : Fin r) (h_i_add_1 : i + 1 < r) :
  (normalizedW ùîΩq Œ≤ (i + 1)).eval (Œ≤ i) = 0

@[simp]
lemma invFun_toFun (f : F) : inst.equiv.invFun (inst.equiv.toFun f) = f

lemma rank_eq_if_det_ne_zero {U : Matrix (Fin n) (Fin n) F} [IsDomain F] :
  Matrix.det U ‚â† 0 ‚Üí U.rank = n

theorem fconcat‚ÇÇ_inj {Œ±‚ÇÅ : Fin n ‚Üí A} {Œ±‚ÇÇ : Fin n ‚Üí B} {Œ≤‚ÇÅ : A} {Œ≤‚ÇÇ : B}
    (v‚ÇÅ v‚ÇÇ : (i : Fin n) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i)) (a‚ÇÅ a‚ÇÇ : F‚ÇÇ Œ≤‚ÇÅ Œ≤‚ÇÇ) :
    fconcat‚ÇÇ (F := F‚ÇÇ) v‚ÇÅ a‚ÇÅ = fconcat‚ÇÇ (F := F‚ÇÇ) v‚ÇÇ a‚ÇÇ ‚Üî v‚ÇÅ = v‚ÇÇ ‚àß a‚ÇÅ = a‚ÇÇ

omit [NeZero r] [Field L] [Fintype L] [DecidableEq L] [Field ùîΩq] [Algebra ùîΩq L] in
lemma sBasis_range_eq (i : Fin r) (h_i : i < ‚Ñì + R_rate) :
    Œ≤ '' Set.Ico i ‚ü®‚Ñì + R_rate, h_‚Ñì_add_R_rate‚ü©
    = Set.range (sBasis Œ≤ h_‚Ñì_add_R_rate i h_i)

lemma inv_eq_pow (a : Field) (ha : a ‚â† 0) : a‚Åª¬π = a ^ (fieldSize - 2)

theorem snoc_left_injective : Injective (Finsupp.snoc ¬∑ y : (Fin n ‚Üí‚ÇÄ M) ‚Üí Fin (n + 1) ‚Üí‚ÇÄ M)

theorem eval_comp_eval_C_finSuccEquiv (p : R[X (Fin (n + 1))]) (y : Fin n ‚Üí R) (x : R) :
    eval y (Polynomial.eval (C x) (finSuccEquiv R n p)) = eval (Fin.cons x y) p

@[simp]
theorem verifier_rbrKnowledgeSoundness :
    (verifier oSpec Statement).rbrKnowledgeSoundness init impl rel rel 0

theorem foldl_succ
 {Œ± Œ≤} {n : ‚Ñï} [NeZero n] (f : Œ≤ ‚Üí Œ± ‚Üí Œ≤) (init : Œ≤) (v : Vector Œ± n) :
  v.foldl (f:=f) (b:=init) = v.tail.foldl (f:=f) (b:=f init v.head)

lemma definingPoly_ne_zero {F : Type*} [Field F] [Fintype F] (s : F) [NeZero s] :
  (definingPoly s) ‚â† 0

@[simp]
theorem BTField.RingHom_eq_of_dest_AdjoinRoot_eq (k m : ‚Ñï) :
  (BTField k ‚Üí+* BTField (m+1)) = (BTField k ‚Üí+* (AdjoinRoot (poly m)))

lemma sum_insertNth' [AddCommMonoid M] [AddCommMonoid N] {n : ‚Ñï} (œÉ : Fin n ‚Üí‚ÇÄ M) (i : M)
    (p : Fin (n + 1)) (f : Fin (n+1) ‚Üí M ‚Üí N) (h : ‚àÄ x, f x 0 = 0) :
    sum (insertNth p i œÉ) f = f p i + sum œÉ (Fin.removeNth p f)

Nat.succ_le_succ in Init.Prelude

@[simp]
theorem fcons_succ {Œ≤ : Fin n ‚Üí A} (a : F Œ±) (v : (i : Fin n) ‚Üí F (Œ≤ i)) (i : Fin n) :
    fcons a v i.succ = cast (by simp [vcons_succ]) (v i)

lemma getBit_of_highBits_no_shl {n: ‚Ñï} (numLowBits : ‚Ñï) :
    ‚àÄ k, getBit k (getHighBits_no_shl numLowBits n)
  = getBit (k + numLowBits) (n)

@[simp]
lemma coeffsOfPolynomial_polynomialOfCoeffs :
  coeffsOfPolynomial (polynomialOfCoeffs coeffs) = coeffs

lemma roots_comp_X_sub_C (p : L[X]) (a : L) :
    (p.comp (X - C a)).roots = p.roots.map (fun r => r + a)

theorem concrete_eq_zero_or_eq_one {k : ‚Ñï} {a : ConcreteBTField k} (h_k_zero : k = 0)
 : a = zero ‚à® a = one

@[simp]
theorem verifier_first (pSpec : ProtocolSpec n) [NeZero n] [h : VerifierFirst pSpec] :
    pSpec.dir 0 = .V_to_P

@[simp]
theorem FullData.get_leaf {Œ±} (a : Œ±) :
    (FullData.leaf a).get SkeletonNodeIndex.ofLeaf = a

@[simp, grind] lemma fin_chunkSize_plus_absorbPos_lt_N (absorbPos arrSize : Nat)
    (i : Fin (min arrSize (SpongeSize.R - absorbPos))) :
    absorbPos + i < SpongeSize.N

theorem MLE_degreeOf (evals : (œÉ ‚Üí Fin 2) ‚Üí R) (i : œÉ) : degreeOf i (MLE evals) ‚â§ 1

@[simp, grind =]
lemma leadingCoeffY_ne_zero (f : F[X][Y]) : leadingCoeffY f ‚â† 0 ‚Üî f ‚â† 0

@[simp]
theorem Prover.run_of_prover_first [ProverOnly pSpec] (stmt : StmtIn) (wit : WitIn)
    (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      prover.run stmt wit = (do
        let state := prover.input (stmt, wit)
        let ‚ü®msg, state‚ü© ‚Üê liftComp (prover.sendMessage ‚ü®0, by simp‚ü© state) _
        let ctxOut ‚Üê prover.output state
        return ((fun i => match i with | ‚ü®0, _‚ü© => msg), ctxOut))

@[simp] lemma natCast_eq {k : ‚Ñï} (n : ‚Ñï) : (‚Üën : ConcreteBTField k) = natCast n

theorem mulVecLin_coeff_vandermondens_eq_eval_matrixOfPolynomials
  {n : ‚Ñï} [NeZero n] {v : Œπ ‚Ü™ F} {p : F[X]} (h_deg : p.natDegree < n) :
  (Vandermonde.nonsquare (Œπ' := n) v).mulVecLin (Fin.liftF' p.coeff) =
  fun i => p.eval (v i)

theorem stir_rbr_soundness
    [SelectableType F] {s : ‚Ñï}
    {P : Params Œπ F} {œÜ : (i : Fin (M + 1)) ‚Üí (Œπ i ‚Ü™ F)}
    [h_nonempty : ‚àÄ i : Fin (M + 1), Nonempty (Œπ i)]
    {hParams : ParamConditions Œπ P} {Dist : Distances M}
    {Codes : CodeParams Œπ P Dist}
    (h_not_code : ‚àÄ f‚ÇÄ : (Œπ 0) ‚Üí F, f‚ÇÄ ‚àâ (Codes.C 0))
    (hŒ¥‚ÇÄLe : ‚àÄ f‚ÇÄ : (Œπ 0) ‚Üí F, Dist.Œ¥ 0 ‚â§ (Œ¥·µ£(f‚ÇÄ, (Codes.C 0)) : ‚Ñù) ‚àß
      Dist.Œ¥ 0 < (1 - Bstar (rate (code (P.œÜ 0) P.deg))))
    (hŒ¥·µ¢ : ‚àÄ {j : Fin (M + 1)}, j ‚â† 0 ‚Üí
        Dist.Œ¥ j < (1 - rate (code (P.œÜ j) (degree Œπ P j))
          - 1 / Fintype.card (Œπ j) : ‚Ñù) ‚àß
        Dist.Œ¥ j < (1 - Bstar (rate (code (P.œÜ j) (degree Œπ P j)))))
    (Œµ_fold : ‚Ñù‚â•0) (Œµ_out : Fin M ‚Üí ‚Ñù‚â•0) (Œµ_shift : Fin M ‚Üí ‚Ñù‚â•0) (Œµ_fin : ‚Ñù‚â•0) :
    ‚àÉ n : ‚Ñï,
    -- There exists an `n`-message vector IOPP,
    ‚àÉ vPSpec : ProtocolSpec.VectorSpec n,
    -- such that there are `2 * M + 2` challenges from the verifier to the prover,
    Fintype.card (vPSpec.ChallengeIdx) = 2 * M + 2 ‚àß
    -- ‚àÉ vector IOPP œÄ with the aforementioned `vPSpec`, and for
    -- `Statement = Unit, Witness = Unit, OracleStatement(Œπ‚ÇÄ, F)` such that
    ‚àÉ œÄ : VectorIOP Unit (OracleStatement (Œπ 0) F) Unit vPSpec F,
    let Œµ_rbr : vPSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0

Nat.pow_lt_pow_right in Init.Data.Nat.Lemmas

omit h_Œ≤‚ÇÄ_eq_1 in
lemma finToBinaryCoeffs_sDomainToFin (i : Fin r) (h_i : i < ‚Ñì + R_rate)
    (x : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i) :
    let pointFinIdx := (sDomainToFin ùîΩq Œ≤ h_‚Ñì_add_R_rate i h_i) x
    finToBinaryCoeffs ùîΩq (i := i) (idx :=pointFinIdx) =
    (sDomain_basis ùîΩq Œ≤
    h_‚Ñì_add_R_rate i h_i).repr x

@[simp]
lemma liftF'_zero_eq_zero
  : liftF' (fun _ ‚Ü¶ (0 : Œ±)) = (fun (_ : Fin n) ‚Ü¶ (0 : Œ±))

@[simp]
theorem ConcreteBTFieldAlgebra_id {l r : ‚Ñï} (h_eq : l = r) :
    @ConcreteBTFieldAlgebra l r (h_le:=by omega) =
    (h_eq ‚ñ∏ (Algebra.id (ConcreteBTField l)) :
      Algebra (ConcreteBTField l) (ConcreteBTField r))

theorem distFromCode_eq_top_iff_empty (u : n ‚Üí R) (C : Set (n ‚Üí R)) : Œî‚ÇÄ(u, C) = ‚ä§ ‚Üî C = ‚àÖ

omit [NeZero ‚Ñì] [NeZero r] [NeZero ùì°] in
lemma fin_r_succ_bound {h_‚Ñì_add_R_rate : ‚Ñì + ùì° < r} (i : Fin r) (h_i : i + 1 < ‚Ñì + ùì°)
    : i + 1 < r

theorem induction_append_right {m n : ‚Ñï} {motive : Fin (m + n + 1) ‚Üí Sort*} {zero : motive 0}
  {succ : ‚àÄ i : Fin (m + n), motive i.castSucc ‚Üí motive i.succ} {i : Fin (n + 1)} :
    induction zero succ (i.natAdd m) =
      @induction n (fun i => motive (i.natAdd m))
        (@induction m (fun j => motive (Fin.cast (by omega) (j.castAdd n)))
          zero (fun j x => succ (j.castAdd n) x) (last m))
        (fun i x => succ (i.natAdd m) x) i

theorem succ_mul {a b : AssocNat} : (succ a) * b = a * b + b

lemma join_split_eq_join {k : ‚Ñï} (h_pos : k > 0) (x : ConcreteBTField k) :
  „Ää (split h_pos x).fst, (split h_pos x).snd „Äã = x

lemma split_join_eq_split {k : ‚Ñï} (h_pos : k > 0)
    (hi_btf lo_btf : ConcreteBTField (k - 1)) :
    split h_pos („Ää hi_btf, lo_btf „Äã) = (hi_btf, lo_btf)

omit [Finite F] in
lemma pow_2_pow_i_mem_Di_of_mem_D :
  ‚àÄ {x : FÀ£} (i : ‚Ñï),
    x ‚àà D ‚Üí x ^ (2 ^ i) ‚àà evalDomain D i

theorem eq_symm {Œ± : Type u} (mx my : m Œ±) : eq mx my ‚Üí eq my mx

lemma towerRingHomBackwardMap_forwardMap_eq (k : ‚Ñï) (x : ConcreteBTField k) :
  towerRingHomBackwardMap (k:=k) (towerRingHomForwardMap (k:=k) x) = x

@[simp]
theorem dist_le_card (C : Set (n ‚Üí R)) : dist C ‚â§ Fintype.card n

@[simp]
lemma coeff_truncate : (truncate p n).coeff k = if k < n then p.coeff k else 0

lemma getBit_of_or {n m k: ‚Ñï} : getBit k (n ||| m) = getBit k n ||

@[simp]
theorem binaryTowerAlgebra_id {l r : ‚Ñï} (h_eq : l = r) :
    @binaryAlgebraTower l r (h_le:=by omega) =
    (h_eq ‚ñ∏ (Algebra.id (BTField l)) : Algebra (BTField l) (BTField r))

omit [CharP L 2] [DecidableEq ùîΩq] hF‚ÇÇ h_Œ≤‚ÇÄ_eq_1 [NeZero ùì°] in
lemma take_snoc_oracle_eq_oStmtIn (i : Fin ‚Ñì)
    (oStmtIn : (j : Fin (toOutCodewordsCount ‚Ñì œë i.castSucc)) ‚Üí
      OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j)
    (newOracleFn : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ) :
    (take_snoc_oracle ùîΩq Œ≤ i oStmtIn newOracleFn) = oStmtIn

theorem liftContext_rbr_soundness [Inhabited InnerStmtOut]
    {outerLangIn : Set OuterStmtIn} {outerLangOut : Set OuterStmtOut}
    {innerLangIn : Set InnerStmtIn} {innerLangOut : Set InnerStmtOut}
    {rbrSoundnessError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    {lens : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut}
    (V : Verifier oSpec InnerStmtIn InnerStmtOut pSpec)
    -- TODO: figure out the right compatibility relation for the IsSound condition
    [lensSound : lens.IsSound outerLangIn outerLangOut innerLangIn innerLangOut
      (V.compatStatement lens)]
    (h : V.rbrSoundness init impl innerLangIn innerLangOut rbrSoundnessError) :
      (V.liftContext lens).rbrSoundness init impl outerLangIn outerLangOut rbrSoundnessError

lemma getBit_of_two_pow_sub_one {i k: ‚Ñï} : getBit k (2^i - 1) =
    if k < i then 1 else 0

theorem rtake_eq_take_rev {Œ± : Sort*} (m : ‚Ñï) (h : m ‚â§ n) (v : Fin n ‚Üí Œ±) :
    rtake m h v = (take m h (v ‚àò Fin.rev)) ‚àò Fin.rev

@[simp]
theorem Prover.runToRound_one_of_prover_first [ProverOnly pSpec] (stmt : StmtIn) (wit : WitIn)
    (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      prover.runToRound 1 stmt wit = (do
        let state := prover.input (stmt, wit)
        let ‚ü®msg, state‚ü© ‚Üê liftComp (prover.sendMessage ‚ü®0, by simp‚ü© state) _
        return (fun i => match i with | ‚ü®0, _‚ü© => msg, state))

@[simp]
lemma natDegree_solutionToE :
  (solutionToE e k v).natDegree = e

lemma comm_map_smul_add (s : Right) (x y : Right ‚äó[K] Left)
    (hx : e (s ‚Ä¢ x) = s ‚Ä¢ (e x)) (hy : e (s ‚Ä¢ y) = s ‚Ä¢ (e y)) :
    e (s ‚Ä¢ x) + e (s ‚Ä¢ y) = s ‚Ä¢ e x + s ‚Ä¢ e y

theorem liftContext_rbr_knowledgeSoundness [Inhabited InnerStmtOut] [Inhabited InnerWitIn]
    {outerRelIn : Set (OuterStmtIn √ó OuterWitIn)} {outerRelOut : Set (OuterStmtOut √ó OuterWitOut)}
    {innerRelIn : Set (InnerStmtIn √ó InnerWitIn)} {innerRelOut : Set (InnerStmtOut √ó InnerWitOut)}
    {rbrKnowledgeError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    {stmtLens : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut}
    {witLens : Witness.InvLens OuterStmtIn OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    (V : Verifier oSpec InnerStmtIn InnerStmtOut pSpec)
    [lensKS : Extractor.Lens.IsKnowledgeSound outerRelIn innerRelIn outerRelOut innerRelOut
      (V.compatStatement stmtLens) (fun _ _ => True) ‚ü®stmtLens, witLens‚ü©]
    (h : V.rbrKnowledgeSoundness init impl innerRelIn innerRelOut rbrKnowledgeError) :
      (V.liftContext stmtLens).rbrKnowledgeSoundness init impl outerRelIn outerRelOut
        rbrKnowledgeError

theorem completeness [DecidableEq Œ±] [SelectableType Œ±] {s}
    (leaf_data_tree : LeafData Œ± s) (idx : BinaryTree.SkeletonLeafIndex s)
    (preexisting_cache : (spec Œ±).QueryCache) :
    (((do
      let cache ‚Üê buildMerkleTree leaf_data_tree
      let proof := generateProof cache idx
      let _ ‚Üê verifyProof idx (leaf_data_tree.get idx) (cache.getRootValue) proof
      ).simulateQ (randomOracle)).run preexisting_cache).neverFails

theorem pow_one {a : CNat 50} : a ^ 1 = a

theorem foldOracleVerifier_rbrKnowledgeSoundness (i : Fin ‚Ñì) :
    (foldOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i).rbrKnowledgeSoundness init impl
      (relIn := roundRelation (mp := mp) ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        (ùìë := ùìë) i.castSucc)
      (relOut := foldStepRelOut (mp := mp) ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        (ùìë := ùìë) i)
      (foldKnowledgeError ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)

theorem liftContext_run
    {lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    {outerStmtIn : OuterStmtIn} {outerWitIn : OuterWitIn}
    {P : Prover oSpec InnerStmtIn InnerWitIn InnerStmtOut InnerWitOut pSpec} :
      (P.liftContext lens).run outerStmtIn outerWitIn
      = do
        let ‚ü®fullTranscript, innerCtxOut‚ü© ‚Üê
          P.run.uncurry (lens.proj (outerStmtIn, outerWitIn))
        return ‚ü®fullTranscript, lens.lift (outerStmtIn, outerWitIn) innerCtxOut‚ü©

theorem peval_def (f : œÉ ‚Üí œÉ‚ÇÅ ‚äï œÉ‚ÇÇ) (x : œÉ‚ÇÅ ‚Üí R) (p : MvPolynomial œÉ R) :
    peval f x p = eval‚ÇÇ C (Sum.elim (fun i => C (x i)) X ‚àò f) p

theorem stir_main
  (secpar : ‚Ñï) [SelectableType F]
  {Œπ : Type} [Fintype Œπ] [Nonempty Œπ] [DecidableEq Œπ]
  {œÜ : Œπ ‚Ü™ F} {degree : ‚Ñï} [hsmooth : Smooth œÜ]
  {k proofLen qNumtoInput qNumtoProofstr : ‚Ñï}
  (hk : ‚àÉ p, k = 2 ^ p) (hkGe : k ‚â• 4)
  (Œ¥ : ‚Ñù‚â•0) (hŒ¥ub : Œ¥ < 1 - 1.05 * Real.sqrt (degree / Fintype.card Œπ))
  (hF : Fintype.card F ‚â§
        secpar * 2 ^ secpar * degree ^ 2 * (Fintype.card Œπ) ^ (7 / 2) /
          Real.log (1 / rate (code œÜ degree))) :
  ‚àÉ n : ‚Ñï,
  ‚àÉ vPSpec : ProtocolSpec.VectorSpec n,
  ‚àÉ Œµ_rbr : vPSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0,
  ‚àÉ œÄ : VectorIOP Unit (OracleStatement Œπ F) Unit vPSpec F,
  IsSecureWithGap (stirRelation degree œÜ 0)
                  (stirRelation degree œÜ Œ¥)
                  Œµ_rbr œÄ
  ‚àß ‚àÄ i, Œµ_rbr i ‚â§ (1 : ‚Ñö‚â•0) / (2 ^ secpar)
  ‚àß ‚àÉ c > 0, M ‚â§ c * (Real.log degree / Real.log k)
  ‚àß ‚àÉ c‚Çñ : ‚Ñï ‚Üí ‚Ñù, proofLen ‚â§ (Fintype.card Œπ) + (c‚Çñ k) * (Real.log degree)
  ‚àß qNumtoInput = secpar / (- Real.log (1 - Œ¥))
  ‚àß ‚àÉ c‚Çñ : ‚Ñï ‚Üí ‚Ñù, qNumtoProofstr ‚â§
    (c‚Çñ k) * ((Real.log degree) +
      secpar * (Real.log ((Real.log degree) / Real.log (1/rate (code œÜ degree)))))

lemma qCompositionChain_eq_foldl (i : Fin r) :
  qCompositionChain ùîΩq Œ≤ (‚Ñì:=‚Ñì) (R_rate:=R_rate) i =
  Fin.foldl (n:=i) (fun acc j =>
    (qMap ùîΩq Œ≤ ‚ü®j, by omega‚ü©).comp acc) (X)

lemma sup_eq_of_le_of_reach {Œ± Œ≤ : Type} [SemilatticeSup Œ≤] [OrderBot Œ≤] {s : Finset Œ±} {f : Œ± ‚Üí Œ≤}
      (x : Œ±) {y : Œ≤} (h : x ‚àà s) :
    f x = y ‚Üí
    (‚àÄ x ‚àà s, f x ‚â§ y) ‚Üí
    s.sup f = y

lemma farness_implies_non_compliance (i : Fin ‚Ñì) (steps : ‚Ñï) [NeZero steps]
  (h_i_add_steps : i + steps ‚â§ ‚Ñì)
  (f_i : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i, by omega‚ü©)
  (f_i_plus_steps : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
    ‚ü®i + steps, by omega‚ü©)
  (challenges : Fin steps ‚Üí L)
  (h_far : 2 * Code.distFromCode f_i
      (BBF_Code ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i, by omega‚ü©)
    ‚â• (BBF_CodeDistance ‚Ñì ùì° ‚ü®i, by omega‚ü© : ‚Ñï‚àû)) :
  ¬¨ isCompliant ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := i) (steps := steps)
    h_i_add_steps f_i f_i_plus_steps challenges

lemma not_outOfOrder_of_not_combined (h : ¬¨ E trace) : ¬¨ E_time trace state

theorem OracleVerifier.liftContext_toVerifier_comm
    {lens : OracleStatement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                              OuterOStmtIn OuterOStmtOut InnerOStmtIn InnerOStmtOut}
    {V : OracleVerifier oSpec InnerStmtIn InnerOStmtIn InnerStmtOut InnerOStmtOut pSpec} :
      (V.liftContext lens).toVerifier = V.toVerifier.liftContext lens

@[simp]
theorem fflatten_zero {A : Sort u} {F : A ‚Üí Sort v} {n : Fin 0 ‚Üí ‚Ñï}
    {Œ± : (i : Fin 0) ‚Üí (j : Fin (n i)) ‚Üí A}
    {v : (i : Fin 0) ‚Üí (j : Fin (n i)) ‚Üí F (Œ± i j)} : fflatten v = !h[]

@[simp]
lemma probFailure_bind_eq_zero_iff [spec.FiniteRange]
    (oa : OracleComp spec Œ±) (ob : Œ± ‚Üí OracleComp spec Œ≤) :
    [‚ä• | oa >>= ob] = 0 ‚Üî [‚ä• | oa] = 0 ‚àß ‚àÄ x ‚àà oa.support, [‚ä• | ob x] = 0

theorem divSum?_is_some_iff_lt_sum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {k : ‚Ñï} :
    (divSum? n k).isSome ‚Üî k < ‚àë i, n i

lemma getBit_zero_eq_self {n : ‚Ñï} (h_n : n < 2) : getBit 0 n = n

lemma split_algebraMap_eq_zero_x {k : ‚Ñï} (h_pos : k > 0) (x : BTField (k - 1)) :
  letI instAlgebra := binaryAlgebraTower (l:=k-1) (r:=k) (h_le:=by omega)
  split (k:=k) (h_k:=h_pos) (algebraMap (BTField (k - 1)) (BTField k) x) = (0, x)

@[simp]
lemma challengeOracleInterface_append_domain_inr (j : pSpec‚ÇÇ.ChallengeIdx) :
    [(pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).Challenge]‚Çí.domain (.inr j) = Unit

theorem towerEquiv_commutes_left (i j : ‚Ñï) (h : i ‚â§ j) : ‚àÄ r : ConcreteBTField i,
  (AlgebraTower.algebraMap i j h) ((towerEquiv i).ringEquiv r) =
  (towerEquiv j).ringEquiv ((AlgebraTower.algebraMap i j h) r)

@[simp]
theorem cast_val {m n : ‚Ñï} (h : m = n) (a : Fin m) : (Fin.cast h a).val = a.val

@[simp]
lemma dfoldr'_zero {Œ± : Fin 1 ‚Üí Type u}
    (f : (i : Fin 0) ‚Üí Œ± i.succ ‚Üí Œ± i.castSucc) (x : Œ± (last 0)) :
    dfoldr' 0 Œ± f x = x

theorem peval_eq_eval_sumToIter_rename (f : œÉ ‚Üí œÉ‚ÇÅ ‚äï œÉ‚ÇÇ) (x : œÉ‚ÇÅ ‚Üí R) (p : MvPolynomial œÉ R) :
    peval f x p = eval (C ‚àò x) (sumToIter R œÉ‚ÇÅ œÉ‚ÇÇ (rename f p))

lemma oodSampling_crs_eq_rs
    {f : Œπ ‚Üí F} {m s : ‚Ñï} {œÜ : Œπ ‚Ü™ F} [Smooth œÜ]
    (l Œ¥ : ‚Ñù‚â•0) (hŒ¥Le : Œ¥ ‚â§ 1)
    {C : Set (Œπ ‚Üí F)} (hcode : C = smoothCode œÜ m ‚àß listDecodable C Œ¥ l) :
    Pr_{ let rs ‚Üê$·µñ (Fin s ‚Üí F) }[ (‚àÉ œÉ : Fin s ‚Üí F,
                        let w : Fin s ‚Üí MvPolynomial (Fin (m + 1)) F :=
                          fun i =>
                            let ri := rs i
                            let rVec := fun j : Fin m => ri ^ (2^(j : ‚Ñï))
                            MvPolynomial.X (Fin.last m) * rename Fin.castSucc (eqPolynomial rVec)
                        let multiCRSCode := multiConstrainedCode œÜ m s w œÉ
                        ‚àÉ u u' : Œπ ‚Üí F, u ‚â† u' ‚àß
                          u ‚àà relHammingBall multiCRSCode f Œ¥ ‚àß
                          u' ‚àà relHammingBall multiCRSCode f Œ¥)]
    =
    Pr_{ let rs ‚Üê$·µñ (Fin s ‚Üí F) }[ (‚àÉ u u' : smoothCode œÜ m,
                        u.val ‚â† u'.val ‚àß
                        u.val ‚àà relHammingBall C f Œ¥ ‚àß
                        u'.val ‚àà relHammingBall C f Œ¥ ‚àß
                        ‚àÄ i : Fin s,
                          let ri := rs i
                          let rVec := fun j : Fin m => ri ^ (2^(j : ‚Ñï))
                          (mVdecode u).eval (rVec) = (mVdecode u').eval (rVec))]

theorem trim_toImpl [LawfulBEq R] (p : R[X]) : p.toImpl.trim = p.toImpl

@[simp]
lemma weight_constantCode [DecidableEq F] :
  wt (constantCode x Œπ) = 0 ‚Üî IsEmpty Œπ ‚à® x = 0

lemma if_self_rfl {Œ± : Type*} [DecidableEq Œ±] (a b : Œ±) :
  (if a = b then b else a) = a

theorem fullOracleVerifier_rbrKnowledgeSoundness :
  (fullOracleVerifier ùîΩq Œ≤ Œ≥_repetitions (œë:=œë)
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).rbrKnowledgeSoundness init impl
    (relIn := roundRelation (mp := BBF_SumcheckMultiplierParam) ùîΩq Œ≤ (œë:=œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) 0)
    (relOut := acceptRejectOracleRel)
    (rbrKnowledgeError := fullRbrKnowledgeError ùîΩq Œ≤ Œ≥_repetitions (œë:=œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
</all_available_lemmas>

<local_ctx>
import ArkLib.Data.MvPolynomial.LinearMvExtension

import ArkLib.Data.Polynomial.Interface

import Mathlib.LinearAlgebra.Lagrange

import Mathlib.RingTheory.Henselian

namespace ReedSolomon

open Polynomial NNReal

variable {F : Type*} {Œπ : Type*} (domain : Œπ ‚Ü™ F)

def evalOnPoints [Semiring F] : F[X] ‚Üí‚Çó[F] (Œπ ‚Üí F) where
  toFun := fun p => fun x => p.eval (domain x)
  map_add' := fun x y => by admit /- proof elided -/

def code (deg : ‚Ñï) [Semiring F]: Submodule F (Œπ ‚Üí F) :=
  (Polynomial.degreeLT F deg).map (evalOnPoints domain)

variable [Semiring F]

end ReedSolomon

open Polynomial Matrix Code LinearCode

variable {F Œπ Œπ' : Type*}
         {C : Set (Œπ ‚Üí F)}

noncomputable section

namespace Vandermonde

def nonsquare [Semiring F] (Œπ' : ‚Ñï) (Œ± : Œπ ‚Üí F) : Matrix Œπ (Fin Œπ') F :=
  Matrix.of fun i j => (Œ± i) ^ j.1

section

variable [CommRing F] {m n : ‚Ñï} {Œ± : Fin m ‚Üí F}

section

variable [IsDomain F]

end

end

end Vandermonde

namespace ReedSolomonCode

section

open Finset Function

open scoped BigOperators

variable {Œπ : Type*} [Fintype Œπ] [Nonempty Œπ]
         {F : Type*} [Field F] [Fintype F]

open Classical in

end

section

variable {deg m n : ‚Ñï} {Œ± : Fin m ‚Üí F}

section

variable [Semiring F] {p : F[X]}

end

open LinearCode
</local_ctx>

<target_theorem>
lemma genMatIsVandermonde [Fintype Œπ] [Field F] [DecidableEq F] [inst : NeZero m] {Œ± : Œπ ‚Ü™ F} :
  fromColGenMat (Vandermonde.nonsquare (Œπ' := m) Œ±) = ReedSolomon.code Œ± m :=
</target_theorem>

