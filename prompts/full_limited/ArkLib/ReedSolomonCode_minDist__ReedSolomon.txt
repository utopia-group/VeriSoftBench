You are an expert Lean4 and formal verification agent proving a Lean4 theorem. Your output **must** strictly adhere to the specified format.

### Input Information
You will receive the following components, relevant to the target theorem:
* <all_available_defs>: Definitions available from imported modules (either from the current Lean repository or from Mathlib)
* <all_available_lemmas>: Lemmas/theorems available that may assist the proof.
* <local_ctx>...</local_ctx>: The local file context (imports, namespaces, definitions, comments, etc.) from the top of the file up to‚Äîbut not including‚Äîthe target theorem or any previously defined local lemmas/theorems.
* <target_theorem>...</target_theorem>: The target theorem statement, ending with `:=`.

**Notes**
1. Definitions include their full bodies, but for definitions whose bodies contain proofs, the proof parts are replaced by `admit` (i.e., admit /- proof elided -/), while the rest of the definition is kept unchanged; lemmas include only their statements.
2. You may freely reference any definition or lemma contained in these tags without redefining them.
3. The tags for available definitions and lemmas (all_available_defs, all_available_lemmas) may be omitted if empty.

### Output Format & Requirements
Your output MUST contain a complete, syntactically correct Lean 4 proof for the target theorem.

**Strict Output Structure:**
<reasoning> 
...
</reasoning> 

<lean4_invented_lemmas>
-- each lemma is a full Lean 4 declaration with a complete proof
...
</lean4_invented_lemmas>

<lean4_proof>
-- Lean 4 proof body of the target theorem
...
</lean4_proof>

**Requirements:**
1. <reasoning> and <lean4_invented_lemmas> are OPTIONAL. Include them only if they aid proof construction.
2. <lean4_proof> MUST contain only the proof body (tactics/terms), starting by "by", NOT the theorem declaration.
3. <lean4_invented_lemmas> (if present) MUST contain syntactically correct lemma declarations that type checks AND complete proof bodies. Defining a lemma using `axiom` is NOT allowed.
4. <reasoning> contains high-level proof planning.
5. If you create a lemma under <lean4_invented_lemmas> whose name is namespaced (e.g., X.Y.Z), you MUST always refer to it using its fully qualified name. Do NOT rely on shortened names. For example, write rw [X.Y.Z], not rw [Z] for invented lemmas.
6. All Lean 4 code MUST be syntactically correct. No `sorry`, `admit`, or non-Lean text. Comments allowed using `--` or `/- ... -/`.
7. Follow the tags and structure EXACTLY. No extra text before, between, or after the sections.
8. Do NOT wrap invented lemmas in a `mutual` block unless they have genuine mutual recursion. Declare each lemma independently.

### Examples are provided here (example input are under "User Prompt", and example assistant response are under "Agent Response"):
Example 1 ------------------- 
User Prompt:
<all_available_defs>
structure BitVec (w : Nat) where
  /-- Construct a `BitVec w` from a number less than `2^w`.
  O(1), because we use `Fin` as the internal representation of a bitvector. -/
  ofFin ::

  /-- Interpret a bitvector as a number less than `2^w`.
  O(1), because we use `Fin` as the internal representation of a bitvector. -/
  toFin : Fin (hPow 2 w)
</all_available_defs>

<all_available_lemmas>
theorem List.getElem_append_left{Œ± : Type u_1} {l‚ÇÅ l‚ÇÇ : List Œ±} {i : Nat} (hn : i < l‚ÇÅ.length) : (l‚ÇÅ ++ l‚ÇÇ)[i] = l‚ÇÅ[i]
theorem getElem_eq_testBit_toNat (x : BitVec w) (i : Nat) (h : i < w) :
  x[i] = x.toNat.testBit i := rfl
@[simp, grind =] theorem toNat_cons (b : Bool) (x : BitVec w) :
    (cons b x).toNat = (b.toNat <<< w) ||| x.toNat
@[simp, grind =] theorem getLsbD_of_ge (x : BitVec w) (i : Nat) (ge : w ‚â§ i) : getLsbD x i = false
theorem testBit_toNat (x : BitVec w) : x.toNat.testBit i = x.getLsbD i
</all_available_lemmas>

<local_ctx>
import Mathlib.Computability.NFA
import Mathlib.Data.FinEnum
import Mathlib.Data.Rel
import Mathlib.Data.Vector.Basic
import Blase.AutoStructs.ForLean

open Set
open Mathlib
open SetRel

-- this is better because card is defeq to n
instance (Œ± : Type) : Inter (Language Œ±) := ‚ü®Set.inter‚ü©
instance (Œ± : Type) : Union (Language Œ±) := ‚ü®Set.union‚ü©

/--
The set of `n`-tuples of bit vectors of an arbitrary width.
-/
structure BitVecs (n : Nat) where
  w : Nat
  bvs : List.Vector (BitVec w) n

def BitVecs.cast (bvs : BitVecs n) (h : n = n') : BitVecs n' :=
  { w := bvs.w, bvs := h ‚ñ∏ bvs.bvs }

abbrev BitVecs.empty : BitVecs n := ‚ü®0, List.Vector.replicate n .nil‚ü©
abbrev BitVecs.singleton {w : Nat} (bv : BitVec w) : BitVecs 1 := ‚ü®w, bv ::·µ• .nil‚ü©
abbrev BitVecs.pair {w : Nat} (bv1 bv2 : BitVec w) : BitVecs 2 := ‚ü®w, bv1 ::·µ• bv2 ::·µ• .nil‚ü©

/--
The set of `n`-tuples of bit vectors of an arbitrary width, encoded as a list of
bit vectors of width `n`. The width of the encoded bit vectors is the length of
the list.
-/
abbrev BitVecs' (n : Nat) := List (BitVec n)

@[simps]
def dec (bvs' : BitVecs' n) : BitVecs n where
  w := bvs'.length
  bvs := List.Vector.ofFn fun k => BitVec.ofFn fun i => bvs'[i].getLsbD k

@[simp]
</local_ctx>

<target_theorem>
lemma dec_snoc n (bvs' : BitVecs' n) (a : BitVec n) :
  dec (bvs' ++ [a]) =
    { w := bvs'.length + 1
      bvs := List.Vector.ofFn fun k =>
        BitVec.cons (a.getLsbD k) ((dec bvs').bvs.get k) } :=
</target_theorem>

Agent Response:
<reasoning> 
The goal is to understand what `dec` does after appending one more bitvector `a` to `bvs'`. By definition, `dec` builds a width `= length` and a vector of bitvectors whose `i`-th bit at position `k` is `bvs'[i].getLsbD k`. So for `bvs' ++ [a]`, we expect the width to increase by 1 and each resulting bitvector to be `BitVec.cons` of the new bit coming from `a`.

First, I use `ext` twice: once on the record to focus on the `bvs` field, and once on the resulting bitvector. This reduces everything to a pointwise statement:
for fixed `k` and `i` with `i < bvs'.length + 1`,
the bit `(bvs' ++ [a])[i].getLsbD k` should match the bit at index `i` of `BitVec.cons (a.getLsbD k) ((dec bvs').bvs.get k)`.

At this point I need a clean description of indexing into `BitVec.cons`: if we have `x : BitVec n`, then `(cons b x)[i]` should give `b` at the new ‚Äúlast‚Äù index `n` and `x[i]` otherwise. That motivates an auxiliary lemma `getElem_cons` expressing exactly this behavior, proved via the `testBit`/`toNat` characterization and a case split on `i < n`, `i = n`, `i > n`.

Using `getElem_cons`, the RHS becomes an `if` on whether `i = bvs'.length`. So I split into cases:
- If `i = bvs'.length`, then `(bvs' ++ [a])[i]` is the appended `a`, so both sides reduce to `a.getLsbD k`.
- If `i ‚â† bvs'.length`, the bound `i < bvs'.length + 1` forces `i < bvs'.length`. Then `(bvs' ++ [a])[i] = bvs'[i]` by `List.getElem_append_left`, and the RHS takes the ‚Äúelse‚Äù branch and likewise gives the bit from `bvs'[i]`. In both subcases, `simp` (plus the definition of `dec`) finishes.

So the whole proof is: `ext` to bit level, unfold `dec` with `simp_all`, rewrite with `getElem_cons`, split on the boundary index `i = length bvs'`, and in the ‚Äú< length‚Äù branch use `List.getElem_append_left` and bounds to line up both sides.
</reasoning> 

<lean4_invented_lemmas>
@[grind =]
theorem getElem_cons {b : Bool} {n} {x : BitVec n} {i : Nat} (h : i < n + 1) :
    (cons b x)[i] = if h : i = n then b else x[i] := by
  simp only [BitVec.getElem_eq_testBit_toNat, BitVec.toNat_cons, Nat.testBit_or]
  rw [Nat.testBit_shiftLeft]
  rcases Nat.lt_trichotomy i n with i_lt_n | i_eq_n | n_lt_i
  ¬∑ have p1 : ¬¨(n ‚â§ i) := by omega
    have p2 : i ‚â† n := by omega
    simp [p1, p2]
  ¬∑ simp only [i_eq_n, ge_iff_le, Nat.le_refl, decide_true, Nat.sub_self, Nat.testBit_zero,
    Bool.true_and, BitVec.testBit_toNat, BitVec.getLsbD_of_ge, Bool.or_false]
    cases b <;> trivial
  ¬∑ have p1 : i ‚â† n := by omega
    have p2 : i - n ‚â† 0 := by omega
    simp [p1, p2, Nat.testBit_bool_toNat]
</lean4_invented_lemmas>

<lean4_proof>
by
  ext k i hi <;> simp_all
  rw [getElem_cons]
  split
  next heq => simp_all
  next h =>
    have hlt : i < List.length bvs' := by simp at hi; omega
    rw [List.getElem_append_left hlt]
    simp
</lean4_proof>

### Your task:
<all_available_defs>
Fintype in Mathlib.Data.Fintype.Defs
Polynomial.X in Mathlib.Algebra.Polynomial.Basic
Semiring in Mathlib.Algebra.Ring.Defs
toFun in ToMathlib.Control.Monad.Hom
Submodule in Mathlib.Algebra.Module.Submodule.Defs
Polynomial in Mathlib.Algebra.Polynomial.Basic
Polynomial.degreeLT in Mathlib.RingTheory.Polynomial.Basic
Zero in Init.Prelude
DecidableEq in Init.Prelude
Field in Mathlib.Algebra.Field.Defs
Fin in Init.Prelude
Function.Injective in Init.Data.Function
NeZero in Init.Data.NeZero
Set in Mathlib.Data.Set.Defs
Finset in Mathlib.Data.Finset.Defs
Matrix.add in Mathlib.LinearAlgebra.Matrix.Defs
Multiset in Mathlib.Data.Multiset.Defs
Multiset.count in Mathlib.Data.Multiset.Count
Set.InjOn in Mathlib.Data.Set.Operations
Finset.max in Mathlib.Data.Finset.Max
Module in Mathlib.Algebra.Module.Defs
Module.finrank in Mathlib.LinearAlgebra.Dimension.Finrank
Matrix in Mathlib.LinearAlgebra.Matrix.Defs
Matrix.of in Mathlib.LinearAlgebra.Matrix.Defs
Finset.min in Mathlib.Data.Finset.Max
Fin.castLE in Init.Data.Fin.Basic
Matrix.submatrix in Mathlib.LinearAlgebra.Matrix.Defs
id in Init.Prelude
Matrix.vandermonde in Mathlib.LinearAlgebra.Vandermonde
IsDomain in Mathlib.Algebra.Ring.Defs
Matrix.det in Mathlib.LinearAlgebra.Matrix.Determinant.Basic
Matrix.rank in Mathlib.LinearAlgebra.Matrix.Rank
Matrix.cRank in Mathlib.LinearAlgebra.Matrix.Rank
Fin.val in Init.Prelude
Finset.map in Mathlib.Data.Finset.Image
CommRing in Mathlib.Algebra.Ring.Defs
LinearMap in Mathlib.Algebra.Module.LinearMap.Defs
LinearMap.range in Mathlib.Algebra.Module.Submodule.Range
Finset.range in Mathlib.Data.Finset.Range
CommSemiring in Mathlib.Algebra.Ring.Defs
Polynomial.coeff in Mathlib.Algebra.Polynomial.Basic
hammingDist in Mathlib.InformationTheory.Hamming
Fintype.card in Mathlib.Data.Fintype.Card
StrongRankCondition in Mathlib.LinearAlgebra.InvariantBasisNumber

def wt [Zero F]
  (v : Œπ ‚Üí F) : ‚Ñï := #{i | v i ‚â† 0}

noncomputable def dim [Semiring F] (LC : LinearCode Œπ F) : ‚Ñï :=
  Module.finrank F LC

abbrev LinearCode.{u, v} (Œπ : Type u) [Fintype Œπ] (F : Type v) [Semiring F] : Type (max u v) :=
  Submodule F (Œπ ‚Üí F)

def subUpFull (U : Matrix (Fin m) (Fin n) F) (r_reindex : Fin n ‚Üí Fin m) :
  Matrix (Fin n) (Fin n) F := Matrix.submatrix U r_reindex id

@[simps]
def refl (pSpec : ProtocolSpec n) : Equiv pSpec pSpec where
  round_eq := rfl
  dir_eq := fun _ => rfl
  typeEquiv := fun _ => _root_.Equiv.refl _

def subLeftFull (U : Matrix (Fin m) (Fin n) F) (c_reindex : Fin m ‚Üí Fin n) :
  Matrix (Fin m) (Fin m) F := Matrix.submatrix U id c_reindex

def polynomialOfCoeffs (coeffs : Fin deg ‚Üí F) : F[X] :=
  ‚ü®
    Finset.map ‚ü®Fin.val, Fin.val_injective‚ü© {i | coeffs i ‚â† 0},
    fun i ‚Ü¶ if h : i < deg then coeffs ‚ü®i, h‚ü© else 0,
    fun a ‚Ü¶ by admit /- proof elided -/
  ‚ü©

def liftF' (f : ‚Ñï ‚Üí Œ±) : Fin n ‚Üí Œ± :=
  fun m ‚Ü¶ f m.1

noncomputable def fromColGenMat [CommRing F] (G : Matrix Œπ Œ∫ F) : LinearCode Œπ F :=
  LinearMap.range G.mulVecLin

def coeff.{u} {F : Type u} [Semiring F] (f : F[X][Y]) (i j : ‚Ñï) : F := (f.coeff j).coeff i

noncomputable def restrictLinear [Semiring F] (S : Finset Œπ) :
  (Œπ ‚Üí F) ‚Üí‚Çó[F] (S ‚Üí F) :=
{ toFun := fun f i => f i.1,
  map_add' := by admit /- proof elided -/

noncomputable def minDist (C : Set (n ‚Üí R)) : ‚Ñï :=
  sInf {d | ‚àÉ u ‚àà C, ‚àÉ v ‚àà C, u ‚â† v ‚àß hammingDist u v = d}

noncomputable def minWtCodewords [Semiring F] (LC : LinearCode Œπ F) : ‚Ñï :=
  sInf {w | ‚àÉ c ‚àà LC, c ‚â† 0 ‚àß Code.wt c = w}

def length [Semiring F] (_ : LinearCode Œπ F) : ‚Ñï := Fintype.card Œπ

notation "Œî" IC => minDist IC

@[reducible, simp] def StmtOut := Query OStatement

structure Commit where
  commit : Data ‚Üí Randomness ‚Üí OracleComp oSpec Commitment

@[inline]
def seqCompose {m : ‚Ñï} (Stmt : Fin (m + 1) ‚Üí Type)
    {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (V : (i : Fin m) ‚Üí Verifier oSpec (Stmt i.castSucc) (Stmt i.succ) (pSpec i)) :
    Verifier oSpec (Stmt 0) (Stmt (Fin.last m)) (seqCompose pSpec) := match m with
  | 0 => Verifier.id
  | _ + 1 => append (V 0) (seqCompose (Stmt ‚àò Fin.succ) (fun i => V (Fin.succ i)))

@[simp]
abbrev Statement := R1CS.Statement R pp.toSizeR1CS

noncomputable instance fintype_sDomain (i : Fin r) :
  Fintype (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i) :=

Polynomial.derivative in Mathlib.Algebra.Polynomial.Derivative

def pSpecFinalSumcheckStep : ProtocolSpec 1 := ‚ü®![Direction.P_to_V], ![L]‚ü©

Fin.reduceLast in Lean.Meta.Tactic.Simp.BuiltinSimprocs.Fin

abbrev BTF‚ÇÉ := ConcreteBTField 3 

Set.fintypeMemFinset in Mathlib.Data.Set.Finite.Basic

@[ext]
structure ProverOutput {Œπ : Type} (oSpec : OracleSpec Œπ) (Output PrvState : Type) where
  output : PrvState ‚Üí OracleComp oSpec Output

def foldStepRelOutProp (i : Fin ‚Ñì)
    (input : (Statement (L := L) Context i.succ √ó
      (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j)) √ó
      Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ) : Prop :=
  let stmt := input.1.1
  let oStmt := input.1.2
  let wit := input.2
  masterKStateProp (mp := mp) (ùìë := ùìë) ùîΩq Œ≤
    (stmtIdx := i.succ) (oracleIdx := i.castSucc)
    (h_le := Nat.le_of_lt (Fin.castSucc_lt_succ i)) stmt wit oStmt (localChecks := True)

def hconcat {n : ‚Ñï} {Œ± : Fin n ‚Üí Sort u} {Œ≤ : Sort u} (u : (i : Fin n) ‚Üí Œ± i) (a : Œ≤) :
    (i : Fin (n + 1)) ‚Üí Fin.vconcat Œ± Œ≤ i :=
  fconcat (F := id) u a

instance {i : Fin (n + 1)} : OfNat (evalDomain D i) 1 where
  ofNat := ‚ü®1, one_in_doms D i‚ü©

noncomputable def batchProver :
  OracleProver []‚Çí
    Unit (OracleStatement D x m) (Witness F s d m)
    ((Fin m ‚Üí F) √ó Fri.Spec.Statement F (0 : Fin (k + 1)))
      (OracleStatement D x m) (Fri.Spec.Witness F s d (0 : Fin (k + 2)))
    (batchSpec F m) where
  PrvState
  | 0 => (‚àÄj, OracleStatement D x m j) √ó Witness F s d m
  | 1 => (Fin m ‚Üí F) √ó (‚àÄj, OracleStatement D x m j) √ó Fri.Spec.Witness F s d (0 : Fin (k + 2))

  input := fun i => ‚ü®i.1.2, i.2‚ü©

  sendMessage
  | ‚ü®0, h‚ü© => nomatch h

  receiveChallenge
  | ‚ü®0, _‚ü© => fun ‚ü®os, ps‚ü© => pure <|
    fun (cs : Fin m ‚Üí F) =>
      ‚ü®cs, os,
        ‚ü®
          ps 0 + ‚àë i, Polynomial.C (cs i) * (ps i.succ).1,
          by admit /- proof elided -/
        ‚ü©
      ‚ü©

  output := fun ‚ü®cs, os, p‚ü© => pure <|
    ‚ü®‚ü®‚ü®cs, Fin.elim0‚ü©, os‚ü©, p‚ü©

MvPolynomial in Mathlib.Algebra.MvPolynomial.Basic

def linearMvExtension :
  Polynomial.degreeLT F (2^m) ‚Üí‚Çó[F] MvPolynomial (Fin m) F where
    
    toFun p := (p : Polynomial F).sum fun i a =>
      MvPolynomial.monomial (bitExpo i) a
    map_add' := by admit /- proof elided -/

ByteArray.mk in Init.Prelude

instance : Add (Cayley T) where
  add := add

noncomputable def hasMutualCorrAgreement
  (Gen : ProximityGenerator Œπ F) [Fintype Gen.par‚Ñì]
  (BStar : ‚Ñù) (errStar : ‚Ñù ‚Üí ENNReal) :=
    haveI := Gen.Gen_nonempty
    ‚àÄ (f : Gen.par‚Ñì ‚Üí Œπ ‚Üí F) (Œ¥ : ‚Ñù‚â•0) (_hŒ¥ : 0 < Œ¥ ‚àß Œ¥ < 1 - BStar),
    Pr_{let r ‚Üê$·µñ Gen.Gen}[ proximityCondition f Œ¥ r Gen.C ] ‚â§ errStar Œ¥

@[inline]
def ofOutputOnly
    (stmtLift : OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i) ‚Üí InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i) ‚Üí
                OuterStmtOut √ó (‚àÄ i, OuterOStmtOut i))
    (witLift : (OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i)) √ó OuterWitIn ‚Üí
               (InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i)) √ó InnerWitOut ‚Üí OuterWitOut) :
    OracleContext.Lens OuterStmtIn OuterStmtOut OuterStmtIn InnerStmtOut
                OuterOStmtIn OuterOStmtOut OuterOStmtIn InnerOStmtOut
                OuterWitIn OuterWitOut OuterWitIn InnerWitOut where
  stmt := OracleStatement.Lens.ofOutputOnly stmtLift
  wit := Witness.Lens.ofOutputOnly witLift

def pointToIterateQuotientIndex (i : Fin (‚Ñì + 1)) (steps : ‚Ñï) (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
    (x : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i, by omega‚ü©)) : Fin (2 ^ steps) :=

def BBF_eq_multiplier (r : Fin ‚Ñì ‚Üí L) : MultilinearPoly L ‚Ñì :=
  ‚ü®MvPolynomial.eqPolynomial r, by admit /- proof elided -/
  ‚ü©

@[reducible, simp]
def rbrSoundness
    (langIn : Set (Statement √ó ‚àÄ i, OStatement i))
    (verifier : OracleVerifier oSpec Statement OStatement Bool (fun _ : Empty => Unit) pSpec)
    (rbrSoundnessError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) : Prop :=
  verifier.rbrSoundness init impl langIn acceptRejectOracleRel.language rbrSoundnessError

@[reducible]
def OracleStatement : Fin (m + 1) ‚Üí Type :=
  fun _ => evalDomain D x 0 ‚Üí F

def squeeze (sponge : DuplexSponge U C) (len : Nat) :
    OracleComp (forwardPermutationOracle C) (Vector U len √ó DuplexSponge U C) :=
  match len with
  
  | 0 => pure (#v[], sponge)
  
  | n + 1 => do
    
    let sponge1 : DuplexSponge U C := { sponge with absorbPos := 0 }
    let sponge2 ‚Üê if sponge1.squeezePos = SpongeSize.R then
      let permutedState ‚Üê query (spec := forwardPermutationOracle _) () (sponge1.state)
      let sponge2 : DuplexSponge U C := { sponge1 with state := permutedState, squeezePos := 0 }
      pure sponge2
    else
      pure sponge1
    let squeezedVal := (SpongeState.get sponge2.state)[sponge2.squeezePos]
    let sponge3 := { sponge2 with squeezePos := sponge2.squeezePos + 1 }
    
    let (restVec, sponge4) ‚Üê squeeze sponge3 n
    
    
    return (restVec.insertIdx 0 squeezedVal, sponge4)

@[inline, specialize]
def OracleVerifier.run [O‚Çò : ‚àÄ i, OracleInterface (pSpec.Message i)]
    (stmt : StmtIn) (oStmtIn : ‚àÄ i, OStmtIn i) (transcript : FullTranscript pSpec)
    (verifier : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec) :
      OracleComp oSpec (StmtOut √ó (‚àÄ i, OStmtOut i)) := do
  let f := OracleInterface.simOracle2 oSpec oStmtIn transcript.messages
  let stmtOut ‚Üê simulateQ f (verifier.verify stmt transcript.challenges)
  let oStmtOut : ‚àÄ i, OStmtOut i := fun i => match h : verifier.embed i with
  | .inl j => by admit /- proof elided -/
  | .inr j => by admit /- proof elided -/

class Extractor.Straightline.IsMonotone
    (relIn : Set (StmtIn √ó WitIn))
    (E : Extractor.Straightline oSpec StmtIn WitIn WitOut pSpec)
    [oSpec.FiniteRange]
    where
  is_monotone : ‚àÄ witOut stmtIn transcript, ‚àÄ proveQueryLog‚ÇÅ proveQueryLog‚ÇÇ : oSpec.QueryLog,
    ‚àÄ verifyQueryLog‚ÇÅ verifyQueryLog‚ÇÇ : oSpec.QueryLog,
    proveQueryLog‚ÇÅ.Sublist proveQueryLog‚ÇÇ ‚Üí
    verifyQueryLog‚ÇÅ.Sublist verifyQueryLog‚ÇÇ ‚Üí
    
    [fun witIn => (stmtIn, witIn) ‚àà relIn |
      E stmtIn witOut transcript proveQueryLog‚ÇÅ verifyQueryLog‚ÇÅ] ‚â§
    [fun witIn => (stmtIn, witIn) ‚àà relIn |
      E stmtIn witOut transcript proveQueryLog‚ÇÇ verifyQueryLog‚ÇÇ]

def Œ≥ (x‚ÇÄ : F) (R : F[X][X][Y]) (H : F[X][Y]) [œÜ : Fact (Irreducible H)] : PowerSeries (ùïÉ H) :=
  let subst (t : ‚Ñï) : ùïÉ H :=
    match t with
    | 0 => fieldToùïÉ (-x‚ÇÄ)
    | 1 => 1
    | _ => 0
  PowerSeries.subst (PowerSeries.mk subst) (PowerSeries.mk (Œ± x‚ÇÄ R H))

def checkSrs (proveSrs : Vector G‚ÇÅ (n + 1)) (verifySrs : Vector G‚ÇÇ 2) : Prop :=
  ‚àÄ i : Fin n,
    pairing (proveSrs[i.succ]) (verifySrs[0]) = pairing (proveSrs[i.castSucc]) (verifySrs[1])

def existPriorSameQuery (log : QueryLog spec) (idx : Fin log.length) : Prop :=
  ‚àÉ j' < idx, log[j'] = log[idx]

Dist in Mathlib.Topology.MetricSpace.Pseudo.Defs

Set.imageFactorization in Mathlib.Data.Set.Operations

Fin.isValue in Lean.Meta.Tactic.Simp.BuiltinSimprocs.Fin

@[reducible]
def GroupEqOracle : OracleSpec Unit := fun _ => (Œπ √ó Œπ, Bool)

def relayKnowledgeStateFunction (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
    (relayOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        i hNCR).KnowledgeStateFunction init impl
      (relIn := foldStepRelOut (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i.succ)
      (extractor := relayRbrExtractor ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) where
  toFun := fun m ‚ü®stmtIn, oStmtIn‚ü© tr witMid =>
    relayKStateProp (mp:=mp) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (ùìë := ùìë) i hNCR stmtIn witMid oStmtIn
  toFun_empty := fun ‚ü®stmtIn, oStmtIn‚ü© witIn => by admit /- proof elided -/

def nonLastBlockOracleVerifier (bIdx : Fin (‚Ñì / œë - 1)) :=
  let stmt : Fin (œë - 1 + 1) ‚Üí Type :=
    fun i => Statement (L := L) Context ‚ü®bIdx * œë + i, bIdx_mul_œë_add_i_cast_lt_‚Ñì_succ bIdx i‚ü©
  let oStmt := fun i: Fin (œë - 1 + 1) => OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë
    ‚ü®bIdx * œë + i, bIdx_mul_œë_add_i_cast_lt_‚Ñì_succ bIdx i‚ü©
  let firstFoldRelayRoundsOracleVerifier :=
    OracleVerifier.seqCompose (oSpec := []‚Çí)
      (Stmt := stmt)
      (OStmt := oStmt)
      (pSpec := fun i => pSpecFoldRelay (L:=L))
      (V := fun i => by admit /- proof elided -/
      )
  let h1 : ‚ÜëbIdx * œë + (œë - 1) < ‚Ñì := by admit /- proof elided -/

def findSumIdx (l : List Œ±) (j : Œ±) : ‚Ñï := l.partialSum.findIdx (j < ¬∑)

OrderBot in Mathlib.Order.BoundedOrder.Basic

instance : Field ScalarField := ZMod.instField scalarFieldSize

@[simps!]
noncomputable def algEquivAevalXSubC {R : Type*} [CommRing R] (t : R) : R[X] ‚âÉ‚Çê[R] R[X] :=

def rootMultiplicity.{u} {F : Type u} [CommSemiring F] [DecidableEq F]
  (f : F[X][Y]) (x y : F) : Option ‚Ñï :=
  let X := (Polynomial.X : Polynomial F)
  rootMultiplicity‚ÇÄ (F := F) ((f.comp (Y + (C (C y)))).map (Polynomial.compRingHom (X + C x)))

def lastBlockOracleVerifier :=
  let bIdx := ‚Ñì / œë - 1
  let stmt : Fin (œë + 1) ‚Üí Type := fun i => Statement (L := L) (‚Ñì:=‚Ñì) Context
    ‚ü®bIdx * œë + i, by admit /- proof elided -/
    ‚ü©
  let oStmt := fun i: Fin (œë + 1) => OracleStatement ùîΩq Œ≤ œë
    ‚ü®bIdx * œë + i, by admit /- proof elided -/
    ‚ü©
  let V:  OracleVerifier []‚Çí (StmtIn := Statement (L := L) (‚Ñì := ‚Ñì) Context
      ‚ü®bIdx * œë, by admit /- proof elided -/
      ‚ü©)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë
      ‚ü®bIdx * œë, by admit /- proof elided -/
      ‚ü©)
    (StmtOut := Statement (L := L) (‚Ñì := ‚Ñì) Context (Fin.last ‚Ñì))
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (pSpec := pSpecLastBlock (L:=L) (œë:=œë)) := by admit /- proof elided -/

def internalLinearLayer (state : Vector KoalaBear.Field params.width) :
    Vector KoalaBear.Field params.width :=
  
  
  let sumAll := state.foldl (fun acc x => acc + x) 0

  
  
  state.zipWith (fun s d => sumAll + d * s) params.internalDiagVectors

def binaryAlgebraTower {l r : ‚Ñï} (h_le : l ‚â§ r) : Algebra (BTField l) (BTField r) :=

evalDist in VCVio.EvalDist.Basic

private noncomputable def Q (œâs : Fin n ‚Üí F)
  (f : Fin n ‚Üí F) (p : Polynomial F) (e : ‚Ñï) : Polynomial F :=
  p * (E œâs f p e)

@[elab_as_elim]
def dflatten {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {motive : (k : Fin (vsum n)) ‚Üí Sort*}
    (v : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí motive (embedSum i j)) (k : Fin (vsum n)) : motive k :=
  match m with
  | 0 => Fin.elim0 k
  | _ + 1 =>
    dappend
      (fun j => v 0 j)
      (fun j => dflatten (motive := fun j => motive (natAdd _ j)) (fun i => v i.succ) j)
      k

inductive ScalarVectorOp where | scale

@[reducible] def OracleProof {Œπ : Type} (oSpec : OracleSpec Œπ)
    (Statement : Type) {Œπ‚Çõ·µ¢ : Type} (OStatement : Œπ‚Çõ·µ¢ ‚Üí Type) (Witness : Type)
    {n : ‚Ñï} (pSpec : ProtocolSpec n)
    [O‚Çõ·µ¢ : ‚àÄ i, OracleInterface (OStatement i)]
    [O‚Çò : ‚àÄ i, OracleInterface (pSpec.Message i)] :=
  OracleReduction oSpec Statement OStatement Witness Bool (fun _ : Empty => Unit) Unit pSpec

@[simp]
def innerRelIn_Test : Set (InnerStmtIn_Test √ó Unit) :=
  setOf (fun ‚ü®‚ü®f, t‚ü©, _‚ü© => ‚àë x ‚àà {0, 1}, f.eval x = t)

noncomputable def liftBivariate {H : F[X][Y]} : F[X][Y] ‚Üí+* ùïÉ H :=
  RingHom.comp (Ideal.Quotient.mk (Ideal.span {H_tilde H})) bivPolyHom

noncomputable def W (i : Fin r) : L[X] :=
  ‚àè u : U ùîΩq Œ≤ i, (X - C u.val)

inductive FullData (Œ± : Type) : Skeleton ‚Üí Type
  | leaf (value : Œ±) : FullData Œ± Skeleton.leaf
  | internal {left right} (value : Œ±)
      (leftData : FullData Œ± left)
      (rightData : FullData Œ± right) :
      FullData Œ± (Skeleton.internal left right)
  deriving Repr

@[inline]
def ofInputOnly
    (liftWit : OuterStmtIn √ó OuterWitOut ‚Üí InnerWitIn ‚Üí OuterWitIn) :
    Witness.InvLens OuterStmtIn OuterWitIn OuterWitOut InnerWitIn OuterWitOut :=
  ‚ü®Prod.snd, liftWit‚ü©

def Cache (n : ‚Ñï) := (layer : Fin (n + 1)) ‚Üí List.Vector Œ± (2 ^ layer.val)

def coeffsOfPolynomial (p : F[X]) : Fin deg ‚Üí F :=
  fun ‚ü®x, _‚ü© ‚Ü¶ p.coeff x

class IsSound (langIn : Set StmtIn) (langOut : Set StmtOut)
    (verifier : Verifier oSpec StmtIn StmtOut pSpec) where
  soundnessError : ‚Ñù‚â•0
  is_sound : soundness init impl langIn langOut verifier soundnessError

Subtype.fintype in Mathlib.Data.Fintype.Sets

instance : IsEmpty (ChallengeIdx ‚ü®!v[.P_to_V], !v[Msg]‚ü©) :=
  ‚ü®fun ‚ü®i, h‚ü© => by admit /- proof elided -/
  ‚ü©

@[inline, specialize]
def oracleReduction : OracleReduction oSpec
    Statement OStatement Unit Statement OStatement Unit !p[] where
  prover := oracleProver oSpec Statement OStatement
  verifier := oracleVerifier oSpec Statement OStatement pred

def implGroupExpOracle : QueryImpl (GroupExpOracle Œπ p) (StateT (GroupValTable Œπ G) Option) where
  impl | query _ ‚ü®i, a, j‚ü© => fun table =>
    match table i with
    | some g => some ((), table.update j (some (g ^ a.val)))
    | none => none

structure DomainSeparator (U : Type) [SpongeUnit U] (H : Type*) [DuplexSpongeInterface U H] where
   
  io : String
deriving Repr

BitVec.toNat in Init.Prelude

Subsingleton in Init.Core

instance instDCast‚ÇÇ : DCast‚ÇÇ Nat ProtocolSpec (fun _ pSpec => ChallengeIdx pSpec) where
  dcast‚ÇÇ h := ChallengeIdx.cast h
  dcast‚ÇÇ_id := cast_id

instance [VerifierFirst pSpec] : VerifierLast pSpec where
  verifier_last' := by admit /- proof elided -/

minpoly in Mathlib.FieldTheory.Minpoly.Basic

def evalWAt (i : Fin r) (x : L) : L :=
  ((getUElements (Œ≤ := Œ≤) (‚Ñì := ‚Ñì) (R_rate := R_rate) i).map (fun u => x - u)).prod

class DCast‚ÇÇ (Œ± : Sort*) (Œ≤ : Œ± ‚Üí Sort*) (Œ≥ : (a : Œ±) ‚Üí Œ≤ a ‚Üí Sort*) [DCast Œ± Œ≤] where
  dcast‚ÇÇ : ‚àÄ {a a' : Œ±} {b : Œ≤ a} {b' : Œ≤ a'},
    (ha : a = a') ‚Üí (dcast ha b = b') ‚Üí Œ≥ a b ‚Üí Œ≥ a' b'
  dcast‚ÇÇ_id : ‚àÄ {a : Œ±} {b : Œ≤ a}, dcast‚ÇÇ (Eq.refl a) dcast_eq = (id : Œ≥ a b ‚Üí Œ≥ a b)

private noncomputable def oddPart' (f : Polynomial F) : Polynomial F :=
  match f with
  | ‚ü®‚ü®supp, f, pr‚ü©‚ü© => ‚ü®‚ü®
      shift_left (erase_even supp),
      fun n => if Even n then f (n + 1) else 0, by admit /- proof elided -/
      ‚ü©‚ü©

System.mkFilePath in Init.System.FilePath

@[inline]
def ofOutputOnly
    (witLift :
      OuterStmtIn √ó OuterWitIn ‚Üí InnerStmtOut √ó InnerWitOut ‚Üí OuterWitOut)
    (stmtLift : OuterStmtIn ‚Üí InnerStmtOut ‚Üí OuterStmtOut) :
    Context.Lens OuterStmtIn OuterStmtOut OuterStmtIn InnerStmtOut
                OuterWitIn OuterWitOut OuterWitIn InnerWitOut where
  wit := Witness.Lens.ofOutputOnly witLift
  stmt := Statement.Lens.ofOutputOnly stmtLift

def start {Œ± : Type} (a : Œ±) : OracleComp (Œ± ‚Üí‚Çí Vector U SpongeSize.C) (DuplexSponge U C) := do
  let capacitySegment : Vector U SpongeSize.C ‚Üê query (spec := Œ± ‚Üí‚Çí Vector U SpongeSize.C) () a
  let vecSponge := (Vector.replicate SpongeSize.R (0 : U)) ++ capacitySegment
  return {
    state := SpongeState.update (Œ± := C) (0 : C) (vecSponge.cast (by admit /- proof elided -/
    )),
    absorbPos := 0,
    squeezePos := Fin.last SpongeSize.R
  }

@[reducible, simp]
def relOut : (StmtOut OStatement √ó ‚àÄ i, OStmtOut OStatement i) ‚Üí WitOut ‚Üí Prop :=
  fun ‚ü®‚ü®q, r‚ü©, oStmt‚ü© () => answer (oStmt 0) q = r

structure Gate (ùì° : Type*) (numWires : ‚Ñï) extends Selector ùì°, WireIndices numWires
deriving DecidableEq

head in ToMathlib.Control.Comonad.Instances

Array.map in Init.Data.Array.Basic

def oracleVerifier (i : Fin n) : OracleVerifier oSpec
    (StatementRound R n i.castSucc) (OracleStatement R n deg)
    (StatementRound R n i.succ) (OracleStatement R n deg) (pSpec R deg) where
  
  
  
  
  verify := fun ‚ü®target, challenges‚ü© chal => do
    let evals : List R ‚Üê (List.finRange m).mapM
      (fun i => do
        return ‚Üê query
          (spec := (oSpec ++‚Çí ([OracleStatement R n deg]‚Çí ++‚Çí [(pSpec R deg).Message]‚Çí)))
            (Sum.inr <| Sum.inr default) (D i))
    guard (evals.sum = target)
    let newTarget ‚Üê query
      (spec := (oSpec ++‚Çí ([OracleStatement R n deg]‚Çí ++‚Çí [(pSpec R deg).Message]‚Çí)))
        (Sum.inr <| Sum.inr default) (by admit /- proof elided -/
        )
    letI newTarget : R := by admit /- proof elided -/

@[reducible]
def Set.language {Œ± Œ≤} (rel : Set (Œ± √ó Œ≤)) : Set Œ± :=
  Prod.fst '' rel

def distanceLE (Message : Type*) [O : OracleInterface Message]
    [Fintype (O.Query)] [DecidableEq (O.Response)] (d : ‚Ñï) : Prop :=
  ‚àÄ a b : Message, a ‚â† b ‚Üí #{q | OracleInterface.answer a q = OracleInterface.answer b q} ‚â§ d

SetLike in Mathlib.Data.SetLike.Basic

def nil {Œ±} : Vector Œ± 0 := ‚ü®#[], rfl‚ü© 

class VCVCompatible (Œ± : Type*) extends Fintype Œ±, Inhabited Œ± where
  [type_decidableEq' : DecidableEq Œ±]

inductive ScalarOp where | add | sub | mul | div

def NBlockMessages := 2 * (œë - 1) + 3

def totalNumPermQueries : Nat :=
  pSpec.totalNumPermQueriesMessage + pSpec.totalNumPermQueriesChallenge

@[simp]
abbrev OracleStatement.AfterFirstChallenge : R1CS.MatrixIdx ‚äï Fin 1 ‚Üí Type :=
  OracleStatement.AfterFirstMessage R pp

@[inline, specialize]
def Prover.processRoundDSFS [‚àÄ i, VCVCompatible (pSpec.Challenge i)] (j : Fin n)
    (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec)
    (currentResult : OracleComp (oSpec ++‚Çí duplexSpongeChallengeOracle StmtIn U)
      (pSpec.MessagesUpTo j.castSucc √ó
        CanonicalDuplexSponge U √ó prover.PrvState j.castSucc)) :
      OracleComp (oSpec ++‚Çí duplexSpongeChallengeOracle StmtIn U)
        (pSpec.MessagesUpTo j.succ √ó
          CanonicalDuplexSponge U √ó prover.PrvState j.succ) := do
  let ‚ü®messages, sponge, state‚ü© ‚Üê currentResult
  match hDir : pSpec.dir j with
  | .V_to_P => do
    let f ‚Üê prover.receiveChallenge ‚ü®j, hDir‚ü© state
    let (challenge, newSponge) ‚Üê
      liftM (DuplexSponge.squeeze sponge (challengeSize ‚ü®j, hDir‚ü©))
    
    let deserializedChallenge : pSpec.Challenge ‚ü®j, hDir‚ü© := Deserialize.deserialize challenge
    return ‚ü®messages.extend hDir, newSponge, f deserializedChallenge‚ü©
  | .P_to_V => do
    let ‚ü®msg, newState‚ü© ‚Üê prover.sendMessage ‚ü®j, hDir‚ü© state
    let serializedMessage : Vector U (messageSize ‚ü®j, hDir‚ü©) := Serialize.serialize msg
    let newSponge ‚Üê liftM (DuplexSponge.absorb sponge serializedMessage.toList)
    return ‚ü®messages.concat hDir msg, newSponge, newState‚ü©

@[reducible]
def OracleStatement : Unit ‚Üí Type := fun _ => R‚¶É‚â§ deg‚¶Ñ[X Fin n]

def getHighBits (numLowBits : ‚Ñï) (n : ‚Ñï) : ‚Ñï :=
  (getHighBits_no_shl numLowBits n) <<< numLowBits

Fin.rev in Init.Data.Fin.Basic

def BerlekampWelchMatrix
  (e k : ‚Ñï)
  (œâs f : Fin n ‚Üí F) : Matrix (Fin n) (Fin (2 * e + k)) F :=
  Matrix.of fun i j =>
    let Œ±·µ¢ := œâs i
    if ‚Üëj < e then -Rhs j.1 œâs f i else -Œ±·µ¢^(j - e)

instance : Slice (FullTranscript pSpec) ‚Ñï ‚Ñï
    (fun _ start stop => start ‚â§ stop ‚àß stop ‚â§ n)
    (fun _ start stop _ => FullTranscript (pSpec‚ü¶start:stop‚üß))
    where
  slice := fun v start stop h => extract start stop h.1 h.2 v

def divX (p : UniPoly R) : UniPoly R := p.extract 1 p.size

def JohnsonConditionStrong (B : Finset (Fin n ‚Üí F)) (v : Fin n ‚Üí F) : Prop :=
  let e := e B v
  let d := d B
  let q : ‚Ñö := Fintype.card F
  let frac := q / (q - 1)
  (1 - frac * d/n) < (1- frac * e/n) ^ 2

List.rightpad in Init.Data.List.Basic

USize.ofNat in Init.Data.UInt.BasicAux

@[inline, specialize]
def oracleVerifier : OracleVerifier oSpec
    Statement OStatement Statement (OStatement ‚äï·µ• (fun _ : Fin 1 => Witness))
    (oraclePSpec Witness) where
  verify := fun stmt _ => pure stmt
  embed := .sumMap (.refl _)
    <| Equiv.toEmbedding
    <|.symm (subtypeUnivEquiv (by admit /- proof elided -/
    ))
  hEq := by admit /- proof elided -/

BitVec.zero in Init.Data.BitVec.Basic

instance : MonadLift (StateT œÑ m) (StateT (œÉ √ó œÑ) m) where
  monadLift := fun x st => do let y ‚Üê x st.2; return (y.1, st.1, y.2)

instance instDCast‚ÇÇOracleProver : DCast‚ÇÇ Nat ProtocolSpec
    (fun _ pSpec => OracleProver oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec) where
  dcast‚ÇÇ := OracleProver.cast
  dcast‚ÇÇ_id := OracleProver.cast_id

Polynomial.resultant in Mathlib.RingTheory.Polynomial.Resultant.Basic

@[reducible]
def pBits : Nat := 31

@[inline, specialize]
def OracleReduction.run [‚àÄ i, OracleInterface (pSpec.Message i)]
    (stmt : StmtIn) (oStmt : ‚àÄ i, OStmtIn i) (wit : WitIn)
    (reduction : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec) :
      OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí)
        ((FullTranscript pSpec √ó (StmtOut √ó ‚àÄ i, OStmtOut i) √ó WitOut) √ó
          (StmtOut √ó ‚àÄ i, OStmtOut i)) := do
  let proverResult ‚Üê reduction.prover.run ‚ü®stmt, oStmt‚ü© wit
  let stmtOut ‚Üê liftM (reduction.verifier.run stmt oStmt proverResult.1)
  return ‚ü®proverResult, stmtOut‚ü©

instance [ProverFirst pSpec] : ‚àÄ i, VCVCompatible (pSpec.Challenge i) := isEmptyElim

List.max? in Init.Data.List.Basic

def multilinearBasis (l r : ‚Ñï) (h_le : l ‚â§ r) :
    letI instAlgebra := ConcreteBTFieldAlgebra (h_le:=h_le)
    Basis (Fin (2 ^ (r - l))) (ConcreteBTField l) (ConcreteBTField r) :=

Lagrange.basis in Mathlib.LinearAlgebra.Lagrange

def deriveTranscriptDSFSAux {Œπ : Type} {oSpec : OracleSpec Œπ} {StmtIn : Type}
    (sponge : CanonicalDuplexSponge U)
    (messages : pSpec.Messages) (i : Fin (n + 1)) :
      OracleComp (oSpec ++‚Çí duplexSpongeChallengeOracle StmtIn U)
        (CanonicalDuplexSponge U √ó pSpec.Transcript i) :=
  Fin.induction
    (pure (sponge, fun i => i.elim0))
    (fun i ih => do
      let ‚ü®curSponge, prevTranscript‚ü© ‚Üê ih
      match hDir : pSpec.dir i with
      | .V_to_P =>
        let ‚ü®challenge, newSponge‚ü© ‚Üê liftM (curSponge.squeeze (challengeSize ‚ü®i, hDir‚ü©))
        let deserializedChallenge : pSpec.Challenge ‚ü®i, hDir‚ü© :=
          Deserialize.deserialize challenge
        return (newSponge, prevTranscript.concat deserializedChallenge)
      | .P_to_V =>
        let serializedMessage : Vector U (messageSize ‚ü®i, hDir‚ü©) :=
          Serialize.serialize (messages ‚ü®i, hDir‚ü©)
        let newSponge ‚Üê liftM (DuplexSponge.absorb curSponge serializedMessage.toList)
        return (newSponge, prevTranscript.concat (messages ‚ü®i, hDir‚ü©)))
    i

def Reduction.liftContext
    (lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut)
    (R : Reduction oSpec InnerStmtIn InnerWitIn InnerStmtOut InnerWitOut pSpec) :
      Reduction oSpec OuterStmtIn OuterWitIn OuterStmtOut OuterWitOut pSpec where
  prover := R.prover.liftContext lens
  verifier := R.verifier.liftContext lens.stmt

def findFinIdx (p : Œ± ‚Üí Bool) (l : List Œ±) : Fin (l.length + 1) :=
  ‚ü®List.findIdx' p l,
    Nat.lt_succ_of_le (by admit /- proof elided -/
    )‚ü©

abbrev MultiquadraticPoly (L : Type) [CommSemiring L] (‚Ñì : ‚Ñï) := L‚¶É‚â§ 2‚¶Ñ[X Fin ‚Ñì]

def divSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (k : Fin (‚àë j, n j)) : Fin m :=
  (divSum? n k).get (divSum?_is_some_iff_lt_sum.mpr k.isLt)

instance : LawfulHasPred Nat where
  pred'_succ := Nat.pred_succ

@[inline, specialize]
def Reduction.runWithLog (stmt : StmtIn) (wit : WitIn)
    (reduction : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí)
        (((FullTranscript pSpec √ó StmtOut √ó WitOut) √ó StmtOut) √ó
          QueryLog (oSpec ++‚Çí [pSpec.Challenge]‚Çí) √ó QueryLog oSpec) := do
  
  let ‚ü®proverResult, proveQueryLog‚ü© ‚Üê reduction.prover.runWithLog stmt wit
  let ‚ü®stmtOut, verifyQueryLog‚ü© ‚Üê
    liftM (simulateQ loggingOracle (reduction.verifier.run stmt proverResult.1)).run
  return ‚ü®‚ü®proverResult, stmtOut‚ü©, proveQueryLog, verifyQueryLog‚ü©

def getCommitProverFinalOutput (i : Fin ‚Ñì)
    (inputPrvState : commitPrvState (Context := Context) ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i 0) :
  (‚Ü•(sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®‚Üëi + 1, by admit /- proof elided -/
  ‚ü©) ‚Üí L) √ó
  commitPrvState (Context := Context) ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i 1 :=
  let (stmt, oStmtIn, wit) := inputPrvState
  let f·µ¢_succ := wit.f
  let oStmtOut := snoc_oracle ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
    oStmtIn f·µ¢_succ 
  (f·µ¢_succ, (stmt, oStmtOut, wit))

instance : SMul R (UniPoly R) := ‚ü®UniPoly.smul‚ü©

def churchAnd (p q : ChurchBool Œ±) : ChurchBool Œ± :=
  fun x y => p (q x y) y

def extractMiddleFinMask (v : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®0, by exact pos_of_neZero r‚ü©)
    (i : Fin ‚Ñì) (steps : ‚Ñï) : Fin (2 ^ steps) :=

def pad (sz‚ÇÅ sz‚ÇÇ : Size)
    (stmt : Statement R sz‚ÇÅ)
    (matrices : MatrixIdx ‚Üí Matrix (Fin sz‚ÇÅ.m) (Fin sz‚ÇÅ.n) R)
    (wit : Witness R sz‚ÇÅ) :
    Statement R sz‚ÇÇ √ó (MatrixIdx ‚Üí Matrix (Fin sz‚ÇÇ.m) (Fin sz‚ÇÇ.n) R) √ó Witness R sz‚ÇÇ :=
  (Fin.rightpad sz‚ÇÇ.n_x 0 stmt,
    fun idx => Matrix.rightpad sz‚ÇÇ.m sz‚ÇÇ.n 0 (matrices idx),
    Fin.rightpad sz‚ÇÇ.n_w 0 wit)

StateT.lift in Init.Control.State

def powAlgHom :
  MvPolynomial (Fin m) F ‚Üí‚Çê[F] Polynomial F :=
   aeval fun j => Polynomial.X ^ (2 ^ (j : ‚Ñï))

instance [ProverFirst pSpec] : ProverLast pSpec where
  prover_last' := by admit /- proof elided -/

instance {Message : Type u} : Inhabited (OracleInterface Message) :=
  ‚ü®instDefault‚ü©

AlgHom in Mathlib.Algebra.Algebra.Hom

def monomialXY (n m : ‚Ñï) : F ‚Üí‚Çó[F] F[X][Y] where
  toFun t := ‚ü®Finsupp.single m ‚ü®(Finsupp.single n t)‚ü©‚ü©
  map_add' x y := by admit /- proof elided -/

@[reducible]
def fieldSize : Nat := 2 ^ 31 - 2 ^ 24 + 1

noncomputable def monomialBasisOfDegreeLT {n : ‚Ñï} : Basis (Fin n) L (L‚¶É< n‚¶Ñ[X]) :=

Neg in Init.Prelude

partial def verifyCertificate (n' : Q(‚Ñï)) (n : ‚Ñï) :
    UnverifiedPrattCertificate n ‚Üí MetaM Q(Nat.Prime $n')
  | .knownPrime n => verifySmallPrime n'
  | .of n a part => do
      let cert ‚Üê generateCertificate n' n a part
      return q(PrattCertificate.out $cert)
  where
  generateCertificate (n' : Q(‚Ñï)) (_ : ‚Ñï) (a : ‚Ñï) (part : UnverifiedPrattPart) :
      MetaM Q(PrattCertificate $n') := do
    have alit : Q(‚Ñï) := mkRawNatLit a
    let ‚ü®a', pa'‚ü© ‚Üê mkOfNat q(ZMod $n') q(instAddMonoidWithOne) alit
    let hpow : Q($a' ^ ($n' - 1) = 1) ‚Üê verifyEqOne n' alit a' pa'
    let result ‚Üê generatePart n' a' alit pa' part
    haveI : $(result.1) =Q $n' - 1 := ‚ü®‚ü©
    return q(PrattCertificate.mk $a' $hpow $(result.2))
  generatePart (n' : Q(‚Ñï)) (a : Q(ZMod $n')) (a' : Q(‚Ñï)) (pa' : Q(($a' : ZMod $n') = $a)) :
      UnverifiedPrattPart ‚Üí MetaM ((nn : Q(‚Ñï)) √ó Q(PrattPart $n' $a $nn))
    | .prime p k hp => do
      
      have plit : Q(‚Ñï) := mkRawNatLit p
      let inner ‚Üê verifyCertificate plit p hp
      have pklit : Q(‚Ñï) := mkRawNatLit (p ^ k)
      have klit : Q(‚Ñï) := mkRawNatLit k
      let hpow ‚Üê verifyNeOne n' a' plit a pa'
      haveI : $pklit =Q $plit ^ $klit := ‚ü®‚ü©
      return ‚ü®pklit, q(PrattPart.prime $plit $klit _ $inner $hpow (.refl _))‚ü©
    | .split left right => do
      let ‚ü®nleft, pleft‚ü© ‚Üê generatePart n' a a' pa' left
      let ‚ü®nright, pright‚ü© ‚Üê generatePart n' a a' pa' right
      
      have nn : Q(‚Ñï) := mkRawNatLit (nleft.natLit! * nright.natLit!)
      haveI : $nn =Q $nleft * $nright := ‚ü®‚ü©
      return ‚ü®nn, q(PrattPart.split $nleft $nright $pleft $pright (.refl _))‚ü©

instance {Œ± : Type} {s : Skeleton} :
    CoeFun (InternalData Œ± s) fun (_ : InternalData Œ± s) => SkeletonInternalIndex s ‚Üí Œ± where
  coe := fun tree idx => tree.get idx

def Extractor.RoundByRound.id :
    Extractor.RoundByRound oSpec Statement Witness Witness !p[] (fun _ => Witness) where
  eqIn := rfl
  extractMid := fun i => Fin.elim0 i
  extractOut := fun _ _ => _root_.id

def Fin.traverseM {Œ≤ : Fin n ‚Üí Type u}
    (f : (i : Fin n) ‚Üí m (Œ≤ i)) : m ((i : Fin n) ‚Üí Œ≤ i) :=
  let rec aux (k : ‚Ñï) (h : k ‚â§ n) : m ((i : Fin k) ‚Üí Œ≤ (Fin.castLE h i)) :=
    match k with
    | 0 => pure (fun i => i.elim0)
    | k' + 1 => do
      let tail ‚Üê aux k' (Nat.le_of_succ_le h)
      let head ‚Üê f (Fin.castLE h (Fin.last k'))
      return (Fin.snoc tail head)
  aux n (le_refl n)

instance instDCast‚ÇÇ : DCast‚ÇÇ Nat ProtocolSpec (fun _ pSpec => MessageIdx pSpec) where
  dcast‚ÇÇ h := MessageIdx.cast h
  dcast‚ÇÇ_id := cast_id

structure ParamConditions (P : Params Œπ F) where
  m : ‚Ñï 
  h_m : m = P.varCount 0
  h_sumkLt : ‚àë i : Fin (M + 1), P.foldingParam i ‚â§ m
  h_varCount_i : ‚àÄ i : Fin (M + 1),
    P.varCount i = m - ‚àë j : Fin i, P.foldingParam (Fin.castLT j (Nat.lt_trans j.isLt i.isLt))
  h_smooth : ‚àÄ i : Fin (M + 1), Smooth (P.œÜ i)
  h_repeatPLt : ‚àÄ i : Fin (M + 1), P.repeatParam i ‚â§ Fintype.card (Œπ i)

instance : ‚àÄ i, OracleInterface ((default : ProtocolSpec 0).Message i) := fun ‚ü®i, _‚ü© => Fin.elim0 i

instance [Zero T] [DecidableEq T] [ToNat T] : Div (Cayley T) where
  div := div

noncomputable def foldingDistRange
   (degree : ‚Ñï) [Fintype Œπ] [Nonempty Œπ] (œÜ : Œπ ‚Ü™ F) (f : Œπ ‚Üí F) : ‚Ñù :=
    let C : Set (Œπ ‚Üí F) := code œÜ degree
    min Œ¥·µ£(f, C) (1 - Bstar (LinearCode.rate (code œÜ degree)))

Module.Basis.baseChange in Mathlib.LinearAlgebra.TensorProduct.Basis

instance oCtxLens_complete :
    (oCtxLens R n deg D i).toContext.IsComplete
      (relationRound R n deg D i.castSucc) (Simple.inputRelation R deg D)
      (relationRound R n deg D i.succ) (Simple.outputRelation R deg)
      ((Simple.oracleReduction R deg D oSpec).toReduction.compatContext
        (oCtxLens R n deg D i).toContext)
where
  proj_complete := by admit /- proof elided -/

  partial def computePrattCertificate (n : ‚Ñï) : Option (UnverifiedPrattCertificate n) :=
    
    if n ‚â§ 50 ‚àß deterministicMillerRabin n then
      some (.knownPrime n)
    else do
      let fs ‚Üê factor' (n - 1)
      let a ‚Üê findWitness n fs
      let part ‚Üê computePrattPart fs
      return .of n a part
  where
    findWitness (n : ‚Ñï) (fs : List PrimeWithMultiplicity) : Option ‚Ñï := do
      for a in [2:n] do
        let mut ok := true
        for ‚ü®p, _‚ü© in fs do
          if powMod a ((n - 1) / p) n = 1 then
            ok := false
            break

        if ok then
          return a

      none

instance {Œ± : Type u} [ToNat Œ±] : CoeHead Œ± Nat where
  coe := ToNat.toNat

Fin.succEmb in Mathlib.Data.Fin.Embedding

def roundRelation (i : Fin (‚Ñì + 1)) :
    Set ((Statement (L := L) Context i √ó
      (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i j)) √ó
      Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) :=
  { input | roundRelationProp (mp := mp) (ùìë := ùìë) ùîΩq Œ≤ i input}

noncomputable def towerRingEquivFromConcrete0 : ConcreteBTField 0 ‚âÉ+* BTField 0 :=

instance instDCast : DCast Nat ProtocolSpec where
  dcast h := ProtocolSpec.cast h
  dcast_id := cast_id

private def k [Zero F] (B : Finset (Fin n ‚Üí F)) : ‚Ñö :=
  (1 : ‚Ñö) / n * ‚àë i, K B i 0

Quotient.lift in Init.Core

noncomputable def vanishingPoly (S : Finset F) : Polynomial F :=
  ‚àè s ‚àà S, (Polynomial.X - Polynomial.C s)

instance : ‚àÄ j, OracleInterface ((pSpecFold D x k s).Message j) :=
  instOracleInterfaceMessageSeqCompose

protected def cast (R : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec‚ÇÅ) :
    OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec‚ÇÇ where
  prover := R.prover.cast hn hSpec
  verifier := R.verifier.cast hn hSpec hO‚Çò

def buildLayer (n : ‚Ñï) (leaves : List.Vector Œ± (2 ^ (n + 1))) :
    OracleComp (spec Œ±) (List.Vector Œ± (2 ^ n)) := do
  let leaves : List.Vector Œ± (2 ^ n * 2) :=

instance {langIn : Set StmtIn} {langOut : Set StmtOut}
    {verifier : Verifier oSpec StmtIn StmtOut pSpec} :
    CoeFun (KnowledgeStateFunctionOneShot init impl langIn langOut verifier)
    (fun _ => (m : Fin (n + 1)) ‚Üí StmtIn ‚Üí Transcript m pSpec ‚Üí Prop) := ‚ü®fun f => f.toFun‚ü©

instance {Œπ : Type u} (v : Œπ ‚Üí Type v) [O : ‚àÄ i, OracleInterface (v i)]
    [h : ‚àÄ i, DecidableEq (Query (v i))]
    [h' : ‚àÄ i, DecidableEq (Response (v i))] :
    [v]‚Çí.DecidableEq where
  domain_decidableEq' := h
  range_decidableEq' := h'

Id.run in Init.Control.Id

Units.mk0 in Mathlib.Algebra.GroupWithZero.Units.Basic

@[app_unexpander Fin.fcons]
def fconsUnexpander : Lean.PrettyPrinter.Unexpander
  | `($_ $a !h‚¶É$F‚¶Ñ‚ü®$Œ±‚ü©[$b, $bs,*]) => `(!h‚¶É$F‚¶Ñ‚ü®$Œ±‚ü©[$a, $b, $bs,*])
  | `($_ $a !h‚¶É$F‚¶Ñ‚ü®$Œ±‚ü©[$b]) => `(!h‚¶É$F‚¶Ñ‚ü®$Œ±‚ü©[$a, $b])
  | `($_ $a !h‚¶É$F‚¶Ñ‚ü®$Œ±‚ü©[]) => `(!h‚¶É$F‚¶Ñ‚ü®$Œ±‚ü©[$a])
  | _ => throw ()

def toVerifierState (ds : DomainSeparator U H) (transcript : ByteArray) : FSVerifierState U H :=
  FSVerifierState.new ds transcript

def foldStepRelOut (i : Fin ‚Ñì) :
    Set ((Statement (L := L) Context i.succ √ó
      (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j)) √ó
      Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ) :=
  { input | foldStepRelOutProp (mp := mp) (ùìë := ùìë) ùîΩq Œ≤ i input}

Std.Format in Init.Data.Format.Basic

@[ext]
class OracleInterface (Message : Type u) where
  Query : Type v
  Response : Type w
  answer : Message ‚Üí Query ‚Üí Response

def SkeletonLeafIndex.depth {s : Skeleton} : SkeletonLeafIndex s ‚Üí Nat
  | SkeletonLeafIndex.ofLeaf => 0
  | SkeletonLeafIndex.ofLeft idxLeft => idxLeft.depth + 1
  | SkeletonLeafIndex.ofRight idxRight => idxRight.depth + 1

NatCast in Init.Data.Cast

noncomputable def linearEquivMvPolynomialDeg1 : MlPoly R n ‚âÉ‚Çó[R] R‚¶É‚â§ 1‚¶Ñ[X Fin n] :=
  { toEquiv := equivMvPolynomialDeg1
    map_add' := by admit /- proof elided -/

instance : Unique (Transcript 0 pSpec) where
  default := fun i => Fin.elim0 i
  uniq := fun T => by admit /- proof elided -/

noncomputable def modBivar (P P' : MvPolynomial (Fin 2) F)
    (hlg : IsUnit ((MonomialOrder.lex).leadingCoeff P')) : MvPolynomial (Fin 2) F :=
      
      let ord : MonomialOrder (Fin 2) := MonomialOrder.lex
      
      let b : Unit ‚Üí MvPolynomial (Fin 2) F := fun _ => P'
      
      have hb : ‚àÄ i : Unit, IsUnit (ord.leadingCoeff (b i)) := by admit /- proof elided -/

List.Vector.get in Mathlib.Data.Vector.Defs

noncomputable def commitRbrExtractor (i : Fin ‚Ñì) :
  Extractor.RoundByRound []‚Çí
    (StmtIn := (Statement (L := L) Context i.succ) √ó (‚àÄ j, OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc j))
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (pSpec := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)
    (WitMid := fun _messageIdx => Witness (L := L) ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ) where
  eqIn := rfl
  extractMid := fun _ _ _ witMidSucc => witMidSucc
  extractOut := fun _ _ witOut => witOut

def fappend {A : Sort u} {F : A ‚Üí Sort v} {m n : ‚Ñï} {Œ± : Fin m ‚Üí A} {Œ≤ : Fin n ‚Üí A}
    (u : (i : Fin m) ‚Üí F (Œ± i)) (v : (i : Fin n) ‚Üí F (Œ≤ i)) :
    (i : Fin (m + n)) ‚Üí F (Fin.vappend Œ± Œ≤ i) :=
  match n with
  | 0 => u
  | k + 1 => fconcat (fappend u (fun i => v (Fin.castSucc i))) (v (Fin.last k))

ToString in Init.Data.ToString.Basic

instance instOI‚ÇÅ : ‚àÄ i, OracleInterface ((‚ü®!v[.P_to_V], !v[R‚¶É‚â§ deg‚¶Ñ[X]]‚ü© ++‚Çö !p[]).Message i) :=
  instOracleInterfaceMessageAppend

noncomputable def queryOracleReduction :
  OracleReduction
    (oSpec := []‚Çí)
    (StmtIn := FinalSumcheckStatementOut (L:=L) (‚Ñì:=‚Ñì))
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (
    Fin.last ‚Ñì))
    (WitIn := Unit)
    (StmtOut := Bool)
    (OStmtOut := fun _ : Empty => Unit)
    (WitOut := Unit)
    (pSpec := pSpecQuery ùîΩq Œ≤ Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)) where
  prover := queryOracleProver ùîΩq Œ≤ (œë:=œë) Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
  verifier := queryOracleVerifier ùîΩq Œ≤ (œë:=œë) Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)

ZMod in Mathlib.Data.ZMod.Defs

def Option.doubleBind {Œ± Œ≤ Œ≥ : Type} (f : Œ± ‚Üí Œ≤ ‚Üí Option Œ≥)
    (x : Option Œ±) (y : Option Œ≤) : Option Œ≥ :=
  match x, y with
  | none, _ => none
  | _, none => none
  | some a, some b => f a b

def code (deg : ‚Ñï) [Semiring F]: Submodule F (Œπ ‚Üí F) :=
  (Polynomial.degreeLT F deg).map (evalOnPoints domain)

noncomputable def relayOracleVerifier (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
  OracleVerifier
    (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) Context i.succ)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (pSpec := pSpecRelay) where
  verify := fun stmtIn _ => pure stmtIn
  embed := ‚ü®fun j => by admit /- proof elided -/
  ‚ü©
  hEq := fun oracleIdx => by admit /- proof elided -/

instance {s} : Functor (fun Œ± => LeafData Œ± s) where
  map f x := x.map f

  inductive UnverifiedPrattPart : Type
    | prime : (p : ‚Ñï) ‚Üí (k : ‚Ñï) ‚Üí (hp : UnverifiedPrattCertificate p) ‚Üí UnverifiedPrattPart
    | split : UnverifiedPrattPart ‚Üí UnverifiedPrattPart ‚Üí UnverifiedPrattPart
  deriving Repr

def getRoot {n : ‚Ñï} (cache : Cache Œ± n) : Œ± :=
  (cache 0).get ‚ü®0, by admit /- proof elided -/
  ‚ü©

def zeroCheckVirtualPolynomial (ùï© : Statement.AfterFirstMessage R pp)
    
    (oStmt : ‚àÄ i, OracleStatement.AfterFirstMessage R pp i) :
      MvPolynomial (Fin pp.‚Ñì_m) R :=
  letI ùï´ := R1CS.ùï´ ùï© (oStmt (.inr 0))
  ‚àë x : Fin (2 ^ pp.‚Ñì_m),
    (eqPolynomial (finFunctionFinEquiv.symm x : Fin pp.‚Ñì_m ‚Üí R)) *
      C ((oStmt (.inl .A) *·µ• ùï´) x * (oStmt (.inl .B) *·µ• ùï´) x - (oStmt (.inl .C) *·µ• ùï´) x)

Functor in Init.Prelude

def bivPolyHom {F : Type} [CommRing F] [IsDomain F] :
  Polynomial (F[X]) ‚Üí+* Polynomial (RatFunc F) := Polynomial.mapRingHom (univPolyHom)

def rootsOfUnity (n s : ‚Ñï) : List (Domain.evalDomain D (n - s)) :=
  List.map
    (fun i =>
      ‚ü®
        (DIsCyclicC.gen.1 ^ (2 ^ (n - s))) ^ i,
        by admit /- proof elided -/
      ‚ü©
    )
    (List.range (2 ^ s))

instance {Œ± : Type} {s : Skeleton} :
    CoeFun (LeafData Œ± s) fun (_ : LeafData Œ± s) => SkeletonLeafIndex s ‚Üí Œ± where
  coe := fun tree idx => tree.get idx

Set.Pairwise in Mathlib.Logic.Pairwise

Array.foldl in Init.Data.Array.Basic

Prod.fst in Init.Prelude

@[simp]
instance BTFieldIsDomain (k : ‚Ñï) : IsDomain (BTField k) := inferInstance

@[reducible, simp] def OStmtOut := fun _ : Fin 2 => OStatement

instance [VerifierFirst pSpec] : Unique (pSpec.ChallengeIdx) where
  default := ‚ü®0, by admit /- proof elided -/
  ‚ü©
  uniq := fun ‚ü®i, _‚ü© => by admit /- proof elided -/

def externalLinearLayer (state : Vector KoalaBear.Field params.width) :
    Vector KoalaBear.Field params.width :=
  
  let chunks := Vector.Matrix.ofFlatten (state.cast (params.widthDiv4_mul_4_eq_width).symm)
  let chunksAfterM4 := chunks.map (fun chunk => applyM4 chunk)

  
  

  
  let transposedMatrix := Vector.Matrix.transpose chunksAfterM4

  
  let columnSums := transposedMatrix.map (fun col => col.foldl (¬∑ + ¬∑) 0)

  
  let chunksAfterDiffusion := chunksAfterM4.map (fun row => row.zipWith (¬∑ + ¬∑) columnSums)

  
  (Vector.flatten chunksAfterDiffusion).cast (params.widthDiv4_mul_4_eq_width)

instance {Œ± : Type*} {n : ‚Ñï} [VCVCompatible Œ±] : VCVCompatible (Vector Œ± n) where

@[reducible, simp] def OStmtIn := fun _ : Fin 2 => OStatement

def SkeletonNodeIndex.path {s : Skeleton} (idx : SkeletonNodeIndex s) :
    List (SkeletonNodeIndex s) := sorry

OracleComp.liftComp in VCVio.OracleComp.Coercions.SubSpec

noncomputable def R
  (Œ¥ : ‚Ñö) (x‚ÇÄ : F)
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  : F[Z][X][Y] := (exists_factors_with_large_common_root_set k Œ¥ x‚ÇÄ h_gs).choose

instance (s : Finset œÉ) : Fintype { x : œÉ | x ‚àà s } :=

def acceptRejectOracleRel : Set ((Bool √ó (‚àÄ _ : Empty, Unit)) √ó Unit) :=
  { ((true, isEmptyElim), ()) }

noncomputable def finalFoldProver :
  OracleProver []‚Çí
    (Statement F (Fin.last k)) (OracleStatement D x s (Fin.last k))
      (Witness F s d (Fin.last k).castSucc)
    (FinalStatement F k) (FinalOracleStatement D x s)
      (Witness F s d (Fin.last (k + 1)))
    (pSpec F) where
  PrvState
  | 0 =>
    (Statement F (Fin.last k) √ó ((j : Fin (k + 1)) ‚Üí OracleStatement D x s (Fin.last k) j)) √ó
      Witness F s d (Fin.last k).castSucc
  | _ =>
    (FinalStatement F k √ó ((j : Fin (k + 1)) ‚Üí OracleStatement D x s (Fin.last k) j)) √ó
      Witness F s d (Fin.last (k + 1))

  input := id

  sendMessage
  | ‚ü®0, h‚ü© => nomatch h
  | ‚ü®1, _‚ü© => fun ‚ü®‚ü®chals, o‚ü©, p‚ü© =>
    pure ‚ü®fun x => p.1, ‚ü®‚ü®chals, o‚ü©, p‚ü©‚ü©

  receiveChallenge
  | ‚ü®0, _‚ü© => fun ‚ü®‚ü®chals, o‚ü©, p‚ü© => pure <|
    fun (Œ± : F) =>
      ‚ü®
        ‚ü®Fin.vappend chals !v[Œ±], o‚ü©,
        ‚ü®
          p.1.foldNth (2 ^ (s (Fin.last k)).1) Œ±,
          by admit /- proof elided -/
        ‚ü©
      ‚ü©
  | ‚ü®1, h‚ü© => nomatch h

  output := fun ‚ü®‚ü®chals, o‚ü©, p‚ü© => pure <|
    ‚ü®
      ‚ü®
        chals,
        fun j => by admit /- proof elided -/
      ‚ü©,
      p
    ‚ü©

Nat.all in Init.Data.Nat.Fold

def Transcript.extractSalt {k : Fin (n + 1)} (transcript : (pSpec.addSalt Salt).Transcript k) :
    (i : pSpec.MessageIdxUpTo k) ‚Üí Salt ‚ü®i.val.castLE (by admit /- proof elided -/
    ), by admit /- proof elided -/
    ‚ü© :=
  fun i => by admit /- proof elided -/

@[inline]
abbrev concat {m : Fin n} (msg : pSpec.¬´Type¬ª m) (T : Transcript m.castSucc pSpec) :
    Transcript m.succ pSpec :=
  Fin.snoc T msg

UInt32 in Init.Prelude

@[simp]
def outerRelIn_Test : Set (OuterStmtIn_Test √ó Unit) :=
  setOf (fun ‚ü®‚ü®p, q, t‚ü©, _‚ü© => ‚àë x ‚àà {0, 1}, (p * q).eval x = t)

@[simp]
def AlgebraTower.toAlgebra {i j : Œπ} (h : i ‚â§ j) : Algebra (A i) (A j) :=
  (AlgebraTower.algebraMap (i:=i) (j:=j) (h:=h)).toAlgebra

IO.eprintln in Init.System.IO

def matrixSubmoduleOfLinearCode (Œ∫ : Type*) [Fintype Œ∫]
                                (LC : LinearCode Œπ F) : MatrixSubmodule Œ∫ Œπ F :=
  Submodule.span F { V | ‚àÄ i, V i ‚àà LC }

def oracleVerifier (i : Fin n) : OracleVerifier oSpec (StatementRound R n i.castSucc)
    (OracleStatement R n deg) (StatementRound R n i.succ) (OracleStatement R n deg) (pSpec R deg) :=
  (Simple.oracleVerifier R deg D oSpec).liftContext (oStmtLens R n deg D i)

def perfectCompleteness
    (relIn : Set ((StmtIn √ó ‚àÄ i, OStmtIn i) √ó WitIn))
    (relOut : Set ((StmtOut √ó ‚àÄ i, OStmtOut i) √ó WitOut))
    (oracleReduction : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec) :
      Prop :=
  Reduction.perfectCompleteness init impl relIn relOut oracleReduction.toReduction

MvPolynomial.eval in Mathlib.Algebra.MvPolynomial.Eval

DecidablePred in Init.Prelude

instance instDCast‚ÇÇSigma {Œ± : Type*} {Œ≤ : Œ± ‚Üí Type*} {Œ≥ : (a : Œ±) ‚Üí Œ≤ a ‚Üí Type*}
    {Œ¥ : (a : Œ±) ‚Üí (b : Œ≤ a) ‚Üí Œ≥ a b ‚Üí Type*}
    [DCast Œ± Œ≤] [DCast‚ÇÇ Œ± Œ≤ Œ≥] [DCast‚ÇÉ Œ± Œ≤ Œ≥ Œ¥] :
    DCast‚ÇÇ ((a : Œ±) √ó Œ≤ a) (fun a => Œ≥ a.1 a.2) (fun a => Œ¥ a.1 a.2) where
  dcast‚ÇÇ ha hb c := dcast‚ÇÉ (by admit /- proof elided -/
  ) (by admit /- proof elided -/
  ) (by admit /- proof elided -/
  ) c
  dcast‚ÇÇ_id := by admit /- proof elided -/

def relHammingDistRange (Œπ : Type*) [Fintype Œπ] : Set ‚Ñö‚â•0 :=
  {d : ‚Ñö‚â•0 | ‚àÉ d' : ‚Ñï, d' ‚â§ Fintype.card Œπ ‚àß d = d' / Fintype.card Œπ}

noncomputable def polynomialFromNovelCoeffs (‚Ñì : ‚Ñï) (h_‚Ñì : ‚Ñì ‚â§ r)
  (a : Fin (2 ^ ‚Ñì) ‚Üí L) : L[X] := ‚àë j, C (a j) * (X‚±º ùîΩq Œ≤ ‚Ñì h_‚Ñì j)

abbrev contract (m : ‚Ñï) (f : Fin n ‚Üí Œ±) := liftF (liftF' (n := m) (liftF f))

@[reducible, simp]
def pSpec : ProtocolSpec 1 := ‚ü®!v[.P_to_V], !v[Witness]‚ü©

LinearMap.codRestrict in Mathlib.Algebra.Module.Submodule.LinearMap

Mathlib.Linter.TextBased.ErrorFormat in Mathlib.Tactic.Linter.TextBased

noncomputable def monomialToNovelCoeffs

  (‚Ñì : ‚Ñï) (h_‚Ñì : ‚Ñì ‚â§ r) (monomial_coeffs : Fin (2 ^ ‚Ñì) ‚Üí L) : Fin (2^‚Ñì) ‚Üí L :=
  let A := changeOfBasisMatrix ùîΩq Œ≤ ‚Ñì h_‚Ñì
  
  
  Matrix.vecMul monomial_coeffs A‚Åª¬π

instance : Field BaseField := ZMod.instField baseFieldSize

@[simp]
def finRangeTo {k : ‚Ñï} (i : ‚Ñï) : Finset (Fin k) :=
  (List.take i (List.finRange k)).toFinset

def domainEmb {i : ‚Ñï} : evalDomain D i ‚Ü™ F :=
  ‚ü®
    fun x => x.1.1,
    by admit /- proof elided -/
  ‚ü©

noncomputable def intermediateNovelBasisX (i : Fin (‚Ñì + 1)) (j : Fin (2 ^ (‚Ñì - i))) : L[X] :=
  (Finset.univ: Finset (Fin (‚Ñì - i)) ).prod (fun k =>
    (intermediateNormVpoly ùîΩq Œ≤ h_‚Ñì_add_R_rate i (k:=‚ü®k, by admit /- proof elided -/
    ‚ü©)) ^ (Nat.getBit k j))

def quotient (f g : F[X][Y]) : Prop := ‚àÉ q : F[X][Y], g = q * f

@[reducible, simp]
def knowledgeSoundness (relation : Set (Statement √ó Bool))
    (verifier : Verifier oSpec Statement Bool pSpec)
    (knowledgeError : ‚Ñù‚â•0) : Prop :=
  verifier.knowledgeSoundness init impl relation acceptRejectRel knowledgeError

instance {k : Fin 1} : Unique (Transcript k !p[]) where
  default := fun ‚ü®i, h‚ü© => by admit /- proof elided -/

@[reducible]
def OracleStatement (Œπ F : Type) : Unit ‚Üí Type :=
    fun _ => Œπ ‚Üí F

def ar2 (k0 k1 : ‚Ñï) : Fin 2 ‚Üí ‚Ñï
  | ‚ü®0, _‚ü© => k0
  | ‚ü®1, _‚ü© => k1

def modByMonic [Field R] (p : UniPoly R) (q : UniPoly R) :
    UniPoly R :=
  (divModByMonicAux p q).2

def proximityMeasure (u v : n ‚Üí F) (d : ‚Ñï) : ‚Ñï :=
  Fintype.card {r : F | Œî‚ÇÄ'(r ‚Ä¢ u + (1 - r) ‚Ä¢ v, C) ‚â§ d}

noncomputable def ElocPolyF (œâs f : Fin n ‚Üí F) (p : Polynomial F) : Polynomial F :=
  ElocPoly n (liftF œâs) (liftF f) p

abbrev SEP_CHAR : Char := Char.ofNat 0

def foldKStateProp {i : Fin ‚Ñì} (m : Fin (2 + 1))
    (tr : Transcript m (pSpecFold (L := L))) (stmt : Statement (L := L) Context i.castSucc)
    (witMid : Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j) :
    Prop :=
  
  let h_star : ‚Ü•L‚¶É‚â§ 2‚¶Ñ[X] := getSumcheckRoundPoly ‚Ñì ùìë (i := i) (h := witMid.H)
  
  let get_H·µ¢ := fun (m: Fin (2 + 1)) (tr: Transcript m pSpecFold) (hm: 1 ‚â§ m.val) =>
    let ‚ü®msgsUpTo, _‚ü© := Transcript.equivMessagesChallenges (k := m)
      (pSpec := pSpecFold (L := L)) tr
    let i_msg1 : ((pSpecFold (L := L)).take m m.is_le).MessageIdx :=
      ‚ü®‚ü®0, Nat.lt_of_succ_le hm‚ü©, by admit /- proof elided -/
      ‚ü©
    let h_i : L‚¶É‚â§ 2‚¶Ñ[X] := msgsUpTo i_msg1
    h_i

  let get_r·µ¢' := fun (m: Fin (2 + 1)) (tr: Transcript m pSpecFold) (hm: 2 ‚â§ m.val) =>
    let ‚ü®msgsUpTo, chalsUpTo‚ü© := Transcript.equivMessagesChallenges (k := m)
      (pSpec := pSpecFold (L := L)) tr
    let i_msg1 : ((pSpecFold (L := L)).take m m.is_le).MessageIdx :=
      ‚ü®‚ü®0, Nat.lt_of_succ_le (Nat.le_trans (by admit /- proof elided -/
      ) hm)‚ü©, by admit /- proof elided -/
      ‚ü©
    let h_i : L‚¶É‚â§ 2‚¶Ñ[X] := msgsUpTo i_msg1
    let i_msg2 : ((pSpecFold (L := L)).take m m.is_le).ChallengeIdx :=
      ‚ü®‚ü®1, Nat.lt_of_succ_le hm‚ü©, by admit /- proof elided -/
      ‚ü©
    let r_i' : L := chalsUpTo i_msg2
    r_i'

  match m with
  | ‚ü®0, _‚ü© => 
    masterKStateProp (mp := mp) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (stmtIdx := i.castSucc) (oracleIdx := i.castSucc)
      (h_le := le_refl _)
      (stmt := stmt) (wit := witMid) (oStmt := oStmt)
      (localChecks := True)
  | ‚ü®1, h1‚ü© => 
    masterKStateProp (mp := mp) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (stmtIdx := i.castSucc) (oracleIdx := i.castSucc)
      (h_le := le_refl _)
      (stmt := stmt) (wit := witMid) (oStmt := oStmt)
      (localChecks :=
        let h_i := get_H·µ¢ (m := ‚ü®1, h1‚ü©) (tr := tr) (hm := by admit /- proof elided -/
        )
        let explicitVCheck := h_i.val.eval 0 + h_i.val.eval 1 = stmt.sumcheck_target
        let localizedRoundPolyCheck := h_i = h_star
        explicitVCheck ‚àß localizedRoundPolyCheck
      )
  | ‚ü®2, h2‚ü© => 
    
    masterKStateProp (mp := mp) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (stmtIdx := i.castSucc) (oracleIdx := i.castSucc)
      (h_le := le_refl _)
      (stmt := stmt) (wit := witMid) (oStmt := oStmt)
      (localChecks :=
        let h_i := get_H·µ¢ (m := ‚ü®2, h2‚ü©) (tr := tr) (hm := by admit /- proof elided -/
        )
        let r_i' := get_r·µ¢' (m := ‚ü®2, h2‚ü©) (tr := tr) (hm := by admit /- proof elided -/
        )
        let localizedRoundPolyCheck := h_i = h_star
        let nextSumcheckTargetCheck := 
          h_i.val.eval r_i' = h_star.val.eval r_i'
        localizedRoundPolyCheck ‚àß nextSumcheckTargetCheck
      ) 

def FullData.Equiv {Œ±} (s : Skeleton) :
    FullData Œ± s ‚âÉ InternalData Œ± s √ó LeafData Œ± s :=

class Serialize (Œ± : Type u) (Œ≤ : Type v) where
  serialize : Œ± ‚Üí Œ≤

instance instInvConcreteBTF {k : ‚Ñï} : Inv (ConcreteBTField k) where
  inv := concrete_inv

Nat.max in Init.Data.Nat.Basic

def toList (xs : ChurchVec Œ±) : List Œ± :=
  churchVecFold xs (fun x acc => x :: acc) []

CommGroup in Mathlib.Algebra.Group.Defs

Or in Init.Prelude

def distFromCode' (C : Set (n ‚Üí R)) [Fintype C] (u : n ‚Üí R) : ‚Ñï‚àû :=
  Finset.min <| (@Finset.univ C _).image (fun v => hammingDist u v.1)

@[inline]
def smul [Mul R] (r : R) (p : MlPolyEval R n) : MlPolyEval R n := p.map (fun a => r * a)

def dfoldr' (n : ‚Ñï) (Œ± : Fin (n + 1) ‚Üí Type u)
    (f : (i : Fin n) ‚Üí Œ± i.succ ‚Üí Œ± i.castSucc) (init : Œ± (last n)) : Œ± 0 :=
  dfoldrM' (m := Id) n Œ± f init

def range (n : ‚Ñï) : Fin n ‚Üí ‚Ñï := fun i => i

Finsupp.cons in Mathlib.Data.Finsupp.Fin

def generateProof {s} (cache_tree : FullData Œ± s) :
    BinaryTree.SkeletonLeafIndex s ‚Üí List Œ±
  | .ofLeaf => []
  | .ofLeft idxLeft =>
    (cache_tree.rightSubtree).getRootValue ::
      (generateProof cache_tree.leftSubtree idxLeft)
  | .ofRight idxRight =>
    (cache_tree.leftSubtree).getRootValue ::
      (generateProof cache_tree.rightSubtree idxRight)

def baseFoldMatrix (i : Fin r) (h_i : i + 1 < ‚Ñì + ùì°)
    (y : ‚Ü•(sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®‚Üëi + 1, by admit /- proof elided -/
    ‚ü©)) : Matrix (Fin 2) (Fin 2) L :=
  let fiberMap := qMap_total_fiber ùîΩq Œ≤ (i := i) (steps := 1)
      (h_i_add_steps := h_i) (y := y)
  let x‚ÇÄ := fiberMap 0
  let x‚ÇÅ := fiberMap 1
  fun i j => match i, j with
  | 0, 0 => x‚ÇÅ
  | 0, 1 => -x‚ÇÄ
  | 1, 0 => -1
  | 1, 1 => 1

instance : ‚àÄ j, SelectableType ((fullPSpec ùîΩq Œ≤ Œ≥_repetitions (œë:=œë)
  (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).Challenge j) := instSelectableTypeChallengeAppend

instance {bIdx : Fin (‚Ñì / œë - 1)} : ‚àÄ j, OracleInterface ((pSpecFullNonLastBlock ùîΩq Œ≤
  (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) bIdx).Message j) :=
  instOracleInterfaceMessageAppend

@[inline, reducible]
def lift : OuterStmtIn √ó OuterWitOut ‚Üí InnerWitIn ‚Üí OuterWitIn :=
  lens.toFunB

structure GaloisAutomorphism (F : Type*) [Field F] (u : F) (k : ‚Ñï) : Prop where
  forward : u ^ (2 ^ (2 ^ k)) = u‚Åª¬π
  reverse : (u‚Åª¬π) ^ (2 ^ (2 ^ k)) = u

MulOneClass in Mathlib.Algebra.Group.Defs

def SkeletonNodeIndex.leftChild {s : Skeleton} (idx : SkeletonNodeIndex s) :
    Option (SkeletonNodeIndex s) :=
  match idx with
  | SkeletonNodeIndex.ofLeaf => none
  | @SkeletonNodeIndex.ofInternal left right =>
    some (SkeletonNodeIndex.ofLeft (getRootIndex left))
  | SkeletonNodeIndex.ofLeft idxLeft =>
    idxLeft.leftChild.map (SkeletonNodeIndex.ofLeft)
  | SkeletonNodeIndex.ofRight idxRight =>
    idxRight.leftChild.map (SkeletonNodeIndex.ofRight)

instance instSetoidUniPoly : Setoid (UniPoly R) where
  r := equiv
  iseqv := instEquivalenceEquiv

Matrix.submatrix in Mathlib.LinearAlgebra.Matrix.Defs

Finset.sum in Mathlib.Algebra.BigOperators.Group.Finset.Defs

private def Fi (B : Finset (Fin n ‚Üí F)) (i : Fin n) (Œ± : F) : Finset (Fin n ‚Üí F) :=
  { x | x ‚àà B ‚àß x i = Œ± }

@[reducible]
def VectorIOP
    (Statement : Type) {Œπ‚Çõ : Type} (OStatement : Œπ‚Çõ ‚Üí Type) (Witness : Type)
    (vPSpec : ProtocolSpec.VectorSpec n) (A : Type)
    [‚àÄ i, OracleInterface (OStatement i)] :=
  OracleProof []‚Çí Statement OStatement Witness (vPSpec.toProtocolSpec A)

@[inline, specialize]
def add (p q : UniPoly R) : UniPoly R :=
  add_raw p q |> trim

def AlgebraTowerEquiv.toAlgEquivOverRight (e : AlgebraTowerEquiv A B) (i j : Œπ) (h : i ‚â§ j) :
  letI : Algebra (B i) (B j) :=

instance : ‚àÄ i, OracleInterface ((pSpecCoreInteraction ùîΩq Œ≤ (œë:=œë)
  (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).Message i) := instOracleInterfaceMessageAppend

Set in Mathlib.Data.Set.Defs

instance [DecidableEq Œπ] : Memory Œπ Œ± (‚àÄ i, Œ± i) where
  read m i := m i
  write m i v := Function.update m i v

@[reducible]
def oracleReduction : OracleReduction oSpec
    (StatementRound R n 0) (OracleStatement R n deg) Unit
    (StatementRound R n (.last n)) (OracleStatement R n deg) Unit
    (pSpec R deg n) :=
  OracleReduction.seqCompose (oSpec := oSpec)
    (Stmt := StatementRound R n)
    (OStmt := fun _ => OracleStatement R n deg)
    (Wit := fun _ => Unit)
    (pSpec := fun _ => SingleRound.pSpec R deg)
    (SingleRound.oracleReduction R n deg D oSpec)

def evalX (a : F) (f : F[X][Y]) : Polynomial F :=
  ‚ü®Finsupp.mapRange (Polynomial.eval a) eval_zero f.toFinsupp‚ü©

Fintype.card in Mathlib.Data.Fintype.Card

@[inline] def zero : Cayley T :=
  ‚ü®id, by admit /- proof elided -/
  ‚ü©

def codeOfLinearCode (Œ∫ : Type*) [Fintype Œ∫] (LC : LinearCode Œπ F) : InterleavedCode Œ∫ Œπ F :=
  { MF := matrixSubmoduleOfLinearCode Œ∫ LC, LC := LC }

def SkeletonInternalIndex.toNodeIndex {s : Skeleton} (idx : SkeletonInternalIndex s) :
    SkeletonNodeIndex s :=
  match idx with
  | SkeletonInternalIndex.ofInternal => SkeletonNodeIndex.ofInternal
  | SkeletonInternalIndex.ofLeft idxLeft =>
    SkeletonNodeIndex.ofLeft (SkeletonInternalIndex.toNodeIndex idxLeft)
  | SkeletonInternalIndex.ofRight idxRight =>
    SkeletonNodeIndex.ofRight (SkeletonInternalIndex.toNodeIndex idxRight)

Context in Examples.FrankingProtocol

def verifySmallPrime (n' : Q(‚Ñï)) : MetaM Q(Nat.Prime $n') :=
  match n'.natLit! with
    | 2 => do haveI : $n' =Q 2 := ‚ü®‚ü©; return q(prime_2)
    | 3 => do haveI : $n' =Q 3 := ‚ü®‚ü©; return q(prime_3)
    | 5 => do haveI : $n' =Q 5 := ‚ü®‚ü©; return q(prime_5)
    | 7 => do haveI : $n' =Q 7 := ‚ü®‚ü©; return q(prime_7)
    | 11 => do haveI : $n' =Q 11 := ‚ü®‚ü©; return q(prime_11)
    | 13 => do haveI : $n' =Q 13 := ‚ü®‚ü©; return q(prime_13)
    | 17 => do haveI : $n' =Q 17 := ‚ü®‚ü©; return q(prime_17)
    | 19 => do haveI : $n' =Q 19 := ‚ü®‚ü©; return q(prime_19)
    | 23 => do haveI : $n' =Q 23 := ‚ü®‚ü©; return q(prime_23)
    | 29 => do haveI : $n' =Q 29 := ‚ü®‚ü©; return q(prime_29)
    | 31 => do haveI : $n' =Q 31 := ‚ü®‚ü©; return q(prime_31)
    | 37 => do haveI : $n' =Q 37 := ‚ü®‚ü©; return q(prime_37)
    | 41 => do haveI : $n' =Q 41 := ‚ü®‚ü©; return q(prime_41)
    | 43 => do haveI : $n' =Q 43 := ‚ü®‚ü©; return q(prime_43)
    | 47 => do haveI : $n' =Q 47 := ‚ü®‚ü©; return q(prime_47)
    | _ => failure

@[inline, reducible]
protected def id :
    Witness.InvLens OuterStmtIn OuterWitIn OuterWitOut OuterWitIn OuterWitOut :=
  ‚ü®Prod.snd, fun _ => id‚ü©

alias trivial := Witness.InvLens.id

def parametrisedCurveFinite [DecidableEq Œπ] [Fintype F] [DecidableEq F] [Semiring F]
  {l : ‚Ñï} (u : Fin l ‚Üí Œπ ‚Üí F) : Finset (Œπ ‚Üí F) :=
  {v | ‚àÉ r : F, v = ‚àë i : Fin l, (r ^ (i : ‚Ñï)) ‚Ä¢ u i}

@[inline]
def nsmul [SMul ‚Ñï R] (m : ‚Ñï) (p : MlPolyEval R n) : MlPolyEval R n := p.map (fun a => m ‚Ä¢ a)

instance [VCVCompatible A] : ‚àÄ i, VCVCompatible ((vPSpec.toProtocolSpec A).Challenge i) :=
  fun _ => by admit /- proof elided -/

structure TraceMapProperty (F : Type*) [Field F] (u : F) (k : ‚Ñï) : Prop where
  element_trace : ‚àë i ‚àà Finset.range (2 ^ k), u ^ (2 ^ i) = 1
  inverse_trace : ‚àë i ‚àà Finset.range (2 ^ k), (u‚Åª¬π) ^ (2 ^ i) = 1

@[simp]
def oCtxLens (i : Fin n) : OracleContext.Lens
    (StatementRound R n i.castSucc) (StatementRound R n i.succ) (Simple.StmtIn R) (Simple.StmtOut R)
    (OracleStatement R n deg) (OracleStatement R n deg)
    (Simple.OStmtIn R deg) (Simple.OStmtOut R deg)
    Unit Unit Unit Unit where
  wit := Witness.Lens.trivial
  stmt := oStmtLens R n deg D i

instance : ‚àÄ j, OracleInterface ((batchSpec F m).Message j)
  | ‚ü®0, h‚ü© => nomatch h

abbrev Fwd : PermuteDir := Sum.inl ()

def AlgebraTowerEquiv.algebraMapRightUp (e : AlgebraTowerEquiv A B) (i j : Œπ)
    (h : i ‚â§ j) : (A i) ‚Üí+* (B j) :=

def MlPoly.mk {R : Type*} (n : ‚Ñï) (v : Vector R (2 ^ n)) : MlPoly R n := v

instance instZero {n : ‚Ñï} : Zero (CNat n) := match n with
  | 0 => by admit /- proof elided -/
  | .succ n => by admit /- proof elided -/

def map {Œ± Œ≤ : Fin n ‚Üí Sort*} (f : (i : Fin n) ‚Üí Œ± i ‚Üí Œ≤ i) (a : (i : Fin n) ‚Üí Œ± i) :
    (i : Fin n) ‚Üí Œ≤ i := fun i => f i (a i)

instance : curve.IsElliptic :=

@[inline]
def ofArray [Zero R] (coeffs : Array R) (n : ‚Ñï) : MlPolyEval R n :=
  .ofFn (fun i => if h : i.1 < coeffs.size then coeffs[i] else 0)

private def Bi (B : Finset (Fin n ‚Üí F)) (i : Fin n) : Finset ((Fin n ‚Üí F) √ó (Fin n ‚Üí F)) :=
  { x | x ‚àà B √óÀ¢ B ‚àß x.1 i = x.2 i ‚àß x.1 ‚â† x.2 }

noncomputable def listDecodingCollisionProbability
  (œÜ : Œπ ‚Ü™ F) (f : Œπ ‚Üí F) (Œ¥ : ‚Ñù) (s degree : ‚Ñï)
  (h_nonempty : Nonempty (domainComplement œÜ)) : ENNReal :=
  Pr_{let r ‚Üê$·µñ (Fin s ‚Üí domainComplement œÜ)}[ ‚àÉ (u u' : code œÜ degree),
                                    u.val ‚â† u'.val ‚àß
                                    u.val ‚àà relHammingBall (code œÜ degree) f Œ¥ ‚àß
                                    u'.val ‚àà relHammingBall (code œÜ degree) f Œ¥ ‚àß
                                    ‚àÄ i : Fin s,
                                    let uPoly := decodeLT u
                                    let uPoly' := decodeLT u'
                                    (uPoly : F[X]).eval (r i).1
                                      = (uPoly' : F[X]).eval (r i).1
                                    ]

def init (s : Fin (n + 1) ‚Üí‚ÇÄ M) : Fin n ‚Üí‚ÇÄ M :=
  Finsupp.equivFunOnFinite.symm (Fin.init s)

Fin.succAboveEmb in Mathlib.Data.Fin.Embedding

@[inline]
def smul [Mul R] (r : R) (p : MlPoly R n) : MlPoly R n := p.map (fun a => r * a)

noncomputable def S_Œ≤ {H : F[X][Y]} (Œ≤ : ùí™ H) : Set F :=
  {z : F | ‚àÉ root : rationalRoot (H_tilde' H) z, (œÄ_z z root) Œ≤ = 0}

def bool (j : Fin numWires) : Gate ùì° numWires :=
  { qL := -1, qR := 0, qO := 0, qM := 1, qC := 0, a := j, b := j, c := j }

@[inline, reducible]
def proj : OuterStmtIn √ó OuterWitOut ‚Üí InnerWitOut :=
  lens.toFunA

noncomputable def sDomain (i : Fin r) : Subspace ùîΩq L :=
  let W_i_norm := normalizedW ùîΩq Œ≤ i
  let h_W_i_norm_is_additive : IsLinearMap ùîΩq (fun x : L => W_i_norm.eval x) :=
    AdditiveNTT.normalizedW_is_additive ùîΩq Œ≤ i
  Submodule.map (polyEvalLinearMap W_i_norm h_W_i_norm_is_additive)
    (U ùîΩq Œ≤ ‚ü®‚Ñì + R_rate, h_‚Ñì_add_R_rate‚ü©)

def mapOStmtOutRelayStep (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j) :
    ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.succ j := fun j => by admit /- proof elided -/

@[reducible, inline]
instance instPolynomialDegreeLT : OracleInterface (R‚¶É< d‚¶Ñ[X]) where
  Query := R
  Response := R
  answer := fun ‚ü®poly, _‚ü© point => poly.eval point

Monoid.toMulAction in Mathlib.Algebra.Group.Action.Defs

def DVec {m : Type v} (Œ± : m ‚Üí Type u) : Type (max u v) := ‚àÄ i, Œ± i

def processMemoryOps (ops : List (MemoryOp Œπ Œ±)) (startMem : M) : Option M :=
  ops.foldlM (fun m op =>
    match op with
    | .read ‚ü®i, v‚ü© => if Memory.read m i = v then some m else none
    | .write ‚ü®i, v‚ü© => some (Memory.write m i v)
  ) startMem

def Reduction.append (R‚ÇÅ : Reduction oSpec Stmt‚ÇÅ Wit‚ÇÅ Stmt‚ÇÇ Wit‚ÇÇ pSpec‚ÇÅ)
    (R‚ÇÇ : Reduction oSpec Stmt‚ÇÇ Wit‚ÇÇ Stmt‚ÇÉ Wit‚ÇÉ pSpec‚ÇÇ) :
      Reduction oSpec Stmt‚ÇÅ Wit‚ÇÅ Stmt‚ÇÉ Wit‚ÇÉ (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ) where
  prover := Prover.append R‚ÇÅ.prover R‚ÇÇ.prover
  verifier := Verifier.append R‚ÇÅ.verifier R‚ÇÇ.verifier

@[inline] def one : AssocNat :=
  ‚ü®Nat.succ, by admit /- proof elided -/
  ‚ü©

Nat.boddDiv2 in Mathlib.Data.Nat.Bits

class IsComplete (relIn : Set (StmtIn √ó WitIn)) (relOut : Set (StmtOut √ó WitOut))
    (reduction : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec)
    where
  completenessError : ‚Ñù‚â•0
  is_complete : completeness init impl relIn relOut reduction completenessError

@[simp]
abbrev Witness.AfterFirstMessage : Type := Unit

def extractability (scheme : Scheme oSpec Data Randomness Commitment pSpec)
    (extractabilityError : ‚Ñù‚â•0) : Prop :=
  ‚àÉ extractor : StraightlineExtractor oSpec Data Commitment,
  ‚àÄ AuxState : Type,
  ‚àÄ adversary : ExtractabilityAdversary oSpec Data Commitment AuxState,
  ‚àÄ prover : Prover oSpec (Commitment √ó O.Query √ó O.Response) AuxState Bool Unit pSpec,
    False

instance [Semiring R] : Module R (MlPolyEval R n) where
  smul := smul
  one_smul a := by admit /- proof elided -/

def mkRingInstance {k : ‚Ñï} (props : ConcreteBTFieldProps k) : Ring (ConcreteBTField k) where
  toAddCommGroup := mkAddCommGroupInstance
  toOne := inferInstance
  mul := concrete_mul
  mul_assoc := props.mul_assoc
  one_mul := props.one_mul
  mul_one := props.mul_one
  left_distrib := props.mul_left_distrib
  right_distrib := props.mul_right_distrib
  zero_mul := props.zero_mul
  mul_zero := props.mul_zero

  natCast n := natCast n
  natCast_zero := natCast_zero
  natCast_succ n := natCast_succ n
  intCast n := intCast n
  intCast_ofNat n := intCast_ofNat n
  intCast_negSucc n := intCast_negSucc n

noncomputable def J (q Œ¥ : ‚Ñö) : ‚Ñù :=
  let frac := q / (q - 1)
  (1 / frac) * (1 - Real.sqrt (1 - frac * Œ¥))

toNat in Mathlib.Computability.Reduce

@[inline] def div [Zero T] [DecidableEq T] [ToNat T]
    (dividend divisor : Cayley T) : Cayley T :=
  
  letI fuel := (‚Üëdividend : Nat) + 1
  divNat dividend divisor fuel

@[inline, reducible]
def Witness.Lens (OuterStmtIn InnerStmtOut OuterWitIn OuterWitOut InnerWitIn InnerWitOut : Type)
    := PFunctor.Lens ((OuterStmtIn √ó OuterWitIn) X^ OuterWitOut)
                     (InnerWitIn X^ (InnerStmtOut √ó InnerWitOut))

AddMonoidAlgebra in Mathlib.Algebra.MonoidAlgebra.Defs

Fin.tail in Mathlib.Data.Fin.Tuple.Basic

Sum.inl in Init.Core

@[inline] def min [Zero T] [ToNat T] (a b : Cayley T) : Cayley T :=
  if (a : Nat) ‚â§ (b : Nat) then a else b

def secondSumCheckVirtualPolynomial
    (stmt : Statement.AfterLinearCombination R pp)
    (oStmt : ‚àÄ i, OracleStatement.AfterLinearCombination R pp i) :
      MvPolynomial (Fin pp.‚Ñì_n) R := sorry

def FullData.getRootValue {s} {Œ± : Type} (tree : FullData Œ± s) :=
  tree.get (getRootIndex s)

@[inline] def add (a b : AssocNat) : AssocNat :=
  ‚ü®a ‚àò b, by admit /- proof elided -/
  ‚ü©

instance : Coe (‚àÄ a : Œ±, Œ≤ a) F where
  coe := DFunEquiv.equiv.invFun

Finsupp.linearCombination in Mathlib.LinearAlgebra.Finsupp.LinearCombination

def mkFieldInstance {k : ‚Ñï} (props : ConcreteBTFieldProps k) : Field (ConcreteBTField k) where
  toDivisionRing := mkDivisionRingInstance (k:=k) props
  mul_comm := props.mul_comm

noncomputable def towerRingHomForwardMap (k : ‚Ñï) : ConcreteBTField k ‚Üí BTField k :=

def fflatten‚ÇÇ {A : Sort u} {B : Sort v} {F : A ‚Üí B ‚Üí Sort w} {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï}
    {Œ± : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí A} {Œ≤ : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí B}
    (v : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí F (Œ± i j) (Œ≤ i j)) :
    (k : Fin (vsum n)) ‚Üí F (Fin.vflatten Œ± k) (Fin.vflatten Œ≤ k) :=
  match m with
  | 0 => !h[]
  | _ + 1 => fappend‚ÇÇ (v 0) (fflatten‚ÇÇ (fun i => v i.succ))

@[ext]
structure Cayley (T : Type u) [HasSucc T] where
   
  toFun : T ‚Üí T
   
  toFun_succ : ‚àÄ (t : T), toFun (succ' t) = succ' (toFun t)

@[simp]
abbrev Witness.AfterLinearCombination : Type := Unit

HSMul in Init.Prelude

@[app_unexpander Fin.vcons]
def vconsUnexpander : Lean.PrettyPrinter.Unexpander
  | `($_ $term !v[$term2, $terms,*]) => `(!v[$term, $term2, $terms,*])
  | `($_ $term !v[$term2]) => `(!v[$term, $term2])
  | `($_ $term !v[]) => `(!v[$term])
  | _ => throw ()

def churchOr (p q : ChurchBool Œ±) : ChurchBool Œ± :=
  fun x y => p x (q x y)

Nat.decEq in Init.Prelude

def mkDivisionRingInstance {k : ‚Ñï} (props : ConcreteBTFieldProps k)
    : DivisionRing (ConcreteBTField k) where
  toRing := mkRingInstance (k:=k) props
  inv := concrete_inv
  exists_pair_ne := concrete_exists_pair_ne (k := k)
  mul_inv_cancel := props.mul_inv_cancel
  inv_zero := concrete_inv_zero
  qsmul := (Rat.castRec ¬∑ * ¬∑)
  nnqsmul := (NNRat.castRec ¬∑ * ¬∑)

def getConst (k : ‚Ñï) (s : Fin (k + 1) ‚Üí ‚Ñï+) : OracleComp [FinalOracleStatement D x s]‚Çí F[X] :=
  OracleComp.lift
    (by admit /- proof elided -/
    )

def SkeletonNodeIndex.isLeaf {s : Skeleton} (idx : SkeletonNodeIndex s) : Bool :=
  match idx with
  | SkeletonNodeIndex.ofLeaf => true
  | SkeletonNodeIndex.ofInternal => false
  | SkeletonNodeIndex.ofLeft _ => false
  | SkeletonNodeIndex.ofRight _ => false

instance coe_field_adjoinRoot (k : ‚Ñï) : Coe (AdjoinRoot (poly k)) (BTField (k+1)) where
  coe := Eq.mp (BTField_succ_eq_adjoinRoot k)

def CEmbedding : R ‚Ü™ MvPolynomial œÉ R := ‚ü®C, C_injective œÉ R‚ü©

def FullData.ofFun {Œ± : Type} (s : Skeleton)
    (f : SkeletonNodeIndex s ‚Üí Œ±) : FullData Œ± s :=
  match s with
  | .leaf => FullData.leaf (f SkeletonNodeIndex.ofLeaf)
  | .internal l r =>
      FullData.internal
        (f SkeletonNodeIndex.ofInternal)
        (FullData.ofFun l (fun idx => f (SkeletonNodeIndex.ofLeft idx)))
        (FullData.ofFun r (fun idx => f (SkeletonNodeIndex.ofRight idx)))

@[reducible, simp]
def completeness (relation : Set (Statement √ó Witness)) (completenessError : ‚Ñù‚â•0)
    (proof : Proof oSpec Statement Witness pSpec) : Prop :=
  Reduction.completeness init impl relation acceptRejectRel proof completenessError

Fintype in Mathlib.Data.Fintype.Defs

def verifier (i : Fin n) : Verifier oSpec
    ((StatementRound R n i.castSucc) √ó (‚àÄ i, OracleStatement R n deg i))
    (StatementRound R n i.succ √ó (‚àÄ i, OracleStatement R n deg i)) (pSpec R deg) where
  verify := fun ‚ü®‚ü®target, challenges‚ü©, oStmt‚ü© transcript => do
    let ‚ü®p_i, _‚ü© : R‚¶É‚â§ deg‚¶Ñ[X] := transcript 0
    let r_i : R := transcript 1
    guard (‚àë x ‚àà (univ.map D), p_i.eval x = target)
    pure ‚ü®‚ü®p_i.eval r_i, Fin.snoc challenges r_i‚ü©, oStmt‚ü©

def OracleReduction.addSalt
    (R : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec)
    (saltComp : (i : pSpec.MessageIdx) ‚Üí R.prover.PrvState i.1.castSucc ‚Üí
      OracleComp oSpec (Salt i)) :
    OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut (pSpec.addSalt Salt) where
  prover := R.prover.addSalt Salt saltComp
  verifier := R.verifier.addSalt Salt

def basisSucc (k : ‚Ñï) : Basis (Fin 2) (ConcreteBTField k) (ConcreteBTField (k + 1)) :=

Matrix.vandermonde in Mathlib.LinearAlgebra.Vandermonde

noncomputable def finalSumcheckRbrExtractor :
  Extractor.RoundByRound []‚Çí
    (StmtIn := (Statement (L := L) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì)) √ó (‚àÄ j, OracleStatement ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë  (Fin.last ‚Ñì) j))
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì))
    (WitOut := Unit)
    (pSpec := pSpecFinalSumcheckStep (L := L))
    (WitMid := FinalSumcheckWit (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì)) where
  eqIn := rfl
  extractMid := fun m ‚ü®stmtMid, oStmtMid‚ü© trSucc witMidSucc => by admit /- proof elided -/
    | none => 
      exact dummyLastWitness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
    | some tpoly =>
      
      exact {
        t := tpoly,
        H := projectToMidSumcheckPoly (L := L) (‚Ñì := ‚Ñì) (t := tpoly)
          (m := BBF_SumcheckMultiplierParam.multpoly stmtMid.ctx)
          (i := Fin.last ‚Ñì) (challenges := stmtMid.challenges),
        f := getMidCodewords ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) tpoly stmtMid.challenges
      }
  extractOut := fun ‚ü®stmtIn, oStmtIn‚ü© tr witOut => ()

Subgroup.zpowers in Mathlib.Algebra.Group.Subgroup.ZPowers.Basic

def ConstraintSystem (ùì° : Type) (numWires numGates : ‚Ñï) := Fin numGates ‚Üí Gate ùì° numWires

Nat.cast in Init.Data.Cast

def BindingAdversary (oSpec : OracleSpec Œπ) (Data Commitment AuxState : Type)
    [O : OracleInterface Data] :=
  OracleComp oSpec (Commitment √ó O.Query √ó O.Response √ó O.Response √ó AuxState)

def finUInt64Equiv : Fin (2 ^ 64) ‚âÉ UInt64 where
  toFun := fun i => UInt64.ofFin i
  invFun := fun u => u.toFin
  left_inv _ := rfl
  right_inv _ := rfl

@[reducible, inline, specialize, simp]
def MessageIdx (vPSpec : VectorSpec n) := {i : Fin n // vPSpec.dir i = .P_to_V}

instance : Fintype BTF‚ÇÉ := (inferInstance : Fintype (ConcreteBTField 3))

instance [inst : ‚àÄ i, SelectableType (pSpec.Challenge i)] :
    ‚àÄ i, SelectableType ((pSpec.addSalt Salt).Challenge i) :=
  fun i => by admit /- proof elided -/

instance : Zero (Cayley T) where
  zero := zero

Nat.decLe in Init.Prelude

Eq in Init.Prelude

@[reducible]
def index (op : MemoryWrite Œπ Œ±) := op.1

@[reducible]
def backwardPermutationOracle (Œ± : Type*) : OracleSpec Unit := Œ± ‚Üí‚Çí Œ±

Set.Ioo in Mathlib.Order.Interval.Set.Defs

structure FinalSumcheckStatementOut extends
  Statement (L := L) (Context := SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì) where
  final_constant : L               

@[inline]
def seqCompose {m : ‚Ñï} (Stmt : Fin (m + 1) ‚Üí Type) (Wit : Fin (m + 1) ‚Üí Type)
    {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (R : (i : Fin m) ‚Üí
      Reduction oSpec (Stmt i.castSucc) (Wit i.castSucc) (Stmt i.succ) (Wit i.succ) (pSpec i)) :
    Reduction oSpec (Stmt 0) (Wit 0) (Stmt (Fin.last m)) (Wit (Fin.last m)) (seqCompose pSpec) where
  prover := Prover.seqCompose Stmt Wit (fun i => (R i).prover)
  verifier := Verifier.seqCompose Stmt (fun i => (R i).verifier)

@[simp]
abbrev Witness.AfterSecondSumcheck : Type := Unit

Vector.tail in Init.Data.Vector.Basic

@[reducible, simp]
def soundness (langIn : Set Statement)
    (verifier : Verifier oSpec Statement Bool pSpec)
    (soundnessError : ‚Ñù‚â•0) : Prop :=
  verifier.soundness init impl langIn acceptRejectRel.language soundnessError

def verifyProof {Œ±} [DecidableEq Œ±] {s}
    (idx : BinaryTree.SkeletonLeafIndex s) (leafValue : Œ±) (rootValue : Œ±)
    (proof : List Œ±) : OracleComp (spec Œ±) Unit := do
  let putative_root ‚Üê getPutativeRoot idx leafValue proof
  guard (putative_root = rootValue)

def seqComposeChallengeIdxToSigma {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (k : (seqCompose pSpec).ChallengeIdx) : (i : Fin m) √ó (pSpec i).ChallengeIdx :=
  let ij := Fin.splitSum k.1
  ‚ü®ij.1, ‚ü®ij.2, by admit /- proof elided -/
    ‚ü©‚ü©

OrderDual in Mathlib.Order.Basic

Algebra.TensorProduct.leftAlgebra in Mathlib.RingTheory.TensorProduct.Basic

noncomputable def roundConsistencyCheck [Field ùîΩ] [DecidableEq ùîΩ]
    (Œ≥ : ùîΩ) (pts : List (ùîΩ √ó ùîΩ)) (Œ≤ : ùîΩ) : Bool :=
  let p := Lagrange.interpolate Finset.univ (fun i => (pts.get i).1) (fun i => (pts.get i).2)
  p.eval Œ≥ == Œ≤

Submodule.span in Mathlib.LinearAlgebra.Span.Defs

instance {Œπ : Type} : OracleInterface (OracleStatement Œπ F ()) := OracleInterface.instFunction

def Mymotive : Fin 3 ‚Üí Type := !v[‚Ñï, Bool, String]

example : !d‚ü®Mymotive‚ü©[(1 : ‚Ñï), (true : Bool), ("hello" : String)] =
  (Fin.dcons (1 : ‚Ñï) (Fin.dcons (true : Bool) (Fin.dcons ("hello" : String) Fin.dempty)) :
   (i : Fin 3) ‚Üí Mymotive i) := rfl


example : !v[1, 2] ++·µõ !v[3, 4] = !v[1, 2, 3, 4] := rfl
example : (0 : ‚Ñï) ::·µõ !v[1, 2] = !v[0, 1, 2] := rfl
example : !v[1, 2] :+·µõ (3 : ‚Ñï) = !v[1, 2, 3] := rfl


example : (1 : ‚Ñï) :: ∞ (Fin.dempty : (i : Fin 0) ‚Üí Fin.vempty i) =
  (!h[(1 : ‚Ñï)] : (i : Fin 1) ‚Üí !v[‚Ñï] i) := rfl


example : !h[(1 : ‚Ñï), (true : Bool), ("hello" : String)] =
  Fin.hcons 1 (Fin.hcons true ("hello" :: ∞‚ü®String ; !v[]‚ü© !h[])) := rfl

def powFiber (S : Finset Œπ) (œÜ : Œπ ‚Ü™ F) (k : ‚Ñï) (y : indexPow S œÜ k) : Finset Œπ :=
  S.filter (fun x => (œÜ x) ^ k = y)

def Matrix (Œ± : Type*) (m n : ‚Ñï) := Vector (Vector Œ± n) m

noncomputable def extract_x
  (S : Finset Œπ) (œÜ : Œπ ‚Ü™ F) (k : ‚Ñï) (y : indexPowT S œÜ (k + 1)) : indexPowT S œÜ k :=
  let x := Classical.choose y.property
  let hx := Classical.choose_spec y.property
  let z := (œÜ x) ^ (2^k)
  ‚ü®z, ‚ü®x, hx.1, rfl‚ü©‚ü©

@[inline] def le [Zero T] [ToNat T] (a b : Cayley T) : Prop :=
  (‚Üëa : Nat) ‚â§ (‚Üëb : Nat)

@[reducible]
def spec : OracleSpec Unit := fun _ => (Œ± √ó Œ±, Œ±)

UInt8 in Init.Prelude

def inputRelation : Set ((StmtIn R √ó (‚àÄ i, OStmtIn R deg i)) √ó Unit) :=
  { ‚ü®‚ü®target, oStmt‚ü©, _‚ü© | ‚àë x ‚àà (univ.map D), (oStmt ()).1.eval x = target }

class Verifier.IsPure (V : Verifier oSpec StmtIn StmtOut pSpec) where
    is_pure : ‚àÉ verify : _ ‚Üí _ ‚Üí _, ‚àÄ stmtIn transcript,
      V.verify stmtIn transcript = pure (verify stmtIn transcript)

RingHom.comp in Mathlib.Algebra.Ring.Hom.Defs

noncomputable instance {s : Set (Œπ ‚Üí F)} : Fintype (affineSpan F s) :=
  Fintype.ofFinite ‚Ü•(affineSpan F s)

noncomputable instance {H : F[X][Y]} : Ring (ùí™ H) :=
  Ideal.Quotient.ring (Ideal.span {H_tilde' H})

Fin.succ in Init.Data.Fin.Basic

Repr in Init.Data.Repr

Finsupp in Mathlib.Data.Finsupp.Defs

def curve : WeierstrassCurve BaseField := {
  a‚ÇÅ := 0,  
  a‚ÇÇ := 0,  
  a‚ÇÉ := 0,  
  a‚ÇÑ := 0,  
  a‚ÇÜ := 3   
}

def knowledgeStateFunction (hRel : ‚àÄ stmtIn witOut,
      (mapStmt stmtIn, witOut) ‚àà relOut ‚Üí (stmtIn, mapWitInv stmtIn witOut) ‚àà relIn) :
    (verifier oSpec mapStmt).KnowledgeStateFunction
      init impl relIn relOut (extractor mapWitInv) where
  toFun | ‚ü®0, _‚ü© => fun stmtIn _ witIn => ‚ü®stmtIn, witIn‚ü© ‚àà relIn
  toFun_empty := fun stmtIn witIn => by admit /- proof elided -/

def inputRelation (cond : ‚àë i, (s i).1 ‚â§ n) [DecidableEq F] (Œ¥ : ‚Ñù‚â•0) :
    Set
      (
        (
          Statement F (Fin.last k) √ó
          (‚àÄ j, OracleStatement D x s (Fin.last k) j)
        ) √ó
        Witness F s d (Fin.last k).castSucc
      ) := sorry

Polynomial.modByMonic in Mathlib.Algebra.Polynomial.Div

def fiberEvaluationMapping (i : Fin r) (steps : ‚Ñï) (h_i_add_steps : i.val + steps < ‚Ñì + ùì°)
    (f : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) i ‚Üí L)
    (y : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate)
      ‚ü®‚Üëi + steps, by admit /- proof elided -/
      ‚ü©)
    : Fin (2 ^ steps) ‚Üí L :=
  
  let fiberMap := qMap_total_fiber ùîΩq Œ≤ (i := i) (steps := steps)
    (h_i_add_steps := h_i_add_steps) (y := y)

  
  fun idx => f (fiberMap idx)

instance instDCast‚ÇÅ‚ÇÇ : DCast (Œ≤ a) (Œ≥ a) where
  dcast hb c := dcast‚ÇÇ (Eq.refl a) (by admit /- proof elided -/
  ) c
  dcast_id := by admit /- proof elided -/

instance : ‚àÄ j, OracleInterface (OracleStatement D x m j) :=
  fun _ => inferInstance

def D_YZ (Q : F[Z][X][Y]) : ‚Ñï :=
  Option.getD (dflt := 0) <| Finset.max
    (Finset.image
            (
              fun j =>
                Option.getD (
                  Finset.max (
                    Finset.image
                      (fun k => j + (Bivariate.coeff Q j k).natDegree)
                      (Q.coeff j).support
                  )
                ) 0
            )
            Q.support
    )

instance instDecidableEqOption {Œ± : Type*} [DecidableEq Œ±] :
    DecidableEq (Option Œ±) := inferInstance

noncomputable def polyQuotient (S : Finset F) (fPoly : F[X]) : F[X] :=
    (fPoly - (ansPoly S (fun s => fPoly.eval s))) / (vanishingPoly S)

noncomputable def evaluationPointœâ (i : Fin (‚Ñì + 1))
    (x : Fin (2 ^ (‚Ñì + R_rate - i))) : L := 
    
  ‚àë (‚ü®k, hk‚ü©: Fin (‚Ñì + R_rate - i)),
    if Nat.getBit k x.val = 1 then
      (normalizedW ùîΩq Œ≤ ‚ü®i, by admit /- proof elided -/
      ‚ü©).eval (Œ≤ ‚ü®i + k, by admit /- proof elided -/
      ‚ü©)
    else
      0

ZMod.instField in Mathlib.Algebra.Field.ZMod

def findImports (path : System.FilePath) : IO (Array Lean.Name) := do
  return (‚Üê Lean.parseImports' (‚Üê IO.FS.readFile path) path.toString)
    |>.map (fun imp ‚Ü¶ imp.module) |>.erase `Init

instance instST‚ÇÅ : ‚àÄ i, SelectableType ((‚ü®!v[.P_to_V], !v[R‚¶É‚â§ deg‚¶Ñ[X]]‚ü© ++‚Çö !p[]).Challenge i) :=
  instSelectableTypeChallengeAppend

Empty in Init.Prelude

def uniqueDecodable (C : Code Œπ F) (r : ‚Ñù) : Prop :=
  listDecodable C r 1

@[reducible, inline, specialize]
def Transcript (k : Fin (n + 1)) (pSpec : ProtocolSpec n) : Type :=
  (pSpec‚ü¶:k.val‚üß).FullTranscript

Nat.succ in Init.Prelude

@[reducible]
def foldRelayOracleVerifier (i : Fin ‚Ñì)
    (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
  OracleVerifier []‚Çí
    (StmtIn := Statement (L := L) Context i.castSucc)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.succ)
    (pSpec := pSpecFoldRelay (L:=L)) :=
  OracleVerifier.append
        (pSpec‚ÇÅ := pSpecFold (L:=L))
    (pSpec‚ÇÇ := pSpecRelay)
    (foldOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)
    (relayOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hNCR)

def listOfCloseCodewordsRel (C : Code Œπ F) (y : Œπ ‚Üí F) (r : ‚Ñù) : ‚Ñï :=
  Nat.card (relHammingBall C y r)

noncomputable def UniPolyC.toPoly (p : UniPolyC R) : Polynomial R := p.val.toPoly

alias ofPoly := Polynomial.toImpl

instance {Œ± : Fin 0 ‚Üí Sort u} : Unique ((i : Fin 0) ‚Üí Œ± i) where
  uniq := fun v => by admit /- proof elided -/

def absorb (sponge : DuplexSponge U C) (ls : List U) :
    OracleComp (forwardPermutationOracle C) (DuplexSponge U C) :=
  match ls with
  
  
  | [] => pure { sponge with squeezePos := Fin.last SpongeSize.R }
  
  | x :: xs =>
    
    
    
    if sponge.absorbPos = SpongeSize.R then do
      let permutedState ‚Üê query (spec := forwardPermutationOracle _) () (sponge.state)
      let newSponge : DuplexSponge U C := {
        state := SpongeState.modify permutedState (Vector.set ¬∑ 0 x),
        absorbPos := 1
        squeezePos := Fin.last SpongeSize.R }
      
      absorb newSponge xs
    else do
      
      
      
      let newSponge : DuplexSponge U C := {
        state := SpongeState.modify sponge.state (Vector.set ¬∑ (sponge.absorbPos : Nat) x),
        absorbPos := sponge.absorbPos + 1,
        squeezePos := Fin.last SpongeSize.R }
      absorb newSponge xs

@[inline]
def neg [Neg R] (p : MlPolyEval R n) : MlPolyEval R n := p.map (fun a => -a)

def linearCodeDist' {F} {Œπ} [Fintype Œπ] [Semiring F] [DecidableEq F] [Fintype F] [DecidableEq Œπ]
 (LC : LinearCode Œπ F) [DecidablePred (¬∑ ‚àà LC)] : ‚Ñï‚àû :=
  Finset.min <| ((Finset.univ (Œ± := LC)).filter (fun v => v ‚â† 0)).image (fun v => hammingNorm v.1)

@[inline, specialize]
def nsmul (n : ‚Ñï) (p : UniPoly R) : UniPoly R :=
  nsmul_raw n p |> trim

Multiset.count in Mathlib.Data.Multiset.Count

@[ext]
structure Reduction {Œπ : Type} (oSpec : OracleSpec Œπ)
    (StmtIn WitIn StmtOut WitOut : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n) where
  prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec
  verifier : Verifier oSpec StmtIn StmtOut pSpec

def toRoundByRound (E : RoundByRoundOneShot oSpec StmtIn WitIn pSpec) :
    RoundByRound oSpec StmtIn WitIn WitOut pSpec (fun _ => WitIn) where
  eqIn := rfl
  extractMid := fun m stmtIn tr witIn =>
    if m.castSucc = 0 then witIn else E m.castSucc stmtIn (Fin.init tr) default
  extractOut := fun stmtIn tr _ => E (.last n) stmtIn tr default

@[reducible, simp] def StmtOut : Type := R √ó R

BitVec in Init.Prelude

Module.Basis.reindex in Mathlib.LinearAlgebra.Basis.Defs

Fin.insertNth in Mathlib.Data.Fin.Tuple.Basic

IsField.toField in Mathlib.Algebra.Field.IsField

Mathlib.Meta.NormNum.instAddMonoidWithOne in Mathlib.Tactic.NormNum.Result

LE.le in Init.Prelude

Multiset.ofList in Mathlib.Data.Multiset.Defs

@[inline]
def ofOutputOnly
    (liftWit : OuterStmtIn √ó OuterWitIn ‚Üí InnerStmtOut √ó InnerWitOut ‚Üí OuterWitOut) :
    Witness.Lens OuterStmtIn InnerStmtOut OuterWitIn OuterWitOut OuterWitIn InnerWitOut :=
  ‚ü®Prod.snd, liftWit‚ü©

noncomputable def fromConcreteBTF0 : ConcreteBTField 0 ‚Üí (GF(2)) :=
  fun x => if decide (x = zero) then 0 else 1

instance : Repr ByteArray where
  reprPrec b n := List.repr b.toList n

def toProverState (ds : DomainSeparator U H) (rng : R) : FSProverState U H R :=
  FSProverState.new ds rng

Nat.testBit in Init.Data.Nat.Bitwise.Basic

def JohnsonConditionWeak (B : Finset (Fin n ‚Üí F)) (e : ‚Ñï) : Prop :=
  let d := sInf { d | ‚àÉ u ‚àà B, ‚àÉ v ‚àà B, u ‚â† v ‚àß hammingDist u v = d }
  let q : ‚Ñö := Fintype.card F
  (e : ‚Ñö) / n < J q (d / n)

@[reducible]
def combineMap : StmtIn √ó WitIn ‚Üí OracleComp oSpec (StmtOut √ó WitOut) :=
  fun ‚ü®stmt, wit‚ü© => do return (‚Üê mapStmt stmt, ‚Üê mapWit stmt wit)

class Deserialize (Œ± : Type u) (Œ≤ : Type v) where
  deserialize : Œ≤ ‚Üí Œ±

def implGroupEncodeOracle [Serialize G (BitVec bitLength)] :
    QueryImpl (GroupEncodeOracle Œπ bitLength) (StateT (GroupValTable Œπ G) Option) where
  impl | query _ i => fun table =>
    match table i with
    | some g => some (serialize g, table)
    | none => none

ByteArray.empty in Init.Prelude

CommMonoid in Mathlib.Algebra.Group.Defs

instance (priority := low) : DCast Œ± Œ≤ where
  dcast h := cast (congrArg Œ≤ h)
  dcast_id := by admit /- proof elided -/

Fintype.ofFinite in Mathlib.Data.Fintype.EquivFin

Unique in Mathlib.Logic.Unique

def relation : Set (M √ó M √ó List (MemoryOp Œπ Œ±)) :=
  { ‚ü®startMem, finalMem, ops‚ü© | processMemoryOps ops startMem = some finalMem }

Infinite in Mathlib.Data.Finite.Defs

instance : ‚àÄ i, NeZero (toOutCodewordsCount ‚Ñì œë i) :=

private noncomputable def evenPart' (f : Polynomial F) : Polynomial F :=
  match f with
  | ‚ü®‚ü®supp, f, pr‚ü©‚ü© => ‚ü®‚ü®erase_odd supp, fun n => if Even n then f n else 0, by admit /- proof elided -/
  ‚ü©‚ü©

@[simp]
instance BTFieldNoZeroDiv (k : ‚Ñï) : NoZeroDivisors (BTField k) :=

cast in Init.Prelude

@[reducible, simp]
def OStmtIn : Unit ‚Üí Type := fun _ => R‚¶É‚â§ deg‚¶Ñ[X]

ENat.toNat in Mathlib.Data.ENat.Basic

def Reduction.fiatShamir (R : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec) :
    NonInteractiveReduction (‚àÄ i, pSpec.Message i) (oSpec ++‚Çí fsChallengeOracle StmtIn pSpec)
      StmtIn WitIn StmtOut WitOut where
  prover := R.prover.fiatShamir
  verifier := R.verifier.fiatShamir

structure SumcheckBaseContext (L : Type) (‚Ñì : ‚Ñï) where
  t_eval_point : Fin ‚Ñì ‚Üí L         
  original_claim : L               

ZeroMemClass in Mathlib.Algebra.Group.Submonoid.Defs

def singleHash (left : Œ±) (right : Œ±) : OracleComp (spec Œ±) Œ± := do
  let out ‚Üê query (spec := spec Œ±) () ‚ü®left, right‚ü©
  return out

abbrev MultilinearPoly (L : Type) [CommSemiring L] (‚Ñì : ‚Ñï) := L‚¶É‚â§ 1‚¶Ñ[X Fin ‚Ñì]

def equivFin2 : Direction ‚âÉ Fin 2 where
  toFun := fun dir => match dir with | .V_to_P => ‚ü®0, by admit /- proof elided -/
  ‚ü© | .P_to_V => ‚ü®1, by admit /- proof elided -/
  ‚ü©
  invFun := fun n => match n with | ‚ü®0, _‚ü© => .V_to_P | ‚ü®1, _‚ü© => .P_to_V
  left_inv := fun dir => match dir with | .P_to_V => rfl | .V_to_P => rfl
  right_inv := fun n => match n with | ‚ü®0, _‚ü© => rfl | ‚ü®1, _‚ü© => rfl

@[reducible, inline, specialize, simp]
def Challenge' (pSpec : ProtocolSpec n) (i : Fin n) (_ : pSpec.dir i = .V_to_P) := pSpec.¬´Type¬ª i

Nat.bit in Mathlib.Data.Nat.BinaryRec

noncomputable def polyQ (P q : Polynomial F) : MvPolynomial (Fin 2) F :=
  
  let Pbi : MvPolynomial (Fin 2) F := uni2bi P
  
  let P' : MvPolynomial (Fin 2) F := (MvPolynomial.X 1) - uni2bi q
  
  have h_unit : IsUnit ((MonomialOrder.lex).leadingCoeff P') := sorry
  modBivar Pbi P' h_unit

noncomputable def Œ∑Star (U : Type) [SpongeUnit U] [Fintype U]
    (t‚Çï t‚Çö t‚Çö·µ¢ : ‚Ñï) (L : ‚Ñï) (Œµcodec : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) : ‚Ñù‚â•0 :=
  let tTotal : ‚Ñï := (t‚Çï + t‚Çö + t‚Çö·µ¢)
  
  
  
  
  let firstTermNumerator : ‚Ñù‚â•0 :=
    7 * tTotal ^2 + (28 * L + 25) * tTotal + (14 * L + 1) * (L + 1)
  let firstTermDenominator : ‚Ñù‚â•0 := 2 * ((Fintype.card U) ^ (SpongeSize.C + 1))
  
  let secondTerm : ‚Ñù‚â•0 := Œ∏Star t‚Çï t‚Çö t‚Çö·µ¢ * (iSup Œµcodec)
  
  let thirdTerm : ‚Ñù‚â•0 := ‚àë i, Œµcodec i
  
  firstTermNumerator / firstTermDenominator + secondTerm + thirdTerm

noncomputable def sDomainBasisVectors (i : Fin r) : Fin (‚Ñì + R_rate - i) ‚Üí L :=
  fun k => (normalizedW ùîΩq Œ≤ i).eval (Œ≤ ‚ü®i + k.val, by admit /- proof elided -/
  ‚ü©)

instance instSub {n : ‚Ñï} : Sub (CNat n) := match n with
  | 0 => by admit /- proof elided -/
  | .succ n => by admit /- proof elided -/

noncomputable instance : Algebra K (Left ‚äó[K] Right) := Algebra.TensorProduct.instAlgebra

def StateFunction.append
    (V‚ÇÅ : Verifier oSpec Stmt‚ÇÅ Stmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : Verifier oSpec Stmt‚ÇÇ Stmt‚ÇÉ pSpec‚ÇÇ)
    (S‚ÇÅ : V‚ÇÅ.StateFunction init impl lang‚ÇÅ lang‚ÇÇ)
    (S‚ÇÇ : V‚ÇÇ.StateFunction init impl lang‚ÇÇ lang‚ÇÉ)
    
    (verify : Stmt‚ÇÅ ‚Üí pSpec‚ÇÅ.FullTranscript ‚Üí Stmt‚ÇÇ)
    (hVerify : V‚ÇÅ = ‚ü®fun stmt tr => pure (verify stmt tr)‚ü©) :
      (V‚ÇÅ.append V‚ÇÇ).StateFunction init impl lang‚ÇÅ lang‚ÇÉ where
  toFun := fun roundIdx stmt‚ÇÅ transcript =>
    if h : roundIdx.val ‚â§ m then
    
      S‚ÇÅ ‚ü®roundIdx, by admit /- proof elided -/
      ‚ü© stmt‚ÇÅ (by admit /- proof elided -/
      )
    else
    
    
    
      S‚ÇÅ ‚ü®m, by admit /- proof elided -/
      ‚ü© stmt‚ÇÅ (by admit /- proof elided -/
      ) ‚àß
      S‚ÇÇ ‚ü®roundIdx - m, by admit /- proof elided -/
      ‚ü© (verify stmt‚ÇÅ
        (by admit /- proof elided -/
        ))
        (by admit /- proof elided -/
        )
  toFun_empty := sorry
  toFun_next := sorry
  toFun_full := sorry

noncomputable def relayOracleProver (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
  OracleProver (oSpec := []‚Çí)
    
    (StmtIn := Statement (L := L) Context i.succ)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) i.succ)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) i.succ)
    (pSpec := pSpecRelay) where
  PrvState := relayPrvState ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i
  input := fun ‚ü®‚ü®stmtIn, oStmtIn‚ü©, witIn‚ü© => (stmtIn, oStmtIn, witIn)
  sendMessage | ‚ü®x, h‚ü© => by admit /- proof elided -/
| ‚ü®x, h‚ü© => by admit /- proof elided -/

@[inline, specialize]
def oracleVerifier : OracleVerifier oSpec
    Unit (fun _ : Fin 2 => OStatement)
    (Query OStatement) (fun _ : Fin 2 => OStatement) (pSpec OStatement) where

  verify := fun _ chal => do
    let q : Query OStatement := chal ‚ü®0, rfl‚ü©
    pure q

  embed := Function.Embedding.inl

  hEq := by admit /- proof elided -/

instance : Unique (FullTranscript (default : ProtocolSpec 0)) := inferInstance

@[inline, specialize, simp]
def prover : Prover oSpec Statement Witness Statement Witness !p[] := Prover.id

def fnOracle (spec : OracleSpec Œπ) (f : (i : Œπ) ‚Üí spec.domain i ‚Üí spec.range i) :
    SimOracle.Impl spec where
  impl | query i t => pure (f i t)

instance [IsSingleRound pSpec] [h : OracleInterface (pSpec.Message default)] :
    (i : pSpec.MessageIdx) ‚Üí OracleInterface (pSpec.Message i) := fun i => by admit /- proof elided -/

@[inline, reducible]
def lift : OuterStmtIn ‚Üí InnerStmtOut ‚Üí OuterStmtOut :=
  lens.toFunB

class PolynomialLike.LawfulCoeff (R : Type u) [CommSemiring R] (P : Type v) [CommSemiring P]
    [PolynomialLike R P] (coeff : P ‚Üí ‚Ñï ‚Üí R) where
  coeff_finite (p : P) : Set.Finite {n | coeff p n ‚â† 0}

structure BinaryTowerInductiveStepResult (k : ‚Ñï) (prevBTField : Type _)
  (prevBTResult : BinaryTowerResult prevBTField k) [instPrevBTFieldIsField : Field prevBTField]
  (prevPoly : Polynomial prevBTField) (F : Type _) where
  binaryTowerResult : BinaryTowerResult F (k+1)
  eq_adjoin : F = AdjoinRoot prevPoly
  u_is_root : Eq.mp (eq_adjoin) binaryTowerResult.specialElement = AdjoinRoot.root prevPoly
  eval_defining_poly_at_root : Eq.mp (eq_adjoin) binaryTowerResult.specialElement^2 +
    Eq.mp (eq_adjoin) binaryTowerResult.specialElement * (of prevPoly) prevBTResult.specialElement
    + 1 = 0

OptionT in Init.Control.Option

@[reducible, simp]
def oraclePSpec : ProtocolSpec 1 := ‚ü®!v[.P_to_V], !v[Witness]‚ü©

structure CodeParams (P : Params Œπ F) (Dist : Distances M) where
  C : ‚àÄ i : Fin (M + 1), Set ((Œπ i) ‚Üí F)
  h_code : ‚àÄ i : Fin (M + 1), C i = code (P.œÜ i) (degree Œπ P i)
  h_listDecode : ‚àÄ i : Fin (M + 1), i ‚â† 0 ‚Üí listDecodable (C i) (Dist.Œ¥ i) (Dist.l i)

Classical.arbitrary in Mathlib.Logic.Nonempty

structure InitialStatement where
  
  t_eval_point : Fin ‚Ñì ‚Üí L         
  original_claim : L               

@[inline]
def zsmul [SMul ‚Ñ§ R] (m : ‚Ñ§) (p : MlPoly R n) : MlPoly R n := p.map (fun a => m ‚Ä¢ a)

instance : ‚àÄ j, OracleInterface (((pSpecFold D x k s ++‚Çö FinalFoldPhase.pSpec F)).Message j) :=
  instOracleInterfaceMessageAppend

instance [inst : SelectableType Chal] : ‚àÄ i, SelectableType (Challenge ‚ü®!v[.V_to_P], !v[Chal]‚ü© i)
  | ‚ü®0, _‚ü© => inst

UInt64.ofFin in Init.Data.UInt.Basic

instance instOfNat {n : ‚Ñï} : OfNat (CNat n) n := match n with
  | 0 => by admit /- proof elided -/
  | .succ n => by admit /- proof elided -/

GaloisField.equivZmodP in Mathlib.FieldTheory.Finite.GaloisField

instance : ‚àÄ i, VCVCompatible (Challenge ‚ü®!v[.P_to_V], !v[Msg]‚ü© i)
  | ‚ü®0, h‚ü© => nomatch h

def Reduction.duplexSpongeFiatShamir (R : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec) :
    NonInteractiveReduction (‚àÄ i, pSpec.Message i) (oSpec ++‚Çí duplexSpongeChallengeOracle StmtIn U)
      StmtIn WitIn StmtOut WitOut where
  prover := R.prover.duplexSpongeFiatShamir
  verifier := R.verifier.duplexSpongeFiatShamir

LinearIndepOn in Mathlib.LinearAlgebra.LinearIndependent.Defs

def partialSum {Œ± : Type*} [AddMonoid Œ±] (l : List Œ±) : List Œ± :=
  [0] ++ match l with
  | [] => []
  | a :: l' => (partialSum l').map (a + ¬∑)

instance {s} : LawfulFunctor (fun Œ± => InternalData Œ± s) :=

def numberOfClosePts (u v : Œπ ‚Üí F) (deg : ‚Ñï) (Œ± : Œπ ‚Ü™ F) (e : ‚Ñï) : ‚Ñï :=
  Fintype.card (closePtsOnAffineLine u v deg Œ± e)

def multilinearBasis (l r : ‚Ñï) (h_le : l ‚â§ r) :
    letI instAlgebra : Algebra (BTField l) (BTField r) := binaryAlgebraTower (h_le:=h_le)
    Basis (Fin (2 ^ (r - l))) (BTField l) (BTField r) :=

def lt {Œ± : Type} (m n : ChurchNat Œ±) : ChurchBool Œ± :=
  ChurchBool.churchAnd (leq m n) (ChurchBool.churchNot (leq n m))

OrderDual.toDual in Mathlib.Order.Synonym

def KnowledgeStateFunctionOneShot.toKnowledgeStateFunction
    {relIn : Set (StmtIn √ó WitIn)} {relOut : Set (StmtOut √ó WitOut)}
    {verifier : Verifier oSpec StmtIn StmtOut pSpec}
    (stF : KnowledgeStateFunctionOneShot init impl relIn.language relOut.language verifier)
    (oneShotE : Extractor.RoundByRoundOneShot oSpec StmtIn WitIn pSpec) :
    verifier.KnowledgeStateFunction init impl relIn relOut oneShotE.toRoundByRound where
  toFun := fun m stmtIn tr witIn => if m = 0 then (stmtIn, witIn) ‚àà relIn else
    stF.toFun m stmtIn tr ‚à® (stmtIn, oneShotE m stmtIn tr default) ‚àà relIn
  toFun_empty := fun stmtIn witIn => by admit /- proof elided -/

@[inline, specialize]
def runWithLogToRound (i : Fin (n + 1))
    (stmt : StmtIn) (wit : WitIn) (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí)
        ((pSpec.Transcript i √ó prover.PrvState i) √ó QueryLog (oSpec ++‚Çí [pSpec.Challenge]‚Çí)) :=
  (simulateQ loggingOracle (prover.runToRound i stmt wit)).run

cond in Init.Prelude

def extract {n : ‚Ñï} {Œ± : Fin n ‚Üí Sort*} (start stop : ‚Ñï) (h1 : start ‚â§ stop) (h2 : stop ‚â§ n)
    (v : (i : Fin n) ‚Üí Œ± i) : (i : Fin (stop - start)) ‚Üí Œ± ‚ü®i + start, by admit /- proof elided -/
    ‚ü© :=
  fun i ‚Ü¶ v ‚ü®i + start, by admit /- proof elided -/
  ‚ü©

@[simps!]
def MessageIdx.sumEquiv :
    MessageIdx pSpec‚ÇÅ ‚äï MessageIdx pSpec‚ÇÇ ‚âÉ MessageIdx (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ) where
  toFun := Sum.elim (MessageIdx.inl) (MessageIdx.inr)
  invFun := fun ‚ü®i, h‚ü© => by admit /- proof elided -/

inductive PrattPart : (p : ‚Ñï) ‚Üí (a : ZMod p) ‚Üí ‚Ñï ‚Üí Prop
  | prime : {p : ‚Ñï} ‚Üí {a : ZMod p} ‚Üí (n k nk : ‚Ñï) ‚Üí n.Prime ‚Üí
      a ^ ((p - 1) / n) ‚â† 1 ‚Üí n ^ k = nk ‚Üí PrattPart p a nk
  | split : {p : ‚Ñï} ‚Üí {a : ZMod p} ‚Üí {n : ‚Ñï} ‚Üí (l r : ‚Ñï) ‚Üí
      PrattPart p a l ‚Üí PrattPart p a r ‚Üí l * r = n ‚Üí PrattPart p a n

@[reducible]
def capacitySegment (state : CanonicalSpongeState U) : Vector U SpongeSize.C :=
  Vector.drop state SpongeSize.R

AdjoinRoot in Mathlib.RingTheory.AdjoinRoot

def Option.doubleBind_v3 {Œ± Œ≤ Œ≥ : Type} (f : Œ± ‚Üí Œ≤ ‚Üí Option Œ≥)
    (x : Option Œ±) (y : Option Œ≤) : Option Œ≥ := do f (‚Üê x) (‚Üê y)

instance : ‚àÄ j, OracleInterface ((fullPSpec ùîΩq Œ≤ Œ≥_repetitions (œë:=œë)
  (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).Message j) := instOracleInterfaceMessageAppend

instance {U : Type} {H : Type*} {R : Type*} [SpongeUnit U] [DuplexSpongeInterface U H] :
    UnitTranscript (FSProverState U H R) U where
  publicUnits state input := do
    
    
    let newState ‚Üê state.addUnits input
    .ok { rng := newState.rng, hashState := newState.hashState,
          nargString := state.nargString } 
  fillChallengeUnits state count :=
    match state.hashState.squeeze count with
    | .ok (newHashState, output) =>
      .ok ({ rng := state.rng, hashState := newHashState, nargString := state.nargString }, output)
    | .error e => .error e

def eq {Œ± : Type u} (mx my : m Œ±) : Prop :=
  evalDist mx = evalDist my

class HasSucc (T : Type u) where
   
  succ' : T ‚Üí T

Finset.Icc in Mathlib.Order.Interval.Finset.Defs

def partition (cs : ConstraintSystem ùì° numWires numGates) :
    Fin numWires ‚Üí Finset (Fin (3 * numGates)) :=
  
  
  
  
  fun i => Finset.map (Equiv.toEmbedding finProdFinEquiv)
    (Finset.filter (fun j => if j.1 = 0 then (cs j.2).a = i
      else if j.1 = 1 then (cs j.2).b = i else (cs j.2).c = i)
    (Finset.univ : Finset (Fin 3 √ó Fin numGates)))

def millerRabinBases : List ‚Ñï :=
  [2, 325, 9375, 28178, 450775, 9780504, 1795265022]

List.Vector.snoc in Mathlib.Data.Vector.Snoc

def drop (m : ‚Ñï) (h : m ‚â§ n) (pSpec : ProtocolSpec n) : ProtocolSpec (n - m) :=
  {dir := Fin.drop m h pSpec.dir, ¬´Type¬ª := Fin.drop m h pSpec.¬´Type¬ª}

def subNat [Zero T] [ToNat T] (a : Cayley T) : Nat ‚Üí Cayley T
  | 0        => a
  | .succ k  => pred (subNat a k)

def degreeX (f : F[X][Y]) : ‚Ñï := f.support.sup (fun n => (f.coeff n).natDegree)

instance [Fintype F] [Nonempty F] [Semiring F] [DecidableEq Œπ] [DecidableEq F] {l : ‚Ñï}
  {u : Fin l ‚Üí Œπ ‚Üí F} : Nonempty {x // x ‚àà parametrisedCurveFinite u} :=

@[reducible]
def Witness (F : Type) [NonBinaryField F] {k : ‚Ñï}
    (s : Fin (k + 1) ‚Üí ‚Ñï+) (d : ‚Ñï+) (i : Fin (k + 2)) :=
  F‚¶É< 2^((‚àë j', (s j').1) - (‚àë j' ‚àà finRangeTo i.1, (s j').1)) * d‚¶Ñ[X]

UInt16.ofFin in Init.Data.UInt.Basic

instance : Sub AssocNat where
  sub := sub

instance instDCast : DCast Nat Fin where
  dcast h := Fin.cast h
  dcast_id := by admit /- proof elided -/

  inductive UnverifiedPrattCertificate : ‚Ñï ‚Üí Type
    | knownPrime : (n : ‚Ñï) ‚Üí UnverifiedPrattCertificate n
    | of : (n : ‚Ñï) ‚Üí (a : ‚Ñï) ‚Üí (part : UnverifiedPrattPart) ‚Üí UnverifiedPrattCertificate n
  deriving Repr

NatPow in Init.Prelude

instance [Inhabited OuterWitOut]
    [instKS : lens.IsKnowledgeSound
                outerRelIn innerRelIn
                outerRelOut innerRelOut
                compatStmt (fun _ _ => True)] :
    lens.stmt.IsSound
      outerRelIn.language outerRelOut.language
      innerRelIn.language innerRelOut.language
      compatStmt where
  proj_sound := fun outerStmtIn hCompat => by admit /- proof elided -/

DivisionRing in Mathlib.Algebra.Field.Defs

def powNat [Zero T] [One T] [ToNat T] (a : Cayley T) : Nat ‚Üí Cayley T
  | 0        => one  
  | .succ k  => mul a (powNat a k)  

def binaryTowerModule {l r : ‚Ñï} (h_le : l ‚â§ r) : Module (BTField l) (BTField r) :=
  (binaryAlgebraTower (h_le:=h_le)).toModule

def block (i : ‚Ñï) {k : ‚Ñï} {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F}
  (S' : Finset (indexPowT S œÜ i))
  (œÜ' : (indexPowT S œÜ i) ‚Ü™ F) (z : indexPowT S œÜ k)
  [DecidableEq F] [DecidableEq Œπ] [Smooth œÜ] :=
    powFiberT i S' œÜ' z

noncomputable def ofPolynomialAlgHom : R[X] ‚Üí‚Çê[R] P := Polynomial.aeval PolynomialLike.X

def towerOfExponents (g : G) (a : ZMod p) (n : ‚Ñï) : Vector G (n + 1) :=
  .ofFn (fun i => g ^ (a.val ^ i.val))

instance : SubSpec [pSpec‚ÇÇ.Challenge]‚Çí ([(pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).Challenge]‚Çí) where
  monadLift | query i t => instSubSpecOfProtocolSpecAppendChallenge.monadLift (query (Sum.inr i) t)

noncomputable def relayRbrExtractor (i : Fin ‚Ñì) :
  Extractor.RoundByRound []‚Çí
    (StmtIn := (Statement (L := L) Context i.succ) √ó (‚àÄ j, OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc j))
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (pSpec := pSpecRelay)
    (WitMid := fun _messageIdx => Witness (L := L) ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ) where
  eqIn := rfl
  extractMid := fun _ _ _ witMidSucc => witMidSucc
  extractOut := fun _ _ witOut => witOut

RingHom in Mathlib.Algebra.Ring.Hom.Defs

def Function.interleave‚ÇÇ {Œ± Œ≤ : Type*} (u v : Œ± ‚Üí Œ≤) : (Fin 2) √ó Œ± ‚Üí Œ≤ :=
  Function.uncurry (fun a => if a = 0 then u else v)

structure ProverInteraction {Œπ : Type} (oSpec : OracleSpec Œπ) {n : ‚Ñï} (pSpec : ProtocolSpec n)
    extends ProverState n, ProverInit (PrvState 0), ProverRound oSpec pSpec

def rtake {n : ‚Ñï} {Œ± : Fin n ‚Üí Sort*} (m : ‚Ñï) (h : m ‚â§ n) (v : (i : Fin n) ‚Üí Œ± i) :
    (i : Fin m) ‚Üí Œ± (Fin.cast (Nat.sub_add_cancel h) (natAdd (n - m) i)) :=
  fun i => v (Fin.cast (Nat.sub_add_cancel h) (natAdd (n - m) i))

Lean.parseImports' in Lean.Elab.ParseImportsFast

def deriveTranscriptSR {Œπ : Type} {oSpec : OracleSpec Œπ} {StmtIn : Type}
    (stmt : StmtIn) (messages : pSpec.Messages) :
    OracleComp (oSpec ++‚Çí fsChallengeOracle StmtIn pSpec) pSpec.FullTranscript := do
  MessagesUpTo.deriveTranscriptSR stmt (Fin.last n) messages

alias deriveTranscriptFS := deriveTranscriptSR

noncomputable def basisVectors (‚Ñì : Nat) (h_‚Ñì : ‚Ñì ‚â§ r) :
  Fin (2 ^ ‚Ñì) ‚Üí L‚¶É<2^‚Ñì‚¶Ñ[X] :=
  fun j => ‚ü®X‚±º ùîΩq Œ≤ ‚Ñì h_‚Ñì j, by admit /- proof elided -/
  ‚ü©

instance {i : Fin r} : DecidableEq (U ùîΩq Œ≤ i) :=

BitVec.getLsb in Init.Data.BitVec.Basic

def findIdxRev? (cond : Œ± ‚Üí Bool) (as : Array Œ±) : Option (Fin as.size) :=
  find ‚ü® as.size, Nat.lt_succ_self _ ‚ü©
where
  find : Fin (as.size + 1) ‚Üí Option (Fin as.size)
    | 0 => none
    | ‚ü® i+1, h ‚ü© =>
      if (cond as[i]) then
        some ‚ü® i, Nat.lt_of_succ_lt_succ h ‚ü©
      else
        find ‚ü® i, Nat.lt_of_succ_lt h ‚ü©

Polynomial.charP in Mathlib.Algebra.Polynomial.Coeff

def masterKStateProp (stmtIdx : Fin (‚Ñì + 1))
    (oracleIdx : Fin (‚Ñì + 1))
    (h_le : oracleIdx.val ‚â§ stmtIdx.val) (stmt : Statement (L := L) Context stmtIdx)
    (wit : Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) stmtIdx)
    (oStmt : ‚àÄ j, (OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (i := oracleIdx) j))
    (localChecks : Prop := True) : Prop :=
  let oracleWitnessConsistency: Prop := oracleWitnessConsistency (mp := mp) (ùìë := ùìë) ùîΩq Œ≤
    stmtIdx oracleIdx h_le stmt wit oStmt
  let badEventExists := badEventExistsProp (œë := œë) ùîΩq Œ≤ oracleIdx
    (challenges := Fin.take (m := oracleIdx) (v := stmt.challenges) (h := by admit /- proof elided -/
    ))
    (oStmt := oStmt)
  localChecks ‚àß (badEventExists ‚à® oracleWitnessConsistency)

@[ext]
structure VectorSpec (n : ‚Ñï) where
  dir : Fin n ‚Üí Direction
  length : Fin n ‚Üí Nat

noncomputable def D_X (rho : ‚Ñö) (n m : ‚Ñï) : ‚Ñù := (m + 1/2) * (Real.sqrt rho) * n

MvPolynomial.monomial in Mathlib.Algebra.MvPolynomial.Basic

instance : Pow (UniPoly R) Nat := ‚ü®UniPoly.pow‚ü©

Finset.Nonempty in Mathlib.Data.Finset.Empty

Fin.natAdd in Init.Data.Fin.Basic

Fin.removeNth in Mathlib.Data.Fin.Tuple.Basic

def relationAfterRandomQuery :
    Set (((StmtAfterRandomQuery R) √ó (‚àÄ i, OStmtAfterRandomQuery R deg i)) √ó Unit) :=
  { ‚ü®‚ü®chal, oStmt‚ü©, _‚ü© | (oStmt (Sum.inr ())).1.eval chal = (oStmt (Sum.inl ())).1.eval chal }

instance instDCastPSigma : DCast ((a : Œ±) √ó' Œ≤ a) (fun a => Œ≥ a.1 a.2) where
  dcast hab c := dcast‚ÇÇ (by admit /- proof elided -/
  ) (by admit /- proof elided -/
  ) c
  dcast_id := by admit /- proof elided -/

@[reducible, inline, specialize]
def OracleMessage (i : pSpec.OracleMessageIdx) := pSpec.Message i.1

instance {k : Fin 1} : Unique (MessagesUpTo k !p[]) where
  default := fun ‚ü®‚ü®i, h‚ü©, _‚ü© => by admit /- proof elided -/

@[inline, reducible]
def lift : OuterStmtIn √ó OuterWitIn ‚Üí InnerStmtOut √ó InnerWitOut ‚Üí OuterStmtOut √ó OuterWitOut :=
  fun ctxIn ctxOut =>
    ‚ü®lens.stmt.toFunB ctxIn.1 ctxOut.1, lens.wit.toFunB ctxIn ctxOut‚ü©

List.IsPrefix in Init.Data.List.Basic

HMul.hMul in Init.Prelude

def partialEval {k : ‚Ñï} (f : MvPolynomial (Fin m) F) (Œ± : Fin k ‚Üí F) (h : k ‚â§ m) :
    MvPolynomial (Fin (m - k)) F :=
  let œÜ : Fin m ‚Üí MvPolynomial (Fin (m - k)) F := fun i =>
    if h' : i.val < k then
      C (Œ± ‚ü®i.val, h'‚ü©)
    else
      let j := i.val - k
      let j' : Fin (m - k) := ‚ü®j, sorry‚ü©
      X j'
  eval‚ÇÇ C œÜ f

def finalSumcheckKStateProp {m : Fin (1 + 1)} (tr : Transcript m (pSpecFinalSumcheckStep (L := L)))
    (stmt : Statement (L := L) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì))
    (witMid : FinalSumcheckWit (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) m)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì) j) : Prop :=
  match m with
  | ‚ü®0, _‚ü© => 
    masterKStateProp ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (mp := BBF_SumcheckMultiplierParam)
      (stmtIdx := Fin.last ‚Ñì) (oracleIdx := Fin.last ‚Ñì) (h_le := le_refl _)
      (stmt := stmt) (wit := witMid) (oStmt := oStmt) (localChecks := True)
  | ‚ü®1, _‚ü© => 
    let tr_so_far := (pSpecFinalSumcheckStep (L := L)).take 1 (by admit /- proof elided -/
    )
    let i_msg0 : tr_so_far.MessageIdx := ‚ü®‚ü®0, by admit /- proof elided -/
    ‚ü©, rfl‚ü©
    let c : L := (ProtocolSpec.Transcript.equivMessagesChallenges (k := 1)
      (pSpec := pSpecFinalSumcheckStep (L := L)) tr).1 i_msg0

    let stmtOut : FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì) := {
      ctx := stmt.ctx,
      sumcheck_target := stmt.sumcheck_target,
      challenges := stmt.challenges,
      final_constant := c
    }

    let sumcheckFinalCheck : Prop := stmt.sumcheck_target = eqTilde r stmt.challenges * c
    let finalFoldingProp := finalNonDoomedFoldingProp ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (h_le := by admit /- proof elided -/
        ) (input := ‚ü®stmtOut, oStmt‚ü©)

    sumcheckFinalCheck ‚àß finalFoldingProp 

def someTypes : List Type := [Nat, String, Nat]

Module.Basis in Mathlib.LinearAlgebra.Basis.Defs

noncomputable def iteratedQuotientMap (i : Fin ‚Ñì) (k : ‚Ñï)
    (h_bound : i.val + k ‚â§ ‚Ñì) (x : (sDomain ùîΩq Œ≤
    h_‚Ñì_add_R_rate) ‚ü®i, by omega‚ü©) :
    (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®i.val + k, by omega‚ü© :=

@[reducible]
def FinalOracleStatement : Fin (k + 2) ‚Üí Type :=
  fun j =>
    if j.1 = k + 1
    then (Unit ‚Üí F[X])
    else (evalDomain D x (‚àë j' ‚àà finRangeTo j.1, s j') ‚Üí F)

noncomputable def mVdecode :
  (smoothCode domain m) ‚Üí‚Çó[F] MvPolynomial (Fin m) F :=
    linearMvExtension.comp decodeLT

def knowledgeStateFunction :
    (oracleVerifier oSpec OStatement).KnowledgeStateFunction init impl
    (relIn OStatement) (relOut OStatement) (rbrExtractor oSpec OStatement) where
  toFun
  | 0 => fun ‚ü®_, oracles‚ü© _ _ => oracles 0 = oracles 1
  | 1 => fun ‚ü®_, oracles‚ü© chal _ =>
    let q : Query OStatement := by admit /- proof elided -/

def Verifier.addSalt (V : Verifier oSpec StmtIn StmtOut pSpec) :
    Verifier oSpec StmtIn StmtOut (pSpec.addSalt Salt) where
  verify := fun stmtIn transcript => V.verify stmtIn transcript.removeSalt

def append (T‚ÇÅ : FullTranscript pSpec‚ÇÅ) (T‚ÇÇ : FullTranscript pSpec‚ÇÇ) :
    FullTranscript (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ) :=
  Fin.happend T‚ÇÅ T‚ÇÇ

def relationRound (i : Fin (n + 1)) :
    Set (((StatementRound R n i) √ó (‚àÄ i, OracleStatement R n deg i)) √ó Unit) :=
  { ‚ü®‚ü®‚ü®target, challenges‚ü©, polyOracle‚ü©, _‚ü© |
    ‚àë x ‚àà (univ.map D) ^·∂† (n - i), (polyOracle ()).val ‚∏®challenges, x‚∏© = target }

def ofNat (n : ‚Ñï) : ValidChurchNat :=
  ‚ü®ChurchNat.ofNat n, n, by admit /- proof elided -/
      ‚ü©

@[reducible, inline, specialize]
def Challenges' (pSpec : ProtocolSpec n) : Type :=
  ‚àÄ i, (hi : pSpec.dir i = .V_to_P) ‚Üí pSpec.¬´Type¬ª i

def completeness (relIn : Set (StmtIn √ó WitIn))
    (relOut : Set (StmtOut √ó WitOut))
    (reduction : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec)
    (completenessError : ‚Ñù‚â•0) : Prop :=
  ‚àÄ stmtIn : StmtIn,
  ‚àÄ witIn : WitIn,
  (stmtIn, witIn) ‚àà relIn ‚Üí
    [fun ‚ü®‚ü®_, (prvStmtOut, witOut)‚ü©, stmtOut‚ü© => (stmtOut, witOut) ‚àà relOut ‚àß prvStmtOut = stmtOut
    | do (simulateQ (impl ++‚Çõ‚Çí challengeQueryImpl : QueryImpl _ (StateT œÉ ProbComp))
          <| reduction.run stmtIn witIn).run' (‚Üê init)] ‚â• 1 - completenessError

def snd (T : (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).Transcript k) : pSpec‚ÇÇ.Transcript ‚ü®k - m, by admit /- proof elided -/
‚ü© :=
  if hk : k ‚â§ m then
    fun i => Fin.elim0 (by admit /- proof elided -/
    )
  else
    fun i => sorry

def InnerStmtIn_Test := ‚Ñ§[X] √ó ‚Ñ§

def proverInput (i : Fin n) : ProverInput
    ((StatementRound R n i.castSucc) √ó (‚àÄ i, OracleStatement R n deg i))
    Unit ((proverState R n deg i).PrvState 0) where
  input := Prod.fst

instance {i : Fin k} : ‚àÄ j, OracleInterface ((pSpec D x s i).Message j)
  | ‚ü®0, h‚ü© => nomatch h
  | ‚ü®1, _‚ü© => by admit /- proof elided -/

List.finRange in Init.Data.List.FinRange

def oracleReduction.sendClaim : OracleReduction oSpec (StmtIn R) (OStmtIn R deg) Unit
    (StmtAfterSendClaim R) (OStmtAfterSendClaim R deg) Unit ‚ü®!v[.P_to_V], !v[R‚¶É‚â§ deg‚¶Ñ[X]]‚ü© := sorry

@[reducible]
noncomputable def batchedFRIreduction [DecidableEq F] :=
  OracleReduction.append
    (BatchingRound.batchOracleReduction D x s d m)
    (liftedFRI D x k s d dom_size_cond l m)

def hcons {n : ‚Ñï} {Œ± : Sort u} {Œ≤ : Fin n ‚Üí Sort u} (a : Œ±) (b : (i : Fin n) ‚Üí Œ≤ i) :
    (i : Fin (n + 1)) ‚Üí Fin.vcons Œ± Œ≤ i :=
  fcons (F := id) a b

AdjoinRoot.root in Mathlib.RingTheory.AdjoinRoot

Classical.typeDecidableEq in Init.Classical

@[reducible, simp]
def StmtOut : Type := R √ó R

@[inline, specialize]
def reduction : Reduction oSpec Statement Unit Statement Unit !p[] where
  prover := prover oSpec Statement
  verifier := verifier oSpec Statement pred

def firstOracleWitnessConsistencyProp (t : MultilinearPoly L ‚Ñì)
    (f‚ÇÄ : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate 0 ‚Üí L) : Prop :=
  let P‚ÇÄ: L[X]_(2 ^ ‚Ñì) := polynomialFromNovelCoeffsF‚ÇÇ ùîΩq Œ≤ ‚Ñì (by admit /- proof elided -/
  ) (fun œâ => t.val.eval œâ)
  
  2 * hammingDist (fun x => P‚ÇÄ.val.eval x.val) f‚ÇÄ < BBF_CodeDistance ‚Ñì ùì° ‚ü®0, by admit /- proof elided -/
  ‚ü©

noncomputable def queryOracleReduction [DecidableEq F] :
  OracleReduction []‚Çí
    (FinalStatement F k) (FinalOracleStatement D x s) (Witness F s d (Fin.last (k + 1)))
    (FinalStatement F k) (FinalOracleStatement D x s) (Witness F s d (Fin.last (k + 1)))
    (pSpec D x l) where
  prover := queryProver D x s d l
  verifier := queryVerifier D x s (round_bound domain_size_cond) l

def pSpecFullNonLastBlock (bIdx : Fin (‚Ñì / œë - 1)) :=
  (pSpecFoldRelaySequence (L:=L) (n:=œë - 1) ++‚Çö
      pSpecFoldCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        ‚ü®‚ÜëbIdx * œë + (œë - 1), by admit /- proof elided -/
          ‚ü©)

def verifyEqOne (n a' : Q(‚Ñï)) (a : Q(ZMod $n)) (_ : Q(($a' : ZMod $n) = $a)) :
    MetaM Q($a ^ ($n - 1) = 1) := do
  let p : Q(ZMod $n) := q($a ^ ($n - 1))
  let .isNat _ c hc ‚Üê Tactic.ReduceModChar.normIntNumeral n p
    q(CommRing.toRing) q(ZMod.charP $n) | failure
  assumeInstancesCommute
  haveI : $p =Q $a ^ ($n - 1) := ‚ü®‚ü©
  haveI : $c =Q 1 := ‚ü®‚ü©
  return q(ZMod.bla $a (.refl _) $hc)

noncomputable def toPoly (p : UniPoly R) : Polynomial R :=
  p.eval‚ÇÇ Polynomial.C Polynomial.X

noncomputable def finalSumcheckVerifier :
  OracleVerifier
    (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì))
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (StmtOut := FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì))
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (pSpec := pSpecFinalSumcheckStep (L := L)) where
  verify := fun stmtIn _ => do
    
    let c : L ‚Üê query (spec := [(pSpecFinalSumcheckStep (L := L)).Message]‚Çí) ‚ü®0, rfl‚ü© ()

    
    let eq_tilde_eval : L := eqTilde (r := stmtIn.ctx.t_eval_point) (r' := stmtIn.challenges)
    unless stmtIn.sumcheck_target = eq_tilde_eval * c do
      return { 
        ctx := {t_eval_point := 0, original_claim := 0},
        sumcheck_target := 0,
        challenges := 0,
        final_constant := 0
      }

    
    let stmtOut : FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì) := {
      ctx := stmtIn.ctx,
      sumcheck_target := eq_tilde_eval * c, 
      challenges := stmtIn.challenges,
      final_constant := c
    }
    pure stmtOut

  embed := ‚ü®fun j => by admit /- proof elided -/
  ‚ü©
  hEq := fun oracleIdx => by admit /- proof elided -/

instance : NeZero (2^3) := ‚ü®by admit /- proof elided -/
‚ü©

abbrev rdrop (m : ‚Ñï) (h : m ‚â§ n)
    (transcript : FullTranscript pSpec) : FullTranscript (pSpec.rdrop m h) :=
  Fin.rdrop m h transcript

def InnerStmtOut_Test := ‚Ñ§[X] √ó ‚Ñ§ √ó ‚Ñ§

def foldingBadEvent (i : Fin ‚Ñì) (steps : ‚Ñï) [NeZero steps] (h_i_add_steps : i + steps ‚â§ ‚Ñì)
  (f_i : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i, by admit /- proof elided -/
  ‚ü©)
  (challenges : Fin steps ‚Üí L) : Prop :=
  let d_i_plus_steps := BBF_CodeDistance ‚Ñì ùì° ‚ü®i + steps, by admit /- proof elided -/
  ‚ü©
  if h_is_close : 2 * fiberwiseDistance ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := i)
      steps h_i_add_steps f_i < (d_i_plus_steps : ‚Ñï‚àû) then
    
    
    
    let h_dist_curr_lt := fiberwise_dist_lt_imp_dist_lt_unique_decoding_radius ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := i) (steps := steps) h_i_add_steps f_i h_is_close

    let f_bar_i := uniqueClosestCodeword ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (i := ‚ü®i, by admit /- proof elided -/
      ‚ü©) (h_i := by admit /- proof elided -/
      ) f_i
      h_dist_curr_lt
    let folded_f_i := iterated_fold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (steps := ‚ü®steps, by admit /- proof elided -/
      ‚ü©) (i := ‚ü®i, by admit /- proof elided -/
      ‚ü©)
      (h_i_add_steps := by admit /- proof elided -/
      ) f_i challenges
    let folded_f_bar_i := iterated_fold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (steps := ‚ü®steps, by admit /- proof elided -/
      ‚ü©) (i := ‚ü®i, by admit /- proof elided -/
      ‚ü©)
      (h_i_add_steps := by admit /- proof elided -/
      ) f_bar_i challenges

    let fiberwise_disagreements := fiberwiseDisagreementSet ùîΩq Œ≤ i steps h_i_add_steps
      f_i f_bar_i
    let folded_disagreements := disagreementSet ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i steps
      h_i_add_steps folded_f_i folded_f_bar_i
    
    ¬¨ (fiberwise_disagreements ‚äÜ folded_disagreements)
  else
    
    
    
    let folded_f_i := iterated_fold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (steps := ‚ü®steps, by admit /- proof elided -/
      ‚ü©) (i := ‚ü®i, by admit /- proof elided -/
      ‚ü©)
      (h_i_add_steps := by admit /- proof elided -/
      ) f_i challenges
    let dist_to_code := distFromCode folded_f_i
      (BBF_Code ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i + steps, by admit /- proof elided -/
      ‚ü©)
    2 * dist_to_code < (d_i_plus_steps : ‚Ñï‚àû)

def forwardRange (n : ‚Ñï) (r : Fin (n)) (l : Fin (r.val + 1)) : List (Fin n) :=
  let len := r.val - l.val + 1
  List.ofFn (fun (k : Fin len) =>
    let val := l.val + k.val
    have h_bound : val < n := by admit /- proof elided -/
  )

def minDist [DecidableEq F] (IC : MatrixSubmodule Œ∫ Œπ F) : ‚Ñï :=
  sInf { d : ‚Ñï | ‚àÉ U ‚àà IC, ‚àÉ V ‚àà IC, distCodewords U V = d }

List.cons in Init.Prelude

OfNat in Init.Prelude

def params16 : Params where
  width := 16
  numFullRounds := 8
  numPartialRounds := 20
  internalDiagVectors := #v[
       -2,
        1,
        2,
        1 / 2,
        3,
        4,
        -1 / 2,
        -3,
        -4,
        1 / (2 ^ 8),
        1 / 8,
        1 / (2 ^ 24),
        -1 / (2 ^ 8),
        -1 / 8,
        -1 / 16,
        -1 / (2 ^ 24),
    ]
  roundConstants := rawConstants16
  width_dvd_by_4 := by admit /- proof elided -/

instance : SliceGE (ProtocolSpec n) ‚Ñï
    (fun _ start => start ‚â§ n)
    (fun _ start _ => ProtocolSpec (n - start))
    where
  sliceGE := fun v start h => drop start h v

def churchRecNat {Œ≤ : Type} (n : ChurchNat ‚Ñï) (step : Œ≤ ‚Üí Œ≤) (base : Œ≤) : Œ≤ :=
  Nat.iterate step (ChurchNat.toNat n) base

def implGroupEqOracle [BEq G] :
    QueryImpl (GroupEqOracle Œπ) (StateT (GroupValTable Œπ G) Option) where
  impl | query _ ‚ü®i, j‚ü© => fun table =>
    match table i, table j with
    | some g‚ÇÅ, some g‚ÇÇ => some (g‚ÇÅ == g‚ÇÇ, table)
    | _, _ => none

def parametrisedCurve {l : ‚Ñï} [Semiring F] (u : Fin l ‚Üí Œπ ‚Üí F) : Set (Œπ ‚Üí F)
  := {v | ‚àÉ r : F, v = ‚àë i : Fin l, (r ^ (i : ‚Ñï)) ‚Ä¢ u i}

inductive Lit where
  | scalar (val : F)
  
  
  | vector (len : Nat) (v : Fin len ‚Üí F)

def getMiddleBits (offset len n : ‚Ñï) : ‚Ñï :=
  getLowBits (numLowBits:=len) (n:=n >>> offset)

IO.FS.readFile in Init.System.IO

def natWeightedDegree.{u} {F : Type u} [Semiring F] (f : F[X][Y]) (u v : ‚Ñï) : ‚Ñï :=
  f.support.sup (fun m => u * (f.coeff m).natDegree + v * m)

def rbrKnowledgeSoundness (relIn : Set (StmtIn √ó WitIn)) (relOut : Set (StmtOut √ó WitOut))
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    (rbrKnowledgeError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) : Prop :=
  ‚àÉ WitMid : Fin (n + 1) ‚Üí Type,
  ‚àÉ extractor : Extractor.RoundByRound oSpec StmtIn WitIn WitOut pSpec WitMid,
  ‚àÉ kSF : verifier.KnowledgeStateFunction init impl relIn relOut extractor,
  ‚àÄ stmtIn : StmtIn,
  ‚àÄ witIn : WitIn,
  ‚àÄ prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec,
  ‚àÄ i : pSpec.ChallengeIdx,
    [fun ‚ü®transcript, challenge, _proveQueryLog‚ü© =>
      ‚àÉ witMid,
        ¬¨ kSF i.1.castSucc stmtIn transcript
          (extractor.extractMid i.1 stmtIn (transcript.concat challenge) witMid) ‚àß
          kSF i.1.succ stmtIn (transcript.concat challenge) witMid
    | do
      (simulateQ (impl ++‚Çõ‚Çí challengeQueryImpl : QueryImpl _ (StateT œÉ ProbComp))
        (do
          let ‚ü®‚ü®transcript, _‚ü©, proveQueryLog‚ü© ‚Üê prover.runWithLogToRound i.1.castSucc stmtIn witIn
          let challenge ‚Üê liftComp (pSpec.getChallenge i) _
          return (transcript, challenge, proveQueryLog))).run' (‚Üê init)] ‚â§
      rbrKnowledgeError i

def mul (a b : AssocNat) : AssocNat :=
  mulNat a b.toNat

class IsSecureWithGap
    (completeRelation : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (soundRelation : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (Œµ_rbr : vPSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0)
    (vectorIOP : VectorIOP Statement OStatement Witness vPSpec A) where

   
  is_complete : vectorIOP.perfectCompleteness (pure ()) ‚ü®isEmptyElim‚ü© completeRelation

   
  is_rbr_knowledge_sound :
    OracleProof.rbrKnowledgeSoundness (pure ()) ‚ü®isEmptyElim‚ü© soundRelation vectorIOP.verifier Œµ_rbr

def forwardPermutationOracleImpl {Œ± : Type*} [Permute Œ±] :
    QueryImpl (forwardPermutationOracle Œ±) Id where
  impl | query () q => Permute.permute (Œ± := Œ±) q

@[reducible]
def reduction : Reduction oSpec
    (StatementRound R n 0 √ó ‚àÄ i, OracleStatement R n deg i) Unit
    (StatementRound R n (.last n) √ó ‚àÄ i, OracleStatement R n deg i) Unit
    (pSpec R deg n) :=
  Reduction.seqCompose (oSpec := oSpec)
    (Stmt := fun i => StatementRound R n i √ó (‚àÄ j, OracleStatement R n deg j))
    (Wit := fun _ => Unit)
    (pSpec := fun _ => SingleRound.pSpec R deg)
    (SingleRound.reduction R n deg D oSpec)

instance instDCast‚ÇÉ : DCast‚ÇÉ Nat (fun n => Fin (n + 1)) (fun n _ => ProtocolSpec n)
    (fun _ k pSpec => pSpec.Transcript k) where
  dcast‚ÇÉ h h' h'' T := Transcript.cast h
    (by admit /- proof elided -/
    )
    (by admit /- proof elided -/
    )
    T
  dcast‚ÇÉ_id := cast_id

def StateRestoration.Soundness (oSpec : OracleSpec Œπ) (StmtIn : Type)
    {n : ‚Ñï} (pSpec : ProtocolSpec n) :=
  OracleComp (oSpec ++‚Çí (srChallengeOracle StmtIn pSpec)) (StmtIn √ó pSpec.Messages)

noncomputable def P
  (Œ¥ : ‚Ñö) (x‚ÇÄ : F)
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  :
  F[Z][X] :=
  let v‚ÇÄ := Classical.choose (solution_gamma_is_linear_in_Z k (Œ¥ := Œ¥) (x‚ÇÄ := x‚ÇÄ) h_gs)
  let v‚ÇÅ := Classical.choose 
    (Classical.choose_spec <| solution_gamma_is_linear_in_Z k (Œ¥ := Œ¥) (x‚ÇÄ := x‚ÇÄ) h_gs)
  (
    (Polynomial.map Polynomial.C v‚ÇÄ) +
    (Polynomial.C Polynomial.X) * (Polynomial.map Polynomial.C v‚ÇÅ)
  )

instance : Slice (ProtocolSpec n) ‚Ñï ‚Ñï
    (fun _ start stop => start ‚â§ stop ‚àß stop ‚â§ n)
    (fun _ start stop _ => ProtocolSpec (stop - start))
    where
  slice := fun v start stop h => extract start stop h.1 h.2 v

instance : Serialize UInt8 ByteArray where
  serialize byte := ByteArray.mk #[byte]

@[reducible]
def pSpec : ProtocolSpec 1 := ‚ü®!v[.P_to_V], !v[OStatement default]‚ü©

noncomputable def finalSumcheckProver :
  OracleProver
    (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì))
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì))
    (StmtOut := FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì))
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (WitOut := Unit)
    (pSpec := pSpecFinalSumcheckStep (L := L)) where
  PrvState := fun
    | 0 => Statement (L := L) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì) √ó (‚àÄ j, OracleStatement ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì) j)
        √ó Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì)
    | _ => Statement (L := L) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì) √ó (‚àÄ j, OracleStatement ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì) j)
        √ó Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì) √ó L
  input := fun ‚ü®‚ü®stmt, oStmt‚ü©, wit‚ü© => (stmt, oStmt, wit)

  sendMessage
  | ‚ü®0, _‚ü© => fun ‚ü®stmtIn, oStmtIn, witIn‚ü© => do
    let f‚Ñì : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := ‚ü®‚Ñì, by admit /- proof elided -/
    ‚ü©)
      := witIn.f
    
    let c : L := f‚Ñì ‚ü®0, by admit /- proof elided -/
    ‚ü© 
    pure ‚ü®c, (stmtIn, oStmtIn, witIn, c)‚ü©

  receiveChallenge
  | ‚ü®0, h‚ü© => nomatch h 

  output := fun ‚ü®stmtIn, oStmtIn, witIn, c‚ü© => do
    let stmtOut : FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì) := {
      ctx := stmtIn.ctx,
      
      sumcheck_target := stmtIn.sumcheck_target,
      challenges := stmtIn.challenges,
      final_constant := c
    }

    pure (‚ü®stmtOut, oStmtIn‚ü©, ())

noncomputable def batchOracleReduction :
  OracleReduction []‚Çí
    Unit (OracleStatement D x m) (Witness F s d m)
    ((Fin m ‚Üí F) √ó Fri.Spec.Statement F (0 : Fin (k + 1)))
    (OracleStatement D x m)
    (Fri.Spec.Witness F s d (0 : Fin (k + 2)))
    (batchSpec F m) where
  prover := batchProver D x s d m
  verifier := batchVerifier (k := k) D x m

def numQueries (stmt : StmtIn) (challenges : ‚àÄ i, pSpec.Challenge i)
    (verifier : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec) :
  OracleComp (oSpec ++‚Çí ([OStmtIn]‚Çí ++‚Çí [pSpec.Message]‚Çí)) ‚Ñï := sorry

def proximityChecksSpec (Œ≥_challenges :
    Fin Œ≥_repetitions ‚Üí sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®0, by omega‚ü©)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì) j)
    (fold_challenges : Fin ‚Ñì ‚Üí L) (final_constant : L) : Prop :=
  ‚àÄ rep : Fin Œ≥_repetitions,
    let v := Œ≥_challenges rep
    -- For all folding levels k = 0, ..., ‚Ñì/œë - 1, we track c_cur through the iterations
    ‚àÄ k_val : Fin (‚Ñì / œë),
      let i := k_val.val * œë
      have h_k: k_val ‚â§ (‚Ñì/œë - 1) := by omega
      have h_i_add_œë_le_‚Ñì : i + œë ‚â§ ‚Ñì := by
        calc i + œë = k_val * œë + œë := by omega
          _ ‚â§ (‚Ñì/œë - 1) * œë + œë := by
            apply Nat.add_le_add_right; apply Nat.mul_le_mul_right; omega
          _ = ‚Ñì/œë * œë :=

def finUInt16Equiv : Fin (2 ^ 16) ‚âÉ UInt16 where
  toFun := fun i => UInt16.ofFin i
  invFun := fun u => u.toFin
  left_inv _ := rfl
  right_inv _ := rfl

FreeMonad in ToMathlib.Control.Monad.Free

@[inline, specialize]
def mulX (p : UniPoly R) : UniPoly R := p.mulPowX 1

def commitKStateProp (i : Fin ‚Ñì) (m : Fin (1 + 1))
  (stmtIn : Statement (L := L) Context i.succ)
  (witMid : Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
  (oStmtIn : (i_1 : Fin (toOutCodewordsCount ‚Ñì œë i.castSucc)) ‚Üí
    OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc i_1)
  : Prop :=

  match m with
  | ‚ü®0, _‚ü© => 
    masterKStateProp (mp := mp) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (stmtIdx := i.succ) (oracleIdx := i.castSucc)
      (h_le := by admit /- proof elided -/
      )
      (stmt := stmtIn) (wit := witMid) (oStmt := oStmtIn)
      (localChecks := True)
  | ‚ü®1, _‚ü© => 
    let ‚ü®_, stmtOut, oStmtOut, witOut‚ü© := getCommitProverFinalOutput ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i ‚ü®stmtIn, oStmtIn, witMid‚ü©
    masterKStateProp (mp := mp) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (stmtIdx := i.succ) (oracleIdx := i.succ)
      (h_le := le_refl _)
      (stmt := stmtOut) (wit := witOut) (oStmt := oStmtOut)
      (localChecks := True)

Function.RightInverse in Init.Data.Function

Polynomial.degreeLTEquiv in Mathlib.RingTheory.Polynomial.Basic

@[reducible, inline]
instance (priority := low) instTensorForall {Œπ : Type u} (v : Œπ ‚Üí Type v)
    [O : ‚àÄ i, OracleInterface (v i)] : OracleInterface (‚àÄ i, v i) where
  Query := (i : Œπ) ‚Üí (O i).Query
  Response := (i : Œπ) ‚Üí (O i).Response
  answer := fun f q i => (O i).answer (f i) (q i)

@[reducible]
def StateRestoration.KnowledgeSoundness (oSpec : OracleSpec Œπ)
    (StmtIn : Type) {Œπ‚Çõ·µ¢ : Type} (OStmtIn : Œπ‚Çõ·µ¢ ‚Üí Type) (WitOut : Type)
    {n : ‚Ñï} {pSpec : ProtocolSpec n} :=
  Prover.StateRestoration.KnowledgeSoundness oSpec (StmtIn √ó (‚àÄ i, OStmtIn i)) WitOut pSpec

OracleComp.uniformOfFintype in VCVio.OracleComp.Constructions.UniformSelect

def buildMerkleTree_with_hash {s} (leaf_tree : LeafData Œ± s) (hashFn : Œ± ‚Üí Œ± ‚Üí Œ±) :
    (FullData Œ± s) :=
  match leaf_tree with
  | LeafData.leaf a => FullData.leaf a
  | LeafData.internal left right =>
    let leftTree := buildMerkleTree_with_hash left hashFn
    let rightTree := buildMerkleTree_with_hash right hashFn
    let rootHash := hashFn (leftTree.getRootValue) (rightTree.getRootValue)
    FullData.internal rootHash leftTree rightTree

tail in ToMathlib.Control.Comonad.Instances

def ratchetUnchecked [Permute C] (sponge : DuplexSponge U C) : DuplexSponge U C :=
  simulateQ' forwardPermutationOracleImpl (ratchet sponge) (by admit /- proof elided -/
  )

noncomputable def novelToMonomialCoeffs

  (‚Ñì : ‚Ñï) (h_‚Ñì : ‚Ñì ‚â§ r) (novel_coeffs : Fin (2 ^ ‚Ñì) ‚Üí L) : Fin (2^‚Ñì) ‚Üí L :=
  let A := changeOfBasisMatrix ùîΩq Œ≤ ‚Ñì h_‚Ñì
  Matrix.vecMul novel_coeffs A

Real in Mathlib.Data.Real.Basic

Cardinal in Mathlib.SetTheory.Cardinal.Defs

Fin.init in Mathlib.Data.Fin.Tuple.Basic

def liftLeftNil {Œπ : Type} {œÉ : Type} (oSpec : OracleSpec Œπ) :
    SimOracle.Stateful ([]‚Çí ++‚Çí oSpec) oSpec œÉ where impl
  | query (.inr i) q => fun s ‚Ü¶ do return ‚ü®‚Üê query i q, s‚ü©

@[reducible] def Proof {Œπ : Type} (oSpec : OracleSpec Œπ)
    (Statement Witness : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n) :=
  Reduction oSpec Statement Witness Bool Unit pSpec

def InternalData.leftSubtree {Œ± : Type} {s_left s_right : Skeleton}
    (tree : InternalData Œ± (Skeleton.internal s_left s_right)) :
    InternalData Œ± s_left :=
  match tree with
  | InternalData.internal _ left _right =>
    left

repr in Init.Data.Repr

MonomialOrder.lex in Mathlib.Data.Finsupp.MonomialOrder

def deterministicMillerRabin (n : ‚Ñï) : Bool := Id.run do
  if n ‚â§ 2 ‚à® n % 2 = 0 then
    return n = 2

  let ‚ü®s, d‚ü© := factorOutTwos (n - 1)
  for a in millerRabinBases do
    if a % n == 0 then
      continue

    let mut x := powMod a d n
    if x = 1 ‚à® x = n - 1 then
      continue

    for _ in [0:s] do
      x := (x * x) % n
      if x == n - 1 ‚à® x ‚â§ 1 then
        break
    if x ‚â† n - 1 then
      return false

  return true

RingHom.toAlgebra in Mathlib.Algebra.Algebra.Defs

def toOracleImpl {Œπ : Type u} (v : Œπ ‚Üí Type v) [O : ‚àÄ i, OracleInterface (v i)]
    (data : ‚àÄ i, v i) : QueryImpl [v]‚Çí Id where
  impl | query i t => (O i).answer (data i) t

instance {k : ‚Ñï} : Mul (ConcreteBTField k) where
  mul := concrete_mul

def perm (cs : ConstraintSystem ùì° numWires numGates) : Equiv.Perm (Fin (3 * numGates)) := sorry

FreeMonad.roll in ToMathlib.Control.Monad.Free

def trans (eqv : Equiv pSpec pSpec') (eqv' : Equiv pSpec' pSpec'') : Equiv pSpec pSpec'' where
  round_eq := eqv.round_eq.trans eqv'.round_eq
  dir_eq := fun i => by admit /- proof elided -/

def twoAdicGenerators : List Field :=
  [
    (0x1 : Field),
    (0x7F000000 : Field),
    (0x7E010002 : Field),
    (0x6832FE4A : Field),
    (0x8DBD69C : Field),
    (0xA28F031 : Field),
    (0x5C4A5B99 : Field),
    (0x29B75A80 : Field),
    (0x17668B8A : Field),
    (0x27AD539B : Field),
    (0x334D48C7 : Field),
    (0x7744959C : Field),
    (0x768FC6FA : Field),
    (0x303964B2 : Field),
    (0x3E687D4D : Field),
    (0x45A60E61 : Field),
    (0x6E2F4D7A : Field),
    (0x163BD499 : Field),
    (0x6C4A8A45 : Field),
    (0x143EF899 : Field),
    (0x514DDCAD : Field),
    (0x484EF19B : Field),
    (0x205D63C3 : Field),
    (0x68E7DD49 : Field),
    (0x6AC49F88 : Field)
  ]

class PrimeOrder (G : Type*) [Group G] where
  p : ‚Ñï
  [hPrime : Fact (Nat.Prime p)]
  hCard : Nat.card G = p

def backwardPermutationOracleImpl {Œ± : Type*} [Permute Œ±] [LawfulPermute Œ±] :
    QueryImpl (backwardPermutationOracle Œ±) Id where
  impl | query () q => LawfulPermute.permuteInv (Œ± := Œ±) q

@[inline, specialize]
def oracleProver : OracleProver oSpec
    Statement OStatement (‚àÄ i, Witness i)
    Statement (OStatement ‚äï·µ• Witness) Unit
    (oraclePSpec Witness) where
  PrvState := fun _ => (Statement √ó (‚àÄ i, OStatement i)) √ó (‚àÄ i, Witness i)
  input := id
  sendMessage | ‚ü®0, _‚ü© => fun ‚ü®stmt, wit‚ü© => pure (wit, ‚ü®stmt, wit‚ü©)
  
  receiveChallenge | ‚ü®0, h‚ü© => nomatch h
  output := fun ‚ü®‚ü®stmt, oStmt‚ü©, wit‚ü© => pure (‚ü®stmt, Sum.rec oStmt wit‚ü©, ())

commit in VCVio.CryptoFoundations.SigmaAlg

def OracleReduction.toReduction {Œπ : Type} {oSpec : OracleSpec Œπ}
    {StmtIn : Type} {Œπ‚Çõ·µ¢ : Type} {OStmtIn : Œπ‚Çõ·µ¢ ‚Üí Type} {WitIn : Type}
    {StmtOut : Type} {Œπ‚Çõ‚Çí : Type} {OStmtOut : Œπ‚Çõ‚Çí ‚Üí Type} {WitOut : Type}
    {n : ‚Ñï} {pSpec : ProtocolSpec n}
    [O‚Çõ·µ¢ : ‚àÄ i, OracleInterface (OStmtIn i)] [O‚Çò : ‚àÄ i, OracleInterface (pSpec.Message i)]
    (oracleReduction : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec) :
      Reduction oSpec (StmtIn √ó (‚àÄ i, OStmtIn i)) WitIn
        (StmtOut √ó (‚àÄ i, OStmtOut i)) WitOut pSpec :=
  ‚ü®oracleReduction.prover, oracleReduction.verifier.toVerifier‚ü©

def LeafData.get {s} {Œ± : Type}
    (tree : LeafData Œ± s) (idx : SkeletonLeafIndex s) : Œ± :=
  match tree, idx with
  | LeafData.leaf value, SkeletonLeafIndex.ofLeaf => value
  | LeafData.internal left _, SkeletonLeafIndex.ofLeft idxLeft =>
    LeafData.get left idxLeft
  | LeafData.internal _ right, SkeletonLeafIndex.ofRight idxRight =>
    LeafData.get right idxRight

protected def OracleReduction.id :
    OracleReduction oSpec Statement OStatement Witness Statement OStatement Witness !p[] :=
  ‚ü®OracleProver.id, OracleVerifier.id‚ü©

alias Prover.trivial := Prover.id
alias Verifier.trivial := Verifier.id
alias Reduction.trivial := Reduction.id
alias OracleProver.trivial := OracleProver.id
alias OracleVerifier.trivial := OracleVerifier.id
alias OracleReduction.trivial := OracleReduction.id

@[reducible, simp]
def relOut : Set ((StmtOut OStatement √ó ‚àÄ i, OStmtOut OStatement i) √ó WitOut) :=
  { ‚ü®‚ü®q, oStmt‚ü©, ()‚ü© | answer (oStmt 0) q = answer (oStmt 1) q }

def halfNumFullRounds : Nat := params.numFullRounds / 2

HomogeneousPow in Init.Prelude

def perfectCompleteness (relIn : Set (StmtIn √ó WitIn)) (relOut : Set (StmtOut √ó WitOut))
    (reduction : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec) : Prop :=
  completeness init impl relIn relOut reduction 0

def d (B : Finset (Fin n ‚Üí F)) : ‚Ñö :=
  (1 : ‚Ñö)/(2 * choose_2 B.card) * ‚àë x ‚àà (Finset.product B B) with x.1 ‚â† x.2, Œî‚ÇÄ(x.1, x.2)

DecidableRel in Init.Prelude

@[reducible, simp]
def MessageIdxUpTo (k : Fin (n + 1)) (pSpec : ProtocolSpec n) : Type :=
  (pSpec‚ü¶:k.val‚üß).MessageIdx

@[reducible]
def get {Œ±s : List (Type u)} : HList Œ±s ‚Üí (n : Fin Œ±s.length) ‚Üí Œ±s.get n
  | x ::‚Çï _, ‚ü®0, _‚ü© => x
  | _ ::‚Çï xs, ‚ü®n+1, h‚ü© => xs.get ‚ü®n, Nat.lt_of_succ_lt_succ h‚ü©

Fin.modNat in Batteries.Data.Fin.Basic

structure InterleavedCode (Œ∫ Œπ : Type*) [Fintype Œ∫] [Fintype Œπ] (F : Type*) [Semiring F] where
  MF : MatrixSubmodule Œ∫ Œπ F
  LC : LinearCode Œπ F

def BBF_Code (i : Fin (‚Ñì + 1)) : Submodule L ((sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate)
    ‚ü®i, by admit /- proof elided -/
        ‚ü© ‚Üí L) :=
  let domain : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®i, by admit /- proof elided -/
  ‚ü© ‚Ü™ L :=
    ‚ü®fun x => x.val, fun x y h => by admit /- proof elided -/
    ‚ü©
  ReedSolomon.code (domain := domain) (deg := 2^(‚Ñì - i.val))

def implGroupOpOracle : QueryImpl (GroupOpOracle Œπ) (StateT (GroupValTable Œπ G) Option) where
  impl | query _ ‚ü®i, j, k‚ü© => fun table =>
    match table i, table j with
    | some g‚ÇÅ, some g‚ÇÇ => some ((), table.update k (some (g‚ÇÅ * g‚ÇÇ)))
    | _, _ => none

def distToCode [DecidableEq F] (U : Matrix Œ∫ Œπ F) (IC : MatrixSubmodule Œ∫ Œπ F) : ‚Ñï :=
 sInf { d : ‚Ñï | ‚àÉ V ‚àà IC, distCodewords U V = d }

Decidable in Init.Prelude

Vector.finRange in Init.Data.Vector.FinRange

structure Selector (ùì° : Type*) where
   
  qL : ùì°
   
  qR : ùì°
   
  qO : ùì°
   
  qM : ùì°
   
  qC : ùì°
deriving DecidableEq

@[reducible, simp]
def knowledgeSoundness
    (relation : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (verifier : OracleVerifier oSpec Statement OStatement Bool (fun _ : Empty => Unit) pSpec)
    (knowledgeError : ‚Ñù‚â•0) : Prop :=
  verifier.toVerifier.knowledgeSoundness init impl relation acceptRejectOracleRel knowledgeError

@[reducible, inline, specialize]
def getChallenge (pSpec : ProtocolSpec n) (i : pSpec.ChallengeIdx) :
    OracleComp ([pSpec.Challenge]‚Çí'challengeOracleInterface) (pSpec.Challenge i) :=
  (query i () : OracleQuery ([pSpec.Challenge]‚Çí'challengeOracleInterface) (pSpec.Challenge i))

VAdd in Mathlib.Algebra.Notation.Defs

instance [ProverFirst pSpec] [h : OracleInterface (pSpec.¬´Type¬ª 0)] :
    ‚àÄ i, OracleInterface (pSpec.Message i)
  | ‚ü®0, _‚ü© => inferInstance

def OracleProver.addSalt (P : OracleProver oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec)
    (saltComp : (i : pSpec.MessageIdx) ‚Üí P.PrvState i.1.castSucc ‚Üí OracleComp oSpec (Salt i)) :
  OracleProver oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut (pSpec.addSalt Salt) :=
  Prover.addSalt Salt P saltComp

@[reducible, inline, specialize, simp]
def Challenge (pSpec : ProtocolSpec n) (i : ChallengeIdx pSpec) := pSpec.¬´Type¬ª i.val

def addUnits (state : FSProverState U H R) (input : Array U) :
    Except DomainSeparatorMismatch (FSProverState U H R) :=
  match state.hashState.absorb input with
  | .ok newHashState =>
    
    
    .ok { rng := state.rng, hashState := newHashState, nargString := state.nargString }
  | .error e => .error e

instance : HListRepr (HList []) where
  repr := fun _ => ""

Polynomial.sum in Mathlib.Algebra.Polynomial.Basic

@[reducible, simp] def WitIn := Unit

instance : Inhabited (UniPolyC R) := ‚ü®#[], Trim.canonical_empty‚ü©

Algebra.TensorProduct.instCommSemiring in Mathlib.RingTheory.TensorProduct.Basic

@[to_additive existing]
def partialProd {Œ± : Type*} [Monoid Œ±] (l : List Œ±) : List Œ± :=
  [1] ++ match l with
  | [] => []
  | a :: l' => (partialProd l').map (a * ¬∑)

structure ConcreteBTFDivisionRingProps (k : ‚Ñï) extends (ConcreteBTFRingProps k) where
  
  mul_inv_cancel : ‚àÄ a : ConcreteBTField k, a ‚â† zero ‚Üí concrete_mul a (concrete_inv a) = one

instance : LawfulToNat Nat where
  toNat_zero := rfl
  toNat_succ := fun _ => rfl

def multiConstrainedCode
  (domain : Œπ ‚Ü™ F) [Smooth domain] (m t : ‚Ñï)
  (w : Fin t ‚Üí MvPolynomial (Fin (m + 1)) F)
  (œÉ : Fin t ‚Üí F) : Set (Œπ ‚Üí F) :=
    { f |
      ‚àÉ (h : f ‚àà smoothCode domain m),
        ‚àÄ i : Fin t, weightConstraint (mVdecode (‚ü®f, h‚ü© : smoothCode domain m)) (w i) (œÉ i)}

structure KnowledgeStateFunctionOneShot
    (langIn : Set StmtIn) (langOut : Set StmtOut)
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    where
  toFun : (m : Fin (n + 1)) ‚Üí StmtIn ‚Üí Transcript m pSpec ‚Üí Prop
   
  toFun_empty : ‚àÄ stmtIn, ¬¨ toFun 0 stmtIn default
   
  toFun_next : ‚àÄ m, pSpec.dir m = .P_to_V ‚Üí
    ‚àÄ stmt tr msg, ¬¨ toFun m.castSucc stmt tr ‚Üí ¬¨ toFun m.succ stmt (tr.concat msg)
   
  toFun_full : ‚àÄ stmt tr, ¬¨ toFun (.last n) stmt tr ‚Üí
    [(¬∑ ‚àà langOut) | do (simulateQ impl (verifier.run stmt tr)).run' (‚Üê init)] = 0

Subtype.mk in Init.Prelude

def binaryFinMapToNat {n : ‚Ñï} (m : Fin n ‚Üí ‚Ñï) (h_binary : ‚àÄ j: Fin n, m j ‚â§ 1) : Fin (2^n) :=

def erase_odd (s : Finset ‚Ñï) : Finset ‚Ñï := s.filter Even

HAdd in Init.Prelude

noncomputable def toMLE (A : Matrix (Fin (2 ^ m)) (Fin (2 ^ n)) R) : R[X Fin n][X Fin m] :=
  MLE' (MLE' ‚àò A)

@[inline, reducible]
def proj : OuterStmtIn √ó OuterWitIn ‚Üí InnerStmtIn √ó InnerWitIn :=
  fun ctxIn => ‚ü®lens.stmt.toFunA ctxIn.1, lens.wit.toFunA ctxIn‚ü©

Mathlib.Meta.NormNum.IsNat in Mathlib.Tactic.NormNum.Result

Algebra.TensorProduct.includeLeftRingHom in Mathlib.RingTheory.TensorProduct.Basic

instance : ‚àÄ j, OracleInterface (FinalOracleStatement D x s j) :=
  fun j =>
    if h : j = k + 1
    then {
           Query := Unit
           Response := F[X]
           answer := cast (by admit /- proof elided -/
           )
                          (id (Œ± := Unit ‚Üí F[X]))
         }
    else {
           Query :=
            ‚Üë(
              evalDomain D x
              (‚àë j' ‚àà finRangeTo j.1, s j')
            )
           Response := F
           answer := cast (by admit /- proof elided -/
           )
                          (id (Œ± := ‚Üë(evalDomain D x (‚àë j' ‚àà finRangeTo j.1, s j')) ‚Üí F))
         }

def Prover.addSalt (P : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec)
    (saltComp : (i : pSpec.MessageIdx) ‚Üí P.PrvState i.1.castSucc ‚Üí OracleComp oSpec (Salt i)) :
  Prover oSpec StmtIn WitIn StmtOut WitOut (pSpec.addSalt Salt) where
  PrvState := P.PrvState
  input := P.input
  sendMessage := fun i st => by admit /- proof elided -/

Rat in Init.Data.Rat.Basic

def binary_tower_inductive_step
  (k : Nat)
  (prevBTField : Type _) [Field prevBTField]
  (prevBTResult : BinaryTowerResult prevBTField k)
: Œ£' (F : Type _), BinaryTowerInductiveStepResult (k:=k) (prevBTField:=prevBTField)
  (prevBTResult:=prevBTResult) (prevPoly:=definingPoly (F:=prevBTField)
    (instField:=prevBTResult.instField) (s:=prevBTResult.specialElement)) (F:=F)
  (instPrevBTFieldIsField:=prevBTResult.instField) :=

def instTestLensKnowledgeSound : testLensE.IsKnowledgeSound
      outerRelIn_Test innerRelIn_Test outerRelOut_Test innerRelOut_Test
      (fun ‚ü®p, q, _‚ü© ‚ü®f, _‚ü© => p * q = f) (fun _ _ => True) where
  proj_knowledgeSound := fun ‚ü®p, q, t‚ü© ‚ü®f, t', r‚ü© _ h h' => by admit /- proof elided -/

Finset.map in Mathlib.Data.Finset.Image

instance [ProverFirst pSpec] : Unique (pSpec.MessageIdx) where
  default := ‚ü®0, by admit /- proof elided -/
  ‚ü©
  uniq := fun ‚ü®i, _‚ü© => by admit /- proof elided -/

QueryImpl in VCVio.OracleComp.SimSemantics.SimulateQ

@[reducible, inline, specialize]
def UniPoly (R : Type*) := Array R

noncomputable def Œ¥_Œµ_proximityGap {Œ± : Type} [DecidableEq Œ±] [Nonempty Œ±]
  (P : Finset (Œπ ‚Üí Œ±)) (C : Set (Finset (Œπ ‚Üí Œ±))) (Œ¥ Œµ : ‚Ñù‚â•0) : Prop :=
  ‚àÄ S ‚àà C, ‚àÄ [Nonempty S],
  Xor'
  ( Pr_{let x ‚Üê $·µñ S}[Code.relHammingDistToCode x.1 P ‚â§ Œ¥] = 1 )
  ( Pr_{let x ‚Üê $·µñ S}[Code.relHammingDistToCode x.1 P ‚â§ Œ¥] ‚â§ Œµ )

structure BerlekampWelchCondition (e k : ‚Ñï) (œâs f : Fin n ‚Üí F) (E Q : Polynomial F) : Prop where
  cond: ‚àÄ i : Fin n, Q.eval (œâs i) = (f i) * E.eval (œâs i)
  E_natDegree : E.natDegree = e
  E_leadingCoeff : E.coeff e = 1
  Q_natDegree : Q.natDegree ‚â§ e + k - 1

Nat.mod in Init.Prelude

def shift_left (s : Finset ‚Ñï) : Finset ‚Ñï :=
  s.filterMap
    (fun n => match n with
      | 0 => .none
      | n + 1 => .some n
      )
    (by admit /- proof elided -/
    )

instance : LawfulHasSucc Nat where
  succ'_eq_add_one := Nat.succ_eq_add_one

def Cache.upper (n : ‚Ñï) (cache : Cache Œ± (n + 1)) :
    Cache Œ± n :=
  Fin.init cache

@[simp]
abbrev OracleStatement.AfterFirstMessage : R1CS.MatrixIdx ‚äï Fin 1 ‚Üí Type :=
  Sum.rec (OracleStatement R pp) (fun _ => Witness R pp)

instance inhabited [Inhabited R] : Inhabited (MlPoly R n) :=

instance [Zero T] [One T] [ToNat T] : NatPow (Cayley T) where
  pow := powNat

List.mergeSort in Init.Data.List.Sort.Basic

def outputRelation :
    Set
      (
        (Fri.Spec.Statement F (0 : Fin (k + 1)) √ó
        (‚àÄ j, Fri.Spec.OracleStatement D x s (0 : Fin (k + 1)) j)) √ó
        Fri.Spec.Witness F s d (0 : Fin (k + 2))
      ) := sorry

def Rhs (e : ‚Ñï) (œâs f : Fin n ‚Üí F) (i : Fin n) : F :=
  let Œ±·µ¢ := œâs i
  (-(f i) * Œ±·µ¢^e)

structure WireIndices (numWires : ‚Ñï) where
   
  a : Fin numWires
   
  b : Fin numWires
   
  c : Fin numWires
deriving DecidableEq

noncomputable def proximityError (F : Type*) [Fintype F] (d : ‚Ñï) (œÅ : ‚Ñù) (Œ¥ : ‚Ñù) (m : ‚Ñï) : ‚Ñù :=
  if Œ¥ ‚â§ (1 - œÅ) / 2 then
    ((m - 1) * d) / (œÅ * (Fintype.card F))
  else
    let min_val := min (1 - (Real.sqrt œÅ) - Œ¥ ) ((Real.sqrt œÅ) / 20)
    ((m - 1) * d^2) / ((Fintype.card F) * (2 * min_val)^7)

@[reducible, inline]
instance instMvPolynomial : OracleInterface (R[X œÉ]) where
  Query := œÉ ‚Üí R
  Response := R
  answer := fun poly point => eval point poly

def FullData.rightSubtree {Œ± : Type} {s_left s_right : Skeleton}
    (tree : FullData Œ± (Skeleton.internal s_left s_right)) :
    FullData Œ± s_right :=
  match tree with
  | FullData.internal _ _left right =>
    right

gen in VCVio.CryptoFoundations.FiatShamir

False.elim in Init.Prelude

def FullData.toLeafData {Œ± : Type} {s : Skeleton}
    (tree : FullData Œ± s) : LeafData Œ± s :=
  match tree with
  | FullData.leaf value => LeafData.leaf value
  | FullData.internal _ left right =>
    LeafData.internal (left.toLeafData) (right.toLeafData)

Set.Finite in Mathlib.Data.Finite.Defs

noncomputable def H_tilde (H : F[X][Y]) : Polynomial (RatFunc F) :=
  let h·µ¢ (i : ‚Ñï) := H.coeff i
  let d := H.natDegree
  let W := (RingHom.comp Polynomial.C univPolyHom) (h·µ¢ d)
  let S : Polynomial (RatFunc F) := Polynomial.X / W
  let H' := Polynomial.eval‚ÇÇ (RingHom.comp Polynomial.C univPolyHom) S H
  W ^ (d - 1) * H'

Array.reverse in Init.Data.Array.Basic

instance : Unique (MessageIdx ‚ü®!v[.P_to_V], !v[Msg]‚ü©) where
  default := ‚ü®0, by admit /- proof elided -/
  ‚ü©
  uniq := fun i => by admit /- proof elided -/

structure ConcreteBTFStepResult (k : ‚Ñï) extends (ConcreteBTFieldProps k) where
  instFintype : Fintype (ConcreteBTField k)
  fieldFintypeCard : Fintype.card (ConcreteBTField k) = 2^(2^k)
  
  sumZeroIffEq : ‚àÄ (x y : ConcreteBTField k), x + y = 0 ‚Üî x = y
  traceMapEvalAtRootsIs1 :
    letI := mkFieldInstance (k:=k) (props:=toConcreteBTFieldProps)
    TraceMapProperty (ConcreteBTField k) (u:=Z k) k
  instIrreduciblePoly :
    letI := mkFieldInstance (k:=k) (props:=toConcreteBTFieldProps)
    (Irreducible (p := (definingPoly (s:=(Z k)))))

List.Vector.ofFn in Mathlib.Data.Vector.Defs

def insertNth (p : Fin (n + 1)) (y : M) (s : Fin n ‚Üí‚ÇÄ M) : Fin (n + 1) ‚Üí‚ÇÄ M :=
  Finsupp.equivFunOnFinite.symm (Fin.insertNth p y s : Fin (n + 1) ‚Üí M)

instance :
    ‚àÄ i, OracleInterface
          ((pSpecFold D x k s ++‚Çö FinalFoldPhase.pSpec F ++‚Çö QueryRound.pSpec D x l).Message i) :=
  instOracleInterfaceMessageAppend

instance instDCast‚ÇÇ : DCast‚ÇÇ Nat ProtocolSpec
    (fun _ pSpec => Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) where
  dcast‚ÇÇ := Prover.cast
  dcast‚ÇÇ_id := Prover.cast_id

def equivMonomialLagrangeRepr : MlPoly R n ‚âÉ MlPolyEval R n where
  toFun := monoToLagrange n
  invFun := lagrangeToMono n
  left_inv v := by admit /- proof elided -/

@[reducible, simp] def WitIn := Unit

inductive Data (Œ± : Type) :
    {n : ‚Ñï} ‚Üí {ar : Fin n ‚Üí ‚Ñï} ‚Üí Skeleton n ar ‚Üí Type where
  | leaf {ar0 : Fin 0 ‚Üí ‚Ñï} (value : Œ±) :
      Data Œ± (Skeleton.leaf (ar0 := ar0))
  | node {n : ‚Ñï} {ar : Fin (n+1) ‚Üí ‚Ñï}
      {children : Fin (ar 0) ‚Üí
        Skeleton n (fun i => ar i.succ)}
      (value : Œ±)
      (childrenData : (i : Fin (ar 0)) ‚Üí
        Data Œ± (children i)) :
      Data Œ± (Skeleton.node children)

Polynomial.evalEvalRingHom in Mathlib.Algebra.Polynomial.Bivariate

ZMod.charP in Mathlib.Data.ZMod.Basic

@[inline, reducible]
def lift : OuterStmtIn √ó OuterWitIn ‚Üí InnerStmtOut √ó InnerWitOut ‚Üí OuterWitOut :=
  lens.toFunB

@[simp]
def BTField (k : ‚Ñï) := (BinaryTowerAux k).1

instDecidableEqOfLawfulBEq in Init.Core

Int.ofNat in Init.Data.Int.Basic

def toEvalsZeroOne (p : MvPolynomial œÉ R) : (œÉ ‚Üí Fin 2) ‚Üí R :=
  fun x => eval (x : œÉ ‚Üí R) p

instance Z_NeZero {k : ‚Ñï} : NeZero (Z k) := { out := Z_ne_zero (k:=k) }

List.findIdx in Init.Data.List.Basic

def twoLevelData {Œ±} (k0 k1 : ‚Ñï)
    (root : Œ±)
    (lvl1 : Fin k0 ‚Üí Œ±)
    (lvl2 : (i : Fin k0) ‚Üí Fin k1 ‚Üí Œ±) :
    ArityTree.Data Œ± (twoLevelSkel k0 k1) :=

structure FSProverState (U : Type) [SpongeUnit U] (H : Type*) [DuplexSpongeInterface U H]
    (R : Type*) extends FSVerifierState U H where
   
  rng : ProverPrivateRng R
deriving Repr

def closePtsOnAffineLine {Œπ : Type*} [Fintype Œπ]
                         (u v : Œπ ‚Üí F) (deg : ‚Ñï) (Œ± : Œπ ‚Ü™ F) (e : ‚Ñï) : Set (Œπ ‚Üí F) :=
  {x : Œπ ‚Üí F | x ‚àà Affine.line u v ‚àß distFromCode x (ReedSolomon.code Œ± deg) ‚â§ e}

Polynomial.evalEval in Mathlib.Algebra.Polynomial.Bivariate

def dfoldrM' {m : Type u ‚Üí Type v} [Monad m]
    (n : ‚Ñï) (Œ± : Fin (n + 1) ‚Üí Type u)
    (f : (i : Fin n) ‚Üí Œ± i.succ ‚Üí m (Œ± i.castSucc)) (init : Œ± (last n)) : m (Œ± 0) :=
  match n with
  | 0 => pure init
  | n + 1 => do
    let x ‚Üê dfoldrM' n (Œ± ‚àò succ) (fun i => f i.succ) init
    f 0 x

instance : ‚àÄ i, SelectableType ((pSpecFinalSumcheckStep (L:=L)).Challenge i)
  | ‚ü®0, _‚ü© => by admit /- proof elided -/

noncomputable def coeffs_of_close_proximity (œâs : Fin n ‚Ü™ F) (Œ¥ : ‚Ñö) (u‚ÇÄ u‚ÇÅ : Fin n ‚Üí F)
  : Finset F := Set.toFinset { z | ‚àÉ v : ReedSolomon.code œâs (k + 1), Œ¥·µ£(u‚ÇÄ + z ‚Ä¢ u‚ÇÅ, v) ‚â§ Œ¥}

@[reducible]
def reduction : Reduction oSpec StmtIn WitIn StmtOut WitOut !p[] where
  prover := prover mapStmt mapWit
  verifier := verifier mapStmt

def dfoldl' (n : ‚Ñï) (Œ± : Fin (n + 1) ‚Üí Type u)
    (f : (i : Fin n) ‚Üí Œ± i.castSucc ‚Üí Œ± i.succ) (init : Œ± 0) : Œ± (last n) :=
  dfoldlM' (m := Id) n Œ± f init

@[reducible]
def MlPoly (R : Type*) (n : ‚Ñï) := Vector R (2 ^ n) 

noncomputable def oddPart (f : Polynomial F) : Polynomial F :=
    C (2‚Åª¬π : F) * (f - f.comp (-X)) /‚Çò X

def ofFinMatrix {m n : ‚Ñï} (matrix : _root_.Matrix (Fin m) (Fin n) Œ±) : Matrix Œ± m n :=
  Vector.ofFn (fun i => Vector.ofFn (fun j => matrix i j))

@[ext]
structure Equiv {m n : ‚Ñï} (pSpec : ProtocolSpec m) (pSpec' : ProtocolSpec n) where
  round_eq : m = n
  dir_eq : ‚àÄ i, pSpec.dir i = pSpec'.dir (Fin.cast round_eq i)
  typeEquiv : ‚àÄ i, pSpec.¬´Type¬ª i ‚âÉ pSpec'.¬´Type¬ª (Fin.cast round_eq i)

noncomputable instance {H : F[X][Y]} [inst : Fact (Irreducible H)] : Field (ùïÉ H) :=
  IsField.toField (isField_of_irreducible inst.out)

def LeafData.map {Œ± Œ≤ : Type} (f : Œ± ‚Üí Œ≤) {s : Skeleton}
    (tree : LeafData Œ± s) : LeafData Œ≤ s :=
  match tree with
  | LeafData.leaf value => LeafData.leaf (f value)
  | LeafData.internal left right =>
    LeafData.internal (left.map f) (right.map f)

@[inline] def zero : AssocNat :=
  ‚ü®id, by admit /- proof elided -/
  ‚ü©

@[reducible, inline, specialize]
def PlainMessage (i : pSpec.PlainMessageIdx) := pSpec.Message i.1

inductive MatrixIdx where | A | B | C deriving Inhabited, DecidableEq

@[reducible]
def matchSize (a b : Array Œ±) (unit : Œ±) : Array Œ± √ó Array Œ± :=
  (a.rightpad (b.size) unit, b.rightpad (a.size) unit)

def removeNth (p : Fin (n + 1)) (s : Fin (n + 1) ‚Üí‚ÇÄ M) : Fin n ‚Üí‚ÇÄ M :=
  Finsupp.equivFunOnFinite.symm (Fin.removeNth p s : Fin n ‚Üí M)

affineSpan in Mathlib.LinearAlgebra.AffineSpace.AffineSubspace.Defs

noncomputable def Pz
  {k : ‚Ñï}
  {z : F}
  (hS : z ‚àà coeffs_of_close_proximity k œâs Œ¥ u‚ÇÄ u‚ÇÅ)
  :
  F[X]
  := (exists_Pz_of_coeffs_of_close_proximity (n := n) (k := k) hS).choose

instance {U : Type} [SpongeUnit U] [SpongeSize] :
    SpongeState U (Vector U SpongeSize.N) where
  
  new := fun _ => 0
  get := id
  update := fun _ v => v

def divByMonic [Field R] (p : UniPoly R) (q : UniPoly R) :
    UniPoly R :=
  (divModByMonicAux p q).1

def domainEnum (i : Fin (n + 1)) : Fin (2 ^ (n - i)) ‚Ü™ evalDomain D i :=
  ‚ü®domain D n i.1, domain_injective D i.1 (by admit /- proof elided -/
  )‚ü©

instance instVector : OracleInterface (Vector Œ± n) where
  Query := Fin n
  Response := Œ±
  answer := fun vec i => vec[i]

instance [LawfulBEq R] : AddCommGroup (UniPolyC R) where
  add_assoc := add_assoc
  zero_add := zero_add
  add_zero := add_zero
  add_comm := add_comm
  neg_add_cancel := neg_add_cancel
  nsmul := nsmul 
  nsmul_zero := nsmul_zero
  nsmul_succ := nsmul_succ
  zsmul := zsmulRec 

class RoundByRoundOneShot.IsMonotone (E : RoundByRoundOneShot oSpec StmtIn WitIn pSpec)
    (relIn : Set (StmtIn √ó WitIn)) where
  is_monotone : ‚àÄ roundIdx stmtIn transcript,
    ‚àÄ proveQueryLog‚ÇÅ proveQueryLog‚ÇÇ : oSpec.QueryLog,
    
    proveQueryLog‚ÇÅ.Sublist proveQueryLog‚ÇÇ ‚Üí
    
    
    (stmtIn, E roundIdx stmtIn transcript proveQueryLog‚ÇÅ) ‚àà relIn ‚Üí
      (stmtIn, E roundIdx stmtIn transcript proveQueryLog‚ÇÇ) ‚àà relIn

def accepts (x : Fin numWires ‚Üí ùì°) (g : Gate ùì° numWires) : Prop :=
  g.eval x = 0

abbrev FunEquiv F Œ± Œ≤ := DFunEquiv F Œ± fun _ => Œ≤

Array.zipWith in Init.Data.Array.Basic

structure OracleContext.Lens (OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut : Type)
    {Outer_Œπ‚Çõ·µ¢ : Type} (OuterOStmtIn : Outer_Œπ‚Çõ·µ¢ ‚Üí Type) [‚àÄ i, OracleInterface (OuterOStmtIn i)]
    {Outer_Œπ‚Çõ‚Çí : Type} (OuterOStmtOut : Outer_Œπ‚Çõ‚Çí ‚Üí Type) [‚àÄ i, OracleInterface (OuterOStmtOut i)]
    {Inner_Œπ‚Çõ·µ¢ : Type} (InnerOStmtIn : Inner_Œπ‚Çõ·µ¢ ‚Üí Type) [‚àÄ i, OracleInterface (InnerOStmtIn i)]
    {Inner_Œπ‚Çõ‚Çí : Type} (InnerOStmtOut : Inner_Œπ‚Çõ‚Çí ‚Üí Type) [‚àÄ i, OracleInterface (InnerOStmtOut i)]
    (OuterWitIn OuterWitOut InnerWitIn InnerWitOut : Type) where
  stmt : OracleStatement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                                  OuterOStmtIn OuterOStmtOut InnerOStmtIn InnerOStmtOut
  wit : Witness.Lens (OuterStmtIn √ó ‚àÄ i, OuterOStmtIn i) (InnerStmtOut √ó ‚àÄ i, InnerOStmtOut i)
                          OuterWitIn OuterWitOut InnerWitIn InnerWitOut

def interleaveCode [Semiring F] [DecidableEq F] (C : Submodule F (n ‚Üí F)) (Œπ : Type*)
  : Submodule F ((Œπ √ó n) ‚Üí F) :=
  Submodule.span F {v | ‚àÄ i, ‚àÉ c ‚àà C, c = fun j => v (i, j)}

instance : ‚àÄ j, OracleInterface ((pSpec D x l).Message j) := fun j =>
  match j with
  | ‚ü®0, h‚ü© => nomatch h

def possibleDists (C : Set (Œπ ‚Üí F)) (Œ¥f : (Œπ ‚Üí F) ‚Üí (Œπ ‚Üí F) ‚Üí Œ±) : Set Œ± :=
  {d : Œ± | ‚àÉ p ‚àà Set.offDiag C, Œ¥f p.1 p.2 = d}

def MLEEquivFin {n : ‚Ñï} : R‚¶É‚â§ 1‚¶Ñ[X (Fin n)] ‚âÉ (Fin (2 ^ n) ‚Üí R) :=
  Equiv.trans MLEEquiv (Equiv.piCongr finFunctionFinEquiv (fun _ => Equiv.refl _))

@[reducible, inline]
def OracleProver {Œπ : Type} (oSpec : OracleSpec Œπ)
    (StmtIn : Type) {Œπ‚Çõ·µ¢ : Type} (OStmtIn : Œπ‚Çõ·µ¢ ‚Üí Type) (WitIn : Type)
    (StmtOut : Type) {Œπ‚Çõ‚Çí : Type} (OStmtOut : Œπ‚Çõ‚Çí ‚Üí Type) (WitOut : Type)
    {n : ‚Ñï} (pSpec : ProtocolSpec n) :=
  Prover oSpec (StmtIn √ó (‚àÄ i, OStmtIn i)) WitIn (StmtOut √ó (‚àÄ i, OStmtOut i)) WitOut pSpec

instance [h : VerifierFirst pSpec] : IsEmpty (pSpec.MessageIdx) where
  false | ‚ü®0, h'‚ü© => by admit /- proof elided -/

@[reducible, simp]
def perfectCompleteness (relation : Set (Statement √ó Witness))
    (proof : Proof oSpec Statement Witness pSpec) : Prop :=
  Reduction.perfectCompleteness init impl relation acceptRejectRel proof

instance : ‚àÄ j, OracleInterface ((pSpecFoldRelay (L:=L)).Message j) :=
  instOracleInterfaceMessageAppend

@[inline, specialize]
def processRound (j : Fin n)
    (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec)
    (currentResult : OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí)
      (pSpec.Transcript j.castSucc √ó prover.PrvState j.castSucc)) :
      OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí)
        (pSpec.Transcript j.succ √ó prover.PrvState j.succ) := do
  let ‚ü®transcript, state‚ü© ‚Üê currentResult
  match hDir : pSpec.dir j with
  | .V_to_P => do
    let challenge ‚Üê pSpec.getChallenge ‚ü®j, hDir‚ü©
    letI newState := (‚Üê prover.receiveChallenge ‚ü®j, hDir‚ü© state) challenge
    return ‚ü®transcript.concat challenge, newState‚ü©
  | .P_to_V => do
    let ‚ü®msg, newState‚ü© ‚Üê prover.sendMessage ‚ü®j, hDir‚ü© state
    return ‚ü®transcript.concat msg, newState‚ü©

def Œ±' (x‚ÇÄ : F) (R : F[X][X][Y]) (H_irreducible : Irreducible H) (t : ‚Ñï) : ùïÉ H :=
  Œ± x‚ÇÄ R _ (œÜ := ‚ü®H_irreducible‚ü©) t

structure BinaryTowerResult (F : Type _) (k : ‚Ñï) where
  vec : (List.Vector F (k + 1))
  instField : (Field F)
  instFintype : Fintype F
  specialElement : F
  specialElementNeZero : NeZero specialElement
  firstElementOfVecIsSpecialElement [Inhabited F] : vec.1.headI = specialElement
  instIrreduciblePoly : (Irreducible (p := (definingPoly specialElement)))
  sumZeroIffEq : ‚àÄ (x y : F), x + y = 0 ‚Üî x = y
  fieldFintypeCard : Fintype.card F = 2^(2^k)
  traceMapEvalAtRootsIs1 : TraceMapProperty F specialElement k

Algebra.TensorProduct.includeRight in Mathlib.RingTheory.TensorProduct.Basic

Setoid in Init.Core

instance instDCast‚ÇÇ : DCast‚ÇÇ Nat ProtocolSpec (fun _ pSpec => FullTranscript pSpec) where
  dcast‚ÇÇ h h' T := FullTranscript.cast h h' T
  dcast‚ÇÇ_id := cast_id

def sigmaMessageIdxToSeqCompose {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (i : Fin m) (j : (pSpec i).MessageIdx) : (seqCompose pSpec).MessageIdx :=
  ‚ü®Fin.embedSum i j.1, by admit /- proof elided -/
  ‚ü©

Ideal in Mathlib.RingTheory.Ideal.Defs

Polynomial.eval‚ÇÇRingHom in Mathlib.Algebra.Polynomial.Eval.Defs

@[app_unexpander Fin.hcons]
def hconsUnexpander : Lean.PrettyPrinter.Unexpander
  | `($_ $term !h[$term2, $terms,*]) => `(!h[$term, $term2, $terms,*])
  | `($_ $term !h[$term2]) => `(!h[$term, $term2])
  | `($_ $term !h[]) => `(!h[$term])
  | _ => throw ()

def ofNat : ‚Ñï ‚Üí ChurchNat Œ±
  | 0 => zero
  | Nat.succ n => succ (ofNat n)

def eval‚ÇÇ (p : MlPoly R n) (f : R ‚Üí+* S) (x : Vector S n) : S := eval (map f p) x

Finset.range in Mathlib.Data.Finset.Range

finSuccEquiv in Mathlib.Logic.Equiv.Fin.Basic

@[simp]
def outerRelOut_Test : Set (OuterStmtOut_Test √ó Unit) :=
  setOf (fun ‚ü®‚ü®p, q, t, r‚ü©, _‚ü© => (p * q).eval r = t)

def verifier : Verifier oSpec (StmtIn R √ó (‚àÄ i, OStmtIn R deg i))
                              (StmtOut R √ó (‚àÄ i, OStmtOut R deg i)) (pSpec R deg) where
  verify := fun ‚ü®target, oStmt‚ü© transcript => do
    letI polyLE := transcript 0
    guard (‚àë x ‚àà (univ.map D), polyLE.val.eval x = target)
    letI chal := transcript 1
    pure ‚ü®‚ü®(oStmt ()).val.eval chal, chal‚ü©, fun _ => oStmt ()‚ü©

def leadingCoeff (p : UniPoly R) : R := p.trim.getLastD 0

def powFiberT (i : ‚Ñï) {k : ‚Ñï} {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F} (S' : Finset (indexPowT S œÜ i))
  (œÜ' : (indexPowT S œÜ i) ‚Ü™ F) (y : indexPowT S œÜ k) :=
  { x : (indexPowT S œÜ i) // x ‚àà S' ‚àß (œÜ' x) ^ (2^(k-i)) = y.val }

structure Context.Lens (OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                          OuterWitIn OuterWitOut InnerWitIn InnerWitOut : Type) where
  stmt : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
  wit : Witness.Lens OuterStmtIn InnerStmtOut OuterWitIn OuterWitOut InnerWitIn InnerWitOut

@[inline]
def add [Add R] (p q : MlPoly R n) : MlPoly R n := Vector.zipWith (¬∑ + ¬∑) p q

def hammingBall (C : Code Œπ F) (y : Œπ ‚Üí F) (r : ‚Ñï) : Set (Œπ ‚Üí F) :=
  { c | c ‚àà C ‚àß hammingDist y c ‚â§ r }

class SliceGE (coll : Type u) (start : Type v) (valid : outParam (coll ‚Üí start ‚Üí Prop))
    (subcoll : outParam ((xs : coll) ‚Üí (start : start) ‚Üí (h : valid xs start) ‚Üí Type w)) where
  sliceGE : (xs : coll) ‚Üí (start : start) ‚Üí (h : valid xs start) ‚Üí subcoll xs start h

inductive MemoryOp (Œπ : Type u) (Œ± : Œπ ‚Üí Type v) where
  | read (op : MemoryRead Œπ Œ±)
  | write (op : MemoryWrite Œπ Œ±)

instance extractorLens_rbr_knowledge_soundness :
    Extractor.Lens.IsKnowledgeSound
      (relationRound R n deg D i.castSucc) (Simple.inputRelation R deg D)
      (relationRound R n deg D i.succ) (Simple.outputRelation R deg)
      ((Simple.oracleVerifier R deg D oSpec).toVerifier.compatStatement (oStmtLens R n deg D i))
      (fun _ _ => True)
      ‚ü®oStmtLens R n deg D i, Witness.InvLens.trivial‚ü© where
  proj_knowledgeSound := by admit /- proof elided -/

PFunctor.Lens.id in ToMathlib.PFunctor.Lens.Basic

@[inline, specialize, simp]
def verifier : Verifier oSpec Statement Statement !p[] := Verifier.id

def divNat [Zero T] [DecidableEq T] [ToNat T]
    (dividend divisor : Cayley T) : Nat ‚Üí Cayley T
  | 0        => zero  
  | .succ fuel =>
    
    if (‚Üëdivisor : Nat) = 0 then
      zero
    else
      
      if (‚Üëdivisor : Nat) ‚â§ (‚Üëdividend : Nat) then
        
        add one (divNat (sub dividend divisor) divisor fuel)
      else
        zero

instance : Zero (DuplexSponge U C) where
  zero := {
    state := 0,
    absorbPos := 0,
    squeezePos := 0
  }

def sumcheckFoldKnowledgeError := fun j : (pSpecSumcheckFold ùîΩq Œ≤ (œë:=œë)
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).ChallengeIdx =>
    if hj: (j.val % NBlockMessages (œë:=œë)) % 2 = 1 then
      foldKnowledgeError ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        ‚ü®j / NBlockMessages (œë:=œë) * œë + ((j % NBlockMessages (œë:=œë)) / 2 + 1), by admit /- proof elided -/
        ‚ü© ‚ü®1, rfl‚ü©
    else 0 

def sumPartial (m : ‚Ñï) (n : ‚Ñï) (D : Fin n ‚Üí Finset R) :
    MvPolynomial (Fin (m + n)) R ‚Üí‚Çó[R] MvPolynomial (Fin m) R where
  toFun := fun p => ‚àë x ‚àà Fintype.piFinset D, peval (Fin.sumCommEquiv m n) x p
  map_add' := fun p q => by admit /- proof elided -/

noncomputable def foldVerifier :
  OracleVerifier []‚Çí
    (Statement F i.castSucc) (OracleStatement D x s i.castSucc)
    (Statement F i.succ) (OracleStatement D x s i.succ)
    (pSpec D x s i) where
  verify := fun prevChallenges roundChallenge =>
    pure (Fin.vappend prevChallenges (fun _ => roundChallenge ‚ü®0, by admit /- proof elided -/
    ‚ü©))
  embed :=
    ‚ü®
      fun j =>
        if h : j.val = (i.val + 1)
        then Sum.inr ‚ü®1, by admit /- proof elided -/
        ‚ü©
        else Sum.inl ‚ü®j.val, by admit /- proof elided -/
        ‚ü©,
      by admit /- proof elided -/
    ‚ü©
  hEq := by admit /- proof elided -/

Id in Init.Control.Id

Vector.drop in Init.Data.Vector.Basic

noncomputable def sDomain.lift (i j : Fin r) (h_j : j < ‚Ñì + R_rate) (h_le : i ‚â§ j)
    (y : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate j) :
    sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i :=

def relationAfterCheckClaim :
    Set (((StmtAfterCheckClaim R) √ó (‚àÄ i, OStmtAfterCheckClaim R deg i)) √ó Unit) :=
  { ‚ü®‚ü®_, oStmt‚ü©, _‚ü© | oStmt (Sum.inr ()) = oStmt (Sum.inl ()) }

Sum.elim in Init.Data.Sum.Basic

def getUElements (i : Fin r) : List L :=
  (List.finRange (2^i.val)).map fun k =>
    (Finset.univ : Finset (Fin i)).sum fun j =>
      if Nat.getBit (n := k.val) (k := j.val) == 1 then
        Œ≤ ‚ü®j.val, by admit /- proof elided -/
        ‚ü©
      else 0

def relayKnowledgeError (m : pSpecRelay.ChallengeIdx) : ‚Ñù‚â•0 :=
  match m with
  | ‚ü®j, _‚ü© => j.elim0

MvPolynomial.sumToIter in Mathlib.Algebra.MvPolynomial.Equiv

@[reducible, simp] def OStmtAfterRandomQuery : Unit ‚äï Unit ‚Üí Type := fun _ => R‚¶É‚â§ deg‚¶Ñ[X]

def oracleReduction (i : Fin n) : OracleReduction oSpec
    (StatementRound R n i.castSucc) (OracleStatement R n deg) Unit
    (StatementRound R n i.succ) (OracleStatement R n deg) Unit (pSpec R deg) :=
  (Simple.oracleReduction R deg D oSpec).liftContext (oCtxLens R n deg D i)

abbrev eqPolynomial (r : œÉ ‚Üí R) : R[X œÉ] :=
  ‚àè i : œÉ, singleEqPolynomial (r i) (X i)

instance : ‚àÄ i, OracleInterface ((pSpecQuery ùîΩq Œ≤ Œ≥_repetitions
  (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).Message i) := fun _ => OracleInterface.instDefault

def finUInt8Equiv : Fin (2 ^ 8) ‚âÉ UInt8 where
  toFun := fun i => UInt8.ofFin i
  invFun := fun u => u.toFin
  left_inv _ := rfl
  right_inv _ := rfl

def splitSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (k : Fin (vsum n)) : (i : Fin m) √ó Fin (n i) := match m with
  | 0 => Fin.elim0 k
  | _ + 1 => Fin.dappend
    (fun k => ‚ü®0, k‚ü©)
    (fun k => ‚ü®(splitSum k).1.succ, (splitSum k).2‚ü©)
    k

LinearMap.ker in Mathlib.Algebra.Module.Submodule.Ker

def X : UniPoly R := #[0, 1]

def Verifier.liftContext
    (lens : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut)
    (V : Verifier oSpec InnerStmtIn InnerStmtOut pSpec) :
      Verifier oSpec OuterStmtIn OuterStmtOut pSpec where
  verify := fun stmtIn transcript => do
    let innerStmtIn := lens.proj stmtIn
    let innerStmtOut ‚Üê V.verify innerStmtIn transcript
    return lens.lift stmtIn innerStmtOut

CommRing.toRing in Mathlib.Algebra.Ring.Defs

noncomputable def eval_on_Z‚ÇÄ (p : (RatFunc F)) (z : F) : F :=
  RatFunc.eval (RingHom.id _) z p


notation3:max R "[Z][X]" => Polynomial (Polynomial R)

notation3:max R "[Z][X][Y]" => Polynomial (Polynomial (Polynomial (R)))

notation3:max "Y" => Polynomial.X
notation3:max "X" => Polynomial.C Polynomial.X
notation3:max "Z" => Polynomial.C (Polynomial.C Polynomial.X)

abbrev ScalarField := ZMod scalarFieldSize

Nat.Coprime in Init.Data.Nat.Coprime

@[simp]
abbrev Witness.AfterFirstSumcheck : Type := Unit

Option.getD in Init.Prelude

def implGroupDecodeOracle [DeserializeOption G (BitVec bitLength)] :
    QueryImpl (GroupDecodeOracle Œπ bitLength) (StateT (GroupValTable Œπ G) Option) where
  impl | query _ (b, i) => fun table =>
    match DeserializeOption.deserialize b with
    | some g => some ((), table.update i (some g))
    | none => none

def extract (start stop : ‚Ñï) (h1 : start ‚â§ stop) (h2 : stop ‚â§ n) (pSpec : ProtocolSpec n) :
    ProtocolSpec (stop - start) where
  dir := Fin.extract start stop h1 h2 pSpec.dir
  ¬´Type¬ª := Fin.extract start stop h1 h2 pSpec.¬´Type¬ª

abbrev extract (start stop : ‚Ñï) (h1 : start ‚â§ stop) (h2 : stop ‚â§ n)
    (transcript : FullTranscript pSpec) : FullTranscript (pSpec.extract start stop h1 h2) :=
  Fin.extract start stop h1 h2 transcript

@[reducible, inline]
def ùï´ {R} {sz} (stmt : Statement R sz) (wit : Witness R sz) : Fin sz.n ‚Üí R :=
  Fin.append stmt wit ‚àò Fin.cast (by admit /- proof elided -/
  )

def canonicalEmbedding (k : ‚Ñï) : BTField k ‚Üí+* BTField (k+1) :=
  AdjoinRoot.of (poly k)

abbrev drop (m : ‚Ñï) (h : m ‚â§ n)
    (transcript : FullTranscript pSpec) : FullTranscript (pSpec.drop m h) :=
  Fin.drop m h transcript

@[inline, specialize]
def Prover.runToRoundDSFS [‚àÄ i, VCVCompatible (pSpec.Challenge i)] (i : Fin (n + 1))
    (stmt : StmtIn) (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec)
    (state : prover.PrvState 0) :
        OracleComp (oSpec ++‚Çí duplexSpongeChallengeOracle StmtIn U)
          (pSpec.MessagesUpTo i √ó
            DuplexSponge U (Vector U SpongeSize.N) √ó prover.PrvState i) :=
  Fin.induction
    (do
      
      let sponge ‚Üê liftM (DuplexSponge.start stmt)
      return ‚ü®default, sponge, state‚ü©
    )
    (prover.processRoundDSFS)
    i

Fin.consInduction in Mathlib.Data.Fin.Tuple.Basic

OracleComp.SelectableType.probFailure_selectElem in VCVio.OracleComp.Constructions.UniformSelect

def squeeze (state : HashStateWithInstructions U H) (outputSize : Nat) :
    Except DomainSeparatorMismatch (HashStateWithInstructions U H √ó Array U) := do
  
  sorry

def binaryTowerModule {l r : ‚Ñï} (h_le : l ‚â§ r) :
    Module (ConcreteBTField l) (ConcreteBTField r) :=
  (ConcreteBTFieldAlgebra (h_le:=h_le)).toModule

def Verifier.StateFunction.liftContext
    {œÉ : Type} {init : ProbComp œÉ} {impl : QueryImpl oSpec (StateT œÉ ProbComp)}
    (lens : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut)
    (V : Verifier oSpec InnerStmtIn InnerStmtOut pSpec)
    (outerLangIn : Set OuterStmtIn) (outerLangOut : Set OuterStmtOut)
    (innerLangIn : Set InnerStmtIn) (innerLangOut : Set InnerStmtOut)
    [lensSound : lens.IsSound outerLangIn outerLangOut innerLangIn innerLangOut
      (V.compatStatement lens)]
    (stF : V.StateFunction init impl innerLangIn innerLangOut) :
      (V.liftContext lens).StateFunction init impl outerLangIn outerLangOut
where
  toFun := fun m outerStmtIn transcript =>
    stF m (lens.proj outerStmtIn) transcript
  toFun_empty := fun stmt => by admit /- proof elided -/

noncomputable def Basis.baseChangeRight (b : Basis Œπ K Left) : Basis Œπ Right (Left ‚äó[K] Right) :=

def ChurchBool (Œ± : Type) : Type := Œ± ‚Üí Œ± ‚Üí Œ±

instance : ‚àÄ j, OracleInterface ((pSpec D x l).Challenge j) := fun j =>
  by admit /- proof elided -/

structure PrattCertificate' (p : ‚Ñï) : Type where
  a : ZMod p
  pow_eq_one : a ^ (p - 1) = 1
  part : PrattPartList p a (p - 1)

def ri (dstar : ‚Ñï) (degs : Fin m ‚Üí ‚Ñï) (r : F) (i : Fin m) : F :=
          match i.1 with
          | 0 => 1
          | .succ i' =>
            let exp := i' + ‚àë j < i, (dstar - degs j)
            r ^ exp

def rightpad {m : ‚Ñï} {Œ± : Sort*} (n : ‚Ñï) (a : Œ±) (v : Fin m ‚Üí Œ±) : Fin n ‚Üí Œ± :=
  fun i => if h : i < m then v ‚ü®i, h‚ü© else a

structure BacktrackSequenceFamily (trace : QueryLog (duplexSpongeChallengeOracle StmtIn U))
    (state : CanonicalSpongeState U) where
   
  seqFamily : Finset (BacktrackSequence trace state)
   
  maximality : ‚àÄ s ‚àà seqFamily, ‚àÄ s' ‚àà seqFamily,
    (s.stmt ‚â† s'.stmt) ‚à® ¬¨ (s.inputState ‚äÜ s'.inputState) ‚à® ¬¨ (s'.outputState ‚äÜ s.outputState)

Fin.succAboveCases in Mathlib.Data.Fin.Tuple.Basic

def lintStyleCli (args : Cli.Parsed) : IO UInt32 := do
  let style : ErrorFormat := match args.hasFlag "github" with
    | true => ErrorFormat.github
    | false => ErrorFormat.humanReadable
  let fix := args.hasFlag "fix"
  
  let mut allModuleNames := #[]
  for s in ["ArkLib.lean"] do
    allModuleNames := allModuleNames.append (‚Üê findImports s)
  
  allModuleNames := allModuleNames.erase `Batteries
  let mut numberErrors ‚Üê lintModules allModuleNames style fix
  if ‚Üê checkInitImports then numberErrors := numberErrors + 1
  
  
  
  
  if args.hasFlag "fix" then
    return 0
  else return min numberErrors 125

def LeafData.optionComposeBuild {Œ± : Type} {s : Skeleton} (leaf_data_tree : LeafData Œ± s)
    (compose : Œ± ‚Üí Œ± ‚Üí Option Œ±) :
    FullData (Option Œ±) s :=
  (leaf_data_tree.map (.some)).composeBuild (Option.doubleBind compose)

right_inv in ToMathlib.Control.Monad.Equiv

Quotient.lift‚ÇÇ in Init.Core

def computableBasisExplicit (k : ‚Ñï) (i : Fin (2 ^ k)) : ConcreteBTField k :=
  (Finset.univ : Finset (Fin k)).prod fun j =>
    if Nat.getBit (n := i.val) (k := j.val) == 1 then
      concreteTowerAlgebraMap (j.val + 1) k (by admit /- proof elided -/
      ) (Z (j.val + 1))
    else
      1

def pSpecLastBlock := pSpecFoldRelaySequence (L:=L) (n:=œë)

SMulZeroClass in Mathlib.Algebra.GroupWithZero.Action.Defs

structure Simulator (oSpec : OracleSpec Œπ) (StmtIn : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n) where
  SimState : Type
  oracleSim : SimOracle.Stateful oSpec oSpec SimState
  proverSim : StmtIn ‚Üí StateT SimState (OracleComp oSpec) pSpec.FullTranscript

protected def cast (pSpec : ProtocolSpec n‚ÇÅ) : ProtocolSpec n‚ÇÇ :=
  ‚ü®pSpec.dir ‚àò (Fin.cast hn.symm), pSpec.¬´Type¬ª ‚àò (Fin.cast hn.symm)‚ü©

def concrete_pow_nat {k : ‚Ñï} (x : ConcreteBTField k) (n : ‚Ñï) : ConcreteBTField k :=
  if n = 0 then one
  else if n % 2 = 0 then concrete_pow_nat (concrete_mul x x) (n / 2)
  else concrete_mul x (concrete_pow_nat (concrete_mul x x) (n / 2))

AdjoinRoot.powerBasis' in Mathlib.RingTheory.AdjoinRoot

Pi.single in Mathlib.Algebra.Notation.Pi.Basic

MvPolynomial.eval‚ÇÇ in Mathlib.Algebra.MvPolynomial.Eval

class IsSingleRound (pSpec : ProtocolSpec 2) extends ProverFirst pSpec, VerifierLast pSpec

alias ProverThenVerifier := IsSingleRound

instance {s} : Functor (fun Œ± => FullData Œ± s) where
  map f x := x.map f

List.take in Init.Data.List.Basic

Function.comp in Init.Prelude

MvPolynomial.totalDegree in Mathlib.Algebra.MvPolynomial.Degrees

instance : LT AssocNat where
  lt a b := a 0 < b 0

@[reducible, inline, specialize]
def MessageUpTo (k : Fin (n + 1)) (pSpec : ProtocolSpec n) (i : pSpec.MessageIdxUpTo k) :=
  (pSpec‚ü¶:k.val‚üß).Message i

@[reducible, simp] def OStmtOut := fun _ : Fin 1 => OStatement

Polynomial.aeval in Mathlib.Algebra.Polynomial.AlgebraMap

@[reducible]
def pSpecFold : ProtocolSpec 2 := ‚ü®![Direction.P_to_V, Direction.V_to_P], ![L‚¶É‚â§ 2‚¶Ñ[X], L]‚ü©

outParam in Init.Prelude

instance instDCastPSigmaPSigma :
    DCast ((a : Œ±) √ó' (b : Œ≤ a) √ó' Œ≥ a b) (fun a => Œ¥ a.1 a.2.1 a.2.2) where
  dcast hc d := dcast‚ÇÉ (by admit /- proof elided -/
  ) (by admit /- proof elided -/
  ) (by admit /- proof elided -/
  ) d
  dcast_id := by admit /- proof elided -/

instance : HasSucc Nat where
  succ' := Nat.succ

structure PrimeWithMultiplicity : Type where
  prime : ‚Ñï
  multiplicity : ‚Ñï
deriving Repr

Polynomial.IsRoot in Mathlib.Algebra.Polynomial.Eval.Defs

structure LookaheadSequenceFamily
    (trace : QueryLog (forwardPermutationOracle (CanonicalSpongeState U)))
    (state : CanonicalSpongeState U) (i : pSpec.ChallengeIdx) where
   
  seqFamily : Finset (LookaheadSequence trace state)
   
  maximality : ‚àÄ s ‚àà seqFamily, ‚àÄ s' ‚àà seqFamily,
    ¬¨ (s.inputState ‚äÜ s'.inputState) ‚à® ¬¨ (s'.outputState ‚äÜ s.outputState)
   
  length_le_challengeSize : ‚àÄ s ‚àà seqFamily, s.inputState.length ‚â§ challengeSize i

def eqTilde {L : Type} [CommRing L] {‚Ñì : ‚Ñï} (r r' : Fin ‚Ñì ‚Üí L) : L :=
  MvPolynomial.eval r' (MvPolynomial.eqPolynomial r)

@[simp]
def evalDomain (i : ‚Ñï) : Set FÀ£ :=
  (x ^ (2 ^ i)) ‚Ä¢ (Domain.evalDomain D i)

LT in Init.Prelude

def generateProof {n : ‚Ñï} (i : Fin (2 ^ n)) (cache : Cache Œ± n) :
    List.Vector Œ± n :=
  match n with
  | 0 => List.Vector.nil
  | n + 1 => List.Vector.snoc (generateProof ‚ü®i.val / 2, by admit /- proof elided -/
  ‚ü© (cache.upper))
                              ((cache.leaves).get (findNeighbors i (Fin.last _)))

def rightpadPowerOfTwo (unit : Œ±) (a : Array Œ±) : Array Œ± :=
  a.rightpad (2 ^ (Nat.clog 2 a.size)) unit

instance : IsEmpty (AssocFin AssocNat.zero) :=

class ProverOnly (pSpec : ProtocolSpec 1) extends ProverFirst pSpec

 
alias NonInteractive := ProverOnly

CommSemiring in Mathlib.Algebra.Ring.Defs

@[reducible, inline, specialize, simp]
def ChallengeIdx (vPSpec : VectorSpec n) := {i : Fin n // vPSpec.dir i = .V_to_P}

Mul in Init.Prelude

@[reducible, simp]
def rbrSoundness (langIn : Set Statement)
    (verifier : Verifier oSpec Statement Bool pSpec)
    (rbrSoundnessError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) : Prop :=
  verifier.rbrSoundness init impl langIn acceptRejectRel.language rbrSoundnessError

@[reducible, inline]
instance instProdForall {Œπ : Type u} (v : Œπ ‚Üí Type v) [O : ‚àÄ i, OracleInterface (v i)] :
    OracleInterface (‚àÄ i, v i) where
  Query := (i : Œπ) √ó (O i).Query
  Response := (i : Œπ) √ó (O i).Response
  answer := fun f ‚ü®i, q‚ü© => ‚ü®i, (O i).answer (f i) q‚ü©

Polynomial.erase in Mathlib.Algebra.Polynomial.Basic

def EvenPoly (f : Polynomial F) : Prop := ‚àÄ n, Odd n ‚Üí f.coeff n = 0

instance instOne {n : ‚Ñï} : One (CNat n) := match n with
  | 0 => by admit /- proof elided -/
  | .succ n => by admit /- proof elided -/

private def sum_choose_K_i (B : Finset (Fin n ‚Üí F)) (i : Fin n) : ‚Ñö :=
  ‚àë (Œ± : F), choose_2 (K B i Œ±)

liftM in Init.Prelude

instance [Zero T] [ToNat T] : ToNat (Cayley T) where
  toNat := ToNat.toNat ‚àò toT

@[simp]
abbrev FirstSumcheckChallenge : Type := Fin pp.‚Ñì_m ‚Üí R

def isRead : MemoryOp Œπ Œ± ‚Üí Prop
  | read _ => True
  | _ => False

def colSpan : Submodule F (Œπ ‚Üí F) :=
  Submodule.span F {Matrix.transpose U i | i : Œπ'}

def foldKnowledgeError (i : Fin ‚Ñì) (_ : (pSpecFold (L := L)).ChallengeIdx) : ‚Ñù‚â•0 :=
  let err_SC := (1 : ‚Ñù‚â•0) / (Fintype.card L)
  
  let err_BE := if hi : œë ‚à£ (i.val + 1) then
    
    œë * (Fintype.card ((sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate)
      ‚ü®i.val + 1, by admit /- proof elided -/
        ‚ü©) : ‚Ñù‚â•0) / (Fintype.card L)
  else 0
  err_SC + err_BE

local instance {Œ± : Type*} : Zero (Option Œ±) where
  zero := none

noncomputable def toRatFuncPoly (p : F[Z][X][Y]) : (RatFunc F)[X][Y] :=
  p.map (Polynomial.mapRingHom (algebraMap F[X] (RatFunc F)))

def getPutativeRoot {n : ‚Ñï} (i : Fin (2 ^ n)) (leaf : Œ±) (proof : List.Vector Œ± n) :
    OracleComp (spec Œ±) Œ± := do
  match h : n with
  | 0 => do
    
    return leaf
  | n + 1 => do
    
    let signBit := i.val % 2
    
    let i' : Fin (2 ^ n) := ‚ü®i.val / 2, by admit /- proof elided -/
    ‚ü©
    if signBit = 0 then
      
      let newLeaf ‚Üê query (spec := spec Œ±) () ‚ü®leaf, proof.get (Fin.last n)‚ü©
      getPutativeRoot i' newLeaf (proof.drop 1)
    else
      
      let newLeaf ‚Üê query (spec := spec Œ±) () ‚ü®proof.get (Fin.last n), leaf‚ü©
      getPutativeRoot i' newLeaf (proof.drop 1)

OracleComp.construct' in VCVio.OracleComp.OracleComp

def computableAdditiveNTT (a : Fin (2 ^ ‚Ñì) ‚Üí L) : Fin (2^(‚Ñì + R_rate)) ‚Üí L :=
  let b: Fin (2^(‚Ñì + R_rate)) ‚Üí L := tileCoeffs a 
  Fin.foldl (n:=‚Ñì) (f:= fun current_b i  =>
    computableNTTStage (ùîΩq := ùîΩq) (Œ≤ := Œ≤) (‚Ñì := ‚Ñì) (R_rate := R_rate)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := ‚ü®‚Ñì - 1 - i, by admit /- proof elided -/
      ‚ü©) (b:=current_b)
  ) (init:=b)

def factor' (n : ‚Ñï) : Option (List PrimeWithMultiplicity) := do
  let facts := List.mergeSort (‚Üê factor n)
  let groups := List.splitBy (¬∑ = ¬∑) facts
  return groups.map (fun g => ‚ü®g[0]!, g.length‚ü©)

def MLE (evals : (œÉ ‚Üí Fin 2) ‚Üí R) : MvPolynomial œÉ R :=
    ‚àë x : œÉ ‚Üí Fin 2, (eqPolynomial (x : œÉ ‚Üí R)) * C (evals x)

protected def cast (T : FullTranscript pSpec‚ÇÅ) :
    FullTranscript pSpec‚ÇÇ :=
  Transcript.cast (k := Fin.last n‚ÇÅ) (l := Fin.last n‚ÇÇ) hn hn hSpec T

@[inline] def monoToLagrange (n : ‚Ñï) : MlPoly R n ‚Üí MlPolyEval R n :=
  (List.finRange n).foldl (fun acc level => monoToLagrangeLevel level acc)

instance : OracleInterfaces (vPSpec.toProtocolSpec A) where
  oracleInterfaces := fun _ => some OracleInterface.instVector

class IsSecure
    (relation : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (Œµ_rbr : vPSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0)
    (vectorIOP : VectorIOP Statement OStatement Witness vPSpec A) where

   
  is_complete : vectorIOP.perfectCompleteness (pure ()) ‚ü®isEmptyElim‚ü© relation

   
  is_rbr_knowledge_sound :
    OracleProof.rbrKnowledgeSoundness (pure ()) ‚ü®isEmptyElim‚ü© relation vectorIOP.verifier Œµ_rbr

Fin.castLT in Init.Data.Fin.Basic

@[inline] def pred [Zero T] [ToNat T] (a : Cayley T) : Cayley T :=
  match (‚Üëa : Nat) with
  | 0 => zero
  | Nat.succ n => ofNat n

def hli_level_diff_0 (l : ‚Ñï) :
  letI instAlgebra:= ConcreteBTFieldAlgebra (l:=l) (r:=l) (h_le:=by omega)
  @Basis (Fin 1) (ConcreteBTField l) (ConcreteBTField l) _ _ instAlgebra.toModule :=

def finUInt32Equiv : Fin (2 ^ 32) ‚âÉ UInt32 where
  toFun := fun i => UInt32.ofFin i
  invFun := fun u => u.toFin
  left_inv _ := rfl
  right_inv _ := rfl

@[reducible]
def coreInteractionOracleReduction :=
  OracleReduction.append (oSpec:=[]‚Çí)
    (Stmt‚ÇÅ := Statement (L := L) (‚Ñì:=‚Ñì) (SumcheckBaseContext L ‚Ñì) 0)
    (Stmt‚ÇÇ := Statement (L := L) (‚Ñì:=‚Ñì) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì))
    (Stmt‚ÇÉ := FinalSumcheckStatementOut (L:=L) (‚Ñì:=‚Ñì))
    (Wit‚ÇÅ := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) 0)
    (Wit‚ÇÇ := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) (Fin.last ‚Ñì))
    (Wit‚ÇÉ := Unit)
    (OStmt‚ÇÅ := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë 0)
    (OStmt‚ÇÇ := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (OStmt‚ÇÉ := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (pSpec‚ÇÅ := pSpecSumcheckFold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (pSpec‚ÇÇ := pSpecFinalSumcheckStep (L:=L))
    (R‚ÇÅ := sumcheckFoldOracleReduction ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë))
    (R‚ÇÇ := finalSumcheckOracleReduction ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))

@[reducible]
def batchSpec (F : Type) (m : ‚Ñï) : ProtocolSpec 1 := ‚ü®!v[.V_to_P], !v[Fin m ‚Üí F]‚ü©

instance instTestLensComplete : testLens.IsComplete
      outerRelIn_Test innerRelIn_Test outerRelOut_Test innerRelOut_Test
      (fun ‚ü®‚ü®p, q, _‚ü©, _‚ü© ‚ü®‚ü®f, _‚ü©, _‚ü© => p * q = f) where
  proj_complete := fun ‚ü®p, q, t‚ü© () hRelIn => by admit /- proof elided -/

@[reducible]
def messageLength (vPSpec : VectorSpec n) (i : MessageIdx vPSpec) : Nat := vPSpec.length i

noncomputable def E_and_Q_to_a_solution (e : ‚Ñï) (E Q : Polynomial F) (i : Fin n) : F :=
  if i < e then E.toFinsupp i else Q.toFinsupp (i - e)

zsmulRec in Mathlib.Algebra.Group.Defs

@[inline]
def ofInputOnly (projStmt : OuterStmtIn ‚Üí InnerStmtIn) :
    Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn OuterStmtOut :=
  ‚ü®projStmt, fun _ => id‚ü©

def take (j : Fin (k + 1)) (challenges : ChallengesUpTo k pSpec) :
    ChallengesUpTo (j.castLE (by admit /- proof elided -/
    )) pSpec :=
  fun i => challenges ‚ü®i.val.castLE (by admit /- proof elided -/
  ), i.property‚ü©

def FullData.map {Œ± Œ≤ : Type} (f : Œ± ‚Üí Œ≤) {s : Skeleton}
    (tree : FullData Œ± s) : FullData Œ≤ s :=
  match tree with
  | FullData.leaf value => FullData.leaf (f value)
  | FullData.internal value left right =>
    FullData.internal (f value) (left.map f) (right.map f)

def append' (so‚ÇÅ : SimOracle.Stateful spec‚ÇÅ spec‚Çú‚ÇÅ œÉ) (so‚ÇÇ : SimOracle.Stateful spec‚ÇÇ spec‚Çú‚ÇÇ œÑ) :
    SimOracle.Stateful (spec‚ÇÅ ++‚Çí spec‚ÇÇ) (spec‚Çú‚ÇÅ ++‚Çí spec‚Çú‚ÇÇ) (œÉ √ó œÑ) where
  impl
  | query (.inl i) t => fun (s‚ÇÅ, s‚ÇÇ) ‚Ü¶ do
      let (u, s‚ÇÅ') ‚Üê so‚ÇÅ.impl (query i t) s‚ÇÅ; return (u, s‚ÇÅ', s‚ÇÇ)
  | query (.inr i) t => fun (s‚ÇÅ, s‚ÇÇ) ‚Ü¶ do
      let (u, s‚ÇÇ') ‚Üê so‚ÇÇ.impl (query i t) s‚ÇÇ; return (u, s‚ÇÅ, s‚ÇÇ')

def bitVecToString (width : ‚Ñï) (bv : BitVec width) : String :=
  Fin.foldl width (fun (s : String) (idx : Fin width) =>
    
    
    s.push (if BitVec.getLsb bv (Fin.rev idx) then '1' else '0')
  ) ""

def vflatten {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (v : (i : Fin m) ‚Üí Fin (n i) ‚Üí Œ±) :
    Fin (vsum n) ‚Üí Œ± :=
  dflatten v

@[reducible, simp] def StmtOut := Query OStatement √ó Response OStatement

AffineSubspace in Mathlib.LinearAlgebra.AffineSpace.AffineSubspace.Defs

def StraightlineExtractor (oSpec : OracleSpec Œπ) (Data Commitment : Type) :=
  Commitment ‚Üí QueryLog oSpec ‚Üí Data

noncomputable def getFoldProverFinalOutput (i : Fin ‚Ñì)
    (finalPrvState : foldPrvState ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      i 2 (Context := Context)) :
  ((Statement (L := L) Context i.succ √ó ((j : Fin (toOutCodewordsCount ‚Ñì œë i.castSucc)) ‚Üí
    OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j))
      √ó Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ) :=

def relayPrvState (i : Fin ‚Ñì) : Fin (0 + 1) ‚Üí Type := fun
  | ‚ü®0, _‚ü© => Statement (L := L) Context i.succ √ó
    (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j) √ó
    Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ

def relation (cs : ConstraintSystem ùì° numWires numGates) (‚Ñì : ‚Ñï) (h‚Ñì : ‚Ñì ‚â§ numWires) :
    (publicInputs : Fin ‚Ñì ‚Üí ùì°) ‚Üí (privateWitness : Fin (numWires - ‚Ñì) ‚Üí ùì°) ‚Üí Prop :=
  fun (x : Fin ‚Ñì ‚Üí ùì°) (œâ : Fin (numWires - ‚Ñì) ‚Üí ùì°) =>
    let combined := Fin.append x œâ ‚àò Fin.cast (by admit /- proof elided -/
    )
    cs.accepts combined

Finset.filterMap in Mathlib.Data.Finset.Image

@[reducible]
def C : R ‚Üí+* P := algebraMap R P

abbrev RScodeSet (domain : Œπ ‚Ü™ F) (deg : ‚Ñï) : Set (Œπ ‚Üí F) := (ReedSolomon.code domain deg).carrier

def getMidCodewords {i : Fin (‚Ñì + 1)} (t : L‚¶É‚â§ 1‚¶Ñ[X Fin ‚Ñì]) 
    (challenges : Fin i ‚Üí L) : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i, by admit /- proof elided -/
    ‚ü©) ‚Üí L) :=
  let P‚ÇÄ : L‚¶É< 2^‚Ñì‚¶Ñ[X] := polynomialFromNovelCoeffsF‚ÇÇ ùîΩq Œ≤ ‚Ñì (by admit /- proof elided -/
  ) (fun œâ => t.val.eval œâ)
  let f‚ÇÄ : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate 0) ‚Üí L := fun x => P‚ÇÄ.val.eval x.val
  let f·µ¢ := iterated_fold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
    (i := 0)
    (steps := i)
    (h_i_add_steps := by admit /- proof elided -/
      )
    (f := f‚ÇÄ)
    (r_challenges := challenges)
  fun x => f·µ¢ ‚ü®x, by admit /- proof elided -/
  ‚ü©

GaloisField in Mathlib.FieldTheory.Finite.GaloisField

abbrev Field := ZMod fieldSize

def zero {k : ‚Ñï} : ConcreteBTField k := BitVec.zero (2 ^ k)

@[inline] def ofNat (k : Nat) : AssocNat :=
  ‚ü®fun m => m + k, fun m => Nat.succ_add m k‚ü©

instance [IsSingleRound pSpec] [h : VCVCompatible (pSpec.Challenge default)] :
    (i : pSpec.ChallengeIdx) ‚Üí VCVCompatible (pSpec.Challenge i) := fun i => by admit /- proof elided -/

RingHomCompTriple in Mathlib.Algebra.Ring.CompTypeclasses

def toStatement (stmt : FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì)) :
  Statement (L := L) (Context := SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì)  :=
  {
    sumcheck_target := stmt.sumcheck_target,
    challenges := stmt.challenges,
    ctx := stmt.ctx
  }

Finset.Ici in Mathlib.Order.Interval.Finset.Defs

Polynomial in Mathlib.Algebra.Polynomial.Basic

def finIdxOf [BEq Œ±] [LawfulBEq Œ±] (a : Œ±) (l : List Œ±) : Fin (l.length + 1) :=
  ‚ü®List.idxOf' a l, Nat.lt_succ_of_le (by admit /- proof elided -/
  )‚ü©

@[inline]
def permute (params : Params) (state : Vector KoalaBear.Field params.width) :
    Vector KoalaBear.Field params.width :=
  letI rcs := params.roundConstants

  
  let st0 := externalLinearLayer params state

  
  let st1 : Vector KoalaBear.Field params.width :=
    Fin.foldl params.halfNumFullRounds (fun st_acc rc_idx =>
      let rc_chunk := (rcs.extract rc_idx (rc_idx + params.width)).cast (by admit /- proof elided -/
      )
      let st_new := fullRound params st_acc rc_chunk
      st_new) st0

  
  let rcs := rcs.drop (params.halfNumFullRounds * params.width)

  
  let st2 := Fin.foldl params.numPartialRounds (fun st_acc rc_idx =>
    let rc_val := rcs[rc_idx]'(sorry)
    let st_new := partialRound params st_acc rc_val
    st_new) st1

  
  let rcs := rcs.drop params.numPartialRounds

  
  let st3 := Fin.foldl params.halfNumFullRounds (fun st_acc rc_idx =>
    let rc_chunk := (rcs.extract rc_idx (rc_idx + params.width)).cast (by admit /- proof elided -/
    )
    let st_new := fullRound params st_acc rc_chunk
    st_new) st2

  st3

def Array.toFinVec {Œ± : Type _} (n : ‚Ñï) (arr : Array Œ±) (h : arr.size = n) : Fin n ‚Üí Œ± :=
  fun i => arr[i]

def StateRestoration (oSpec : OracleSpec Œπ)
    (StmtIn WitIn WitOut : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n) :=
  StmtIn ‚Üí 
  WitOut ‚Üí 
  pSpec.FullTranscript ‚Üí 
  QueryLog (oSpec ++‚Çí (srChallengeOracle StmtIn pSpec)) ‚Üí 
  QueryLog oSpec ‚Üí 
  OracleComp oSpec WitIn 

def queryKStateProp {m : Fin (1 + 1)}
  (tr : ProtocolSpec.Transcript m
    (pSpecQuery ùîΩq Œ≤ Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)))
  (stmt : FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì))
  (witMid : Unit)
  (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤ (œë := œë)
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì) j) : Prop :=
if h0 : m.val = 0 then
  
  Binius.BinaryBasefold.finalSumcheckRelOutProp ùîΩq Œ≤ (input:=‚ü®‚ü®stmt, oStmt‚ü©, witMid‚ü©)
else
    let r := stmt.ctx.t_eval_point
    let s := stmt.ctx.original_claim
    let challenges : Fin ‚Ñì ‚Üí L := stmt.challenges
    let tr_so_far := (pSpecQuery ùîΩq Œ≤ Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).take m m.is_le
    let chalIdx : tr_so_far.ChallengeIdx := ‚ü®‚ü®0,
      Nat.lt_of_succ_le (by admit /- proof elided -/
      )‚ü©, by admit /- proof elided -/
      ‚ü©
    let Œ≥_challenges : Fin Œ≥_repetitions ‚Üí sDomain ùîΩq
      Œ≤ h_‚Ñì_add_R_rate ‚ü®0, by admit /- proof elided -/
      ‚ü© := ((ProtocolSpec.Transcript.equivMessagesChallenges (k:=m)
        (pSpec:=pSpecQuery ùîΩq Œ≤ Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
        tr).2 chalIdx)
    let fold_challenges := stmt.challenges
    
    let proximityTestsCheck : Prop :=
      proximityChecksSpec ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (œë:=œë) Œ≥_repetitions Œ≥_challenges oStmt fold_challenges stmt.final_constant
    proximityTestsCheck

def PlainMessages (pSpec : ProtocolSpec n) [OracleInterfaces pSpec] : Type :=
  ‚àÄ i, pSpec.PlainMessage i

instance [Inhabited C] [Permute C] : DuplexSpongeInterface U (DuplexSponge U C) where
  absorbUnchecked := fun (sponge, arr) => absorbUnchecked sponge arr
  squeezeUnchecked := fun (sponge, arr) => squeezeUnchecked sponge arr
  ratchetUnchecked := ratchetUnchecked

def isBoolean {R : Type _} [Zero R] [One R] (a : Array R) : Prop :=
    ‚àÄ i : Fin a.size, (a[i] = 0) ‚à® (a[i] = 1)

@[reducible]
def foldCommitOracleVerifier (i : Fin ‚Ñì) (hCR : isCommitmentRound ‚Ñì œë i) :
  OracleVerifier []‚Çí
    (StmtIn := Statement (L := L) Context i.castSucc)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.succ)
    (pSpec := pSpecFoldCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) :=
    OracleVerifier.append (oSpec:=[]‚Çí)
      (pSpec‚ÇÅ := pSpecFold (L:=L))
      (pSpec‚ÇÇ := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)
      (V‚ÇÅ := foldOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)
      (V‚ÇÇ := commitOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hCR)

def OracleSpec.proverOracle (StmtIn : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n) :
    OracleSpec pSpec.MessageIdx :=
  fun i => (StmtIn √ó pSpec.Transcript i.val.castSucc, pSpec.Message i)

def divide_by_2 (s : Finset ‚Ñï) : Finset ‚Ñï :=
  (erase_odd s).image (fun n => n / 2)

class IsCyclicWithGen (G : Type) [Pow G ‚Ñ§] where
  gen : G
  zpow_surjective : Function.Surjective (gen ^ ¬∑ : ‚Ñ§ ‚Üí G)

def BBF_SumcheckMultiplierParam : SumcheckMultiplierParam L ‚Ñì (SumcheckBaseContext L ‚Ñì) :=
  { multpoly := fun ctx => BBF_eq_multiplier ctx.t_eval_point }

def neg_descending (p : UniPoly R) : QuotientUniPoly R :=
  Quotient.mk _ (neg p)

instance (priority := high) : MonadLiftT (OracleComp []‚Çí) (OracleComp spec) where
  monadLift := OracleComp.construct pure (fun a => by admit /- proof elided -/
  ) failure

def sumCases {l : List ‚Ñï} {motive : Fin l.sum ‚Üí Sort*}
    (cases : ‚àÄ (n : ‚Ñï) (h : n ‚àà l) (i : Fin n), motive (castSum l h i))
    (i : Fin l.sum) : motive i := match l with
  | [] => by admit /- proof elided -/
  | n' :: l' => by admit /- proof elided -/

instance polyIrreducibleFact (n : ‚Ñï) : Fact (Irreducible (poly n)) := ‚ü®polyIrreducible n‚ü©

def concat' {k : Fin n}
    (messages : (i : Fin k) ‚Üí (pSpec.dir (i.castLE (by admit /- proof elided -/
    )) = .P_to_V
      ‚Üí pSpec.¬´Type¬ª (i.castLE (by admit /- proof elided -/
      ))))
    (msg : (h : pSpec.dir k = .P_to_V) ‚Üí pSpec.Message ‚ü®k, h‚ü©) :
    (i : Fin (k + 1)) ‚Üí (pSpec.dir (i.castLE (by admit /- proof elided -/
    )) = .P_to_V) ‚Üí
      pSpec.¬´Type¬ª (i.castLE (by admit /- proof elided -/
      )) :=
  Fin.dconcat messages msg

@[reducible, inline]
instance instPolynomialDegreeLE : OracleInterface (R‚¶É‚â§ d‚¶Ñ[X]) where
  Query := R
  Response := R
  answer := fun ‚ü®poly, _‚ü© point => poly.eval point

def simulateQ' (oa : OracleComp spec Œ±) (h : oa.neverFails) : m Œ± :=

instance (priority := low) : DCast‚ÇÇ Œ± Œ≤ Œ≥ where
  dcast‚ÇÇ ha hb c := by admit /- proof elided -/

def commit (srs : Vector G‚ÇÅ n) (coeffs : Fin n ‚Üí ZMod p) : G‚ÇÅ :=
  ‚àè i : Fin n, srs[i] ^ (coeffs i).val

noncomputable def qMap_total_fiber
    
      (i : Fin r) (steps : ‚Ñï) (h_i_add_steps : i.val + steps < ‚Ñì + ùì°)
        (y : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i.val + steps, by admit /- proof elided -/
        ‚ü©)) :
    Fin (2 ^ steps) ‚Üí sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i :=
  if h_steps : steps = 0 then by
    
    subst h_steps
    simp only [add_zero, Fin.eta] at y
    exact fun _ => y
  else by
    
    let basis_y := sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i+steps,by admit /- proof elided -/
    ‚ü©) (by admit /- proof elided -/
    )
    let y_coeffs : Fin (‚Ñì + ùì° - (‚Üëi + steps)) ‚Üí‚ÇÄ ùîΩq := basis_y.repr y

    let basis_x := sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i, by admit /- proof elided -/
    ‚ü© (by admit /- proof elided -/
    )
    exact fun elementIdx => by admit /- proof elided -/

instance [Zero T] [ToNat T] : DecidableEq (Cayley T) := fun a b =>
  if h : (‚Üëa : Nat) = (‚Üëb : Nat) then
    isTrue (by admit /- proof elided -/
      )
  else
    isFalse (fun heq => h (by admit /- proof elided -/
    ))

MvPolynomial.eval‚ÇÇHom in Mathlib.Algebra.MvPolynomial.Eval

class GenMutualCorrParams (P : Params Œπ F) (S : ‚àÄ i : Fin (M + 1), Finset (Œπ i)) where

  Œ¥ : Fin (M + 1) ‚Üí ‚Ñù‚â•0
  dist : (i : Fin (M + 1)) ‚Üí Fin ((P.foldingParam i) + 1) ‚Üí ‚Ñù‚â•0


  œÜ : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), (indexPowT (S i) (P.œÜ i) j) ‚Ü™ F

  inst1 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Fintype (indexPowT (S i) (P.œÜ i) j)
  inst2 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    Nonempty (indexPowT (S i) (P.œÜ i) j)
  inst3 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    DecidableEq (indexPowT (S i) (P.œÜ i) j)
  inst4 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Smooth (œÜ i j)

  par‚Ñì_type : ‚àÄ i : Fin (M + 1), ‚àÄ _ : Fin ((P.foldingParam i) + 1), Type
  inst5 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Fintype (par‚Ñì_type i j)

  exp : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), (par‚Ñì_type i j) ‚Ü™ ‚Ñï



  Gen_Œ± : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    ProximityGenerator (indexPowT (S i) (P.œÜ i) j) F :=
      fun i j => RSGenerator.genRSC (par‚Ñì_type i j) (œÜ i j) (P.varCount i - j) (exp i j)

  inst6 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Fintype (Gen_Œ± i j).par‚Ñì

  BStar : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    (Set ((indexPowT (S i) (P.œÜ i) j) ‚Üí F)) ‚Üí Type ‚Üí ‚Ñù‚â•0
  errStar : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    (Set ((indexPowT (S i) (P.œÜ i) j) ‚Üí F)) ‚Üí Type ‚Üí ‚Ñù ‚Üí ENNReal

  C : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Set ((indexPowT (S i) (P.œÜ i) j) ‚Üí F)
  hcode : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), (C i j) = (Gen_Œ± i j).C

  h : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    hasMutualCorrAgreement (Gen_Œ± i j)
      (BStar i j (C i j) (Gen_Œ± i j).par‚Ñì)
      (errStar i j (C i j) (Gen_Œ± i j).par‚Ñì)

  h‚Ñì_bound : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    Fintype.card (Gen_Œ± i j).par‚Ñì = 2
  h‚Ñì_bound' : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    Fintype.card (par‚Ñì_type i j) = 2

  hŒ¥Le : ‚àÄ i : Fin (M + 1),
    (Œ¥ i) ‚â§ 1 - Finset.univ.sup (fun j => BStar i j (C i j) (Gen_Œ± i j).par‚Ñì)

  hlistDecode : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    listDecodable (C i j) (Œ¥ i) (dist i j)

structure StateFunction
    (langIn : Set StmtIn) (langOut : Set StmtOut)
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    where
  toFun : (m : Fin (n + 1)) ‚Üí StmtIn ‚Üí Transcript m pSpec ‚Üí Prop
   
  toFun_empty : ‚àÄ stmt, stmt ‚àà langIn ‚Üî toFun 0 stmt default
   
  toFun_next : ‚àÄ m, pSpec.dir m = .P_to_V ‚Üí
    ‚àÄ stmt tr, ¬¨ toFun m.castSucc stmt tr ‚Üí
    ‚àÄ msg, ¬¨ toFun m.succ stmt (tr.concat msg)
   
  toFun_full : ‚àÄ stmt tr, ¬¨ toFun (.last n) stmt tr ‚Üí
    [(¬∑ ‚àà langOut) | do (simulateQ impl (verifier.run stmt tr)).run' (‚Üê init)] = 0

noncomputable def relayOracleReduction (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
  OracleReduction (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) Context i.succ)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (pSpec := pSpecRelay) where
  prover := relayOracleProver ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hNCR
  verifier := relayOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hNCR

def vcons {n : ‚Ñï} (a : Œ±) (v : Fin n ‚Üí Œ±) : Fin (n + 1) ‚Üí Œ± :=
  dcons a v

@[inline, reducible]
protected def id :
    Statement.Lens OuterStmtIn OuterStmtOut OuterStmtIn OuterStmtOut :=
  PFunctor.Lens.id _

alias trivial := Statement.Lens.id

def map (f : R ‚Üí+* S) (p : MlPolyEval R n) : MlPolyEval S n :=
  Vector.map (fun a => f a) p

@[inline, specialize]
def prover : Prover oSpec Statement Witness (Statement √ó Witness) Unit (pSpec Witness) where
  PrvState
  | 0 => Statement √ó Witness
  | 1 => Statement √ó Witness
  input := id
  sendMessage | ‚ü®0, _‚ü© => fun ‚ü®stmt, wit‚ü© => pure (wit, ‚ü®stmt, wit‚ü©)
  receiveChallenge | ‚ü®0, h‚ü© => nomatch h
  output := fun ‚ü®stmt, wit‚ü© => pure (‚ü®stmt, wit‚ü©, ())

structure Params where
  
  width : Nat
  numFullRounds : Nat
  numPartialRounds : Nat
  internalDiagVectors : Vector KoalaBear.Field width
  roundConstants : Vector KoalaBear.Field (numFullRounds * width + numPartialRounds)

  

   
  [width_ne_zero : NeZero width]

   
  [numFullRounds_ne_zero : NeZero numFullRounds]

   
  [numPartialRounds_ne_zero : NeZero numPartialRounds]

   
  width_dvd_by_4 : 4 ‚à£ width
   
  numFullRounds_even : Even numFullRounds

instance {k : ‚Ñï} : NeZero (1 : ConcreteBTField k) :=

Polynomial.Monic in Mathlib.Algebra.Polynomial.Degree.Definitions

def AlgebraTowerEquiv.toAlgebraOverRight (e : AlgebraTowerEquiv A B) (i j : Œπ)
    (h : i ‚â§ j) : Algebra (B i) (A j) :=

instance instST‚ÇÇ [SelectableType R] : ‚àÄ i, SelectableType
    ((‚ü®!v[.P_to_V], !v[R‚¶É‚â§ deg‚¶Ñ[X]]‚ü© ++‚Çö !p[] ++‚Çö ‚ü®!v[.V_to_P], !v[R]‚ü©).Challenge i) :=
  instSelectableTypeChallengeAppend

noncomputable def sDomainToFin (i : Fin r) (h_i : i < ‚Ñì + R_rate)
  (x : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i) :
  Fin (2^(‚Ñì + R_rate - i.val)) :=

BitVec.ofNat in Init.Prelude

@[reducible]
def pSpec (F : Type) [Semiring F] : ProtocolSpec 2 := ‚ü®!v[.V_to_P, .P_to_V], !v[F, Unit ‚Üí F[X]]‚ü©

def powerBasisSucc (k : ‚Ñï) :
    PowerBasis (BTField k) (BTField (k+1)) :=

AdjoinRoot.instField in Mathlib.RingTheory.AdjoinRoot

def AlgebraTowerEquiv.algebraMapLeftUp (e : AlgebraTowerEquiv A B) (i j : Œπ)
    (h : i ‚â§ j) : (B i) ‚Üí+* (A j) :=

def rawConstants16 : Vector KoalaBear.Field 148 := #v[
    2128964168,
    288780357,
    316938561,
    2126233899,
    426817493,
    1714118888,
    1045008582,
    1738510837,
    889721787,
    8866516,
    681576474,
    419059826,
    1596305521,
    1583176088,
    1584387047,
    1529751136,
    1863858111,
    1072044075,
    517831365,
    1464274176,
    1138001621,
    428001039,
    245709561,
    1641420379,
    1365482496,
    770454828,
    693167409,
    757905735,
    136670447,
    436275702,
    525466355,
    1559174242,
    1030087950,
    869864998,
    322787870,
    267688717,
    948964561,
    740478015,
    679816114,
    113662466,
    2066544572,
    1744924186,
    367094720,
    1380455578,
    1842483872,
    416711434,
    1342291586,
    1692058446,
    1493348999,
    1113949088,
    210900530,
    1071655077,
    610242121,
    1136339326,
    2020858841,
    1019840479,
    678147278,
    1678413261,
    1361743414,
    61132629,
    1209546658,
    64412292,
    1936878279,
    1980661727,
    1423960925,
    2101391318,
    1915532054,
    275400051,
    1168624859,
    1141248885,
    356546469,
    1165250474,
    1320543726,
    932505663,
    1204226364,
    1452576828,
    1774936729,
    926808140,
    1184948056,
    1186493834,
    843181003,
    185193011,
    452207447,
    510054082,
    1139268644,
    630873441,
    669538875,
    462500858,
    876500520,
    1214043330,
    383937013,
    375087302,
    636912601,
    307200505,
    390279673,
    1999916485,
    1518476730,
    1606686591,
    1410677749,
    1581191572,
    1004269969,
    143426723,
    1747283099,
    1016118214,
    1749423722,
    66331533,
    1177761275,
    1581069649,
    1851371119,
    852520128,
    1499632627,
    1820847538,
    150757557,
    884787840,
    619710451,
    1651711087,
    505263814,
    212076987,
    1482432120,
    1458130652,
    382871348,
    417404007,
    2066495280,
    1996518884,
    902934924,
    582892981,
    1337064375,
    1199354861,
    2102596038,
    1533193853,
    1436311464,
    2012303432,
    839997195,
    1225781098,
    2011967775,
    575084315,
    1309329169,
    786393545,
    995788880,
    1702925345,
    1444525226,
    908073383,
    1811535085,
    1531002367,
    1635653662,
    1585100155,
    867006515,
    879151050,
]

def ofMvPolynomialDeg1 (p : R‚¶É‚â§ 1‚¶Ñ[X Fin n]) : MlPoly R n :=
  Vector.ofFn (fun i : Fin (2 ^ n) => p.val.coeff (monomialOfNat i))

def add_descending (p q : UniPoly R) : QuotientUniPoly R :=
  Quotient.mk _ (add p q)

id in Init.Prelude

def natCast_succ {k : ‚Ñï} (n : ‚Ñï) : natCast (k:=k) (n + 1) = natCast (k:=k) n + 1 :=

instance : ‚àÄ i, VCVCompatible ((pSpec Witness).Challenge i) | ‚ü®0, h‚ü© => nomatch h

def isScalarTower_succ_right (l r : ‚Ñï) (h_le : l ‚â§ r) :=
    instAlgebraTowerConcreteBTF.toIsScalarTower (i:=l) (j:=r) (k:=r+1)
    (h1:=by admit /- proof elided -/
    ) (h2:=by admit /- proof elided -/
    )

Fin.cons in Mathlib.Data.Fin.Tuple.Basic

finProdFinEquiv in Mathlib.Logic.Equiv.Fin.Basic

instance : Fintype (pSpec.MessageIdx) := Subtype.fintype (fun i => pSpec.dir i = .P_to_V)

@[reducible, simp] def WitOut := Unit

inline in Init.Core

instance [Zero T] [ToNat T] : Mul (Cayley T) where
  mul := mul

OracleComp.inductionOn in VCVio.OracleComp.OracleComp

abbrev MatrixSubmodule.{u, v, w} (Œ∫ : Type u) [Fintype Œ∫] (Œπ : Type v) [Fintype Œπ]
                                 (F : Type w) [Semiring F] : Type (max u v w) :=
  Submodule F (Matrix Œ∫ Œπ F)

CommMonoidWithZero in Mathlib.Algebra.GroupWithZero.Defs

def proverOutput (i : Fin n) : ProverOutput oSpec
    ((StatementRound R n i.succ √ó (‚àÄ i, OracleStatement R n deg i)) √ó Unit)
    ((proverState R n deg i).PrvState (Fin.last 2)) where
  output := fun x => pure (x, ())

instance {Œ± : Type u} : Slice (List Œ±) Nat Nat (fun _ _ _ => True) (fun _ _ _ _ => List Œ±) where
  slice xs start stop _ := xs.extract start stop

structure Size where
  m : ‚Ñï 
  n : ‚Ñï 
  n_w : ‚Ñï 
  n_w_le_n : n_w ‚â§ n := by admit /- proof elided -/

CommRing in Mathlib.Algebra.Ring.Defs

def getConst (F : Type) [NonBinaryField F] : OracleComp [(pSpec F).Message]‚Çí F[X] :=
  OracleComp.lift
    (by admit /- proof elided -/
    )

instance : Unique (ChallengesUpTo 0 pSpec) where
  default := fun ‚ü®i, _‚ü© => Fin.elim0 i
  uniq := fun T => by admit /- proof elided -/

@[simp]
instance BTFieldIsField (k : ‚Ñï) : Field (BTField k) := (BinaryTowerAux k).2.instField

One in Init.Prelude

def oracleWitnessConsistency
    (stmtIdx : Fin (‚Ñì + 1)) (oracleIdx : Fin (‚Ñì + 1))
    (h_le : oracleIdx.val ‚â§ stmtIdx.val) (stmt : Statement (L := L) (Context := Context) stmtIdx)
    (wit : Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) stmtIdx)
    (oStmt : ‚àÄ j, (OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      œë (i := oracleIdx) j)) : Prop :=
  let witnessStructuralInvariant: Prop := witnessStructuralInvariant (mp := mp) (i:=stmtIdx) ùîΩq Œ≤
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) stmt wit
  let sumCheckConsistency: Prop := sumcheckConsistencyProp (ùìë := ùìë) stmt.sumcheck_target wit.H
  let firstOracleConsistency: Prop := firstOracleWitnessConsistencyProp ùîΩq Œ≤
    wit.t (getFirstOracle ùîΩq Œ≤ oStmt)
  let oracleFoldingConsistency: Prop := oracleFoldingConsistencyProp ùîΩq Œ≤ oracleIdx
    (challenges := Fin.take (m := oracleIdx) (v := stmt.challenges) (h := by admit /- proof elided -/
    ))
    (oStmt := oStmt)
  witnessStructuralInvariant ‚àß sumCheckConsistency ‚àß firstOracleConsistency ‚àß
    oracleFoldingConsistency

@[simp]
abbrev Statement.AfterFirstSumcheck : Type :=
  FirstSumcheckChallenge R pp √ó Statement.AfterFirstChallenge R pp

noncomputable def evenize (f : Polynomial F) : Polynomial F :=
  match f with
  | ‚ü®‚ü®supp, g, h‚ü©‚ü© => ‚ü®‚ü®mul_by_2 supp, fun n => if Even n then g (n / 2) else 0, by admit /- proof elided -/
  ‚ü©‚ü©

@[reducible, simp]
def toRelOut : Set ((Statement √ó Witness) √ó Unit) :=
  Prod.fst ‚Åª¬π' relIn

@[inline, reducible]
def OracleStatement.Lens (OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut : Type)
    {Outer_Œπ‚Çõ·µ¢ : Type} (OuterOStmtIn : Outer_Œπ‚Çõ·µ¢ ‚Üí Type) [‚àÄ i, OracleInterface (OuterOStmtIn i)]
    {Outer_Œπ‚Çõ‚Çí : Type} (OuterOStmtOut : Outer_Œπ‚Çõ‚Çí ‚Üí Type) [‚àÄ i, OracleInterface (OuterOStmtOut i)]
    {Inner_Œπ‚Çõ·µ¢ : Type} (InnerOStmtIn : Inner_Œπ‚Çõ·µ¢ ‚Üí Type) [‚àÄ i, OracleInterface (InnerOStmtIn i)]
    {Inner_Œπ‚Çõ‚Çí : Type} (InnerOStmtOut : Inner_Œπ‚Çõ‚Çí ‚Üí Type) [‚àÄ i, OracleInterface (InnerOStmtOut i)]
  :=
    Statement.Lens (OuterStmtIn √ó ‚àÄ i, OuterOStmtIn i) (OuterStmtOut √ó ‚àÄ i, OuterOStmtOut i)
                  (InnerStmtIn √ó ‚àÄ i, InnerOStmtIn i) (InnerStmtOut √ó ‚àÄ i, InnerOStmtOut i)

def LeafData.leftSubtree {Œ± : Type} {s_left s_right : Skeleton}
    (tree : LeafData Œ± (Skeleton.internal s_left s_right)) :
    LeafData Œ± s_left :=
  match tree with
  | LeafData.internal left _right =>
    left

def rbrKnowledgeSoundness
    (relIn : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (verifier : OracleVerifier oSpec Statement OStatement Bool (fun _ : Empty => Unit) pSpec)
    (rbrKnowledgeError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) : Prop :=
  verifier.rbrKnowledgeSoundness init impl relIn acceptRejectOracleRel rbrKnowledgeError

def towerAlgebraMap (l r : ‚Ñï) (h_le : l ‚â§ r) : BTField l ‚Üí+* BTField r :=

instance [Zero T] [ToNat T] : DecidableRel (@LT.lt (Cayley T) _) := fun a b =>
  Nat.decLt (‚Üëa) (‚Üëb)

noncomputable def commitOracleReduction (i : Fin ‚Ñì) (hCR : isCommitmentRound ‚Ñì œë i) :
  OracleReduction (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) Context i.succ)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (pSpec := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) where
  prover := commitOracleProver ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i
  verifier := commitOracleVerifier ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hCR

@[ext]
structure ProtocolSpec (n : ‚Ñï) where
   
  dir : Fin n ‚Üí Direction
   
  ¬´Type¬ª : Fin n ‚Üí Type
deriving Inhabited

def Transcript.removeSalt {k : Fin (n + 1)} (transcript : (pSpec.addSalt Salt).Transcript k) :
    pSpec.Transcript k :=

  fun i => by admit /- proof elided -/

EDist in Mathlib.Topology.EMetricSpace.Defs

def starData {Œ±} (k : ‚Ñï) (root : Œ±) (leaves : Fin k ‚Üí Œ±) :
    ArityTree.Data Œ± (starSkel k) :=

def MyTypeVec : Fin 3 ‚Üí Type := !v[‚Ñï, Bool, String]

example : !d‚ü®MyTypeVec‚ü©[(1 : ‚Ñï), true, "hello"] =
  (!h[1, true, "hello"] : (i : Fin 3) ‚Üí MyTypeVec i) := rfl


example : !d‚ü®!v[]‚ü©[] = (Fin.dempty : (i : Fin 0) ‚Üí !v[] i) := rfl


example : !d‚ü® !v[‚Ñï, Bool, String] ‚ü©[(1 : ‚Ñï), (true : Bool), ("hello" : String)] =
  Fin.dcons (1 : ‚Ñï) (Fin.dcons true (Fin.dcons "hello" Fin.dempty)) := rfl


example : let motive : Fin 2 ‚Üí Type := fun i => if i = 0 then ‚Ñï else Bool
          !d‚ü®motive‚ü©[(1 : ‚Ñï), (true : Bool)] =
          (Fin.dcons (1 : ‚Ñï) (Fin.dcons (true : Bool) Fin.dempty) : (i : Fin 2) ‚Üí motive i) := rfl

def mul_by_2 (s : Finset ‚Ñï) : Finset ‚Ñï :=
  s.map ‚ü®fun n => 2 * n, by admit /- proof elided -/
  ‚ü©

Equiv.ofBijective in Mathlib.Logic.Equiv.Defs

@[inline] def add (a b : Cayley T) : Cayley T :=
  ‚ü®a.toFun ‚àò b.toFun, by admit /- proof elided -/
  ‚ü©

instance instOI‚ÇÇ : ‚àÄ i, OracleInterface
    ((‚ü®!v[.P_to_V], !v[R‚¶É‚â§ deg‚¶Ñ[X]]‚ü© ++‚Çö !p[] ++‚Çö ‚ü®!v[.V_to_P], !v[R]‚ü©).Message i) :=
  instOracleInterfaceMessageAppend

def combined : Prop :=
  capacitySegmentDup trace ‚à® notFunction trace

alias E := combined

def concreteTowerAlgebraMap (l r : ‚Ñï) (h_le : l ‚â§ r) :
    ConcreteBTField l ‚Üí+* ConcreteBTField r :=

instance {Œ± : Type u} : SliceLT (List Œ±) Nat (fun _ _ => True) (fun _ _ _ => List Œ±) where
  sliceLT xs stop _ := List.take stop xs

def rho (n : ‚Ñï) : Option ‚Ñï := Id.run do
  for st in [2:n] do
    for c in [1:n] do
      if let some d := rho' n st c then
        return some d

  return none

def subNat (c : AssocNat) : Nat ‚Üí AssocNat
| 0            => c 
| Nat.succ k   => pred (subNat c k) 

@[inline, specialize]
def add {R : Type*} [Ring R] [BEq R] [LawfulBEq R] (p q : QuotientUniPoly R) : QuotientUniPoly R :=
  Quotient.lift‚ÇÇ add_descending add_descends p q

@[reducible]
def proverState (i : Fin n) : ProverState 2 where
  PrvState
  | 0 => (StatementRound R n i.castSucc) √ó (‚àÄ i, OracleStatement R n deg i)
  | 1 => (StatementRound R n i.castSucc) √ó (‚àÄ i, OracleStatement R n deg i)
  | 2 => (StatementRound R n i.succ) √ó (‚àÄ i, OracleStatement R n deg i)

instance instPow {n : ‚Ñï} : Pow (CNat n) Nat := match n with
  | 0 => by admit /- proof elided -/
  | .succ n => by admit /- proof elided -/

def proverRound (i : Fin n) : ProverRound oSpec (pSpec R deg) where
  PrvState := (proverState R n deg i).PrvState

  sendMessage
  | ‚ü®0, _‚ü© => fun state =>
    match n with
    | 0 => sorry
    | n + 1 =>
      let ‚ü®‚ü®_, challenges‚ü©, oStmt‚ü© := state
      let ‚ü®poly, hp‚ü© := oStmt 0
      pure ‚ü® ‚ü®‚àë x ‚àà (univ.map D) ^·∂† (n - i), poly ‚∏®X ‚¶Éi‚¶Ñ, challenges, x‚∏©'(by admit /- proof elided -/
      ),
        sumcheck_roundPoly_degreeLE R n deg D i hp‚ü©,
          state‚ü©
  | ‚ü®1, h‚ü© => nomatch h

  receiveChallenge
  | ‚ü®0, h‚ü© => nomatch h
  | ‚ü®1, _‚ü© => fun ‚ü®‚ü®target, challenges‚ü©, oStmt‚ü© => pure fun chal =>
    let ‚ü®poly, hp‚ü© := oStmt 0
    letI newChallenges : Fin i.succ ‚Üí R := Fin.snoc challenges chal
    letI newTarget := ‚àë x ‚àà (univ.map D) ^·∂† (n - i - 1), poly ‚∏®newChallenges, x‚∏©'(by admit /- proof elided -/
    )
    ‚ü®‚ü®newTarget, newChallenges‚ü©, fun _ => ‚ü®poly, hp‚ü©‚ü©

def squeeze (ds : DomainSeparator U H) (count : Nat) (label : String) : DomainSeparator U H :=
  
  
  
  
  { io := ds.io ++ SEP_BYTE ++ s!"S{count}" ++ label }

IO.FS.Stream.write in Init.System.IO

setOf in Mathlib.Data.Set.Defs

Iff in Init.Core

class HasSize (Œ± : Type*) (Œ≤ : Type*) where
  size : Nat
  toFun : Œ± ‚Ü™ Vector Œ≤ size

def dotProduct [Zero R] [Add R] [Mul R] (a b : Vector R n) : R :=
  a.zipWith (¬∑ * ¬∑) b |>.foldl (¬∑ + ¬∑) 0

@[reducible]
def MemoryRead (Œπ : Type u) (Œ± : Œπ ‚Üí Type v) := (index : Œπ) √ó (Œ± index)

@[reducible]
def GroupEncodeOracle : OracleSpec Unit := fun _ => (Œπ, BitVec bitLength)

Finset.min in Mathlib.Data.Finset.Max

noncomputable def uni2bi (p : Polynomial F) : MvPolynomial (Fin 2) F :=
  Polynomial.eval‚ÇÇ MvPolynomial.C (MvPolynomial.X 0) p

noncomputable def queryKnowledgeStateFunction {œÉ : Type} (init : ProbComp œÉ)
    (impl : QueryImpl []‚Çí (StateT œÉ ProbComp)) :
  (queryOracleVerifier ùîΩq Œ≤ (œë:=œë) Œ≥_repetitions).KnowledgeStateFunction init impl
  (relIn := finalSumcheckRelOut ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
  (relOut := acceptRejectOracleRel)
  (extractor := queryRbrExtractor ùîΩq Œ≤ (œë:=œë) Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)) where
  toFun := fun m ‚ü®stmt, oStmt‚ü© tr witMid =>
    queryKStateProp ùîΩq Œ≤ (œë:=œë) (Œ≥_repetitions:=Œ≥_repetitions)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (m:=m) (tr:=tr) (stmt:=stmt) (witMid:=witMid) (oStmt:=oStmt)
  toFun_empty := fun stmt witMid => by admit /- proof elided -/

MvPolynomial.degreeOf in Mathlib.Algebra.MvPolynomial.Degrees

@[reducible]
def Witness (F : Type) [Semiring F] {k : ‚Ñï} (s : Fin (k + 1) ‚Üí ‚Ñï+) (d : ‚Ñï+) (m : ‚Ñï) :=
  Fin (m + 1) ‚Üí F‚¶É< 2 ^ (‚àë i, (s i).1) * d‚¶Ñ[X]

Polynomial.monomial in Mathlib.Algebra.Polynomial.Basic

instance [VerifierFirst pSpec] [h : VCVCompatible (pSpec.¬´Type¬ª 0)] :
    ‚àÄ i, VCVCompatible (pSpec.Challenge i)
  | ‚ü®0, _‚ü© => inferInstance

class HListRepr (Œ± : Type _) where
  repr: Œ± ‚Üí Std.Format

ByteArray in Init.Prelude

noncomputable def toPolynomialAlgHom : P ‚Üí‚Çê[R] R[X] := PolynomialLike.aeval Polynomial.X

context in Examples.FrankingProtocol

@[inline, reducible]
def Witness.InvLens (OuterStmtIn OuterWitIn OuterWitOut InnerWitIn InnerWitOut : Type)
    := PFunctor.Lens ((OuterStmtIn √ó OuterWitOut) X^ OuterWitIn)
                     (InnerWitOut X^ InnerWitIn)

@[inline]
def add [Add R] (p q : MlPolyEval R n) : MlPolyEval R n := Vector.zipWith (¬∑ + ¬∑) p q

MvPolynomial.X in Mathlib.Algebra.MvPolynomial.Basic

def singleHash (left : Œ±) (right : Œ±) : OracleComp (spec Œ±) Œ± := do
  let out ‚Üê query (spec := spec Œ±) () ‚ü®left, right‚ü©
  return out

@[reducible]
def relation :
    (Fin sz.n_x ‚Üí R) ‚Üí 
    (MatrixIdx ‚Üí Matrix (Fin sz.m) (Fin sz.n) R) ‚Üí 
    (Fin sz.n_w ‚Üí R) ‚Üí 
    Prop :=
  fun stmt matrix wit =>
    letI ùï´ := ùï´ stmt wit
    (matrix .A *·µ• ùï´) * (matrix .B *·µ• ùï´) = (matrix .C *·µ• ùï´)

def ratchet (sponge : DuplexSponge U C) :
    OracleComp (forwardPermutationOracle C) (DuplexSponge U C) := do
  let permutedState : C ‚Üê query (spec := forwardPermutationOracle C) () sponge.state
  
  let vecState : Vector U SpongeSize.N := SpongeState.get permutedState
  
  let zeroed : Vector U SpongeSize.N :=
    Vector.ofFn (fun i => if i < SpongeSize.R then 0 else vecState[i])
  
  let newVecState := SpongeState.update permutedState zeroed
  
  return { sponge with
    state := newVecState,
    squeezePos := Fin.last SpongeSize.R }

Polynomial.roots in Mathlib.Algebra.Polynomial.Roots

OracleSpec.DecidableEq in VCVio.OracleComp.OracleSpec

@[inline, specialize, simp]
def oracleReduction : OracleReduction oSpec
    Statement OStatement Witness Statement OStatement Witness !p[] := OracleReduction.id

Array.rightpad in Init.Data.Array.Basic

abbrev Bwd : PermuteDir := Sum.inr ()

MvPolynomial.degrees in Mathlib.Algebra.MvPolynomial.Degrees

noncomputable def toMvPolynomialAlgHom : P ‚Üí‚Çê[R] MvPolynomial œÉ R := aeval MvPolynomial.X

instance [Fintype F] [Nonempty F] [Semiring F] [DecidableEq Œπ] [DecidableEq F] {l : ‚Ñï} :
  ‚àÄ u : Fin l ‚Üí Œπ ‚Üí F, Nonempty {x // x ‚àà parametrisedCurveFinite u } :=

@[reducible, inline, specialize]
def challengeOracleInterfaceSR (StmtIn : Type) (pSpec : ProtocolSpec n) :
    ‚àÄ i, OracleInterface (pSpec.Challenge i) := fun i =>
  { Query := StmtIn √ó pSpec.MessagesUpTo i.1.castSucc
    Response := pSpec.Challenge i
    answer := fun c _ => c }

alias challengeOracleInterfaceFS := challengeOracleInterfaceSR

instance polyIrreducible (n : ‚Ñï) : Irreducible (poly n) := (BinaryTowerAux n).2.instIrreduciblePoly

def findNeighbors {n : ‚Ñï} (i : Fin (2 ^ n)) (layer : Fin n) :
    Fin (2 ^ (layer.val + 1)) :=
  
  
  let bits := (Vector.ofFn (finFunctionFinEquiv.invFun i)).reverse
  
  let neighbor := (bits.set layer (bits.get layer + 1)).take (layer.val + 1)
  have : min (layer.val + 1) n = layer.val + 1 := by admit /- proof elided -/

protected def OracleProver.id :
    OracleProver oSpec Statement OStatement Witness Statement OStatement Witness !p[] :=
  Prover.id

Array.zipIdx in Init.Data.Array.Basic

Set.Nonempty in Mathlib.Data.Set.Defs

Vector.zipWith in Init.Data.Vector.Basic

def OracleMessages (pSpec : ProtocolSpec n) [OracleInterfaces pSpec] : Type :=
  ‚àÄ i, pSpec.OracleMessage i

Algebra.algebraMap in Mathlib.Algebra.Algebra.Defs

def inputRelation [DecidableEq F] (Œ¥ : ‚Ñù‚â•0) :
    Set
      (
        Unit √ó (‚àÄ j, OracleStatement D x m j) √ó (Witness F s d m)
      ) := sorry

instance [h : ProverLast pSpec] : ProverFirst pSpec where
  prover_first' := by admit /- proof elided -/

instance : HListString (HList []) where
  toString
  | HList.nil => ""

@[elab_as_elim]
def dconcat {n : ‚Ñï} {motive : Fin (n + 1) ‚Üí Sort u}
    (u : (i : Fin n) ‚Üí motive i.castSucc) (a : motive (last n)) (i : Fin (n + 1)) : motive i :=
  match n with
  | 0 => match i with | 0 => a
  | _ + 1 => dcons (u 0) (dconcat (fun i => u (Fin.succ i)) a) i

Fin.add in Init.Data.Fin.Basic

def leftpad (m‚ÇÇ n‚ÇÇ : ‚Ñï) (a : Œ±) {m‚ÇÅ n‚ÇÅ : ‚Ñï} (M : Matrix (Fin m‚ÇÅ) (Fin n‚ÇÅ) Œ±) :
    Matrix (Fin m‚ÇÇ) (Fin n‚ÇÇ) Œ± :=
  Fin.leftpad m‚ÇÇ (fun _ => a) (Fin.leftpad n‚ÇÇ a ‚àò M)

instance {Œ± : Type} [Sampleable Œ±] : DecidableEq Œ± := inferInstance

@[reducible]
def sumcheckFoldOracleVerifier :=
  let stmt : Fin (‚Ñì / œë - 1 + 1) ‚Üí Type :=
    fun i => Statement (L := L) (‚Ñì := ‚Ñì) Context ‚ü®i * œë, blockIdx_mul_œë_lt_‚Ñì_succ i‚ü©
  let oStmt :=
    fun i: Fin (‚Ñì / œë - 1 + 1) => OracleStatement ùîΩq Œ≤ œë ‚ü®i * œë, blockIdx_mul_œë_lt_‚Ñì_succ i‚ü©
  let nonLastBlocksOracleVerifier :=
  OracleVerifier.seqCompose (oSpec := []‚Çí)
      (Stmt := stmt)
      (OStmt := oStmt)
      (pSpec := fun (bIdx: Fin (‚Ñì / œë - 1)) => pSpecFullNonLastBlock ùîΩq Œ≤ bIdx)
      (V := fun bIdx => nonLastBlockOracleVerifier (L:=L) ùîΩq Œ≤ (œë:=œë) (bIdx:=bIdx))

  let lastOracleVerifier := lastBlockOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)

  let sumcheckFoldOV: OracleVerifier []‚Çí
    (StmtIn := Statement (L := L) (‚Ñì := ‚Ñì) Context 0)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë 0)
    (StmtOut := Statement (L := L) (‚Ñì := ‚Ñì) Context (Fin.last ‚Ñì))
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (pSpec := pSpecSumcheckFold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
     := by admit /- proof elided -/

def LeafData.rightSubtree {Œ± : Type} {s_left s_right : Skeleton}
    (tree : LeafData Œ± (Skeleton.internal s_left s_right)) :
    LeafData Œ± s_right :=
  match tree with
  | LeafData.internal _left right =>
    right

instance : MvPolynomialLike œÉ R (MvPolynomial œÉ R) where
  X := MvPolynomial.X
  eval‚ÇÇ := fun f g => eval‚ÇÇHom f g
  eval‚ÇÇ_C := fun f g r => by admit /- proof elided -/

List.ofFn in Init.Data.List.OfFn

instance (k : ‚Ñï) : NeZero (2^k) :=

def FullData.get {s} {Œ± : Type}
    (tree : FullData Œ± s) (idx : SkeletonNodeIndex s) : Œ± :=
  match tree, idx with
  | FullData.leaf value, SkeletonNodeIndex.ofLeaf => value
  | FullData.internal value _ _, SkeletonNodeIndex.ofInternal => value
  | FullData.internal _ left _, SkeletonNodeIndex.ofLeft idxLeft =>
    FullData.get left idxLeft
  | FullData.internal _ _ right, SkeletonNodeIndex.ofRight idxRight =>
    FullData.get right idxRight

iSup in Mathlib.Order.SetNotation

LawfulMonad in Init.Control.Lawful.Basic

structure AlgebraTowerEquiv (A : Œπ ‚Üí Type*) [‚àÄ i, CommSemiring (A i)] [a : AlgebraTower A]
  (B : Œπ ‚Üí Type*) [‚àÄ i, CommSemiring (B i)] [b : AlgebraTower B]
  where
    toRingEquiv : ‚àÄ i, (A i ‚âÉ+* B i)
    commutesLeft' : ‚àÄ (i j : Œπ) (h : i ‚â§ j) (r : A i),
      (b.algebraMap (i:=i) (j:=j) (h:=h)) ((toRingEquiv i) r) =
      (toRingEquiv j) (a.algebraMap (i:=i) (j:=j) (h:=h) r)

class Serde (Œ± : Type u) (Œ≤ : Type v) extends Serialize Œ± Œ≤, DeserializeOption Œ± Œ≤

noncomputable def disagreementSet (f : Œπ ‚Üí F) (S : Finset F) (Ans : S ‚Üí F) : Finset F :=
  Set.toFinset ({x : Œπ | x.val ‚àà S ‚àß (ansPoly S Ans).eval x.val ‚â† f x}.image Subtype.val)

Polynomial.reverse in Mathlib.Algebra.Polynomial.Reverse

@[reducible]
def scalarFieldSize : Nat :=
  21888242871839275222246405745257275088548364400416034343698204186575808495617

def ratchet (state : FSVerifierState U H) :
    Except DomainSeparatorMismatch (FSVerifierState U H) := do
  let newHashState ‚Üê state.hashState.ratchet
  .ok { hashState := newHashState, nargString := state.nargString }

def whirRelation
    {F : Type} [Field F] [Fintype F] [DecidableEq F]
    {Œπ : Type} [Fintype Œπ] [Nonempty Œπ]
    (varCount : ‚Ñï) (œÜ : Œπ ‚Ü™ F) [Smooth œÜ] (err : ‚Ñù)
    : Set ((Unit √ó ‚àÄ i, (OracleStatement Œπ F i)) √ó Unit) :=
  { ‚ü®‚ü®_, oracle‚ü©, _‚ü© | Œ¥·µ£(oracle (), smoothCode œÜ varCount) ‚â§ err }

@[simp]
instance Nontrivial (k : ‚Ñï) : Nontrivial (BTField k) := inferInstance

Nontrivial in Mathlib.Logic.Nontrivial.Defs

Polynomial.eval in Mathlib.Algebra.Polynomial.Eval.Defs

Field in Mathlib.Algebra.Field.Defs

def perfectCorrectness (scheme : Scheme oSpec Data Randomness Commitment pSpec) : Prop :=
  correctness scheme 0

def finIdxOfIfTrue [BEq Œ±] [LawfulBEq Œ±] (a : Œ±) (l : List Œ±) (h : a ‚àà l) : Fin l.length :=
  ‚ü®List.idxOf' a l, by admit /- proof elided -/
  ‚ü©

Polynomial.degreeLT in Mathlib.RingTheory.Polynomial.Basic

noncomputable instance (‚Ñì : Nat) : AddCommGroup (CoeffVecSpace L ‚Ñì) :=

instance [Repr Œ±] (Œ±s : List Type) [HListRepr (HList Œ±s)] : HListRepr (HList (Œ± :: Œ±s)) where
  repr
  | HList.cons x xs =>
    match xs with
    | HList.nil => reprPrec x 0
    | HList.cons _ _ => reprPrec x 0 ++ ", " ++ HListRepr.repr xs

def knowledgeSoundness
    (relIn : Set ((StmtIn √ó ‚àÄ i, OStmtIn i) √ó WitIn))
    (relOut : Set ((StmtOut √ó ‚àÄ i, OStmtOut i) √ó WitOut))
    (verifier : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec)
    (knowledgeError : ‚Ñù‚â•0) : Prop :=
  verifier.toVerifier.knowledgeSoundness init impl relIn relOut knowledgeError

def somePairs : HList' (fun x => x √ó x) someTypes :=
  HList'.cons (1, 1) (HList'.cons ("good", "bad") (HList'.cons (5, 3) HList'.nil))

@[simp]
abbrev OracleStatement.AfterFirstSumcheck : R1CS.MatrixIdx ‚äï Fin 1 ‚Üí Type :=
  OracleStatement.AfterFirstChallenge R pp

instance {k : Fin 1} : Unique (Transcript k (default : ProtocolSpec 0)) where
  default := fun i => ()
  uniq := by admit /- proof elided -/

structure Opening where
  opening : Proof oSpec (Commitment √ó O.Query √ó O.Response) (Data √ó Randomness) pSpec

def Permute.ofEquiv (Œ± : Type*) (e : Equiv Œ± Œ±) : Permute Œ± where
  permute := e.toFun

@[reducible]
def SimOracle.Stateful (spec : OracleSpec Œπ) (spec‚Çú : OracleSpec Œπ‚Çú) (œÉ : Type) :=
  QueryImpl spec (StateT œÉ (OracleComp spec‚Çú))

def composeM {m' : Type u ‚Üí Type v} [Monad m'] (hom : m ‚Üí·µê m') (so : QueryImpl spec m) :
    QueryImpl spec m' where
  impl | query i t => hom (so.impl (query i t))

Ne in Init.Core

noncomputable def polyEvalLinearMap {L ùîΩq : Type*} [Field L] [Field ùîΩq] [Algebra ùîΩq L]
  (p : L[X]) (hp_add : IsLinearMap ùîΩq (fun x : L => p.eval x)) : L ‚Üí‚Çó[ùîΩq] L :=
{
  toFun    := fun x => p.eval x,
  map_add' := hp_add.map_add,
  map_smul' := hp_add.map_smul
}

def erase_even (s : Finset ‚Ñï) : Finset ‚Ñï := s.filter Odd

@[inline] def max [Zero T] [ToNat T] (a b : Cayley T) : Cayley T :=
  if (a : Nat) ‚â• (b : Nat) then a else b

Fin.snoc in Mathlib.Data.Fin.Tuple.Basic

instance : SMul ‚Ñï (UniPoly R) := ‚ü®nsmul‚ü©

instance : Sub (UniPoly R) := ‚ü®UniPoly.sub‚ü©

def checkInitImports : IO Bool := do
  \n\
      The `header` linter is included in Mathlib.Init, and every file in Mathlib \
      should import Mathlib.Init.\nPlease adjust the imports accordingly."
    return true

  e

List.range in Init.Data.List.Basic

def RoundByRound.append
    {WitMid‚ÇÅ : Fin (m + 1) ‚Üí Type} {WitMid‚ÇÇ : Fin (n + 1) ‚Üí Type}
    (E‚ÇÅ : Extractor.RoundByRound oSpec Stmt‚ÇÅ Wit‚ÇÅ Wit‚ÇÇ pSpec‚ÇÅ WitMid‚ÇÅ)
    (E‚ÇÇ : Extractor.RoundByRound oSpec Stmt‚ÇÇ Wit‚ÇÇ Wit‚ÇÉ pSpec‚ÇÇ WitMid‚ÇÇ) :
      Extractor.RoundByRound oSpec Stmt‚ÇÅ Wit‚ÇÅ Wit‚ÇÉ (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ)
        (Fin.append (m := m + 1) WitMid‚ÇÅ (Fin.tail WitMid‚ÇÇ) ‚àò Fin.cast (by admit /- proof elided -/
        )) where
  eqIn := by admit /- proof elided -/

def pSpecCoreInteraction := (pSpecSumcheckFold ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)) ++‚Çö
  (pSpecFinalSumcheckStep (L:=L))

def Œæ (x‚ÇÄ : F) (R : F[X][X][Y]) (H : F[X][Y]) [œÜ : Fact (Irreducible H)] : ùí™ H :=
  (Œæ_regular x‚ÇÄ R H).choose

List.leftpad in Init.Data.List.Basic

Nat.zero in Init.Prelude

noncomputable def novelPolynomialBasis (‚Ñì : Nat) (h_‚Ñì : ‚Ñì ‚â§ r) :
  Basis (Fin (2^‚Ñì)) (R := L) (M := L‚¶É<2^‚Ñì‚¶Ñ[X]) :=

instance instSelectableTypeChallengePSpec [SelectableType R] :
    ‚àÄ i, SelectableType ((pSpec R deg).Challenge i) :=
  instSelectableTypeChallengeAppend

noncomputable instance changeOfBasisMatrix_invertible
  (‚Ñì : Nat) (h_‚Ñì : ‚Ñì ‚â§ r) :
  Invertible (changeOfBasisMatrix ùîΩq Œ≤ ‚Ñì h_‚Ñì) :=

@[inline, reducible]
def lift : (OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i)) √ó OuterWitIn ‚Üí
    (InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i)) √ó InnerWitOut ‚Üí
    (OuterStmtOut √ó (‚àÄ i, OuterOStmtOut i)) √ó OuterWitOut :=
  fun ctxIn ctxOut => ‚ü®lens.stmt.lift ctxIn.1 ctxOut.1, lens.wit.lift ctxIn ctxOut‚ü©

Mathlib.Linter.TextBased.lintModules in Mathlib.Tactic.Linter.TextBased

def OuterStmtOut_Test := ‚Ñ§[X] √ó ‚Ñ§[X] √ó ‚Ñ§ √ó ‚Ñ§

def oracleReduction.sendEvalClaim :
    OracleReduction oSpec
      (Statement.AfterFirstSumcheck R pp) (OracleStatement.AfterFirstSumcheck R pp) (Witness R pp)
      (Statement.AfterSendEvalClaim R pp) (OracleStatement.AfterSendEvalClaim R pp) Unit
      ‚ü®!v[.P_to_V], !v[‚àÄ i, EvalClaim R i]‚ü© :=
  sorry

def IsBerlekampWelchSolution
  (e k : ‚Ñï)
  (œâs f : Fin n ‚Üí F)
  (v : Fin (2 * e + k) ‚Üí F)
  : Prop
  := Matrix.mulVec (BerlekampWelchMatrix e k œâs f) v = Rhs e œâs f

def verifier (i : Fin n) : Verifier oSpec
    (StatementRound R n i.castSucc √ó (‚àÄ i, OracleStatement R n deg i))
    (StatementRound R n i.succ √ó (‚àÄ i, OracleStatement R n deg i)) (pSpec R deg) :=
  (Simple.verifier R deg D oSpec).liftContext (oStmtLens R n deg D i)

@[inline, specialize, simp]
def oracleVerifier : OracleVerifier oSpec Statement OStatement Statement OStatement !p[] :=
  OracleVerifier.id

MvPolynomial.restrictDegree in Mathlib.RingTheory.MvPolynomial.Basic

@[reducible]
def value (op : MemoryWrite Œπ Œ±) := op.2

@[simp]
def ùïè (k : ‚Ñï) : BTField (k+1) := Z (k+1)

instance {k : Fin 1} : Unique (ChallengesUpTo k !p[]) where
  default := fun ‚ü®‚ü®i, h‚ü©, _‚ü© => by admit /- proof elided -/

def capacitySegmentDupHash : Prop :=
  let ‚ü®baseTrace, _‚ü© := removeRedundantEntryDS trace
  ‚àÉ j : Fin baseTrace.length, ‚àÉ capSeg : Vector U SpongeSize.C,
    ‚àÉ stmt : StmtIn, baseTrace[j] = ‚ü®.inl (), stmt, capSeg‚ü© ‚àß
      ‚àÉ j' < j,
        ‚àÉ stmt', baseTrace[j'] = ‚ü®.inl (), stmt', capSeg‚ü© ‚à®
        (‚àÉ stateIn1 stateOut1, baseTrace[j'] = ‚ü®.inr .Fwd, stateIn1, stateOut1‚ü©
          ‚àß stateOut1.capacitySegment = capSeg) ‚à®
        (‚àÉ stateOut2 stateIn2, baseTrace[j'] = ‚ü®.inr .Bwd, stateOut2, stateIn2‚ü©
          ‚àß stateIn2.capacitySegment = capSeg) ‚à®
        (‚àÉ stateIn3 stateOut3, baseTrace[j'] = ‚ü®.inr .Fwd, stateIn3, stateOut3‚ü©
          ‚àß stateIn3.capacitySegment = capSeg) ‚à®
        (‚àÉ stateOut4 stateIn4, baseTrace[j'] = ‚ü®.inr .Bwd, stateOut4, stateIn4‚ü©
          ‚àß stateOut4.capacitySegment = capSeg)

alias E_h := capacitySegmentDupHash

noncomputable def polyToPowerSeriesùïÉ (H : F[X][Y])
  (P : F[X][Y])
    : PowerSeries (ùïÉ H) :=
  PowerSeries.mk <| fun n =>
    liftToFunctionField (P.coeff n)

@[reducible]
def mk {R : Type*} (coeffs : Array R) : UniPoly R := coeffs

EquivLike in Mathlib.Data.FunLike.Equiv

def dropLastWhile (p : Œ± ‚Üí Bool) (l : List Œ±) : List Œ± :=
  (l.reverse.dropWhile p).reverse

BitVec.xor in Init.Data.BitVec.Basic

structure Witness (i : Fin (‚Ñì + 1)) where
  t : L‚¶É‚â§ 1‚¶Ñ[X Fin ‚Ñì]  
  H : L‚¶É‚â§ 2‚¶Ñ[X Fin (‚Ñì - i)] 
  f: (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®i, by admit /- proof elided -/
  ‚ü© ‚Üí L 

def isCommitmentRound (i : Fin ‚Ñì) : Prop :=
  œë ‚à£ i.val + 1 ‚àß i.val + 1 ‚â† ‚Ñì

@[reducible]
def FinalStatement (F : Type) (k : ‚Ñï) : Type := Fin (k + 1) ‚Üí F

class SpongeSize where
   
  N : Nat
   
  R : Nat
   
  R_lt_N : R < N := by admit /- proof elided -/

@[reducible, simp]
def OracleStatement.Lens.IsSound {OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut : Type}
    {Outer_Œπ‚Çõ·µ¢ : Type} {OuterOStmtIn : Outer_Œπ‚Çõ·µ¢ ‚Üí Type} [‚àÄ i, OracleInterface (OuterOStmtIn i)]
    {Outer_Œπ‚Çõ‚Çí : Type} {OuterOStmtOut : Outer_Œπ‚Çõ‚Çí ‚Üí Type} [‚àÄ i, OracleInterface (OuterOStmtOut i)]
    {Inner_Œπ‚Çõ·µ¢ : Type} {InnerOStmtIn : Inner_Œπ‚Çõ·µ¢ ‚Üí Type} [‚àÄ i, OracleInterface (InnerOStmtIn i)]
    {Inner_Œπ‚Çõ‚Çí : Type} {InnerOStmtOut : Inner_Œπ‚Çõ‚Çí ‚Üí Type} [‚àÄ i, OracleInterface (InnerOStmtOut i)]
    (outerLangIn : Set (OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i)))
    (outerLangOut : Set (OuterStmtOut √ó (‚àÄ i, OuterOStmtOut i)))
    (innerLangIn : Set (InnerStmtIn √ó (‚àÄ i, InnerOStmtIn i)))
    (innerLangOut : Set (InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i)))
    (compatStmt :
      OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i) ‚Üí InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i) ‚Üí Prop)
    (lens : OracleStatement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                                    OuterOStmtIn OuterOStmtOut InnerOStmtIn InnerOStmtOut) :=
  Statement.Lens.IsSound outerLangIn outerLangOut innerLangIn innerLangOut compatStmt lens

class IsRBRSound (langIn : Set StmtIn) (langOut : Set StmtOut)
    (verifier : Verifier oSpec StmtIn StmtOut pSpec) where
  rbrSoundnessError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0
  is_rbr_sound : rbrSoundness init impl langIn langOut verifier rbrSoundnessError

class HasPred (T : Type u) where
   
  pred' : T ‚Üí T

def coeffsToBitVec {n : ‚Ñï} (coeffs : List (ZMod 2)) : BitVec n :=
  let val := List.foldr (fun c acc => acc * 2 + c.val) 0 (coeffs.take n)
  BitVec.ofNat n val

def Straightline.append (E‚ÇÅ : Extractor.Straightline oSpec Stmt‚ÇÅ Wit‚ÇÅ Wit‚ÇÇ pSpec‚ÇÅ)
    (E‚ÇÇ : Extractor.Straightline oSpec Stmt‚ÇÇ Wit‚ÇÇ Wit‚ÇÉ pSpec‚ÇÇ)
    (V‚ÇÅ : Verifier oSpec Stmt‚ÇÅ Stmt‚ÇÇ pSpec‚ÇÅ) :
      Extractor.Straightline oSpec Stmt‚ÇÅ Wit‚ÇÅ Wit‚ÇÉ (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ) :=
  fun stmt‚ÇÅ wit‚ÇÉ transcript proveQueryLog verifyQueryLog => do
    let stmt‚ÇÇ ‚Üê V‚ÇÅ.verify stmt‚ÇÅ transcript.fst
    let wit‚ÇÇ ‚Üê E‚ÇÇ stmt‚ÇÇ wit‚ÇÉ transcript.snd proveQueryLog verifyQueryLog
    let wit‚ÇÅ ‚Üê E‚ÇÅ stmt‚ÇÅ wit‚ÇÇ transcript.fst proveQueryLog verifyQueryLog
    return wit‚ÇÅ

instance Vector.instFintype {Œ± : Type*} {n : ‚Ñï} [VCVCompatible Œ±] : Fintype (Vector Œ± n) :=
  Fintype.ofEquiv _ (Equiv.rootVectorEquivFin).symm

def outputRelation (cond : ‚àë i, (s i).1 ‚â§ n) [DecidableEq F] (Œ¥ : ‚Ñù‚â•0) :
    Set
      (
        (FinalStatement F k √ó ‚àÄ j, FinalOracleStatement D x s j) √ó
        Witness F s d (Fin.last (k + 1))
      ) := sorry

instance : EDist (n ‚Üí R) where
  edist := fun u v => hammingDist u v

OracleComp in VCVio.OracleComp.OracleComp

Mod in Init.Prelude

noncomputable def definingPoly {F : Type*} [instField : Field F] (s : F)
  := X ^ 2 + C s * X + 1

instance : Fact (Nat.Prime baseFieldSize) := ‚ü®BaseField_is_prime‚ü©

FiniteDimensional in Mathlib.LinearAlgebra.FiniteDimensional.Defs

def sub (m n : ChurchNat Œ±) : ChurchNat Œ± := sorry 

class LawfulHasSucc (T : Type u) [HasSucc T] [Add T] [One T] : Prop where
   
  succ'_eq_add_one : ‚àÄ x : T, succ' x = x + 1

noncomputable def ansPoly (S : Finset F) (Ans : S ‚Üí F) : Polynomial F :=
  Lagrange.interpolate S.attach (fun i => (i : F)) Ans

@[simp]
def evalDomain (i : ‚Ñï) : Subgroup FÀ£ :=
  Subgroup.zpowers (DIsCyclicC.gen ^ (2 ^ i))

BitVec.extractLsb' in Init.Data.BitVec.Basic

def commitKnowledgeError {i : Fin ‚Ñì}
    (m : (pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i).ChallengeIdx) : ‚Ñù‚â•0 :=
  match m with
  | ‚ü®j, hj‚ü© => by admit /- proof elided -/

Set.Nontrivial in Mathlib.Data.Set.Subsingleton

noncomputable def proximity_gap_degree_bound (rho : ‚Ñö) (m n : ‚Ñï) : ‚Ñï :=
  let b := D_X rho m n
  if h : ‚àÉ n : ‚Ñï, b = n
  then h.choose - 1
  else Nat.floor b

instance : ‚àÄ j, SelectableType ((pSpecFoldRelay (L:=L)).Challenge j) :=
  instSelectableTypeChallengeAppend

@[reducible, inline, specialize, simp]
def Message (pSpec : ProtocolSpec n) (i : MessageIdx pSpec) := pSpec.¬´Type¬ª i.val

@[inline, specialize]
def eval (x : R) (p : UniPoly R) : R :=
  p.eval‚ÇÇ (RingHom.id R) x

instance : _root_.Field Field := ZMod.instField fieldSize

def relHammingBallInterleavedCode [DecidableEq F] (U : Matrix Œ∫ Œπ F)
  (IC : MatrixSubmodule Œ∫ Œπ F) (r : ‚Ñù) :=
    {V | V ‚àà IC ‚àß relDistCodewords U V < r}

@[reducible, simp] def OStmtAfterCheckClaim : Unit ‚äï Unit ‚Üí Type := fun _ => R‚¶É‚â§ deg‚¶Ñ[X]

def rho' (n : ‚Ñï) (start : ‚Ñï) (c : ‚Ñï) : Option ‚Ñï := Id.run do
  if n % 2 = 0 then
    return some 2

  let mut x := start
  let mut y := x
  let mut d := 1

  while d = 1 do
    x := g n c x
    y := g n c (g n c y)
    d := Nat.gcd (Int.natAbs (x - y)) n

  if d = n then
    return none
  else
    return some d

instance {s} : LawfulFunctor (fun Œ± => LeafData Œ± s) :=

UInt8.ofFin in Init.Data.UInt.Basic

List.getLast in Init.Data.List.Basic

def powerBasisSucc (k : ‚Ñï) :
    PowerBasis (ConcreteBTField k) (ConcreteBTField (k + 1)) :=

@[reducible, simp]
def relOut : Set (Statement √ó Unit) := Set.univ

Units.mulAction' in Mathlib.Algebra.Group.Action.Units

def evalNormalizedWAt (i : Fin r) (x : L) : L :=
  let W_x := evalWAt (r := r) (L := L) (‚Ñì := ‚Ñì) (Œ≤ := Œ≤) (R_rate := R_rate) (i := i) x
  let beta_i := Œ≤ i
  let W_beta := evalWAt (Œ≤ := Œ≤) (‚Ñì := ‚Ñì) (R_rate := R_rate) (i := i) beta_i
  W_x * W_beta‚Åª¬π

@[elab_as_elim] def Fin.succRecOnSameFinType {motive : Fin r ‚Üí Sort _}
    (zero : motive (0 : Fin r))
    (succ : ‚àÄ i : Fin r, i + 1 < r ‚Üí motive i ‚Üí motive (i + 1)) : ‚àÄ (i : Fin r), motive i
  | ‚ü®0, _‚ü© => by admit /- proof elided -/
  | ‚ü®Nat.succ i_val, h‚ü© => by admit /- proof elided -/

@[inline] def pow [Zero T] [One T] [ToNat T] (a b : Cayley T) : Cayley T :=
  powNat a ‚Üëb

def Verifier.duplexSpongeFiatShamir (V : Verifier oSpec StmtIn StmtOut pSpec) :
    NonInteractiveVerifier (‚àÄ i, pSpec.Message i) (oSpec ++‚Çí duplexSpongeChallengeOracle StmtIn U)
      StmtIn StmtOut where
  verify := fun stmtIn proof => do
    
    let messages : pSpec.Messages := proof 0
    
    let ‚ü®_, transcript‚ü© ‚Üê messages.deriveTranscriptDSFS stmtIn
    V.verify stmtIn transcript

instance instHasSucc {n : ‚Ñï} : HasSucc (CNat n) := (CayleyTower n).2

@[inline]
def zero [Zero R] : MlPolyEval R n := Vector.replicate (2 ^ n) 0

instance [h : ProverFirst pSpec] : IsEmpty (pSpec.ChallengeIdx) where
  false | ‚ü®0, h'‚ü© => by admit /- proof elided -/

def rowSpan : Submodule F (Œπ' ‚Üí F) :=
  Submodule.span F {U i | i : Œπ}

def intCast_negSucc {k : ‚Ñï} (n : ‚Ñï) : intCast (k:=k) (Int.negSucc n)
  = - (‚Üë(n + 1) : ConcreteBTField k) :=

WithBot.addMonoidWithOne in Mathlib.Algebra.Order.Monoid.Unbundled.WithTop

def commitKState (i : Fin ‚Ñì) (hCR : isCommitmentRound ‚Ñì œë i) :
    (commitOracleVerifier ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      i hCR).KnowledgeStateFunction init impl
      (relIn := foldStepRelOut (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i.succ)
      (extractor := commitRbrExtractor ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) where
  toFun := fun m ‚ü®stmtIn, oStmtIn‚ü© tr witMid =>
    commitKStateProp ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (i := i) (m := m) (stmtIn := stmtIn) (witMid := witMid) (oStmtIn := oStmtIn) (mp:=mp)
  toFun_empty := fun stmtIn witMid => by admit /- proof elided -/

Fin.cast in Init.Data.Fin.Basic

def eval (x : Fin numWires ‚Üí ùì°) (g : Gate ùì° numWires) : ùì° :=
  g.qL * x g.a + g.qR * x g.b + g.qO * x g.c + g.qM * (x g.a * x g.b) + g.qC

def sumcheckConsistencyProp {k : ‚Ñï} (sumcheckTarget : L) (H : L‚¶É‚â§ 2‚¶Ñ[X Fin (k)]) : Prop :=
  sumcheckTarget = ‚àë x ‚àà (univ.map ùìë) ^·∂† (k), H.val.eval x

noncomputable def fieldToùïÉ {H : F[X][Y]} : F ‚Üí+* ùïÉ H :=
  RingHom.comp liftToFunctionField Polynomial.C

instance {i : ‚Ñï} : IsCyclicWithGen (evalDomain D i) :=

def g (n : ‚Ñï) (c : ‚Ñï) (x : ‚Ñï) := (x * x + c) % n

MonomialOrder in Mathlib.Data.Finsupp.MonomialOrder

inductive HList' {Œ± : Type v} (Œ≤ : Œ± ‚Üí Type u) : List Œ± ‚Üí Type (max u v)
  | nil  : HList' Œ≤ []
  | cons : Œ≤ i ‚Üí HList' Œ≤ is ‚Üí HList' Œ≤ (i :: is)

class DCast‚ÇÉ (Œ± : Sort*) (Œ≤ : Œ± ‚Üí Sort*) (Œ≥ : (a : Œ±) ‚Üí Œ≤ a ‚Üí Sort*)
    (Œ¥ : (a : Œ±) ‚Üí (b : Œ≤ a) ‚Üí Œ≥ a b ‚Üí Sort*) [DCast Œ± Œ≤] [DCast‚ÇÇ Œ± Œ≤ Œ≥] where
  dcast‚ÇÉ : ‚àÄ {a a' : Œ±} {b : Œ≤ a} {b' : Œ≤ a'} {c : Œ≥ a b} {c' : Œ≥ a' b'},
    (ha : a = a') ‚Üí (hb : dcast ha b = b') ‚Üí (hc : dcast‚ÇÇ ha hb c = c') ‚Üí Œ¥ a b c ‚Üí Œ¥ a' b' c'
  dcast‚ÇÉ_id : ‚àÄ {a : Œ±} {b : Œ≤ a} {c : Œ≥ a b},
    dcast‚ÇÉ (Eq.refl a) dcast_eq dcast‚ÇÇ_eq = (id : Œ¥ a b c ‚Üí Œ¥ a b c)

def fiberwiseDistance (i : Fin ‚Ñì) (steps : ‚Ñï) [NeZero steps] (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
  (f : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i.val, by admit /- proof elided -/
  ‚ü©) : ‚Ñï :=
  
  
  let C_i := BBF_Code ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i.val, by admit /- proof elided -/
  ‚ü©
  let disagreement_sizes := (fun (g : C_i) =>
    (fiberwiseDisagreementSet ùîΩq Œ≤ i steps h_i_add_steps f g).ncard) '' Set.univ
  sInf disagreement_sizes

noncomputable def foldf (S : Finset Œπ) (œÜ : Œπ ‚Ü™ F)
  {k : ‚Ñï} [Neg (indexPowT S œÜ k)] (y : indexPowT S œÜ (k + 1))
  (f : indexPowT S œÜ k ‚Üí F) (Œ± : F) : F :=
  let xPow := extract_x S œÜ k y
  let fx := f xPow
  let f_negx := f (-xPow)
  (fx + f_negx) / 2 + Œ± * ((fx - f_negx) / (2 * (xPow.val : F)))

Set.toFinset in Mathlib.Data.Fintype.Sets

BitVec.cast in Init.Data.BitVec.Basic

Prod in Init.Prelude
</all_available_defs>

<all_available_lemmas>
Finset.image_subset_iff in Mathlib.Data.Finset.Image
Finset.sum_image in Mathlib.Algebra.BigOperators.Group.Finset.Basic
Finset.sum_le_sum in Mathlib.Algebra.Order.BigOperators.Group.Finset
Finset.sum_le_sum_of_subset_of_nonneg in Mathlib.Algebra.Order.BigOperators.Group.Finset
Multiset.count_pos in Mathlib.Data.Multiset.Count
Multiset.toFinset_sum_count_eq in Mathlib.Algebra.BigOperators.Group.Finset.Basic
le_trans in Mathlib.Order.Defs.PartialOrder
lt_of_lt_of_le in Mathlib.Order.Defs.PartialOrder
Polynomial.mem_degreeLT in Mathlib.RingTheory.Polynomial.Basic
Polynomial.natDegree_lt_iff_degree_lt in Mathlib.Algebra.Polynomial.Degree.Definitions
Polynomial.ext in Mathlib.Algebra.Polynomial.Basic
Fin.castLE_injective in Mathlib.Data.Fin.SuccPred
Function.Injective.comp in Init.Data.Function
Matrix.det_vandermonde_ne_zero_iff in Mathlib.LinearAlgebra.Vandermonde
Matrix.mulVecLin_apply in Mathlib.LinearAlgebra.Matrix.ToLin
Matrix.mulVec_eq_sum in Mathlib.Data.Matrix.Mul
Finset.mem_range in Mathlib.Data.Finset.Range
Finset.sum_congr in Mathlib.Algebra.BigOperators.Group.Finset.Basic
Finset.sum_fin_eq_sum_range in Mathlib.Data.Fintype.BigOperators
Polynomial.eval_eq_sum_range' in Mathlib.Algebra.Polynomial.Eval.Degree
LinearMap.mem_range in Mathlib.Algebra.Module.Submodule.Range
Submodule.mem_map in Mathlib.Algebra.Module.Submodule.Map
Finset.filter_card_add_filter_neg_card_eq_card in Mathlib.Data.Finset.Card
Multiset.count_eq_one_of_mem in Mathlib.Data.Multiset.Count
Multiset.count_filter in Mathlib.Data.Multiset.Filter
Multiset.nodup_iff_count_eq_one in Mathlib.Data.Multiset.Count
Polynomial.card_roots' in Mathlib.Algebra.Polynomial.Roots
le_antisymm in Mathlib.Order.Defs.PartialOrder
le_csInf in Mathlib.Order.ConditionallyCompleteLattice.Basic
lt_of_le_of_lt in Mathlib.Order.Defs.PartialOrder

lemma rank_eq_if_det_ne_zero {U : Matrix (Fin n) (Fin n) F} [IsDomain F] :
  Matrix.det U ‚â† 0 ‚Üí U.rank = n

lemma rank_eq_if_subUpFull_eq (h : n ‚â§ m) :
   (subUpFull U (Fin.castLE h)).rank = n  ‚Üí U.rank = n

lemma full_row_rank_via_rank_subLeftFull (h : m ‚â§ n) :
   (subLeftFull U (Fin.castLE h)).rank = m ‚Üí U.rank = m

lemma cRank_rank_conversion :
  ‚Üë(U.rank) = U.cRank

@[simp]
lemma liftF'_p_coeff {p : F[X]} {k : ‚Ñï} {i : Fin k} : liftF' p.coeff i = p.coeff i

@[simp]
lemma coeff_polynomialOfCoeffs_eq_coeffs :
  Fin.liftF' (polynomialOfCoeffs coeffs).coeff = coeffs

lemma rank_eq_dim_fromColGenMat [CommRing F] {G : Matrix Œ∫ Œπ F} :
  G.rank = dim (fromColGenMat G)

theorem singletonBound [CommRing F] [StrongRankCondition F]
  (LC : LinearCode Œπ F) :
  dim LC ‚â§ length LC - Code.minDist (LC : Set (Œπ ‚Üí F)) + 1

lemma dist_UB [CommRing F] {LC : LinearCode Œπ F} :
    Code.minDist (LC : Set (Œπ ‚Üí F)) ‚â§ length LC

lemma dist_eq_minWtCodewords [CommRing F] {LC : LinearCode Œπ F} :
  Code.minDist (LC : Set (Œπ ‚Üí F)) = minWtCodewords LC

lemma hammingDist_eq_wt_sub [CommRing F] {u v : Œπ ‚Üí F} : hammingDist u v = Code.wt (u - v)

lemma add_eq_zero_iff_eq {k : ‚Ñï} (a b : ConcreteBTField k) : a + b = 0 ‚Üî a = b

theorem cast_run (stmt : StmtIn) (wit : WitIn) :
    R.run stmt wit = cast (sorry) ((R.cast hn hSpec).run stmt wit)

lemma BerlekampWelch_E_ne_zero {e k : ‚Ñï}
  {œâs f : Fin n ‚Üí F}
  {E Q : Polynomial F}
  (h_cond : BerlekampWelchCondition e k œâs f E Q)
  : E ‚â† 0

theorem nsmul_succ (n : ‚Ñï) (p : UniPolyC R) : nsmul (n + 1) p = nsmul n p + p

@[simp]
theorem cast_id :
    OracleVerifier.cast rfl rfl (fun i => rfl) =
      (id : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec‚ÇÅ ‚Üí _)

omit [NeZero r] [NeZero ùì°] in
lemma isCommitmentRoundOfNonLastBlock (bIdx : Fin (‚Ñì / œë - 1)) :
    isCommitmentRound ‚Ñì œë ‚ü®‚ÜëbIdx * œë + (œë - 1), by
      have hpos: œë > 0 := by exact Nat.pos_of_neZero œë
      conv_rhs => rw [‚ÜêNat.add_zero (n:=‚Ñì)]
      change bIdx.val * œë + (‚ü®œë - 1, by omega‚ü©: Fin œë).val < ‚Ñì + 0
      apply bIdx_mul_œë_add_i_lt_‚Ñì_succ (m:=0)
    ‚ü©

theorem degrees_eval [DecidableEq œÉ] {œÑ : Type*} {f : œÑ ‚Üí R} {p : R[X œÉ][X œÑ]} :
    (eval (C ‚àò f) p).degrees ‚â§ p.support.sup (fun c => (coeff c p).degrees)

@[simp]
theorem dappend_right {motive : Fin (m + n) ‚Üí Sort u} (u : (i : Fin m) ‚Üí motive (castAdd n i))
    (v : (i : Fin n) ‚Üí motive (natAdd m i)) (i : Fin n) :
    dappend (motive := motive) u v (natAdd m i) = v i

lemma take_eq_take : transcript‚ü¶:m‚üß = transcript.take m h

lemma getLowBits_lt_two_pow {n : ‚Ñï} (numLowBits : ‚Ñï) :
    getLowBits numLowBits n < 2 ^ numLowBits

theorem toPoly_toImpl {p : Q[X]} : p.toImpl.toPoly = p

lemma oracleWitnessConsistency_relay_preserved
    (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i)
    (stmt : Statement (L := L) Context i.succ)
    (wit : Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j) :
    oracleWitnessConsistency (mp := mp) (ùìë := ùìë) ùîΩq Œ≤ i.succ i.castSucc
      (le_succ ‚Üëi.castSucc) stmt wit oStmt =
    oracleWitnessConsistency (mp := mp) (ùìë := ùìë) ùîΩq Œ≤ i.succ i.succ (by rfl) stmt wit
      (mapOStmtOutRelayStep ùîΩq Œ≤ i hNCR oStmt)

Nat.sub_mul in Init.Data.Nat.Basic

Nat.add_le_of_le_sub in Init.Data.Nat.Basic

theorem heq_of_dcast (ha : a = a') (hb : dcast ha b = b') : HEq b b'

@[simp] theorem equiv_symm {p q : UniPoly Q} : equiv p q ‚Üí equiv q p

theorem prime_19 : Nat.Prime 19

theorem join_eq_iff_dcast_extractLsb {k : ‚Ñï} (h_pos : k > 0) (x : ConcreteBTField k)
  (hi_btf lo_btf : ConcreteBTField (k - 1)) :
  x = „Ää hi_btf, lo_btf „Äã ‚Üî
  (hi_btf = dcast (h_sub_middle h_pos) (BitVec.extractLsb (hi := 2 ^ k - 1) (lo := 2 ^ (k - 1)) x) ‚àß
  lo_btf = dcast (h_middle_sub) (BitVec.extractLsb (hi := 2 ^ (k - 1) - 1) (lo := 0) x))

theorem unique_repr {R : Type*} [CommRing R] {S : Type*} [CommRing S] [Algebra R S]
    (pb : PowerBasis R S) (repr1 repr2 : Fin pb.dim ‚Üí‚ÇÄ R)
    (h : ‚àë i : Fin pb.dim, repr1 i ‚Ä¢ pb.basis i = ‚àë i : Fin pb.dim, repr2 i ‚Ä¢ pb.basis i) :
    repr1 = repr2

@[simp] theorem zero_add {a : AssocNat} : 0 + a = a

omit [NeZero r] [NeZero ùì°] in
lemma isNeCommitmentRound (bIdx : Fin (‚Ñì / œë - 1)) (x : ‚Ñï) {hx : x < œë - 1} :
    ¬¨isCommitmentRound ‚Ñì œë ‚ü®‚ÜëbIdx * œë + x, by
      conv_rhs => rw [‚ÜêNat.add_zero (n:=‚Ñì)]
      change bIdx.val * œë + (‚ü®x, by omega‚ü©: Fin œë).val < ‚Ñì + 0
      apply bIdx_mul_œë_add_i_lt_‚Ñì_succ (m:=0)
    ‚ü©

lemma sup_eq_of_le_of_reach {Œ± Œ≤ : Type} [SemilatticeSup Œ≤] [OrderBot Œ≤] {s : Finset Œ±} {f : Œ± ‚Üí Œ≤}
      (x : Œ±) {y : Œ≤} (h : x ‚àà s) :
    f x = y ‚Üí
    (‚àÄ x ‚àà s, f x ‚â§ y) ‚Üí
    s.sup f = y

theorem GF_2_pow_card (x : GF(2)) : x ^ Fintype.card (GF(2)) = x

lemma out_of_dom_smpl_1
  {Œ¥ l : ‚Ñù‚â•0} {s : ‚Ñï} {f : Œπ ‚Üí F} {degree : ‚Ñï} {œÜ : Œπ ‚Ü™ F}
  (C : Set (Œπ ‚Üí F)) (hC : C = code œÜ degree)
  (h_decodable : listDecodable C Œ¥ l)
  (h_nonempty : Nonempty (domainComplement œÜ)) :
  listDecodingCollisionProbability œÜ f Œ¥ s degree h_nonempty ‚â§
    ((l * (l-1) / 2)) * ((degree - 1) / (Fintype.card F - Fintype.card Œπ))^s

omit [DecidableEq ùîΩq] hF‚ÇÇ h_Œ≤‚ÇÄ_eq_1 in
lemma getSDomainBasisCoeff_of_sum_repr [NeZero R_rate] (i : Fin (‚Ñì + 1))
    (x : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®i, by omega‚ü©)
    (x_coeffs : Fin (‚Ñì + R_rate - i) ‚Üí ùîΩq)
    (hx : x = ‚àë j_x, (x_coeffs j_x) ‚Ä¢ (sDomain_basis ùîΩq Œ≤
      h_‚Ñì_add_R_rate (i := ‚ü®i, by omega‚ü©) (h_i := by
        simp only; apply Nat.lt_add_of_pos_right_of_le; omega) j_x).val) :
    ‚àÄ (j: Fin (‚Ñì + R_rate - i)), ((sDomain_basis ùîΩq Œ≤
      h_‚Ñì_add_R_rate (i := ‚ü®i, by omega‚ü©) (h_i := by
        simp only; apply Nat.lt_add_of_pos_right_of_le; omega)).repr x) j = x_coeffs j

@[simp]
theorem embedSum_succ_zero {n : Fin (m + 1) ‚Üí ‚Ñï} {j : Fin (n 0)} :
    embedSum 0 j = Fin.castAdd _ j

@[simp]
theorem toNat_succ (n : ChurchNat ‚Ñï) : toNat (succ n) = n.toNat.succ

@[simp]
theorem removeNth_zero : removeNth 0 s = tail s

omit [DecidableEq Œ±] [Inhabited Œ±] [Fintype Œ±] in
@[simp]
lemma Cache.upper_cons (n : ‚Ñï) (leaves : List.Vector Œ± (2 ^ (n + 1))) (cache : Cache Œ± n) :
    Cache.upper Œ± n (Cache.cons Œ± n leaves cache) = cache

theorem insertNth_self_removeNth : insertNth p (t p) (removeNth p t) = t

theorem prime_43 : Nat.Prime 43

lemma combine_theorem
  {œÜ : Œπ ‚Ü™ F} {dstar m degree : ‚Ñï}
  (fs : Fin m ‚Üí Œπ ‚Üí F) (degs : Fin m ‚Üí ‚Ñï) (hdegs : ‚àÄ i, degs i ‚â§ dstar)
  (Œ¥ : ‚Ñù) (hŒ¥Pos : Œ¥ > 0)
  (hŒ¥Lt : Œ¥ < (min (1 - Bstar (rate (code œÜ degree)))
                   (1 - (rate (code œÜ degree)) - 1 / Fintype.card Œπ)))
  (hProb : Pr_{ let r ‚Üê $·µñ F}[Œ¥·µ£((combine œÜ dstar r fs degs), (code œÜ dstar)) ‚â§ Œ¥] >
    ENNReal.ofReal (proximityError F dstar (rate (code œÜ degree)) Œ¥ (m * (dstar + 1) - ‚àë i, degs i))) :
      ProximityGap.correlatedAgreement (code œÜ degree) ‚ü®Œ¥, by linarith‚ü© fs

theorem seqCompose_rbrKnowledgeSoundness
    (rel : ‚àÄ i, Set ((Stmt i √ó ‚àÄ j, OStmt i j) √ó Wit i))
    (V : (i : Fin m) ‚Üí OracleVerifier oSpec (Stmt i.castSucc) (OStmt i.castSucc)
      (Stmt i.succ) (OStmt i.succ) (pSpec i))
    (rbrKnowledgeError : ‚àÄ i, (pSpec i).ChallengeIdx ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (V i).rbrKnowledgeSoundness init impl
      (rel i.castSucc) (rel i.succ) (rbrKnowledgeError i)) :
    (OracleVerifier.seqCompose Stmt OStmt V).rbrKnowledgeSoundness
        init impl (rel 0) (rel (Fin.last m))
        (fun combinedIdx =>
          letI ij := seqComposeChallengeIdxToSigma combinedIdx
          rbrKnowledgeError ij.1 ij.2)

theorem snoc_ne_zero_of_left (h : s ‚â† 0) : snoc s y ‚â† 0

private lemma solution_to_BerlekampWelch_condition {e k : ‚Ñï}
  [NeZero n]
  {œâs f : Fin n ‚Üí F}
  {v : Fin (2 * e + k) ‚Üí F}
  (h_sol : IsBerlekampWelchSolution e k œâs f v)
  : BerlekampWelchCondition e k œâs f (solutionToE e k v) (solutionToQ e k v)

@[simp]
lemma numFullRounds_pos : 0 < params.numFullRounds

@[simp]
lemma seqCompose_succ {m : ‚Ñï} (Stmt : Fin (m + 2) ‚Üí Type)
    {n : Fin (m + 1) ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (V : (i : Fin (m + 1)) ‚Üí Verifier oSpec (Stmt i.castSucc) (Stmt i.succ) (pSpec i)) :
    seqCompose Stmt V = append (V 0) (seqCompose (Stmt ‚àò Fin.succ) (fun i => V (Fin.succ i)))

lemma h_sum_two_same_pow2 {k : ‚Ñï} (h_pos : k > 0) : 2 ^ (k - 1) + 2 ^ (k - 1) = 2 ^ k

lemma sDomain_eq_image_of_upper_span (i : Fin r) (h_i : i < ‚Ñì + R_rate) :
    let V_i := Submodule.span ùîΩq (Set.range (sBasis Œ≤ h_‚Ñì_add_R_rate i h_i))
    let W_i_map := polyEvalLinearMap (normalizedW ùîΩq Œ≤ i)
      (normalizedW_is_additive ùîΩq Œ≤ i)
    sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i
    = Submodule.map W_i_map V_i

theorem oracleVerifier_rbrKnowledgeSoundness [Fintype R] :
    (oracleVerifier R deg D oSpec).rbrKnowledgeSoundness init impl
    (inputRelation R deg D) (outputRelation R deg) (fun _ => (deg : ‚Ñù‚â•0) / (Fintype.card R))

@[simp]
theorem fappend‚ÇÇ_left {Œ±‚ÇÅ : Fin m ‚Üí A} {Œ±‚ÇÇ : Fin m ‚Üí B} {Œ≤‚ÇÅ : Fin n ‚Üí A} {Œ≤‚ÇÇ : Fin n ‚Üí B}
    (u : (i : Fin m) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i)) (v : (i : Fin n) ‚Üí F‚ÇÇ (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) (i : Fin m) :
    fappend‚ÇÇ (F := F‚ÇÇ) u v (castAdd n i) =
      cast (by simp [vappend_left]) (u i)

Fin.append_left in Mathlib.Data.Fin.Tuple.Basic

@[simp] theorem rightpad_length (n : Nat) (unit : Œ±) (l : List Œ±) :
    (rightpad n unit l).length = max n l.length

lemma concrete_mul_one
  (prevBTFieldProps : ConcreteBTFieldProps (k := k - 1))
  (a : ConcreteBTField k) : concrete_mul a (one (k:=k)) = a

theorem pow_three_eq_mul_sq {a : CNat 1} : a ^ 3 = a * (a * a)

lemma bwm_of_neg [NeZero n] (h : e ‚â§ j.1) :
  BerlekampWelchMatrix e k œâs f i j = -(œâs i)^(j - e)

Finset.sup_lt_iff in Mathlib.Data.Finset.Lattice.Fold

lemma aeval_eq' {A : Type w} [CommSemiring A] [Algebra R A] (f : P ‚Üí‚Çê[R] A) (p : P) :
    f p = aeval (f X) p

theorem randomOracle_cache_neverFails_iff_runWithOracle_neverFails {Œ≤}
    [DecidableEq Œπ] [spec.DecidableEq] [(i : Œπ) ‚Üí SelectableType (OracleSpec.range spec i)]
    (oa : OracleComp (spec) Œ≤) (preexisting_cache : spec.QueryCache)
    :
    ((oa.simulateQ randomOracle).run preexisting_cache).neverFails
    ‚Üî
    (‚àÄ (f : spec.FunctionType),
      Oracle.containsCache f preexisting_cache ‚Üí
      (runWithOracle f oa).isSome)

lemma add_assoc {k : ‚Ñï} : ‚àÄ (a b c : ConcreteBTField k), a + b + c = a + (b + c)

lemma rounds_sub_steps_lt : ‚Ñì - œë < ‚Ñì :=
  Nat.sub_lt (pos_of_neZero ‚Ñì) (folding_steps_pos)

lemma œë_sub_one_le_self : œë - 1 < œë

theorem stir_rbr_soundness
    [SelectableType F] {s : ‚Ñï}
    {P : Params Œπ F} {œÜ : (i : Fin (M + 1)) ‚Üí (Œπ i ‚Ü™ F)}
    [h_nonempty : ‚àÄ i : Fin (M + 1), Nonempty (Œπ i)]
    {hParams : ParamConditions Œπ P} {Dist : Distances M}
    {Codes : CodeParams Œπ P Dist}
    (h_not_code : ‚àÄ f‚ÇÄ : (Œπ 0) ‚Üí F, f‚ÇÄ ‚àâ (Codes.C 0))
    (hŒ¥‚ÇÄLe : ‚àÄ f‚ÇÄ : (Œπ 0) ‚Üí F, Dist.Œ¥ 0 ‚â§ (Œ¥·µ£(f‚ÇÄ, (Codes.C 0)) : ‚Ñù) ‚àß
      Dist.Œ¥ 0 < (1 - Bstar (rate (code (P.œÜ 0) P.deg))))
    (hŒ¥·µ¢ : ‚àÄ {j : Fin (M + 1)}, j ‚â† 0 ‚Üí
        Dist.Œ¥ j < (1 - rate (code (P.œÜ j) (degree Œπ P j))
          - 1 / Fintype.card (Œπ j) : ‚Ñù) ‚àß
        Dist.Œ¥ j < (1 - Bstar (rate (code (P.œÜ j) (degree Œπ P j)))))
    (Œµ_fold : ‚Ñù‚â•0) (Œµ_out : Fin M ‚Üí ‚Ñù‚â•0) (Œµ_shift : Fin M ‚Üí ‚Ñù‚â•0) (Œµ_fin : ‚Ñù‚â•0) :
    ‚àÉ n : ‚Ñï,
    -- There exists an `n`-message vector IOPP,
    ‚àÉ vPSpec : ProtocolSpec.VectorSpec n,
    -- such that there are `2 * M + 2` challenges from the verifier to the prover,
    Fintype.card (vPSpec.ChallengeIdx) = 2 * M + 2 ‚àß
    -- ‚àÉ vector IOPP œÄ with the aforementioned `vPSpec`, and for
    -- `Statement = Unit, Witness = Unit, OracleStatement(Œπ‚ÇÄ, F)` such that
    ‚àÉ œÄ : VectorIOP Unit (OracleStatement (Œπ 0) F) Unit vPSpec F,
    let Œµ_rbr : vPSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0

@[simp]
theorem simulateQ'_query (q : OracleQuery spec Œ±) :
    simulateQ' so q (by simp) = so.impl q

@[simp]
theorem OracleSpec.append_range_left {Œπ‚ÇÅ Œπ‚ÇÇ : Type} {spec‚ÇÅ : OracleSpec Œπ‚ÇÅ} {spec‚ÇÇ : OracleSpec Œπ‚ÇÇ}
    (i : Œπ‚ÇÅ) : (spec‚ÇÅ ++‚Çí spec‚ÇÇ).range (Sum.inl i) = spec‚ÇÅ.range i

Nat.add_zero in Init.Core

theorem cast_eq_dcast {m n : ‚Ñï} (h : m = n) (a : Fin m) :
    Fin.cast h a = dcast h a

@[simp]
theorem fappend_succ {Œ± : Fin m ‚Üí A} {Œ≤ : Fin (n + 1) ‚Üí A}
    (u : (i : Fin m) ‚Üí F (Œ± i)) (v : (i : Fin (n + 1)) ‚Üí F (Œ≤ i)) :
    fappend u v = fconcat (fappend u (fun i => v (castSucc i))) (v (last n))

lemma liftF_eval {f : Fin n ‚Üí Œ±} {i : Fin n} :
  liftF f i.val = f i

protected lemma errors_are_roots_of_elocPolyF {i : Fin n} {œâs f : Fin n ‚Üí F}
  (h : f i ‚â† p.eval (œâs i)) : (ElocPolyF œâs f p).eval (œâs i) = 0

lemma add_eq_one_iff (a b : ConcreteBTField 0) :
  a + b = 1 ‚Üî (a = 0 ‚àß b = 1) ‚à® (a = 1 ‚àß b = 0)

theorem and_highBits_lowBits_eq_zero {n : ‚Ñï} (numLowBits : ‚Ñï) :
    getHighBits numLowBits n &&& getLowBits numLowBits n = 0

lemma wt_eq_hammingNorm [Zero F] {v : Œπ ‚Üí F} :
  wt v = hammingNorm v

lemma relHammingDist_le_blockRelDistance
  (i k : ‚Ñï) {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F} {œÜ' : (indexPowT S œÜ i) ‚Ü™ F}
  [DecidableEq F] [DecidableEq Œπ] [Smooth œÜ]
  (f g : (indexPowT S œÜ i) ‚Üí F) (S' : Finset (indexPowT S œÜ i))
  [h_fintype : ‚àÄ i : ‚Ñï, Fintype (indexPowT S œÜ i)]
  [DecidableEq (indexPowT S œÜ i)] [Smooth œÜ']
  [h_dec : DecidableBlockDisagreement i k f S' œÜ'] :
  Œ¥·µ£(f, g) ‚â§ Œî·µ£(i, k, f, S', œÜ', g)

lemma getBit_of_highBits_no_shl {n: ‚Ñï} (numLowBits : ‚Ñï) :
    ‚àÄ k, getBit k (getHighBits_no_shl numLowBits n)
  = getBit (k + numLowBits) (n)

theorem add_succ (m n : ChurchNat Œ±) : add (succ m) n = succ (add m n)

theorem liftContext_runWithLogToRound
    {lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    {outerStmtIn : OuterStmtIn} {outerWitIn : OuterWitIn} {i : Fin (n + 1)}
    (P : Prover oSpec InnerStmtIn InnerWitIn InnerStmtOut InnerWitOut pSpec) :
      (P.liftContext lens).runWithLogToRound i outerStmtIn outerWitIn
      = do
        let ‚ü®‚ü®transcript, prvState‚ü©, queryLog‚ü© ‚Üê
          (P.runWithLogToRound i).uncurry (lens.proj (outerStmtIn, outerWitIn))
        return ‚ü®‚ü®transcript, ‚ü®prvState, outerStmtIn, outerWitIn‚ü©‚ü©, queryLog‚ü©

theorem sum_join_via_add_smul (k : ‚Ñï) (h_pos : k > 0) (a‚ÇÅ a‚ÇÄ b‚ÇÅ b‚ÇÄ : BTField (k - 1)) :
  ‚ãò a‚ÇÅ, a‚ÇÄ ‚ãô + ‚ãò b‚ÇÅ, b‚ÇÄ ‚ãô = ‚ãò a‚ÇÅ + b‚ÇÅ, a‚ÇÄ + b‚ÇÄ ‚ãô

lemma towerRingHomForwardMap_add_eq (k : ‚Ñï) (x y : ConcreteBTField k) :
    towerRingHomForwardMap (k:=k) (x + y)
    = towerRingHomForwardMap (k:=k) x + towerRingHomForwardMap (k:=k) y

@[simp]
lemma OracleVerifier.id_toVerifier :
    (OracleVerifier.id : OracleVerifier oSpec Statement OStatement _ _ _).toVerifier =
      Verifier.id

theorem fcons_right_injective {Œ≤ : Fin n ‚Üí A} (a : F Œ±) :
    Function.Injective (fcons a : ((i : Fin n) ‚Üí F (Œ≤ i)) ‚Üí (i : Fin (n + 1)) ‚Üí _)

theorem getElem?_eq_toList {a : Array Œ±} {i : ‚Ñï} : a.toList[i]? = a[i]?

@[simp]
theorem acceptRejectRel_language : acceptRejectRel.language = { true }

theorem finSuccEquivNth_rename_finSuccEquivNth (e : œÉ ‚âÉ Fin n) (œÜ : MvPolynomial (Option œÉ) R) :
    ((finSuccEquivNth R p) ((rename ((Equiv.optionCongr e).trans (_root_.finSuccEquiv' p).symm)) œÜ))
      = Polynomial.map (rename e).toRingHom (optionEquivLeft R œÉ œÜ)

lemma zipWith_size {R} {f : R ‚Üí R ‚Üí R} {a b : Array R} (h : a.size = b.size) :
    (Array.zipWith f a b).size = a.size

lemma concrete_mul_zero
  (prevBTFieldProps : ConcreteBTFieldProps (k := k - 1))
  (a : ConcreteBTField k) : concrete_mul a (zero (k:=k)) = zero (k:=k)

omit h_Fq_char_prime in
theorem changeOfBasisMatrix_lower_triangular
  (‚Ñì : Nat) (h_‚Ñì : ‚Ñì ‚â§ r) :
  (changeOfBasisMatrix ùîΩq Œ≤ ‚Ñì h_‚Ñì).BlockTriangular ‚áëOrderDual.toDual

@[simp]
lemma oddPart_coeff {f : Polynomial F} {n : ‚Ñï} :
    (oddPart f).coeff n = if Even n then f.coeff (n + 1) else 0

private lemma Fis_pairwise_disjoint : Set.PairwiseDisjoint Set.univ (Fi B i)

lemma irreducible_factorization_of_gs_solution
  {k : ‚Ñï}
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ) :
  ‚àÉ (C : F[Z][X]) (R : List F[Z][X][Y]) (f : List ‚Ñï) (e : List ‚Ñï),
    R.length = f.length ‚àß
    f.length = e.length ‚àß
    ‚àÄ e·µ¢ ‚àà e, 1 ‚â§ e·µ¢ ‚àß
    ‚àÄ R·µ¢ ‚àà R, R·µ¢.Separable ‚àß
    ‚àÄ R·µ¢ ‚àà R, Irreducible R·µ¢ ‚àß
    Q = (Polynomial.C C) *
        ‚àè (R·µ¢ ‚àà R.toFinset) (f·µ¢ ‚àà f.toFinset) (e·µ¢ ‚àà e.toFinset),
          (R·µ¢.comp ((Y : F[Z][X][Y]) ^ f·µ¢))^e·µ¢

lemma xor_of_and_eq_zero_is_or {n m : ‚Ñï} (h_n_AND_m : n &&& m = 0) : n ^^^ m = n ||

lemma towerRingHomForwardMap_join {k : ‚Ñï} (h_pos : k > 0) (hi lo : ConcreteBTField (k - 1)) :
  towerRingHomForwardMap (k:=k) („Ää hi, lo „Äã) =
    BinaryTower.join_via_add_smul (k:=k) (h_pos:=by omega)
      (hi_btf := towerRingHomForwardMap (k:=k-1) hi)
      (lo_btf := towerRingHomForwardMap (k:=k-1) lo)

lemma sum_eq_xor_plus_twice_and (n : Nat) : ‚àÄ m : ‚Ñï, n + m = (n ^^^ m) + 2 * (n &&& m)

omit O‚Çò in
theorem seqCompose_perfectCompleteness (hInit : init.neverFails)
    (rel : (i : Fin (m + 1)) ‚Üí Set (Stmt i √ó Wit i))
    (R : ‚àÄ i, Reduction oSpec (Stmt i.castSucc) (Wit i.castSucc) (Stmt i.succ) (Wit i.succ)
      (pSpec i))
    (h : ‚àÄ i, (R i).perfectCompleteness init impl (rel i.castSucc) (rel i.succ)) :
      (Reduction.seqCompose Stmt Wit R).perfectCompleteness
        init impl (rel 0) (rel (Fin.last m))

@[simp]
theorem PowerBasis.cast_basis_succ_of_eq_rec_apply
    (r1 r : ‚Ñï) (h_r : r = r1 + 1)
    (k : Fin 2) :
    letI instAlgebra : Algebra (ConcreteBTField r1) (ConcreteBTField r) :=
      ConcreteBTFieldAlgebra (l:=r1) (r:=r) (h_le:=by omega)
    letI instAlgebraSucc : Algebra (ConcreteBTField (r1 + 1)) (ConcreteBTField (r)) :=
      ConcreteBTFieldAlgebra (l:=r1 + 1) (r:=r) (h_le:=by omega)
    let b : PowerBasis (ConcreteBTField r1) (ConcreteBTField (r1 + 1))
      := powerBasisSucc (k:=r1)
    let bCast : PowerBasis (ConcreteBTField r1) (ConcreteBTField r) := Eq.rec (motive:=
      fun (x : ‚Ñï) (_ : r1 + 1 = x) => by
        letI instAlgebraCur : Algebra (ConcreteBTField r1) (ConcreteBTField x) :=
          ConcreteBTFieldAlgebra (l:=r1) (r:=x) (h_le:=by omega)
        exact PowerBasis (ConcreteBTField r1) (ConcreteBTField x)) (refl:=b) (t:=h_r.symm)
    have h_pb_dim : b.dim = 2 := by
      exact powerBasisSucc_dim r1

    have h_pb'_dim : bCast.dim = 2 := by
      dsimp [bCast]
      rw [PowerBasis.dim_of_eq_rec (r1:=r1) (r:=r) (h_r:=h_r) (b:=b)]
      exact h_pb_dim

    have h_pb_type_eq : Basis (Fin bCast.dim) (ConcreteBTField r1) (ConcreteBTField r) =
      Basis (Fin 2) (ConcreteBTField r1) (ConcreteBTField r) := by
      congr

   -- The `cast` needs a proof that `bCast.dim = 2`. We construct it here.
    let left : Basis (Fin 2) (ConcreteBTField r1) (ConcreteBTField r)
      := cast (by exact h_pb_type_eq) bCast.basis
    let right := (algebraMap (ConcreteBTField (r1 + 1)) (ConcreteBTField r))
      (b.basis (Fin.cast h_pb_dim.symm k))
    left k = right

theorem two_eq_zero_in_char2_field {F : Type*} [Field F]
  (sumZeroIffEq : ‚àÄ (x y : F), x + y = 0 ‚Üî x = y) : (2 : F) = 0

theorem galois_automorphism_power
    {curBTField : Type*} [Field curBTField]
    (u : curBTField) (t1 : curBTField) -- here t1 is already lifted to curBTField
    (k : ‚Ñï)
    (sumZeroIffEq : ‚àÄ (x y : curBTField), x + y = 0 ‚Üî x = y)
    (specialElementNeZero : u ‚â† 0)
    (prevSpecialElementNeZero : t1 ‚â† 0)
    (u_plus_inv_eq_t1 : u + u‚Åª¬π = t1)
    (h_u_square : u ^ 2 = u * t1 + 1)
    (h_t1_pow : t1 ^ (2 ^ (2 ^ k) - 1) = 1 ‚àß (t1‚Åª¬π) ^ (2 ^ (2 ^ k) - 1) = 1)
    (trace_map_roots : ‚àë i ‚àà Finset.range (2 ^ k), t1 ^ (2 ^ i) = 1 ‚àß
                      ‚àë i ‚àà Finset.range (2 ^ k), t1‚Åª¬π ^ (2 ^ i) = 1) :
    u^(2^(2^k)) = u‚Åª¬π ‚àß (u‚Åª¬π)^(2^(2^k)) = u

@[simp]
lemma Rhs_zero_eq_neg : Rhs 0 œâs f i = -f i

@[simp]
lemma possibleDeltas_subset_relHammingDistRange :
  possibleDeltas U C ‚äÜ relHammingDistRange Œπ

@[simp]
theorem rtake_zero (v : (i : Fin n) ‚Üí Œ± i) :
    rtake 0 (by omega) v = fun i => Fin.elim0 i

lemma MessageIdxUpTo.eq_MessageIdx {k : Fin (n + 1)} {pSpec : ProtocolSpec n} :
    pSpec.MessageIdxUpTo k = {i : Fin k // pSpec.dir (i.castLE (by omega)) = .P_to_V}

omit [NeZero ‚Ñì] [NeZero r] [NeZero ùì°] in
lemma fin_r_succ_bound {h_‚Ñì_add_R_rate : ‚Ñì + ùì° < r} (i : Fin r) (h_i : i + 1 < ‚Ñì + ùì°)
    : i + 1 < r

theorem completeness_relOut_mono {Œµ : ‚Ñù‚â•0} {relOut' : Set (StmtOut √ó WitOut)}
    (hrelOut : relOut ‚äÜ relOut') :
      completeness init impl relIn relOut reduction Œµ ‚Üí
        completeness init impl relIn relOut' reduction Œµ

@[simp]
theorem drop_one {Œ± : Fin (n + 1) ‚Üí Sort*} (v : (i : Fin (n + 1)) ‚Üí Œ± i) :
    drop 1 (Nat.le_add_left 1 n) v = tail v

theorem liftContext_processRound
    {lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    {i : Fin n}
    {P : Prover oSpec InnerStmtIn InnerWitIn InnerStmtOut InnerWitOut pSpec}
    {resultRound : OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí)
      (pSpec.Transcript i.castSucc √ó (P.liftContext lens).PrvState i.castSucc)} :
      (P.liftContext lens).processRound i resultRound
      = do
        let ‚ü®transcript, prvState, outerStmtIn, outerWitIn‚ü© ‚Üê resultRound
        let ‚ü®newTranscript, newPrvState‚ü© ‚Üê P.processRound i (do return ‚ü®transcript, prvState‚ü©)
        return ‚ü®newTranscript, ‚ü®newPrvState, outerStmtIn, outerWitIn‚ü©‚ü©

@[simp]
lemma lt_add_of_pos_right_of_le (a b c : ‚Ñï) [NeZero c] (h : a ‚â§ b) : a < b + c

theorem is_prime : Nat.Prime fieldSize

@[simp]
theorem hflatten_embedSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {Œ± : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí Sort*}
    (v : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí Œ± i j) (i : Fin m) (j : Fin (n i)) :
    hflatten v (embedSum i j) = cast (vflatten_embedSum Œ± i j).symm (v i j)

lemma lagrangeToMono_eq_lagrangeToMono_segment (n : ‚Ñï) [NeZero n] (v : Vector R (2 ^ n)) :
  have h_n_ne_zero: n ‚â† 0

@[simp]
private lemma K_le_card {Œ± : F} : K B i Œ± ‚â§ B.card

@[simp]
theorem embedSum_succ_succ {n : Fin (m + 1) ‚Üí ‚Ñï} {i : Fin m} (j : Fin (n i.succ)) :
    embedSum (i.succ) j = Fin.natAdd _ (embedSum i j)

lemma join_via_add_smul_zero {k : ‚Ñï} (h_pos : k > 0) :
  ‚ãò 0, 0 ‚ãô = 0

theorem binaryTowerAlgebra_apply_assoc (l mid r : ‚Ñï) (h_l_le_mid : l ‚â§ mid) (h_mid_le_r : mid ‚â§ r) :
    ‚àÄ x : BTField l,
    (@binaryAlgebraTower (l:=l) (r:=r) (h_le:=by
      exact Nat.le_trans h_l_le_mid h_mid_le_r)).algebraMap x =
    (@binaryAlgebraTower (l:=mid) (r:=r) (h_le:=h_mid_le_r)).algebraMap
      ((@binaryAlgebraTower (l:=l) (r:=mid) (h_le:=h_l_le_mid)).algebraMap x)

theorem funext_heq_iff {Œ± Œ±' : Sort u} {Œ≤ : Œ± ‚Üí Sort v} {Œ≤' : Œ±' ‚Üí Sort v}
    {f : (x : Œ±) ‚Üí Œ≤ x} {g : (x : Œ±') ‚Üí Œ≤' x} (ha : Œ± = Œ±') (hb : ‚àÄ x, Œ≤ x = Œ≤' (cast ha x)) :
      HEq f g ‚Üî ‚àÄ x, HEq (f x) (g (cast ha x))

@[simp]
theorem Basis_cast_index_eq (i j k n : ‚Ñï) (h_le : k ‚â§ n) (h_eq : i = j) :
    letI instAlgebra : Algebra (ConcreteBTField k) (ConcreteBTField n) :=
      ConcreteBTFieldAlgebra (l:=k) (r:=n) (h_le:=h_le)
    letI : Module (ConcreteBTField k) (ConcreteBTField n) := instAlgebra.toModule
    (Basis (Fin (i)) (ConcreteBTField k) (ConcreteBTField n)) =
    (Basis (Fin (j)) (ConcreteBTField k) (ConcreteBTField n))

@[simp, grind] lemma R_le_N : sz.R ‚â§ sz.N

theorem append_rbrKnowledgeSoundness
    (V‚ÇÅ : Verifier oSpec Stmt‚ÇÅ Stmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : Verifier oSpec Stmt‚ÇÇ Stmt‚ÇÉ pSpec‚ÇÇ)
    {rbrKnowledgeError‚ÇÅ : pSpec‚ÇÅ.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    {rbrKnowledgeError‚ÇÇ : pSpec‚ÇÇ.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    (h‚ÇÅ : V‚ÇÅ.rbrKnowledgeSoundness init impl rel‚ÇÅ rel‚ÇÇ rbrKnowledgeError‚ÇÅ)
    (h‚ÇÇ : V‚ÇÇ.rbrKnowledgeSoundness init impl rel‚ÇÇ rel‚ÇÉ rbrKnowledgeError‚ÇÇ) :
      (V‚ÇÅ.append V‚ÇÇ).rbrKnowledgeSoundness init impl rel‚ÇÅ rel‚ÇÉ
        (Sum.elim rbrKnowledgeError‚ÇÅ rbrKnowledgeError‚ÇÇ ‚àò ChallengeIdx.sumEquiv.symm)

theorem distFromCode_eq_zero_iff_mem (C : Set (n ‚Üí R)) (u : n ‚Üí R) : Œî‚ÇÄ(u, C) = 0 ‚Üî u ‚àà C

lemma approximate_solution_is_exact_solution_coeffs
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  : ‚àÄ t ‚â• k,
  Œ±' 
    x‚ÇÄ 
    (R k Œ¥ x‚ÇÄ h_gs) 
    (irreducible_H k h_gs) 
    t 
  = 
  (0 : AppendixA.ùïÉ (H k Œ¥ x‚ÇÄ h_gs))

lemma eval‚ÇÇ_induction_on : True

theorem BitVec.eq_append_iff_extract {lo_size hi_size : ‚Ñï} (lo : BitVec lo_size)
  (hi : BitVec hi_size) (h_hi_gt_0 : hi_size > 0) (h_lo_gt_0 : lo_size > 0)
  (x : BitVec (hi_size + lo_size)) : x = dcast (by rfl) (BitVec.append (msbs:=hi) (lsbs:=lo)) ‚Üî
  hi = dcast (by omega) (BitVec.extractLsb (hi:=hi_size + lo_size - 1) (lo:=lo_size) x) ‚àß
  lo = dcast (by omega) (BitVec.extractLsb (hi:=lo_size - 1) (lo:=0) x)

@[simp]
lemma OracleVerifier.id_rbrKnowledgeSoundness
    {rel : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness)} :
    (OracleVerifier.id : OracleVerifier oSpec Statement OStatement _ _ _).rbrKnowledgeSoundness
      init impl rel rel 0

theorem mca_capacity_bound_CONJECTURE
  [DecidableEq Œπ]
  (Œ± : F) (œÜ : Œπ ‚Ü™ F) (m : ‚Ñï) [Smooth œÜ]
  (par‚Ñì_type : Type) [Fintype par‚Ñì_type] (exp : par‚Ñì_type ‚Ü™ ‚Ñï) :
  let Gen := RSGenerator.genRSC par‚Ñì_type œÜ m exp
  let : Fintype Gen.par‚Ñì := Gen.h‚Ñì
  haveI := Gen.Gen_nonempty
  ‚àÉ (c‚ÇÅ c‚ÇÇ : ‚Ñï),
    ‚àÄ (f : Gen.par‚Ñì ‚Üí Œπ ‚Üí F) (Œ∑ : ‚Ñù) (_hŒ∑ : 0 < Œ∑) (Œ¥ : ‚Ñù‚â•0)
      (_hŒ¥ : 0 < Œ¥ ‚àß Œ¥ < 1 - Gen.rate - Œ∑),
      Pr_{let r ‚Üê$·µñ Gen.Gen}[ proximityCondition f Œ¥ r Gen.C ] ‚â§
        ENNReal.ofReal (
          (((Fintype.card par‚Ñì_type - 1) : ‚Ñù)^c‚ÇÇ * ((2^m) : ‚Ñù)^c‚ÇÇ) /
          (Œ∑^c‚ÇÅ * Gen.rate^(c‚ÇÅ+c‚ÇÇ) * (Fintype.card F))
        )

@[csimp]
theorem vappend_eq_append : @vappend = @append

lemma concrete_mul_comm0 (a b : ConcreteBTField 0) :
  concrete_mul a b = concrete_mul b a

Nat.pos_of_neZero in Init.Data.Nat.Basic

theorem hammingDist_le_of_decoder_eq_some [NeZero n] {œâs f : Fin n ‚Üí F}
  (h : decoder e k œâs f = some p) : Œî‚ÇÄ(f, p.eval ‚àò œâs) ‚â§ e

@[simp]
lemma Transcript.def_eq {k : Fin (n + 1)} {pSpec : ProtocolSpec n} :
    (pSpec.take k k.is_le).FullTranscript =
      ((i : Fin k) ‚Üí pSpec.¬´Type¬ª (Fin.castLE (by omega) i))

lemma getBit_of_xor {n m k: ‚Ñï} : getBit k (n ^^^ m) = getBit k n ^^^ getBit k m

@[simp]
theorem seqCompose_one {n : Fin 1 ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)} :
    seqCompose pSpec = pSpec 0

lemma mkLastOracleIndex_last : mkLastOracleIndex ‚Ñì œë (Fin.last ‚Ñì) = ‚Ñì / œë - 1

theorem cast_eq_dcast {h : n‚ÇÅ = n‚ÇÇ} {pSpec : ProtocolSpec n‚ÇÅ} :
    pSpec.cast h = dcast h pSpec

omit [NeZero r] [Field L] [Fintype L] [DecidableEq L] [DecidableEq ùîΩq] [Field ùîΩq] [Algebra ùîΩq L] in
lemma base_coeffsBySuffix (a : Fin (2 ^ ‚Ñì) ‚Üí L) :
  coeffsBySuffix (r:=r) (R_rate := R_rate) a 0 0 = a

lemma getFoldingChallenges_init_succ_eq (i : Fin ‚Ñì)
    (j : Fin (toOutCodewordsCount ‚Ñì œë i.castSucc)) (challenges : Fin i.succ ‚Üí L)
    (h : ‚Üëj * œë + œë ‚â§ ‚Üëi.castSucc) :
    getFoldingChallenges (r := r) (ùì° := ùì°) (œë := œë) i.castSucc (Fin.init challenges) (‚Üëj * œë)
      (h := by omega) =
    getFoldingChallenges (r := r) (ùì° := ùì°) i.succ challenges (‚Üëj * œë)
      (h := by simp only [Fin.val_succ]; simp only [Fin.coe_castSucc] at h; omega)

Nat.lt_trans in Init.Prelude

theorem hconcat_right_injective {Œ± : Fin n ‚Üí Sort u} {Œ≤ : Sort u} (v : (i : Fin n) ‚Üí Œ± i) :
    Function.Injective (hconcat v : Œ≤ ‚Üí (i : Fin (n + 1)) ‚Üí vconcat Œ± Œ≤ i)

Nat.add_left_cancel in Init.Data.Nat.Basic

@[simp]
theorem ConcreteBTField.RingHom_eq_of_source_eq (k n m : ‚Ñï) (h_eq : k = n) :
    (ConcreteBTField k ‚Üí+* ConcreteBTField m)
    = (ConcreteBTField n ‚Üí+* ConcreteBTField m)

@[simp]
lemma toFun_invFun (f : ‚àÄ a, Œ≤ a) : inst.equiv.toFun (equiv.invFun f : F) = f

theorem Reduction.run_of_prover_first [ProverOnly pSpec] (stmt : StmtIn) (wit : WitIn)
    (reduction : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      reduction.run stmt wit = (do
        let state := reduction.prover.input (stmt, wit)
        let ‚ü®msg, state‚ü© ‚Üê liftComp (reduction.prover.sendMessage ‚ü®0, by simp‚ü© state) _
        let ctxOut ‚Üê reduction.prover.output state
        let transcript : pSpec.FullTranscript := fun i => match i with | ‚ü®0, _‚ü© => msg
        let stmtOut ‚Üê reduction.verifier.verify stmt transcript
        return (‚ü®transcript, ctxOut‚ü©, stmtOut))

private lemma errors_are_roots_of_E {i : Fin n}
  (h : f i ‚â† p.eval (œâs i)) : (E œâs f p e).eval (œâs i) = 0

lemma getLowBits_zero_eq_zero {n : ‚Ñï} : getLowBits 0 n = 0

@[simp]
lemma eval_solutionToE {x : F} :
  eval x (solutionToE e k v) = x ^ e + ‚àë y : Fin e, v ‚ü®y, by omega‚ü© * x ^ y.1

theorem ZMod.blub :
    ‚àÄ {n q c : ‚Ñï} (a : ZMod n), (decide (n ‚â• 2) = true) ‚Üí (decide (c < n) = true) ‚Üí
      (decide (c ‚â† 1) = true) ‚Üí IsNat (a ^ ((n - 1) / q)) c ‚Üí a ^ ((n - 1) / q) ‚â† 1

@[simp]
theorem LeafData.rightSubtree_internal {Œ±} {s_left s_right : Skeleton}
    (left : LeafData Œ± s_left) (right : LeafData Œ± s_right) :
    (LeafData.internal left right).rightSubtree = right

lemma sum_inv_Z_next_eq
  (k : ‚Ñï)
  (prev : ConcreteBTFStepResult (k := k)) :
  letI : Field (ConcreteBTField k) := mkFieldInstance (prev.toConcreteBTFieldProps)
  letI : Field (ConcreteBTField (k + 1)) := mkFieldInstance (k:=k+1)
    (props:=liftBTFieldProps (k:=k) (prevBTFResult:=prev))
  letI : Algebra (ConcreteBTField k) (ConcreteBTField (k + 1)) :=
    instAlgebraLiftConcreteBTField k prev
  Z (k + 1) + (Z (k + 1))‚Åª¬π = (algebraMap (ConcreteBTField k) (ConcreteBTField (k + 1))) (Z k)

lemma listOfCloseCodewords_eq_zero :
  listOfCloseCodewords C y n = 0 ‚Üî IsEmpty (hammingBall C y n) ‚à® Infinite (hammingBall C y n)

@[simp]
lemma evenPart_by_2 :
  2 * (evenPart f) = f + f.comp (-X)

@[simp]
theorem runWithOracle_freeMonad_query_roll (f : spec.FunctionType)
    (i : Œπ) (t : spec.domain i)
    (r : (spec.range i) ‚Üí FreeMonad (spec.OracleQuery) (Option Œ±)) :
    runWithOracle f (FreeMonad.roll (query i t) r) = runWithOracle f (r (f i t))

lemma irreducibleHTildeOfIrreducible {H : Polynomial (Polynomial F)} :
    (Irreducible H ‚Üí Irreducible (H_tilde H))

lemma forwardRange_eq_of_r_eq (n : ‚Ñï) (r1 r2 : Fin n) (h_r_eq : r1 = r2) (l : Fin (r1.val + 1)) :
  forwardRange n r1 l = forwardRange n r2 ‚ü®l, by omega‚ü©

theorem finSuccEquivNth_coeff_coeff (m : Fin n ‚Üí‚ÇÄ ‚Ñï) (f : MvPolynomial (Fin (n + 1)) R) (i : ‚Ñï) :
    coeff m (Polynomial.coeff (finSuccEquivNth R p f) i) = coeff (m.insertNth p i) f

lemma sum_insertNth' [AddCommMonoid M] [AddCommMonoid N] {n : ‚Ñï} (œÉ : Fin n ‚Üí‚ÇÄ M) (i : M)
    (p : Fin (n + 1)) (f : Fin (n+1) ‚Üí M ‚Üí N) (h : ‚àÄ x, f x 0 = 0) :
    sum (insertNth p i œÉ) f = f p i + sum œÉ (Fin.removeNth p f)

lemma Fin.le_succ (a : Fin r) (h_a_add_1 : a + 1 < r) : a ‚â§ a + 1

@[simp]
theorem fconcat_castSucc {Œ± : Fin n ‚Üí A} {Œ≤ : A}
    (v : (i : Fin n) ‚Üí F (Œ± i)) (b : F Œ≤) (i : Fin n) :
    (v :+ ∞‚¶ÉF‚¶Ñ b) (castSucc i) = cast (by simp [vconcat_castSucc]) (v i)

lemma concrete_mul_zero0 (a : ConcreteBTField 0) :
  concrete_mul a (zero (k:=0)) = zero (k:=0)

@[simp]
lemma constantCode_eq_ofNat_zero_iff [Nonempty Œπ] :
  constantCode x Œπ = 0 ‚Üî x = 0

@[simp]
theorem oracleReduction_completeness (h : init.neverFails)
    (hRel : ‚àÄ stmtIn oStmtIn witIn,
      ((stmtIn, oStmtIn), witIn) ‚àà relIn ‚Üí
      ((mapStmt stmtIn, mapOStmt embedIdx hEq oStmtIn), mapWit stmtIn witIn) ‚àà relOut) :
    (oracleReduction oSpec mapStmt mapWit embedIdx hEq).perfectCompleteness init impl
      relIn relOut

protected lemma roots_of_eloc_poly {x : F}
  (h : (ElocPoly n œâs f p).eval x = 0) :
  ‚àÉ i, i < n ‚àß f i ‚â† p.eval (œâs i)

@[simp]
theorem divide_by_2_mem {s : Finset ‚Ñï} {d : ‚Ñï} :
  d ‚àà divide_by_2 s ‚Üî 2 * d ‚àà s

lemma isInterleaved_codeOfLinearCode : (codeOfLinearCode Œ∫ LC).isInterleaved

@[to_additive (attr := simp) vsum_succ]
lemma vprod_succ [CommMonoid Œ±] {a : Fin (n + 1) ‚Üí Œ±} : vprod a = a 0 * vprod (a ‚àò Fin.succ)

@[simp]
theorem ConcreteBTFieldAlgebra_id {l r : ‚Ñï} (h_eq : l = r) :
    @ConcreteBTFieldAlgebra l r (h_le:=by omega) =
    (h_eq ‚ñ∏ (Algebra.id (ConcreteBTField l)) :
      Algebra (ConcreteBTField l) (ConcreteBTField r))

theorem liftContext_perfectCompleteness
    (h : R.perfectCompleteness init impl innerRelIn innerRelOut) :
      (R.liftContext lens).perfectCompleteness init impl outerRelIn outerRelOut

@[simp]
theorem zero_dappend {motive : Fin (0 + n) ‚Üí Sort u} {u : (i : Fin 0) ‚Üí motive (castAdd n i)}
    (v : (i : Fin n) ‚Üí motive (natAdd 0 i)) :
    dappend (motive := motive) u v = fun i => cast (by simp) (v (i.cast (by omega)))

@[simp]
lemma lastBlockIdx_mul_œë_add_fin_lt_‚Ñì (i : Fin œë) :
    (‚Ñì / œë - 1) * œë + ‚Üëi < ‚Ñì

@[simp]
theorem FullData.map_internal {Œ± Œ≤} {s_left s_right : Skeleton}
    (f : Œ± ‚Üí Œ≤) (value : Œ±) (left : FullData Œ± s_left) (right : FullData Œ± s_right) :
    (FullData.internal value left right).map f =
      FullData.internal (f value) (left.map f) (right.map f)

theorem support_mul_C_le (p : MvPolynomial œÉ R) (r : R) : (p * C r).support ‚äÜ p.support

@[grind _=_]
theorem monomialXY_mul_monomialXY {n m p q : ‚Ñï} {a b : F} :
    monomialXY n m a * monomialXY p q b = monomialXY (n + p) (m + q) (a * b)

lemma runWithOracle_getPutativeRoot {s} (idx : BinaryTree.SkeletonLeafIndex s)
    (leafValue : Œ±) (proof : List Œ±) (f) :
    (runWithOracle f (getPutativeRoot idx leafValue proof))
      =
    getPutativeRoot_with_hash idx leafValue proof fun (left right : Œ±) => (f () ‚ü®left, right‚ü©)

lemma sum_of_and_eq_zero_is_or {n m : ‚Ñï} (h_n_AND_m : n &&& m = 0) : n + m = n ||

lemma forwardRange_pred_le_ne_empty (n : ‚Ñï) (r : Fin n) (l : Fin (r.val + 1))
    (h_l_gt_0 : l.val > 0) : forwardRange n r ‚ü®l.val - 1, by omega‚ü© ‚â† []

theorem liftContext_completeness
    (h : R.completeness init impl innerRelIn innerRelOut completenessError) :
      (R.liftContext lens).completeness init impl outerRelIn outerRelOut completenessError

theorem liftContext_knowledgeSoundness [Inhabited InnerWitIn]
    {knowledgeError : ‚Ñù‚â•0}
    {stmtLens : OracleStatement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                                OuterOStmtIn OuterOStmtOut InnerOStmtIn InnerOStmtOut}
    {witLens : Witness.InvLens (OuterStmtIn √ó ‚àÄ i, OuterOStmtIn i)
                            OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    (V : OracleVerifier oSpec InnerStmtIn InnerOStmtIn InnerStmtOut InnerOStmtOut pSpec)
    [lensKS : Extractor.Lens.IsKnowledgeSound
      outerRelIn innerRelIn outerRelOut innerRelOut
      (V.toVerifier.compatStatement stmtLens) (fun _ _ => True) ‚ü®stmtLens, witLens‚ü©]
    (h : V.knowledgeSoundness init impl innerRelIn innerRelOut knowledgeError) :
      (V.liftContext stmtLens).knowledgeSoundness init impl outerRelIn outerRelOut
        knowledgeError

lemma eq_degree_of_equiv [LawfulBEq R] {p q : UniPoly R} : equiv p q ‚Üí p.degree = q.degree

lemma Lemma_A_1 {H : F[X][Y]} (Œ≤ : ùí™ H) (D : ‚Ñï) (hD : D ‚â• Bivariate.totalDegree H)
    (S_Œ≤_card : Set.ncard (S_Œ≤ Œ≤) > (weight_Œõ_over_ùí™ Œ≤ D) * H.natDegree) :
  embeddingOfùí™IntoùïÉ _ Œ≤ = 0

lemma domain_injective {i : ‚Ñï} : i ‚â§ n ‚Üí Function.Injective (domain D x n i)

@[simp]
theorem leftpad_apply_lt (n : ‚Ñï) (a : Œ±) (v : Fin m ‚Üí Œ±) (i : Fin n)
    (h : i.val < n - m) : leftpad n a v i = a

@[simp]
theorem oracleReduction_completeness (h : init.neverFails) :
    (oracleReduction oSpec Statement OStatement Witness).perfectCompleteness init impl oRelIn
    (toORelOut oRelIn)

theorem vconcat_inj (v w : Fin n ‚Üí Œ±) (a b : Œ±) :
    vconcat v a = vconcat w b ‚Üî v = w ‚àß a = b

theorem linsolve_some {A : Matrix (Fin n) (Fin m) F} {b : Fin n ‚Üí F} {x : Fin m ‚Üí F}
  (h : linsolve A b = some x)
  : A.mulVec x = b

@[simp]
theorem runWithOracle_bind (f : spec.FunctionType)
    (oa : OracleComp spec Œ±) (ob : Œ± ‚Üí OracleComp spec Œ≤) :
    runWithOracle f (oa >>= ob) =
    (runWithOracle f oa) >>=
    (fun x => runWithOracle f (ob x))

@[simp]
lemma oddPart_by_2 :
    2 * (oddPart f) = (f - f.comp (-X)) /‚Çò X

theorem foldCommitOracleVerifier_rbrKnowledgeSoundness
    (i : Fin ‚Ñì) (hCR : isCommitmentRound ‚Ñì œë i) :
    (foldCommitOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hCR).rbrKnowledgeSoundness
      init impl
      (relIn := roundRelation (mp := mp) ùîΩq Œ≤ (œë:=œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) i.castSucc)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë:=œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) i.succ)
      (rbrKnowledgeError := fun _ => foldKnowledgeError ùîΩq Œ≤ (œë:=œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i ‚ü®1, by rfl‚ü©
      )

theorem one_le_sub_consecutive_two_pow (n : ‚Ñï): 1 ‚â§ 2^(n+1) - 2^n

@[simp]
lemma evenize_coeff {f : Polynomial F} {n : ‚Ñï} :
    (evenize f).coeff n = if Even n then f.coeff (n / 2) else 0

lemma bwm_of_pos [NeZero n] (h : j.1 < e) :
  BerlekampWelchMatrix e k œâs f i j = -Rhs j.1 œâs f i

@[simp] theorem rightpad_eq_self (l : List Œ±) (n : Nat) (h : n ‚â§ l.length) :
    rightpad n unit l = l

@[simp]
protected lemma elocPoly_zero : ElocPoly 0 œâs f p = 1

lemma schwartz_zippel' {p : MvPolynomial œÉ R} (hp : p ‚â† 0) (S : œÉ ‚Üí Finset R) :
    #{x ‚àà Finset.pi p.vars S | eval (extendDomain x) p = 0} / ‚àè i ‚àà p.vars, (#(S i) : ‚Ñö‚â•0)
      ‚â§ ‚àë i ‚àà p.vars, (p.degreeOf i / #(S i) : ‚Ñö‚â•0)

lemma dappend_left_of_lt {motive : Fin (m + n) ‚Üí Sort u}
    (u : (i : Fin m) ‚Üí motive (castAdd n i)) (v : (i : Fin n) ‚Üí motive (natAdd m i))
    (i : Fin (m + n)) (h : i.val < m) :
      dappend (motive := motive) u v i = cast (by simp) (u ‚ü®i, h‚ü©)

lemma rtake_eq_rtake : transcript‚ü¶m:‚üß = transcript.drop m h

omit [NoZeroDivisors ùîΩ] in
lemma splitNth_def (n : ‚Ñï) (f : ùîΩ[X]) [inst : NeZero n] :
    f =
      ‚àë i : Fin n,
        (Polynomial.X ^ i.1) *
          Polynomial.eval‚ÇÇ Polynomial.C (Polynomial.X ^ n) (splitNth f n i)

@[simp]
theorem addCases'_right {m n : ‚Ñï} {Œ± : Fin m ‚Üí Sort u} {Œ≤ : Fin n ‚Üí Sort u}
    (left : (i : Fin m) ‚Üí Œ± i) (right : (j : Fin n) ‚Üí Œ≤ j) (i : Fin n) :
      addCases' left right (Fin.natAdd m i) = (Fin.append_right Œ± Œ≤ i) ‚ñ∏ (right i)

@[csimp, grind =]
theorem idxOf'_eq_idxOf : @idxOf' = @idxOf

lemma folding_steps_pos : (œë : ‚Ñï) > 0

@[simp] theorem BitVec.cast_zero {n m : ‚Ñï} (h : n = m) : BitVec.cast h 0 = 0

lemma iterated_fold_transitivity
    (i : Fin r) (steps‚ÇÅ steps‚ÇÇ : Fin (‚Ñì + 1))
    (h_bounds : i.val + steps‚ÇÅ + steps‚ÇÇ ‚â§ ‚Ñì) -- A single, sufficient bounds check
    (f : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := i) ‚Üí L)
    (r_challenges‚ÇÅ : Fin steps‚ÇÅ ‚Üí L) (r_challenges‚ÇÇ : Fin steps‚ÇÇ ‚Üí L) :
    -- LHS : The nested fold (folding twice)
    have hi1 : i.val + steps‚ÇÅ ‚â§ ‚Ñì := by exact le_of_add_right_le h_bounds
    have hi2 : i.val + steps‚ÇÇ ‚â§ ‚Ñì := by
      rw [Nat.add_assoc, Nat.add_comm steps‚ÇÅ steps‚ÇÇ, ‚ÜêNat.add_assoc] at h_bounds
      exact le_of_add_right_le h_bounds
    have hi12 : steps‚ÇÅ + steps‚ÇÇ < ‚Ñì + 1 := by
      apply Nat.lt_succ_of_le; rw [Nat.add_assoc] at h_bounds;
      exact Nat.le_of_add_left_le h_bounds
    let lhs := iterated_fold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (i := ‚ü®i.val + steps‚ÇÅ, by -- ‚ä¢ ‚Üëi + ‚Üësteps‚ÇÅ < r
        apply Nat.lt_of_le_of_lt (m := ‚Ñì) (hi1) (‚Ñì_lt_r (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))‚ü©)
      (steps := steps‚ÇÇ)
      (h_i_add_steps := by simp only; apply Nat.lt_add_of_pos_right_of_le; exact h_bounds)
      (f := by
        exact iterated_fold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := i) (steps := steps‚ÇÅ)
          (h_i_add_steps := by apply Nat.lt_add_of_pos_right_of_le; exact hi1) (f := f)
          (r_challenges := r_challenges‚ÇÅ)
      ) r_challenges‚ÇÇ
    let rhs := iterated_fold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := i)
      (steps := ‚ü®steps‚ÇÅ + steps‚ÇÇ, hi12‚ü©)
      (h_i_add_steps := by
        simp only; rw [‚ÜêNat.add_assoc]; apply Nat.lt_add_of_pos_right_of_le; exact h_bounds)
      (f := f) (r_challenges := Fin.append r_challenges‚ÇÅ r_challenges‚ÇÇ)
    lhs = by
      simp only [‚ÜêNat.add_assoc] at ‚ä¢ rhs
      exact rhs

theorem monoToLagrangeLevel_lagrangeToMonoLevel_id (v : Vector R (2 ^ n)) (i : Fin n) :
  monoToLagrangeLevel i (lagrangeToMonoLevel i v) = v

@[simp]
theorem snoc_last : snoc s y (Fin.last n) = y

@[simp]
theorem induction_two' {motive : Fin 3 ‚Üí Sort*} {zero : motive 0}
    {succ : ‚àÄ i : Fin 2, motive i.castSucc ‚Üí motive i.succ} :
      induction (motive := motive) zero succ (2 : Fin 3) = succ 1 (succ 0 zero)

theorem lagrangeToMonoLevel_monoToLagrangeLevel_id (v : Vector R (2 ^ n)) (i : Fin n) :
  lagrangeToMonoLevel i (monoToLagrangeLevel i v) = v

Fin.is_le in Init.Data.Fin.Lemmas

theorem concrete_mul_eq
  (prevBTFieldProps : ConcreteBTFieldProps (k := k - 1))
  (a b : ConcreteBTField k) {a‚ÇÅ a‚ÇÄ b‚ÇÅ b‚ÇÄ : ConcreteBTField (k - 1)}
  (h_a : (a‚ÇÅ, a‚ÇÄ) = split h_k a) (h_b : (b‚ÇÅ, b‚ÇÄ) = split h_k b) :
  concrete_mul a b =
    „Ää concrete_mul a‚ÇÄ b‚ÇÅ + concrete_mul b‚ÇÄ a‚ÇÅ + concrete_mul (concrete_mul a‚ÇÅ b‚ÇÅ) (Z (k - 1)),
      concrete_mul a‚ÇÄ b‚ÇÄ + concrete_mul a‚ÇÅ b‚ÇÅ „Äã

lemma oodSampling_rs_le_bound
    {f : Œπ ‚Üí F} {m s : ‚Ñï} {œÜ : Œπ ‚Ü™ F} [Smooth œÜ]
    (Œ¥ l : ‚Ñù‚â•0) (hŒ¥Le : Œ¥ ‚â§ 1)
    (C : Set (Œπ ‚Üí F)) (hcode : C = smoothCode œÜ m ‚àß listDecodable C Œ¥ l) :
    Pr_{ let rs ‚Üê$·µñ (Fin s ‚Üí F) }[ ‚àÉ u u' : smoothCode œÜ m,
                        u.val ‚â† u'.val ‚àß
                        u.val ‚àà relHammingBall C f Œ¥ ‚àß
                        u'.val ‚àà relHammingBall C f Œ¥ ‚àß
                        ‚àÄ i : Fin s,
                          let ri := rs i
                          let rVec := fun j : Fin m => ri ^ (2^(j : ‚Ñï))
                          (mVdecode u).eval (rVec) = (mVdecode u').eval (rVec)
                      ] ‚â§ ENNReal.ofReal (((l : ‚Ñù)^2 / 2) * (((2^m : ‚Ñù) / Fintype.card F)^s))

@[simp]
theorem drop_zero (v : (i : Fin n) ‚Üí Œ± i) : drop 0 n.zero_le v = v

private lemma fold_max_lemma {Œπ : Type} {s : Finset Œπ} {f : Œπ ‚Üí ‚Ñï} {n : ‚Ñï} :
    (‚àÄ i ‚àà s, f i ‚â§ n) ‚Üí Finset.fold max 0 f s ‚â§ n

theorem prime_11 : Nat.Prime 11

lemma towerRingHomForwardMap_split_eq (k : ‚Ñï) (h_pos : k > 0) (x : ConcreteBTField k) :
  let p := split (k:=k) (h:=h_pos) x
  towerRingHomForwardMap (k:=k) (x) =
    BinaryTower.join_via_add_smul (k:=k) (h_pos:=h_pos)
      (hi_btf := towerRingHomForwardMap (k:=k-1) (p.1))
      (lo_btf := towerRingHomForwardMap (k:=k-1) (p.2))

theorem add_zero : p + 0 = p

List.le_sum_of_mem in Mathlib.Algebra.Order.BigOperators.Group.List

private lemma johnson_unrefined_by_M [Zero F]
  (h_n : 0 < n)
  (h_B : 2 ‚â§ B.card)
  (h_card : 2 ‚â§ (Fintype.card F))
  :
  B.card * ((1 - e B 0 / n) ^ 2  + (e B 0) ^ 2 / ((Fintype.card F - 1) * n^2) - 1 + d B/n)
  ‚â§
  d B/n

@[simp, grind =] lemma R_plus_C_eq_N : sz.R + sz.C = sz.N

lemma rootMultiplicity_some_implies_root {F : Type} [CommSemiring F] [DecidableEq F]
  {x y : F} {f : F[X][Y]} (h : some 0 < (rootMultiplicity (f := f) x y))
  : (f.eval 0).eval 0 = 0

@[simp]
lemma eval‚ÇÇAlgHom_apply {A B : Type*} [CommSemiring A] [CommSemiring B] [MvPolynomialLike œÉ A P]
    [Algebra R A] [IsScalarTower R A P] [Algebra R B]
    (f : A ‚Üí‚Çê[R] B) (g : œÉ ‚Üí B) (p : P) :
    (eval‚ÇÇAlgHom f g) p = eval‚ÇÇ f g p

lemma mul_by_2_def {s : Finset ‚Ñï} :
    mul_by_2 s = s.map ‚ü®fun n => 2 * n, by {
      intro a b
      simp
    }‚ü©

@[simp]
lemma aeval_X {A : Type w} [CommSemiring A] [Algebra R A] (s : A) : aeval s X (P := P) = s

theorem append_comp' {a : Fin m ‚Üí Œ±} {b : Fin n ‚Üí Œ±} (f : Œ± ‚Üí Œ≤)
    (i : Fin (m + n)) : append (f ‚àò a) (f ‚àò b) i = f (append a b i)

theorem oracleReduction_eq_reduction :
    (oracleReduction R deg D oSpec).toReduction = reduction R deg D oSpec

private lemma oddPart_eq_oddPart' {f : Polynomial F} : oddPart f = oddPart' f

theorem foldOracleVerifier_rbrKnowledgeSoundness (i : Fin ‚Ñì) :
    (foldOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i).rbrKnowledgeSoundness init impl
      (relIn := roundRelation (mp := mp) ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        (ùìë := ùìë) i.castSucc)
      (relOut := foldStepRelOut (mp := mp) ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        (ùìë := ùìë) i)
      (foldKnowledgeError ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)

theorem drop_eq_rtake (m : ‚Ñï) (h : m ‚â§ n) (v : (i : Fin n) ‚Üí Œ± i) :
    drop m h v = fun i => dcast (by simp [Fin.cast]; omega) (rtake (n - m) (by omega) v i)

@[simp]
theorem Z_succ_eq_adjointRoot_root (k : ‚Ñï) : Z (k+1) = AdjoinRoot.root (poly k)

lemma qMap_eval_mem_sDomain_succ (i : Fin ‚Ñì)
    (h_i_add_1 : i.val + 1 ‚â§ ‚Ñì) (x : (sDomain ùîΩq Œ≤
    h_‚Ñì_add_R_rate) ‚ü®i, by omega‚ü©) :
    (qMap ùîΩq Œ≤ ‚ü®i.val, by omega‚ü©).eval (x.val : L) ‚àà
    sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate
      ‚ü®i.val + 1, by omega‚ü©

@[simp]
lemma eval_solutionToQ {x : F} :
  eval x (solutionToQ e k v) =
  ‚àë i ‚àà Finset.range (e + k), liftF v (e + i) * x ^ i

@[simp]
lemma length_cons (x : Œ£ Œ± : Type u, Œ±) (xs : HList) : (x ::‚Çï xs).length = xs.length + 1

lemma subUpFull_of_vandermonde_is_vandermonde (h : n ‚â§ m) :
  Matrix.vandermonde (Œ± ‚àò Fin.castLE h) =
  Matrix.subUpFull (nonsquare n Œ±) (Fin.castLE h)

omit [NeZero ‚Ñì] [NeZero r] [NeZero ùì°] in
lemma fin_‚Ñì_lt_‚Ñì_add_R (i : Fin ‚Ñì)
    : i.val < ‚Ñì + ùì°

@[simp]
lemma eval‚ÇÇAlgHom_apply {A : Type w} {B : Type*} [CommSemiring A] [CommSemiring B]
    [PolynomialLike A P] [Algebra R A] [IsScalarTower R A P] [Algebra R B]
    (f : A ‚Üí‚Çê[R] B) (b : B) (p : P) :
    (eval‚ÇÇAlgHom f b) p = eval‚ÇÇ f b p

lemma toImpl_toPoly_of_canonical [LawfulBEq R] (p : UniPolyC R) : p.toPoly.toImpl = p

lemma matchSize_size {p q : UniPoly Q} :
    let (p', _) := Array.matchSize p q 0
    p'.size = max p.size q.size

lemma getLowBits_succ {n: ‚Ñï} (numLowBits: ‚Ñï) :
    getLowBits (numLowBits + 1) n = getLowBits numLowBits n
    + (getBit numLowBits n) <<< numLowBits

@[simp]
theorem distFromCode_of_mem (C : Set (n ‚Üí R)) {u : n ‚Üí R} (h : u ‚àà C) : Œî‚ÇÄ(u, C) = 0

private lemma le_sum_choose_K [Zero F]
  (h_card : 2 ‚â§ (Fintype.card F)) :
  choose_2 (K B i 0) + (Fintype.card (Œ± := F) - 1) *
  choose_2 ((B.card - K B i 0) / (Fintype.card (Œ± := F) - 1)) ‚â§ sum_choose_K_i B i

@[simp]
lemma length_nil : nil.length = 0

@[csimp]
theorem dappend_eq_addCases : @dappend = @addCases

theorem lagrangeBasis_getElem {w : Vector R n} (i : Fin (2 ^ n)) :
    (lagrangeBasis w)[i] = ‚àè j : Fin n, if (BitVec.ofFin i).getLsb j then w[j] else 1 - w[j]

theorem insertNth_zero_eq_cases {n : ‚Ñï} {Œ± : Fin (n + 1) ‚Üí Sort u} :
    insertNth 0 = cases (motive := Œ±)

@[grind _=_]
lemma degreeX_as_weighted_deg :
  degreeX f = natWeightedDegree f 1 0

omit hF‚ÇÇ in
theorem kernel_W_eq_U (i : Fin r) :
  LinearMap.ker (polyEvalLinearMap (W ùîΩq Œ≤ i)
    (W_is_additive ùîΩq Œ≤ i)) = U ùîΩq Œ≤ i

theorem add_comm (m n : ChurchNat Œ±) : add m n = add n m

@[simp]
theorem eq_refl {Œ± : Type u} (mx : m Œ±) : eq mx mx

@[simp]
lemma getTypes_hcons (x : Œ£ Œ± : Type u, Œ±) (xs : HList) :
    (x ::‚Çï xs).getTypes = x.1 :: xs.getTypes

theorem Nat.Prime_of_isNat : ‚àÄ {n n' : ‚Ñï}, IsNat n n' ‚Üí n'.Prime ‚Üí n.Prime

@[grind _=_]
lemma degreeY_as_weighted_deg (hf : f ‚â† 0) :
  natDegreeY f = natWeightedDegree f 0 1

lemma guruswami_sudan_for_proximity_gap_existence {k m : ‚Ñï} {œâs : Fin n ‚Ü™ F} {f : Fin n ‚Üí F} :
  ‚àÉ Q, Condition (k + 1) m ((proximity_gap_degree_bound ((k + 1 : ‚Ñö) / n) m n)) œâs f Q

theorem fconcat‚ÇÇ_injective2 {Œ±‚ÇÅ : Fin n ‚Üí A} {Œ±‚ÇÇ : Fin n ‚Üí B} {Œ≤‚ÇÅ : A} {Œ≤‚ÇÇ : B} :
    Function.Injective2 (@fconcat‚ÇÇ A B F‚ÇÇ n Œ±‚ÇÅ Œ≤‚ÇÅ Œ±‚ÇÇ Œ≤‚ÇÇ)

@[simp]
lemma natDegree_truncate [œÜ : NeZero n] : (truncate p n).natDegree < n

theorem hconcat_hcons {Œ± : Sort u} {Œ≤ : Fin n ‚Üí Sort u} {Œ≥ : Sort u} (a : Œ±) (v : (i : Fin n) ‚Üí Œ≤ i) (c : Œ≥) :
    True

theorem vconcat_right_injective (v : Fin n ‚Üí Œ±) : Function.Injective (vconcat v)

@[simp]
lemma natDegree_solutionToQ :
  (solutionToQ e k v).natDegree ‚â§ e + k - 1

lemma johnson_condition_strong_iff_johnson_denom_pos {B : Finset (Fin n ‚Üí F)} {v : Fin n ‚Üí F} :
  JohnsonConditionStrong B v ‚Üî 0 < JohnsonDenominator B v

theorem dcast‚ÇÇ_symm (ha : a = a') (hb : dcast ha b = b') (hc : dcast‚ÇÇ ha hb c = c') :
    dcast‚ÇÇ ha.symm (dcast_symm ha hb) c' = c

Fin.append_right in Mathlib.Data.Fin.Tuple.Basic

theorem dcast_eq_root_cast (h : a = a') : dcast h b = _root_.cast (congrArg Œ≤ h) b

lemma getMiddleBits_eq_mod {n offset len : ‚Ñï} :
  getMiddleBits offset len n = (n >>> offset) % (2 ^ len)

Nat.le_of_succ_le in Init.Data.Nat.Basic

@[simp]
lemma seqCompose_toReduction {m : ‚Ñï}
    (Stmt : Fin (m + 1) ‚Üí Type)
    {Œπ‚Çõ : Fin (m + 1) ‚Üí Type} (OStmt : (i : Fin (m + 1)) ‚Üí Œπ‚Çõ i ‚Üí Type)
    [O‚Çõ : ‚àÄ i, ‚àÄ j, OracleInterface (OStmt i j)]
    (Wit : Fin (m + 1) ‚Üí Type)
    {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    [O‚Çò : ‚àÄ i, ‚àÄ j, OracleInterface ((pSpec i).Message j)]
    (R : (i : Fin m) ‚Üí
      OracleReduction oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Wit i.castSucc)
        (Stmt i.succ) (OStmt i.succ) (Wit i.succ) (pSpec i)) :
    (seqCompose Stmt OStmt Wit R).toReduction =
      Reduction.seqCompose (fun i => Stmt i √ó (‚àÄ j, OStmt i j)) Wit
        (fun i => (R i).toReduction)

@[simp]
lemma aeval_C {A : Type w} [CommSemiring A] [Algebra R A] (x : A) (r : R) :
    (aeval x) (C r : P) = algebraMap R A r

lemma deevenize_comp_x_squared {f : Polynomial F} (hEven : EvenPoly f) :
    (deevenize f).comp (Polynomial.X * Polynomial.X) = f

theorem fappend‚ÇÇ_ext {Œ±‚ÇÅ : Fin m ‚Üí A} {Œ±‚ÇÇ : Fin m ‚Üí B} {Œ≤‚ÇÅ : Fin n ‚Üí A} {Œ≤‚ÇÇ : Fin n ‚Üí B}
    (u‚ÇÅ u‚ÇÇ : (i : Fin m) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i)) (v‚ÇÅ v‚ÇÇ : (i : Fin n) ‚Üí F‚ÇÇ (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) :
    fappend‚ÇÇ (F := F‚ÇÇ) u‚ÇÅ v‚ÇÅ = fappend‚ÇÇ (F := F‚ÇÇ) u‚ÇÇ v‚ÇÇ ‚Üî u‚ÇÅ = u‚ÇÇ ‚àß v‚ÇÅ = v‚ÇÇ

theorem changeOfBasisMatrix_det_ne_zero
  (‚Ñì : Nat) (h_‚Ñì : ‚Ñì ‚â§ r) :
  (changeOfBasisMatrix ùîΩq Œ≤ ‚Ñì h_‚Ñì).det ‚â† 0

theorem sub_add_eq_sub_sub_rev (a b c : Nat) (h1 : c ‚â§ b) (h2 : b ‚â§ a) :
  a - b + c = a - (b - c)

lemma fold_f_g_poly
  {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F} {k m : ‚Ñï}
  {œÜ_0 : (indexPowT S œÜ 0) ‚Ü™ F} {œÜ_k : (indexPowT S œÜ k) ‚Ü™ F}
  [Fintype (indexPowT S œÜ 0)] [DecidableEq (indexPowT S œÜ 0)] [Smooth œÜ_0]
  [Fintype (indexPowT S œÜ k)] [DecidableEq (indexPowT S œÜ k)] [Smooth œÜ_k]
  [‚àÄ i : ‚Ñï, Neg (indexPowT S œÜ i)]
  (Œ±s : Fin k ‚Üí F) (hk : k ‚â§ m)
  (f : smoothCode œÜ_0 m) (g : smoothCode œÜ_k (m-k)) :
  let fPoly

omit [Fintype F] in
private lemma hamming_weight_eq_sum [Zero F] {x : Fin n ‚Üí F}
  :
  ‚Äñx‚Äñ‚ÇÄ = ‚àë i, if x i = 0 then 0 else 1

theorem fconcat_inj {Œ± : Fin n ‚Üí A} {Œ≤ : A}
    (v‚ÇÅ v‚ÇÇ : (i : Fin n) ‚Üí F (Œ± i)) (a‚ÇÅ a‚ÇÇ : F Œ≤) :
    fconcat v‚ÇÅ a‚ÇÅ = fconcat v‚ÇÇ a‚ÇÇ ‚Üî v‚ÇÅ = v‚ÇÇ ‚àß a‚ÇÅ = a‚ÇÇ

@[simp]
theorem dflatten_embedSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {motive : (k : Fin (vsum n)) ‚Üí Sort*}
    (v : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí motive (embedSum i j)) (i : Fin m) (j : Fin (n i)) :
    dflatten (motive := motive) v (embedSum i j) = v i j

theorem image_support_finSuccEquivNth {f : MvPolynomial (Fin (n + 1)) R} {i : ‚Ñï} :
    Finset.image (Finsupp.insertNth p i) (Polynomial.coeff ((finSuccEquivNth R p) f) i).support =
      f.support.filter fun m => m p = i

lemma fieldSize_sub_one_factorization : fieldSize - 1 = 2 ^ twoAdicity * 127

@[simp]
theorem dflatten_one {n : Fin 1 ‚Üí ‚Ñï} {motive : (k : Fin (vsum n)) ‚Üí Sort*}
    {v : (i : Fin 1) ‚Üí (j : Fin (n i)) ‚Üí motive (embedSum i j)} :
    dflatten (motive := motive) v = v 0

List.length_drop in Init.Data.List.TakeDrop

@[simp, grind] lemma absorbPos_lt_N (sponge : DuplexSponge U C) :
    sponge.absorbPos < SpongeSize.N

theorem vcons_eq_const (a : Œ±) : a ::·µõ (fun _ : Fin n => a) = fun _ => a

@[simp] lemma mod_two_eq_zero (m : ‚Ñ§) : m % 2 = ( - m) % 2

@[simp]
theorem rightpad_apply_ge (n : ‚Ñï) (a : Œ±) (v : Fin m ‚Üí Œ±) (i : Fin n)
    (h : m ‚â§ i.val) : rightpad n a v i = a

theorem succ'_injective : Function.Injective (succ' : Nat ‚Üí Nat)

omit [DecidableEq L] h_Fq_char_prime hF‚ÇÇ hŒ≤_lin_indep in
lemma Prod_W_comp_X_sub_C_ne_zero (i : Fin r) :
    (univ : Finset ùîΩq).prod (fun c => (W ùîΩq Œ≤ i).comp (X - C (c ‚Ä¢ Œ≤ i))) ‚â† 0

@[simp]
theorem fappend_right {Œ± : Fin m ‚Üí A} {Œ≤ : Fin n ‚Üí A}
    (u : (i : Fin m) ‚Üí F (Œ± i)) (v : (i : Fin n) ‚Üí F (Œ≤ i)) (i : Fin n) :
    fappend u v (natAdd m i) = cast (by simp [vappend_right]) (v i)

lemma distToCode_of_nonempty {Œ± : Type*} [LinearOrder Œ±] [Zero Œ±]
                             {Œπ F : Type*}
                             {w : Œπ ‚Üí F} {C : Set (Œπ ‚Üí F)}
                             {Œ¥f : (Œπ ‚Üí F) ‚Üí (Œπ ‚Üí F) ‚Üí Œ±}
                             (h‚ÇÅ : (possibleDistsToCode w C Œ¥f).Finite)
                             (h‚ÇÇ : (possibleDistsToCode w C Œ¥f).Nonempty) :
  haveI := @Fintype.ofFinite _ h‚ÇÅ
  distToCode w C Œ¥f h‚ÇÅ = .some ((possibleDistsToCode w C Œ¥f).toFinset.min' (by simpa))

@[simp] theorem rightpad_twice_eq_rightpad_max (m n : Nat) (unit : Œ±) (l : List Œ±) :
    rightpad n unit (rightpad m unit l) = rightpad (max m n) unit l

theorem support_C_mul_le (p : MvPolynomial œÉ R) (r : R) : (C r * p).support ‚äÜ p.support

@[simp]
theorem verifier_rbrKnowledgeSoundness (hRel : ‚àÄ stmtIn witOut,
      (mapStmt stmtIn, witOut) ‚àà relOut ‚Üí (stmtIn, mapWitInv stmtIn witOut) ‚àà relIn) :
    (verifier oSpec mapStmt).rbrKnowledgeSoundness init impl relIn relOut 0

protected lemma elocPolyF_ne_zero {œâs f : Fin m ‚Üí F} :
  ElocPolyF œâs f p ‚â† 0

lemma getBit_eq_succ_getBit_of_mul_two_add_one {n k : ‚Ñï} : getBit (k+1) (2*n + 1) = getBit k n

omit [Fintype L] [DecidableEq L] in
theorem Polynomial.comp_same_inner_eq_if_same_outer (f g : L[X]) (h_f_eq_g : f = g) :
  ‚àÄ x, f.comp x = g.comp x

lemma approximate_solution_is_exact_solution_coeffs'
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  :
    Œ≥' x‚ÇÄ (R k Œ¥ x‚ÇÄ h_gs) (irreducible_H k h_gs) =
        PowerSeries.mk (fun t =>
          if t ‚â• k
          then (0 : AppendixA.ùïÉ (H k Œ¥ x‚ÇÄ h_gs))
          else PowerSeries.coeff _ t
            (Œ≥' 
              x‚ÇÄ
              (R k (x‚ÇÄ := x‚ÇÄ) (Œ¥ := Œ¥) h_gs)
              (irreducible_H k h_gs)))

theorem eq_join_via_add_smul_eq_iff_split (k : ‚Ñï) (h_pos : k > 0)
    (x : BTField k) (hi_btf lo_btf : BTField (k - 1)) :
    x = ‚ãò hi_btf, lo_btf ‚ãô ‚Üî
  split (k:=k) (h_k:=h_pos) x = (hi_btf, lo_btf)

theorem LeafData.composeBuild_leaf {Œ±} (a : Œ±)
    (compose : Œ± ‚Üí Œ± ‚Üí Œ±) :
    (LeafData.leaf a).composeBuild compose = FullData.leaf a

theorem BitVec.extractLsb_concat_hi {hi_size lo_size : ‚Ñï} (hi : BitVec hi_size)
  (lo : BitVec lo_size) (h_hi : hi_size > 0) :
  BitVec.extractLsb (hi:=hi_size + lo_size - 1) (lo:=lo_size)
  (BitVec.append (msbs:=hi) (lsbs:=lo)) = dcast (by
    rw [‚ÜêNat.sub_add_comm (by omega), Nat.sub_add_cancel (by omega), Nat.add_sub_cancel]
  ) hi

@[simp]
theorem dcons_succ {motive : Fin (n + 1) ‚Üí Sort u} (a : motive 0)
    (v : (i : Fin n) ‚Üí motive i.succ) (i : Fin n) : (a ::·µà‚ü®motive‚ü© v) i.succ = v i

@[simp] theorem popWhile_nil_or_last_false (p : Œ± ‚Üí Bool) (as : Array Œ±)
    (h : (as.popWhile p).size > 0) : ¬¨ (p <| (as.popWhile p).getLast h)

@[simp]
theorem reduction_completeness (h : init.neverFails) :
    (reduction oSpec Statement Witness).perfectCompleteness init impl relIn (toRelOut relIn)

lemma guruswami_sudan_for_proximity_gap_property {k m : ‚Ñï} {œâs : Fin n ‚Ü™ F}
  {f : Fin n ‚Üí F}
  {Q : F[X][X]}
  {p : ReedSolomon.code œâs n}
  (h : Œî‚ÇÄ(f, (ReedSolomon.codewordToPoly p).eval ‚àò f) ‚â§ proximity_gap_johnson (n := n) k m)
  :
  ((X : F[X][X]) - C (ReedSolomon.codewordToPoly p)) ‚à£ Q

lemma degree_bound_bivariate
  (qPoly : Polynomial F)
  (hdeg_q_min : qPoly.natDegree > 0)
  (hdeg_q_max : qPoly.natDegree < Fintype.card F)
  {t : ‚Ñï} (Q : MvPolynomial (Fin 2) F)
  (hdegX : MvPolynomial.degreeOf 0 Q < t)
  (hdegY : MvPolynomial.degreeOf 1 Q < qPoly.natDegree) :
  (MvPolynomial.eval‚ÇÇHom (Polynomial.C : F ‚Üí+* Polynomial F)
      (fun i : Fin 2 => if i = 0 then qPoly else Polynomial.X) Q).natDegree < t * qPoly.natDegree

lemma zipWith_const {Œ± Œ≤ : Type _} {f : Œ± ‚Üí Œ≤ ‚Üí Œ≤} {l‚ÇÅ : List Œ±} {l‚ÇÇ : List Œ≤}
  (h‚ÇÅ : l‚ÇÅ.length = l‚ÇÇ.length) (h‚ÇÇ : ‚àÄ a b, f a b = b) : l‚ÇÅ.zipWith f l‚ÇÇ = l‚ÇÇ

omit [NeZero ‚Ñì] [NeZero r] [NeZero ùì°] in
lemma ‚Ñì_lt_r {h_‚Ñì_add_R_rate : ‚Ñì + ùì° < r}
    : ‚Ñì < r

theorem correlatedAgreement_affine_curves [DecidableEq Œπ] {k : ‚Ñï} {u : Fin k ‚Üí Œπ ‚Üí F}
  {deg : ‚Ñï} {domain : Œπ ‚Ü™ F} {Œ¥ : ‚Ñù‚â•0}
  (hŒ¥ : Œ¥ ‚â§ 1 - ReedSolomonCode.sqrtRate deg domain)
  (hproximity :
    Pr_{let y ‚Üê $·µñ (Curve.parametrisedCurveFinite u)}[
      Code.relHammingDistToCode y.1 (ReedSolomon.code domain deg) ‚â§ Œ¥
    ] >
      k * (errorBound Œ¥ deg domain)) :
  correlatedAgreement (ReedSolomon.code domain deg) Œ¥ u

Nat.mul_le_mul_right in Init.Data.Nat.Basic

theorem findIdxRev?_eq_none {cond} {as : Array Œ±} (h : ‚àÄ i, (hi : i < as.size) ‚Üí ¬¨ cond as[i]) :
  findIdxRev? cond as = none

lemma concrete_div_eq_mul_inv {k : ‚Ñï} (a b : ConcreteBTField k) : a / b = a * (concrete_inv b)

private lemma Bi_biUnion_F2i :
  Bi B i = Finset.univ.biUnion (F2i B i)

@[simp]
theorem FullData.toLeafData_internal {Œ±} {s_left s_right : Skeleton}
    (value : Œ±) (left : FullData Œ± s_left) (right : FullData Œ± s_right) :
    (FullData.internal value left right).toLeafData =
      LeafData.internal (left.toLeafData) (right.toLeafData)

@[simp]
lemma bIdx_mul_œë_add_i_cast_lt_‚Ñì_succ (bIdx : Fin (‚Ñì / œë - 1)) (i : Fin (œë - 1 + 1))
    : ‚ÜëbIdx * œë + i < ‚Ñì + 1

theorem vcons_injective2 : Function.Injective2 (@vcons Œ± n)

omit [DecidableEq ùîΩq] hF‚ÇÇ h_Œ≤‚ÇÄ_eq_1 in
lemma get_sDomain_basis (i : Fin r) (h_i : i < ‚Ñì + R_rate) :
    ‚àÄ (k : Fin (‚Ñì + R_rate - i)),
    (sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate
      i (by omega)) k = eval (Œ≤ ‚ü®i + k.val, by omega‚ü©) (normalizedW ùîΩq Œ≤ i)

@[simp]
theorem distFromCode_of_empty (u : n ‚Üí R) : Œî‚ÇÄ(u, (‚àÖ : Set (n ‚Üí R))) = ‚ä§

lemma getBit_zero_eq_self {n : ‚Ñï} (h_n : n < 2) : getBit 0 n = n

theorem reduction_completeness {Œµ : ‚Ñù‚â•0}
    (hRel : ‚àÄ stmtIn witIn, (stmtIn, witIn) ‚àà relIn ‚Üí
      [fun ‚ü®stmtOut, witOut‚ü© => (stmtOut, witOut) ‚àà relOut|do
        (simulateQ impl <| combineMap mapStmt mapWit ‚ü®stmtIn, witIn‚ü©).run' (‚Üê init)] ‚â• 1 - Œµ) :
    Reduction.completeness init impl relIn relOut (reduction mapStmt mapWit) Œµ

@[simp]
theorem generateProof_ofRight {sleft sright : Skeleton}
    (cache_tree : FullData Œ± (Skeleton.internal sleft sright))
    (idxRight : SkeletonLeafIndex sright) :
    generateProof cache_tree (BinaryTree.SkeletonLeafIndex.ofRight idxRight) =
      (cache_tree.leftSubtree).getRootValue ::
        (generateProof cache_tree.rightSubtree idxRight)

theorem hcons_eq_cons {Œ≤ : Fin n ‚Üí Sort u} (a : Œ±) (v : (i : Fin n) ‚Üí Œ≤ i) :
    hcons a v = cons (Œ± := vcons Œ± Œ≤) (hcons a v 0) (fun i => hcons a v i.succ)

theorem BTField.PowerBasis_cast_dest_eq (k n m : ‚Ñï) (h_k_le_n : k ‚â§ n)
  (h_k_le_m : k ‚â§ m) (h_eq : m = n) :
  letI instLeftAlgebra := binaryAlgebraTower (l:=k) (r:=m) (h_le:=h_k_le_m)
  letI instRightAlgebra := binaryAlgebraTower (l:=k) (r:=n) (h_le:=h_k_le_n)
  @PowerBasis (BTField k) (BTField m) _ _ instLeftAlgebra =
  @PowerBasis (BTField k) (BTField n) _ _ instRightAlgebra

theorem toNatInRange {k : ‚Ñï} (b : ConcreteBTField k) :
  BitVec.toNat b ‚â§ 2 ^ (2 ^ k) * 1

theorem cast_injective : Function.Injective (ChallengeIdx.cast hn hSpec)

@[simp]
lemma ofPolynomialAlgHom_toPolynomialAlgHom_C {r : R} :
    ofPolynomialAlgHom (toPolynomialAlgHom (C r : P)) = (Polynomial.C r : R[X])

@[simp]
theorem cast_val {m n : ‚Ñï} (h : m = n) (a : Fin m) : (Fin.cast h a).val = a.val

private lemma almost_johnson [Zero F]
  (h_n : 0 < n)
  (h_B : 2 ‚â§ B.card)
  (h_card : 2 ‚â§ (Fintype.card F))
  :
  n * (choose_2 (k B) + (Fintype.card F - 1)
    * choose_2 ((B.card - k B) / (Fintype.card F - 1)))
  ‚â§
  choose_2 B.card * (n - d B)

@[simp]
theorem induction_one' {motive : Fin 2 ‚Üí Sort*} {zero : motive 0}
    {succ : ‚àÄ i : Fin 1, motive i.castSucc ‚Üí motive i.succ} :
      induction (motive := motive) zero succ (1 : Fin 2) = succ 0 zero

private lemma johnson_unrefined [Zero F]
  (h_n : 0 < n)
  (h_B : 2 ‚â§ B.card)
  (h_card : 2 ‚â§ (Fintype.card F))
  :
  (1 - e B 0 / n) ^ 2 * B.card + B.card * (e B 0) ^ 2 / ((Fintype.card F - 1) * n^2) - 1
  ‚â§
  (B.card - 1) * (1 - d B/n)

theorem linearIndependent_fin2' {f : Fin 2 ‚Üí V} :
    LinearIndependent K f ‚Üî f 0 ‚â† 0 ‚àß ‚àÄ a : K, a ‚Ä¢ f 0 ‚â† f 1

lemma zsmul_neg' {k : ‚Ñï} (n : ‚Ñï) (a : ConcreteBTField k) :
  (if ((Int.negSucc n) : ‚Ñ§) % (2 : ‚Ñ§) = (0 : ‚Ñ§) then zero else a) =
    neg (if (‚Üën.succ : ‚Ñ§) % (2 : ‚Ñ§) = (0 : ‚Ñ§) then zero else a)

@[simp] lemma toMvPolynomialAlgHom_X (s : œÉ) :
    toMvPolynomialAlgHom (X s : P) = (MvPolynomial.X s : MvPolynomial œÉ R)

@[simp]
lemma seqCompose_zero
    (Stmt : Fin 1 ‚Üí Type)
    {Œπ‚Çõ : Fin 1 ‚Üí Type} (OStmt : (i : Fin 1) ‚Üí Œπ‚Çõ i ‚Üí Type)
    [O‚Çõ : ‚àÄ i, ‚àÄ j, OracleInterface (OStmt i j)]
    {n : Fin 0 ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    [O‚Çò : ‚àÄ i, ‚àÄ j, OracleInterface ((pSpec i).Message j)]
    (V : (i : Fin 0) ‚Üí OracleVerifier oSpec
      (Stmt i.castSucc) (OStmt i.castSucc) (Stmt i.succ) (OStmt i.succ) (pSpec i)) :
    seqCompose Stmt OStmt V = OracleVerifier.id

@[simp]
theorem insertNth_apply_succAbove : insertNth p y s (p.succAbove i) = s i

lemma getBit_of_highBits {n: ‚Ñï} (numLowBits : ‚Ñï) : ‚àÄ k, getBit k (getHighBits numLowBits n) =
    if k < numLowBits then 0 else getBit (k) (n)

theorem knowledgeSoundness_implies_soundness (relIn : Set (StmtIn √ó WitIn))
    (relOut : Set (StmtOut √ó WitOut))
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    (knowledgeError : ‚Ñù‚â•0) (hLt : knowledgeError < 1) :
      knowledgeSoundness init impl relIn relOut verifier knowledgeError ‚Üí
        soundness init impl relIn.language relOut.language verifier knowledgeError

theorem eq_of_equiv [LawfulBEq R] {p q : UniPoly R} : equiv p q ‚Üí p.trim = q.trim

lemma one_bitvec_shiftRight {d : ‚Ñï} (h_d : d > 0) : 1 >>> d = 0

lemma join_split_eq_join {k : ‚Ñï} (h_pos : k > 0) (x : ConcreteBTField k) :
  „Ää (split h_pos x).fst, (split h_pos x).snd „Äã = x

@[simp]
lemma liftF'_liftF_eq : liftF' (liftF f') = f'

lemma add_comm {k : ‚Ñï} (a b : ConcreteBTField k) : a + b = b + a

theorem dext_iff {Œ± : Fin n ‚Üí Sort u} {v w : (i : Fin n) ‚Üí Œ± i} :
    v = w ‚Üî ‚àÄ i, v i = w i

theorem singleEqPolynomial_symm (r : R) (s : R) :
    (singleEqPolynomial r (C s) : MvPolynomial œÉ R) = singleEqPolynomial s (C r)

theorem canonical_nonempty_iff [LawfulBEq R] {p : UniPoly R} (hp : p.size > 0) :
  p.trim = p ‚Üî p.last_nonzero = some ‚ü® p.size - 1, Nat.pred_lt_self hp ‚ü©

omit [Finite F] in
private lemma op_der_eq : Monoid.toMulAction FÀ£ = Units.mulAction'

lemma forwardRange_succ_right_ne_empty (n : ‚Ñï) (r : Fin (n - 1)) (l : Fin (r.val + 1)) :
  forwardRange n ‚ü®r + 1, by omega‚ü© ‚ü®l, by simp only; omega‚ü© ‚â† []

lemma concrete_mul_one0 (a : ConcreteBTField 0) :
  concrete_mul a (one (k:=0)) = a

lemma getBit_of_lowBits {n: ‚Ñï} (numLowBits : ‚Ñï) : ‚àÄ k, getBit k (getLowBits numLowBits n) =
    if k < numLowBits then getBit k n else 0

theorem append_soundness (V‚ÇÅ : OracleVerifier oSpec Stmt‚ÇÅ OStmt‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : OracleVerifier oSpec Stmt‚ÇÇ OStmt‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ pSpec‚ÇÇ)
    {soundnessError‚ÇÅ soundnessError‚ÇÇ : ‚Ñù‚â•0}
    (h‚ÇÅ : V‚ÇÅ.soundness init impl lang‚ÇÅ lang‚ÇÇ soundnessError‚ÇÅ)
    (h‚ÇÇ : V‚ÇÇ.soundness init impl lang‚ÇÇ lang‚ÇÉ soundnessError‚ÇÇ) :
      (V‚ÇÅ.append V‚ÇÇ).soundness init impl lang‚ÇÅ lang‚ÇÉ (soundnessError‚ÇÅ + soundnessError‚ÇÇ)

lemma mca_rsc
  [DecidableEq Œπ]
  (Œ± : F) (œÜ : Œπ ‚Ü™ F) (m : ‚Ñï) [Smooth œÜ]
  (par‚Ñì_type : Type) [Fintype par‚Ñì_type] (exp : par‚Ñì_type ‚Ü™ ‚Ñï) :
  let Gen := RSGenerator.genRSC par‚Ñì_type œÜ m exp
  let : Fintype Gen.par‚Ñì := Gen.h‚Ñì
  hasMutualCorrAgreement
    -- Generator
    Gen
    -- BStar
    ((1 + Gen.rate) / 2)
    -- errStar
    (fun Œ¥ => ENNReal.ofReal
        ((Fintype.card par‚Ñì_type - 1) * (2^m / (Gen.rate * (Fintype.card F)))))

theorem zero_add (hp : p.canonical) : 0 + p = p

omit hF‚ÇÇ in
theorem normalizedW_is_additive (i : Fin r) :
  IsLinearMap ùîΩq (f := fun x ‚Ü¶ (normalizedW ùîΩq Œ≤ i).eval x)

@[simp]
theorem fappend_zero {Œ≤ : Fin m ‚Üí A} {Œ± : Fin 0 ‚Üí A}
    (u : (i : Fin m) ‚Üí F (Œ≤ i)) :
    fappend u (!h‚¶ÉF‚¶Ñ‚ü®Œ±‚ü©[] : (i : Fin 0) ‚Üí F (Œ± i)) = u

@[simp]
lemma mul_by_empty :
    mul_by_2 ‚àÖ = ‚àÖ

theorem ScalarField_is_prime : Nat.Prime scalarFieldSize

@[simp, grind] lemma fin_chunkSize_lt_N (arrSize : Nat) (i : Fin (min arrSize SpongeSize.R)) :
    i < SpongeSize.N

@[simp]
theorem hflatten_two_eq_append {n : Fin 2 ‚Üí ‚Ñï} {Œ± : (i : Fin 2) ‚Üí (j : Fin (n i)) ‚Üí Sort*}
    {v : (i : Fin 2) ‚Üí (j : Fin (n i)) ‚Üí Œ± i j} : hflatten v = happend (v 0) (v 1)

@[simp]
lemma solutionToE_zero_eq_C {v : Fin (2 * 0 + k) ‚Üí F} :
  solutionToE 0 k v = C (1 : F)

theorem drop_append_right {n' : ‚Ñï} {Œ± : Sort*} (m : ‚Ñï) (h : m ‚â§ n') (u : (i : Fin n) ‚Üí Œ±)
    (v : (i : Fin n') ‚Üí Œ±) :
      drop (n + m) (Nat.add_le_add_left h n) (append u v) =
        fun i => (drop m h v (i.cast (by omega)))

theorem eq_of_lt_dist {C : Set (n ‚Üí R)} {u v : n ‚Üí R} (hu : u ‚àà C) (hv : v ‚àà C)
    (huv : Œî‚ÇÄ(u, v) < ‚ÄñC‚Äñ‚ÇÄ) : u = v

@[simp]
lemma challengeOracleInterface_append_domain_inl (j : pSpec‚ÇÅ.ChallengeIdx) :
    [(pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).Challenge]‚Çí.domain (.inl j) = Unit

@[simp]
lemma natDegree_polynomialOfCoeffs_deg_lt_deg
  [NeZero deg] {coeffs : Fin deg ‚Üí F} :
  (polynomialOfCoeffs coeffs).natDegree < deg

theorem seqCompose_completeness (hInit : init.neverFails)
    (rel : (i : Fin (m + 1)) ‚Üí Set ((Stmt i √ó ‚àÄ j, OStmt i j) √ó Wit i))
    (R : ‚àÄ i, OracleReduction oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Wit i.castSucc)
      (Stmt i.succ) (OStmt i.succ) (Wit i.succ) (pSpec i))
    (completenessError : Fin m ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (R i).completeness init impl (rel i.castSucc) (rel i.succ) (completenessError i)) :
      (OracleReduction.seqCompose Stmt OStmt Wit R).completeness
        init impl (rel 0) (rel (Fin.last m)) (‚àë i, completenessError i)

theorem hconcat_eq_snoc {Œ± : Fin n ‚Üí Sort u} {Œ≤ : Sort u} (v : (i : Fin n) ‚Üí Œ± i) (b : Œ≤) :
    hconcat v b = snoc (Œ± := vconcat Œ± Œ≤)
      (fun i => cast (vconcat_castSucc _ _ i).symm (v i))
      (cast (vconcat_last _ _).symm b)

theorem eq_zero_or_eq_one {a : ConcreteBTField 0} : a = zero ‚à® a = one

private lemma johnson_unrefined_by_M' [Zero F]
  (h_n : 0 < n)
  (h_B : 2 ‚â§ B.card)
  (h_card : 2 ‚â§ (Fintype.card F))
  :
  B.card * (Fintype.card F / (Fintype.card F - 1)) *
           ((1 - e B 0 / n) ^ 2  + e B 0 ^ 2 / ((Fintype.card F - 1) * n^2) - 1 + d B/n)
  ‚â§
  (Fintype.card F / (Fintype.card F - 1)) * d B/n

theorem GF_2_card : Fintype.card (GF(2)) = 2^(2^0)

omit hF‚ÇÇ in
lemma inductive_linear_map_W (i : Fin r) (h_i_add_1 : i + 1 < r)
    (h_prev_linear_map : IsLinearMap ùîΩq (f := fun inner_p ‚Ü¶ (W ùîΩq Œ≤ i).comp inner_p))
    : IsLinearMap ùîΩq (f := fun inner_p ‚Ü¶ (W ùîΩq Œ≤ (i + 1)).comp inner_p)

@[simp]
theorem cast_perfectCompleteness (hComplete : R.perfectCompleteness init impl relIn relOut) :
    (R.cast hn hSpec).perfectCompleteness init impl relIn relOut

private lemma sum_hamming_weight_sum [Zero F]
  :
  ‚àë x ‚àà B, (‚Äñx‚Äñ‚ÇÄ : ‚Ñö) = n * B.card - ‚àë i, K B i 0

theorem eval_comp_eval_C_finSuccEquiv (p : R[X (Fin (n + 1))]) (y : Fin n ‚Üí R) (x : R) :
    eval y (Polynomial.eval (C x) (finSuccEquiv R n p)) = eval (Fin.cons x y) p

@[simp] theorem toNat_mul (a b : AssocNat) : toNat (mul a b) = toNat a * toNat b

theorem towerEquiv_commutes_left (i j : ‚Ñï) (h : i ‚â§ j) : ‚àÄ r : ConcreteBTField i,
  (AlgebraTower.algebraMap i j h) ((towerEquiv i).ringEquiv r) =
  (towerEquiv j).ringEquiv ((AlgebraTower.algebraMap i j h) r)

@[simp]
theorem fconcat‚ÇÇ_castSucc {Œ±‚ÇÅ : Fin n ‚Üí A} {Œ±‚ÇÇ : Fin n ‚Üí B} {Œ≤‚ÇÅ : A} {Œ≤‚ÇÇ : B}
    (v : (i : Fin n) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i)) (a : F‚ÇÇ Œ≤‚ÇÅ Œ≤‚ÇÇ) (i : Fin n) :
    fconcat‚ÇÇ (F := F‚ÇÇ) v a (castSucc i) =
      cast (by simp [vconcat_castSucc]) (v i)

theorem join_add_join {k : ‚Ñï} (h_pos : k > 0) (hi‚ÇÄ lo‚ÇÄ hi‚ÇÅ lo‚ÇÅ : ConcreteBTField (k - 1)) :
  „Ää hi‚ÇÄ, lo‚ÇÄ „Äã + „Ää hi‚ÇÅ, lo‚ÇÅ „Äã = „Ää hi‚ÇÄ + hi‚ÇÅ, lo‚ÇÄ + lo‚ÇÅ „Äã

theorem insertNth_ne_zero_iff : insertNth p y s ‚â† 0 ‚Üî y ‚â† 0 ‚à® s ‚â† 0

@[simp]
theorem cast_toVerifier (V : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec‚ÇÅ) :
    (OracleVerifier.cast hn hSpec hO‚Çò V).toVerifier = Verifier.cast hn hSpec V.toVerifier

theorem seqCompose_rbrSoundness
    (lang : (i : Fin (m + 1)) ‚Üí Set (Stmt i))
    (V : (i : Fin m) ‚Üí Verifier oSpec (Stmt i.castSucc) (Stmt i.succ) (pSpec i))
    (rbrSoundnessError : ‚àÄ i, (pSpec i).ChallengeIdx ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (V i).rbrSoundness init impl (lang i.castSucc) (lang i.succ) (rbrSoundnessError i)) :
      (Verifier.seqCompose Stmt V).rbrSoundness init impl (lang 0) (lang (Fin.last m))
        (fun combinedIdx =>
          letI ij := seqComposeChallengeIdxToSigma combinedIdx
          rbrSoundnessError ij.1 ij.2)

omit h_Œ≤‚ÇÄ_eq_1 in
theorem sDomainFin_bijective (i : Fin r) (h_i : i < ‚Ñì + R_rate)
: Function.Bijective
  (sDomainFinEquiv ùîΩq Œ≤ h_‚Ñì_add_R_rate i h_i)

lemma forwardRange_0_eq_finRange (n : ‚Ñï) [NeZero n] : forwardRange n ‚ü®n - 1, by
    have h_ne

@[simp, grind =]
theorem monomialXY_add {n m : ‚Ñï} {a b : F} :
  monomialXY n m (a + b) = monomialXY n m a + monomialXY n m b

@[simp]
lemma polynomialOfCoeffs_eq_zero :
  polynomialOfCoeffs coeffs = 0 ‚Üî ‚àÄ (x : ‚Ñï) (h : x < deg), coeffs ‚ü®x, h‚ü© = 0

theorem eval_zeroOne_eq_MLE_toEvalsZeroOne (p : MvPolynomial œÉ R) (x : œÉ ‚Üí Fin 2) :
    eval (x : œÉ ‚Üí R) p = eval (x : œÉ ‚Üí R) (MLE p.toEvalsZeroOne)

theorem frobenius_identity_in_ground_field
  [Fact (Nat.Prime (ringChar Fq))] (f g : Fq[X]) :
    (f + g)^(Fintype.card Fq) = f^(Fintype.card Fq) + g^(Fintype.card Fq)

@[simp]
theorem runWithOracle_pure (f : spec.FunctionType) (a : Œ±) :
    runWithOracle f (pure a) = some a

lemma divide_by_2_def {s : Finset ‚Ñï} :
    divide_by_2 s = (erase_odd s).image (fun n => n / 2)

@[simp]
lemma bIdx_mul_œë_add_i_fin_‚Ñì_pred_lt_‚Ñì (bIdx : Fin (‚Ñì / œë - 1)) (i : Fin (œë - 1))
    : ‚ÜëbIdx * œë + ‚Üëi < ‚Ñì

theorem rsum_eq_t1_square_aux
  {curBTField : Type*} [Field curBTField] -- curBTField ‚âÉ ùîΩ_{2^{2^k}}
  (u : curBTField) -- here u is already lifted to curBTField
  (k : ‚Ñï)
  (x_pow_card : ‚àÄ (x : curBTField), x ^ (2 ^ (2 ^ (k))) = x)
  (u_ne_zero : u ‚â† 0)
  (trace_map_prop : TraceMapProperty curBTField u k):
   ‚àë j ‚àà Finset.Icc 1 (2 ^ (k)), u ^ (2 ^ 2 ^ (k) - 2 ^ j) = u

lemma dappend_right_of_not_lt {motive : Fin (m + n) ‚Üí Sort u}
    (u : (i : Fin m) ‚Üí motive (castAdd n i)) (v : (i : Fin n) ‚Üí motive (natAdd m i))
    (i : Fin (m + n)) (h : ¬¨ i.val < m) :
      dappend (motive := motive) u v i = dcast (by ext; simp; omega) (v ‚ü®i - m, by omega‚ü©)

@[simp]
theorem add_accepts_iff : (add a b c).accepts x ‚Üî x c = x a + x b

@[simp]
theorem fflatten‚ÇÇ_one {A : Sort u} {B : Sort v} {F : A ‚Üí B ‚Üí Sort w} {n : Fin 1 ‚Üí ‚Ñï}
    {Œ± : (i : Fin 1) ‚Üí (j : Fin (n i)) ‚Üí A}
    {Œ≤ : (i : Fin 1) ‚Üí (j : Fin (n i)) ‚Üí B}
    {v : (i : Fin 1) ‚Üí (j : Fin (n i)) ‚Üí F (Œ± i j) (Œ≤ i j)} :
    fflatten‚ÇÇ v = v 0

@[simp]
theorem cast_rbrKnowledgeSoundness (Œµ : pSpec‚ÇÅ.ChallengeIdx ‚Üí ‚Ñù‚â•0)
    (hRbrKs : V.rbrKnowledgeSoundness init impl relIn relOut Œµ) :
    (V.cast hn hSpec hO‚Çò).rbrKnowledgeSoundness init impl relIn relOut
      (Œµ ‚àò (ChallengeIdx.cast hn.symm (cast_symm hSpec)))

theorem support_finSuccEquivNth_nonempty {f : MvPolynomial (Fin (n + 1)) R} (h : f ‚â† 0) :
    (finSuccEquivNth R p f).support.Nonempty

@[simp]
lemma degree_polynomialOfCoeffs_deg_lt_deg :
  (polynomialOfCoeffs coeffs).degree < deg

@[simp]
theorem dcast‚ÇÇ_eq' (h : a = a) (h' : dcast h b = b) : dcast‚ÇÇ h h' c = c

@[simp]
lemma eval‚ÇÇ_comp_C {S : Type w} [CommSemiring S] (f : R ‚Üí+* S) (x : S) :
    (eval‚ÇÇ f x).comp (C : R ‚Üí+* P) = f

@[simp]
theorem OracleReduction.id_run (stmt : StmtIn) (oStmt : ‚àÄ i, OStmtIn i) (wit : WitIn) :
    (OracleReduction.id : OracleReduction oSpec StmtIn OStmtIn WitIn _ _ _ _).run stmt oStmt wit =
      pure ‚ü®‚ü®default, ‚ü®stmt, oStmt‚ü©, wit‚ü©, ‚ü®stmt, oStmt‚ü©‚ü©

lemma rootMultiplicity_comp_X_sub_C (p : L[X]) (a x : L) :
    rootMultiplicity x (p.comp (X - C a)) = rootMultiplicity (x - a) p

@[simp]
theorem OracleReduction.id_runWithLog (stmt : StmtIn) (oStmt : ‚àÄ i, OStmtIn i) (wit : WitIn) :
    (OracleReduction.id : OracleReduction oSpec StmtIn OStmtIn WitIn _ _ _ _).runWithLog
      stmt oStmt wit = pure ‚ü®‚ü®default, ‚ü®stmt, oStmt‚ü©, wit‚ü©, ‚ü®stmt, oStmt‚ü©, [], []‚ü©

@[simp]
theorem minPoly_of_powerBasisSucc_generator (k : ‚Ñï) :
  (minpoly (ConcreteBTField k) (powerBasisSucc k).gen) = X^2 + (Z k) ‚Ä¢ X + 1

lemma getBit_of_binaryFinMapToNat {n : ‚Ñï} (m : Fin n ‚Üí ‚Ñï) (h_binary: ‚àÄ j: Fin n, m j ‚â§ 1) :
    ‚àÄ k: ‚Ñï, Nat.getBit k (binaryFinMapToNat m h_binary).val
      = if h_k: k < n then m ‚ü®k, by omega‚ü© else 0

@[simp]
theorem cast_idx_symm {i : MessageIdx pSpec‚ÇÇ} :
    pSpec‚ÇÅ.Message (i.cast hn.symm (cast_symm hSpec)) = pSpec‚ÇÇ.Message i

lemma bIdx_succ_mul_œë_le_‚Ñì_succ (bIdx : Fin (‚Ñì / œë - 1)) : (‚ÜëbIdx + 1) * œë ‚â§ ‚Ñì + 1

lemma join_zero_zero {k : ‚Ñï} (h_k : k > 0) :
  „Ää zero (k:=k - 1), zero (k:=k - 1) „Äã = zero (k:=k)

theorem matchSize_comm (l‚ÇÅ : List Œ±) (l‚ÇÇ : List Œ±) (unit : Œ±) :
    matchSize l‚ÇÅ l‚ÇÇ unit = (matchSize l‚ÇÇ l‚ÇÅ unit).swap

theorem mem_restrictDegree_iff_degreeOf_le (p : MvPolynomial œÉ R) (n : ‚Ñï) :
    p ‚àà restrictDegree œÉ R n ‚Üî ‚àÄ i, p.degreeOf i ‚â§ n

@[simp]
lemma halfNumFullRounds_mul_2_eq_numFullRounds :
    params.halfNumFullRounds * 2 = params.numFullRounds

@[simp]
theorem acceptRejectOracleRel_language :
    acceptRejectOracleRel.language = { (true, isEmptyElim) }

lemma concrete_one_mul
  (prevBTFieldProps : ConcreteBTFieldProps (k := k - 1))
  (a : ConcreteBTField k) : concrete_mul (one (k:=k)) a = a

theorem append_rbrSoundness {lang‚ÇÅ : Set Stmt‚ÇÅ} {lang‚ÇÇ : Set Stmt‚ÇÇ} {lang‚ÇÉ : Set Stmt‚ÇÉ}
    (V‚ÇÅ : Verifier oSpec Stmt‚ÇÅ Stmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : Verifier oSpec Stmt‚ÇÇ Stmt‚ÇÉ pSpec‚ÇÇ)
    {rbrSoundnessError‚ÇÅ : pSpec‚ÇÅ.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    {rbrSoundnessError‚ÇÇ : pSpec‚ÇÇ.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    (h‚ÇÅ : V‚ÇÅ.rbrSoundness init impl lang‚ÇÅ lang‚ÇÇ rbrSoundnessError‚ÇÅ)
    (h‚ÇÇ : V‚ÇÇ.rbrSoundness init impl lang‚ÇÇ lang‚ÇÉ rbrSoundnessError‚ÇÇ) :
      (V‚ÇÅ.append V‚ÇÇ).rbrSoundness init impl lang‚ÇÅ lang‚ÇÉ
        (Sum.elim rbrSoundnessError‚ÇÅ rbrSoundnessError‚ÇÇ ‚àò ChallengeIdx.sumEquiv.symm)

theorem seqCompose_soundness
    (lang : (i : Fin (m + 1)) ‚Üí Set (Stmt i √ó ‚àÄ j, OStmt i j))
    (V : (i : Fin m) ‚Üí
      OracleVerifier oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Stmt i.succ) (OStmt i.succ)
        (pSpec i))
    (soundnessError : Fin m ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (V i).soundness init impl (lang i.castSucc) (lang i.succ) (soundnessError i)) :
      (OracleVerifier.seqCompose Stmt OStmt V).soundness init impl (lang 0) (lang (Fin.last m))
        (‚àë i, soundnessError i)

theorem vcons_vappend_comm (a : Œ±) (u : Fin m ‚Üí Œ±) (v : Fin n ‚Üí Œ±) :
    vcons a (vappend u v) = (vappend (vcons a u) v) ‚àò Fin.cast (Nat.succ_add m n).symm

theorem dcast‚ÇÉ_dcast‚ÇÇ : dcast‚ÇÉ rfl rfl rfl d = dcast‚ÇÇ dcast_eq.symm dcast‚ÇÇ_dcast.symm d

omit [Finite F] in
lemma sqr_mem_D_succ_i_of_mem_D_i : ‚àÄ {x : FÀ£} {i : ‚Ñï},
  x ‚àà evalDomain D i ‚Üí x ^ 2 ‚àà evalDomain D (i + 1)

protected lemma elocPoly_congr {œâs' f' : ‚Ñï ‚Üí F}
  (h‚ÇÅ : ‚àÄ {m}, m < n ‚Üí œâs m = œâs' m) (h‚ÇÇ : ‚àÄ {m}, m < n ‚Üí f m = f' m) :
  ElocPoly n œâs f = ElocPoly n œâs' f'

lemma towerAlgebraMap_id (k : ‚Ñï) : towerAlgebraMap (h_le:=by omega) = RingHom.id (BTField k)

lemma algebraMap_eq_zero_x {i j : ‚Ñï} (h_le : i < j) (x : BTField i) :
    letI instAlgebra := binaryAlgebraTower (l:=i) (r:=j) (h_le:=by omega)
    letI instAlgebraPred := binaryAlgebraTower (l:=i) (r:=j-1) (h_le:=by omega)
    algebraMap (BTField i) (BTField j) x
      = ‚ãò 0, algebraMap (BTField i) (BTField (j-1)) x ‚ãô

@[simp]
lemma seqCompose_zero
    (Stmt : Fin 1 ‚Üí Type)
    {Œπ‚Çõ : Fin 1 ‚Üí Type} (OStmt : (i : Fin 1) ‚Üí Œπ‚Çõ i ‚Üí Type)
    [O‚Çõ : ‚àÄ i, ‚àÄ j, OracleInterface (OStmt i j)]
    (Wit : Fin 1 ‚Üí Type)
    {n : Fin 0 ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    [O‚Çò : ‚àÄ i, ‚àÄ j, OracleInterface ((pSpec i).Message j)]
    (R : (i : Fin 0) ‚Üí
      OracleReduction oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Wit i.castSucc)
        (Stmt i.succ) (OStmt i.succ) (Wit i.succ) (pSpec i)) :
    seqCompose Stmt OStmt Wit R =
      @OracleReduction.id Œπ oSpec (Stmt 0) (Œπ‚Çõ 0) (OStmt 0) (Wit 0) (O‚Çõ 0)

lemma qMap_total_fiber_repr_coeff (i : Fin ‚Ñì) (steps : ‚Ñï) (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
    (y : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i.val + steps, by omega‚ü©))
    (k : Fin (2 ^ steps)) :
    let x := qMap_total_fiber ùîΩq Œ≤ (i := ‚ü®i, by omega‚ü©)
      (steps := steps)
      (h_i_add_steps := by simp only; exact fin_‚Ñì_steps_lt_‚Ñì_add_R i steps h_i_add_steps) (y := y) k
    let basis_y := sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i.val + steps, by omega‚ü©)
      (h_i := by simp only; exact fin_‚Ñì_steps_lt_‚Ñì_add_R i steps h_i_add_steps)
    let y_coeffs := basis_y.repr y
    ‚àÄ j, -- j refers to bit index of the fiber point x
      ((sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i, by omega‚ü©) (by simp only; omega)).repr x) j
      = fiber_coeff (i := i) (steps := steps) (j := j) (elementIdx := k)
        (y_coeffs := y_coeffs)

Nat.lt_of_le_of_lt in Init.Prelude

Fin.coe_castSucc in Init.Data.Fin.Lemmas

lemma aeval_apply {A : Type w} [CommSemiring A] [Algebra R A] (s : A) :
    aeval (P := P) s = eval‚ÇÇAlgHom (Algebra.ofId R A) s

theorem dconcat_inj {motive : Fin (n + 1) ‚Üí Sort u} (v w : (i : Fin n) ‚Üí motive (castSucc i))
    (a b : motive (last n)) :
    (v :+·µà‚ü®motive‚ü© a) = (w :+·µà‚ü®motive‚ü© b) ‚Üî v = w ‚àß a = b

@[simp]
lemma erase_odd_empty :
    erase_odd ‚àÖ = ‚àÖ

lemma neverFails_map_iff' (oa : OracleComp spec Œ±) (f : Œ± ‚Üí Œ≤) :
    neverFails (f <$> oa) ‚Üî neverFails oa

lemma weight_Œæ_bound (x‚ÇÄ : F) {D : ‚Ñï} (hD : D ‚â• Bivariate.totalDegree H) :
  weight_Œõ_over_ùí™ (Œæ x‚ÇÄ R H) D ‚â§
    WithBot.some ((Bivariate.natDegreeY R - 1) * (D - Bivariate.natDegreeY H + 1))

lemma oracle_block_k_next_le (i : Fin (‚Ñì + 1)) (j : Fin (toOutCodewordsCount ‚Ñì œë i))
    (hj : j.val + 1 < toOutCodewordsCount ‚Ñì œë i) : j.val * œë + œë ‚â§ i

omit [NeZero ‚Ñì] in
lemma fin_‚Ñì_steps_lt_‚Ñì_add_R (i : Fin ‚Ñì) (steps : ‚Ñï) (h : i.val + steps ‚â§ ‚Ñì)
    : i.val + steps < ‚Ñì + ùì°

theorem foldl_eq_toList_foldl {Œ± Œ≤} {n : ‚Ñï} (f : Œ≤ ‚Üí Œ± ‚Üí Œ≤) (init : Œ≤) (v : Vector Œ± n) :
  v.foldl (f:=f) (b:=init) = v.toList.foldl (f:=f) (init:=init)

lemma concrete_mul_inv_cancel
  (prevBTFieldResult : ConcreteBTFStepResult (k := k - 1))
  (a : ConcreteBTField k) (h : a ‚â† 0) :
  concrete_mul a (concrete_inv a) = one

@[simp]
lemma domain_def : (spec Œ±).domain () = (Œ± √ó Œ±)

private lemma johnson_condition_strong_implies_2_le_B_card
  (h_johnson : JohnsonConditionStrong B v)
  :
  2 ‚â§ B.card

@[simp]
lemma not_P_to_V_eq_V_to_P {x : Direction} (h : x ‚â† .V_to_P) : x = .P_to_V

lemma eqRec_fun_eqRec_sort_eq_self {Œ± : Sort*} {Œ≤ : Œ± ‚Üí Sort u} {a a' : Œ±}
    (h : a = a') (h' : Œ≤ a = Œ≤ a') (b : Œ≤ a) :
  b = h ‚ñ∏ h' ‚ñ∏ b

Nat.zero_add in Init.Data.Nat.Basic

theorem non_zero_divisors_iff (M‚ÇÄ : Type*) [Mul M‚ÇÄ] [Zero M‚ÇÄ] :
    NoZeroDivisors M‚ÇÄ ‚Üî ‚àÄ {a b : M‚ÇÄ}, a * b = 0 ‚Üí a = 0 ‚à® b = 0

lemma addSalt_Message (i : pSpec.MessageIdx) :
    (pSpec.addSalt Salt).Message i = (pSpec.Message i √ó Salt i)

@[simp]
theorem splitSum_succ {n : Fin (m + 1) ‚Üí ‚Ñï} {k : Fin (vsum n)} :
    splitSum k = Fin.dappend
      (fun k => ‚ü®0, k‚ü©)
      (fun k => ‚ü®(splitSum k).1.succ, (splitSum k).2‚ü©)
      k

theorem BaseField_is_prime : Nat.Prime baseFieldSize

theorem reduction_perfectCompleteness (hInit : init.neverFails) :
    (reduction R deg D oSpec).perfectCompleteness init impl
      (inputRelation R deg D) (outputRelation R deg)

theorem append_rbrKnowledgeSoundness (V‚ÇÅ : OracleVerifier oSpec Stmt‚ÇÅ OStmt‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : OracleVerifier oSpec Stmt‚ÇÇ OStmt‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ pSpec‚ÇÇ)
    {rbrKnowledgeError‚ÇÅ : pSpec‚ÇÅ.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    {rbrKnowledgeError‚ÇÇ : pSpec‚ÇÇ.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    (h‚ÇÅ : V‚ÇÅ.rbrKnowledgeSoundness init impl rel‚ÇÅ rel‚ÇÇ rbrKnowledgeError‚ÇÅ)
    (h‚ÇÇ : V‚ÇÇ.rbrKnowledgeSoundness init impl rel‚ÇÇ rel‚ÇÉ rbrKnowledgeError‚ÇÇ) :
      (V‚ÇÅ.append V‚ÇÇ).rbrKnowledgeSoundness init impl rel‚ÇÅ rel‚ÇÉ
        (Sum.elim rbrKnowledgeError‚ÇÅ rbrKnowledgeError‚ÇÇ ‚àò ChallengeIdx.sumEquiv.symm)

theorem hcons_left_injective {Œ± : Sort u} {Œ≤ : Fin n ‚Üí Sort u} (b : (i : Fin n) ‚Üí Œ≤ i) :
    Function.Injective (fun (a : Œ±) => hcons a b)

theorem decoder_mem_impl_dist
  {k r D e : ‚Ñï}
  (h_e : e ‚â§ n - Real.sqrt (k * n))
  {œâs : Fin n ‚Ü™ F}
  {f : Fin n ‚Üí F}
  {p : F[X]}
  (h_in : p ‚àà decoder k r D e œâs f)
  :
  Œî‚ÇÄ(f, p.eval ‚àò œâs) ‚â§ e

theorem evalNormalizedWAt_eq_normalizedW (i : Fin r) (x : L) :
  evalNormalizedWAt (Œ≤ := Œ≤) (‚Ñì := ‚Ñì) (R_rate := R_rate) (i := i) x
    = (normalizedW (ùîΩq := ùîΩq) (Œ≤ := Œ≤) (i := i)).eval x

lemma getBit_of_two_pow_sub_one {i k: ‚Ñï} : getBit k (2^i - 1) =
    if k < i then 1 else 0

lemma evenPart_even {f : Polynomial F} :
    EvenPoly (evenPart f)

lemma oddPart_def :
  oddPart f =
  C (2‚Åª¬π : F) * (f - f.comp (-X)) /‚Çò X

@[simp]
lemma seqCompose_zero (Stmt : Fin 1 ‚Üí Type)
    {n : Fin 0 ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (V : (i : Fin 0) ‚Üí Verifier oSpec (Stmt i.castSucc) (Stmt i.succ) (pSpec i)) :
    seqCompose Stmt V = Verifier.id

@[simp] lemma drop_dir : pSpec‚ü¶m:‚üß.dir = pSpec.dir‚ü¶m:‚üß

lemma rootMultiplicity_W (i : Fin r) (a : L) :
    rootMultiplicity a (W ùîΩq Œ≤ i) = if a ‚àà (U ùîΩq Œ≤ i : Set L) then 1 else 0

@[simp]
theorem vflatten_embedSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (v : (i : Fin m) ‚Üí Fin (n i) ‚Üí Œ±) (i : Fin m)
    (j : Fin (n i)) : vflatten v (embedSum i j) = v i j

lemma listBlock_subset_listHamming
  (i k : ‚Ñï) {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F} {œÜ' : (indexPowT S œÜ i) ‚Ü™ F}
  {m : ‚Ñï} [DecidableEq F] [DecidableEq Œπ] [Smooth œÜ]
  (f : (indexPowT S œÜ i) ‚Üí F) (S' : Finset (indexPowT S œÜ i))
  [h_fintype : ‚àÄ i : ‚Ñï, Fintype (indexPowT S œÜ i)] [DecidableEq (indexPowT S œÜ i)] [Smooth œÜ']
  (C : Set ((indexPowT S œÜ i) ‚Üí F)) (hcode : C = smoothCode œÜ' m)
  [h_dec : DecidableBlockDisagreement i k f S' œÜ']
  (Œ¥ : ‚Ñù‚â•0) (hŒ¥Le : Œ¥ ‚â§ 1) :
  Œõ·µ£(i, k, f, S', C, hcode, Œ¥) ‚äÜ relHammingBall C f Œ¥

lemma eq_zero_or_eq_one_of_lt_two {n : ‚Ñï} (h_lt : n < 2) : n = 0 ‚à® n = 1

theorem cast_eq_cast_iff {Œ± Œ≤ Œ≥ : Sort u} {h : Œ± = Œ≥} {h' : Œ≤ = Œ≥} {a : Œ±} {b : Œ≤} :
    cast h a = cast h' b ‚Üî a = cast (h'.trans h.symm) b

lemma solutionToQ_ne_zero {e k : ‚Ñï}
  [NeZero n]
  {œâs f : Fin n ‚Üí F}
  {v : Fin (2 * e + k) ‚Üí F}
  (h_dist : e < Œî‚ÇÄ(f, 0))
  (h_sol : IsBerlekampWelchSolution e k œâs f v)
  (h_inj : Function.Injective œâs)
  : solutionToQ e k v ‚â† 0

@[simp]
theorem Reduction.id_perfectCompleteness {rel : Set (StmtIn √ó WitIn)} (hInit : init.neverFails) :
    (Reduction.id : Reduction oSpec _ _ _ _ _).perfectCompleteness init impl rel rel

@[simp]
theorem bit_finProdFinEquiv_symm_2_pow_succ {n : ‚Ñï} (j : Fin (2 ^ (n + 1))) (i : Fin (n + 1)) :
  let e:=finProdFinEquiv (m:=2^(n)) (n:=2).symm
  Nat.getBit (i) j = if i.val > 0 then Nat.getBit (i.val-1) (e j).1 else (e j).2

private lemma evenPart_eq_evenPart' {f : Polynomial F} : evenPart f = evenPart' f

lemma one_bitvec_toNat {width : ‚Ñï} (h_width : width > 0) : (1#width).toNat = 1

@[simp]
theorem reduction_perfectCompleteness (hInit : init.neverFails) :
    (reduction oSpec Statement Witness).perfectCompleteness init impl rel rel

@[simp]
theorem cast_perfectCompleteness (hComplete : R.perfectCompleteness init impl relIn relOut) :
    (R.cast hn hSpec hO‚Çò).perfectCompleteness init impl relIn relOut

lemma matching_set_is_a_sub_of_coeffs_of_close_proximity
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  : matching_set k œâs Œ¥ u‚ÇÄ u‚ÇÅ h_gs ‚äÜ coeffs_of_close_proximity k œâs Œ¥ u‚ÇÄ u‚ÇÅ

Fin.isLt in Init.Prelude

theorem monomialBasis_getElem {w : Vector R n} (i : Fin (2 ^ n)) :
    (monomialBasis w)[i] = ‚àè j : Fin n, if (BitVec.ofFin i).getLsb j then w[j] else 1

omit [SelectableType R] in
@[simp]
lemma reduction_verifier_eq_verifier :
    (reduction R deg D n oSpec).verifier = verifier R deg D n oSpec

theorem one_mul (n : ChurchNat Œ±) : mul one n = n

lemma concrete_zero_mul
  (prevBTFieldProps : ConcreteBTFieldProps (k := k - 1))
  (a : ConcreteBTField k) : concrete_mul (zero (k:=k)) a = zero (k:=k)

lemma sum_insertNth [AddCommMonoid M] {n : ‚Ñï} (œÉ : Fin n ‚Üí‚ÇÄ M) (i : M) (p : Fin (n + 1)) :
    (insertNth p i œÉ).sum (fun _ e ‚Ü¶ e) = i + œÉ.sum (fun _ e ‚Ü¶ e)

theorem append_left_injective (b : Fin n ‚Üí Œ±) : Function.Injective (@Fin.append m n Œ± ¬∑ b)

@[simp]
theorem generateProof_leaf (a : Œ±) (idx) :
    generateProof (FullData.leaf a) idx = []

@[csimp]
theorem dcons_eq_cons : @dcons = @cons

theorem Nat.shiftRight_eq_sub_mod_then_div_two_pow {n lo_len : ‚Ñï} :
  n >>> lo_len = (n - n % 2 ^ lo_len) / 2 ^ lo_len

lemma eq_iff_eq_all_getBits {n m : ‚Ñï} : n = m ‚Üî ‚àÄ k, getBit k n = getBit k m

private lemma cast_eq_cast_same_type {Œ± Œ≤ : Sort u} (h1 h2 : Œ± = Œ≤) {x y : Œ±}
    (h : cast h1 x = cast h2 y) : x = y

private lemma sum_choose_K' [Zero F]
  (h_card : 2 ‚â§ (Fintype.card F))
  :
  (Fintype.card (Œ± := F) - 1) * choose_2 ((B.card - K B i 0) / (Fintype.card (Œ± := F) - 1)) ‚â§
  ‚àë (Œ± : F) with Œ± ‚â† 0, choose_2 (K B i Œ±)

@[simp]
theorem FullData.internal_getRootValue {s_left s_right : Skeleton} {Œ± : Type}
    (value : Œ±) (left : FullData Œ± s_left) (right : FullData Œ± s_right) :
    (FullData.internal value left right).getRootValue =
      value

@[simp]
theorem vcons_zero (a : Œ±) (v : Fin n ‚Üí Œ±) : (a ::·µõ v) 0 = a

theorem cast_eq_dcast‚ÇÇ {hn} {hSpec : pSpec‚ÇÅ.cast hn = pSpec‚ÇÇ} {i : ChallengeIdx pSpec‚ÇÅ}:
    i.cast hn hSpec = dcast‚ÇÇ hn hSpec i

theorem ConcreteBTFieldAlgebra_apply_assoc (l mid r : ‚Ñï)
    (h_l_le_mid : l ‚â§ mid) (h_mid_le_r : mid ‚â§ r) :
    ‚àÄ x : ConcreteBTField l,
    (@ConcreteBTFieldAlgebra (l:=l) (r:=r) (h_le:=by
      exact Nat.le_trans h_l_le_mid h_mid_le_r)).algebraMap x =
    (@ConcreteBTFieldAlgebra (l:=mid) (r:=r) (h_le:=h_mid_le_r)).algebraMap
      ((@ConcreteBTFieldAlgebra (l:=l) (r:=mid) (h_le:=h_l_le_mid)).algebraMap x)

@[simp, grind =]
theorem monomialXY_eq_zero_iff {n m : ‚Ñï} {a : F} : monomialXY n m a = 0 ‚Üî a = 0

theorem BitVec.extractLsb_concat_lo {hi_size lo_size : ‚Ñï} (hi : BitVec hi_size)
  (lo : BitVec lo_size) (h_lo : lo_size > 0) : BitVec.extractLsb (hi:=lo_size - 1) (lo:=0)
  (BitVec.append (msbs:=hi) (lsbs:=lo)) = dcast (by
    rw [‚ÜêNat.sub_add_comm (h:=by omega), Nat.sub_add_cancel (h:=by omega), Nat.sub_zero]
  ) lo

theorem intermediateNormVpoly_comp_qmap_helper (i : Fin (‚Ñì))
    (k : Fin (‚Ñì - (‚Üëi + 1))) :
    (intermediateNormVpoly ùîΩq Œ≤ h_‚Ñì_add_R_rate
      ‚ü®‚Üëi + 1, by omega‚ü© (k:=‚ü®k, by simp only; omega‚ü©)).comp (qMap ùîΩq Œ≤ ‚ü®‚Üëi, by omega‚ü©) =
    intermediateNormVpoly ùîΩq Œ≤ h_‚Ñì_add_R_rate
      ‚ü®‚Üëi, by omega‚ü© ‚ü®k + 1, by simp only; omega‚ü©

@[simp]
theorem Basis_cast_index_apply {Œ± Œ≤ i j : ‚Ñï} {k : Fin j}
    (h_le : Œ± ‚â§ Œ≤) (h_eq : i = j)
    {b : @Basis (Fin (i)) (ConcreteBTField Œ±) (ConcreteBTField Œ≤) _ _
      (@ConcreteBTFieldAlgebra (l := Œ±) (r := Œ≤) (h_le := h_le)).toModule} :
  let castBasis : @Basis (Fin j) (ConcreteBTField Œ±) (ConcreteBTField Œ≤) _ _
    (@ConcreteBTFieldAlgebra (l:=Œ±) (r:=Œ≤) (h_le:=h_le)).toModule :=
    cast (by exact Basis_cast_index_eq i j Œ± Œ≤ h_le h_eq) b
  (castBasis k) = b (Fin.cast (h_eq.symm) k)

omit [NeZero œë] hdiv in
lemma toOutCodewordsCountOf0 : toOutCodewordsCount ‚Ñì œë 0 = 1

@[simp]
theorem dcast‚ÇÇ_eq : dcast‚ÇÇ (Eq.refl a) dcast_eq c = c

lemma join_via_add_smul_one_zero_eq_Z {k : ‚Ñï} (h_pos : k > 0) :
  ‚ãò 1, 0 ‚ãô = Z k

lemma getBit_of_middleBits {n offset len k : ‚Ñï} :
  getBit k (getMiddleBits offset len n) =
    if k < len then getBit (k + offset) n else 0

@[simp]
theorem append_right_cancel_iff {pSpec : ProtocolSpec m} {p1 p2 : ProtocolSpec n} :
    pSpec ++‚Çö p1 = pSpec ++‚Çö p2 ‚Üî p1 = p2

theorem prod_poly_sub_C_eq_poly_pow_card_sub_poly_in_L
  (p : L[X]) :
  (‚àè c ‚àà (Finset.univ : Finset Fq), (p - Polynomial.C (algebraMap Fq L c))) =
    p^(Fintype.card Fq) - p

theorem vconcat_vcons_eq_vcons_vconcat (a : Œ±) (v : Fin n ‚Üí Œ±) (b : Œ±) :
    vconcat (a ::·µõ v) b = a ::·µõ (vconcat v b)

lemma eqRec_fun_eq_eqRec_sort {Œ± : Sort*} {Œ≤ : Œ± ‚Üí Sort u} {a a' : Œ±}
    (h : a = a') (h' : Œ≤ a = Œ≤ a') (b : Œ≤ a) :
  h ‚ñ∏ b = h' ‚ñ∏ b

@[simp]
theorem fappend‚ÇÇ_succ {Œ±‚ÇÅ : Fin m ‚Üí A} {Œ±‚ÇÇ : Fin m ‚Üí B}
    {Œ≤‚ÇÅ : Fin (n + 1) ‚Üí A} {Œ≤‚ÇÇ : Fin (n + 1) ‚Üí B}
    (u : (i : Fin m) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i)) (v : (i : Fin (n + 1)) ‚Üí F‚ÇÇ (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) :
    fappend‚ÇÇ (F := F‚ÇÇ) u v =
      fconcat‚ÇÇ (F := F‚ÇÇ) (fappend‚ÇÇ (F := F‚ÇÇ) u (fun i => v (castSucc i))) (v (last n))

lemma sub_descends [LawfulBEq R] (a‚ÇÅ b‚ÇÅ a‚ÇÇ b‚ÇÇ : UniPoly R) :
  equiv a‚ÇÅ a‚ÇÇ ‚Üí equiv b‚ÇÅ b‚ÇÇ ‚Üí sub_descending a‚ÇÅ b‚ÇÅ = sub_descending a‚ÇÇ b‚ÇÇ

@[simp]
theorem removeNth_update : removeNth p (update s p y) = removeNth p s

@[simp]
theorem OracleReduction.id_perfectCompleteness
    {rel : Set ((StmtIn √ó ‚àÄ i, OStmtIn i) √ó WitIn)}
    (hInit : init.neverFails) :
    (OracleReduction.id : OracleReduction oSpec _ _ _ _ _ _ _).perfectCompleteness
      init impl rel rel

lemma bIdx_succ_mul_œë_lt_‚Ñì_succ (bIdx : Fin (‚Ñì / œë - 1)) :
    (‚ÜëbIdx + 1) * œë < ‚Ñì + 1

theorem join_of_split {k : ‚Ñï} (h_pos : k > 0) (x : ConcreteBTField k)
    (hi_btf lo_btf : ConcreteBTField (k - 1))
    (h_split_eq : split h_pos x = (hi_btf, lo_btf)) :
    x = „Ää hi_btf, lo_btf „Äã

protected lemma johnson_bound_lemma [Field F] {v : Fin n ‚Üí F}
  (h_n : 0 < n)
  (h_B : 2 ‚â§ B.card)
  (h_card : 2 ‚â§ (Fintype.card F))
  :
  B.card *
    ((1 - ((Fintype.card F : ‚Ñö) / (Fintype.card F - 1)) * (e B v / n)) ^ 2
      - (1 - ((Fintype.card F : ‚Ñö) / (Fintype.card F - 1)) * (d B/n)))  ‚â§
  ((Fintype.card F : ‚Ñö) / (Fintype.card F - 1)) * d B/n

@[simp]
theorem seqCompose_succ_dir {m : ‚Ñï} {n : Fin (m + 1) ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)} :
    (seqCompose pSpec).dir = Fin.vflatten (fun i => (pSpec i).dir)

@[simp]
theorem snoc_take {pSpec : ProtocolSpec n} (k : ‚Ñï) (h : k < n) :
    (pSpec.take k (Nat.le_of_succ_le h) ++‚Çö ‚ü®![pSpec.dir ‚ü®k, h‚ü©], ![pSpec.Type ‚ü®k, h‚ü©]‚ü©)
      = pSpec.take (k + 1) h

lemma mca_linearCode
  (Gen : ProximityGenerator Œπ F) [Fintype Gen.par‚Ñì] [Nonempty Gen.par‚Ñì]
  (C : LinearCode Œπ F) (hC : C = Gen.C) :
    hasMutualCorrAgreement
     -- Gen
      Gen
    -- BStar (using Œ¥·µ£ produced )
      (min (1 - (Œ¥·µ£ (C : Set (Œπ ‚Üí F))) / 2) (Gen.B Gen.C Gen.par‚Ñì))
    -- errStar
      (fun Œ¥ => Gen.err C Gen.par‚Ñì Œ¥)

@[simp]
theorem getLastI_append_single [Inhabited Œ±] (x : Œ±) : (l ++ [x]).getLastI = x

lemma duplexSpongeToFSGameStatDist
    (maliciousProver : OracleComp (oSpec ++‚Çí duplexSpongeChallengeOracle StmtIn U)
      (StmtIn √ó pSpec.Messages))
    (t‚Çí : Œπ ‚Üí ‚Ñï) (t‚Çï t‚Çö t‚Çö·µ¢ : ‚Ñï)
    -- TODO: state query bound only for subset of the oracles
    (hQuery : IsQueryBound maliciousProver (t‚Çí ‚äï·µ• (t‚Çï ‚äï·µ• (t‚Çö ‚äï·µ• t‚Çö·µ¢)))) : True

omit [Finite R] in
theorem projection_injective
    (C : Set (n ‚Üí R))
    (nontriv : ‚ÄñC‚Äñ‚ÇÄ ‚â• 1)
    (S : Finset n)
    (hS : card S = card n - (‚ÄñC‚Äñ‚ÇÄ - 1))
    (u v : n ‚Üí R)
    (hu : u ‚àà C)
    (hv : v ‚àà C) : projection S u = projection S v ‚Üí u = v

theorem eq_symm {Œ± : Type u} (mx my : m Œ±) : eq mx my ‚Üí eq my mx

@[simp]
theorem Prover.run_of_prover_first [ProverOnly pSpec] (stmt : StmtIn) (wit : WitIn)
    (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      prover.run stmt wit = (do
        let state := prover.input (stmt, wit)
        let ‚ü®msg, state‚ü© ‚Üê liftComp (prover.sendMessage ‚ü®0, by simp‚ü© state) _
        let ctxOut ‚Üê prover.output state
        return ((fun i => match i with | ‚ü®0, _‚ü© => msg), ctxOut))

Nat.zero_le in Init.Prelude

theorem sumcheck_roundPoly_degreeLE (i : Fin (n + 1)) {challenges : Fin i.castSucc ‚Üí R}
    {poly : R[X Fin (n + 1)]} (hp : poly ‚àà R‚¶É‚â§ deg‚¶Ñ[X Fin (n + 1)]) :
      ‚àë x ‚àà (univ.map D) ^·∂† (n - i), poly ‚∏®X ‚¶Éi‚¶Ñ, challenges, x‚∏©'
        (by simp; omega) ‚àà R‚¶É‚â§ deg‚¶Ñ[X]

Fin.is_le' in Init.Data.Fin.Lemmas

Nat.le_add_left in Init.Data.Nat.Basic

lemma concentration_bounds {deg : ‚Ñï} {domain : Œπ ‚Ü™ F}
  {U : AffineSubspace F (Œπ ‚Üí F)} [Nonempty U]
  (hdiv_pos : 0 < (divergence U (RScodeSet domain deg) : ‚Ñù‚â•0))
  (hdiv_lt : (divergence U (RScodeSet domain deg) : ‚Ñù‚â•0) < 1 - ReedSolomonCode.sqrtRate deg domain)
  : let Œ¥' := divergence U (RScodeSet domain deg)
    Pr_{let u ‚Üê $·µñ U}[Code.relHammingDistToCode u (RScodeSet domain deg) ‚â† Œ¥']
    ‚â§ errorBound Œ¥' deg domain

@[simp]
theorem card_univ_filter_eq {e : Œ±} :
  #{x : Œ± | x ‚â† e} = #(Finset.univ (Œ± := Œ±)) - 1

lemma E_and_Q_unique
  [NeZero n]
  {e k : ‚Ñï}
  {E Q E' Q' : Polynomial F}
  {œâs f : Fin n ‚Üí F}
  (he : 2 * e < n - k + 1)
  (hk_n : k ‚â§ n)
  (h_Q : Q ‚â† 0)
  (h_Q' : Q' ‚â† 0)
  (h_inj : Function.Injective œâs)
  (h_bw‚ÇÅ : BerlekampWelchCondition e k œâs f E Q)
  (h_bw‚ÇÇ : BerlekampWelchCondition e k œâs f E' Q')
: E * Q' = E' * Q

theorem base_intermediateNormVpoly
  (k : Fin (‚Ñì + 1)) :
  intermediateNormVpoly ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®0, by
    by_contra ht
    simp only [not_lt, nonpos_iff_eq_zero] at ht
    contradiction
  ‚ü© ‚ü®k, by simp only [tsub_zero]; omega‚ü© =
  normalizedW ùîΩq Œ≤ ‚ü®k, by omega‚ü©

theorem monomialToNovel_novelToMonomial_inverse
  (‚Ñì : ‚Ñï) (h_‚Ñì : ‚Ñì ‚â§ r) :
  ‚àÄ coeffs : Fin (2^‚Ñì) ‚Üí L,
    novelToMonomialCoeffs ùîΩq Œ≤ ‚Ñì h_‚Ñì
    (monomialToNovelCoeffs ùîΩq Œ≤ ‚Ñì h_‚Ñì coeffs) = coeffs

lemma twoAdicGenerator_unit_mem_rootsOfUnity
    (bits : Fin (twoAdicity + 1)) (h : twoAdicGenerators[bits] ‚â† 0) :
    Units.mk0 (twoAdicGenerators[bits]) h ‚àà rootsOfUnity (2 ^ (bits : Nat)) (Field)

theorem induction_append_left {m n : ‚Ñï} {motive : Fin (m + n + 1) ‚Üí Sort*} {zero : motive 0}
    {succ : ‚àÄ i : Fin (m + n), motive i.castSucc ‚Üí motive i.succ} {i : Fin (m + 1)} :
      induction (motive := motive) zero succ ‚ü®i, by omega‚ü© =
        @induction m (fun j => motive ‚ü®j, by omega‚ü©) zero (fun j x => succ ‚ü®j, by omega‚ü© x) i

lemma toCodewordsCount_mul_œë_lt_‚Ñì (‚Ñì œë : ‚Ñï) [NeZero œë] [NeZero ‚Ñì] (i : Fin (‚Ñì + 1)) :
  ‚àÄ j: Fin (toOutCodewordsCount ‚Ñì œë i), j.val * œë < ‚Ñì

omit [Fintype F] in
private lemma hamming_dist_eq_sum {x y : Fin n ‚Üí F} :
  Œî‚ÇÄ(x, y) = ‚àë i, if x i = y i then 0 else 1

theorem eqPolynomial_symm (x : œÉ ‚Üí R) (y : œÉ ‚Üí R) :
    MvPolynomial.eval y (eqPolynomial x) = MvPolynomial.eval x (eqPolynomial y)

@[simp]
theorem dcons_one {motive : Fin (n + 2) ‚Üí Sort u} (a : motive 0)
    (v : (i : Fin (n + 1)) ‚Üí motive i.succ) : (a ::·µà‚ü®motive‚ü© v) 1 = v 0

lemma degreesY_nonempty {f : F[X][Y]} (hf : f ‚â† 0) : (f.toFinsupp.support).Nonempty

theorem mul_one (n : ChurchNat Œ±) : mul n one = n

theorem succ'_ne_zero (n : Nat) : succ' n ‚â† 0

@[to_additive vsum_castSucc]
lemma vprod_castSucc [CommMonoid Œ±] {a : Fin (n + 1) ‚Üí Œ±} :
    vprod a = vprod (a ‚àò Fin.castSucc) * a (last n)

lemma ConcreteBTFieldAlgebra_def (l r : ‚Ñï) (h_le : l ‚â§ r) :
    @ConcreteBTFieldAlgebra (l:=l) (r:=r) (h_le:=h_le)
    = (concreteTowerAlgebraMap l r h_le).toAlgebra

lemma exist_bit_diff_if_diff {n: ‚Ñï} (a: Fin (2^n)) (b: Fin (2^n)) (h_a_ne_b: a ‚â† b):
  ‚àÉ k: Fin n, getBit k a ‚â† getBit k b

theorem happend_eq_addCases {Œ± : Fin m ‚Üí Sort u} {Œ≤ : Fin n ‚Üí Sort u}
    (u : (i : Fin m) ‚Üí Œ± i) (v : (i : Fin n) ‚Üí Œ≤ i) :
    happend u v = addCases (motive := vappend Œ± Œ≤)
      (fun i => cast (vappend_left Œ± Œ≤ i).symm (u i))
      (fun i => cast (vappend_right Œ± Œ≤ i).symm (v i))

private lemma johnson_condition_strong_implies_n_pos
  (h_johnson : JohnsonConditionStrong B v)
  :
  0 < n

lemma Basis.baseChangeRight_repr_tmul (b : Basis Œπ K Left) (x y i) :
    (Basis.baseChangeRight (b:=b) (Right:=Right)).repr (x ‚äó‚Çú y) i = b.repr x i ‚Ä¢ y

@[simp, grind _=_]
theorem monomialXY_pow {n m k : ‚Ñï} {a : F} :
  monomialXY n m a ^ k = monomialXY (n * k) (m * k) (a ^ k)

@[simp]
lemma rank_nonsquare_rows_eq_min (inj : Function.Injective Œ±) :
  (Vandermonde.nonsquare (Œπ' := n) Œ±).rank = min m n

lemma add_self_cancel {k : ‚Ñï} (a : ConcreteBTField k) : a + a = 0

@[simp]
theorem zero_vappend {u : Fin 0 ‚Üí Œ±} (v : Fin n ‚Üí Œ±) :
    vappend u v = v ‚àò Fin.cast (Nat.zero_add n)

@[simp]
lemma solutionToE_and_Q_E_and_Q_to_a_solution :
  E_and_Q_to_a_solution e (solutionToE e k v) (solutionToQ e k v) = v

theorem natDegree_finSuccEquivNth (f : MvPolynomial (Fin (n + 1)) R) :
    (finSuccEquivNth R p f).natDegree = degreeOf p f

@[simp]
theorem cast_idx_symm {i : ChallengeIdx pSpec‚ÇÇ} :
    pSpec‚ÇÅ.Challenge (i.cast hn.symm (cast_symm hSpec)) = pSpec‚ÇÇ.Challenge i

theorem ScalarField_is_prime : Nat.Prime SCALAR_FIELD_CARD

@[simp]
theorem oracleReduction_completeness (h : init.neverFails) :
    (oracleReduction oSpec Statement OStatement pred).perfectCompleteness init impl
    (toRelInput pred hPred) Set.univ

omit [Fintype L] [DecidableEq L] in
theorem Polynomial.foldl_comp (n : ‚Ñï) (f : Fin n ‚Üí L[X]) : ‚àÄ initInner initOuter: L[X],
    Fin.foldl (n:=n) (fun acc j => (f j).comp acc) (initOuter.comp initInner)
    = (Fin.foldl (n:=n) (fun acc j => (f j).comp acc) (initOuter)).comp initInner

theorem nsmul_zero [LawfulBEq R] (p : UniPoly R) : nsmul 0 p = 0

theorem comp_x_square_coeff {f : Polynomial F} {n : ‚Ñï} :
  (f.comp (X * X)).coeff n = if Even n then f.coeff (n / 2) else 0

@[simp]
theorem FullData.ofFun_get {Œ±} {s} (tree : FullData Œ± s) :
    FullData.ofFun s (fun idx => tree.get idx) = tree

@[simp]
private lemma E_ne_zero : (E œâs f p e) ‚â† 0

@[simp]
theorem dappend_left {motive : Fin (m + n) ‚Üí Sort u} (u : (i : Fin m) ‚Üí motive (castAdd n i))
    (v : (i : Fin n) ‚Üí motive (natAdd m i)) (i : Fin m) :
    dappend (motive := motive) u v (castAdd n i) = u i

theorem last_nonzero_some [LawfulBEq R] {p : UniPoly R} {i} (hi : i < p.size) (h : p[i] ‚â† 0) :
  ‚àÉ k, p.last_nonzero = some k

theorem mul_distrib_add (m n p : ChurchNat Œ±) : mul m (add n p) = add (mul m n) (mul m p)

Nat.pred_lt_self in Init.Data.Nat.Basic

lemma solution_gamma_matches_word_if_subset_large
  {œâs : Fin n ‚Ü™ F}
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  {x : Fin n}
  {D : ‚Ñï}
  (hD : D ‚â• Bivariate.totalDegree (H k Œ¥ x‚ÇÄ h_gs))
  (hx : (matching_set_at_x k Œ¥ h_gs x).card >
    (2 * k + 1)
      * (Bivariate.natDegreeY <| H k Œ¥ x‚ÇÄ h_gs)
      * (Bivariate.natDegreeY <| R k Œ¥ x‚ÇÄ h_gs)
      * D)
  : (P k Œ¥ x‚ÇÄ h_gs).eval (Polynomial.C (œâs x)) =
    (Polynomial.C <| u‚ÇÄ x) + u‚ÇÅ x ‚Ä¢ Polynomial.X

lemma round_bound {n k : ‚Ñï} {s : Fin (k + 1) ‚Üí ‚Ñï+} {d : ‚Ñï+}
    (domain_size_cond : (2 ^ (‚àë i, (s i).1)) * d ‚â§ 2 ^ n) :
  (‚àë i, (s i).1) ‚â§ n

lemma crs_equiv_rs_random_point_agreement
  {f : Œπ ‚Üí F} {m s : ‚Ñï} {œÜ : Œπ ‚Ü™ F} [Smooth œÜ] :
  ‚àÄ (r : Fin s ‚Üí Fin m ‚Üí F) (Œ¥ : ‚Ñù‚â•0) (hŒ¥Le : Œ¥ ‚â§ 1),
    (‚àÉ u u' : smoothCode œÜ m,
      u.val ‚â† u'.val ‚àß
      u.val ‚àà relHammingBall (smoothCode œÜ m) f Œ¥ ‚àß
      u'.val ‚àà relHammingBall (smoothCode œÜ m) f Œ¥ ‚àß
      ‚àÄ i : Fin s, (mVdecode u).eval (r i) = (mVdecode u').eval (r i))
    ‚Üî
    (‚àÉ œÉ : Fin s ‚Üí F,
      let w : Fin s ‚Üí MvPolynomial (Fin (m + 1)) F :=
        fun i => MvPolynomial.X (Fin.last m) * rename Fin.castSucc (eqPolynomial (r i))
      let multiCRSCode := multiConstrainedCode œÜ m s w œÉ
      ‚àÉ u u' : Œπ ‚Üí F, u ‚â† u' ‚àß
        u ‚àà relHammingBall multiCRSCode f Œ¥ ‚àß
        u' ‚àà relHammingBall multiCRSCode f Œ¥)

@[simp]
lemma liftF_succ {f : Fin (n + 1) ‚Üí Œ±} : liftF f n = f ‚ü®n, Nat.lt_add_one _‚ü©

theorem dcast_fun‚ÇÇ {a‚ÇÅ a‚ÇÇ a‚ÇÅ' a‚ÇÇ' : Œ±} {h‚ÇÅ : a‚ÇÅ = a‚ÇÅ'} {h‚ÇÇ : a‚ÇÇ = a‚ÇÇ'} {f : Œ± ‚Üí Œ± ‚Üí Œ±}
    {g : (a‚ÇÅ : Œ±) ‚Üí (a‚ÇÇ : Œ±) ‚Üí Œ≤ a‚ÇÅ ‚Üí Œ≤ a‚ÇÇ ‚Üí Œ≤ (f a‚ÇÅ a‚ÇÇ)} {b‚ÇÅ : Œ≤ a‚ÇÅ} {b‚ÇÇ : Œ≤ a‚ÇÇ} :
    dcast (by cases h‚ÇÅ; cases h‚ÇÇ; rfl) (g a‚ÇÅ a‚ÇÇ b‚ÇÅ b‚ÇÇ) = g a‚ÇÅ' a‚ÇÇ' (dcast h‚ÇÅ b‚ÇÅ) (dcast h‚ÇÇ b‚ÇÇ)

lemma powerBasisSucc_dim (k : ‚Ñï) :
  powerBasisSucc (k:=k).dim = 2

theorem qMap_maps_sDomain (i : Fin r) (h_i_add_1 : i + 1 < r) :
  have q_comp_linear_map := qMap_is_linear_map ùîΩq Œ≤ i
  have q_eval_linear_map := linear_map_of_comp_to_linear_map_of_eval
    (f:=qMap ùîΩq Œ≤ i) q_comp_linear_map
  let q_i_map := polyEvalLinearMap (qMap ùîΩq Œ≤ i) q_eval_linear_map
  let S_i := sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i
  let S_i_plus_1 := sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i+1)
  Submodule.map q_i_map S_i = S_i_plus_1

omit [DecidableEq ùîΩq] hF‚ÇÇ h_Œ≤‚ÇÄ_eq_1 in
lemma get_sDomain_first_basis_eq_1 (i : Fin r) (h_i : i < ‚Ñì + R_rate) :
    (sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate
    i (by omega)) ‚ü®0, by omega‚ü© = (1: L)

theorem sumcheckFoldOracleVerifier_rbrKnowledgeSoundness :
    (sumcheckFoldOracleVerifier ùîΩq Œ≤).rbrKnowledgeSoundness init impl
      (pSpec := pSpecSumcheckFold ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
      (relIn := roundRelation (mp := mp) ùîΩq Œ≤ (œë:=œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) 0)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë:=œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) (Fin.last ‚Ñì))
      (rbrKnowledgeError := sumcheckFoldKnowledgeError ùîΩq Œ≤ (œë:=œë))

theorem append_right' {u : Fin m ‚Üí Œ±} {v : Fin n ‚Üí Œ±} {i : Fin n}
    (j : Fin (m + n)) (h : j = natAdd m i) : append u v j = v i

lemma split_join_eq_split {k : ‚Ñï} (h_pos : k > 0)
    (hi_btf lo_btf : ConcreteBTField (k - 1)) :
    split h_pos („Ää hi_btf, lo_btf „Äã) = (hi_btf, lo_btf)

lemma eval‚ÇÇ_eq' {S : Type w} [CommSemiring S] (g : P ‚Üí+* S) (p : P) :
    g p = eval‚ÇÇ (g.comp (Algebra.ofId R P)) (g X) p

@[simp]
theorem FullData.get_ofFun {Œ±} {s} (f : SkeletonNodeIndex s ‚Üí Œ±) :
    (FullData.ofFun s f).get = f

lemma poly_eq_zero_of_dist_lt {n k : ‚Ñï} {F : Type*} [DecidableEq F] [CommRing F] [IsDomain F]
  {p : Polynomial F} {œâs : Fin n ‚Üí F}
  (h_deg : p.natDegree < k)
  (hn : k ‚â§ n)
  (h_inj : Function.Injective œâs)
  (h_dist : Œî‚ÇÄ(p.eval ‚àò œâs, 0) < n - k + 1)
  : p = 0

@[simp]
lemma E_and_Q_to_a_solution_coeff
  : E_and_Q_to_a_solution e E Q i = if i < e then E.coeff i else Q.coeff (i - e)

theorem completeness_relIn_mono {Œµ : ‚Ñù‚â•0} {relIn' : Set (StmtIn √ó WitIn)}
    (hrelIn : relIn' ‚äÜ relIn) :
      completeness init impl relIn relOut reduction Œµ ‚Üí
        completeness init impl relIn' relOut reduction Œµ

theorem getBit_repr {‚Ñì : Nat} : ‚àÄ j, j < 2^‚Ñì ‚Üí
  j = ‚àë k ‚àà Finset.Icc 0 (‚Ñì-1), (getBit k j) * 2^k

@[simp] theorem one_mul {a : AssocNat} : 1 * a = a

theorem queryOracleVerifier_rbrKnowledgeSoundness [Fintype L] {œÉ : Type} (init : ProbComp œÉ)
    (impl : QueryImpl []‚Çí (StateT œÉ ProbComp)) :
    (queryOracleVerifier ùîΩq Œ≤ (œë:=œë) Œ≥_repetitions).rbrKnowledgeSoundness init impl
    (relIn := finalSumcheckRelOut ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (relOut := acceptRejectOracleRel)
    (rbrKnowledgeError := queryRbrKnowledgeError ùîΩq Œ≤ Œ≥_repetitions
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))

theorem intermediateNormVpoly_comp_qmap (i : Fin (‚Ñì))
    (k : Fin (‚Ñì - i - 1)) : -- corresponds to intermediateNormVpoly_comp

@[simp]
theorem OracleReduction.runWithLog_eq_runWithLog_reduction [‚àÄ i, OracleInterface (pSpec.Message i)]
    {stmt : StmtIn} {oStmt : ‚àÄ i, OStmtIn i} {wit : WitIn}
    {oracleReduction : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec} :
      oracleReduction.run stmt oStmt wit =
        oracleReduction.toReduction.run ‚ü®stmt, oStmt‚ü© wit

theorem canonical_iff [LawfulBEq R] {p : UniPoly R} :
   p.trim = p ‚Üî ‚àÄ hp : p.size > 0, p.getLast hp ‚â† 0

lemma nonDoomedFoldingProp_relay_preserved (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i)
    (challenges : Fin i.succ ‚Üí L)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j)
    :
    nonDoomedFoldingProp ùîΩq Œ≤ i.castSucc (Fin.init challenges) oStmt ‚Üî
    nonDoomedFoldingProp ùîΩq Œ≤ i.succ challenges (mapOStmtOutRelayStep ùîΩq Œ≤ i hNCR oStmt)

@[simp]
protected lemma elocPolyF_eq_elocPoly :
  ElocPolyF (n := n) (liftF' œâs) (liftF' f) = ElocPoly n œâs f

theorem withBot_lt_one_cases (x : WithBot ‚Ñï) (h : x < (1 : ‚Ñï)) : x = ‚ä• ‚à® x = (0 : ‚Ñï)

lemma twoAdicGenerators_pow_twoPow_ne_one_of_lt
    {bits : Fin (twoAdicity + 1)} {m : Nat} (hm : m < bits) :
    (twoAdicGenerators[bits]) ^ (2 ^ m) ‚â† (1 : Field)

protected lemma a_lemma_im_not_proud_of_OLD {v a : Fin n ‚Üí F}
  (h_card : 2 ‚â§ Fintype.card F)
  :
  |(1 : ‚Ñö) - ((1 : ‚Ñö) + (1 : ‚Ñö) / ((Fintype.card F : ‚Ñö) - 1)) * ‚ÜëŒî‚ÇÄ(v, a) / ‚Üën

lemma monoToLagrange_eq_monoToLagrange_segment (n : ‚Ñï) [NeZero n] (v : Vector R (2 ^ n)) :
  have h_n_ne_zero: n ‚â† 0

theorem is_prime : Nat.Prime fieldSize

@[simp]
lemma coe_fn_of_coe (f : ‚àÄ a, Œ≤ a) : (f : F) = inst.equiv.invFun f

theorem happend_left_eq_hcons {Œ± : Fin 1 ‚Üí Sort u} {Œ≤ : Fin n ‚Üí Sort u}
    (a : (i : Fin 1) ‚Üí Œ± i) (v : (i : Fin n) ‚Üí Œ≤ i) :
    True

theorem canonical_ext [LawfulBEq R] {p q : UniPoly R} (hp : p.trim = p) (hq : q.trim = q) :
    equiv p q ‚Üí p = q

@[simp]
theorem cast_id :
    Prover.cast rfl rfl = (id : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec‚ÇÅ ‚Üí _)

@[simp]
theorem vcons_succ (a : Œ±) (v : Fin n ‚Üí Œ±) (i : Fin n) : (a ::·µõ v) i.succ = v i

Nat.add_sub_cancel in Init.Data.Nat.Basic

theorem vconcat_eq_snoc (v : Fin n ‚Üí Œ±) (a : Œ±) : vconcat v a = snoc v a

theorem BitVec.eq_mp_eq_dcast {w w2 : ‚Ñï} (x : BitVec w) (h_width_eq : w = w2)
  (h_bitvec_eq : BitVec w = BitVec w2 := by rw [h_width_eq]) :
  Eq.mp (h:=h_bitvec_eq) (a:=x) = dcast (h_width_eq) (x)

@[to_additive (attr := simp)]
theorem prod_Iic_zero : ‚àè j ‚àà Iic 0, v j = v 0

@[simp]
theorem OracleVerifier.run_eq_run_verifier [O‚Çò : ‚àÄ i, OracleInterface (pSpec.Message i)]
    {stmt : StmtIn} {oStmt : ‚àÄ i, OStmtIn i} {transcript : FullTranscript pSpec}
    {verifier : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec} :
      verifier.run stmt oStmt transcript =
        verifier.toVerifier.run ‚ü®stmt, oStmt‚ü© transcript

omit hF‚ÇÇ in
theorem kernel_normalizedW_eq_U (i : Fin r) :
    LinearMap.ker (polyEvalLinearMap (normalizedW ùîΩq Œ≤ i)
    (normalizedW_is_additive ùîΩq Œ≤ i))
    = U ùîΩq Œ≤ i

lemma W_prod_comp_decomposition
    (i : Fin r) (hi : i > 0) :
    (W ùîΩq Œ≤ i) = ‚àè c: ùîΩq, (W ùîΩq Œ≤ (i-1)).comp (X - C (c ‚Ä¢ Œ≤ (i-1)))

@[simp]
theorem erase_even_mem
  {s : Finset ‚Ñï}
  {n : ‚Ñï}
  : n ‚àà (erase_even s) ‚Üî Odd n ‚àß n ‚àà s

lemma aeval_eq' {A : Type y} [CommSemiring A] [Algebra R A] {F : Type z} [FunEquiv F œÉ A]
    (f : P ‚Üí‚Çê[R] A) (p : P) : f p = aeval (fun s => f (X s) : F) p

lemma toOutCodewordsCount_mul_œë_eq_i_succ (i : Fin ‚Ñì) (hCR : isCommitmentRound ‚Ñì œë i) :
  (toOutCodewordsCount ‚Ñì œë i.castSucc) * œë = i.val + 1

omit [Finite F] in
lemma pow_lift : ‚àÄ {a : FÀ£} {i : ‚Ñï} (s : ‚Ñï),
    a ‚àà evalDomain D x i ‚Üí a ^ (2 ^ s) ‚àà evalDomain D x (i + s)

theorem bitsToU_bijective (i : Fin r) :
  Function.Bijective (bitsToU (ùîΩq := ùîΩq) (Œ≤ := Œ≤) (‚Ñì := ‚Ñì) (R_rate := R_rate) i)

theorem qMap_total_fiber_disjoint
  (i : Fin ‚Ñì) (steps : ‚Ñï) (h_i_add_steps : i + steps ‚â§ ‚Ñì)
  {y‚ÇÅ y‚ÇÇ : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i.val + steps, by omega‚ü©}
  (hy_ne : y‚ÇÅ ‚â† y‚ÇÇ) :
  Disjoint
    ((qMap_total_fiber ùîΩq Œ≤ (i := ‚ü®i, by omega‚ü©) (steps := steps)
      (h_i_add_steps := fin_‚Ñì_steps_lt_‚Ñì_add_R i steps h_i_add_steps) y‚ÇÅ '' Set.univ).toFinset)
    ((qMap_total_fiber ùîΩq Œ≤ (i := ‚ü®i, by omega‚ü©) (steps := steps)
      (h_i_add_steps := fin_‚Ñì_steps_lt_‚Ñì_add_R i steps h_i_add_steps) y‚ÇÇ '' Set.univ).toFinset)

lemma getBit_of_and {n m k: ‚Ñï} : getBit k (n &&& m) = getBit k n &&& getBit k m

lemma or_by_split_lowBits {n m n1 m1 bn bm : ‚Ñï} (h_bn : bn < 2) (h_bm : bm < 2)
  (h_n : n = n1 * 2 + bn) (h_m : m = m1 * 2 + bm):
  n ||

omit [Finite F] in
lemma minus_one_in_doms {i : ‚Ñï} (h : i < n) :
    -1 ‚àà evalDomain D i

theorem toFun_eq_const_plus (t : AssocNat) : ‚àÄ m : Nat, t m = t 0 + m

@[simp]
lemma liftF'_zero_eq_zero
  : liftF' (fun _ ‚Ü¶ (0 : Œ±)) = (fun (_ : Fin n) ‚Ü¶ (0 : Œ±))

theorem setWidth_eq_ofNat_mod {n num_bits : Nat} (x : BitVec n) :
  BitVec.setWidth num_bits x = BitVec.ofNat num_bits (x.toNat % 2 ^ num_bits)

omit [DecidableEq ùîΩq] hF‚ÇÇ h_Œ≤‚ÇÄ_eq_1 in
lemma eval_point_œâ_eq_next_twiddleFactor_comp_qmap

  (i : Fin ‚Ñì) (x : Fin (2 ^ (‚Ñì + R_rate - (i + 1)))) :
  -- `j = u||b||v` => x here means u at level i
  evaluationPointœâ ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i.val+1, by omega‚ü© x =
  eval (twiddleFactor ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i, by omega‚ü© ‚ü®x.val, by
    calc x.val < 2 ^ (‚Ñì + R_rate - (i.val + 1)) := by omega
      _ = 2 ^ (‚Ñì + R_rate - i.val - 1) := by rfl
  ‚ü©) (qMap ùîΩq Œ≤ ‚ü®i, by omega‚ü©)

@[simp]
theorem cast_id : Verifier.cast rfl rfl = (id : Verifier oSpec StmtIn StmtOut pSpec‚ÇÅ ‚Üí _)

theorem mca_johnson_bound_CONJECTURE
  [DecidableEq Œπ]
  (Œ± : F) (œÜ : Œπ ‚Ü™ F) (m : ‚Ñï) [Smooth œÜ]
  (par‚Ñì_type : Type) [Fintype par‚Ñì_type] (exp : par‚Ñì_type ‚Ü™ ‚Ñï) :
  let Gen := RSGenerator.genRSC par‚Ñì_type œÜ m exp
  let : Fintype Gen.par‚Ñì := Gen.h‚Ñì
  hasMutualCorrAgreement Gen
    -- Conjectured BStar = ‚àöœÅ
    (Real.sqrt Gen.rate)
    -- Conjectured errStar
    (fun Œ¥ =>
      let min_val := min (1 - Real.sqrt Gen.rate - (Œ¥ : ‚Ñù)) (Real.sqrt Gen.rate / 20)
      ENNReal.ofReal (
        ((Fintype.card par‚Ñì_type - 1) * 2^(2*m)) /
        ((Fintype.card F) * (2 * min_val)^7)
      )
    )

@[simp]
protected lemma elocPoly_one :
  ElocPoly 1 œâs f p = if f 0 ‚â† p.eval (œâs 0) then X - (C (œâs 0)) else 1

theorem liftContext_rbr_knowledgeSoundness [Inhabited InnerWitIn]
    {rbrKnowledgeError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    {stmtLens : OracleStatement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                                OuterOStmtIn OuterOStmtOut InnerOStmtIn InnerOStmtOut}
    {witLens : Witness.InvLens (OuterStmtIn √ó ‚àÄ i, OuterOStmtIn i)
                            OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    (V : OracleVerifier oSpec InnerStmtIn InnerOStmtIn InnerStmtOut InnerOStmtOut pSpec)
    [lensKS : Extractor.Lens.IsKnowledgeSound
      outerRelIn innerRelIn outerRelOut innerRelOut
      (V.toVerifier.compatStatement stmtLens) (fun _ _ => True) ‚ü®stmtLens, witLens‚ü©]
    (h : V.rbrKnowledgeSoundness init impl innerRelIn innerRelOut rbrKnowledgeError) :
      (V.liftContext stmtLens).rbrKnowledgeSoundness init impl outerRelIn outerRelOut
        rbrKnowledgeError

@[simp, grind _=_]
lemma degreeX_mul [IsDomain F] (f g : F[X][Y]) (hf : f ‚â† 0) (hg : g ‚â† 0) :
  degreeX (f * g) = degreeX f + degreeX g

lemma johnson_denominator_def :
  JohnsonDenominator B v = ((1 - ((Fintype.card F) / (Fintype.card F - 1)) * (e B v / n)) ^ 2
      - (1 - ((Fintype.card F) / (Fintype.card F - 1)) * (d B/n)))

@[simp]
lemma finite_possibleDeltas : (possibleDeltas U V).Finite

@[simp, grind =]
lemma totalDegree_monomialXY {n m : ‚Ñï} {a : F} (ha : a ‚â† 0) :
  totalDegree (monomialXY n m a) = n + m

@[simp]
theorem cast_id : Transcript.cast rfl rfl rfl = (id : pSpec‚ÇÅ.Transcript k ‚Üí _)

congrArg in Init.Prelude

@[simp]
lemma ConcreteBTField_add_eq (k n m) :
      ConcreteBTField (k + n + m) = ConcreteBTField (k + (n + m))

theorem oracleReduction_perfectCompleteness (hInit : init.neverFails) :
    (oracleReduction R n deg D oSpec i).perfectCompleteness init impl
      (relationRound R n deg D i.castSucc) (relationRound R n deg D i.succ)

theorem add_zero (hp : p.canonical) : p + 0 = p

theorem PrattPartList.out {p : ‚Ñï} {a : ZMod p} {n : ‚Ñï} (h : PrattPartList p a n) :
    ‚àÄ q : ‚Ñï, q.Prime ‚Üí q ‚à£ n ‚Üí a ^ ((p - 1) / q) ‚â† 1

lemma and_eq_zero_iff_and_each_getBit_eq_zero {n m : ‚Ñï} :
    n &&& m = 0 ‚Üî ‚àÄ k, Nat.getBit k n &&& Nat.getBit k m = 0

private lemma johnson_condition_strong_implies_2_le_F_card
  (h_johnson : JohnsonConditionStrong B v)
  :
  2 ‚â§ Fintype.card F

theorem congrArg‚ÇÉ {Œ± Œ≤ Œ≥ Œ¥ : Sort*} {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥ ‚Üí Œ¥} {a a' : Œ±} {b b' : Œ≤} {c c' : Œ≥}
    (h : a = a') (h' : b = b') (h'' : c = c') : f a b c = f a' b' c'

@[simp]
theorem drop_apply (m : ‚Ñï) (h : m ‚â§ n) (v : (i : Fin n) ‚Üí Œ± i) (i : Fin (n - m)) :
    (drop m h v) i = v (Fin.cast (Nat.sub_add_cancel h) (addNat i m))

@[simp]
theorem fappend‚ÇÇ_right {Œ±‚ÇÅ : Fin m ‚Üí A} {Œ±‚ÇÇ : Fin m ‚Üí B} {Œ≤‚ÇÅ : Fin n ‚Üí A} {Œ≤‚ÇÇ : Fin n ‚Üí B}
    (u : (i : Fin m) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i)) (v : (i : Fin n) ‚Üí F‚ÇÇ (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) (i : Fin n) :
    fappend‚ÇÇ (F := F‚ÇÇ) u v (natAdd m i) =
      cast (by simp [vappend_right]) (v i)

@[simp]
theorem happend_zero {Œ≤ : Fin m ‚Üí Sort u} {Œ± : Fin 0 ‚Üí Sort u} (u : (i : Fin m) ‚Üí Œ≤ i) :
    happend u !h‚ü®Œ±‚ü©[] = u

theorem dconcat_injective2 {motive : Fin (n + 1) ‚Üí Sort u} :
    Function.Injective2 (@dconcat n motive)

theorem init_dconcat {motive : Fin (n + 1) ‚Üí Sort u} (v : (i : Fin n) ‚Üí motive (castSucc i))
    (a : motive (last n)) : (fun i => (v :+·µà‚ü®motive‚ü© a) (castSucc i)) = v

theorem oddRefinement_eq_novel_poly_of_1_leading_suffix (i : Fin ‚Ñì) (v : Fin (2 ^ i.val))
    (original_coeffs : Fin (2 ^ ‚Ñì) ‚Üí L) :
    have h_v: v.val ||

@[simp]
lemma natDegree_solutionToE :
  (solutionToE e k v).natDegree = e

theorem FullTranscript.mk2_eq_snoc_snoc {pSpec : ProtocolSpec 2} (msg0 : pSpec.¬´Type¬ª 0)
    (msg1 : pSpec.¬´Type¬ª 1) :
      FullTranscript.mk2 msg0 msg1 = ((default : pSpec.Transcript 0).concat msg0).concat msg1

lemma list_0 : list 0 = List.Vector.cons (1 : GF(2)) List.Vector.nil

nonpos_iff_eq_zero in Mathlib.Algebra.Order.Monoid.Canonical.Defs

omit [(i : Œπ‚Çõ) ‚Üí OracleInterface (OStatement i)] [OracleInterface Witness] in
theorem oracleProver_run {stmt : Statement} {oStmt : ‚àÄ i, OStatement i} {wit : Witness} :
    (oracleProver oSpec Statement OStatement Witness).run ‚ü®stmt, oStmt‚ü© wit =
      pure (fun i => by aesop, ‚ü®stmt, Sum.rec oStmt (fun _ => wit)‚ü©, ())

theorem is_prime : Nat.Prime fieldSize

theorem add_zero {n : ‚Ñï} (a : CNat (n + 1)) : a + 0 = a

lemma shiftRight_and_one_distrib {n m k : ‚Ñï} :
    Nat.getBit k (n &&& m) = Nat.getBit k n &&& Nat.getBit k m

@[simp]
theorem OracleSpec.append_range_right {Œπ‚ÇÅ Œπ‚ÇÇ : Type} {spec‚ÇÅ : OracleSpec Œπ‚ÇÅ} {spec‚ÇÇ : OracleSpec Œπ‚ÇÇ}
    (i : Œπ‚ÇÇ) : (spec‚ÇÅ ++‚Çí spec‚ÇÇ).range (Sum.inr i) = spec‚ÇÇ.range i

lemma towerEquiv_commutes_left_diff (i d : ‚Ñï) : ‚àÄ r : ConcreteBTField i,
  (AlgebraTower.algebraMap i (i+d) (by omega)) ((towerEquiv i).ringEquiv r) =
  (towerEquiv (i+d)).ringEquiv ((AlgebraTower.algebraMap i (i+d) (by omega)) r)

theorem prime_5 : Nat.Prime 5

lemma probOfBadPts {deg : ‚Ñï} {Œ± : Œπ ‚Ü™ F} {e : ‚Ñï} {U : Matrix Œ∫ Œπ F}
  (he : (e : ‚Ñö) < (Code.minDist (RScodeSet Œ± deg) : ‚Ñö) / 3)
  (hU : e < Œî(U, matrixSubmoduleOfLinearCode Œ∫ (ReedSolomon.code Œ± deg))) :
  (PMF.uniformOfFintype (Matrix.rowSpan U)).toOuterMeasure
    { w | distFromCode (n := Œπ) (R := F) w (ReedSolomon.code Œ± deg) ‚â§ e }
  ‚â§ (Code.minDist (RScodeSet Œ± deg) : ‚Ñù‚â•0) /(Fintype.card F : ‚Ñù‚â•0)

omit [NoZeroDivisors ùîΩ] in
lemma foldNth_degree_le' {n : ‚Ñï} {f : ùîΩ[X]} {Œ± : ùîΩ} [inst : NeZero n] :
    n * (foldNth n f Œ±).natDegree ‚â§ f.natDegree

pow_one in Mathlib.Algebra.Group.Defs

@[simp]
theorem init_update_last : init (update s (Fin.last n) y) = init s

@[simp]
lemma shift_left_empty :
    shift_left ‚àÖ = ‚àÖ

@[simp]
theorem cast_completeness (Œµ : ‚Ñù‚â•0) (hComplete : R.completeness init impl relIn relOut Œµ) :
    (R.cast hn hSpec hO‚Çò).completeness init impl relIn relOut Œµ

lemma algebraMap_succ_eq_zero_x {k : ‚Ñï} (h_pos : k > 0) (x : ConcreteBTField (k - 1)) :
  letI instAlgebra := ConcreteBTFieldAlgebra (l:=k-1) (r:=k) (h_le:=by omega)
  algebraMap (ConcreteBTField (k - 1)) (ConcreteBTField k) x = „Ää 0, x „Äã

theorem sum_square_char2 {F : Type*} [Field F] (sumZeroIffEq : ‚àÄ (x y : F), x + y = 0 ‚Üî x = y)
  (s : Finset ‚Ñï) (f : ‚Ñï ‚Üí F) : (‚àë j ‚àà s, f j)^2 = ‚àë j ‚àà s, (f j)^2

@[simp]
lemma challengeOracleInterface_append_range_inr (j : pSpec‚ÇÇ.ChallengeIdx) :
    [(pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).Challenge]‚Çí.range (.inr j) = pSpec‚ÇÇ.Challenge j

@[simp]
theorem hcons_zero {Œ≤ : Fin n ‚Üí Sort u} (a : Œ±) (b : (i : Fin n) ‚Üí Œ≤ i) :
    hcons a b 0 = cast (vcons_zero Œ± Œ≤).symm a

lemma nonsquare_mulVecLin [CommSemiring F] {Œπ' : ‚Ñï} {Œ±‚ÇÅ : Œπ ‚Ü™ F} {Œ±‚ÇÇ : Fin Œπ' ‚Üí F} {i : Œπ} :
  (nonsquare Œπ' Œ±‚ÇÅ).mulVecLin Œ±‚ÇÇ i = ‚àë x, Œ±‚ÇÇ x * Œ±‚ÇÅ i ^ x.1

@[simp]
theorem Reduction.runWithLog_discard_logs_eq_run
    {stmt : StmtIn} {wit : WitIn}
    {reduction : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec} :
      Prod.fst <$>
        reduction.runWithLog stmt wit = reduction.run stmt wit

omit [DecidableEq L] [DecidableEq ùîΩq] h_Fq_char_prime hF‚ÇÇ hŒ≤_lin_indep h_Œ≤‚ÇÄ_eq_1 in
lemma intermediateNovelBasisX_zero_eq_one (i : Fin (‚Ñì + 1)) :
    intermediateNovelBasisX ùîΩq Œ≤ h_‚Ñì_add_R_rate i ‚ü®0, by
      exact Nat.two_pow_pos (‚Ñì - ‚Üëi)‚ü© = 1

@[simp]
theorem hconcat_zero {Œ± : Fin 0 ‚Üí Sort u} {Œ≤ : Sort u} (a : Œ≤) :
    hconcat !h‚ü®Œ±‚ü©[] a = fun i => match i with

@[grind]
lemma degreeX_le_degreeX_sub_degreeX [IsDomain F] {f q : F[X][Y]} (hf : f ‚â† 0) (hg : q * f ‚â† 0) :
  degreeX q ‚â§ degreeX (q * f) - degreeX f

@[simp]
lemma probFailure_bind_eq_zero_iff [spec.FiniteRange]
    (oa : OracleComp spec Œ±) (ob : Œ± ‚Üí OracleComp spec Œ≤) :
    [‚ä• | oa >>= ob] = 0 ‚Üî [‚ä• | oa] = 0 ‚àß ‚àÄ x ‚àà oa.support, [‚ä• | ob x] = 0

lemma getBit_of_shiftRight {n p : ‚Ñï}:
  ‚àÄ k, getBit k (n >>> p) = getBit (k+p) n

Fin.val_succ in Init.Data.Fin.Lemmas

@[simp]
lemma list_eq (k : ‚Ñï) :
  list (k+1) = (Z (k+1)) ::·µ• (list k).map (AdjoinRoot.of (poly k))

@[simp]
theorem OracleVerifier.id_soundness {lang : Set (StmtIn √ó ‚àÄ i, OStmtIn i)} :
    (OracleVerifier.id : OracleVerifier oSpec _ _ _ _ _).soundness
      init impl lang lang 0

@[simp]
theorem cast_dir_idx {hn} (hSpec : pSpec‚ÇÅ.cast hn = pSpec‚ÇÇ) {i : Fin n‚ÇÅ} :
    pSpec‚ÇÇ.dir (Fin.cast hn i) = pSpec‚ÇÅ.dir i

@[simp]
theorem insertNth_apply_same : insertNth p y s p = y

private lemma almost_johnson_choose_2_elimed [Zero F]
  (h_n : 0 < n)
  (h_B : 2 ‚â§ B.card)
  (h_card : 2 ‚â§ Fintype.card F)
  :
  (k B * (k B - 1)  +
    (B.card - k B) * ((B.card - k B)/(Fintype.card F-1) - 1))
  ‚â§
  B.card * (B.card - 1) * (n - d B)/n

@[simp]
theorem take_append_left' : (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ)‚ü¶:m‚üß = pSpec‚ÇÅ

theorem linear_sum_repr (R : Type*) [CommRing R] (S : Type*) [CommRing S] [Algebra R S]
    (pb : PowerBasis R S) (h_dim : pb.dim = (2 : ‚Ñï)) (s : S) :
    ‚àÉ a b : R, s = a ‚Ä¢ pb.gen + algebraMap R S b

lemma BTField.cast_BTField_eq (k m : ‚Ñï) (h_eq : k = m) :
  BTField k = BTField m

@[csimp, grind =]
theorem findIdx'_eq_findIdx : @findIdx' = @findIdx

private lemma k_and_e [Zero F]
  (h_n : n ‚â† 0)
  (h_B : B.card ‚â† 0)
  :
  k B = B.card * (n - e B 0) / n

@[simp]
theorem dflatten_splitSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {motive : (k : Fin (vsum n)) ‚Üí Sort*}
    (v : (k : Fin (vsum n)) ‚Üí motive k) (k : Fin (vsum n)) :
    dflatten (motive := motive) (fun i j => v (embedSum i j)) k = v k

lemma rank_eq_rowRank : U.rank = rowRank U

Fin.val_injective in Mathlib.Data.Fin.Basic

theorem is_multilinear_iff_eq_evals_zeroOne {p : MvPolynomial œÉ R} :
    p ‚àà R‚¶É‚â§ 1‚¶Ñ[X œÉ] ‚Üî MLE p.toEvalsZeroOne = p

private lemma f_convex {x‚ÇÅ x‚ÇÇ : ‚Ñö} {Œ±‚ÇÅ Œ±‚ÇÇ : ‚Ñö}
  (h_noneg_1 : 0 ‚â§ Œ±‚ÇÅ)
  (h_noneg_2 : 0 ‚â§ Œ±‚ÇÇ)
  (h_conv : Œ±‚ÇÅ + Œ±‚ÇÇ = 1)
  :
  f (Œ±‚ÇÅ * x‚ÇÅ + Œ±‚ÇÇ * x‚ÇÇ) ‚â§ Œ±‚ÇÅ * f x‚ÇÅ + Œ±‚ÇÇ * f x‚ÇÇ

@[simp]
theorem hflatten_zero {n : Fin 0 ‚Üí ‚Ñï} {Œ± : (i : Fin 0) ‚Üí (j : Fin (n i)) ‚Üí Sort*}
    {v : (i : Fin 0) ‚Üí (j : Fin (n i)) ‚Üí Œ± i j} : hflatten v = !h[]

theorem zero_mul {a : AssocNat} : 0 * a = 0

omit h_Fq_char_prime hF‚ÇÇ in
lemma rootMultiplicity_prod_W_comp_X_sub_C
    (i : Fin r) (h_i_add_1 : i + 1 < r) (a : L) :
    rootMultiplicity a ((univ : Finset ùîΩq).prod (fun c => (W ùîΩq Œ≤ i).comp (X - C (c ‚Ä¢ Œ≤ i)))) =
    if a ‚àà (U ùîΩq Œ≤ (i+1) : Set L) then 1 else 0

@[simp]
theorem induction_one {motive : Fin 2 ‚Üí Sort*} {zero : motive 0}
    {succ : ‚àÄ i : Fin 1, motive i.castSucc ‚Üí motive i.succ} :
      induction (motive := motive) zero succ (last 1) = succ 0 zero

theorem take_addCases'_left {n' : ‚Ñï} {Œ≤ : Fin n' ‚Üí Sort u} (m : ‚Ñï) (h : m ‚â§ n)
    (u : (i : Fin n) ‚Üí Œ± i) (v : (j : Fin n') ‚Üí Œ≤ j) (i : Fin m) :
    take m (Nat.le_add_right_of_le h) (addCases' u v) i =
      (append_left Œ± Œ≤ (castLE h i)) ‚ñ∏ (take m h u i)

omit [Finite F] in
lemma mul_root_of_unity {x : FÀ£} :
  ‚àÄ {a b : FÀ£} {i j : ‚Ñï},
    i ‚â§ j ‚Üí a ‚àà evalDomain D x i ‚Üí b ‚àà Domain.evalDomain D j ‚Üí
      a * b ‚àà evalDomain D x i

theorem ofFn_rtake_eq_rtake_ofFn {Œ± : Type*} {m : ‚Ñï} (h : m ‚â§ n) (v : Fin n ‚Üí Œ±) :
    List.ofFn (rtake m h v) = (List.ofFn v).rtake m

lemma W_monic (i : Fin r) : (W ùîΩq Œ≤ i).Monic

lemma schwartz_zippel_of_fintype {p : MvPolynomial œÉ R} (hp : p ‚â† 0) (S : œÉ ‚Üí Finset R) :
    #{x ‚àà S ^^ œÉ | eval x p = 0} / ‚àè i, (#(S i) : ‚Ñö‚â•0) ‚â§ ‚àë i, (p.degreeOf i / #(S i) : ‚Ñö‚â•0)

theorem finalSumcheckOracleVerifier_rbrKnowledgeSoundness [Fintype L] {œÉ : Type}
    (init : ProbComp œÉ) (impl : QueryImpl []‚Çí (StateT œÉ ProbComp)) :
    (finalSumcheckVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).rbrKnowledgeSoundness init impl
      (relIn := roundRelation ùîΩq Œ≤ (œë := œë) (ùìë := ùìë)
        (mp := BBF_SumcheckMultiplierParam) (Fin.last ‚Ñì))
      (relOut := finalSumcheckRelOut ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
      (rbrKnowledgeError := finalSumcheckKnowledgeError)

theorem PowerBasis_cast_dest_eq (k n m : ‚Ñï) (h_k_le_n : k ‚â§ n)
  (h_k_le_m : k ‚â§ m) (h_eq : m = n) :
  letI instLeftAlgebra := ConcreteBTFieldAlgebra (l:=k) (r:=m) (h_le:=h_k_le_m)
  letI instRightAlgebra := ConcreteBTFieldAlgebra (l:=k) (r:=n) (h_le:=h_k_le_n)
  @PowerBasis (ConcreteBTField k) (ConcreteBTField m) _ _ instLeftAlgebra =
  @PowerBasis (ConcreteBTField k) (ConcreteBTField n) _ _ instRightAlgebra

@[simp]
theorem dconcat_zero {motive : Fin 1 ‚Üí Sort u} (a : motive (last 0)) :
    !d‚ü®fun _ : Fin 0 => motive (castSucc _)‚ü©[] :+·µà‚ü®motive‚ü© a = !d‚ü®motive‚ü©[a]

@[simp]
lemma aeval_X {A : Type y} [CommSemiring A] [Algebra R A] {F : Type z} [FunEquiv F œÉ A] (g : F)
    (s : œÉ) : aeval g (X s : P) = g s

Fin.eta in Init.Data.Fin.Lemmas

Polynomial.degree_sum_le in Mathlib.Algebra.Polynomial.Degree.Definitions

@[simp]
theorem vappend_vcons (a : Œ±) (u : Fin m ‚Üí Œ±) (v : Fin n ‚Üí Œ±) :
    vappend (vcons a u) v = (vcons a (vappend u v)) ‚àò Fin.cast (Nat.succ_add m n)

@[simp]
theorem FullData.rightSubtree_internal {Œ±} {s_left s_right : Skeleton}
    (value : Œ±) (left : FullData Œ± s_left) (right : FullData Œ± s_right) :
    (FullData.internal value left right).rightSubtree = right

lemma getBit_of_add_distrib {n m k : ‚Ñï}
  (h_n_AND_m : n &&& m = 0) : getBit k (n + m) = getBit k n + getBit k m

@[simp]
theorem cast_id : MessageIdx.cast (Eq.refl n‚ÇÅ) rfl = (id : pSpec‚ÇÅ.MessageIdx ‚Üí _)

lemma extract_start_zero_eq_take {n : ‚Ñï} {Œ± : Fin n ‚Üí Sort*} (stop : ‚Ñï) (h : stop ‚â§ n)
    (v : (i : Fin n) ‚Üí Œ± i) : extract 0 stop (Nat.zero_le _) h v = take stop h v

@[coe]
theorem BTField_succ_eq_adjoinRoot (k : ‚Ñï) : AdjoinRoot (poly k) = BTField (k+1)

theorem dconcat_init_self {motive : Fin (n + 1) ‚Üí Sort u} (v : (i : Fin (n + 1)) ‚Üí motive i) :
    (fun i => v (castSucc i)) :+·µà‚ü®motive‚ü© (v (last n)) = v

theorem take_drop_addCases' (m : ‚Ñï) (h : m ‚â§ n) (v : (i : Fin n) ‚Üí Œ± i) :
    Fin.addCases' (take m h v) (drop m h v) =
      fun i =>
        cast (by simp [append, addCases, castLE, Fin.cast]; intro hi; rw! [Nat.sub_add_cancel hi])
          (v (i.cast (by omega)))

omit [Finite F] in
private lemma gen_def {i : ‚Ñï} :
    (IsCyclicWithGen.gen : evalDomain D i) =
      ‚ü®
        DIsCyclicC.gen ^ (2 ^ i),
        by
          apply pow_2_pow_i_mem_Di_of_mem_D
          exact DIsCyclicC.gen.2
      ‚ü©

theorem completeness [DecidableEq Œ±] [SelectableType Œ±] {s}
    (leaf_data_tree : LeafData Œ± s) (idx : BinaryTree.SkeletonLeafIndex s)
    (preexisting_cache : (spec Œ±).QueryCache) :
    (((do
      let cache ‚Üê buildMerkleTree leaf_data_tree
      let proof := generateProof cache idx
      let _ ‚Üê verifyProof idx (leaf_data_tree.get idx) (cache.getRootValue) proof
      ).simulateQ (randomOracle)).run preexisting_cache).neverFails

omit h_Œ≤‚ÇÄ_eq_1 in
lemma finToBinaryCoeffs_sDomainToFin (i : Fin r) (h_i : i < ‚Ñì + R_rate)
    (x : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i) :
    let pointFinIdx := (sDomainToFin ùîΩq Œ≤ h_‚Ñì_add_R_rate i h_i) x
    finToBinaryCoeffs ùîΩq (i := i) (idx :=pointFinIdx) =
    (sDomain_basis ùîΩq Œ≤
    h_‚Ñì_add_R_rate i h_i).repr x

omit [Fintype L] [DecidableEq L] [Fintype ùîΩq] h_Fq_char_prime hŒ≤_lin_indep in
theorem root_U_lift_up (i : Fin r) (h_i_add_1 : i + 1 < r) (a : L) (x : ùîΩq) :
  a - x ‚Ä¢ Œ≤ i ‚àà (U ùîΩq Œ≤ i) ‚Üí a ‚àà (U ùîΩq Œ≤ (i+1))

theorem LeafData.composeBuild_getRootValue {Œ±} {s_left s_right : Skeleton}
    (left : LeafData Œ± s_left) (right : LeafData Œ± s_right)
    (compose : Œ± ‚Üí Œ± ‚Üí Œ±) :
    ((LeafData.internal left right).composeBuild compose).getRootValue =
      compose (left.composeBuild compose).getRootValue (right.composeBuild compose).getRootValue

theorem two_le_two_pow_n_plus_1 (n : ‚Ñï) : 2 ‚â§ 2 ^ (n + 1)

@[simp]
theorem rtake_append_right :
    (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).rtake n (Nat.le_add_left n m) = pSpec‚ÇÇ

lemma W·µ¢_eval_Œ≤·µ¢_neq_zero
    (i : Fin r): (W ùîΩq Œ≤ i).eval (Œ≤ i) ‚â† 0

@[simp]
theorem drop_update_of_lt (m : ‚Ñï) (h : m ‚â§ n) (v : (i : Fin n) ‚Üí Œ± i) (i : Fin n)
    (hi : i < m) (x : Œ± i) : drop m h (update v i x) = drop m h v

theorem whir_rbr_soundness
    [SelectableType F] {d dstar : ‚Ñï}
  -- P : set of M + 1 parameters including foldingParam·µ¢, varCount·µ¢, œÜ·µ¢, repeatParam·µ¢,
  --

private lemma solutionToE_from_E
  (h_p_deg : p.natDegree < k)
  (h_dist : (Œî‚ÇÄ(f, p.eval ‚àò œâs) : ‚Ñï) ‚â§ e)
  : solutionToE e k (E_and_Q_to_a_solution e (E œâs f p e) (Q œâs f p e)) = E œâs f p e

@[simp]
theorem toNat_zero : toNat zero = 0

lemma h_middle_sub {k : ‚Ñï} : 2 ^ (k - 1) - 1 - 0 + 1 = 2 ^ (k - 1)

theorem towerAlgebraMap_assoc : ‚àÄ r mid l : ‚Ñï, (h_l_le_mid : l ‚â§ mid) ‚Üí (h_mid_le_r : mid ‚â§ r) ‚Üí
    towerAlgebraMap (l:=l) (r:=r) (h_le:=by exact Nat.le_trans h_l_le_mid h_mid_le_r) =
    (towerAlgebraMap (l:=mid) (r:=r) (h_le:=h_mid_le_r)).comp
    (towerAlgebraMap (l:=l) (r:=mid) (h_le:=h_l_le_mid))

Fin.ext in Init.Data.Fin.Lemmas

theorem two_pow_ne_zero (n : ‚Ñï) : 2 ^ n ‚â† 0

lemma evenize_eval {f : Polynomial F} {s : F} :
    (evenize f).eval s = f.eval (s * s)

@[simp]
lemma relHammingDist_mem_relHammingDistRange [DecidableEq F] : Œ¥·µ£(u, v) ‚àà relHammingDistRange Œπ

beq_iff_eq in Init.Core

lemma trim_add_trim [LawfulBEq R] (p q : UniPoly R) : p.trim + q = p + q

theorem evenRefinement_eq_novel_poly_of_0_leading_suffix (i : Fin ‚Ñì) (v : Fin (2 ^ i.val))
    (original_coeffs : Fin (2 ^ ‚Ñì) ‚Üí L) :
    have h_v: v.val < 2 ^ (i.val + 1) := by
      calc v.val < 2 ^ i.val := by omega
        _ < 2 ^ (i.val + 1) := by apply Nat.pow_lt_pow_right (by omega) (by omega)
    evenRefinement ùîΩq Œ≤ h_‚Ñì_add_R_rate i (coeffsBySuffix (r:=r)
      (R_rate:=R_rate) (a:=original_coeffs) ‚ü®i, by omega‚ü© v) =
    intermediateEvaluationPoly ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i + 1, by omega‚ü©
      (coeffsBySuffix (r:=r) (R_rate:=R_rate) original_coeffs ‚ü®i + 1, by omega‚ü© ‚ü®v, h_v‚ü©)

private lemma choose_2_eq_half_f :
  choose_2 = (1/2) * f

lemma galois_eval_in_BTField
    {curBTField : Type*} [Field curBTField]
    (u : curBTField) (t1 : curBTField) -- here t1 is already lifted to curBTField
    (k : ‚Ñï)
    (sumZeroIffEq : ‚àÄ (x y : curBTField), x + y = 0 ‚Üî x = y)
    (prevSpecialElementNeZero : t1 ‚â† 0)
    (u_plus_inv_eq_t1 : u + u‚Åª¬π = t1)
    (h_u_square : u^2 = u*t1 + 1)
    (h_t1_pow : t1^(2^(2^k)-1) = 1 ‚àß (t1‚Åª¬π)^(2^(2^k)-1) = 1)
    (h_t1_pow_2_pow_2_pow_k :  t1^(2^(2^k)) = t1)
    (h_t1_inv_pow_2_pow_2_pow_k :  (t1‚Åª¬π)^(2^(2^k)) = t1‚Åª¬π)
    (trace_map_at_inv : ‚àë i ‚àà Finset.range (2 ^ k), t1‚Åª¬π ^ (2 ^ i) = 1) :
    u^(2^(2^k)) = u‚Åª¬π

lemma and_shl_eq_zero_of_lt_two_pow {a n b : ‚Ñï} (hb : b < 2 ^ n) : (a <<< n) &&& b = 0

@[simp]
theorem Set.not_mem_language_iff {Œ± Œ≤} (rel : Set (Œ± √ó Œ≤)) (stmt : Œ±) :
    stmt ‚àâ rel.language ‚Üî ‚àÄ wit, (stmt, wit) ‚àâ rel

@[simp] lemma twoAdicGenerators_length : twoAdicGenerators.length = twoAdicity + 1

theorem dconcat_left_injective {motive : Fin (n + 1) ‚Üí Sort u} (a : motive (last n)) :
    Function.Injective (fun v => dconcat (motive := motive) v a)

@[simp]
theorem mul_by_2_mem {s : Finset ‚Ñï} {d : ‚Ñï} :
    d ‚àà mul_by_2 s ‚Üî Even d ‚àß (d / 2) ‚àà s

theorem rbrKnowledgeSoundnessOneShot_implies_rbrKnowledgeSoundness
    {relIn : Set (StmtIn √ó WitIn)} {relOut : Set (StmtOut √ó WitOut)}
    {verifier : Verifier oSpec StmtIn StmtOut pSpec}
    {rbrKnowledgeError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    (hInit : init.neverFails)
    (h : verifier.rbrKnowledgeSoundnessOneShot init impl relIn relOut rbrKnowledgeError) :
    verifier.rbrKnowledgeSoundness init impl relIn relOut rbrKnowledgeError

@[simp]
theorem Prover.runToRound_one_of_prover_first [ProverOnly pSpec] (stmt : StmtIn) (wit : WitIn)
    (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      prover.runToRound 1 stmt wit = (do
        let state := prover.input (stmt, wit)
        let ‚ü®msg, state‚ü© ‚Üê liftComp (prover.sendMessage ‚ü®0, by simp‚ü© state) _
        return (fun i => match i with | ‚ü®0, _‚ü© => msg, state))

omit [NeZero ‚Ñì] [NeZero r] [NeZero ùì°] in
lemma fin_‚Ñì_steps_lt_r {h_‚Ñì_add_R_rate : ‚Ñì + ùì° < r} (i : Fin ‚Ñì) (steps : ‚Ñï)
    (h : i.val + steps ‚â§ ‚Ñì) : i.val + steps < r

lemma sDomain_card (i : Fin r) (h_i : i < ‚Ñì + R_rate) :
    Fintype.card (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i) = (Fintype.card ùîΩq)^(‚Ñì + R_rate - i)

theorem linear_form_of_elements_in_adjoined_commring
    {R : Type*} [CommRing R] (f : R[X]) (hf_deg : f.natDegree = 2)
    (hf_monic : Monic f) (c1 : AdjoinRoot f) :
    ‚àÉ a b : R, c1 = (AdjoinRoot.of f) a * root f + (AdjoinRoot.of f) b

lemma getHighBits_no_shl_joinBits {n m : ‚Ñï} (low : Fin (2 ^ n)) (high : Fin (2 ^ m)) :
  getHighBits_no_shl n (joinBits low high).val = high.val

theorem relayOracleReduction_perfectCompleteness (hInit : init.neverFails) (i : Fin ‚Ñì)
    (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
    OracleReduction.perfectCompleteness
      (pSpec := pSpecRelay)
      (relIn := foldStepRelOut (mp := mp) ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        (ùìë := ùìë) i)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        (ùìë := ùìë) i.succ)
      (oracleReduction := relayOracleReduction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        i hNCR)
      (init := init)
      (impl := impl)

theorem happend_hconcat {Œ± : Fin m ‚Üí Sort u} {Œ≤ : Fin n ‚Üí Sort u} {Œ≥ : Sort u}
    (u : (i : Fin m) ‚Üí Œ± i) (v : (i : Fin n) ‚Üí Œ≤ i) (c : Œ≥) :
    True

theorem sum_of_root_and_inverse_is_t1
    {curBTField : Type*} [Field curBTField]
    (u : curBTField) (t1 : curBTField) -- here t1 is already lifted to curBTField
    (specialElementNeZero : u ‚â† 0)
    (eval_prevPoly_at_root : u ^ 2 + t1 * u + 1 = 0)
    (sumZeroIffEq : ‚àÄ (x y : curBTField), x + y = 0 ‚Üî x = y) :
    u + u‚Åª¬π = t1

@[simp]
lemma challengeOracleInterface_append_range_inl (j : pSpec‚ÇÅ.ChallengeIdx) :
    [(pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).Challenge]‚Çí.range (.inl j) = pSpec‚ÇÅ.Challenge j

@[simp]
theorem init_apply : init s i = s i.castSucc

@[simp]
theorem ConcreteBTField.RingHom_cast_source_apply (k n m : ‚Ñï) (h_eq : k = n)
  (f : ConcreteBTField k ‚Üí+* ConcreteBTField m) (x : ConcreteBTField n) :
    (cast (ConcreteBTField.RingHom_eq_of_source_eq (k:=k) (n:=n) (m:=m) h_eq) f) x
    = f (cast (by apply cast_ConcreteBTField_eq (h_eq:=h_eq.symm)) x)

@[simp]
theorem append_snd (T‚ÇÅ : FullTranscript pSpec‚ÇÅ) (T‚ÇÇ : FullTranscript pSpec‚ÇÇ) :
    (T‚ÇÅ ++‚Çú T‚ÇÇ).snd = T‚ÇÇ

@[simp]
theorem dconcat_castSucc {motive : Fin (n + 1) ‚Üí Sort u} (v : (i : Fin n) ‚Üí motive (castSucc i))
    (a : motive (last n)) (i : Fin n) : (v :+·µà‚ü®motive‚ü© a) (castSucc i) = v i

Nat.lt_of_add_right_lt in Init.Data.Nat.Basic

theorem support_C {r : R} [h : Decidable (r = 0)] :
    (@C R œÉ _ r).support = if r = 0 then ‚àÖ else { 0 }

theorem elim [LawfulBEq R] (p : UniPoly R) :
    (p.trim = #[] ‚àß  (‚àÄ i, (hi : i < p.size) ‚Üí p[i] = 0))
  ‚à® (‚àÉ k : Fin p.size,
        p.trim = p.extract 0 (k + 1)
      ‚àß p[k] ‚â† 0
      ‚àß (‚àÄ j : ‚Ñï, (hj : j < p.size) ‚Üí j > k ‚Üí p[j] = 0))

lemma towerRingHomForwardMap_one {k : ‚Ñï} :
  (towerRingHomForwardMap k) 1 = 1

lemma quotienting [DecidableEq F] {degree : ‚Ñï} {domain : Œπ ‚Ü™ F} [Nonempty Œπ]
  (S : Finset F) (hS_lt : S.card < degree) (r : F)
  (f : Œπ ‚Üí F) (Ans Fill : S ‚Üí F) (Œ¥ : ‚Ñù) (hŒ¥Pos : Œ¥ > 0) (hŒ¥Lt : Œ¥ < 1)
  (h : ‚àÄ u : code domain degree, u.val ‚àà (relHammingBall ‚Üë(code domain degree) f Œ¥) ‚Üí
    ‚àÉ (x : S) (hx : x.val ‚àà S), ((decodeLT u) : F[X]).eval x.val ‚â† Ans ‚ü®x.val, hx‚ü©) :
    Œ¥·µ£((funcQuotient f S Ans Fill), (code domain (degree - S.card))) +
      ((disagreementSet f S Ans).card : ‚Ñù) / (Œπ.card : ‚Ñù) > Œ¥

@[simp]
theorem cast_id :
    Reduction.cast rfl rfl = (id : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec‚ÇÅ ‚Üí _)

lemma johnson_condition_weak_implies_strong {B : Finset (Fin n ‚Üí F)} {v : Fin n ‚Üí F} {e : ‚Ñï}
  (h : JohnsonConditionWeak B e)
  :
  JohnsonConditionStrong (B ‚à© ({ x | Œî‚ÇÄ(x, v) ‚â§ e } : Finset _)) v

@[simp]
theorem FullData.get_leaf {Œ±} (a : Œ±) :
    (FullData.leaf a).get SkeletonNodeIndex.ofLeaf = a

@[simp]
theorem BTField.Basis_cast_dest_apply {Œπ : Type*} (Œ± Œ≤ Œ≥ : ‚Ñï) (h_le1 : Œ± ‚â§ Œ≤) (h_le2 : Œ± ‚â§ Œ≥)
    (h_eq : Œ≤ = Œ≥) {k : Œπ} (b : @Basis Œπ (BTField Œ±) (BTField Œ≤) _ _
    (@binaryAlgebraTower (l := Œ±) (r := Œ≤) (h_le := h_le1)).toModule) :
    let castBasis : @Basis Œπ (BTField Œ±) (BTField Œ≥) _ _
      (@binaryAlgebraTower (l := Œ±) (r := Œ≥) (h_le := h_le2)).toModule :=
      cast (by
        exact Basis_cast_dest_eq Œ± Œ≥ Œ≤ h_le2 h_le1 h_eq
      ) b
    (castBasis k) = cast (by exact BTField.cast_BTField_eq Œ≤ Œ≥ h_eq) (b k)

theorem hammingDist_le_of_outer_comp_injective {Œπ‚ÇÅ Œπ‚ÇÇ : Type*} [Fintype Œπ‚ÇÅ] [Fintype Œπ‚ÇÇ]
    {Œ≤ : Œπ‚ÇÇ ‚Üí Type*} [‚àÄ i, DecidableEq (Œ≤ i)] [DecidableEq Œπ‚ÇÇ]
    (x y : ‚àÄ i, Œ≤ i) (g : Œπ‚ÇÅ ‚Üí Œπ‚ÇÇ) (hg : Function.Injective g) :
    hammingDist (fun i => x (g i)) (fun i => y (g i)) ‚â§ hammingDist x y

theorem join_eq_bitvec_iff_fromNat {k : ‚Ñï} (h_pos : k > 0) (x : ConcreteBTField k)
  (hi_btf lo_btf : ConcreteBTField (k - 1)) :
  x = „Ää hi_btf, lo_btf „Äã ‚Üî
  (hi_btf = fromNat (k:=k - 1) (x.toNat >>> 2 ^ (k - 1)) ‚àß
  lo_btf = fromNat (k:=k - 1) (x.toNat &&& (2 ^ (2 ^ (k - 1)) - 1)))

theorem rightpad_eq_self (v : Fin n ‚Üí Œ±) (a : Œ±) : rightpad n a v = v

theorem challengeOracleInterface_cast {h : n‚ÇÅ = n‚ÇÇ} {hSpec : pSpec‚ÇÅ.cast h = pSpec‚ÇÇ}
    {i : pSpec‚ÇÅ.ChallengeIdx} :
    pSpec‚ÇÅ.challengeOracleInterface i =
      dcast (by simp) (pSpec‚ÇÇ.challengeOracleInterface (i.cast hn hSpec))

theorem GF_2_value_eq_zero_or_one (x : GF(2)) : x = 0 ‚à® x = 1

lemma addSalt_Challenge (i : pSpec.ChallengeIdx) :
    (pSpec.addSalt Salt).Challenge i = pSpec.Challenge i

lemma concrete_exists_pair_ne {k : ‚Ñï} : ‚àÉ x y : ConcreteBTField k, x ‚â† y

Nat.succ_lt_succ_iff in Init.Data.Nat.Basic

lemma getBit_of_or {n m k: ‚Ñï} : getBit k (n ||| m) = getBit k n ||

omit [Fintype F] [DecidableEq F] in
private lemma choose_2_card_ne_zero (h : 2 ‚â§ B.card) : choose_2 ‚ÜëB.card ‚â† 0

theorem add_comm : p + q = q + p

@[simp]
theorem vflatten_zero {n : Fin 0 ‚Üí ‚Ñï} {v : (i : Fin 0) ‚Üí Fin (n i) ‚Üí Œ±} : vflatten v = !v[]

lemma sum_of_and_eq_zero_is_xor {n m : ‚Ñï} (h_n_AND_m : n &&& m = 0) : n + m = n ^^^ m

@[simp] theorem join_cons : (l :: ls).join = l ++ ls.join

@[grind _=_]
lemma weightedDegree_eq_natWeightedDegree {u v : ‚Ñï} :
  f ‚â† 0 ‚Üí weightedDegree f u v = natWeightedDegree f u v

lemma getBit_eq_testBit (k n : Nat) : getBit k n = if n.testBit k then 1 else 0

@[simp]
theorem head_cons {Œ±} {n : ‚Ñï} (hd : Œ±) (tl : Vector Œ± n) : (cons hd tl).head = hd

lemma toImpl_elim (p : Q[X]) :
    (p = 0 ‚àß p.toImpl = #[])
  ‚à® (p ‚â† 0 ‚àß p.toImpl = .ofFn (fun i : Fin (p.natDegree + 1) => p.coeff i))

@[simp] theorem BitVec.dcast_zero {n m : ‚Ñï} (h : n = m) : DCast.dcast h (0#n) = 0#m

@[simp]
theorem vflatten_two_eq_append {n : Fin 2 ‚Üí ‚Ñï} {v : (i : Fin 2) ‚Üí Fin (n i) ‚Üí Œ±} :
    vflatten v = vappend (v 0) (v 1)

omit hF‚ÇÇ in
theorem W_linear_comp_decomposition (i : Fin r) (h_i_add_1 : i + 1 < r) :
    ‚àÄ p: L[X], (W ùîΩq Œ≤ (i + 1)).comp p =
      ((W ùîΩq Œ≤ i).comp p) ^ Fintype.card ùîΩq -
        C (eval (Œ≤ i) (W ùîΩq Œ≤ i)) ^ (Fintype.card ùîΩq - 1) * ((W ùîΩq Œ≤ i).comp p)

lemma binaryTowerAlgebra_def (l r : ‚Ñï) (h_le : l ‚â§ r) :
    @binaryAlgebraTower (l:=l) (r:=r) (h_le:=h_le)
    = (towerAlgebraMap l r h_le).toAlgebra

theorem fcons‚ÇÇ_left_injective {Œ±‚ÇÅ : A} {Œ±‚ÇÇ : B} {Œ≤‚ÇÅ : Fin n ‚Üí A} {Œ≤‚ÇÇ : Fin n ‚Üí B}
    (b : (i : Fin n) ‚Üí F‚ÇÇ (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) :
    Function.Injective (fun a : F‚ÇÇ Œ±‚ÇÅ Œ±‚ÇÇ => fcons‚ÇÇ (F := F‚ÇÇ) a b)

omit [SelectableType R] in
@[simp]
lemma reduction_verifier_eq_verifier {i : Fin n} :
    (reduction R n deg D oSpec i).verifier = verifier R n deg D oSpec i

lemma xor_eq_sub_iff_submask {n m : ‚Ñï} (h: m ‚â§ n) : n ^^^ m = n - m ‚Üî n &&& m = m

theorem last_nonzero_spec [LawfulBEq R] {p : UniPoly R} {k} :
  p.last_nonzero = some k
  ‚Üí p[k] ‚â† 0 ‚àß (‚àÄ j, (hj : j < p.size) ‚Üí j > k ‚Üí p[j] = 0)

lemma zero_def [Zero R] : zero = Vector.replicate (2 ^ n) 0

theorem finrank_degreeLT_n (n : ‚Ñï) : Module.finrank L (L‚¶É< n‚¶Ñ[X]) = n

lemma Fin.le_iff_lt_succ (a b : Fin r) (h_b : b + 1 < r) : a ‚â§ b ‚Üî a < b + 1

lemma algebraMap_adjacent_tower_def (l : ‚Ñï) :
  (algebraMap (BTField l) (BTField (l + 1))) = canonicalEmbedding l

theorem finalSumcheckOracleReduction_perfectCompleteness {œÉ : Type}
  (init : ProbComp œÉ)
  (impl : QueryImpl []‚Çí (StateT œÉ ProbComp))
  (hInit : init.neverFails) :
  OracleReduction.perfectCompleteness
    (pSpec := pSpecFinalSumcheckStep (L := L))
    (relIn := roundRelation ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (ùìë := ùìë) (mp := BBF_SumcheckMultiplierParam) (Fin.last ‚Ñì))
    (relOut := finalSumcheckRelOut ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (oracleReduction := finalSumcheckOracleReduction ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)) (init := init) (impl := impl)

theorem peval_eq_eval_sumToIter_rename (f : œÉ ‚Üí œÉ‚ÇÅ ‚äï œÉ‚ÇÇ) (x : œÉ‚ÇÅ ‚Üí R) (p : MvPolynomial œÉ R) :
    peval f x p = eval (C ‚àò x) (sumToIter R œÉ‚ÇÅ œÉ‚ÇÇ (rename f p))

lemma definingPoly_is_monic {F : Type*} [Field F] [Fintype F] (s : F) [NeZero s] :
  (definingPoly s).Monic

lemma evenize_eq_comp_x_squared {f : Polynomial F} :
    evenize f = f.comp (Polynomial.X * Polynomial.X)

theorem append_right_injective (a : Fin m ‚Üí Œ±) : Function.Injective (@Fin.append m n Œ± a)

lemma pointToIterateQuotientIndex_qMap_total_fiber_eq_self (i : Fin ‚Ñì) (steps : ‚Ñï)
    (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
    (y : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) (i := ‚ü®i + steps, by omega‚ü©)) (k : Fin (2 ^ steps)) :
    pointToIterateQuotientIndex (i := ‚ü®i, by omega‚ü©) (steps := steps) (h_i_add_steps := by omega)
      (x := ((qMap_total_fiber ùîΩq Œ≤ (i := ‚ü®i, by omega‚ü©) (steps := steps)
        (h_i_add_steps := by apply Nat.lt_add_of_pos_right_of_le; omega) (y := y) k):
          sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i, by omega‚ü©))) = k

@[simp]
theorem Set.mem_language_iff {Œ± Œ≤} (rel : Set (Œ± √ó Œ≤)) (stmt : Œ±) :
    stmt ‚àà rel.language ‚Üî ‚àÉ wit, (stmt, wit) ‚àà rel

@[simp]
private lemma x_times_oddPart'_coeff {f : Polynomial F} {n : ‚Ñï} :
    (x_times_oddPart' f).coeff n = if Odd n then f.coeff n else 0

lemma getBit_zero_of_two_mul {n : ‚Ñï} : getBit 0 (2*n) = 0

@[simp] lemma ofMvPolynomialAlgHom_X (s : œÉ) :
    ofMvPolynomialAlgHom (MvPolynomial.X s : MvPolynomial œÉ R) = (X s : P)

lemma concreteTowerAlgebraMap_succ (l r : ‚Ñï) (h_le : l ‚â§ r) :
  concreteTowerAlgebraMap (l:=l) (r:=r + 1) (h_le:=by omega) =
  (concreteTowerAlgebraMap (l:=r) (r:=r + 1) (h_le:=by omega)).comp
  (concreteTowerAlgebraMap (l:=l) (r:=r) (h_le:=by omega))

theorem vcons_inj (a b : Œ±) (v w : Fin n ‚Üí Œ±) : a ::·µõ v = b ::·µõ w ‚Üî a = b ‚àß v = w

@[simp]
lemma zero_le_relHammingDist : 0 ‚â§ Œ¥·µ£(u, v)

theorem liftContext_soundness
    {soundnessError : ‚Ñù‚â•0}
    {lens : OracleStatement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                                OuterOStmtIn OuterOStmtOut InnerOStmtIn InnerOStmtOut}
    (V : OracleVerifier oSpec InnerStmtIn InnerOStmtIn InnerStmtOut InnerOStmtOut pSpec)
    [lensSound : lens.IsSound outerLangIn outerLangOut innerLangIn innerLangOut
      (V.toVerifier.compatStatement lens)]
    (h : V.soundness init impl innerLangIn innerLangOut soundnessError) :
      (V.liftContext lens).soundness init impl outerLangIn outerLangOut soundnessError

theorem range_vconcat {Œ± : Type*} (v : Fin n ‚Üí Œ±) (a : Œ±) :
    Set.range (vconcat v a) = insert a (Set.range v)

@[simp]
private lemma leadingCoeff_E : (E œâs f p e).leadingCoeff = 1

lemma domain_injective (i : ‚Ñï) : i ‚â§ n ‚Üí Function.Injective (domain D n i)

lemma IsBerlekampWelchSolution_def
  : IsBerlekampWelchSolution e k œâs f v
  ‚Üî Matrix.mulVec (BerlekampWelchMatrix e k œâs f) v = (Rhs e œâs f)

theorem liftContext_knowledgeSoundness [Inhabited InnerStmtOut] [Inhabited InnerWitIn]
    {outerRelIn : Set (OuterStmtIn √ó OuterWitIn)} {outerRelOut : Set (OuterStmtOut √ó OuterWitOut)}
    {innerRelIn : Set (InnerStmtIn √ó InnerWitIn)} {innerRelOut : Set (InnerStmtOut √ó InnerWitOut)}
    {knowledgeError : ‚Ñù‚â•0}
    {stmtLens : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut}
    {witLens : Witness.InvLens OuterStmtIn OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    (V : Verifier oSpec InnerStmtIn InnerStmtOut pSpec)
    [lensKS : Extractor.Lens.IsKnowledgeSound outerRelIn innerRelIn outerRelOut innerRelOut
      (V.compatStatement stmtLens) (fun _ _ => True) ‚ü®stmtLens, witLens‚ü©]
    (h : V.knowledgeSoundness init impl innerRelIn innerRelOut knowledgeError) :
      (V.liftContext stmtLens).knowledgeSoundness init impl outerRelIn outerRelOut
        knowledgeError

private lemma x_times_oddPart'_eq_x_times_oddPart' {f : Polynomial F} :
    Polynomial.X * (oddPart' f) = x_times_oddPart' f

@[simp]
theorem take_append_left (T : FullTranscript pSpec‚ÇÅ) (T' : FullTranscript pSpec‚ÇÇ) :
    (T ++‚Çú T').take m (Nat.le_add_right m n) =
      T.cast rfl (by simp [ProtocolSpec.append])

theorem finSuccEquivNth_eq :
    (finSuccEquivNth R p : MvPolynomial (Fin (n + 1)) R ‚Üí+* Polynomial (MvPolynomial (Fin n) R)) =
      eval‚ÇÇHom (Polynomial.C.comp (C : R ‚Üí+* MvPolynomial (Fin n) R))
        (Fin.insertNth p Polynomial.X (Polynomial.C ‚àò X))

@[simp]
lemma deevenize_coeff {f : Polynomial F} {n : ‚Ñï} :
    (deevenize f).coeff n = f.coeff (2 * n)

@[simp]
lemma ofPolynomialAlgHom_X : ofPolynomialAlgHom (Polynomial.X : R[X]) = (X : P)

lemma BerlekampWelch_Q_ne_zero {e k : ‚Ñï}
  [NeZero n]
  {œâs f : Fin n ‚Üí F}
  {E Q : Polynomial F}
  (h_bw : BerlekampWelchCondition e k œâs f E Q)
  (h_dist : e < Œî‚ÇÄ(f, 0))
  (h_inj : Function.Injective œâs)
  : Q ‚â† 0

theorem coeff_of_toMvPolynomial_eq_coeff_of_MlPoly (p : MlPoly R n) (m : Fin n ‚Üí‚ÇÄ ‚Ñï) :
  coeff m (toMvPolynomial p) =
    if h_binary: (‚àÄ j: Fin n, m j ‚â§ 1) then
      let i_of_m: ‚Ñï := Nat.binaryFinMapToNat (m:=m) (h_binary:=h_binary)
      p[i_of_m]
    else
      0

theorem induction_heq {n n' : ‚Ñï} {motive : Fin (n + 1) ‚Üí Sort u} {motive' : Fin (n' + 1) ‚Üí Sort u}
    {zero : motive 0} {zero' : motive' 0}
    {succ : ‚àÄ i : Fin n, motive i.castSucc ‚Üí motive i.succ}
    {succ' : ‚àÄ i : Fin n', motive' i.castSucc ‚Üí motive' i.succ}
    {i : Fin (n + 1)} {i' : Fin (n' + 1)}
    (hn : n = n') (hmotive : HEq motive motive') (hzero : HEq zero zero')
    (hsucc : HEq succ succ') (hi : HEq i i') :
      HEq (induction (motive := motive) zero succ i)
        (induction (motive := motive') zero' succ' i')

theorem matchSize_eq_iff_forall_eq (l‚ÇÅ l‚ÇÇ : List Œ±) (unit : Œ±) :
    (fun (x, y) => x = y) (matchSize l‚ÇÅ l‚ÇÇ unit) ‚Üî ‚àÄ i : Nat, l‚ÇÅ.getD i unit = l‚ÇÇ.getD i unit

@[simp]
theorem LeafData.ofFun_get {Œ±} {s} (tree : LeafData Œ± s) :
    LeafData.ofFun s (fun idx => tree.get idx) = tree

@[simp] -- TODO: more general version/class for query impls that never have failures
lemma loggingOracle.probFailure_simulateQ [spec.FiniteRange] (oa : OracleComp spec Œ±) :
    [‚ä• | (simulateQ loggingOracle oa).run] = [‚ä• | oa] := by
  induction oa using OracleComp.induction with

lemma qCompositionChain_eq_foldl (i : Fin r) :
  qCompositionChain ùîΩq Œ≤ (‚Ñì:=‚Ñì) (R_rate:=R_rate) i =
  Fin.foldl (n:=i) (fun acc j =>
    (qMap ùîΩq Œ≤ ‚ü®j, by omega‚ü©).comp acc) (X)

lemma getLowBits_joinBits {n m : ‚Ñï} (low : Fin (2 ^ n)) (high : Fin (2 ^ m)) :
  getLowBits n (joinBits low high).val = low.val

@[simp]
theorem dist'_empty : ‚Äñ(‚àÖ : Set (n ‚Üí R))‚Äñ‚ÇÄ' = ‚ä§

@[simp]
theorem dcast‚ÇÇ_trans (ha : a = a') (ha' : a' = a'')
    (hb : dcast ha b = b') (hb' : dcast ha' b' = b'') :
      dcast‚ÇÇ ha' hb' (dcast‚ÇÇ ha hb c) = dcast‚ÇÇ (ha.trans ha') (by simp [‚Üê hb', ‚Üê hb]) c

theorem add_assoc {n : ‚Ñï} (a b c : CNat (n + 1)) : (a + b) + c = a + (b + c)

theorem prime_7 : Nat.Prime 7

lemma testBit_of_sub_two_pow_of_bit_1 {n i : ‚Ñï} (h_testBit_eq_1 : (n).testBit i = true) :
  (n - 2^i).testBit i = false

@[simp]
lemma seqCompose_succ {m : ‚Ñï}
    (Stmt : Fin (m + 2) ‚Üí Type) (Wit : Fin (m + 2) ‚Üí Type)
    {n : Fin (m + 1) ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (R : (i : Fin (m + 1)) ‚Üí
      Reduction oSpec (Stmt i.castSucc) (Wit i.castSucc) (Stmt i.succ) (Wit i.succ) (pSpec i)) :
    seqCompose Stmt Wit R =
      append (R 0) (seqCompose (Stmt ‚àò Fin.succ) (Wit ‚àò Fin.succ) (fun i => R (Fin.succ i)))

lemma coe_one_succ (l : ‚Ñï) :
    (@ConcreteBTFieldAlgebra (l:=l) (r:=l + 1) (h_le:=by omega)).algebraMap
    (1 : ConcreteBTField l) = (1 : ConcreteBTField (l + 1))

lemma forwardRange_length (n : ‚Ñï) (r : Fin n) (l : Fin (r.val + 1)) :
    (forwardRange n r l).length = r.val - l.val + 1

@[simp]
theorem ranges_succ {a : ‚Ñï} {l : List ‚Ñï} :
    List.ranges (a :: l) = range a :: l.ranges.map (map (a + ¬∑))

theorem support_eval [DecidableEq œÉ] {œÑ : Type*} {f : œÑ ‚Üí R} {p : R[X œÉ][X œÑ]} :
    (eval (C ‚àò f) p).support ‚äÜ p.support.biUnion (fun c => (coeff c p).support)

lemma evenize_is_even {f : Polynomial F} :
    EvenPoly (evenize f)

theorem liftContext_soundness [Inhabited InnerStmtOut]
    {outerLangIn : Set OuterStmtIn} {outerLangOut : Set OuterStmtOut}
    {innerLangIn : Set InnerStmtIn} {innerLangOut : Set InnerStmtOut}
    {soundnessError : ‚Ñù‚â•0}
    {lens : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut}
    (V : Verifier oSpec InnerStmtIn InnerStmtOut pSpec)
    -- TODO: figure out the right compatibility relation for the IsSound condition
    [lensSound : lens.IsSound outerLangIn outerLangOut innerLangIn innerLangOut
      (V.compatStatement lens)]
    (h : V.soundness init impl innerLangIn innerLangOut soundnessError) :
      (V.liftContext lens).soundness init impl outerLangIn outerLangOut soundnessError

lemma eval_normalizedW_succ_at_beta_prev (i : Fin r) (h_i_add_1 : i + 1 < r) :
  (normalizedW ùîΩq Œ≤ (i + 1)).eval (Œ≤ i) = 0

@[simp]
lemma invFun_toFun (f : F) : inst.equiv.invFun (inst.equiv.toFun f) = f

lemma rank_eq_colRank : U.rank = colRank U

theorem fconcat‚ÇÇ_right_injective {Œ±‚ÇÅ : Fin n ‚Üí A} {Œ±‚ÇÇ : Fin n ‚Üí B} {Œ≤‚ÇÅ : A} {Œ≤‚ÇÇ : B}
    (v : (i : Fin n) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i)) :
    Function.Injective (fconcat‚ÇÇ (F := F‚ÇÇ) v :
      F‚ÇÇ Œ≤‚ÇÅ Œ≤‚ÇÇ ‚Üí (i : Fin (n + 1)) ‚Üí F‚ÇÇ (Fin.vconcat Œ±‚ÇÅ Œ≤‚ÇÅ i) (Fin.vconcat Œ±‚ÇÇ Œ≤‚ÇÇ i))

theorem fcons‚ÇÇ_inj {Œ±‚ÇÅ : A} {Œ±‚ÇÇ : B} {Œ≤‚ÇÅ : Fin n ‚Üí A} {Œ≤‚ÇÇ : Fin n ‚Üí B}
    (a‚ÇÅ a‚ÇÇ : F‚ÇÇ Œ±‚ÇÅ Œ±‚ÇÇ) (b‚ÇÅ b‚ÇÇ : (i : Fin n) ‚Üí F‚ÇÇ (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) :
    fcons‚ÇÇ (F := F‚ÇÇ) a‚ÇÅ b‚ÇÅ = fcons‚ÇÇ (F := F‚ÇÇ) a‚ÇÇ b‚ÇÇ ‚Üî a‚ÇÅ = a‚ÇÇ ‚àß b‚ÇÅ = b‚ÇÇ

lemma concrete_inv_zero {k : ‚Ñï} : concrete_inv (k:=k) 0 = 0

@[simp]
theorem finSigmaFinEquiv'_apply {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (k : (i : Fin m) √ó Fin (n i)) :
    (finSigmaFinEquiv' k : ‚Ñï) = ‚àë i : Fin k.1, n (Fin.castLE k.1.isLt.le i) + k.2

theorem BitVec.extractLsb_eq_shift_ofNat {n : Nat} (x : BitVec n) (l r : Nat) :
    BitVec.extractLsb r l x = BitVec.ofNat (r - l + 1) (x.toNat >>> l)

@[simp]
theorem oracleReduction_perfectCompleteness (hInit : init.neverFails) :
    (oracleReduction oSpec Statement OStatement Witness).perfectCompleteness init impl rel rel

theorem sum_fromNat_eq_from_xor_Nat {k : ‚Ñï} (x y : Nat) :
  fromNat (k:=k) (x ^^^ y) = fromNat (k:=k) x + fromNat (k:=k) y

theorem tail_init_eq_init_tail (s : Fin (n + 2) ‚Üí‚ÇÄ M) : tail (init s) = init (tail s)

omit [Fintype L] [DecidableEq L] [Fintype ùîΩq] h_Fq_char_prime in
theorem root_U_lift_down
  (i : Fin r) (h_i_add_1 : i + 1 < r) (a : L) :
  a ‚àà (U ùîΩq Œ≤ (i+1)) ‚Üí ‚àÉ! x: ùîΩq, a - x ‚Ä¢ Œ≤ i ‚àà (U ùîΩq Œ≤ i)

@[simp]
theorem vconcat_last (v : Fin n ‚Üí Œ±) (a : Œ±) : vconcat v a (Fin.last n) = a

theorem induct [LawfulBEq R] {motive : UniPoly R ‚Üí Prop}
  (case1 : ‚àÄ p, p.trim = #[] ‚Üí (‚àÄ i, (hi : i < p.size) ‚Üí p[i] = 0) ‚Üí motive p)
  (case2 : ‚àÄ p : UniPoly R, ‚àÄ k : Fin p.size, p.trim = p.extract 0 (k + 1)
    ‚Üí p[k] ‚â† 0 ‚Üí (‚àÄ j : ‚Ñï, (hj : j < p.size) ‚Üí j > k ‚Üí p[j] = 0) ‚Üí motive p)
  (p : UniPoly R) : motive p

lemma split_join_via_add_smul_eq_iff_split {k : ‚Ñï} (h_pos : k > 0)
    (hi_btf lo_btf : ConcreteBTField (k - 1)) :
    split (k:=k) (h:=by omega) (x:=join_via_add_smul (k:=k) (h_pos:=h_pos) hi_btf lo_btf) =
      (hi_btf, lo_btf)

theorem hconcat_init_self {Œ± : Fin n.succ ‚Üí Sort u} (v : (i : Fin (n + 1)) ‚Üí Œ± i) :
    True

@[simp]
theorem fcons_one {Œ≤ : Fin (n + 1) ‚Üí A} (a : F Œ±) (v : (i : Fin (n + 1)) ‚Üí F (Œ≤ i)) :
    fcons a v 1 = v 0

lemma num_eq_highBits_xor_lowBits {n: ‚Ñï} (numLowBits: ‚Ñï) :
  n = getHighBits numLowBits n ^^^ getLowBits numLowBits n

omit [Finite F] in
lemma sqr_mem_D_succ_i_of_mem_D_i : ‚àÄ {a : FÀ£} {i : ‚Ñï},
    a ‚àà evalDomain D x i ‚Üí a ^ 2 ‚àà evalDomain D x (i + 1)

lemma roots_comp_X_sub_C (p : L[X]) (a : L) :
    (p.comp (X - C a)).roots = p.roots.map (fun r => r + a)

lemma lin_shift_d [Field F] [Fintype F]
  (h_B : 2 ‚â§ B.card)
  :
  d B = d ({x - v | x ‚àà B} : Finset _)

@[simp]
theorem verifier_last (pSpec : ProtocolSpec n) [NeZero n] [h : VerifierLast pSpec] :
    pSpec.dir ‚ü®n - 1, by simp [Nat.pos_of_neZero]‚ü© = .V_to_P

@[simp]
lemma coe_toFun_of_coe_apply (f : ‚àÄ a, Œ≤ a) (a : Œ±) : (f : F) a = f a

lemma out_of_dom_smpl_2
  {Œ¥ l : ‚Ñù‚â•0} {s : ‚Ñï} {f : Œπ ‚Üí F} {degree : ‚Ñï} {œÜ : Œπ ‚Ü™ F}
  (C : Set (Œπ ‚Üí F)) (hC : C = code œÜ degree)
  (h_decodable : listDecodable C Œ¥ l)
  (h_nonempty : Nonempty (domainComplement œÜ)) :
  listDecodingCollisionProbability œÜ f Œ¥ s degree h_nonempty ‚â§
    ((l^2 / 2)) * (degree / (Fintype.card F - Fintype.card Œπ))^s

theorem singleEqPolynomial_nf (r : R) (x : MvPolynomial œÉ R) :
    singleEqPolynomial r x = (2 * C r - 1) * x + (1 - C r)

@[csimp] lemma dfoldr_eq_dfoldr' : @dfoldr = @dfoldr'

@[simp]
lemma coeff_solutionToE :
  (solutionToE e k v).coeff n = if n = e then 1 else if n < e then liftF v n else 0

lemma add_zero {k : ‚Ñï} (a : ConcreteBTField k) : a + 0 = a

lemma rank_nonsquare_eq_deg_of_Œπ_le (inj : Function.Injective Œ±) (h : m ‚â§ n) :
  (Vandermonde.nonsquare (Œπ' := n) Œ±).rank = m

@[simp]
theorem partialSum_nil : [].partialSum = [0]

Nat.pow_lt_pow_right in Init.Data.Nat.Lemmas

Nat.two_pow_pos in Init.Data.Nat.Basic

lemma principal_is_maximal_iff_irred {F : Type} [Field F] (f : F[X]) :
  (principalIdeal f).IsMaximal ‚Üî Irreducible f

@[simp]
theorem InternalData.get_ofFun {Œ±} {s} (f : SkeletonInternalIndex s ‚Üí Œ±) :
    (InternalData.ofFun s f).get = f

@[simp]
theorem vcons_fin_zero (a : Œ±) (v : Fin 0 ‚Üí Œ±) : a ::·µõ v = fun i => match i with

@[simp] theorem equiv_refl (p : UniPoly Q) : equiv p p

@[simp]
theorem fflatten_splitSum {A : Sort u} {F : A ‚Üí Sort v} {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï}
    {Œ± : (i : Fin (vsum n)) ‚Üí A}
    (v : (k : Fin (vsum n)) ‚Üí F (Œ± k)) (k : Fin (vsum n)) :
    fflatten (fun i j => v (embedSum i j)) k = cast (by simp) (v k)

theorem split_sum_eq_sum_split {k : ‚Ñï} (h_pos : k > 0) (x‚ÇÄ x‚ÇÅ : ConcreteBTField k)
  (hi‚ÇÄ lo‚ÇÄ hi‚ÇÅ lo‚ÇÅ : ConcreteBTField (k - 1))
  (h_split_x‚ÇÄ : split h_pos x‚ÇÄ = (hi‚ÇÄ, lo‚ÇÄ))
  (h_split_x‚ÇÅ : split h_pos x‚ÇÅ = (hi‚ÇÅ, lo‚ÇÅ)) :
  split h_pos (x‚ÇÄ + x‚ÇÅ) = (hi‚ÇÄ + hi‚ÇÅ, lo‚ÇÄ + lo‚ÇÅ)

NeZero.ne in Init.Data.NeZero

@[simp]
theorem seqCompose_zero {n : Fin 0 ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    {T : ‚àÄ i, FullTranscript (pSpec i)} :
    seqCompose T = !h[]

@[simp]
theorem fflatten‚ÇÇ_embedSum {A : Sort u} {B : Sort v} {F : A ‚Üí B ‚Üí Sort w} {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï}
    {Œ± : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí A}
    {Œ≤ : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí B}
    (v : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí F (Œ± i j) (Œ≤ i j)) (i : Fin m) (j : Fin (n i)) :
    fflatten‚ÇÇ v (embedSum i j) = cast (by simp) (v i j)

omit [NoZeroDivisors ùîΩ] in
lemma splitNth_degree_le {n : ‚Ñï} {f : ùîΩ[X]} [inst : NeZero n] :
  ‚àÄ {i}, (splitNth f n i).natDegree ‚â§ f.natDegree / n

lemma exists_unique_bivariate
  (qPoly : Polynomial F) (hdeg_q_min : qPoly.natDegree > 0)
  (hdeg_q_max : qPoly.natDegree < Fintype.card F) (fPoly : Polynomial F) :
    -- Q ‚àà ùîΩ[X,Y]
    ‚àÉ! Q : MvPolynomial (Fin 2) F,
      -- deg_x(Q) = Floor ( deg(fPoly) / deg(qPoly) )
      -- This is natural number division towards zero, which is floor
      (MvPolynomial.degreeOf 0 Q = (Polynomial.natDegree fPoly) / (Polynomial.natDegree qPoly)) ‚àß
      -- deg_y(Q) < deg (q)
      (MvPolynomial.degreeOf 1 Q < Polynomial.natDegree qPoly) ‚àß
      -- point‚Äëwise equality on F: f(z) = Q(q(z), z)
      (‚àÄ z : F, Polynomial.eval z fPoly = evalBivar Q (Polynomial.eval z qPoly) z) ‚àß
      (‚àÄ t : ‚Ñï, fPoly.natDegree < t * qPoly.natDegree ‚Üí MvPolynomial.degreeOf 0 Q < t)

@[simp]
lemma foldl'_succ {n : ‚Ñï} {Œ± : Type u} (f : (i : Fin (n + 1)) ‚Üí Œ± ‚Üí Œ±) (x : Œ±) :
    foldl' (n + 1) f x = f (last n) (foldl' n (fun i => f i.castSucc) x)

lemma sDomainBasisVectors_mem_sDomain (i : Fin r) (k : Fin (‚Ñì + R_rate - i)) :
  sDomainBasisVectors ùîΩq Œ≤ h_‚Ñì_add_R_rate i k
    ‚àà sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i

theorem liftContext_run
    {lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    {outerStmtIn : OuterStmtIn} {outerWitIn : OuterWitIn}
    {R : Reduction oSpec InnerStmtIn InnerWitIn InnerStmtOut InnerWitOut pSpec} :
      (R.liftContext lens).run outerStmtIn outerWitIn = do
        let ‚ü®‚ü®fullTranscript, innerCtxOut‚ü©, verInnerStmtOut‚ü© ‚Üê
          R.run.uncurry (lens.proj (outerStmtIn, outerWitIn))
        return ‚ü®‚ü®fullTranscript, lens.lift (outerStmtIn, outerWitIn) innerCtxOut‚ü© ,
                lens.stmt.lift outerStmtIn verInnerStmtOut‚ü©

theorem split_bitvec_eq_iff_fromNat {k : ‚Ñï} (h_pos : k > 0) (x : ConcreteBTField k)
  (hi_btf lo_btf : ConcreteBTField (k - 1)) :
  split h_pos x = (hi_btf, lo_btf) ‚Üî
  (hi_btf = fromNat (k:=k - 1) (x.toNat >>> 2 ^ (k - 1)) ‚àß
  lo_btf = fromNat (k:=k - 1) (x.toNat &&& (2 ^ (2 ^ (k - 1)) - 1)))

theorem basis_repr_of_sDomain_lift (i j : Fin r) (h_j : j < ‚Ñì + R_rate) (h_le : i ‚â§ j)
    (y : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := j)) :
    let x‚ÇÄ := sDomain.lift ùîΩq Œ≤ h_‚Ñì_add_R_rate i j (by omega) (by omega) y
    ‚àÄ k: Fin (‚Ñì + R_rate - i),
      (sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := i) (h_i := by omega)).repr x‚ÇÄ k =
        if hk: k < (j.val - i.val) then 0
        else (sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := j)
          (h_i := by omega)).repr y ‚ü®k - (j.val - i.val), by omega‚ü©

lemma liftF_ne_zero_of_lt {i : ‚Ñï} (h : i < n) : liftF f' i ‚â† 0 ‚Üî f' ‚ü®i, h‚ü© ‚â† 0

@[simp]
lemma finite_offDiag [Finite F] : C.offDiag.Finite

theorem finSuccEquivNth_apply (f : MvPolynomial (Fin (n + 1)) R) :
    finSuccEquivNth R p f =
      eval‚ÇÇHom (Polynomial.C.comp (C : R ‚Üí+* MvPolynomial (Fin n) R))
        (Fin.insertNth p Polynomial.X (Polynomial.C ‚àò X)) f

@[simp]
lemma lin_shift_hamming_distance [Field F] {x‚ÇÅ x‚ÇÇ v : Fin n ‚Üí F}
  :
  Œî‚ÇÄ(x‚ÇÅ - v, x‚ÇÇ - v) = Œî‚ÇÄ(x‚ÇÅ, x‚ÇÇ)

omit [DecidableEq Œ±] [Inhabited Œ±] [Fintype Œ±] in
@[simp]
lemma Cache.leaves_cons (n : ‚Ñï) (leaves : List.Vector Œ± (2 ^ (n + 1))) (cache : Cache Œ± n) :
    Cache.leaves Œ± n (Cache.cons Œ± n leaves cache) = leaves

@[simp] theorem ofNat_toNat (t : AssocNat) : ofNat (toNat t) = t

theorem congrArg‚ÇÑ {Œ± Œ≤ Œ≥ Œ¥ Œµ : Sort*} {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥ ‚Üí Œ¥ ‚Üí Œµ} {a a' : Œ±} {b b' : Œ≤} {c c' : Œ≥}
    {d d' : Œ¥} (h : a = a') (h' : b = b') (h'' : c = c') (h''' : d = d') :
      f a b c d = f a' b' c' d'

@[grind]
lemma quotient_nezero {f q : F[X][Y]} (hg : q * f ‚â† 0) : q ‚â† 0

@[simp]
theorem fcons_succ {Œ≤ : Fin n ‚Üí A} (a : F Œ±) (v : (i : Fin n) ‚Üí F (Œ≤ i)) (i : Fin n) :
    fcons a v i.succ = cast (by simp [vcons_succ]) (v i)

@[simp]
theorem seqCompose_zero {n : Fin 0 ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)} :
    seqCompose pSpec = !p[]

theorem degrees_C_mul_le (p : MvPolynomial œÉ R) (c : R) : (C c * p).degrees ‚â§ p.degrees

protected lemma errors_are_roots_of_elocPoly {i : ‚Ñï}
  (hi : i < n) (h : f i ‚â† p.eval (œâs i)) : (ElocPoly n œâs f p).eval (œâs i) = 0

@[simp]
theorem ConcreteBTField.RingHom_comp_cast {Œ± Œ≤ Œ≥ Œ¥ : ‚Ñï}
    (f : ConcreteBTField Œ± ‚Üí+* ConcreteBTField Œ≤)
    (g : ConcreteBTField Œ≤ ‚Üí+* ConcreteBTField Œ≥) (h : Œ≥ = Œ¥) :
    ((cast (ConcreteBTField.RingHom_eq_of_dest_eq (k:=Œ≤) (m:=Œ≥) (n:=Œ¥) h) g).comp f)
    = cast (ConcreteBTField.RingHom_eq_of_dest_eq (k:=Œ±) (m:=Œ≥) (n:=Œ¥) h) (g.comp f)

lemma Fin.val_add_one' (a : Fin r) (h_a_add_1 : a + 1 < r) : (a + 1).val = a.val + 1

Nat.sub_lt_left_of_lt_add in Init.Data.Nat.Basic

lemma getMiddleBits_lt_two_pow {n offset len : ‚Ñï} :
  getMiddleBits offset len n < 2 ^ len

@[simp]
theorem BTField.RingHom_cast_dest_AdjoinRoot_apply (k m : ‚Ñï)
  (f : BTField k ‚Üí+* AdjoinRoot (poly m)) (x : BTField k) :
  (cast (BTField.RingHom_eq_of_dest_AdjoinRoot_eq (k:=k) (m:=m)).symm f) x
  = cast (BTField_succ_eq_adjoinRoot m) (f x)

theorem add_assoc (a b c : AssocNat) : (a + b) + c = a + (b + c)

@[simp]
theorem MLE_eval_zeroOne (x : œÉ ‚Üí Fin 2) (evals : (œÉ ‚Üí Fin 2) ‚Üí R) :
    MvPolynomial.eval (x : œÉ ‚Üí R) (MLE evals) = evals x

theorem oracleVerifier_rbrKnowledgeSoundness [Fintype R] :
    (oracleReduction R deg oSpec).verifier.rbrKnowledgeSoundness init impl
      (inputRelation R deg D) (outputRelation R deg)
        (fun _ => (deg : ‚Ñù‚â•0) / (Fintype.card R))

@[simp]
theorem drop_all (v : (i : Fin n) ‚Üí Œ± i) :
    drop n n.le_refl v = fun i => Fin.elim0 (i.cast (Nat.sub_self n))

@[simp]
lemma numFullRounds_dvd_by_2 : 2 ‚à£ params.numFullRounds

@[simp]
theorem vflatten_splitSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (v : (k : Fin (vsum n)) ‚Üí Œ±) (k : Fin (vsum n)) :
    vflatten (fun i j => v (embedSum i j)) k = v k

omit [Finite F] in
lemma domain_surjective (i : ‚Ñï) : i ‚â§ n ‚Üí Function.Surjective (domain D n i)

@[simp]
theorem append_cast_left {n m : ‚Ñï} {pSpec : ProtocolSpec n} {pSpec' : ProtocolSpec m} (n' : ‚Ñï)
    (h : n + m = n' + m) :
      dcast h (pSpec ++‚Çö pSpec') = (dcast (Nat.add_right_cancel h) pSpec) ++‚Çö pSpec'

theorem induction_append_right {m n : ‚Ñï} {motive : Fin (m + n + 1) ‚Üí Sort*} {zero : motive 0}
  {succ : ‚àÄ i : Fin (m + n), motive i.castSucc ‚Üí motive i.succ} {i : Fin (n + 1)} :
    induction zero succ (i.natAdd m) =
      @induction n (fun i => motive (i.natAdd m))
        (@induction m (fun j => motive (Fin.cast (by omega) (j.castAdd n)))
          zero (fun j x => succ (j.castAdd n) x) (last m))
        (fun i x => succ (i.natAdd m) x) i

theorem append_right_injective {pSpec : ProtocolSpec m} :
    Function.Injective (@ProtocolSpec.append m n pSpec)

theorem mul_zero (n : ChurchNat Œ±) : mul n zero = zero

lemma getBit_of_multiple_of_power_of_two {n p : ‚Ñï}: ‚àÄ k,
  getBit (k) (2^p * n) = if k < p then 0 else getBit (k-p) n

lemma rateOfLinearCode_eq_div [NeZero n] (inj : Function.Injective Œ±) (h : n ‚â§ m) :
  rate (ReedSolomon.code ‚ü®Œ±, inj‚ü© n) = n / m

lemma normalizedW_eq_qMap_composition (‚Ñì R_rate : ‚Ñï) (i : Fin r) :
    normalizedW ùîΩq Œ≤ i = qCompositionChain ùîΩq Œ≤ (‚Ñì:=‚Ñì) (R_rate:=R_rate) i
</all_available_lemmas>

<local_ctx>
import ArkLib.Data.MvPolynomial.LinearMvExtension

import ArkLib.Data.Polynomial.Interface

import Mathlib.LinearAlgebra.Lagrange

import Mathlib.RingTheory.Henselian

namespace ReedSolomon

open Polynomial NNReal

variable {F : Type*} {Œπ : Type*} (domain : Œπ ‚Ü™ F)

def evalOnPoints [Semiring F] : F[X] ‚Üí‚Çó[F] (Œπ ‚Üí F) where
  toFun := fun p => fun x => p.eval (domain x)
  map_add' := fun x y => by admit /- proof elided -/

def code (deg : ‚Ñï) [Semiring F]: Submodule F (Œπ ‚Üí F) :=
  (Polynomial.degreeLT F deg).map (evalOnPoints domain)

variable [Semiring F]

end ReedSolomon

open Polynomial Matrix Code LinearCode

variable {F Œπ Œπ' : Type*}
         {C : Set (Œπ ‚Üí F)}

noncomputable section

namespace Vandermonde

def nonsquare [Semiring F] (Œπ' : ‚Ñï) (Œ± : Œπ ‚Üí F) : Matrix Œπ (Fin Œπ') F :=
  Matrix.of fun i j => (Œ± i) ^ j.1

section

variable [CommRing F] {m n : ‚Ñï} {Œ± : Fin m ‚Üí F}

section

variable [IsDomain F]

end

end

end Vandermonde

namespace ReedSolomonCode

section

open Finset Function

open scoped BigOperators

variable {Œπ : Type*} [Fintype Œπ] [Nonempty Œπ]
         {F : Type*} [Field F] [Fintype F]

abbrev RScodeSet (domain : Œπ ‚Ü™ F) (deg : ‚Ñï) : Set (Œπ ‚Üí F) := (ReedSolomon.code domain deg).carrier

open Classical in

def toFinset (domain : Œπ ‚Ü™ F) (deg : ‚Ñï) : Finset (Œπ ‚Üí F) :=
  (RScodeSet domain deg).toFinset

end

section

variable {deg m n : ‚Ñï} {Œ± : Fin m ‚Üí F}

section

variable [Semiring F] {p : F[X]}

end

open LinearCode

section

open NNReal

variable [Field F]

end

section

def constantCode {Œ± : Type*} (x : Œ±) (Œπ' : Type*) [Fintype Œπ'] : Œπ' ‚Üí Œ± := fun _ ‚Ü¶ x

variable [Semiring F] {x : F} [Fintype Œπ] {Œ± : Œπ ‚Ü™ F}

end

open Finset in
</local_ctx>

<target_theorem>
theorem minDist [Field F] [DecidableEq F] (inj : Function.Injective Œ±) [NeZero n] (h : n ‚â§ m) :
  minDist ((ReedSolomon.code ‚ü®Œ±, inj‚ü© n) : Set (Fin m ‚Üí F)) = m - n + 1 :=
</target_theorem>

