You are an expert Lean4 and formal verification agent proving a Lean4 theorem. Your output **must** strictly adhere to the specified format.

### Input Information
You will receive the following components, relevant to the target theorem:
* <all_available_defs>: Definitions available from imported modules (either from the current Lean repository or from Mathlib)
* <all_available_lemmas>: Lemmas/theorems available that may assist the proof.
* <local_ctx>...</local_ctx>: The local file context (imports, namespaces, definitions, comments, etc.) from the top of the file up to‚Äîbut not including‚Äîthe target theorem or any previously defined local lemmas/theorems.
* <target_theorem>...</target_theorem>: The target theorem statement, ending with `:=`.

**Notes**
1. Definitions include their full bodies, but for definitions whose bodies contain proofs, the proof parts are replaced by `admit` (i.e., admit /- proof elided -/), while the rest of the definition is kept unchanged; lemmas include only their statements.
2. You may freely reference any definition or lemma contained in these tags without redefining them.
3. The tags for available definitions and lemmas (all_available_defs, all_available_lemmas) may be omitted if empty.

### Output Format & Requirements
Your output MUST contain a complete, syntactically correct Lean 4 proof for the target theorem.

**Strict Output Structure:**
<reasoning> 
...
</reasoning> 

<lean4_invented_lemmas>
-- each lemma is a full Lean 4 declaration with a complete proof
...
</lean4_invented_lemmas>

<lean4_proof>
-- Lean 4 proof body of the target theorem
...
</lean4_proof>

**Requirements:**
1. <reasoning> and <lean4_invented_lemmas> are OPTIONAL. Include them only if they aid proof construction.
2. <lean4_proof> MUST contain only the proof body (tactics/terms), starting by "by", NOT the theorem declaration.
3. <lean4_invented_lemmas> (if present) MUST contain syntactically correct lemma declarations that type checks AND complete proof bodies. Defining a lemma using `axiom` is NOT allowed.
4. <reasoning> contains high-level proof planning.
5. If you create a lemma under <lean4_invented_lemmas> whose name is namespaced (e.g., X.Y.Z), you MUST always refer to it using its fully qualified name. Do NOT rely on shortened names. For example, write rw [X.Y.Z], not rw [Z] for invented lemmas.
6. All Lean 4 code MUST be syntactically correct. No `sorry`, `admit`, or non-Lean text. Comments allowed using `--` or `/- ... -/`.
7. Follow the tags and structure EXACTLY. No extra text before, between, or after the sections.
8. Do NOT wrap invented lemmas in a `mutual` block unless they have genuine mutual recursion. Declare each lemma independently.

### Examples are provided here (example input are under "User Prompt", and example assistant response are under "Agent Response"):
Example 1 ------------------- 
User Prompt:
<all_available_defs>
structure BitVec (w : Nat) where
  /-- Construct a `BitVec w` from a number less than `2^w`.
  O(1), because we use `Fin` as the internal representation of a bitvector. -/
  ofFin ::

  /-- Interpret a bitvector as a number less than `2^w`.
  O(1), because we use `Fin` as the internal representation of a bitvector. -/
  toFin : Fin (hPow 2 w)
</all_available_defs>

<all_available_lemmas>
theorem List.getElem_append_left{Œ± : Type u_1} {l‚ÇÅ l‚ÇÇ : List Œ±} {i : Nat} (hn : i < l‚ÇÅ.length) : (l‚ÇÅ ++ l‚ÇÇ)[i] = l‚ÇÅ[i]
theorem getElem_eq_testBit_toNat (x : BitVec w) (i : Nat) (h : i < w) :
  x[i] = x.toNat.testBit i := rfl
@[simp, grind =] theorem toNat_cons (b : Bool) (x : BitVec w) :
    (cons b x).toNat = (b.toNat <<< w) ||| x.toNat
@[simp, grind =] theorem getLsbD_of_ge (x : BitVec w) (i : Nat) (ge : w ‚â§ i) : getLsbD x i = false
theorem testBit_toNat (x : BitVec w) : x.toNat.testBit i = x.getLsbD i
</all_available_lemmas>

<local_ctx>
import Mathlib.Computability.NFA
import Mathlib.Data.FinEnum
import Mathlib.Data.Rel
import Mathlib.Data.Vector.Basic
import Blase.AutoStructs.ForLean

open Set
open Mathlib
open SetRel

-- this is better because card is defeq to n
instance (Œ± : Type) : Inter (Language Œ±) := ‚ü®Set.inter‚ü©
instance (Œ± : Type) : Union (Language Œ±) := ‚ü®Set.union‚ü©

/--
The set of `n`-tuples of bit vectors of an arbitrary width.
-/
structure BitVecs (n : Nat) where
  w : Nat
  bvs : List.Vector (BitVec w) n

def BitVecs.cast (bvs : BitVecs n) (h : n = n') : BitVecs n' :=
  { w := bvs.w, bvs := h ‚ñ∏ bvs.bvs }

abbrev BitVecs.empty : BitVecs n := ‚ü®0, List.Vector.replicate n .nil‚ü©
abbrev BitVecs.singleton {w : Nat} (bv : BitVec w) : BitVecs 1 := ‚ü®w, bv ::·µ• .nil‚ü©
abbrev BitVecs.pair {w : Nat} (bv1 bv2 : BitVec w) : BitVecs 2 := ‚ü®w, bv1 ::·µ• bv2 ::·µ• .nil‚ü©

/--
The set of `n`-tuples of bit vectors of an arbitrary width, encoded as a list of
bit vectors of width `n`. The width of the encoded bit vectors is the length of
the list.
-/
abbrev BitVecs' (n : Nat) := List (BitVec n)

@[simps]
def dec (bvs' : BitVecs' n) : BitVecs n where
  w := bvs'.length
  bvs := List.Vector.ofFn fun k => BitVec.ofFn fun i => bvs'[i].getLsbD k

@[simp]
</local_ctx>

<target_theorem>
lemma dec_snoc n (bvs' : BitVecs' n) (a : BitVec n) :
  dec (bvs' ++ [a]) =
    { w := bvs'.length + 1
      bvs := List.Vector.ofFn fun k =>
        BitVec.cons (a.getLsbD k) ((dec bvs').bvs.get k) } :=
</target_theorem>

Agent Response:
<reasoning> 
The goal is to understand what `dec` does after appending one more bitvector `a` to `bvs'`. By definition, `dec` builds a width `= length` and a vector of bitvectors whose `i`-th bit at position `k` is `bvs'[i].getLsbD k`. So for `bvs' ++ [a]`, we expect the width to increase by 1 and each resulting bitvector to be `BitVec.cons` of the new bit coming from `a`.

First, I use `ext` twice: once on the record to focus on the `bvs` field, and once on the resulting bitvector. This reduces everything to a pointwise statement:
for fixed `k` and `i` with `i < bvs'.length + 1`,
the bit `(bvs' ++ [a])[i].getLsbD k` should match the bit at index `i` of `BitVec.cons (a.getLsbD k) ((dec bvs').bvs.get k)`.

At this point I need a clean description of indexing into `BitVec.cons`: if we have `x : BitVec n`, then `(cons b x)[i]` should give `b` at the new ‚Äúlast‚Äù index `n` and `x[i]` otherwise. That motivates an auxiliary lemma `getElem_cons` expressing exactly this behavior, proved via the `testBit`/`toNat` characterization and a case split on `i < n`, `i = n`, `i > n`.

Using `getElem_cons`, the RHS becomes an `if` on whether `i = bvs'.length`. So I split into cases:
- If `i = bvs'.length`, then `(bvs' ++ [a])[i]` is the appended `a`, so both sides reduce to `a.getLsbD k`.
- If `i ‚â† bvs'.length`, the bound `i < bvs'.length + 1` forces `i < bvs'.length`. Then `(bvs' ++ [a])[i] = bvs'[i]` by `List.getElem_append_left`, and the RHS takes the ‚Äúelse‚Äù branch and likewise gives the bit from `bvs'[i]`. In both subcases, `simp` (plus the definition of `dec`) finishes.

So the whole proof is: `ext` to bit level, unfold `dec` with `simp_all`, rewrite with `getElem_cons`, split on the boundary index `i = length bvs'`, and in the ‚Äú< length‚Äù branch use `List.getElem_append_left` and bounds to line up both sides.
</reasoning> 

<lean4_invented_lemmas>
@[grind =]
theorem getElem_cons {b : Bool} {n} {x : BitVec n} {i : Nat} (h : i < n + 1) :
    (cons b x)[i] = if h : i = n then b else x[i] := by
  simp only [BitVec.getElem_eq_testBit_toNat, BitVec.toNat_cons, Nat.testBit_or]
  rw [Nat.testBit_shiftLeft]
  rcases Nat.lt_trichotomy i n with i_lt_n | i_eq_n | n_lt_i
  ¬∑ have p1 : ¬¨(n ‚â§ i) := by omega
    have p2 : i ‚â† n := by omega
    simp [p1, p2]
  ¬∑ simp only [i_eq_n, ge_iff_le, Nat.le_refl, decide_true, Nat.sub_self, Nat.testBit_zero,
    Bool.true_and, BitVec.testBit_toNat, BitVec.getLsbD_of_ge, Bool.or_false]
    cases b <;> trivial
  ¬∑ have p1 : i ‚â† n := by omega
    have p2 : i - n ‚â† 0 := by omega
    simp [p1, p2, Nat.testBit_bool_toNat]
</lean4_invented_lemmas>

<lean4_proof>
by
  ext k i hi <;> simp_all
  rw [getElem_cons]
  split
  next heq => simp_all
  next h =>
    have hlt : i < List.length bvs' := by simp at hi; omega
    rw [List.getElem_append_left hlt]
    simp
</lean4_proof>

### Your task:
<all_available_defs>
Eq in Init.Prelude
id in Init.Prelude
BitVec in Init.Prelude
Nat in Init.Prelude
BitVec.cast in Init.Data.BitVec.Basic
BitVec.zero in Init.Data.BitVec.Basic
BitVec.append in Init.Data.BitVec.Basic
BitVec.extractLsb in Init.Data.BitVec.Basic
BitVec.xor in Init.Data.BitVec.Basic
AddCommGroup in Mathlib.Algebra.Group.Defs
Int in Init.Data.Int.Basic
Int.negSucc in Init.Data.Int.Basic
Ring in Mathlib.Algebra.Ring.Defs
DivisionRing in Mathlib.Algebra.Field.Defs
NNRat in Mathlib.Data.Rat.Init
NNRat.castRec in Mathlib.Algebra.Field.Defs
Rat in Init.Data.Rat.Basic
Rat.castRec in Mathlib.Algebra.Field.Defs
Field in Mathlib.Algebra.Field.Defs
Finset in Mathlib.Data.Finset.Defs
Finset.range in Mathlib.Data.Finset.Range
Polynomial.C in Mathlib.Algebra.Polynomial.Basic
Polynomial.X in Mathlib.Algebra.Polynomial.Basic
AdjoinRoot.instField in Mathlib.RingTheory.AdjoinRoot
Fintype in Mathlib.Data.Fintype.Defs
Fintype.card in Mathlib.Data.Fintype.Card
Irreducible in Mathlib.Algebra.Group.Irreducible.Defs
List in Init.Prelude
List.Vector in Mathlib.Data.Vector.Defs
NeZero in Init.Data.NeZero
Polynomial in Mathlib.Algebra.Polynomial.Basic
AdjoinRoot in Mathlib.RingTheory.AdjoinRoot
AdjoinRoot.of in Mathlib.RingTheory.AdjoinRoot
AdjoinRoot.root in Mathlib.RingTheory.AdjoinRoot
Eq.mp in Init.Core
CharP in Mathlib.Algebra.CharP.Defs
DivisionSemiring in Mathlib.Algebra.Field.Defs
Finset.Icc in Mathlib.Order.Interval.Finset.Defs
GroupWithZero in Mathlib.Algebra.GroupWithZero.Defs
Ne in Init.Core
Equiv in Mathlib.Logic.Equiv.Defs
Equiv.ofBijective in Mathlib.Logic.Equiv.Defs
Fact in Mathlib.Logic.Basic
Fintype.ofEquiv in Mathlib.Data.Fintype.OfMap
Function.Bijective in Mathlib.Logic.Function.Defs
Function.Injective in Init.Data.Function
Function.Surjective in Init.Data.Function
Polynomial.Monic in Mathlib.Algebra.Polynomial.Degree.Definitions
Polynomial.eval‚ÇÇ in Mathlib.Algebra.Polynomial.Eval.Defs
Prod in Init.Prelude
Semiring in Mathlib.Algebra.Ring.Defs
Fintype.ofFinite in Mathlib.Data.Fintype.EquivFin
List.Vector.cons in Mathlib.Data.Vector.Defs
List.Vector.nil in Mathlib.Data.Vector.Defs
toFun in ToMathlib.Control.Monad.Hom
Algebra in Mathlib.Algebra.Algebra.Defs
RingHom in Mathlib.Algebra.Ring.Hom.Defs
RingHom.toAlgebra in Mathlib.Algebra.Algebra.Defs
invFun in ToMathlib.Control.Monad.Equiv
left_inv in ToMathlib.Control.Monad.Equiv
right_inv in ToMathlib.Control.Monad.Equiv
False.elim in Init.Prelude
Finite in Mathlib.Data.Finite.Defs
absurd in Init.Prelude
instAlgebra in Mathlib.LinearAlgebra.TensorAlgebra.Basic
instFintypeProd in Mathlib.Data.Fintype.Prod
reduceDIte in Lean.Meta.Tactic.Simp.BuiltinSimprocs.Core
RingHom.id in Mathlib.Algebra.Ring.Hom.Defs
CommSemiring in Mathlib.Algebra.Ring.Defs
Preorder in Mathlib.Order.Defs.PartialOrder
algebraMap in Mathlib.Algebra.Algebra.Defs
CommMonoid in Mathlib.Algebra.Group.Defs
Fin in Init.Prelude
Module.Basis in Mathlib.LinearAlgebra.Basis.Defs
Algebra.algebraMap in Mathlib.Algebra.Algebra.Defs
Module.Basis.mk in Mathlib.LinearAlgebra.Basis.Basic
Set in Mathlib.Data.Set.Defs
Submodule in Mathlib.Algebra.Module.Submodule.Defs
PowerBasis in Mathlib.RingTheory.PowerBasis
gen in VCVio.CryptoFoundations.FiatShamir
minpoly in Mathlib.FieldTheory.Minpoly.Basic
IsUnit in Mathlib.Algebra.Group.Units.Defs
Polynomial.leadingCoeff in Mathlib.Algebra.Polynomial.Degree.Definitions
BitVec.ofNat in Init.Prelude
BitVec.extractLsb' in Init.Data.BitVec.Basic
BitVec.setWidth in Init.Data.BitVec.Basic
cast in Init.Prelude
And in Init.Prelude
OfNat in Init.Prelude
pos in ToMathlib.Control.Comonad.Instances
BitVec.toNat in Init.Prelude
Polynomial.aeval in Mathlib.Algebra.Polynomial.AlgebraMap
MonoidHom in Mathlib.Algebra.Group.Hom.Defs
OneHom in Mathlib.Algebra.Group.Hom.Defs

notation : 10 "GF(" term : 10 ")" => GaloisField term 1

class DCast (Œ± : Sort*) (Œ≤ : Œ± ‚Üí Sort*) where
  dcast : ‚àÄ {a a' : Œ±}, a = a' ‚Üí Œ≤ a ‚Üí Œ≤ a'
  dcast_id : ‚àÄ {a : Œ±}, dcast (Eq.refl a) = id

@[simp]
def sumZeroIffEq (k : ‚Ñï) : ‚àÄ (x y : BTField k),
  x + y = 0 ‚Üî x = y := (BinaryTowerAux k).2.sumZeroIffEq

@[simp]
def BTField (k : ‚Ñï) := (BinaryTowerAux k).1

def BinaryTowerAux (k : ‚Ñï) : (Œ£' (F : Type 0), BinaryTowerResult F k) :=
  match k with
  | 0 => 
    let curBTField := GF(2)
    let newList : List.Vector (GF(2)) 1 := List.Vector.cons (1 : GF(2)) List.Vector.nil
    let specialElement : GF(2) := newList.1.headI
    let firstElementOfVecIsSpecialElement : newList.1.headI = specialElement := rfl
    let specialElementIs1 : specialElement = 1 := by admit /- proof elided -/

structure BinaryTowerInductiveStepResult (k : ‚Ñï) (prevBTField : Type _)
  (prevBTResult : BinaryTowerResult prevBTField k) [instPrevBTFieldIsField : Field prevBTField]
  (prevPoly : Polynomial prevBTField) (F : Type _) where
  binaryTowerResult : BinaryTowerResult F (k+1)
  eq_adjoin : F = AdjoinRoot prevPoly
  u_is_root : Eq.mp (eq_adjoin) binaryTowerResult.specialElement = AdjoinRoot.root prevPoly
  eval_defining_poly_at_root : Eq.mp (eq_adjoin) binaryTowerResult.specialElement^2 +
    Eq.mp (eq_adjoin) binaryTowerResult.specialElement * (of prevPoly) prevBTResult.specialElement
    + 1 = 0

structure BinaryTowerResult (F : Type _) (k : ‚Ñï) where
  vec : (List.Vector F (k + 1))
  instField : (Field F)
  instFintype : Fintype F
  specialElement : F
  specialElementNeZero : NeZero specialElement
  firstElementOfVecIsSpecialElement [Inhabited F] : vec.1.headI = specialElement
  instIrreduciblePoly : (Irreducible (p := (definingPoly specialElement)))
  sumZeroIffEq : ‚àÄ (x y : F), x + y = 0 ‚Üî x = y
  fieldFintypeCard : Fintype.card F = 2^(2^k)
  traceMapEvalAtRootsIs1 : TraceMapProperty F specialElement k

@[simp]
instance Inhabited (k : ‚Ñï) : Inhabited (BTField k) where
  default := (0 : BTField k)

structure TraceMapProperty (F : Type*) [Field F] (u : F) (k : ‚Ñï) : Prop where
  element_trace : ‚àë i ‚àà Finset.range (2 ^ k), u ^ (2 ^ i) = 1
  inverse_trace : ‚àë i ‚àà Finset.range (2 ^ k), (u‚Åª¬π) ^ (2 ^ i) = 1

noncomputable def definingPoly {F : Type*} [instField : Field F] (s : F)
  := X ^ 2 + C s * X + 1

def binary_tower_inductive_step
  (k : Nat)
  (prevBTField : Type _) [Field prevBTField]
  (prevBTResult : BinaryTowerResult prevBTField k)
: Œ£' (F : Type _), BinaryTowerInductiveStepResult (k:=k) (prevBTField:=prevBTField)
  (prevBTResult:=prevBTResult) (prevPoly:=definingPoly (F:=prevBTField)
    (instField:=prevBTResult.instField) (s:=prevBTResult.specialElement)) (F:=F)
  (instPrevBTFieldIsField:=prevBTResult.instField) :=

def AlgebraTowerEquiv.symm (e : AlgebraTowerEquiv A B) : AlgebraTowerEquiv B A where
  toRingEquiv := fun i => (e.toRingEquiv i).symm
  commutesLeft' := fun i j h r => by admit /- proof elided -/

structure AlgebraTowerEquiv (A : Œπ ‚Üí Type*) [‚àÄ i, CommSemiring (A i)] [a : AlgebraTower A]
  (B : Œπ ‚Üí Type*) [‚àÄ i, CommSemiring (B i)] [b : AlgebraTower B]
  where
    toRingEquiv : ‚àÄ i, (A i ‚âÉ+* B i)
    commutesLeft' : ‚àÄ (i j : Œπ) (h : i ‚â§ j) (r : A i),
      (b.algebraMap (i:=i) (j:=j) (h:=h)) ((toRingEquiv i) r) =
      (toRingEquiv j) (a.algebraMap (i:=i) (j:=j) (h:=h) r)

structure SpecialElementRelation {F_prev : Type*} [Field F_prev] (t1 : F_prev)
  {F_cur : Type*} [Field F_cur] (u : F_cur) [Algebra F_prev F_cur] : Prop where
    sum_inv_eq : u + u‚Åª¬π = algebraMap F_prev F_cur t1
    h_u_square : u^2 = u * (algebraMap F_prev F_cur t1) + 1

instance irreducible_quadratic_defining_poly_of_traceMap_eq_1
  {F : Type*} [Field F] [Fintype F] [CharP F 2] (s : F) [NeZero s] (k : ‚Ñï)
  (trace_map_prop : TraceMapProperty F s k)
  (fintypeCard : Fintype.card F = 2 ^ (2 ^ k))
  : Irreducible (definingPoly s) :=

instance charP_eq_2_of_add_self_eq_zero {F : Type*} [Field F]
    (sumZeroIffEq : ‚àÄ (x y : F), x + y = 0 ‚Üî x = y) : CharP F 2 :=
  have h_two : (2 : (F)) = 0 := by admit /- proof elided -/

def coeff.{u} {F : Type u} [Semiring F] (f : F[X][Y]) (i j : ‚Ñï) : F := (f.coeff j).coeff i

instance GF_2_fintype : Fintype (GF(2)) := Fintype.ofFinite (GF(2))

@[simp]
instance AlgebraTower.toIsScalarTower (a : AlgebraTower C) {i j k : Œπ}
    (h1 : i ‚â§ j) (h2 : j ‚â§ k) :
    letI : Algebra (C i) (C j) :=

@[simp]
def AlgebraTower.toAlgebra {i j : Œπ} (h : i ‚â§ j) : Algebra (A i) (A j) :=
  (AlgebraTower.algebraMap (i:=i) (j:=j) (h:=h)).toAlgebra

def example1 : ChurchVec ‚Ñï := churchCons 1 (churchCons 2 (churchCons 3 churchNil))

example : toList example1 = [1, 2, 3] := rfl

def domainEnum (i : Fin (n + 1)) : Fin (2 ^ (n - i)) ‚Ü™ evalDomain D i :=
  ‚ü®domain D n i.1, domain_injective D i.1 (by admit /- proof elided -/
  )‚ü©

ENat.toNat in Mathlib.Data.ENat.Basic

NoZeroDivisors in Mathlib.Algebra.GroupWithZero.Defs

@[inline]
def ofOutputOnly (liftStmt : OuterStmtIn ‚Üí InnerStmtOut ‚Üí OuterStmtOut) :
    Statement.Lens OuterStmtIn OuterStmtOut OuterStmtIn InnerStmtOut :=
  ‚ü®id, liftStmt‚ü©

def fullRound (params : Params) (state : Vector KoalaBear.Field params.width)
    (roundConstants : Vector KoalaBear.Field params.width) : Vector KoalaBear.Field params.width :=
  
  let stateWithConstants := state.zipWith (¬∑+¬∑) roundConstants
  
  let stateAfterSbox := stateWithConstants.map (fun x => x ^ sBoxDegree)
  
  externalLinearLayer params stateAfterSbox

def nonsquare [Semiring F] (Œπ' : ‚Ñï) (Œ± : Œπ ‚Üí F) : Matrix Œπ (Fin Œπ') F :=
  Matrix.of fun i j => (Œ± i) ^ j.1

instance [ProverFirst pSpec] : Unique (pSpec.MessageIdx) where
  default := ‚ü®0, by admit /- proof elided -/
  ‚ü©
  uniq := fun ‚ü®i, _‚ü© => by admit /- proof elided -/

@[reducible]
def pSpecFold : ProtocolSpec (Fin.vsum fun (_ : Fin k) ‚Ü¶ 2) :=
  ProtocolSpec.seqCompose (fun (i : Fin k) => FoldPhase.pSpec D x s i)

instance {n : ‚Ñï} {Œ± : Type v} : Memory (Fin n) (fun _ => Œ±) (Vector Œ± n) where
  read m i := m[i]
  write m i v := m.set i v

@[inline]
def seqCompose {m : ‚Ñï} (Stmt : Fin (m + 1) ‚Üí Type) (Wit : Fin (m + 1) ‚Üí Type)
    {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (R : (i : Fin m) ‚Üí
      Reduction oSpec (Stmt i.castSucc) (Wit i.castSucc) (Stmt i.succ) (Wit i.succ) (pSpec i)) :
    Reduction oSpec (Stmt 0) (Wit 0) (Stmt (Fin.last m)) (Wit (Fin.last m)) (seqCompose pSpec) where
  prover := Prover.seqCompose Stmt Wit (fun i => (R i).prover)
  verifier := Verifier.seqCompose Stmt (fun i => (R i).verifier)

def getCommitProverFinalOutput (i : Fin ‚Ñì)
    (inputPrvState : commitPrvState (Context := Context) ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i 0) :
  (‚Ü•(sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®‚Üëi + 1, by admit /- proof elided -/
  ‚ü©) ‚Üí L) √ó
  commitPrvState (Context := Context) ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i 1 :=
  let (stmt, oStmtIn, wit) := inputPrvState
  let f·µ¢_succ := wit.f
  let oStmtOut := snoc_oracle ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
    oStmtIn f·µ¢_succ 
  (f·µ¢_succ, (stmt, oStmtOut, wit))

instance oCtxLens_complete :
    (oCtxLens R n deg D i).toContext.IsComplete
      (relationRound R n deg D i.castSucc) (Simple.inputRelation R deg D)
      (relationRound R n deg D i.succ) (Simple.outputRelation R deg)
      ((Simple.oracleReduction R deg D oSpec).toReduction.compatContext
        (oCtxLens R n deg D i).toContext)
where
  proj_complete := by admit /- proof elided -/

def length [Semiring F] (_ : LinearCode Œπ F) : ‚Ñï := Fintype.card Œπ

@[reducible, inline, specialize]
def ChallengesUpTo (k : Fin (n + 1)) (pSpec : ProtocolSpec n) : Type :=
  ‚àÄ i, (pSpec.take k k.is_le).Challenge i

noncomputable def finalSumcheckRbrExtractor :
  Extractor.RoundByRound []‚Çí
    (StmtIn := (Statement (L := L) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì)) √ó (‚àÄ j, OracleStatement ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë  (Fin.last ‚Ñì) j))
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì))
    (WitOut := Unit)
    (pSpec := pSpecFinalSumcheckStep (L := L))
    (WitMid := FinalSumcheckWit (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì)) where
  eqIn := rfl
  extractMid := fun m ‚ü®stmtMid, oStmtMid‚ü© trSucc witMidSucc => by admit /- proof elided -/
    | none => 
      exact dummyLastWitness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
    | some tpoly =>
      
      exact {
        t := tpoly,
        H := projectToMidSumcheckPoly (L := L) (‚Ñì := ‚Ñì) (t := tpoly)
          (m := BBF_SumcheckMultiplierParam.multpoly stmtMid.ctx)
          (i := Fin.last ‚Ñì) (challenges := stmtMid.challenges),
        f := getMidCodewords ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) tpoly stmtMid.challenges
      }
  extractOut := fun ‚ü®stmtIn, oStmtIn‚ü© tr witOut => ()

Fin.castLT in Init.Data.Fin.Basic

Algebra.TensorProduct.includeRight in Mathlib.RingTheory.TensorProduct.Basic

def lift {Œπ‚ÇÅ Œπ‚ÇÇ Œπ : Type} {œÉ : Type} (oSpec‚ÇÅ : OracleSpec Œπ‚ÇÅ) (oSpec‚ÇÇ : OracleSpec Œπ‚ÇÇ)
    (oSpec : OracleSpec Œπ) (so : SimOracle.Stateful oSpec‚ÇÅ oSpec‚ÇÇ œÉ) :
      SimOracle.Stateful (oSpec ++‚Çí oSpec‚ÇÅ) (oSpec ++‚Çí oSpec‚ÇÇ) œÉ where
  impl := fun q s => match q with
    | query (.inl i) q => do return ‚ü®‚Üê query i q, s‚ü©
    | query (.inr i) q => so.impl (query (spec := oSpec‚ÇÅ) i q) s

@[reducible]
def OracleStatement : Fin (m + 1) ‚Üí Type :=
  fun _ => evalDomain D x 0 ‚Üí F

def combined : Prop :=
  capacitySegmentDup trace ‚à® notFunction trace

alias E := combined

class VerifierOnly (pSpec : ProtocolSpec 1) extends VerifierFirst pSpec

def SkeletonInternalIndex.toNodeIndex {s : Skeleton} (idx : SkeletonInternalIndex s) :
    SkeletonNodeIndex s :=
  match idx with
  | SkeletonInternalIndex.ofInternal => SkeletonNodeIndex.ofInternal
  | SkeletonInternalIndex.ofLeft idxLeft =>
    SkeletonNodeIndex.ofLeft (SkeletonInternalIndex.toNodeIndex idxLeft)
  | SkeletonInternalIndex.ofRight idxRight =>
    SkeletonNodeIndex.ofRight (SkeletonInternalIndex.toNodeIndex idxRight)

instance [Zero T] [DecidableEq T] [ToNat T] : Mod (Cayley T) where
  mod := mod

@[inline, specialize]
def OracleReduction.runWithLog [‚àÄ i, OracleInterface (pSpec.Message i)]
    (stmt : StmtIn) (oStmt : ‚àÄ i, OStmtIn i) (wit : WitIn)
    (reduction : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec) :
      OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí)
        ((FullTranscript pSpec √ó (StmtOut √ó ‚àÄ i, OStmtOut i) √ó WitOut) √ó
          (StmtOut √ó ‚àÄ i, OStmtOut i) √ó
            QueryLog (oSpec ++‚Çí [pSpec.Challenge]‚Çí) √ó QueryLog oSpec) := do
  let ‚ü®proverResult, proveQueryLog‚ü© ‚Üê
    (simulateQ loggingOracle (reduction.prover.run ‚ü®stmt, oStmt‚ü© wit)).run
  let ‚ü®stmtOut, verifyQueryLog‚ü© ‚Üê
    liftM (simulateQ loggingOracle (reduction.verifier.run stmt oStmt proverResult.1)).run
  return ‚ü®proverResult, stmtOut, proveQueryLog, verifyQueryLog‚ü©

instance : SMul ‚Ñï (UniPoly R) := ‚ü®nsmul‚ü©

@[reducible, simp]
def relOut : (StmtOut OStatement √ó ‚àÄ i, OStmtOut OStatement i) ‚Üí WitOut ‚Üí Prop :=
  fun ‚ü®‚ü®q, r‚ü©, oStmt‚ü© () => answer (oStmt 0) q = r

def StraightlineExtractor (oSpec : OracleSpec Œπ) (Data Commitment : Type) :=
  Commitment ‚Üí QueryLog oSpec ‚Üí Data

noncomputable instance finiteDimensionalCoeffVecSpace (‚Ñì : ‚Ñï) :
  FiniteDimensional (K := L) (V := CoeffVecSpace L ‚Ñì) :=

noncomputable def finalSumcheckProver :
  OracleProver
    (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì))
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì))
    (StmtOut := FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì))
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (WitOut := Unit)
    (pSpec := pSpecFinalSumcheckStep (L := L)) where
  PrvState := fun
    | 0 => Statement (L := L) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì) √ó (‚àÄ j, OracleStatement ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì) j)
        √ó Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì)
    | _ => Statement (L := L) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì) √ó (‚àÄ j, OracleStatement ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì) j)
        √ó Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì) √ó L
  input := fun ‚ü®‚ü®stmt, oStmt‚ü©, wit‚ü© => (stmt, oStmt, wit)

  sendMessage
  | ‚ü®0, _‚ü© => fun ‚ü®stmtIn, oStmtIn, witIn‚ü© => do
    let f‚Ñì : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := ‚ü®‚Ñì, by admit /- proof elided -/
    ‚ü©)
      := witIn.f
    
    let c : L := f‚Ñì ‚ü®0, by admit /- proof elided -/
    ‚ü© 
    pure ‚ü®c, (stmtIn, oStmtIn, witIn, c)‚ü©

  receiveChallenge
  | ‚ü®0, h‚ü© => nomatch h 

  output := fun ‚ü®stmtIn, oStmtIn, witIn, c‚ü© => do
    let stmtOut : FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì) := {
      ctx := stmtIn.ctx,
      
      sumcheck_target := stmtIn.sumcheck_target,
      challenges := stmtIn.challenges,
      final_constant := c
    }

    pure (‚ü®stmtOut, oStmtIn‚ü©, ())

def liftBTFieldProps (k : ‚Ñï) (prevBTFResult : ConcreteBTFStepResult (k := k)) :
  ConcreteBTFieldProps (k + 1) := {
    zero_mul := concrete_zero_mul (prevBTFResult.toConcreteBTFieldProps),
    zero_mul' := fun a => by admit /- proof elided -/

@[inline, specialize]
def oracleProver : OracleProver oSpec
    Statement OStatement Unit Statement OStatement Unit !p[] where
  PrvState := fun _ => Statement √ó (‚àÄ i, OStatement i)
  input := Prod.fst
  sendMessage := fun i => nomatch i
  receiveChallenge := fun i => nomatch i
  output := fun stmt => pure (stmt, ())

Array.size in Init.Prelude

@[reducible, simp] def StmtOut := Query OStatement

def findSumIdx (l : List Œ±) (j : Œ±) : ‚Ñï := l.partialSum.findIdx (j < ¬∑)

def indexPow (S : Finset Œπ) (œÜ : Œπ ‚Ü™ F) (k : ‚Ñï) : Finset F :=
  S.image (fun x => (œÜ x) ^ k)

def generateSrs (n : ‚Ñï) (a : ZMod p) : Vector G‚ÇÅ (n + 1) √ó Vector G‚ÇÇ 2 :=
  (towerOfExponents g‚ÇÅ a n, towerOfExponents g‚ÇÇ a 1)

List.leftpad in Init.Data.List.Basic

@[reducible, inline]
instance instPolynomial : OracleInterface R[X] where
  Query := R
  Response := R
  answer := fun poly point => poly.eval point

def FullTranscript.removeSalt (transcript : (pSpec.addSalt Salt).FullTranscript) :
    pSpec.FullTranscript :=
  Transcript.removeSalt (pSpec := pSpec) (k := Fin.last n) transcript

@[inline, specialize]
def Reduction.run (stmt : StmtIn) (wit : WitIn)
    (reduction : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí)
        ((FullTranscript pSpec √ó StmtOut √ó WitOut) √ó StmtOut) := do
  
  let proverResult ‚Üê reduction.prover.run stmt wit
  let stmtOut ‚Üê liftM (reduction.verifier.run stmt proverResult.1)
  return ‚ü®proverResult, stmtOut‚ü©

def getNargString (state : FSProverState U H R) : ByteArray := state.nargString

Finset.range in Mathlib.Data.Finset.Range

def towerAlgebraMap (l r : ‚Ñï) (h_le : l ‚â§ r) : BTField l ‚Üí+* BTField r :=

IO.println in Init.System.IO

noncomputable def ofPolynomialAlgHom : R[X] ‚Üí‚Çê[R] P := Polynomial.aeval PolynomialLike.X

def cons {Œ±} {n : ‚Ñï} (hd : Œ±) (tl : Vector Œ± n) : Vector Œ± (n + 1) :=
  tl.insertIdx 0 hd

noncomputable def hasMutualCorrAgreement
  (Gen : ProximityGenerator Œπ F) [Fintype Gen.par‚Ñì]
  (BStar : ‚Ñù) (errStar : ‚Ñù ‚Üí ENNReal) :=
    haveI := Gen.Gen_nonempty
    ‚àÄ (f : Gen.par‚Ñì ‚Üí Œπ ‚Üí F) (Œ¥ : ‚Ñù‚â•0) (_hŒ¥ : 0 < Œ¥ ‚àß Œ¥ < 1 - BStar),
    Pr_{let r ‚Üê$·µñ Gen.Gen}[ proximityCondition f Œ¥ r Gen.C ] ‚â§ errStar Œ¥

def findFinIdxIfTrue (p : Œ± ‚Üí Bool) (l : List Œ±) (h : ‚àÉ x ‚àà l, p x) : Fin l.length :=
  ‚ü®List.findIdx' p l, by admit /- proof elided -/
  ‚ü©

def dummyLastWitness :
    Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì) := {
  t := ‚ü®0, by admit /- proof elided -/
  ‚ü©,
  H := ‚ü®0, by admit /- proof elided -/
  ‚ü©,
  f := fun _ => 0
}

def genMatrix (deg : ‚Ñï) : Matrix (Fin deg) Œπ F :=
  .of fun i j => domain j ^ (i : ‚Ñï)

noncomputable def discriminant {F : Type} [Field F] [Inhabited F] (f : F[X]) : F :=
  1/f.leadingCoeff * Polynomial.resultant f (Polynomial.derivative f)

protected def Reduction.id : Reduction oSpec Statement Witness Statement Witness !p[] where
  prover := Prover.id
  verifier := Verifier.id

FreeMonad in ToMathlib.Control.Monad.Free

def hint (ds : DomainSeparator U H) (label : String) : DomainSeparator U H :=
  
  { io := ds.io ++ SEP_BYTE ++ "H" ++ label }

def Fin.sumCommEquiv (m : ‚Ñï) (n : ‚Ñï) : Fin (m + n) ‚âÉ (Fin n) ‚äï (Fin m) :=
  (@finSumFinEquiv m n).symm.trans (Equiv.sumComm (Fin m) (Fin n))

@[simp]
abbrev Witness.AfterFirstSumcheck : Type := Unit

message in Examples.FrankingProtocol

def toVerifier : Verifier oSpec (StmtIn √ó ‚àÄ i, OStmtIn i) (StmtOut √ó (‚àÄ i, OStmtOut i)) pSpec where
  verify := fun ‚ü®stmt, oStmt‚ü© transcript => do
    let stmtOut ‚Üê simulateQ (OracleInterface.simOracle2 oSpec oStmt transcript.messages)
      (verifier.verify stmt transcript.challenges)
    letI oStmtOut := fun i => match h : verifier.embed i with
      | Sum.inl j => by admit /- proof elided -/
      | Sum.inr j => by admit /- proof elided -/

instance : Field ScalarField := ZMod.instField scalarFieldSize

def canonicalEmbedding (k : ‚Ñï) : BTField k ‚Üí+* BTField (k+1) :=
  AdjoinRoot.of (poly k)

instance instDCast‚ÇÇ : DCast‚ÇÇ Nat ProtocolSpec (fun _ pSpec => ChallengeIdx pSpec) where
  dcast‚ÇÇ h := ChallengeIdx.cast h
  dcast‚ÇÇ_id := cast_id

@[inline]
def ofInputOnly
    (liftWit : OuterStmtIn √ó OuterWitOut ‚Üí InnerWitIn ‚Üí OuterWitIn) :
    Witness.InvLens OuterStmtIn OuterWitIn OuterWitOut InnerWitIn OuterWitOut :=
  ‚ü®Prod.snd, liftWit‚ü©

noncomputable def intermediateNormVpoly
    
    (i: Fin (‚Ñì+1)) (k : Fin (‚Ñì - i + 1)) : L[X] :=
  
  Fin.foldl (n:=k) (fun acc j =>
    (qMap ùîΩq Œ≤ ‚ü®(i : ‚Ñï) + (j : ‚Ñï), by admit /- proof elided -/
    ‚ü©).comp acc) (X)

@[simp]
def testLens : Context.Lens OuterStmtIn_Test OuterStmtOut_Test InnerStmtIn_Test InnerStmtOut_Test
                Unit Unit Unit Unit where
  stmt := testStmtLens
  wit := Witness.Lens.id

instance {k : Fin 1} : Unique (Transcript k !p[]) where
  default := fun ‚ü®i, h‚ü© => by admit /- proof elided -/

def liftF' (f : ‚Ñï ‚Üí Œ±) : Fin n ‚Üí Œ± :=
  fun m ‚Ü¶ f m.1

def Reduction.fiatShamir (R : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec) :
    NonInteractiveReduction (‚àÄ i, pSpec.Message i) (oSpec ++‚Çí fsChallengeOracle StmtIn pSpec)
      StmtIn WitIn StmtOut WitOut where
  prover := R.prover.fiatShamir
  verifier := R.verifier.fiatShamir

def eval (p : MlPolyEval R n) (x : Vector R n) : R :=
  Vector.dotProduct p (lagrangeBasis x)

instance (priority := low) : DCast‚ÇÇ Œ± Œ≤ Œ≥ where
  dcast‚ÇÇ ha hb c := by admit /- proof elided -/

def FullData.get {s} {Œ± : Type}
    (tree : FullData Œ± s) (idx : SkeletonNodeIndex s) : Œ± :=
  match tree, idx with
  | FullData.leaf value, SkeletonNodeIndex.ofLeaf => value
  | FullData.internal value _ _, SkeletonNodeIndex.ofInternal => value
  | FullData.internal _ left _, SkeletonNodeIndex.ofLeft idxLeft =>
    FullData.get left idxLeft
  | FullData.internal _ _ right, SkeletonNodeIndex.ofRight idxRight =>
    FullData.get right idxRight

def bitVecToString (width : ‚Ñï) (bv : BitVec width) : String :=
  Fin.foldl width (fun (s : String) (idx : Fin width) =>
    
    
    s.push (if BitVec.getLsb bv (Fin.rev idx) then '1' else '0')
  ) ""

structure Gate (ùì° : Type*) (numWires : ‚Ñï) extends Selector ùì°, WireIndices numWires
deriving DecidableEq

def NestedList (n : ‚Ñï) : Type := dfoldr' n (fun _ => Type) (fun _ T => List T) Nat

example : NestedList 0 = Nat := rfl
example (n : ‚Ñï) : NestedList (n + 1) = List (NestedList n) := rfl

def domain (n : ‚Ñï) (i : ‚Ñï) : Fin (2 ^ (n - i)) ‚Üí evalDomain D x i :=
  fun j =>
    ‚ü®
      x ^ 2 ^ i * (DIsCyclicC.gen ^ (2 ^ i)) ^ j.1,
      by admit /- proof elided -/
    ‚ü©

@[reducible]
def Set.language {Œ± Œ≤} (rel : Set (Œ± √ó Œ≤)) : Set Œ± :=
  Prod.fst '' rel

@[inline] def gt [Zero T] [ToNat T] (a b : Cayley T) : Prop :=
  (‚Üëa : Nat) > (‚Üëb : Nat)

Fin.last in Init.Data.Fin.Basic

def absorb (ds : DomainSeparator U H) (count : Nat) (label : String) : DomainSeparator U H :=
  
  
  
  
  { io := ds.io ++ SEP_BYTE ++ s!"A{count}" ++ label }

class VCVCompatible (Œ± : Type*) extends Fintype Œ±, Inhabited Œ± where
  [type_decidableEq' : DecidableEq Œ±]

structure CodeParams (P : Params Œπ F) (Dist : Distances M) where
  C : ‚àÄ i : Fin (M + 1), Set ((Œπ i) ‚Üí F)
  h_code : ‚àÄ i : Fin (M + 1), C i = code (P.œÜ i) (degree Œπ P i)
  h_listDecode : ‚àÄ i : Fin (M + 1), i ‚â† 0 ‚Üí listDecodable (C i) (Dist.Œ¥ i) (Dist.l i)

def coeffsToBitVec {n : ‚Ñï} (coeffs : List (ZMod 2)) : BitVec n :=
  let val := List.foldr (fun c acc => acc * 2 + c.val) 0 (coeffs.take n)
  BitVec.ofNat n val

class Statement.Lens.IsSound {OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut : Type}
    (outerLangIn : Set OuterStmtIn) (outerLangOut : Set OuterStmtOut)
    (innerLangIn : Set InnerStmtIn) (innerLangOut : Set InnerStmtOut)
    (compatStmt : OuterStmtIn ‚Üí InnerStmtOut ‚Üí Prop)
    (lens : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut) where

  proj_sound : ‚àÄ outerStmtIn,
    outerStmtIn ‚àâ outerLangIn ‚Üí lens.proj outerStmtIn ‚àâ innerLangIn

  lift_sound : ‚àÄ outerStmtIn innerStmtOut,
    compatStmt outerStmtIn innerStmtOut ‚Üí
    innerStmtOut ‚àâ innerLangOut ‚Üí
    lens.lift outerStmtIn innerStmtOut ‚àâ outerLangOut

def listOfCloseCodewords (C : Code Œπ F) (y : Œπ ‚Üí F) (r : ‚Ñï) : ‚Ñï :=
  Nat.card (hammingBall C y r)

def canonical (p : UniPoly R) := p.trim = p

@[reducible]
def spec : OracleSpec Unit := fun _ => (Œ± √ó Œ±, Œ±)

def projectToNextSumcheckPoly (i : Fin (‚Ñì)) (H·µ¢ : MultiquadraticPoly L (‚Ñì - i))
    (r·µ¢ : L) : -- the current challenge
    MultiquadraticPoly L (‚Ñì - i.succ) :=

CanLift in Mathlib.Tactic.Lift

abbrev RScodeSet (domain : Œπ ‚Ü™ F) (deg : ‚Ñï) : Set (Œπ ‚Üí F) := (ReedSolomon.code domain deg).carrier

instance : ‚àÄ j, OracleInterface ((pSpecSumcheckFold ùîΩq Œ≤ (œë:=œë)
  (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).Message j) := instOracleInterfaceMessageAppend

def relHammingBall (C : Code Œπ F) (y : Œπ ‚Üí F) (r : ‚Ñù) : Code Œπ F :=
  { c | c ‚àà C ‚àß Code.relHammingDist y c ‚â§ r }

abbrev OracleFunction (i : Fin (‚Ñì + 1)) : Type _ := sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i, by admit /- proof elided -/
    ‚ü© ‚Üí L

@[inline, specialize]
def oracleVerifier : OracleVerifier oSpec
    Statement OStatement Statement (OStatement ‚äï·µ• (fun _ : Fin 1 => Witness))
    (oraclePSpec Witness) where
  verify := fun stmt _ => pure stmt
  embed := .sumMap (.refl _)
    <| Equiv.toEmbedding
    <|.symm (subtypeUnivEquiv (by admit /- proof elided -/
    ))
  hEq := by admit /- proof elided -/

Option.getD in Init.Prelude

Equiv.ofBijective in Mathlib.Logic.Equiv.Defs

@[inline] def mod [Zero T] [DecidableEq T] [ToNat T]
    (dividend divisor : Cayley T) : Cayley T :=
  
  letI fuel := (‚Üëdividend : Nat) + 1
  modNat dividend divisor fuel

cast in Init.Prelude

def lastBlockOracleVerifier :=
  let bIdx := ‚Ñì / œë - 1
  let stmt : Fin (œë + 1) ‚Üí Type := fun i => Statement (L := L) (‚Ñì:=‚Ñì) Context
    ‚ü®bIdx * œë + i, by admit /- proof elided -/
    ‚ü©
  let oStmt := fun i: Fin (œë + 1) => OracleStatement ùîΩq Œ≤ œë
    ‚ü®bIdx * œë + i, by admit /- proof elided -/
    ‚ü©
  let V:  OracleVerifier []‚Çí (StmtIn := Statement (L := L) (‚Ñì := ‚Ñì) Context
      ‚ü®bIdx * œë, by admit /- proof elided -/
      ‚ü©)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë
      ‚ü®bIdx * œë, by admit /- proof elided -/
      ‚ü©)
    (StmtOut := Statement (L := L) (‚Ñì := ‚Ñì) Context (Fin.last ‚Ñì))
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (pSpec := pSpecLastBlock (L:=L) (œë:=œë)) := by admit /- proof elided -/

def concat' {k : Fin n}
    (challenges : (i : Fin k) ‚Üí (pSpec.dir (i.castLE (by admit /- proof elided -/
    )) = .V_to_P
      ‚Üí pSpec.¬´Type¬ª (i.castLE (by admit /- proof elided -/
      ))))
    (chal : (h : pSpec.dir k = .V_to_P) ‚Üí pSpec.Challenge ‚ü®k, h‚ü©) :
    (i : Fin (k + 1)) ‚Üí (pSpec.dir (i.castLE (by admit /- proof elided -/
    )) = .V_to_P) ‚Üí
      pSpec.¬´Type¬ª (i.castLE (by admit /- proof elided -/
      )) :=
  Fin.dconcat challenges chal

Set.univ in Mathlib.Data.Set.Defs

instance : SpongeUnit UInt8 where

instance : ‚àÄ j, OracleInterface (FinalOracleStatement D x s j) :=
  fun j =>
    if h : j = k + 1
    then {
           Query := Unit
           Response := F[X]
           answer := cast (by admit /- proof elided -/
           )
                          (id (Œ± := Unit ‚Üí F[X]))
         }
    else {
           Query :=
            ‚Üë(
              evalDomain D x
              (‚àë j' ‚àà finRangeTo j.1, s j')
            )
           Response := F
           answer := cast (by admit /- proof elided -/
           )
                          (id (Œ± := ‚Üë(evalDomain D x (‚àë j' ‚àà finRangeTo j.1, s j')) ‚Üí F))
         }

IsField.toField in Mathlib.Algebra.Field.IsField

SimOracle.append in VCVio.OracleComp.SimSemantics.Append

Array.range in Init.Data.Array.Basic

def add (m n : ChurchNat Œ±) : ChurchNat Œ± := fun f x => m f (n f x)

def soundness
    (langIn : Set (StmtIn √ó ‚àÄ i, OStmtIn i))
    (langOut : Set (StmtOut √ó ‚àÄ i, OStmtOut i))
    (verifier : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec)
    (soundnessError : ‚Ñù‚â•0) : Prop :=
  verifier.toVerifier.soundness init impl langIn langOut soundnessError

def monomialY (n : ‚Ñï) : F[X] ‚Üí‚Çó[F[X]] F[X][Y] where
  toFun t := ‚ü®Finsupp.single n t‚ü©
  map_add' x y := by admit /- proof elided -/

noncomputable def polynomialFromNovelCoeffs (‚Ñì : ‚Ñï) (h_‚Ñì : ‚Ñì ‚â§ r)
  (a : Fin (2 ^ ‚Ñì) ‚Üí L) : L[X] := ‚àë j, C (a j) * (X‚±º ùîΩq Œ≤ ‚Ñì h_‚Ñì j)

def finUInt8Equiv : Fin (2 ^ 8) ‚âÉ UInt8 where
  toFun := fun i => UInt8.ofFin i
  invFun := fun u => u.toFin
  left_inv _ := rfl
  right_inv _ := rfl

  inductive UnverifiedPrattCertificate : ‚Ñï ‚Üí Type
    | knownPrime : (n : ‚Ñï) ‚Üí UnverifiedPrattCertificate n
    | of : (n : ‚Ñï) ‚Üí (a : ‚Ñï) ‚Üí (part : UnverifiedPrattPart) ‚Üí UnverifiedPrattCertificate n
  deriving Repr

@[reducible]
def pSpec : ProtocolSpec 2 :=
  ‚ü®!v[.P_to_V], !v[R‚¶É‚â§ deg‚¶Ñ[X]]‚ü© ++‚Çö !p[] ++‚Çö ‚ü®!v[.V_to_P], !v[R]‚ü© ++‚Çö !p[]

CoeHead in Init.Coe

Sum.inl in Init.Core

structure RoundByRound
    (oSpec : OracleSpec Œπ) (StmtIn WitIn WitOut : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n)
    (WitMid : Fin (n + 1) ‚Üí Type) where
   
  eqIn : WitMid 0 = WitIn
   
  extractMid : (m : Fin n) ‚Üí StmtIn ‚Üí Transcript m.succ pSpec ‚Üí WitMid m.succ ‚Üí WitMid m.castSucc
   
  extractOut : StmtIn ‚Üí FullTranscript pSpec ‚Üí WitOut ‚Üí WitMid (.last n)

def toOracleSpec {Œπ : Type u} (v : Œπ ‚Üí Type v) [O : ‚àÄ i, OracleInterface (v i)] :
    OracleSpec Œπ := fun i => ((O i).Query, (O i).Response)

instance {G} [Pow G ‚Ñ§] [inst : IsCyclicWithGen G] : IsCyclic G where
  exists_zpow_surjective := ‚ü®inst.gen, inst.zpow_surjective‚ü©

noncomputable def queryOracleReduction [DecidableEq F] :
  OracleReduction []‚Çí
    (FinalStatement F k) (FinalOracleStatement D x s) (Witness F s d (Fin.last (k + 1)))
    (FinalStatement F k) (FinalOracleStatement D x s) (Witness F s d (Fin.last (k + 1)))
    (pSpec D x l) where
  prover := queryProver D x s d l
  verifier := queryVerifier D x s (round_bound domain_size_cond) l

instance finiteDimensional_degreeLT {n : ‚Ñï} (h_n_pos : 0 < n) :
  FiniteDimensional L L‚¶É< n‚¶Ñ[X] :=

def roundRelation (i : Fin (‚Ñì + 1)) :
    Set ((Statement (L := L) Context i √ó
      (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i j)) √ó
      Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) :=
  { input | roundRelationProp (mp := mp) (ùìë := ùìë) ùîΩq Œ≤ i input}

def oracleReduction.sendEvalClaim :
    OracleReduction oSpec
      (Statement.AfterFirstSumcheck R pp) (OracleStatement.AfterFirstSumcheck R pp) (Witness R pp)
      (Statement.AfterSendEvalClaim R pp) (OracleStatement.AfterSendEvalClaim R pp) Unit
      ‚ü®!v[.P_to_V], !v[‚àÄ i, EvalClaim R i]‚ü© :=
  sorry

RatFunc in Mathlib.FieldTheory.RatFunc.Defs

def getRootIndex (s : Skeleton) : SkeletonNodeIndex s := match s with
  | Skeleton.leaf => SkeletonNodeIndex.ofLeaf
  | Skeleton.internal _ _ =>
    SkeletonNodeIndex.ofInternal

@[reducible]
def pSpecFoldRelay : ProtocolSpec (2) :=
  pSpecFold (L:=L) ++‚Çö pSpecRelay

instance instDCast‚ÇÇ : DCast‚ÇÇ Nat ProtocolSpec (fun _ pSpec => MessageIdx pSpec) where
  dcast‚ÇÇ h := MessageIdx.cast h
  dcast‚ÇÇ_id := cast_id

noncomputable def dist (C : Set (n ‚Üí R)) : ‚Ñï :=
  sInf {d | ‚àÉ u ‚àà C, ‚àÉ v ‚àà C, u ‚â† v ‚àß Œî‚ÇÄ( u, v ) ‚â§ d}

structure ParamConditions (P : Params Œπ F) where
  m : ‚Ñï 
  h_m : m = P.varCount 0
  h_sumkLt : ‚àë i : Fin (M + 1), P.foldingParam i ‚â§ m
  h_varCount_i : ‚àÄ i : Fin (M + 1),
    P.varCount i = m - ‚àë j : Fin i, P.foldingParam (Fin.castLT j (Nat.lt_trans j.isLt i.isLt))
  h_smooth : ‚àÄ i : Fin (M + 1), Smooth (P.œÜ i)
  h_repeatPLt : ‚àÄ i : Fin (M + 1), P.repeatParam i ‚â§ Fintype.card (Œπ i)

@[reducible, simp]
def relIn : Set (Statement √ó Unit) := { ‚ü®stmt, _‚ü© | pred stmt }

@[reducible]
def GroupEncodeOracle : OracleSpec Unit := fun _ => (Œπ, BitVec bitLength)

structure InterleavedCode (Œ∫ Œπ : Type*) [Fintype Œ∫] [Fintype Œπ] (F : Type*) [Semiring F] where
  MF : MatrixSubmodule Œ∫ Œπ F
  LC : LinearCode Œπ F

def basisSucc (k : ‚Ñï) : Basis (Fin 2) (ConcreteBTField k) (ConcreteBTField (k + 1)) :=

noncomputable def distToCode [LinearOrder Œ±] [Zero Œ±]
                             (w : Œπ ‚Üí F) (C : Set (Œπ ‚Üí F))
                             (Œ¥f : (Œπ ‚Üí F) ‚Üí (Œπ ‚Üí F) ‚Üí Œ±)
                             (h : (possibleDistsToCode w C Œ¥f).Finite) : WithTop Œ± :=
  haveI := @Fintype.ofFinite _ h
  (possibleDistsToCode w C Œ¥f).toFinset.min

def append (T‚ÇÅ : FullTranscript pSpec‚ÇÅ) (T‚ÇÇ : FullTranscript pSpec‚ÇÇ) :
    FullTranscript (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ) :=
  Fin.happend T‚ÇÅ T‚ÇÇ

noncomputable def minDist (C : Set (n ‚Üí R)) : ‚Ñï :=
  sInf {d | ‚àÉ u ‚àà C, ‚àÉ v ‚àà C, u ‚â† v ‚àß hammingDist u v = d}

OracleSpec.domain in VCVio.OracleComp.OracleSpec

RatFunc.eval in Mathlib.FieldTheory.RatFunc.AsPolynomial

instance instDCast : DCast Nat ProtocolSpec where
  dcast h := ProtocolSpec.cast h
  dcast_id := cast_id

private def k [Zero F] (B : Finset (Fin n ‚Üí F)) : ‚Ñö :=
  (1 : ‚Ñö) / n * ‚àë i, K B i 0

OrderBot in Mathlib.Order.BoundedOrder.Basic

instance {Œπ : Type u} (v : Œπ ‚Üí Type v) [O : ‚àÄ i, OracleInterface (v i)]
    [h : ‚àÄ i, Fintype (Response (v i))]
    [h' : ‚àÄ i, Inhabited (Response (v i))] :
    [v]‚Çí.FiniteRange where
  range_fintype' := h
  range_inhabited' := h'

@[simp]
def testLensE : Extractor.Lens OuterStmtIn_Test OuterStmtOut_Test InnerStmtIn_Test InnerStmtOut_Test
                Unit Unit Unit Unit where
  stmt := testStmtLens
  wit := Witness.InvLens.id

def relHammingBallInterleavedCode [DecidableEq F] (U : Matrix Œ∫ Œπ F)
  (IC : MatrixSubmodule Œ∫ Œπ F) (r : ‚Ñù) :=
    {V | V ‚àà IC ‚àß relDistCodewords U V < r}

instance {Œ± : Type} {s : Skeleton} :
    CoeFun (FullData Œ± s) fun (_ : FullData Œ± s) => SkeletonNodeIndex s ‚Üí Œ± where
  coe := fun tree idx => tree.get idx

instance : ‚àÄ j, SelectableType ((pSpecFoldRelay (L:=L)).Challenge j) :=
  instSelectableTypeChallengeAppend

def Mymotive : Fin 3 ‚Üí Type := !v[‚Ñï, Bool, String]

example : !d‚ü®Mymotive‚ü©[(1 : ‚Ñï), (true : Bool), ("hello" : String)] =
  (Fin.dcons (1 : ‚Ñï) (Fin.dcons (true : Bool) (Fin.dcons ("hello" : String) Fin.dempty)) :
   (i : Fin 3) ‚Üí Mymotive i) := rfl


example : !v[1, 2] ++·µõ !v[3, 4] = !v[1, 2, 3, 4] := rfl
example : (0 : ‚Ñï) ::·µõ !v[1, 2] = !v[0, 1, 2] := rfl
example : !v[1, 2] :+·µõ (3 : ‚Ñï) = !v[1, 2, 3] := rfl


example : (1 : ‚Ñï) :: ∞ (Fin.dempty : (i : Fin 0) ‚Üí Fin.vempty i) =
  (!h[(1 : ‚Ñï)] : (i : Fin 1) ‚Üí !v[‚Ñï] i) := rfl


example : !h[(1 : ‚Ñï), (true : Bool), ("hello" : String)] =
  Fin.hcons 1 (Fin.hcons true ("hello" :: ∞‚ü®String ; !v[]‚ü© !h[])) := rfl

def reduction : Reduction oSpec (StmtIn R √ó (‚àÄ i, OStmtIn R deg i)) Unit
                                (StmtOut R √ó (‚àÄ i, OStmtOut R deg i)) Unit (pSpec R deg) where
  prover := prover R deg oSpec
  verifier := verifier R deg D oSpec

TensorProduct in Mathlib.LinearAlgebra.TensorProduct.Basic

def instDefault {Message : Type u} : OracleInterface Message where
  Query := Unit
  Response := Message
  answer := fun m _ => m

def pow (S : Finset Œπ) (œÜ : Œπ ‚Ü™ F) (k : ‚Ñï) : indexPow S œÜ k ‚Ü™ F :=
    Function.Embedding.subtype fun y => y ‚àà indexPow S œÜ k

inductive Program where

@[reducible, inline, specialize]
def Challenges' (pSpec : ProtocolSpec n) : Type :=
  ‚àÄ i, (hi : pSpec.dir i = .V_to_P) ‚Üí pSpec.¬´Type¬ª i

LinearOrder in Mathlib.Order.Defs.LinearOrder

Function.Surjective in Init.Data.Function

def PowerType (n : ‚Ñï) : Type := dfoldr' n (fun _ => Type) (fun _ T => T ‚Üí T) Nat


example : PowerType 0 = Nat := rfl
example (n : ‚Ñï) : PowerType (n + 1) = (PowerType n ‚Üí PowerType n) := rfl

def toOutCodewordsCount (i : Fin (‚Ñì + 1)) : ‚Ñï :=

noncomputable def H_tilde (H : F[X][Y]) : Polynomial (RatFunc F) :=
  let h·µ¢ (i : ‚Ñï) := H.coeff i
  let d := H.natDegree
  let W := (RingHom.comp Polynomial.C univPolyHom) (h·µ¢ d)
  let S : Polynomial (RatFunc F) := Polynomial.X / W
  let H' := Polynomial.eval‚ÇÇ (RingHom.comp Polynomial.C univPolyHom) S H
  W ^ (d - 1) * H'

noncomputable def finalSumcheckVerifier :
  OracleVerifier
    (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì))
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (StmtOut := FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì))
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (pSpec := pSpecFinalSumcheckStep (L := L)) where
  verify := fun stmtIn _ => do
    
    let c : L ‚Üê query (spec := [(pSpecFinalSumcheckStep (L := L)).Message]‚Çí) ‚ü®0, rfl‚ü© ()

    
    let eq_tilde_eval : L := eqTilde (r := stmtIn.ctx.t_eval_point) (r' := stmtIn.challenges)
    unless stmtIn.sumcheck_target = eq_tilde_eval * c do
      return { 
        ctx := {t_eval_point := 0, original_claim := 0},
        sumcheck_target := 0,
        challenges := 0,
        final_constant := 0
      }

    
    let stmtOut : FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì) := {
      ctx := stmtIn.ctx,
      sumcheck_target := eq_tilde_eval * c, 
      challenges := stmtIn.challenges,
      final_constant := c
    }
    pure stmtOut

  embed := ‚ü®fun j => by admit /- proof elided -/
  ‚ü©
  hEq := fun oracleIdx => by admit /- proof elided -/

@[inline, reducible]
def lift : (OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i)) √ó OuterWitIn ‚Üí
    (InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i)) √ó InnerWitOut ‚Üí
    (OuterStmtOut √ó (‚àÄ i, OuterOStmtOut i)) √ó OuterWitOut :=
  fun ctxIn ctxOut => ‚ü®lens.stmt.lift ctxIn.1 ctxOut.1, lens.wit.lift ctxIn ctxOut‚ü©

class Serialize (Œ± : Type u) (Œ≤ : Type v) where
  serialize : Œ± ‚Üí Œ≤

@[reducible, simp]
def knowledgeSoundness (relation : Set (Statement √ó Bool))
    (verifier : Verifier oSpec Statement Bool pSpec)
    (knowledgeError : ‚Ñù‚â•0) : Prop :=
  verifier.knowledgeSoundness init impl relation acceptRejectRel knowledgeError

def NBlockMessages := 2 * (œë - 1) + 3

Vector.drop in Init.Data.Vector.Basic

@[reducible]
def foldRelayOracleReduction (i : Fin ‚Ñì)
    (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
  OracleReduction []‚Çí
    (StmtIn := Statement (L := L) Context i.castSucc)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) i.castSucc)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) i.succ)
    (pSpec := pSpecFoldRelay (L:=L)) :=
  OracleReduction.append
    (pSpec‚ÇÅ := pSpecFold (L:=L))
    (pSpec‚ÇÇ := pSpecRelay)
        (foldOracleReduction ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) i)
    (relayOracleReduction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hNCR)

def buildMerkleTree {s} (leaf_tree : LeafData Œ± s) : OracleComp (spec Œ±) (FullData Œ± s) :=
  match leaf_tree with
  | LeafData.leaf a => do return (FullData.leaf a)
  | LeafData.internal left right => do
    let leftTree ‚Üê buildMerkleTree left
    let rightTree ‚Üê buildMerkleTree right
    let rootHash ‚Üê singleHash leftTree.getRootValue rightTree.getRootValue
    return FullData.internal rootHash leftTree rightTree

@[inline]
def zero [Zero R] : MlPoly R n := Vector.replicate (2 ^ n) 0

noncomputable instance fintype_sDomain (i : Fin r) :
  Fintype (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i) :=

def relayKnowledgeError (m : pSpecRelay.ChallengeIdx) : ‚Ñù‚â•0 :=
  match m with
  | ‚ü®j, _‚ü© => j.elim0

instance {s} : Functor (fun Œ± => LeafData Œ± s) where
  map f x := x.map f

def checkMatrix (deg : ‚Ñï) [Fintype Œπ] : Matrix (Fin (Fintype.card Œπ - deg)) Œπ F :=
  sorry

Finset.fold in Mathlib.Data.Finset.Fold

@[simp]
abbrev EvalClaim : R1CS.MatrixIdx ‚Üí Type := fun _ => R

instance : Unique (ProtocolSpec 0) where
  default := empty
  uniq := fun ‚ü®_, _‚ü© => by admit /- proof elided -/

@[reducible, inline, specialize]
def FullTranscript (pSpec : ProtocolSpec n) := (i : Fin n) ‚Üí pSpec.¬´Type¬ª i

@[reducible, simp] def OStmtOut := fun _ : Fin 2 => OStatement

@[reducible]
def fullPSpec := (pSpecCoreInteraction ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)) ++‚Çö
    (pSpecQuery ùîΩq Œ≤ Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))

def internalLinearLayer (state : Vector KoalaBear.Field params.width) :
    Vector KoalaBear.Field params.width :=
  
  
  let sumAll := state.foldl (fun acc x => acc + x) 0

  
  
  state.zipWith (fun s d => sumAll + d * s) params.internalDiagVectors

instance {Œ± : Type*} {n : ‚Ñï} [VCVCompatible Œ±] : VCVCompatible (Vector Œ± n) where

@[reducible, simp] def OStmtIn := fun _ : Fin 2 => OStatement

IntCast in Init.Data.Int.Basic

def acceptRejectOracleRel : Set ((Bool √ó (‚àÄ _ : Empty, Unit)) √ó Unit) :=
  { ((true, isEmptyElim), ()) }

instance [IsSingleRound pSpec] : Unique (pSpec.ChallengeIdx) where
  default := ‚ü®1, by admit /- proof elided -/
  ‚ü©
  uniq := fun ‚ü®i, hi‚ü© => by admit /- proof elided -/

List.replicate in Init.Data.List.Basic

ToString in Init.Data.ToString.Basic

def MlPoly.mk {R : Type*} (n : ‚Ñï) (v : Vector R (2 ^ n)) : MlPoly R n := v

Algebra.TensorProduct.instCommSemiring in Mathlib.RingTheory.TensorProduct.Basic

noncomputable def towerRingEquivFromConcrete0 : ConcreteBTField 0 ‚âÉ+* BTField 0 :=

def backwardPermutationOracleImpl {Œ± : Type*} [Permute Œ±] [LawfulPermute Œ±] :
    QueryImpl (backwardPermutationOracle Œ±) Id where
  impl | query () q => LawfulPermute.permuteInv (Œ± := Œ±) q

Subtype.eq_iff in Init.Ext

noncomputable def proximity_gap_johnson (rho : ‚Ñö) (m : ‚Ñï) : ‚Ñù :=
  (1 : ‚Ñù) - Real.sqrt rho - Real.sqrt rho / (2 * m)

And in Init.Prelude

System.FilePath.walkDir in Init.System.IO

Infinite in Mathlib.Data.Finite.Defs

noncomputable def AffSpanFinsetCollection {t : ‚Ñï} [NeZero k] [NeZero t]
  (C : Fin t ‚Üí (Fin k ‚Üí (Œπ ‚Üí F))) : Set (Finset (Œπ ‚Üí F)) :=
  Set.range (fun i => AffSpanFinset (C i))

Finset.Nonempty in Mathlib.Data.Finset.Empty

def OuterStmtIn_Test := ‚Ñ§[X] √ó ‚Ñ§[X] √ó ‚Ñ§

@[simp]
instance CommRing (k : ‚Ñï) : CommRing (BTField k) := Field.toCommRing

@[reducible]
def rateSegment (state : CanonicalSpongeState U) : Vector U SpongeSize.R :=
  
  (Vector.take state SpongeSize.R).cast (by admit /- proof elided -/
  )

instance instDCast‚ÇÇForall :
    DCast‚ÇÇ Œ± (fun a => ‚àÄ b : Œ≤ a, Œ≥ a b) (fun a f => ‚àÄ b : Œ≤ a, Œ¥ a b (f b)) where
  dcast‚ÇÇ ha hb c := fun b => dcast‚ÇÉ ha (by admit /- proof elided -/
  )
    (by admit /- proof elided -/
    ) (c (dcast ha.symm b))
  dcast‚ÇÇ_id := by admit /- proof elided -/

instance [IsSingleRound pSpec] : Unique (pSpec.MessageIdx) where
  default := ‚ü®0, by admit /- proof elided -/
  ‚ü©
  uniq := fun ‚ü®i, hi‚ü© => by admit /- proof elided -/

structure TowerEquivResult (k : ‚Ñï) where
  ringEquiv : ConcreteBTField k ‚âÉ+* BTField k
  ringEquivForwardMapEq : ringEquiv = towerRingHomForwardMap k

def fst (T : (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).Transcript k) : pSpec‚ÇÅ.Transcript ‚ü®min k m, by admit /- proof elided -/
‚ü© :=
  if hk : k ‚â§ m then
    fun i => by admit /- proof elided -/

@[reducible, simp]
def pSpec : ProtocolSpec 1 := ‚ü®!v[.P_to_V], !v[Witness]‚ü©

def snoc_oracle {i : Fin ‚Ñì}
    (oStmtIn : ‚àÄ j : Fin (toOutCodewordsCount ‚Ñì œë i.castSucc),
      OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j)
    (newOracleFn : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ) :
    ‚àÄ j : Fin (toOutCodewordsCount ‚Ñì œë i.succ),
      OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.succ j := fun j =>
  have h_succ_val: i.succ.val = i.val + 1 := rfl
  if hj: j.val < (toOutCodewordsCount ‚Ñì œë i.castSucc) then
    oStmtIn ‚ü®j, by admit /- proof elided -/
    ‚ü©
  else 
    
    if hi: isCommitmentRound ‚Ñì œë i then
      
      
      have h_count_succ : toOutCodewordsCount ‚Ñì œë i.succ =
        toOutCodewordsCount ‚Ñì œë i.castSucc + 1 := by admit /- proof elided -/

CommRing in Mathlib.Algebra.Ring.Defs

@[inline, specialize]
def OracleReduction.run [‚àÄ i, OracleInterface (pSpec.Message i)]
    (stmt : StmtIn) (oStmt : ‚àÄ i, OStmtIn i) (wit : WitIn)
    (reduction : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec) :
      OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí)
        ((FullTranscript pSpec √ó (StmtOut √ó ‚àÄ i, OStmtOut i) √ó WitOut) √ó
          (StmtOut √ó ‚àÄ i, OStmtOut i)) := do
  let proverResult ‚Üê reduction.prover.run ‚ü®stmt, oStmt‚ü© wit
  let stmtOut ‚Üê liftM (reduction.verifier.run stmt oStmt proverResult.1)
  return ‚ü®proverResult, stmtOut‚ü©

noncomputable def relayOracleProver (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
  OracleProver (oSpec := []‚Çí)
    
    (StmtIn := Statement (L := L) Context i.succ)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) i.succ)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) i.succ)
    (pSpec := pSpecRelay) where
  PrvState := relayPrvState ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i
  input := fun ‚ü®‚ü®stmtIn, oStmtIn‚ü©, witIn‚ü© => (stmtIn, oStmtIn, witIn)
  sendMessage | ‚ü®x, h‚ü© => by admit /- proof elided -/
| ‚ü®x, h‚ü© => by admit /- proof elided -/

Functor.map in Init.Prelude

class LawfulHasSucc (T : Type u) [HasSucc T] [Add T] [One T] : Prop where
   
  succ'_eq_add_one : ‚àÄ x : T, succ' x = x + 1

List.findIdx in Init.Data.List.Basic

@[reducible] def NonInteractiveVerifier (Message : Type) {Œπ : Type} (oSpec : OracleSpec Œπ)
    (StmtIn StmtOut : Type) :=
  Verifier oSpec StmtIn StmtOut ‚ü®!v[.P_to_V], !v[Message]‚ü©

def finOneEquiv : MvPolynomial (Fin 1) R ‚âÉ‚Çê[R] Polynomial R :=
  (finSuccEquiv R 0).trans (Polynomial.mapAlgEquiv (isEmptyAlgEquiv R (Fin 0)))

instance {i : ‚Ñï} : SmoothPowerOfTwo (n - i) (evalDomain D i) where
  smooth := by admit /- proof elided -/

def generateTag (iopBytes : ByteArray) : Vector UInt8 32 :=
  
  sorry

List.splitBy in Init.Data.List.Basic

Polynomial.C in Mathlib.Algebra.Polynomial.Basic

def relOut : Set ((Unit √ó (‚àÄ i, (Sum.elim OStatement OStatement) i)) √ó Unit) :=
  setOf (fun ‚ü®‚ü®(), oracles‚ü©, _‚ü© => oracles (.inl default) = oracles (.inr default))

structure ParamConditions (P : Params Œπ F) where
  h_deg : ‚àÉ k : ‚Ñï, P.deg = 2^k
  h_foldingParams : ‚àÄ i : Fin (M + 1), ‚àÉ k : ‚Ñï, (P.foldingParam i) = 2^k
  h_deg_ge : P.deg ‚â• ‚àè i : Fin (M + 1), (P.foldingParam i)
  h_smooth : ‚àÄ i : Fin (M + 1), Smooth (P.œÜ i)
  h_smooth_le : ‚àÄ i : Fin (M + 1), Fintype.card (Œπ i) ‚â§ (degree Œπ P i)
  h_repeatP_le : ‚àÄ i : Fin (M + 1), P.repeatParam i + 1 ‚â§ (degree Œπ P i)

def subNat (c : AssocNat) : Nat ‚Üí AssocNat
| 0            => c 
| Nat.succ k   => pred (subNat c k) 

UInt32.ofFin in Init.Data.UInt.Basic

def div [Field R] (p q : UniPoly R) : UniPoly R :=
  (C (q.leadingCoeff)‚Åª¬π ‚Ä¢ p).divByMonic (C (q.leadingCoeff)‚Åª¬π * q)

def rowSpan : Submodule F (Œπ' ‚Üí F) :=
  Submodule.span F {U i | i : Œπ}

noncomputable def ElocPolyF (œâs f : Fin n ‚Üí F) (p : Polynomial F) : Polynomial F :=
  ElocPoly n (liftF œâs) (liftF f) p

def ofMessagesChallenges (messages : MessagesUpTo k pSpec)
    (challenges : ChallengesUpTo k pSpec) : Transcript k pSpec :=
  fun i => match h : pSpec.dir (i.castLE (by admit /- proof elided -/
  )) with
  | Direction.P_to_V => messages ‚ü®i.castLE (by admit /- proof elided -/
  ), h‚ü©
  | Direction.V_to_P => challenges ‚ü®i.castLE (by admit /- proof elided -/
  ), h‚ü©

def FullData.map {Œ± Œ≤ : Type} (f : Œ± ‚Üí Œ≤) {s : Skeleton}
    (tree : FullData Œ± s) : FullData Œ≤ s :=
  match tree with
  | FullData.leaf value => FullData.leaf (f value)
  | FullData.internal value left right =>
    FullData.internal (f value) (left.map f) (right.map f)

Fin.consInduction in Mathlib.Data.Fin.Tuple.Basic

class IsRBRKnowledgeSound (relIn : Set (StmtIn √ó WitIn)) (relOut : Set (StmtOut √ó WitOut))
    (verifier : Verifier oSpec StmtIn StmtOut pSpec) where
  rbrKnowledgeError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0
  is_rbr_knowledge_sound : rbrKnowledgeSoundness init impl relIn relOut verifier rbrKnowledgeError

IO.FS.Stream in Init.System.IO

Functor in Init.Prelude

def IterType (n : ‚Ñï) : Type := dfoldl' n (fun _ => Type) (fun _ T => T √ó T) Nat


example : IterType 0 = Nat := rfl
example (n : ‚Ñï) : IterType (n + 1) = (IterType n √ó IterType n) := rfl

@[ext]
structure AssocNat where
  toFun : Nat ‚Üí Nat
  presSucc : ‚àÄ n, toFun (n.succ) = (toFun n).succ

instance : IsEmpty (OracleQuery []‚Çí Œ±) where
  false := by admit /- proof elided -/

def badEventExistsProp
    (stmtIdx : Fin (‚Ñì + 1)) (oracleIdx : Fin (‚Ñì + 1))
    (oStmt : ‚àÄ j, (OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (i := oracleIdx) j))
    (challenges : Fin stmtIdx ‚Üí L) : Prop :=
  ‚àÉ j, foldingBadEventAtBlock ùîΩq Œ≤ (stmtIdx := stmtIdx) (oracleIdx := oracleIdx)
    (oStmt := oStmt) (challenges := challenges) j

Eq in Init.Prelude

def ar1 (k : ‚Ñï) : Fin 1 ‚Üí ‚Ñï := fun _ => k

def ranges {n : ‚Ñï} (a : Fin n ‚Üí ‚Ñï) : (i : Fin n) ‚Üí Fin (a i) ‚Üí ‚Ñï :=
  match n with
  | 0 => fun i => elim0 i
  | n + 1 => fun i => by admit /- proof elided -/

@[reducible, simp]
def rbrSoundness (langIn : Set Statement)
    (verifier : Verifier oSpec Statement Bool pSpec)
    (rbrSoundnessError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) : Prop :=
  verifier.rbrSoundness init impl langIn acceptRejectRel.language rbrSoundnessError

def split (k : ‚Ñï) (h_k : k > 0) (x : BTField k) : BTField (k-1) √ó BTField (k-1) :=

tail in ToMathlib.Control.Comonad.Instances

def commitmentScheme : Commitment.Scheme (oSpec Œ± Œ≤ Œ≥) Œ± Œ≤ Œ≥ !p[] where
  commit := fun v r => commit v
  opening := .mk (sorry) (.mk (sorry))

abbrev Field := ZMod fieldSize

def leftModNat {m n : ‚Ñï} (h_m : m > 0) (i : Fin (m * n)) : Fin m := ‚ü®i % m, by admit /- proof elided -/
‚ü©

def degCor
  (œÜ : Œπ ‚Ü™ F) (dstar degree : ‚Ñï) (r : F) (f : Œπ ‚Üí F) (x : Œπ) : F :=
    f x * ‚àë l ‚àà range (dstar - degree + 1), ((œÜ x) * r) ^ l

abbrev Bwd : PermuteDir := Sum.inr ()

def QuotientUniPoly (R : Type*) [Ring R] [BEq R] := Quotient (@instSetoidUniPoly R _)

Eq.mpr in Init.Core

EquivLike in Mathlib.Data.FunLike.Equiv

private def Fi (B : Finset (Fin n ‚Üí F)) (i : Fin n) (Œ± : F) : Finset (Fin n ‚Üí F) :=
  { x | x ‚àà B ‚àß x i = Œ± }

@[reducible]
def VectorIOP
    (Statement : Type) {Œπ‚Çõ : Type} (OStatement : Œπ‚Çõ ‚Üí Type) (Witness : Type)
    (vPSpec : ProtocolSpec.VectorSpec n) (A : Type)
    [‚àÄ i, OracleInterface (OStatement i)] :=
  OracleProof []‚Çí Statement OStatement Witness (vPSpec.toProtocolSpec A)

@[inline, specialize]
def smul (r : R) (p : UniPoly R) : UniPoly R :=
  .mk (Array.map (fun a => r * a) p)

structure DomainSeparator (U : Type) [SpongeUnit U] (H : Type*) [DuplexSpongeInterface U H] where
   
  io : String
deriving Repr

@[reducible]
def BASE_FIELD_CARD : Nat := 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f

/- Alternative representation -/
example : BASE_FIELD_CARD = 2 ^ 256 - 2 ^ 32 - 2 ^ 9 - 2 ^ 8 - 2 ^ 7 - 2 ^ 6 - 2 ^ 4 - 1 :=

def getRoot {n : ‚Ñï} (cache : Cache Œ± n) : Œ± :=
  (cache 0).get ‚ü®0, by admit /- proof elided -/
  ‚ü©

inductive ScalarVectorOp where | scale

def OracleVerifier.liftContext
    (lens : OracleStatement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                              OuterOStmtIn OuterOStmtOut InnerOStmtIn InnerOStmtOut)
    (V : OracleVerifier oSpec InnerStmtIn InnerOStmtIn InnerStmtOut InnerOStmtOut pSpec) :
      OracleVerifier oSpec OuterStmtIn OuterOStmtIn OuterStmtOut OuterOStmtOut pSpec where
  verify := fun outerStmtIn transcript => sorry
  embed := by admit /- proof elided -/

@[reducible]
def coreInteractionOracleVerifier :=
  OracleVerifier.append (oSpec:=[]‚Çí)
    (Stmt‚ÇÅ := Statement (L := L) (‚Ñì:=‚Ñì) (SumcheckBaseContext L ‚Ñì) 0)
    (Stmt‚ÇÇ := Statement (L := L) (‚Ñì:=‚Ñì) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì))
    (Stmt‚ÇÉ := FinalSumcheckStatementOut (L:=L) (‚Ñì:=‚Ñì))
    (OStmt‚ÇÅ := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë 0)
    (OStmt‚ÇÇ := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (OStmt‚ÇÉ := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (pSpec‚ÇÅ := pSpecSumcheckFold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (pSpec‚ÇÇ := pSpecFinalSumcheckStep (L:=L))
    (V‚ÇÅ := sumcheckFoldOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (V‚ÇÇ := finalSumcheckVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))

noncomputable def commitOracleProver (i : Fin ‚Ñì) :
  OracleProver (oSpec := []‚Çí)
    
    (StmtIn := Statement (L := L) Context i.succ)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) i.succ)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) i.succ)
    (pSpec := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) where

  PrvState := commitPrvState ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i

  input := fun ‚ü®‚ü®stmt, oStmt‚ü©, wit‚ü© => (stmt, oStmt, wit)

  sendMessage 
  | ‚ü®0, _‚ü© => fun inputPrvState => by admit /- proof elided -/
  | ‚ü®0, h‚ü© => nomatch h 

  output := fun ‚ü®stmt, oStmt, wit‚ü© => by admit /- proof elided -/

Fintype.decidablePiFintype in Mathlib.Data.Fintype.Defs

instance : CoeFun AssocNat (fun _ => Nat ‚Üí Nat) := ‚ü®AssocNat.toFun‚ü©

noncomputable def disFromHammingNorm [Semiring F] [DecidableEq F] (LC : LinearCode Œπ F) : ‚Ñï :=
  sInf {d | ‚àÉ u ‚àà LC, u ‚â† 0 ‚àß hammingNorm u ‚â§ d}

def Œ∂ (R : F[X][X][Y]) (x‚ÇÄ : F) (H : F[X][Y]) [H_irreducible : Fact (Irreducible H)] : ùïÉ H :=
  let W  : ùïÉ H := liftToFunctionField (H.leadingCoeff);
  let T : ùïÉ H := liftToFunctionField (Polynomial.X);
    Polynomial.eval‚ÇÇ liftToFunctionField (T / W)
      (Bivariate.evalX (Polynomial.C x‚ÇÄ) R.derivative)

def eval‚ÇÇ (p : MlPolyEval R n) (f : R ‚Üí+* S) (x : Vector S n) : S := eval (map f p) x

instance [VCVCompatible A] : ‚àÄ i, VCVCompatible ((vPSpec.toProtocolSpec A).Challenge i) :=
  fun _ => by admit /- proof elided -/

@[simps]
def revFinProdFinEquiv {m n : ‚Ñï} (h_m : m > 0) : Fin m √ó Fin n ‚âÉ Fin (m * n) where
  toFun x :=
    ‚ü®x.1.val + m * x.2.val,
      calc
        x.1.val + m * x.2.val < m + m * x.2.val := Nat.add_lt_add_right x.1.is_lt _
        _ = m * (1 + x.2.val) := by admit /- proof elided -/
        ‚ü©
  invFun := fun x => 
    (leftModNat (m:=m) (n:=n) h_m (i:=x), leftDivNat (m:=m) (n:=n) (i:=x))
  left_inv := fun ‚ü®x, y‚ü© =>
    
    
    Prod.ext
      (Fin.eq_of_val_eq <|
        calc
          (x.val + m * y.val) % m = x.val % m := by admit /- proof elided -/
          )
      (Fin.eq_of_val_eq <|
        calc
          (x.val + m * y.val) / m = x.val / m + y.val := by admit /- proof elided -/
          )
  right_inv x := by admit /- proof elided -/

MvPolynomial in Mathlib.Algebra.MvPolynomial.Basic

CommRing.toRing in Mathlib.Algebra.Ring.Defs

noncomputable def towerRingEquiv0 : BTField 0 ‚âÉ+* ConcreteBTField 0 :=

def getNextOracle (i : Fin (‚Ñì + 1))
    (oStmt : ‚àÄ j, (OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i) j)
    (j : Fin (toOutCodewordsCount ‚Ñì œë i)) (hj : j.val + 1 < toOutCodewordsCount ‚Ñì œë i) :
    OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®j.val * œë + œë, by
    apply Nat.lt_succ_of_le;
    let h_k_next_le_i := oracle_block_k_next_le (‚Ñì := ‚Ñì) (œë := œë) (i := i) (j := j) (hj := hj)
    calc _ ‚â§ i.val := h_k_next_le_i
      _ ‚â§ ‚Ñì := Fin.is_le i
  ‚ü© :=

@[inline]
def neg [Neg R] (p : MlPoly R n) : MlPoly R n := p.map (fun a => -a)

instance : ‚àÄ j, OracleInterface ((batchSpec F m).Message j)
  | ‚ü®0, h‚ü© => nomatch h

@[reducible]
def pSpecFoldCommit (i : Fin ‚Ñì) : ProtocolSpec (3) :=
  pSpecFold (L:=L) ++‚Çö pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i

Subtype.mk in Init.Prelude

Polynomial.algEquivOfCompEqX in Mathlib.Algebra.Polynomial.AlgebraMap

instance [AddCommMonoid R] : AddCommMonoid (MlPolyEval R n) where
  add := add
  add_assoc a b c := by admit /- proof elided -/

private def Bi (B : Finset (Fin n ‚Üí F)) (i : Fin n) : Finset ((Fin n ‚Üí F) √ó (Fin n ‚Üí F)) :=
  { x | x ‚àà B √óÀ¢ B ‚àß x.1 i = x.2 i ‚àß x.1 ‚â† x.2 }

inferInstanceAs in Init.Prelude

@[reducible]
def GroupExpOracle : OracleSpec Unit := fun _ => (Œπ √ó ZMod p √ó Œπ, Unit)

def fromNat {k : ‚Ñï} (n : Nat) : ConcreteBTField k :=
  BitVec.ofNat (2 ^ k) n

Subgroup.zpowers in Mathlib.Algebra.Group.Subgroup.ZPowers.Basic

@[reducible, inline]
instance instProdForall {Œπ : Type u} (v : Œπ ‚Üí Type v) [O : ‚àÄ i, OracleInterface (v i)] :
    OracleInterface (‚àÄ i, v i) where
  Query := (i : Œπ) √ó (O i).Query
  Response := (i : Œπ) √ó (O i).Response
  answer := fun f ‚ü®i, q‚ü© => ‚ü®i, (O i).answer (f i) q‚ü©

def eval (p : MlPoly R n) (x : Vector R n) : R :=
  Vector.dotProduct p (monomialBasis x)

@[ext]
structure OracleVerifier {Œπ : Type} (oSpec : OracleSpec Œπ)
    (StmtIn : Type) {Œπ‚Çõ·µ¢ : Type} (OStmtIn : Œπ‚Çõ·µ¢ ‚Üí Type)
    (StmtOut : Type) {Œπ‚Çõ‚Çí : Type} (OStmtOut : Œπ‚Çõ‚Çí ‚Üí Type)
    {n : ‚Ñï} (pSpec : ProtocolSpec n)
    [O‚Çõ·µ¢ : ‚àÄ i, OracleInterface (OStmtIn i)]
    [O‚Çò : ‚àÄ i, OracleInterface (pSpec.Message i)]
    where
    
    

   
  verify : StmtIn ‚Üí pSpec.Challenges ‚Üí
    OracleComp (oSpec ++‚Çí ([OStmtIn]‚Çí ++‚Çí [pSpec.Message]‚Çí)) StmtOut

  
  
  

  

   
  embed : Œπ‚Çõ‚Çí ‚Ü™ Œπ‚Çõ·µ¢ ‚äï pSpec.MessageIdx

   
  hEq : ‚àÄ i, OStmtOut i = match embed i with
    | Sum.inl j => OStmtIn j
    | Sum.inr j => pSpec.Message j

def bool (j : Fin numWires) : Gate ùì° numWires :=
  { qL := -1, qR := 0, qO := 0, qM := 1, qC := 0, a := j, b := j, c := j }

def churchOr (p q : ChurchBool Œ±) : ChurchBool Œ± :=
  fun x y => p x (q x y)

@[simp]
abbrev OracleStatement.AfterFirstMessage : R1CS.MatrixIdx ‚äï Fin 1 ‚Üí Type :=
  Sum.rec (OracleStatement R pp) (fun _ => Witness R pp)

def computableNTTStage [Fact (LinearIndependent ùîΩq Œ≤)]
  (i : Fin ‚Ñì) (b : Fin (2 ^ (‚Ñì + R_rate)) ‚Üí L) : Fin (2^(‚Ñì + R_rate)) ‚Üí L :=
  have h_2_pow_i_lt_2_pow_‚Ñì_add_R_rate: 2^i.val < 2^(‚Ñì + R_rate) := by admit /- proof elided -/

@[reducible, inline]
instance instMvPolynomial : OracleInterface (R[X œÉ]) where
  Query := œÉ ‚Üí R
  Response := R
  answer := fun poly point => eval point poly

PowerSeries in Mathlib.RingTheory.PowerSeries.Basic

def HList.toDVec (l : HList) : DVec (m := Fin l.length) (fun i => l[i].1) := fun i => l[i].2

noncomputable def R
  (Œ¥ : ‚Ñö) (x‚ÇÄ : F)
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  : F[Z][X][Y] := (exists_factors_with_large_common_root_set k Œ¥ x‚ÇÄ h_gs).choose

@[inline] def add (a b : AssocNat) : AssocNat :=
  ‚ü®a ‚àò b, by admit /- proof elided -/
  ‚ü©

instance [inst : ‚àÄ i, DecidableEq (pSpec.Message i)] {k : Fin (n + 1)} :
    DecidableEq (MessagesUpTo k pSpec) :=
  @Fintype.decidablePiFintype _ _ (fun i => inst ‚ü®i.1.castLE (by admit /- proof elided -/
  ), i.property‚ü©) _

@[inline, specialize]
def prover : Prover oSpec Statement Unit Statement Unit !p[] where
  PrvState := fun _ => Statement
  input := Prod.fst
  sendMessage := fun i => nomatch i
  receiveChallenge := fun i => nomatch i
  output := fun stmt => pure (stmt, ())

@[inline] def lagrangeToMonoLevel {n : ‚Ñï} (j : Fin n) : Vector R (2 ^ n) ‚Üí Vector R (2 ^ n) :=
  fun v =>
    let stride : ‚Ñï := 2 ^ j.val  
    Vector.ofFn (fun i : Fin (2 ^ n) =>
      if (BitVec.ofFin i).getLsb j then
        v[i] - v[i - stride]'(Nat.sub_lt_of_lt i.isLt)
      else
        v[i])

def take (j : Fin (n + 1)) (messages : Messages pSpec) : MessagesUpTo j pSpec :=

def collisionPerm : Prop :=
  collisionFwdFwd trace ‚à® collisionBwdBwd trace ‚à® collisionFwdBwd trace ‚à® collisionBwdFwd trace

alias E_prp := collisionPerm

structure ProverInit (PrvState : Type) where
  init : PrvState

noncomputable def embeddingOfùí™IntoùïÉ (H : F[X][Y]) : ùí™ H ‚Üí+* ùïÉ H :=
  Ideal.quotientMap
        (I := Ideal.span {H_tilde' H}) (Ideal.span {H_tilde H})
        bivPolyHom sorry

noncomputable def getSumcheckRoundPoly (i : Fin ‚Ñì) (h : ‚Ü•L‚¶É‚â§ 2‚¶Ñ[X Fin (‚Ñì - ‚Üëi.castSucc)])
    : L‚¶É‚â§ 2‚¶Ñ[X] :=

Lean.PrettyPrinter.Unexpander in Init.Prelude

instance : PrimeOrder G where
  p := p
  hCard := PrimeOrderWith.hCard

def sub (m n : ChurchNat Œ±) : ChurchNat Œ± := sorry 

def proverRound (i : Fin n) : ProverRound oSpec (pSpec R deg) where
  PrvState := (proverState R n deg i).PrvState

  sendMessage
  | ‚ü®0, _‚ü© => fun state =>
    match n with
    | 0 => sorry
    | n + 1 =>
      let ‚ü®‚ü®_, challenges‚ü©, oStmt‚ü© := state
      let ‚ü®poly, hp‚ü© := oStmt 0
      pure ‚ü® ‚ü®‚àë x ‚àà (univ.map D) ^·∂† (n - i), poly ‚∏®X ‚¶Éi‚¶Ñ, challenges, x‚∏©'(by admit /- proof elided -/
      ),
        sumcheck_roundPoly_degreeLE R n deg D i hp‚ü©,
          state‚ü©
  | ‚ü®1, h‚ü© => nomatch h

  receiveChallenge
  | ‚ü®0, h‚ü© => nomatch h
  | ‚ü®1, _‚ü© => fun ‚ü®‚ü®target, challenges‚ü©, oStmt‚ü© => pure fun chal =>
    let ‚ü®poly, hp‚ü© := oStmt 0
    letI newChallenges : Fin i.succ ‚Üí R := Fin.snoc challenges chal
    letI newTarget := ‚àë x ‚àà (univ.map D) ^·∂† (n - i - 1), poly ‚∏®newChallenges, x‚∏©'(by admit /- proof elided -/
    )
    ‚ü®‚ü®newTarget, newChallenges‚ü©, fun _ => ‚ü®poly, hp‚ü©‚ü©

protected def Prover.id : Prover oSpec Statement Witness Statement Witness !p[] where
  PrvState := fun _ => Statement √ó Witness
  input := _root_.id
  sendMessage := fun i => Fin.elim0 i
  receiveChallenge := fun i => Fin.elim0 i
  output := pure

multiplicity in Mathlib.RingTheory.Multiplicity

Mathlib.Linter.TextBased.ErrorFormat in Mathlib.Tactic.Linter.TextBased

instance : Slice (ProtocolSpec n) ‚Ñï ‚Ñï
    (fun _ start stop => start ‚â§ stop ‚àß stop ‚â§ n)
    (fun _ start stop _ => ProtocolSpec (stop - start))
    where
  slice := fun v start stop h => extract start stop h.1 h.2 v

def sub (a b : AssocNat) : AssocNat :=
  subNat a b.toNat

gen in VCVio.CryptoFoundations.FiatShamir

def buildMerkleTree (Œ±) (n : ‚Ñï) (leaves : List.Vector Œ± (2 ^ n)) :
    OracleComp (spec Œ±) (Cache Œ± n) := do
  match n with
  | 0 => do
    return fun j => (by admit /- proof elided -/
      )
  | n + 1 => do
    let lastLayer ‚Üê buildLayer Œ± n leaves
    let cache ‚Üê buildMerkleTree Œ± n lastLayer
    return Cache.cons Œ± n leaves cache

def modSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (k : Fin (‚àë j, n j)) : Fin (n (divSum k)) :=
  ‚ü®k - ‚àë j, n (Fin.castLE (divSum k).isLt.le j), by admit /- proof elided -/
    ‚ü©

@[inline] def zero : Cayley T :=
  ‚ü®id, by admit /- proof elided -/
  ‚ü©

@[reducible, inline, specialize]
def OracleMessage (i : pSpec.OracleMessageIdx) := pSpec.Message i.1

AddMonoid in Mathlib.Algebra.Group.Defs

BitVec.zero in Init.Data.BitVec.Basic

def FullData.EquivIndexFun {Œ± : Type} (s : Skeleton) :
    FullData Œ± s ‚âÉ (SkeletonNodeIndex s ‚Üí Œ±) where
  toFun := fun tree idx => tree.get idx
  invFun := fun f => FullData.ofFun s f
  left_inv := by admit /- proof elided -/

@[reducible, simp]
def rbrSoundness
    (langIn : Set (Statement √ó ‚àÄ i, OStatement i))
    (verifier : OracleVerifier oSpec Statement OStatement Bool (fun _ : Empty => Unit) pSpec)
    (rbrSoundnessError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) : Prop :=
  verifier.rbrSoundness init impl langIn acceptRejectOracleRel.language rbrSoundnessError

BitVec.extractLsb in Init.Data.BitVec.Basic

LT in Init.Prelude

def weightedDegreeMonomialXY {n m : ‚Ñï} (a b t : ‚Ñï) : ‚Ñï :=
  a * (degreeX (monomialXY n m t)) + b * natDegreeY (monomialXY n m t)

@[inline] def ofNat (n : Nat) : Cayley T :=
  ‚ü®fun t => succ'^[n] t, Function.iterate_succ_apply' succ' n‚ü©

instance [Zero T] [ToNat T] : Mul (Cayley T) where
  mul := mul

@[reducible]
def SimOracle.Stateless (spec : OracleSpec Œπ) (spec‚Çú : OracleSpec Œπ‚Çú) :=
  QueryImpl spec (OracleComp spec‚Çú)

abbrev rtake (m : ‚Ñï) (h : m ‚â§ n)
    (transcript : FullTranscript pSpec) : FullTranscript (pSpec.rtake m h) :=
  Fin.rtake m h transcript

noncomputable def E_and_Q_to_a_solution (e : ‚Ñï) (E Q : Polynomial F) (i : Fin n) : F :=
  if i < e then E.toFinsupp i else Q.toFinsupp (i - e)

noncomputable def sDomain (i : Fin r) : Subspace ùîΩq L :=
  let W_i_norm := normalizedW ùîΩq Œ≤ i
  let h_W_i_norm_is_additive : IsLinearMap ùîΩq (fun x : L => W_i_norm.eval x) :=
    AdditiveNTT.normalizedW_is_additive ùîΩq Œ≤ i
  Submodule.map (polyEvalLinearMap W_i_norm h_W_i_norm_is_additive)
    (U ùîΩq Œ≤ ‚ü®‚Ñì + R_rate, h_‚Ñì_add_R_rate‚ü©)

def trans (eqv : Equiv pSpec pSpec') (eqv' : Equiv pSpec' pSpec'') : Equiv pSpec pSpec'' where
  round_eq := eqv.round_eq.trans eqv'.round_eq
  dir_eq := fun i => by admit /- proof elided -/

class AlgebraTower {Œπ : Type*} [Preorder Œπ] (AT : Œπ ‚Üí Type*)
  [‚àÄ i, CommSemiring (AT i)] where
   
  protected algebraMap : ‚àÄ i j, (h : i ‚â§ j) ‚Üí (AT i ‚Üí+* AT j)
   
  commutes' : ‚àÄ (i j : Œπ) (h : i ‚â§ j) (r : AT i) (x : AT j),
    (algebraMap i j h r) * x = x * (algebraMap i j h r)
  coherence': ‚àÄ (i j k : Œπ) (h1 : i ‚â§ j) (h2 : j ‚â§ k),
    algebraMap i k (h1.trans h2) =
      (algebraMap j k h2).comp (algebraMap i j h1)

def bitsToU (i : Fin r) (k : Fin (2 ^ i.val)) :
    AdditiveNTT.U (L := L) (ùîΩq := ùîΩq) (Œ≤ := Œ≤) i :=
  let val := (Finset.univ : Finset (Fin i)).sum fun j =>
    if (Nat.getBit (n := k.val) (k := j.val) == 1) then
      Œ≤ ‚ü®j, by admit /- proof elided -/
      ‚ü©
    else 0

  
  ‚ü®val, by admit /- proof elided -/
  ‚ü©

def ConstraintSystem (ùì° : Type) (numWires numGates : ‚Ñï) := Fin numGates ‚Üí Gate ùì° numWires

local instance : Fintype F := Fintype.ofFinite F

MvPolynomial.degreeOf in Mathlib.Algebra.MvPolynomial.Degrees

def linearMvExtension :
  Polynomial.degreeLT F (2^m) ‚Üí‚Çó[F] MvPolynomial (Fin m) F where
    
    toFun p := (p : Polynomial F).sum fun i a =>
      MvPolynomial.monomial (bitExpo i) a
    map_add' := by admit /- proof elided -/

def FullData.Equiv {Œ±} (s : Skeleton) :
    FullData Œ± s ‚âÉ InternalData Œ± s √ó LeafData Œ± s :=

@[reducible, inline, specialize, simp]
def MessageIdx (vPSpec : VectorSpec n) := {i : Fin n // vPSpec.dir i = .P_to_V}

instance [NeZero k] {f : Fin k ‚Üí Œπ ‚Üí F} : Nonempty (Finset.univ.image f) :=

Quotient.mk in Init.Core

instance : Add (Cayley T) where
  add := add

Subgroup in Mathlib.Algebra.Group.Subgroup.Defs

Finsupp.mapRange in Mathlib.Data.Finsupp.Defs

abbrev CoeffVecSpace (L : Type u) (‚Ñì : Nat) := Fin (2^‚Ñì) ‚Üí L

List.rightpad in Init.Data.List.Basic

def Prover.liftContext
    (lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut)
    (P : Prover oSpec InnerStmtIn InnerWitIn InnerStmtOut InnerWitOut pSpec) :
      Prover oSpec OuterStmtIn OuterWitIn OuterStmtOut OuterWitOut pSpec where
  PrvState := fun i => P.PrvState i √ó OuterStmtIn √ó OuterWitIn
  input := fun ctxIn => ‚ü®P.input <| lens.proj ctxIn, ctxIn‚ü©
  sendMessage := fun i ‚ü®prvState, stmtIn, witIn‚ü© => do
    let ‚ü®msg, prvState'‚ü© ‚Üê P.sendMessage i prvState
    return ‚ü®msg, ‚ü®prvState', stmtIn, witIn‚ü©‚ü©
  receiveChallenge := fun i ‚ü®prvState, stmtIn, witIn‚ü© => do
    let f ‚Üê P.receiveChallenge i prvState
    return fun chal => ‚ü®f chal, stmtIn, witIn‚ü©
  output := fun ‚ü®prvState, stmtIn, witIn‚ü© => do
    let ‚ü®innerStmtOut, innerWitOut‚ü© ‚Üê P.output prvState
    return lens.lift (stmtIn, witIn) (innerStmtOut, innerWitOut)

def ChurchBool (Œ± : Type) : Type := Œ± ‚Üí Œ± ‚Üí Œ±

def Array.toFinVec {Œ± : Type _} (n : ‚Ñï) (arr : Array Œ±) (h : arr.size = n) : Fin n ‚Üí Œ± :=
  fun i => arr[i]

def additiveNTTInvariant (evaluation_buffer : Fin (2 ^ (‚Ñì + R_rate)) ‚Üí L)
    (original_coeffs : Fin (2 ^ ‚Ñì) ‚Üí L) (i : Fin (‚Ñì + 1)) : Prop :=
  ‚àÄ (j : Fin (2^(‚Ñì + R_rate))),
    let u_b_v := j.val
    let v: Fin (2^i.val) := ‚ü®Nat.getLowBits i.val u_b_v, by admit /- proof elided -/
    ‚ü© 
    let u_b := u_b_v / (2^i.val) 
    have h_u_b : u_b = u_b_v / (2^i.val) := by admit /- proof elided -/

ProbComp in VCVio.OracleComp.OracleComp

@[inline]
def seqCompose {m : ‚Ñï}
    (Stmt : Fin (m + 1) ‚Üí Type) {Œπ‚Çõ : Fin (m + 1) ‚Üí Type} (OStmt : (i : Fin (m + 1)) ‚Üí Œπ‚Çõ i ‚Üí Type)
    (Wit : Fin (m + 1) ‚Üí Type) {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (P : (i : Fin m) ‚Üí
      OracleProver oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Wit i.castSucc)
        (Stmt i.succ) (OStmt i.succ) (Wit i.succ) (pSpec i)) :
    OracleProver oSpec (Stmt 0) (OStmt 0) (Wit 0) (Stmt (Fin.last m)) (OStmt (Fin.last m))
      (Wit (Fin.last m)) (seqCompose pSpec) :=
  Prover.seqCompose (fun i => Stmt i √ó (‚àÄ j, OStmt i j)) Wit P

Sum.isLeft in Init.Data.Sum.Basic

structure HashStateWithInstructions (U : Type) [SpongeUnit U] (H : Type*)
    [DuplexSpongeInterface U H] where
   
  ds : H
   
  stack : Array DomainSeparator.Op
deriving Inhabited, DecidableEq, Repr

noncomputable def ansPoly (S : Finset F) (Ans : S ‚Üí F) : Polynomial F :=
  Lagrange.interpolate S.attach (fun i => (i : F)) Ans

@[ext]
structure Equiv {m n : ‚Ñï} (pSpec : ProtocolSpec m) (pSpec' : ProtocolSpec n) where
  round_eq : m = n
  dir_eq : ‚àÄ i, pSpec.dir i = pSpec'.dir (Fin.cast round_eq i)
  typeEquiv : ‚àÄ i, pSpec.¬´Type¬ª i ‚âÉ pSpec'.¬´Type¬ª (Fin.cast round_eq i)

noncomputable def sDomain_basis (i : Fin r) (h_i : i < ‚Ñì + R_rate) :
    Basis (Fin (‚Ñì + R_rate - i)) ùîΩq (
      sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i) :=

LawfulBEq in Init.Core

Finite in Mathlib.Data.Finite.Defs

Algebra.TensorProduct.leftAlgebra in Mathlib.RingTheory.TensorProduct.Basic

BitVec.setWidth in Init.Data.BitVec.Basic

instance {Œπ : Type} : OracleInterface (OracleStatement Œπ F ()) := OracleInterface.instFunction

noncomputable def minWtCodewords [Semiring F] (LC : LinearCode Œπ F) : ‚Ñï :=
  sInf {w | ‚àÉ c ‚àà LC, c ‚â† 0 ‚àß Code.wt c = w}

def BerlekampWelchMatrix
  (e k : ‚Ñï)
  (œâs f : Fin n ‚Üí F) : Matrix (Fin n) (Fin (2 * e + k)) F :=
  Matrix.of fun i j =>
    let Œ±·µ¢ := œâs i
    if ‚Üëj < e then -Rhs j.1 œâs f i else -Œ±·µ¢^(j - e)

Fin.succAboveEmb in Mathlib.Data.Fin.Embedding

Array.mk in Init.Prelude

noncomputable def twiddleFactor (i : Fin ‚Ñì) (u : Fin (2 ^ (‚Ñì + R_rate - i - 1))) : L :=
  ‚àë (‚ü®k, hk‚ü©: Fin (‚Ñì + R_rate - i - 1)),
    if Nat.getBit k u.val = 1 then
      
        
      (normalizedW ùîΩq Œ≤ ‚ü®i, by admit /- proof elided -/
      ‚ü©).eval (Œ≤ ‚ü®i + 1 + k, by admit /- proof elided -/
      ‚ü©)
    else 0

def SumFunEquivProd (Œ± Œ≤ Œ≥ : Type) : ((Œ± ‚äï Œ≤) ‚Üí Œ≥) ‚âÉ (Œ± ‚Üí Œ≥) √ó (Œ≤ ‚Üí Œ≥) :=
{ toFun := fun f => (fun a => f (.inl a), fun b => f (.inr b))
  , invFun := fun p x => match x with | .inl a => p.fst a | .inr b => p.snd b
  , left_inv := by admit /- proof elided -/

def totalNumPermQueriesMessage : Nat :=
  ‚àë i, pSpec.L‚Çö·µ¢ i

@[simp]
abbrev relation := R1CS.relation R pp.toSizeR1CS

Polynomial.IsRoot in Mathlib.Algebra.Polynomial.Eval.Defs

def commitPrvState (i : Fin ‚Ñì) : Fin (1 + 1) ‚Üí Type := fun
  | ‚ü®0, _‚ü© => Statement (L := L) Context i.succ √ó
    (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j) √ó
    Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ
  | ‚ü®1, _‚ü© => Statement (L := L) Context i.succ √ó
    (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.succ j) √ó
    Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ

Set.Pairwise in Mathlib.Logic.Pairwise

Vector.finRange in Init.Data.Vector.FinRange

@[reducible]
def GroupOpOracle : OracleSpec Unit := fun _ => (Œπ √ó Œπ √ó Œπ, Unit)

def e (B : Finset (Fin n ‚Üí F)) (v : Fin n ‚Üí F) : ‚Ñö :=
  (1 : ‚Ñö)/B.card * ‚àë x ‚àà B, Œî‚ÇÄ(v, x)

@[reducible, simp]
def mapOStmt (oStmtIn : ‚àÄ i, OStmtIn i) : ‚àÄ i, OStmtOut i := fun i => (hEq i) ‚ñ∏ oStmtIn (embedIdx i)

def foldr' {Œ± : Type u} (n : ‚Ñï) (f : (i : Fin n) ‚Üí Œ± ‚Üí Œ±) (init : Œ±) : Œ± :=
  dfoldr' n (fun _ => Œ±) f init

IO.throwServerError in Lean.Server.Utils

def fiberEvaluationMapping (i : Fin r) (steps : ‚Ñï) (h_i_add_steps : i.val + steps < ‚Ñì + ùì°)
    (f : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) i ‚Üí L)
    (y : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate)
      ‚ü®‚Üëi + steps, by admit /- proof elided -/
      ‚ü©)
    : Fin (2 ^ steps) ‚Üí L :=
  
  let fiberMap := qMap_total_fiber ùîΩq Œ≤ (i := i) (steps := steps)
    (h_i_add_steps := h_i_add_steps) (y := y)

  
  fun idx => f (fiberMap idx)

instance instDCastPSigma : DCast ((a : Œ±) √ó' Œ≤ a) (fun a => Œ≥ a.1 a.2) where
  dcast hab c := dcast‚ÇÇ (by admit /- proof elided -/
  ) (by admit /- proof elided -/
  ) c
  dcast_id := by admit /- proof elided -/

HSMul in Init.Prelude

List.rtake in Mathlib.Data.List.DropRight

def verifier : Verifier oSpec (StmtIn R √ó (‚àÄ i, OStmtIn R deg i))
                              (StmtOut R √ó (‚àÄ i, OStmtOut R deg i)) (pSpec R deg) where
  verify := fun ‚ü®target, oStmt‚ü© transcript => do
    letI polyLE := transcript 0
    guard (‚àë x ‚àà (univ.map D), polyLE.val.eval x = target)
    letI chal := transcript 1
    pure ‚ü®‚ü®(oStmt ()).val.eval chal, chal‚ü©, fun _ => oStmt ()‚ü©

instance instDecidableEqOption {Œ± : Type*} [DecidableEq Œ±] :
    DecidableEq (Option Œ±) := inferInstance

@[simp]
instance BTFieldIsField (k : ‚Ñï) : Field (BTField k) := (BinaryTowerAux k).2.instField

def take (j : Fin (k + 1)) (messages : MessagesUpTo k pSpec) :
    MessagesUpTo (j.castLE (by admit /- proof elided -/
    )) pSpec :=
  fun i => messages ‚ü®i.val.castLE (by admit /- proof elided -/
  ), i.property‚ü©

def allScriptsDocumented : IO Bool := do
  \n  \
      {String.intercalate "," undocumented.toList}"
  return undocumented.size == 0

def verifyProof {n : ‚Ñï} (i : Fin (2 ^ n)) (leaf : Œ±) (root : Œ±) (proof : List.Vector Œ± n) :
    OracleComp (spec Œ±) Unit := do
  let putative_root ‚Üê getPutativeRoot Œ± i leaf proof
  guard (putative_root = root)

def vflatten {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (v : (i : Fin m) ‚Üí Fin (n i) ‚Üí Œ±) :
    Fin (vsum n) ‚Üí Œ± :=
  dflatten v

def D_YZ (Q : F[Z][X][Y]) : ‚Ñï :=
  Option.getD (dflt := 0) <| Finset.max
    (Finset.image
            (
              fun j =>
                Option.getD (
                  Finset.max (
                    Finset.image
                      (fun k => j + (Bivariate.coeff Q j k).natDegree)
                      (Q.coeff j).support
                  )
                ) 0
            )
            Q.support
    )

def finSum'FinEquiv' {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} : (i : Fin m) √ó Fin (n i) ‚âÉ Fin (vsum n) where
  toFun := fun ij => embedSum ij.1 ij.2
  invFun := splitSum
  left_inv := fun ij => splitSum_embedSum ij.1 ij.2
  right_inv := embedSum_splitSum

private noncomputable def oddPart' (f : Polynomial F) : Polynomial F :=
  match f with
  | ‚ü®‚ü®supp, f, pr‚ü©‚ü© => ‚ü®‚ü®
      shift_left (erase_even supp),
      fun n => if Even n then f (n + 1) else 0, by admit /- proof elided -/
      ‚ü©‚ü©

@[reducible, inline, specialize, simp]
def Challenge (pSpec : ProtocolSpec n) (i : ChallengeIdx pSpec) := pSpec.¬´Type¬ª i.val

def computeInitialSumcheckPoly (t : MultilinearPoly L ‚Ñì)
    (m : MultilinearPoly L ‚Ñì) : MultiquadraticPoly L ‚Ñì :=
  ‚ü®m * t, by
    rw [MvPolynomial.mem_restrictDegree_iff_degreeOf_le]
    intro i
    have h_t_deg: degreeOf i t.val ‚â§ 1 :=
      degreeOf_le_iff.mpr fun term a ‚Ü¶ (t.property) a i
    have h_m_deg: degreeOf i m.val ‚â§ 1 :=
      degreeOf_le_iff.mpr fun term a ‚Ü¶ (m.property) a i
    calc
      _ ‚â§ (degreeOf i m.val) + (degreeOf i t.val) :=
        degreeOf_mul_le i m.val t.val
      _ ‚â§ 2 :=

instance instEquivalenceEquiv : Equivalence (equiv (R := R)) where
  refl := equiv_refl
  symm := equiv_symm
  trans := equiv_trans

def ratchet (sponge : DuplexSponge U C) :
    OracleComp (forwardPermutationOracle C) (DuplexSponge U C) := do
  let permutedState : C ‚Üê query (spec := forwardPermutationOracle C) () sponge.state
  
  let vecState : Vector U SpongeSize.N := SpongeState.get permutedState
  
  let zeroed : Vector U SpongeSize.N :=
    Vector.ofFn (fun i => if i < SpongeSize.R then 0 else vecState[i])
  
  let newVecState := SpongeState.update permutedState zeroed
  
  return { sponge with
    state := newVecState,
    squeezePos := Fin.last SpongeSize.R }

def map (f : R ‚Üí+* S) (p : MlPolyEval R n) : MlPolyEval S n :=
  Vector.map (fun a => f a) p

HMul.hMul in Init.Prelude

@[inline, specialize]
def neg (p : UniPoly R) : UniPoly R := p.map (fun a => -a)

noncomputable def polyQuotient (S : Finset F) (fPoly : F[X]) : F[X] :=
    (fPoly - (ansPoly S (fun s => fPoly.eval s))) / (vanishingPoly S)

class SpongeState (U : Type) [SpongeUnit U] [SpongeSize] (Œ± : Type*) extends
    Zero Œ±,
    Initialize Œ± (Vector UInt8 32)
    where
  get : Œ± ‚Üí Vector U SpongeSize.N
  update : Œ± ‚Üí Vector U SpongeSize.N ‚Üí Œ±

def Permute.ofEquiv (Œ± : Type*) (e : Equiv Œ± Œ±) : Permute Œ± where
  permute := e.toFun

def challengeTensorProduct (steps : ‚Ñï) (r_challenges : Fin steps ‚Üí L) : Vector L (2 ^ steps) :=
  if h_steps_zero : steps = 0 then
    
    by
      rw [h_steps_zero, pow_zero]
      exact ‚ü®#[1], rfl‚ü©
  else
    
    Nat.rec
      (motive := fun k => k ‚â§ steps ‚Üí Vector L (2^k))
      (fun _ => ‚ü®#[1], rfl‚ü©)  
      (fun k ih h_k_le =>
        
        let prev_vec := ih (Nat.le_trans (Nat.le_succ k) h_k_le)
        let r_k := r_challenges ‚ü®k, by admit /- proof elided -/
        ‚ü©
        
        Vector.ofFn (fun idx : Fin (2^k.succ) =>
          let prev_idx : Fin (2^k) := ‚ü®idx.val / 2, by admit /- proof elided -/
            ‚ü©
          let bit := idx.val % 2
          let prev_val := prev_vec.get prev_idx
          if bit = 0 then (1 - r_k) * prev_val else r_k * prev_val))
      steps (le_refl steps)

def perfectCompleteness
    (relIn : Set ((StmtIn √ó ‚àÄ i, OStmtIn i) √ó WitIn))
    (relOut : Set ((StmtOut √ó ‚àÄ i, OStmtOut i) √ó WitOut))
    (oracleReduction : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec) :
      Prop :=
  Reduction.perfectCompleteness init impl relIn relOut oracleReduction.toReduction

noncomputable def polynomialAlgEquiv : P ‚âÉ‚Çê[R] R[X] where
  toFun := toPolynomialAlgHom
  invFun := ofPolynomialAlgHom
  left_inv := by admit /- proof elided -/

@[reducible, simp]
def OracleContext.Lens.IsComplete {OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut : Type}
    {Outer_Œπ‚Çõ·µ¢ : Type} {OuterOStmtIn : Outer_Œπ‚Çõ·µ¢ ‚Üí Type} [‚àÄ i, OracleInterface (OuterOStmtIn i)]
    {Outer_Œπ‚Çõ‚Çí : Type} {OuterOStmtOut : Outer_Œπ‚Çõ‚Çí ‚Üí Type} [‚àÄ i, OracleInterface (OuterOStmtOut i)]
    {Inner_Œπ‚Çõ·µ¢ : Type} {InnerOStmtIn : Inner_Œπ‚Çõ·µ¢ ‚Üí Type} [‚àÄ i, OracleInterface (InnerOStmtIn i)]
    {Inner_Œπ‚Çõ‚Çí : Type} {InnerOStmtOut : Inner_Œπ‚Çõ‚Çí ‚Üí Type} [‚àÄ i, OracleInterface (InnerOStmtOut i)]
    {OuterWitIn OuterWitOut InnerWitIn InnerWitOut : Type}
    (outerRelIn : Set ((OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i)) √ó OuterWitIn))
    (innerRelIn : Set ((InnerStmtIn √ó (‚àÄ i, InnerOStmtIn i)) √ó InnerWitIn))
    (outerRelOut : Set ((OuterStmtOut √ó (‚àÄ i, OuterOStmtOut i)) √ó OuterWitOut))
    (innerRelOut : Set ((InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i)) √ó InnerWitOut))
    (compat : (OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i)) √ó OuterWitIn ‚Üí
              (InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i)) √ó InnerWitOut ‚Üí Prop)
    (lens : OracleContext.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                                    OuterOStmtIn OuterOStmtOut InnerOStmtIn InnerOStmtOut
                                    OuterWitIn OuterWitOut InnerWitIn InnerWitOut) :=
  Context.Lens.IsComplete outerRelIn innerRelIn outerRelOut innerRelOut compat lens.toContext

CommMonoid in Mathlib.Algebra.Group.Defs

Finsupp.equivFunOnFinite in Mathlib.Data.Finsupp.Defs

Lean.mkRawNatLit in Lean.Expr

Function.uncurry in Init.Data.Function

Fin.succAbove in Mathlib.Data.Fin.SuccPred

StrongRankCondition in Mathlib.LinearAlgebra.InvariantBasisNumber

def InternalData.leftSubtree {Œ± : Type} {s_left s_right : Skeleton}
    (tree : InternalData Œ± (Skeleton.internal s_left s_right)) :
    InternalData Œ± s_left :=
  match tree with
  | InternalData.internal _ left _right =>
    left

instance {k : ‚Ñï} : IntCast (ConcreteBTField k) where
  intCast n:= intCast n

instance : Fact (Nat.Prime scalarFieldSize) := ‚ü®ScalarField_is_prime‚ü©

instance [VerifierFirst pSpec] [h : VCVCompatible (pSpec.¬´Type¬ª 0)] :
    ‚àÄ i, VCVCompatible (pSpec.Challenge i)
  | ‚ü®0, _‚ü© => inferInstance

inductive ScalarOp where | add | sub | mul | div

@[reducible]
def combineMap : StmtIn √ó WitIn ‚Üí OracleComp oSpec (StmtOut √ó WitOut) :=
  fun ‚ü®stmt, wit‚ü© => do return (‚Üê mapStmt stmt, ‚Üê mapWit stmt wit)

BitVec.getLsb in Init.Data.BitVec.Basic

def oracleReduction.randomQuery : OracleReduction oSpec
    (StmtAfterCheckClaim R) (OStmtAfterCheckClaim R deg) Unit
    (StmtAfterRandomQuery R) (OStmtAfterRandomQuery R deg) Unit ‚ü®!v[.V_to_P], !v[R]‚ü© :=
  sorry

abbrev Size.n_x : ‚Ñï := sz.n - sz.n_w

class DCast‚ÇÇ (Œ± : Sort*) (Œ≤ : Œ± ‚Üí Sort*) (Œ≥ : (a : Œ±) ‚Üí Œ≤ a ‚Üí Sort*) [DCast Œ± Œ≤] where
  dcast‚ÇÇ : ‚àÄ {a a' : Œ±} {b : Œ≤ a} {b' : Œ≤ a'},
    (ha : a = a') ‚Üí (dcast ha b = b') ‚Üí Œ≥ a b ‚Üí Œ≥ a' b'
  dcast‚ÇÇ_id : ‚àÄ {a : Œ±} {b : Œ≤ a}, dcast‚ÇÇ (Eq.refl a) dcast_eq = (id : Œ≥ a b ‚Üí Œ≥ a b)

noncomputable def queryProver :
  OracleProver []‚Çí
    (FinalStatement F k) (FinalOracleStatement D x s) (Witness F s d (Fin.last (k + 1)))
    (FinalStatement F k) (FinalOracleStatement D x s) (Witness F s d (Fin.last (k + 1)))
    (pSpec D x l) where
  PrvState
  | _ =>
    (FinalStatement F k √ó ((i : Fin (k + 2)) ‚Üí FinalOracleStatement D x s i)) √ó
      Witness F s d (Fin.last (k + 1))

  input := id

  sendMessage
  | ‚ü®0, h‚ü© => nomatch h

  receiveChallenge
  | ‚ü®1, _‚ü© => fun x => pure <| fun _ => x

  output := pure

instance {i : Fin (n + 1)} : OfNat (evalDomain D i) 1 where
  ofNat := ‚ü®1, one_in_doms D i‚ü©

def evalWAt (i : Fin r) (x : L) : L :=
  ((getUElements (Œ≤ := Œ≤) (‚Ñì := ‚Ñì) (R_rate := R_rate) i).map (fun u => x - u)).prod

noncomputable def batchVerifier :
  OracleVerifier []‚Çí
    Unit (OracleStatement D x m)
    ((Fin m ‚Üí F) √ó Fri.Spec.Statement F (0 : Fin (k + 1)))
    (OracleStatement D x m)
    (batchSpec F m) where
  verify := fun _ chals => pure ‚ü®chals ‚ü®0, by admit /- proof elided -/
  ‚ü©, Fin.elim0‚ü©
  embed :=
    ‚ü®
      fun i => Sum.inl i,
      by admit /- proof elided -/
    ‚ü©
  hEq := by admit /- proof elided -/

UInt64 in Init.Prelude

instance instNatPow {n : ‚Ñï} : NatPow (CNat n) := match n with
  | 0 => by admit /- proof elided -/
  | .succ n => by admit /- proof elided -/

def stirRelation
    {F : Type} [Field F] [Fintype F] [DecidableEq F]
    {Œπ : Type} [Fintype Œπ] [Nonempty Œπ]
    (degree : ‚Ñï) (œÜ : Œπ ‚Ü™ F) (err : ‚Ñù)
    : Set ((Unit √ó ‚àÄ i, (OracleStatement Œπ F i)) √ó Unit) :=
  fun ‚ü®‚ü®_, oracle‚ü©, _‚ü© => Œ¥·µ£(oracle (), ReedSolomon.code œÜ degree) ‚â§ err

protected def cast (P : OracleProver oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec‚ÇÅ) :
    OracleProver oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec‚ÇÇ :=
  Prover.cast hn hSpec P

def fillNextUnits (state : FSVerifierState U H) (count : Nat) :
    Except DomainSeparatorMismatch (FSVerifierState U H √ó Array U) := do
  
  let bytesNeeded := count * HasSize.size U UInt8
  if state.nargString.size < bytesNeeded then
    .error {
      message := s!"Insufficient transcript remaining, need {bytesNeeded} bytes,
        got {state.nargString.size}" }
  else
    
    let readBytes := state.nargString.extract 0 bytesNeeded
    let remaining := state.nargString.extract bytesNeeded state.nargString.size
    
    let units := Array.range count |>.mapM (fun i =>
      let unitBytes := readBytes.extract (i * HasSize.size U UInt8) (HasSize.size U UInt8)
      DeserializeOption.deserialize unitBytes)
    match units with
    | some unitsArray =>
      
      let newHashState ‚Üê state.hashState.absorb unitsArray
      .ok ({ hashState := newHashState, nargString := remaining }, unitsArray)
    | none =>
      .error { message := "Failed to deserialize units from NARG string" }

List.mergeSort in Init.Data.List.Sort.Basic

def equivFin2 : Direction ‚âÉ Fin 2 where
  toFun := fun dir => match dir with | .V_to_P => ‚ü®0, by admit /- proof elided -/
  ‚ü© | .P_to_V => ‚ü®1, by admit /- proof elided -/
  ‚ü©
  invFun := fun n => match n with | ‚ü®0, _‚ü© => .V_to_P | ‚ü®1, _‚ü© => .P_to_V
  left_inv := fun dir => match dir with | .P_to_V => rfl | .V_to_P => rfl
  right_inv := fun n => match n with | ‚ü®0, _‚ü© => rfl | ‚ü®1, _‚ü© => rfl

private noncomputable def E (œâs : Fin n ‚Üí F)
  (f : Fin n ‚Üí F) (p : Polynomial F) (e : ‚Ñï) : Polynomial F :=
  X ^ (e - (Œî‚ÇÄ(f, p.eval ‚àò œâs) : ‚Ñï)) * ElocPolyF œâs f p

structure SumcheckBaseContext (L : Type) (‚Ñì : ‚Ñï) where
  t_eval_point : Fin ‚Ñì ‚Üí L         
  original_claim : L               

Module in Mathlib.Algebra.Module.Defs

def StateRestoration.Soundness (oSpec : OracleSpec Œπ) (StmtIn : Type)
    {n : ‚Ñï} (pSpec : ProtocolSpec n) :=
  OracleComp (oSpec ++‚Çí (srChallengeOracle StmtIn pSpec)) (StmtIn √ó pSpec.Messages)

Even in Mathlib.Algebra.Group.Even

noncomputable def proximity_gap_johnson (k m : ‚Ñï) : ‚Ñï :=
  let rho := (k + 1 : ‚Ñö) / n
  Nat.floor ((1 : ‚Ñù) - Real.sqrt rho - Real.sqrt rho / (2 * m))

class Deserialize (Œ± : Type u) (Œ≤ : Type v) where
  deserialize : Œ≤ ‚Üí Œ±

def natDegreeY (f : F[X][Y]) : ‚Ñï := Polynomial.natDegree f

AddMemClass in Mathlib.Algebra.Group.Subsemigroup.Defs

Div in Init.Prelude

instance [Zero T] [ToNat T] : DecidableRel (@LE.le (Cayley T) _) := fun a b =>
  Nat.decLe (‚Üëa) (‚Üëb)

@[inline, specialize]
def oracleVerifier : OracleVerifier oSpec
    Unit (fun _ : Fin 2 => OStatement)
    (Query OStatement) (fun _ : Fin 2 => OStatement) (pSpec OStatement) where

  verify := fun _ chal => do
    let q : Query OStatement := chal ‚ü®0, rfl‚ü©
    pure q

  embed := Function.Embedding.inl

  hEq := by admit /- proof elided -/

def oracleReduction.reduceClaim : OracleReduction oSpec
    (StmtAfterRandomQuery R) (OStmtAfterRandomQuery R deg) Unit
    (StmtOut R) (OStmtOut R deg) Unit !p[] :=

instance : ToNat Nat where
  toNat := id

@[simps!]
def equivMessagesChallenges :
    Transcript k pSpec ‚âÉ (MessagesUpTo k pSpec √ó ChallengesUpTo k pSpec) where
  toFun := toMessagesChallenges
  invFun := ofMessagesChallenges.uncurry
  left_inv := fun T => by admit /- proof elided -/

def StateRestoration (oSpec : OracleSpec Œπ)
    (StmtIn WitIn WitOut : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n) :=
  StmtIn ‚Üí 
  WitOut ‚Üí 
  pSpec.FullTranscript ‚Üí 
  QueryLog (oSpec ++‚Çí (srChallengeOracle StmtIn pSpec)) ‚Üí 
  QueryLog oSpec ‚Üí 
  OracleComp oSpec WitIn 

instance : MonadLift (StateT œÑ m) (StateT (œÉ √ó œÑ) m) where
  monadLift := fun x st => do let y ‚Üê x st.2; return (y.1, st.1, y.2)

noncomputable def matching_set_at_x
  (Œ¥ : ‚Ñö)
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  (x : Fin n)
  : Finset F := @Set.toFinset _ {z : F | ‚àÉ h : z ‚àà matching_set k œâs Œ¥ u‚ÇÄ u‚ÇÅ h_gs,
    u‚ÇÄ x + z * u‚ÇÅ x = 
      (Pz (matching_set_is_a_sub_of_coeffs_of_close_proximity k h_gs h)).eval (œâs x)} sorry

Set.PairwiseDisjoint in Mathlib.Data.Set.Pairwise.Basic

PFunctor in Mathlib.Data.PFunctor.Univariate.Basic

LinearMap.ker in Mathlib.Algebra.Module.Submodule.Ker

@[simp]
instance BTFieldIsDomain (k : ‚Ñï) : IsDomain (BTField k) := inferInstance

def rowRank : ‚Ñï :=
  Module.finrank F (rowSpan U)

def concat' {k : Fin n}
    (messages : (i : Fin k) ‚Üí (pSpec.dir (i.castLE (by admit /- proof elided -/
    )) = .P_to_V
      ‚Üí pSpec.¬´Type¬ª (i.castLE (by admit /- proof elided -/
      ))))
    (msg : (h : pSpec.dir k = .P_to_V) ‚Üí pSpec.Message ‚ü®k, h‚ü©) :
    (i : Fin (k + 1)) ‚Üí (pSpec.dir (i.castLE (by admit /- proof elided -/
    )) = .P_to_V) ‚Üí
      pSpec.¬´Type¬ª (i.castLE (by admit /- proof elided -/
      )) :=
  Fin.dconcat messages msg

@[reducible, simp]
def oraclePSpec : ProtocolSpec 1 := ‚ü®!v[.P_to_V], !v[Witness]‚ü©

Array.map in Init.Data.Array.Basic

Vector.ofFn in Init.Data.Vector.Basic

@[simp]
def transpose {m n : ‚Ñï} (matrix : Matrix Œ± m n) : Matrix Œ± n m :=
  ofFn (fun j => ofFn (fun i => (matrix.get i).get j))

instance inhabited [Inhabited R] : Inhabited (MlPolyEval R n) :=

def queryCodeword (j : Fin (toOutCodewordsCount ‚Ñì œë (Fin.last ‚Ñì)))
    (point : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®j.val * œë,
      by admit /- proof elided -/
          ‚ü©) :
  OracleComp ([OracleStatement ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (
  Fin.last ‚Ñì)]‚Çí) L :=
      OracleComp.lift <| by
        simpa using
          OracleSpec.query
            (spec := [OracleStatement ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì)]‚Çí)
            ‚ü®j, by admit /- proof elided -/
            ‚ü©
            (by admit /- proof elided -/
            )

noncomputable def evaluationPointœâ (i : Fin (‚Ñì + 1))
    (x : Fin (2 ^ (‚Ñì + R_rate - i))) : L := 
    
  ‚àë (‚ü®k, hk‚ü©: Fin (‚Ñì + R_rate - i)),
    if Nat.getBit k x.val = 1 then
      (normalizedW ùîΩq Œ≤ ‚ü®i, by admit /- proof elided -/
      ‚ü©).eval (Œ≤ ‚ü®i + k, by admit /- proof elided -/
      ‚ü©)
    else
      0

inductive SkeletonNodeIndex : Skeleton ‚Üí Type
  | ofLeaf : SkeletonNodeIndex Skeleton.leaf
  | ofInternal {left right} :
      SkeletonNodeIndex (Skeleton.internal left right)
  | ofLeft {left right : Skeleton} (idxLeft : SkeletonNodeIndex left) :
      SkeletonNodeIndex (Skeleton.internal left right)
  | ofRight {left right : Skeleton} (idxRight : SkeletonNodeIndex right) :
      SkeletonNodeIndex (Skeleton.internal left right)

Equiv.toFun in Mathlib.Logic.Equiv.Defs

Module.Basis.smulTower in Mathlib.RingTheory.AlgebraTower

Irreducible in Mathlib.Algebra.Group.Irreducible.Defs

@[inline, reducible]
def lift : OuterStmtIn √ó OuterWitIn ‚Üí InnerStmtOut √ó InnerWitOut ‚Üí OuterStmtOut √ó OuterWitOut :=
  fun ctxIn ctxOut =>
    ‚ü®lens.stmt.toFunB ctxIn.1 ctxOut.1, lens.wit.toFunB ctxIn ctxOut‚ü©

instance {s} : LawfulFunctor (fun Œ± => InternalData Œ± s) :=

def FullData.ofFun {Œ± : Type} (s : Skeleton)
    (f : SkeletonNodeIndex s ‚Üí Œ±) : FullData Œ± s :=
  match s with
  | .leaf => FullData.leaf (f SkeletonNodeIndex.ofLeaf)
  | .internal l r =>
      FullData.internal
        (f SkeletonNodeIndex.ofInternal)
        (FullData.ofFun l (fun idx => f (SkeletonNodeIndex.ofLeft idx)))
        (FullData.ofFun r (fun idx => f (SkeletonNodeIndex.ofRight idx)))

def OracleReduction.addSalt
    (R : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec)
    (saltComp : (i : pSpec.MessageIdx) ‚Üí R.prover.PrvState i.1.castSucc ‚Üí
      OracleComp oSpec (Salt i)) :
    OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut (pSpec.addSalt Salt) where
  prover := R.prover.addSalt Salt saltComp
  verifier := R.verifier.addSalt Salt

@[simp]
abbrev OracleStatement := R1CS.OracleStatement R pp.toSizeR1CS

@[inline, specialize]
def run (stmt : StmtIn) (wit : WitIn)
    (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí) (FullTranscript pSpec √ó StmtOut √ó WitOut) := do
  let ‚ü®transcript, state‚ü© ‚Üê prover.runToRound (Fin.last n) stmt wit
  return ‚ü®transcript, ‚Üê prover.output state‚ü©

noncomputable def extract_x
  (S : Finset Œπ) (œÜ : Œπ ‚Ü™ F) (k : ‚Ñï) (y : indexPowT S œÜ (k + 1)) : indexPowT S œÜ k :=
  let x := Classical.choose y.property
  let hx := Classical.choose_spec y.property
  let z := (œÜ x) ^ (2^k)
  ‚ü®z, ‚ü®x, hx.1, rfl‚ü©‚ü©

def completeness
    (relIn : Set ((StmtIn √ó ‚àÄ i, OStmtIn i) √ó WitIn))
    (relOut : Set ((StmtOut √ó ‚àÄ i, OStmtOut i) √ó WitOut))
    (oracleReduction : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec)
    (completenessError : ‚Ñù‚â•0) : Prop :=
  Reduction.completeness init impl relIn relOut oracleReduction.toReduction completenessError

def vcons {n : ‚Ñï} (a : Œ±) (v : Fin n ‚Üí Œ±) : Fin (n + 1) ‚Üí Œ± :=
  dcons a v

instance [O‚ÇÅ : ‚àÄ i, OracleInterface.{0, u, v} (pSpec‚ÇÅ.Message i)]
    [O‚ÇÇ : ‚àÄ i, OracleInterface.{0, u, v} (pSpec‚ÇÇ.Message i)] :
    ‚àÄ i, OracleInterface.{0, u, v} ((pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).Message i) :=
  fun ‚ü®i, h‚ü© => Fin.fappend‚ÇÇ (A := Direction) (B := Type)
    (F := fun dir type => (h : dir = .P_to_V) ‚Üí OracleInterface type)
    (Œ±‚ÇÅ := pSpec‚ÇÅ.dir) (Œ≤‚ÇÅ := pSpec‚ÇÇ.dir)
    (Œ±‚ÇÇ := pSpec‚ÇÅ.Type) (Œ≤‚ÇÇ := pSpec‚ÇÇ.Type) (fun i h => O‚ÇÅ ‚ü®i, h‚ü©) (fun i h => O‚ÇÇ ‚ü®i, h‚ü©) i h

def encode [DecidableEq F] (msg : Fin deg ‚Üí F) (domain : Fin m ‚Ü™ F) : Fin m ‚Üí F :=
  (polynomialOfCoeffs msg).eval ‚àò ‚áëdomain

def AlgebraTowerEquiv.algebraMapLeftUp (e : AlgebraTowerEquiv A B) (i j : Œπ)
    (h : i ‚â§ j) : (B i) ‚Üí+* (A j) :=

instance : Serde UInt8 ByteArray where

def rdrop (m : ‚Ñï) (h : m ‚â§ n) (pSpec : ProtocolSpec n) : ProtocolSpec (n - m) :=
  {dir := Fin.rdrop m h pSpec.dir, ¬´Type¬ª := Fin.rdrop m h pSpec.¬´Type¬ª}

def Œ± (x‚ÇÄ : F) (R : F[X][X][Y]) (H : F[X][Y]) [œÜ : Fact (Irreducible H)] (t : ‚Ñï) : ùïÉ H :=
  let W : ùïÉ H := liftToFunctionField (H.leadingCoeff)
  embeddingOfùí™IntoùïÉ _ (Œ≤ R t) / (W ^ (t + 1) * (embeddingOfùí™IntoùïÉ _ (Œæ x‚ÇÄ R H)) ^ (2*t - 1))

def BBF_CodeDistance (‚Ñì ùì° : ‚Ñï) (i : Fin (‚Ñì + 1)) : ‚Ñï :=
  2^(‚Ñì + ùì° - i.val) - 2^(‚Ñì - i.val) + 1

def partition (cs : ConstraintSystem ùì° numWires numGates) :
    Fin numWires ‚Üí Finset (Fin (3 * numGates)) :=
  
  
  
  
  fun i => Finset.map (Equiv.toEmbedding finProdFinEquiv)
    (Finset.filter (fun j => if j.1 = 0 then (cs j.2).a = i
      else if j.1 = 1 then (cs j.2).b = i else (cs j.2).c = i)
    (Finset.univ : Finset (Fin 3 √ó Fin numGates)))

def g (n : ‚Ñï) (c : ‚Ñï) (x : ‚Ñï) := (x * x + c) % n

def localized_fold_eval (i : Fin ‚Ñì) (steps : ‚Ñï) (h_i_add_steps : i + steps ‚â§ ‚Ñì)
    (f : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate)
      ‚ü®i, by exact Nat.lt_of_le_of_lt (n := i) (k := r) (m := ‚Ñì) (h‚ÇÅ := by
        exact Fin.is_le') (by exact lt_of_add_right_lt h_‚Ñì_add_R_rate)‚ü© ‚Üí L)
    (r_challenges : Fin steps ‚Üí L)
    (y : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®‚Üëi + steps, by omega‚ü©) : L :=

Set.Finite in Mathlib.Data.Finite.Defs

def correlatedAgreement (C : Set (n ‚Üí F)) (Œ¥ : ‚Ñù‚â•0) {k : ‚Ñï} (W : Fin k ‚Üí n ‚Üí F) : Prop :=
  ‚àÉ S : Finset n, #(S) ‚â• (1 - Œ¥) * (Fintype.card n) ‚àß
    ‚àÉ v : Fin k ‚Üí n ‚Üí F, ‚àÄ i, v i ‚àà C ‚àß {j | v i j = W i j} = S

@[inline, reducible]
protected def id :
    OracleStatement.Lens OuterStmtIn OuterStmtOut OuterStmtIn OuterStmtOut
                        OuterOStmtIn OuterOStmtOut OuterOStmtIn OuterOStmtOut :=
  PFunctor.Lens.id _

alias trivial := OracleStatement.Lens.id

List.min in Init.Data.List.Basic

def evalX (a : F) (f : F[X][Y]) : Polynomial F :=
  ‚ü®Finsupp.mapRange (Polynomial.eval a) eval_zero f.toFinsupp‚ü©

def oracleProver : OracleProver oSpec
    Statement OStatement Unit
    Unit (OStatement ‚äï·µ• OStatement) Unit
    (pSpec OStatement) where
  PrvState := fun _ => OStatement default

  input := fun ‚ü®‚ü®_, oStmt‚ü©, _‚ü© => oStmt default

  sendMessage | ‚ü®0, _‚ü© => fun st => pure (st, st)

  receiveChallenge | ‚ü®0, h‚ü© => nomatch h

  output := fun st => pure
    (‚ü®(), fun x => match x with
      | .inl _ => by admit /- proof elided -/
      ‚ü©,
     ())

instance : ‚àÄ j, OracleInterface ((pSpec F).Message j)
  | ‚ü®0, h‚ü© => nomatch h
  | ‚ü®1, _‚ü© => by admit /- proof elided -/

@[ext]
structure AssocFin (n : AssocNat) where
  val : AssocNat
  isLt : val < n

noncomputable def codeDistNew (C : Set (n ‚Üí R)) : ‚Ñù := C.infsep

System.mkFilePath in Init.System.FilePath

@[ext]
class OracleInterface (Message : Type u) where
  Query : Type v
  Response : Type w
  answer : Message ‚Üí Query ‚Üí Response

instance : MonadLift (StateT œÉ m) (StateT (œÉ √ó œÑ) m) where
  monadLift := fun x st => do let y ‚Üê x st.1; return (y.1, y.2, st.2)

noncomputable def getFoldProverFinalOutput (i : Fin ‚Ñì)
    (finalPrvState : foldPrvState ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      i 2 (Context := Context)) :
  ((Statement (L := L) Context i.succ √ó ((j : Fin (toOutCodewordsCount ‚Ñì œë i.castSucc)) ‚Üí
    OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j))
      √ó Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ) :=

GaloisField.equivZmodP in Mathlib.FieldTheory.Finite.GaloisField

Vector.tail in Init.Data.Vector.Basic

def fiberwiseClose (i : Fin ‚Ñì) (steps : ‚Ñï) [NeZero steps] (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
    (f : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      ‚ü®i, by admit /- proof elided -/
      ‚ü©) : Prop :=
  2 * fiberwiseDistance ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := i) steps
    (h_i_add_steps := h_i_add_steps) (f := f) < (BBF_CodeDistance ‚Ñì ùì° ‚ü®i + steps, by admit /- proof elided -/
    ‚ü© : ‚Ñï‚àû)

def FullTranscript.extractSalt (transcript : (pSpec.addSalt Salt).FullTranscript) :
    (i : pSpec.MessageIdx) ‚Üí Salt i :=
  Transcript.extractSalt (pSpec := pSpec) (k := Fin.last n) transcript

Fin.init in Mathlib.Data.Fin.Tuple.Basic

@[elab_as_elim] def Fin.succRecOnSameFinType {motive : Fin r ‚Üí Sort _}
    (zero : motive (0 : Fin r))
    (succ : ‚àÄ i : Fin r, i + 1 < r ‚Üí motive i ‚Üí motive (i + 1)) : ‚àÄ (i : Fin r), motive i
  | ‚ü®0, _‚ü© => by admit /- proof elided -/
  | ‚ü®Nat.succ i_val, h‚ü© => by admit /- proof elided -/

@[reducible, simp]
def soundness
    (langIn : Set (Statement √ó ‚àÄ i, OStatement i))
    (verifier : OracleVerifier oSpec Statement OStatement Bool (fun _ : Empty => Unit) pSpec)
    (soundnessError : ‚Ñù‚â•0) : Prop :=
  verifier.toVerifier.soundness init impl langIn acceptRejectOracleRel.language soundnessError

Multiset in Mathlib.Data.Multiset.Defs

def JohnsonConditionWeak (B : Finset (Fin n ‚Üí F)) (e : ‚Ñï) : Prop :=
  let d := sInf { d | ‚àÉ u ‚àà B, ‚àÉ v ‚àà B, u ‚â† v ‚àß hammingDist u v = d }
  let q : ‚Ñö := Fintype.card F
  (e : ‚Ñö) / n < J q (d / n)

instance {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    [inst : ‚àÄ i, ‚àÄ j, SelectableType ((pSpec i).Challenge j)] :
    ‚àÄ k, SelectableType ((seqCompose pSpec).Challenge k) :=
  fun ‚ü®k, h‚ü© => Fin.fflatten‚ÇÇ
    (A := Direction) (B := Type) (F := fun dir type => (h : dir = .V_to_P) ‚Üí SelectableType type)
    (fun i' j' h' => inst i' ‚ü®j', h'‚ü©) k h

@[elab_as_elim]
def dconcat {n : ‚Ñï} {motive : Fin (n + 1) ‚Üí Sort u}
    (u : (i : Fin n) ‚Üí motive i.castSucc) (a : motive (last n)) (i : Fin (n + 1)) : motive i :=
  match n with
  | 0 => match i with | 0 => a
  | _ + 1 => dcons (u 0) (dconcat (fun i => u (Fin.succ i)) a) i

Vector.foldl in Init.Data.Vector.Basic

String.intercalate in Init.Data.String.Defs

BitVec.toNat in Init.Prelude

List.prod in Batteries.Data.List.Basic

noncomputable def œÄ_z {H : F[X][Y]} (z : F) (root : rationalRoot (H_tilde' H) z) : ùí™ H ‚Üí+* F :=
  Ideal.Quotient.lift (Ideal.span {H_tilde' H}) (œÄ_z_lift z root) sorry

Fin in Init.Prelude

@[ext]
structure VectorSpec (n : ‚Ñï) where
  dir : Fin n ‚Üí Direction
  length : Fin n ‚Üí Nat

UInt16.ofFin in Init.Data.UInt.Basic

Nat.reducePow in Lean.Meta.Tactic.Simp.BuiltinSimprocs.Nat

instance : NatCast (UniPoly R) := ‚ü®fun n => UniPoly.C (n : R)‚ü©

def natCast_zero {k : ‚Ñï} : natCast (k:=k) 0 = zero :=

@[simp]
abbrev Statement.AfterFirstChallenge : Type :=
  FirstChallenge R pp √ó Statement.AfterFirstMessage R pp

Polynomial.degreeLT in Mathlib.RingTheory.Polynomial.Basic

Subspace in Mathlib.Algebra.Module.Submodule.Basic

def JohnsonConditionStrong (B : Finset (Fin n ‚Üí F)) (v : Fin n ‚Üí F) : Prop :=
  let e := e B v
  let d := d B
  let q : ‚Ñö := Fintype.card F
  let frac := q / (q - 1)
  (1 - frac * d/n) < (1- frac * e/n) ^ 2

instance instDCastSigma {Œ± : Type*} {Œ≤ : Œ± ‚Üí Type*} {Œ≥ : (a : Œ±) ‚Üí Œ≤ a ‚Üí Type*}
    [DCast Œ± Œ≤] [DCast‚ÇÇ Œ± Œ≤ Œ≥] : DCast ((a : Œ±) √ó Œ≤ a) (fun a => Œ≥ a.1 a.2) where
  dcast hab c := dcast‚ÇÇ (by admit /- proof elided -/
  ) (by admit /- proof elided -/
  ) c
  dcast_id := by admit /- proof elided -/

@[inline] def le [Zero T] [ToNat T] (a b : Cayley T) : Prop :=
  (‚Üëa : Nat) ‚â§ (‚Üëb : Nat)

@[inline, reducible]
def lift : OuterStmtIn √ó OuterWitOut ‚Üí InnerWitIn ‚Üí OuterWitIn :=
  lens.toFunB

def nil {Œ±} : Vector Œ± 0 := ‚ü®#[], rfl‚ü© 

instance [Zero T] [ToNat T] : LE (Cayley T) where
  le := le

@[reducible, simp]
def relOut : Set (Statement √ó Unit) := Set.univ

AdjoinRoot.powerBasis' in Mathlib.RingTheory.AdjoinRoot

def truncate (p : Polynomial F) (n : ‚Ñï) : Polynomial F
  := ‚ü®‚ü®p.1.1 ‚à© Finset.range n, fun i ‚Ü¶ if i < n then p.1.2 i else 0, by admit /- proof elided -/
  ‚ü©‚ü©

@[ext]
structure Reduction {Œπ : Type} (oSpec : OracleSpec Œπ)
    (StmtIn WitIn StmtOut WitOut : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n) where
  prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec
  verifier : Verifier oSpec StmtIn StmtOut pSpec

def lastBlockOracleReduction :=
  let bIdx := ‚Ñì / œë - 1
  let stmt : Fin (œë + 1) ‚Üí Type := fun i => Statement (L := L) (‚Ñì := ‚Ñì) Context
    ‚ü®bIdx * œë + i, by admit /- proof elided -/
    ‚ü©
  let oStmt := fun i: Fin (œë + 1) => OracleStatement ùîΩq Œ≤ œë
    ‚ü®bIdx * œë + i, by admit /- proof elided -/
    ‚ü©
  let wit := fun i: Fin (œë + 1) => Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì)
    ‚ü®bIdx * œë + i, by admit /- proof elided -/
    ‚ü©
  let V:  OracleReduction []‚Çí (StmtIn := Statement (L := L) (‚Ñì := ‚Ñì) Context
    ‚ü®bIdx * œë, by admit /- proof elided -/
    ‚ü©)
    (OStmtIn := OracleStatement ùîΩq Œ≤ œë
      ‚ü®bIdx * œë, by admit /- proof elided -/
      ‚ü©)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì)
      ‚ü®bIdx * œë, by admit /- proof elided -/
      ‚ü©)
    (StmtOut := Statement (L := L) (‚Ñì := ‚Ñì) Context (Fin.last ‚Ñì))
    (OStmtOut := OracleStatement ùîΩq Œ≤ œë (Fin.last ‚Ñì))
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) (Fin.last ‚Ñì))
    (pSpec := pSpecLastBlock (L:=L) (œë:=œë)) := by admit /- proof elided -/

OracleSpec.append in VCVio.OracleComp.OracleSpec

def FinalSumcheckWit := fun (m : Fin (1 + 1)) =>
 match m with
 | ‚ü®0, _‚ü© => Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì)
 | ‚ü®1, _‚ü© => Unit

@[reducible]
def pSpec (F : Type) [Semiring F] : ProtocolSpec 2 := ‚ü®!v[.V_to_P, .P_to_V], !v[F, Unit ‚Üí F[X]]‚ü©

def knowledgeStateFunction :
    (oracleVerifier oSpec OStatement).KnowledgeStateFunction init impl
    (relIn OStatement) (relOut OStatement) (rbrExtractor oSpec OStatement) where
  toFun
  | 0 => fun ‚ü®_, oracles‚ü© _ _ => oracles 0 = oracles 1
  | 1 => fun ‚ü®_, oracles‚ü© chal _ =>
    let q : Query OStatement := by admit /- proof elided -/

def statelessOracle (baseSpec : OracleSpec Œπ‚Çú) (spec : OracleSpec Œπ)
    (f : (i : Œπ) ‚Üí spec.domain i ‚Üí spec.range i) :
    SimOracle.Stateless (baseSpec ++‚Çí spec) baseSpec where
  impl
  | query (.inl i) t => query i t
  | query (.inr i) t => pure (f i t)

def ChallengeIdx.inl (i : ChallengeIdx pSpec‚ÇÅ) : ChallengeIdx (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ) :=
  ‚ü®Fin.castAdd n i.1, by admit /- proof elided -/
  ‚ü©

def toList (xs : ChurchVec Œ±) : List Œ± :=
  churchVecFold xs (fun x acc => x :: acc) []

def SparseMatrix.toMatrix {m n Œ± : Type*} [DecidableEq m] [DecidableEq n] [AddCommMonoid Œ±]
    (A : SparseMatrix m n Œ±) : Matrix m n Œ± :=
  fun i j => ‚àë k : Fin A.numEntries, if A.row k = i ‚àß A.col k = j then A.val k else 0

class IsSound (langIn : Set StmtIn) (langOut : Set StmtOut)
    (verifier : Verifier oSpec StmtIn StmtOut pSpec) where
  soundnessError : ‚Ñù‚â•0
  is_sound : soundness init impl langIn langOut verifier soundnessError

HEq in Init.Prelude

@[simps!]
def MessageIdx.sumEquiv :
    MessageIdx pSpec‚ÇÅ ‚äï MessageIdx pSpec‚ÇÇ ‚âÉ MessageIdx (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ) where
  toFun := Sum.elim (MessageIdx.inl) (MessageIdx.inr)
  invFun := fun ‚ü®i, h‚ü© => by admit /- proof elided -/

@[simp]
def testStmtLens :
    Statement.Lens OuterStmtIn_Test OuterStmtOut_Test InnerStmtIn_Test InnerStmtOut_Test :=
  ‚ü®fun ‚ü®p, q, t‚ü© => ‚ü®p * q, t‚ü©, fun ‚ü®p, q, _‚ü© ‚ü®_, t', u‚ü© => (p, q, t', u)‚ü©

@[reducible]
def C : R ‚Üí+* P := algebraMap R P

def outputRelation (cond : ‚àë i, (s i).1 ‚â§ n) [DecidableEq F] (Œ¥ : ‚Ñù‚â•0) :
    Set
      (
        (FinalStatement F k √ó ‚àÄ j, FinalOracleStatement D x s j) √ó
        Witness F s d (Fin.last (k + 1))
      )
  := FinalFoldPhase.outputRelation D x s d cond Œ¥

LinearEquiv.ofBijective in Mathlib.Algebra.Module.Submodule.Equiv

protected def dcast {n n' : ‚Ñï} {Œ± : Fin n ‚Üí Sort u} {Œ±' : Fin n' ‚Üí Sort u}
    (h : n' = n) (hŒ± : ‚àÄ i, Œ± (Fin.cast h i) = Œ±' i) (v : (i : Fin n) ‚Üí Œ± i) :
      (i : Fin n') ‚Üí Œ±' i :=
  fun i => _root_.cast (hŒ± i) (v (Fin.cast h i))

def oracleVerifier : OracleVerifier oSpec Statement OStatement Unit (OStatement ‚äï·µ• OStatement)
    (pSpec OStatement) where

  verify := fun stmt _ => relComp stmt

  embed := sorry

  hEq := sorry

noncomputable def Bstar (x : ‚Ñù) : ‚Ñù := x.sqrt

def implGroupEncodeOracle [Serialize G (BitVec bitLength)] :
    QueryImpl (GroupEncodeOracle Œπ bitLength) (StateT (GroupValTable Œπ G) Option) where
  impl | query _ i => fun table =>
    match table i with
    | some g => some (serialize g, table)
    | none => none

Finset.add in Mathlib.Algebra.Group.Pointwise.Finset.Basic

@[reducible, simp]
def StmtOut : Type := R √ó R

class HasPred (T : Type u) where
   
  pred' : T ‚Üí T

Decidable in Init.Prelude

@[reducible]
def scalarFieldSize : Nat :=
  52435875175126190479447740508185965837690552500527637822603658699938581184513

partial def verifyCertificate (n' : Q(‚Ñï)) (n : ‚Ñï) :
    UnverifiedPrattCertificate n ‚Üí MetaM Q(Nat.Prime $n')
  | .knownPrime n => verifySmallPrime n'
  | .of n a part => do
      let cert ‚Üê generateCertificate n' n a part
      return q(PrattCertificate.out $cert)
  where
  generateCertificate (n' : Q(‚Ñï)) (_ : ‚Ñï) (a : ‚Ñï) (part : UnverifiedPrattPart) :
      MetaM Q(PrattCertificate $n') := do
    have alit : Q(‚Ñï) := mkRawNatLit a
    let ‚ü®a', pa'‚ü© ‚Üê mkOfNat q(ZMod $n') q(instAddMonoidWithOne) alit
    let hpow : Q($a' ^ ($n' - 1) = 1) ‚Üê verifyEqOne n' alit a' pa'
    let result ‚Üê generatePart n' a' alit pa' part
    haveI : $(result.1) =Q $n' - 1 := ‚ü®‚ü©
    return q(PrattCertificate.mk $a' $hpow $(result.2))
  generatePart (n' : Q(‚Ñï)) (a : Q(ZMod $n')) (a' : Q(‚Ñï)) (pa' : Q(($a' : ZMod $n') = $a)) :
      UnverifiedPrattPart ‚Üí MetaM ((nn : Q(‚Ñï)) √ó Q(PrattPart $n' $a $nn))
    | .prime p k hp => do
      
      have plit : Q(‚Ñï) := mkRawNatLit p
      let inner ‚Üê verifyCertificate plit p hp
      have pklit : Q(‚Ñï) := mkRawNatLit (p ^ k)
      have klit : Q(‚Ñï) := mkRawNatLit k
      let hpow ‚Üê verifyNeOne n' a' plit a pa'
      haveI : $pklit =Q $plit ^ $klit := ‚ü®‚ü©
      return ‚ü®pklit, q(PrattPart.prime $plit $klit _ $inner $hpow (.refl _))‚ü©
    | .split left right => do
      let ‚ü®nleft, pleft‚ü© ‚Üê generatePart n' a a' pa' left
      let ‚ü®nright, pright‚ü© ‚Üê generatePart n' a a' pa' right
      
      have nn : Q(‚Ñï) := mkRawNatLit (nleft.natLit! * nright.natLit!)
      haveI : $nn =Q $nleft * $nright := ‚ü®‚ü©
      return ‚ü®nn, q(PrattPart.split $nleft $nright $pleft $pright (.refl _))‚ü©

noncomputable def toPoly' (p : UniPoly R) : Polynomial R :=
  Polynomial.ofFinsupp (Finsupp.onFinset (Finset.range p.size) p.coeff (by admit /- proof elided -/
  ))

structure BerlekampWelchCondition (e k : ‚Ñï) (œâs f : Fin n ‚Üí F) (E Q : Polynomial F) : Prop where
  cond: ‚àÄ i : Fin n, Q.eval (œâs i) = (f i) * E.eval (œâs i)
  E_natDegree : E.natDegree = e
  E_leadingCoeff : E.coeff e = 1
  Q_natDegree : Q.natDegree ‚â§ e + k - 1

def Equiv.ofLawfulPermute (Œ± : Type*) [Permute Œ±] [LawfulPermute Œ±] : Equiv Œ± Œ± where
  toFun := Permute.permute
  invFun := LawfulPermute.permuteInv
  left_inv := LawfulPermute.left_inv
  right_inv := LawfulPermute.right_inv

Equiv.invFun in Mathlib.Logic.Equiv.Defs

def instTestLensKnowledgeSound : testLensE.IsKnowledgeSound
      outerRelIn_Test innerRelIn_Test outerRelOut_Test innerRelOut_Test
      (fun ‚ü®p, q, _‚ü© ‚ü®f, _‚ü© => p * q = f) (fun _ _ => True) where
  proj_knowledgeSound := fun ‚ü®p, q, t‚ü© ‚ü®f, t', r‚ü© _ h h' => by admit /- proof elided -/

Polynomial.evalEval in Mathlib.Algebra.Polynomial.Bivariate

noncomputable def toMLE (A : Matrix (Fin (2 ^ m)) (Fin (2 ^ n)) R) : R[X Fin n][X Fin m] :=
  MLE' (MLE' ‚àò A)

@[reducible]
def fieldSize : Nat := 2 ^ 64 - 2 ^ 32 + 1

instance instOracleInterfaceMessagePSpec : ‚àÄ i, OracleInterface ((pSpec R deg).Message i) :=
  instOracleInterfaceMessageAppend

class GenMutualCorrParams (S : Finset Œπ) (œÜ : Œπ ‚Ü™ F) (k : ‚Ñï) where
  m : ‚Ñï

  inst1 : ‚àÄ i : Fin (k + 1), Fintype (indexPowT S œÜ i)
  inst2 : ‚àÄ i : Fin (k + 1), Nonempty (indexPowT S œÜ i)
  inst3 : ‚àÄ i : Fin (k + 1), DecidableEq (indexPowT S œÜ i)

  œÜ_i : ‚àÄ i : Fin (k + 1), (indexPowT S œÜ i) ‚Ü™ F
  inst4 : ‚àÄ i : Fin (k + 1), Smooth (œÜ_i i)

  par‚Ñì_type : ‚àÄ _ : Fin (k + 1), Type
  inst5 : ‚àÄ i : Fin (k + 1), Fintype (par‚Ñì_type i)

  exp : ‚àÄ i : Fin (k + 1), (par‚Ñì_type i) ‚Ü™ ‚Ñï

  Gen_Œ± : ‚àÄ i : Fin (k + 1), ProximityGenerator (indexPowT S œÜ i) F :=
    fun i => RSGenerator.genRSC (par‚Ñì_type i) (œÜ_i i) (m - i) (exp i)
  inst6 : ‚àÄ i : Fin (k + 1), Fintype (Gen_Œ± i).par‚Ñì

  BStar : ‚àÄ i : Fin (k + 1), (Set (indexPowT S œÜ i ‚Üí F)) ‚Üí Type ‚Üí ‚Ñù‚â•0
  errStar : ‚àÄ i : Fin (k + 1), (Set (indexPowT S œÜ i ‚Üí F)) ‚Üí Type ‚Üí ‚Ñù ‚Üí ENNReal

  h : ‚àÄ i : Fin (k + 1), hasMutualCorrAgreement (Gen_Œ± i)
                                             (BStar i (Gen_Œ± i).C (Gen_Œ± i).par‚Ñì)
                                             (errStar i (Gen_Œ± i).C (Gen_Œ± i).par‚Ñì)

  hcard : ‚àÄ i : Fin (k + 1), Fintype.card ((Gen_Œ± i).par‚Ñì) = 2
  hcard' : ‚àÄ i : Fin (k + 1), Fintype.card (par‚Ñì_type i) = 2

@[reducible, simp] def StmtAfterSendClaim : Type := R

def params24 : Params where
  width := 24
  numFullRounds := 8
  numPartialRounds := 23
  internalDiagVectors := #v[
        -2,
        1,
        2,
        1 / 2,
        3,
        4,
        -1 / 2,
        -3,
        -4,
        1 / (2 ^ 8),
        1 / 4,
        1 / 8,
        1 / 16,
        1 / 32,
        1 / 64,
        1 / (2 ^ 24),
        -1 / (2 ^ 8),
        -1 / 8,
        -1 / 16,
        -1 / 32,
        -1 / 64,
        -1 / (2 ^ 7),
        -1 / (2 ^ 9),
        -1 / (2 ^ 24)
    ]
  roundConstants := RAW_CONSTANTS_24
  width_dvd_by_4 := by admit /- proof elided -/

def LeafData.composeBuild {Œ± : Type} {s : Skeleton} (leaf_data_tree : LeafData Œ± s)
    (compose : Œ± ‚Üí Œ± ‚Üí Œ±) :
    FullData Œ± s :=
  match s, leaf_data_tree with
  | Skeleton.leaf, LeafData.leaf value =>
    FullData.leaf value
  | Skeleton.internal _ _, LeafData.internal left right =>
    let left_tree := LeafData.composeBuild left compose
    let right_tree := LeafData.composeBuild right compose
    FullData.internal
      (compose left_tree.getRootValue right_tree.getRootValue)
      left_tree
      right_tree

def verify [BEq Œ≥] (cm : Œ≥) (v : Œ±) (r : Œ≤) : OracleComp (ROspec Œ± Œ≤ Œ≥) Unit := do
  let cm' ‚Üê (query (spec := ROspec Œ± Œ≤ Œ≥) () (v, r) : OracleComp (ROspec Œ± Œ≤ Œ≥) Œ≥)
  guard (cm' == cm)

class Prover.IsPure (P : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) where
    is_pure : ‚àÉ sendMessage : ‚àÄ _, _ ‚Üí _, ‚àÄ i st,
      P.sendMessage i st = pure (sendMessage i st)

Nat.decLt in Init.Prelude

def foldl' {Œ± : Type u} (n : ‚Ñï) (f : (i : Fin n) ‚Üí Œ± ‚Üí Œ±) (init : Œ±) : Œ± :=
  dfoldl' n (fun _ => Œ±) f init

Polynomial.charP in Mathlib.Algebra.Polynomial.Coeff

@[reducible]
def proverState (i : Fin n) : ProverState 2 where
  PrvState
  | 0 => (StatementRound R n i.castSucc) √ó (‚àÄ i, OracleStatement R n deg i)
  | 1 => (StatementRound R n i.castSucc) √ó (‚àÄ i, OracleStatement R n deg i)
  | 2 => (StatementRound R n i.succ) √ó (‚àÄ i, OracleStatement R n deg i)

MonoidHom in Mathlib.Algebra.Group.Hom.Defs

IO.FS.readFile in Init.System.IO

def evalSetY [DecidableEq F] (f : F[X][Y]) (P : Finset F) [Nonempty P] : Finset (Polynomial F) :=
  P.image (fun a => evalY a f)

noncomputable def decoder (e k : ‚Ñï) [NeZero n] (œâs f : Fin n ‚Üí F) : Option (Polynomial F) :=
  if ‚Äñf‚Äñ‚ÇÄ ‚â§ e
  then some 0
  else
    let x := linsolve (BerlekampWelchMatrix e k œâs f) (Rhs e œâs f)
    match x with
    | none => none
    | some x =>
      let E := solutionToE e k x
      let Q := solutionToQ e k x
      if Q % E = 0 then
        let p := Q / E
        if Œî‚ÇÄ(f, p.eval ‚àò œâs) ‚â§ e then
          some p
        else
          none
      else
        none

@[simps] def equivNat : Nat ‚âÉ AssocNat where
  toFun := ofNat
  invFun := toNat
  left_inv := by admit /- proof elided -/

class IsSecureWithGap
    (completeRelation : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (soundRelation : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (Œµ_rbr : vPSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0)
    (vectorIOP : VectorIOP Statement OStatement Witness vPSpec A) where

   
  is_complete : vectorIOP.perfectCompleteness (pure ()) ‚ü®isEmptyElim‚ü© completeRelation

   
  is_rbr_knowledge_sound :
    OracleProof.rbrKnowledgeSoundness (pure ()) ‚ü®isEmptyElim‚ü© soundRelation vectorIOP.verifier Œµ_rbr

instance {U : Type} [SpongeUnit U] [SpongeSize] :
    SpongeState U (Vector U SpongeSize.N) where
  
  new := fun _ => 0
  get := id
  update := fun _ v => v

AddMonoidAlgebra in Mathlib.Algebra.MonoidAlgebra.Defs

instance instDCast‚ÇÉ : DCast‚ÇÉ Nat (fun n => Fin (n + 1)) (fun n _ => ProtocolSpec n)
    (fun _ k pSpec => pSpec.Transcript k) where
  dcast‚ÇÉ h h' h'' T := Transcript.cast h
    (by admit /- proof elided -/
    )
    (by admit /- proof elided -/
    )
    T
  dcast‚ÇÉ_id := cast_id

def StateRestoration.KnowledgeSoundness (oSpec : OracleSpec Œπ) (StmtIn WitOut : Type)
    {n : ‚Ñï} (pSpec : ProtocolSpec n) :=
  OracleComp (oSpec ++‚Çí (srChallengeOracle StmtIn pSpec)) (StmtIn √ó pSpec.Messages √ó WitOut)

@[reducible, simp]
def MessageIdxUpTo (k : Fin (n + 1)) (pSpec : ProtocolSpec n) : Type :=
  (pSpec‚ü¶:k.val‚üß).MessageIdx

MonadLift in Init.Prelude

def KnowledgeStateFunctionOneShot.toKnowledgeStateFunction
    {relIn : Set (StmtIn √ó WitIn)} {relOut : Set (StmtOut √ó WitOut)}
    {verifier : Verifier oSpec StmtIn StmtOut pSpec}
    (stF : KnowledgeStateFunctionOneShot init impl relIn.language relOut.language verifier)
    (oneShotE : Extractor.RoundByRoundOneShot oSpec StmtIn WitIn pSpec) :
    verifier.KnowledgeStateFunction init impl relIn relOut oneShotE.toRoundByRound where
  toFun := fun m stmtIn tr witIn => if m = 0 then (stmtIn, witIn) ‚àà relIn else
    stF.toFun m stmtIn tr ‚à® (stmtIn, oneShotE m stmtIn tr default) ‚àà relIn
  toFun_empty := fun stmtIn witIn => by admit /- proof elided -/

PowerSeries.mk in Mathlib.RingTheory.PowerSeries.Basic

Neg.neg in Init.Prelude

@[elab_as_elim] def Fin.predRecOnSameFinType {motive : Fin r ‚Üí Sort _}
    (last : motive (‚ü®r - 1, by
      have h_r_ne_0: r ‚â† 0 := by exact NeZero.ne r
      omega
    ‚ü© : Fin r))
    (succ : ‚àÄ i : Fin r, i.val > 0 ‚Üí motive i ‚Üí motive (‚ü®i.val - 1, by omega‚ü© : Fin r))
    (i : Fin r): motive i :=

noncomputable def polyQ (P q : Polynomial F) : MvPolynomial (Fin 2) F :=
  
  let Pbi : MvPolynomial (Fin 2) F := uni2bi P
  
  let P' : MvPolynomial (Fin 2) F := (MvPolynomial.X 1) - uni2bi q
  
  have h_unit : IsUnit ((MonomialOrder.lex).leadingCoeff P') := sorry
  modBivar Pbi P' h_unit

def queryRbrKnowledgeError := fun _ : (pSpecQuery ùîΩq Œ≤ Œ≥_repetitions
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).ChallengeIdx =>
  ((1/2 : ‚Ñù‚â•0) + (1 : ‚Ñù‚â•0) / (2 * 2^ùì°))^Œ≥_repetitions

@[reducible]
def permutationOracle (Œ± : Type*) : OracleSpec PermuteDir :=
  forwardPermutationOracle Œ± ++‚Çí backwardPermutationOracle Œ±

OracleComp.construct' in VCVio.OracleComp.OracleComp

@[inline, specialize]
def mul (p q : UniPoly R) : UniPoly R :=
  p.zipIdx.foldl (fun acc ‚ü®a, i‚ü© => acc.add <| (smul a q).mulPowX i) (C 0)

abbrev extract (start stop : ‚Ñï) (h1 : start ‚â§ stop) (h2 : stop ‚â§ n)
    (transcript : FullTranscript pSpec) : FullTranscript (pSpec.extract start stop h1 h2) :=
  Fin.extract start stop h1 h2 transcript

Lagrange.basis in Mathlib.LinearAlgebra.Lagrange

def foldStepRelOut (i : Fin ‚Ñì) :
    Set ((Statement (L := L) Context i.succ √ó
      (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j)) √ó
      Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ) :=
  { input | foldStepRelOutProp (mp := mp) (ùìë := ùìë) ùîΩq Œ≤ i input}

Fintype.ofIsEmpty in Mathlib.Data.Fintype.OfMap

def someValues : HList' (fun x => x) someTypes :=
  HList'.cons 1 (HList'.cons "bad" (HList'.cons 3 HList'.nil))

def redundantEntryDS (log : QueryLog (duplexSpongeChallengeOracle StmtIn U))
    (idx : Fin log.length) : Prop :=
  match log[idx] with
   
  | ‚ü®.inl _, ‚ü®stmt, state‚ü©‚ü© => ‚àÉ j' < idx, log[j'] = ‚ü®.inl _, ‚ü®stmt, state‚ü©‚ü©
   
  | ‚ü®.inr .Fwd, stateIn, stateOut‚ü© =>
    ‚àÉ j' < idx, log[j'] = ‚ü®.inr .Fwd, stateIn, stateOut‚ü© ‚à® log[j'] = ‚ü®.inr .Bwd, stateOut, stateIn‚ü©
  | ‚ü®.inr .Bwd, stateOut, stateIn‚ü© =>
    ‚àÉ j' < idx, log[j'] = ‚ü®.inr .Bwd, stateOut, stateIn‚ü© ‚à® log[j'] = ‚ü®.inr .Fwd, stateIn, stateOut‚ü©

instance domain_neg_inst {F : Type} [NonBinaryField F] [Finite F] {D : Subgroup FÀ£} {n : ‚Ñï}
    [DIsCyclicC : IsCyclicWithGen ‚Ü•D] [DSmooth : SmoothPowerOfTwo n ‚Ü•D]
    {x : FÀ£} (i : Fin n) : Neg (evalDomain D x i) where
  neg := fun a => ‚ü®_, neg_mem_dom_of_mem_dom D x i a.2‚ü©

def getBTFResult (k : ‚Ñï) : ConcreteBTFStepResult k :=
  match k with
  | 0 =>
    let base : ConcreteBTFieldProps 0 := {
      mul_eq := fun a b h_k _ _ _ _ _ _ => by admit /- proof elided -/
| c1_one
        ¬∑ 
          rw [c1_zero] at h_mul
          
          simp at h_mul
        ¬∑ 
          rcases c2_cases with c2_zero | c2_one
          ¬∑ 
            rw [c2_zero] at h_mul
            
            simp at h_mul
          ¬∑ 
            
            exact ‚ü®c1_one, c2_one‚ü©
      
      have specialElement_eq_zero : specialElement = 0 := by admit /- proof elided -/

MvPolynomial.degrees in Mathlib.Algebra.MvPolynomial.Degrees

protected def cast (R : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec‚ÇÅ) :
    Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec‚ÇÇ where
  prover := R.prover.cast hn hSpec
  verifier := R.verifier.cast hn hSpec

Ideal.Quotient.mk in Mathlib.RingTheory.Ideal.Quotient.Defs

def buildMerkleTree_with_hash {s} (leaf_tree : LeafData Œ± s) (hashFn : Œ± ‚Üí Œ± ‚Üí Œ±) :
    (FullData Œ± s) :=
  match leaf_tree with
  | LeafData.leaf a => FullData.leaf a
  | LeafData.internal left right =>
    let leftTree := buildMerkleTree_with_hash left hashFn
    let rightTree := buildMerkleTree_with_hash right hashFn
    let rootHash := hashFn (leftTree.getRootValue) (rightTree.getRootValue)
    FullData.internal rootHash leftTree rightTree

def degree (P : Params Œπ F) : Fin (M + 1) ‚Üí ‚Ñï :=
  fun i => P.deg / ‚àè j < i, (P.foldingParam j)

instance instHDivConcreteBTF {k : ‚Ñï} : HDiv (ConcreteBTField k) (ConcreteBTField k)
  (ConcreteBTField k) where hDiv a b := a * (concrete_inv b)

def KnowledgeStateFunction.toStateFunction
    {relIn : Set (StmtIn √ó WitIn)} {relOut : Set (StmtOut √ó WitOut)}
    {verifier : Verifier oSpec StmtIn StmtOut pSpec} {WitMid : Fin (n + 1) ‚Üí Type}
    {extractor : Extractor.RoundByRound oSpec StmtIn WitIn WitOut pSpec WitMid}
    (kSF : KnowledgeStateFunction init impl relIn relOut verifier extractor) :
      verifier.StateFunction init impl relIn.language relOut.language where
  toFun := fun m stmtIn tr => ‚àÉ witMid, kSF.toFun m stmtIn tr witMid
  toFun_empty := by admit /- proof elided -/

def squeeze (state : HashStateWithInstructions U H) (outputSize : Nat) :
    Except DomainSeparatorMismatch (HashStateWithInstructions U H √ó Array U) := do
  
  sorry

Nat.binaryRec in Mathlib.Data.Nat.BinaryRec

Quotient.lift‚ÇÇ in Init.Core

Classical.arbitrary in Mathlib.Logic.Nonempty

noncomputable def foldProver :
  OracleProver []‚Çí
    (Statement F i.castSucc) (OracleStatement D x s i.castSucc) (Witness F s d i.castSucc.castSucc)
    (Statement F i.succ) (OracleStatement D x s i.succ) (Witness F s d i.castSucc.succ)
    (pSpec D x s i) where
  PrvState
  | 0 =>
    (Statement F i.castSucc √ó ((j : Fin (‚Üëi.castSucc + 1)) ‚Üí OracleStatement D x s i.castSucc j)) √ó
      Witness F s d i.castSucc.castSucc
  | _ =>
    (Statement F i.succ √ó ((j : Fin (‚Üëi.castSucc + 1)) ‚Üí OracleStatement D x s i.castSucc j)) √ó
      Witness F s d i.castSucc.succ

  input := id

  sendMessage
  | ‚ü®0, h‚ü© => nomatch h
  | ‚ü®1, _‚ü© => fun ‚ü®‚ü®chals, o‚ü©, p‚ü© =>
    pure ‚ü®fun x => p.1.eval x.1.1, ‚ü®‚ü®chals, o‚ü©, p‚ü©‚ü©

  receiveChallenge
  | ‚ü®0, _‚ü© => fun ‚ü®‚ü®chals, o‚ü©, p‚ü© => pure <|
    fun (Œ± : F) =>
      ‚ü®
        ‚ü®Fin.append chals (fun (_ : Fin 1) => Œ±), o‚ü©,
        ‚ü®p.1.foldNth (2 ^ (s i.castSucc).1) Œ±, witness_lift p.2‚ü©
      ‚ü©
  | ‚ü®1, h‚ü© => nomatch h

  output := fun ‚ü®‚ü®chals, o‚ü©, p‚ü© => pure <|
    ‚ü®
      ‚ü®
        chals,
        fun j =>
          if h : j.1 < i.1
          then by admit /- proof elided -/
      ‚ü©,
      p
    ‚ü©

DivisionSemiring in Mathlib.Algebra.Field.Defs

def SkeletonInternalIndex.depth {s : Skeleton} : SkeletonInternalIndex s ‚Üí Nat
  | SkeletonInternalIndex.ofInternal => 0
  | SkeletonInternalIndex.ofLeft idxLeft => idxLeft.depth + 1
  | SkeletonInternalIndex.ofRight idxRight => idxRight.depth + 1

def findSumIdxWith (l : List ‚Ñï) (j : Fin l.sum) : (i : Fin l.length) √ó Fin (l.get i) := sorry

@[reducible, simp] def StmtIn : Type := R

def rho' (n : ‚Ñï) (start : ‚Ñï) (c : ‚Ñï) : Option ‚Ñï := Id.run do
  if n % 2 = 0 then
    return some 2

  let mut x := start
  let mut y := x
  let mut d := 1

  while d = 1 do
    x := g n c x
    y := g n c (g n c y)
    d := Nat.gcd (Int.natAbs (x - y)) n

  if d = n then
    return none
  else
    return some d

NNRat in Mathlib.Data.Rat.Init

instance (i : Fin 0) : OracleInterface i.elim0 := Fin.elim0 i

instance {k : ‚Ñï} : Mul (ConcreteBTField k) where
  mul := concrete_mul

def perm (cs : ConstraintSystem ùì° numWires numGates) : Equiv.Perm (Fin (3 * numGates)) := sorry

@[reducible]
def pBits : Nat := 31

def SkeletonNodeIndex.isLeaf {s : Skeleton} (idx : SkeletonNodeIndex s) : Bool :=
  match idx with
  | SkeletonNodeIndex.ofLeaf => true
  | SkeletonNodeIndex.ofInternal => false
  | SkeletonNodeIndex.ofLeft _ => false
  | SkeletonNodeIndex.ofRight _ => false

def findSum (l : List Œ±) (j : Œ±) : Option Œ± := l.partialSum.find? (j < ¬∑)

@[app_unexpander Fin.vcons]
def vconsUnexpander : Lean.PrettyPrinter.Unexpander
  | `($_ $term !v[$term2, $terms,*]) => `(!v[$term, $term2, $terms,*])
  | `($_ $term !v[$term2]) => `(!v[$term, $term2])
  | `($_ $term !v[]) => `(!v[$term])
  | _ => throw ()

structure DuplexSponge (U : Type) [SpongeUnit U] [SpongeSize] (C : Type*)
    [SpongeState U C] where
   
  state : C
   
  absorbPos : Fin (SpongeSize.R + 1)
   
  squeezePos : Fin (SpongeSize.R + 1)
deriving Inhabited

@[inline, specialize]
def oracleProver : OracleProver oSpec
    Statement OStatement (‚àÄ i, Witness i)
    Statement (OStatement ‚äï·µ• Witness) Unit
    (oraclePSpec Witness) where
  PrvState := fun _ => (Statement √ó (‚àÄ i, OStatement i)) √ó (‚àÄ i, Witness i)
  input := id
  sendMessage | ‚ü®0, _‚ü© => fun ‚ü®stmt, wit‚ü© => pure (wit, ‚ü®stmt, wit‚ü©)
  
  receiveChallenge | ‚ü®0, h‚ü© => nomatch h
  output := fun ‚ü®‚ü®stmt, oStmt‚ü©, wit‚ü© => pure (‚ü®stmt, Sum.rec oStmt wit‚ü©, ())

noncomputable def towerRingHomForwardMap (k : ‚Ñï) : ConcreteBTField k ‚Üí BTField k :=

def SkeletonNodeIndex.leftChild {s : Skeleton} (idx : SkeletonNodeIndex s) :
    Option (SkeletonNodeIndex s) :=
  match idx with
  | SkeletonNodeIndex.ofLeaf => none
  | @SkeletonNodeIndex.ofInternal left right =>
    some (SkeletonNodeIndex.ofLeft (getRootIndex left))
  | SkeletonNodeIndex.ofLeft idxLeft =>
    idxLeft.leftChild.map (SkeletonNodeIndex.ofLeft)
  | SkeletonNodeIndex.ofRight idxRight =>
    idxRight.leftChild.map (SkeletonNodeIndex.ofRight)

def concreteCanonicalEmbedding (k : ‚Ñï)
    (prevBTFieldProps : ConcreteBTFieldProps (k := (k)))
    (curBTFieldProps : ConcreteBTFieldProps (k := (k + 1))) :
  letI := mkFieldInstance prevBTFieldProps
  letI := mkFieldInstance curBTFieldProps
  ConcreteBTField k ‚Üí+* ConcreteBTField (k + 1) :=

@[reducible, simp]
def relOut : Set ((StmtOut OStatement √ó ‚àÄ i, OStmtOut OStatement i) √ó WitOut) :=
  { ‚ü®‚ü®q, oStmt‚ü©, ()‚ü© | answer (oStmt 0) q = answer (oStmt 1) q }

def params16 : Params where
  width := 16
  numFullRounds := 8
  numPartialRounds := 20
  internalDiagVectors := #v[
       -2,
        1,
        2,
        1 / 2,
        3,
        4,
        -1 / 2,
        -3,
        -4,
        1 / (2 ^ 8),
        1 / 8,
        1 / (2 ^ 24),
        -1 / (2 ^ 8),
        -1 / 8,
        -1 / 16,
        -1 / (2 ^ 24),
    ]
  roundConstants := rawConstants16
  width_dvd_by_4 := by admit /- proof elided -/

Sub in Init.Prelude

Fin.mk in Init.Prelude

instance (k : ‚Ñï) : NeZero (2^k) :=

def OracleVerifier.append (V‚ÇÅ : OracleVerifier oSpec Stmt‚ÇÅ OStmt‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : OracleVerifier oSpec Stmt‚ÇÇ OStmt‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ pSpec‚ÇÇ) :
      OracleVerifier oSpec Stmt‚ÇÅ OStmt‚ÇÅ Stmt‚ÇÉ OStmt‚ÇÉ (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ) where
  verify := fun stmt challenges => by admit /- proof elided -/
|
    
    .trans (.sumMap V‚ÇÅ.embed (.refl _)) <|
    
    .trans (Equiv.sumAssoc _ _ _).toEmbedding <|
    
    .sumMap (.refl _) MessageIdx.sumEquiv.toEmbedding

  hEq := fun i => by admit /- proof elided -/

inductive Lit where
  | scalar (val : F)
  
  
  | vector (len : Nat) (v : Fin len ‚Üí F)

@[reducible, simp]
def ChallengeIdxUpTo (k : Fin (n + 1)) (pSpec : ProtocolSpec n) : Type :=
  (pSpec‚ü¶:k.val‚üß).ChallengeIdx

Fin.succAboveCases in Mathlib.Data.Fin.Tuple.Basic

def getTypes {Œ±s : List Type} (_ : HList Œ±s) : List Type := Œ±s

def minDist [DecidableEq F] (IC : MatrixSubmodule Œ∫ Œπ F) : ‚Ñï :=
  sInf { d : ‚Ñï | ‚àÉ U ‚àà IC, ‚àÉ V ‚àà IC, distCodewords U V = d }

OracleComp in VCVio.OracleComp.OracleComp

noncomputable def toMvPolynomialAlgHom : P ‚Üí‚Çê[R] MvPolynomial œÉ R := aeval MvPolynomial.X

abbrev Field := ZMod fieldSize

def minRelHammingDistCode (C : Set (Œπ ‚Üí F)) : ‚Ñö‚â•0 :=
  haveI : Fintype (possibleRelHammingDists C) := @Fintype.ofFinite _ finite_possibleRelHammingDists
  if h : (possibleRelHammingDists C).Nonempty
  then (possibleRelHammingDists C).toFinset.min' (Set.toFinset_nonempty.2 h)
  else 0

structure Selector (ùì° : Type*) where
   
  qL : ùì°
   
  qR : ùì°
   
  qO : ùì°
   
  qM : ùì°
   
  qC : ùì°
deriving DecidableEq

@[reducible]
def foldRelayOracleVerifier (i : Fin ‚Ñì)
    (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
  OracleVerifier []‚Çí
    (StmtIn := Statement (L := L) Context i.castSucc)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.succ)
    (pSpec := pSpecFoldRelay (L:=L)) :=
  OracleVerifier.append
        (pSpec‚ÇÅ := pSpecFold (L:=L))
    (pSpec‚ÇÇ := pSpecRelay)
    (foldOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)
    (relayOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hNCR)

@[reducible, inline, specialize]
def getChallenge (pSpec : ProtocolSpec n) (i : pSpec.ChallengeIdx) :
    OracleComp ([pSpec.Challenge]‚Çí'challengeOracleInterface) (pSpec.Challenge i) :=
  (query i () : OracleQuery ([pSpec.Challenge]‚Çí'challengeOracleInterface) (pSpec.Challenge i))

Fin.tail in Mathlib.Data.Fin.Tuple.Basic

protected def Verifier.id : Verifier oSpec Statement Statement !p[] where
  verify := fun stmt _ => pure stmt

instance [ProverFirst pSpec] [h : OracleInterface (pSpec.¬´Type¬ª 0)] :
    ‚àÄ i, OracleInterface (pSpec.Message i)
  | ‚ü®0, _‚ü© => inferInstance

def fnOracle (spec : OracleSpec Œπ) (f : (i : Œπ) ‚Üí spec.domain i ‚Üí spec.range i) :
    SimOracle.Impl spec where
  impl | query i t => pure (f i t)

MvPolynomial.renameEquiv in Mathlib.Algebra.MvPolynomial.Rename

def hintBytes (state : FSProverState U H R) (hint : ByteArray) :
    Except DomainSeparatorMismatch (FSProverState U H R) :=
  match state.hashState.hint with
  | .ok newHashState =>
    
    
    .ok { rng := state.rng, hashState := newHashState, nargString := state.nargString }
  | .error e => .error e

instance [Repr Œ±] (Œ±s : List Type) [HListRepr (HList Œ±s)] : HListRepr (HList (Œ± :: Œ±s)) where
  repr
  | HList.cons x xs =>
    match xs with
    | HList.nil => reprPrec x 0
    | HList.cons _ _ => reprPrec x 0 ++ ", " ++ HListRepr.repr xs

noncomputable def foldingBadEventAtBlock
    (stmtIdx : Fin (‚Ñì + 1)) (oracleIdx : Fin (‚Ñì + 1))
    (oStmt : ‚àÄ j, (OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (i := oracleIdx) j))
    (challenges : Fin stmtIdx ‚Üí L)
    (j : Fin (toOutCodewordsCount ‚Ñì œë oracleIdx)) : Prop :=
  have h_œë: œë > 0 := by admit /- proof elided -/

@[reducible, simp] def WitIn := Unit

def tileCoeffs (a : Fin (2 ^ ‚Ñì) ‚Üí L) : Fin (2^(‚Ñì + R_rate)) ‚Üí L :=
  fun v => a (Fin.mk (v.val % (2^‚Ñì)) (Nat.mod_lt v.val (pow_pos (zero_lt_two) ‚Ñì)))

def eval‚ÇÇ [Semiring S] (f : R ‚Üí+* S) (x : S) (p : UniPoly R) : S :=
  p.zipIdx.foldl (fun acc ‚ü®a, i‚ü© => acc + f a * x ^ i) 0

Polynomial.reverse in Mathlib.Algebra.Polynomial.Reverse

Membership.mem in Init.Prelude

@[simp]
abbrev Statement.AfterSendEvalClaim : Type := Statement.AfterFirstSumcheck R pp

dotProduct in Mathlib.Data.Matrix.Mul

def starData {Œ±} (k : ‚Ñï) (root : Œ±) (leaves : Fin k ‚Üí Œ±) :
    ArityTree.Data Œ± (starSkel k) :=

def rbrKnowledgeSoundness
    (relIn : Set ((StmtIn √ó ‚àÄ i, OStmtIn i) √ó WitIn))
    (relOut : Set ((StmtOut √ó ‚àÄ i, OStmtOut i) √ó WitOut))
    (verifier : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec)
    (rbrKnowledgeError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) : Prop :=
  verifier.toVerifier.rbrKnowledgeSoundness init impl relIn relOut rbrKnowledgeError

Subtype in Init.Prelude

def CEmbedding : R ‚Ü™ MvPolynomial œÉ R := ‚ü®C, C_injective œÉ R‚ü©

def erase_even (s : Finset ‚Ñï) : Finset ‚Ñï := s.filter Odd

@[elab_as_elim]
def dcons {n : ‚Ñï} {motive : Fin (n + 1) ‚Üí Sort u} (a : motive 0)
    (b : (i : Fin n) ‚Üí motive i.succ) (i : Fin (n + 1)) : motive i :=
  match n with
  | 0 => match i with | 0 => a
  | _ + 1 => match i with
    | 0 => a
    | ‚ü®k + 1, hk‚ü© => b ‚ü®k, Nat.succ_lt_succ_iff.mp hk‚ü©

structure SumcheckMultiplierParam (L : Type) [CommRing L] (‚Ñì : ‚Ñï) (Context : Type := Unit) where
  multpoly : (ctx: Context) ‚Üí MultilinearPoly L ‚Ñì

MvPolynomial.coeff in Mathlib.Algebra.MvPolynomial.Basic

def getConst (F : Type) [NonBinaryField F] : OracleComp [(pSpec F).Message]‚Çí F[X] :=
  OracleComp.lift
    (by admit /- proof elided -/
    )

protected def cast (P : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec‚ÇÅ) :
    Prover oSpec StmtIn WitIn StmtOut WitOut pSpec‚ÇÇ where
  PrvState := P.PrvState ‚àò Fin.cast (congrArg (¬∑ + 1) hn.symm)
  input := P.input
  sendMessage := fun i st => do
    let ‚ü®msg, newSt‚ü© ‚Üê P.sendMessage (i.cast hn.symm (cast_symm hSpec)) st
    return ‚ü®(Message.cast_idx_symm hSpec) ‚ñ∏ msg, newSt‚ü©
  receiveChallenge := fun i st => do
    let f ‚Üê P.receiveChallenge (i.cast hn.symm (cast_symm hSpec)) st
    return fun chal => f (Challenge.cast_idx hSpec ‚ñ∏ chal)
  output := P.output ‚àò (fun st => _root_.cast (by admit /- proof elided -/
  ) st)

@[reducible]
def SimOracle.Impl (spec : OracleSpec Œπ) := SimOracle.Stateless spec []‚Çí

@[inline, reducible]
def lift : OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i) ‚Üí InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i) ‚Üí
    OuterStmtOut √ó (‚àÄ i, OuterOStmtOut i) :=
  lens.toFunB

instance : Slice (FullTranscript pSpec) ‚Ñï ‚Ñï
    (fun _ start stop => start ‚â§ stop ‚àß stop ‚â§ n)
    (fun _ start stop _ => FullTranscript (pSpec‚ü¶start:stop‚üß))
    where
  slice := fun v start stop h => extract start stop h.1 h.2 v

@[simp]
instance BTFieldNoZeroDiv (k : ‚Ñï) : NoZeroDivisors (BTField k) :=

local instance : OracleInterface Œ± where
  Query := Unit
  Response := Œ±
  answer := fun x _ => x

instance {Œ± : Type u} : SliceLT (Array Œ±) Nat (fun _ _ => True) (fun _ _ _ => Array Œ±) where
  sliceLT xs stop _ := xs.take stop

List.map in Init.Prelude

instance : Fact (Nat.Prime fieldSize) := ‚ü®is_prime‚ü©

Multiset.map in Mathlib.Data.Multiset.MapFold

instance instST‚ÇÅ : ‚àÄ i, SelectableType ((‚ü®!v[.P_to_V], !v[R‚¶É‚â§ deg‚¶Ñ[X]]‚ü© ++‚Çö !p[]).Challenge i) :=
  instSelectableTypeChallengeAppend

def Polynomial.toImpl {R : Type*} [Semiring R] (p : R[X]) : UniPoly R :=
  match p.degree with
  | ‚ä• => #[]
  | some d  => .ofFn (fun i : Fin (d + 1) => p.coeff i)

noncomputable def modBivar (P P' : MvPolynomial (Fin 2) F)
    (hlg : IsUnit ((MonomialOrder.lex).leadingCoeff P')) : MvPolynomial (Fin 2) F :=
      
      let ord : MonomialOrder (Fin 2) := MonomialOrder.lex
      
      let b : Unit ‚Üí MvPolynomial (Fin 2) F := fun _ => P'
      
      have hb : ‚àÄ i : Unit, IsUnit (ord.leadingCoeff (b i)) := by admit /- proof elided -/

def mul_by_2 (s : Finset ‚Ñï) : Finset ‚Ñï :=
  s.map ‚ü®fun n => 2 * n, by admit /- proof elided -/
  ‚ü©

@[reducible]
def pSpec : ProtocolSpec 1 := ‚ü®!v[.P_to_V], !v[OStatement default]‚ü©

@[ext]
structure ProverState (n : ‚Ñï) where
  PrvState : Fin (n + 1) ‚Üí Type

def one {k : ‚Ñï} : ConcreteBTField k := 1#(2 ^ k)

invFun in ToMathlib.Control.Monad.Equiv

@[inline]
def zsmul [SMul ‚Ñ§ R] (m : ‚Ñ§) (p : MlPoly R n) : MlPoly R n := p.map (fun a => m ‚Ä¢ a)

structure PublicParams where
  ‚Ñì_m : ‚Ñï
  ‚Ñì_n : ‚Ñï
  ‚Ñì_w : ‚Ñï
  ‚Ñì_w_le_‚Ñì_n : ‚Ñì_w ‚â§ ‚Ñì_n := by admit /- proof elided -/

BitVec in Init.Prelude

def outputRelation :
    Set
      (
        (Fri.Spec.Statement F (0 : Fin (k + 1)) √ó
        (‚àÄ j, Fri.Spec.OracleStatement D x s (0 : Fin (k + 1)) j)) √ó
        Fri.Spec.Witness F s d (0 : Fin (k + 2))
      ) := sorry

noncomputable def uni2bi (p : Polynomial F) : MvPolynomial (Fin 2) F :=
  Polynomial.eval‚ÇÇ MvPolynomial.C (MvPolynomial.X 0) p

structure WireIndices (numWires : ‚Ñï) where
   
  a : Fin numWires
   
  b : Fin numWires
   
  c : Fin numWires
deriving DecidableEq

instance [inst : SelectableType Chal] : ‚àÄ i, SelectableType (Challenge ‚ü®!v[.V_to_P], !v[Chal]‚ü© i)
  | ‚ü®0, _‚ü© => inst

@[reducible, inline]
instance instMvPolynomialDegreeLE : OracleInterface (R‚¶É‚â§ d‚¶Ñ[X œÉ]) where
  Query := œÉ ‚Üí R
  Response := R
  answer := fun ‚ü®poly, _‚ü© point => eval point poly

def SkeletonNodeIndex.sibling {s : Skeleton} (idx : SkeletonNodeIndex s) :
    Option (SkeletonNodeIndex s) :=
  match idx with
  
  | SkeletonNodeIndex.ofLeaf => none
  
  | SkeletonNodeIndex.ofInternal => none
  
  | @SkeletonNodeIndex.ofLeft left right idxLeft =>
    match idxLeft with
    
    | SkeletonNodeIndex.ofLeaf => some (getRootIndex right).ofRight
    
    | SkeletonNodeIndex.ofInternal => some (getRootIndex right).ofRight
    
    
    | SkeletonNodeIndex.ofLeft idxLeftLeft =>
      idxLeftLeft.ofLeft.sibling.map (SkeletonNodeIndex.ofLeft)
    | SkeletonNodeIndex.ofRight idxLeftRight =>
      idxLeftRight.ofRight.sibling.map (SkeletonNodeIndex.ofLeft)
  | @SkeletonNodeIndex.ofRight left right idxRight =>
    match idxRight with
    | SkeletonNodeIndex.ofLeaf => some (getRootIndex left).ofLeft
    | SkeletonNodeIndex.ofInternal => some (getRootIndex left).ofLeft
    | SkeletonNodeIndex.ofLeft idxRightLeft =>
      idxRightLeft.ofLeft.sibling.map (SkeletonNodeIndex.ofRight)
    | SkeletonNodeIndex.ofRight idxRightRight =>
      idxRightRight.ofRight.sibling.map (SkeletonNodeIndex.ofRight)

private noncomputable def evenPart' (f : Polynomial F) : Polynomial F :=
  match f with
  | ‚ü®‚ü®supp, f, pr‚ü©‚ü© => ‚ü®‚ü®erase_odd supp, fun n => if Even n then f n else 0, by admit /- proof elided -/
  ‚ü©‚ü©

noncomputable def towerRingHomBackwardMap (k : ‚Ñï) : BTField k ‚Üí ConcreteBTField k :=

def FullData.copath {Œ±} {s} (cache_tree : FullData Œ± s) :
    BinaryTree.SkeletonLeafIndex s ‚Üí List Œ±
  | .ofLeaf => []
  | .ofLeft idxLeft =>
    (cache_tree.rightSubtree).getRootValue ::
      (copath cache_tree.leftSubtree idxLeft)
  | .ofRight idxRight =>
    (cache_tree.leftSubtree).getRootValue ::
      (copath cache_tree.rightSubtree idxRight)

def toChallengesUpTo (transcript : Transcript k pSpec) : ChallengesUpTo k pSpec :=
  fun ‚ü®i, _‚ü© => transcript i

def checkInitImports : IO Bool := do
  \n\
      The `header` linter is included in Mathlib.Init, and every file in Mathlib \
      should import Mathlib.Init.\nPlease adjust the imports accordingly."
    return true

  e

@[inline] def div [Zero T] [DecidableEq T] [ToNat T]
    (dividend divisor : Cayley T) : Cayley T :=
  
  letI fuel := (‚Üëdividend : Nat) + 1
  divNat dividend divisor fuel

ByteArray.empty in Init.Prelude

Function.comp in Init.Prelude

Lean.Name in Init.Prelude

def duplexSpongeToBasicFSAlgo
    (P : OracleComp (oSpec ++‚Çí duplexSpongeChallengeOracle StmtIn U)
    (StmtIn √ó pSpec.Messages)) :
    OracleComp (oSpec ++‚Çí fsChallengeOracle StmtIn pSpec) (StmtIn √ó pSpec.Messages) :=
  sorry

alias d2SAlgo := duplexSpongeToBasicFSAlgo

instance instZero {n : ‚Ñï} : Zero (CNat n) := match n with
  | 0 => by admit /- proof elided -/
  | .succ n => by admit /- proof elided -/

Set.toFinset in Mathlib.Data.Fintype.Sets

@[simp]
instance BTFieldNeZero1 (k : ‚Ñï) : NeZero (1 : BTField k) :=

Classical.typeDecidableEq in Init.Classical

@[inline, reducible]
def OracleStatement.Lens (OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut : Type)
    {Outer_Œπ‚Çõ·µ¢ : Type} (OuterOStmtIn : Outer_Œπ‚Çõ·µ¢ ‚Üí Type) [‚àÄ i, OracleInterface (OuterOStmtIn i)]
    {Outer_Œπ‚Çõ‚Çí : Type} (OuterOStmtOut : Outer_Œπ‚Çõ‚Çí ‚Üí Type) [‚àÄ i, OracleInterface (OuterOStmtOut i)]
    {Inner_Œπ‚Çõ·µ¢ : Type} (InnerOStmtIn : Inner_Œπ‚Çõ·µ¢ ‚Üí Type) [‚àÄ i, OracleInterface (InnerOStmtIn i)]
    {Inner_Œπ‚Çõ‚Çí : Type} (InnerOStmtOut : Inner_Œπ‚Çõ‚Çí ‚Üí Type) [‚àÄ i, OracleInterface (InnerOStmtOut i)]
  :=
    Statement.Lens (OuterStmtIn √ó ‚àÄ i, OuterOStmtIn i) (OuterStmtOut √ó ‚àÄ i, OuterOStmtOut i)
                  (InnerStmtIn √ó ‚àÄ i, InnerOStmtIn i) (InnerStmtOut √ó ‚àÄ i, InnerOStmtOut i)

def extract {n : ‚Ñï} {Œ± : Fin n ‚Üí Sort*} (start stop : ‚Ñï) (h1 : start ‚â§ stop) (h2 : stop ‚â§ n)
    (v : (i : Fin n) ‚Üí Œ± i) : (i : Fin (stop - start)) ‚Üí Œ± ‚ü®i + start, by admit /- proof elided -/
    ‚ü© :=
  fun i ‚Ü¶ v ‚ü®i + start, by admit /- proof elided -/
  ‚ü©

@[reducible, simp] def WitIn := Unit

def twoLevelSkel (k0 k1 : ‚Ñï) :
    ArityTree.Skeleton 2 (ar2 k0 k1) :=
  ArityTree.Skeleton.node (fun _ =>
    ArityTree.Skeleton.node (fun _ => ArityTree.Skeleton.leaf))

def numOStmtQueries [DecidableEq Œπ‚Çõ·µ¢] (i : Œπ‚Çõ·µ¢)
    (stmt : StmtIn) (challenges : ‚àÄ i, pSpec.Challenge i)
    (naVerifier : OracleVerifier.NonAdaptive oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec) : ‚Ñï :=
  (naVerifier.queryOStmt stmt challenges).filter (fun q => q.1 = i) |>.length

instance [h : ProverFirst pSpec] : IsEmpty (pSpec.ChallengeIdx) where
  false | ‚ü®0, h'‚ü© => by admit /- proof elided -/

@[inline, reducible]
def proj (lens : Extractor.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
              OuterWitIn OuterWitOut InnerWitIn InnerWitOut) :
    OuterStmtIn √ó OuterWitOut ‚Üí InnerStmtIn √ó InnerWitOut :=
  fun ‚ü®stmtIn, witOut‚ü© => ‚ü®lens.stmt.proj stmtIn, lens.wit.proj (stmtIn, witOut)‚ü©

@[simp]
def list (k : ‚Ñï) : List.Vector (BTField k) (k + 1) := (BinaryTowerAux k).2.vec

def toEvalsZeroOne (p : MvPolynomial œÉ R) : (œÉ ‚Üí Fin 2) ‚Üí R :=
  fun x => eval (x : œÉ ‚Üí R) p

@[reducible]
def duplexSpongeChallengeOracle (StartType : Type) (U : Type) [SpongeUnit U] [SpongeSize] :
    OracleSpec (Unit ‚äï PermuteDir) :=
  (StartType ‚Üí‚Çí Vector U SpongeSize.C) ++‚Çí permutationOracle (CanonicalSpongeState U)

alias ùíü_ùîñ := duplexSpongeChallengeOracle

List.IsSuffix in Init.Data.List.Basic

abbrev SEP_BYTE : String := ‚ü®[SEP_CHAR]‚ü©

MvPolynomial.support in Mathlib.Algebra.MvPolynomial.Basic

@[reducible]
def oracleVerifier : OracleVerifier oSpec (StatementRound R n 0) (OracleStatement R n deg)
    (StatementRound R n (.last n)) (OracleStatement R n deg) (pSpec R deg n) :=
  OracleVerifier.seqCompose (oSpec := oSpec)
    (Stmt := StatementRound R n)
    (OStmt := fun _ => OracleStatement R n deg)
    (pSpec := fun _ => SingleRound.pSpec R deg)
    (SingleRound.oracleVerifier R n deg D oSpec)

def pSpecFoldRelaySequence (n : ‚Ñï) :=
  ProtocolSpec.seqCompose fun (_: Fin n) ‚Ü¶ pSpecFoldRelay (L:=L)

def InternalData.ofFun {Œ± : Type} (s : Skeleton)
    (f : SkeletonInternalIndex s ‚Üí Œ±) : InternalData Œ± s :=
  match s with
  | .leaf => InternalData.leaf
  | .internal l r =>
      InternalData.internal
        (f SkeletonInternalIndex.ofInternal)
        (InternalData.ofFun l (fun idx => f (SkeletonInternalIndex.ofLeft idx)))
        (InternalData.ofFun r (fun idx => f (SkeletonInternalIndex.ofRight idx)))

def soundness (langIn : Set StmtIn) (langOut : Set StmtOut)
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    (soundnessError : ‚Ñù‚â•0) : Prop :=
  ‚àÄ WitIn WitOut : Type,
  ‚àÄ witIn : WitIn,
  ‚àÄ prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec,
  ‚àÄ stmtIn ‚àâ langIn,
    letI reduction := Reduction.mk prover verifier
    [fun ‚ü®_, stmtOut‚ü© => stmtOut ‚àà langOut
    | do (simulateQ (impl ++‚Çõ‚Çí challengeQueryImpl : QueryImpl _ (StateT œÉ ProbComp))
        <| reduction.run stmtIn witIn).run' (‚Üê init)] ‚â§ soundnessError

Function.onFun in Mathlib.Logic.Function.Defs

@[reducible]
def reduction : Reduction oSpec StmtIn WitIn StmtOut WitOut !p[] where
  prover := prover mapStmt mapWit
  verifier := verifier mapStmt

instance [reduction.IsPerfectComplete init impl relIn relOut] :
    IsComplete init impl relIn relOut reduction where
  completenessError := 0
  is_complete := IsPerfectComplete.is_perfect_complete

@[inline]
def add [Add R] (p q : MlPoly R n) : MlPoly R n := Vector.zipWith (¬∑ + ¬∑) p q

noncomputable def deevenize (f : Polynomial F) : Polynomial F :=
    match f with
      | ‚ü®‚ü®supp, g, h‚ü©‚ü© => ‚ü®‚ü®divide_by_2 supp, fun n => g (2 * n), by admit /- proof elided -/
      ‚ü©‚ü©

abbrev ùí™ (H : F[X][Y]) : Type :=
  (Polynomial (Polynomial F)) ‚ß∏ (Ideal.span {H_tilde' H})

Nat.max in Init.Data.Nat.Basic

def SkeletonLeafIndex.isLeaf {s : Skeleton} (idx : SkeletonLeafIndex s) : Bool :=
  match idx with
  | SkeletonLeafIndex.ofLeaf => true
  | SkeletonLeafIndex.ofLeft _ => false
  | SkeletonLeafIndex.ofRight _ => false

CommGroup in Mathlib.Algebra.Group.Defs

class Deserialize.CloseToUniform (Œ± : Type u) (Œ≤ : Type u)
    [Fintype Œ±] [Fintype Œ≤] [Nonempty Œ±] [Nonempty Œ≤] [Deserialize Œ± Œ≤] where
  Œµ : ‚Ñù‚â•0
  Œµ_close : dist (PMF.uniformOfFintype Œ±) (deserialize <$> PMF.uniformOfFintype Œ≤) ‚â§ Œµ

@[inline] def pred : AssocNat ‚Üí AssocNat :=
  fun a => match a.toNat with
  | 0 => zero
  | Nat.succ k => ofNat k

instance : Unique (ChallengeIdx ‚ü®!v[.V_to_P], !v[Chal]‚ü©) where
  default := ‚ü®0, by admit /- proof elided -/
  ‚ü©
  uniq := fun i => by admit /- proof elided -/

def findImports (path : System.FilePath) : IO (Array Lean.Name) := do
  return (‚Üê Lean.parseImports' (‚Üê IO.FS.readFile path) path.toString)
    |>.map (fun imp ‚Ü¶ imp.module) |>.erase `Init

Int.natAbs in Init.Data.Int.Basic

Vector.insertIdx in Init.Data.Vector.Basic

def toFinMatrix {m n : ‚Ñï} (matrix : Matrix Œ± m n) : _root_.Matrix (Fin m) (Fin n) Œ± :=
  fun i j => (matrix.get i).get j

@[simp]
instance Nontrivial (k : ‚Ñï) : Nontrivial (BTField k) := inferInstance

structure Indexer {Œπ : Type} (oSpec : OracleSpec Œπ) {n : ‚Ñï} (pSpec : ProtocolSpec n) (Index : Type)
    (Encoding : Type) where
  encode : Index ‚Üí OracleComp oSpec Encoding
  [OracleInterface : OracleInterface Encoding]

def multilinearBasis (l r : ‚Ñï) (h_le : l ‚â§ r) :
    letI instAlgebra := ConcreteBTFieldAlgebra (h_le:=h_le)
    Basis (Fin (2 ^ (r - l))) (ConcreteBTField l) (ConcreteBTField r) :=

def evalOnPoints [Semiring F] : F[X] ‚Üí‚Çó[F] (Œπ ‚Üí F) where
  toFun := fun p => fun x => p.eval (domain x)
  map_add' := fun x y => by admit /- proof elided -/

def ratchetUnchecked [Permute C] (sponge : DuplexSponge U C) : DuplexSponge U C :=
  simulateQ' forwardPermutationOracleImpl (ratchet sponge) (by admit /- proof elided -/
  )

instance (k : ‚Ñï) : AddCommGroup (ConcreteBTField k) := mkAddCommGroupInstance

def modByMonic [Field R] (p : UniPoly R) (q : UniPoly R) :
    UniPoly R :=
  (divModByMonicAux p q).2

@[simp]
def evalDomain (i : ‚Ñï) : Set FÀ£ :=
  (x ^ (2 ^ i)) ‚Ä¢ (Domain.evalDomain D i)

noncomputable def monomialBasisOfDegreeLT {n : ‚Ñï} : Basis (Fin n) L (L‚¶É< n‚¶Ñ[X]) :=

noncomputable def toPoly (p : UniPoly R) : Polynomial R :=
  p.eval‚ÇÇ Polynomial.C Polynomial.X

def rbrKnowledgeSoundnessOneShot (relIn : Set (StmtIn √ó WitIn)) (relOut : Set (StmtOut √ó WitOut))
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    (rbrKnowledgeError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) : Prop :=
  ‚àÉ stateFunction : verifier.KnowledgeStateFunctionOneShot init impl relIn.language relOut.language,
  ‚àÉ extractor : Extractor.RoundByRoundOneShot oSpec StmtIn WitIn pSpec,
  ‚àÄ stmtIn : StmtIn,
  ‚àÄ witIn : WitIn,
  ‚àÄ prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec,
  ‚àÄ i : pSpec.ChallengeIdx,
    [fun ‚ü®transcript, challenge, proveQueryLog‚ü© =>
      letI extractedWitIn := extractor i.1.castSucc stmtIn transcript proveQueryLog.fst
      (stmtIn, extractedWitIn) ‚àâ relIn ‚àß
        ¬¨ stateFunction i.1.castSucc stmtIn transcript ‚àß
          stateFunction i.1.succ stmtIn (transcript.concat challenge)
    | do
      (simulateQ (impl ++‚Çõ‚Çí challengeQueryImpl : QueryImpl _ (StateT œÉ ProbComp))
        (do
          let ‚ü®‚ü®transcript, _‚ü©, proveQueryLog‚ü© ‚Üê prover.runWithLogToRound i.1.castSucc stmtIn witIn
          let challenge ‚Üê liftComp (pSpec.getChallenge i) _
          return (transcript, challenge, proveQueryLog))).run' (‚Üê init)] ‚â§
      rbrKnowledgeError i

def sumExceptFirst (n : ‚Ñï) (D : Fin n ‚Üí Finset R) :
    MvPolynomial (Fin (n + 1)) R ‚Üí‚Çó[R] Polynomial R :=

def accepts (x : Fin numWires ‚Üí ùì°) (g : Gate ùì° numWires) : Prop :=
  g.eval x = 0

@[reducible, simp]
def OracleStatement.Lens.IsSound {OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut : Type}
    {Outer_Œπ‚Çõ·µ¢ : Type} {OuterOStmtIn : Outer_Œπ‚Çõ·µ¢ ‚Üí Type} [‚àÄ i, OracleInterface (OuterOStmtIn i)]
    {Outer_Œπ‚Çõ‚Çí : Type} {OuterOStmtOut : Outer_Œπ‚Çõ‚Çí ‚Üí Type} [‚àÄ i, OracleInterface (OuterOStmtOut i)]
    {Inner_Œπ‚Çõ·µ¢ : Type} {InnerOStmtIn : Inner_Œπ‚Çõ·µ¢ ‚Üí Type} [‚àÄ i, OracleInterface (InnerOStmtIn i)]
    {Inner_Œπ‚Çõ‚Çí : Type} {InnerOStmtOut : Inner_Œπ‚Çõ‚Çí ‚Üí Type} [‚àÄ i, OracleInterface (InnerOStmtOut i)]
    (outerLangIn : Set (OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i)))
    (outerLangOut : Set (OuterStmtOut √ó (‚àÄ i, OuterOStmtOut i)))
    (innerLangIn : Set (InnerStmtIn √ó (‚àÄ i, InnerOStmtIn i)))
    (innerLangOut : Set (InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i)))
    (compatStmt :
      OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i) ‚Üí InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i) ‚Üí Prop)
    (lens : OracleStatement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                                    OuterOStmtIn OuterOStmtOut InnerOStmtIn InnerOStmtOut) :=
  Statement.Lens.IsSound outerLangIn outerLangOut innerLangIn innerLangOut compatStmt lens

instance : curve.IsElliptic :=

def MLEEquivFin {n : ‚Ñï} : R‚¶É‚â§ 1‚¶Ñ[X (Fin n)] ‚âÉ (Fin (2 ^ n) ‚Üí R) :=
  Equiv.trans MLEEquiv (Equiv.piCongr finFunctionFinEquiv (fun _ => Equiv.refl _))

def fiberwiseDistance (i : Fin ‚Ñì) (steps : ‚Ñï) [NeZero steps] (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
  (f : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i.val, by admit /- proof elided -/
  ‚ü©) : ‚Ñï :=
  
  
  let C_i := BBF_Code ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i.val, by admit /- proof elided -/
  ‚ü©
  let disagreement_sizes := (fun (g : C_i) =>
    (fiberwiseDisagreementSet ùîΩq Œ≤ i steps h_i_add_steps f g).ncard) '' Set.univ
  sInf disagreement_sizes

instance [h : VerifierFirst pSpec] : IsEmpty (pSpec.MessageIdx) where
  false | ‚ü®0, h'‚ü© => by admit /- proof elided -/

@[reducible, inline]
def ùï´ {R} {sz} (stmt : Statement R sz) (wit : Witness R sz) : Fin sz.n ‚Üí R :=
  Fin.append stmt wit ‚àò Fin.cast (by admit /- proof elided -/
  )

noncomputable instance {Œ± : Type} (s : Set Œ±) [inst : Finite s] : Fintype s := Fintype.ofFinite _

def ConcreteBTField : ‚Ñï ‚Üí Type := fun k => BitVec (2 ^ k)

noncomputable def disagreementSet (f : Œπ ‚Üí F) (S : Finset F) (Ans : S ‚Üí F) : Finset F :=
  Set.toFinset ({x : Œπ | x.val ‚àà S ‚àß (ansPoly S Ans).eval x.val ‚â† f x}.image Subtype.val)

@[inline, specialize]
def runToRound (i : Fin (n + 1))
    (stmt : StmtIn) (wit : WitIn) (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí) (pSpec.Transcript i √ó prover.PrvState i) :=
  Fin.induction
    (pure ‚ü®default, prover.input (stmt, wit)‚ü©)
    (prover.processRound)
    i

noncomputable def queryOracleProver :
  OracleProver
    (oSpec := []‚Çí)
    (StmtIn := FinalSumcheckStatementOut (L:=L) (‚Ñì:=‚Ñì))
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (
    Fin.last ‚Ñì))
    (WitIn := Unit)
    (StmtOut := Bool)
    (OStmtOut := fun _ : Empty => Unit)
    (WitOut := Unit)
    (pSpec := pSpecQuery ùîΩq Œ≤ Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)) where
  PrvState := fun
    | 0 => Unit
    | 1 => Unit
  input := fun _ => ()

  sendMessage
  | ‚ü®0, h‚ü© => nomatch h

  receiveChallenge
  | ‚ü®0, _‚ü© => fun _ => do
    
    pure (fun _challenges => ())

  output := fun _ => do 
    pure (‚ü®true, fun _ => ()‚ü©, ())

def Cache.leaves (n : ‚Ñï) (cache : Cache Œ± (n + 1)) :
    List.Vector Œ± (2 ^ (n + 1)) := cache (Fin.last _)

@[simp]
def BTFieldCard (k : ‚Ñï) : Fintype.card (BTField k) = 2^(2^k)
  := (BinaryTowerAux k).2.fieldFintypeCard

Rat in Init.Data.Rat.Basic

Algebra.TensorProduct.comm in Mathlib.RingTheory.TensorProduct.Maps

instance instDCast‚ÇÇ : DCast‚ÇÇ Nat ProtocolSpec (fun _ pSpec => FullTranscript pSpec) where
  dcast‚ÇÇ h h' T := FullTranscript.cast h h' T
  dcast‚ÇÇ_id := cast_id

def Reduction.liftContext
    (lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut)
    (R : Reduction oSpec InnerStmtIn InnerWitIn InnerStmtOut InnerWitOut pSpec) :
      Reduction oSpec OuterStmtIn OuterWitIn OuterStmtOut OuterWitOut pSpec where
  prover := R.prover.liftContext lens
  verifier := R.verifier.liftContext lens.stmt

  inductive UnverifiedPrattPart : Type
    | prime : (p : ‚Ñï) ‚Üí (k : ‚Ñï) ‚Üí (hp : UnverifiedPrattCertificate p) ‚Üí UnverifiedPrattPart
    | split : UnverifiedPrattPart ‚Üí UnverifiedPrattPart ‚Üí UnverifiedPrattPart
  deriving Repr

Polynomial.natDegree in Mathlib.Algebra.Polynomial.Degree.Definitions

@[app_unexpander Fin.dempty]
def demptyUnexpander : Lean.PrettyPrinter.Unexpander
  | `($_:ident) => `(!h[])
  | _ => throw ()

def ValidChurchNat : Type :=
  { f : ChurchNat ‚Ñï // ‚àÉ n, ‚àÄ g x, f g x = Nat.iterate g n x }

def oracleReduction : OracleReduction oSpec
      Statement OStatement Unit
      Unit (OStatement ‚äï·µ• OStatement) Unit (pSpec OStatement) where
  prover := oracleProver oSpec Statement OStatement
  verifier := oracleVerifier oSpec Statement OStatement relComp

def oracleReduction : OracleReduction oSpec (StmtIn R) (OStmtIn R deg) Unit
                                            (StmtOut R) (OStmtOut R deg) Unit (pSpec R deg) where
  prover := prover R deg oSpec
  verifier := oracleVerifier R deg D oSpec

@[inline]
def nsmul [SMul ‚Ñï R] (m : ‚Ñï) (p : MlPolyEval R n) : MlPolyEval R n := p.map (fun a => m ‚Ä¢ a)

@[reducible, simp] def OStmtAfterSendClaim : Unit ‚äï Unit ‚Üí Type := fun _ => R‚¶É‚â§ deg‚¶Ñ[X]

SemilatticeSup in Mathlib.Order.Lattice

class SliceLT (coll : Type u) (stop : Type v) (valid : outParam (coll ‚Üí stop ‚Üí Prop))
    (subcoll : outParam ((xs : coll) ‚Üí (stop : stop) ‚Üí (h : valid xs stop) ‚Üí Type w)) where
  sliceLT : (xs : coll) ‚Üí (stop : stop) ‚Üí (h : valid xs stop) ‚Üí subcoll xs stop h

@[reducible, inline, specialize, simp]
def srChallengeQueryImpl {Statement : Type} {pSpec : ProtocolSpec n}
    [‚àÄ i, SelectableType (pSpec.Challenge i)] :
    QueryImpl (srChallengeOracle Statement pSpec) ProbComp where
  impl | query i _ => uniformOfFintype (pSpec.Challenge i)

def last_nonzero_prop {p : UniPoly R} (k : Fin p.size) : Prop :=
  p[k] ‚â† 0 ‚àß (‚àÄ j, (hj : j < p.size) ‚Üí j > k ‚Üí p[j] = 0)

StateT in Init.Control.State

class Context.Lens.IsComplete {OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut : Type}
    {OuterWitIn OuterWitOut InnerWitIn InnerWitOut : Type}
    (outerRelIn : Set (OuterStmtIn √ó OuterWitIn))
    (innerRelIn : Set (InnerStmtIn √ó InnerWitIn))
    (outerRelOut : Set (OuterStmtOut √ó OuterWitOut))
    (innerRelOut : Set (InnerStmtOut √ó InnerWitOut))
    (compat : (OuterStmtIn √ó OuterWitIn) ‚Üí (InnerStmtOut √ó InnerWitOut) ‚Üí Prop)
    (lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut) where

  proj_complete : ‚àÄ stmtIn witIn,
    (stmtIn, witIn) ‚àà outerRelIn ‚Üí
    (lens.stmt.proj stmtIn, lens.wit.proj (stmtIn, witIn)) ‚àà innerRelIn

  lift_complete : ‚àÄ outerStmtIn outerWitIn innerStmtOut innerWitOut,
    compat (outerStmtIn, outerWitIn) (innerStmtOut, innerWitOut) ‚Üí
    (outerStmtIn, outerWitIn) ‚àà outerRelIn ‚Üí
    (innerStmtOut, innerWitOut) ‚àà innerRelOut ‚Üí
    (lens.stmt.lift outerStmtIn innerStmtOut,
    lens.wit.lift (outerStmtIn, outerWitIn) (innerStmtOut, innerWitOut)) ‚àà outerRelOut

def equivMvPolynomialDeg1 : MlPoly R n ‚âÉ R‚¶É‚â§ 1‚¶Ñ[X Fin n] where
  toFun := toMvPolynomialDeg1
  invFun := ofMvPolynomialDeg1
  left_inv v := by admit /- proof elided -/

def monomialBasis (w : Vector R n) : Vector R (2 ^ n) :=
  Vector.ofFn (fun i => ‚àè j : Fin n, if (BitVec.ofFin i).getLsb j then w[j] else 1)

def vprod [CommMonoid Œ±] {n : ‚Ñï} (a : Fin n ‚Üí Œ±) : Œ± :=
  Fin.dfoldr' n (fun _ => Œ±) (fun i acc => a i * acc) 1

instance {Œ± : Type u} : Slice (Array Œ±) Nat Nat (fun _ _ _ => True) (fun _ _ _ _ => Array Œ±) where
  slice xs start stop _ := xs.extract start stop

def processMemoryOps (ops : List (MemoryOp Œπ Œ±)) (startMem : M) : Option M :=
  ops.foldlM (fun m op =>
    match op with
    | .read ‚ü®i, v‚ü© => if Memory.read m i = v then some m else none
    | .write ‚ü®i, v‚ü© => some (Memory.write m i v)
  ) startMem

instance instAlgebraLiftConcreteBTField (k : ‚Ñï)
  (prevBTFResult : ConcreteBTFStepResult (k := k)) :
  letI := mkFieldInstance (prevBTFResult.toConcreteBTFieldProps)
  letI := liftConcreteBTField (k:=k) prevBTFResult
  Algebra (ConcreteBTField k) (ConcreteBTField (k + 1)) :=
  letI := mkFieldInstance (prevBTFResult.toConcreteBTFieldProps)
  letI := liftConcreteBTField (k:=k) prevBTFResult
  RingHom.toAlgebra (R:=ConcreteBTField k) (S:=ConcreteBTField (k + 1))
    (i:=(concreteCanonicalEmbedding (k:=k)
      (prevBTFieldProps:=prevBTFResult.toConcreteBTFieldProps)
      (curBTFieldProps:=liftBTFieldProps (k:=k) (prevBTFResult:=prevBTFResult))))

PFunctor.Lens in ToMathlib.PFunctor.Basic

instance {Œ± : Type u} [ToNat Œ±] : CoeHead Œ± Nat where
  coe := ToNat.toNat

Equiv.toEmbedding in Mathlib.Logic.Embedding.Basic

Finsupp.onFinset in Mathlib.Data.Finsupp.Defs

instance : DeserializeOption UInt8 ByteArray where
  deserialize bytes :=
    if h : bytes.size = 1 then
      some bytes[0]
    else
      none

def OracleSpec.FunctionType (spec : OracleSpec Œπ) := (i : Œπ) ‚Üí spec.domain i ‚Üí spec.range i

instance : ‚àÄ j, OracleInterface ((pSpec D x l).Message j) := fun j =>
  match j with
  | ‚ü®0, h‚ü© => nomatch h

Fin.castLE in Init.Data.Fin.Basic

instance : ‚àÄ j, SelectableType ((pSpecRelay).Challenge j)
  | ‚ü®x, hj‚ü© => by admit /- proof elided -/

instance (k : ‚Ñï) : HAdd (ConcreteBTField k) (ConcreteBTField k) (ConcreteBTField k)
  where hAdd := add

CommGroupWithZero in Mathlib.Algebra.GroupWithZero.Defs

noncomputable def sDomain.lift (i j : Fin r) (h_j : j < ‚Ñì + R_rate) (h_le : i ‚â§ j)
    (y : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate j) :
    sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i :=

cond in Init.Prelude

def testNTTBTF‚ÇÉ : Fin (2 ^ (2 + 2)) ‚Üí BTF‚ÇÉ :=

noncomputable def finalSumcheckKnowledgeStateFunction {œÉ : Type} (init : ProbComp œÉ)
    (impl : QueryImpl []‚Çí (StateT œÉ ProbComp)) :
    (finalSumcheckVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).KnowledgeStateFunction init impl
    (relIn := roundRelation ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (ùìë := ùìë) (mp := BBF_SumcheckMultiplierParam) (Fin.last ‚Ñì))
    (relOut := finalSumcheckRelOut ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (extractor := finalSumcheckRbrExtractor ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
  where
  toFun := fun m ‚ü®stmt, oStmt‚ü© tr witMid =>
    finalSumcheckKStateProp ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (ùìë := ùìë) (tr := tr) (stmt := stmt) (witMid := witMid) (oStmt := oStmt)
  toFun_empty := fun stmt witMid => by admit /- proof elided -/

structure ModifiedGuruswami
  (m n k : ‚Ñï)
  (œâs : Fin n ‚Ü™ F)
  (Q : F[Z][X][Y])
  (u‚ÇÄ u‚ÇÅ : Fin n ‚Üí F)
  where
  Q_ne_0 : Q ‚â† 0
   
  Q_deg : natWeightedDegree Q 1 k < D_X ((k + 1) / (n : ‚Ñö)) n m
   
  Q_multiplicity : ‚àÄ i, rootMultiplicity Q
              (Polynomial.C <| œâs i)
              ((Polynomial.C <| u‚ÇÄ i) + Polynomial.X * (Polynomial.C <| u‚ÇÅ i))
            ‚â• m
   
  Q_deg_X :
    degreeX Q < D_X ((k + 1) / (n : ‚Ñö)) n m
   
  Q_D_Y :
    D_Y Q < D_X (k + 1 / (n : ‚Ñö)) n m / k
   
  Q_D_YZ :
    D_YZ Q ‚â§ n * (m + 1/(2 : ‚Ñö))^3 / (6 * Real.sqrt ((k + 1) / n))

instance : ‚àÄ i, SelectableType (Challenge ‚ü®!v[.P_to_V], !v[Msg]‚ü© i)
  | ‚ü®0, h‚ü© => nomatch h

abbrev eqPolynomial (r : œÉ ‚Üí R) : R[X œÉ] :=
  ‚àè i : œÉ, singleEqPolynomial (r i) (X i)

instance : ‚àÄ i, OracleInterface ((pSpecQuery ùîΩq Œ≤ Œ≥_repetitions
  (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).Message i) := fun _ => OracleInterface.instDefault

@[reducible]
def backwardPermutationOracle (Œ± : Type*) : OracleSpec Unit := Œ± ‚Üí‚Çí Œ±

def map {Œ± Œ≤ : Fin n ‚Üí Sort*} (f : (i : Fin n) ‚Üí Œ± i ‚Üí Œ≤ i) (a : (i : Fin n) ‚Üí Œ± i) :
    (i : Fin n) ‚Üí Œ≤ i := fun i => f i (a i)

def last_nonzero (p : UniPoly R) : Option (Fin p.size) :=
  p.findIdxRev? (¬∑ != 0)

def Verifier.StateFunction.liftContext
    {œÉ : Type} {init : ProbComp œÉ} {impl : QueryImpl oSpec (StateT œÉ ProbComp)}
    (lens : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut)
    (V : Verifier oSpec InnerStmtIn InnerStmtOut pSpec)
    (outerLangIn : Set OuterStmtIn) (outerLangOut : Set OuterStmtOut)
    (innerLangIn : Set InnerStmtIn) (innerLangOut : Set InnerStmtOut)
    [lensSound : lens.IsSound outerLangIn outerLangOut innerLangIn innerLangOut
      (V.compatStatement lens)]
    (stF : V.StateFunction init impl innerLangIn innerLangOut) :
      (V.liftContext lens).StateFunction init impl outerLangIn outerLangOut
where
  toFun := fun m outerStmtIn transcript =>
    stF m (lens.proj outerStmtIn) transcript
  toFun_empty := fun stmt => by admit /- proof elided -/

OracleSpec.QueryCache in VCVio.OracleComp.QueryTracking.Structures

abbrev ScalarField := ZMod scalarFieldSize

def choose_2 (x : ‚Ñö) : ‚Ñö := x * (x-1)/2

def secondSumCheckVirtualPolynomial
    (stmt : Statement.AfterLinearCombination R pp)
    (oStmt : ‚àÄ i, OracleStatement.AfterLinearCombination R pp i) :
      MvPolynomial (Fin pp.‚Ñì_n) R := sorry

algebraMap in Mathlib.Algebra.Algebra.Defs

def completeness (relIn : Set (StmtIn √ó WitIn))
    (relOut : Set (StmtOut √ó WitOut))
    (reduction : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec)
    (completenessError : ‚Ñù‚â•0) : Prop :=
  ‚àÄ stmtIn : StmtIn,
  ‚àÄ witIn : WitIn,
  (stmtIn, witIn) ‚àà relIn ‚Üí
    [fun ‚ü®‚ü®_, (prvStmtOut, witOut)‚ü©, stmtOut‚ü© => (stmtOut, witOut) ‚àà relOut ‚àß prvStmtOut = stmtOut
    | do (simulateQ (impl ++‚Çõ‚Çí challengeQueryImpl : QueryImpl _ (StateT œÉ ProbComp))
          <| reduction.run stmtIn witIn).run' (‚Üê init)] ‚â• 1 - completenessError

def challengeQueryImpl {pSpec : ProtocolSpec n} [‚àÄ i, SelectableType (pSpec.Challenge i)] :
    QueryImpl ([pSpec.Challenge]‚Çí'challengeOracleInterface) ProbComp where
  impl | query i () => uniformOfFintype (pSpec.Challenge i)

def outputRelation [DecidableEq F] (Œ¥ : ‚Ñù‚â•0) :
    Set
      (
        (FinalStatement F k √ó ‚àÄ j, FinalOracleStatement D x s j) √ó
        Witness F s d (Fin.last (k + 1))
      )
  := QueryRound.outputRelation D x s d (round_bound dom_size_cond) Œ¥

@[reducible]
def addSalt (pSpec : ProtocolSpec n) (Salt : pSpec.MessageIdx ‚Üí Type) :
    ProtocolSpec n :=
  ‚ü®pSpec.dir, fun i => match hDir : pSpec.dir i with
    | .P_to_V => (pSpec.¬´Type¬ª i) √ó Salt ‚ü®i, hDir‚ü©
    | .V_to_P => pSpec.¬´Type¬ª i‚ü©

abbrev rdrop (m : ‚Ñï) (h : m ‚â§ n)
    (transcript : FullTranscript pSpec) : FullTranscript (pSpec.rdrop m h) :=
  Fin.rdrop m h transcript

instance : ‚àÄ i, OracleInterface (OracleStatement R pp i) :=
  fun i => {
    Query := (Fin pp.‚Ñì_m ‚Üí R) √ó (Fin pp.‚Ñì_n ‚Üí R)
    Response := R
    answer := fun matrix ‚ü®x, y‚ü© => matrix.toMLE ‚∏®C ‚àò x‚∏© ‚∏®y‚∏©
  }

BitVec.ofNat in Init.Prelude

Fin.pred in Init.Data.Fin.Basic

private def f (x : ‚Ñö) : ‚Ñö := x^2 - x

@[reducible]
def SCALAR_FIELD_CARD : Nat := 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141

def popCount (n : Nat) := (Nat.digits 2 n).sum

def oracleReduction.checkClaim : OracleReduction oSpec
    (StmtAfterSendClaim R) (OStmtAfterSendClaim R deg) Unit
    (StmtAfterCheckClaim R) (OStmtAfterCheckClaim R deg) Unit !p[] :=
  sorry

@[simp]
def outerRelOut_Test : Set (OuterStmtOut_Test √ó Unit) :=
  setOf (fun ‚ü®‚ü®p, q, t, r‚ü©, _‚ü© => (p * q).eval r = t)

def natWeightedDegree.{u} {F : Type u} [Semiring F] (f : F[X][Y]) (u v : ‚Ñï) : ‚Ñï :=
  f.support.sup (fun m => u * (f.coeff m).natDegree + v * m)

def churchNil : ChurchVec Œ± := fun f base => base

def generator : BaseField √ó BaseField := (1, 2)

def ri (dstar : ‚Ñï) (degs : Fin m ‚Üí ‚Ñï) (r : F) (i : Fin m) : F :=
          match i.1 with
          | 0 => 1
          | .succ i' =>
            let exp := i' + ‚àë j < i, (dstar - degs j)
            r ^ exp

def vconcat {n : ‚Ñï} (v : Fin n ‚Üí Œ±) (a : Œ±) : Fin (n + 1) ‚Üí Œ± :=
  dconcat v a

@[inline] def succ (a : Cayley T) : Cayley T := add a one

noncomputable def J (q Œ¥ : ‚Ñö) : ‚Ñù :=
  let frac := q / (q - 1)
  (1 / frac) * (1 - Real.sqrt (1 - frac * Œ¥))

Quotient in Init.Core

def getPutativeRoot_with_hash {s} (idx : BinaryTree.SkeletonLeafIndex s)
    (leafValue : Œ±) (proof : List Œ±) (hashFn : Œ± ‚Üí Œ± ‚Üí Œ±) : Œ± :=
  match proof with
  | [] => leafValue 
  | siblingBelowRootHash :: restProof =>
    match idx with
    | BinaryTree.SkeletonLeafIndex.ofLeaf =>
      
      
      
      leafValue
    | BinaryTree.SkeletonLeafIndex.ofLeft idxLeft =>
      
      hashFn (getPutativeRoot_with_hash idxLeft leafValue restProof hashFn) siblingBelowRootHash
    | BinaryTree.SkeletonLeafIndex.ofRight idxRight =>
      
      hashFn siblingBelowRootHash (getPutativeRoot_with_hash idxRight leafValue restProof hashFn)

class LawfulPermute (Œ± : Type*) [Permute Œ±] where
  permuteInv : Œ± ‚Üí Œ±
  left_inv : Function.LeftInverse permuteInv Permute.permute
  right_inv : Function.RightInverse permuteInv Permute.permute

def prover (i : Fin n) : OracleProver oSpec
    (StatementRound R n i.castSucc) (OracleStatement R n deg) Unit
    (StatementRound R n i.succ) (OracleStatement R n deg) Unit (pSpec R deg) where
  toProverState := proverState R n deg i
  toProverInput := proverInput R n deg i
  sendMessage := (proverRound R n deg D oSpec i).sendMessage
  receiveChallenge := (proverRound R n deg D oSpec i).receiveChallenge
  toProverOutput := proverOutput R n deg oSpec i

Finset.Ici in Mathlib.Order.Interval.Finset.Defs

abbrev ScalarField := ZMod scalarFieldSize

@[reducible, simp]
def knowledgeSoundness
    (relation : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (verifier : OracleVerifier oSpec Statement OStatement Bool (fun _ : Empty => Unit) pSpec)
    (knowledgeError : ‚Ñù‚â•0) : Prop :=
  verifier.toVerifier.knowledgeSoundness init impl relation acceptRejectOracleRel knowledgeError

protected def cast (pSpec : ProtocolSpec n‚ÇÅ) : ProtocolSpec n‚ÇÇ :=
  ‚ü®pSpec.dir ‚àò (Fin.cast hn.symm), pSpec.¬´Type¬ª ‚àò (Fin.cast hn.symm)‚ü©

SetLike in Mathlib.Data.SetLike.Basic

@[reducible]
def Witness (F : Type) [Semiring F] {k : ‚Ñï} (s : Fin (k + 1) ‚Üí ‚Ñï+) (d : ‚Ñï+) (m : ‚Ñï) :=
  Fin (m + 1) ‚Üí F‚¶É< 2 ^ (‚àë i, (s i).1) * d‚¶Ñ[X]

CommMonoidWithZero in Mathlib.Algebra.GroupWithZero.Defs

def getLowBits (numLowBits : ‚Ñï) (n : ‚Ñï) := n &&& ((1 <<< numLowBits) - 1)

instance {s} : Functor (fun Œ± => FullData Œ± s) where
  map f x := x.map f

def outputRelation :
    Set (((StmtOut R) √ó (‚àÄ i, OStmtOut R deg i)) √ó Unit) :=
  { ‚ü®‚ü®‚ü®newTarget, chal‚ü©, oStmt‚ü©, _‚ü© | (oStmt ()).1.eval chal = newTarget }

Polynomial.mapAlgHom in Mathlib.Algebra.Polynomial.AlgebraMap

Set.Nonempty in Mathlib.Data.Set.Defs

def ofFin {n : AssocNat} (f : Fin (AssocNat.toNat n)) : AssocFin n :=
  ‚ü®AssocNat.ofNat f.val, by admit /- proof elided -/
  ‚ü©

Disjoint in Mathlib.Order.Disjoint

@[reducible, simp] def OStmtOut := fun _ : Fin 1 => OStatement

abs in Mathlib.Algebra.Order.Group.Unbundled.Abs

instance instDCastSigmaSigma {Œ± : Type*} {Œ≤ : Œ± ‚Üí Type*} {Œ≥ : (a : Œ±) ‚Üí Œ≤ a ‚Üí Type*}
    {Œ¥ : (a : Œ±) ‚Üí (b : Œ≤ a) ‚Üí Œ≥ a b ‚Üí Type*}
    [DCast Œ± Œ≤] [DCast‚ÇÇ Œ± Œ≤ Œ≥] [DCast‚ÇÉ Œ± Œ≤ Œ≥ Œ¥] :
    DCast ((a : Œ±) √ó (b : Œ≤ a) √ó Œ≥ a b) (fun a => Œ¥ a.1 a.2.1 a.2.2) where
  dcast hc d := dcast‚ÇÉ (by admit /- proof elided -/
  ) (by admit /- proof elided -/
  ) (by admit /- proof elided -/
  ) d
  dcast_id := by admit /- proof elided -/

@[simp]
def extractorLens (i : Fin n) : Extractor.Lens
    (StatementRound R n i.castSucc √ó (‚àÄ i, OracleStatement R n deg i))
    (StatementRound R n i.succ √ó (‚àÄ i, OracleStatement R n deg i))
    (Simple.StmtIn R √ó (‚àÄ i, Simple.OStmtIn R deg i))
    (Simple.StmtOut R √ó (‚àÄ i, Simple.OStmtOut R deg i))
    Unit Unit Unit Unit where
  stmt := oStmtLens R n deg D i
  wit := Witness.InvLens.trivial

def verifyEqOne (n a' : Q(‚Ñï)) (a : Q(ZMod $n)) (_ : Q(($a' : ZMod $n) = $a)) :
    MetaM Q($a ^ ($n - 1) = 1) := do
  let p : Q(ZMod $n) := q($a ^ ($n - 1))
  let .isNat _ c hc ‚Üê Tactic.ReduceModChar.normIntNumeral n p
    q(CommRing.toRing) q(ZMod.charP $n) | failure
  assumeInstancesCommute
  haveI : $p =Q $a ^ ($n - 1) := ‚ü®‚ü©
  haveI : $c =Q 1 := ‚ü®‚ü©
  return q(ZMod.bla $a (.refl _) $hc)

instance instFieldConcrete {k : ‚Ñï} : Field (ConcreteBTField k) :=
  mkFieldInstance (getBTFResult k).toConcreteBTFieldProps

structure LookaheadSequenceFamily
    (trace : QueryLog (forwardPermutationOracle (CanonicalSpongeState U)))
    (state : CanonicalSpongeState U) (i : pSpec.ChallengeIdx) where
   
  seqFamily : Finset (LookaheadSequence trace state)
   
  maximality : ‚àÄ s ‚àà seqFamily, ‚àÄ s' ‚àà seqFamily,
    ¬¨ (s.inputState ‚äÜ s'.inputState) ‚à® ¬¨ (s'.outputState ‚äÜ s.outputState)
   
  length_le_challengeSize : ‚àÄ s ‚àà seqFamily, s.inputState.length ‚â§ challengeSize i

Nat.boddDiv2 in Mathlib.Data.Nat.Bits

def isInterleaved (IC : InterleavedCode Œ∫ Œπ F) :=
  ‚àÄ V ‚àà IC.MF, ‚àÄ i, V i ‚àà IC.LC

def width (k : ‚Ñï) : ‚Ñï := 2 ^ k

def generateProof {n : ‚Ñï} (i : Fin (2 ^ n)) (cache : Cache Œ± n) :
    List.Vector Œ± n :=
  match n with
  | 0 => List.Vector.nil
  | n + 1 => List.Vector.snoc (generateProof ‚ü®i.val / 2, by admit /- proof elided -/
  ‚ü© (cache.upper))
                              ((cache.leaves).get (findNeighbors i (Fin.last _)))

def rightpadPowerOfTwo (unit : Œ±) (a : Array Œ±) : Array Œ± :=
  a.rightpad (2 ^ (Nat.clog 2 a.size)) unit

@[inline, specialize, simp]
def oracleVerifier : OracleVerifier oSpec Statement OStatement Statement OStatement !p[] :=
  OracleVerifier.id

noncomputable def fold_k
  {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F} {k m : ‚Ñï}
  [‚àÄ j : ‚Ñï, Neg (indexPowT S œÜ j)]
  (f : (indexPowT S œÜ 0) ‚Üí F) (Œ±s : Fin k ‚Üí F) (_hk : k ‚â§ m): indexPowT S œÜ k ‚Üí F :=
  fold_k_core f k Œ±s

Field in Mathlib.Algebra.Field.Defs

@[reducible, inline, specialize, simp]
def ChallengeIdx (vPSpec : VectorSpec n) := {i : Fin n // vPSpec.dir i = .V_to_P}

iSup in Mathlib.Order.SetNotation

def zero : ChurchNat Œ± := fun _ x => x

Empty in Init.Prelude

def append {Œπ‚ÇÅ : Type u} {T‚ÇÅ : Œπ‚ÇÅ ‚Üí Type v} [‚àÄ i, OracleInterface (T‚ÇÅ i)]
    {Œπ‚ÇÇ : Type u} {T‚ÇÇ : Œπ‚ÇÇ ‚Üí Type v} [‚àÄ i, OracleInterface (T‚ÇÇ i)] : OracleSpec (Œπ‚ÇÅ ‚äï Œπ‚ÇÇ) :=
  [Sum.rec T‚ÇÅ T‚ÇÇ]‚Çí

def finToBinaryCoeffs (i : Fin r) (idx : Fin (2 ^ (‚Ñì + R_rate - i.val))) :
  Fin (‚Ñì + R_rate - i.val) ‚Üí ùîΩq := fun j =>
    if (Nat.getBit (k:=j) (n:=idx)) = 1 then (1 : ùîΩq) else (0 : ùîΩq)

class PrimeOrder (G : Type*) [Group G] where
  p : ‚Ñï
  [hPrime : Fact (Nat.Prime p)]
  hCard : Nat.card G = p

Finset.Iio in Mathlib.Order.Interval.Finset.Defs

abbrev BaseField := ZMod BASE_FIELD_CARD

private def sum_choose_K_i (B : Finset (Fin n ‚Üí F)) (i : Fin n) : ‚Ñö :=
  ‚àë (Œ± : F), choose_2 (K B i Œ±)

Multiset.filter in Mathlib.Data.Multiset.Filter

instance [Zero T] [ToNat T] : Sub (Cayley T) where
  sub := sub

@[simp]
abbrev OracleStatement.AfterLinearCombination : R1CS.MatrixIdx ‚äï R1CS.MatrixIdx ‚äï Fin 1 ‚Üí Type :=
  Sum.elim (EvalClaim R) (OracleStatement.AfterFirstSumcheck R pp)

def finalSumcheckRelOut :
    Set ((FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì) √ó
      (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì) j)) √ó
      (Unit)) :=
  { input | finalSumcheckRelOutProp ùîΩq Œ≤ (input := input) }

def relation : Set (M √ó M √ó List (MemoryOp Œπ Œ±)) :=
  { ‚ü®startMem, finalMem, ops‚ü© | processMemoryOps ops startMem = some finalMem }

def commitKState (i : Fin ‚Ñì) (hCR : isCommitmentRound ‚Ñì œë i) :
    (commitOracleVerifier ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      i hCR).KnowledgeStateFunction init impl
      (relIn := foldStepRelOut (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i.succ)
      (extractor := commitRbrExtractor ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) where
  toFun := fun m ‚ü®stmtIn, oStmtIn‚ü© tr witMid =>
    commitKStateProp ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (i := i) (m := m) (stmtIn := stmtIn) (witMid := witMid) (oStmtIn := oStmtIn) (mp:=mp)
  toFun_empty := fun stmtIn witMid => by admit /- proof elided -/

Monad in Init.Prelude

abbrev ùïÉ (H : F[X][Y]) : Type :=
  (Polynomial (RatFunc F)) ‚ß∏ (Ideal.span {H_tilde H})

def Adversary (Œπ : Type) (G : Type) (p : ‚Ñï) (bitLength : ‚Ñï) (Œ± : Type) : Type _ :=
  ReaderT (GroupValTable Œπ G)
    (OracleComp (GroupOpOracle Œπ ++‚Çí GroupExpOracle Œπ p ++‚Çí
      GroupEqOracle Œπ ++‚Çí GroupEncodeOracle Œπ bitLength))
    (List Œπ √ó Œ±)

noncomputable def toRatFuncPoly (p : F[Z][X][Y]) : (RatFunc F)[X][Y] :=
  p.map (Polynomial.mapRingHom (algebraMap F[X] (RatFunc F)))

BitVec.cast in Init.Data.BitVec.Basic

evalDist in VCVio.EvalDist.Basic

def finBitVecEquiv {n : ‚Ñï} : Fin (2 ^ n) ‚âÉ BitVec n where
  toFun := fun i => BitVec.ofFin i
  invFun := fun u => u.toFin
  left_inv _ := rfl
  right_inv _ := rfl

AdjoinRoot.of in Mathlib.RingTheory.AdjoinRoot

def verifyNeOne (n a' q : Q(‚Ñï)) (a : Q(ZMod $n)) (_ : Q(($a' : ZMod $n) = $a)) :
    MetaM Q($a ^ (($n - 1) / $q) ‚â† 1) := do
  
  let p : Q(ZMod $n) := q($a ^ (($n - 1) / $q))
  let .isNat _ c hc ‚Üê Tactic.ReduceModChar.normIntNumeral n p
    q(CommRing.toRing) q(ZMod.charP $n) | failure
  
  
  
  assumeInstancesCommute
  have hn : Q(decide ($n ‚â• 2) = true) := (q(Eq.refl true) : Expr)
  have hc‚ÇÅ : Q(decide ($c < $n) = true) := (q(Eq.refl true) : Expr)
  have hc‚ÇÇ : Q(decide ($c ‚â† 1) = true) := (q(Eq.refl true) : Expr)
  return q(ZMod.blub $a $hn $hc‚ÇÅ $hc‚ÇÇ $hc)

run in VCVio.CryptoFoundations.SecExp

def MLE (evals : (œÉ ‚Üí Fin 2) ‚Üí R) : MvPolynomial œÉ R :=
    ‚àë x : œÉ ‚Üí Fin 2, (eqPolynomial (x : œÉ ‚Üí R)) * C (evals x)

protected def cast (T : FullTranscript pSpec‚ÇÅ) :
    FullTranscript pSpec‚ÇÇ :=
  Transcript.cast (k := Fin.last n‚ÇÅ) (l := Fin.last n‚ÇÇ) hn hn hSpec T

def zeta_apply_mobius_apply_eq_id (n : ‚Ñï) (r : Fin n) (l : Fin (r.val + 1)) (v : Vector R (2 ^ n)) :
  monoToLagrange_segment n r l (lagrangeToMono_segment n r l v) = v :=

instance : OracleInterfaces (vPSpec.toProtocolSpec A) where
  oracleInterfaces := fun _ => some OracleInterface.instVector

@[reducible]
def Witness := Fin sz.n_w ‚Üí R

class IsSecure
    (relation : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (Œµ_rbr : vPSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0)
    (vectorIOP : VectorIOP Statement OStatement Witness vPSpec A) where

   
  is_complete : vectorIOP.perfectCompleteness (pure ()) ‚ü®isEmptyElim‚ü© relation

   
  is_rbr_knowledge_sound :
    OracleProof.rbrKnowledgeSoundness (pure ()) ‚ü®isEmptyElim‚ü© relation vectorIOP.verifier Œµ_rbr

MonomialOrder.lex in Mathlib.Data.Finsupp.MonomialOrder

instance [Zero T] [One T] [ToNat T] : HomogeneousPow (Cayley T) where
  pow := pow

def forwardPermutationOracleImpl {Œ± : Type*} [Permute Œ±] :
    QueryImpl (forwardPermutationOracle Œ±) Id where
  impl | query () q => Permute.permute (Œ± := Œ±) q

def Oracle.containsCache {Œπ : Type} {spec : OracleSpec Œπ}
    (f : spec.FunctionType) (cache : spec.QueryCache) :
    Prop :=
  ‚àÄ i q r, cache i q = some r ‚Üí f i q = r

@[app_unexpander Slice.slice]
def sliceUnexpander : Lean.PrettyPrinter.Unexpander
  | `($_ $v $start $stop $_) => `($v‚ü¶$start : $stop‚üß)
  | _ => throw ()

@[reducible]
def messageLength (vPSpec : VectorSpec n) (i : MessageIdx vPSpec) : Nat := vPSpec.length i

noncomputable def polyFold
  [DecidableEq F] (fPoly : Polynomial F)
  (k : ‚Ñï) (hk0 : 0 < k) (hkfin : k < Fintype.card F)
  (r : F) : Polynomial F :=
    let qPoly : Polynomial F := Polynomial.X ^ k
    let hdeg_q_min : qPoly.natDegree > 0 := sorry
    let hdeg_q_max : qPoly.natDegree < Fintype.card F := sorry
  
    let Q : MvPolynomial (Fin 2) F := polyQ fPoly qPoly
    MvPolynomial.eval‚ÇÇHom
      (Polynomial.C : F ‚Üí+* Polynomial F)
      (fun i : Fin 2 => if i = 0 then Polynomial.X else Polynomial.C r) Q

@[inline]
def ofInputOnly
    (stmtProj : OuterStmtIn ‚Üí InnerStmtIn)
    (witProj : OuterStmtIn √ó OuterWitIn ‚Üí InnerWitIn) :
    Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn OuterStmtOut
                OuterWitIn OuterWitOut InnerWitIn OuterWitOut where
  stmt := Statement.Lens.ofInputOnly stmtProj
  wit := Witness.Lens.ofInputOnly witProj

class Serde (Œ± : Type u) (Œ≤ : Type v) extends Serialize Œ± Œ≤, DeserializeOption Œ± Œ≤

def outputRelation (cond : ‚àë i, (s i).1 ‚â§ n) [DecidableEq F] (Œ¥ : ‚Ñù‚â•0) :
    Set
      (
        (Statement F i.succ √ó (‚àÄ j, OracleStatement D x s i.succ j)) √ó
        Witness F s d i.succ.castSucc
      ) := sorry

Polynomial.map in Mathlib.Algebra.Polynomial.Eval.Defs

def divSum? {m : ‚Ñï} (n : Fin m ‚Üí ‚Ñï) (k : ‚Ñï) : Option (Fin m) :=
  find (fun i => k < ‚àë j, n (castLE i.isLt j))

@[reducible, simp] def StmtOut := Query OStatement √ó Response OStatement

def powAlgHom :
  MvPolynomial (Fin m) F ‚Üí‚Çê[F] Polynomial F :=
   aeval fun j => Polynomial.X ^ (2 ^ (j : ‚Ñï))

noncomputable def commitOracleReduction (i : Fin ‚Ñì) (hCR : isCommitmentRound ‚Ñì œë i) :
  OracleReduction (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) Context i.succ)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (pSpec := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) where
  prover := commitOracleProver ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i
  verifier := commitOracleVerifier ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hCR

def finalSumcheckKnowledgeError (m : pSpecFinalSumcheckStep (L := L).ChallengeIdx) :
  ‚Ñù‚â•0 :=
  match m with
  | ‚ü®0, h0‚ü© => nomatch h0

noncomputable def queryOracleReduction :
  OracleReduction
    (oSpec := []‚Çí)
    (StmtIn := FinalSumcheckStatementOut (L:=L) (‚Ñì:=‚Ñì))
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (
    Fin.last ‚Ñì))
    (WitIn := Unit)
    (StmtOut := Bool)
    (OStmtOut := fun _ : Empty => Unit)
    (WitOut := Unit)
    (pSpec := pSpecQuery ùîΩq Œ≤ Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)) where
  prover := queryOracleProver ùîΩq Œ≤ (œë:=œë) Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
  verifier := queryOracleVerifier ùîΩq Œ≤ (œë:=œë) Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)

def relation (cs : ConstraintSystem ùì° numWires numGates) (‚Ñì : ‚Ñï) (h‚Ñì : ‚Ñì ‚â§ numWires) :
    (publicInputs : Fin ‚Ñì ‚Üí ùì°) ‚Üí (privateWitness : Fin (numWires - ‚Ñì) ‚Üí ùì°) ‚Üí Prop :=
  fun (x : Fin ‚Ñì ‚Üí ùì°) (œâ : Fin (numWires - ‚Ñì) ‚Üí ùì°) =>
    let combined := Fin.append x œâ ‚àò Fin.cast (by admit /- proof elided -/
    )
    cs.accepts combined

Algebra.id in Mathlib.Algebra.Algebra.Defs

def OracleReduction.append (R‚ÇÅ : OracleReduction oSpec Stmt‚ÇÅ OStmt‚ÇÅ Wit‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ Wit‚ÇÇ pSpec‚ÇÅ)
    (R‚ÇÇ : OracleReduction oSpec Stmt‚ÇÇ OStmt‚ÇÇ Wit‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ Wit‚ÇÉ pSpec‚ÇÇ) :
      OracleReduction oSpec Stmt‚ÇÅ OStmt‚ÇÅ Wit‚ÇÅ Stmt‚ÇÉ OStmt‚ÇÉ Wit‚ÇÉ (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ) where
  prover := Prover.append R‚ÇÅ.prover R‚ÇÇ.prover
  verifier := OracleVerifier.append R‚ÇÅ.verifier R‚ÇÇ.verifier

noncomputable def decodeLT : (ReedSolomon.code domain deg) ‚Üí‚Çó[F] (Polynomial.degreeLT F deg) :=
  codRestrict
    (Polynomial.degreeLT F deg)
    decode
    (fun c => decoded_polynomial_lt_deg c)

Module.Basis.reindex in Mathlib.LinearAlgebra.Basis.Defs

USize in Init.Prelude

def univPolyHom {F : Type} [CommRing F] [IsDomain F] : F[X] ‚Üí+* RatFunc F :=
  algebraMap (F[X]) (RatFunc F)

def mul (a b : AssocNat) : AssocNat :=
  mulNat a b.toNat

instance [IsSingleRound pSpec] [h : VCVCompatible (pSpec.Challenge default)] :
    (i : pSpec.ChallengeIdx) ‚Üí VCVCompatible (pSpec.Challenge i) := fun i => by admit /- proof elided -/

def toNum {R : Type _} [Zero R] [DecidableEq R] (a : Array R) : ‚Ñï :=
  (a.map (fun r => if r = 0 then 0 else 1)).reverse.foldl (fun acc elem => (acc * 2) + elem) 0

def regularElms (H : F[X][Y]) : Type :=
  {a : ùïÉ H // ‚àÉ b : ùí™ H, a = embeddingOfùí™IntoùïÉ _ b}

instance {i : Fin ‚Ñì} : ‚àÄ j, SelectableType ((pSpecFoldCommit ùîΩq Œ≤
  (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i).Challenge j) := instSelectableTypeChallengeAppend

Nat.digits in Mathlib.Data.Nat.Digits.Defs

Nat.Prime in Mathlib.Data.Nat.Prime.Defs

def finIdxOfIfTrue [BEq Œ±] [LawfulBEq Œ±] (a : Œ±) (l : List Œ±) (h : a ‚àà l) : Fin l.length :=
  ‚ü®List.idxOf' a l, by admit /- proof elided -/
  ‚ü©

@[reducible, inline, specialize]
def UniPoly (R : Type*) := Array R

HMul in Init.Prelude

def natCast {k : ‚Ñï} (n : ‚Ñï) : ConcreteBTField k := if n % 2 = 0 then zero else one

instance : DecidableEq BTF‚ÇÉ := (inferInstance : DecidableEq (ConcreteBTField 3))

def srSoundnessGame (P : Prover.StateRestoration.Soundness oSpec StmtIn pSpec) :
    OracleComp (oSpec ++‚Çí (srChallengeOracle StmtIn pSpec))
      (pSpec.FullTranscript √ó StmtIn) := do
  let ‚ü®stmtIn, messages‚ü© ‚Üê P
  let transcript ‚Üê messages.deriveTranscriptSR stmtIn
  return ‚ü®transcript, stmtIn‚ü©

MulOneClass in Mathlib.Algebra.Group.Defs

noncomputable def genRSC
  [Nonempty F] (par‚Ñì : Type) [h‚Ñì : Fintype par‚Ñì] (œÜ : Œπ ‚Ü™ F) [Smooth œÜ]
  (m : ‚Ñï) (exp : par‚Ñì ‚Ü™ ‚Ñï) : ProximityGenerator Œπ F :=
    let r := LinearCode.rate (smoothCode œÜ m);
    { C := smoothCode œÜ m,
      par‚Ñì := par‚Ñì,
      h‚Ñì := h‚Ñì,
      rate := r,
      Gen := Finset.image (fun r => (fun j => r ^ (exp j))) (Finset.univ : Finset F),
      Gen_nonempty := by admit /- proof elided -/

structure KnowledgeStateFunctionOneShot
    (langIn : Set StmtIn) (langOut : Set StmtOut)
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    where
  toFun : (m : Fin (n + 1)) ‚Üí StmtIn ‚Üí Transcript m pSpec ‚Üí Prop
   
  toFun_empty : ‚àÄ stmtIn, ¬¨ toFun 0 stmtIn default
   
  toFun_next : ‚àÄ m, pSpec.dir m = .P_to_V ‚Üí
    ‚àÄ stmt tr msg, ¬¨ toFun m.castSucc stmt tr ‚Üí ¬¨ toFun m.succ stmt (tr.concat msg)
   
  toFun_full : ‚àÄ stmt tr, ¬¨ toFun (.last n) stmt tr ‚Üí
    [(¬∑ ‚àà langOut) | do (simulateQ impl (verifier.run stmt tr)).run' (‚Üê init)] = 0

Fin.addCases in Init.Data.Fin.Lemmas

def coreInteractionOracleRbrKnowledgeError (j : (pSpecCoreInteraction ùîΩq Œ≤ (œë := œë)
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).ChallengeIdx) : ‚Ñù‚â•0 :=
    Sum.elim
      (f := fun i => sumcheckFoldKnowledgeError ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)
      (g := fun i => finalSumcheckKnowledgeError (L := L) i)
      (ChallengeIdx.sumEquiv.symm j)

def OracleSpec.proverOracle (StmtIn : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n) :
    OracleSpec pSpec.MessageIdx :=
  fun i => (StmtIn √ó pSpec.Transcript i.val.castSucc, pSpec.Message i)

@[simp]
def finRangeTo {k : ‚Ñï} (i : ‚Ñï) : Finset (Fin k) :=
  (List.take i (List.finRange k)).toFinset

List.Vector.cons in Mathlib.Data.Vector.Defs

@[inline, specialize]
def neg {R : Type*} [Ring R] [BEq R] (p : QuotientUniPoly R) : QuotientUniPoly R :=
  Quotient.lift neg_descending neg_descends p

@[reducible]
def FinalStatement (F : Type) (k : ‚Ñï) : Type := Fin (k + 1) ‚Üí F

def finSuccEquivNth' (i : Fin n) : Fin n ‚âÉ Option (Fin (n - 1)) :=

def BTField.isScalarTower_succ_right (l r : ‚Ñï) (h_le : l ‚â§ r) :=
  instAlgebraTowerNatBTField.toIsScalarTower (i:=l) (j:=r) (k:=r+1)
  (h1:=by admit /- proof elided -/
  ) (h2:=by admit /- proof elided -/
  )

OracleComp.SelectableType in VCVio.OracleComp.Constructions.UniformSelect

Fintype.ofEquiv in Mathlib.Data.Fintype.OfMap

Sum.isRight in Init.Data.Sum.Basic

@[reducible, inline]
instance instPolynomialDegreeLT : OracleInterface (R‚¶É< d‚¶Ñ[X]) where
  Query := R
  Response := R
  answer := fun ‚ü®poly, _‚ü© point => poly.eval point

@[reducible]
def OracleStatement (i : Fin (k + 1)) : Fin (i.val + 1) ‚Üí Type :=
  fun j =>
    evalDomain D x (‚àë j' ‚àà finRangeTo j.1, s j')
      ‚Üí F

instance instDCast‚ÇÅ‚ÇÇ : DCast (Œ≤ a) (Œ≥ a) where
  dcast hb c := dcast‚ÇÇ (Eq.refl a) (by admit /- proof elided -/
  ) c
  dcast_id := by admit /- proof elided -/

def SkeletonLeafIndex.isRoot {s : Skeleton} (idx : SkeletonLeafIndex s) : Bool :=
  match idx with
  | SkeletonLeafIndex.ofLeaf => true
  | SkeletonLeafIndex.ofLeft _ => false
  | SkeletonLeafIndex.ofRight _ => false

propext in Init.Core

instance instOfNat {n : ‚Ñï} : OfNat (CNat n) n := match n with
  | 0 => by admit /- proof elided -/
  | .succ n => by admit /- proof elided -/

Ne in Init.Core

def hammingClose (i : Fin (‚Ñì + 1)) (f : OracleFunction ùîΩq Œ≤
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) : Prop :=
  2 * Code.distFromCode (u := f)
    (C := BBF_Code ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) <
    (BBF_CodeDistance ‚Ñì ùì° i : ‚Ñï‚àû)

MvPolynomial.X in Mathlib.Algebra.MvPolynomial.Basic

class GenMutualCorrParams (P : Params Œπ F) (S : ‚àÄ i : Fin (M + 1), Finset (Œπ i)) where

  Œ¥ : Fin (M + 1) ‚Üí ‚Ñù‚â•0
  dist : (i : Fin (M + 1)) ‚Üí Fin ((P.foldingParam i) + 1) ‚Üí ‚Ñù‚â•0


  œÜ : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), (indexPowT (S i) (P.œÜ i) j) ‚Ü™ F

  inst1 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Fintype (indexPowT (S i) (P.œÜ i) j)
  inst2 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    Nonempty (indexPowT (S i) (P.œÜ i) j)
  inst3 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    DecidableEq (indexPowT (S i) (P.œÜ i) j)
  inst4 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Smooth (œÜ i j)

  par‚Ñì_type : ‚àÄ i : Fin (M + 1), ‚àÄ _ : Fin ((P.foldingParam i) + 1), Type
  inst5 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Fintype (par‚Ñì_type i j)

  exp : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), (par‚Ñì_type i j) ‚Ü™ ‚Ñï



  Gen_Œ± : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    ProximityGenerator (indexPowT (S i) (P.œÜ i) j) F :=
      fun i j => RSGenerator.genRSC (par‚Ñì_type i j) (œÜ i j) (P.varCount i - j) (exp i j)

  inst6 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Fintype (Gen_Œ± i j).par‚Ñì

  BStar : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    (Set ((indexPowT (S i) (P.œÜ i) j) ‚Üí F)) ‚Üí Type ‚Üí ‚Ñù‚â•0
  errStar : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    (Set ((indexPowT (S i) (P.œÜ i) j) ‚Üí F)) ‚Üí Type ‚Üí ‚Ñù ‚Üí ENNReal

  C : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Set ((indexPowT (S i) (P.œÜ i) j) ‚Üí F)
  hcode : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), (C i j) = (Gen_Œ± i j).C

  h : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    hasMutualCorrAgreement (Gen_Œ± i j)
      (BStar i j (C i j) (Gen_Œ± i j).par‚Ñì)
      (errStar i j (C i j) (Gen_Œ± i j).par‚Ñì)

  h‚Ñì_bound : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    Fintype.card (Gen_Œ± i j).par‚Ñì = 2
  h‚Ñì_bound' : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    Fintype.card (par‚Ñì_type i j) = 2

  hŒ¥Le : ‚àÄ i : Fin (M + 1),
    (Œ¥ i) ‚â§ 1 - Finset.univ.sup (fun j => BStar i j (C i j) (Gen_Œ± i j).par‚Ñì)

  hlistDecode : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    listDecodable (C i j) (Œ¥ i) (dist i j)

def distEq (mx my : OracleComp spec Œ±) : Prop :=
  evalDist mx = evalDist my

@[reducible, simp]
def StateFunction
    (langIn : Set (StmtIn √ó ‚àÄ i, OStmtIn i))
    (langOut : Set (StmtOut √ó ‚àÄ i, OStmtOut i))
    (verifier : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec) :=
  verifier.toVerifier.StateFunction init impl langIn langOut

def finalSumcheckKStateProp {m : Fin (1 + 1)} (tr : Transcript m (pSpecFinalSumcheckStep (L := L)))
    (stmt : Statement (L := L) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì))
    (witMid : FinalSumcheckWit (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) m)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì) j) : Prop :=
  match m with
  | ‚ü®0, _‚ü© => 
    masterKStateProp ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (mp := BBF_SumcheckMultiplierParam)
      (stmtIdx := Fin.last ‚Ñì) (oracleIdx := Fin.last ‚Ñì) (h_le := le_refl _)
      (stmt := stmt) (wit := witMid) (oStmt := oStmt) (localChecks := True)
  | ‚ü®1, _‚ü© => 
    let tr_so_far := (pSpecFinalSumcheckStep (L := L)).take 1 (by admit /- proof elided -/
    )
    let i_msg0 : tr_so_far.MessageIdx := ‚ü®‚ü®0, by admit /- proof elided -/
    ‚ü©, rfl‚ü©
    let c : L := (ProtocolSpec.Transcript.equivMessagesChallenges (k := 1)
      (pSpec := pSpecFinalSumcheckStep (L := L)) tr).1 i_msg0

    let stmtOut : FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì) := {
      ctx := stmt.ctx,
      sumcheck_target := stmt.sumcheck_target,
      challenges := stmt.challenges,
      final_constant := c
    }

    let sumcheckFinalCheck : Prop := stmt.sumcheck_target = eqTilde r stmt.challenges * c
    let finalFoldingProp := finalNonDoomedFoldingProp ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (h_le := by admit /- proof elided -/
        ) (input := ‚ü®stmtOut, oStmt‚ü©)

    sumcheckFinalCheck ‚àß finalFoldingProp 

def fconcat {A : Sort u} {F : A ‚Üí Sort v} {n : ‚Ñï} {Œ± : Fin n ‚Üí A} {Œ≤ : A}
    (u : (i : Fin n) ‚Üí F (Œ± i)) (a : F Œ≤) : (i : Fin (n + 1)) ‚Üí F (Fin.vconcat Œ± Œ≤ i) :=
  match n with
  | 0 => fun i => match i with | 0 => a
  | _ + 1 => fcons (u 0) (fconcat (fun i => u (Fin.succ i)) a)

@[inline, reducible]
protected def id :
    Context.Lens OuterStmtIn OuterStmtOut OuterStmtIn OuterStmtOut
                OuterWitIn OuterWitOut OuterWitIn OuterWitOut where
  stmt := Statement.Lens.id
  wit := Witness.Lens.id

alias trivial := Context.Lens.id

def existPriorSameQuery (log : QueryLog spec) (idx : Fin log.length) : Prop :=
  ‚àÉ j' < idx, log[j'] = log[idx]

def lagrangeToMonoSpec (p : MlPolyEval R n) : MlPolyEval R n :=
  
  Vector.ofFn (fun i =>
    
    Finset.sum Finset.univ (fun j =>
      
      if (i.val &&& j.val = j.val) then
        
        
        if (i.val.popCount - j.val.popCount) % 2 = 0 then
          p.get j 
        else
          -p.get j 
      else
        0 
    )
  )

@[inline, specialize]
def prover : Prover oSpec Statement Witness (Statement √ó Witness) Unit (pSpec Witness) where
  PrvState
  | 0 => Statement √ó Witness
  | 1 => Statement √ó Witness
  input := id
  sendMessage | ‚ü®0, _‚ü© => fun ‚ü®stmt, wit‚ü© => pure (wit, ‚ü®stmt, wit‚ü©)
  receiveChallenge | ‚ü®0, h‚ü© => nomatch h
  output := fun ‚ü®stmt, wit‚ü© => pure (‚ü®stmt, wit‚ü©, ())

def widthDiv4 : Nat := params.width / 4

Classical.propDecidable in Init.Classical

def relHammingDistRange (Œπ : Type*) [Fintype Œπ] : Set ‚Ñö‚â•0 :=
  {d : ‚Ñö‚â•0 | ‚àÉ d' : ‚Ñï, d' ‚â§ Fintype.card Œπ ‚àß d = d' / Fintype.card Œπ}

List.max? in Init.Data.List.Basic

Trans in Init.Prelude

def getConst (k : ‚Ñï) (s : Fin (k + 1) ‚Üí ‚Ñï+) : OracleComp [FinalOracleStatement D x s]‚Çí F[X] :=
  OracleComp.lift
    (by admit /- proof elided -/
    )

LT.lt in Init.Prelude

List.Vector.head in Mathlib.Data.Vector.Defs

def Prover.addSalt (P : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec)
    (saltComp : (i : pSpec.MessageIdx) ‚Üí P.PrvState i.1.castSucc ‚Üí OracleComp oSpec (Salt i)) :
  Prover oSpec StmtIn WitIn StmtOut WitOut (pSpec.addSalt Salt) where
  PrvState := P.PrvState
  input := P.input
  sendMessage := fun i st => by admit /- proof elided -/

ZeroMemClass in Mathlib.Algebra.Group.Submonoid.Defs

def distFromCode' (C : Set (n ‚Üí R)) [Fintype C] (u : n ‚Üí R) : ‚Ñï‚àû :=
  Finset.min <| (@Finset.univ C _).image (fun v => hammingDist u v.1)

def RAW_CONSTANTS_24 : Vector KoalaBear.Field 215 := #v[
    487143900,
    1829048205,
    1652578477,
    646002781,
    1044144830,
    53279448,
    1519499836,
    22697702,
    1768655004,
    230479744,
    1484895689,
    705130286,
    1429811285,
    1695785093,
    1417332623,
    1115801016,
    1048199020,
    878062617,
    738518649,
    249004596,
    1601837737,
    24601614,
    245692625,
    364803730,
    1857019234,
    1906668230,
    1916890890,
    835590867,
    557228239,
    352829675,
    515301498,
    973918075,
    954515249,
    1142063750,
    1795549558,
    608869266,
    1850421928,
    2028872854,
    1197543771,
    1027240055,
    1976813168,
    963257461,
    652017844,
    2113212249,
    213459679,
    90747280,
    1540619478,
    324138382,
    1377377119,
    294744504,
    512472871,
    668081958,
    907306515,
    518526882,
    1907091534,
    1152942192,
    1572881424,
    720020214,
    729527057,
    1762035789,
    86171731,
    205890068,
    453077400,
    1201344594,
    986483134,
    125174298,
    2050269685,
    1895332113,
    749706654,
    40566555,
    742540942,
    1735551813,
    162985276,
    1943496073,
    1469312688,
    703013107,
    1979485151,
    1278193166,
    548674995,
    2118718736,
    749596440,
    1476142294,
    1293606474,
    918523452,
    890353212,
    1691895663,
    1932240646,
    1180911992,
    86098300,
    1592168978,
    895077289,
    724819849,
    1697986774,
    1608418116,
    1083269213,
    691256798,
    328586442,
    1572520009,
    1375479591,
    322991001,
    967600467,
    1172861548,
    1973891356,
    1503625929,
    1881993531,
    40601941,
    1155570620,
    571547775,
    1361622243,
    1495024047,
    1733254248,
    964808915,
    763558040,
    1887228519,
    994888261,
    718330940,
    213359415,
    603124968,
    1038411577,
    2099454809,
    949846777,
    630926956,
    1168723439,
    222917504,
    1527025973,
    1009157017,
    2029957881,
    805977836,
    1347511739,
    540019059,
    589807745,
    440771316,
    1530063406,
    761076336,
    87974206,
    1412686751,
    1230318064,
    514464425,
    1469011754,
    1770970737,
    1510972858,
    965357206,
    209398053,
    778802532,
    40567006,
    1984217577,
    1545851069,
    879801839,
    1611910970,
    1215591048,
    330802499,
    1051639108,
    321036,
    511927202,
    591603098,
    1775897642,
    115598532,
    278200718,
    233743176,
    525096211,
    1335507608,
    830017835,
    1380629279,
    560028578,
    598425701,
    302162385,
    567434115,
    1859222575,
    958294793,
    1582225556,
    1781487858,
    1570246000,
    1067748446,
    526608119,
    1666453343,
    1786918381,
    348203640,
    1860035017,
    1489902626,
    1904576699,
    860033965,
    1954077639,
    1685771567,
    971513929,
    1877873770,
    137113380,
    520695829,
    806829080,
    1408699405,
    1613277964,
    793223662,
    648443918,
    893435011,
    403879071,
    1363789863,
    1662900517,
    2043370,
    2109755796,
    931751726,
    2091644718,
    606977583,
    185050397,
    946157136,
    1350065230,
    1625860064,
    122045240,
    880989921,
    145137438,
    1059782436,
    1477755661,
    335465138,
    1640704282,
    1757946479,
    1551204074,
    681266718,
]

Vector.zipWith in Init.Data.Vector.Basic

def ofMvPolynomialDeg1 (p : R‚¶É‚â§ 1‚¶Ñ[X Fin n]) : MlPoly R n :=
  Vector.ofFn (fun i : Fin (2 ^ n) => p.val.coeff (monomialOfNat i))

@[inline, specialize]
def add {R : Type*} [Ring R] [BEq R] [LawfulBEq R] (p q : QuotientUniPoly R) : QuotientUniPoly R :=
  Quotient.lift‚ÇÇ add_descending add_descends p q

instance : ‚àÄ i, VCVCompatible ((pSpec Witness).Challenge i) | ‚ü®0, h‚ü© => nomatch h

Polynomial.comp in Mathlib.Algebra.Polynomial.Eval.Defs

Finset.filter in Mathlib.Data.Finset.Filter

@[reducible, simp] def WitOut := Unit

Fin.elim0 in Init.Data.Fin.Basic

@[inline] def pow [Zero T] [One T] [ToNat T] (a b : Cayley T) : Cayley T :=
  powNat a ‚Üëb

def distCodewords [DecidableEq F] (U V : Matrix Œ∫ Œπ F) : ‚Ñï :=
  (Matrix.neqCols U V).card

def proverOutput (i : Fin n) : ProverOutput oSpec
    ((StatementRound R n i.succ √ó (‚àÄ i, OracleStatement R n deg i)) √ó Unit)
    ((proverState R n deg i).PrvState (Fin.last 2)) where
  output := fun x => pure (x, ())

inductive MemoryOp (Œπ : Type u) (Œ± : Œπ ‚Üí Type v) where
  | read (op : MemoryRead Œπ Œ±)
  | write (op : MemoryWrite Œπ Œ±)

finFunctionFinEquiv in Mathlib.Algebra.BigOperators.Fin

Finset.univ in Mathlib.Data.Fintype.Defs

@[reducible]
def baseFieldSize : Nat :=
  21888242871839275222246405745257275088696311157297823662689037894645226208583

def toMessagesChallenges (transcript : Transcript k pSpec) :
    MessagesUpTo k pSpec √ó ChallengesUpTo k pSpec :=
  (transcript.toMessagesUpTo, transcript.toChallengesUpTo)

@[simp]
def Z (k : ‚Ñï) : BTField k := (BinaryTowerAux k).snd.specialElement 

def masterKStateProp (stmtIdx : Fin (‚Ñì + 1))
    (oracleIdx : Fin (‚Ñì + 1))
    (h_le : oracleIdx.val ‚â§ stmtIdx.val) (stmt : Statement (L := L) Context stmtIdx)
    (wit : Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) stmtIdx)
    (oStmt : ‚àÄ j, (OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (i := oracleIdx) j))
    (localChecks : Prop := True) : Prop :=
  let oracleWitnessConsistency: Prop := oracleWitnessConsistency (mp := mp) (ùìë := ùìë) ùîΩq Œ≤
    stmtIdx oracleIdx h_le stmt wit oStmt
  let badEventExists := badEventExistsProp (œë := œë) ùîΩq Œ≤ oracleIdx
    (challenges := Fin.take (m := oracleIdx) (v := stmt.challenges) (h := by admit /- proof elided -/
    ))
    (oStmt := oStmt)
  localChecks ‚àß (badEventExists ‚à® oracleWitnessConsistency)

@[simp]
abbrev Witness.AfterLinearCombination : Type := Unit

instance : IsCyclic G :=
  isCyclic_of_prime_card PrimeOrder.hCard

MonadLift.monadLift in Init.Prelude

@[reducible, simp]
def toRelOut : Set ((Statement √ó Witness) √ó Unit) :=
  Prod.fst ‚Åª¬π' relIn

@[inline, reducible]
def toContext :
    Context.Lens (OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i)) (OuterStmtOut √ó (‚àÄ i, OuterOStmtOut i))
                (InnerStmtIn √ó (‚àÄ i, InnerOStmtIn i)) (InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i))
                OuterWitIn OuterWitOut InnerWitIn InnerWitOut :=
  ‚ü®lens.stmt, lens.wit‚ü©

def FullData.getRootValue {s} {Œ± : Type} (tree : FullData Œ± s) :=
  tree.get (getRootIndex s)

def mul (m n : ChurchNat Œ±) : ChurchNat Œ± := fun f => n (m f)

def Transcript.removeSalt {k : Fin (n + 1)} (transcript : (pSpec.addSalt Salt).Transcript k) :
    pSpec.Transcript k :=

  fun i => by admit /- proof elided -/

instance instOne {n : ‚Ñï} : One (CNat n) := match n with
  | 0 => by admit /- proof elided -/
  | .succ n => by admit /- proof elided -/

def relayKnowledgeStateFunction (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
    (relayOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        i hNCR).KnowledgeStateFunction init impl
      (relIn := foldStepRelOut (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i.succ)
      (extractor := relayRbrExtractor ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) where
  toFun := fun m ‚ü®stmtIn, oStmtIn‚ü© tr witMid =>
    relayKStateProp (mp:=mp) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (ùìë := ùìë) i hNCR stmtIn witMid oStmtIn
  toFun_empty := fun ‚ü®stmtIn, oStmtIn‚ü© witIn => by admit /- proof elided -/

Finset.Iic in Mathlib.Order.Interval.Finset.Defs

@[reducible]
def empty : ProtocolSpec 0 := ‚ü®!v[], !v[]‚ü©

noncomputable def foldNth (n : ‚Ñï) (f : ùîΩ[X]) (Œ± : ùîΩ) [inst : NeZero n] : ùîΩ[X] :=
  ‚àë i : Fin n, Polynomial.C Œ± ^ i.1 * splitNth f n i

structure DomainSeparatorMismatch where
  message : String
deriving Inhabited, DecidableEq, Repr

inductive Expr where
  | lit (a : Lit F)
  | var (name : String)
  | sOp (op : ScalarOp) (a : Lit F) (b : Lit F)
  | svOp (op : ScalarVectorOp) (a : Lit F) (v : Lit F)
  | vOp (op : VectorOp) (v1 : Lit F) (v2 : Lit F)

def divide_by_2 (s : Finset ‚Ñï) : Finset ‚Ñï :=
  (erase_odd s).image (fun n => n / 2)

def findIdxRev?_maximal {cond} {as : Array Œ±} {k : Fin as.size} :
  findIdxRev? cond as = some k ‚Üí ‚àÄ j : Fin as.size, j > k ‚Üí ¬¨ cond as[j] :=

instance {n : ‚Ñï} : OfNat (Cayley T) n where
  ofNat := ofNat n

@[reducible, simp] def OStmtIn : Unit ‚Üí Type := fun _ => R‚¶É‚â§ deg‚¶Ñ[X]

@[reducible]
def index (op : MemoryWrite Œπ Œ±) := op.1

  partial def computePrattCertificate (n : ‚Ñï) : Option (UnverifiedPrattCertificate n) :=
    
    if n ‚â§ 50 ‚àß deterministicMillerRabin n then
      some (.knownPrime n)
    else do
      let fs ‚Üê factor' (n - 1)
      let a ‚Üê findWitness n fs
      let part ‚Üê computePrattPart fs
      return .of n a part
  where
    findWitness (n : ‚Ñï) (fs : List PrimeWithMultiplicity) : Option ‚Ñï := do
      for a in [2:n] do
        let mut ok := true
        for ‚ü®p, _‚ü© in fs do
          if powMod a ((n - 1) / p) n = 1 then
            ok := false
            break

        if ok then
          return a

      none

instance : Sub AssocNat where
  sub := sub

def neg_descending (p : UniPoly R) : QuotientUniPoly R :=
  Quotient.mk _ (neg p)

def oracleVerifier (i : Fin n) : OracleVerifier oSpec
    (StatementRound R n i.castSucc) (OracleStatement R n deg)
    (StatementRound R n i.succ) (OracleStatement R n deg) (pSpec R deg) where
  
  
  
  
  verify := fun ‚ü®target, challenges‚ü© chal => do
    let evals : List R ‚Üê (List.finRange m).mapM
      (fun i => do
        return ‚Üê query
          (spec := (oSpec ++‚Çí ([OracleStatement R n deg]‚Çí ++‚Çí [(pSpec R deg).Message]‚Çí)))
            (Sum.inr <| Sum.inr default) (D i))
    guard (evals.sum = target)
    let newTarget ‚Üê query
      (spec := (oSpec ++‚Çí ([OracleStatement R n deg]‚Çí ++‚Çí [(pSpec R deg).Message]‚Çí)))
        (Sum.inr <| Sum.inr default) (by admit /- proof elided -/
        )
    letI newTarget : R := by admit /- proof elided -/

instance : Field ScalarField := ZMod.instField SCALAR_FIELD_CARD

Lean.Expr in Lean.Expr

instance BitVec.instDCast : DCast Nat BitVec where
  dcast h := BitVec.cast h
  dcast_id := by admit /- proof elided -/

noncomputable instance : Algebra K (Left ‚äó[K] Right) := Algebra.TensorProduct.instAlgebra

def mapOStmtOutRelayStep (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j) :
    ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.succ j := fun j => by admit /- proof elided -/

Sum.elim in Init.Data.Sum.Basic

Vector.take in Init.Data.Vector.Basic

def dotProduct [Zero R] [Add R] [Mul R] (a b : Vector R n) : R :=
  a.zipWith (¬∑ * ¬∑) b |>.foldl (¬∑ + ¬∑) 0

def isRead : MemoryOp Œπ Œ± ‚Üí Prop
  | read _ => True
  | _ => False

def pSpecNonLastBlocks := seqCompose fun bIdx ‚Ü¶
  pSpecFullNonLastBlock ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) bIdx

def dfoldrM' {m : Type u ‚Üí Type v} [Monad m]
    (n : ‚Ñï) (Œ± : Fin (n + 1) ‚Üí Type u)
    (f : (i : Fin n) ‚Üí Œ± i.succ ‚Üí m (Œ± i.castSucc)) (init : Œ± (last n)) : m (Œ± 0) :=
  match n with
  | 0 => pure init
  | n + 1 => do
    let x ‚Üê dfoldrM' n (Œ± ‚àò succ) (fun i => f i.succ) init
    f 0 x

noncomputable def normalizedW (i : Fin r) : L[X] :=
  C (1 / (W ùîΩq Œ≤ i).eval (Œ≤ i)) * W ùîΩq Œ≤ i

@[reducible]
def GroupEqOracle : OracleSpec Unit := fun _ => (Œπ √ó Œπ, Bool)

noncomputable def batchProver :
  OracleProver []‚Çí
    Unit (OracleStatement D x m) (Witness F s d m)
    ((Fin m ‚Üí F) √ó Fri.Spec.Statement F (0 : Fin (k + 1)))
      (OracleStatement D x m) (Fri.Spec.Witness F s d (0 : Fin (k + 2)))
    (batchSpec F m) where
  PrvState
  | 0 => (‚àÄj, OracleStatement D x m j) √ó Witness F s d m
  | 1 => (Fin m ‚Üí F) √ó (‚àÄj, OracleStatement D x m j) √ó Fri.Spec.Witness F s d (0 : Fin (k + 2))

  input := fun i => ‚ü®i.1.2, i.2‚ü©

  sendMessage
  | ‚ü®0, h‚ü© => nomatch h

  receiveChallenge
  | ‚ü®0, _‚ü© => fun ‚ü®os, ps‚ü© => pure <|
    fun (cs : Fin m ‚Üí F) =>
      ‚ü®cs, os,
        ‚ü®
          ps 0 + ‚àë i, Polynomial.C (cs i) * (ps i.succ).1,
          by admit /- proof elided -/
        ‚ü©
      ‚ü©

  output := fun ‚ü®cs, os, p‚ü© => pure <|
    ‚ü®‚ü®‚ü®cs, Fin.elim0‚ü©, os‚ü©, p‚ü©

AffineSubspace in Mathlib.LinearAlgebra.AffineSpace.AffineSubspace.Defs

@[inline, reducible]
def FullTranscript.mk2 {pSpec : ProtocolSpec 2} (msg0 : pSpec.¬´Type¬ª 0) (msg1 : pSpec.¬´Type¬ª 1) :
    FullTranscript pSpec := fun | ‚ü®0, _‚ü© => msg0 | ‚ü®1, _‚ü© => msg1

instance : HListRepr (HList []) where
  repr := fun _ => ""

noncomputable def proximity_gap_degree_bound (k m : ‚Ñï) : ‚Ñï :=
  let rho := (k + 1 : ‚Ñö) / n
  Nat.floor ((((m : ‚Ñö) + (1 : ‚Ñö)/2)*(Real.sqrt rho))*n)

Nat.cast in Init.Data.Cast

@[inline]
def ofInputOnly (projStmt : OuterStmtIn ‚Üí InnerStmtIn) :
    Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn OuterStmtOut :=
  ‚ü®projStmt, fun _ => id‚ü©

Mathlib.Meta.NormNum.IsNat in Mathlib.Tactic.NormNum.Result

def lagrangeBasis (w : Vector R n) : Vector R (2 ^ n) :=
  Vector.ofFn (fun i => ‚àè j : Fin n, if (BitVec.ofFin i).getLsb j then w[j] else 1 - w[j])

def verifyProof {Œ±} [DecidableEq Œ±] {s}
    (idx : BinaryTree.SkeletonLeafIndex s) (leafValue : Œ±) (rootValue : Œ±)
    (proof : List Œ±) : OracleComp (spec Œ±) Unit := do
  let putative_root ‚Üê getPutativeRoot idx leafValue proof
  guard (putative_root = rootValue)

def inv : Prop :=
  
  trace = [] ‚àß state = 0

alias E_inv := inv

@[reducible]
def pSpec : ProtocolSpec (Fin.vsum (fun _ : Fin n => 2)) :=
  ProtocolSpec.seqCompose (fun _ => SingleRound.pSpec R deg)

structure KnowledgeStateFunction
    (relIn : Set (StmtIn √ó WitIn)) (relOut : Set (StmtOut √ó WitOut))
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    {WitMid : Fin (n + 1) ‚Üí Type}
    (extractor : Extractor.RoundByRound oSpec StmtIn WitIn WitOut pSpec WitMid)
    where
   
  toFun : (m : Fin (n + 1)) ‚Üí StmtIn ‚Üí Transcript m pSpec ‚Üí WitMid m ‚Üí Prop
   
  toFun_empty : ‚àÄ stmtIn witMid,
    ‚ü®stmtIn, cast extractor.eqIn witMid‚ü© ‚àà relIn ‚Üî toFun 0 stmtIn default witMid
   
  toFun_next : ‚àÄ m, pSpec.dir m = .P_to_V ‚Üí
    ‚àÄ stmtIn tr msg witMid, toFun m.succ stmtIn (tr.concat msg) witMid ‚Üí
      toFun m.castSucc stmtIn tr (extractor.extractMid m stmtIn (tr.concat msg) witMid)
   
  toFun_full : ‚àÄ stmtIn tr witOut,
    [fun stmtOut => (stmtOut, witOut) ‚àà relOut
    | do (simulateQ impl (verifier.run stmtIn tr)).run' (‚Üê init)] > 0 ‚Üí
    toFun (.last n) stmtIn tr (extractor.extractOut stmtIn tr witOut)

Except in Init.Prelude

Subtype.fintype in Mathlib.Data.Fintype.Sets

inductive Data (Œ± : Type) :
    {n : ‚Ñï} ‚Üí {ar : Fin n ‚Üí ‚Ñï} ‚Üí Skeleton n ar ‚Üí Type where
  | leaf {ar0 : Fin 0 ‚Üí ‚Ñï} (value : Œ±) :
      Data Œ± (Skeleton.leaf (ar0 := ar0))
  | node {n : ‚Ñï} {ar : Fin (n+1) ‚Üí ‚Ñï}
      {children : Fin (ar 0) ‚Üí
        Skeleton n (fun i => ar i.succ)}
      (value : Œ±)
      (childrenData : (i : Fin (ar 0)) ‚Üí
        Data Œ± (children i)) :
      Data Œ± (Skeleton.node children)

Matrix.of in Mathlib.LinearAlgebra.Matrix.Defs

instance : ‚àÄ j, OracleInterface ((pSpecFold (L:=L)).Message j) 
  | ‚ü®0, h‚ü© => by admit /- proof elided -/
  | ‚ü®1, _‚ü© => by admit /- proof elided -/

def modify (state : C) (f : Vector U SpongeSize.N ‚Üí Vector U SpongeSize.N) : C :=
  SpongeState.update state (f (SpongeState.get state))

HSMul.hSMul in Init.Prelude

def oracleWitnessConsistency
    (stmtIdx : Fin (‚Ñì + 1)) (oracleIdx : Fin (‚Ñì + 1))
    (h_le : oracleIdx.val ‚â§ stmtIdx.val) (stmt : Statement (L := L) (Context := Context) stmtIdx)
    (wit : Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) stmtIdx)
    (oStmt : ‚àÄ j, (OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      œë (i := oracleIdx) j)) : Prop :=
  let witnessStructuralInvariant: Prop := witnessStructuralInvariant (mp := mp) (i:=stmtIdx) ùîΩq Œ≤
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) stmt wit
  let sumCheckConsistency: Prop := sumcheckConsistencyProp (ùìë := ùìë) stmt.sumcheck_target wit.H
  let firstOracleConsistency: Prop := firstOracleWitnessConsistencyProp ùîΩq Œ≤
    wit.t (getFirstOracle ùîΩq Œ≤ oStmt)
  let oracleFoldingConsistency: Prop := oracleFoldingConsistencyProp ùîΩq Œ≤ oracleIdx
    (challenges := Fin.take (m := oracleIdx) (v := stmt.challenges) (h := by admit /- proof elided -/
    ))
    (oStmt := oStmt)
  witnessStructuralInvariant ‚àß sumCheckConsistency ‚àß firstOracleConsistency ‚àß
    oracleFoldingConsistency

def findSumIdx' (l : List ‚Ñï) (j : Fin l.sum) : Fin l.length := ‚ü®findSumIdx l j, sorry‚ü©

@[reducible, inline, specialize]
def challengeOracleInterfaceSR (StmtIn : Type) (pSpec : ProtocolSpec n) :
    ‚àÄ i, OracleInterface (pSpec.Challenge i) := fun i =>
  { Query := StmtIn √ó pSpec.MessagesUpTo i.1.castSucc
    Response := pSpec.Challenge i
    answer := fun c _ => c }

alias challengeOracleInterfaceFS := challengeOracleInterfaceSR

instance [inst : VCVCompatible Chal] : ‚àÄ i, VCVCompatible (Challenge ‚ü®!v[.V_to_P], !v[Chal]‚ü© i)
  | ‚ü®0, _‚ü© => inst

def hli_level_diff_0 (l : ‚Ñï) :
  letI instAlgebra:= binaryAlgebraTower (l:=l) (r:=l) (h_le:=by omega)
  @Basis (Fin 1) (BTField l) (BTField l) _ _ instAlgebra.toModule :=

noncomputable def fixFirstVariablesOfMQP (v : Fin (‚Ñì + 1))
  (H : MvPolynomial (Fin ‚Ñì) L) (challenges : Fin v ‚Üí L) : MvPolynomial (Fin (‚Ñì - v)) L :=
  have h_l_eq : ‚Ñì = (‚Ñì - v) + v := by rw [Nat.add_comm]; exact (Nat.add_sub_of_le v.is_le).symm
  -- Step 1 : Rename L[X Fin ‚Ñì] to L[X (Fin (‚Ñì - v) ‚äï Fin v)]
  let finEquiv := finSumFinEquiv (m := ‚Ñì - v) (n := v).symm
  let H_sum : L[X (Fin (‚Ñì - v) ‚äï Fin v)] :=

class VerifierLast (pSpec : ProtocolSpec n) [NeZero n] where
  verifier_last' : pSpec.dir ‚ü®n - 1, by admit /- proof elided -/
  ‚ü© = .V_to_P

Polynomial.ofFinsupp in Mathlib.Algebra.Polynomial.Basic

OracleComp.inductionOn in VCVio.OracleComp.OracleComp

Std.Format in Init.Data.Format.Basic

Fin.castAdd in Init.Data.Fin.Basic

Sum.inr in Init.Core

def one : ChurchNat Œ± := succ zero

instance [ProverFirst pSpec] : ‚àÄ i, VCVCompatible (pSpec.Challenge i) := isEmptyElim

instance [ToString Œ±] (Œ±s : List Type) [HListString (HList Œ±s)] :
    HListString (HList (Œ± :: Œ±s)) where
  toString
  | HList.cons x xs =>
    match xs with
    | HList.nil => toString x
    | HList.cons _ _ => toString x ++ ", " ++ HListString.toString xs

Int.negSucc in Init.Data.Int.Basic

def fcons {A : Sort u} {F : A ‚Üí Sort v} {n : ‚Ñï} {Œ± : A} {Œ≤ : Fin n ‚Üí A}
    (a : F Œ±) (b : (i : Fin n) ‚Üí F (Œ≤ i)) : (i : Fin (n + 1)) ‚Üí F (Fin.vcons Œ± Œ≤ i) :=
  match n with
  | 0 => fun i => match i with | 0 => a
  | _ + 1 => fun i => match i with
    | 0 => a
    | ‚ü®k + 1, hk‚ü© => b ‚ü®k, Nat.succ_lt_succ_iff.mp hk‚ü©

Nat.succ in Init.Prelude

ZMod in Mathlib.Data.ZMod.Defs

def leftpad {m : ‚Ñï} {Œ± : Sort*} (n : ‚Ñï) (a : Œ±) (v : Fin m ‚Üí Œ±) : Fin n ‚Üí Œ± :=
  fun i => if h : n - m ‚â§ i then v ‚ü®i - (n - m), by admit /- proof elided -/
  ‚ü© else a

instance {Œ± : Type} [Sampleable Œ±] : DecidableEq Œ± := inferInstance

@[inline, specialize]
def Prover.processRoundFS [‚àÄ i, VCVCompatible (pSpec.Challenge i)] (j : Fin n)
    (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec)
    (currentResult : OracleComp (oSpec ++‚Çí fsChallengeOracle StmtIn pSpec)
      (pSpec.MessagesUpTo j.castSucc √ó StmtIn √ó prover.PrvState j.castSucc)) :
      OracleComp (oSpec ++‚Çí fsChallengeOracle StmtIn pSpec)
        (pSpec.MessagesUpTo j.succ √ó StmtIn √ó prover.PrvState j.succ) := do
  let ‚ü®messages, stmtIn, state‚ü© ‚Üê currentResult
  match hDir : pSpec.dir j with
  | .V_to_P => do
    let f ‚Üê prover.receiveChallenge ‚ü®j, hDir‚ü© state
    let challenge ‚Üê query (spec := fsChallengeOracle StmtIn pSpec) ‚ü®j, hDir‚ü© ‚ü®stmtIn, messages‚ü©
    return ‚ü®messages.extend hDir, stmtIn, f challenge‚ü©
  | .P_to_V => do
    let ‚ü®msg, newState‚ü© ‚Üê prover.sendMessage ‚ü®j, hDir‚ü© state
    return ‚ü®messages.concat hDir msg, stmtIn, newState‚ü©

def SkeletonLeafIndex.depth {s : Skeleton} : SkeletonLeafIndex s ‚Üí Nat
  | SkeletonLeafIndex.ofLeaf => 0
  | SkeletonLeafIndex.ofLeft idxLeft => idxLeft.depth + 1
  | SkeletonLeafIndex.ofRight idxRight => idxRight.depth + 1

@[reducible]
def C : R ‚Üí+* P := algebraMap R P

class Permute (Œ± : Type*) where
  permute : Œ± ‚Üí Œ±

def SkeletonNodeIndex.path {s : Skeleton} (idx : SkeletonNodeIndex s) :
    List (SkeletonNodeIndex s) := sorry

Finset.max in Mathlib.Data.Finset.Max

Finsupp.update in Mathlib.Data.Finsupp.Single

def possibleDistsToCode (w : Œπ ‚Üí F) (C : Set (Œπ ‚Üí F)) (Œ¥f : (Œπ ‚Üí F) ‚Üí (Œπ ‚Üí F) ‚Üí Œ±) : Set Œ± :=
  {d : Œ± | ‚àÉ c ‚àà C, c ‚â† w ‚àß Œ¥f w c = d}

def foldKnowledgeError (i : Fin ‚Ñì) (_ : (pSpecFold (L := L)).ChallengeIdx) : ‚Ñù‚â•0 :=
  let err_SC := (1 : ‚Ñù‚â•0) / (Fintype.card L)
  
  let err_BE := if hi : œë ‚à£ (i.val + 1) then
    
    œë * (Fintype.card ((sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate)
      ‚ü®i.val + 1, by admit /- proof elided -/
        ‚ü©) : ‚Ñù‚â•0) / (Fintype.card L)
  else 0
  err_SC + err_BE

def sumcheckFoldKnowledgeError := fun j : (pSpecSumcheckFold ùîΩq Œ≤ (œë:=œë)
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).ChallengeIdx =>
    if hj: (j.val % NBlockMessages (œë:=œë)) % 2 = 1 then
      foldKnowledgeError ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        ‚ü®j / NBlockMessages (œë:=œë) * œë + ((j % NBlockMessages (œë:=œë)) / 2 + 1), by admit /- proof elided -/
        ‚ü© ‚ü®1, rfl‚ü©
    else 0 

instance : Fact (Nat.Prime scalarFieldSize) := ‚ü®ScalarField_is_prime‚ü©

instance : HasPred Nat where
  pred' := Nat.pred

def whirRelation
    {F : Type} [Field F] [Fintype F] [DecidableEq F]
    {Œπ : Type} [Fintype Œπ] [Nonempty Œπ]
    (varCount : ‚Ñï) (œÜ : Œπ ‚Ü™ F) [Smooth œÜ] (err : ‚Ñù)
    : Set ((Unit √ó ‚àÄ i, (OracleStatement Œπ F i)) √ó Unit) :=
  { ‚ü®‚ü®_, oracle‚ü©, _‚ü© | Œ¥·µ£(oracle (), smoothCode œÜ varCount) ‚â§ err }

@[simp]
def poly (k : ‚Ñï) : Polynomial (BTField k) := definingPoly (s:=(Z k))

GaloisField in Mathlib.FieldTheory.Finite.GaloisField

slice in Mathlib.Tactic.CategoryTheory.Slice

Polynomial.degreeLTEquiv in Mathlib.RingTheory.Polynomial.Basic

Id in Init.Control.Id

def bitExpo (i : ‚Ñï) : (Fin m) ‚Üí‚ÇÄ ‚Ñï :=
  Finsupp.onFinset Finset.univ
    (fun j => if Nat.testBit i j.1 then 1 else 0)
    (by admit /- proof elided -/
    )

def erase_odd (s : Finset ‚Ñï) : Finset ‚Ñï := s.filter Even

noncomputable instance (‚Ñì : Nat) : AddCommGroup (CoeffVecSpace L ‚Ñì) :=

instance (Œ±s : List Type) [HListRepr (HList Œ±s)] : Repr (HList Œ±s) where
  reprPrec
  | v, _ => "[" ++ HListRepr.repr v ++ "]"

noncomputable def funcQuotient (f : Œπ ‚Üí F) (S : Finset F) (Ans Fill : S ‚Üí F) : Œπ ‚Üí F :=
  fun x =>
    if hx : x.val ‚àà S then Fill ‚ü®x.val, hx‚ü© 
    else (f x - (ansPoly S Ans).eval x.val) / (vanishingPoly S).eval x.val

@[simps]
def subtypeSumComplEquiv {Œ± : Type*} {p : Œ± ‚Üí Prop} [DecidablePred p] :
    {a // p a} ‚äï {a // ¬¨ p a} ‚âÉ Œ± where
  toFun := fun x => match x with
    | Sum.inl a => a.1
    | Sum.inr a => a.1
  invFun := fun x =>
    if h : p x then Sum.inl ‚ü®x, h‚ü© else Sum.inr ‚ü®x, h‚ü©
  left_inv := fun x => match x with
    | Sum.inl a => by admit /- proof elided -/
    | Sum.inr a => by admit /- proof elided -/

IsDomain in Mathlib.Algebra.Ring.Defs

AdjoinRoot.instAlgebra in Mathlib.RingTheory.AdjoinRoot

def oracleReduction.linearCombination :
    OracleReduction oSpec
      (Statement.AfterFirstSumcheck R pp) (OracleStatement.AfterFirstSumcheck R pp) (Witness R pp)
      (Statement.AfterLinearCombination R pp) (OracleStatement.AfterLinearCombination R pp) Unit
      ‚ü®!v[.V_to_P], !v[LinearCombinationChallenge R]‚ü© :=
  sorry

instance {k : Fin 1} : Unique (Transcript k (default : ProtocolSpec 0)) where
  default := fun i => ()
  uniq := by admit /- proof elided -/

def ExtractabilityAdversary (oSpec : OracleSpec Œπ) (Data Commitment AuxState : Type)
    [O : OracleInterface Data] :=
  OracleComp oSpec (Commitment √ó O.Query √ó O.Response √ó AuxState)

class SpongeSize where
   
  N : Nat
   
  R : Nat
   
  R_lt_N : R < N := by admit /- proof elided -/

@[reducible]
def FinalOracleStatement : Fin (k + 2) ‚Üí Type :=
  fun j =>
    if j.1 = k + 1
    then (Unit ‚Üí F[X])
    else (evalDomain D x (‚àë j' ‚àà finRangeTo j.1, s j') ‚Üí F)

@[inline, reducible]
def proj : OuterStmtIn ‚Üí InnerStmtIn :=
  lens.toFunA

HAdd in Init.Prelude

def shift_left (s : Finset ‚Ñï) : Finset ‚Ñï :=
  s.filterMap
    (fun n => match n with
      | 0 => .none
      | n + 1 => .some n
      )
    (by admit /- proof elided -/
    )

instance instToNat {n : ‚Ñï} : ToNat (CNat n) := match n with
  | 0 => by admit /- proof elided -/
  | .succ n => @Cayley.instToNatOfZero (CNat n) instHasSucc instZero instToNat

structure ProximityGenerator
  (Œπ : Type) [Fintype Œπ] [Nonempty Œπ]
  (F : Type) [Semiring F] [Fintype F] [DecidableEq F] where
  
  C : LinearCode Œπ F
  
  par‚Ñì : Type
  h‚Ñì : Fintype par‚Ñì
  
  Gen : Finset (par‚Ñì ‚Üí F)
  Gen_nonempty : Nonempty Gen
  
  rate : ‚Ñù
  
  B : (LinearCode Œπ F) ‚Üí Type ‚Üí ‚Ñù
  
  err : (LinearCode Œπ F) ‚Üí Type ‚Üí ‚Ñù ‚Üí ENNReal
   
  proximity:
    ‚àÄ (f : par‚Ñì ‚Üí Œπ ‚Üí F)
      (Œ¥ : ‚Ñù‚â•0) 
      (_hŒ¥ : 0 < Œ¥ ‚àß Œ¥ < 1 - (B C par‚Ñì)) ,
      Pr_{ let r ‚Üê $·µñ Gen }[ (proximityCondition f Œ¥ r C) ] > (err C par‚Ñì Œ¥) ‚Üí
        ‚àÉ S : Finset Œπ,
          S.card ‚â• (1 - Œ¥) * (Fintype.card Œπ) ‚àß
        ‚àÄ i : par‚Ñì, ‚àÉ u ‚àà C, ‚àÄ x ‚àà S, f i x = u x

instance : Neg (UniPoly R) := ‚ü®UniPoly.neg‚ü©

instance : Mul (UniPoly R) := ‚ü®UniPoly.mul‚ü©

Set.range in Mathlib.Data.Set.Operations

@[inline] def add (a b : Cayley T) : Cayley T :=
  ‚ü®a.toFun ‚àò b.toFun, by admit /- proof elided -/
  ‚ü©

Neg in Init.Prelude

def duplexSpongeHybridOracle : OracleSpec pSpec.ChallengeIdx :=
  fun i =>
    ‚ü®StmtIn √ó ((j : pSpec.MessageIdx) ‚Üí (j.1 < i.1) ‚Üí Vector U (pSpec.L‚Çö·µ¢ j)),
    Vector U (pSpec.L·µ•·µ¢ i)‚ü©

alias ¬´ùíü_Œ£¬ª := duplexSpongeHybridOracle

instance : ‚àÄ j, OracleInterface ((pSpecRelay).Message j)
  | ‚ü®x, hj‚ü© => by admit /- proof elided -/

def Function.extendDomain {Œ± Œ≤ : Type*} [DecidableEq Œ±] [Zero Œ≤] {s : Finset Œ±}
    (f : (x : Œ±) ‚Üí (x ‚àà s) ‚Üí Œ≤) : Œ± ‚Üí Œ≤ :=
  fun x ‚Ü¶ if hx : x ‚àà s then f x hx else 0

List.foldr in Init.Data.List.Basic

def relationAfterSendClaim :
    Set (((StmtAfterSendClaim R) √ó (‚àÄ i, OStmtAfterSendClaim R deg i)) √ó Unit) :=
  { ‚ü®‚ü®target, oStmt‚ü©, _‚ü© |
    ‚àë x ‚àà (univ.map D), (oStmt (Sum.inl ())).1.eval x = target
      ‚àß oStmt (Sum.inr ()) = oStmt (Sum.inl ()) }

noncomputable instance changeOfBasisMatrix_invertible
  (‚Ñì : Nat) (h_‚Ñì : ‚Ñì ‚â§ r) :
  Invertible (changeOfBasisMatrix ùîΩq Œ≤ ‚Ñì h_‚Ñì) :=

instance [Inhabited OuterWitOut]
    [instKS : lens.IsKnowledgeSound
                outerRelIn innerRelIn
                outerRelOut innerRelOut
                compatStmt (fun _ _ => True)] :
    lens.stmt.IsSound
      outerRelIn.language outerRelOut.language
      innerRelIn.language innerRelOut.language
      compatStmt where
  proj_sound := fun outerStmtIn hCompat => by admit /- proof elided -/

Function.Injective in Init.Data.Function

instance instTestLensComplete : testLens.IsComplete
      outerRelIn_Test innerRelIn_Test outerRelOut_Test innerRelOut_Test
      (fun ‚ü®‚ü®p, q, _‚ü©, _‚ü© ‚ü®‚ü®f, _‚ü©, _‚ü© => p * q = f) where
  proj_complete := fun ‚ü®p, q, t‚ü© () hRelIn => by admit /- proof elided -/

abbrev Field := ZMod fieldSize

def evalBivar
  (Q : MvPolynomial (Fin 2) F) (a b : F) : F := MvPolynomial.eval (Fin.cases a (fun _ ‚Ü¶ b)) Q

local instance : Inhabited R := ‚ü®0‚ü©

inductive Skeleton :
    (n : ‚Ñï) ‚Üí (ar : Fin n ‚Üí ‚Ñï) ‚Üí Type where
  | leaf {ar0 : Fin 0 ‚Üí ‚Ñï} : Skeleton 0 ar0
  | node {n : ‚Ñï} {ar : Fin (n+1) ‚Üí ‚Ñï}
      (children : Fin (ar 0) ‚Üí
        Skeleton n (fun i => ar i.succ)) :
      Skeleton (n+1) ar

noncomputable def fold_k_set
  {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F} {k m : ‚Ñï}
  [‚àÄ j : ‚Ñï, Neg (indexPowT S œÜ j)]
  (set : Set ((indexPowT S œÜ 0) ‚Üí F)) (Œ±s : Fin k ‚Üí F) (hk : k ‚â§ m): Set (indexPowT S œÜ k ‚Üí F) :=
    { g | ‚àÉ f ‚àà set, g = fold_k f Œ±s hk}

def relation : Set (M √ó List (MemoryRead Œπ Œ±)) :=
  { ‚ü®mem, ops‚ü© | ‚àÄ op ‚àà ops, Memory.read mem op.index = op.value }

def join_via_add_smul {k : ‚Ñï} (h_pos : k > 0) (hi_btf lo_btf : BTField (k - 1)) :
    BTField k :=

instance {k : Fin 1} : Unique (ChallengesUpTo k !p[]) where
  default := fun ‚ü®‚ü®i, h‚ü©, _‚ü© => by admit /- proof elided -/

def capacitySegmentDupPerm : Prop :=
  let ‚ü®baseTrace, _‚ü© := removeRedundantEntryDS trace
  ‚àÉ j : Fin baseTrace.length, ‚àÉ capSeg : Vector U SpongeSize.C,
    (‚àÉ stateIn stateOut, baseTrace[j] = ‚ü®.inr .Fwd, stateIn, stateOut‚ü© ‚àß
      stateOut.capacitySegment = capSeg) ‚àß
      (
        (‚àÉ j' < j, ‚àÉ stmt', baseTrace[j'] = ‚ü®.inl (), stmt', capSeg‚ü©) ‚à®
        (‚àÉ j' < j, ‚àÉ stateIn1 stateOut1, baseTrace[j'] = ‚ü®.inr .Fwd, stateIn1, stateOut1‚ü© ‚àß
          stateOut1.capacitySegment = capSeg) ‚à®
        (‚àÉ j' ‚â§ j, ‚àÉ stateOut2 stateIn2, baseTrace[j'] = ‚ü®.inr .Bwd, stateOut2, stateIn2‚ü© ‚àß
          stateIn2.capacitySegment = capSeg) ‚à®
        (‚àÉ j' ‚â§ j, ‚àÉ stateIn3 stateOut3, baseTrace[j'] = ‚ü®.inr .Fwd, stateIn3, stateOut3‚ü© ‚àß
          stateIn3.capacitySegment = capSeg) ‚à®
        (‚àÉ j' ‚â§ j, ‚àÉ stateOut4 stateIn4, baseTrace[j'] = ‚ü®.inr .Bwd, stateOut4, stateIn4‚ü© ‚àß
          stateOut4.capacitySegment = capSeg)
      )

alias E_p := capacitySegmentDupPerm

def Œ≥ (x‚ÇÄ : F) (R : F[X][X][Y]) (H : F[X][Y]) [œÜ : Fact (Irreducible H)] : PowerSeries (ùïÉ H) :=
  let subst (t : ‚Ñï) : ùïÉ H :=
    match t with
    | 0 => fieldToùïÉ (-x‚ÇÄ)
    | 1 => 1
    | _ => 0
  PowerSeries.subst (PowerSeries.mk subst) (PowerSeries.mk (Œ± x‚ÇÄ R H))

@[reducible]
def coeffs {R : Type*} (p : UniPoly R) : Array R := p

Algebra.algebraMap in Mathlib.Algebra.Algebra.Defs

def dropLastWhile (p : Œ± ‚Üí Bool) (l : List Œ±) : List Œ± :=
  (l.reverse.dropWhile p).reverse

BitVec.append in Init.Data.BitVec.Basic

noncomputable def extractMLP (i : Fin ‚Ñì) (f : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®i, by omega‚ü© ‚Üí L) :
    Option (L‚¶É‚â§ 1‚¶Ñ[X Fin (‚Ñì - i)]) :=

def inputRelation (cond : ‚àë i, (s i).1 ‚â§ n) [DecidableEq F] (Œ¥ : ‚Ñù‚â•0) :
    Set
      (
        (
          Statement F (Fin.last k) √ó
          (‚àÄ j, OracleStatement D x s (Fin.last k) j)
        ) √ó
        Witness F s d (Fin.last k).castSucc
      ) := sorry

instance : Initialize (DuplexSponge U C) (Vector UInt8 32) where
  new iv := {
    state := Initialize.new iv,
    absorbPos := 0,
    squeezePos := Fin.last SpongeSize.R
  }

@[inline, reducible]
protected def id :
    Witness.InvLens OuterStmtIn OuterWitIn OuterWitOut OuterWitIn OuterWitOut :=
  ‚ü®Prod.snd, fun _ => id‚ü©

alias trivial := Witness.InvLens.id

def Extractor.RoundByRound.id :
    Extractor.RoundByRound oSpec Statement Witness Witness !p[] (fun _ => Witness) where
  eqIn := rfl
  extractMid := fun i => Fin.elim0 i
  extractOut := fun _ _ => _root_.id

def MlPolyEval.mk {R : Type*} (n : ‚Ñï) (v : Vector R (2 ^ n)) : MlPolyEval R n := v

instance (k : ‚Ñï) : LT (ConcreteBTField k) where
  lt := fun x y => by admit /- proof elided -/

def totalNumPermQueries : Nat :=
  pSpec.totalNumPermQueriesMessage + pSpec.totalNumPermQueriesChallenge

instance Vector.instFintype {Œ± : Type*} {n : ‚Ñï} [VCVCompatible Œ±] : Fintype (Vector Œ± n) :=
  Fintype.ofEquiv _ (Equiv.rootVectorEquivFin).symm

def queryCodeword (k : ‚Ñï) (s : Fin (k + 1) ‚Üí ‚Ñï+) {i : Fin (k + 1)}
      (w : evalDomain D x (‚àë j' ‚àà (List.take i.1 (List.finRange (k + 1))).toFinset, (s j').1)) :
    OracleComp [FinalOracleStatement D x s]‚Çí F :=
      OracleComp.lift <| by
        simpa using
          OracleSpec.query
            (spec := [FinalOracleStatement D x s]‚Çí)
            ‚ü®i.1, Nat.lt_succ_of_lt i.2‚ü©
            (by admit /- proof elided -/
            )

def relHammingDistToCode [Nonempty Œπ] [DecidableEq F] (w : Œπ ‚Üí F) (C : Set (Œπ ‚Üí F)) : ‚Ñö‚â•0 :=
  if h : (possibleDistsToCode w C relHammingDist).Nonempty
  then distToCode w C relHammingDist finite_possibleRelHammingDistsToCode |>.get (p h)
  else 0
  where p (h : (possibleDistsToCode w C relHammingDist).Nonempty) := by admit /- proof elided -/

def BindingAdversary (oSpec : OracleSpec Œπ) (Data Commitment AuxState : Type)
    [O : OracleInterface Data] :=
  OracleComp oSpec (Commitment √ó O.Query √ó O.Response √ó O.Response √ó AuxState)

instance : Field ScalarField := ZMod.instField scalarFieldSize

Finsupp.linearCombination in Mathlib.LinearAlgebra.Finsupp.LinearCombination

def leq {Œ± : Type} (m n : ChurchNat Œ±) : ChurchBool Œ± :=
  isZero (ChurchNat.sub m n)

Nat.pow in Init.Prelude

def nonLastBlockOracleReduction (bIdx : Fin (‚Ñì / œë - 1)) :=
  let stmt : Fin (œë - 1 + 1) ‚Üí Type :=
    fun i => Statement (L := L) (‚Ñì := ‚Ñì) Context ‚ü®bIdx * œë + i, bIdx_mul_œë_add_i_cast_lt_‚Ñì_succ bIdx i‚ü©
  let oStmt := fun i: Fin (œë - 1 + 1) =>
    OracleStatement ùîΩq Œ≤ œë ‚ü®bIdx * œë + i, bIdx_mul_œë_add_i_cast_lt_‚Ñì_succ bIdx i‚ü©
  let wit := fun i: Fin (œë - 1 + 1) =>
    Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì)
      ‚ü®bIdx * œë + i, bIdx_mul_œë_add_i_cast_lt_‚Ñì_succ bIdx i‚ü©
  let firstFoldRelayRoundsOracleReduction :=
    OracleReduction.seqCompose (oSpec := []‚Çí)
      (Stmt := stmt)
      (OStmt := oStmt)
      (Wit := wit)
      (pSpec := fun i => pSpecFoldRelay (L:=L))
      (R := fun i => by admit /- proof elided -/
      )

  let h1 : ‚ÜëbIdx * œë + (œë - 1) < ‚Ñì := by admit /- proof elided -/

instance domain_neg_inst {i : Fin n} : Neg (evalDomain D i.1) where
  neg := fun x => ‚ü®_, minus_one_in_doms D i.2‚ü© * x

def redundantQuery (log : QueryLog spec) (i : Œπ) (q : spec.domain i) (r : spec.range i) : Prop :=
  (log.getQ i).count (q, r) > 1

instance : ‚àÄ j, OracleInterface ((pSpecFinalSumcheckStep (L := L)).Message j) := fun j =>
  match j with
  | ‚ü®0, _‚ü© => OracleInterface.instDefault

Vector.flatten in Init.Data.Vector.Basic

noncomputable def coeffs_of_close_proximity (œâs : Fin n ‚Ü™ F) (Œ¥ : ‚Ñö) (u‚ÇÄ u‚ÇÅ : Fin n ‚Üí F)
  : Finset F := Set.toFinset { z | ‚àÉ v : ReedSolomon.code œâs (k + 1), Œ¥·µ£(u‚ÇÄ + z ‚Ä¢ u‚ÇÅ, v) ‚â§ Œ¥}

instance : ‚àÄ i, SelectableType ((pSpecSumcheckFold ùîΩq Œ≤ (œë:=œë)
  (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).Challenge i) := instSelectableTypeChallengeAppend

Mathlib.Meta.NormNum.mkOfNat in Mathlib.Tactic.NormNum.Result

@[inline, specialize]
def add_raw (p q : UniPoly R) : UniPoly R :=
  let ‚ü®p', q'‚ü© := Array.matchSize p q 0
  .mk (Array.zipWith (¬∑ + ¬∑) p' q' )

def AlgebraTowerEquiv.toAlgEquivOverLeft (e : AlgebraTowerEquiv A B) (i j : Œπ) (h : i ‚â§ j) :
  letI : Algebra (A i) (A j) :=

def polynomialOfCoeffs (coeffs : Fin deg ‚Üí F) : F[X] :=
  ‚ü®
    Finset.map ‚ü®Fin.val, Fin.val_injective‚ü© {i | coeffs i ‚â† 0},
    fun i ‚Ü¶ if h : i < deg then coeffs ‚ü®i, h‚ü© else 0,
    fun a ‚Ü¶ by admit /- proof elided -/
  ‚ü©

@[reducible, simp] def OStmtOut : Unit ‚Üí Type := fun _ => R‚¶É‚â§ deg‚¶Ñ[X]

  partial def computePrattPart (l : List PrimeWithMultiplicity) : Option UnverifiedPrattPart := do
    if let [‚ü®p, k‚ü©] := l then
      let cert ‚Üê computePrattCertificate p
      return .prime p k cert

    let ‚ü®left, right‚ü© := l.splitAt (l.length / 2)
    let lhs ‚Üê computePrattPart left
    let rhs ‚Üê computePrattPart right
    return .split lhs rhs

instance {s} : LawfulFunctor (fun Œ± => LeafData Œ± s) :=

UInt8 in Init.Prelude

Inv in Init.Prelude

Iff in Init.Core

Coe in Init.Coe

instance {U : Type} {H : Type*} [SpongeUnit U] [DuplexSpongeInterface U H] :
    UnitTranscript (FSVerifierState U H) U where
  publicUnits state input := do
    let newHashState ‚Üê state.hashState.absorb input
    .ok { hashState := newHashState, nargString := state.nargString }
  fillChallengeUnits state count := do
    let (newHashState, output) ‚Üê state.hashState.squeeze count
    .ok ({ hashState := newHashState, nargString := state.nargString }, output)

def finUInt16Equiv : Fin (2 ^ 16) ‚âÉ UInt16 where
  toFun := fun i => UInt16.ofFin i
  invFun := fun u => u.toFin
  left_inv _ := rfl
  right_inv _ := rfl

@[reducible]
def pSpecCommit (i : Fin ‚Ñì) : ProtocolSpec 1 :=
  ‚ü®![Direction.P_to_V],
   ![OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i.val + 1, by admit /- proof elided -/
   ‚ü©]‚ü©

@[inline] def lt [Zero T] [ToNat T] (a b : Cayley T) : Prop :=
  (‚Üëa : Nat) < (‚Üëb : Nat)

@[simp]
abbrev Statement.AfterFirstMessage : Type := Statement R pp

instance instMul {n : ‚Ñï} : Mul (CNat n) := match n with
  | 0 => by admit /- proof elided -/
  | .succ n => by admit /- proof elided -/

@[reducible, inline, specialize]
def Messages' (pSpec : ProtocolSpec n) : Type :=
  ‚àÄ i, (hi : pSpec.dir i = .P_to_V) ‚Üí pSpec.¬´Type¬ª i

Polynomial.eval‚ÇÇ in Mathlib.Algebra.Polynomial.Eval.Defs

instance [Semiring R] : Module R (MlPolyEval R n) where
  smul := smul
  one_smul a := by admit /- proof elided -/

Polynomial.ofFn in Mathlib.Algebra.Polynomial.OfFn

class IsSingleRound (pSpec : ProtocolSpec 2) extends ProverFirst pSpec, VerifierLast pSpec

alias ProverThenVerifier := IsSingleRound

noncomputable instance {v : Œπ ‚Üí F} {s : AffineSubspace F (Œπ ‚Üí F)} [Fintype s] :
    Fintype (v +·µ• s) := Fintype.ofFinite ‚Ü•(v +·µ• s)

structure ConcreteBTFieldProps (k : ‚Ñï) extends (ConcreteBTFDivisionRingProps k) where
  
  mul_comm : ‚àÄ a b : ConcreteBTField k, concrete_mul a b = concrete_mul b a

Prod.fst in Init.Prelude

noncomputable def finalSumcheckOracleReduction :
  OracleReduction
    (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì))
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì))
    (StmtOut := FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì))
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (WitOut := Unit)
    (pSpec := pSpecFinalSumcheckStep (L := L)) where
  prover := finalSumcheckProver ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
  verifier := finalSumcheckVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)

ReaderT in Init.Prelude

def eval (x : Fin numWires ‚Üí ùì°) (g : Gate ùì° numWires) : ùì° :=
  g.qL * x g.a + g.qR * x g.b + g.qO * x g.c + g.qM * (x g.a * x g.b) + g.qC

def firstOracleWitnessConsistencyProp (t : MultilinearPoly L ‚Ñì)
    (f‚ÇÄ : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate 0 ‚Üí L) : Prop :=
  let P‚ÇÄ: L[X]_(2 ^ ‚Ñì) := polynomialFromNovelCoeffsF‚ÇÇ ùîΩq Œ≤ ‚Ñì (by admit /- proof elided -/
  ) (fun œâ => t.val.eval œâ)
  
  2 * hammingDist (fun x => P‚ÇÄ.val.eval x.val) f‚ÇÄ < BBF_CodeDistance ‚Ñì ùì° ‚ü®0, by admit /- proof elided -/
  ‚ü©

@[reducible, inline, specialize]
def MessagesUpTo (k : Fin (n + 1)) (pSpec : ProtocolSpec n) : Type :=
  ‚àÄ i, pSpec.MessageUpTo k i

def Œ±' (x‚ÇÄ : F) (R : F[X][X][Y]) (H_irreducible : Irreducible H) (t : ‚Ñï) : ùïÉ H :=
  Œ± x‚ÇÄ R _ (œÜ := ‚ü®H_irreducible‚ü©) t

def domainEnum (i : Fin (n + 1)) : Fin (2 ^ (n - i)) ‚Ü™ evalDomain D x i :=
  ‚ü®domain D x n i, domain_injective (i := i.1) D x (by admit /- proof elided -/
  )‚ü©

instance {n : ‚Ñï} : ToString (UnverifiedPrattCertificate n) where
  toString := fun c => s!"{repr c}"

IsUnit in Mathlib.Algebra.Group.Units.Defs

inductive member (a : Œ±) : List Œ± ‚Üí Type v where
  | first : member a (a :: is)
  | next : member a is ‚Üí member a (b :: is)
</all_available_defs>

<all_available_lemmas>
Nat.sub_add_cancel in Init.Data.Nat.Basic
Nat.sub_zero in Init.Data.Nat.Basic
BitVec.ofNat_toNat in Init.Data.BitVec.Bootstrap
BitVec.setWidth_eq in Init.Data.BitVec.Lemmas
BitVec.toNat_setWidth in Init.Data.BitVec.Bootstrap
Nat.and_two_pow_sub_one_eq_mod in Init.Data.Nat.Bitwise.Lemmas
Nat.shiftRight_zero in Init.Data.Nat.Bitwise.Basic
Nat.add_sub_self_left in Init.Data.Nat.Basic
Nat.mul_two in Init.Data.Nat.Basic
Nat.pow_succ in Init.Data.Nat.Basic
Nat.succ_eq_add_one in Init.Data.Nat.Basic
Nat.mul_comm in Init.Data.Nat.Basic
Nat.two_pow_pred_mul_two in Init.Data.Nat.Lemmas
id_eq in Init.Prelude
Nat.add_sub_cancel in Init.Data.Nat.Basic
Nat.sub_add_comm in Init.Data.Nat.Lemmas
BitVec.extractLsb'_append_eq_of_le in Init.Data.BitVec.Lemmas
Nat.le_refl in Init.Prelude
congrArg in Init.Prelude
eq_mp_eq_cast in Init.PropLemmas
BitVec.append_eq in Init.Data.BitVec.Basic
BitVec.setWidth_append in Init.Data.BitVec.Lemmas
Nat.add_comm in Init.Data.Nat.Basic
Nat.div_eq_sub_mod_div in Init.Data.Nat.Lemmas
Nat.div_lt_of_lt_mul in Init.Data.Nat.Mod
Nat.div_mul_cancel in Init.Data.Nat.Dvd
Nat.dvd_sub_mod in Init.Data.Nat.Lemmas
Nat.mod_eq_of_lt in Init.Data.Nat.Div.Basic
Nat.pow_add in Init.Data.Nat.Lemmas
Nat.shiftLeft_eq in Init.Data.Nat.Bitwise.Basic
Nat.shiftRight_eq_div_pow in Init.Data.Nat.Bitwise.Basic
Nat.mod_le in Init.Data.Nat.Div.Basic
Nat.mod_lt in Init.Prelude
Nat.shiftLeft_add_eq_or_of_lt in Init.Data.Nat.Bitwise.Lemmas
BitVec.eq_of_toNat_eq in Init.Data.BitVec.Bootstrap
BitVec.isLt in Init.Data.BitVec.BasicAux
BitVec.toNat_append in Init.Data.BitVec.Bootstrap
BitVec.toNat_ofNat in Init.Data.BitVec.Bootstrap
Nat.ofNat_pos in Mathlib.Data.Nat.Cast.Order.Ring
OfNat.ofNat_ne_one in Mathlib.Algebra.CharZero.Defs
ne_eq in Init.SimpLemmas
not_false_eq_true in Init.SimpLemmas
pow_right_inj‚ÇÄ in Mathlib.Algebra.Order.GroupWithZero.Unbundled.Basic
Nat.two_pow_pos in Init.Data.Nat.Basic
Prod.ext_iff in Init.Ext
BitVec.extractLsb_ofNat in Init.Data.BitVec.Lemmas
BitVec.zero_eq in Init.Data.BitVec.Basic
Nat.zero_mod in Init.Data.Nat.Div.Basic
Nat.zero_shiftRight in Init.Data.Nat.Lemmas
Nat.ne_zero_of_lt in Init.Data.Nat.Basic
Nat.one_lt_two_pow_iff in Init.Data.Nat.Lemmas
Nat.shiftRight_eq_zero in Init.Data.Nat.Bitwise.Basic
Nat.one_mod_two_pow_eq_one in Init.Data.Nat.Lemmas
Nat.one_mod_two_pow in Init.Data.Nat.Lemmas
Nat.zero_lt_two in Init.Data.Nat.Basic
pow_pos in Mathlib.Algebra.Order.GroupWithZero.Unbundled.Basic
BitVec.zero_xor in Init.Data.BitVec.Lemmas
BitVec.xor_zero in Init.Data.BitVec.Lemmas
Nat.add_one_sub_one in Init.Data.Nat.Basic
pow_two in Mathlib.Algebra.Group.Defs
BitVec.ofNat_xor in Init.Data.BitVec.Lemmas
BitVec.xor_eq in Init.Data.BitVec.Basic
BitVec.toNat_xor in Init.Data.BitVec.Lemmas
Nat.and_xor_distrib_right in Init.Data.Nat.Bitwise.Lemmas
Nat.shiftRight_xor_distrib in Init.Data.Nat.Bitwise.Lemmas
mul_one in Mathlib.Algebra.Group.Defs
Ne.dite_eq_left_iff in Mathlib.Logic.Basic
Nat.left_eq_add in Init.Data.Nat.Lemmas
RingHom.comp_id in Mathlib.Algebra.Ring.Hom.Defs
cast_eq in Init.Core
one_ne_zero in Mathlib.Algebra.NeZero
BitVec.xor_assoc in Init.Data.BitVec.Lemmas
BitVec.xor_self in Init.Data.BitVec.Lemmas
Polynomial.C_mul' in Mathlib.Algebra.Polynomial.Coeff
Polynomial.aeval_def in Mathlib.Algebra.Polynomial.AlgebraMap
Polynomial.eval‚ÇÇ_X in Mathlib.Algebra.Polynomial.Eval.Defs
Polynomial.eval‚ÇÇ_X_pow in Mathlib.Algebra.Polynomial.Eval.Defs
Polynomial.eval‚ÇÇ_add in Mathlib.Algebra.Polynomial.Eval.Defs
Polynomial.eval‚ÇÇ_one in Mathlib.Algebra.Polynomial.Eval.Defs
Polynomial.eval‚ÇÇ_smul in Mathlib.Algebra.Polynomial.Eval.SMul
mul_comm in Mathlib.Algebra.Group.Defs
MonoidHom.coe_mk in Mathlib.Algebra.Group.Hom.Defs
Nat.sub_one_add_one in Init.Data.Nat.Basic
OneHom.coe_mk in Mathlib.Algebra.Group.Hom.Defs
RingHom.coe_mk in Mathlib.Algebra.Ring.Hom.Defs
cast_cast in Init.PropLemmas
eqRec_eq_cast in Batteries.Logic
Polynomial.aeval_C in Mathlib.Algebra.Polynomial.AlgebraMap
Polynomial.aeval_X in Mathlib.Algebra.Polynomial.AlgebraMap
Polynomial.degree_eq_iff_natDegree_eq in Mathlib.Algebra.Polynomial.Degree.Definitions
Polynomial.degree_ne_bot in Mathlib.Algebra.Polynomial.Degree.Definitions
Polynomial.eq_C_of_natDegree_eq_zero in Mathlib.Algebra.Polynomial.Degree.Operations
Polynomial.eq_X_add_C_of_degree_eq_one in Mathlib.Algebra.Polynomial.Degree.SmallDegree
Polynomial.leadingCoeff_eq_zero in Mathlib.Algebra.Polynomial.Degree.Definitions
Polynomial.natDegree_lt_iff_degree_lt in Mathlib.Algebra.Polynomial.Degree.Definitions
false_or in Init.SimpLemmas
map_add in Mathlib.Algebra.Group.Hom.Defs
map_eq_zero in Mathlib.Algebra.GroupWithZero.Units.Lemmas
map_smul in Mathlib.GroupTheory.GroupAction.Hom
map_zero in Mathlib.Algebra.Group.Hom.Defs
minpoly.unique' in Mathlib.FieldTheory.Minpoly.Basic
ne_zero_of_eq_one in Mathlib.Algebra.NeZero
not_true_eq_false in Init.SimpLemmas
or_false in Init.SimpLemmas

theorem one_le_two_pow_n (n : ‚Ñï) : 1 ‚â§ 2 ^ n

@[simp]
theorem dcast_eq : dcast (Eq.refl a) b = b

theorem one_le_sub_consecutive_two_pow (n : ‚Ñï): 1 ‚â§ 2^(n+1) - 2^n

theorem dcast_eq_root_cast (h : a = a') : dcast h b = _root_.cast (congrArg Œ≤ h) b

theorem dcast_symm (ha : a = a') (hb : dcast ha b = b') : dcast (ha.symm) b' = b

theorem dcast_eq_dcast_iff (h : a = a'') (h' : a' = a'') :
    dcast h b = dcast h' b' ‚Üî b = dcast (h'.trans h.symm) b'

theorem zero_lt_pow_n (m : ‚Ñï) (n : ‚Ñï) (h_m : m > 0): 0 < m^n

theorem is_unit_iff_deg_0 {R : Type*} [Field R] {p : R[X]} : p.degree = 0 ‚Üî IsUnit p

lemma definingPoly_is_monic {F : Type*} [Field F] [Fintype F] (s : F) [NeZero s] :
  (definingPoly s).Monic

lemma degree_s_smul_X_add_1 {F : Type*} [Field F] [Fintype F] (s : F) [NeZero s] :
  (C s * (X : (F)[X]) + 1).degree = 1

lemma degree_s_smul_X {F : Type*} [Field F] [Fintype F] (s : F) [NeZero s] :
  (C s * (X : (F)[X])).degree = 1

lemma degree_definingPoly {F : Type*} [Field F] [Fintype F] (s : F) [NeZero s] :
  (definingPoly s).degree = 2

lemma getBit_eq_pred_getBit_of_div_two {n k : ‚Ñï} (h_k: k > 0) :
    getBit k (n) = getBit (k-1) (n/2)

theorem degreeOf_linear_le {a b : R} : degreeOf n (C a + C b * p) ‚â§ degreeOf n p

theorem dcast_fun {Œ≥ : (a : Œ±) ‚Üí Œ≤ a ‚Üí Sort*} {f : (b : Œ≤ a) ‚Üí Œ≥ a b} :
    f (dcast rfl b) = dcast (Œ± := Œ≤ a) (Œ≤ := Œ≥ a) dcast_eq.symm (f b)

@[simp] theorem toNat_succ (t : AssocNat) : toNat (succ t) = (toNat t).succ

@[simp]
theorem divide_by_2_mem {s : Finset ‚Ñï} {d : ‚Ñï} :
  d ‚àà divide_by_2 s ‚Üî 2 * d ‚àà s

@[simp]
theorem hflatten_splitSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {Œ± : (k : Fin (vsum n)) ‚Üí Sort*}
    (v : (k : Fin (vsum n)) ‚Üí Œ± k) (k : Fin (vsum n)) :
    hflatten (fun i j => v (embedSum i j)) k = cast (vflatten_splitSum Œ± k).symm (v k)

@[simp]
theorem vcons_one (a : Œ±) (v : Fin (n + 1) ‚Üí Œ±) : (a ::·µõ v) 1 = v 0

lemma out_of_dom_smpl_2
  {Œ¥ l : ‚Ñù‚â•0} {s : ‚Ñï} {f : Œπ ‚Üí F} {degree : ‚Ñï} {œÜ : Œπ ‚Ü™ F}
  (C : Set (Œπ ‚Üí F)) (hC : C = code œÜ degree)
  (h_decodable : listDecodable C Œ¥ l)
  (h_nonempty : Nonempty (domainComplement œÜ)) :
  listDecodingCollisionProbability œÜ f Œ¥ s degree h_nonempty ‚â§
    ((l^2 / 2)) * (degree / (Fintype.card F - Fintype.card Œπ))^s

@[grind]
lemma quotient_nezero {f q : F[X][Y]} (hg : q * f ‚â† 0) : q ‚â† 0

theorem SkeletonNodeIndex.rightChild_bind_parent {s : Skeleton}
    (idx : SkeletonNodeIndex s) :
    idx.rightChild >>= parent = idx.rightChild.map (fun _ => idx)

@[simp]
theorem simulateQ'_query (q : OracleQuery spec Œ±) :
    simulateQ' so q (by simp) = so.impl q

theorem prime_23 : Nat.Prime 23

lemma concrete_pow_base_one
  (prevBTFieldProps : ConcreteBTFieldProps (k := k - 1)) (n : ‚Ñï) :
  concrete_pow_nat (k:=k) (x:=1) n = 1

@[simp]
lemma rank_nonsquare_rows_eq_min (inj : Function.Injective Œ±) :
  (Vandermonde.nonsquare (Œπ' := n) Œ±).rank = min m n

@[simp]
theorem verifier_first (pSpec : ProtocolSpec n) [NeZero n] [h : VerifierFirst pSpec] :
    pSpec.dir 0 = .V_to_P

lemma algebra_adjacent_tower_def (l : ‚Ñï) :
  (algebra_adjacent_tower l) = (canonicalEmbedding l).toAlgebra

theorem GF_2_pow_card (x : GF(2)) : x ^ Fintype.card (GF(2)) = x

Finset.sup_lt_iff in Mathlib.Data.Finset.Lattice.Fold

omit O‚Çò in
theorem seqCompose_completeness (hInit : init.neverFails)
    (rel : (i : Fin (m + 1)) ‚Üí Set (Stmt i √ó Wit i))
    (R : ‚àÄ i, Reduction oSpec (Stmt i.castSucc) (Wit i.castSucc) (Stmt i.succ) (Wit i.succ)
      (pSpec i))
    (completenessError : Fin m ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (R i).completeness init impl (rel i.castSucc) (rel i.succ) (completenessError i)) :
      (Reduction.seqCompose Stmt Wit R).completeness init impl (rel 0) (rel (Fin.last m))
        (‚àë i, completenessError i)

@[simp]
protected lemma elocPolyF_eq_elocPoly :
  ElocPolyF (n := n) (liftF' œâs) (liftF' f) = ElocPoly n œâs f

@[simp]
theorem finSuccEquivNth_X_same : finSuccEquivNth R p (X p) = Polynomial.X

lemma evenize_eval {f : Polynomial F} {s : F} :
    (evenize f).eval s = f.eval (s * s)

theorem add_size {p q : UniPoly Q} : (add_raw p q).size = max p.size q.size

@[simp]
lemma solutionToE_zero_eq_C {v : Fin (2 * 0 + k) ‚Üí F} :
  solutionToE 0 k v = C (1 : F)

lemma zero_def [Zero R] : zero = Vector.replicate (2 ^ n) 0

@[simp]
theorem Vector.ofFn_get {Œ± : Type*} {n : ‚Ñï} (v : Vector Œ± n) : Vector.ofFn (Vector.get v) = v

@[simp]
theorem mul_by_2_mem {s : Finset ‚Ñï} {d : ‚Ñï} :
    d ‚àà mul_by_2 s ‚Üî Even d ‚àß (d / 2) ‚àà s

lemma lt_two_pow_of_lt_two_pow_exp_le (x i j: ‚Ñï)
    (h_x_lt_2_pow_i: x < 2^i) (h_i_le_j: i ‚â§ j): x < 2^j

theorem generator_on_curve : let (x, y) := generator
  y^2 = x^3 + 3

@[grind]
lemma coeff_ne_zero {f q : F[X][Y]} (hg : q * f ‚â† 0) : q.coeff ‚â† 0

private lemma almost_johnson_choose_2_elimed [Zero F]
  (h_n : 0 < n)
  (h_B : 2 ‚â§ B.card)
  (h_card : 2 ‚â§ Fintype.card F)
  :
  (k B * (k B - 1)  +
    (B.card - k B) * ((B.card - k B)/(Fintype.card F-1) - 1))
  ‚â§
  B.card * (B.card - 1) * (n - d B)/n

lemma nonsquare_mulVecLin [CommSemiring F] {Œπ' : ‚Ñï} {Œ±‚ÇÅ : Œπ ‚Ü™ F} {Œ±‚ÇÇ : Fin Œπ' ‚Üí F} {i : Œπ} :
  (nonsquare Œπ' Œ±‚ÇÅ).mulVecLin Œ±‚ÇÇ i = ‚àë x, Œ±‚ÇÇ x * Œ±‚ÇÅ i ^ x.1

theorem eq_trans {Œ± : Type u} (mx my mz : m Œ±) (hxy : eq mx my) (hyz : eq my mz) : eq mx mz

@[simp]
lemma numPartialRounds_pos : 0 < params.numPartialRounds

@[simp]
theorem fconcat_zero {Œ± : Fin 0 ‚Üí A} {Œ≤ : A} (a : F Œ≤) : !h‚¶ÉF‚¶Ñ‚ü®Œ±‚ü©[] :+ ∞ a =
  fun i => match i with

@[simp]
lemma finite_possibleRelHammingDists : (possibleRelHammingDists C).Finite

theorem getBit_repr_univ {‚Ñì : Nat} : ‚àÄ j, j < 2^‚Ñì ‚Üí
  j = ‚àë k ‚àà Finset.univ (Œ±:=Fin ‚Ñì), (getBit k j) * 2^k.val

theorem stir_main
  (secpar : ‚Ñï) [SelectableType F]
  {Œπ : Type} [Fintype Œπ] [Nonempty Œπ] [DecidableEq Œπ]
  {œÜ : Œπ ‚Ü™ F} {degree : ‚Ñï} [hsmooth : Smooth œÜ]
  {k proofLen qNumtoInput qNumtoProofstr : ‚Ñï}
  (hk : ‚àÉ p, k = 2 ^ p) (hkGe : k ‚â• 4)
  (Œ¥ : ‚Ñù‚â•0) (hŒ¥ub : Œ¥ < 1 - 1.05 * Real.sqrt (degree / Fintype.card Œπ))
  (hF : Fintype.card F ‚â§
        secpar * 2 ^ secpar * degree ^ 2 * (Fintype.card Œπ) ^ (7 / 2) /
          Real.log (1 / rate (code œÜ degree))) :
  ‚àÉ n : ‚Ñï,
  ‚àÉ vPSpec : ProtocolSpec.VectorSpec n,
  ‚àÉ Œµ_rbr : vPSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0,
  ‚àÉ œÄ : VectorIOP Unit (OracleStatement Œπ F) Unit vPSpec F,
  IsSecureWithGap (stirRelation degree œÜ 0)
                  (stirRelation degree œÜ Œ¥)
                  Œµ_rbr œÄ
  ‚àß ‚àÄ i, Œµ_rbr i ‚â§ (1 : ‚Ñö‚â•0) / (2 ^ secpar)
  ‚àß ‚àÉ c > 0, M ‚â§ c * (Real.log degree / Real.log k)
  ‚àß ‚àÉ c‚Çñ : ‚Ñï ‚Üí ‚Ñù, proofLen ‚â§ (Fintype.card Œπ) + (c‚Çñ k) * (Real.log degree)
  ‚àß qNumtoInput = secpar / (- Real.log (1 - Œ¥))
  ‚àß ‚àÉ c‚Çñ : ‚Ñï ‚Üí ‚Ñù, qNumtoProofstr ‚â§
    (c‚Çñ k) * ((Real.log degree) +
      secpar * (Real.log ((Real.log degree) / Real.log (1/rate (code œÜ degree)))))

lemma fieldSize_sub_one_factorization : fieldSize - 1 = 2 ^ twoAdicity * 127

lemma exists_factors_with_large_common_root_set
  (Œ¥ : ‚Ñö) (x‚ÇÄ : F)
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  :
  ‚àÉ R H, R ‚àà (irreducible_factorization_of_gs_solution h_gs).choose_spec.choose ‚àß
    Irreducible H ‚àß H ‚à£ (Bivariate.evalX (Polynomial.C x‚ÇÄ) R) ‚àß
    #(@Set.toFinset _ { z : coeffs_of_close_proximity (F := F) k œâs Œ¥ u‚ÇÄ u‚ÇÅ |
        letI Pz := Pz z.2
        (Trivariate.eval_on_Z R z.1).eval Pz = 0 ‚àß
        (Bivariate.evalX z.1 H).eval (Pz.eval x‚ÇÄ) = 0} sorry)
    ‚â• #(coeffs_of_close_proximity k œâs Œ¥ u‚ÇÄ u‚ÇÅ) / (Bivariate.natDegreeY Q)
    ‚àß #(coeffs_of_close_proximity k œâs Œ¥ u‚ÇÄ u‚ÇÅ) / (Bivariate.natDegreeY Q) >
      2 * D_Y Q ^ 2 * (D_X ((k + 1 : ‚Ñö) / n) n m) * D_YZ Q

@[simp]
lemma E_and_Q_to_a_solution_coeff
  : E_and_Q_to_a_solution e E Q i = if i < e then E.coeff i else Q.coeff (i - e)

omit [NeZero ‚Ñì] [NeZero r] [NeZero ùì°] in
lemma fin_r_succ_bound {h_‚Ñì_add_R_rate : ‚Ñì + ùì° < r} (i : Fin r) (h_i : i + 1 < ‚Ñì + ùì°)
    : i + 1 < r

lemma add_two_pow_of_getBit_eq_zero_lt_two_pow {n m i : ‚Ñï} (h_n: n < 2^m) (h_i: i < m)
  (h_getBit_at_i_eq_zero: getBit i n = 0) :
  n + 2^i < 2^m

lemma getBit_eq_succ_getBit_of_mul_two {n k : ‚Ñï} : getBit (k+1) (2*n) = getBit k n

@[simp] theorem idxOf'_nil [BEq Œ±] {a : Œ±} : idxOf' a [] = 0

theorem liftContext_completeness
    (h : R.completeness init impl innerRelIn innerRelOut completenessError) :
      (R.liftContext lens).completeness init impl outerRelIn outerRelOut completenessError

@[simp]
lemma wt_constantCode [DecidableEq F] [NeZero x] :
  wt (constantCode x Œπ) = Fintype.card Œπ

theorem fiberwise_dist_lt_imp_dist_lt_unique_decoding_radius (i : Fin ‚Ñì) (steps : ‚Ñï)
    [NeZero steps] (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
    (f : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i, by omega‚ü©)
  (h_fw_dist_lt : fiberwiseClose ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
    (i := i) (steps := steps) (h_i_add_steps := h_i_add_steps) (f := f)) :
  hammingClose ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i, by omega‚ü© f

lemma johnson_condition_strong_iff_johnson_denom_pos {B : Finset (Fin n ‚Üí F)} {v : Fin n ‚Üí F} :
  JohnsonConditionStrong B v ‚Üî 0 < JohnsonDenominator B v

omit [NeZero ‚Ñì] in
lemma fin_‚Ñì_steps_lt_‚Ñì_add_R (i : Fin ‚Ñì) (steps : ‚Ñï) (h : i.val + steps ‚â§ ‚Ñì)
    : i.val + steps < ‚Ñì + ùì°

theorem srSoundness_addSalt_implies_srSoundness_original
    (langIn : Set StmtIn) (langOut : Set StmtOut)
    (Salt : pSpec.MessageIdx ‚Üí Type) [‚àÄ i, Nonempty (Salt i)] [‚àÄ i, Fintype (Salt i)]
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    (srInit : ProbComp (srChallengeOracle StmtIn (pSpec.addSalt Salt)).FunctionType)
    (srImpl : QueryImpl oSpec
      (StateT (srChallengeOracle StmtIn (pSpec.addSalt Salt)).FunctionType ProbComp))
    (srSoundnessError : ‚Ñù‚â•0) :
      Verifier.StateRestoration.soundness srInit srImpl langIn langOut
        (verifier.addSalt Salt) srSoundnessError ‚Üí
        Verifier.StateRestoration.soundness sorry sorry langIn langOut
          verifier srSoundnessError

theorem init_vconcat (v : Fin n ‚Üí Œ±) (a : Œ±) :
    (fun i => vconcat v a (Fin.castSucc i)) = v

theorem fappend‚ÇÇ_ext {Œ±‚ÇÅ : Fin m ‚Üí A} {Œ±‚ÇÇ : Fin m ‚Üí B} {Œ≤‚ÇÅ : Fin n ‚Üí A} {Œ≤‚ÇÇ : Fin n ‚Üí B}
    (u‚ÇÅ u‚ÇÇ : (i : Fin m) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i)) (v‚ÇÅ v‚ÇÇ : (i : Fin n) ‚Üí F‚ÇÇ (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) :
    fappend‚ÇÇ (F := F‚ÇÇ) u‚ÇÅ v‚ÇÅ = fappend‚ÇÇ (F := F‚ÇÇ) u‚ÇÇ v‚ÇÇ ‚Üî u‚ÇÅ = u‚ÇÇ ‚àß v‚ÇÅ = v‚ÇÇ

theorem liftContext_knowledgeSoundness [Inhabited InnerStmtOut] [Inhabited InnerWitIn]
    {outerRelIn : Set (OuterStmtIn √ó OuterWitIn)} {outerRelOut : Set (OuterStmtOut √ó OuterWitOut)}
    {innerRelIn : Set (InnerStmtIn √ó InnerWitIn)} {innerRelOut : Set (InnerStmtOut √ó InnerWitOut)}
    {knowledgeError : ‚Ñù‚â•0}
    {stmtLens : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut}
    {witLens : Witness.InvLens OuterStmtIn OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    (V : Verifier oSpec InnerStmtIn InnerStmtOut pSpec)
    [lensKS : Extractor.Lens.IsKnowledgeSound outerRelIn innerRelIn outerRelOut innerRelOut
      (V.compatStatement stmtLens) (fun _ _ => True) ‚ü®stmtLens, witLens‚ü©]
    (h : V.knowledgeSoundness init impl innerRelIn innerRelOut knowledgeError) :
      (V.liftContext stmtLens).knowledgeSoundness init impl outerRelIn outerRelOut
        knowledgeError

lemma aeval_definingPoly_at_Z_succ (k : ‚Ñï) :
  (aeval (Z (k + 1))) (definingPoly (s:=Z (k))) = 0

@[simp]
lemma ofPolynomialAlgHom_toPolynomialAlgHom_C {r : R} :
    ofPolynomialAlgHom (toPolynomialAlgHom (C r : P)) = (Polynomial.C r : R[X])

theorem hcons_left_injective {Œ± : Sort u} {Œ≤ : Fin n ‚Üí Sort u} (b : (i : Fin n) ‚Üí Œ≤ i) :
    Function.Injective (fun (a : Œ±) => hcons a b)

theorem append_left_injective (b : Fin n ‚Üí Œ±) : Function.Injective (@Fin.append m n Œ± ¬∑ b)

@[simp]
lemma aeval_X {A : Type w} [CommSemiring A] [Algebra R A] (s : A) : aeval s X (P := P) = s

omit [Finite F] in
private lemma op_der_eq : Monoid.toMulAction FÀ£ = Units.mulAction'

theorem hcons_happend_comm {Œ≤ : Fin m ‚Üí Sort u} {Œ≥ : Fin n ‚Üí Sort u}
    (a : Œ±) (u : (i : Fin m) ‚Üí Œ≤ i) (v : (i : Fin n) ‚Üí Œ≥ i) :
    True

lemma concrete_zero_mul0 (b : ConcreteBTField 0) :
  concrete_mul (zero (k:=0)) b = zero (k:=0)

@[simp]
lemma erase_odd_empty :
    erase_odd ‚àÖ = ‚àÖ

lemma concrete_mul_assoc
  {h_k : k > 0} (prevBTFieldProps : ConcreteBTFieldProps (k := k - 1))
  (a b c : ConcreteBTField k) :
  concrete_mul (concrete_mul a b) c = concrete_mul a (concrete_mul b c)

lemma BerlekampWelch_Q_ne_zero {e k : ‚Ñï}
  [NeZero n]
  {œâs f : Fin n ‚Üí F}
  {E Q : Polynomial F}
  (h_bw : BerlekampWelchCondition e k œâs f E Q)
  (h_dist : e < Œî‚ÇÄ(f, 0))
  (h_inj : Function.Injective œâs)
  : Q ‚â† 0

theorem prime_47 : Nat.Prime 47

@[simp]
theorem oracleReduction_completeness (hInit : init.neverFails) :
    (oracleReduction oSpec OStatement).perfectCompleteness
      init impl (relIn OStatement) (relOut OStatement)

@[simp]
theorem induction_two' {motive : Fin 3 ‚Üí Sort*} {zero : motive 0}
    {succ : ‚àÄ i : Fin 2, motive i.castSucc ‚Üí motive i.succ} :
      induction (motive := motive) zero succ (2 : Fin 3) = succ 1 (succ 0 zero)

lemma take_eq_take : transcript‚ü¶:m‚üß = transcript.take m h

Nat.lt_of_le_of_lt in Init.Prelude

private lemma sum_1_over_n_aux_frac_k_i [Zero F]
  (h_n : 0 < n) : ‚àë i, 1/n * aux_frac B (K B i 0) = aux_frac B (k B)

lemma comm_map_smul_add (s : Right) (x y : Right ‚äó[K] Left)
    (hx : e (s ‚Ä¢ x) = s ‚Ä¢ (e x)) (hy : e (s ‚Ä¢ y) = s ‚Ä¢ (e y)) :
    e (s ‚Ä¢ x) + e (s ‚Ä¢ y) = s ‚Ä¢ e x + s ‚Ä¢ e y

@[simp] theorem rightpad_eq_self (l : List Œ±) (n : Nat) (h : n ‚â§ l.length) :
    rightpad n unit l = l

theorem coreInteractionOracleVerifier_rbrKnowledgeSoundness :
    (coreInteractionOracleVerifier ùîΩq Œ≤).rbrKnowledgeSoundness init impl
      (pSpec := pSpecCoreInteraction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
      (relIn := roundRelation (mp := BBF_SumcheckMultiplierParam) ùîΩq Œ≤ (œë:=œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) 0)
      (relOut := finalSumcheckRelOut ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
      (rbrKnowledgeError := coreInteractionOracleRbrKnowledgeError ùîΩq Œ≤ (œë:=œë))

theorem relayOracleVerifier_rbrKnowledgeSoundness (i : Fin ‚Ñì)
    (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
    (relayOracleVerifier ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        i hNCR).rbrKnowledgeSoundness init impl
      (relIn := foldStepRelOut (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i.succ)
      (relayKnowledgeError)

@[simp]
lemma lastBlockIdx_mul_œë_add_x_lt_‚Ñì_succ (x : ‚Ñï) {hx : x ‚â§ œë} :
    (‚Ñì / œë - 1) * œë + x < ‚Ñì + 1

theorem hcons_inj {Œ± : Sort u} {Œ≤ : Fin n ‚Üí Sort u} (a‚ÇÅ a‚ÇÇ : Œ±) (b‚ÇÅ b‚ÇÇ : (i : Fin n) ‚Üí Œ≤ i) :
    hcons a‚ÇÅ b‚ÇÅ = hcons a‚ÇÇ b‚ÇÇ ‚Üî a‚ÇÅ = a‚ÇÇ ‚àß b‚ÇÅ = b‚ÇÇ

theorem cast_symm {Œ± Œ≤ : Sort u} {h : Œ± = Œ≤} {a : Œ±} {b : Œ≤} :
    cast h a = b ‚Üî a = cast h.symm b

@[simp]
theorem Reduction.id_run (stmt : StmtIn) (wit : WitIn) :
    (Reduction.id : Reduction oSpec StmtIn WitIn _ _ _).run stmt wit =
      pure ‚ü®‚ü®default, stmt, wit‚ü©, stmt‚ü©

@[simp]
theorem Z_succ_eq_adjointRoot_root (k : ‚Ñï) : Z (k+1) = AdjoinRoot.root (poly k)

theorem pow_zero {a : CNat 50} : a ^ 0 = 1

lemma rounds_sub_steps_lt : ‚Ñì - œë < ‚Ñì :=
  Nat.sub_lt (pos_of_neZero ‚Ñì) (folding_steps_pos)

lemma œë_sub_one_le_self : œë - 1 < œë

Nat.zero_le in Init.Prelude

omit [Fintype F] [DecidableEq F] in
private lemma choose_2_card_ne_zero (h : 2 ‚â§ B.card) : choose_2 ‚ÜëB.card ‚â† 0

theorem Nat.reconstruct_from_hi_and_lo_parts_or_ver (n hi_len lo_len : ‚Ñï)
  (h_n : n < 2 ^ (hi_len + lo_len)) :
    n = (((n >>> lo_len) % (2 ^ hi_len)) <<< lo_len) ||

theorem BaseField_is_prime : Nat.Prime BASE_FIELD_CARD

lemma liftF_ne_zero_of_lt {i : ‚Ñï} (h : i < n) : liftF f' i ‚â† 0 ‚Üî f' ‚ü®i, h‚ü© ‚â† 0

@[simp]
lemma length_nil : nil.length = 0

theorem append_right' {u : Fin m ‚Üí Œ±} {v : Fin n ‚Üí Œ±} {i : Fin n}
    (j : Fin (m + n)) (h : j = natAdd m i) : append u v j = v i

@[simp]
lemma dfoldl'_succ_last {n : ‚Ñï} {Œ± : Fin (n + 2) ‚Üí Type u}
    (f : (i : Fin (n + 1)) ‚Üí Œ± i.castSucc ‚Üí Œ± i.succ) (x : Œ± 0) :
    dfoldl' (n + 1) Œ± f x = f (last n) (dfoldl' n (Œ± ‚àò castSucc) (fun i => f i.castSucc) x)

Fin.append_right in Mathlib.Data.Fin.Tuple.Basic

lemma isInterleaved_codeOfLinearCode : (codeOfLinearCode Œ∫ LC).isInterleaved

theorem dcast‚ÇÇ_dcast : dcast‚ÇÇ rfl rfl c = dcast dcast_eq.symm c

theorem fcons‚ÇÇ_inj {Œ±‚ÇÅ : A} {Œ±‚ÇÇ : B} {Œ≤‚ÇÅ : Fin n ‚Üí A} {Œ≤‚ÇÇ : Fin n ‚Üí B}
    (a‚ÇÅ a‚ÇÇ : F‚ÇÇ Œ±‚ÇÅ Œ±‚ÇÇ) (b‚ÇÅ b‚ÇÇ : (i : Fin n) ‚Üí F‚ÇÇ (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) :
    fcons‚ÇÇ (F := F‚ÇÇ) a‚ÇÅ b‚ÇÅ = fcons‚ÇÇ (F := F‚ÇÇ) a‚ÇÇ b‚ÇÇ ‚Üî a‚ÇÅ = a‚ÇÇ ‚àß b‚ÇÅ = b‚ÇÇ

theorem fconcat_left_injective {Œ± : Fin n ‚Üí A} {Œ≤ : A} (a : F Œ≤) :
    Function.Injective (fun v : (i : Fin n) ‚Üí F (Œ± i) => fconcat v a)

@[simp]
theorem snoc_init_self : snoc (init t) (t (Fin.last n)) = t

lemma Fin.val_sub_one (a : Fin r) (h_a_sub_1 : a > 0) : (a - 1).val = a.val - 1

lemma powContraction_is_right_inverse_to_linearMvExtension
  (p : Polynomial.degreeLT F (2^m)) :
    powContraction.comp linearMvExtension p = p

@[simp]
theorem dflatten_one {n : Fin 1 ‚Üí ‚Ñï} {motive : (k : Fin (vsum n)) ‚Üí Sort*}
    {v : (i : Fin 1) ‚Üí (j : Fin (n i)) ‚Üí motive (embedSum i j)} :
    dflatten (motive := motive) v = v 0

theorem size_eq_degree (p : UniPoly R) : p.trim.size = p.degree

@[simp]
lemma challengeOracleInterface_append_domain_inl (j : pSpec‚ÇÅ.ChallengeIdx) :
    [(pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).Challenge]‚Çí.domain (.inl j) = Unit

@[simp]
theorem fappend_right {Œ± : Fin m ‚Üí A} {Œ≤ : Fin n ‚Üí A}
    (u : (i : Fin m) ‚Üí F (Œ± i)) (v : (i : Fin n) ‚Üí F (Œ≤ i)) (i : Fin n) :
    fappend u v (natAdd m i) = cast (by simp [vappend_right]) (v i)

theorem linear_sum_repr (R : Type*) [CommRing R] (S : Type*) [CommRing S] [Algebra R S]
    (pb : PowerBasis R S) (h_dim : pb.dim = (2 : ‚Ñï)) (s : S) :
    ‚àÉ a b : R, s = a ‚Ä¢ pb.gen + algebraMap R S b

@[simp]
theorem append_cast_left {n m : ‚Ñï} {pSpec : ProtocolSpec n} {pSpec' : ProtocolSpec m} (n' : ‚Ñï)
    (h : n + m = n' + m) :
      dcast h (pSpec ++‚Çö pSpec') = (dcast (Nat.add_right_cancel h) pSpec) ++‚Çö pSpec'

@[simp]
theorem bit_revFinProdFinEquiv_symm_2_pow_succ {n : ‚Ñï} (j : Fin (2 ^ (n + 1))) (i : Fin (n + 1)):
  let e : Fin (2 ^ n * 2) ‚âÉ Fin (2 ^ n) √ó Fin 2 :=revFinProdFinEquiv (m:=2^(n)) (n:=2)
    (h_m:=by exact Nat.two_pow_pos n).symm
  let msb : Fin 2 := (e j).2
  let lsbs : Fin (2 ^ n) := (e j).1
  Nat.getBit (i) j = if i.val < n then Nat.getBit (i.val) lsbs else msb

lemma geometric_sum_units {F : Type*} [Field F] [DecidableEq F] {r : FÀ£} {a : ‚Ñï} :
  ‚àë j ‚àà range (a + 1), (r ^ j : F) =
    if r = 1 then (a + 1 : F)
    else (1 - r ^ (a + 1)) / (1 - r)

lemma and_two_pow_eq_zero_of_getBit_0 {n i : ‚Ñï} (h_getBit : getBit i n = 0)
    : n &&& (2 ^ i) = 0

theorem liftContext_perfectCompleteness
    (h : R.perfectCompleteness init impl innerRelIn innerRelOut) :
      (R.liftContext lens).perfectCompleteness init impl outerRelIn outerRelOut

omit hF‚ÇÇ in
theorem kernel_W_eq_U (i : Fin r) :
  LinearMap.ker (polyEvalLinearMap (W ùîΩq Œ≤ i)
    (W_is_additive ùîΩq Œ≤ i)) = U ùîΩq Œ≤ i

@[simp]
lemma seqCompose_toReduction {m : ‚Ñï}
    (Stmt : Fin (m + 1) ‚Üí Type)
    {Œπ‚Çõ : Fin (m + 1) ‚Üí Type} (OStmt : (i : Fin (m + 1)) ‚Üí Œπ‚Çõ i ‚Üí Type)
    [O‚Çõ : ‚àÄ i, ‚àÄ j, OracleInterface (OStmt i j)]
    (Wit : Fin (m + 1) ‚Üí Type)
    {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    [O‚Çò : ‚àÄ i, ‚àÄ j, OracleInterface ((pSpec i).Message j)]
    (R : (i : Fin m) ‚Üí
      OracleReduction oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Wit i.castSucc)
        (Stmt i.succ) (OStmt i.succ) (Wit i.succ) (pSpec i)) :
    (seqCompose Stmt OStmt Wit R).toReduction =
      Reduction.seqCompose (fun i => Stmt i √ó (‚àÄ j, OStmt i j)) Wit
        (fun i => (R i).toReduction)

Nat.pred_lt_self in Init.Data.Nat.Basic

@[simp]
lemma liftComp_support {Œπ' : Type w} {superSpec : OracleSpec Œπ'}
    [h : MonadLift (OracleQuery spec) (OracleQuery superSpec)]
    (oa : OracleComp spec Œ±) : (liftComp oa superSpec).support = oa.support

@[simp] theorem mul_one {a : AssocNat} : a * 1 = a

@[simp]
lemma solutionToQ_zero {v : Fin (2 * 0 + 0) ‚Üí F} :
  solutionToQ (F := F) 0 0 v = 0

@[simp]
theorem BTField.PowerBasis.dim_of_eq_rec
    (r1 r : ‚Ñï)
    (h_r : r = r1 + 1)
    (b : PowerBasis (BTField r1) (BTField (r1 + 1))) :
    letI instAlgebra : Algebra (BTField r1) (BTField r) :=
      binaryAlgebraTower (l:=r1) (r:=r) (h_le:=by omega)
    ((Eq.rec (motive:=fun (x : ‚Ñï) (_ : r1 + 1 = x) => by
      letI instAlgebraCur : Algebra (BTField r1) (BTField x) :=
        binaryAlgebraTower (l:=r1) (r:=x) (h_le:=by omega)
      exact PowerBasis (BTField r1) (BTField x)) (refl:=b) (t:=h_r.symm)) :
        PowerBasis (BTField r1) (BTField r)).dim
    = b.dim

lemma lifted_trace_map_eval_at_roots_prev_BTField
  {curBTField : Type*} [Field curBTField]
  (u : curBTField) (t1 : curBTField) -- here t1 is already lifted to curBTField
  (k : ‚Ñï)
  (sumZeroIffEq : ‚àÄ (x y : curBTField), x + y = 0 ‚Üî x = y)
  (u_plus_inv_eq_t1 : u + u‚Åª¬π = t1)
  (galois_automorphism : u^(2^(2^k)) = u‚Åª¬π ‚àß (u‚Åª¬π)^(2^(2^k)) = u)
  (trace_map_at_prev_root : ‚àë i ‚àà Finset.range (2 ^ k), t1 ^ (2 ^ i) = 1) :
  ‚àë i ‚àà Finset.range (2 ^ (k+1)), u ^ (2 ^ i) = 1

@[simp]
theorem reduction_completeness (h : init.neverFails) :
    (reduction oSpec Statement Witness).perfectCompleteness init impl relIn (toRelOut relIn)

@[simp]
theorem insertNth_zero_zero : insertNth p 0 (0 : Fin n ‚Üí‚ÇÄ M) = 0

theorem galois_automorphism_power
    {curBTField : Type*} [Field curBTField]
    (u : curBTField) (t1 : curBTField) -- here t1 is already lifted to curBTField
    (k : ‚Ñï)
    (sumZeroIffEq : ‚àÄ (x y : curBTField), x + y = 0 ‚Üî x = y)
    (specialElementNeZero : u ‚â† 0)
    (prevSpecialElementNeZero : t1 ‚â† 0)
    (u_plus_inv_eq_t1 : u + u‚Åª¬π = t1)
    (h_u_square : u ^ 2 = u * t1 + 1)
    (h_t1_pow : t1 ^ (2 ^ (2 ^ k) - 1) = 1 ‚àß (t1‚Åª¬π) ^ (2 ^ (2 ^ k) - 1) = 1)
    (trace_map_roots : ‚àë i ‚àà Finset.range (2 ^ k), t1 ^ (2 ^ i) = 1 ‚àß
                      ‚àë i ‚àà Finset.range (2 ^ k), t1‚Åª¬π ^ (2 ^ i) = 1) :
    u^(2^(2^k)) = u‚Åª¬π ‚àß (u‚Åª¬π)^(2^(2^k)) = u

@[simp]
theorem dcast‚ÇÇ_eq : dcast‚ÇÇ (Eq.refl a) dcast_eq c = c

private lemma K_eq_sum {Œ± : F} : K B i Œ± = ‚àë (x : B), if x.1 i = Œ± then 1 else 0

theorem foldl_split_outer {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤ ‚Üí Œ±) (init : Œ±)
    (l : List Œ≤) (h : l ‚â† []): foldl (f:=f) (init:=init) (l)
    = f (foldl (f:=f) (init:=init) (l.dropLast)) (l.getLast (by omega))

omit [Finite F] in
lemma pow_2_pow_i_mem_Di_of_mem_D :
  ‚àÄ {x : FÀ£} (i : ‚Ñï),
    x ‚àà D ‚Üí x ^ (2 ^ i) ‚àà evalDomain D i

lemma add_eq_one_iff (a b : ConcreteBTField 0) :
  a + b = 1 ‚Üî (a = 0 ‚àß b = 1) ‚à® (a = 1 ‚àß b = 0)

theorem rbrSoundness_implies_soundness (langIn : Set StmtIn) (langOut : Set StmtOut)
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    (rbrSoundnessError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) :
      rbrSoundness init impl langIn langOut verifier rbrSoundnessError ‚Üí
        soundness init impl langIn langOut verifier (‚àë i, rbrSoundnessError i)

lemma f_eq_evenPart_plus_x_oddPart {f : Polynomial F} :
  f = evenPart f + Polynomial.X * oddPart f

theorem foldOracleVerifier_rbrKnowledgeSoundness (i : Fin ‚Ñì) :
    (foldOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i).rbrKnowledgeSoundness init impl
      (relIn := roundRelation (mp := mp) ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        (ùìë := ùìë) i.castSucc)
      (relOut := foldStepRelOut (mp := mp) ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        (ùìë := ùìë) i)
      (foldKnowledgeError ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)

lemma pointToIterateQuotientIndex_qMap_total_fiber_eq_self (i : Fin ‚Ñì) (steps : ‚Ñï)
    (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
    (y : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) (i := ‚ü®i + steps, by omega‚ü©)) (k : Fin (2 ^ steps)) :
    pointToIterateQuotientIndex (i := ‚ü®i, by omega‚ü©) (steps := steps) (h_i_add_steps := by omega)
      (x := ((qMap_total_fiber ùîΩq Œ≤ (i := ‚ü®i, by omega‚ü©) (steps := steps)
        (h_i_add_steps := by apply Nat.lt_add_of_pos_right_of_le; omega) (y := y) k):
          sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i, by omega‚ü©))) = k

lemma towerRingHomForwardMap_join {k : ‚Ñï} (h_pos : k > 0) (hi lo : ConcreteBTField (k - 1)) :
  towerRingHomForwardMap (k:=k) („Ää hi, lo „Äã) =
    BinaryTower.join_via_add_smul (k:=k) (h_pos:=by omega)
      (hi_btf := towerRingHomForwardMap (k:=k-1) hi)
      (lo_btf := towerRingHomForwardMap (k:=k-1) lo)

omit [DecidableEq L] [DecidableEq ùîΩq] h_Fq_char_prime hF‚ÇÇ hŒ≤_lin_indep h_Œ≤‚ÇÄ_eq_1 in
lemma intermediateNovelBasisX_zero_eq_one (i : Fin (‚Ñì + 1)) :
    intermediateNovelBasisX ùîΩq Œ≤ h_‚Ñì_add_R_rate i ‚ü®0, by
      exact Nat.two_pow_pos (‚Ñì - ‚Üëi)‚ü© = 1

omit [DecidableEq ùîΩq] hF‚ÇÇ h_Œ≤‚ÇÄ_eq_1 in
lemma getSDomainBasisCoeff_of_sum_repr [NeZero R_rate] (i : Fin (‚Ñì + 1))
    (x : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®i, by omega‚ü©)
    (x_coeffs : Fin (‚Ñì + R_rate - i) ‚Üí ùîΩq)
    (hx : x = ‚àë j_x, (x_coeffs j_x) ‚Ä¢ (sDomain_basis ùîΩq Œ≤
      h_‚Ñì_add_R_rate (i := ‚ü®i, by omega‚ü©) (h_i := by
        simp only; apply Nat.lt_add_of_pos_right_of_le; omega) j_x).val) :
    ‚àÄ (j: Fin (‚Ñì + R_rate - i)), ((sDomain_basis ùîΩq Œ≤
      h_‚Ñì_add_R_rate (i := ‚ü®i, by omega‚ü©) (h_i := by
        simp only; apply Nat.lt_add_of_pos_right_of_le; omega)).repr x) j = x_coeffs j

theorem singletonBound [CommRing F] [StrongRankCondition F]
  (LC : LinearCode Œπ F) :
  dim LC ‚â§ length LC - Code.minDist (LC : Set (Œπ ‚Üí F)) + 1

private lemma sum_K_eq_card : ‚àë (Œ± : F), K B i Œ± = B.card

lemma one_is_1 {k : ‚Ñï} : (one (k:=k)) = 1

theorem Nat.Prime_of_isNat : ‚àÄ {n n' : ‚Ñï}, IsNat n n' ‚Üí n'.Prime ‚Üí n.Prime

@[simp]
theorem LeafData.optionComposeBuild_leaf {Œ±} (a : Œ±)
    (compose : Œ± ‚Üí Œ± ‚Üí Option Œ±) :
    (LeafData.leaf a).optionComposeBuild compose = FullData.leaf (.some a)

lemma zero_def [Zero R] : zero = Vector.replicate (2 ^ n) 0

theorem insertNth_ne_zero_of_left (h : y ‚â† 0) : insertNth p y s ‚â† 0

lemma vappend_zero_of_succ_left {u : Fin (m + 1) ‚Üí Œ±} {v : Fin n ‚Üí Œ±} :
    (vappend u v) 0 = u 0

lemma vappend_right_of_not_lt {m n : ‚Ñï} {Œ± : Sort u}
    (u : Fin m ‚Üí Œ±) (v : Fin n ‚Üí Œ±) (i : Fin (m + n)) (h : ¬¨ i.val < m) :
      vappend u v i = v ‚ü®i - m, by omega‚ü©

lemma norm_of_ne_zero_is_ne_zero {k : ‚Ñï}
  {h_k_gt_0 : k > 0} (prevBTFieldResult : ConcreteBTFStepResult (k := k - 1))
  (a : ConcreteBTField k) (h_a_ne_zero : a ‚â† 0) :
  let a‚ÇÅ := (split h_k_gt_0 a).1
  let a‚ÇÄ := (split h_k_gt_0 a).2
  concrete_mul a‚ÇÄ (a‚ÇÄ + concrete_mul a‚ÇÅ (Z (k - 1))) + concrete_mul a‚ÇÅ a‚ÇÅ ‚â† 0

theorem cast_run (stmt : StmtIn) (wit : WitIn) :
    R.run stmt wit = cast (sorry) ((R.cast hn hSpec).run stmt wit)

@[simp]
private lemma leadingCoeff_E : (E œâs f p e).leadingCoeff = 1

theorem rtake_eq_take_rev {Œ± : Sort*} (m : ‚Ñï) (h : m ‚â§ n) (v : Fin n ‚Üí Œ±) :
    rtake m h v = (take m h (v ‚àò Fin.rev)) ‚àò Fin.rev

protected theorem heq_fun_iff' {k l : ‚Ñï} {Œ± : Fin k ‚Üí Sort u} {Œ≤ : Fin l ‚Üí Sort u} (h : k = l)
    (h' : ‚àÄ i : Fin k, (Œ± i) = (Œ≤ (Fin.cast h i))) {f : (i : Fin k) ‚Üí Œ± i} {g : (j : Fin l) ‚Üí Œ≤ j} :
    HEq f g ‚Üî ‚àÄ i : Fin k, HEq (f i) (g (Fin.cast h i))

@[simp]
lemma aeval_C {A : Type w} [CommSemiring A] [Algebra R A] (x : A) (r : R) :
    (aeval x) (C r : P) = algebraMap R A r

theorem findSum_of_le_sum {l : List ‚Ñï} {j : ‚Ñï} (h : j < l.sum) : ‚àÉ n, findSum l j = some n

theorem totalDegree_coeff_finSuccEquivNth_add_le (f : MvPolynomial (Fin (n + 1)) R) (i : ‚Ñï)
    (hi : (finSuccEquivNth R p f).coeff i ‚â† 0) :
      totalDegree ((finSuccEquivNth R p f).coeff i) + i ‚â§ totalDegree f

theorem fcons_inj {Œ≤ : Fin n ‚Üí A} (a‚ÇÅ a‚ÇÇ : F Œ±) (b‚ÇÅ b‚ÇÇ : (i : Fin n) ‚Üí F (Œ≤ i)) :
    fcons a‚ÇÅ b‚ÇÅ = fcons a‚ÇÇ b‚ÇÇ ‚Üî a‚ÇÅ = a‚ÇÇ ‚àß b‚ÇÅ = b‚ÇÇ

lemma C_injective : Function.Injective (C : R ‚Üí P)

@[simp]
lemma blockIdx_mul_œë_lt_‚Ñì_succ (i : Fin (‚Ñì / œë - 1 + 1)) : ‚Üëi * œë < ‚Ñì + 1

private lemma aux_sum [Zero F]
  (h_n : 0 < n)
  : n * choose_2 (aux_frac B (k B)) ‚â§ ‚àë i, choose_2 (aux_frac B (K B i 0))

theorem basis_repr_of_sDomain_lift (i j : Fin r) (h_j : j < ‚Ñì + R_rate) (h_le : i ‚â§ j)
    (y : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := j)) :
    let x‚ÇÄ := sDomain.lift ùîΩq Œ≤ h_‚Ñì_add_R_rate i j (by omega) (by omega) y
    ‚àÄ k: Fin (‚Ñì + R_rate - i),
      (sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := i) (h_i := by omega)).repr x‚ÇÄ k =
        if hk: k < (j.val - i.val) then 0
        else (sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := j)
          (h_i := by omega)).repr y ‚ü®k - (j.val - i.val), by omega‚ü©

@[simp]
protected lemma elocPoly_one :
  ElocPoly 1 œâs f p = if f 0 ‚â† p.eval (œâs 0) then X - (C (œâs 0)) else 1

lemma even_index_intermediate_novel_basis_decomposition (i : Fin ‚Ñì) (j : Fin (2 ^ (‚Ñì - i - 1))) :
  intermediateNovelBasisX ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i, by omega‚ü© ‚ü®j * 2, by
    apply mul_two_add_bit_lt_two_pow j (‚Ñì-i-1) (‚Ñì-i) ‚ü®0, by omega‚ü© (by omega) (by omega)
  ‚ü©  = (intermediateNovelBasisX ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i+1, by omega‚ü© ‚ü®j, by
    apply lt_two_pow_of_lt_two_pow_exp_le j (‚Ñì-i-1) (‚Ñì-(i+1)) (by omega) (by omega)
  ‚ü©).comp (qMap ùîΩq Œ≤ ‚ü®i, by omega‚ü©)

lemma aeval_eq {A : Type w} [CommSemiring A] [Algebra R A] (f : P ‚Üí‚Çê[R] A) : f = aeval (f X)

@[ext]
lemma ext {m n : ChurchNat Œ±} (h : ‚àÄ f x, m f x = n f x) : m = n

theorem runWithOracle_succeeds_iff_simulateQ_randomOracle_neverFails
     {Œ≤}
    [DecidableEq Œπ] [spec.DecidableEq] [(i : Œπ) ‚Üí SelectableType (OracleSpec.range spec i)]
    (oa : OracleComp (spec) Œ≤) (f : spec.FunctionType) :
    (runWithOracle f oa).isSome ‚Üî
    ((oa.simulateQ randomOracle).run (fun i q => some (f i q))).neverFails

theorem SkeletonNodeIndex.leftChild_bind_parent {s : Skeleton}
    (idx : SkeletonNodeIndex s) :
    idx.leftChild >>= parent = idx.leftChild.map (fun _ => idx)

@[simp]
theorem generateProof_leaf (a : Œ±) (idx) :
    generateProof (FullData.leaf a) idx = []

theorem basisVectors_linear_independent (‚Ñì : Nat) (h_‚Ñì : ‚Ñì ‚â§ r) :
    LinearIndependent L (basisVectors ùîΩq Œ≤ ‚Ñì h_‚Ñì)

theorem sumcheckFoldOracleReduction_perfectCompleteness (hInit : init.neverFails) :
    OracleReduction.perfectCompleteness
      (pSpec := pSpecSumcheckFold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
      (relIn := roundRelation (mp := mp) ùîΩq Œ≤ (œë:=œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) 0)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë:=œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) (Fin.last ‚Ñì))
      (oracleReduction := sumcheckFoldOracleReduction ùîΩq Œ≤ (œë:=œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë))
      (init := init)
      (impl := impl)

@[simp]
theorem FullData.leftSubtree_internal {Œ±} {s_left s_right : Skeleton}
    (value : Œ±) (left : FullData Œ± s_left) (right : FullData Œ± s_right) :
    (FullData.internal value left right).leftSubtree = left

lemma concrete_mul_zero
  (prevBTFieldProps : ConcreteBTFieldProps (k := k - 1))
  (a : ConcreteBTField k) : concrete_mul a (zero (k:=k)) = zero (k:=k)

private lemma Monad.map_of_prod_fst_eq_prod_fst {m : Type u ‚Üí Type v} [Monad m] [LawfulMonad m]
    {Œ± Œ≤ Œ≥ : Type u} (ma : m (Œ± √ó Œ≤)) (c : Œ≥) :
    (fun a => (c, a.1)) <$> ma = Prod.mk c <$> Prod.fst <$> ma

@[simp]
theorem Reduction.id_perfectCompleteness {rel : Set (StmtIn √ó WitIn)} (hInit : init.neverFails) :
    (Reduction.id : Reduction oSpec _ _ _ _ _).perfectCompleteness init impl rel rel

lemma Basis.baseChangeRight_repr_tmul (b : Basis Œπ K Left) (x y i) :
    (Basis.baseChangeRight (b:=b) (Right:=Right)).repr (x ‚äó‚Çú y) i = b.repr x i ‚Ä¢ y

lemma listOfCloseCodewordsRel_eq_zero :
  listOfCloseCodewordsRel C y r = 0 ‚Üî
  IsEmpty (relHammingBall C y r) ‚à® Infinite (relHammingBall C y r)

theorem randomOracle_cache_neverFails_iff_runWithOracle_neverFails {Œ≤}
    [DecidableEq Œπ] [spec.DecidableEq] [(i : Œπ) ‚Üí SelectableType (OracleSpec.range spec i)]
    (oa : OracleComp (spec) Œ≤) (preexisting_cache : spec.QueryCache)
    :
    ((oa.simulateQ randomOracle).run preexisting_cache).neverFails
    ‚Üî
    (‚àÄ (f : spec.FunctionType),
      Oracle.containsCache f preexisting_cache ‚Üí
      (runWithOracle f oa).isSome)

lemma schwartz_zippel' {p : MvPolynomial œÉ R} (hp : p ‚â† 0) (S : œÉ ‚Üí Finset R) :
    #{x ‚àà Finset.pi p.vars S | eval (extendDomain x) p = 0} / ‚àè i ‚àà p.vars, (#(S i) : ‚Ñö‚â•0)
      ‚â§ ‚àë i ‚àà p.vars, (p.degreeOf i / #(S i) : ‚Ñö‚â•0)

theorem eq_of_equiv [LawfulBEq R] {p q : UniPoly R} : equiv p q ‚Üí p.trim = q.trim

@[csimp]
theorem dconcat_eq_snoc : @dconcat = @snoc

lemma Lemma_A_1 {H : F[X][Y]} (Œ≤ : ùí™ H) (D : ‚Ñï) (hD : D ‚â• Bivariate.totalDegree H)
    (S_Œ≤_card : Set.ncard (S_Œ≤ Œ≤) > (weight_Œõ_over_ùí™ Œ≤ D) * H.natDegree) :
  embeddingOfùí™IntoùïÉ _ Œ≤ = 0

@[simp]
lemma evalDist_cast (h : Œ± = Œ≤) [spec.FiniteRange] :
    evalDist (cast (congrArg (OracleComp spec) h) oa) =
      cast (congrArg (PMF ‚àò Option) h) (evalDist oa)

lemma foldl_NTTStage_inductive_aux (h_‚Ñì : ‚Ñì ‚â§ r) (k : Fin (‚Ñì + 1))
    (original_coeffs : Fin (2 ^ ‚Ñì) ‚Üí L) :
    additiveNTTInvariant ùîΩq Œ≤ h_‚Ñì_add_R_rate
    (Fin.foldl k (fun current_b i ‚Ü¶ NTTStage ùîΩq Œ≤ h_‚Ñì_add_R_rate
      ‚ü®‚Ñì - i -1, by omega‚ü© current_b) (tileCoeffs original_coeffs))
    original_coeffs ‚ü®‚Ñì - k, by omega‚ü©

@[simp]
lemma bIdx_mul_œë_add_i_cast_lt_‚Ñì_succ (bIdx : Fin (‚Ñì / œë - 1)) (i : Fin (œë - 1 + 1))
    : ‚ÜëbIdx * œë + i < ‚Ñì + 1

theorem append_rbrKnowledgeSoundness (V‚ÇÅ : OracleVerifier oSpec Stmt‚ÇÅ OStmt‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : OracleVerifier oSpec Stmt‚ÇÇ OStmt‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ pSpec‚ÇÇ)
    {rbrKnowledgeError‚ÇÅ : pSpec‚ÇÅ.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    {rbrKnowledgeError‚ÇÇ : pSpec‚ÇÇ.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    (h‚ÇÅ : V‚ÇÅ.rbrKnowledgeSoundness init impl rel‚ÇÅ rel‚ÇÇ rbrKnowledgeError‚ÇÅ)
    (h‚ÇÇ : V‚ÇÇ.rbrKnowledgeSoundness init impl rel‚ÇÇ rel‚ÇÉ rbrKnowledgeError‚ÇÇ) :
      (V‚ÇÅ.append V‚ÇÇ).rbrKnowledgeSoundness init impl rel‚ÇÅ rel‚ÇÉ
        (Sum.elim rbrKnowledgeError‚ÇÅ rbrKnowledgeError‚ÇÇ ‚àò ChallengeIdx.sumEquiv.symm)

theorem multilinearBasis_apply (r : ‚Ñï) : ‚àÄ l : ‚Ñï, (h_le : l ‚â§ r) ‚Üí ‚àÄ (j : Fin (2  ^ (r - l))),
  multilinearBasis (l:=l) (r:=r) (h_le:=h_le) j =
    (Finset.univ : Finset (Fin (r - l))).prod (fun i =>
      (binaryAlgebraTower (l:=l + i + 1) (r:=r) (h_le:=by omega)).algebraMap (
        (ùïè (l + i)) ^ (Nat.getBit i j)))

theorem concreteTowerAlgebraMap_succ_last (r : ‚Ñï) : ‚àÄ l : ‚Ñï, (h_le : l ‚â§ r) ‚Üí
  concreteTowerAlgebraMap (l:=l) (r:=r + 1) (h_le:=by
    exact Nat.le_trans (n:=l) (m:=r) (k:=r + 1) (h_le) (by omega)) =
  (concreteTowerAlgebraMap (l:=l + 1) (r:=r + 1) (by omega)).comp (concreteTowerAlgebraMap
    (l:=l) (r:=l + 1) (by omega))

theorem randomOracle_neverFails_iff_runWithOracle_neverFails {Œ≤}
    [DecidableEq Œπ] [spec.DecidableEq] [(i : Œπ) ‚Üí SelectableType (OracleSpec.range spec i)]
    (oa : OracleComp (spec) Œ≤)
    :
    (‚àÄ (preexisting_cache : spec.QueryCache),
      ((oa.simulateQ randomOracle).run preexisting_cache).neverFails)
    ‚Üî
    (‚àÄ (f : spec.FunctionType),
      (runWithOracle f oa).isSome)

@[to_additive (attr := simp)]
theorem prod_insertNth [CommMonoid Œ≤] {n : ‚Ñï} (x : Œ≤) (f : Fin n ‚Üí Œ≤) (p : Fin (n + 1)) :
    ‚àè i, insertNth p x f i = x * ‚àè i, f i

theorem sum_of_root_and_inverse_is_t1
    {curBTField : Type*} [Field curBTField]
    (u : curBTField) (t1 : curBTField) -- here t1 is already lifted to curBTField
    (specialElementNeZero : u ‚â† 0)
    (eval_prevPoly_at_root : u ^ 2 + t1 * u + 1 = 0)
    (sumZeroIffEq : ‚àÄ (x y : curBTField), x + y = 0 ‚Üî x = y) :
    u + u‚Åª¬π = t1

lemma lagrangeToMono_eq_lagrangeToMono_segment (n : ‚Ñï) [NeZero n] (v : Vector R (2 ^ n)) :
  have h_n_ne_zero: n ‚â† 0

@[simp]
private lemma E_ne_zero : (E œâs f p e) ‚â† 0

theorem reduction_rbr_knowledge_soundness : True

theorem linsolve_some {A : Matrix (Fin n) (Fin m) F} {b : Fin n ‚Üí F} {x : Fin m ‚Üí F}
  (h : linsolve A b = some x)
  : A.mulVec x = b

theorem towerEquiv_commutes_left (i j : ‚Ñï) (h : i ‚â§ j) : ‚àÄ r : ConcreteBTField i,
  (AlgebraTower.algebraMap i j h) ((towerEquiv i).ringEquiv r) =
  (towerEquiv j).ringEquiv ((AlgebraTower.algebraMap i j h) r)

theorem vcons_inj (a b : Œ±) (v w : Fin n ‚Üí Œ±) : a ::·µõ v = b ::·µõ w ‚Üî a = b ‚àß v = w

theorem snoc_left_injective : Injective (Finsupp.snoc ¬∑ y : (Fin n ‚Üí‚ÇÄ M) ‚Üí Fin (n + 1) ‚Üí‚ÇÄ M)

lemma addSalt_Message (i : pSpec.MessageIdx) :
    (pSpec.addSalt Salt).Message i = (pSpec.Message i √ó Salt i)

lemma natDegree_lt_of_lbounded_zero_coeff {p : F[X]} [NeZero deg]
  (h : ‚àÄ i, deg ‚â§ i ‚Üí p.coeff i = 0) : p.natDegree < deg

private lemma errors_are_roots_of_E {i : Fin n}
  (h : f i ‚â† p.eval (œâs i)) : (E œâs f p e).eval (œâs i) = 0

@[simp]
lemma length_eq_domain_size (inj : Function.Injective Œ±) :
  length (ReedSolomon.code ‚ü®Œ±, inj‚ü© deg) = m

lemma join_zero_zero {k : ‚Ñï} (h_k : k > 0) :
  „Ää zero (k:=k - 1), zero (k:=k - 1) „Äã = zero (k:=k)

@[simp]
theorem Basis_cast_index_eq (i j k n : ‚Ñï) (h_le : k ‚â§ n) (h_eq : i = j) :
    letI instAlgebra : Algebra (ConcreteBTField k) (ConcreteBTField n) :=
      ConcreteBTFieldAlgebra (l:=k) (r:=n) (h_le:=h_le)
    letI : Module (ConcreteBTField k) (ConcreteBTField n) := instAlgebra.toModule
    (Basis (Fin (i)) (ConcreteBTField k) (ConcreteBTField n)) =
    (Basis (Fin (j)) (ConcreteBTField k) (ConcreteBTField n))

@[simp]
lemma eval‚ÇÇAlgHom_apply {A B : Type*} [CommSemiring A] [CommSemiring B] [MvPolynomialLike œÉ A P]
    [Algebra R A] [IsScalarTower R A P] [Algebra R B]
    (f : A ‚Üí‚Çê[R] B) (g : œÉ ‚Üí B) (p : P) :
    (eval‚ÇÇAlgHom f g) p = eval‚ÇÇ f g p

private lemma f_convex {x‚ÇÅ x‚ÇÇ : ‚Ñö} {Œ±‚ÇÅ Œ±‚ÇÇ : ‚Ñö}
  (h_noneg_1 : 0 ‚â§ Œ±‚ÇÅ)
  (h_noneg_2 : 0 ‚â§ Œ±‚ÇÇ)
  (h_conv : Œ±‚ÇÅ + Œ±‚ÇÇ = 1)
  :
  f (Œ±‚ÇÅ * x‚ÇÅ + Œ±‚ÇÇ * x‚ÇÇ) ‚â§ Œ±‚ÇÅ * f x‚ÇÅ + Œ±‚ÇÇ * f x‚ÇÇ

theorem add_succ (m n : ChurchNat Œ±) : add (succ m) n = succ (add m n)

theorem induction_heq {n n' : ‚Ñï} {motive : Fin (n + 1) ‚Üí Sort u} {motive' : Fin (n' + 1) ‚Üí Sort u}
    {zero : motive 0} {zero' : motive' 0}
    {succ : ‚àÄ i : Fin n, motive i.castSucc ‚Üí motive i.succ}
    {succ' : ‚àÄ i : Fin n', motive' i.castSucc ‚Üí motive' i.succ}
    {i : Fin (n + 1)} {i' : Fin (n' + 1)}
    (hn : n = n') (hmotive : HEq motive motive') (hzero : HEq zero zero')
    (hsucc : HEq succ succ') (hi : HEq i i') :
      HEq (induction (motive := motive) zero succ i)
        (induction (motive := motive') zero' succ' i')

lemma Œ≤_regular (R : F[X][X][Y])
                (H : F[X][Y]) [H_irreducible : Fact (Irreducible H)]
                {D : ‚Ñï} (hD : D ‚â• Bivariate.totalDegree H) :
    ‚àÄ t : ‚Ñï, ‚àÉ Œ≤ : ùí™ H, weight_Œõ_over_ùí™ Œ≤ ‚â§ (2 * t + 1) * Bivariate.natDegreeY R * D

theorem ofNat_toNat (n : ChurchNat ‚Ñï) : ofNat (toNat n) = n

@[simp]
theorem drop_of_succ {Œ± : Fin (n + 1) ‚Üí Sort*} (v : (i : Fin (n + 1)) ‚Üí Œ± i) :
    drop n n.le_succ v = fun i => v (Fin.cast (Nat.sub_add_cancel n.le_succ) (addNat i n))

theorem induction_append_right {m n : ‚Ñï} {motive : Fin (m + n + 1) ‚Üí Sort*} {zero : motive 0}
  {succ : ‚àÄ i : Fin (m + n), motive i.castSucc ‚Üí motive i.succ} {i : Fin (n + 1)} :
    induction zero succ (i.natAdd m) =
      @induction n (fun i => motive (i.natAdd m))
        (@induction m (fun j => motive (Fin.cast (by omega) (j.castAdd n)))
          zero (fun j x => succ (j.castAdd n) x) (last m))
        (fun i x => succ (i.natAdd m) x) i

theorem hconcat_init_self {Œ± : Fin n.succ ‚Üí Sort u} (v : (i : Fin (n + 1)) ‚Üí Œ± i) :
    True

theorem trim_equiv [LawfulBEq R] (p : UniPoly R) : equiv p.trim p

@[simp]
theorem verifier_rbrKnowledgeSoundness :
    (verifier oSpec Statement).rbrKnowledgeSoundness init impl rel rel 0

@[simp]
theorem dflatten_two_eq_append {n : Fin 2 ‚Üí ‚Ñï} {motive : (k : Fin (vsum n)) ‚Üí Sort*}
    {v : (i : Fin 2) ‚Üí (j : Fin (n i)) ‚Üí motive (embedSum i j)} :
    dflatten (motive := motive) v = dappend (v 0) (v 1)

omit [Finite R] in
theorem projection_injective
    (C : Set (n ‚Üí R))
    (nontriv : ‚ÄñC‚Äñ‚ÇÄ ‚â• 1)
    (S : Finset n)
    (hS : card S = card n - (‚ÄñC‚Äñ‚ÇÄ - 1))
    (u v : n ‚Üí R)
    (hu : u ‚àà C)
    (hv : v ‚àà C) : projection S u = projection S v ‚Üí u = v

@[simp]
theorem Set.mem_language_iff {Œ± Œ≤} (rel : Set (Œ± √ó Œ≤)) (stmt : Œ±) :
    stmt ‚àà rel.language ‚Üî ‚àÉ wit, (stmt, wit) ‚àà rel

@[simp] lemma extract_dir : pSpec‚ü¶start:stop‚üß.dir = pSpec.dir‚ü¶start:stop‚üß

theorem liftContext_soundness [Inhabited InnerStmtOut]
    {outerLangIn : Set OuterStmtIn} {outerLangOut : Set OuterStmtOut}
    {innerLangIn : Set InnerStmtIn} {innerLangOut : Set InnerStmtOut}
    {soundnessError : ‚Ñù‚â•0}
    {lens : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut}
    (V : Verifier oSpec InnerStmtIn InnerStmtOut pSpec)
    -- TODO: figure out the right compatibility relation for the IsSound condition
    [lensSound : lens.IsSound outerLangIn outerLangOut innerLangIn innerLangOut
      (V.compatStatement lens)]
    (h : V.soundness init impl innerLangIn innerLangOut soundnessError) :
      (V.liftContext lens).soundness init impl outerLangIn outerLangOut soundnessError

lemma rank_eq_rowRank : U.rank = rowRank U

lemma bwm_of_pos [NeZero n] (h : j.1 < e) :
  BerlekampWelchMatrix e k œâs f i j = -Rhs j.1 œâs f i

@[simp]
lemma mul_by_empty :
    mul_by_2 ‚àÖ = ‚àÖ

omit h_Fq_char_prime in
lemma ùîΩq_element_eq_zero_or_eq_one : ‚àÄ c: ùîΩq, c = 0 ‚à® c = 1

theorem verifier_rbrKnowledgeSoundness [Fintype R] :
    (verifier R deg D oSpec).rbrKnowledgeSoundness init impl
    (inputRelation R deg D) (outputRelation R deg) (fun _ => (deg : ‚Ñù‚â•0) / (Fintype.card R))

omit [CommSemiring ùîΩ] in
private lemma poly_eq_of [Field ùîΩ] {p q : ùîΩ[X]} {n : ‚Ñï}
      (hp : p.degree < .some n) (hq : q.degree < .some n) (s : Finset ùîΩ) :
    s.card ‚â• n ‚Üí (‚àÄ x ‚àà s, p.eval x = q.eval x) ‚Üí p = q

private lemma johnson_condition_strong_implies_2_le_B_card
  (h_johnson : JohnsonConditionStrong B v)
  :
  2 ‚â§ B.card

lemma rank_eq_colRank : U.rank = colRank U

lemma oodSampling_crs_eq_rs
    {f : Œπ ‚Üí F} {m s : ‚Ñï} {œÜ : Œπ ‚Ü™ F} [Smooth œÜ]
    (l Œ¥ : ‚Ñù‚â•0) (hŒ¥Le : Œ¥ ‚â§ 1)
    {C : Set (Œπ ‚Üí F)} (hcode : C = smoothCode œÜ m ‚àß listDecodable C Œ¥ l) :
    Pr_{ let rs ‚Üê$·µñ (Fin s ‚Üí F) }[ (‚àÉ œÉ : Fin s ‚Üí F,
                        let w : Fin s ‚Üí MvPolynomial (Fin (m + 1)) F :=
                          fun i =>
                            let ri := rs i
                            let rVec := fun j : Fin m => ri ^ (2^(j : ‚Ñï))
                            MvPolynomial.X (Fin.last m) * rename Fin.castSucc (eqPolynomial rVec)
                        let multiCRSCode := multiConstrainedCode œÜ m s w œÉ
                        ‚àÉ u u' : Œπ ‚Üí F, u ‚â† u' ‚àß
                          u ‚àà relHammingBall multiCRSCode f Œ¥ ‚àß
                          u' ‚àà relHammingBall multiCRSCode f Œ¥)]
    =
    Pr_{ let rs ‚Üê$·µñ (Fin s ‚Üí F) }[ (‚àÉ u u' : smoothCode œÜ m,
                        u.val ‚â† u'.val ‚àß
                        u.val ‚àà relHammingBall C f Œ¥ ‚àß
                        u'.val ‚àà relHammingBall C f Œ¥ ‚àß
                        ‚àÄ i : Fin s,
                          let ri := rs i
                          let rVec := fun j : Fin m => ri ^ (2^(j : ‚Ñï))
                          (mVdecode u).eval (rVec) = (mVdecode u').eval (rVec))]

omit [NeZero r] [NeZero ùì°] in
lemma isCommitmentRoundOfNonLastBlock (bIdx : Fin (‚Ñì / œë - 1)) :
    isCommitmentRound ‚Ñì œë ‚ü®‚ÜëbIdx * œë + (œë - 1), by
      have hpos: œë > 0 := by exact Nat.pos_of_neZero œë
      conv_rhs => rw [‚ÜêNat.add_zero (n:=‚Ñì)]
      change bIdx.val * œë + (‚ü®œë - 1, by omega‚ü©: Fin œë).val < ‚Ñì + 0
      apply bIdx_mul_œë_add_i_lt_‚Ñì_succ (m:=0)
    ‚ü©

lemma Z_square_mul_form
  (k : ‚Ñï)
  (prev : ConcreteBTFStepResult (k := k)) :
  letI : Field (ConcreteBTField k) := mkFieldInstance (prev.toConcreteBTFieldProps)
  letI : Field (ConcreteBTField (k + 1)) := mkFieldInstance (k:=k+1)
    (props:=liftBTFieldProps (k:=k) (prevBTFResult:=prev))
  letI : Algebra (ConcreteBTField k) (ConcreteBTField (k + 1)) :=
    instAlgebraLiftConcreteBTField k prev
  Z (k + 1) ^ 2
    = Z (k + 1)
      * (algebraMap (ConcreteBTField k) (ConcreteBTField (k + 1))) (Z k)
      + 1

@[simp]
theorem dappend_dempty {motive : Fin (m + 0) ‚Üí Sort u} (v : (i : Fin m) ‚Üí motive (castAdd 0 i)) :
    dappend (motive := motive) v !d‚ü®fun _ : Fin 0 => motive (natAdd m _)‚ü©[] = v

@[simp]
lemma length_cons (x : Œ£ Œ± : Type u, Œ±) (xs : HList) : (x ::‚Çï xs).length = xs.length + 1

omit [Fintype L] [DecidableEq L] [Fintype ùîΩq] h_Fq_char_prime in
theorem root_U_lift_down
  (i : Fin r) (h_i_add_1 : i + 1 < r) (a : L) :
  a ‚àà (U ùîΩq Œ≤ (i+1)) ‚Üí ‚àÉ! x: ùîΩq, a - x ‚Ä¢ Œ≤ i ‚àà (U ùîΩq Œ≤ i)

lemma binaryTowerAlgebra_def (l r : ‚Ñï) (h_le : l ‚â§ r) :
    @binaryAlgebraTower (l:=l) (r:=r) (h_le:=h_le)
    = (towerAlgebraMap l r h_le).toAlgebra

theorem get_drop_eq_drop_get_comp_cast {Œ± : Type*} {m : ‚Ñï} (l : List Œ±) (h : m ‚â§ l.length) :
    (l.drop m).get = drop m h l.get ‚àò Fin.cast (List.length_drop)

@[simp]
theorem dcast‚ÇÉ_trans (ha : a = a') (ha' : a' = a'')
    (hb : dcast ha b = b') (hb' : dcast ha' b' = b'')
    (hc : dcast‚ÇÇ ha hb c = c') (hc' : dcast‚ÇÇ ha' hb' c' = c'') :
    dcast‚ÇÉ ha' hb' hc' (dcast‚ÇÉ ha hb hc d) =
    dcast‚ÇÉ (ha.trans ha') (by simp [‚Üê hb', ‚Üê hb]) (by simp [‚Üê hc', ‚Üê hc]) d

@[simp]
theorem oracleVerifier_rbrKnowledgeSoundness (hRel : ‚àÄ stmtIn oStmtIn witOut,
      ((mapStmt stmtIn, mapOStmt embedIdx hEq oStmtIn), witOut) ‚àà relOut ‚Üí
      ((stmtIn, oStmtIn), mapWitInv (stmtIn, oStmtIn) witOut) ‚àà relIn) :
    (oracleVerifier oSpec mapStmt embedIdx hEq).rbrKnowledgeSoundness init impl relIn relOut 0

omit [Finite F] in
lemma D_def : D = evalDomain D 0

theorem toImpl_toPoly [LawfulBEq R] (p : UniPoly R) : p.toPoly.toImpl = p.trim

private lemma oddPart_eq_oddPart' {f : Polynomial F} : oddPart f = oddPart' f

@[simp]
lemma cons_empty_tail_eq_nil {Œ±} (hd : Œ±) (tl : Vector Œ± 0) :
    cons hd tl = ‚ü®#[hd], rfl‚ü©

lemma zipWith_size {R} {f : R ‚Üí R ‚Üí R} {a b : Array R} (h : a.size = b.size) :
    (Array.zipWith f a b).size = a.size

theorem cast_eq_dcast {h : n‚ÇÅ = n‚ÇÇ} {pSpec : ProtocolSpec n‚ÇÅ} :
    pSpec.cast h = dcast h pSpec

@[simp]
lemma toFun_invFun (f : ‚àÄ a, Œ≤ a) : inst.equiv.toFun (equiv.invFun f : F) = f

@[simp]
lemma append_zero_of_succ_left {u : Fin (m + 1) ‚Üí Œ±} {v : Fin n ‚Üí Œ±} :
    (append u v) 0 = u 0

private lemma solutionToQ_from_Q
  (h_p_deg : p.natDegree < k)
  (h_dist : (Œî‚ÇÄ(f, p.eval ‚àò œâs) : ‚Ñï) ‚â§ e)
  : solutionToQ e k (E_and_Q_to_a_solution e (E œâs f p e) (Q œâs f p e)) = Q œâs f p e

@[simp]
lemma oddPart_by_2 :
    2 * (oddPart f) = (f - f.comp (-X)) /‚Çò X

theorem OracleVerifier.liftContext_toVerifier_comm
    {lens : OracleStatement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                              OuterOStmtIn OuterOStmtOut InnerOStmtIn InnerOStmtOut}
    {V : OracleVerifier oSpec InnerStmtIn InnerOStmtIn InnerStmtOut InnerOStmtOut pSpec} :
      (V.liftContext lens).toVerifier = V.toVerifier.liftContext lens

lemma getLowBits_lt_two_pow {n : ‚Ñï} (numLowBits : ‚Ñï) :
    getLowBits numLowBits n < 2 ^ numLowBits

@[simp]
lemma seqCompose_succ {m : ‚Ñï} (Stmt : Fin (m + 2) ‚Üí Type)
    {n : Fin (m + 1) ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (V : (i : Fin (m + 1)) ‚Üí Verifier oSpec (Stmt i.castSucc) (Stmt i.succ) (pSpec i)) :
    seqCompose Stmt V = append (V 0) (seqCompose (Stmt ‚àò Fin.succ) (fun i => V (Fin.succ i)))

private lemma comp_x_square_coeff_pos_deg {f : Polynomial F} {n : ‚Ñï} (h : 0 < f.degree) :
  (f.comp (X * X)).coeff n = if Even n then f.coeff (n / 2) else 0

theorem coeff_eq_coeff [LawfulBEq R] (p : UniPoly R) (i : ‚Ñï) :
  p.trim.coeff i = p.coeff i

lemma concrete_mul_zero0 (a : ConcreteBTField 0) :
  concrete_mul a (zero (k:=0)) = zero (k:=0)

@[simp]
theorem zero_dappend {motive : Fin (0 + n) ‚Üí Sort u} {u : (i : Fin 0) ‚Üí motive (castAdd n i)}
    (v : (i : Fin n) ‚Üí motive (natAdd 0 i)) :
    dappend (motive := motive) u v = fun i => cast (by simp) (v (i.cast (by omega)))

private lemma BerlekampWelchCondition_to_Solution' [NeZero n]
  (h : BerlekampWelchCondition e k œâs f (solutionToE e k v) (solutionToQ e k v))
  : IsBerlekampWelchSolution e k œâs f v

theorem fcons_injective2 {Œ≤ : Fin n ‚Üí A} :
    Function.Injective2 (@fcons A F n Œ± Œ≤)

theorem relayOracleReduction_perfectCompleteness (hInit : init.neverFails) (i : Fin ‚Ñì)
    (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
    OracleReduction.perfectCompleteness
      (pSpec := pSpecRelay)
      (relIn := foldStepRelOut (mp := mp) ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        (ùìë := ùìë) i)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        (ùìë := ùìë) i.succ)
      (oracleReduction := relayOracleReduction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        i hNCR)
      (init := init)
      (impl := impl)

theorem add_coeff? (p q : UniPoly Q) (i : ‚Ñï) :
  (add_raw p q).coeff i = p.coeff i + q.coeff i

private lemma johnson_unrefined_by_M' [Zero F]
  (h_n : 0 < n)
  (h_B : 2 ‚â§ B.card)
  (h_card : 2 ‚â§ (Fintype.card F))
  :
  B.card * (Fintype.card F / (Fintype.card F - 1)) *
           ((1 - e B 0 / n) ^ 2  + e B 0 ^ 2 / ((Fintype.card F - 1) * n^2) - 1 + d B/n)
  ‚â§
  (Fintype.card F / (Fintype.card F - 1)) * d B/n

Nat.le_of_succ_le in Init.Data.Nat.Basic

@[simp]
theorem dcast_trans (h : a = a') (h' : a' = a'') :
    dcast h' (dcast h b) = dcast (h.trans h') b

lemma sum_of_and_eq_zero_is_xor {n m : ‚Ñï} (h_n_AND_m : n &&& m = 0) : n + m = n ^^^ m

@[simp]
theorem dconcat_last {motive : Fin (n + 1) ‚Üí Sort u} (v : (i : Fin n) ‚Üí motive (castSucc i))
    (a : motive (last n)) : (v :+·µà‚ü®motive‚ü© a) (last n) = a

theorem mapM_single (f : Œ± ‚Üí m Œ≤) (a : Œ±) : List.mapM f [a] = return [‚Üê f a]

@[simp]
protected lemma elocPolyF_leading_coeff_one {œâs f : Fin n ‚Üí F}
  : (ElocPolyF œâs f p).leadingCoeff = 1

@[simp]
theorem rtake_append_right :
    (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).rtake n (Nat.le_add_left n m) = pSpec‚ÇÇ

lemma polynomialOfCoeffs_coeffsOfPolynomial {p : F[X]}
  (h : p.natDegree + 1 = deg) : polynomialOfCoeffs (coeffsOfPolynomial (deg := deg) p) = p

lemma relHammingDist_le_blockRelDistance
  (i k : ‚Ñï) {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F} {œÜ' : (indexPowT S œÜ i) ‚Ü™ F}
  [DecidableEq F] [DecidableEq Œπ] [Smooth œÜ]
  (f g : (indexPowT S œÜ i) ‚Üí F) (S' : Finset (indexPowT S œÜ i))
  [h_fintype : ‚àÄ i : ‚Ñï, Fintype (indexPowT S œÜ i)]
  [DecidableEq (indexPowT S œÜ i)] [Smooth œÜ']
  [h_dec : DecidableBlockDisagreement i k f S' œÜ'] :
  Œ¥·µ£(f, g) ‚â§ Œî·µ£(i, k, f, S', œÜ', g)

lemma qMap_total_fiber_repr_coeff (i : Fin ‚Ñì) (steps : ‚Ñï) (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
    (y : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i.val + steps, by omega‚ü©))
    (k : Fin (2 ^ steps)) :
    let x := qMap_total_fiber ùîΩq Œ≤ (i := ‚ü®i, by omega‚ü©)
      (steps := steps)
      (h_i_add_steps := by simp only; exact fin_‚Ñì_steps_lt_‚Ñì_add_R i steps h_i_add_steps) (y := y) k
    let basis_y := sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i.val + steps, by omega‚ü©)
      (h_i := by simp only; exact fin_‚Ñì_steps_lt_‚Ñì_add_R i steps h_i_add_steps)
    let y_coeffs := basis_y.repr y
    ‚àÄ j, -- j refers to bit index of the fiber point x
      ((sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i, by omega‚ü©) (by simp only; omega)).repr x) j
      = fiber_coeff (i := i) (steps := steps) (j := j) (elementIdx := k)
        (y_coeffs := y_coeffs)

lemma fold_f_g_poly
  {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F} {k m : ‚Ñï}
  {œÜ_0 : (indexPowT S œÜ 0) ‚Ü™ F} {œÜ_k : (indexPowT S œÜ k) ‚Ü™ F}
  [Fintype (indexPowT S œÜ 0)] [DecidableEq (indexPowT S œÜ 0)] [Smooth œÜ_0]
  [Fintype (indexPowT S œÜ k)] [DecidableEq (indexPowT S œÜ k)] [Smooth œÜ_k]
  [‚àÄ i : ‚Ñï, Neg (indexPowT S œÜ i)]
  (Œ±s : Fin k ‚Üí F) (hk : k ‚â§ m)
  (f : smoothCode œÜ_0 m) (g : smoothCode œÜ_k (m-k)) :
  let fPoly

Fin.isLt in Init.Prelude

@[simp]
lemma finite_possibleDeltas : (possibleDeltas U V).Finite

theorem distanceLE_polynomial_degreeLE : distanceLE (R‚¶É‚â§ d‚¶Ñ[X]) d

theorem mul_two_eq_add {a : CNat 50} : a * 2 = a + a

theorem foldOracleReduction_perfectCompleteness (hInit : init.neverFails) (i : Fin ‚Ñì) :
    OracleReduction.perfectCompleteness
      (pSpec := pSpecFold (L := L))
      (relIn := roundRelation ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        (ùìë := ùìë) i.castSucc (mp := mp))
      (relOut := foldStepRelOut ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        (ùìë := ùìë) i (mp := mp))
      (oracleReduction := foldOracleReduction ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i)
      (init := init)
      (impl := impl)

@[simp] theorem rightpadPowerOfTwo_size (unit : Œ±) (a : Array Œ±) :
    (a.rightpadPowerOfTwo unit).size = 2 ^ (Nat.clog 2 a.size)

@[simp]
theorem vconcat_zero (a : Œ±) : vconcat !v[] a = !v[a]

Fin.coe_castSucc in Init.Data.Fin.Lemmas

@[simp]
theorem distanceLE_polynomial_degreeLT : distanceLE (R‚¶É< d‚¶Ñ[X]) (d - 1)

omit hF‚ÇÇ in
theorem W_linear_comp_decomposition (i : Fin r) (h_i_add_1 : i + 1 < r) :
    ‚àÄ p: L[X], (W ùîΩq Œ≤ (i + 1)).comp p =
      ((W ùîΩq Œ≤ i).comp p) ^ Fintype.card ùîΩq -
        C (eval (Œ≤ i) (W ùîΩq Œ≤ i)) ^ (Fintype.card ùîΩq - 1) * ((W ùîΩq Œ≤ i).comp p)

theorem eq_join_via_add_smul_eq_iff_split (k : ‚Ñï) (h_pos : k > 0)
    (x : BTField k) (hi_btf lo_btf : BTField (k - 1)) :
    x = ‚ãò hi_btf, lo_btf ‚ãô ‚Üî
  split (k:=k) (h_k:=h_pos) x = (hi_btf, lo_btf)

theorem johnson_bound [Field F]
  (h_condition : JohnsonConditionStrong B v)
  :
  let d := d B
  let q : ‚Ñö := Fintype.card F
  let frac := q / (q - 1)
  B.card ‚â§ (frac * d/n) / JohnsonDenominator B v

@[simp]
theorem leftpad_apply_ge (n : ‚Ñï) (a : Œ±) (v : Fin m ‚Üí Œ±) (i : Fin n)
    (h : n - m ‚â§ i.val) : leftpad n a v i = v ‚ü®i.val - (n - m), by omega‚ü©

@[simp]
lemma two_mul_inv_two : (2 : F) * 2‚Åª¬π = 1

theorem unique_linear_decomposition_succ (k : ‚Ñï) :
  letI : Algebra (ConcreteBTField k) (ConcreteBTField (k+1)) :=
    ConcreteBTFieldAlgebra (l:=k) (r:=k+1) (h_le:=by omega)
  ‚àÄ (x : ConcreteBTField (k+1)), ‚àÉ! (p : ConcreteBTField k √ó ConcreteBTField k),
    x = join_via_add_smul (k+1) (by omega) p.1 p.2

omit [Fintype ùîΩq] h_Fq_char_prime hŒ≤_lin_indep in
lemma eval_W_eq_zero_iff_in_U (i : Fin r) (a : L) :
  (W ùîΩq Œ≤ i).eval a = 0 ‚Üî a ‚àà U ùîΩq Œ≤ i

omit [DecidableEq L] [DecidableEq ùîΩq] h_Fq_char_prime hF‚ÇÇ hŒ≤_lin_indep h_Œ≤‚ÇÄ_eq_1 in
theorem intermediateNormVpoly_comp (i : Fin ‚Ñì) (k : Fin (‚Ñì - i + 1))
  (l : Fin (‚Ñì - (i.val + k.val) + 1)) :
  intermediateNormVpoly ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i, by omega‚ü©) (k:=‚ü®k + l, by
      simp only; omega‚ü©) =
    (intermediateNormVpoly ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i+k, by omega‚ü©) (k:=‚ü®l, by
      simp only; omega‚ü©)).comp (
  intermediateNormVpoly ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i, by omega‚ü©) (k:=‚ü®k, by
      simp only; omega‚ü©)
  )

theorem non_zero_map [LawfulBEq R] (f : R ‚Üí R) (hf : ‚àÄ r, f r = 0 ‚Üí r = 0) (p : UniPoly R) :
  let fp := UniPoly.mk (p.map f);
  p.trim = p ‚Üí fp.trim = fp

lemma folding_preserves_listdecoding_base_ne_subset
  {S : Finset Œπ} {k m : ‚Ñï} (hm : 1 ‚â§ m) {œÜ : Œπ ‚Ü™ F} [Smooth œÜ] {Œ¥ : ‚Ñù‚â•0}
  {S_0 : Finset (indexPowT S œÜ 0)} {S_1 : Finset (indexPowT S œÜ 1)}
  {œÜ_0 : (indexPowT S œÜ 0) ‚Ü™ F} {œÜ_1 : (indexPowT S œÜ 1) ‚Ü™ F}
  [‚àÄ i : ‚Ñï, Fintype (indexPowT S œÜ i)] [‚àÄ i : ‚Ñï, DecidableEq (indexPowT S œÜ i)]
  [Smooth œÜ_0] [Smooth œÜ_1]
  [h : ‚àÄ {f : (indexPowT S œÜ 0) ‚Üí F}, DecidableBlockDisagreement 0 k f S_0 œÜ_0]
  [h : ‚àÄ {f : (indexPowT S œÜ 1) ‚Üí F}, DecidableBlockDisagreement 1 k f S_1 œÜ_1]
  [‚àÄ i : ‚Ñï, Neg (indexPowT S œÜ i)]
  {C : Set ((indexPowT S œÜ 0) ‚Üí F)} (hcode : C = smoothCode œÜ_0 m)
  (C' : Set ((indexPowT S œÜ 1) ‚Üí F)) (hcode' : C' = smoothCode œÜ_1 (m-1))
  {BStar : (Set (indexPowT S œÜ 1 ‚Üí F)) ‚Üí ‚Ñï ‚Üí ‚Ñù‚â•0}
  {errStar : (Set (indexPowT S œÜ 1 ‚Üí F)) ‚Üí ‚Ñï ‚Üí ‚Ñù‚â•0 ‚Üí ‚Ñù‚â•0} :
    Pr_{let Œ± ‚Üê$·µñ F}[ ‚àÄ { f : (indexPowT S œÜ 0) ‚Üí F} (hŒ¥Le: Œ¥ ‚â§ 1 - (BStar C' 2)),
                      let listBlock : Set ((indexPowT S œÜ 0) ‚Üí F) := Œõ·µ£(0, k, f, S_0, C, hcode, Œ¥)
                      let vec_Œ± : Fin 1 ‚Üí F := (fun _ : Fin 1 => Œ±)
                      let foldSet := fold_k_set listBlock vec_Œ± hm
                      let fold := fold_k f vec_Œ± hm
                      let listBlock' : Set ((indexPowT S œÜ 1) ‚Üí F)
                        := Œõ·µ£(1, k, fold, S_1, C', hcode', Œ¥)
                      ¬¨ (listBlock' ‚äÜ foldSet)
                    ] < errStar C' 2 Œ¥

lemma num_eq_highBits_xor_lowBits {n: ‚Ñï} (numLowBits: ‚Ñï) :
  n = getHighBits numLowBits n ^^^ getLowBits numLowBits n

theorem prime_19 : Nat.Prime 19

@[simp]
lemma lt_add_of_pos_right_of_le (a b c : ‚Ñï) [NeZero c] (h : a ‚â§ b) : a < b + c

@[simp]
lemma finite_possibleRelHammingDistsToCode [Nonempty Œπ] [DecidableEq F] :
  (possibleDistsToCode w C relHammingDist).Finite

lemma odd_index_intermediate_novel_basis_decomposition
    (i : Fin ‚Ñì) (j : Fin (2 ^ (‚Ñì - i - 1))) :
    intermediateNovelBasisX ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i, by omega‚ü© ‚ü®j * 2 + 1, by
      apply mul_two_add_bit_lt_two_pow j (‚Ñì-i-1) (‚Ñì-i) ‚ü®1, by omega‚ü© (by omega) (by omega)
    ‚ü©  = X * (intermediateNovelBasisX ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i+1, by omega‚ü© ‚ü®j, by
      apply lt_two_pow_of_lt_two_pow_exp_le j (‚Ñì-i-1) (‚Ñì-(i+1)) (by omega) (by omega)
    ‚ü©).comp (qMap ùîΩq Œ≤ ‚ü®i, by omega‚ü©)

lemma deevenize_comp_x_squared {f : Polynomial F} (hEven : EvenPoly f) :
    (deevenize f).comp (Polynomial.X * Polynomial.X) = f

@[simp]
theorem cast_completeness (Œµ : ‚Ñù‚â•0) (hComplete : R.completeness init impl relIn relOut Œµ) :
    (R.cast hn hSpec).completeness init impl relIn relOut Œµ

@[simp]
theorem vcons_of_one (a : Œ±) {i : Fin 1} : !v[a] i = match i with

lemma runWithOracle_buildMerkleTree {s} (leaf_data_tree : LeafData Œ± s) (f) :
    (runWithOracle f (buildMerkleTree leaf_data_tree))
    = buildMerkleTree_with_hash leaf_data_tree fun (left right : Œ±) =>
      (f () ‚ü®left, right‚ü©)

theorem liftContext_rbr_knowledgeSoundness [Inhabited InnerStmtOut] [Inhabited InnerWitIn]
    {outerRelIn : Set (OuterStmtIn √ó OuterWitIn)} {outerRelOut : Set (OuterStmtOut √ó OuterWitOut)}
    {innerRelIn : Set (InnerStmtIn √ó InnerWitIn)} {innerRelOut : Set (InnerStmtOut √ó InnerWitOut)}
    {rbrKnowledgeError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    {stmtLens : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut}
    {witLens : Witness.InvLens OuterStmtIn OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    (V : Verifier oSpec InnerStmtIn InnerStmtOut pSpec)
    [lensKS : Extractor.Lens.IsKnowledgeSound outerRelIn innerRelIn outerRelOut innerRelOut
      (V.compatStatement stmtLens) (fun _ _ => True) ‚ü®stmtLens, witLens‚ü©]
    (h : V.rbrKnowledgeSoundness init impl innerRelIn innerRelOut rbrKnowledgeError) :
      (V.liftContext stmtLens).rbrKnowledgeSoundness init impl outerRelIn outerRelOut
        rbrKnowledgeError

@[simp]
theorem drop_one {Œ± : Fin (n + 1) ‚Üí Sort*} (v : (i : Fin (n + 1)) ‚Üí Œ± i) :
    drop 1 (Nat.le_add_left 1 n) v = tail v

@[simp]
theorem dcast‚ÇÇ_eq' (h : a = a) (h' : dcast h b = b) : dcast‚ÇÇ h h' c = c

lemma probOfBadPts {deg : ‚Ñï} {Œ± : Œπ ‚Ü™ F} {e : ‚Ñï} {U : Matrix Œ∫ Œπ F}
  (he : (e : ‚Ñö) < (Code.minDist (RScodeSet Œ± deg) : ‚Ñö) / 3)
  (hU : e < Œî(U, matrixSubmoduleOfLinearCode Œ∫ (ReedSolomon.code Œ± deg))) :
  (PMF.uniformOfFintype (Matrix.rowSpan U)).toOuterMeasure
    { w | distFromCode (n := Œπ) (R := F) w (ReedSolomon.code Œ± deg) ‚â§ e }
  ‚â§ (Code.minDist (RScodeSet Œ± deg) : ‚Ñù‚â•0) /(Fintype.card F : ‚Ñù‚â•0)

omit [NoZeroDivisors ùîΩ] in
lemma foldNth_degree_le {n : ‚Ñï} {f : ùîΩ[X]} {Œ± : ùîΩ} [inst : NeZero n] :
    (foldNth n f Œ±).natDegree ‚â§ f.natDegree / n

theorem fconcat‚ÇÇ_inj {Œ±‚ÇÅ : Fin n ‚Üí A} {Œ±‚ÇÇ : Fin n ‚Üí B} {Œ≤‚ÇÅ : A} {Œ≤‚ÇÇ : B}
    (v‚ÇÅ v‚ÇÇ : (i : Fin n) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i)) (a‚ÇÅ a‚ÇÇ : F‚ÇÇ Œ≤‚ÇÅ Œ≤‚ÇÇ) :
    fconcat‚ÇÇ (F := F‚ÇÇ) v‚ÇÅ a‚ÇÅ = fconcat‚ÇÇ (F := F‚ÇÇ) v‚ÇÇ a‚ÇÇ ‚Üî v‚ÇÅ = v‚ÇÇ ‚àß a‚ÇÅ = a‚ÇÇ

lemma guruswami_sudan_for_proximity_gap_existence {k m : ‚Ñï} {œâs : Fin n ‚Ü™ F} {f : Fin n ‚Üí F} :
  ‚àÉ Q, Condition (k + 1) m ((proximity_gap_degree_bound ((k + 1 : ‚Ñö) / n) m n)) œâs f Q

lemma oodSampling_rs_le_bound
    {f : Œπ ‚Üí F} {m s : ‚Ñï} {œÜ : Œπ ‚Ü™ F} [Smooth œÜ]
    (Œ¥ l : ‚Ñù‚â•0) (hŒ¥Le : Œ¥ ‚â§ 1)
    (C : Set (Œπ ‚Üí F)) (hcode : C = smoothCode œÜ m ‚àß listDecodable C Œ¥ l) :
    Pr_{ let rs ‚Üê$·µñ (Fin s ‚Üí F) }[ ‚àÉ u u' : smoothCode œÜ m,
                        u.val ‚â† u'.val ‚àß
                        u.val ‚àà relHammingBall C f Œ¥ ‚àß
                        u'.val ‚àà relHammingBall C f Œ¥ ‚àß
                        ‚àÄ i : Fin s,
                          let ri := rs i
                          let rVec := fun j : Fin m => ri ^ (2^(j : ‚Ñï))
                          (mVdecode u).eval (rVec) = (mVdecode u').eval (rVec)
                      ] ‚â§ ENNReal.ofReal (((l : ‚Ñù)^2 / 2) * (((2^m : ‚Ñù) / Fintype.card F)^s))

theorem lt_iff_toNat_lt (a b : AssocNat) : a < b ‚Üî toNat a < toNat b

@[simp]
theorem runWithOracle_freeMonad_pure_none (f : spec.FunctionType) :
    runWithOracle f (FreeMonad.pure (none : Option Œ±)) = none

@[simp]
protected lemma elocPolyF_eq_elocPoly' {œâs f : Fin n ‚Üí F} :
  ElocPolyF œâs f p = ElocPoly n (liftF œâs) (liftF f) p

theorem mul_assoc (m n p : ChurchNat Œ±) : mul (mul m n) p = mul m (mul n p)

private lemma evenPart_eq_evenPart' {f : Polynomial F} : evenPart f = evenPart' f

theorem trim_toImpl [LawfulBEq R] (p : R[X]) : p.toImpl.trim = p.toImpl

theorem two_eq_zero_in_char2_field {F : Type*} [Field F]
  (sumZeroIffEq : ‚àÄ (x y : F), x + y = 0 ‚Üî x = y) : (2 : F) = 0

lemma mca_rsc
  [DecidableEq Œπ]
  (Œ± : F) (œÜ : Œπ ‚Ü™ F) (m : ‚Ñï) [Smooth œÜ]
  (par‚Ñì_type : Type) [Fintype par‚Ñì_type] (exp : par‚Ñì_type ‚Ü™ ‚Ñï) :
  let Gen := RSGenerator.genRSC par‚Ñì_type œÜ m exp
  let : Fintype Gen.par‚Ñì := Gen.h‚Ñì
  hasMutualCorrAgreement
    -- Generator
    Gen
    -- BStar
    ((1 + Gen.rate) / 2)
    -- errStar
    (fun Œ¥ => ENNReal.ofReal
        ((Fintype.card par‚Ñì_type - 1) * (2^m / (Gen.rate * (Fintype.card F)))))

theorem dconcat_dcons_eq_dcons_dconcat {motive : Fin (n + 2) ‚Üí Sort u} (a : motive 0)
    (v : (i : Fin n) ‚Üí motive (succ (castSucc i))) (b : motive (last (n + 1))) :
    (a ::·µà v) :+·µà‚ü®motive‚ü© b = a ::·µà‚ü®motive‚ü© (v :+·µà b)

lemma forwardRange_pred_le_ne_empty (n : ‚Ñï) (r : Fin n) (l : Fin (r.val + 1))
    (h_l_gt_0 : l.val > 0) : forwardRange n r ‚ü®l.val - 1, by omega‚ü© ‚â† []

Fin.is_le in Init.Data.Fin.Lemmas

private lemma natDegree_Q
  (h : (Œî‚ÇÄ(f, p.eval ‚àò œâs) : ‚Ñï) ‚â§ e) :
  (Q œâs f p e).natDegree ‚â§ e + p.natDegree

@[csimp] lemma dfoldl_eq_dfoldl' : @dfoldl = @dfoldl'

lemma rank_eq_if_det_ne_zero {U : Matrix (Fin n) (Fin n) F} [IsDomain F] :
  Matrix.det U ‚â† 0 ‚Üí U.rank = n

@[simp]
theorem seqCompose_one {n : Fin 1 ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)} :
    seqCompose pSpec = pSpec 0

@[simp]
lemma range_def : (spec Œ±).range () = Œ±

lemma definingPoly_coeffOf0 {F : Type*} [Field F] [Fintype F] (s : F) [NeZero s] :
    (definingPoly s).coeff 0 = 1

@[simp]
lemma OracleVerifier.append_toVerifier
    (V‚ÇÅ : OracleVerifier oSpec Stmt‚ÇÅ OStmt‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : OracleVerifier oSpec Stmt‚ÇÇ OStmt‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ pSpec‚ÇÇ) :
      (OracleVerifier.append V‚ÇÅ V‚ÇÇ).toVerifier =
        Verifier.append V‚ÇÅ.toVerifier V‚ÇÇ.toVerifier

@[simp]
lemma Rhs_add_one : Rhs (e + 1) œâs f = fun i ‚Ü¶ Rhs e œâs f i * œâs i

theorem leftpad_eq_self (v : Fin n ‚Üí Œ±) (a : Œ±) : leftpad n a v = v

@[simp]
theorem Ici_zero : Ici (0 : Fin (n + 1)) = univ

theorem insertNth_support :
    (insertNth p y s).support ‚äÜ insert p (s.support.map (Fin.succAboveEmb p))

theorem sum_zero_iff_eq_of_self_sum_zero {F : Type*} [AddGroup F]
  (h_self_sum_eq_zero : ‚àÄ (x : F), x + x = 0) : ‚àÄ (x y : F), x + y = 0 ‚Üî x = y

@[simp] theorem toNat_mul (a b : AssocNat) : toNat (mul a b) = toNat a * toNat b

lemma even_eval {f : Polynomial F} {s : F} (hEven : EvenPoly f) :
  f.eval (-s) = f.eval s

omit [NeZero ‚Ñì] [NeZero r] [NeZero ùì°] in
lemma fin_‚Ñì_lt_‚Ñì_add_R (i : Fin ‚Ñì)
    : i.val < ‚Ñì + ùì°

theorem join_zero_one {k : ‚Ñï} (h_k : k > 0) :
    „Ää zero (k:=k - 1), one (k:=k - 1) „Äã = one (k:=k)

lemma lin_shift_card [Field F] [Fintype F]
  :
  B.card = ({ x - v | x ‚àà B} : Finset _).card

private lemma oddPart_eq_oddPart'_aux' {f : Polynomial F}
  : (f - f.comp (-Polynomial.X)) = (Polynomial.C 2) * x_times_oddPart' f

@[simp, grind] lemma R_le_N : sz.R ‚â§ sz.N

lemma concrete_mul_right_distrib
  {h_k : k > 0} (prevBTFieldProps : ConcreteBTFieldProps (k := k - 1))
  (a b c : ConcreteBTField k) :
    concrete_mul (a + b) c = concrete_mul a c + concrete_mul b c

lemma neg_add_cancel {k : ‚Ñï} (a : ConcreteBTField k) : neg a + a = 0

theorem happend_singleton {Œ± : Fin m ‚Üí Sort u} {Œ≤ : Sort u} (u : (i : Fin m) ‚Üí Œ± i) (a : Œ≤) :
    True

@[simp]
theorem cast_run (stmt : StmtIn) (transcript : FullTranscript pSpec‚ÇÅ) :
    V.run stmt transcript = (V.cast hn hSpec).run stmt (transcript.cast hn hSpec)

omit [Finite F] in
lemma dom_n_eq_triv : evalDomain D x n = {x ^ (2 ^ n)}

lemma getBit_of_binaryFinMapToNat {n : ‚Ñï} (m : Fin n ‚Üí ‚Ñï) (h_binary: ‚àÄ j: Fin n, m j ‚â§ 1) :
    ‚àÄ k: ‚Ñï, Nat.getBit k (binaryFinMapToNat m h_binary).val
      = if h_k: k < n then m ‚ü®k, by omega‚ü© else 0

theorem lagrangeToMonoLevel_monoToLagrangeLevel_id (v : Vector R (2 ^ n)) (i : Fin n) :
  lagrangeToMonoLevel i (monoToLagrangeLevel i v) = v

theorem happend_assoc {Œ± : Fin m ‚Üí Sort u} {Œ≤ : Fin n ‚Üí Sort u} {p : ‚Ñï} {Œ≥ : Fin p ‚Üí Sort u}
    (u : (i : Fin m) ‚Üí Œ± i) (v : (i : Fin n) ‚Üí Œ≤ i) (w : (i : Fin p) ‚Üí Œ≥ i) :
    happend (happend u v) w =
      fun i => cast (by simp [vappend_assoc])
        (happend u (happend v w) (i.cast (by omega)))

@[simp]
protected lemma elocPoly_zero : ElocPoly 0 œâs f p = 1

@[simp]
theorem induction_two {motive : Fin 3 ‚Üí Sort*} {zero : motive 0}
    {succ : ‚àÄ i : Fin 2, motive i.castSucc ‚Üí motive i.succ} :
      induction (motive := motive) zero succ (last 2) = succ 1 (succ 0 zero)

theorem and_highBits_lowBits_eq_zero {n : ‚Ñï} (numLowBits : ‚Ñï) :
    getHighBits numLowBits n &&& getLowBits numLowBits n = 0

@[simp]
theorem fflatten_embedSum {A : Sort u} {F : A ‚Üí Sort v} {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï}
    {Œ± : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí A}
    (v : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí F (Œ± i j)) (i : Fin m) (j : Fin (n i)) :
    fflatten v (embedSum i j) = cast (by simp) (v i j)

@[simp]
theorem BTField.Basis_cast_dest_apply {Œπ : Type*} (Œ± Œ≤ Œ≥ : ‚Ñï) (h_le1 : Œ± ‚â§ Œ≤) (h_le2 : Œ± ‚â§ Œ≥)
    (h_eq : Œ≤ = Œ≥) {k : Œπ} (b : @Basis Œπ (BTField Œ±) (BTField Œ≤) _ _
    (@binaryAlgebraTower (l := Œ±) (r := Œ≤) (h_le := h_le1)).toModule) :
    let castBasis : @Basis Œπ (BTField Œ±) (BTField Œ≥) _ _
      (@binaryAlgebraTower (l := Œ±) (r := Œ≥) (h_le := h_le2)).toModule :=
      cast (by
        exact Basis_cast_dest_eq Œ± Œ≥ Œ≤ h_le2 h_le1 h_eq
      ) b
    (castBasis k) = cast (by exact BTField.cast_BTField_eq Œ≤ Œ≥ h_eq) (b k)

theorem evaluation_poly_split_identity (i : Fin (‚Ñì))
    (coeffs : Fin (2 ^ (‚Ñì - i)) ‚Üí L) :
  let P_i: L[X] := intermediateEvaluationPoly ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i, by omega‚ü© coeffs
  let P_even_i_plus_1: L[X] := evenRefinement ùîΩq Œ≤ h_‚Ñì_add_R_rate i coeffs
  let P_odd_i_plus_1: L[X] := oddRefinement ùîΩq Œ≤ h_‚Ñì_add_R_rate i coeffs
  let q_i: L[X] := qMap ùîΩq Œ≤ ‚ü®i, by omega‚ü©
  P_i = (P_even_i_plus_1.comp q_i) + X * (P_odd_i_plus_1.comp q_i)

lemma Fin.le_iff_lt_succ (a b : Fin r) (h_b : b + 1 < r) : a ‚â§ b ‚Üî a < b + 1

@[simp]
theorem dconcat_zero {motive : Fin 1 ‚Üí Sort u} (a : motive (last 0)) :
    !d‚ü®fun _ : Fin 0 => motive (castSucc _)‚ü©[] :+·µà‚ü®motive‚ü© a = !d‚ü®motive‚ü©[a]

theorem canonical_ext [LawfulBEq R] {p q : UniPoly R} (hp : p.trim = p) (hq : q.trim = q) :
    equiv p q ‚Üí p = q

theorem singleton_bound (C : Set (n ‚Üí R)) :
    (ofFinite C).card ‚â§ (ofFinite R).card ^ (card n - (‚ÄñC‚Äñ‚ÇÄ - 1))

private lemma solutionToE_from_E
  (h_p_deg : p.natDegree < k)
  (h_dist : (Œî‚ÇÄ(f, p.eval ‚àò œâs) : ‚Ñï) ‚â§ e)
  : solutionToE e k (E_and_Q_to_a_solution e (E œâs f p e) (Q œâs f p e)) = E œâs f p e

lemma twoAdicGenerator_unit_mem_rootsOfUnity
    (bits : Fin (twoAdicity + 1)) (h : twoAdicGenerators[bits] ‚â† 0) :
    Units.mk0 (twoAdicGenerators[bits]) h ‚àà rootsOfUnity (2 ^ (bits : Nat)) (Field)

theorem unique_linear_decomposition_succ (k : ‚Ñï) :
  ‚àÄ (x : BTField (k+1)), ‚àÉ! (p : BTField k √ó BTField k),
    x = ‚ãò p.1, p.2 ‚ãô

lemma trim_add_trim [LawfulBEq R] (p q : UniPoly R) : p.trim + q = p + q

theorem hconcat_hcons {Œ± : Sort u} {Œ≤ : Fin n ‚Üí Sort u} {Œ≥ : Sort u} (a : Œ±) (v : (i : Fin n) ‚Üí Œ≤ i) (c : Œ≥) :
    True

private lemma almost_johnson_lhs_div_B_card [Zero F]
  (h_n : 0 < n)
  (h_B : 2 ‚â§ B.card)
  :
  (k B * (k B - 1)  +
    (B.card - k B) * ((B.card - k B)/(Fintype.card F - 1) - 1)) / B.card
  =
  (1 - e B 0 / n) ^ 2 * B.card + B.card * (e B 0) ^ 2 / ((Fintype.card F - 1) * n^2) - 1

theorem decoder_eq_some {e k : ‚Ñï} [NeZero n] {œâs f : Fin n ‚Üí F} {p : Polynomial F}
  (he : 2 * e < n - k + 1)
  (hn : k ‚â§ n)
  (h_inj : Function.Injective œâs)
  (h_deg : p.natDegree < k)
  (h_dist : Œî‚ÇÄ(f, p.eval ‚àò œâs) ‚â§ e)
  : decoder e k œâs f = some p

@[simp]
theorem dempty_dappend {motive : Fin (0 + n) ‚Üí Sort u} (v : (i : Fin n) ‚Üí motive (natAdd 0 i)) :
    dappend (motive := motive) !d‚ü®fun _ : Fin 0 => motive (castAdd n _)‚ü©[] v =
      fun i => cast (by simp) (v (i.cast (by omega)))

@[simp]
theorem vempty_vappend (v : Fin n ‚Üí Œ±) : vappend !v[] v = v ‚àò Fin.cast (Nat.zero_add n)

theorem BitVec.dcast_bitvec_eq_zero {l r : ‚Ñï} (h_width_eq : l = r) :
  dcast (h_width_eq) 0#(l) = 0#(r)

@[simp]
lemma degree_polynomialOfCoeffs_deg_lt_deg :
  (polynomialOfCoeffs coeffs).degree < deg

lemma normalizedW_eq_qMap_composition (‚Ñì R_rate : ‚Ñï) (i : Fin r) :
    normalizedW ùîΩq Œ≤ i = qCompositionChain ùîΩq Œ≤ (‚Ñì:=‚Ñì) (R_rate:=R_rate) i

protected lemma abs_one_sub_div_le_one {v a : Fin n ‚Üí F}
  (h_card : 2 ‚â§ Fintype.card F)
  :
  |1 - (1 + 1 / ((Fintype.card F : ‚Ñö) - 1)) * Œî‚ÇÄ(v, a) / n

theorem drop_repeat {Œ± : Type*} {n' : ‚Ñï} (m : ‚Ñï) (h : m ‚â§ n) (a : Fin n' ‚Üí Œ±) :
    drop (m * n') (Nat.mul_le_mul_right n' h) (Fin.repeat n a) =
      fun i : Fin (n * n' - m * n') =>
          (Fin.repeat (n - m) a (i.cast (Nat.sub_mul n m n').symm))

lemma sDomainBasisVectors_mem_sDomain (i : Fin r) (k : Fin (‚Ñì + R_rate - i)) :
  sDomainBasisVectors ùîΩq Œ≤ h_‚Ñì_add_R_rate i k
    ‚àà sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i

private lemma x_times_oddPart'_eq_x_times_oddPart' {f : Polynomial F} :
    Polynomial.X * (oddPart' f) = x_times_oddPart' f

@[simp]
lemma liftF'_liftF : Function.LeftInverse liftF' (liftF (Œ± := Œ±) (n := n))

@[simp]
theorem Basis_cast_index_apply {Œ± Œ≤ i j : ‚Ñï} {k : Fin j}
    (h_le : Œ± ‚â§ Œ≤) (h_eq : i = j)
    {b : @Basis (Fin (i)) (ConcreteBTField Œ±) (ConcreteBTField Œ≤) _ _
      (@ConcreteBTFieldAlgebra (l := Œ±) (r := Œ≤) (h_le := h_le)).toModule} :
  let castBasis : @Basis (Fin j) (ConcreteBTField Œ±) (ConcreteBTField Œ≤) _ _
    (@ConcreteBTFieldAlgebra (l:=Œ±) (r:=Œ≤) (h_le:=h_le)).toModule :=
    cast (by exact Basis_cast_index_eq i j Œ± Œ≤ h_le h_eq) b
  (castBasis k) = b (Fin.cast (h_eq.symm) k)

@[to_additive vsum_eq_univ_sum]
lemma vprod_eq_univ_prod [CommMonoid Œ±] {a : Fin n ‚Üí Œ±} : vprod a = ‚àè i, a i

@[simp]
theorem finSuccEquivNth_X_above {i : Fin n} (h : p < i.succ) :
    finSuccEquivNth R p (X i.succ) = Polynomial.C (X i)

theorem srSoundness_implies_soundness
    (langIn : Set StmtIn) (langOut : Set StmtOut)
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    (srInit : ProbComp (srChallengeOracle StmtIn pSpec).FunctionType)
    (srImpl : QueryImpl oSpec (StateT (srChallengeOracle StmtIn pSpec).FunctionType ProbComp))
    (srSoundnessError : ‚Ñù‚â•0) :
      Verifier.StateRestoration.soundness srInit srImpl langIn langOut verifier srSoundnessError ‚Üí
        soundness init impl langIn langOut verifier srSoundnessError

omit [SelectableType R] in
@[simp]
lemma oracleReduction_verifier_eq_verifier {i : Fin n} :
    (oracleReduction R n deg D oSpec i).verifier = oracleVerifier R n deg D oSpec i

omit [(i : Œπ‚Çõ) ‚Üí OracleInterface (OStatement i)] [OracleInterface Witness] in
theorem oracleProver_run {stmt : Statement} {oStmt : ‚àÄ i, OStatement i} {wit : Witness} :
    (oracleProver oSpec Statement OStatement Witness).run ‚ü®stmt, oStmt‚ü© wit =
      pure (fun i => by aesop, ‚ü®stmt, Sum.rec oStmt (fun _ => wit)‚ü©, ())

theorem not_irreducible_of_isRoot_of_degree_gt_one
  (p : R[X]) (h_root : ‚àÉ r : R, IsRoot p r) (h_deg : p.degree > 1) :
  ¬¨ Irreducible p

@[simp]
theorem shift_left_mem {s : Finset ‚Ñï} {d : ‚Ñï} : d ‚àà shift_left s ‚Üî (d + 1) ‚àà s

@[simp]
theorem dcast‚ÇÇ_trans (ha : a = a') (ha' : a' = a'')
    (hb : dcast ha b = b') (hb' : dcast ha' b' = b'') :
      dcast‚ÇÇ ha' hb' (dcast‚ÇÇ ha hb c) = dcast‚ÇÇ (ha.trans ha') (by simp [‚Üê hb', ‚Üê hb]) c

lemma rtake_eq_rtake : transcript‚ü¶m:‚üß = transcript.drop m h

theorem GF_2_one_add_one_eq_zero : (1 + 1 : GF(2)) = 0

omit [CharP L 2] [DecidableEq ùîΩq] h_Œ≤‚ÇÄ_eq_1 [NeZero ùì°] in
lemma firstOracleWitnessConsistencyProp_relay_preserved (i : Fin ‚Ñì)
    (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) (wit : Witness (L := L) ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j) :
    firstOracleWitnessConsistencyProp ùîΩq Œ≤ wit.t (getFirstOracle ùîΩq Œ≤ oStmt) =
    firstOracleWitnessConsistencyProp ùîΩq Œ≤ wit.t
      (getFirstOracle ùîΩq Œ≤ (mapOStmtOutRelayStep ùîΩq Œ≤ i hNCR oStmt))

theorem eqPolynomial_expanded (r : œÉ ‚Üí R) :
    eqPolynomial r = ‚àè i : œÉ, ((1 - C (r i)) * (1 - X i) + C (r i) * X i)

@[simp]
theorem simulateQ_map_fst (oa : OracleComp spec Œ±) :
    Prod.fst <$> (simulateQ loggingOracle oa).run = oa

@[simp]
lemma bIdx_mul_œë_add_i_fin_‚Ñì_pred_lt_‚Ñì (bIdx : Fin (‚Ñì / œë - 1)) (i : Fin (œë - 1))
    : ‚ÜëbIdx * œë + ‚Üëi < ‚Ñì

@[simp]
theorem hconcat_last {Œ± : Fin n ‚Üí Sort u} {Œ≤ : Sort u} (v : (i : Fin n) ‚Üí Œ± i) (b : Œ≤) :
    hconcat v b (last n) = cast (vconcat_last Œ± Œ≤).symm b

List.length_drop in Init.Data.List.TakeDrop

@[simp]
theorem Prover.run_of_prover_first [ProverOnly pSpec] (stmt : StmtIn) (wit : WitIn)
    (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      prover.run stmt wit = (do
        let state := prover.input (stmt, wit)
        let ‚ü®msg, state‚ü© ‚Üê liftComp (prover.sendMessage ‚ü®0, by simp‚ü© state) _
        let ctxOut ‚Üê prover.output state
        return ((fun i => match i with | ‚ü®0, _‚ü© => msg), ctxOut))

theorem cast_eq_dcast {m n : ‚Ñï} (h : m = n) (a : Fin m) :
    Fin.cast h a = dcast h a

@[simp]
theorem ranges_length_eq_self_length {l : List ‚Ñï} : l.ranges.length = l.length

lemma lt_of_liftF_ne_zero {f : Fin n ‚Üí Œ±} {i : ‚Ñï}
  (h : liftF f i ‚â† 0)
  : i < n

theorem foldl_succ
 {Œ± Œ≤} {n : ‚Ñï} [NeZero n] (f : Œ≤ ‚Üí Œ± ‚Üí Œ≤) (init : Œ≤) (v : Vector Œ± n) :
  v.foldl (f:=f) (b:=init) = v.tail.foldl (f:=f) (b:=f init v.head)

theorem computableAdditiveNTT_eq_additiveNTT (a : Fin (2 ^ ‚Ñì) ‚Üí L) :
  computableAdditiveNTT (ùîΩq := ùîΩq) (Œ≤ := Œ≤) (‚Ñì := ‚Ñì) (R_rate := R_rate)
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (a := a) =
  additiveNTT (ùîΩq := ùîΩq) (L := L) (Œ≤ := Œ≤) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (a := a)

@[simp]
theorem LeafData.get_internal_ofRight {Œ±} {s_left s_right : Skeleton}
    (left : LeafData Œ± s_left) (right : LeafData Œ± s_right)
    (idxRight : SkeletonLeafIndex s_right) :
    (LeafData.internal left right).get (SkeletonLeafIndex.ofRight idxRight) =
      right.get idxRight

theorem insertNth_ne_zero_iff : insertNth p y s ‚â† 0 ‚Üî y ‚â† 0 ‚à® s ‚â† 0

theorem castSum_castLT {l' : List ‚Ñï} {i : ‚Ñï} (j : Fin i) :
    castSum (i :: l') (by simp) j =
      castLT j (Nat.lt_of_lt_of_le j.isLt (List.le_sum_of_mem (by simp)))

@[simp]
theorem OracleReduction.id_runWithLog (stmt : StmtIn) (oStmt : ‚àÄ i, OStmtIn i) (wit : WitIn) :
    (OracleReduction.id : OracleReduction oSpec StmtIn OStmtIn WitIn _ _ _ _).runWithLog
      stmt oStmt wit = pure ‚ü®‚ü®default, ‚ü®stmt, oStmt‚ü©, wit‚ü©, ‚ü®stmt, oStmt‚ü©, [], []‚ü©

theorem zero_add (n : ChurchNat Œ±) : add zero n = n

lemma definingPoly_is_not_unit {F : Type*} [Field F] [Fintype F] (s : F) [NeZero s] :
  ¬¨IsUnit (definingPoly s)

lemma zero_add {k : ‚Ñï} (a : ConcreteBTField k) : 0 + a = a

lemma bIdx_succ_mul_œë_le_‚Ñì_succ (bIdx : Fin (‚Ñì / œë - 1)) : (‚ÜëbIdx + 1) * œë ‚â§ ‚Ñì + 1

theorem last_nonzero_spec [LawfulBEq R] {p : UniPoly R} {k} :
  p.last_nonzero = some k
  ‚Üí p[k] ‚â† 0 ‚àß (‚àÄ j, (hj : j < p.size) ‚Üí j > k ‚Üí p[j] = 0)

lemma NTTStage_correctness (i : Fin (‚Ñì))
    (input_buffer : Fin (2 ^ (‚Ñì + R_rate)) ‚Üí L) (original_coeffs : Fin (2 ^ ‚Ñì) ‚Üí L) :
    additiveNTTInvariant ùîΩq Œ≤ h_‚Ñì_add_R_rate (evaluation_buffer:=input_buffer)
      (original_coeffs:=original_coeffs) (i := ‚ü®i.val+1, by omega‚ü©) ‚Üí
    additiveNTTInvariant ùîΩq Œ≤ h_‚Ñì_add_R_rate (evaluation_buffer:=NTTStage ùîΩq Œ≤ h_‚Ñì_add_R_rate
      ‚ü®i, by omega‚ü© input_buffer) (original_coeffs:=original_coeffs) ‚ü®i, by omega‚ü©

theorem mul_join_via_add_smul (k : ‚Ñï) (h_pos : k > 0) (a‚ÇÅ a‚ÇÄ b‚ÇÅ b‚ÇÄ : BTField (k - 1)) :
  ‚ãò a‚ÇÅ, a‚ÇÄ ‚ãô * ‚ãò b‚ÇÅ, b‚ÇÄ ‚ãô = ‚ãò a‚ÇÅ * b‚ÇÅ * Z (k - 1) + a‚ÇÅ * b‚ÇÄ + a‚ÇÄ * b‚ÇÅ, a‚ÇÄ * b‚ÇÄ + a‚ÇÅ * b‚ÇÅ ‚ãô

@[simp]
theorem cast_id : MessageIdx.cast (Eq.refl n‚ÇÅ) rfl = (id : pSpec‚ÇÅ.MessageIdx ‚Üí _)

@[to_additive]
theorem prod_Iio_succ (i : Fin n) :
    ‚àè j ‚àà Iio i.succ, v j = (‚àè j ‚àà Iio i.castSucc, v j) * v i.castSucc

lemma pow_2_pow_i_mem_Di_of_mem_D {F : Type} [NonBinaryField F] [Finite F] {D : Subgroup FÀ£}
  [DIsCyclicC : IsCyclicWithGen ‚Ü•D] {x : FÀ£} :
  ‚àÄ {a : FÀ£} (i : ‚Ñï),
    a ‚àà evalDomain D x 0 ‚Üí a ^ (2 ^ i) ‚àà evalDomain D x i

protected lemma errors_are_roots_of_elocPoly {i : ‚Ñï}
  (hi : i < n) (h : f i ‚â† p.eval (œâs i)) : (ElocPoly n œâs f p).eval (œâs i) = 0

protected lemma roots_of_eloc_poly {x : F}
  (h : (ElocPoly n œâs f p).eval x = 0) :
  ‚àÉ i, i < n ‚àß f i ‚â† p.eval (œâs i)

theorem range_vcons {Œ± : Type*} (a : Œ±) (v : Fin n ‚Üí Œ±) :
    Set.range (a ::·µõ v) = insert a (Set.range v)

@[simp]
theorem vflatten_embedSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (v : (i : Fin m) ‚Üí Fin (n i) ‚Üí Œ±) (i : Fin m)
    (j : Fin (n i)) : vflatten v (embedSum i j) = v i j

@[simp]
lemma seqCompose_zero
    (Stmt : Fin 1 ‚Üí Type)
    {Œπ‚Çõ : Fin 1 ‚Üí Type} (OStmt : (i : Fin 1) ‚Üí Œπ‚Çõ i ‚Üí Type)
    [O‚Çõ : ‚àÄ i, ‚àÄ j, OracleInterface (OStmt i j)]
    (Wit : Fin 1 ‚Üí Type)
    {n : Fin 0 ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    [O‚Çò : ‚àÄ i, ‚àÄ j, OracleInterface ((pSpec i).Message j)]
    (R : (i : Fin 0) ‚Üí
      OracleReduction oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Wit i.castSucc)
        (Stmt i.succ) (OStmt i.succ) (Wit i.succ) (pSpec i)) :
    seqCompose Stmt OStmt Wit R =
      @OracleReduction.id Œπ oSpec (Stmt 0) (Œπ‚Çõ 0) (OStmt 0) (Wit 0) (O‚Çõ 0)

@[simp]
lemma seqCompose_toVerifier {m : ‚Ñï}
    (Stmt : Fin (m + 1) ‚Üí Type)
    {Œπ‚Çõ : Fin (m + 1) ‚Üí Type} (OStmt : (i : Fin (m + 1)) ‚Üí Œπ‚Çõ i ‚Üí Type)
    [O‚Çõ : ‚àÄ i, ‚àÄ j, OracleInterface (OStmt i j)]
    {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    [O‚Çò : ‚àÄ i, ‚àÄ j, OracleInterface ((pSpec i).Message j)]
    (V : (i : Fin m) ‚Üí
      OracleVerifier oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Stmt i.succ) (OStmt i.succ)
        (pSpec i)) :
    (seqCompose Stmt OStmt V).toVerifier =
      Verifier.seqCompose (fun i => Stmt i √ó (‚àÄ j, OStmt i j)) (fun i => (V i).toVerifier)

lemma sDomain_card (i : Fin r) (h_i : i < ‚Ñì + R_rate) :
    Fintype.card (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i) = (Fintype.card ùîΩq)^(‚Ñì + R_rate - i)

@[simp]
theorem dflatten_embedSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {motive : (k : Fin (vsum n)) ‚Üí Sort*}
    (v : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí motive (embedSum i j)) (i : Fin m) (j : Fin (n i)) :
    dflatten (motive := motive) v (embedSum i j) = v i j

@[simp]
lemma constantCode_mem_code [NeZero n] :
  constantCode x Œπ ‚àà ReedSolomon.code Œ± n

lemma erase_odd_def {s : Finset ‚Ñï} :
    erase_odd s = s.filter Even

lemma concrete_zero_mul
  (prevBTFieldProps : ConcreteBTFieldProps (k := k - 1))
  (a : ConcreteBTField k) : concrete_mul (zero (k:=k)) a = zero (k:=k)

theorem nsmul_zero : nsmul 0 p = 0

@[simp]
lemma seqCompose_zero
    (Stmt : Fin 1 ‚Üí Type)
    {Œπ‚Çõ : Fin 1 ‚Üí Type} (OStmt : (i : Fin 1) ‚Üí Œπ‚Çõ i ‚Üí Type)
    [O‚Çõ : ‚àÄ i, ‚àÄ j, OracleInterface (OStmt i j)]
    {n : Fin 0 ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    [O‚Çò : ‚àÄ i, ‚àÄ j, OracleInterface ((pSpec i).Message j)]
    (V : (i : Fin 0) ‚Üí OracleVerifier oSpec
      (Stmt i.castSucc) (OStmt i.castSucc) (Stmt i.succ) (OStmt i.succ) (pSpec i)) :
    seqCompose Stmt OStmt V = OracleVerifier.id

omit [Finite F] in
@[simp]
lemma domain_lem‚ÇÅ {i : Fin (k + 1)} :
    [FinalOracleStatement D x s]‚Çí.domain ‚ü®i.1, Nat.lt_succ_of_lt i.2‚ü© =
      evalDomain D x (‚àë j' ‚àà finRangeTo i.1, s j')

@[simp]
lemma dotProduct_cons [AddCommMonoid R] [Mul R] (a : R) (b : Vector R n) (c : R) (d : Vector R n) :
  dotProduct (cons a b) (cons c d) = a * c + dotProduct b d

lemma getBit_of_highBits_no_shl {n: ‚Ñï} (numLowBits : ‚Ñï) :
    ‚àÄ k, getBit k (getHighBits_no_shl numLowBits n)
  = getBit (k + numLowBits) (n)

theorem commitOracleVerifier_rbrKnowledgeSoundness (i : Fin ‚Ñì)
    (hCR : isCommitmentRound ‚Ñì œë i) :
    (commitOracleVerifier ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      i hCR).rbrKnowledgeSoundness init impl
      (relIn := foldStepRelOut (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i.succ)
      (commitKnowledgeError ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))

@[simp]
lemma eval‚ÇÇ_C' {r : R} {S : Type w} [CommSemiring S] (f : R ‚Üí+* S) (x : S) :
    eval‚ÇÇ (P := P) f x (C r) = f r

theorem not_exists_of_decoder_eq_none {e k : ‚Ñï} [NeZero n] {œâs f : Fin n ‚Üí F}
  (he : 2 * e < n - k + 1)
  (hn : k ‚â§ n)
  (h_inj : Function.Injective œâs)
  (h_none : decoder e k œâs f = none)
  : ¬¨‚àÉp : F[X], Œî‚ÇÄ(f, p.eval ‚àò œâs) ‚â§ e ‚àß p.natDegree < k

Nat.zero_add in Init.Data.Nat.Basic

theorem vappend_left_eq_cons (a : Fin 1 ‚Üí Œ±) (v : Fin n ‚Üí Œ±) :
    vappend a v = (vcons (a 0) v) ‚àò Fin.cast (Nat.add_comm 1 n)

theorem liftContext_soundness
    {soundnessError : ‚Ñù‚â•0}
    {lens : OracleStatement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                                OuterOStmtIn OuterOStmtOut InnerOStmtIn InnerOStmtOut}
    (V : OracleVerifier oSpec InnerStmtIn InnerOStmtIn InnerStmtOut InnerOStmtOut pSpec)
    [lensSound : lens.IsSound outerLangIn outerLangOut innerLangIn innerLangOut
      (V.toVerifier.compatStatement lens)]
    (h : V.soundness init impl innerLangIn innerLangOut soundnessError) :
      (V.liftContext lens).soundness init impl outerLangIn outerLangOut soundnessError

theorem sum_square_char2 {F : Type*} [Field F] (sumZeroIffEq : ‚àÄ (x y : F), x + y = 0 ‚Üî x = y)
  (s : Finset ‚Ñï) (f : ‚Ñï ‚Üí F) : (‚àë j ‚àà s, f j)^2 = ‚àë j ‚àà s, (f j)^2

lemma lin_shift_d [Field F] [Fintype F]
  (h_B : 2 ‚â§ B.card)
  :
  d B = d ({x - v | x ‚àà B} : Finset _)

@[simp] theorem ofNat_add (n m : Nat) : ofNat (n + m) = add (ofNat n) (ofNat m)

lemma getMiddleBits_eq_mod {n offset len : ‚Ñï} :
  getMiddleBits offset len n = (n >>> offset) % (2 ^ len)

omit O‚Çò in
theorem seqCompose_perfectCompleteness (hInit : init.neverFails)
    (rel : (i : Fin (m + 1)) ‚Üí Set (Stmt i √ó Wit i))
    (R : ‚àÄ i, Reduction oSpec (Stmt i.castSucc) (Wit i.castSucc) (Stmt i.succ) (Wit i.succ)
      (pSpec i))
    (h : ‚àÄ i, (R i).perfectCompleteness init impl (rel i.castSucc) (rel i.succ)) :
      (Reduction.seqCompose Stmt Wit R).perfectCompleteness
        init impl (rel 0) (rel (Fin.last m))

theorem mul_one {a : CNat 50} : a * 1 = a

lemma getBit_of_shiftLeft {n p : ‚Ñï}:
  ‚àÄ k, getBit (k) (n <<< p) = if k < p then 0 else getBit (k - p) n

@[simp, grind] lemma C_pos : 0 < sz.C

lemma join_split_eq_join {k : ‚Ñï} (h_pos : k > 0) (x : ConcreteBTField k) :
  „Ää (split h_pos x).fst, (split h_pos x).snd „Äã = x

Nat.lt_trans in Init.Prelude

theorem add_zero : p + 0 = p

@[simp] theorem join_nil : List.join ([] : List (List Œ±)) = []

lemma powerBasisSucc_dim (k : ‚Ñï) :
  powerBasisSucc (k:=k).dim = 2

lemma getLowBits_zero_eq_zero {n : ‚Ñï} : getLowBits 0 n = 0

theorem insertNth_ne_zero_of_right (h : s ‚â† 0) : insertNth p y s ‚â† 0

lemma rowRank_eq_colRank : rowRank U = colRank U

omit [Fintype F] in
private lemma hamming_dist_eq_sum {x y : Fin n ‚Üí F} :
  Œî‚ÇÄ(x, y) = ‚àë i, if x i = y i then 0 else 1

theorem append_soundness (V‚ÇÅ : OracleVerifier oSpec Stmt‚ÇÅ OStmt‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : OracleVerifier oSpec Stmt‚ÇÇ OStmt‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ pSpec‚ÇÇ)
    {soundnessError‚ÇÅ soundnessError‚ÇÇ : ‚Ñù‚â•0}
    (h‚ÇÅ : V‚ÇÅ.soundness init impl lang‚ÇÅ lang‚ÇÇ soundnessError‚ÇÅ)
    (h‚ÇÇ : V‚ÇÇ.soundness init impl lang‚ÇÇ lang‚ÇÉ soundnessError‚ÇÇ) :
      (V‚ÇÅ.append V‚ÇÇ).soundness init impl lang‚ÇÅ lang‚ÇÉ (soundnessError‚ÇÅ + soundnessError‚ÇÇ)

theorem linear_form_of_elements_in_adjoined_commring
    {R : Type*} [CommRing R] (f : R[X]) (hf_deg : f.natDegree = 2)
    (hf_monic : Monic f) (c1 : AdjoinRoot f) :
    ‚àÉ a b : R, c1 = (AdjoinRoot.of f) a * root f + (AdjoinRoot.of f) b

theorem vconcat_init_self (v : Fin (n + 1) ‚Üí Œ±) :
    vconcat (fun i => v (Fin.castSucc i)) (v (Fin.last n)) = v

lemma definingPoly_ne_zero {F : Type*} [Field F] [Fintype F] (s : F) [NeZero s] :
  (definingPoly s) ‚â† 0

theorem insertNth_self_removeNth : insertNth p (t p) (removeNth p t) = t

lemma concrete_mul_right_distrib0 (a b c : ConcreteBTField 0) :
  concrete_mul (a + b) c = concrete_mul a c + concrete_mul b c

@[simp]
lemma erase_even_empty :
    erase_even ‚àÖ = ‚àÖ

theorem zero_add {n : ‚Ñï} (a : CNat (n + 1)) : 0 + a = a

lemma concrete_exists_pair_ne {k : ‚Ñï} : ‚àÉ x y : ConcreteBTField k, x ‚â† y

lemma H_tilde_equiv_H_tilde' (H : F[X][Y]) : (H_tilde' H).map univPolyHom = H_tilde H

theorem Reduction.run_of_prover_first [ProverOnly pSpec] (stmt : StmtIn) (wit : WitIn)
    (reduction : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      reduction.run stmt wit = (do
        let state := reduction.prover.input (stmt, wit)
        let ‚ü®msg, state‚ü© ‚Üê liftComp (reduction.prover.sendMessage ‚ü®0, by simp‚ü© state) _
        let ctxOut ‚Üê reduction.prover.output state
        let transcript : pSpec.FullTranscript := fun i => match i with | ‚ü®0, _‚ü© => msg
        let stmtOut ‚Üê reduction.verifier.verify stmt transcript
        return (‚ü®transcript, ctxOut‚ü©, stmtOut))

lemma concrete_mul_one
  (prevBTFieldProps : ConcreteBTFieldProps (k := k - 1))
  (a : ConcreteBTField k) : concrete_mul a (one (k:=k)) = a

lemma concrete_mul_comm
  {h_k : k > 0} (prevBTFieldProps : ConcreteBTFieldProps (k := k - 1))
  (a b : ConcreteBTField k) :
  concrete_mul a b = concrete_mul b a

theorem append_right_injective (a : Fin m ‚Üí Œ±) : Function.Injective (@Fin.append m n Œ± a)

omit [Finite F] in
private lemma gen_def {i : ‚Ñï} :
    (IsCyclicWithGen.gen : evalDomain D i) =
      ‚ü®
        DIsCyclicC.gen ^ (2 ^ i),
        by
          apply pow_2_pow_i_mem_Di_of_mem_D
          exact DIsCyclicC.gen.2
      ‚ü©

@[simp]
theorem simulateQ'_pure (x : Œ±) : simulateQ' so (pure x) (by simp) = pure x

@[simp]
theorem reduction_completeness (h : init.neverFails)
    (hRel : ‚àÄ stmtIn witIn, (stmtIn, witIn) ‚àà relIn ‚Üî
      (mapStmt stmtIn, mapWit stmtIn witIn) ‚àà relOut) :
    (reduction oSpec mapStmt mapWit).perfectCompleteness init impl relIn relOut

congrArg in Init.Prelude

@[simp]
theorem head_cons {Œ±} {n : ‚Ñï} (hd : Œ±) (tl : Vector Œ± n) : (cons hd tl).head = hd

theorem vcons_eq_const (a : Œ±) : a ::·µõ (fun _ : Fin n => a) = fun _ => a

@[simp]
theorem dcons_succ {motive : Fin (n + 1) ‚Üí Sort u} (a : motive 0)
    (v : (i : Fin n) ‚Üí motive i.succ) (i : Fin n) : (a ::·µà‚ü®motive‚ü© v) i.succ = v i

theorem LeafData.composeBuild_internal {Œ±} {s_left s_right : Skeleton}
    (left : LeafData Œ± s_left) (right : LeafData Œ± s_right)
    (compose : Œ± ‚Üí Œ± ‚Üí Œ±) :
    (LeafData.internal left right).composeBuild compose =
      FullData.internal
        (compose (left.composeBuild compose).getRootValue (right.composeBuild compose).getRootValue)
        (left.composeBuild compose)
        (right.composeBuild compose)

theorem append_comp {a : Fin m ‚Üí Œ±} {b : Fin n ‚Üí Œ±} (f : Œ± ‚Üí Œ≤) :
    append (f ‚àò a) (f ‚àò b) = f ‚àò append a b

theorem cast_idx {i : MessageIdx pSpec‚ÇÅ} :
    pSpec‚ÇÇ.Message (i.cast hn hSpec) = pSpec‚ÇÅ.Message i

omit [DecidableEq F] in
@[simp]
lemma isBerlekampWelchSolution_zero_zero [NeZero n] {v : Fin (2 * 0 + 0) ‚Üí F} :
  IsBerlekampWelchSolution 0 0 œâs f v ‚Üî f = 0

private lemma natDegree_E
  (h : (Œî‚ÇÄ(f, p.eval ‚àò œâs) : ‚Ñï) ‚â§ e) :
  (E (œâs := œâs) f p e).natDegree = e

theorem snoc_ne_zero_of_left (h : s ‚â† 0) : snoc s y ‚â† 0

lemma cast_ConcreteBTField_eq (k m : ‚Ñï) (h_eq : k = m) :
  ConcreteBTField k = ConcreteBTField m

lemma folding_steps_pos : (œë : ‚Ñï) > 0

Nat.lt_succ_of_lt in Init.Data.Nat.Basic

lemma blockRelDistance_eq_relHammingDist_of_k_eq_i -- Renamed for clarity
  (i : ‚Ñï) {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F}
  [DecidableEq F] [DecidableEq Œπ] [Smooth œÜ]
  -- The Fintype instance is now declared before it is needed by `hS'`.
  [h_fintype : ‚àÄ i : ‚Ñï, Fintype (indexPowT S œÜ i)]
  (f g : (indexPowT S œÜ i) ‚Üí F) (S' : Finset (indexPowT S œÜ i))
  (hS' : S' = Finset.univ) -- This now works.
  (œÜ' : (indexPowT S œÜ i) ‚Ü™ F)
  [h_dec : DecidableBlockDisagreement i i f S' œÜ'] [DecidableEq (indexPowT S œÜ i)] :
  Œî·µ£(i, i, f, S', œÜ', g) = Œ¥·µ£(f, g)

@[simp]
theorem insertNth_apply_same : insertNth p y s p = y

theorem dconcat_init_self {motive : Fin (n + 1) ‚Üí Sort u} (v : (i : Fin (n + 1)) ‚Üí motive i) :
    (fun i => v (castSucc i)) :+·µà‚ü®motive‚ü© (v (last n)) = v

theorem take_addCases'_left {n' : ‚Ñï} {Œ≤ : Fin n' ‚Üí Sort u} (m : ‚Ñï) (h : m ‚â§ n)
    (u : (i : Fin n) ‚Üí Œ± i) (v : (j : Fin n') ‚Üí Œ≤ j) (i : Fin m) :
    take m (Nat.le_add_right_of_le h) (addCases' u v) i =
      (append_left Œ± Œ≤ (castLE h i)) ‚ñ∏ (take m h u i)

@[simp]
theorem PowerBasis.cast_basis_succ_of_eq_rec_apply
    (r1 r : ‚Ñï) (h_r : r = r1 + 1)
    (k : Fin 2) :
    letI instAlgebra : Algebra (ConcreteBTField r1) (ConcreteBTField r) :=
      ConcreteBTFieldAlgebra (l:=r1) (r:=r) (h_le:=by omega)
    letI instAlgebraSucc : Algebra (ConcreteBTField (r1 + 1)) (ConcreteBTField (r)) :=
      ConcreteBTFieldAlgebra (l:=r1 + 1) (r:=r) (h_le:=by omega)
    let b : PowerBasis (ConcreteBTField r1) (ConcreteBTField (r1 + 1))
      := powerBasisSucc (k:=r1)
    let bCast : PowerBasis (ConcreteBTField r1) (ConcreteBTField r) := Eq.rec (motive:=
      fun (x : ‚Ñï) (_ : r1 + 1 = x) => by
        letI instAlgebraCur : Algebra (ConcreteBTField r1) (ConcreteBTField x) :=
          ConcreteBTFieldAlgebra (l:=r1) (r:=x) (h_le:=by omega)
        exact PowerBasis (ConcreteBTField r1) (ConcreteBTField x)) (refl:=b) (t:=h_r.symm)
    have h_pb_dim : b.dim = 2 := by
      exact powerBasisSucc_dim r1

    have h_pb'_dim : bCast.dim = 2 := by
      dsimp [bCast]
      rw [PowerBasis.dim_of_eq_rec (r1:=r1) (r:=r) (h_r:=h_r) (b:=b)]
      exact h_pb_dim

    have h_pb_type_eq : Basis (Fin bCast.dim) (ConcreteBTField r1) (ConcreteBTField r) =
      Basis (Fin 2) (ConcreteBTField r1) (ConcreteBTField r) := by
      congr

   -- The `cast` needs a proof that `bCast.dim = 2`. We construct it here.
    let left : Basis (Fin 2) (ConcreteBTField r1) (ConcreteBTField r)
      := cast (by exact h_pb_type_eq) bCast.basis
    let right := (algebraMap (ConcreteBTField (r1 + 1)) (ConcreteBTField r))
      (b.basis (Fin.cast h_pb_dim.symm k))
    left k = right

lemma divide_by_2_def {s : Finset ‚Ñï} :
    divide_by_2 s = (erase_odd s).image (fun n => n / 2)

theorem funext_heq_iff {Œ± Œ±' : Sort u} {Œ≤ : Œ± ‚Üí Sort v} {Œ≤' : Œ±' ‚Üí Sort v}
    {f : (x : Œ±) ‚Üí Œ≤ x} {g : (x : Œ±') ‚Üí Œ≤' x} (ha : Œ± = Œ±') (hb : ‚àÄ x, Œ≤ x = Œ≤' (cast ha x)) :
      HEq f g ‚Üî ‚àÄ x, HEq (f x) (g (cast ha x))

@[simp]
lemma evenPart_by_2 :
  2 * (evenPart f) = f + f.comp (-X)

theorem foldCommitOracleVerifier_rbrKnowledgeSoundness
    (i : Fin ‚Ñì) (hCR : isCommitmentRound ‚Ñì œë i) :
    (foldCommitOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hCR).rbrKnowledgeSoundness
      init impl
      (relIn := roundRelation (mp := mp) ùîΩq Œ≤ (œë:=œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) i.castSucc)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë:=œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) i.succ)
      (rbrKnowledgeError := fun _ => foldKnowledgeError ùîΩq Œ≤ (œë:=œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i ‚ü®1, by rfl‚ü©
      )

lemma bIdx_succ_mul_œë_lt_‚Ñì_succ (bIdx : Fin (‚Ñì / œë - 1)) :
    (‚ÜëbIdx + 1) * œë < ‚Ñì + 1

omit [NeZero r] [Field L] [Fintype L] [DecidableEq L] [Field ùîΩq] [Algebra ùîΩq L] in
lemma sBasis_range_eq (i : Fin r) (h_i : i < ‚Ñì + R_rate) :
    Œ≤ '' Set.Ico i ‚ü®‚Ñì + R_rate, h_‚Ñì_add_R_rate‚ü©
    = Set.range (sBasis Œ≤ h_‚Ñì_add_R_rate i h_i)

@[simp]
lemma seqCompose_dir {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)} :
    (seqCompose pSpec).dir = Fin.vflatten (fun i => (pSpec i).dir)

theorem foldr_split_outer {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤ ‚Üí Œ≤) (init : Œ≤)
    (l : List Œ±) (h : l ‚â† []): foldr (f:=f) (init:=init) (l)
    = f (l.head (by omega)) (foldr (f:=f) (init:=init) (l.tail))

@[simp]
theorem removeNth_last : removeNth (Fin.last n) s = init s

@[simp]
theorem partialSum_nil : [].partialSum = [0]

lemma eval‚ÇÇ_eq' {S : Type w} [CommSemiring S] (g : P ‚Üí+* S) (p : P) :
    g p = eval‚ÇÇ (g.comp (Algebra.ofId R P)) (g X) p

theorem singleEqPolynomial_zeroOne (r : Fin 2) (x : MvPolynomial œÉ R) :
    singleEqPolynomial (r : R) x = if r = 0 then 1 - x else x

@[simp]
theorem BTField.RingHom_cast_dest_apply (k m n : ‚Ñï) (h_eq : m = n)
  (f : BTField k ‚Üí+* BTField m) (x : BTField k) :
    (cast (BTField.RingHom_eq_of_dest_eq (k:=k) (m:=m) (n:=n) h_eq) f) x
    = cast (by apply cast_BTField_eq (h_eq:=h_eq)) (f x)

theorem dconcat_injective2 {motive : Fin (n + 1) ‚Üí Sort u} :
    Function.Injective2 (@dconcat n motive)

theorem eq_symm {Œ± : Type u} (mx my : m Œ±) : eq mx my ‚Üí eq my mx

theorem finSuccEquivNth_eq :
    (finSuccEquivNth R p : MvPolynomial (Fin (n + 1)) R ‚Üí+* Polynomial (MvPolynomial (Fin n) R)) =
      eval‚ÇÇHom (Polynomial.C.comp (C : R ‚Üí+* MvPolynomial (Fin n) R))
        (Fin.insertNth p Polynomial.X (Polynomial.C ‚àò X))

Nat.le_add_left in Init.Data.Nat.Basic

@[simp]
theorem partialSum_succ {a : Œ±} {l : List Œ±} :
    (a :: l).partialSum = [0] ++ (partialSum l).map (a + ¬∑)

private lemma johnson_denom [Zero F]
  (h_card : 2 ‚â§ (Fintype.card F))
  :
  (Fintype.card F / (Fintype.card F - 1)) *
  ((1 - e B 0 / n) ^ 2  + (e B 0) ^ 2 / ((Fintype.card F - 1) * n^2) - 1 + d B/n)
  =
  (1 - ((Fintype.card F) / (Fintype.card F - 1)) *
  (e B 0 / n)) ^ 2 - (1 - ((Fintype.card F) / (Fintype.card F - 1)) * (d B/n))

omit [Fintype L] [DecidableEq L] in
theorem Polynomial.comp_same_inner_eq_if_same_outer (f g : L[X]) (h_f_eq_g : f = g) :
  ‚àÄ x, f.comp x = g.comp x

Polynomial.degree_sum_le in Mathlib.Algebra.Polynomial.Degree.Definitions

@[csimp]
theorem dcons_eq_cons : @dcons = @cons

@[simp]
theorem distFromCode_of_empty (u : n ‚Üí R) : Œî‚ÇÄ(u, (‚àÖ : Set (n ‚Üí R))) = ‚ä§

theorem empty_unique (v : Fin 0 ‚Üí Œ±) : v = !v[]

@[simp]
private lemma F2i_disjoint :
  Set.PairwiseDisjoint Set.univ (F2i B i)

@[simp]
theorem LeafData.map_internal {Œ± Œ≤} {s_left s_right : Skeleton}
    (f : Œ± ‚Üí Œ≤) (left : LeafData Œ± s_left) (right : LeafData Œ± s_right) :
    (LeafData.internal left right).map f =
      LeafData.internal (left.map f) (right.map f)

theorem rightpad_eq_rightpad_append_replicate_of_ge
  (l : List Œ±) (m n : Nat) (h : n ‚â§ m) :
    rightpad m unit l = rightpad n unit l ++ replicate (m - max n l.length) unit

@[local grind _=_]
private lemma support_eq_support_toFinsupp {f : F[X][Y]} : f.support = f.toFinsupp.support

@[simp]
theorem vappend_vempty (v : Fin m ‚Üí Œ±) : vappend v !v[] = v

theorem succ'_ne_zero (n : Nat) : succ' n ‚â† 0

theorem base_intermediateNormVpoly
  (k : Fin (‚Ñì + 1)) :
  intermediateNormVpoly ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®0, by
    by_contra ht
    simp only [not_lt, nonpos_iff_eq_zero] at ht
    contradiction
  ‚ü© ‚ü®k, by simp only [tsub_zero]; omega‚ü© =
  normalizedW ùîΩq Œ≤ ‚ü®k, by omega‚ü©

theorem vappend_vconcat (u : Fin m ‚Üí Œ±) (v : Fin n ‚Üí Œ±) (a : Œ±) :
    vappend u (vconcat v a) = vconcat (vappend u v) a

@[grind _=_]
lemma degreeX_as_weighted_deg :
  degreeX f = natWeightedDegree f 1 0

lemma toPoly_trim [LawfulBEq R] {p : UniPoly R} : p.trim.toPoly = p.toPoly

lemma add_comm {k : ‚Ñï} (a b : ConcreteBTField k) : a + b = b + a

theorem dappend_succ {motive : Fin (m + (n + 1)) ‚Üí Sort u}
    (u : (i : Fin m) ‚Üí motive (castAdd (n + 1) i))
    (v : (i : Fin (n + 1)) ‚Üí motive (natAdd m i)) :
    dappend (motive := motive) u v =
      (dappend u (fun i => v (castSucc i))) :+·µà‚ü®motive‚ü© (v (last n))

lemma BerlekampWelch_E_ne_zero {e k : ‚Ñï}
  {œâs f : Fin n ‚Üí F}
  {E Q : Polynomial F}
  (h_cond : BerlekampWelchCondition e k œâs f E Q)
  : E ‚â† 0

lemma eq_iff_eq_all_getBits {n m : ‚Ñï} : n = m ‚Üî ‚àÄ k, getBit k n = getBit k m

@[simp]
lemma ofPolynomialAlgHom_X : ofPolynomialAlgHom (Polynomial.X : R[X]) = (X : P)

lemma getBit_of_lt_two_pow {n: ‚Ñï} (a: Fin (2^n)) (k: ‚Ñï) :
  getBit k a = if k < n then getBit k a else 0

lemma testBit_false_eq_getBit_eq_0 (k n : Nat) :
  (n.testBit k = false) = ((Nat.getBit k n) = 0)

@[simp]
lemma natDegree_truncate [œÜ : NeZero n] : (truncate p n).natDegree < n

theorem heq_of_dcast (ha : a = a') (hb : dcast ha b = b') : HEq b b'

lemma neg_descends (a b : UniPoly R) : equiv a b ‚Üí neg_descending a = neg_descending b

theorem seqCompose_soundness
    (lang : (i : Fin (m + 1)) ‚Üí Set (Stmt i √ó ‚àÄ j, OStmt i j))
    (V : (i : Fin m) ‚Üí
      OracleVerifier oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Stmt i.succ) (OStmt i.succ)
        (pSpec i))
    (soundnessError : Fin m ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (V i).soundness init impl (lang i.castSucc) (lang i.succ) (soundnessError i)) :
      (OracleVerifier.seqCompose Stmt OStmt V).soundness init impl (lang 0) (lang (Fin.last m))
        (‚àë i, soundnessError i)

lemma nonDoomedFoldingProp_relay_preserved (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i)
    (challenges : Fin i.succ ‚Üí L)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j)
    :
    nonDoomedFoldingProp ùîΩq Œ≤ i.castSucc (Fin.init challenges) oStmt ‚Üî
    nonDoomedFoldingProp ùîΩq Œ≤ i.succ challenges (mapOStmtOutRelayStep ùîΩq Œ≤ i hNCR oStmt)

@[simp]
lemma dfoldl'_zero {Œ± : Fin 1 ‚Üí Type u}
    (f : (i : Fin 0) ‚Üí Œ± i.castSucc ‚Üí Œ± i.succ) (x : Œ± 0) :
    dfoldl' 0 Œ± f x = x

@[simp]
theorem vappend_right (u : Fin m ‚Üí Œ±) (v : Fin n ‚Üí Œ±) (i : Fin n) :
    vappend u v (natAdd m i) = v i

theorem linear_map_of_comp_to_linear_map_of_eval (f : L[X])
  (h_f_linear : IsLinearMap (R := Fq) (M := L[X]) (M‚ÇÇ := L[X])
    (f := fun inner_p ‚Ü¶ f.comp inner_p)) :
    IsLinearMap (R := Fq) (M := L) (M‚ÇÇ := L) (f := fun x ‚Ü¶ f.eval x)

@[simp]
theorem prover_first (pSpec : ProtocolSpec n) [NeZero n] [h : ProverFirst pSpec] :
    pSpec.dir 0 = .P_to_V

lemma div_2_form {nD2 b : ‚Ñï} (h_b : b < 2):
  (nD2 * 2 + b) / 2 = nD2

theorem liftContext_perfectCompleteness
    (h : R.perfectCompleteness init impl innerRelIn innerRelOut) :
      (R.liftContext lens).perfectCompleteness init impl outerRelIn outerRelOut

private lemma roots_of_unity_lem {s : Fin (k + 1) ‚Üí ‚Ñï+} {i : Fin (k + 1)}
    (k_le_n : (‚àë j', (s j').1) ‚â§ n) :
  (‚àë j' ‚àà finRangeTo i.1, (s j').1) ‚â§ n - (s i).1

theorem get_rtake_eq_rtake_get_comp_cast {Œ± : Type*} {m : ‚Ñï} (l : List Œ±) (h : m ‚â§ l.length) :
    (l.rtake m).get = rtake m h l.get ‚àò Fin.cast (by simp [List.rtake]; omega)

lemma liftF'_liftF_of_lt {k : Fin m} (h : k < n) :
  liftF' (n := m) (liftF (n := n) f') k = f' ‚ü®k, by omega‚ü©

lemma getBit_of_add_distrib {n m k : ‚Ñï}
  (h_n_AND_m : n &&& m = 0) : getBit k (n + m) = getBit k n + getBit k m

omit h_Œ≤‚ÇÄ_eq_1 in
lemma finToBinaryCoeffs_sDomainToFin (i : Fin r) (h_i : i < ‚Ñì + R_rate)
    (x : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i) :
    let pointFinIdx := (sDomainToFin ùîΩq Œ≤ h_‚Ñì_add_R_rate i h_i) x
    finToBinaryCoeffs ùîΩq (i := i) (idx :=pointFinIdx) =
    (sDomain_basis ùîΩq Œ≤
    h_‚Ñì_add_R_rate i h_i).repr x

lemma getLast_toImpl {p : Q[X]} (hp : p ‚â† 0) : let h : p.toImpl.size > 0 := toImpl_nonzero hp;
    p.toImpl[p.toImpl.size - 1] = p.leadingCoeff

lemma one_bitvec_toNat {width : ‚Ñï} (h_width : width > 0) : (1#width).toNat = 1

theorem rbrKnowledgeSoundness_implies_rbrSoundness
    {relIn : Set (StmtIn √ó WitIn)} {relOut : Set (StmtOut √ó WitOut)}
    {verifier : Verifier oSpec StmtIn StmtOut pSpec}
    {rbrKnowledgeError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    (h : verifier.rbrKnowledgeSoundness init impl relIn relOut rbrKnowledgeError) :
    verifier.rbrSoundness init impl relIn.language relOut.language rbrKnowledgeError

theorem append_run (tr : (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).FullTranscript) :
      (V‚ÇÅ.append V‚ÇÇ).run stmt tr =
        (do
          let stmt‚ÇÇ ‚Üê V‚ÇÅ.run stmt tr.fst
          let stmt‚ÇÉ ‚Üê V‚ÇÇ.run stmt‚ÇÇ tr.snd
          return stmt‚ÇÉ)

@[simp]
theorem cast_dir_idx_symm {hn} (hSpec : pSpec‚ÇÅ.cast hn = pSpec‚ÇÇ) {i : Fin n‚ÇÇ} :
    pSpec‚ÇÅ.dir (Fin.cast hn.symm i) = pSpec‚ÇÇ.dir i

@[simp]
lemma eval_solutionToE {x : F} :
  eval x (solutionToE e k v) = x ^ e + ‚àë y : Fin e, v ‚ü®y, by omega‚ü© * x ^ y.1

lemma mca_list_decoding
  [Fintype Œπ] [Nonempty Œπ]
  (Gen : ProximityGenerator Œπ F) [Fintype Gen.par‚Ñì]
  (Œ¥ BStar : ‚Ñù) (errStar : ‚Ñù ‚Üí ENNReal)
  (fs us : Matrix Gen.par‚Ñì Œπ F)
  (IC : InterleavedCode Gen.par‚Ñì Œπ F)
  (haveIC : IC = codeOfLinearCode Gen.par‚Ñì Gen.C)
      (hGen : hasMutualCorrAgreement Gen BStar errStar)
  (C : Set (Œπ ‚Üí F)) (hC : C = Gen.C) :
    haveI := Gen.Gen_nonempty
    ‚àÄ {fs : Matrix Gen.par‚Ñì Œπ F}
    (hŒ¥Pos : Œ¥ > 0) (hŒ¥Lt : Œ¥ < min (Œ¥·µ£ C : ‚Ñù) (1 - BStar)),
      Pr_{let r ‚Üê$·µñ Gen.Gen}[ proximityListDecodingCondition Gen.C r Œ¥ fs IC ]
        ‚â§ errStar Œ¥

theorem mobius_apply_zeta_apply_eq_id (n : ‚Ñï) [NeZero n] (r : Fin n) (l : Fin (r.val + 1))
    (v : Vector R (2 ^ n)) : lagrangeToMono_segment n r l (monoToLagrange_segment n r l v) = v

@[simp]
private lemma K_le_card {Œ± : F} : K B i Œ± ‚â§ B.card

lemma qMap_eval_mem_sDomain_succ (i : Fin ‚Ñì)
    (h_i_add_1 : i.val + 1 ‚â§ ‚Ñì) (x : (sDomain ùîΩq Œ≤
    h_‚Ñì_add_R_rate) ‚ü®i, by omega‚ü©) :
    (qMap ùîΩq Œ≤ ‚ü®i.val, by omega‚ü©).eval (x.val : L) ‚àà
    sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate
      ‚ü®i.val + 1, by omega‚ü©

@[simp]
theorem dist_empty : ‚Äñ (‚àÖ : Set (n ‚Üí R) ) ‚Äñ‚ÇÄ = 0

Nat.pos_of_neZero in Init.Data.Nat.Basic

@[simp]
protected lemma elocPoly_ne_zero : ElocPoly n œâs f p ‚â† 0

theorem fcons_right_injective {Œ≤ : Fin n ‚Üí A} (a : F Œ±) :
    Function.Injective (fcons a : ((i : Fin n) ‚Üí F (Œ≤ i)) ‚Üí (i : Fin (n + 1)) ‚Üí _)

lemma is_berlekamp_welch_solution_ext
  (h : ‚àÄ i, (Matrix.mulVec (BerlekampWelchMatrix e k œâs f) v) i = -(f i) * (œâs i) ^ e)
  : IsBerlekampWelchSolution e k œâs f v

@[simp]
theorem distFromCode_of_mem (C : Set (n ‚Üí R)) {u : n ‚Üí R} (h : u ‚àà C) : Œî‚ÇÄ(u, C) = 0

@[simp] -- TODO: more general version/class for query impls that never have failures
lemma loggingOracle.probFailure_simulateQ [spec.FiniteRange] (oa : OracleComp spec Œ±) :
    [‚ä• | (simulateQ loggingOracle oa).run] = [‚ä• | oa] := by
  induction oa using OracleComp.induction with

@[simp]
theorem fflatten_splitSum {A : Sort u} {F : A ‚Üí Sort v} {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï}
    {Œ± : (i : Fin (vsum n)) ‚Üí A}
    (v : (k : Fin (vsum n)) ‚Üí F (Œ± k)) (k : Fin (vsum n)) :
    fflatten (fun i j => v (embedSum i j)) k = cast (by simp) (v k)

@[simp]
theorem init_update_last : init (update s (Fin.last n) y) = init s

theorem cast_symm {hn} (hSpec : pSpec‚ÇÅ.cast hn = pSpec‚ÇÇ) : pSpec‚ÇÇ.cast hn.symm = pSpec‚ÇÅ

lemma modified_guruswami_has_a_solution
  {m n k : ‚Ñï}
  {œâs : Fin n ‚Ü™ F} {u‚ÇÄ u‚ÇÅ : Fin n ‚Üí F}
  :
  ‚àÉ Q : F[Z][X][Y], ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ

@[simp]
theorem cast_val {m n : ‚Ñï} (h : m = n) (a : Fin m) : (Fin.cast h a).val = a.val

theorem reduction_perfectCompleteness (hInit : init.neverFails) :
    (reduction R n deg D oSpec i).perfectCompleteness init impl
    (relationRound R n deg D i.castSucc) (relationRound R n deg D i.succ)

theorem support_C_subset {r : R} : (@C R œÉ _ r).support ‚äÜ { 0 }

@[simp]
theorem cast_id :
    OracleReduction.cast rfl rfl (fun _ => rfl) =
      (id : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec‚ÇÅ ‚Üí _)

Nat.add_sub_cancel in Init.Data.Nat.Basic

theorem init_dconcat {motive : Fin (n + 1) ‚Üí Sort u} (v : (i : Fin n) ‚Üí motive (castSucc i))
    (a : motive (last n)) : (fun i => (v :+·µà‚ü®motive‚ü© a) (castSucc i)) = v

theorem dconcat_left_injective {motive : Fin (n + 1) ‚Üí Sort u} (a : motive (last n)) :
    Function.Injective (fun v => dconcat (motive := motive) v a)

theorem whir_rbr_soundness
    [SelectableType F] {d dstar : ‚Ñï}
  -- P : set of M + 1 parameters including foldingParam·µ¢, varCount·µ¢, œÜ·µ¢, repeatParam·µ¢,
  --

List.le_sum_of_mem in Mathlib.Algebra.Order.BigOperators.Group.List

omit h_Fq_char_prime hF‚ÇÇ in
lemma rootMultiplicity_prod_W_comp_X_sub_C
    (i : Fin r) (h_i_add_1 : i + 1 < r) (a : L) :
    rootMultiplicity a ((univ : Finset ùîΩq).prod (fun c => (W ùîΩq Œ≤ i).comp (X - C (c ‚Ä¢ Œ≤ i)))) =
    if a ‚àà (U ùîΩq Œ≤ (i+1) : Set L) then 1 else 0

theorem max_eq_add_sub {m n : Nat} : Nat.max m n = m + (n - m)

lemma degree_X‚±º (‚Ñì : ‚Ñï) (h_‚Ñì : ‚Ñì ‚â§ r) (j : Fin (2 ^ ‚Ñì)) :
  (X‚±º ùîΩq Œ≤ ‚Ñì h_‚Ñì j).degree = j

theorem BitVec.extractLsb_eq_shift_ofNat {n : Nat} (x : BitVec n) (l r : Nat) :
    BitVec.extractLsb r l x = BitVec.ofNat (r - l + 1) (x.toNat >>> l)

theorem degrees_C_mul_le (p : MvPolynomial œÉ R) (c : R) : (C c * p).degrees ‚â§ p.degrees

lemma mkLastOracleIndex_last : mkLastOracleIndex ‚Ñì œë (Fin.last ‚Ñì) = ‚Ñì / œë - 1

omit h_Fq_char_prime in
theorem changeOfBasisMatrix_diag_ne_zero
  (‚Ñì : Nat) (h_‚Ñì : ‚Ñì ‚â§ r) :
  (‚àÄ i, (changeOfBasisMatrix ùîΩq Œ≤ ‚Ñì h_‚Ñì) i i ‚â† 0)

theorem fold_advances_evaluation_poly
  (i : Fin (‚Ñì)) (h_i_succ_lt : i + 1 < ‚Ñì + ùì°)
  (coeffs : Fin (2 ^ (‚Ñì - ‚Üëi)) ‚Üí L) (r_chal : L) :
  let P_i : L[X] := intermediateEvaluationPoly ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i, by
    exact Nat.lt_trans (n := i) (k := ‚Ñì+1) (m := ‚Ñì) (h‚ÇÅ := i.isLt) (by exact Nat.lt_add_one ‚Ñì)
  ‚ü©) coeffs
  let f_i

@[simp]
lemma addSalt_Type (i : Fin n) :
    (pSpec.addSalt Salt).¬´Type¬ª i = match hDir : pSpec.dir i with

@[simp, grind =]
theorem monomialXY_add {n m : ‚Ñï} {a b : F} :
  monomialXY n m (a + b) = monomialXY n m a + monomialXY n m b

@[simp]
theorem zero_vappend {u : Fin 0 ‚Üí Œ±} (v : Fin n ‚Üí Œ±) :
    vappend u v = v ‚àò Fin.cast (Nat.zero_add n)

theorem comp_x_square_coeff {f : Polynomial F} {n : ‚Ñï} :
  (f.comp (X * X)).coeff n = if Even n then f.coeff (n / 2) else 0

@[simp]
theorem cast_id : FullTranscript.cast rfl rfl = (id : pSpec‚ÇÅ.FullTranscript ‚Üí _)

theorem oracleReduction_rbr_knowledge_soundness : True

Nat.le_trans in Init.Prelude

theorem support_finSuccEquivNth_nonempty {f : MvPolynomial (Fin (n + 1)) R} (h : f ‚â† 0) :
    (finSuccEquivNth R p f).support.Nonempty

lemma twoAdicGenerators_pow_twoPow_eq_one (bits : Fin (twoAdicity + 1)) :
    (twoAdicGenerators[bits]) ^ (2 ^ (bits : Nat)) = (1 : Field)

@[simp]
theorem LeafData.get_ofRight {s_left s_right : Skeleton} {Œ± : Type}
    (tree : LeafData Œ± (Skeleton.internal s_left s_right))
    (idxRight : SkeletonLeafIndex s_right) :
    tree.get (SkeletonLeafIndex.ofRight idxRight) =
      tree.rightSubtree.get idxRight

theorem cast_eq_dcast‚ÇÇ {T : FullTranscript pSpec‚ÇÅ} :
    dcast‚ÇÇ hn hSpec T = FullTranscript.cast hn hSpec T

lemma wt_eq_hammingNorm [Zero F] {v : Œπ ‚Üí F} :
  wt v = hammingNorm v

theorem BitVec.bitvec_cast_eq_dcast {n m : Nat} (h : n = m) (bv : BitVec n) :
  BitVec.cast h bv = DCast.dcast h bv

lemma comm_map_smul_tmul (s s' : Right) (m : Left) :
    e (s ‚Ä¢ (s' ‚äó‚Çú[K] m)) = s ‚Ä¢ (e (s' ‚äó‚Çú[K] m))

@[grind _=_]
theorem monomialXY_mul_monomialXY {n m p q : ‚Ñï} {a b : F} :
    monomialXY n m a * monomialXY p q b = monomialXY (n + p) (m + q) (a * b)

theorem coreInteractionOracleReduction_perfectCompleteness (hInit : init.neverFails) :
    OracleReduction.perfectCompleteness
      (pSpec := pSpecCoreInteraction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
      (relIn := roundRelation (mp := BBF_SumcheckMultiplierParam) ùîΩq Œ≤ (œë:=œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) 0)
      (relOut := finalSumcheckRelOut ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
      (oracleReduction := coreInteractionOracleReduction ùîΩq Œ≤ (œë:=œë) (ùìë:=ùìë))
      (init := init)
      (impl := impl)

lemma aeval_eq' {A : Type w} [CommSemiring A] [Algebra R A] (f : P ‚Üí‚Çê[R] A) (p : P) :
    f p = aeval (f X) p

lemma toOutCodewordsCount_mul_œë_eq_i_succ (i : Fin ‚Ñì) (hCR : isCommitmentRound ‚Ñì œë i) :
  (toOutCodewordsCount ‚Ñì œë i.castSucc) * œë = i.val + 1

@[simp]
lemma domain_def : (spec Œ±).domain () = (Œ± √ó Œ±)

@[simp]
lemma isRoot_polynomialsOfCoeffs {x : F} :
  IsRoot (polynomialOfCoeffs coeffs) x ‚Üî eval x (polynomialOfCoeffs coeffs) = 0

Nat.cast_pow in Mathlib.Data.Nat.Cast.Basic

@[simp]
lemma range_def : (spec Œ±).range () = Œ±

lemma vappend_left_of_lt {m n : ‚Ñï} {Œ± : Sort u}
    (u : Fin m ‚Üí Œ±) (v : Fin n ‚Üí Œ±) (i : Fin (m + n)) (h : i.val < m) :
      vappend u v i = u ‚ü®i, h‚ü©

@[simp]
theorem FullData.get_ofFun {Œ±} {s} (f : SkeletonNodeIndex s ‚Üí Œ±) :
    (FullData.ofFun s f).get = f

theorem add_assoc [LawfulBEq R] : p + q + r = p + (q + r)

@[simp]
theorem Ici_succ (i : Fin n) : Ici i.succ = (Ici i).map (Fin.succEmb _)

@[simp]
lemma numFullRounds_pos : 0 < params.numFullRounds

theorem commitOracleReduction_perfectCompleteness (hInit : init.neverFails) (i : Fin ‚Ñì)
    (hCR : isCommitmentRound ‚Ñì œë i) :
    OracleReduction.perfectCompleteness
      (pSpec := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)
      (relIn := foldStepRelOut (mp := mp) ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        (ùìë := ùìë) i)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        (ùìë := ùìë) i.succ)
      (oracleReduction := commitOracleReduction ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hCR)
      (init := init)
      (impl := impl)

lemma List.prod_finRange_eq_finset_prod {M : Type*} [CommMonoid M] {n : ‚Ñï} (f : Fin n ‚Üí M) :
    ((List.finRange n).map f).prod = ‚àè i : Fin n, f i

@[simp]
theorem LeafData.get_ofFun {Œ±} {s} (f : SkeletonLeafIndex s ‚Üí Œ±) :
    (LeafData.ofFun s f).get = f

omit [Finite F] in
lemma neg_mem_dom_of_mem_dom : ‚àÄ {a : FÀ£} (i : Fin n),
    a ‚àà evalDomain D x i ‚Üí - a ‚àà evalDomain D x i

theorem liftContext_runWithLog
    {lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    {outerStmtIn : OuterStmtIn} {outerWitIn : OuterWitIn}
    {P : Prover oSpec InnerStmtIn InnerWitIn InnerStmtOut InnerWitOut pSpec} :
      (P.liftContext lens).runWithLog outerStmtIn outerWitIn
      = do
        let ‚ü®‚ü®fullTranscript, innerCtxOut‚ü©, queryLog‚ü© ‚Üê
          P.runWithLog.uncurry (lens.proj (outerStmtIn, outerWitIn))
        return ‚ü®‚ü®fullTranscript, lens.lift (outerStmtIn, outerWitIn) innerCtxOut‚ü©, queryLog‚ü©

theorem append_right_injective {pSpec : ProtocolSpec m} :
    Function.Injective (@ProtocolSpec.append m n pSpec)

@[simp]
theorem OracleVerifier.id_knowledgeSoundness {rel : Set ((StmtIn √ó ‚àÄ i, OStmtIn i) √ó WitIn)} :
    (OracleVerifier.id : OracleVerifier oSpec _ _ _ _ _).knowledgeSoundness
      init impl rel rel 0

theorem vconcat_right_injective (v : Fin n ‚Üí Œ±) : Function.Injective (vconcat v)

@[simp]
lemma eval_solutionToQ {x : F} :
  eval x (solutionToQ e k v) =
  ‚àë i ‚àà Finset.range (e + k), liftF v (e + i) * x ^ i

Nat.add_zero in Init.Core

lemma poly_ne_zero (n : ‚Ñï) : poly n ‚â† 0

nonpos_iff_eq_zero in Mathlib.Algebra.Order.Monoid.Canonical.Defs

lemma twoAdicGenerators_pow_twoPow_ne_one_of_lt
    {bits : Fin (twoAdicity + 1)} {m : Nat} (hm : m < bits) :
    (twoAdicGenerators[bits]) ^ (2 ^ m) ‚â† (1 : Field)

@[simp]
lemma dfoldrM'_succ {n : ‚Ñï} {Œ± : Fin (n + 1 + 1) ‚Üí Type u}
    (f : (i : Fin (n + 1)) ‚Üí Œ± i.succ ‚Üí m (Œ± i.castSucc)) (x : Œ± (last (n + 1))) :
    dfoldrM' (n + 1) Œ± f x = (do
      let y ‚Üê dfoldrM' n (Œ± ‚àò succ) (fun i => f i.succ) x
      f 0 y)

@[simp]
theorem minPoly_of_powerBasisSucc_generator (k : ‚Ñï) :
  (minpoly (BTField k) (powerBasisSucc k).gen) = X^2 + (Z k) ‚Ä¢ X + 1

lemma eq_zero_or_eq_one_of_lt_two {n : ‚Ñï} (h_lt : n < 2) : n = 0 ‚à® n = 1

@[simp]
theorem drop_update_of_ge (m : ‚Ñï) (h : m ‚â§ n) (v : (i : Fin n) ‚Üí Œ± i) (i : Fin n) (hi : i ‚â• m)
    (x : Œ± i) : drop m h (update v i x) =
      update (drop m h v) ‚ü®i - m, by omega‚ü©
        (dcast (by simp; ext; simp; rw [Nat.sub_add_cancel hi]) x)

lemma h_sub_middle {k : ‚Ñï} (h_pos : k > 0) : 2 ^ k - 1 - 2 ^ (k - 1) + 1 = 2 ^ (k - 1)

theorem prime_29 : Nat.Prime 29

theorem simulateQ'_eq_simulateQ [AlternativeMonad m] [LawfulMonad m]
    {so : QueryImpl spec m} (oa : OracleComp spec Œ±) (h : oa.neverFails) :
      simulateQ' so oa h = simulateQ so oa

lemma towerAlgebraMap_succ (l r : ‚Ñï) (h_le : l ‚â§ r) :
  towerAlgebraMap (l:=l) (r:=r+1) (h_le:=by omega) =
  (towerAlgebraMap (l:=r) (r:=r+1) (h_le:=by omega)).comp
  (towerAlgebraMap (l:=l) (r:=r) (h_le:=by omega))

lemma zero_is_0 {k : ‚Ñï} : (zero (k:=k)) = (0 : ConcreteBTField k)

@[simp]
theorem seqCompose_zero {n : Fin 0 ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    {T : ‚àÄ i, FullTranscript (pSpec i)} :
    seqCompose T = !h[]

private lemma sum_of_not_equals :
  ‚àë x ‚àà B √óÀ¢ B with x.1 ‚â† x.2, (if x.1 i ‚â† x.2 i then 1 else 0)
  =
  2 * choose_2 #B - 2 * ‚àë Œ±, choose_2 (K B i Œ±)

@[simp]
theorem vflatten_splitSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (v : (k : Fin (vsum n)) ‚Üí Œ±) (k : Fin (vsum n)) :
    vflatten (fun i j => v (embedSum i j)) k = v k

@[simp]
theorem ConcreteBTField.RingHom_cast_dest_apply (k m n : ‚Ñï) (h_eq : m = n)
  (f : ConcreteBTField k ‚Üí+* ConcreteBTField m) (x : ConcreteBTField k) :
    (cast (ConcreteBTField.RingHom_eq_of_dest_eq (k:=k) (m:=m) (n:=n) h_eq) f) x
    = cast (by apply cast_ConcreteBTField_eq (h_eq:=h_eq)) (f x)

@[simp]
theorem hcons_one {Œ≤ : Fin (n + 1) ‚Üí Sort u} (a : Œ±) (v : (i : Fin (n + 1)) ‚Üí Œ≤ i) :
    hcons a v 1 = cast (vcons_succ Œ± Œ≤ 0).symm (v 0)

@[simp]
theorem Reduction.runWithLog_discard_logs_eq_run
    {stmt : StmtIn} {wit : WitIn}
    {reduction : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec} :
      Prod.fst <$>
        reduction.runWithLog stmt wit = reduction.run stmt wit

private lemma le_sum_sum_choose_K [Zero F]
  (h_n : 0 < n)
  (h_B : B.card ‚â† 0)
  (h_card : 2 ‚â§ Fintype.card F)
  :
  n * (choose_2 (k B) + (Fintype.card (Œ± := F) - 1)
    * choose_2 ((B.card - k B) / ((Fintype.card (Œ± := F) - 1))))
  ‚â§ ‚àë i, sum_choose_K_i B i

@[simp]
lemma polynomialOfCoeffs_eq_zero :
  polynomialOfCoeffs coeffs = 0 ‚Üî ‚àÄ (x : ‚Ñï) (h : x < deg), coeffs ‚ü®x, h‚ü© = 0

@[simp, grind =]
theorem monomialXY_eq_zero_iff {n m : ‚Ñï} {a : F} : monomialXY n m a = 0 ‚Üî a = 0

@[simp]
theorem vappend_zero (u : Fin m ‚Üí Œ±) {v : Fin 0 ‚Üí Œ±}: vappend u v = u

@[simp]
theorem fcons_succ {Œ≤ : Fin n ‚Üí A} (a : F Œ±) (v : (i : Fin n) ‚Üí F (Œ≤ i)) (i : Fin n) :
    fcons a v i.succ = cast (by simp [vcons_succ]) (v i)

@[simp]
lemma BTField_add_eq (k n m) : BTField (k + n + m) = BTField (k + (n + m))

@[simp]
theorem acceptRejectOracleRel_language :
    acceptRejectOracleRel.language = { (true, isEmptyElim) }

private lemma BerlekampWelchCondition_to_Solution [NeZero n]
  (hk_or_e : 1 ‚â§ k ‚à® 1 ‚â§ e)
  (h : BerlekampWelchCondition e k œâs f E Q)
  : IsBerlekampWelchSolution e k œâs f (E_and_Q_to_a_solution e E Q)

beq_iff_eq in Init.Core

@[simp]
lemma length_getTypes (l : HList) : l.getTypes.length = l.length

@[simp]
theorem fcons_zero {Œ≤ : Fin n ‚Üí A} (a : F Œ±) (b : (i : Fin n) ‚Üí F (Œ≤ i)) :
    fcons a b 0 = cast (by simp [vcons_zero]) a

private lemma le_sum_choose_K [Zero F]
  (h_card : 2 ‚â§ (Fintype.card F)) :
  choose_2 (K B i 0) + (Fintype.card (Œ± := F) - 1) *
  choose_2 ((B.card - K B i 0) / (Fintype.card (Œ± := F) - 1)) ‚â§ sum_choose_K_i B i

lemma subLeftFull_of_vandermonde_is_vandermonde (h : m ‚â§ n) :
  Matrix.vandermonde Œ± = Matrix.subLeftFull (nonsquare n Œ±) (Fin.castLE h)

theorem completeness [DecidableEq Œ±] [SelectableType Œ±] {s}
    (leaf_data_tree : LeafData Œ± s) (idx : BinaryTree.SkeletonLeafIndex s)
    (preexisting_cache : (spec Œ±).QueryCache) :
    (((do
      let cache ‚Üê buildMerkleTree leaf_data_tree
      let proof := generateProof cache idx
      let _ ‚Üê verifyProof idx (leaf_data_tree.get idx) (cache.getRootValue) proof
      ).simulateQ (randomOracle)).run preexisting_cache).neverFails

lemma le_sInf_of_LB {S : Set ‚Ñï} (hne : S.Nonempty) {i : ‚Ñï}
    (hLB : ‚àÄ s ‚àà S, i ‚â§ s) : i ‚â§ sInf S

Fin.val_injective in Mathlib.Data.Fin.Basic

theorem hconcat_left_injective {Œ± : Fin n ‚Üí Sort u} {Œ≤ : Sort u} (a : Œ≤) :
    Function.Injective (fun v : (i : Fin n) ‚Üí Œ± i => hconcat v a)

theorem MLE_mem_restrictDegree (evals : (œÉ ‚Üí Fin 2) ‚Üí R) : (MLE evals) ‚àà R‚¶É‚â§ 1‚¶Ñ[X œÉ]

@[simp]
theorem runWithOracle_freeMonad_pure (f : spec.FunctionType) (a : Option Œ±) :
    runWithOracle f (FreeMonad.pure a) = a

@[simp]
lemma coeff_truncate : (truncate p n).coeff k = if k < n then p.coeff k else 0

lemma zsmul_succ {k : ‚Ñï} (n : ‚Ñï) (x : ConcreteBTField k) :
  (if (‚Üën.succ : ‚Ñ§) % 2 = 0 then zero else x) = (if (‚Üën : ‚Ñ§) % 2 = 0 then zero else x) + x

omit [Finite F] in
lemma domain_surjective (i : ‚Ñï) : i ‚â§ n ‚Üí Function.Surjective (domain D n i)

theorem toFun_eq_const_plus (t : AssocNat) : ‚àÄ m : Nat, t m = t 0 + m

@[simp]
theorem cast_idx_symm {i : MessageIdx pSpec‚ÇÇ} :
    pSpec‚ÇÅ.Message (i.cast hn.symm (cast_symm hSpec)) = pSpec‚ÇÇ.Message i

lemma comp_sub_C_of_linear_eval (p : L[X])
  (h_lin : IsLinearMap ùîΩq (f := fun inner_p ‚Ü¶ p.comp inner_p)) (a : L) :
    p.comp (X - C a) = p - C (eval a p)

theorem intermediateNormVpoly_comp_qmap (i : Fin (‚Ñì))
    (k : Fin (‚Ñì - i - 1)) : -- corresponds to intermediateNormVpoly_comp

@[simp]
theorem rtake_self (v : (i : Fin n) ‚Üí Œ± i) :
    rtake n (by omega) v = fun i : Fin n => dcast (by simp [Fin.cast]) (v i)

theorem eval_zeroOne_eq_MLE_toEvalsZeroOne (p : MvPolynomial œÉ R) (x : œÉ ‚Üí Fin 2) :
    eval (x : œÉ ‚Üí R) p = eval (x : œÉ ‚Üí R) (MLE p.toEvalsZeroOne)

@[simp] -- main lemma for bIdx: Fin (‚Ñì / œë - 1) bounds
lemma bIdx_mul_œë_add_x_lt_‚Ñì_sub_œë (bIdx : Fin (‚Ñì / œë - 1)) (x : ‚Ñï) {hx : x ‚â§ œë} :
    ‚ÜëbIdx * œë + x ‚â§ ‚Ñì - œë

theorem eq_zero_of_degreeOf_lt_card_of_eval_eq_zero {p : R[X œÉ]} (S : œÉ ‚Üí Finset R)
    (hDegree : ‚àÄ i, p.degreeOf i < #(S i))
    (hEval : ‚àÄ x ‚àà piFinset fun i ‚Ü¶ S i, eval x p = 0) : p = 0

lemma not_outOfOrder_of_not_combined (h : ¬¨ E trace) : ¬¨ E_time trace state

theorem foldr_split_inner {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤ ‚Üí Œ≤) (init : Œ≤)
    (l : List Œ±) (h : l ‚â† []): foldr (f:=f) (init:=init) (l)
    = foldr (f:=f) (init:=f (l.getLast (by omega)) (init)) (l.dropLast)

Nat.two_pow_pos in Init.Data.Nat.Basic

lemma runWithOracle_getPutativeRoot {s} (idx : BinaryTree.SkeletonLeafIndex s)
    (leafValue : Œ±) (proof : List Œ±) (f) :
    (runWithOracle f (getPutativeRoot idx leafValue proof))
      =
    getPutativeRoot_with_hash idx leafValue proof fun (left right : Œ±) => (f () ‚ü®left, right‚ü©)

lemma towerRingHomForwardMap_one {k : ‚Ñï} :
  (towerRingHomForwardMap k) 1 = 1

@[simp]
theorem Verifier.id_soundness {lang : Set StmtIn} :
    (Verifier.id : Verifier oSpec _ _ _).soundness init impl lang lang 0

theorem join_of_split {k : ‚Ñï} (h_pos : k > 0) (x : ConcreteBTField k)
    (hi_btf lo_btf : ConcreteBTField (k - 1))
    (h_split_eq : split h_pos x = (hi_btf, lo_btf)) :
    x = „Ää hi_btf, lo_btf „Äã

@[simp]
theorem FullData.toLeafData_leaf {Œ±} (a : Œ±) :
    (FullData.leaf a).toLeafData = LeafData.leaf a

lemma getBit_of_and {n m k: ‚Ñï} : getBit k (n &&& m) = getBit k n &&& getBit k m

@[simp]
theorem embedSum_zero {n : Fin 0 ‚Üí ‚Ñï} {i : Fin 0} (j : Fin (n i)) : embedSum i j = i

theorem get_rtake_ofFn_eq_rtake_comp_cast {Œ± : Type*} {m : ‚Ñï} (v : Fin n ‚Üí Œ±) (h : m ‚â§ n) :
    ((List.ofFn v).rtake m).get =
      rtake m h v ‚àò Fin.cast (by simp [List.rtake]; omega)

theorem last_nonzero_induct [LawfulBEq R] {motive : UniPoly R ‚Üí Prop}
  (case1 : ‚àÄ p, p.last_nonzero = none ‚Üí (‚àÄ i, (hi : i < p.size) ‚Üí p[i] = 0) ‚Üí motive p)
  (case2 : ‚àÄ p : UniPoly R, ‚àÄ k : Fin p.size, p.last_nonzero = some k ‚Üí p[k] ‚â† 0 ‚Üí
    (‚àÄ j : ‚Ñï, (hj : j < p.size) ‚Üí j > k ‚Üí p[j] = 0) ‚Üí motive p)
  (p : UniPoly R) : motive p

omit [Finite F] in
lemma sqr_mem_D_succ_i_of_mem_D_i : ‚àÄ {a : FÀ£} {i : ‚Ñï},
    a ‚àà evalDomain D x i ‚Üí a ^ 2 ‚àà evalDomain D x (i + 1)

lemma matching_set_is_a_sub_of_coeffs_of_close_proximity
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  : matching_set k œâs Œ¥ u‚ÇÄ u‚ÇÅ h_gs ‚äÜ coeffs_of_close_proximity k œâs Œ¥ u‚ÇÄ u‚ÇÅ

theorem knowledgeSoundness_implies_soundness (relIn : Set (StmtIn √ó WitIn))
    (relOut : Set (StmtOut √ó WitOut))
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    (knowledgeError : ‚Ñù‚â•0) (hLt : knowledgeError < 1) :
      knowledgeSoundness init impl relIn relOut verifier knowledgeError ‚Üí
        soundness init impl relIn.language relOut.language verifier knowledgeError

lemma W_monic (i : Fin r) : (W ùîΩq Œ≤ i).Monic

lemma Fin.lt_iff_le_pred (a b : Fin r) (h_b : b > 0) : a < b ‚Üî a ‚â§ b - 1

lemma sup_eq_of_le_of_reach {Œ± Œ≤ : Type} [SemilatticeSup Œ≤] [OrderBot Œ≤] {s : Finset Œ±} {f : Œ± ‚Üí Œ≤}
      (x : Œ±) {y : Œ≤} (h : x ‚àà s) :
    f x = y ‚Üí
    (‚àÄ x ‚àà s, f x ‚â§ y) ‚Üí
    s.sup f = y

theorem two_pow_ne_zero (n : ‚Ñï) : 2 ^ n ‚â† 0

theorem distanceLE_mvPolynomial_degreeLE {œÉ : Type*} [Fintype œÉ] [DecidableEq œÉ] :
    distanceLE (R‚¶É‚â§ d‚¶Ñ[X œÉ]) (Fintype.card œÉ * d)

theorem zero_add : 0 + p = p

lemma natDegree_lt_of_mem_degreeLT [NeZero deg] (h : p ‚àà degreeLT F deg) : p.natDegree < deg

theorem add_zero : @add Œ± zero = @id (ChurchNat Œ±)

theorem div_two_pow_lt_two_pow (x i j : ‚Ñï) (h_x_lt_2_pow_i : x < 2 ^ (i + j)): x / 2^j < 2^(i)

lemma evenPart_x_eval_eq {f : Polynomial F} {s : F} :
    (evenPart_x f).eval (s * s) = (evenPart f).eval s

theorem srKnowledgeSoundness_addSalt_implies_srKnowledgeSoundness_original
    (relIn : Set (StmtIn √ó WitIn)) (relOut : Set (StmtOut √ó WitOut))
    (Salt : pSpec.MessageIdx ‚Üí Type) [‚àÄ i, Nonempty (Salt i)] [‚àÄ i, Fintype (Salt i)]
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    (srInit : ProbComp (srChallengeOracle StmtIn (pSpec.addSalt Salt)).FunctionType)
    (srImpl : QueryImpl oSpec
      (StateT (srChallengeOracle StmtIn (pSpec.addSalt Salt)).FunctionType ProbComp))
    (srKnowledgeError : ‚Ñù‚â•0) :
      Verifier.StateRestoration.knowledgeSoundness srInit srImpl relIn relOut
        (verifier.addSalt Salt) srKnowledgeError ‚Üí
        Verifier.StateRestoration.knowledgeSoundness sorry sorry relIn relOut
          verifier srKnowledgeError

Fin.append_left in Mathlib.Data.Fin.Tuple.Basic

lemma oracle_block_k_next_le (i : Fin (‚Ñì + 1)) (j : Fin (toOutCodewordsCount ‚Ñì œë i))
    (hj : j.val + 1 < toOutCodewordsCount ‚Ñì œë i) : j.val * œë + œë ‚â§ i

omit [DecidableEq ùîΩq] hF‚ÇÇ in
lemma initial_tiled_coeffs_correctness (h_‚Ñì : ‚Ñì ‚â§ r) (a : Fin (2 ^ ‚Ñì) ‚Üí L) :
    let b: Fin (2^(‚Ñì + R_rate)) ‚Üí L := tileCoeffs a
    additiveNTTInvariant ùîΩq Œ≤ h_‚Ñì_add_R_rate b a (i := ‚ü®‚Ñì, by omega‚ü©)

@[simp]
theorem bit_finProdFinEquiv_symm_2_pow_succ {n : ‚Ñï} (j : Fin (2 ^ (n + 1))) (i : Fin (n + 1)) :
  let e:=finProdFinEquiv (m:=2^(n)) (n:=2).symm
  Nat.getBit (i) j = if i.val > 0 then Nat.getBit (i.val-1) (e j).1 else (e j).2

lemma rank_eq_if_subUpFull_eq (h : n ‚â§ m) :
   (subUpFull U (Fin.castLE h)).rank = n  ‚Üí U.rank = n

theorem unique_repr {R : Type*} [CommRing R] {S : Type*} [CommRing S] [Algebra R S]
    (pb : PowerBasis R S) (repr1 repr2 : Fin pb.dim ‚Üí‚ÇÄ R)
    (h : ‚àë i : Fin pb.dim, repr1 i ‚Ä¢ pb.basis i = ‚àë i : Fin pb.dim, repr2 i ‚Ä¢ pb.basis i) :
    repr1 = repr2

@[simp]
theorem vconcat_last (v : Fin n ‚Üí Œ±) (a : Œ±) : vconcat v a (Fin.last n) = a

theorem prime_7 : Nat.Prime 7

omit [NoZeroDivisors ùîΩ] in
lemma foldNth_zero {s : ‚Ñï} {Œ± : ùîΩ} : foldNth (2 ^ s) 0 Œ± = 0

lemma getBit_of_shiftRight {n p : ‚Ñï}:
  ‚àÄ k, getBit k (n >>> p) = getBit (k+p) n

lemma eqRec_fun_eq_eqRec_sort {Œ± : Sort*} {Œ≤ : Œ± ‚Üí Sort u} {a a' : Œ±}
    (h : a = a') (h' : Œ≤ a = Œ≤ a') (b : Œ≤ a) :
  h ‚ñ∏ b = h' ‚ñ∏ b

omit h_Œ≤‚ÇÄ_eq_1 in
theorem sDomainFin_bijective (i : Fin r) (h_i : i < ‚Ñì + R_rate)
: Function.Bijective
  (sDomainFinEquiv ùîΩq Œ≤ h_‚Ñì_add_R_rate i h_i)

theorem elim [LawfulBEq R] (p : UniPoly R) :
    (p.trim = #[] ‚àß  (‚àÄ i, (hi : i < p.size) ‚Üí p[i] = 0))
  ‚à® (‚àÉ k : Fin p.size,
        p.trim = p.extract 0 (k + 1)
      ‚àß p[k] ‚â† 0
      ‚àß (‚àÄ j : ‚Ñï, (hj : j < p.size) ‚Üí j > k ‚Üí p[j] = 0))

theorem finSigmaFinEquiv'_pair {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (i : Fin m) (k : Fin (n i)) :
    (finSigmaFinEquiv' ‚ü®i, k‚ü© : ‚Ñï) = ‚àë j, n (Fin.castLE i.isLt.le j) + k

theorem Fin.sum_univ_odd_even {n : ‚Ñï} {M : Type*} [AddCommMonoid M] (f : ‚Ñï ‚Üí M) :
    (‚àë i : Fin (2 ^ n), f (2 * i)) + (‚àë i : Fin (2 ^ n), f (2 * i + 1))
    = ‚àë i: Fin (2 ^ (n+1)), f i

theorem tail_init_eq_init_tail (s : Fin (n + 2) ‚Üí‚ÇÄ M) : tail (init s) = init (tail s)

@[simp]
lemma OracleVerifier.id_rbrKnowledgeSoundness
    {rel : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness)} :
    (OracleVerifier.id : OracleVerifier oSpec Statement OStatement _ _ _).rbrKnowledgeSoundness
      init impl rel rel 0

theorem sum_of_pow_exp_of_2 {F : Type*} [Field F]
  (sumZeroIffEq : ‚àÄ (x y : F), x + y = 0 ‚Üî x = y)
  (i : ‚Ñï) : ‚àÄ (a b c : F), a + b = c ‚Üí a^(2^i) + b^(2^i) = c^(2^i)

@[simp]
theorem runWithOracle_freeMonad_pure_some (f : spec.FunctionType) (a : Œ±) :
    runWithOracle f (FreeMonad.pure (a : Option Œ±)) = a

theorem add_assoc : p + q + r = p + (q + r)

theorem eval‚ÇÇ_quadratic_prevField_coeff
  {prevBTField : Type*} [CommRing prevBTField]
  {curBTField : Type*} [CommRing curBTField]
  (of_prev : prevBTField ‚Üí+* curBTField)
  (t1 : prevBTField)
  (x : curBTField) :
  eval‚ÇÇ of_prev x (X^2 + (C t1 * X + 1)) = x^2 + of_prev t1 * x + 1

theorem liftContext_run
    {lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    {outerStmtIn : OuterStmtIn} {outerWitIn : OuterWitIn}
    {R : Reduction oSpec InnerStmtIn InnerWitIn InnerStmtOut InnerWitOut pSpec} :
      (R.liftContext lens).run outerStmtIn outerWitIn = do
        let ‚ü®‚ü®fullTranscript, innerCtxOut‚ü©, verInnerStmtOut‚ü© ‚Üê
          R.run.uncurry (lens.proj (outerStmtIn, outerWitIn))
        return ‚ü®‚ü®fullTranscript, lens.lift (outerStmtIn, outerWitIn) innerCtxOut‚ü© ,
                lens.stmt.lift outerStmtIn verInnerStmtOut‚ü©

@[simp]
lemma foldl'_zero {Œ± : Type u} (f : (i : Fin 0) ‚Üí Œ± ‚Üí Œ±) (x : Œ±) :
    foldl' 0 f x = x

theorem cast_run (stmt : StmtIn) (wit : WitIn)
    (P : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec‚ÇÅ) :
    P.run stmt wit =
      cast (sorry) ((P.cast hn hSpec).run stmt wit)

theorem distFromCode_eq_zero_iff_mem (C : Set (n ‚Üí R)) (u : n ‚Üí R) : Œî‚ÇÄ(u, C) = 0 ‚Üî u ‚àà C

theorem vconcat_eq_snoc (v : Fin n ‚Üí Œ±) (a : Œ±) : vconcat v a = snoc v a

Nat.lt_of_add_right_lt in Init.Data.Nat.Basic

@[simp]
theorem verifier_last (pSpec : ProtocolSpec n) [NeZero n] [h : VerifierLast pSpec] :
    pSpec.dir ‚ü®n - 1, by simp [Nat.pos_of_neZero]‚ü© = .V_to_P

theorem support_mul_C_le (p : MvPolynomial œÉ R) (r : R) : (p * C r).support ‚äÜ p.support

theorem Nat.reconstruct_from_hi_and_lo_parts (n hi_len lo_len : ‚Ñï)
    (h_n : n < 2 ^ (hi_len + lo_len)) :
    n = (((n >>> lo_len) % (2 ^ hi_len)) <<< lo_len) + (n % (2 ^ lo_len))

@[simp]
theorem eqPolynomial_eval_zeroOne (r x : œÉ ‚Üí Fin 2) :
    eval (x : œÉ ‚Üí R) (eqPolynomial r) = if x = r then 1 else 0

theorem rightpad_toList {a : Array Œ±} {n : Nat} {unit : Œ±} :
    a.rightpad n unit = mk (a.toList.rightpad n unit)

lemma nsmul_succ {k : ‚Ñï} (n : ‚Ñï) (x : ConcreteBTField k) :
  (if ‚Üën.succ % 2 = 0 then zero else x) = (if ‚Üën % 2 = 0 then zero else x) + x

@[grind _=_]
theorem monomialXY_def {n m : ‚Ñï} {a : F} : monomialXY n m a = monomial m (monomial n a)

lemma getBit_zero_eq_self {n : ‚Ñï} (h_n : n < 2) : getBit 0 n = n

theorem finSuccEquivNth_rename_finSuccEquivNth (e : œÉ ‚âÉ Fin n) (œÜ : MvPolynomial (Option œÉ) R) :
    ((finSuccEquivNth R p) ((rename ((Equiv.optionCongr e).trans (_root_.finSuccEquiv' p).symm)) œÜ))
      = Polynomial.map (rename e).toRingHom (optionEquivLeft R œÉ œÜ)

omit [DecidableEq L] [Fintype ùîΩq] hŒ≤_lin_indep in
lemma W‚ÇÄ_eq_X : W ùîΩq Œ≤ 0 = X

theorem sub_add_eq_sub_sub_rev (a b c : Nat) (h1 : c ‚â§ b) (h2 : b ‚â§ a) :
  a - b + c = a - (b - c)

omit [NeZero ‚Ñì] [NeZero r] [NeZero ùì°] in
lemma ‚Ñì_lt_r {h_‚Ñì_add_R_rate : ‚Ñì + ùì° < r}
    : ‚Ñì < r

lemma split_join_eq_split {k : ‚Ñï} (h_pos : k > 0)
    (hi_btf lo_btf : ConcreteBTField (k - 1)) :
    split h_pos („Ää hi_btf, lo_btf „Äã) = (hi_btf, lo_btf)

@[simp]
theorem cast_id : Transcript.cast rfl rfl rfl = (id : pSpec‚ÇÅ.Transcript k ‚Üí _)

theorem GF_2_value_eq_zero_or_one (x : GF(2)) : x = 0 ‚à® x = 1

@[simp]
theorem mul_accepts_iff : (mul a b c).accepts x ‚Üî x c = x a * x b

lemma concrete_one_mul0 (a : ConcreteBTField 0) :
  concrete_mul (one (k:=0)) a = a

Nat.succ_lt_succ_iff in Init.Data.Nat.Basic

lemma twoAdicity_maximal : ¬¨ (2 ^ (twoAdicity + 1)) ‚à£ (fieldSize - 1)

theorem snoc_ne_zero_of_right (h : y ‚â† 0) : snoc s y ‚â† 0

@[simp]
theorem fflatten_succ {A : Sort u} {F : A ‚Üí Sort v} {m : ‚Ñï} {n : Fin (m + 1) ‚Üí ‚Ñï}
    {Œ± : (i : Fin (m + 1)) ‚Üí (j : Fin (n i)) ‚Üí A}
    {v : (i : Fin (m + 1)) ‚Üí (j : Fin (n i)) ‚Üí F (Œ± i j)} :
    fflatten v = fappend (v 0) (fflatten (fun i => v i.succ))

theorem append_rbrSoundness (V‚ÇÅ : OracleVerifier oSpec Stmt‚ÇÅ OStmt‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : OracleVerifier oSpec Stmt‚ÇÇ OStmt‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ pSpec‚ÇÇ)
    {rbrSoundnessError‚ÇÅ : pSpec‚ÇÅ.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    {rbrSoundnessError‚ÇÇ : pSpec‚ÇÇ.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    (h‚ÇÅ : V‚ÇÅ.rbrSoundness init impl lang‚ÇÅ lang‚ÇÇ rbrSoundnessError‚ÇÅ)
    (h‚ÇÇ : V‚ÇÇ.rbrSoundness init impl lang‚ÇÇ lang‚ÇÉ rbrSoundnessError‚ÇÇ) :
      (V‚ÇÅ.append V‚ÇÇ).rbrSoundness init impl lang‚ÇÅ lang‚ÇÉ
        (Sum.elim rbrSoundnessError‚ÇÅ rbrSoundnessError‚ÇÇ ‚àò ChallengeIdx.sumEquiv.symm)

@[simp] theorem join_cons : (l :: ls).join = l ++ ls.join

lemma towerRingHomForwardMap0_eq :
  towerRingEquivFromConcrete0.toFun = towerRingHomForwardMap 0

@[simp]
theorem ConcreteBTField.RingHom_eq_of_dest_eq (k m n : ‚Ñï) (h_eq : m = n) :
    (ConcreteBTField k ‚Üí+* ConcreteBTField m)
    = (ConcreteBTField k ‚Üí+* ConcreteBTField n)

@[simp]
lemma coeff_polynomialOfCoeffs_eq_coeffs'' :
  (polynomialOfCoeffs coeffs).coeff = Fin.liftF coeffs

theorem qMap_total_fiber_disjoint
  (i : Fin ‚Ñì) (steps : ‚Ñï) (h_i_add_steps : i + steps ‚â§ ‚Ñì)
  {y‚ÇÅ y‚ÇÇ : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i.val + steps, by omega‚ü©}
  (hy_ne : y‚ÇÅ ‚â† y‚ÇÇ) :
  Disjoint
    ((qMap_total_fiber ùîΩq Œ≤ (i := ‚ü®i, by omega‚ü©) (steps := steps)
      (h_i_add_steps := fin_‚Ñì_steps_lt_‚Ñì_add_R i steps h_i_add_steps) y‚ÇÅ '' Set.univ).toFinset)
    ((qMap_total_fiber ùîΩq Œ≤ (i := ‚ü®i, by omega‚ü©) (steps := steps)
      (h_i_add_steps := fin_‚Ñì_steps_lt_‚Ñì_add_R i steps h_i_add_steps) y‚ÇÇ '' Set.univ).toFinset)

lemma h_sum_two_same_pow2 {k : ‚Ñï} (h_pos : k > 0) : 2 ^ (k - 1) + 2 ^ (k - 1) = 2 ^ k

lemma and_one_eq_of_eq {a b : ‚Ñï} : a = b ‚Üí a &&& 1 = b &&& 1

theorem addCases_left' {motive : Fin (m + n) ‚Üí Sort*}
    {left : (i : Fin m) ‚Üí motive (castAdd n i)} {right : (j : Fin n) ‚Üí motive (natAdd m j)}
    {i : Fin m} (j : Fin (m + n)) (h : j = castAdd n i) :
      addCases (motive := motive) left right j = h ‚ñ∏ (left i)

omit [CharP L 2] [DecidableEq ùîΩq] hF‚ÇÇ h_Œ≤‚ÇÄ_eq_1 [NeZero ùì°] in
lemma take_snoc_oracle_eq_oStmtIn (i : Fin ‚Ñì)
    (oStmtIn : (j : Fin (toOutCodewordsCount ‚Ñì œë i.castSucc)) ‚Üí
      OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j)
    (newOracleFn : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ) :
    (take_snoc_oracle ùîΩq Œ≤ i oStmtIn newOracleFn) = oStmtIn

lemma algebraMap_adjacent_tower_succ_eq_Adjoin_of (k : ‚Ñï) :
  (algebraMap (BTField k) (BTField (k + 1))) = of (poly k)

omit h_Fq_char_prime hF‚ÇÇ in
lemma inductive_rec_form_W_comp (i : Fin r) (h_i_add_1 : i + 1 < r)
    (h_prev_linear_map : IsLinearMap (R := ùîΩq) (M := L[X]) (M‚ÇÇ := L[X])
      (f := fun inner_p ‚Ü¶ (W ùîΩq Œ≤ i).comp inner_p))
    : ‚àÄ p: L[X], (W ùîΩq Œ≤ (i + 1)).comp p =
      ((W ùîΩq Œ≤ i).comp p) ^ Fintype.card ùîΩq -
        C (eval (Œ≤ i) (W ùîΩq Œ≤ i)) ^ (Fintype.card ùîΩq - 1) * ((W ùîΩq Œ≤ i).comp p)

Nat.sub_mul in Init.Data.Nat.Basic

@[simp]
theorem fconcat‚ÇÇ_castSucc {Œ±‚ÇÅ : Fin n ‚Üí A} {Œ±‚ÇÇ : Fin n ‚Üí B} {Œ≤‚ÇÅ : A} {Œ≤‚ÇÇ : B}
    (v : (i : Fin n) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i)) (a : F‚ÇÇ Œ≤‚ÇÅ Œ≤‚ÇÇ) (i : Fin n) :
    fconcat‚ÇÇ (F := F‚ÇÇ) v a (castSucc i) =
      cast (by simp [vconcat_castSucc]) (v i)

@[simp] theorem fromNat_toNat_eq_self {k : ‚Ñï} (bv : BitVec (2 ^ k)) :
  (fromNat (BitVec.toNat bv) : ConcreteBTField k) = bv

lemma forwardRange_length (n : ‚Ñï) (r : Fin n) (l : Fin (r.val + 1)) :
    (forwardRange n r l).length = r.val - l.val + 1

private lemma Fis_cover_B : B = Finset.univ.biUnion (Fi B i)

@[simp]
theorem oracleReduction_perfectCompleteness (hInit : init.neverFails) :
    (oracleReduction oSpec Statement OStatement Witness).perfectCompleteness init impl rel rel

@[simp]
lemma oddPart_coeff {f : Polynomial F} {n : ‚Ñï} :
    (oddPart f).coeff n = if Even n then f.coeff (n + 1) else 0

@[simp]
theorem BTField.Basis_cast_index_apply {Œ± Œ≤ i j : ‚Ñï} {k : Fin j} (h_le : Œ± ‚â§ Œ≤) (h_eq : i = j)
  {b : @Basis (Fin (i)) (BTField Œ±) (BTField Œ≤) _ _
    (@binaryAlgebraTower (l := Œ±) (r := Œ≤) (h_le := h_le)).toModule} :
  let castBasis : @Basis (Fin j) (BTField Œ±) (BTField Œ≤) _ _
    (@binaryAlgebraTower (l:=Œ±) (r:=Œ≤) (h_le:=h_le)).toModule :=
    cast (by exact BTField.Basis_cast_index_eq i j Œ± Œ≤ h_le h_eq) b
  (castBasis k) = b (Fin.cast (h_eq.symm) k)

@[ext]
theorem ext' {a b : AssocNat} (h : a 0 = b 0) : a = b

lemma isPrimitiveRoot_twoAdicGenerator (bits : Fin (twoAdicity + 1)) :
    IsPrimitiveRoot (twoAdicGenerators[bits]) (2 ^ (bits : Nat))

lemma linsolve_is_berlekamp_welch_solution
  (h_linsolve : linsolve (BerlekampWelchMatrix e k œâs f) (Rhs e œâs f) = some v)
  : IsBerlekampWelchSolution e k œâs f v

theorem decoder_dist_impl_mem
  {k r D e : ‚Ñï}
  (h_e : e ‚â§ n - Real.sqrt (k * n))
  {œâs : Fin n ‚Ü™ F}
  {f : Fin n ‚Üí F}
  {p : F[X]}
  (h_dist : Œî‚ÇÄ(f, p.eval ‚àò œâs) ‚â§ e)
  :
  p ‚àà decoder k r D e œâs f

theorem changeOfBasisMatrix_det_ne_zero
  (‚Ñì : Nat) (h_‚Ñì : ‚Ñì ‚â§ r) :
  (changeOfBasisMatrix ùîΩq Œ≤ ‚Ñì h_‚Ñì).det ‚â† 0

theorem BaseField_is_prime : Nat.Prime baseFieldSize

@[simp]
lemma Rhs_zero_eq_neg' : Rhs 0 œâs f = -f

NeZero.ne in Init.Data.NeZero

@[simp]
theorem dist_subsingleton {C : Set (n ‚Üí R)} [Subsingleton C] : ‚ÄñC‚Äñ‚ÇÄ = 0

lemma list_0 : list 0 = List.Vector.cons (1 : GF(2)) List.Vector.nil

lemma shiftRight_and_one_distrib {n m k : ‚Ñï} :
    Nat.getBit k (n &&& m) = Nat.getBit k n &&& Nat.getBit k m

theorem traceMapProperty_of_quadratic_extension
  (F_prev : Type*) [Field F_prev] [Fintype F_prev] (k : ‚Ñï)
  (fintypeCardPrev : Fintype.card F_prev = 2 ^ (2 ^ k))
  (t1 : F_prev) [instNeZero_t1 : NeZero t1]
  {F_cur : Type*} [Field F_cur] (u : F_cur) [instNeZero_u : NeZero u]
  [Algebra F_prev F_cur]
  (h_rel : SpecialElementRelation (t1 := t1) (u := u))
  (prev_trace_map : TraceMapProperty F_prev t1 (k))
  (sumZeroIffEq : ‚àÄ (x y : F_cur), x + y = 0 ‚Üî x = y)
  : TraceMapProperty F_cur u (k + 1)

@[simp] lemma ofMvPolynomialAlgHom_X (s : œÉ) :
    ofMvPolynomialAlgHom (MvPolynomial.X s : MvPolynomial œÉ R) = (X s : P)

theorem last_nonzero_last_iff [LawfulBEq R] {p : UniPoly R} (hp : p.size > 0) :
  p.last_nonzero = some ‚ü® p.size - 1, Nat.pred_lt_self hp ‚ü© ‚Üî p.getLast hp ‚â† 0

lemma U_card (i : Fin r) :
    Fintype.card (U ùîΩq Œ≤ i) = (Fintype.card ùîΩq)^i.val

protected lemma errors_are_roots_of_elocPolyF {i : Fin n} {œâs f : Fin n ‚Üí F}
  (h : f i ‚â† p.eval (œâs i)) : (ElocPolyF œâs f p).eval (œâs i) = 0

theorem concreteTowerAlgebraMap_assoc :
    ‚àÄ r mid l : ‚Ñï, (h_l_le_mid : l ‚â§ mid) ‚Üí (h_mid_le_r : mid ‚â§ r) ‚Üí
    concreteTowerAlgebraMap (l:=l) (r:=r) (h_le:=by exact Nat.le_trans h_l_le_mid h_mid_le_r) =
    (concreteTowerAlgebraMap (l:=mid) (r:=r) (h_le:=h_mid_le_r)).comp
    (concreteTowerAlgebraMap (l:=l) (r:=mid) (h_le:=h_l_le_mid))

@[simp]
theorem rtake_apply (v : (i : Fin n) ‚Üí Œ± i) (m : ‚Ñï) (h : m ‚â§ n)
    (i : Fin m) : rtake m h v i = v (Fin.cast (Nat.sub_add_cancel h) (natAdd (n - m) i))

theorem support_C {r : R} [h : Decidable (r = 0)] :
    (@C R œÉ _ r).support = if r = 0 then ‚àÖ else { 0 }

theorem BerlekampWelchCondition_iff_Solution {e k : ‚Ñï} [NeZero n]
  {œâs f : Fin n ‚Üí F} {v : Fin (2 * e + k) ‚Üí F}
  :
  IsBerlekampWelchSolution e k œâs f v
  ‚Üî
  (BerlekampWelchCondition e k œâs f (solutionToE e k v) (solutionToQ e k v))

@[simp]
theorem dist_le_card (C : Set (n ‚Üí R)) : dist C ‚â§ Fintype.card n

@[simp]
theorem vflatten_zero {n : Fin 0 ‚Üí ‚Ñï} {v : (i : Fin 0) ‚Üí Fin (n i) ‚Üí Œ±} : vflatten v = !v[]

Nat.add_left_cancel in Init.Data.Nat.Basic

theorem append_run (stmt : Stmt‚ÇÅ) (wit : Wit‚ÇÅ) :
      (P‚ÇÅ.append P‚ÇÇ).run stmt wit = (do
        let ‚ü®transcript‚ÇÅ, stmt‚ÇÇ, wit‚ÇÇ‚ü© ‚Üê liftM (P‚ÇÅ.run stmt wit)
        let ‚ü®transcript‚ÇÇ, stmt‚ÇÉ, wit‚ÇÉ‚ü© ‚Üê liftM (P‚ÇÇ.run stmt‚ÇÇ wit‚ÇÇ)
        return ‚ü®transcript‚ÇÅ ++‚Çú transcript‚ÇÇ, stmt‚ÇÉ, wit‚ÇÉ‚ü©)

lemma getBit_eq_zero_or_one {k n : Nat} :
  getBit k n = 0 ‚à® getBit k n = 1

theorem coeff_of_toMvPolynomial_eq_coeff_of_MlPoly (p : MlPoly R n) (m : Fin n ‚Üí‚ÇÄ ‚Ñï) :
  coeff m (toMvPolynomial p) =
    if h_binary: (‚àÄ j: Fin n, m j ‚â§ 1) then
      let i_of_m: ‚Ñï := Nat.binaryFinMapToNat (m:=m) (h_binary:=h_binary)
      p[i_of_m]
    else
      0

theorem functional_completeness (Œ± : Type) {s : Skeleton}
  (idx : SkeletonLeafIndex s)
  (leaf_data_tree : LeafData Œ± s)
  (hash : Œ± ‚Üí Œ± ‚Üí Œ±) :
  (getPutativeRoot_with_hash
    idx
    (leaf_data_tree.get idx)
    (generateProof
      (buildMerkleTree_with_hash leaf_data_tree hash) idx)
    (hash)) =
  (buildMerkleTree_with_hash leaf_data_tree hash).getRootValue

@[simp] theorem rightpad_getD_eq_getD (l : List Œ±) (n : Nat) (unit : Œ±) (i : Nat) :
    (rightpad n unit l).getD i unit = l.getD i unit

@[to_additive (attr := simp)]
theorem prod_Iic_zero : ‚àè j ‚àà Iic 0, v j = v 0

theorem happend_hcons {Œ≤ : Fin m ‚Üí Sort u} {Œ≥ : Fin n ‚Üí Sort u}
    (a : Œ±) (u : (i : Fin m) ‚Üí Œ≤ i) (v : (i : Fin n) ‚Üí Œ≥ i) :
    True

@[simp]
theorem removeNth_apply : removeNth p s i = s (p.succAbove i)

@[simp]
lemma polynomialOfCoeffs_mem_degreeLT [NeZero deg] :
  polynomialOfCoeffs coeffs ‚àà degreeLT F deg

@[simp]
theorem seqCompose_succ_eq_append {m : ‚Ñï} {n : Fin (m + 1) ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    {T : ‚àÄ i, FullTranscript (pSpec i)} :
    seqCompose T = append (T 0) (seqCompose (fun i => T (Fin.succ i)))

@[simp, grind =]
theorem leadingCoeffY_eq_zero (f : F[X][Y]) : leadingCoeffY f = 0 ‚Üî f = 0

theorem pow_three_eq_mul_sq {a : CNat 1} : a ^ 3 = a * (a * a)

lemma extract_stop_last_eq_drop {n : ‚Ñï} {Œ± : Fin n ‚Üí Sort*} (start : ‚Ñï) (h : start ‚â§ n)
    (v : (i : Fin n) ‚Üí Œ± i) : extract start n h (Nat.le_refl _) v = drop start h v

@[simp]
theorem cast_idx {i : ChallengeIdx pSpec‚ÇÅ} :
    pSpec‚ÇÇ.Challenge (i.cast hn hSpec) = pSpec‚ÇÅ.Challenge i

@[simp] theorem leftpad_eq_self (l : List Œ±) (n : Nat) (h : l.length ‚â• n) :
    leftpad n unit l = l

@[csimp, grind =]
theorem findIdx'_eq_findIdx : @findIdx' = @findIdx

lemma monoToLagrange_eq_monoToLagrange_segment (n : ‚Ñï) [NeZero n] (v : Vector R (2 ^ n)) :
  have h_n_ne_zero: n ‚â† 0

lemma aeval_eq' {A : Type y} [CommSemiring A] [Algebra R A] {F : Type z} [FunEquiv F œÉ A]
    (f : P ‚Üí‚Çê[R] A) (p : P) : f p = aeval (fun s => f (X s) : F) p

@[simp] lemma twoAdicGenerators_succ_square_eq' (idx : Fin twoAdicity) :
    twoAdicGenerators[idx.val + 1] ^ 2 = twoAdicGenerators[idx]

omit [Fintype L] [DecidableEq L] [Fintype ùîΩq] h_Fq_char_prime hŒ≤_lin_indep in
lemma Œ≤_lt_mem_U (i : Fin r) (j : Fin i) :
  Œ≤ ‚ü®j, by omega‚ü© ‚àà U ùîΩq Œ≤ (i:=i)

@[simp]
lemma invFun_toFun (f : F) : inst.equiv.invFun (inst.equiv.toFun f) = f

lemma rank_eq_min_row_col_rank : U.rank = min (rowRank U) (colRank U)

@[simp]
theorem fappend‚ÇÇ_succ {Œ±‚ÇÅ : Fin m ‚Üí A} {Œ±‚ÇÇ : Fin m ‚Üí B}
    {Œ≤‚ÇÅ : Fin (n + 1) ‚Üí A} {Œ≤‚ÇÇ : Fin (n + 1) ‚Üí B}
    (u : (i : Fin m) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i)) (v : (i : Fin (n + 1)) ‚Üí F‚ÇÇ (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) :
    fappend‚ÇÇ (F := F‚ÇÇ) u v =
      fconcat‚ÇÇ (F := F‚ÇÇ) (fappend‚ÇÇ (F := F‚ÇÇ) u (fun i => v (castSucc i))) (v (last n))

theorem succ'_injective : Function.Injective (succ' : Nat ‚Üí Nat)

theorem fconcat‚ÇÇ_injective2 {Œ±‚ÇÅ : Fin n ‚Üí A} {Œ±‚ÇÇ : Fin n ‚Üí B} {Œ≤‚ÇÅ : A} {Œ≤‚ÇÇ : B} :
    Function.Injective2 (@fconcat‚ÇÇ A B F‚ÇÇ n Œ±‚ÇÅ Œ≤‚ÇÅ Œ±‚ÇÇ Œ≤‚ÇÇ)

theorem seqCompose_perfectCompleteness (hInit : init.neverFails)
    (rel : (i : Fin (m + 1)) ‚Üí Set ((Stmt i √ó ‚àÄ j, OStmt i j) √ó Wit i))
    (R : ‚àÄ i, OracleReduction oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Wit i.castSucc)
      (Stmt i.succ) (OStmt i.succ) (Wit i.succ) (pSpec i))
    (h : ‚àÄ i, (R i).perfectCompleteness init impl (rel i.castSucc) (rel i.succ)) :
      (OracleReduction.seqCompose Stmt OStmt Wit R).perfectCompleteness
        init impl (rel 0) (rel (Fin.last m))

Fin.eta in Init.Data.Fin.Lemmas

theorem succ_mul {a b : AssocNat} : (succ a) * b = a * b + b

theorem verifier_rbrKnowledgeSoundness [Fintype R] :
    (verifier R n deg D oSpec i).rbrKnowledgeSoundness init impl
    (relationRound R n deg D i.castSucc) (relationRound R n deg D i.succ)
    (fun _ => (deg : ‚Ñù‚â•0) / Fintype.card R)

lemma concreteTowerAlgebraMap_succ (l r : ‚Ñï) (h_le : l ‚â§ r) :
  concreteTowerAlgebraMap (l:=l) (r:=r + 1) (h_le:=by omega) =
  (concreteTowerAlgebraMap (l:=r) (r:=r + 1) (h_le:=by omega)).comp
  (concreteTowerAlgebraMap (l:=l) (r:=r) (h_le:=by omega))

@[simp]
theorem init_snoc : init (snoc s y) = s

theorem fconcat‚ÇÇ_left_injective {Œ±‚ÇÅ : Fin n ‚Üí A} {Œ±‚ÇÇ : Fin n ‚Üí B} {Œ≤‚ÇÅ : A} {Œ≤‚ÇÇ : B} (a : F‚ÇÇ Œ≤‚ÇÅ Œ≤‚ÇÇ) :
    Function.Injective (fun v : (i : Fin n) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i) => fconcat‚ÇÇ (F := F‚ÇÇ) v a)

lemma and_shl_eq_zero_of_lt_two_pow {a n b : ‚Ñï} (hb : b < 2 ^ n) : (a <<< n) &&& b = 0

omit [DecidableEq L] h_Fq_char_prime hF‚ÇÇ hŒ≤_lin_indep in
lemma Prod_W_comp_X_sub_C_ne_zero (i : Fin r) :
    (univ : Finset ùîΩq).prod (fun c => (W ùîΩq Œ≤ i).comp (X - C (c ‚Ä¢ Œ≤ i))) ‚â† 0

theorem hconcat_inj {Œ± : Fin n ‚Üí Sort u} {Œ≤ : Sort u} (v‚ÇÅ v‚ÇÇ : (i : Fin n) ‚Üí Œ± i) (a‚ÇÅ a‚ÇÇ : Œ≤) :
    hconcat v‚ÇÅ a‚ÇÅ = hconcat v‚ÇÇ a‚ÇÇ ‚Üî v‚ÇÅ = v‚ÇÇ ‚àß a‚ÇÅ = a‚ÇÇ

theorem fcons_left_injective {Œ≤ : Fin n ‚Üí A} (b : (i : Fin n) ‚Üí F (Œ≤ i)) :
    Function.Injective (fun (a : F Œ±) => fcons a b)

lemma getMiddleBits_lt_two_pow {n offset len : ‚Ñï} :
  getMiddleBits offset len n < 2 ^ len

@[simp]
theorem ConcreteBTFieldAlgebra_id {l r : ‚Ñï} (h_eq : l = r) :
    @ConcreteBTFieldAlgebra l r (h_le:=by omega) =
    (h_eq ‚ñ∏ (Algebra.id (ConcreteBTField l)) :
      Algebra (ConcreteBTField l) (ConcreteBTField r))

lemma e_leq_dist_over_3 [DecidableEq F] {deg : ‚Ñï} {Œ± : Œπ ‚Ü™ F} {e : ‚Ñï} {u v : Œπ ‚Üí F}
  (he : (e : ‚Ñö) < (Code.minDist (RScodeSet Œ± deg) : ‚Ñö) / 3) :
  ‚àÄ x ‚àà Affine.line u v, distFromCode x (ReedSolomon.code Œ± deg) ‚â§ e
  ‚à® (numberOfClosePts u v deg Œ± e) ‚â§ Code.minDist (RScodeSet Œ± deg)

lemma rootMultiplicity_W (i : Fin r) (a : L) :
    rootMultiplicity a (W ùîΩq Œ≤ i) = if a ‚àà (U ùîΩq Œ≤ i : Set L) then 1 else 0

theorem evalNormalizedWAt_eq_normalizedW (i : Fin r) (x : L) :
  evalNormalizedWAt (Œ≤ := Œ≤) (‚Ñì := ‚Ñì) (R_rate := R_rate) (i := i) x
    = (normalizedW (ùîΩq := ùîΩq) (Œ≤ := Œ≤) (i := i)).eval x

theorem FullTranscript.mk2_eq_snoc_snoc {pSpec : ProtocolSpec 2} (msg0 : pSpec.¬´Type¬ª 0)
    (msg1 : pSpec.¬´Type¬ª 1) :
      FullTranscript.mk2 msg0 msg1 = ((default : pSpec.Transcript 0).concat msg0).concat msg1

@[simp] theorem BitVec.dcast_one {n m : ‚Ñï} (h : n = m) : DCast.dcast h (1#n) = 1#m

theorem SkeletonNodeIndex.parent_of_depth_zero {s : Skeleton}
    (idx : SkeletonNodeIndex s) (h : idx.depth = 0) :
    parent idx = none

lemma concrete_mul_comm0 (a b : ConcreteBTField 0) :
  concrete_mul a b = concrete_mul b a

@[simp, grind] lemma fin_chunkSize_lt_N (arrSize : Nat) (i : Fin (min arrSize SpongeSize.R)) :
    i < SpongeSize.N

@[simp]
lemma OracleVerifier.id_toVerifier :
    (OracleVerifier.id : OracleVerifier oSpec Statement OStatement _ _ _).toVerifier =
      Verifier.id

theorem dcast_fun‚ÇÇ {a‚ÇÅ a‚ÇÇ a‚ÇÅ' a‚ÇÇ' : Œ±} {h‚ÇÅ : a‚ÇÅ = a‚ÇÅ'} {h‚ÇÇ : a‚ÇÇ = a‚ÇÇ'} {f : Œ± ‚Üí Œ± ‚Üí Œ±}
    {g : (a‚ÇÅ : Œ±) ‚Üí (a‚ÇÇ : Œ±) ‚Üí Œ≤ a‚ÇÅ ‚Üí Œ≤ a‚ÇÇ ‚Üí Œ≤ (f a‚ÇÅ a‚ÇÇ)} {b‚ÇÅ : Œ≤ a‚ÇÅ} {b‚ÇÇ : Œ≤ a‚ÇÇ} :
    dcast (by cases h‚ÇÅ; cases h‚ÇÇ; rfl) (g a‚ÇÅ a‚ÇÇ b‚ÇÅ b‚ÇÇ) = g a‚ÇÅ' a‚ÇÇ' (dcast h‚ÇÅ b‚ÇÅ) (dcast h‚ÇÇ b‚ÇÇ)

lemma dim_eq_deg_of_le [NeZero n] (inj : Function.Injective Œ±) (h : n ‚â§ m) :
  dim (ReedSolomon.code ‚ü®Œ±, inj‚ü© n) = n

lemma h_middle_sub {k : ‚Ñï} : 2 ^ (k - 1) - 1 - 0 + 1 = 2 ^ (k - 1)

theorem withBot_lt_one_cases (x : WithBot ‚Ñï) (h : x < (1 : ‚Ñï)) : x = ‚ä• ‚à® x = (0 : ‚Ñï)

Nat.pow_lt_pow_right in Init.Data.Nat.Lemmas

@[simp]
lemma seqCompose_zero
    (Stmt : Fin 1 ‚Üí Type) (Wit : Fin 1 ‚Üí Type) {n : Fin 0 ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (P : (i : Fin 0) ‚Üí
      Prover oSpec (Stmt i.castSucc) (Wit i.castSucc) (Stmt i.succ) (Wit i.succ) (pSpec i)) :
    seqCompose Stmt Wit P = Prover.id

theorem Basis_cast_dest_eq {Œπ : Type*} (k n m : ‚Ñï) (h_k_le_n : k ‚â§ n)
  (h_k_le_m : k ‚â§ m) (h_eq : m = n) :
  letI instLeftAlgebra := ConcreteBTFieldAlgebra (l:=k) (r:=m) (h_le:=h_k_le_m)
  letI instRightAlgebra := ConcreteBTFieldAlgebra (l:=k) (r:=n) (h_le:=h_k_le_n)
  @Basis Œπ (ConcreteBTField k) (ConcreteBTField m) _ _ instLeftAlgebra.toModule =
  @Basis Œπ (ConcreteBTField k) (ConcreteBTField n) _ _ instRightAlgebra.toModule

@[simp]
theorem codeDist'_subsingleton [Subsingleton C] : ‚ÄñC‚Äñ‚ÇÄ' = ‚ä§

@[simp]
lemma natDegree_polynomialOfCoeffs_deg_lt_deg
  [NeZero deg] {coeffs : Fin deg ‚Üí F} :
  (polynomialOfCoeffs coeffs).natDegree < deg

theorem vcons_injective2 : Function.Injective2 (@vcons Œ± n)

theorem oracleVerifier_rbrKnowledgeSoundness [Fintype R] :
    (oracleVerifier R deg D n oSpec).rbrKnowledgeSoundness init impl
      (relationRound R n deg D 0) (relationRound R n deg D (.last n))
      (fun _ => (deg : ‚Ñù‚â•0) / (Fintype.card R))

theorem fconcat_injective2 {Œ± : Fin n ‚Üí A} {Œ≤ : A} :
    Function.Injective2 (@fconcat A F n Œ± Œ≤)

theorem split_zero {k : ‚Ñï} (h_pos : k > 0) : split h_pos zero = (zero, zero)

theorem liftContext_runToRound
    {lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    {outerStmtIn : OuterStmtIn} {outerWitIn : OuterWitIn} {i : Fin (n + 1)}
    (P : Prover oSpec InnerStmtIn InnerWitIn InnerStmtOut InnerWitOut pSpec) :
      (P.liftContext lens).runToRound i outerStmtIn outerWitIn
      = do
        let ‚ü®transcript, prvState‚ü© ‚Üê
          (P.runToRound i).uncurry (lens.proj (outerStmtIn, outerWitIn))
        return ‚ü®transcript, ‚ü®prvState, outerStmtIn, outerWitIn‚ü©‚ü©

theorem prime_5 : Nat.Prime 5

theorem split_sum_eq_sum_split {k : ‚Ñï} (h_pos : k > 0) (x‚ÇÄ x‚ÇÅ : ConcreteBTField k)
  (hi‚ÇÄ lo‚ÇÄ hi‚ÇÅ lo‚ÇÅ : ConcreteBTField (k - 1))
  (h_split_x‚ÇÄ : split h_pos x‚ÇÄ = (hi‚ÇÄ, lo‚ÇÄ))
  (h_split_x‚ÇÅ : split h_pos x‚ÇÅ = (hi‚ÇÅ, lo‚ÇÅ)) :
  split h_pos (x‚ÇÄ + x‚ÇÅ) = (hi‚ÇÄ + hi‚ÇÅ, lo‚ÇÄ + lo‚ÇÅ)

@[grind ‚Üê]
lemma mul_ne_zero [IsDomain F] (f g : F[X][Y]) (hf : f ‚â† 0) (hg : g ‚â† 0) :
  f * g ‚â† 0

theorem embedSum_succ {m : ‚Ñï} {n : Fin (m + 1) ‚Üí ‚Ñï} {i : Fin (m + 1)} (j : Fin (n i)) :
    embedSum i j = (match i with
    | 0 => Fin.castAdd _ j
    | ‚ü®i + 1, h‚ü© => Fin.natAdd _ (embedSum ‚ü®i, Nat.succ_lt_succ_iff.mp h‚ü© j))

theorem congrArg‚ÇÉ {Œ± Œ≤ Œ≥ Œ¥ : Sort*} {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥ ‚Üí Œ¥} {a a' : Œ±} {b b' : Œ≤} {c c' : Œ≥}
    (h : a = a') (h' : b = b') (h'' : c = c') : f a b c = f a' b' c'

lemma getBit_of_lowBits {n: ‚Ñï} (numLowBits : ‚Ñï) : ‚àÄ k, getBit k (getLowBits numLowBits n) =
    if k < numLowBits then getBit k n else 0

@[simp]
theorem fappend‚ÇÇ_right {Œ±‚ÇÅ : Fin m ‚Üí A} {Œ±‚ÇÇ : Fin m ‚Üí B} {Œ≤‚ÇÅ : Fin n ‚Üí A} {Œ≤‚ÇÇ : Fin n ‚Üí B}
    (u : (i : Fin m) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i)) (v : (i : Fin n) ‚Üí F‚ÇÇ (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) (i : Fin n) :
    fappend‚ÇÇ (F := F‚ÇÇ) u v (natAdd m i) =
      cast (by simp [vappend_right]) (v i)

theorem join_eq_bitvec_iff_fromNat {k : ‚Ñï} (h_pos : k > 0) (x : ConcreteBTField k)
  (hi_btf lo_btf : ConcreteBTField (k - 1)) :
  x = „Ää hi_btf, lo_btf „Äã ‚Üî
  (hi_btf = fromNat (k:=k - 1) (x.toNat >>> 2 ^ (k - 1)) ‚àß
  lo_btf = fromNat (k:=k - 1) (x.toNat &&& (2 ^ (2 ^ (k - 1)) - 1)))

@[simp]
theorem cast_completeness (Œµ : ‚Ñù‚â•0) (hComplete : R.completeness init impl relIn relOut Œµ) :
    (R.cast hn hSpec hO‚Çò).completeness init impl relIn relOut Œµ

lemma encode_mem_ReedSolomon_code [DecidableEq F] [NeZero deg]
    {msg : Fin deg ‚Üí F} {domain : Fin m ‚Ü™ F} :
  encode msg domain ‚àà ReedSolomon.code domain deg

theorem base_intermediateNovelBasisX (j : Fin (2 ^ ‚Ñì)) :
  intermediateNovelBasisX ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®0, by
    by_contra ht
    simp only [not_lt, nonpos_iff_eq_zero] at ht
    contradiction
  ‚ü© j =
  X‚±º ùîΩq Œ≤ ‚Ñì (by omega) j

lemma liftF_eq_of_lt {i : ‚Ñï} (h : i < n) : liftF f' i = f' ‚ü®i, h‚ü©

lemma rank_eq_dim_fromColGenMat [CommRing F] {G : Matrix Œ∫ Œπ F} :
  G.rank = dim (fromColGenMat G)

theorem is_prime : Nat.Prime fieldSize

lemma domain_injective {i : ‚Ñï} : i ‚â§ n ‚Üí Function.Injective (domain D x n i)

theorem buildLayer_neverFails (Œ± : Type) [inst : DecidableEq Œ±] [inst_1 : SelectableType Œ±]
    (preexisting_cache : (spec Œ±).QueryCache) (n : ‚Ñï)
    (leaves : List.Vector Œ± (2 ^ (n + 1))) :
    ((simulateQ randomOracle (buildLayer Œ± n leaves)).run preexisting_cache).neverFails

theorem unique_linear_sum_repr (R : Type*) [CommRing R] (S : Type*) [CommRing S] [Algebra R S]
    (pb : PowerBasis R S) (h_dim : pb.dim = 2) (s : S) :
    ‚àÉ! p : R √ó R, s = p.fst ‚Ä¢ pb.gen + algebraMap R S p.snd

lemma degree_W (i : Fin r) : (W ùîΩq Œ≤ i).degree = (Fintype.card ùîΩq)^i.val

lemma smul_Z_eq_zero_x {k : ‚Ñï} (h_pos : k > 0) (x : ConcreteBTField (k - 1)) :
  letI instAlgebra := ConcreteBTFieldAlgebra (l:=k-1) (r:=k) (h_le:=by omega)
  x ‚Ä¢ Z k = „Ää x, 0 „Äã

@[simp] theorem BitVec.cast_zero {n m : ‚Ñï} (h : n = m) : BitVec.cast h 0 = 0

@[simp]
theorem seqCompose_embedSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    {T : ‚àÄ i, FullTranscript (pSpec i)} (i : Fin m) (j : Fin (n i)) :
    seqCompose T (Fin.embedSum i j) = cast (by simp) (T i j)

theorem degreeOf_X_le (i j : œÉ) : degreeOf i (X (R := R) j) ‚â§ 1

Fin.is_le' in Init.Data.Fin.Lemmas

@[simp]
theorem rightpad_apply_ge (n : ‚Ñï) (a : Œ±) (v : Fin m ‚Üí Œ±) (i : Fin n)
    (h : m ‚â§ i.val) : rightpad n a v i = a

theorem join_add_join {k : ‚Ñï} (h_pos : k > 0) (hi‚ÇÄ lo‚ÇÄ hi‚ÇÅ lo‚ÇÅ : ConcreteBTField (k - 1)) :
  „Ää hi‚ÇÄ, lo‚ÇÄ „Äã + „Ää hi‚ÇÅ, lo‚ÇÅ „Äã = „Ää hi‚ÇÄ + hi‚ÇÅ, lo‚ÇÄ + lo‚ÇÅ „Äã

theorem LeafData.composeBuild_leaf {Œ±} (a : Œ±)
    (compose : Œ± ‚Üí Œ± ‚Üí Œ±) :
    (LeafData.leaf a).composeBuild compose = FullData.leaf a

@[to_additive vsum_castSucc]
lemma vprod_castSucc [CommMonoid Œ±] {a : Fin (n + 1) ‚Üí Œ±} :
    vprod a = vprod (a ‚àò Fin.castSucc) * a (last n)

theorem degrees_peval {x : œÉ‚ÇÅ ‚Üí R} {f : œÉ ‚Üí œÉ‚ÇÅ ‚äï œÉ‚ÇÇ} {p : MvPolynomial œÉ R} :
    (peval f x p).degrees ‚â§ (p.degrees.map f).filterMap Sum.getRight?

@[simp]
theorem cast_id :
    Prover.cast rfl rfl = (id : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec‚ÇÅ ‚Üí _)

theorem eqPolynomial_zeroOne (r : œÉ ‚Üí Fin 2) : (eqPolynomial r : MvPolynomial œÉ R) =
    ‚àè i : œÉ, if r i = 0 then 1 - X i else X i

@[simp]
theorem happend_left {Œ± : Fin m ‚Üí Sort u} {Œ≤ : Fin n ‚Üí Sort u}
    (u : (i : Fin m) ‚Üí Œ± i) (v : (i : Fin n) ‚Üí Œ≤ i) (i : Fin m) :
    happend u v (castAdd n i) = cast (vappend_left Œ± Œ≤ i).symm (u i)

@[simp]
theorem drop_drop {m m' : ‚Ñï} (h : m ‚â§ n - m') (h' : m' ‚â§ n) (v : (i : Fin n) ‚Üí Œ± i) :
    drop m h (drop m' h' v) =
      (fun i =>
        letI := drop (m + m') (Nat.add_le_of_le_sub h' h) v (i.cast (by omega))
        dcast (by simp [Fin.cast, add_assoc]) this)

theorem dcast‚ÇÉ_symm (ha : a = a') (hb : dcast ha b = b') (hc : dcast‚ÇÇ ha hb c = c')
    (hd : dcast‚ÇÉ ha hb hc d = d') :
    dcast‚ÇÉ ha.symm (dcast_symm ha hb) (dcast‚ÇÇ_symm ha hb hc) d' = d

@[simp]
theorem embedSum_splitSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (k : Fin (vsum n)) :
    embedSum (splitSum k).1 (splitSum k).2 = k

omit [Finite F] in
lemma minus_one_in_doms {i : ‚Ñï} (h : i < n) :
    -1 ‚àà evalDomain D i

theorem insertNth_zero_eq_cases {n : ‚Ñï} {Œ± : Fin (n + 1) ‚Üí Sort u} :
    insertNth 0 = cases (motive := Œ±)

@[simp]
theorem rtake_append_right (T : FullTranscript pSpec‚ÇÅ) (T' : FullTranscript pSpec‚ÇÇ) :
    (T ++‚Çú T').rtake n (Nat.le_add_left n m) =
      T'.cast rfl (by simp [ProtocolSpec.append])

theorem prime_31 : Nat.Prime 31

lemma subUpFull_of_vandermonde_is_vandermonde (h : n ‚â§ m) :
  Matrix.vandermonde (Œ± ‚àò Fin.castLE h) =
  Matrix.subUpFull (nonsquare n Œ±) (Fin.castLE h)
</all_available_lemmas>

<local_ctx>
import ArkLib.Data.Classes.DCast

import ArkLib.Data.FieldTheory.BinaryField.Tower.Basic

namespace ConcreteBinaryTower

open Polynomial

def ConcreteBTField : ‚Ñï ‚Üí Type := fun k => BitVec (2 ^ k)

section BitVecDCast

instance BitVec.instDCast : DCast Nat BitVec where
  dcast h := BitVec.cast h
  dcast_id := by admit /- proof elided -/

end BitVecDCast

section ConversionUtils

def fromNat {k : ‚Ñï} (n : Nat) : ConcreteBTField k :=
  BitVec.ofNat (2 ^ k) n

instance ConcreteBTField.instDCast_local : DCast ‚Ñï ConcreteBTField where
  dcast h_k_eq term_k1 := BitVec.cast (congrArg (fun n => 2 ^ n) h_k_eq) term_k1
  dcast_id := by admit /- proof elided -/

end ConversionUtils

section NumericLemmas

end NumericLemmas

section FieldOperationsAndInstances

def zero {k : ‚Ñï} : ConcreteBTField k := BitVec.zero (2 ^ k)

def one {k : ‚Ñï} : ConcreteBTField k := 1#(2 ^ k)

def add {k : ‚Ñï} (x y : ConcreteBTField k) : ConcreteBTField k := BitVec.xor x y

def neg {k : ‚Ñï} (x : ConcreteBTField k) : ConcreteBTField k := x

def split {k : ‚Ñï} (h : k > 0) (x : ConcreteBTField k) :
    ConcreteBTField (k - 1) √ó ConcreteBTField (k - 1) :=
  let lo_bits : BitVec (2 ^ (k - 1) - 1 - 0 + 1) :=
    BitVec.extractLsb (hi := 2 ^ (k - 1) - 1) (lo := 0) x
  let hi_bits : BitVec (2 ^ k - 1 - 2 ^ (k - 1) + 1) :=
    BitVec.extractLsb (hi := 2 ^ k - 1) (lo := 2 ^ (k - 1)) x
  have h_lo : 2 ^ (k - 1) - 1 - 0 + 1 = 2 ^ (k - 1) := by admit /- proof elided -/

def join {k : ‚Ñï} (h_pos : k > 0) (hi lo : ConcreteBTField (k - 1)) : ConcreteBTField k :=

structure ConcreteBTFAddCommGroupProps (k : ‚Ñï) where
  add_assoc : ‚àÄ a b c : ConcreteBTField k, (a + b) + c = a + (b + c) := add_assoc
  add_comm : ‚àÄ a b : ConcreteBTField k, a + b = b + a := add_comm
  add_zero : ‚àÄ a : ConcreteBTField k, a + zero = a := add_zero
  zero_add : ‚àÄ a : ConcreteBTField k, zero + a = a := zero_add
  add_neg : ‚àÄ a : ConcreteBTField k, a + (neg a) = zero := neg_add_cancel

def mkAddCommGroupInstance {k : ‚Ñï} : AddCommGroup (ConcreteBTField k) := {
  zero := zero
  neg := neg
  sub := fun x y => add x y
  add_assoc := add_assoc
  add_comm := add_comm
  zero_add := zero_add
  add_zero := add_zero
  nsmul := fun n x => if n % 2 = (0 : ‚Ñï) then zero else x
  zsmul := fun (n : ‚Ñ§) x => if n % 2 = 0 then zero else x  
  neg_add_cancel := neg_add_cancel
  nsmul_succ := nsmul_succ
  zsmul_succ' := fun n a => zsmul_succ n a
  add := add
  zsmul_neg' := zsmul_neg' (k := k)
}

def Z (k : ‚Ñï) : ConcreteBTField k :=
  if h_k : k = 0 then one
  else
    „Ää one (k:=k-1), zero (k:=k-1) „Äã

def equivProd {k : ‚Ñï} (h_k_pos : k > 0) :
  ConcreteBTField k ‚âÉ ConcreteBTField (k - 1) √ó ConcreteBTField (k - 1) where
  toFun := split h_k_pos
  invFun := fun (hi, lo) => „Ää hi, lo „Äã
  left_inv := fun x => Eq.symm (join_of_split h_k_pos x _ _ rfl)
  right_inv := fun ‚ü®hi, lo‚ü© => Eq.symm (split_of_join h_k_pos _ hi lo rfl)

def concrete_mul {k : ‚Ñï} (a b : ConcreteBTField k) : ConcreteBTField k :=
  if h_k_zero : k = 0 then
    if a = zero then zero
    else if b = zero then zero
    else if a = one then b
    else if b = one then a
    else zero 
  else
    have h_k_gt_0 : k > 0 := by admit /- proof elided -/

def concrete_inv {k : ‚Ñï} (a : ConcreteBTField k) : ConcreteBTField k :=
  if h_k_zero : k = 0 then
    if a = 0 then 0 else 1
  else
    if h_a_zero : a = 0 then 0
    else if h_a_one : a = 1 then 1
    else
      let h_k_gt_0 : k > 0 := Nat.zero_lt_of_ne_zero h_k_zero
      let (a_hi, a_lo) := split (k:=k) (h:=h_k_gt_0) a
      let prevZ := Z (k - 1)
      let a_lo_next := a_lo + concrete_mul a_hi prevZ
      let delta := concrete_mul a_lo a_lo_next + concrete_mul a_hi a_hi
      let delta_inverse := concrete_inv delta
      let out_hi := concrete_mul delta_inverse a_hi
      let out_lo := concrete_mul delta_inverse a_lo_next
      let res := „Ää out_hi, out_lo „Äã
      res

section FieldLemmasOfLevel0

end FieldLemmasOfLevel0

section NumericCasting

def natCast {k : ‚Ñï} (n : ‚Ñï) : ConcreteBTField k := if n % 2 = 0 then zero else one

def natCast_zero {k : ‚Ñï} : natCast (k:=k) 0 = zero :=

def natCast_succ {k : ‚Ñï} (n : ‚Ñï) : natCast (k:=k) (n + 1) = natCast (k:=k) n + 1 :=

def intCast {k : ‚Ñï} (n : ‚Ñ§) : ConcreteBTField k := if n % 2 = 0 then zero else one

def intCast_ofNat {k : ‚Ñï} (n : ‚Ñï) : intCast (k:=k) (n : ‚Ñ§) = natCast n :=

def intCast_negSucc {k : ‚Ñï} (n : ‚Ñï) : intCast (k:=k) (Int.negSucc n)
  = - (‚Üë(n + 1) : ConcreteBTField k) :=

end NumericCasting

structure ConcreteBTFRingProps (k : ‚Ñï) extends (ConcreteBTFAddCommGroupProps k) where
  
  mul_eq : ‚àÄ (a b : ConcreteBTField k) (h_k : k > 0)
    {a‚ÇÅ a‚ÇÄ b‚ÇÅ b‚ÇÄ : ConcreteBTField (k - 1)}
    (_h_a : (a‚ÇÅ, a‚ÇÄ) = split h_k a) (_h_b : (b‚ÇÅ, b‚ÇÄ) = split h_k b),
    concrete_mul a b =
      „Ää concrete_mul a‚ÇÄ b‚ÇÅ + concrete_mul b‚ÇÄ a‚ÇÅ + concrete_mul (concrete_mul a‚ÇÅ b‚ÇÅ) (Z (k - 1)),
      concrete_mul a‚ÇÄ b‚ÇÄ + concrete_mul a‚ÇÅ b‚ÇÅ „Äã

  
  zero_mul : ‚àÄ a : ConcreteBTField k, concrete_mul zero a = zero
  zero_mul' : ‚àÄ a : ConcreteBTField k, concrete_mul 0 a = 0
  mul_zero : ‚àÄ a : ConcreteBTField k, concrete_mul a zero = zero
  mul_zero' : ‚àÄ a : ConcreteBTField k, concrete_mul a 0 = 0
  one_mul : ‚àÄ a : ConcreteBTField k, concrete_mul one a = a
  mul_one : ‚àÄ a : ConcreteBTField k, concrete_mul a one = a

  
  mul_assoc : ‚àÄ a b c : ConcreteBTField k, concrete_mul (concrete_mul a b) c
    = concrete_mul a (concrete_mul b c)
  mul_left_distrib : ‚àÄ a b c : ConcreteBTField k, concrete_mul a (b + c)
    = concrete_mul a b + concrete_mul a c
  mul_right_distrib : ‚àÄ a b c : ConcreteBTField k, concrete_mul (a + b) c
    = concrete_mul a c + concrete_mul b c

structure ConcreteBTFDivisionRingProps (k : ‚Ñï) extends (ConcreteBTFRingProps k) where
  
  mul_inv_cancel : ‚àÄ a : ConcreteBTField k, a ‚â† zero ‚Üí concrete_mul a (concrete_inv a) = one

structure ConcreteBTFieldProps (k : ‚Ñï) extends (ConcreteBTFDivisionRingProps k) where
  
  mul_comm : ‚àÄ a b : ConcreteBTField k, concrete_mul a b = concrete_mul b a

def mkRingInstance {k : ‚Ñï} (props : ConcreteBTFieldProps k) : Ring (ConcreteBTField k) where
  toAddCommGroup := mkAddCommGroupInstance
  toOne := inferInstance
  mul := concrete_mul
  mul_assoc := props.mul_assoc
  one_mul := props.one_mul
  mul_one := props.mul_one
  left_distrib := props.mul_left_distrib
  right_distrib := props.mul_right_distrib
  zero_mul := props.zero_mul
  mul_zero := props.mul_zero

  natCast n := natCast n
  natCast_zero := natCast_zero
  natCast_succ n := natCast_succ n
  intCast n := intCast n
  intCast_ofNat n := intCast_ofNat n
  intCast_negSucc n := intCast_negSucc n

def mkDivisionRingInstance {k : ‚Ñï} (props : ConcreteBTFieldProps k)
    : DivisionRing (ConcreteBTField k) where
  toRing := mkRingInstance (k:=k) props
  inv := concrete_inv
  exists_pair_ne := concrete_exists_pair_ne (k := k)
  mul_inv_cancel := props.mul_inv_cancel
  inv_zero := concrete_inv_zero
  qsmul := (Rat.castRec ¬∑ * ¬∑)
  nnqsmul := (NNRat.castRec ¬∑ * ¬∑)

def mkFieldInstance {k : ‚Ñï} (props : ConcreteBTFieldProps k) : Field (ConcreteBTField k) where
  toDivisionRing := mkDivisionRingInstance (k:=k) props
  mul_comm := props.mul_comm

structure ConcreteBTFStepResult (k : ‚Ñï) extends (ConcreteBTFieldProps k) where
  instFintype : Fintype (ConcreteBTField k)
  fieldFintypeCard : Fintype.card (ConcreteBTField k) = 2^(2^k)
  
  sumZeroIffEq : ‚àÄ (x y : ConcreteBTField k), x + y = 0 ‚Üî x = y
  traceMapEvalAtRootsIs1 :
    letI := mkFieldInstance (k:=k) (props:=toConcreteBTFieldProps)
    TraceMapProperty (ConcreteBTField k) (u:=Z k) k
  instIrreduciblePoly :
    letI := mkFieldInstance (k:=k) (props:=toConcreteBTFieldProps)
    (Irreducible (p := (definingPoly (s:=(Z k)))))

end FieldOperationsAndInstances

section BTFieldPropsOneLevelLiftingLemmas

variable {k : ‚Ñï} {h_k : k > 0}

end BTFieldPropsOneLevelLiftingLemmas

section TowerFieldsConstruction

def liftBTFieldProps (k : ‚Ñï) (prevBTFResult : ConcreteBTFStepResult (k := k)) :
  ConcreteBTFieldProps (k + 1) := {
    zero_mul := concrete_zero_mul (prevBTFResult.toConcreteBTFieldProps),
    zero_mul' := fun a => by admit /- proof elided -/

def liftConcreteBTField (k : ‚Ñï) (prevBTFResult : ConcreteBTFStepResult (k := k)) :
  Field (ConcreteBTField (k + 1)) :=

def concreteCanonicalEmbedding (k : ‚Ñï)
    (prevBTFieldProps : ConcreteBTFieldProps (k := (k)))
    (curBTFieldProps : ConcreteBTFieldProps (k := (k + 1))) :
  letI := mkFieldInstance prevBTFieldProps
  letI := mkFieldInstance curBTFieldProps
  ConcreteBTField k ‚Üí+* ConcreteBTField (k + 1) :=

instance instAlgebraLiftConcreteBTField (k : ‚Ñï)
  (prevBTFResult : ConcreteBTFStepResult (k := k)) :
  letI := mkFieldInstance (prevBTFResult.toConcreteBTFieldProps)
  letI := liftConcreteBTField (k:=k) prevBTFResult
  Algebra (ConcreteBTField k) (ConcreteBTField (k + 1)) :=
  letI := mkFieldInstance (prevBTFResult.toConcreteBTFieldProps)
  letI := liftConcreteBTField (k:=k) prevBTFResult
  RingHom.toAlgebra (R:=ConcreteBTField k) (S:=ConcreteBTField (k + 1))
    (i:=(concreteCanonicalEmbedding (k:=k)
      (prevBTFieldProps:=prevBTFResult.toConcreteBTFieldProps)
      (curBTFieldProps:=liftBTFieldProps (k:=k) (prevBTFResult:=prevBTFResult))))

def getBTFResult (k : ‚Ñï) : ConcreteBTFStepResult k :=
  match k with
  | 0 =>
    let base : ConcreteBTFieldProps 0 := {
      mul_eq := fun a b h_k _ _ _ _ _ _ => by admit /- proof elided -/
| c1_one
        ¬∑ 
          rw [c1_zero] at h_mul
          
          simp at h_mul
        ¬∑ 
          rcases c2_cases with c2_zero | c2_one
          ¬∑ 
            rw [c2_zero] at h_mul
            
            simp at h_mul
          ¬∑ 
            
            exact ‚ü®c1_one, c2_one‚ü©
      
      have specialElement_eq_zero : specialElement = 0 := by admit /- proof elided -/

end TowerFieldsConstruction

section ConcreteBTFieldAlgebraConstruction

def canonicalAlgMap (k : ‚Ñï) := concreteCanonicalEmbedding (k:=k)
  (prevBTFieldProps:= ((getBTFResult k).toConcreteBTFieldProps))
  (curBTFieldProps:= ((getBTFResult (k + 1)).toConcreteBTFieldProps))

def concreteTowerAlgebraMap (l r : ‚Ñï) (h_le : l ‚â§ r) :
    ConcreteBTField l ‚Üí+* ConcreteBTField r :=

instance instAlgebraTowerConcreteBTF : AlgebraTower (ConcreteBTField) where
  algebraMap := concreteTowerAlgebraMap
  commutes' := by admit /- proof elided -/

def ConcreteBTFieldAlgebra {l r : ‚Ñï} (h_le : l ‚â§ r) :
    Algebra (ConcreteBTField l) (ConcreteBTField r) := instAlgebraTowerConcreteBTF.toAlgebra h_le

def join_via_add_smul (k : ‚Ñï) (h_pos : k > 0) (hi_btf lo_btf : ConcreteBTField (k - 1)) :
    ConcreteBTField k :=

end ConcreteBTFieldAlgebraConstruction

noncomputable section ConcreteMultilinearBasis

open Module

def basisSucc (k : ‚Ñï) : Basis (Fin 2) (ConcreteBTField k) (ConcreteBTField (k + 1)) :=

def powerBasisSucc (k : ‚Ñï) :
    PowerBasis (ConcreteBTField k) (ConcreteBTField (k + 1)) :=
</local_ctx>

<target_theorem>
@[simp]
theorem minPoly_of_powerBasisSucc_generator (k : ‚Ñï) :
  (minpoly (ConcreteBTField k) (powerBasisSucc k).gen) = X^2 + (Z k) ‚Ä¢ X + 1 :=
</target_theorem>

