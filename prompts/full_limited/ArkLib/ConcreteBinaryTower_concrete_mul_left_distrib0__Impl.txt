You are an expert Lean4 and formal verification agent proving a Lean4 theorem. Your output **must** strictly adhere to the specified format.

### Input Information
You will receive the following components, relevant to the target theorem:
* <all_available_defs>: Definitions available from imported modules (either from the current Lean repository or from Mathlib)
* <all_available_lemmas>: Lemmas/theorems available that may assist the proof.
* <local_ctx>...</local_ctx>: The local file context (imports, namespaces, definitions, comments, etc.) from the top of the file up to‚Äîbut not including‚Äîthe target theorem or any previously defined local lemmas/theorems.
* <target_theorem>...</target_theorem>: The target theorem statement, ending with `:=`.

**Notes**
1. Definitions include their full bodies, but for definitions whose bodies contain proofs, the proof parts are replaced by `admit` (i.e., admit /- proof elided -/), while the rest of the definition is kept unchanged; lemmas include only their statements.
2. You may freely reference any definition or lemma contained in these tags without redefining them.
3. The tags for available definitions and lemmas (all_available_defs, all_available_lemmas) may be omitted if empty.

### Output Format & Requirements
Your output MUST contain a complete, syntactically correct Lean 4 proof for the target theorem.

**Strict Output Structure:**
<reasoning> 
...
</reasoning> 

<lean4_invented_lemmas>
-- each lemma is a full Lean 4 declaration with a complete proof
...
</lean4_invented_lemmas>

<lean4_proof>
-- Lean 4 proof body of the target theorem
...
</lean4_proof>

**Requirements:**
1. <reasoning> and <lean4_invented_lemmas> are OPTIONAL. Include them only if they aid proof construction.
2. <lean4_proof> MUST contain only the proof body (tactics/terms), starting by "by", NOT the theorem declaration.
3. <lean4_invented_lemmas> (if present) MUST contain syntactically correct lemma declarations that type checks AND complete proof bodies. Defining a lemma using `axiom` is NOT allowed.
4. <reasoning> contains high-level proof planning.
5. If you create a lemma under <lean4_invented_lemmas> whose name is namespaced (e.g., X.Y.Z), you MUST always refer to it using its fully qualified name. Do NOT rely on shortened names. For example, write rw [X.Y.Z], not rw [Z] for invented lemmas.
6. All Lean 4 code MUST be syntactically correct. No `sorry`, `admit`, or non-Lean text. Comments allowed using `--` or `/- ... -/`.
7. Follow the tags and structure EXACTLY. No extra text before, between, or after the sections.
8. Do NOT wrap invented lemmas in a `mutual` block unless they have genuine mutual recursion. Declare each lemma independently.

### Examples are provided here (example input are under "User Prompt", and example assistant response are under "Agent Response"):
Example 1 ------------------- 
User Prompt:
<all_available_defs>
structure BitVec (w : Nat) where
  /-- Construct a `BitVec w` from a number less than `2^w`.
  O(1), because we use `Fin` as the internal representation of a bitvector. -/
  ofFin ::

  /-- Interpret a bitvector as a number less than `2^w`.
  O(1), because we use `Fin` as the internal representation of a bitvector. -/
  toFin : Fin (hPow 2 w)
</all_available_defs>

<all_available_lemmas>
theorem List.getElem_append_left{Œ± : Type u_1} {l‚ÇÅ l‚ÇÇ : List Œ±} {i : Nat} (hn : i < l‚ÇÅ.length) : (l‚ÇÅ ++ l‚ÇÇ)[i] = l‚ÇÅ[i]
theorem getElem_eq_testBit_toNat (x : BitVec w) (i : Nat) (h : i < w) :
  x[i] = x.toNat.testBit i := rfl
@[simp, grind =] theorem toNat_cons (b : Bool) (x : BitVec w) :
    (cons b x).toNat = (b.toNat <<< w) ||| x.toNat
@[simp, grind =] theorem getLsbD_of_ge (x : BitVec w) (i : Nat) (ge : w ‚â§ i) : getLsbD x i = false
theorem testBit_toNat (x : BitVec w) : x.toNat.testBit i = x.getLsbD i
</all_available_lemmas>

<local_ctx>
import Mathlib.Computability.NFA
import Mathlib.Data.FinEnum
import Mathlib.Data.Rel
import Mathlib.Data.Vector.Basic
import Blase.AutoStructs.ForLean

open Set
open Mathlib
open SetRel

-- this is better because card is defeq to n
instance (Œ± : Type) : Inter (Language Œ±) := ‚ü®Set.inter‚ü©
instance (Œ± : Type) : Union (Language Œ±) := ‚ü®Set.union‚ü©

/--
The set of `n`-tuples of bit vectors of an arbitrary width.
-/
structure BitVecs (n : Nat) where
  w : Nat
  bvs : List.Vector (BitVec w) n

def BitVecs.cast (bvs : BitVecs n) (h : n = n') : BitVecs n' :=
  { w := bvs.w, bvs := h ‚ñ∏ bvs.bvs }

abbrev BitVecs.empty : BitVecs n := ‚ü®0, List.Vector.replicate n .nil‚ü©
abbrev BitVecs.singleton {w : Nat} (bv : BitVec w) : BitVecs 1 := ‚ü®w, bv ::·µ• .nil‚ü©
abbrev BitVecs.pair {w : Nat} (bv1 bv2 : BitVec w) : BitVecs 2 := ‚ü®w, bv1 ::·µ• bv2 ::·µ• .nil‚ü©

/--
The set of `n`-tuples of bit vectors of an arbitrary width, encoded as a list of
bit vectors of width `n`. The width of the encoded bit vectors is the length of
the list.
-/
abbrev BitVecs' (n : Nat) := List (BitVec n)

@[simps]
def dec (bvs' : BitVecs' n) : BitVecs n where
  w := bvs'.length
  bvs := List.Vector.ofFn fun k => BitVec.ofFn fun i => bvs'[i].getLsbD k

@[simp]
</local_ctx>

<target_theorem>
lemma dec_snoc n (bvs' : BitVecs' n) (a : BitVec n) :
  dec (bvs' ++ [a]) =
    { w := bvs'.length + 1
      bvs := List.Vector.ofFn fun k =>
        BitVec.cons (a.getLsbD k) ((dec bvs').bvs.get k) } :=
</target_theorem>

Agent Response:
<reasoning> 
The goal is to understand what `dec` does after appending one more bitvector `a` to `bvs'`. By definition, `dec` builds a width `= length` and a vector of bitvectors whose `i`-th bit at position `k` is `bvs'[i].getLsbD k`. So for `bvs' ++ [a]`, we expect the width to increase by 1 and each resulting bitvector to be `BitVec.cons` of the new bit coming from `a`.

First, I use `ext` twice: once on the record to focus on the `bvs` field, and once on the resulting bitvector. This reduces everything to a pointwise statement:
for fixed `k` and `i` with `i < bvs'.length + 1`,
the bit `(bvs' ++ [a])[i].getLsbD k` should match the bit at index `i` of `BitVec.cons (a.getLsbD k) ((dec bvs').bvs.get k)`.

At this point I need a clean description of indexing into `BitVec.cons`: if we have `x : BitVec n`, then `(cons b x)[i]` should give `b` at the new ‚Äúlast‚Äù index `n` and `x[i]` otherwise. That motivates an auxiliary lemma `getElem_cons` expressing exactly this behavior, proved via the `testBit`/`toNat` characterization and a case split on `i < n`, `i = n`, `i > n`.

Using `getElem_cons`, the RHS becomes an `if` on whether `i = bvs'.length`. So I split into cases:
- If `i = bvs'.length`, then `(bvs' ++ [a])[i]` is the appended `a`, so both sides reduce to `a.getLsbD k`.
- If `i ‚â† bvs'.length`, the bound `i < bvs'.length + 1` forces `i < bvs'.length`. Then `(bvs' ++ [a])[i] = bvs'[i]` by `List.getElem_append_left`, and the RHS takes the ‚Äúelse‚Äù branch and likewise gives the bit from `bvs'[i]`. In both subcases, `simp` (plus the definition of `dec`) finishes.

So the whole proof is: `ext` to bit level, unfold `dec` with `simp_all`, rewrite with `getElem_cons`, split on the boundary index `i = length bvs'`, and in the ‚Äú< length‚Äù branch use `List.getElem_append_left` and bounds to line up both sides.
</reasoning> 

<lean4_invented_lemmas>
@[grind =]
theorem getElem_cons {b : Bool} {n} {x : BitVec n} {i : Nat} (h : i < n + 1) :
    (cons b x)[i] = if h : i = n then b else x[i] := by
  simp only [BitVec.getElem_eq_testBit_toNat, BitVec.toNat_cons, Nat.testBit_or]
  rw [Nat.testBit_shiftLeft]
  rcases Nat.lt_trichotomy i n with i_lt_n | i_eq_n | n_lt_i
  ¬∑ have p1 : ¬¨(n ‚â§ i) := by omega
    have p2 : i ‚â† n := by omega
    simp [p1, p2]
  ¬∑ simp only [i_eq_n, ge_iff_le, Nat.le_refl, decide_true, Nat.sub_self, Nat.testBit_zero,
    Bool.true_and, BitVec.testBit_toNat, BitVec.getLsbD_of_ge, Bool.or_false]
    cases b <;> trivial
  ¬∑ have p1 : i ‚â† n := by omega
    have p2 : i - n ‚â† 0 := by omega
    simp [p1, p2, Nat.testBit_bool_toNat]
</lean4_invented_lemmas>

<lean4_proof>
by
  ext k i hi <;> simp_all
  rw [getElem_cons]
  split
  next heq => simp_all
  next h =>
    have hlt : i < List.length bvs' := by simp at hi; omega
    rw [List.getElem_append_left hlt]
    simp
</lean4_proof>

### Your task:
<all_available_defs>
Eq in Init.Prelude
id in Init.Prelude
BitVec in Init.Prelude
Nat in Init.Prelude
BitVec.cast in Init.Data.BitVec.Basic
BitVec.append in Init.Data.BitVec.Basic
BitVec.zero in Init.Data.BitVec.Basic
BitVec.extractLsb in Init.Data.BitVec.Basic

notation : 10 "GF(" term : 10 ")" => GaloisField term 1

class DCast (Œ± : Sort*) (Œ≤ : Œ± ‚Üí Sort*) where
  dcast : ‚àÄ {a a' : Œ±}, a = a' ‚Üí Œ≤ a ‚Üí Œ≤ a'
  dcast_id : ‚àÄ {a : Œ±}, dcast (Eq.refl a) = id

def AlgebraTowerEquiv.symm (e : AlgebraTowerEquiv A B) : AlgebraTowerEquiv B A where
  toRingEquiv := fun i => (e.toRingEquiv i).symm
  commutesLeft' := fun i j h r => by admit /- proof elided -/

structure AlgebraTowerEquiv (A : Œπ ‚Üí Type*) [‚àÄ i, CommSemiring (A i)] [a : AlgebraTower A]
  (B : Œπ ‚Üí Type*) [‚àÄ i, CommSemiring (B i)] [b : AlgebraTower B]
  where
    toRingEquiv : ‚àÄ i, (A i ‚âÉ+* B i)
    commutesLeft' : ‚àÄ (i j : Œπ) (h : i ‚â§ j) (r : A i),
      (b.algebraMap (i:=i) (j:=j) (h:=h)) ((toRingEquiv i) r) =
      (toRingEquiv j) (a.algebraMap (i:=i) (j:=j) (h:=h) r)

abbrev SEP_CHAR : Char := Char.ofNat 0

Function.LeftInverse in Init.Data.Function

@[inline, specialize]
def OracleReduction.run [‚àÄ i, OracleInterface (pSpec.Message i)]
    (stmt : StmtIn) (oStmt : ‚àÄ i, OStmtIn i) (wit : WitIn)
    (reduction : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec) :
      OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí)
        ((FullTranscript pSpec √ó (StmtOut √ó ‚àÄ i, OStmtOut i) √ó WitOut) √ó
          (StmtOut √ó ‚àÄ i, OStmtOut i)) := do
  let proverResult ‚Üê reduction.prover.run ‚ü®stmt, oStmt‚ü© wit
  let stmtOut ‚Üê liftM (reduction.verifier.run stmt oStmt proverResult.1)
  return ‚ü®proverResult, stmtOut‚ü©

@[inline, reducible]
def Statement.Lens (OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut : Type)
  := PFunctor.Lens (OuterStmtIn X^ OuterStmtOut)
                   (InnerStmtIn X^ InnerStmtOut)

def hiding' (scheme : Scheme oSpec Data Randomness Commitment pSpec) : Prop := sorry

def domainEmb {i : ‚Ñï} : evalDomain D i ‚Ü™ F :=
  ‚ü®
    fun x => x.1.1,
    by admit /- proof elided -/
  ‚ü©

@[reducible, inline, specialize]
def getChallenge (pSpec : ProtocolSpec n) (i : pSpec.ChallengeIdx) :
    OracleComp ([pSpec.Challenge]‚Çí'challengeOracleInterface) (pSpec.Challenge i) :=
  (query i () : OracleQuery ([pSpec.Challenge]‚Çí'challengeOracleInterface) (pSpec.Challenge i))

abbrev SEP_BYTE : String := ‚ü®[SEP_CHAR]‚ü©

private def k [Zero F] (B : Finset (Fin n ‚Üí F)) : ‚Ñö :=
  (1 : ‚Ñö) / n * ‚àë i, K B i 0

def twoLevelSkel (k0 k1 : ‚Ñï) :
    ArityTree.Skeleton 2 (ar2 k0 k1) :=
  ArityTree.Skeleton.node (fun _ =>
    ArityTree.Skeleton.node (fun _ => ArityTree.Skeleton.leaf))

Set.Nonempty in Mathlib.Data.Set.Defs

noncomputable instance finiteDimensionalCoeffVecSpace (‚Ñì : ‚Ñï) :
  FiniteDimensional (K := L) (V := CoeffVecSpace L ‚Ñì) :=

def matrixSubmoduleOfLinearCode (Œ∫ : Type*) [Fintype Œ∫]
                                (LC : LinearCode Œπ F) : MatrixSubmodule Œ∫ Œπ F :=
  Submodule.span F { V | ‚àÄ i, V i ‚àà LC }

Nat.div2 in Mathlib.Data.Nat.Bits

@[reducible, simp]
def toRelInput : Set ((Statement √ó (‚àÄ i, OStatement i)) √ó Unit) :=
  { ‚ü®‚ü®stmt, oStmt‚ü©, _‚ü© | simulateQ' (toOracleImpl OStatement oStmt) (pred stmt) (hPred stmt) }

def numPermQueriesChallenge (i : pSpec.ChallengeIdx) : Nat :=
  Nat.ceil ((challengeSize i : ‚Ñö) / SpongeSize.R)

alias L·µ•·µ¢ := numPermQueriesChallenge

instance (priority := low) : DCast‚ÇÇ Œ± Œ≤ Œ≥ where
  dcast‚ÇÇ ha hb c := by admit /- proof elided -/

noncomputable def toConcreteBTF0 : GF(2) ‚Üí ConcreteBTField 0 :=
  fun x => if decide (x = 0) then zero else one 

def churchFalse : ChurchBool Œ± := fun _ y => y

Nat.iterate in Mathlib.Logic.Function.Iterate

noncomputable def NTTStage (i : Fin ‚Ñì) (b : Fin (2 ^ (‚Ñì + R_rate)) ‚Üí L) :
    Fin (2^(‚Ñì + R_rate)) ‚Üí L :=
  have h_2_pow_i_lt_2_pow_‚Ñì_add_R_rate: 2^i.val < 2^(‚Ñì + R_rate) := by admit /- proof elided -/

instance : ‚àÄ j, OracleInterface ((pSpec F).Message j)
  | ‚ü®0, h‚ü© => nomatch h
  | ‚ü®1, _‚ü© => by admit /- proof elided -/

@[reducible, simp] def StmtOut := Query OStatement

def collisionBwdBwd : Prop :=
  let ‚ü®baseTrace, _‚ü© := removeRedundantEntryDS trace
  ‚àÉ stateOut stateOut' stateIn,
    (stateOut, stateIn) ‚àà baseTrace.getQ (.inr .Bwd) ‚àß
    (stateOut', stateIn) ‚àà baseTrace.getQ (.inr .Bwd) ‚àß
    stateOut ‚â† stateOut'

alias E_col_pinv := collisionBwdBwd

MvPolynomial.map in Mathlib.Algebra.MvPolynomial.Eval

@[inline]
def seqCompose {m : ‚Ñï} (Stmt : Fin (m + 1) ‚Üí Type) (Wit : Fin (m + 1) ‚Üí Type)
    {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (R : (i : Fin m) ‚Üí
      Reduction oSpec (Stmt i.castSucc) (Wit i.castSucc) (Stmt i.succ) (Wit i.succ) (pSpec i)) :
    Reduction oSpec (Stmt 0) (Wit 0) (Stmt (Fin.last m)) (Wit (Fin.last m)) (seqCompose pSpec) where
  prover := Prover.seqCompose Stmt Wit (fun i => (R i).prover)
  verifier := Verifier.seqCompose Stmt (fun i => (R i).verifier)

abbrev Field := ZMod fieldSize

Fin.find in Mathlib.Data.Fin.Tuple.Basic

def outputRelation :
    Set (((StmtOut R) √ó (‚àÄ i, OStmtOut R deg i)) √ó Unit) :=
  { ‚ü®‚ü®‚ü®newTarget, chal‚ü©, oStmt‚ü©, _‚ü© | (oStmt ()).1.eval chal = newTarget }

Polynomial.ofFinsupp in Mathlib.Algebra.Polynomial.Basic

def churchVecFold (xs : ChurchVec Œ±) (f : Œ± ‚Üí List Œ± ‚Üí List Œ±) (base : List Œ±) : List Œ± :=
  xs f base

def toVerifier : Verifier oSpec (StmtIn √ó ‚àÄ i, OStmtIn i) (StmtOut √ó (‚àÄ i, OStmtOut i)) pSpec where
  verify := fun ‚ü®stmt, oStmt‚ü© transcript => do
    let stmtOut ‚Üê simulateQ (OracleInterface.simOracle2 oSpec oStmt transcript.messages)
      (verifier.verify stmt transcript.challenges)
    letI oStmtOut := fun i => match h : verifier.embed i with
      | Sum.inl j => by admit /- proof elided -/
      | Sum.inr j => by admit /- proof elided -/

def commitKnowledgeError {i : Fin ‚Ñì}
    (m : (pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i).ChallengeIdx) : ‚Ñù‚â•0 :=
  match m with
  | ‚ü®j, hj‚ü© => by admit /- proof elided -/

def NestedList (n : ‚Ñï) : Type := dfoldr' n (fun _ => Type) (fun _ T => List T) Nat

example : NestedList 0 = Nat := rfl
example (n : ‚Ñï) : NestedList (n + 1) = List (NestedList n) := rfl

def canonical (p : UniPoly R) := p.trim = p

@[simp]
def ùïè (k : ‚Ñï) : BTField (k+1) := Z (k+1)

instance : VAdd (Œπ ‚Üí F) (AffineSubspace F (Œπ ‚Üí F)) := AffineSubspace.pointwiseVAdd

def queryCodeword (k : ‚Ñï) (s : Fin (k + 1) ‚Üí ‚Ñï+) {i : Fin (k + 1)}
      (w : evalDomain D x (‚àë j' ‚àà (List.take i.1 (List.finRange (k + 1))).toFinset, (s j').1)) :
    OracleComp [FinalOracleStatement D x s]‚Çí F :=
      OracleComp.lift <| by
        simpa using
          OracleSpec.query
            (spec := [FinalOracleStatement D x s]‚Çí)
            ‚ü®i.1, Nat.lt_succ_of_lt i.2‚ü©
            (by admit /- proof elided -/
            )

List.dropLast in Init.Data.List.Basic

WithTop in Mathlib.Order.TypeTags

@[reducible]
def forwardPermutationOracle (Œ± : Type*) : OracleSpec Unit := Œ± ‚Üí‚Çí Œ±

instance : SMul ‚Ñï (UniPoly R) := ‚ü®nsmul‚ü©

ringChar in Mathlib.Algebra.CharP.Defs

class IsSecureWithGap
    (completeRelation : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (soundRelation : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (Œµ_rbr : vPSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0)
    (vectorIOP : VectorIOP Statement OStatement Witness vPSpec A) where

   
  is_complete : vectorIOP.perfectCompleteness (pure ()) ‚ü®isEmptyElim‚ü© completeRelation

   
  is_rbr_knowledge_sound :
    OracleProof.rbrKnowledgeSoundness (pure ()) ‚ü®isEmptyElim‚ü© soundRelation vectorIOP.verifier Œµ_rbr

def findImports (path : System.FilePath) : IO (Array Lean.Name) := do
  return (‚Üê Lean.parseImports' (‚Üê IO.FS.readFile path) path.toString)
    |>.map (fun imp ‚Ü¶ imp.module) |>.erase `Init

def monomialXY (n m : ‚Ñï) : F ‚Üí‚Çó[F] F[X][Y] where
  toFun t := ‚ü®Finsupp.single m ‚ü®(Finsupp.single n t)‚ü©‚ü©
  map_add' x y := by admit /- proof elided -/

MvPolynomial.eval in Mathlib.Algebra.MvPolynomial.Eval

Subtype in Init.Prelude

structure Gate (ùì° : Type*) (numWires : ‚Ñï) extends Selector ùì°, WireIndices numWires
deriving DecidableEq

IsUnit in Mathlib.Algebra.Group.Units.Defs

@[reducible]
def scalarFieldSize : Nat :=
  21888242871839275222246405745257275088548364400416034343698204186575808495617

structure InitialStatement where
  
  t_eval_point : Fin ‚Ñì ‚Üí L         
  original_claim : L               

class UnitTranscript (Œ± : Type*) (U : Type) where
   
  publicUnits : Œ± ‚Üí Array U ‚Üí Except DomainSeparatorMismatch Œ±
   
  fillChallengeUnits : Œ± ‚Üí Nat ‚Üí Except DomainSeparatorMismatch (Œ± √ó Array U)

def roundRelationProp (i : Fin (‚Ñì + 1))
    (input : (Statement (L := L) Context i √ó
      (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i j)) √ó
      Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) : Prop :=
  let stmt := input.1.1
  let oStmt := input.1.2
  let wit := input.2
  masterKStateProp (mp := mp) (ùìë := ùìë) ùîΩq Œ≤
    (stmtIdx := i) (oracleIdx := i) (h_le := le_refl i) stmt wit oStmt (localChecks := True)

def toVerifierState (ds : DomainSeparator U H) (transcript : ByteArray) : FSVerifierState U H :=
  FSVerifierState.new ds transcript

def modSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (k : Fin (‚àë j, n j)) : Fin (n (divSum k)) :=
  ‚ü®k - ‚àë j, n (Fin.castLE (divSum k).isLt.le j), by admit /- proof elided -/
    ‚ü©

def foldl' {Œ± : Type u} (n : ‚Ñï) (f : (i : Fin n) ‚Üí Œ± ‚Üí Œ±) (init : Œ±) : Œ± :=
  dfoldl' n (fun _ => Œ±) f init

instance [VerifierFirst pSpec] : Unique (pSpec.ChallengeIdx) where
  default := ‚ü®0, by admit /- proof elided -/
  ‚ü©
  uniq := fun ‚ü®i, _‚ü© => by admit /- proof elided -/

noncomputable def hasMutualCorrAgreement
  (Gen : ProximityGenerator Œπ F) [Fintype Gen.par‚Ñì]
  (BStar : ‚Ñù) (errStar : ‚Ñù ‚Üí ENNReal) :=
    haveI := Gen.Gen_nonempty
    ‚àÄ (f : Gen.par‚Ñì ‚Üí Œπ ‚Üí F) (Œ¥ : ‚Ñù‚â•0) (_hŒ¥ : 0 < Œ¥ ‚àß Œ¥ < 1 - BStar),
    Pr_{let r ‚Üê$·µñ Gen.Gen}[ proximityCondition f Œ¥ r Gen.C ] ‚â§ errStar Œ¥

instance {k : ‚Ñï} : NeZero (1 : ConcreteBTField k) :=

OracleSpec.QueryLog in VCVio.OracleComp.QueryTracking.Structures

def SumFunEquivProd (Œ± Œ≤ Œ≥ : Type) : ((Œ± ‚äï Œ≤) ‚Üí Œ≥) ‚âÉ (Œ± ‚Üí Œ≥) √ó (Œ≤ ‚Üí Œ≥) :=
{ toFun := fun f => (fun a => f (.inl a), fun b => f (.inr b))
  , invFun := fun p x => match x with | .inl a => p.fst a | .inr b => p.snd b
  , left_inv := by admit /- proof elided -/

Mod.mod in Init.Prelude

noncomputable instance {R : Type u} [CommSemiring R] : PolynomialLike R R[X] where
  X := Polynomial.X
  eval‚ÇÇ := Polynomial.eval‚ÇÇRingHom
  eval‚ÇÇ_C := Polynomial.eval‚ÇÇ_C
  eval‚ÇÇ_X := Polynomial.eval‚ÇÇ_X
  eval‚ÇÇ_eq f := by admit /- proof elided -/

@[reducible]
def SimOracle.Impl (spec : OracleSpec Œπ) := SimOracle.Stateless spec []‚Çí

def Straightline :=
  StmtIn ‚Üí 
  WitOut ‚Üí 
  FullTranscript pSpec ‚Üí 
  QueryLog oSpec ‚Üí 
  QueryLog oSpec ‚Üí 
  OracleComp oSpec WitIn 

instance : Coe (‚àÄ a : Œ±, Œ≤ a) F where
  coe := DFunEquiv.equiv.invFun

@[inline, reducible]
protected def id :
    OracleContext.Lens OuterStmtIn OuterStmtOut OuterStmtIn OuterStmtOut
                OuterOStmtIn OuterOStmtOut OuterOStmtIn OuterOStmtOut
                OuterWitIn OuterWitOut OuterWitIn OuterWitOut where
  stmt := OracleStatement.Lens.id
  wit := Witness.Lens.id

alias trivial := OracleContext.Lens.id

def EvenPoly (f : Polynomial F) : Prop := ‚àÄ n, Odd n ‚Üí f.coeff n = 0

@[reducible]
def Set.language {Œ± Œ≤} (rel : Set (Œ± √ó Œ≤)) : Set Œ± :=
  Prod.fst '' rel

structure Witness (i : Fin (‚Ñì + 1)) where
  t : L‚¶É‚â§ 1‚¶Ñ[X Fin ‚Ñì]  
  H : L‚¶É‚â§ 2‚¶Ñ[X Fin (‚Ñì - i)] 
  f: (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®i, by admit /- proof elided -/
  ‚ü© ‚Üí L 

Polynomial.support in Mathlib.Algebra.Polynomial.Basic

def sumPartial (m : ‚Ñï) (n : ‚Ñï) (D : Fin n ‚Üí Finset R) :
    MvPolynomial (Fin (m + n)) R ‚Üí‚Çó[R] MvPolynomial (Fin m) R where
  toFun := fun p => ‚àë x ‚àà Fintype.piFinset D, peval (Fin.sumCommEquiv m n) x p
  map_add' := fun p q => by admit /- proof elided -/

instance : Field BaseField := ZMod.instField baseFieldSize

Fintype.decidablePiFintype in Mathlib.Data.Fintype.Defs

@[simp]
abbrev Witness.AfterFirstMessage : Type := Unit

def rbrKnowledgeSoundnessOneShot (relIn : Set (StmtIn √ó WitIn)) (relOut : Set (StmtOut √ó WitOut))
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    (rbrKnowledgeError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) : Prop :=
  ‚àÉ stateFunction : verifier.KnowledgeStateFunctionOneShot init impl relIn.language relOut.language,
  ‚àÉ extractor : Extractor.RoundByRoundOneShot oSpec StmtIn WitIn pSpec,
  ‚àÄ stmtIn : StmtIn,
  ‚àÄ witIn : WitIn,
  ‚àÄ prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec,
  ‚àÄ i : pSpec.ChallengeIdx,
    [fun ‚ü®transcript, challenge, proveQueryLog‚ü© =>
      letI extractedWitIn := extractor i.1.castSucc stmtIn transcript proveQueryLog.fst
      (stmtIn, extractedWitIn) ‚àâ relIn ‚àß
        ¬¨ stateFunction i.1.castSucc stmtIn transcript ‚àß
          stateFunction i.1.succ stmtIn (transcript.concat challenge)
    | do
      (simulateQ (impl ++‚Çõ‚Çí challengeQueryImpl : QueryImpl _ (StateT œÉ ProbComp))
        (do
          let ‚ü®‚ü®transcript, _‚ü©, proveQueryLog‚ü© ‚Üê prover.runWithLogToRound i.1.castSucc stmtIn witIn
          let challenge ‚Üê liftComp (pSpec.getChallenge i) _
          return (transcript, challenge, proveQueryLog))).run' (‚Üê init)] ‚â§
      rbrKnowledgeError i

@[reducible, simp]
def relOut : (StmtOut OStatement √ó ‚àÄ i, OStmtOut OStatement i) ‚Üí WitOut ‚Üí Prop :=
  fun ‚ü®‚ü®q, r‚ü©, oStmt‚ü© () => answer (oStmt 0) q = r

instance instDCast‚ÇÇ : DCast‚ÇÇ Nat ProtocolSpec (fun _ pSpec => ChallengeIdx pSpec) where
  dcast‚ÇÇ h := ChallengeIdx.cast h
  dcast‚ÇÇ_id := cast_id

def getPutativeRoot {n : ‚Ñï} (i : Fin (2 ^ n)) (leaf : Œ±) (proof : List.Vector Œ± n) :
    OracleComp (spec Œ±) Œ± := do
  match h : n with
  | 0 => do
    
    return leaf
  | n + 1 => do
    
    let signBit := i.val % 2
    
    let i' : Fin (2 ^ n) := ‚ü®i.val / 2, by admit /- proof elided -/
    ‚ü©
    if signBit = 0 then
      
      let newLeaf ‚Üê query (spec := spec Œ±) () ‚ü®leaf, proof.get (Fin.last n)‚ü©
      getPutativeRoot i' newLeaf (proof.drop 1)
    else
      
      let newLeaf ‚Üê query (spec := spec Œ±) () ‚ü®proof.get (Fin.last n), leaf‚ü©
      getPutativeRoot i' newLeaf (proof.drop 1)

@[reducible]
noncomputable def reduction [DecidableEq F] :
  OracleReduction []‚Çí
    (Statement F (0 : Fin (k + 1))) (OracleStatement D x s (0 : Fin (k + 1)))
      (Witness F s d (0 : Fin (k + 2)))
    (FinalStatement F k) (FinalOracleStatement D x s) (Witness F s d (Fin.last (k + 1)))
    (pSpecFold D x k s ++‚Çö FinalFoldPhase.pSpec F ++‚Çö QueryRound.pSpec D x l) :=
  OracleReduction.append (reductionFold D x k s d)
    (QueryRound.queryOracleReduction (k := k) D x s d dom_size_cond l)

instAlgebra in Mathlib.LinearAlgebra.TensorAlgebra.Basic

Nat.decEq in Init.Prelude

Empty in Init.Prelude

instance : ‚àÄ i, SelectableType ((pSpecLastBlock (L:=L) (œë:=œë)).Challenge i) :=
  instSelectableTypeChallengeSeqCompose

protected def Reduction.id : Reduction oSpec Statement Witness Statement Witness !p[] where
  prover := Prover.id
  verifier := Verifier.id

def instDefault {Message : Type u} : OracleInterface Message where
  Query := Unit
  Response := Message
  answer := fun m _ => m

AdjoinRoot.instField in Mathlib.RingTheory.AdjoinRoot

Finset.min in Mathlib.Data.Finset.Max

@[reducible]
def index (op : MemoryWrite Œπ Œ±) := op.1

@[simp]
abbrev FirstChallenge : Type := Fin pp.‚Ñì_m ‚Üí R

structure ProverPrivateRng (R : Type*) where
   
  ds : Unit 
   
  csrng : R
deriving Repr

class VCVCompatible (Œ± : Type*) extends Fintype Œ±, Inhabited Œ± where
  [type_decidableEq' : DecidableEq Œ±]

def findIdxRev?_def {cond} {as : Array Œ±} {k : Fin as.size} :
  findIdxRev? cond as = some k ‚Üí cond as[k] :=

noncomputable instance {v : Œπ ‚Üí F} {s : AffineSubspace F (Œπ ‚Üí F)} [Fintype s] :
    Fintype (v +·µ• s) := Fintype.ofFinite ‚Ü•(v +·µ• s)

noncomputable def R
  (Œ¥ : ‚Ñö) (x‚ÇÄ : F)
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  : F[Z][X][Y] := (exists_factors_with_large_common_root_set k Œ¥ x‚ÇÄ h_gs).choose

noncomputable def towerRingEquivFromConcrete0 : ConcreteBTField 0 ‚âÉ+* BTField 0 :=

structure Context.Lens (OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                          OuterWitIn OuterWitOut InnerWitIn InnerWitOut : Type) where
  stmt : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
  wit : Witness.Lens OuterStmtIn InnerStmtOut OuterWitIn OuterWitOut InnerWitIn InnerWitOut

def fullRound (params : Params) (state : Vector KoalaBear.Field params.width)
    (roundConstants : Vector KoalaBear.Field params.width) : Vector KoalaBear.Field params.width :=
  
  let stateWithConstants := state.zipWith (¬∑+¬∑) roundConstants
  
  let stateAfterSbox := stateWithConstants.map (fun x => x ^ sBoxDegree)
  
  externalLinearLayer params stateAfterSbox

structure Opening where
  opening : Proof oSpec (Commitment √ó O.Query √ó O.Response) (Data √ó Randomness) pSpec

def prover (i : Fin n) : OracleProver oSpec
    (StatementRound R n i.castSucc) (OracleStatement R n deg) Unit
    (StatementRound R n i.succ) (OracleStatement R n deg) Unit (pSpec R deg) where
  toProverState := proverState R n deg i
  toProverInput := proverInput R n deg i
  sendMessage := (proverRound R n deg D oSpec i).sendMessage
  receiveChallenge := (proverRound R n deg D oSpec i).receiveChallenge
  toProverOutput := proverOutput R n deg oSpec i

def AlgebraTowerEquiv.algebraMapRightUp (e : AlgebraTowerEquiv A B) (i j : Œπ)
    (h : i ‚â§ j) : (A i) ‚Üí+* (B j) :=

def partialEval {k : ‚Ñï} (f : MvPolynomial (Fin m) F) (Œ± : Fin k ‚Üí F) (h : k ‚â§ m) :
    MvPolynomial (Fin (m - k)) F :=
  let œÜ : Fin m ‚Üí MvPolynomial (Fin (m - k)) F := fun i =>
    if h' : i.val < k then
      C (Œ± ‚ü®i.val, h'‚ü©)
    else
      let j := i.val - k
      let j' : Fin (m - k) := ‚ü®j, sorry‚ü©
      X j'
  eval‚ÇÇ C œÜ f

def lastBlockOracleReduction :=
  let bIdx := ‚Ñì / œë - 1
  let stmt : Fin (œë + 1) ‚Üí Type := fun i => Statement (L := L) (‚Ñì := ‚Ñì) Context
    ‚ü®bIdx * œë + i, by admit /- proof elided -/
    ‚ü©
  let oStmt := fun i: Fin (œë + 1) => OracleStatement ùîΩq Œ≤ œë
    ‚ü®bIdx * œë + i, by admit /- proof elided -/
    ‚ü©
  let wit := fun i: Fin (œë + 1) => Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì)
    ‚ü®bIdx * œë + i, by admit /- proof elided -/
    ‚ü©
  let V:  OracleReduction []‚Çí (StmtIn := Statement (L := L) (‚Ñì := ‚Ñì) Context
    ‚ü®bIdx * œë, by admit /- proof elided -/
    ‚ü©)
    (OStmtIn := OracleStatement ùîΩq Œ≤ œë
      ‚ü®bIdx * œë, by admit /- proof elided -/
      ‚ü©)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì)
      ‚ü®bIdx * œë, by admit /- proof elided -/
      ‚ü©)
    (StmtOut := Statement (L := L) (‚Ñì := ‚Ñì) Context (Fin.last ‚Ñì))
    (OStmtOut := OracleStatement ùîΩq Œ≤ œë (Fin.last ‚Ñì))
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) (Fin.last ‚Ñì))
    (pSpec := pSpecLastBlock (L:=L) (œë:=œë)) := by admit /- proof elided -/

def Straightline.append (E‚ÇÅ : Extractor.Straightline oSpec Stmt‚ÇÅ Wit‚ÇÅ Wit‚ÇÇ pSpec‚ÇÅ)
    (E‚ÇÇ : Extractor.Straightline oSpec Stmt‚ÇÇ Wit‚ÇÇ Wit‚ÇÉ pSpec‚ÇÇ)
    (V‚ÇÅ : Verifier oSpec Stmt‚ÇÅ Stmt‚ÇÇ pSpec‚ÇÅ) :
      Extractor.Straightline oSpec Stmt‚ÇÅ Wit‚ÇÅ Wit‚ÇÉ (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ) :=
  fun stmt‚ÇÅ wit‚ÇÉ transcript proveQueryLog verifyQueryLog => do
    let stmt‚ÇÇ ‚Üê V‚ÇÅ.verify stmt‚ÇÅ transcript.fst
    let wit‚ÇÇ ‚Üê E‚ÇÇ stmt‚ÇÇ wit‚ÇÉ transcript.snd proveQueryLog verifyQueryLog
    let wit‚ÇÅ ‚Üê E‚ÇÅ stmt‚ÇÅ wit‚ÇÇ transcript.fst proveQueryLog verifyQueryLog
    return wit‚ÇÅ

MvPolynomial.eval‚ÇÇ in Mathlib.Algebra.MvPolynomial.Eval

noncomputable def modBivar (P P' : MvPolynomial (Fin 2) F)
    (hlg : IsUnit ((MonomialOrder.lex).leadingCoeff P')) : MvPolynomial (Fin 2) F :=
      
      let ord : MonomialOrder (Fin 2) := MonomialOrder.lex
      
      let b : Unit ‚Üí MvPolynomial (Fin 2) F := fun _ => P'
      
      have hb : ‚àÄ i : Unit, IsUnit (ord.leadingCoeff (b i)) := by admit /- proof elided -/

@[inline, specialize]
def oracleVerifier : OracleVerifier oSpec
    Statement OStatement Statement (OStatement ‚äï·µ• (fun _ : Fin 1 => Witness))
    (oraclePSpec Witness) where
  verify := fun stmt _ => pure stmt
  embed := .sumMap (.refl _)
    <| Equiv.toEmbedding
    <|.symm (subtypeUnivEquiv (by admit /- proof elided -/
    ))
  hEq := by admit /- proof elided -/

@[inline]
def ofInputOnly (projWit : OuterStmtIn √ó OuterWitIn ‚Üí InnerWitIn) :
    Witness.Lens OuterStmtIn OuterStmtOut OuterWitIn OuterWitOut InnerWitIn OuterWitOut :=
  ‚ü®projWit, fun _ => Prod.snd‚ü©

def Verifier.StateFunction.id {lang : Set Statement} :
    (Verifier.id : Verifier oSpec Statement _ _).StateFunction init impl lang lang where
  toFun | ‚ü®0, _‚ü© => fun stmtIn _ => stmtIn ‚àà lang
  toFun_empty := fun _ => by admit /- proof elided -/

Array.reverse in Init.Data.Array.Basic

def JohnsonConditionStrong (B : Finset (Fin n ‚Üí F)) (v : Fin n ‚Üí F) : Prop :=
  let e := e B v
  let d := d B
  let q : ‚Ñö := Fintype.card F
  let frac := q / (q - 1)
  (1 - frac * d/n) < (1- frac * e/n) ^ 2

def rootsOfUnity (n s : ‚Ñï) : List (Domain.evalDomain D (n - s)) :=
  List.map
    (fun i =>
      ‚ü®
        (DIsCyclicC.gen.1 ^ (2 ^ (n - s))) ^ i,
        by admit /- proof elided -/
      ‚ü©
    )
    (List.range (2 ^ s))

noncomputable def normalizedW (i : Fin r) : L[X] :=
  C (1 / (W ùîΩq Œ≤ i).eval (Œ≤ i)) * W ùîΩq Œ≤ i

@[inline]
def nsmul [SMul ‚Ñï R] (m : ‚Ñï) (p : MlPolyEval R n) : MlPolyEval R n := p.map (fun a => m ‚Ä¢ a)

PMF.uniformOfFintype in Mathlib.Probability.Distributions.Uniform

Algebra.TensorProduct.includeLeftRingHom in Mathlib.RingTheory.TensorProduct.Basic

def range (n : ‚Ñï) : Fin n ‚Üí ‚Ñï := fun i => i

def finSuccEquivNth : MvPolynomial (Fin (n + 1)) R ‚âÉ‚Çê[R] Polynomial (MvPolynomial (Fin n) R) :=
  (renameEquiv R (_root_.finSuccEquiv' p)).trans (optionEquivLeft R (Fin n))

instance [O‚Çò : ‚àÄ i, OracleInterface (pSpec.Message i)] :
    ‚àÄ i, OracleInterface ((pSpec.addSalt Salt).Message i) :=
  fun i => {
    Query := (O‚Çò i).Query
    Response := (O‚Çò i).Response
    answer := fun msg => (O‚Çò i).answer (by admit /- proof elided -/
      )
  }

def getUElements (i : Fin r) : List L :=
  (List.finRange (2^i.val)).map fun k =>
    (Finset.univ : Finset (Fin i)).sum fun j =>
      if Nat.getBit (n := k.val) (k := j.val) == 1 then
        Œ≤ ‚ü®j.val, by admit /- proof elided -/
        ‚ü©
      else 0

TensorProduct in Mathlib.LinearAlgebra.TensorProduct.Basic

Subtype.mk in Init.Prelude

@[reducible]
noncomputable def fullOracleProof :
  OracleProof []‚Çí
    (Statement := Statement (L := L) (‚Ñì:=‚Ñì) (SumcheckBaseContext L ‚Ñì) 0)
    (OStatement := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë 0)
    (Witness := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) 0)
    (pSpec:=fullPSpec ùîΩq Œ≤ Œ≥_repetitions (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)) :=
  fullOracleReduction ùîΩq Œ≤ Œ≥_repetitions (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë)

@[reducible]
def foldCommitOracleVerifier (i : Fin ‚Ñì) (hCR : isCommitmentRound ‚Ñì œë i) :
  OracleVerifier []‚Çí
    (StmtIn := Statement (L := L) Context i.castSucc)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.succ)
    (pSpec := pSpecFoldCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) :=
    OracleVerifier.append (oSpec:=[]‚Çí)
      (pSpec‚ÇÅ := pSpecFold (L:=L))
      (pSpec‚ÇÇ := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)
      (V‚ÇÅ := foldOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)
      (V‚ÇÇ := commitOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hCR)

HDiv in Init.Prelude

@[reducible]
def MlPoly (R : Type*) (n : ‚Ñï) := Vector R (2 ^ n) 

def findFinIdxIfTrue (p : Œ± ‚Üí Bool) (l : List Œ±) (h : ‚àÉ x ‚àà l, p x) : Fin l.length :=
  ‚ü®List.findIdx' p l, by admit /- proof elided -/
  ‚ü©

@[simp]
abbrev Statement.AfterLinearCombination : Type :=
  LinearCombinationChallenge R √ó Statement.AfterSendEvalClaim R pp

@[inline, specialize]
def OracleReduction.runWithLog [‚àÄ i, OracleInterface (pSpec.Message i)]
    (stmt : StmtIn) (oStmt : ‚àÄ i, OStmtIn i) (wit : WitIn)
    (reduction : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec) :
      OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí)
        ((FullTranscript pSpec √ó (StmtOut √ó ‚àÄ i, OStmtOut i) √ó WitOut) √ó
          (StmtOut √ó ‚àÄ i, OStmtOut i) √ó
            QueryLog (oSpec ++‚Çí [pSpec.Challenge]‚Çí) √ó QueryLog oSpec) := do
  let ‚ü®proverResult, proveQueryLog‚ü© ‚Üê
    (simulateQ loggingOracle (reduction.prover.run ‚ü®stmt, oStmt‚ü© wit)).run
  let ‚ü®stmtOut, verifyQueryLog‚ü© ‚Üê
    liftM (simulateQ loggingOracle (reduction.verifier.run stmt oStmt proverResult.1)).run
  return ‚ü®proverResult, stmtOut, proveQueryLog, verifyQueryLog‚ü©

instance instDCast‚ÇÇ : DCast‚ÇÇ Nat ProtocolSpec
    (fun _ pSpec => Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) where
  dcast‚ÇÇ := Prover.cast
  dcast‚ÇÇ_id := Prover.cast_id

instance {Œπ : Type u} (v : Œπ ‚Üí Type v) [O : ‚àÄ i, OracleInterface (v i)]
    [h : ‚àÄ i, Fintype (Response (v i))]
    [h' : ‚àÄ i, Inhabited (Response (v i))] :
    [v]‚Çí.FiniteRange where
  range_fintype' := h
  range_inhabited' := h'

@[reducible, simp]
def MessageIdx (pSpec : ProtocolSpec n) :=
  {i : Fin n // pSpec.dir i = Direction.P_to_V}

def implGroupOpOracle : QueryImpl (GroupOpOracle Œπ) (StateT (GroupValTable Œπ G) Option) where
  impl | query _ ‚ü®i, j, k‚ü© => fun table =>
    match table i, table j with
    | some g‚ÇÅ, some g‚ÇÇ => some ((), table.update k (some (g‚ÇÅ * g‚ÇÇ)))
    | _, _ => none

def ranges {n : ‚Ñï} (a : Fin n ‚Üí ‚Ñï) : (i : Fin n) ‚Üí Fin (a i) ‚Üí ‚Ñï :=
  match n with
  | 0 => fun i => elim0 i
  | n + 1 => fun i => by admit /- proof elided -/

Polynomial.resultant in Mathlib.RingTheory.Polynomial.Resultant.Basic

@[reducible, simp]
def rbrKnowledgeSoundness (relation : Set (Statement √ó Bool))
    (verifier : Verifier oSpec Statement Bool pSpec)
    (rbrKnowledgeError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) : Prop :=
  verifier.rbrKnowledgeSoundness init impl relation acceptRejectRel rbrKnowledgeError

@[reducible]
def rateSegment (state : CanonicalSpongeState U) : Vector U SpongeSize.R :=
  
  (Vector.take state SpongeSize.R).cast (by admit /- proof elided -/
  )

instance {k : ‚Ñï} : IntCast (ConcreteBTField k) where
  intCast n:= intCast n

Equiv in Mathlib.Logic.Equiv.Defs

Irreducible in Mathlib.Algebra.Group.Irreducible.Defs

instance [h : ProverLast pSpec] : ProverFirst pSpec where
  prover_first' := by admit /- proof elided -/

@[inline] def add (a b : AssocNat) : AssocNat :=
  ‚ü®a ‚àò b, by admit /- proof elided -/
  ‚ü©

@[simp]
instance BTFieldIsDomain (k : ‚Ñï) : IsDomain (BTField k) := inferInstance

instance finiteDimensional_degreeLT {n : ‚Ñï} (h_n_pos : 0 < n) :
  FiniteDimensional L L‚¶É< n‚¶Ñ[X] :=

def implGroupExpOracle : QueryImpl (GroupExpOracle Œπ p) (StateT (GroupValTable Œπ G) Option) where
  impl | query _ ‚ü®i, a, j‚ü© => fun table =>
    match table i with
    | some g => some ((), table.update j (some (g ^ a.val)))
    | none => none

def SkeletonNodeIndex.parent {s : Skeleton} (idx : SkeletonNodeIndex s) :
    Option (SkeletonNodeIndex s) :=
  match idx with
  | SkeletonNodeIndex.ofLeaf => none
  | SkeletonNodeIndex.ofInternal => none
  | SkeletonNodeIndex.ofLeft (.ofLeaf) => some .ofInternal
  | SkeletonNodeIndex.ofLeft (.ofInternal) => some .ofInternal
  | SkeletonNodeIndex.ofLeft idxLeft =>
    idxLeft.parent.map (SkeletonNodeIndex.ofLeft)
  | SkeletonNodeIndex.ofRight (.ofLeaf) => some .ofInternal
  | SkeletonNodeIndex.ofRight (.ofInternal) => some .ofInternal
  | SkeletonNodeIndex.ofRight idxRight =>
    idxRight.parent.map (SkeletonNodeIndex.ofRight)

instance : ‚àÄ i, NeZero (toOutCodewordsCount ‚Ñì œë i) :=

def extend {k : Fin n} (messages : MessagesUpTo k.castSucc pSpec)
    (h : pSpec.dir k = .V_to_P) : MessagesUpTo k.succ pSpec :=
  fun ‚ü®i, h‚ü© => (concat' (pSpec := pSpec) (fun i hi => messages ‚ü®i, hi‚ü©) (fun h' => by admit /- proof elided -/
  )) i h

def FullData.map {Œ± Œ≤ : Type} (f : Œ± ‚Üí Œ≤) {s : Skeleton}
    (tree : FullData Œ± s) : FullData Œ≤ s :=
  match tree with
  | FullData.leaf value => FullData.leaf (f value)
  | FullData.internal value left right =>
    FullData.internal (f value) (left.map f) (right.map f)

def pSpecNonLastBlocks := seqCompose fun bIdx ‚Ü¶
  pSpecFullNonLastBlock ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) bIdx

noncomputable def polyEvalLinearMap {L ùîΩq : Type*} [Field L] [Field ùîΩq] [Algebra ùîΩq L]
  (p : L[X]) (hp_add : IsLinearMap ùîΩq (fun x : L => p.eval x)) : L ‚Üí‚Çó[ùîΩq] L :=
{
  toFun    := fun x => p.eval x,
  map_add' := hp_add.map_add,
  map_smul' := hp_add.map_smul
}

instance instDCast‚ÇÇ : DCast‚ÇÇ Nat ProtocolSpec (fun _ pSpec => MessageIdx pSpec) where
  dcast‚ÇÇ h := MessageIdx.cast h
  dcast‚ÇÇ_id := cast_id

structure ParamConditions (P : Params Œπ F) where
  m : ‚Ñï 
  h_m : m = P.varCount 0
  h_sumkLt : ‚àë i : Fin (M + 1), P.foldingParam i ‚â§ m
  h_varCount_i : ‚àÄ i : Fin (M + 1),
    P.varCount i = m - ‚àë j : Fin i, P.foldingParam (Fin.castLT j (Nat.lt_trans j.isLt i.isLt))
  h_smooth : ‚àÄ i : Fin (M + 1), Smooth (P.œÜ i)
  h_repeatPLt : ‚àÄ i : Fin (M + 1), P.repeatParam i ‚â§ Fintype.card (Œπ i)

@[reducible]
def Extractor.Straightline.id : Extractor.Straightline oSpec StmtIn WitIn WitIn !p[] :=
  fun _ witOut _ _ _ => pure witOut

@[reducible]
def relation :
    (Fin sz.n_x ‚Üí R) ‚Üí 
    (MatrixIdx ‚Üí Matrix (Fin sz.m) (Fin sz.n) R) ‚Üí 
    (Fin sz.n_w ‚Üí R) ‚Üí 
    Prop :=
  fun stmt matrix wit =>
    letI ùï´ := ùï´ stmt wit
    (matrix .A *·µ• ùï´) * (matrix .B *·µ• ùï´) = (matrix .C *·µ• ùï´)

instance : Fintype (pSpec.MessageIdx) := Subtype.fintype (fun i => pSpec.dir i = .P_to_V)

instance instDCast : DCast Nat ProtocolSpec where
  dcast h := ProtocolSpec.cast h
  dcast_id := cast_id

def oracleVerifier : OracleVerifier oSpec (StmtIn R) (OStmtIn R deg) (StmtOut R) (OStmtOut R deg)
    (pSpec R deg) where
  verify := fun target chal => do
    let evals : Vector R m ‚Üê (Vector.finRange m).mapM
      (fun i => query (spec := [OStmtIn R deg]‚Çí) () (D i))
    guard (evals.sum = target)
    
    pure (sorry, chal default)
  embed := .inl
  hEq := fun i => by admit /- proof elided -/

Inhabited in Init.Prelude

EquivLike in Mathlib.Data.FunLike.Equiv

def fappend {A : Sort u} {F : A ‚Üí Sort v} {m n : ‚Ñï} {Œ± : Fin m ‚Üí A} {Œ≤ : Fin n ‚Üí A}
    (u : (i : Fin m) ‚Üí F (Œ± i)) (v : (i : Fin n) ‚Üí F (Œ≤ i)) :
    (i : Fin (m + n)) ‚Üí F (Fin.vappend Œ± Œ≤ i) :=
  match n with
  | 0 => u
  | k + 1 => fconcat (fappend u (fun i => v (Fin.castSucc i))) (v (Fin.last k))

@[reducible, inline]
instance instPolynomial : OracleInterface R[X] where
  Query := R
  Response := R
  answer := fun poly point => poly.eval point

def toOracleSpec {Œπ : Type u} (v : Œπ ‚Üí Type v) [O : ‚àÄ i, OracleInterface (v i)] :
    OracleSpec Œπ := fun i => ((O i).Query, (O i).Response)

instance [h : ProverFirst pSpec] : IsEmpty (pSpec.ChallengeIdx) where
  false | ‚ü®0, h'‚ü© => by admit /- proof elided -/

def fold (i : Fin r) (h_i : i + 1 < ‚Ñì + ùì°) (f : (sDomain ùîΩq Œ≤
    h_‚Ñì_add_R_rate) i ‚Üí L) (r_chal : L) :
    (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) (‚ü®i + 1, by admit /- proof elided -/
    ‚ü©) ‚Üí L :=
  fun y => by admit /- proof elided -/

def Prover.duplexSpongeFiatShamir (P : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) :
    NonInteractiveProver (‚àÄ i, pSpec.Message i) (oSpec ++‚Çí duplexSpongeChallengeOracle StmtIn U)
      StmtIn WitIn StmtOut WitOut where
  PrvState := fun i => match i with
    | 0 => StmtIn √ó P.PrvState 0
    | _ => P.PrvState (Fin.last n)
  input := fun ctx => ‚ü®ctx.1, P.input ctx‚ü©
  
  sendMessage | ‚ü®0, _‚ü© => fun ‚ü®stmtIn, state‚ü© => do
    let ‚ü®messages, _, state‚ü© ‚Üê P.runToRoundDSFS (Fin.last n) stmtIn state
    return ‚ü®messages, state‚ü©
  
  receiveChallenge | ‚ü®0, h‚ü© => nomatch h
  output := fun st => (P.output st).liftComp _

instance : ‚àÄ j, OracleInterface ((pSpecFoldRelay (L:=L)).Message j) :=
  instOracleInterfaceMessageAppend

PFunctor.Lens in ToMathlib.PFunctor.Basic

noncomputable def H
  (Œ¥ : ‚Ñö) (x‚ÇÄ : F)
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  : F[Z][X] := (exists_factors_with_large_common_root_set k Œ¥ x‚ÇÄ h_gs).choose_spec.choose

def deriveTranscriptDSFSAux {Œπ : Type} {oSpec : OracleSpec Œπ} {StmtIn : Type}
    (sponge : CanonicalDuplexSponge U)
    (messages : pSpec.Messages) (i : Fin (n + 1)) :
      OracleComp (oSpec ++‚Çí duplexSpongeChallengeOracle StmtIn U)
        (CanonicalDuplexSponge U √ó pSpec.Transcript i) :=
  Fin.induction
    (pure (sponge, fun i => i.elim0))
    (fun i ih => do
      let ‚ü®curSponge, prevTranscript‚ü© ‚Üê ih
      match hDir : pSpec.dir i with
      | .V_to_P =>
        let ‚ü®challenge, newSponge‚ü© ‚Üê liftM (curSponge.squeeze (challengeSize ‚ü®i, hDir‚ü©))
        let deserializedChallenge : pSpec.Challenge ‚ü®i, hDir‚ü© :=
          Deserialize.deserialize challenge
        return (newSponge, prevTranscript.concat deserializedChallenge)
      | .P_to_V =>
        let serializedMessage : Vector U (messageSize ‚ü®i, hDir‚ü©) :=
          Serialize.serialize (messages ‚ü®i, hDir‚ü©)
        let newSponge ‚Üê liftM (DuplexSponge.absorb curSponge serializedMessage.toList)
        return (newSponge, prevTranscript.concat (messages ‚ü®i, hDir‚ü©)))
    i

def sumcheckConsistencyProp {k : ‚Ñï} (sumcheckTarget : L) (H : L‚¶É‚â§ 2‚¶Ñ[X Fin (k)]) : Prop :=
  sumcheckTarget = ‚àë x ‚àà (univ.map ùìë) ^·∂† (k), H.val.eval x

Nat.boddDiv2 in Mathlib.Data.Nat.Bits

def FullData.Equiv {Œ±} (s : Skeleton) :
    FullData Œ± s ‚âÉ InternalData Œ± s √ó LeafData Œ± s :=

def StateRestoration.KnowledgeSoundness (oSpec : OracleSpec Œπ) (StmtIn WitOut : Type)
    {n : ‚Ñï} (pSpec : ProtocolSpec n) :=
  OracleComp (oSpec ++‚Çí (srChallengeOracle StmtIn pSpec)) (StmtIn √ó pSpec.Messages √ó WitOut)

structure SparseMatrix (m n Œ± : Type*) where
  numEntries : ‚Ñï
  row : Fin numEntries ‚Üí m
  col : Fin numEntries ‚Üí n
  val : Fin numEntries ‚Üí Œ±
deriving Inhabited, DecidableEq

def fappend‚ÇÇ {A : Sort u} {B : Sort v} {F : A ‚Üí B ‚Üí Sort w} {m n : ‚Ñï}
    {Œ±‚ÇÅ : Fin m ‚Üí A} {Œ≤‚ÇÅ : Fin n ‚Üí A} {Œ±‚ÇÇ : Fin m ‚Üí B} {Œ≤‚ÇÇ : Fin n ‚Üí B}
    (u : (i : Fin m) ‚Üí F (Œ±‚ÇÅ i) (Œ±‚ÇÇ i)) (v : (i : Fin n) ‚Üí F (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) :
    (i : Fin (m + n)) ‚Üí F (Fin.vappend Œ±‚ÇÅ Œ≤‚ÇÅ i) (Fin.vappend Œ±‚ÇÇ Œ≤‚ÇÇ i) :=
  match n with
  | 0 => u
  | k + 1 => fconcat‚ÇÇ (fappend‚ÇÇ u (fun i => v (Fin.castSucc i))) (v (Fin.last k))

def sBasis (i : Fin r) (h_i : i < ‚Ñì + R_rate) : Fin (‚Ñì + R_rate - i) ‚Üí L :=
  fun k => Œ≤ ‚ü®i + k.val, by admit /- proof elided -/
  ‚ü©

instance {s} : Functor (fun Œ± => LeafData Œ± s) where
  map f x := x.map f

@[inline, specialize]
def Reduction.run (stmt : StmtIn) (wit : WitIn)
    (reduction : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí)
        ((FullTranscript pSpec √ó StmtOut √ó WitOut) √ó StmtOut) := do
  
  let proverResult ‚Üê reduction.prover.run stmt wit
  let stmtOut ‚Üê liftM (reduction.verifier.run stmt proverResult.1)
  return ‚ü®proverResult, stmtOut‚ü©

OracleComp.construct in VCVio.OracleComp.OracleComp

structure PrimeWithMultiplicity : Type where
  prime : ‚Ñï
  multiplicity : ‚Ñï
deriving Repr

@[simp]
abbrev Witness.AfterLinearCombination : Type := Unit

class LawfulToNat (Œ± : Type u) [ToNat Œ±] [Zero Œ±] [HasSucc Œ±] : Prop where
  toNat_zero : ToNat.toNat (0 : Œ±) = 0
  toNat_succ (n : Œ±) : ToNat.toNat (succ' n) = ToNat.toNat n + 1

Finset.univ in Mathlib.Data.Fintype.Defs

def new (domainSeparator : DomainSeparator U H) : HashStateWithInstructions U H :=
  letI stack := domainSeparator.finalize
  letI tag := generateTag domainSeparator.asBytes
  { ds := Initialize.new tag, stack := stack }

def Reduction.addSalt (R : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec)
    (saltComp : (i : pSpec.MessageIdx) ‚Üí R.prover.PrvState i.1.castSucc ‚Üí
      OracleComp oSpec (Salt i)) :
    Reduction oSpec StmtIn WitIn StmtOut WitOut (pSpec.addSalt Salt) where
  prover := R.prover.addSalt Salt saltComp
  verifier := R.verifier.addSalt Salt

@[reducible, inline, specialize]
def MessagesUpTo (k : Fin (n + 1)) (pSpec : ProtocolSpec n) : Type :=
  ‚àÄ i, pSpec.MessageUpTo k i

noncomputable def relayOracleReduction (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
  OracleReduction (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) Context i.succ)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (pSpec := pSpecRelay) where
  prover := relayOracleProver ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hNCR
  verifier := relayOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hNCR

noncomputable def xPoly
  {S : Finset Œπ} (f : Œπ ‚Üí F) (œÜ : Œπ ‚Ü™ F) (k : ‚Ñï) (x : indexPow S œÜ k) : Polynomial F :=
  let dom := powFiber S œÜ k x
  let emb : { y // y ‚àà dom } ‚Üí F := œÜ ‚àò Subtype.val
  let g : { y // y ‚àà dom } ‚Üí F := f ‚àò Subtype.val
  Lagrange.interpolate univ emb g

@[simps!]
def equivMessagesChallenges :
    Transcript k pSpec ‚âÉ (MessagesUpTo k pSpec √ó ChallengesUpTo k pSpec) where
  toFun := toMessagesChallenges
  invFun := ofMessagesChallenges.uncurry
  left_inv := fun T => by admit /- proof elided -/

instance : IsEmpty (MessageIdx ‚ü®!v[.V_to_P], !v[Chal]‚ü©) :=
  ‚ü®fun ‚ü®i, h‚ü© => by admit /- proof elided -/
  ‚ü©

def processMemoryOps (ops : List (MemoryOp Œπ Œ±)) (startMem : M) : Option M :=
  ops.foldlM (fun m op =>
    match op with
    | .read ‚ü®i, v‚ü© => if Memory.read m i = v then some m else none
    | .write ‚ü®i, v‚ü© => some (Memory.write m i v)
  ) startMem

inductive SkeletonNodeIndex : Skeleton ‚Üí Type
  | ofLeaf : SkeletonNodeIndex Skeleton.leaf
  | ofInternal {left right} :
      SkeletonNodeIndex (Skeleton.internal left right)
  | ofLeft {left right : Skeleton} (idxLeft : SkeletonNodeIndex left) :
      SkeletonNodeIndex (Skeleton.internal left right)
  | ofRight {left right : Skeleton} (idxRight : SkeletonNodeIndex right) :
      SkeletonNodeIndex (Skeleton.internal left right)

def subNat [Zero T] [ToNat T] (a : Cayley T) : Nat ‚Üí Cayley T
  | 0        => a
  | .succ k  => pred (subNat a k)

def internalLinearLayer (state : Vector KoalaBear.Field params.width) :
    Vector KoalaBear.Field params.width :=
  
  
  let sumAll := state.foldl (fun acc x => acc + x) 0

  
  
  state.zipWith (fun s d => sumAll + d * s) params.internalDiagVectors

instance {Œ± : Type*} {n : ‚Ñï} [VCVCompatible Œ±] : VCVCompatible (Vector Œ± n) where

@[reducible, simp] def OStmtIn := fun _ : Fin 2 => OStatement

noncomputable def fieldToùïÉ {H : F[X][Y]} : F ‚Üí+* ùïÉ H :=
  RingHom.comp liftToFunctionField Polynomial.C

def HList.toDVec (l : HList) : DVec (m := Fin l.length) (fun i => l[i].1) := fun i => l[i].2

def sumExceptFirst (n : ‚Ñï) (D : Fin n ‚Üí Finset R) :
    MvPolynomial (Fin (n + 1)) R ‚Üí‚Çó[R] Polynomial R :=

def Prover.fiatShamir (P : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) :
    NonInteractiveProver (‚àÄ i, pSpec.Message i) (oSpec ++‚Çí fsChallengeOracle StmtIn pSpec)
      StmtIn WitIn StmtOut WitOut where
  PrvState := fun i => match i with
    | 0 => StmtIn √ó P.PrvState 0
    | _ => P.PrvState (Fin.last n)
  input := fun ctx => ‚ü®ctx.1, P.input ctx‚ü©
  
  sendMessage | ‚ü®0, _‚ü© => fun ‚ü®stmtIn, state‚ü© => do
    let ‚ü®messages, _, state‚ü© ‚Üê P.runToRoundFS (Fin.last n) stmtIn state
    return ‚ü®messages, state‚ü©
  
  receiveChallenge | ‚ü®0, h‚ü© => nomatch h
  output := fun st => (P.output st).liftComp _

def numQueries (stmt : StmtIn) (challenges : ‚àÄ i, pSpec.Challenge i)
    (verifier : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec) :
  OracleComp (oSpec ++‚Çí ([OStmtIn]‚Çí ++‚Çí [pSpec.Message]‚Çí)) ‚Ñï := sorry

@[reducible]
def randSpec (Œ≤ : Type) : OracleSpec Unit := fun _ => (Unit, Œ≤)

Fin.succAbove in Mathlib.Data.Fin.SuccPred

IsDomain in Mathlib.Algebra.Ring.Defs

instDecidableEqOfLawfulBEq in Init.Core

structure Simulator (oSpec : OracleSpec Œπ) (StmtIn : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n) where
  SimState : Type
  oracleSim : SimOracle.Stateful oSpec oSpec SimState
  proverSim : StmtIn ‚Üí StateT SimState (OracleComp oSpec) pSpec.FullTranscript

toNat in Mathlib.Computability.Reduce

def liftBTFieldProps (k : ‚Ñï) (prevBTFResult : ConcreteBTFStepResult (k := k)) :
  ConcreteBTFieldProps (k + 1) := {
    zero_mul := concrete_zero_mul (prevBTFResult.toConcreteBTFieldProps),
    zero_mul' := fun a => by admit /- proof elided -/

@[inline, specialize]
def mul (p q : UniPoly R) : UniPoly R :=
  p.zipIdx.foldl (fun acc ‚ü®a, i‚ü© => acc.add <| (smul a q).mulPowX i) (C 0)

def powContraction :
  MvPolynomial (Fin m) F ‚Üí‚Çó[F] Polynomial F :=
  powAlgHom.toLinearMap

noncomputable def byCheckMatrix [CommRing F] (H : Matrix Œπ Œ∫ F) : LinearCode Œ∫ F :=
  LinearMap.ker H.mulVecLin

instance : HasSucc Nat where
  succ' := Nat.succ

@[simps!]
noncomputable def algEquivAevalXSubC {R : Type*} [CommRing R] (t : R) : R[X] ‚âÉ‚Çê[R] R[X] :=

@[reducible]
def fieldSize : Nat := 2 ^ 31 - 2 ^ 24 + 1

def Transcript.removeSalt {k : Fin (n + 1)} (transcript : (pSpec.addSalt Salt).Transcript k) :
    pSpec.Transcript k :=

  fun i => by admit /- proof elided -/

head in ToMathlib.Control.Comonad.Instances

instance instDCast‚ÇÇForall :
    DCast‚ÇÇ Œ± (fun a => ‚àÄ b : Œ≤ a, Œ≥ a b) (fun a f => ‚àÄ b : Œ≤ a, Œ¥ a b (f b)) where
  dcast‚ÇÇ ha hb c := fun b => dcast‚ÇÉ ha (by admit /- proof elided -/
  )
    (by admit /- proof elided -/
    ) (c (dcast ha.symm b))
  dcast‚ÇÇ_id := by admit /- proof elided -/

instance [VerifierFirst pSpec] [h : VCVCompatible (pSpec.¬´Type¬ª 0)] :
    ‚àÄ i, VCVCompatible (pSpec.Challenge i)
  | ‚ü®0, _‚ü© => inferInstance

Cardinal in Mathlib.SetTheory.Cardinal.Defs

def seqComposeChallengeIdxToSigma {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (k : (seqCompose pSpec).ChallengeIdx) : (i : Fin m) √ó (pSpec i).ChallengeIdx :=
  let ij := Fin.splitSum k.1
  ‚ü®ij.1, ‚ü®ij.2, by admit /- proof elided -/
    ‚ü©‚ü©

@[reducible, simp]
def pSpec : ProtocolSpec 1 := ‚ü®!v[.P_to_V], !v[Witness]‚ü©

dotProduct in Mathlib.Data.Matrix.Mul

Array.zipWith in Init.Data.Array.Basic

def Reduction.liftContext
    (lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut)
    (R : Reduction oSpec InnerStmtIn InnerWitIn InnerStmtOut InnerWitOut pSpec) :
      Reduction oSpec OuterStmtIn OuterWitIn OuterStmtOut OuterWitOut pSpec where
  prover := R.prover.liftContext lens
  verifier := R.verifier.liftContext lens.stmt

private noncomputable def oddPart' (f : Polynomial F) : Polynomial F :=
  match f with
  | ‚ü®‚ü®supp, f, pr‚ü©‚ü© => ‚ü®‚ü®
      shift_left (erase_even supp),
      fun n => if Even n then f (n + 1) else 0, by admit /- proof elided -/
      ‚ü©‚ü©

noncomputable def relayRbrExtractor (i : Fin ‚Ñì) :
  Extractor.RoundByRound []‚Çí
    (StmtIn := (Statement (L := L) Context i.succ) √ó (‚àÄ j, OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc j))
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (pSpec := pSpecRelay)
    (WitMid := fun _messageIdx => Witness (L := L) ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ) where
  eqIn := rfl
  extractMid := fun _ _ _ witMidSucc => witMidSucc
  extractOut := fun _ _ witOut => witOut

instance : Zero AssocNat where
  zero := zero

def relationAfterRandomQuery :
    Set (((StmtAfterRandomQuery R) √ó (‚àÄ i, OStmtAfterRandomQuery R deg i)) √ó Unit) :=
  { ‚ü®‚ü®chal, oStmt‚ü©, _‚ü© | (oStmt (Sum.inr ())).1.eval chal = (oStmt (Sum.inl ())).1.eval chal }

Polynomial.degree in Mathlib.Algebra.Polynomial.Degree.Definitions

abbrev BaseField := ZMod baseFieldSize

liftM in Init.Prelude

def finOneEquiv : MvPolynomial (Fin 1) R ‚âÉ‚Çê[R] Polynomial R :=
  (finSuccEquiv R 0).trans (Polynomial.mapAlgEquiv (isEmptyAlgEquiv R (Fin 0)))

AddGroup in Mathlib.Algebra.Group.Defs

def Œ≥' (x‚ÇÄ : F) (R : F[X][X][Y]) (H_irreducible : Irreducible H) : PowerSeries (ùïÉ H) :=
  Œ≥ x‚ÇÄ R H (œÜ := ‚ü®H_irreducible‚ü©)

def uniqueClosestCodeword
  (i : Fin (‚Ñì + 1)) (h_i : i < ‚Ñì + ùì°)
  (f : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i, i.isLt‚ü©)
  (h_within_radius : hammingClose ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i f) :
  OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i, i.isLt‚ü© :=

def InternalData.ofFun {Œ± : Type} (s : Skeleton)
    (f : SkeletonInternalIndex s ‚Üí Œ±) : InternalData Œ± s :=
  match s with
  | .leaf => InternalData.leaf
  | .internal l r =>
      InternalData.internal
        (f SkeletonInternalIndex.ofInternal)
        (InternalData.ofFun l (fun idx => f (SkeletonInternalIndex.ofLeft idx)))
        (InternalData.ofFun r (fun idx => f (SkeletonInternalIndex.ofRight idx)))

instance {n : ‚Ñï} : ToString (UnverifiedPrattCertificate n) where
  toString := fun c => s!"{repr c}"

def div [Field R] (p q : UniPoly R) : UniPoly R :=
  (C (q.leadingCoeff)‚Åª¬π ‚Ä¢ p).divByMonic (C (q.leadingCoeff)‚Åª¬π * q)

def evalX (a : F) (f : F[X][Y]) : Polynomial F :=
  ‚ü®Finsupp.mapRange (Polynomial.eval a) eval_zero f.toFinsupp‚ü©

noncomputable def polyQuotient (S : Finset F) (fPoly : F[X]) : F[X] :=
    (fPoly - (ansPoly S (fun s => fPoly.eval s))) / (vanishingPoly S)

noncomputable def ElocPolyF (œâs f : Fin n ‚Üí F) (p : Polynomial F) : Polynomial F :=
  ElocPoly n (liftF œâs) (liftF f) p

Repr in Init.Data.Repr

def backTrack (trace : QueryLog (duplexSpongeChallengeOracle StmtIn U))
    (state : CanonicalSpongeState U) :
    OptionT Option ((StmtIn √ó (i : Fin (n + 1)) √ó (pSpec.MessagesUpTo i))) :=
  sorry

def SkeletonNodeIndex.leftChild {s : Skeleton} (idx : SkeletonNodeIndex s) :
    Option (SkeletonNodeIndex s) :=
  match idx with
  | SkeletonNodeIndex.ofLeaf => none
  | @SkeletonNodeIndex.ofInternal left right =>
    some (SkeletonNodeIndex.ofLeft (getRootIndex left))
  | SkeletonNodeIndex.ofLeft idxLeft =>
    idxLeft.leftChild.map (SkeletonNodeIndex.ofLeft)
  | SkeletonNodeIndex.ofRight idxRight =>
    idxRight.leftChild.map (SkeletonNodeIndex.ofRight)

@[simp]
def ùïè (k : ‚Ñï) : ConcreteBTField (k + 1) := Z (k + 1)

Submodule.span in Mathlib.LinearAlgebra.Span.Defs

class ProverOnly (pSpec : ProtocolSpec 1) extends ProverFirst pSpec

 
alias NonInteractive := ProverOnly

instance {n : ‚Ñï} {Œ± : Fin n ‚Üí Type*} : SliceLT ((i : Fin n) ‚Üí Œ± i) ‚Ñï
    (fun _ stop => stop ‚â§ n)
    (fun _ stop h => (i : Fin stop) ‚Üí Œ± (i.castLE h))
    where
  sliceLT := fun v stop h => take stop h v

noncomputable def eval_on_Z‚ÇÄ (p : (RatFunc F)) (z : F) : F :=
  RatFunc.eval (RingHom.id _) z p


notation3:max R "[Z][X]" => Polynomial (Polynomial R)

notation3:max R "[Z][X][Y]" => Polynomial (Polynomial (Polynomial (R)))

notation3:max "Y" => Polynomial.X
notation3:max "X" => Polynomial.C Polynomial.X
notation3:max "Z" => Polynomial.C (Polynomial.C Polynomial.X)

instance {i : Fin (n + 1)} : OfNat (evalDomain D i) 1 where
  ofNat := ‚ü®1, one_in_doms D i‚ü©

@[ext]
structure OracleVerifier {Œπ : Type} (oSpec : OracleSpec Œπ)
    (StmtIn : Type) {Œπ‚Çõ·µ¢ : Type} (OStmtIn : Œπ‚Çõ·µ¢ ‚Üí Type)
    (StmtOut : Type) {Œπ‚Çõ‚Çí : Type} (OStmtOut : Œπ‚Çõ‚Çí ‚Üí Type)
    {n : ‚Ñï} (pSpec : ProtocolSpec n)
    [O‚Çõ·µ¢ : ‚àÄ i, OracleInterface (OStmtIn i)]
    [O‚Çò : ‚àÄ i, OracleInterface (pSpec.Message i)]
    where
    
    

   
  verify : StmtIn ‚Üí pSpec.Challenges ‚Üí
    OracleComp (oSpec ++‚Çí ([OStmtIn]‚Çí ++‚Çí [pSpec.Message]‚Çí)) StmtOut

  
  
  

  

   
  embed : Œπ‚Çõ‚Çí ‚Ü™ Œπ‚Çõ·µ¢ ‚äï pSpec.MessageIdx

   
  hEq : ‚àÄ i, OStmtOut i = match embed i with
    | Sum.inl j => OStmtIn j
    | Sum.inr j => pSpec.Message j

instance [IsSingleRound pSpec] : Unique (pSpec.MessageIdx) where
  default := ‚ü®0, by admit /- proof elided -/
  ‚ü©
  uniq := fun ‚ü®i, hi‚ü© => by admit /- proof elided -/

instance : curve.IsShortNF :=

RingHomCompTriple in Mathlib.Algebra.Ring.CompTypeclasses

instance : AlgebraTower (BTField) where
  algebraMap := towerAlgebraMap
  commutes' := by admit /- proof elided -/

def quotient (f g : F[X][Y]) : Prop := ‚àÉ q : F[X][Y], g = q * f

def findIdxRev? (cond : Œ± ‚Üí Bool) (as : Array Œ±) : Option (Fin as.size) :=
  find ‚ü® as.size, Nat.lt_succ_self _ ‚ü©
where
  find : Fin (as.size + 1) ‚Üí Option (Fin as.size)
    | 0 => none
    | ‚ü® i+1, h ‚ü© =>
      if (cond as[i]) then
        some ‚ü® i, Nat.lt_of_succ_lt_succ h ‚ü©
      else
        find ‚ü® i, Nat.lt_of_succ_lt h ‚ü©

@[inline, reducible]
protected def id :
    Witness.Lens OuterStmtIn OuterStmtOut OuterWitIn OuterWitOut OuterWitIn OuterWitOut :=
  ‚ü®Prod.snd, fun _ => Prod.snd‚ü©

alias trivial := Witness.Lens.id

Fin.cast in Init.Data.Fin.Basic

structure TraceMapProperty (F : Type*) [Field F] (u : F) (k : ‚Ñï) : Prop where
  element_trace : ‚àë i ‚àà Finset.range (2 ^ k), u ^ (2 ^ i) = 1
  inverse_trace : ‚àë i ‚àà Finset.range (2 ^ k), (u‚Åª¬π) ^ (2 ^ i) = 1

def QuotientUniPoly (R : Type*) [Ring R] [BEq R] := Quotient (@instSetoidUniPoly R _)

def new (domainSeparator : DomainSeparator U H) (csrng : R) : FSProverState U H R :=
  let hashState := HashStateWithInstructions.new domainSeparator
  
  let rng : ProverPrivateRng R := { ds := (), csrng := csrng }
  { rng := rng, hashState := hashState, nargString := ByteArray.empty }

instance : CommGroup G := IsCyclic.commGroup

private def Fi (B : Finset (Fin n ‚Üí F)) (i : Fin n) (Œ± : F) : Finset (Fin n ‚Üí F) :=
  { x | x ‚àà B ‚àß x i = Œ± }

@[reducible]
def VectorIOP
    (Statement : Type) {Œπ‚Çõ : Type} (OStatement : Œπ‚Çõ ‚Üí Type) (Witness : Type)
    (vPSpec : ProtocolSpec.VectorSpec n) (A : Type)
    [‚àÄ i, OracleInterface (OStatement i)] :=
  OracleProof []‚Çí Statement OStatement Witness (vPSpec.toProtocolSpec A)

def soundness
    (langIn : Set (StmtIn √ó ‚àÄ i, OStmtIn i))
    (langOut : Set (StmtOut √ó ‚àÄ i, OStmtOut i))
    (verifier : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec)
    (soundnessError : ‚Ñù‚â•0) : Prop :=
  verifier.toVerifier.soundness init impl langIn langOut soundnessError

@[inline, specialize]
def smul (r : R) (p : UniPoly R) : UniPoly R :=
  .mk (Array.map (fun a => r * a) p)

def coeffsOfPolynomial (p : F[X]) : Fin deg ‚Üí F :=
  fun ‚ü®x, _‚ü© ‚Ü¶ p.coeff x

Monad in Init.Prelude

def ofFlatten {m n : ‚Ñï} (v : Vector Œ± (m * n)) : Matrix Œ± m n :=
  (Vector.finRange m).map (fun i => (v.extract (i.val * n) (i.val * n + n)).cast
    (by admit /- proof elided -/
      ))

Vector.tail in Init.Data.Vector.Basic

def duplexSpongeHybridOracle : OracleSpec pSpec.ChallengeIdx :=
  fun i =>
    ‚ü®StmtIn √ó ((j : pSpec.MessageIdx) ‚Üí (j.1 < i.1) ‚Üí Vector U (pSpec.L‚Çö·µ¢ j)),
    Vector U (pSpec.L·µ•·µ¢ i)‚ü©

alias ¬´ùíü_Œ£¬ª := duplexSpongeHybridOracle

noncomputable def extractMLP (i : Fin ‚Ñì) (f : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®i, by omega‚ü© ‚Üí L) :
    Option (L‚¶É‚â§ 1‚¶Ñ[X Fin (‚Ñì - i)]) :=

def toMessagesUpTo (transcript : Transcript k pSpec) : MessagesUpTo k pSpec :=
  fun ‚ü®i, _‚ü© => transcript i

instance : Initialize (DuplexSponge U C) (Vector UInt8 32) where
  new iv := {
    state := Initialize.new iv,
    absorbPos := 0,
    squeezePos := Fin.last SpongeSize.R
  }

œÜ in ToMathlib.Control.Monad.Relative

def stirRelation
    {F : Type} [Field F] [Fintype F] [DecidableEq F]
    {Œπ : Type} [Fintype Œπ] [Nonempty Œπ]
    (degree : ‚Ñï) (œÜ : Œπ ‚Ü™ F) (err : ‚Ñù)
    : Set ((Unit √ó ‚àÄ i, (OracleStatement Œπ F i)) √ó Unit) :=
  fun ‚ü®‚ü®_, oracle‚ü©, _‚ü© => Œ¥·µ£(oracle (), ReedSolomon.code œÜ degree) ‚â§ err

Fin.val in Init.Prelude

Polynomial.Monic in Mathlib.Algebra.Polynomial.Degree.Definitions

noncomputable def vanishingPoly (S : Finset F) : Polynomial F :=
  ‚àè s ‚àà S, (Polynomial.X - Polynomial.C s)

FiniteDimensional in Mathlib.LinearAlgebra.FiniteDimensional.Defs

@[inline]
def zsmul [SMul ‚Ñ§ R] (m : ‚Ñ§) (p : MlPolyEval R n) : MlPolyEval R n := p.map (fun a => m ‚Ä¢ a)

instance [VCVCompatible A] : ‚àÄ i, VCVCompatible ((vPSpec.toProtocolSpec A).Challenge i) :=
  fun _ => by admit /- proof elided -/

structure SpecialElementRelation {F_prev : Type*} [Field F_prev] (t1 : F_prev)
  {F_cur : Type*} [Field F_cur] (u : F_cur) [Algebra F_prev F_cur] : Prop where
    sum_inv_eq : u + u‚Åª¬π = algebraMap F_prev F_cur t1
    h_u_square : u^2 = u * (algebraMap F_prev F_cur t1) + 1

List.mapM' in Init.Data.List.Monadic

def relayKnowledgeStateFunction (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
    (relayOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        i hNCR).KnowledgeStateFunction init impl
      (relIn := foldStepRelOut (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i.succ)
      (extractor := relayRbrExtractor ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) where
  toFun := fun m ‚ü®stmtIn, oStmtIn‚ü© tr witMid =>
    relayKStateProp (mp:=mp) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (ùìë := ùìë) i hNCR stmtIn witMid oStmtIn
  toFun_empty := fun ‚ü®stmtIn, oStmtIn‚ü© witIn => by admit /- proof elided -/

def foldKnowledgeStateFunction (i : Fin ‚Ñì) :
    (foldOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i).KnowledgeStateFunction init impl
      (relIn := roundRelation (mp := mp) ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        (ùìë := ùìë) i.castSucc)
      (relOut := foldStepRelOut (mp := mp) ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        (ùìë := ùìë) i)
      (extractor := foldRbrExtractor (mp:=mp) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) where
  toFun := fun m ‚ü®stmt, oStmt‚ü© tr witMid =>
    foldKStateProp (mp:=mp) ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (i := i) (m := m) (tr := tr) (stmt := stmt) (witMid := witMid) (oStmt := oStmt)
  toFun_empty := fun _ _ => by admit /- proof elided -/

@[reducible]
def MlPolyEval (R : Type*) (n : ‚Ñï) := Vector R (2 ^ n) 

Fin.subNat in Init.Data.Fin.Basic

def lagrangeBasis (w : Vector R n) : Vector R (2 ^ n) :=
  Vector.ofFn (fun i => ‚àè j : Fin n, if (BitVec.ofFin i).getLsb j then w[j] else 1 - w[j])

@[reducible, simp] def OStmtIn : Unit ‚Üí Type := fun _ => R‚¶É‚â§ deg‚¶Ñ[X]

@[reducible]
def spec : OracleSpec Unit := fun _ => (Œ± √ó Œ±, Œ±)

@[inline]
def zero [Zero R] : MlPolyEval R n := Vector.replicate (2 ^ n) 0

private def Bi (B : Finset (Fin n ‚Üí F)) (i : Fin n) : Finset ((Fin n ‚Üí F) √ó (Fin n ‚Üí F)) :=
  { x | x ‚àà B √óÀ¢ B ‚àß x.1 i = x.2 i ‚àß x.1 ‚â† x.2 }

Ideal in Mathlib.RingTheory.Ideal.Defs

Vector.take in Init.Data.Vector.Basic

inductive PrattPartList : (p : ‚Ñï) ‚Üí (a : ZMod p) ‚Üí ‚Ñï ‚Üí Prop
  | prime : {p : ‚Ñï} ‚Üí {a : ZMod p} ‚Üí (n k nk : ‚Ñï) ‚Üí n.Prime ‚Üí
      a ^ ((p - 1) / n) ‚â† 1 ‚Üí n ^ k = nk ‚Üí PrattPartList p a nk
  | split : {p : ‚Ñï} ‚Üí {a : ZMod p} ‚Üí {n : ‚Ñï} ‚Üí (list : List ‚Ñï) ‚Üí
      (‚àÄ r ‚àà list, PrattPartList p a r) ‚Üí list.prod = n ‚Üí PrattPartList p a n

instance [DecidableEq Œπ] : Memory Œπ Œ± (‚àÄ i, Œ± i) where
  read m i := m i
  write m i v := Function.update m i v

Polynomial.erase in Mathlib.Algebra.Polynomial.Basic

structure ProverInit (PrvState : Type) where
  init : PrvState

@[inline]
def nsmul [SMul ‚Ñï R] (m : ‚Ñï) (p : MlPoly R n) : MlPoly R n := p.map (fun a => m ‚Ä¢ a)

noncomputable def D_X (rho : ‚Ñö) (n m : ‚Ñï) : ‚Ñù := (m + 1/2) * (Real.sqrt rho) * n

def bool (j : Fin numWires) : Gate ùì° numWires :=
  { qL := -1, qR := 0, qO := 0, qM := 1, qC := 0, a := j, b := j, c := j }

structure Distances (M : ‚Ñï) where
  Œ¥ : Fin (M + 1) ‚Üí ‚Ñù‚â•0
  l : Fin (M + 1) ‚Üí ‚Ñù‚â•0

@[reducible]
def permutationOracle (Œ± : Type*) : OracleSpec PermuteDir :=
  forwardPermutationOracle Œ± ++‚Çí backwardPermutationOracle Œ±

def vflatten {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (v : (i : Fin m) ‚Üí Fin (n i) ‚Üí Œ±) :
    Fin (vsum n) ‚Üí Œ± :=
  dflatten v

instance : SliceLT (ProtocolSpec n) ‚Ñï
    (fun _ stop => stop ‚â§ n)
    (fun _ stop _ => ProtocolSpec stop)
    where
  sliceLT := fun v stop h => take stop h v

def interleaveCode [Semiring F] [DecidableEq F] (C : Submodule F (n ‚Üí F)) (Œπ : Type*)
  : Submodule F ((Œπ √ó n) ‚Üí F) :=
  Submodule.span F {v | ‚àÄ i, ‚àÉ c ‚àà C, c = fun j => v (i, j)}

def generateSrs (n : ‚Ñï) (a : ZMod p) : Vector G‚ÇÅ (n + 1) √ó Vector G‚ÇÇ 2 :=
  (towerOfExponents g‚ÇÅ a n, towerOfExponents g‚ÇÇ a 1)

def FullData.EquivIndexFun {Œ± : Type} (s : Skeleton) :
    FullData Œ± s ‚âÉ (SkeletonNodeIndex s ‚Üí Œ±) where
  toFun := fun tree idx => tree.get idx
  invFun := fun f => FullData.ofFun s f
  left_inv := by admit /- proof elided -/

@[reducible, simp] def OStmtOut := fun _ : Fin 2 => OStatement

def Œ≥ (x‚ÇÄ : F) (R : F[X][X][Y]) (H : F[X][Y]) [œÜ : Fact (Irreducible H)] : PowerSeries (ùïÉ H) :=
  let subst (t : ‚Ñï) : ùïÉ H :=
    match t with
    | 0 => fieldToùïÉ (-x‚ÇÄ)
    | 1 => 1
    | _ => 0
  PowerSeries.subst (PowerSeries.mk subst) (PowerSeries.mk (Œ± x‚ÇÄ R H))

abbrev rdrop (m : ‚Ñï) (h : m ‚â§ n)
    (transcript : FullTranscript pSpec) : FullTranscript (pSpec.rdrop m h) :=
  Fin.rdrop m h transcript

Array.replicate in Init.Data.Array.Basic

def rootMultiplicity.{u} {F : Type u} [CommSemiring F] [DecidableEq F]
  (f : F[X][Y]) (x y : F) : Option ‚Ñï :=
  let X := (Polynomial.X : Polynomial F)
  rootMultiplicity‚ÇÄ (F := F) ((f.comp (Y + (C (C y)))).map (Polynomial.compRingHom (X + C x)))

def toNat (f : ValidChurchNat) : ‚Ñï :=
  ChurchNat.toNat f.1

algebraMap in Mathlib.Algebra.Algebra.Defs

def bivPolyHom {F : Type} [CommRing F] [IsDomain F] :
  Polynomial (F[X]) ‚Üí+* Polynomial (RatFunc F) := Polynomial.mapRingHom (univPolyHom)

noncomputable def towerRingHomForwardMap (k : ‚Ñï) : ConcreteBTField k ‚Üí BTField k :=

def commitKState (i : Fin ‚Ñì) (hCR : isCommitmentRound ‚Ñì œë i) :
    (commitOracleVerifier ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      i hCR).KnowledgeStateFunction init impl
      (relIn := foldStepRelOut (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i.succ)
      (extractor := commitRbrExtractor ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) where
  toFun := fun m ‚ü®stmtIn, oStmtIn‚ü© tr witMid =>
    commitKStateProp ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (i := i) (m := m) (stmtIn := stmtIn) (witMid := witMid) (oStmtIn := oStmtIn) (mp:=mp)
  toFun_empty := fun stmtIn witMid => by admit /- proof elided -/

@[inline] def succ (n : AssocNat) : AssocNat :=
  add n one

AddCommMonoid in Mathlib.Algebra.Group.Defs

Exists in Init.Core

def hflatten {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {Œ± : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí Sort*}
    (v : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí Œ± i j) : (k : Fin (vsum n)) ‚Üí Fin.vflatten Œ± k :=
  fflatten (F := id) v

def mulNat [Zero T] (a : Cayley T) : Nat ‚Üí Cayley T
  | 0        => zero
  | .succ k  => add (mulNat a k) a

def principalIdeal {F : Type} [Semiring F] (f : F) : Ideal F := Ideal.span {f}

@[inline, reducible]
def proj : OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i) ‚Üí InnerStmtIn √ó (‚àÄ i, InnerOStmtIn i) :=
  lens.toFunA

DecidableRel in Init.Prelude

Finsupp.linearCombination in Mathlib.LinearAlgebra.Finsupp.LinearCombination

List.ofFn in Init.Data.List.OfFn

OracleComp.uniformOfFintype in VCVio.OracleComp.Constructions.UniformSelect

def findSum (l : List Œ±) (j : Œ±) : Option Œ± := l.partialSum.find? (j < ¬∑)

def computableBasisExplicit (k : ‚Ñï) (i : Fin (2 ^ k)) : ConcreteBTField k :=
  (Finset.univ : Finset (Fin k)).prod fun j =>
    if Nat.getBit (n := i.val) (k := j.val) == 1 then
      concreteTowerAlgebraMap (j.val + 1) k (by admit /- proof elided -/
      ) (Z (j.val + 1))
    else
      1

@[simp]
def BTFieldCard (k : ‚Ñï) : Fintype.card (BTField k) = 2^(2^k)
  := (BinaryTowerAux k).2.fieldFintypeCard

def leq {Œ± : Type} (m n : ChurchNat Œ±) : ChurchBool Œ± :=
  isZero (ChurchNat.sub m n)

Nat.reduceBEq in Lean.Meta.Tactic.Simp.BuiltinSimprocs.Nat

@[reducible]
def GroupOpOracle : OracleSpec Unit := fun _ => (Œπ √ó Œπ √ó Œπ, Unit)

def intCast_ofNat {k : ‚Ñï} (n : ‚Ñï) : intCast (k:=k) (n : ‚Ñ§) = natCast n :=

abbrev BaseField := ZMod BASE_FIELD_CARD

instance {Œ± : Type} {s : Skeleton} :
    CoeFun (LeafData Œ± s) fun (_ : LeafData Œ± s) => SkeletonLeafIndex s ‚Üí Œ± where
  coe := fun tree idx => tree.get idx

def Option.doubleBind {Œ± Œ≤ Œ≥ : Type} (f : Œ± ‚Üí Œ≤ ‚Üí Option Œ≥)
    (x : Option Œ±) (y : Option Œ≤) : Option Œ≥ :=
  match x, y with
  | none, _ => none
  | _, none => none
  | some a, some b => f a b

def churchOr (p q : ChurchBool Œ±) : ChurchBool Œ± :=
  fun x y => p x (q x y)

def churchAnd (p q : ChurchBool Œ±) : ChurchBool Œ± :=
  fun x y => p (q x y) y

noncomputable def proximity_gap_johnson (rho : ‚Ñö) (m : ‚Ñï) : ‚Ñù :=
  (1 : ‚Ñù) - Real.sqrt rho - Real.sqrt rho / (2 * m)

Nat.cast in Init.Data.Cast

Sum.inl in Init.Core

class DecidableBlockDisagreement
  (i k : ‚Ñï) {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F}
  [DecidableEq F] [DecidableEq Œπ] [Smooth œÜ]
  (f : (indexPowT S œÜ i) ‚Üí F) (S' : Finset (indexPowT S œÜ i))
  (œÜ' : (indexPowT S œÜ i) ‚Ü™ F) where
  dec_inst :
    ‚àÄ z : indexPowT S œÜ k, ‚àÄ g : (indexPowT S œÜ i) ‚Üí F,
      Decidable (‚àÉ y : block i S' œÜ' z, f y.val ‚â† g y.val)

noncomputable def foldOracleReduction :
  OracleReduction []‚Çí
    (Statement F i.castSucc) (OracleStatement D x s i.castSucc) (Witness F s d i.castSucc.castSucc)
    (Statement F i.succ) (OracleStatement D x s i.succ) (Witness F s d i.succ.castSucc)
    (pSpec D x s i) where
  prover := foldProver D x s d i
  verifier := foldVerifier D x s i

HEq in Init.Prelude

def ConstraintSystem (ùì° : Type) (numWires numGates : ‚Ñï) := Fin numGates ‚Üí Gate ùì° numWires

Int in Init.Data.Int.Basic

def binding (scheme : Scheme oSpec Data Randomness Commitment pSpec)
    (bindingError : ‚Ñù‚â•0) : Prop :=
  ‚àÄ AuxState : Type,
  ‚àÄ adversary : BindingAdversary oSpec Data Commitment AuxState,
  ‚àÄ prover : Prover oSpec (Commitment √ó O.Query √ó O.Response) AuxState Bool Unit pSpec,
    False

def lintStyle : Cmd := `[Cli|
  ¬´lint-style¬ª VIA lintStyleCli; ["0.0.1"]
  "Run text-based style linters on every Lean file in Mathlib/, Archive/ and Counterexamples/.
  Print errors about any unexpected style errors to standard output."

  FLAGS:
    github;     "Print errors in a format suitable for github problem matchers\n\
                 otherwise, produce human-readable output"
    fix;        "Automatically fix the style error, if possible"
]

@[reducible, inline, specialize, simp]
def MessageIdx (vPSpec : VectorSpec n) := {i : Fin n // vPSpec.dir i = .P_to_V}

Nontrivial in Mathlib.Logic.Nontrivial.Defs

@[inline] def sub [Zero T] [ToNat T] (a b : Cayley T) : Cayley T :=
  subNat a ‚Üëb

def possibleDistsToCode (w : Œπ ‚Üí F) (C : Set (Œπ ‚Üí F)) (Œ¥f : (Œπ ‚Üí F) ‚Üí (Œπ ‚Üí F) ‚Üí Œ±) : Set Œ± :=
  {d : Œ± | ‚àÉ c ‚àà C, c ‚â† w ‚àß Œ¥f w c = d}

def relationAfterSendClaim :
    Set (((StmtAfterSendClaim R) √ó (‚àÄ i, OStmtAfterSendClaim R deg i)) √ó Unit) :=
  { ‚ü®‚ü®target, oStmt‚ü©, _‚ü© |
    ‚àë x ‚àà (univ.map D), (oStmt (Sum.inl ())).1.eval x = target
      ‚àß oStmt (Sum.inr ()) = oStmt (Sum.inl ()) }

Odd in Mathlib.Algebra.Ring.Parity

noncomputable def queryKnowledgeStateFunction {œÉ : Type} (init : ProbComp œÉ)
    (impl : QueryImpl []‚Çí (StateT œÉ ProbComp)) :
  (queryOracleVerifier ùîΩq Œ≤ (œë:=œë) Œ≥_repetitions).KnowledgeStateFunction init impl
  (relIn := finalSumcheckRelOut ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
  (relOut := acceptRejectOracleRel)
  (extractor := queryRbrExtractor ùîΩq Œ≤ (œë:=œë) Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)) where
  toFun := fun m ‚ü®stmt, oStmt‚ü© tr witMid =>
    queryKStateProp ùîΩq Œ≤ (œë:=œë) (Œ≥_repetitions:=Œ≥_repetitions)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (m:=m) (tr:=tr) (stmt:=stmt) (witMid:=witMid) (oStmt:=oStmt)
  toFun_empty := fun stmt witMid => by admit /- proof elided -/

noncomputable def towerEquiv (n : ‚Ñï) : TowerEquivResult n :=

instance {langIn : Set StmtIn} {langOut : Set StmtOut}
    {verifier : Verifier oSpec StmtIn StmtOut pSpec} :
    CoeFun (verifier.StateFunction init impl langIn langOut)
    (fun _ => (m : Fin (n + 1)) ‚Üí StmtIn ‚Üí Transcript m pSpec ‚Üí Prop) := ‚ü®fun f => f.toFun‚ü©

CommGroup in Mathlib.Algebra.Group.Defs

instance : ‚àÄ j, OracleInterface ((pSpecFinalSumcheckStep (L := L)).Message j) := fun j =>
  match j with
  | ‚ü®0, _‚ü© => OracleInterface.instDefault

@[inline]
def seqCompose {m : ‚Ñï}
    (Stmt : Fin (m + 1) ‚Üí Type) {Œπ‚Çõ : Fin (m + 1) ‚Üí Type} (OStmt : (i : Fin (m + 1)) ‚Üí Œπ‚Çõ i ‚Üí Type)
    (Wit : Fin (m + 1) ‚Üí Type) {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (P : (i : Fin m) ‚Üí
      OracleProver oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Wit i.castSucc)
        (Stmt i.succ) (OStmt i.succ) (Wit i.succ) (pSpec i)) :
    OracleProver oSpec (Stmt 0) (OStmt 0) (Wit 0) (Stmt (Fin.last m)) (OStmt (Fin.last m))
      (Wit (Fin.last m)) (seqCompose pSpec) :=
  Prover.seqCompose (fun i => Stmt i √ó (‚àÄ j, OStmt i j)) Wit P

@[simp]
def evalDomain (i : ‚Ñï) : Subgroup FÀ£ :=
  Subgroup.zpowers (DIsCyclicC.gen ^ (2 ^ i))

OrderDual.toDual in Mathlib.Order.Synonym

@[inline, reducible]
def Witness.InvLens (OuterStmtIn OuterWitIn OuterWitOut InnerWitIn InnerWitOut : Type)
    := PFunctor.Lens ((OuterStmtIn √ó OuterWitOut) X^ OuterWitIn)
                     (InnerWitOut X^ InnerWitIn)

@[simp]
def innerRelIn_Test : Set (InnerStmtIn_Test √ó Unit) :=
  setOf (fun ‚ü®‚ü®f, t‚ü©, _‚ü© => ‚àë x ‚àà {0, 1}, f.eval x = t)

Subgroup.zpowers in Mathlib.Algebra.Group.Subgroup.ZPowers.Basic

@[simp]
def outerRelIn_Test : Set (OuterStmtIn_Test √ó Unit) :=
  setOf (fun ‚ü®‚ü®p, q, t‚ü©, _‚ü© => ‚àë x ‚àà {0, 1}, (p * q).eval x = t)

instance {Œπ : Type} : OracleInterface (OracleStatement Œπ F ()) := OracleInterface.instFunction

MvPolynomial.coeff in Mathlib.Algebra.MvPolynomial.Basic

Ideal.span in Mathlib.RingTheory.Ideal.Span

instance instST‚ÇÇ [SelectableType R] : ‚àÄ i, SelectableType
    ((‚ü®!v[.P_to_V], !v[R‚¶É‚â§ deg‚¶Ñ[X]]‚ü© ++‚Çö !p[] ++‚Çö ‚ü®!v[.V_to_P], !v[R]‚ü©).Challenge i) :=
  instSelectableTypeChallengeAppend

noncomputable def polynomialFromNovelCoeffs (‚Ñì : ‚Ñï) (h_‚Ñì : ‚Ñì ‚â§ r)
  (a : Fin (2 ^ ‚Ñì) ‚Üí L) : L[X] := ‚àë j, C (a j) * (X‚±º ùîΩq Œ≤ ‚Ñì h_‚Ñì j)

@[inline] def mul [Zero T] [ToNat T] (a b : Cayley T) : Cayley T :=
  mulNat a ‚Üëb

Finset.Ici in Mathlib.Order.Interval.Finset.Defs

Polynomial.charP in Mathlib.Algebra.Polynomial.Coeff

instance [inst : VCVCompatible Chal] : ‚àÄ i, VCVCompatible (Challenge ‚ü®!v[.V_to_P], !v[Chal]‚ü© i)
  | ‚ü®0, _‚ü© => inst

@[reducible]
def GroupDecodeOracle : OracleSpec Unit := fun _ => (BitVec bitLength √ó Œπ, Unit)

instance {n : ‚Ñï} {Œ± : Fin n ‚Üí Type*} : Slice ((i : Fin n) ‚Üí Œ± i) ‚Ñï ‚Ñï
    (fun _ start stop => start ‚â§ stop ‚àß stop ‚â§ n)
    (fun _ start stop h =>
      (i : Fin (stop - start)) ‚Üí
        Œ± (castLE h.2 (Fin.cast (Nat.sub_add_cancel h.1) (i.addNat start))))
    where
  slice := fun v start stop h => Fin.drop start h.1 (Fin.take stop h.2 v)

def finUInt8Equiv : Fin (2 ^ 8) ‚âÉ UInt8 where
  toFun := fun i => UInt8.ofFin i
  invFun := fun u => u.toFin
  left_inv _ := rfl
  right_inv _ := rfl

@[reducible, simp]
def mapOStmt (oStmtIn : ‚àÄ i, OStmtIn i) : ‚àÄ i, OStmtOut i := fun i => (hEq i) ‚ñ∏ oStmtIn (embedIdx i)

Equiv.cast in Mathlib.Logic.Equiv.Defs

GaloisField.equivZmodP in Mathlib.FieldTheory.Finite.GaloisField

LinearMap.codRestrict in Mathlib.Algebra.Module.Submodule.LinearMap

@[inline, reducible]
def lift : OuterStmtIn √ó OuterWitIn ‚Üí InnerStmtOut √ó InnerWitOut ‚Üí OuterWitOut :=
  lens.toFunB

MvPolynomial.eval‚ÇÇHom in Mathlib.Algebra.MvPolynomial.Eval

instance instDCastPSigma : DCast ((a : Œ±) √ó' Œ≤ a) (fun a => Œ≥ a.1 a.2) where
  dcast hab c := dcast‚ÇÇ (by admit /- proof elided -/
  ) (by admit /- proof elided -/
  ) c
  dcast_id := by admit /- proof elided -/

@[reducible]
def OracleStatement : Fin (m + 1) ‚Üí Type :=
  fun _ => evalDomain D x 0 ‚Üí F

def finUInt32Equiv : Fin (2 ^ 32) ‚âÉ UInt32 where
  toFun := fun i => UInt32.ofFin i
  invFun := fun u => u.toFin
  left_inv _ := rfl
  right_inv _ := rfl

def ofMessagesChallenges (messages : Messages pSpec) (challenges : Challenges pSpec) :
    FullTranscript pSpec :=

def one {k : ‚Ñï} : ConcreteBTField k := 1#(2 ^ k)

instance instDecidableEqOption {Œ± : Type*} [DecidableEq Œ±] :
    DecidableEq (Option Œ±) := inferInstance

Finite in Mathlib.Data.Finite.Defs

Ideal.Quotient.mk in Mathlib.RingTheory.Ideal.Quotient.Defs

def fiberwiseDisagreementSet (i : Fin ‚Ñì) (steps : ‚Ñï) [NeZero steps]
    (h_i_add_steps : i.val + steps ‚â§ ‚Ñì) (f g : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate :=
      h_‚Ñì_add_R_rate) ‚ü®i, by admit /- proof elided -/
      ‚ü©) :
  Set ((sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®i.val + steps, by admit /- proof elided -/
  ‚ü©) :=
  
    
  {y | ‚àÉ x, iteratedQuotientMap ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := i)
    (k := steps) (h_bound := by admit /- proof elided -/
    ) x = y ‚àß f x ‚â† g x}

Finsupp.equivFunOnFinite in Mathlib.Data.Finsupp.Defs

def addCast {n : ‚Ñï} (m : ‚Ñï) (i : Fin n) : Fin (m + n) := ‚ü®i, Nat.lt_add_left m i.2‚ü©

def neqCols [DecidableEq F] (U V : Matrix Œπ Œπ' F) : Finset Œπ' :=
  {j | ‚àÉ i : Œπ, V i j ‚â† U i j}

@[reducible]
def coreInteractionOracleReduction :=
  OracleReduction.append (oSpec:=[]‚Çí)
    (Stmt‚ÇÅ := Statement (L := L) (‚Ñì:=‚Ñì) (SumcheckBaseContext L ‚Ñì) 0)
    (Stmt‚ÇÇ := Statement (L := L) (‚Ñì:=‚Ñì) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì))
    (Stmt‚ÇÉ := FinalSumcheckStatementOut (L:=L) (‚Ñì:=‚Ñì))
    (Wit‚ÇÅ := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) 0)
    (Wit‚ÇÇ := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) (Fin.last ‚Ñì))
    (Wit‚ÇÉ := Unit)
    (OStmt‚ÇÅ := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë 0)
    (OStmt‚ÇÇ := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (OStmt‚ÇÉ := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (pSpec‚ÇÅ := pSpecSumcheckFold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (pSpec‚ÇÇ := pSpecFinalSumcheckStep (L:=L))
    (R‚ÇÅ := sumcheckFoldOracleReduction ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë))
    (R‚ÇÇ := finalSumcheckOracleReduction ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))

def listDecodable (C : Code Œπ F) (r : ‚Ñù) (‚Ñì : ‚Ñù) : Prop :=
  ‚àÄ y : Œπ ‚Üí F, listOfCloseCodewordsRel C y r ‚â§ ‚Ñì

OracleSpec.OracleQuery in VCVio.OracleComp.OracleComp

Quotient.lift in Init.Core

noncomputable def proximityCondition
   (f : par‚Ñì ‚Üí Œπ ‚Üí F) (Œ¥ : ‚Ñù) (r : par‚Ñì ‚Üí F) (C : LinearCode Œπ F) : Prop :=
  Œ¥·µ£( (fun x => ‚àë j : par‚Ñì, (r j) * f j x) , C ) ‚â§ (Œ¥ : ‚Ñù)

instance instEquivalenceEquiv : Equivalence (equiv (R := R)) where
  refl := equiv_refl
  symm := equiv_symm
  trans := equiv_trans

def tileCoeffs (a : Fin (2 ^ ‚Ñì) ‚Üí L) : Fin (2^(‚Ñì + R_rate)) ‚Üí L :=
  fun v => a (Fin.mk (v.val % (2^‚Ñì)) (Nat.mod_lt v.val (pow_pos (zero_lt_two) ‚Ñì)))

@[inline]
def smul [Mul R] (r : R) (p : MlPolyEval R n) : MlPolyEval R n := p.map (fun a => r * a)

def U (i : Fin r) : Subspace ùîΩq L := Submodule.span ùîΩq (Œ≤ '' (Set.Ico 0 i))

@[inline, specialize]
def neg (p : UniPoly R) : UniPoly R := p.map (fun a => -a)

@[reducible]
def foldCommitOracleReduction (i : Fin ‚Ñì)
    (hCR : isCommitmentRound ‚Ñì œë i) :
  OracleReduction []‚Çí
    (StmtIn := Statement (L := L) Context i.castSucc)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) i.castSucc)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) i.succ)
    (pSpec := pSpecFoldCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) :=
  OracleReduction.append (oSpec:=[]‚Çí)
    (pSpec‚ÇÅ := pSpecFold (L:=L))
    (pSpec‚ÇÇ := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)
    (R‚ÇÅ := foldOracleReduction ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) i)
    (R‚ÇÇ := commitOracleReduction ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hCR)

instance : Zero (DuplexSponge U C) where
  zero := {
    state := 0,
    absorbPos := 0,
    squeezePos := 0
  }

@[simp]
abbrev Statement.AfterSecondSumcheck : Type :=
  SecondSumcheckChallenge R pp √ó Statement.AfterLinearCombination R pp

def codeOfLinearCode (Œ∫ : Type*) [Fintype Œ∫] (LC : LinearCode Œπ F) : InterleavedCode Œ∫ Œπ F :=
  { MF := matrixSubmoduleOfLinearCode Œ∫ LC, LC := LC }

OracleComp.liftComp in VCVio.OracleComp.Coercions.SubSpec

@[reducible, inline, specialize, simp]
def Message (pSpec : ProtocolSpec n) (i : MessageIdx pSpec) := pSpec.¬´Type¬ª i.val

instance : Fact (Nat.Prime baseFieldSize) := ‚ü®BaseField_is_prime‚ü©

Function.Injective in Init.Data.Function

def Option.doubleBind_v3 {Œ± Œ≤ Œ≥ : Type} (f : Œ± ‚Üí Œ≤ ‚Üí Option Œ≥)
    (x : Option Œ±) (y : Option Œ≤) : Option Œ≥ := do f (‚Üê x) (‚Üê y)

def millerRabinBases : List ‚Ñï :=
  [2, 325, 9375, 28178, 450775, 9780504, 1795265022]

def hintBytes (state : FSVerifierState U H) :
    Except DomainSeparatorMismatch (FSVerifierState U H √ó ByteArray) := do
  let newHashState ‚Üê state.hashState.hint

    
  if state.nargString.size < 4 then
    .error { message := "Insufficient transcript remaining for hint" }
  else
    
    let byte0 := state.nargString[0]!.toNat
    let byte1 := state.nargString[1]!.toNat
    let byte2 := state.nargString[2]!.toNat
    let byte3 := state.nargString[3]!.toNat
    let length := byte0 + (byte1 <<< 8) + (byte2 <<< 16) + (byte3 <<< 24)
    let rest := state.nargString.extract 4 state.nargString.size

    
    if rest.size < length then
      .error { message := s!"Insufficient transcript remaining, got {rest.size}, need {length}" }
    else
      
      let hint := rest.extract 0 length
      let remaining := rest.extract length rest.size
      .ok ({ hashState := newHashState, nargString := remaining }, hint)

def concat {k : Fin n} (messages : MessagesUpTo k.castSucc pSpec)
    (h : pSpec.dir k = .P_to_V) (msg : pSpec.Message ‚ü®k, h‚ü©) : MessagesUpTo k.succ pSpec :=
  fun ‚ü®i, h‚ü© => (concat' (pSpec := pSpec) (fun i hi => messages ‚ü®i, hi‚ü©) (fun _ => msg)) i h

instance [Inhabited C] [Permute C] : DuplexSpongeInterface U (DuplexSponge U C) where
  absorbUnchecked := fun (sponge, arr) => absorbUnchecked sponge arr
  squeezeUnchecked := fun (sponge, arr) => squeezeUnchecked sponge arr
  ratchetUnchecked := ratchetUnchecked

noncomputable def novelToMonomialCoeffs

  (‚Ñì : ‚Ñï) (h_‚Ñì : ‚Ñì ‚â§ r) (novel_coeffs : Fin (2 ^ ‚Ñì) ‚Üí L) : Fin (2^‚Ñì) ‚Üí L :=
  let A := changeOfBasisMatrix ùîΩq Œ≤ ‚Ñì h_‚Ñì
  Matrix.vecMul novel_coeffs A

@[reducible, simp]
def completeness (relation : Set (Statement √ó Witness)) (completenessError : ‚Ñù‚â•0)
    (proof : Proof oSpec Statement Witness pSpec) : Prop :=
  Reduction.completeness init impl relation acceptRejectRel proof completenessError

@[reducible, simp]
def perfectCompleteness
    (relation : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (oracleProof : OracleProof oSpec Statement OStatement Witness pSpec) :
      Prop :=
  OracleReduction.perfectCompleteness init impl relation acceptRejectOracleRel oracleProof

def intCast_negSucc {k : ‚Ñï} (n : ‚Ñï) : intCast (k:=k) (Int.negSucc n)
  = - (‚Üë(n + 1) : ConcreteBTField k) :=

def relHammingBallInterleavedCode [DecidableEq F] (U : Matrix Œ∫ Œπ F)
  (IC : MatrixSubmodule Œ∫ Œπ F) (r : ‚Ñù) :=
    {V | V ‚àà IC ‚àß relDistCodewords U V < r}

abbrev OracleFunction (i : Fin (‚Ñì + 1)) : Type _ := sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i, by admit /- proof elided -/
    ‚ü© ‚Üí L

Vector.foldl in Init.Data.Vector.Basic

def intCast {k : ‚Ñï} (n : ‚Ñ§) : ConcreteBTField k := if n % 2 = 0 then zero else one

@[reducible]
def combineMap : StmtIn √ó WitIn ‚Üí OracleComp oSpec (StmtOut √ó WitOut) :=
  fun ‚ü®stmt, wit‚ü© => do return (‚Üê mapStmt stmt, ‚Üê mapWit stmt wit)

IO.FS.readFile in Init.System.IO

def FinalSumcheckWit := fun (m : Fin (1 + 1)) =>
 match m with
 | ‚ü®0, _‚ü© => Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì)
 | ‚ü®1, _‚ü© => Unit

class DCast‚ÇÇ (Œ± : Sort*) (Œ≤ : Œ± ‚Üí Sort*) (Œ≥ : (a : Œ±) ‚Üí Œ≤ a ‚Üí Sort*) [DCast Œ± Œ≤] where
  dcast‚ÇÇ : ‚àÄ {a a' : Œ±} {b : Œ≤ a} {b' : Œ≤ a'},
    (ha : a = a') ‚Üí (dcast ha b = b') ‚Üí Œ≥ a b ‚Üí Œ≥ a' b'
  dcast‚ÇÇ_id : ‚àÄ {a : Œ±} {b : Œ≤ a}, dcast‚ÇÇ (Eq.refl a) dcast_eq = (id : Œ≥ a b ‚Üí Œ≥ a b)

Function.update in Mathlib.Logic.Function.Basic

def relation : Set (M √ó M √ó List (MemoryOp Œπ Œ±)) :=
  { ‚ü®startMem, finalMem, ops‚ü© | processMemoryOps ops startMem = some finalMem }

def singleHash (left : Œ±) (right : Œ±) : OracleComp (spec Œ±) Œ± := do
  let out ‚Üê query (spec := spec Œ±) () ‚ü®left, right‚ü©
  return out

def relayPrvState (i : Fin ‚Ñì) : Fin (0 + 1) ‚Üí Type := fun
  | ‚ü®0, _‚ü© => Statement (L := L) Context i.succ √ó
    (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j) √ó
    Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ

def toCoeffsVec (‚Ñì : Nat) : L‚¶É<2^‚Ñì‚¶Ñ[X] ‚Üí‚Çó[L] CoeffVecSpace L ‚Ñì where
  toFun := fun p => fun i => p.val.coeff i.val
  map_add' := fun p q => by admit /- proof elided -/

structure KnowledgeStateFunctionOneShot
    (langIn : Set StmtIn) (langOut : Set StmtOut)
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    where
  toFun : (m : Fin (n + 1)) ‚Üí StmtIn ‚Üí Transcript m pSpec ‚Üí Prop
   
  toFun_empty : ‚àÄ stmtIn, ¬¨ toFun 0 stmtIn default
   
  toFun_next : ‚àÄ m, pSpec.dir m = .P_to_V ‚Üí
    ‚àÄ stmt tr msg, ¬¨ toFun m.castSucc stmt tr ‚Üí ¬¨ toFun m.succ stmt (tr.concat msg)
   
  toFun_full : ‚àÄ stmt tr, ¬¨ toFun (.last n) stmt tr ‚Üí
    [(¬∑ ‚àà langOut) | do (simulateQ impl (verifier.run stmt tr)).run' (‚Üê init)] = 0

Finset.filterMap in Mathlib.Data.Finset.Image

Polynomial.degreeLTEquiv in Mathlib.RingTheory.Polynomial.Basic

Or in Init.Prelude

def mapOStmtOutRelayStep (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j) :
    ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.succ j := fun j => by admit /- proof elided -/

def equivFin2 : Direction ‚âÉ Fin 2 where
  toFun := fun dir => match dir with | .V_to_P => ‚ü®0, by admit /- proof elided -/
  ‚ü© | .P_to_V => ‚ü®1, by admit /- proof elided -/
  ‚ü©
  invFun := fun n => match n with | ‚ü®0, _‚ü© => .V_to_P | ‚ü®1, _‚ü© => .P_to_V
  left_inv := fun dir => match dir with | .P_to_V => rfl | .V_to_P => rfl
  right_inv := fun n => match n with | ‚ü®0, _‚ü© => rfl | ‚ü®1, _‚ü© => rfl

@[inline, reducible]
protected def id :
    Witness.InvLens OuterStmtIn OuterWitIn OuterWitOut OuterWitIn OuterWitOut :=
  ‚ü®Prod.snd, fun _ => id‚ü©

alias trivial := Witness.InvLens.id

def snoc_oracle {i : Fin ‚Ñì}
    (oStmtIn : ‚àÄ j : Fin (toOutCodewordsCount ‚Ñì œë i.castSucc),
      OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j)
    (newOracleFn : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ) :
    ‚àÄ j : Fin (toOutCodewordsCount ‚Ñì œë i.succ),
      OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.succ j := fun j =>
  have h_succ_val: i.succ.val = i.val + 1 := rfl
  if hj: j.val < (toOutCodewordsCount ‚Ñì œë i.castSucc) then
    oStmtIn ‚ü®j, by admit /- proof elided -/
    ‚ü©
  else 
    
    if hi: isCommitmentRound ‚Ñì œë i then
      
      
      have h_count_succ : toOutCodewordsCount ‚Ñì œë i.succ =
        toOutCodewordsCount ‚Ñì œë i.castSucc + 1 := by admit /- proof elided -/

def StateRestoration.Soundness (oSpec : OracleSpec Œπ) (StmtIn : Type)
    {n : ‚Ñï} (pSpec : ProtocolSpec n) :=
  OracleComp (oSpec ++‚Çí (srChallengeOracle StmtIn pSpec)) (StmtIn √ó pSpec.Messages)

def peval (f : œÉ ‚Üí œÉ‚ÇÅ ‚äï œÉ‚ÇÇ) (x : œÉ‚ÇÅ ‚Üí R) : MvPolynomial œÉ R ‚Üí+* MvPolynomial œÉ‚ÇÇ R :=
  eval‚ÇÇHom C (Sum.elim (fun i => C (x i)) X ‚àò f)

abbrev CNat (n : ‚Ñï) : Type := (CayleyTower n).1

def divNat [Zero T] [DecidableEq T] [ToNat T]
    (dividend divisor : Cayley T) : Nat ‚Üí Cayley T
  | 0        => zero  
  | .succ fuel =>
    
    if (‚Üëdivisor : Nat) = 0 then
      zero
    else
      
      if (‚Üëdivisor : Nat) ‚â§ (‚Üëdividend : Nat) then
        
        add one (divNat (sub dividend divisor) divisor fuel)
      else
        zero

noncomputable instance : Algebra Left (Left ‚äó[K] Right) := Algebra.TensorProduct.leftAlgebra

def pow (S : Finset Œπ) (œÜ : Œπ ‚Ü™ F) (k : ‚Ñï) : indexPow S œÜ k ‚Ü™ F :=
    Function.Embedding.subtype fun y => y ‚àà indexPow S œÜ k

def finalSumcheckKnowledgeError (m : pSpecFinalSumcheckStep (L := L).ChallengeIdx) :
  ‚Ñù‚â•0 :=
  match m with
  | ‚ü®0, h0‚ü© => nomatch h0

@[inline, specialize]
def oracleVerifier : OracleVerifier oSpec
    Unit (fun _ : Fin 2 => OStatement)
    (Query OStatement) (fun _ : Fin 2 => OStatement) (pSpec OStatement) where

  verify := fun _ chal => do
    let q : Query OStatement := chal ‚ü®0, rfl‚ü©
    pure q

  embed := Function.Embedding.inl

  hEq := by admit /- proof elided -/

instance : ‚àÄ i, SelectableType ((pSpecCoreInteraction ùîΩq Œ≤ (œë:=œë)
  (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).Challenge i) := instSelectableTypeChallengeAppend

CommGroupWithZero in Mathlib.Algebra.GroupWithZero.Defs

Lean.Expr in Lean.Expr

@[inline, specialize, simp]
def verifier : Verifier oSpec Statement Statement !p[] := Verifier.id

PowerBasis in Mathlib.RingTheory.PowerBasis

abbrev Field := ZMod fieldSize

Matrix.add in Mathlib.LinearAlgebra.Matrix.Defs

@[inline, reducible]
def toContext :
    Context.Lens (OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i)) (OuterStmtOut √ó (‚àÄ i, OuterOStmtOut i))
                (InnerStmtIn √ó (‚àÄ i, InnerOStmtIn i)) (InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i))
                OuterWitIn OuterWitOut InnerWitIn InnerWitOut :=
  ‚ü®lens.stmt, lens.wit‚ü©

Equiv.sumComm in Mathlib.Logic.Equiv.Sum

Algebra.TensorProduct.includeRight in Mathlib.RingTheory.TensorProduct.Basic

structure PublicParams where
  ‚Ñì_m : ‚Ñï
  ‚Ñì_n : ‚Ñï
  ‚Ñì_w : ‚Ñï
  ‚Ñì_w_le_‚Ñì_n : ‚Ñì_w ‚â§ ‚Ñì_n := by admit /- proof elided -/

structure BinaryTowerResult (F : Type _) (k : ‚Ñï) where
  vec : (List.Vector F (k + 1))
  instField : (Field F)
  instFintype : Fintype F
  specialElement : F
  specialElementNeZero : NeZero specialElement
  firstElementOfVecIsSpecialElement [Inhabited F] : vec.1.headI = specialElement
  instIrreduciblePoly : (Irreducible (p := (definingPoly specialElement)))
  sumZeroIffEq : ‚àÄ (x y : F), x + y = 0 ‚Üî x = y
  fieldFintypeCard : Fintype.card F = 2^(2^k)
  traceMapEvalAtRootsIs1 : TraceMapProperty F specialElement k

@[inline] def min [Zero T] [ToNat T] (a b : Cayley T) : Cayley T :=
  if (a : Nat) ‚â§ (b : Nat) then a else b

instance {k : Fin 1} : Unique (Transcript k (default : ProtocolSpec 0)) where
  default := fun i => ()
  uniq := by admit /- proof elided -/

@[reducible, simp]
def oraclePSpec : ProtocolSpec 1 := ‚ü®!v[.P_to_V], !v[Witness]‚ü©

instance : Unique (MessagesUpTo 0 pSpec) where
  default := fun ‚ü®i, _‚ü© => Fin.elim0 i
  uniq := fun T => by admit /- proof elided -/

def domainComplement (œÜ : Œπ ‚Ü™ F) : Finset F :=
  Finset.univ \ Finset.image œÜ.toFun Finset.univ

def ri (dstar : ‚Ñï) (degs : Fin m ‚Üí ‚Ñï) (r : F) (i : Fin m) : F :=
          match i.1 with
          | 0 => 1
          | .succ i' =>
            let exp := i' + ‚àë j < i, (dstar - degs j)
            r ^ exp

MonoidHom in Mathlib.Algebra.Group.Hom.Defs

noncomputable def additiveNTT (a : Fin (2 ^ ‚Ñì) ‚Üí L) : Fin (2^(‚Ñì + R_rate)) ‚Üí L :=
  let b: Fin (2^(‚Ñì + R_rate)) ‚Üí L := tileCoeffs a 
  Fin.foldl (n:=‚Ñì) (f:= fun current_b i  =>
    NTTStage ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®‚Ñì - 1 - i, by admit /- proof elided -/
    ‚ü©) current_b
  ) (init:=b)

abbrev PermuteDir := Unit ‚äï Unit

def knowledgeSoundness (relIn : Set (StmtIn √ó WitIn)) (relOut : Set (StmtOut √ó WitOut))
    (verifier : Verifier oSpec StmtIn StmtOut pSpec) (knowledgeError : ‚Ñù‚â•0) : Prop :=
  ‚àÉ extractor : Extractor.Straightline oSpec StmtIn WitIn WitOut pSpec,
  ‚àÄ stmtIn : StmtIn,
  ‚àÄ witIn : WitIn,
  ‚àÄ prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec,
    letI reduction := Reduction.mk prover verifier
    [fun ‚ü®stmtIn, witIn, stmtOut, witOut‚ü© =>
      (stmtIn, witIn) ‚àâ relIn ‚àß (stmtOut, witOut) ‚àà relOut
    | do
      let s ‚Üê init
      (simulateQ (impl ++‚Çõ‚Çí challengeQueryImpl : QueryImpl _ (StateT œÉ ProbComp))
        <| do
      let ‚ü®‚ü®‚ü®transcript, ‚ü®_, witOut‚ü©‚ü©, stmtOut‚ü©, proveQueryLog, verifyQueryLog‚ü© ‚Üê
        reduction.runWithLog stmtIn witIn
      let extractedWitIn ‚Üê
        liftComp (extractor stmtIn witOut transcript proveQueryLog.fst verifyQueryLog) _
      return (stmtIn, extractedWitIn, stmtOut, witOut)).run' s] ‚â§ knowledgeError

instance [AddCommMonoid R] : AddCommMonoid (MlPoly R n) where
  add := add
  add_assoc a b c := by admit /- proof elided -/

noncomputable def errorBound (Œ¥ : ‚Ñù‚â•0) (deg : ‚Ñï) (domain : Œπ ‚Ü™ F) : ‚Ñù‚â•0 :=
  letI œÅ : ‚Ñù‚â•0 := œÅ (ReedSolomon.code domain deg)
  if Œ¥ ‚àà Set.Ioc 0 ((1 - œÅ)/2)
  then Fintype.card Œπ / Fintype.card F
  else if Œ¥ ‚àà Set.Ioo ((1 - œÅ)/2) (1 - œÅ.sqrt)
       then letI m := min (1 - œÅ.sqrt - Œ¥) (œÅ.sqrt / 20)
            ‚ü®(deg ^ 2 : ‚Ñù‚â•0) / ((2 * m) ^ 7 * (Fintype.card F : ‚Ñù)), by admit /- proof elided -/
            ‚ü©
       else 0

def absorbUnchecked [Permute C] (sponge : DuplexSponge U C) (arr : Array U) : DuplexSponge U C :=
  simulateQ' forwardPermutationOracleImpl (absorbFast sponge arr) (by admit /- proof elided -/
  )

def getPutativeRoot {s} (idx : BinaryTree.SkeletonLeafIndex s) (leafValue : Œ±)
    (proof : List Œ±) : OracleComp (spec Œ±) Œ± :=
  match proof with
  | [] => return leafValue 
  | siblingBelowRootHash :: restProof => do
    match idx with
    | BinaryTree.SkeletonLeafIndex.ofLeaf =>
      
      
      
      return leafValue
    | BinaryTree.SkeletonLeafIndex.ofLeft idxLeft =>
      
      let ancestorBelowRootHash ‚Üê getPutativeRoot idxLeft leafValue restProof
      singleHash ancestorBelowRootHash siblingBelowRootHash
    | BinaryTree.SkeletonLeafIndex.ofRight idxRight =>
      
      let ancestorBelowRootHash ‚Üê getPutativeRoot idxRight leafValue restProof
      singleHash siblingBelowRootHash ancestorBelowRootHash

Mathlib.Linter.TextBased.ErrorFormat in Mathlib.Tactic.Linter.TextBased

class VerifierFirst (pSpec : ProtocolSpec n) [NeZero n] where
  verifier_first' : pSpec.dir 0 = .V_to_P

@[ext]
structure Verifier {Œπ : Type} (oSpec : OracleSpec Œπ)
    (StmtIn StmtOut : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n) where
  verify : StmtIn ‚Üí FullTranscript pSpec ‚Üí OracleComp oSpec StmtOut

noncomputable def monomialToNovelCoeffs

  (‚Ñì : ‚Ñï) (h_‚Ñì : ‚Ñì ‚â§ r) (monomial_coeffs : Fin (2 ^ ‚Ñì) ‚Üí L) : Fin (2^‚Ñì) ‚Üí L :=
  let A := changeOfBasisMatrix ùîΩq Œ≤ ‚Ñì h_‚Ñì
  
  
  Matrix.vecMul monomial_coeffs A‚Åª¬π

UInt8.ofFin in Init.Data.UInt.Basic

def numberOfClosePts (u v : Œπ ‚Üí F) (deg : ‚Ñï) (Œ± : Œπ ‚Ü™ F) (e : ‚Ñï) : ‚Ñï :=
  Fintype.card (closePtsOnAffineLine u v deg Œ± e)

def BTField.isScalarTower_succ_right (l r : ‚Ñï) (h_le : l ‚â§ r) :=
  instAlgebraTowerNatBTField.toIsScalarTower (i:=l) (j:=r) (k:=r+1)
  (h1:=by admit /- proof elided -/
  ) (h2:=by admit /- proof elided -/
  )

inductive LeafData (Œ± : Type) : Skeleton ‚Üí Type
  | leaf (value : Œ±) : LeafData Œ± Skeleton.leaf
  | internal {left right} (leftData : LeafData Œ± left) (rightData : LeafData Œ± right) :
      LeafData Œ± (Skeleton.internal left right)
  deriving Repr

def oracleReduction.randomQuery : OracleReduction oSpec
    (StmtAfterCheckClaim R) (OStmtAfterCheckClaim R deg) Unit
    (StmtAfterRandomQuery R) (OStmtAfterRandomQuery R deg) Unit ‚ü®!v[.V_to_P], !v[R]‚ü© :=
  sorry

@[inline, specialize]
def run (stmt : StmtIn) (wit : WitIn)
    (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí) (FullTranscript pSpec √ó StmtOut √ó WitOut) := do
  let ‚ü®transcript, state‚ü© ‚Üê prover.runToRound (Fin.last n) stmt wit
  return ‚ü®transcript, ‚Üê prover.output state‚ü©

noncomputable def towerRingEquiv0 : BTField 0 ‚âÉ+* ConcreteBTField 0 :=

@[reducible, simp]
def perfectCompleteness (relation : Set (Statement √ó Witness))
    (proof : Proof oSpec Statement Witness pSpec) : Prop :=
  Reduction.perfectCompleteness init impl relation acceptRejectRel proof

def rightpad {m : ‚Ñï} {Œ± : Sort*} (n : ‚Ñï) (a : Œ±) (v : Fin m ‚Üí Œ±) : Fin n ‚Üí Œ± :=
  fun i => if h : i < m then v ‚ü®i, h‚ü© else a

@[simps!]
def MessageIdx.sumEquiv :
    MessageIdx pSpec‚ÇÅ ‚äï MessageIdx pSpec‚ÇÇ ‚âÉ MessageIdx (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ) where
  toFun := Sum.elim (MessageIdx.inl) (MessageIdx.inr)
  invFun := fun ‚ü®i, h‚ü© => by admit /- proof elided -/

BitVec in Init.Prelude

Nat.gcd in Init.Data.Nat.Gcd

def JohnsonDenominator (B : Finset (Fin n ‚Üí F)) (v : Fin n ‚Üí F) : ‚Ñö :=
  let e := e B v
  let d := d B
  let q : ‚Ñö := Fintype.card F
  let frac := q / (q - 1)
  (1- frac * e/n) ^ 2 - (1 - frac * d/n)

Set.toFinset in Mathlib.Data.Fintype.Sets

noncomputable def queryOracleProof : OracleProof
    (oSpec := []‚Çí)
    (Statement := FinalSumcheckStatementOut (L:=L) (‚Ñì:=‚Ñì))
    (OStatement := OracleStatement ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (
    Fin.last ‚Ñì))
    (Witness := Unit)
    (pSpec := pSpecQuery ùîΩq Œ≤ Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)) :=
  queryOracleReduction ùîΩq Œ≤ (œë:=œë) Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)

hammingNorm in Mathlib.InformationTheory.Hamming

instance irreducible_quadratic_defining_poly_of_traceMap_eq_1
  {F : Type*} [Field F] [Fintype F] [CharP F 2] (s : F) [NeZero s] (k : ‚Ñï)
  (trace_map_prop : TraceMapProperty F s k)
  (fintypeCard : Fintype.card F = 2 ^ (2 ^ k))
  : Irreducible (definingPoly s) :=

def redundantQuery (log : QueryLog spec) (i : Œπ) (q : spec.domain i) (r : spec.range i) : Prop :=
  (log.getQ i).count (q, r) > 1

def inputRelation : Set (((StmtIn R) √ó (‚àÄ i, OStmtIn R deg i)) √ó Unit) :=
  { ‚ü®‚ü®target, oStmt‚ü©, _‚ü© | ‚àë x ‚àà (univ.map D), (oStmt ()).1.eval x = target }

def partition (cs : ConstraintSystem ùì° numWires numGates) :
    Fin numWires ‚Üí Finset (Fin (3 * numGates)) :=
  
  
  
  
  fun i => Finset.map (Equiv.toEmbedding finProdFinEquiv)
    (Finset.filter (fun j => if j.1 = 0 then (cs j.2).a = i
      else if j.1 = 1 then (cs j.2).b = i else (cs j.2).c = i)
    (Finset.univ : Finset (Fin 3 √ó Fin numGates)))

instance instST‚ÇÅ : ‚àÄ i, SelectableType ((‚ü®!v[.P_to_V], !v[R‚¶É‚â§ deg‚¶Ñ[X]]‚ü© ++‚Çö !p[]).Challenge i) :=
  instSelectableTypeChallengeAppend

Set.finrank in Mathlib.LinearAlgebra.Dimension.Constructions

instance Vector.instFintype {Œ± : Type*} {n : ‚Ñï} [VCVCompatible Œ±] : Fintype (Vector Œ± n) :=
  Fintype.ofEquiv _ (Equiv.rootVectorEquivFin).symm

class Serialize (Œ± : Type u) (Œ≤ : Type v) where
  serialize : Œ± ‚Üí Œ≤

@[reducible, inline, specialize]
def MessageUpTo (k : Fin (n + 1)) (pSpec : ProtocolSpec n) (i : pSpec.MessageIdxUpTo k) :=
  (pSpec‚ü¶:k.val‚üß).Message i

def binaryTowerModule {l r : ‚Ñï} (h_le : l ‚â§ r) :
    Module (ConcreteBTField l) (ConcreteBTField r) :=
  (ConcreteBTFieldAlgebra (h_le:=h_le)).toModule

def FullData.toInternalData {Œ± : Type} {s : Skeleton}
    (tree : FullData Œ± s) : InternalData Œ± s :=
  match tree with
  | FullData.leaf _ => InternalData.leaf
  | FullData.internal value left right =>
    InternalData.internal value (left.toInternalData) (right.toInternalData)

def degreeX (f : F[X][Y]) : ‚Ñï := f.support.sup (fun n => (f.coeff n).natDegree)

@[reducible]
def FinalOracleStatement : Fin (k + 2) ‚Üí Type :=
  fun j =>
    if j.1 = k + 1
    then (Unit ‚Üí F[X])
    else (evalDomain D x (‚àë j' ‚àà finRangeTo j.1, s j') ‚Üí F)

Finset.biUnion in Mathlib.Data.Finset.Union

Fin.castSucc in Init.Data.Fin.Basic

instance : Mul AssocNat where
  mul := mul

@[ext]
class OracleInterface (Message : Type u) where
  Query : Type v
  Response : Type w
  answer : Message ‚Üí Query ‚Üí Response

def foldKnowledgeError (i : Fin ‚Ñì) (_ : (pSpecFold (L := L)).ChallengeIdx) : ‚Ñù‚â•0 :=
  let err_SC := (1 : ‚Ñù‚â•0) / (Fintype.card L)
  
  let err_BE := if hi : œë ‚à£ (i.val + 1) then
    
    œë * (Fintype.card ((sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate)
      ‚ü®i.val + 1, by admit /- proof elided -/
        ‚ü©) : ‚Ñù‚â•0) / (Fintype.card L)
  else 0
  err_SC + err_BE

BitVec.extractLsb in Init.Data.BitVec.Basic

Polynomial.compRingHom in Mathlib.Algebra.Polynomial.Eval.Defs

def binaryAlgebraTower {l r : ‚Ñï} (h_le : l ‚â§ r) : Algebra (BTField l) (BTField r) :=

instance [NeZero k] {f : Fin k ‚Üí Œπ ‚Üí F} : Nonempty (Finset.univ.image f) :=

class VerifierLast (pSpec : ProtocolSpec n) [NeZero n] where
  verifier_last' : pSpec.dir ‚ü®n - 1, by admit /- proof elided -/
  ‚ü© = .V_to_P

@[reducible] def Proof {Œπ : Type} (oSpec : OracleSpec Œπ)
    (Statement Witness : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n) :=
  Reduction oSpec Statement Witness Bool Unit pSpec

noncomputable instance {v : Œπ ‚Üí F} {s : AffineSubspace F (Œπ ‚Üí F)} [inst : Nonempty s] :
    Nonempty (v +·µ• s) :=

instance : SubSpec [pSpec‚ÇÇ.Challenge]‚Çí ([(pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).Challenge]‚Çí) where
  monadLift | query i t => instSubSpecOfProtocolSpecAppendChallenge.monadLift (query (Sum.inr i) t)

Lean.Elab.WF.paramLet in Lean.Elab.PreDefinition.WF.Preprocess

Ne in Init.Core

def drop {n : ‚Ñï} {Œ± : Fin n ‚Üí Sort*} (m : ‚Ñï) (h : m ‚â§ n) (v : (i : Fin n) ‚Üí Œ± i) :
    (i : Fin (n - m)) ‚Üí Œ± (Fin.cast (Nat.sub_add_cancel h) (addNat i m)) :=
  fun i ‚Ü¶ v (Fin.cast (Nat.sub_add_cancel h) (addNat i m))

def rho (n : ‚Ñï) : Option ‚Ñï := Id.run do
  for st in [2:n] do
    for c in [1:n] do
      if let some d := rho' n st c then
        return some d

  return none

instance : ‚àÄ j, OracleInterface ((pSpecLastBlock (L:=L) (œë:=œë)).Message j) :=
  instOracleInterfaceMessageSeqCompose

instance : _root_.Field Field := ZMod.instField fieldSize

def cons {Œ±} {n : ‚Ñï} (hd : Œ±) (tl : Vector Œ± n) : Vector Œ± (n + 1) :=
  tl.insertIdx 0 hd

instance : MvPolynomialLike œÉ R (MvPolynomial œÉ R) where
  X := MvPolynomial.X
  eval‚ÇÇ := fun f g => eval‚ÇÇHom f g
  eval‚ÇÇ_C := fun f g r => by admit /- proof elided -/

def verifyProof {Œ±} [DecidableEq Œ±] {s}
    (idx : BinaryTree.SkeletonLeafIndex s) (leafValue : Œ±) (rootValue : Œ±)
    (proof : List Œ±) : OracleComp (spec Œ±) Unit := do
  let putative_root ‚Üê getPutativeRoot idx leafValue proof
  guard (putative_root = rootValue)

@[reducible]
def verifier : Verifier oSpec (StatementRound R n 0 √ó (‚àÄ i, OracleStatement R n deg i))
    (StatementRound R n (.last n) √ó (‚àÄ i, OracleStatement R n deg i)) (pSpec R deg n) :=
  Verifier.seqCompose (oSpec := oSpec)
    (Stmt := fun i => StatementRound R n i √ó (‚àÄ j, OracleStatement R n deg j))
    (pSpec := fun _ => SingleRound.pSpec R deg)
    (SingleRound.verifier R n deg D oSpec)

@[ext]
structure VectorSpec (n : ‚Ñï) where
  dir : Fin n ‚Üí Direction
  length : Fin n ‚Üí Nat

@[app_unexpander Fin.hcons]
def hconsUnexpander : Lean.PrettyPrinter.Unexpander
  | `($_ $term !h[$term2, $terms,*]) => `(!h[$term, $term2, $terms,*])
  | `($_ $term !h[$term2]) => `(!h[$term, $term2])
  | `($_ $term !h[]) => `(!h[$term])
  | _ => throw ()

Set.Finite in Mathlib.Data.Finite.Defs

@[reducible, inline, specialize, simp]
def srChallengeQueryImpl' {Statement : Type} {pSpec : ProtocolSpec n}
    [‚àÄ i, SelectableType (pSpec.Challenge i)] :
    QueryImpl (srChallengeOracle Statement pSpec)
      (StateT (srChallengeOracle Statement pSpec).FunctionType ProbComp)
    where
  impl | query i t => fun f => pure (f i t, f)

alias fsChallengeQueryImpl' := srChallengeQueryImpl'

instance : NatCast (UniPoly R) := ‚ü®fun n => UniPoly.C (n : R)‚ü©

def concreteTowerAlgebraMap (l r : ‚Ñï) (h_le : l ‚â§ r) :
    ConcreteBTField l ‚Üí+* ConcreteBTField r :=

structure RoundByRound
    (oSpec : OracleSpec Œπ) (StmtIn WitIn WitOut : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n)
    (WitMid : Fin (n + 1) ‚Üí Type) where
   
  eqIn : WitMid 0 = WitIn
   
  extractMid : (m : Fin n) ‚Üí StmtIn ‚Üí Transcript m.succ pSpec ‚Üí WitMid m.succ ‚Üí WitMid m.castSucc
   
  extractOut : StmtIn ‚Üí FullTranscript pSpec ‚Üí WitOut ‚Üí WitMid (.last n)

def Prover.append (P‚ÇÅ : Prover oSpec Stmt‚ÇÅ Wit‚ÇÅ Stmt‚ÇÇ Wit‚ÇÇ pSpec‚ÇÅ)
    (P‚ÇÇ : Prover oSpec Stmt‚ÇÇ Wit‚ÇÇ Stmt‚ÇÉ Wit‚ÇÉ pSpec‚ÇÇ) :
      Prover oSpec Stmt‚ÇÅ Wit‚ÇÅ Stmt‚ÇÉ Wit‚ÇÉ (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ) where

   
  PrvState := Fin.append (m := m + 1) P‚ÇÅ.PrvState (Fin.tail P‚ÇÇ.PrvState) ‚àò Fin.cast (by admit /- proof elided -/
  )

   
  input := fun ctxIn => by admit /- proof elided -/

protected def cast (R : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec‚ÇÅ) :
    Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec‚ÇÇ where
  prover := R.prover.cast hn hSpec
  verifier := R.verifier.cast hn hSpec

@[reducible]
def ROspec (Œ± Œ≤ Œ≥ : Type) : OracleSpec Unit := fun _ => (Œ± √ó Œ≤, Œ≥)

instance instDCastSigma {Œ± : Type*} {Œ≤ : Œ± ‚Üí Type*} {Œ≥ : (a : Œ±) ‚Üí Œ≤ a ‚Üí Type*}
    [DCast Œ± Œ≤] [DCast‚ÇÇ Œ± Œ≤ Œ≥] : DCast ((a : Œ±) √ó Œ≤ a) (fun a => Œ≥ a.1 a.2) where
  dcast hab c := dcast‚ÇÇ (by admit /- proof elided -/
  ) (by admit /- proof elided -/
  ) c
  dcast_id := by admit /- proof elided -/

Group in Mathlib.Algebra.Group.Defs

protected def OracleProver.id :
    OracleProver oSpec Statement OStatement Witness Statement OStatement Witness !p[] :=
  Prover.id

noncomputable def sDomain_basis (i : Fin r) (h_i : i < ‚Ñì + R_rate) :
    Basis (Fin (‚Ñì + R_rate - i)) ùîΩq (
      sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i) :=

def natWeightedDegree.{u} {F : Type u} [Semiring F] (f : F[X][Y]) (u v : ‚Ñï) : ‚Ñï :=
  f.support.sup (fun m => u * (f.coeff m).natDegree + v * m)

def powAlgHom :
  MvPolynomial (Fin m) F ‚Üí‚Çê[F] Polynomial F :=
   aeval fun j => Polynomial.X ^ (2 ^ (j : ‚Ñï))

def indexPow (S : Finset Œπ) (œÜ : Œπ ‚Ü™ F) (k : ‚Ñï) : Finset F :=
  S.image (fun x => (œÜ x) ^ k)

def someValues : HList' (fun x => x) someTypes :=
  HList'.cons 1 (HList'.cons "bad" (HList'.cons 3 HList'.nil))

noncomputable def coeffs_of_close_proximity (œâs : Fin n ‚Ü™ F) (Œ¥ : ‚Ñö) (u‚ÇÄ u‚ÇÅ : Fin n ‚Üí F)
  : Finset F := Set.toFinset { z | ‚àÉ v : ReedSolomon.code œâs (k + 1), Œ¥·µ£(u‚ÇÄ + z ‚Ä¢ u‚ÇÅ, v) ‚â§ Œ¥}

Fin.last in Init.Data.Fin.Basic

instance : ‚àÄ j, OracleInterface ((batchSpec F m).Message j)
  | ‚ü®0, h‚ü© => nomatch h

structure BerlekampWelchCondition (e k : ‚Ñï) (œâs f : Fin n ‚Üí F) (E Q : Polynomial F) : Prop where
  cond: ‚àÄ i : Fin n, Q.eval (œâs i) = (f i) * E.eval (œâs i)
  E_natDegree : E.natDegree = e
  E_leadingCoeff : E.coeff e = 1
  Q_natDegree : Q.natDegree ‚â§ e + k - 1

@[simp]
abbrev Statement.AfterFirstMessage : Type := Statement R pp

@[reducible]
def OracleStatement (i : Fin (k + 1)) : Fin (i.val + 1) ‚Üí Type :=
  fun j =>
    evalDomain D x (‚àë j' ‚àà finRangeTo j.1, s j')
      ‚Üí F

def fork : Prop :=
  
  trace = [] ‚àß state = 0

alias E_fork := fork

def knowledgeStateFunction :
    (oracleVerifier oSpec OStatement).KnowledgeStateFunction init impl
    (relIn OStatement) (relOut OStatement) (rbrExtractor oSpec OStatement) where
  toFun
  | 0 => fun ‚ü®_, oracles‚ü© _ _ => oracles 0 = oracles 1
  | 1 => fun ‚ü®_, oracles‚ü© chal _ =>
    let q : Query OStatement := by admit /- proof elided -/

def OracleProver.addSalt (P : OracleProver oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec)
    (saltComp : (i : pSpec.MessageIdx) ‚Üí P.PrvState i.1.castSucc ‚Üí OracleComp oSpec (Salt i)) :
  OracleProver oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut (pSpec.addSalt Salt) :=
  Prover.addSalt Salt P saltComp

def append (T‚ÇÅ : FullTranscript pSpec‚ÇÅ) (T‚ÇÇ : FullTranscript pSpec‚ÇÇ) :
    FullTranscript (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ) :=
  Fin.happend T‚ÇÅ T‚ÇÇ

noncomputable def commitOracleReduction (i : Fin ‚Ñì) (hCR : isCommitmentRound ‚Ñì œë i) :
  OracleReduction (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) Context i.succ)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (pSpec := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) where
  prover := commitOracleProver ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i
  verifier := commitOracleVerifier ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hCR

noncomputable def oddRefinement (i : Fin (‚Ñì))
    (coeffs : Fin (2 ^ (‚Ñì - i)) ‚Üí L) : L[X] :=
  ‚àë (‚ü®j, hj‚ü©: Fin (2^(‚Ñì-i-1))), C (coeffs ‚ü®j*2+1, by admit /- proof elided -/
  ‚ü©) * (intermediateNovelBasisX ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i+1, by admit /- proof elided -/
  ‚ü© ‚ü®j, hj‚ü©)

Fin.addNat in Init.Data.Fin.Basic

def snd (T : (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).Transcript k) : pSpec‚ÇÇ.Transcript ‚ü®k - m, by admit /- proof elided -/
‚ü© :=
  if hk : k ‚â§ m then
    fun i => Fin.elim0 (by admit /- proof elided -/
    )
  else
    fun i => sorry

def InnerStmtIn_Test := ‚Ñ§[X] √ó ‚Ñ§

@[reducible]
def pSpec : ProtocolSpec 2 :=
  ‚ü®
    !v[.V_to_P, .P_to_V],
    !v[
        F,
        (evalDomain D x (‚àë j' ‚àà (List.take (i.1 + 1) (List.finRange (k + 1))).toFinset, s j')) ‚Üí F
      ]
  ‚ü©

def Fin.traverseM {Œ≤ : Fin n ‚Üí Type u}
    (f : (i : Fin n) ‚Üí m (Œ≤ i)) : m ((i : Fin n) ‚Üí Œ≤ i) :=
  let rec aux (k : ‚Ñï) (h : k ‚â§ n) : m ((i : Fin k) ‚Üí Œ≤ (Fin.castLE h i)) :=
    match k with
    | 0 => pure (fun i => i.elim0)
    | k' + 1 => do
      let tail ‚Üê aux k' (Nat.le_of_succ_le h)
      let head ‚Üê f (Fin.castLE h (Fin.last k'))
      return (Fin.snoc tail head)
  aux n (le_refl n)

noncomputable def liftedFRI [DecidableEq F] :
  OracleReduction []‚Çí
    ((Fin m ‚Üí F) √ó Fri.Spec.Statement F (0 : Fin (k + 1)))
      (OracleStatement D x m) (Fri.Spec.Witness F s d 0)
    (Fri.Spec.FinalStatement F k)
      (Fri.Spec.FinalOracleStatement D x s) (Fri.Spec.Witness F s d (Fin.last (k + 1)))
    (
      Fri.Spec.pSpecFold D x k s ++‚Çö
      Fri.Spec.FinalFoldPhase.pSpec F ++‚Çö
      Fri.Spec.QueryRound.pSpec D x l
    ) :=
    OracleReduction.liftContext
      (liftingLens D x k s d m)
      (Fri.Spec.reduction D x k s d dom_size_cond l)

def fconcat {A : Sort u} {F : A ‚Üí Sort v} {n : ‚Ñï} {Œ± : Fin n ‚Üí A} {Œ≤ : A}
    (u : (i : Fin n) ‚Üí F (Œ± i)) (a : F Œ≤) : (i : Fin (n + 1)) ‚Üí F (Fin.vconcat Œ± Œ≤ i) :=
  match n with
  | 0 => fun i => match i with | 0 => a
  | _ + 1 => fcons (u 0) (fconcat (fun i => u (Fin.succ i)) a)

@[reducible]
def twoAdicity : Nat := 24

Matrix.col in Mathlib.LinearAlgebra.Matrix.Defs

@[reducible, inline, specialize]
def Transcript (k : Fin (n + 1)) (pSpec : ProtocolSpec n) : Type :=
  (pSpec‚ü¶:k.val‚üß).FullTranscript

@[reducible, simp]
def relIn : Set (Statement √ó Unit) := { ‚ü®stmt, _‚ü© | pred stmt }

Rat in Init.Data.Rat.Basic

noncomputable def queryVerifier (k_le_n : (‚àë j', (s j').1) ‚â§ n) (l : ‚Ñï) [DecidableEq F] :
  OracleVerifier []‚Çí
    (FinalStatement F k) (FinalOracleStatement D x s)
    (FinalStatement F k) (FinalOracleStatement D x s)
    (pSpec D x l) where
  verify := fun prevChallenges roundChallenge => do
    let (p : F[X]) ‚Üê getConst D x k s
    for m in (List.finRange l) do
      let s‚ÇÄ := roundChallenge ‚ü®1, by admit /- proof elided -/
      ‚ü© m
      discard <|
        (List.finRange (k + 1)).mapM
              (fun i =>
                do
                  let x‚ÇÄ := prevChallenges i
                  let s‚ÇÄ :
                    evalDomain D x
                      (‚àë j' ‚àà finRangeTo i.1, (s j').1) :=
                    ‚ü®_, pow_2_pow_i_mem_Di_of_mem_D _ s‚ÇÄ.2‚ü©
                  let queries :
                    List (
                      evalDomain D x
                        (‚àë j' ‚àà finRangeTo i.1, (s j').1)
                    ) :=
                    List.map
                      (fun r =>
                        ‚ü®
                          _,
                          CosetDomain.mul_root_of_unity D (roots_of_unity_lem k_le_n) s‚ÇÄ.2 r.2
                        ‚ü©
                      )
                      (Domain.rootsOfUnity D n (s i))
                  let (pts : List (F √ó F)) ‚Üê
                    List.mapM
                      (fun q => queryCodeword D x k s q >>= fun v => pure (q.1.1, v))
                      queries
                  let Œ≤ ‚Üê
                    if h : i.1 < k
                    then
                      have := CosetDomain.pow_lift D x (s i).1 s‚ÇÄ.2
                      queryCodeword D x k s (i := ‚ü®i.1.succ, Order.lt_add_one_iff.mpr h‚ü©)
                        ‚ü®_, by admit /- proof elided -/
                        ‚ü©
                    else
                      pure (p.eval (s‚ÇÄ.1.1 ^ (2 ^ (s (Fin.last k)).1)))
                  guard (RoundConsistency.roundConsistencyCheck x‚ÇÄ pts Œ≤)
              )
    pure prevChallenges
  embed :=
    ‚ü®
      fun j => Sum.inl j,
      by admit /- proof elided -/
    ‚ü©
  hEq := by admit /- proof elided -/

Context in Examples.FrankingProtocol

noncomputable def toPoly' (p : UniPoly R) : Polynomial R :=
  Polynomial.ofFinsupp (Finsupp.onFinset (Finset.range p.size) p.coeff (by admit /- proof elided -/
  ))

abbrev BTF‚ÇÉ := ConcreteBTField 3 

@[reducible]
def GroupEncodeOracle : OracleSpec Unit := fun _ => (Œπ, BitVec bitLength)

def InnerStmtOut_Test := ‚Ñ§[X] √ó ‚Ñ§ √ó ‚Ñ§

@[reducible, inline, specialize, simp]
def srChallengeQueryImpl {Statement : Type} {pSpec : ProtocolSpec n}
    [‚àÄ i, SelectableType (pSpec.Challenge i)] :
    QueryImpl (srChallengeOracle Statement pSpec) ProbComp where
  impl | query i _ => uniformOfFintype (pSpec.Challenge i)

def monoToLagrange_segment (n : ‚Ñï) (r : Fin n) (l : Fin (r.val + 1)) :
    Vector R (2 ^ n) ‚Üí Vector R (2 ^ n) :=
  let range := forwardRange n r l
  (range.foldl (fun acc h => monoToLagrangeLevel h acc))

def minDist [DecidableEq F] (IC : MatrixSubmodule Œ∫ Œπ F) : ‚Ñï :=
  sInf { d : ‚Ñï | ‚àÉ U ‚àà IC, ‚àÉ V ‚àà IC, distCodewords U V = d }

instance instDCast‚ÇÉ : DCast‚ÇÉ Nat (fun n => Fin (n + 1)) (fun n _ => ProtocolSpec n)
    (fun _ k pSpec => pSpec.Transcript k) where
  dcast‚ÇÉ h h' h'' T := Transcript.cast h
    (by admit /- proof elided -/
    )
    (by admit /- proof elided -/
    )
    T
  dcast‚ÇÉ_id := cast_id

Nat.reducePow in Lean.Meta.Tactic.Simp.BuiltinSimprocs.Nat

OptionT.mk in Init.Control.Option

Finset.Ico in Mathlib.Order.Interval.Finset.Defs

def params24 : Params where
  width := 24
  numFullRounds := 8
  numPartialRounds := 23
  internalDiagVectors := #v[
        -2,
        1,
        2,
        1 / 2,
        3,
        4,
        -1 / 2,
        -3,
        -4,
        1 / (2 ^ 8),
        1 / 4,
        1 / 8,
        1 / 16,
        1 / 32,
        1 / 64,
        1 / (2 ^ 24),
        -1 / (2 ^ 8),
        -1 / 8,
        -1 / 16,
        -1 / 32,
        -1 / 64,
        -1 / (2 ^ 7),
        -1 / (2 ^ 9),
        -1 / (2 ^ 24)
    ]
  roundConstants := RAW_CONSTANTS_24
  width_dvd_by_4 := by admit /- proof elided -/

Char in Init.Prelude

def relHammingDist (u v : Œπ ‚Üí F) : ‚Ñö‚â•0 :=
  hammingDist u v / Fintype.card Œπ

def SkeletonLeafIndex.isLeaf {s : Skeleton} (idx : SkeletonLeafIndex s) : Bool :=
  match idx with
  | SkeletonLeafIndex.ofLeaf => true
  | SkeletonLeafIndex.ofLeft _ => false
  | SkeletonLeafIndex.ofRight _ => false

noncomputable def AffSpanFinset [NeZero k] (U : Fin k ‚Üí Œπ ‚Üí F) : Finset (Œπ ‚Üí F) :=
  (AffSpanSet.instFinite U).toFinset

def churchRec {Œ± : Type} (n : ChurchNat Œ±) (step : Œ± ‚Üí Œ±) (base : Œ±) : Œ± :=
  n step base

LE.le in Init.Prelude

class Smooth
  (domain : Œπ ‚Ü™ F) where
    H : Subgroup (Units F)
    a           : Units F
    h_coset     : Finset.image domain Finset.univ
                  = (fun h : Units F => (a : F) * (h : F)) '' (H : Set (Units F))
    h_card_pow2 : ‚àÉ k : ‚Ñï, Fintype.card Œπ = 2 ^ k

def PowerType (n : ‚Ñï) : Type := dfoldr' n (fun _ => Type) (fun _ T => T ‚Üí T) Nat


example : PowerType 0 = Nat := rfl
example (n : ‚Ñï) : PowerType (n + 1) = (PowerType n ‚Üí PowerType n) := rfl

instance : ‚àÄ i, OracleInterface ((default : ProtocolSpec 0).Message i) := fun ‚ü®i, _‚ü© => Fin.elim0 i

Module.Basis in Mathlib.LinearAlgebra.Basis.Defs

def acceptRejectOracleRel : Set ((Bool √ó (‚àÄ _ : Empty, Unit)) √ó Unit) :=
  { ((true, isEmptyElim), ()) }

abbrev AffSpanSet [NeZero k] (U : Fin k ‚Üí Œπ ‚Üí F) : Set (Œπ ‚Üí F) :=
  (affineSpan F (Finset.univ.image U : Set (Œπ ‚Üí F))).carrier

def eqTilde {L : Type} [CommRing L] {‚Ñì : ‚Ñï} (r r' : Fin ‚Ñì ‚Üí L) : L :=
  MvPolynomial.eval r' (MvPolynomial.eqPolynomial r)

def OracleReduction.liftContext
    (lens : OracleContext.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                              OuterOStmtIn OuterOStmtOut InnerOStmtIn InnerOStmtOut
                              OuterWitIn OuterWitOut InnerWitIn InnerWitOut)
    (R : OracleReduction oSpec InnerStmtIn InnerOStmtIn InnerWitIn
                            InnerStmtOut InnerOStmtOut InnerWitOut pSpec) :
      OracleReduction oSpec OuterStmtIn OuterOStmtIn OuterWitIn
                      OuterStmtOut OuterOStmtOut OuterWitOut pSpec where
  prover := R.prover.liftContext lens
  verifier := R.verifier.liftContext lens.stmt

instance : DecidableEq BTF‚ÇÉ := (inferInstance : DecidableEq (ConcreteBTField 3))

Finset in Mathlib.Data.Finset.Defs

inductive VectorOp where | dotProd

def completeness (relIn : Set (StmtIn √ó WitIn))
    (relOut : Set (StmtOut √ó WitOut))
    (reduction : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec)
    (completenessError : ‚Ñù‚â•0) : Prop :=
  ‚àÄ stmtIn : StmtIn,
  ‚àÄ witIn : WitIn,
  (stmtIn, witIn) ‚àà relIn ‚Üí
    [fun ‚ü®‚ü®_, (prvStmtOut, witOut)‚ü©, stmtOut‚ü© => (stmtOut, witOut) ‚àà relOut ‚àß prvStmtOut = stmtOut
    | do (simulateQ (impl ++‚Çõ‚Çí challengeQueryImpl : QueryImpl _ (StateT œÉ ProbComp))
          <| reduction.run stmtIn witIn).run' (‚Üê init)] ‚â• 1 - completenessError

@[reducible, inline]
instance instProdForall {Œπ : Type u} (v : Œπ ‚Üí Type v) [O : ‚àÄ i, OracleInterface (v i)] :
    OracleInterface (‚àÄ i, v i) where
  Query := (i : Œπ) √ó (O i).Query
  Response := (i : Œπ) √ó (O i).Response
  answer := fun f ‚ü®i, q‚ü© => ‚ü®i, (O i).answer (f i) q‚ü©

LinearIndepOn in Mathlib.LinearAlgebra.LinearIndependent.Defs

def StateRestoration (oSpec : OracleSpec Œπ)
    (StmtIn WitIn WitOut : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n) :=
  StmtIn ‚Üí 
  WitOut ‚Üí 
  pSpec.FullTranscript ‚Üí 
  QueryLog (oSpec ++‚Çí (srChallengeOracle StmtIn pSpec)) ‚Üí 
  QueryLog oSpec ‚Üí 
  OracleComp oSpec WitIn 

def generateProof {n : ‚Ñï} (i : Fin (2 ^ n)) (cache : Cache Œ± n) :
    List.Vector Œ± n :=
  match n with
  | 0 => List.Vector.nil
  | n + 1 => List.Vector.snoc (generateProof ‚ü®i.val / 2, by admit /- proof elided -/
  ‚ü© (cache.upper))
                              ((cache.leaves).get (findNeighbors i (Fin.last _)))

def makeZero (Œπ : ‚Ñï) (F : Type*) [Zero F] : Fin Œπ ‚Üí F := fun _ ‚Ü¶ 0

def ratchet (sponge : DuplexSponge U C) :
    OracleComp (forwardPermutationOracle C) (DuplexSponge U C) := do
  let permutedState : C ‚Üê query (spec := forwardPermutationOracle C) () sponge.state
  
  let vecState : Vector U SpongeSize.N := SpongeState.get permutedState
  
  let zeroed : Vector U SpongeSize.N :=
    Vector.ofFn (fun i => if i < SpongeSize.R then 0 else vecState[i])
  
  let newVecState := SpongeState.update permutedState zeroed
  
  return { sponge with
    state := newVecState,
    squeezePos := Fin.last SpongeSize.R }

instance {s} : LawfulFunctor (fun Œ± => LeafData Œ± s) :=

List.Vector.snoc in Mathlib.Data.Vector.Snoc

def lift {Œπ‚ÇÅ Œπ‚ÇÇ Œπ : Type} {œÉ : Type} (oSpec‚ÇÅ : OracleSpec Œπ‚ÇÅ) (oSpec‚ÇÇ : OracleSpec Œπ‚ÇÇ)
    (oSpec : OracleSpec Œπ) (so : SimOracle.Stateful oSpec‚ÇÅ oSpec‚ÇÇ œÉ) :
      SimOracle.Stateful (oSpec ++‚Çí oSpec‚ÇÅ) (oSpec ++‚Çí oSpec‚ÇÇ) œÉ where
  impl := fun q s => match q with
    | query (.inl i) q => do return ‚ü®‚Üê query i q, s‚ü©
    | query (.inr i) q => so.impl (query (spec := oSpec‚ÇÅ) i q) s

def AlgebraTowerEquiv.toAlgEquivOverRight (e : AlgebraTowerEquiv A B) (i j : Œπ) (h : i ‚â§ j) :
  letI : Algebra (B i) (B j) :=

def LeafData.leftSubtree {Œ± : Type} {s_left s_right : Skeleton}
    (tree : LeafData Œ± (Skeleton.internal s_left s_right)) :
    LeafData Œ± s_left :=
  match tree with
  | LeafData.internal left _right =>
    left

instance {i : Fin ‚Ñì} : ‚àÄ j, SelectableType ((pSpecCommit ùîΩq Œ≤
  (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i).Challenge j)
  | ‚ü®0, hj‚ü© => by admit /- proof elided -/

def outputRelation : Set ((StmtOut R √ó (‚àÄ i, OStmtOut R deg i)) √ó Unit) :=
  { ‚ü®‚ü®‚ü®newTarget, chal‚ü©, oStmt‚ü©, _‚ü© | (oStmt ()).1.eval chal = newTarget }

CommMonoid in Mathlib.Algebra.Group.Defs

instance (i : Fin 0) : OracleInterface i.elim0 := Fin.elim0 i

Set.image in Mathlib.Data.Set.Defs

def getBTFResult (k : ‚Ñï) : ConcreteBTFStepResult k :=
  match k with
  | 0 =>
    let base : ConcreteBTFieldProps 0 := {
      mul_eq := fun a b h_k _ _ _ _ _ _ => by admit /- proof elided -/
| c1_one
        ¬∑ 
          rw [c1_zero] at h_mul
          
          simp at h_mul
        ¬∑ 
          rcases c2_cases with c2_zero | c2_one
          ¬∑ 
            rw [c2_zero] at h_mul
            
            simp at h_mul
          ¬∑ 
            
            exact ‚ü®c1_one, c2_one‚ü©
      
      have specialElement_eq_zero : specialElement = 0 := by admit /- proof elided -/

def perm (cs : ConstraintSystem ùì° numWires numGates) : Equiv.Perm (Fin (3 * numGates)) := sorry

Lean.parseImports' in Lean.Elab.ParseImportsFast

@[simps]
def refl (pSpec : ProtocolSpec n) : Equiv pSpec pSpec where
  round_eq := rfl
  dir_eq := fun _ => rfl
  typeEquiv := fun _ => _root_.Equiv.refl _

def forwardPermutationOracleImpl {Œ± : Type*} [Permute Œ±] :
    QueryImpl (forwardPermutationOracle Œ±) Id where
  impl | query () q => Permute.permute (Œ± := Œ±) q

@[inline, specialize]
def oracleProver : OracleProver oSpec
    Statement OStatement (‚àÄ i, Witness i)
    Statement (OStatement ‚äï·µ• Witness) Unit
    (oraclePSpec Witness) where
  PrvState := fun _ => (Statement √ó (‚àÄ i, OStatement i)) √ó (‚àÄ i, Witness i)
  input := id
  sendMessage | ‚ü®0, _‚ü© => fun ‚ü®stmt, wit‚ü© => pure (wit, ‚ü®stmt, wit‚ü©)
  
  receiveChallenge | ‚ü®0, h‚ü© => nomatch h
  output := fun ‚ü®‚ü®stmt, oStmt‚ü©, wit‚ü© => pure (‚ü®stmt, Sum.rec oStmt wit‚ü©, ())

def fiberwiseDistance (i : Fin ‚Ñì) (steps : ‚Ñï) [NeZero steps] (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
  (f : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i.val, by admit /- proof elided -/
  ‚ü©) : ‚Ñï :=
  
  
  let C_i := BBF_Code ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i.val, by admit /- proof elided -/
  ‚ü©
  let disagreement_sizes := (fun (g : C_i) =>
    (fiberwiseDisagreementSet ùîΩq Œ≤ i steps h_i_add_steps f g).ncard) '' Set.univ
  sInf disagreement_sizes

instance [ProverFirst pSpec] : ProverLast pSpec where
  prover_last' := by admit /- proof elided -/

def FullData.leftSubtree {Œ± : Type} {s_left s_right : Skeleton}
    (tree : FullData Œ± (Skeleton.internal s_left s_right)) :
    FullData Œ± s_left :=
  match tree with
  | FullData.internal _ left _right =>
    left

noncomputable def disFromHammingNorm [Semiring F] [DecidableEq F] (LC : LinearCode Œπ F) : ‚Ñï :=
  sInf {d | ‚àÉ u ‚àà LC, u ‚â† 0 ‚àß hammingNorm u ‚â§ d}

@[reducible, simp]
def relOut : Set ((StmtOut OStatement √ó ‚àÄ i, OStmtOut OStatement i) √ó WitOut) :=
  { ‚ü®‚ü®q, oStmt‚ü©, ()‚ü© | answer (oStmt 0) q = answer (oStmt 1) q }

def params16 : Params where
  width := 16
  numFullRounds := 8
  numPartialRounds := 20
  internalDiagVectors := #v[
       -2,
        1,
        2,
        1 / 2,
        3,
        4,
        -1 / 2,
        -3,
        -4,
        1 / (2 ^ 8),
        1 / 8,
        1 / (2 ^ 24),
        -1 / (2 ^ 8),
        -1 / 8,
        -1 / 16,
        -1 / (2 ^ 24),
    ]
  roundConstants := rawConstants16
  width_dvd_by_4 := by admit /- proof elided -/

Array.size in Init.Prelude

noncomputable def commSEquiv : Right ‚äó[K] Left ‚âÉ‚Çó[Right] Left ‚äó[K] Right :=
  { Algebra.TensorProduct.comm K Right Left with
    map_smul' := fun s x => by admit /- proof elided -/
      | zero =>
        simp only [AlgEquiv.toEquiv_eq_coe, smul_zero, Equiv.toFun_as_coe, EquivLike.coe_coe,
          map_zero, RingHom.id_apply];
      | tmul s' m =>
        simp only [AlgEquiv.toEquiv_eq_coe, Equiv.toFun_as_coe, EquivLike.coe_coe, RingHom.id_apply,
          Algebra.TensorProduct.comm_tmul];
          
          exact comm_map_smul_tmul (Right:=Right) (Left:=Left) s s' m
      | add x y hx hy =>
        simp only [AlgEquiv.toEquiv_eq_coe, Equiv.toFun_as_coe, EquivLike.coe_coe, RingHom.id_apply,
          smul_add,
          map_add] at *
        exact comm_map_smul_add (Right:=Right) (Left:=Left) s x y hx hy
   }

instFintypeProd in Mathlib.Data.Fintype.Prod

def e (B : Finset (Fin n ‚Üí F)) (v : Fin n ‚Üí F) : ‚Ñö :=
  (1 : ‚Ñö)/B.card * ‚àë x ‚àà B, Œî‚ÇÄ(v, x)

@[reducible, simp]
def knowledgeSoundness
    (relation : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (verifier : OracleVerifier oSpec Statement OStatement Bool (fun _ : Empty => Unit) pSpec)
    (knowledgeError : ‚Ñù‚â•0) : Prop :=
  verifier.toVerifier.knowledgeSoundness init impl relation acceptRejectOracleRel knowledgeError

def toProverState (ds : DomainSeparator U H) (rng : R) : FSProverState U H R :=
  FSProverState.new ds rng

Monoid in Mathlib.Algebra.Group.Defs

Polynomial.evalEval in Mathlib.Algebra.Polynomial.Bivariate

def getTypes {Œ±s : List Type} (_ : HList Œ±s) : List Type := Œ±s

structure InterleavedCode (Œ∫ Œπ : Type*) [Fintype Œ∫] [Fintype Œπ] (F : Type*) [Semiring F] where
  MF : MatrixSubmodule Œ∫ Œπ F
  LC : LinearCode Œπ F

def CEmbedding : R ‚Ü™ MvPolynomial œÉ R := ‚ü®C, C_injective œÉ R‚ü©

@[inline] def mod [Zero T] [DecidableEq T] [ToNat T]
    (dividend divisor : Cayley T) : Cayley T :=
  
  letI fuel := (‚Üëdividend : Nat) + 1
  modNat dividend divisor fuel

Set.univ in Mathlib.Data.Set.Defs

def distToCode [DecidableEq F] (U : Matrix Œ∫ Œπ F) (IC : MatrixSubmodule Œ∫ Œπ F) : ‚Ñï :=
 sInf { d : ‚Ñï | ‚àÉ V ‚àà IC, distCodewords U V = d }

def finalSumcheckRelOutProp
    (input : ((FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì) √ó
      (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì) j)) √ó
      (Unit))) : Prop :=
  
  finalNonDoomedFoldingProp ùîΩq Œ≤
    (h_le := by admit /- proof elided -/
    )
    (input := input.1)

structure Selector (ùì° : Type*) where
   
  qL : ùì°
   
  qR : ùì°
   
  qO : ùì°
   
  qM : ùì°
   
  qC : ùì°
deriving DecidableEq

def relOut : Set ((Unit √ó (‚àÄ i, (Sum.elim OStatement OStatement) i)) √ó Unit) :=
  setOf (fun ‚ü®‚ü®(), oracles‚ü©, _‚ü© => oracles (.inl default) = oracles (.inr default))

Finset.zero in Mathlib.Algebra.Group.Pointwise.Finset.Basic

AdjoinRoot.root in Mathlib.RingTheory.AdjoinRoot

class HasSucc (T : Type u) where
   
  succ' : T ‚Üí T

def Prover.addSalt (P : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec)
    (saltComp : (i : pSpec.MessageIdx) ‚Üí P.PrvState i.1.castSucc ‚Üí OracleComp oSpec (Salt i)) :
  Prover oSpec StmtIn WitIn StmtOut WitOut (pSpec.addSalt Salt) where
  PrvState := P.PrvState
  input := P.input
  sendMessage := fun i st => by admit /- proof elided -/

def extract (start stop : ‚Ñï) (h1 : start ‚â§ stop) (h2 : stop ‚â§ n) (pSpec : ProtocolSpec n) :
    ProtocolSpec (stop - start) where
  dir := Fin.extract start stop h1 h2 pSpec.dir
  ¬´Type¬ª := Fin.extract start stop h1 h2 pSpec.¬´Type¬ª

def isCommitmentRound (i : Fin ‚Ñì) : Prop :=
  œë ‚à£ i.val + 1 ‚àß i.val + 1 ‚â† ‚Ñì

instance [Repr Œ±] (Œ±s : List Type) [HListRepr (HList Œ±s)] : HListRepr (HList (Œ± :: Œ±s)) where
  repr
  | HList.cons x xs =>
    match xs with
    | HList.nil => reprPrec x 0
    | HList.cons _ _ => reprPrec x 0 ++ ", " ++ HListRepr.repr xs

finProdFinEquiv in Mathlib.Logic.Equiv.Fin.Basic

abbrev FunEquiv F Œ± Œ≤ := DFunEquiv F Œ± fun _ => Œ≤

@[reducible, simp] def WitIn := Unit

instance [Zero T] [ToNat T] : HasPred (Cayley T) where
  pred' := pred

def eval‚ÇÇ [Semiring S] (f : R ‚Üí+* S) (x : S) (p : UniPoly R) : S :=
  p.zipIdx.foldl (fun acc ‚ü®a, i‚ü© => acc + f a * x ^ i) 0

Function.Embedding in Mathlib.Logic.Embedding.Basic

def verifier : Verifier oSpec (StmtIn R √ó (‚àÄ i, OStmtIn R deg i))
                              (StmtOut R √ó (‚àÄ i, OStmtOut R deg i)) (pSpec R deg) where
  verify := fun ‚ü®target, oStmt‚ü© transcript => do
    letI polyLE := transcript 0
    guard (‚àë x ‚àà (univ.map D), polyLE.val.eval x = target)
    letI chal := transcript 1
    pure ‚ü®‚ü®(oStmt ()).val.eval chal, chal‚ü©, fun _ => oStmt ()‚ü©

inductive Skeleton :
    (n : ‚Ñï) ‚Üí (ar : Fin n ‚Üí ‚Ñï) ‚Üí Type where
  | leaf {ar0 : Fin 0 ‚Üí ‚Ñï} : Skeleton 0 ar0
  | node {n : ‚Ñï} {ar : Fin (n+1) ‚Üí ‚Ñï}
      (children : Fin (ar 0) ‚Üí
        Skeleton n (fun i => ar i.succ)) :
      Skeleton (n+1) ar

class PrimeOrderWith (G : Type*) [Group G] (p : outParam ‚Ñï) [Fact (Nat.Prime p)] where
  hCard : Nat.card G = p

def KnowledgeStateFunction.toStateFunction
    {relIn : Set (StmtIn √ó WitIn)} {relOut : Set (StmtOut √ó WitOut)}
    {verifier : Verifier oSpec StmtIn StmtOut pSpec} {WitMid : Fin (n + 1) ‚Üí Type}
    {extractor : Extractor.RoundByRound oSpec StmtIn WitIn WitOut pSpec WitMid}
    (kSF : KnowledgeStateFunction init impl relIn relOut verifier extractor) :
      verifier.StateFunction init impl relIn.language relOut.language where
  toFun := fun m stmtIn tr => ‚àÉ witMid, kSF.toFun m stmtIn tr witMid
  toFun_empty := by admit /- proof elided -/

Fin.succ in Init.Data.Fin.Basic

PFunctor.Lens.id in ToMathlib.PFunctor.Lens.Basic

instance {n : ‚Ñï} : OfNat (Cayley T) n where
  ofNat := ofNat n

instance : Field ScalarField := ZMod.instField SCALAR_FIELD_CARD

def erase_even (s : Finset ‚Ñï) : Finset ‚Ñï := s.filter Odd

def Œ±' (x‚ÇÄ : F) (R : F[X][X][Y]) (H_irreducible : Irreducible H) (t : ‚Ñï) : ùïÉ H :=
  Œ± x‚ÇÄ R _ (œÜ := ‚ü®H_irreducible‚ü©) t

def rtake {n : ‚Ñï} {Œ± : Fin n ‚Üí Sort*} (m : ‚Ñï) (h : m ‚â§ n) (v : (i : Fin n) ‚Üí Œ± i) :
    (i : Fin m) ‚Üí Œ± (Fin.cast (Nat.sub_add_cancel h) (natAdd (n - m) i)) :=
  fun i => v (Fin.cast (Nat.sub_add_cancel h) (natAdd (n - m) i))

@[reducible, simp]
def OracleStatement.Lens.IsSound {OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut : Type}
    {Outer_Œπ‚Çõ·µ¢ : Type} {OuterOStmtIn : Outer_Œπ‚Çõ·µ¢ ‚Üí Type} [‚àÄ i, OracleInterface (OuterOStmtIn i)]
    {Outer_Œπ‚Çõ‚Çí : Type} {OuterOStmtOut : Outer_Œπ‚Çõ‚Çí ‚Üí Type} [‚àÄ i, OracleInterface (OuterOStmtOut i)]
    {Inner_Œπ‚Çõ·µ¢ : Type} {InnerOStmtIn : Inner_Œπ‚Çõ·µ¢ ‚Üí Type} [‚àÄ i, OracleInterface (InnerOStmtIn i)]
    {Inner_Œπ‚Çõ‚Çí : Type} {InnerOStmtOut : Inner_Œπ‚Çõ‚Çí ‚Üí Type} [‚àÄ i, OracleInterface (InnerOStmtOut i)]
    (outerLangIn : Set (OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i)))
    (outerLangOut : Set (OuterStmtOut √ó (‚àÄ i, OuterOStmtOut i)))
    (innerLangIn : Set (InnerStmtIn √ó (‚àÄ i, InnerOStmtIn i)))
    (innerLangOut : Set (InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i)))
    (compatStmt :
      OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i) ‚Üí InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i) ‚Üí Prop)
    (lens : OracleStatement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                                    OuterOStmtIn OuterOStmtOut InnerOStmtIn InnerOStmtOut) :=
  Statement.Lens.IsSound outerLangIn outerLangOut innerLangIn innerLangOut compatStmt lens

Finset.Iic in Mathlib.Order.Interval.Finset.Defs

Set.Ioo in Mathlib.Order.Interval.Set.Defs

instance {i : Fin (k + 1)} : ‚àÄ j, OracleInterface (OracleStatement D x s i j) :=
  fun _ => inferInstance

instance [inst : ‚àÄ i, SelectableType (pSpec.Challenge i)] :
    ‚àÄ i, SelectableType ((pSpec.addSalt Salt).Challenge i) :=
  fun i => by admit /- proof elided -/

structure BinaryTowerInductiveStepResult (k : ‚Ñï) (prevBTField : Type _)
  (prevBTResult : BinaryTowerResult prevBTField k) [instPrevBTFieldIsField : Field prevBTField]
  (prevPoly : Polynomial prevBTField) (F : Type _) where
  binaryTowerResult : BinaryTowerResult F (k+1)
  eq_adjoin : F = AdjoinRoot prevPoly
  u_is_root : Eq.mp (eq_adjoin) binaryTowerResult.specialElement = AdjoinRoot.root prevPoly
  eval_defining_poly_at_root : Eq.mp (eq_adjoin) binaryTowerResult.specialElement^2 +
    Eq.mp (eq_adjoin) binaryTowerResult.specialElement * (of prevPoly) prevBTResult.specialElement
    + 1 = 0

instance : Unique (Fin 0 ‚Üí Œ±) where
  uniq v := by admit /- proof elided -/

def instTestLensKnowledgeSound : testLensE.IsKnowledgeSound
      outerRelIn_Test innerRelIn_Test outerRelOut_Test innerRelOut_Test
      (fun ‚ü®p, q, _‚ü© ‚ü®f, _‚ü© => p * q = f) (fun _ _ => True) where
  proj_knowledgeSound := fun ‚ü®p, q, t‚ü© ‚ü®f, t', r‚ü© _ h h' => by admit /- proof elided -/

OfNat in Init.Prelude

Subspace in Mathlib.Algebra.Module.Submodule.Basic

WeierstrassCurve in Mathlib.AlgebraicGeometry.EllipticCurve.Weierstrass

def Polynomial.toImpl {R : Type*} [Semiring R] (p : R[X]) : UniPoly R :=
  match p.degree with
  | ‚ä• => #[]
  | some d  => .ofFn (fun i : Fin (d + 1) => p.coeff i)

def inputRelation (cond : ‚àë i, (s i).1 ‚â§ n) [DecidableEq F] (Œ¥ : ‚Ñù‚â•0) :
    Set
      (
        (
          Statement F (Fin.last k) √ó
          (‚àÄ j, OracleStatement D x s (Fin.last k) j)
        ) √ó
        Witness F s d (Fin.last k).castSucc
      ) := sorry

def finalSumcheckKStateProp {m : Fin (1 + 1)} (tr : Transcript m (pSpecFinalSumcheckStep (L := L)))
    (stmt : Statement (L := L) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì))
    (witMid : FinalSumcheckWit (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) m)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì) j) : Prop :=
  match m with
  | ‚ü®0, _‚ü© => 
    masterKStateProp ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (mp := BBF_SumcheckMultiplierParam)
      (stmtIdx := Fin.last ‚Ñì) (oracleIdx := Fin.last ‚Ñì) (h_le := le_refl _)
      (stmt := stmt) (wit := witMid) (oStmt := oStmt) (localChecks := True)
  | ‚ü®1, _‚ü© => 
    let tr_so_far := (pSpecFinalSumcheckStep (L := L)).take 1 (by admit /- proof elided -/
    )
    let i_msg0 : tr_so_far.MessageIdx := ‚ü®‚ü®0, by admit /- proof elided -/
    ‚ü©, rfl‚ü©
    let c : L := (ProtocolSpec.Transcript.equivMessagesChallenges (k := 1)
      (pSpec := pSpecFinalSumcheckStep (L := L)) tr).1 i_msg0

    let stmtOut : FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì) := {
      ctx := stmt.ctx,
      sumcheck_target := stmt.sumcheck_target,
      challenges := stmt.challenges,
      final_constant := c
    }

    let sumcheckFinalCheck : Prop := stmt.sumcheck_target = eqTilde r stmt.challenges * c
    let finalFoldingProp := finalNonDoomedFoldingProp ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (h_le := by admit /- proof elided -/
        ) (input := ‚ü®stmtOut, oStmt‚ü©)

    sumcheckFinalCheck ‚àß finalFoldingProp 

Algebra.cast in Mathlib.Algebra.Algebra.Defs

def mul_by_2 (s : Finset ‚Ñï) : Finset ‚Ñï :=
  s.map ‚ü®fun n => 2 * n, by admit /- proof elided -/
  ‚ü©

abbrev MultiquadraticPoly (L : Type) [CommSemiring L] (‚Ñì : ‚Ñï) := L‚¶É‚â§ 2‚¶Ñ[X Fin ‚Ñì]

OneHom in Mathlib.Algebra.Group.Hom.Defs

instance : DFunLike F Œ± Œ≤ where
  coe := DFunEquiv.equiv.toFun
  coe_injective' := DFunEquiv.equiv.injective

@[inline]
def ofArray [Zero R] (coeffs : Array R) (n : ‚Ñï) : MlPoly R n :=
  .ofFn (fun i => if h : i.1 < coeffs.size then coeffs[i] else 0)

instance : ‚àÄ j, OracleInterface ((pSpecRelay).Message j)
  | ‚ü®x, hj‚ü© => by admit /- proof elided -/

noncomputable def finalSumcheckKnowledgeStateFunction {œÉ : Type} (init : ProbComp œÉ)
    (impl : QueryImpl []‚Çí (StateT œÉ ProbComp)) :
    (finalSumcheckVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).KnowledgeStateFunction init impl
    (relIn := roundRelation ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (ùìë := ùìë) (mp := BBF_SumcheckMultiplierParam) (Fin.last ‚Ñì))
    (relOut := finalSumcheckRelOut ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (extractor := finalSumcheckRbrExtractor ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
  where
  toFun := fun m ‚ü®stmt, oStmt‚ü© tr witMid =>
    finalSumcheckKStateProp ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (ùìë := ùìë) (tr := tr) (stmt := stmt) (witMid := witMid) (oStmt := oStmt)
  toFun_empty := fun stmt witMid => by admit /- proof elided -/

structure WireIndices (numWires : ‚Ñï) where
   
  a : Fin numWires
   
  b : Fin numWires
   
  c : Fin numWires
deriving DecidableEq

structure ParamConditions (P : Params Œπ F) where
  h_deg : ‚àÉ k : ‚Ñï, P.deg = 2^k
  h_foldingParams : ‚àÄ i : Fin (M + 1), ‚àÉ k : ‚Ñï, (P.foldingParam i) = 2^k
  h_deg_ge : P.deg ‚â• ‚àè i : Fin (M + 1), (P.foldingParam i)
  h_smooth : ‚àÄ i : Fin (M + 1), Smooth (P.œÜ i)
  h_smooth_le : ‚àÄ i : Fin (M + 1), Fintype.card (Œπ i) ‚â§ (degree Œπ P i)
  h_repeatP_le : ‚àÄ i : Fin (M + 1), P.repeatParam i + 1 ‚â§ (degree Œπ P i)

@[reducible, inline]
instance instMvPolynomialDegreeLE : OracleInterface (R‚¶É‚â§ d‚¶Ñ[X œÉ]) where
  Query := œÉ ‚Üí R
  Response := R
  answer := fun ‚ü®poly, _‚ü© point => eval point poly

def InternalData.rightSubtree {Œ± : Type} {s_left s_right : Skeleton}
    (tree : InternalData Œ± (Skeleton.internal s_left s_right)) :
    InternalData Œ± s_right :=
  match tree with
  | InternalData.internal _ _left right =>
    right

instance {i : Fin ‚Ñì} :
    ‚àÄ j, OracleInterface ((pSpecFoldCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i).Message j) :=
  instOracleInterfaceMessageAppend (pSpec‚ÇÅ := pSpecFold (L := L))
    (pSpec‚ÇÇ := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)

def InternalData.get {s} {Œ± : Type}
    (tree : InternalData Œ± s) (idx : SkeletonInternalIndex s) : Œ± :=
  match tree, idx with
  | InternalData.internal value _ _, SkeletonInternalIndex.ofInternal => value
  | InternalData.internal _ left _, SkeletonInternalIndex.ofLeft idxLeft =>
    InternalData.get left idxLeft
  | InternalData.internal _ _ right, SkeletonInternalIndex.ofRight idxRight =>
    InternalData.get right idxRight

def inputRelation :
    Set
      (
        (Unit √ó (‚àÄ j, OracleStatement D x m j)) √ó
        Witness F s d m
      ) := sorry

instance : Fact (Nat.Prime BASE_FIELD_CARD) := ‚ü®BaseField_is_prime‚ü©

Nat.reduceAdd in Lean.Meta.Tactic.Simp.BuiltinSimprocs.Nat

Matrix.neg in Mathlib.LinearAlgebra.Matrix.Defs

instance {k : Fin (n + 1)} : Fintype (pSpec.MessageIdxUpTo k) :=
  inferInstanceAs (Fintype <| MessageIdx (pSpec.take k k.is_le))

noncomputable def fromColGenMat [CommRing F] (G : Matrix Œπ Œ∫ F) : LinearCode Œπ F :=
  LinearMap.range G.mulVecLin

def snoc (s : Fin n ‚Üí‚ÇÄ M) (y : M) : Fin (n + 1) ‚Üí‚ÇÄ M :=
  Finsupp.equivFunOnFinite.symm (Fin.snoc s y : Fin (n + 1) ‚Üí M)

instance [IsSingleRound pSpec] [h : VCVCompatible (pSpec.Challenge default)] :
    (i : pSpec.ChallengeIdx) ‚Üí VCVCompatible (pSpec.Challenge i) := fun i => by admit /- proof elided -/

def composeM {m' : Type u ‚Üí Type v} [Monad m'] (hom : m ‚Üí·µê m') (so : QueryImpl spec m) :
    QueryImpl spec m' where
  impl | query i t => hom (so.impl (query i t))

def rightpad (m‚ÇÇ n‚ÇÇ : ‚Ñï) (a : Œ±) {m‚ÇÅ n‚ÇÅ : ‚Ñï} (M : Matrix (Fin m‚ÇÅ) (Fin n‚ÇÅ) Œ±) :
    Matrix (Fin m‚ÇÇ) (Fin n‚ÇÇ) Œ± :=
  Fin.rightpad m‚ÇÇ (fun _ => a) (Fin.rightpad n‚ÇÇ a ‚àò M)

def exSkel0 : ArityTree.Skeleton 0 (fun i => nomatch i) :=
  ArityTree.Skeleton.leaf

class ProverFirst (pSpec : ProtocolSpec n) [NeZero n] where
  prover_first' : pSpec.dir 0 = .P_to_V

System.FilePath.addExtension in Init.System.FilePath

noncomputable def coeffAsRatFunc : F[X] ‚Üí+* Polynomial (RatFunc F) :=
  RingHom.comp bivPolyHom Polynomial.C

Fin.succEmb in Mathlib.Data.Fin.Embedding

@[inline, reducible]
def Witness.Lens (OuterStmtIn InnerStmtOut OuterWitIn OuterWitOut InnerWitIn InnerWitOut : Type)
    := PFunctor.Lens ((OuterStmtIn √ó OuterWitIn) X^ OuterWitOut)
                     (InnerWitIn X^ (InnerStmtOut √ó InnerWitOut))

def BinaryTowerAux (k : ‚Ñï) : (Œ£' (F : Type 0), BinaryTowerResult F k) :=
  match k with
  | 0 => 
    let curBTField := GF(2)
    let newList : List.Vector (GF(2)) 1 := List.Vector.cons (1 : GF(2)) List.Vector.nil
    let specialElement : GF(2) := newList.1.headI
    let firstElementOfVecIsSpecialElement : newList.1.headI = specialElement := rfl
    let specialElementIs1 : specialElement = 1 := by admit /- proof elided -/

LinearEquiv in Mathlib.Algebra.Module.Equiv.Defs

Array.zipIdx in Init.Data.Array.Basic

noncomputable def decode : (ReedSolomon.code domain deg) ‚Üí‚Çó[F] F[X] :=
  domRestrict
    (interpolate (domain := domain))
    (ReedSolomon.code domain deg)

Sum.isRight in Init.Data.Sum.Basic

inductive Data :
    {n : ‚Ñï} ‚Üí (pSpec : ProtocolSpec n) ‚Üí
    {ar : Fin n ‚Üí ‚Ñï} ‚Üí ArityTree.Skeleton n ar ‚Üí Type 1 where
  | leaf {pSpec : ProtocolSpec 0} {ar0 : Fin 0 ‚Üí ‚Ñï} :
      Data pSpec (ArityTree.Skeleton.leaf (ar0 := ar0))
  | msgNode {n : ‚Ñï}
      {pSpec : ProtocolSpec (n + 1)} {ar : Fin (n + 1) ‚Üí ‚Ñï}
      (h : pSpec.dir 0 = Direction.P_to_V)
      (val : pSpec.Message' 0 h)
      {children : Fin (ar 0) ‚Üí
        ArityTree.Skeleton n (fun i => ar i.succ)}
      (childrenData : (i : Fin (ar 0)) ‚Üí
        Data (pSpec := pSpec.drop 1 (Nat.succ_le_succ (Nat.zero_le n))) (children i)) :
      Data pSpec (ArityTree.Skeleton.node children)
  | chalNode {n : ‚Ñï}
      {pSpec : ProtocolSpec (n + 1)} {ar : Fin (n + 1) ‚Üí ‚Ñï}
      (h : pSpec.dir 0 = Direction.V_to_P)
      (val : pSpec.Challenge' 0 h)
      {children : Fin (ar 0) ‚Üí
        ArityTree.Skeleton n (fun i => ar i.succ)}
      (childrenData : (i : Fin (ar 0)) ‚Üí
        Data (pSpec := pSpec.drop 1 (Nat.succ_le_succ (Nat.zero_le n))) (children i)) :
      Data pSpec (ArityTree.Skeleton.node children)

instance {i : Fin r} : DecidableEq (U ùîΩq Œ≤ i) :=

def closePtsOnAffineLine {Œπ : Type*} [Fintype Œπ]
                         (u v : Œπ ‚Üí F) (deg : ‚Ñï) (Œ± : Œπ ‚Ü™ F) (e : ‚Ñï) : Set (Œπ ‚Üí F) :=
  {x : Œπ ‚Üí F | x ‚àà Affine.line u v ‚àß distFromCode x (ReedSolomon.code Œ± deg) ‚â§ e}

noncomputable def Bstar (x : ‚Ñù) : ‚Ñù := x.sqrt

def dfoldl' (n : ‚Ñï) (Œ± : Fin (n + 1) ‚Üí Type u)
    (f : (i : Fin n) ‚Üí Œ± i.castSucc ‚Üí Œ± i.succ) (init : Œ± 0) : Œ± (last n) :=
  dfoldlM' (m := Id) n Œ± f init

Nat.zero in Init.Prelude

@[reducible]
def reduction : Reduction oSpec StmtIn WitIn StmtOut WitOut !p[] where
  prover := prover mapStmt mapWit
  verifier := verifier mapStmt

def run (adversary : Adversary Œπ G p bitLength Œ±) (table : GroupValTable Œπ G) : List G √ó Œ± :=
  sorry

def MlPoly.mk {R : Type*} (n : ‚Ñï) (v : Vector R (2 ^ n)) : MlPoly R n := v

structure Indexer {Œπ : Type} (oSpec : OracleSpec Œπ) {n : ‚Ñï} (pSpec : ProtocolSpec n) (Index : Type)
    (Encoding : Type) where
  encode : Index ‚Üí OracleComp oSpec Encoding
  [OracleInterface : OracleInterface Encoding]

def binaryFinMapToNat {n : ‚Ñï} (m : Fin n ‚Üí ‚Ñï) (h_binary : ‚àÄ j: Fin n, m j ‚â§ 1) : Fin (2^n) :=

partial def factor (n : ‚Ñï) : Option (List ‚Ñï) :=
  if deterministicMillerRabin n then
    [n]
  else do
    let f ‚Üê rho n
    let lhs ‚Üê factor f
    let rhs ‚Üê factor (n / f)
    return (lhs ++ rhs)

Pow in Init.Prelude

OrderDual in Mathlib.Order.Basic

noncomputable def verifyOpening (verifySrs : Vector G‚ÇÇ 2) (commitment : G‚ÇÅ) (opening : G‚ÇÅ)
    (z : ZMod p) (v : ZMod p) : Prop :=
  pairing (commitment / g‚ÇÅ ^ v.val) (verifySrs[0]) = pairing opening (verifySrs[1] / g‚ÇÇ ^ z.val)

def SkeletonNodeIndex.path {s : Skeleton} (idx : SkeletonNodeIndex s) :
    List (SkeletonNodeIndex s) := sorry

@[inline] def one : AssocNat :=
  ‚ü®Nat.succ, by admit /- proof elided -/
  ‚ü©

OracleComp.inductionOn in VCVio.OracleComp.OracleComp

noncomputable def sDomainBasisVectors (i : Fin r) : Fin (‚Ñì + R_rate - i) ‚Üí L :=
  fun k => (normalizedW ùîΩq Œ≤ i).eval (Œ≤ ‚ü®i + k.val, by admit /- proof elided -/
  ‚ü©)

instance {pSpec : ProtocolSpec n} {Statement : Type} [‚àÄ i, VCVCompatible (pSpec.Challenge i)] :
    OracleSpec.FiniteRange (fsChallengeOracle Statement pSpec) :=
  inferInstanceAs (OracleSpec.FiniteRange (srChallengeOracle Statement pSpec))

def take (j : Fin (k + 1)) (challenges : ChallengesUpTo k pSpec) :
    ChallengesUpTo (j.castLE (by admit /- proof elided -/
    )) pSpec :=
  fun i => challenges ‚ü®i.val.castLE (by admit /- proof elided -/
  ), i.property‚ü©

@[reducible, inline, specialize]
def ChallengeUpTo (k : Fin (n + 1)) (pSpec : ProtocolSpec n) (i : pSpec.ChallengeIdxUpTo k) :=
  (pSpec‚ü¶:k.val‚üß).Challenge i

def init (s : Fin (n + 1) ‚Üí‚ÇÄ M) : Fin n ‚Üí‚ÇÄ M :=
  Finsupp.equivFunOnFinite.symm (Fin.init s)

def choose_2 (x : ‚Ñö) : ‚Ñö := x * (x-1)/2

private noncomputable def E (œâs : Fin n ‚Üí F)
  (f : Fin n ‚Üí F) (p : Polynomial F) (e : ‚Ñï) : Polynomial F :=
  X ^ (e - (Œî‚ÇÄ(f, p.eval ‚àò œâs) : ‚Ñï)) * ElocPolyF œâs f p

local instance : Inhabited R := ‚ü®0‚ü©

@[reducible, inline, specialize]
def Messages (pSpec : ProtocolSpec n) : Type := ‚àÄ i, pSpec.Message i

Multiset.map in Mathlib.Data.Multiset.MapFold

def modByMonic [Field R] (p : UniPoly R) (q : UniPoly R) :
    UniPoly R :=
  (divModByMonicAux p q).2

def domainEnum (i : Fin (n + 1)) : Fin (2 ^ (n - i)) ‚Ü™ evalDomain D i :=
  ‚ü®domain D n i.1, domain_injective D i.1 (by admit /- proof elided -/
  )‚ü©

noncomputable def monomialBasisOfDegreeLT {n : ‚Ñï} : Basis (Fin n) L (L‚¶É< n‚¶Ñ[X]) :=

noncomputable def toPoly (p : UniPoly R) : Polynomial R :=
  p.eval‚ÇÇ Polynomial.C Polynomial.X

def RoundByRoundOneShot
    (oSpec : OracleSpec Œπ) (StmtIn WitIn : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n) :=
  (m : Fin (n + 1)) ‚Üí StmtIn ‚Üí Transcript m pSpec ‚Üí QueryLog oSpec ‚Üí WitIn

def liftF (f : Fin n ‚Üí Œ±) : ‚Ñï ‚Üí Œ± :=
  fun m ‚Ü¶ if h : m < n then f ‚ü®m, h‚ü© else 0

def accepts (x : Fin numWires ‚Üí ùì°) (g : Gate ùì° numWires) : Prop :=
  g.eval x = 0

Nat.digits in Mathlib.Data.Nat.Digits.Defs

Mathlib.Linter.TextBased.ErrorFormat.humanReadable in Mathlib.Tactic.Linter.TextBased

@[inline, reducible]
def proj : OuterStmtIn √ó OuterWitIn ‚Üí InnerStmtIn √ó InnerWitIn :=
  fun ctxIn => ‚ü®lens.stmt.toFunA ctxIn.1, lens.wit.toFunA ctxIn‚ü©

instance : OracleInterface (Witness R pp) where
  Query := Fin pp.‚Ñì_w ‚Üí R
  Response := R
  answer := fun ùï® evalPoint => (MLE (ùï® ‚àò finFunctionFinEquiv)) ‚∏®evalPoint‚∏©

@[ext]
structure Cayley (T : Type u) [HasSucc T] where
   
  toFun : T ‚Üí T
   
  toFun_succ : ‚àÄ (t : T), toFun (succ' t) = succ' (toFun t)

@[reducible]
def pSpec : ProtocolSpec 1 :=
  ‚ü®!v[.V_to_P], !v[Fin l ‚Üí evalDomain D x 0]‚ü©

def MLEEquivFin {n : ‚Ñï} : R‚¶É‚â§ 1‚¶Ñ[X (Fin n)] ‚âÉ (Fin (2 ^ n) ‚Üí R) :=
  Equiv.trans MLEEquiv (Equiv.piCongr finFunctionFinEquiv (fun _ => Equiv.refl _))

protected def Prover.id : Prover oSpec Statement Witness Statement Witness !p[] where
  PrvState := fun _ => Statement √ó Witness
  input := _root_.id
  sendMessage := fun i => Fin.elim0 i
  receiveChallenge := fun i => Fin.elim0 i
  output := pure

noncomputable instance {H : F[X][Y]} : Ring (ùí™ H) :=
  Ideal.Quotient.ring (Ideal.span {H_tilde' H})

Vector.head in Init.Data.Vector.Basic

def pred (n : ChurchNat Œ±) : ChurchNat Œ± := sorry

instance Z_NeZero {k : ‚Ñï} : NeZero (Z k) := { out := Z_ne_zero (k:=k) }

def knowledgeSoundness
    (relIn : Set ((StmtIn √ó ‚àÄ i, OStmtIn i) √ó WitIn))
    (relOut : Set ((StmtOut √ó ‚àÄ i, OStmtOut i) √ó WitOut))
    (verifier : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec)
    (knowledgeError : ‚Ñù‚â•0) : Prop :=
  verifier.toVerifier.knowledgeSoundness init impl relIn relOut knowledgeError

List.map in Init.Prelude

@[inline, specialize]
def runToRound (i : Fin (n + 1))
    (stmt : StmtIn) (wit : WitIn) (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí) (pSpec.Transcript i √ó prover.PrvState i) :=
  Fin.induction
    (pure ‚ü®default, prover.input (stmt, wit)‚ü©)
    (prover.processRound)
    i

@[reducible, simp]
def OStmtIn : Unit ‚Üí Type := fun _ => R‚¶É‚â§ deg‚¶Ñ[X]

def renameMessage (pSpec : ProtocolSpec n) (NewMessage : pSpec.MessageIdx ‚Üí Type) :
    ProtocolSpec n :=
  ‚ü® pSpec.dir,
    fun i => if h : pSpec.dir i = Direction.P_to_V then NewMessage ‚ü®i, h‚ü© else pSpec.¬´Type¬ª i‚ü©

AddMonoid in Mathlib.Algebra.Group.Defs

HMul in Init.Prelude

instance instDCast‚ÇÇ : DCast‚ÇÇ Nat ProtocolSpec (fun _ pSpec => FullTranscript pSpec) where
  dcast‚ÇÇ h h' T := FullTranscript.cast h h' T
  dcast‚ÇÇ_id := cast_id

def sigmaMessageIdxToSeqCompose {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (i : Fin m) (j : (pSpec i).MessageIdx) : (seqCompose pSpec).MessageIdx :=
  ‚ü®Fin.embedSum i j.1, by admit /- proof elided -/
  ‚ü©

Finset.image in Mathlib.Data.Finset.Image

def toNat (n : ChurchNat ‚Ñï) : ‚Ñï := n Nat.succ 0

def projectToMidSumcheckPoly (t : MultilinearPoly L ‚Ñì)
    (m : MultilinearPoly L ‚Ñì) (i : Fin (‚Ñì + 1))
    (challenges : Fin i ‚Üí L)
    : MultiquadraticPoly L (‚Ñì-i) :=
  let H‚ÇÄ: MultiquadraticPoly L ‚Ñì := computeInitialSumcheckPoly (‚Ñì:=‚Ñì) t m
  let H·µ¢ := fixFirstVariablesOfMQP (‚Ñì := ‚Ñì) (v := ‚ü®i, by admit /- proof elided -/
  ‚ü©)
    (H := H‚ÇÄ) (challenges := challenges)
  ‚ü®H·µ¢, by admit /- proof elided -/
  ‚ü©

instance inhabited [Inhabited R] : Inhabited (MlPolyEval R n) :=

def rtake (m : ‚Ñï) (h : m ‚â§ n) (pSpec : ProtocolSpec n) : ProtocolSpec m :=
  {dir := Fin.rtake m h pSpec.dir, ¬´Type¬ª := Fin.rtake m h pSpec.¬´Type¬ª}

abbrev Size.n_x : ‚Ñï := sz.n - sz.n_w

Algebra.id in Mathlib.Algebra.Algebra.Defs

@[simp]
def outerRelOut_Test : Set (OuterStmtOut_Test √ó Unit) :=
  setOf (fun ‚ü®‚ü®p, q, t, r‚ü©, _‚ü© => (p * q).eval r = t)

PowerSeries.mk in Mathlib.RingTheory.PowerSeries.Basic

protected def basis : F := sorry

def last_nonzero_prop {p : UniPoly R} (k : Fin p.size) : Prop :=
  p[k] ‚â† 0 ‚àß (‚àÄ j, (hj : j < p.size) ‚Üí j > k ‚Üí p[j] = 0)

class MvPolynomialLike (œÉ : outParam (Type u)) (R : outParam (Type v)) [CommSemiring R]
    (P : Type w) [CommSemiring P] extends Algebra R P where
   
  X : œÉ ‚Üí P

   
  eval‚ÇÇ {S : Type y} [CommSemiring S] {F : Type z} [FunEquiv F œÉ S] (f : R ‚Üí+* S) (g : F) : P ‚Üí+* S

   
  eval‚ÇÇ_C {S : Type y} [CommSemiring S] {F : Type z} [FunEquiv F œÉ S]
    (f : R ‚Üí+* S) (g : F) (r : R) : (eval‚ÇÇ f g) (_root_.algebraMap R P r) = f r

   
  eval‚ÇÇ_X {S : Type y} [CommSemiring S] {F : Type z} [FunEquiv F œÉ S]
    (f : R ‚Üí+* S) (g : F) (s : œÉ) : (eval‚ÇÇ f g) (X s) = g s

   
  eval‚ÇÇ_eq {S : Type y} [CommSemiring S] {F : Type z} [FunEquiv F œÉ S] (h : P ‚Üí+* S) :
    h = eval‚ÇÇ (h.comp (Algebra.ofId R P)) (fun s => h (X s) : F)

@[inline, specialize]
def add_raw (p q : UniPoly R) : UniPoly R :=
  let ‚ü®p', q'‚ü© := Array.matchSize p q 0
  .mk (Array.zipWith (¬∑ + ¬∑) p' q' )

@[inline, reducible]
def proj : OuterStmtIn √ó OuterWitIn ‚Üí InnerWitIn :=
  lens.toFunA

@[inline]
def neg [Neg R] (p : MlPoly R n) : MlPoly R n := p.map (fun a => -a)

LT.lt in Init.Prelude

def relHammingBall (C : Code Œπ F) (y : Œπ ‚Üí F) (r : ‚Ñù) : Code Œπ F :=
  { c | c ‚àà C ‚àß Code.relHammingDist y c ‚â§ r }

class SliceGE (coll : Type u) (start : Type v) (valid : outParam (coll ‚Üí start ‚Üí Prop))
    (subcoll : outParam ((xs : coll) ‚Üí (start : start) ‚Üí (h : valid xs start) ‚Üí Type w)) where
  sliceGE : (xs : coll) ‚Üí (start : start) ‚Üí (h : valid xs start) ‚Üí subcoll xs start h

inductive MemoryOp (Œπ : Type u) (Œ± : Œπ ‚Üí Type v) where
  | read (op : MemoryRead Œπ Œ±)
  | write (op : MemoryWrite Œπ Œ±)

@[inline, specialize, simp]
def reduction : Reduction oSpec Statement Witness Statement Witness !p[] := Reduction.id

instance [Zero T] [ToNat T] : DecidableEq (Cayley T) := fun a b =>
  if h : (‚Üëa : Nat) = (‚Üëb : Nat) then
    isTrue (by admit /- proof elided -/
      )
  else
    isFalse (fun heq => h (by admit /- proof elided -/
    ))

@[reducible, simp] def StmtOut : Type := R √ó R

@[reducible]
def CanonicalDuplexSponge (U : Type) [SpongeUnit U] [SpongeSize] :=
  DuplexSponge U (CanonicalSpongeState U)

@[reducible]
def sumcheckFoldOracleReduction :=
  let stmt : Fin (‚Ñì / œë - 1 + 1) ‚Üí Type :=
    fun i => Statement (L := L) (‚Ñì := ‚Ñì) Context ‚ü®i * œë, blockIdx_mul_œë_lt_‚Ñì_succ i‚ü©
  let oStmt := fun i: Fin (‚Ñì / œë - 1 + 1) =>
    OracleStatement ùîΩq Œ≤ œë ‚ü®i * œë, blockIdx_mul_œë_lt_‚Ñì_succ i‚ü©
  let wit := fun i: Fin (‚Ñì / œë - 1 + 1) =>
    Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì)
      ‚ü®i * œë, blockIdx_mul_œë_lt_‚Ñì_succ i‚ü©
  let nonLastBlocksOracleReduction :=
  OracleReduction.seqCompose (oSpec := []‚Çí)
      (Stmt := stmt)
      (OStmt := oStmt) (Wit := wit)
      (pSpec := fun (bIdx: Fin (‚Ñì / œë - 1)) => pSpecFullNonLastBlock ùîΩq Œ≤ bIdx)
      (R := fun bIdx => nonLastBlockOracleReduction (L:=L) ùîΩq Œ≤ (œë:=œë) (ùìë:=ùìë) (bIdx:=bIdx))

  let lastOracleReduction := lastBlockOracleReduction ùîΩq Œ≤ (œë:=œë) (ùìë:=ùìë)

  let coreInteractionOracleReduction: OracleReduction []‚Çí
    (StmtIn := Statement (L := L) (‚Ñì := ‚Ñì) Context 0)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë 0)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) 0)
    (StmtOut := Statement (L := L) (‚Ñì:=‚Ñì) Context (Fin.last ‚Ñì))
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) (Fin.last ‚Ñì))
    (pSpec := pSpecSumcheckFold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
     := by admit /- proof elided -/

noncomputable def foldProver :
  OracleProver []‚Çí
    (Statement F i.castSucc) (OracleStatement D x s i.castSucc) (Witness F s d i.castSucc.castSucc)
    (Statement F i.succ) (OracleStatement D x s i.succ) (Witness F s d i.castSucc.succ)
    (pSpec D x s i) where
  PrvState
  | 0 =>
    (Statement F i.castSucc √ó ((j : Fin (‚Üëi.castSucc + 1)) ‚Üí OracleStatement D x s i.castSucc j)) √ó
      Witness F s d i.castSucc.castSucc
  | _ =>
    (Statement F i.succ √ó ((j : Fin (‚Üëi.castSucc + 1)) ‚Üí OracleStatement D x s i.castSucc j)) √ó
      Witness F s d i.castSucc.succ

  input := id

  sendMessage
  | ‚ü®0, h‚ü© => nomatch h
  | ‚ü®1, _‚ü© => fun ‚ü®‚ü®chals, o‚ü©, p‚ü© =>
    pure ‚ü®fun x => p.1.eval x.1.1, ‚ü®‚ü®chals, o‚ü©, p‚ü©‚ü©

  receiveChallenge
  | ‚ü®0, _‚ü© => fun ‚ü®‚ü®chals, o‚ü©, p‚ü© => pure <|
    fun (Œ± : F) =>
      ‚ü®
        ‚ü®Fin.append chals (fun (_ : Fin 1) => Œ±), o‚ü©,
        ‚ü®p.1.foldNth (2 ^ (s i.castSucc).1) Œ±, witness_lift p.2‚ü©
      ‚ü©
  | ‚ü®1, h‚ü© => nomatch h

  output := fun ‚ü®‚ü®chals, o‚ü©, p‚ü© => pure <|
    ‚ü®
      ‚ü®
        chals,
        fun j =>
          if h : j.1 < i.1
          then by admit /- proof elided -/
      ‚ü©,
      p
    ‚ü©

def natCast_succ {k : ‚Ñï} (n : ‚Ñï) : natCast (k:=k) (n + 1) = natCast (k:=k) n + 1 :=

def verifier (i : Fin n) : Verifier oSpec
    (StatementRound R n i.castSucc √ó (‚àÄ i, OracleStatement R n deg i))
    (StatementRound R n i.succ √ó (‚àÄ i, OracleStatement R n deg i)) (pSpec R deg) :=
  (Simple.verifier R deg D oSpec).liftContext (oStmtLens R n deg D i)

def bitsToU (i : Fin r) (k : Fin (2 ^ i.val)) :
    AdditiveNTT.U (L := L) (ùîΩq := ùîΩq) (Œ≤ := Œ≤) i :=
  let val := (Finset.univ : Finset (Fin i)).sum fun j =>
    if (Nat.getBit (n := k.val) (k := j.val) == 1) then
      Œ≤ ‚ü®j, by admit /- proof elided -/
      ‚ü©
    else 0

  
  ‚ü®val, by admit /- proof elided -/
  ‚ü©

noncomputable def relayOracleVerifier (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
  OracleVerifier
    (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) Context i.succ)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (pSpec := pSpecRelay) where
  verify := fun stmtIn _ => pure stmtIn
  embed := ‚ü®fun j => by admit /- proof elided -/
  ‚ü©
  hEq := fun oracleIdx => by admit /- proof elided -/

CharP in Mathlib.Algebra.CharP.Defs

def reduction (i : Fin n) : Reduction oSpec
    ((StatementRound R n i.castSucc) √ó (‚àÄ i, OracleStatement R n deg i)) Unit
    ((StatementRound R n i.succ) √ó (‚àÄ i, OracleStatement R n deg i)) Unit (pSpec R deg) :=
  (Simple.reduction R deg D oSpec).liftContext (oCtxLens R n deg D i).toContext

instance : ‚àÄ i, SelectableType ((default : ProtocolSpec 0).Challenge i) := fun ‚ü®i, _‚ü© => Fin.elim0 i

AddCommGroup in Mathlib.Algebra.Group.Defs

abbrev eqPolynomial (r : œÉ ‚Üí R) : R[X œÉ] :=
  ‚àè i : œÉ, singleEqPolynomial (r i) (X i)

def testNTTBTF‚ÇÉ : Fin (2 ^ (2 + 2)) ‚Üí BTF‚ÇÉ :=

def finSum'FinEquiv' {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} : (i : Fin m) √ó Fin (n i) ‚âÉ Fin (vsum n) where
  toFun := fun ij => embedSum ij.1 ij.2
  invFun := splitSum
  left_inv := fun ij => splitSum_embedSum ij.1 ij.2
  right_inv := embedSum_splitSum

instance [VerifierFirst pSpec] : ‚àÄ i, OracleInterface (pSpec.Message i) := isEmptyElim

def last_nonzero (p : UniPoly R) : Option (Fin p.size) :=
  p.findIdxRev? (¬∑ != 0)

def Verifier.liftContext
    (lens : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut)
    (V : Verifier oSpec InnerStmtIn InnerStmtOut pSpec) :
      Verifier oSpec OuterStmtIn OuterStmtOut pSpec where
  verify := fun stmtIn transcript => do
    let innerStmtIn := lens.proj stmtIn
    let innerStmtOut ‚Üê V.verify innerStmtIn transcript
    return lens.lift stmtIn innerStmtOut

instance : EDist (n ‚Üí R) where
  edist := fun u v => hammingDist u v

def multiConstrainedCode
  (domain : Œπ ‚Ü™ F) [Smooth domain] (m t : ‚Ñï)
  (w : Fin t ‚Üí MvPolynomial (Fin (m + 1)) F)
  (œÉ : Fin t ‚Üí F) : Set (Œπ ‚Üí F) :=
    { f |
      ‚àÉ (h : f ‚àà smoothCode domain m),
        ‚àÄ i : Fin t, weightConstraint (mVdecode (‚ü®f, h‚ü© : smoothCode domain m)) (w i) (œÉ i)}

Fin.isValue in Lean.Meta.Tactic.Simp.BuiltinSimprocs.Fin

@[simp]
abbrev Statement.AfterFirstSumcheck : Type :=
  FirstSumcheckChallenge R pp √ó Statement.AfterFirstChallenge R pp

Module.finrank in Mathlib.LinearAlgebra.Dimension.Finrank

def implGroupEqOracle [BEq G] :
    QueryImpl (GroupEqOracle Œπ) (StateT (GroupValTable Œπ G) Option) where
  impl | query _ ‚ü®i, j‚ü© => fun table =>
    match table i, table j with
    | some g‚ÇÅ, some g‚ÇÇ => some (g‚ÇÅ == g‚ÇÇ, table)
    | _, _ => none

Set.imageFactorization in Mathlib.Data.Set.Operations

instance : Unique (ProtocolSpec 0) where
  default := empty
  uniq := fun ‚ü®_, _‚ü© => by admit /- proof elided -/

instance polyMonic (n : ‚Ñï) : Monic (poly n) := definingPoly_is_monic (Z n)

Fin.cons in Mathlib.Data.Fin.Tuple.Basic

def deriveTranscriptDSFS {Œπ : Type} {oSpec : OracleSpec Œπ} {StmtIn : Type}
    (stmtIn : StmtIn) (messages : pSpec.Messages) :
    OracleComp (oSpec ++‚Çí duplexSpongeChallengeOracle StmtIn U)
      (CanonicalDuplexSponge U √ó pSpec.FullTranscript) := do
  let sponge ‚Üê liftM (DuplexSponge.start stmtIn)
  deriveTranscriptDSFSAux sponge messages (Fin.last n)

def ofMvPolynomialDeg1 (p : R‚¶É‚â§ 1‚¶Ñ[X Fin n]) : MlPoly R n :=
  Vector.ofFn (fun i : Fin (2 ^ n) => p.val.coeff (monomialOfNat i))

HasSum in Mathlib.Topology.Algebra.InfiniteSum.Defs

def deterministicMillerRabin (n : ‚Ñï) : Bool := Id.run do
  if n ‚â§ 2 ‚à® n % 2 = 0 then
    return n = 2

  let ‚ü®s, d‚ü© := factorOutTwos (n - 1)
  for a in millerRabinBases do
    if a % n == 0 then
      continue

    let mut x := powMod a d n
    if x = 1 ‚à® x = n - 1 then
      continue

    for _ in [0:s] do
      x := (x * x) % n
      if x == n - 1 ‚à® x ‚â§ 1 then
        break
    if x ‚â† n - 1 then
      return false

  return true

def Verifier.StateFunction.liftContext
    {œÉ : Type} {init : ProbComp œÉ} {impl : QueryImpl oSpec (StateT œÉ ProbComp)}
    (lens : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut)
    (V : Verifier oSpec InnerStmtIn InnerStmtOut pSpec)
    (outerLangIn : Set OuterStmtIn) (outerLangOut : Set OuterStmtOut)
    (innerLangIn : Set InnerStmtIn) (innerLangOut : Set InnerStmtOut)
    [lensSound : lens.IsSound outerLangIn outerLangOut innerLangIn innerLangOut
      (V.compatStatement lens)]
    (stF : V.StateFunction init impl innerLangIn innerLangOut) :
      (V.liftContext lens).StateFunction init impl outerLangIn outerLangOut
where
  toFun := fun m outerStmtIn transcript =>
    stF m (lens.proj outerStmtIn) transcript
  toFun_empty := fun stmt => by admit /- proof elided -/

def coeffs [DecidableEq F] (f : F[X][Y]) : Finset F[X] := f.support.image f.coeff

def three : ChurchNat Œ± := succ two

instance : ‚àÄ j, OracleInterface ((pSpec D x l).Message j) := fun j =>
  match j with
  | ‚ü®0, h‚ü© => nomatch h

  inductive UnverifiedPrattPart : Type
    | prime : (p : ‚Ñï) ‚Üí (k : ‚Ñï) ‚Üí (hp : UnverifiedPrattCertificate p) ‚Üí UnverifiedPrattPart
    | split : UnverifiedPrattPart ‚Üí UnverifiedPrattPart ‚Üí UnverifiedPrattPart
  deriving Repr

noncomputable def commitOracleVerifier (i : Fin ‚Ñì) (hCR : isCommitmentRound ‚Ñì œë i) :
  OracleVerifier
    (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) Context i.succ)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (O‚Çò := fun i => by admit /- proof elided -/
    )
    
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (pSpec := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) where

  
  
  verify := fun stmtIn pSpecChallenges => do
    pure stmtIn

  embed := ‚ü®fun j => by admit /- proof elided -/
  ‚ü©
  hEq := fun oracleIdx => by admit /- proof elided -/

def leftpad {m : ‚Ñï} {Œ± : Sort*} (n : ‚Ñï) (a : Œ±) (v : Fin m ‚Üí Œ±) : Fin n ‚Üí Œ± :=
  fun i => if h : n - m ‚â§ i then v ‚ü®i - (n - m), by admit /- proof elided -/
  ‚ü© else a

@[app_unexpander Fin.dcons]
def dconsUnexpander : Lean.PrettyPrinter.Unexpander
  | `($_ $term !d[$term2, $terms,*]) => `(!d[$term, $term2, $terms,*])
  | `($_ $term !d[$term2]) => `(!d[$term, $term2])
  | `($_ $term !d[]) => `(!d[$term])
  | _ => throw ()

instance {_ : Empty} : OracleInterface (Unit) := OracleInterface.instDefault

def Option.doubleBind_v2 {Œ± Œ≤ Œ≥ : Type} (f : Œ± ‚Üí Œ≤ ‚Üí Option Œ≥)
    (x : Option Œ±) (y : Option Œ≤) : Option Œ≥ := do
  let a ‚Üê x
  let b ‚Üê y
  f a b

commit in VCVio.CryptoFoundations.SigmaAlg

structure HashStateWithInstructions (U : Type) [SpongeUnit U] (H : Type*)
    [DuplexSpongeInterface U H] where
   
  ds : H
   
  stack : Array DomainSeparator.Op
deriving Inhabited, DecidableEq, Repr

def duplexSpongeToBasicFSQueryImpl :
    QueryImpl (duplexSpongeChallengeOracle StmtIn U)
      (OracleComp (fsChallengeOracle StmtIn pSpec)) :=
  sorry

alias d2SQueryImpl := duplexSpongeToBasicFSQueryImpl

instance (k : ‚Ñï) : NeZero (2^k) :=

Polynomial.eval‚ÇÇ in Mathlib.Algebra.Polynomial.Eval.Defs

noncomputable def qMap_total_fiber
    
      (i : Fin r) (steps : ‚Ñï) (h_i_add_steps : i.val + steps < ‚Ñì + ùì°)
        (y : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i.val + steps, by admit /- proof elided -/
        ‚ü©)) :
    Fin (2 ^ steps) ‚Üí sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i :=
  if h_steps : steps = 0 then by
    
    subst h_steps
    simp only [add_zero, Fin.eta] at y
    exact fun _ => y
  else by
    
    let basis_y := sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i+steps,by admit /- proof elided -/
    ‚ü©) (by admit /- proof elided -/
    )
    let y_coeffs : Fin (‚Ñì + ùì° - (‚Üëi + steps)) ‚Üí‚ÇÄ ùîΩq := basis_y.repr y

    let basis_x := sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i, by admit /- proof elided -/
    ‚ü© (by admit /- proof elided -/
    )
    exact fun elementIdx => by admit /- proof elided -/

class IsKnowledgeSound (relIn : Set (StmtIn √ó WitIn)) (relOut : Set (StmtOut √ó WitOut))
    (verifier : Verifier oSpec StmtIn StmtOut pSpec) where
  knowledgeError : ‚Ñù‚â•0
  is_knowledge_sound : knowledgeSoundness init impl relIn relOut verifier knowledgeError

protected def cast (pSpec : ProtocolSpec n‚ÇÅ) : ProtocolSpec n‚ÇÇ :=
  ‚ü®pSpec.dir ‚àò (Fin.cast hn.symm), pSpec.¬´Type¬ª ‚àò (Fin.cast hn.symm)‚ü©

Finsupp.onFinset in Mathlib.Data.Finsupp.Defs

instance : Fact (Nat.Prime scalarFieldSize) := ‚ü®ScalarField_is_prime‚ü©

Polynomial.natDegree in Mathlib.Algebra.Polynomial.Degree.Definitions

instance {s} : Functor (fun Œ± => FullData Œ± s) where
  map f x := x.map f

Nat.mod in Init.Prelude

Polynomial.div in Mathlib.Algebra.Polynomial.FieldDivision

Fintype.equivFin in Mathlib.Data.Fintype.EquivFin

instance : LE AssocNat where
  le a b := a 0 ‚â§ b 0

WithBot.addMonoidWithOne in Mathlib.Algebra.Order.Monoid.Unbundled.WithTop

@[reducible, simp] def OStmtOut := fun _ : Fin 1 => OStatement

Invertible in Mathlib.Algebra.Group.Invertible.Defs

Set.fintypeMemFinset in Mathlib.Data.Set.Finite.Basic

instance : IsCyclic G :=
  isCyclic_of_prime_card PrimeOrder.hCard

instance instDCastSigmaSigma {Œ± : Type*} {Œ≤ : Œ± ‚Üí Type*} {Œ≥ : (a : Œ±) ‚Üí Œ≤ a ‚Üí Type*}
    {Œ¥ : (a : Œ±) ‚Üí (b : Œ≤ a) ‚Üí Œ≥ a b ‚Üí Type*}
    [DCast Œ± Œ≤] [DCast‚ÇÇ Œ± Œ≤ Œ≥] [DCast‚ÇÉ Œ± Œ≤ Œ≥ Œ¥] :
    DCast ((a : Œ±) √ó (b : Œ≤ a) √ó Œ≥ a b) (fun a => Œ¥ a.1 a.2.1 a.2.2) where
  dcast hc d := dcast‚ÇÉ (by admit /- proof elided -/
  ) (by admit /- proof elided -/
  ) (by admit /- proof elided -/
  ) d
  dcast_id := by admit /- proof elided -/

def neg {k : ‚Ñï} (x : ConcreteBTField k) : ConcreteBTField k := x

structure PowTwoRepr where
  two_exp : ‚Ñï
  odd_part : ‚Ñï

class HasSize (Œ± : Type*) (Œ≤ : Type*) where
  size : Nat
  toFun : Œ± ‚Ü™ Vector Œ≤ size

structure LookaheadSequenceFamily
    (trace : QueryLog (forwardPermutationOracle (CanonicalSpongeState U)))
    (state : CanonicalSpongeState U) (i : pSpec.ChallengeIdx) where
   
  seqFamily : Finset (LookaheadSequence trace state)
   
  maximality : ‚àÄ s ‚àà seqFamily, ‚àÄ s' ‚àà seqFamily,
    ¬¨ (s.inputState ‚äÜ s'.inputState) ‚à® ¬¨ (s'.outputState ‚äÜ s.outputState)
   
  length_le_challengeSize : ‚àÄ s ‚àà seqFamily, s.inputState.length ‚â§ challengeSize i

RingHom.toAlgebra in Mathlib.Algebra.Algebra.Defs

def regularElms (H : F[X][Y]) : Type :=
  {a : ùïÉ H // ‚àÉ b : ùí™ H, a = embeddingOfùí™IntoùïÉ _ b}

@[simp]
def evalDomain (i : ‚Ñï) : Set FÀ£ :=
  (x ^ (2 ^ i)) ‚Ä¢ (Domain.evalDomain D i)

abbrev CoeffVecSpace (L : Type u) (‚Ñì : Nat) := Fin (2^‚Ñì) ‚Üí L

noncomputable def oddPart (f : Polynomial F) : Polynomial F :=
    C (2‚Åª¬π : F) * (f - f.comp (-X)) /‚Çò X

def rightpadPowerOfTwo (unit : Œ±) (a : Array Œ±) : Array Œ± :=
  a.rightpad (2 ^ (Nat.clog 2 a.size)) unit

instance (n : AssocNat) : DecidableEq (AssocFin n) :=

Polynomial.IsRoot in Mathlib.Algebra.Polynomial.Eval.Defs

@[reducible, inline, specialize, simp]
def ChallengeIdx (vPSpec : VectorSpec n) := {i : Fin n // vPSpec.dir i = .V_to_P}

instance (k : ‚Ñï) : HMul (ConcreteBTField k) (ConcreteBTField k) (ConcreteBTField k)
  where hMul := concrete_mul

NatPow in Init.Prelude

def rbrKnowledgeSoundness
    (relIn : Set ((StmtIn √ó ‚àÄ i, OStmtIn i) √ó WitIn))
    (relOut : Set ((StmtOut √ó ‚àÄ i, OStmtOut i) √ó WitOut))
    (verifier : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec)
    (rbrKnowledgeError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) : Prop :=
  verifier.toVerifier.rbrKnowledgeSoundness init impl relIn relOut rbrKnowledgeError

AdjoinRoot.of in Mathlib.RingTheory.AdjoinRoot

def append {Œπ‚ÇÅ : Type u} {T‚ÇÅ : Œπ‚ÇÅ ‚Üí Type v} [‚àÄ i, OracleInterface (T‚ÇÅ i)]
    {Œπ‚ÇÇ : Type u} {T‚ÇÇ : Œπ‚ÇÇ ‚Üí Type v} [‚àÄ i, OracleInterface (T‚ÇÇ i)] : OracleSpec (Œπ‚ÇÅ ‚äï Œπ‚ÇÇ) :=
  [Sum.rec T‚ÇÅ T‚ÇÇ]‚Çí

noncomputable def basisVectors (‚Ñì : Nat) (h_‚Ñì : ‚Ñì ‚â§ r) :
  Fin (2 ^ ‚Ñì) ‚Üí L‚¶É<2^‚Ñì‚¶Ñ[X] :=
  fun j => ‚ü®X‚±º ùîΩq Œ≤ ‚Ñì h_‚Ñì j, by admit /- proof elided -/
  ‚ü©

def smoothCode
  (domain : Œπ ‚Ü™ F) [Smooth domain]
  (m : ‚Ñï) : Submodule F (Œπ ‚Üí F) := ReedSolomon.code domain (2^m)

@[reducible, inline]
def ùï´ {R} {sz} (stmt : Statement R sz) (wit : Witness R sz) : Fin sz.n ‚Üí R :=
  Fin.append stmt wit ‚àò Fin.cast (by admit /- proof elided -/
  )

instance [Zero T] [ToNat T] : DecidableRel (@LT.lt (Cayley T) _) := fun a b =>
  Nat.decLt (‚Üëa) (‚Üëb)

private def sum_choose_K_i (B : Finset (Fin n ‚Üí F)) (i : Fin n) : ‚Ñö :=
  ‚àë (Œ± : F), choose_2 (K B i Œ±)

@[inline] def succ (a : Cayley T) : Cayley T := add a one

@[simp]
abbrev Witness.AfterFirstChallenge : Type := Unit

Polynomial.map in Mathlib.Algebra.Polynomial.Eval.Defs

def isRead : MemoryOp Œπ Œ± ‚Üí Prop
  | read _ => True
  | _ => False

One in Init.Prelude

noncomputable def foldOracleVerifier (i : Fin ‚Ñì) :
  OracleVerifier
    (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) Context i.castSucc)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (O‚Çò := fun i => by admit /- proof elided -/
    )
    
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (pSpec := pSpecFold (L := L)) where

  
  
  verify := fun stmtIn pSpecChallenges => do
    
    let h_i : L‚¶É‚â§ 2‚¶Ñ[X] ‚Üê query (spec := [(pSpecFold (L := L)).Message]‚Çí)
      ‚ü®0, rfl‚ü© ()

    
    let sumcheck_check := h_i.val.eval 0 + h_i.val.eval 1 = stmtIn.sumcheck_target
    unless sumcheck_check do
      
      let dummyStmt : Statement (L := L) Context i.succ := {
        ctx := stmtIn.ctx,
        sumcheck_target := 0,
        challenges := Fin.snoc stmtIn.challenges 0
      }
      return dummyStmt

    
    let r_i' : L := pSpecChallenges ‚ü®1, rfl‚ü©  

    
    let stmtOut : Statement (L := L) Context i.succ := {
      ctx := stmtIn.ctx,
      sumcheck_target := h_i.val.eval r_i',
      challenges := Fin.snoc stmtIn.challenges r_i'
    }

    pure stmtOut
  embed := ‚ü®fun j => by admit /- proof elided -/
  ‚ü©
  hEq := fun oracleIdx => by admit /- proof elided -/

Vector in Init.Data.Vector.Basic

def outOfOrderPerm : Prop :=
  
  trace = [] ‚àß state = 0

alias E_time_p := outOfOrderPerm

def Œ∂ (R : F[X][X][Y]) (x‚ÇÄ : F) (H : F[X][Y]) [H_irreducible : Fact (Irreducible H)] : ùïÉ H :=
  let W  : ùïÉ H := liftToFunctionField (H.leadingCoeff);
  let T : ùïÉ H := liftToFunctionField (Polynomial.X);
    Polynomial.eval‚ÇÇ liftToFunctionField (T / W)
      (Bivariate.evalX (Polynomial.C x‚ÇÄ) R.derivative)

instance : ‚àÄ i, SelectableType ((pSpecNonLastBlocks ùîΩq Œ≤ (œë:=œë)
  (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).Challenge i) := instSelectableTypeChallengeSeqCompose

noncomputable def foldingDistRange
   (degree : ‚Ñï) [Fintype Œπ] [Nonempty Œπ] (œÜ : Œπ ‚Ü™ F) (f : Œπ ‚Üí F) : ‚Ñù :=
    let C : Set (Œπ ‚Üí F) := code œÜ degree
    min Œ¥·µ£(f, C) (1 - Bstar (LinearCode.rate (code œÜ degree)))

MonadLiftT in Init.Prelude

Equiv.optionCongr in Mathlib.Logic.Equiv.Option

def computableNTTStage [Fact (LinearIndependent ùîΩq Œ≤)]
  (i : Fin ‚Ñì) (b : Fin (2 ^ (‚Ñì + R_rate)) ‚Üí L) : Fin (2^(‚Ñì + R_rate)) ‚Üí L :=
  have h_2_pow_i_lt_2_pow_‚Ñì_add_R_rate: 2^i.val < 2^(‚Ñì + R_rate) := by admit /- proof elided -/

AdjoinRoot.powerBasis' in Mathlib.RingTheory.AdjoinRoot

def factorOutTwos (n : ‚Ñï) : PowTwoRepr := Id.run do
  let mut two_exp := 0
  let mut odd_part := n

  while odd_part % 2 = 0 do
    two_exp := two_exp + 1
    odd_part := odd_part / 2

  return ‚ü®two_exp, odd_part‚ü©

def MLE (evals : (œÉ ‚Üí Fin 2) ‚Üí R) : MvPolynomial œÉ R :=
    ‚àë x : œÉ ‚Üí Fin 2, (eqPolynomial (x : œÉ ‚Üí R)) * C (evals x)

protected def cast (T : FullTranscript pSpec‚ÇÅ) :
    FullTranscript pSpec‚ÇÇ :=
  Transcript.cast (k := Fin.last n‚ÇÅ) (l := Fin.last n‚ÇÇ) hn hn hSpec T

@[inline] def lagrangeToMonoLevel {n : ‚Ñï} (j : Fin n) : Vector R (2 ^ n) ‚Üí Vector R (2 ^ n) :=
  fun v =>
    let stride : ‚Ñï := 2 ^ j.val  
    Vector.ofFn (fun i : Fin (2 ^ n) =>
      if (BitVec.ofFin i).getLsb j then
        v[i] - v[i - stride]'(Nat.sub_lt_of_lt i.isLt)
      else
        v[i])

instance : OracleInterfaces (vPSpec.toProtocolSpec A) where
  oracleInterfaces := fun _ => some OracleInterface.instVector

class IsSecure
    (relation : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (Œµ_rbr : vPSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0)
    (vectorIOP : VectorIOP Statement OStatement Witness vPSpec A) where

   
  is_complete : vectorIOP.perfectCompleteness (pure ()) ‚ü®isEmptyElim‚ü© relation

   
  is_rbr_knowledge_sound :
    OracleProof.rbrKnowledgeSoundness (pure ()) ‚ü®isEmptyElim‚ü© relation vectorIOP.verifier Œµ_rbr

MonadLift.monadLift in Init.Prelude

@[to_additive existing]
def partialProd {Œ± : Type*} [Monoid Œ±] (l : List Œ±) : List Œ± :=
  [1] ++ match l with
  | [] => []
  | a :: l' => (partialProd l').map (a * ¬∑)

MvPolynomial.isEmptyAlgEquiv in Mathlib.Algebra.MvPolynomial.Equiv

instance : HasSucc (Cayley T) where
  succ' := succ

def finUInt16Equiv : Fin (2 ^ 16) ‚âÉ UInt16 where
  toFun := fun i => UInt16.ofFin i
  invFun := fun u => u.toFin
  left_inv _ := rfl
  right_inv _ := rfl

def sumcheckFoldKnowledgeError := fun j : (pSpecSumcheckFold ùîΩq Œ≤ (œë:=œë)
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).ChallengeIdx =>
    if hj: (j.val % NBlockMessages (œë:=œë)) % 2 = 1 then
      foldKnowledgeError ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        ‚ü®j / NBlockMessages (œë:=œë) * œë + ((j % NBlockMessages (œë:=œë)) / 2 + 1), by admit /- proof elided -/
        ‚ü© ‚ü®1, rfl‚ü©
    else 0 

instance : Fact (Nat.Prime scalarFieldSize) := ‚ü®ScalarField_is_prime‚ü©

instance instTestLensComplete : testLens.IsComplete
      outerRelIn_Test innerRelIn_Test outerRelOut_Test innerRelOut_Test
      (fun ‚ü®‚ü®p, q, _‚ü©, _‚ü© ‚ü®‚ü®f, _‚ü©, _‚ü© => p * q = f) where
  proj_complete := fun ‚ü®p, q, t‚ü© () hRelIn => by admit /- proof elided -/

@[reducible]
def messageLength (vPSpec : VectorSpec n) (i : MessageIdx vPSpec) : Nat := vPSpec.length i

def BerlekampWelchMatrix
  (e k : ‚Ñï)
  (œâs f : Fin n ‚Üí F) : Matrix (Fin n) (Fin (2 * e + k)) F :=
  Matrix.of fun i j =>
    let Œ±·µ¢ := œâs i
    if ‚Üëj < e then -Rhs j.1 œâs f i else -Œ±·µ¢^(j - e)

@[reducible]
def scalarFieldSize : Nat :=
  8444461749428370424248824938781546531375899335154063827935233455917409239041

instance [Inhabited OuterWitOut]
    [instKS : lens.IsKnowledgeSound
                outerRelIn innerRelIn
                outerRelOut innerRelOut
                compatStmt (fun _ _ => True)] :
    lens.stmt.IsSound
      outerRelIn.language outerRelOut.language
      innerRelIn.language innerRelOut.language
      compatStmt where
  proj_sound := fun outerStmtIn hCompat => by admit /- proof elided -/

def LeafData.map {Œ± Œ≤ : Type} (f : Œ± ‚Üí Œ≤) {s : Skeleton}
    (tree : LeafData Œ± s) : LeafData Œ≤ s :=
  match tree with
  | LeafData.leaf value => LeafData.leaf (f value)
  | LeafData.internal left right =>
    LeafData.internal (left.map f) (right.map f)

def statelessOracle (baseSpec : OracleSpec Œπ‚Çú) (spec : OracleSpec Œπ)
    (f : (i : Œπ) ‚Üí spec.domain i ‚Üí spec.range i) :
    SimOracle.Stateless (baseSpec ++‚Çí spec) baseSpec where
  impl
  | query (.inl i) t => query i t
  | query (.inr i) t => pure (f i t)

def fflatten {A : Sort u} {F : A ‚Üí Sort v} {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï}
    {Œ± : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí A}
    (v : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí F (Œ± i j)) : (k : Fin (vsum n)) ‚Üí F (Fin.vflatten Œ± k) :=
  match m with
  | 0 => !h[]
  | _ + 1 => fappend (v 0) (fflatten (fun i => v i.succ))

@[reducible, simp] def StmtIn : Type := R

@[reducible, simp] def StmtOut := Query OStatement √ó Response OStatement

NatCast in Init.Data.Cast

def ExtractabilityAdversary (oSpec : OracleSpec Œπ) (Data Commitment AuxState : Type)
    [O : OracleInterface Data] :=
  OracleComp oSpec (Commitment √ó O.Query √ó O.Response √ó AuxState)

def JohnsonConditionWeak (B : Finset (Fin n ‚Üí F)) (e : ‚Ñï) : Prop :=
  let d := sInf { d | ‚àÉ u ‚àà B, ‚àÉ v ‚àà B, u ‚â† v ‚àß hammingDist u v = d }
  let q : ‚Ñö := Fintype.card F
  (e : ‚Ñö) / n < J q (d / n)

def commitKStateProp (i : Fin ‚Ñì) (m : Fin (1 + 1))
  (stmtIn : Statement (L := L) Context i.succ)
  (witMid : Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
  (oStmtIn : (i_1 : Fin (toOutCodewordsCount ‚Ñì œë i.castSucc)) ‚Üí
    OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc i_1)
  : Prop :=

  match m with
  | ‚ü®0, _‚ü© => 
    masterKStateProp (mp := mp) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (stmtIdx := i.succ) (oracleIdx := i.castSucc)
      (h_le := by admit /- proof elided -/
      )
      (stmt := stmtIn) (wit := witMid) (oStmt := oStmtIn)
      (localChecks := True)
  | ‚ü®1, _‚ü© => 
    let ‚ü®_, stmtOut, oStmtOut, witOut‚ü© := getCommitProverFinalOutput ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i ‚ü®stmtIn, oStmtIn, witMid‚ü©
    masterKStateProp (mp := mp) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (stmtIdx := i.succ) (oracleIdx := i.succ)
      (h_le := le_refl _)
      (stmt := stmtOut) (wit := witOut) (oStmt := oStmtOut)
      (localChecks := True)

noncomputable def fold_k_set
  {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F} {k m : ‚Ñï}
  [‚àÄ j : ‚Ñï, Neg (indexPowT S œÜ j)]
  (set : Set ((indexPowT S œÜ 0) ‚Üí F)) (Œ±s : Fin k ‚Üí F) (hk : k ‚â§ m): Set (indexPowT S œÜ k ‚Üí F) :=
    { g | ‚àÉ f ‚àà set, g = fold_k f Œ±s hk}

def relation (cs : ConstraintSystem ùì° numWires numGates) (‚Ñì : ‚Ñï) (h‚Ñì : ‚Ñì ‚â§ numWires) :
    (publicInputs : Fin ‚Ñì ‚Üí ùì°) ‚Üí (privateWitness : Fin (numWires - ‚Ñì) ‚Üí ùì°) ‚Üí Prop :=
  fun (x : Fin ‚Ñì ‚Üí ùì°) (œâ : Fin (numWires - ‚Ñì) ‚Üí ùì°) =>
    let combined := Fin.append x œâ ‚àò Fin.cast (by admit /- proof elided -/
    )
    cs.accepts combined

class PolynomialLike (R : outParam (Type u)) [CommSemiring R] (P : Type v) [CommSemiring P]
    extends Algebra R P where

   
  X {R} : P

   
  eval‚ÇÇ {S : Type w} [CommSemiring S] (f : R ‚Üí+* S) (x : S) : P ‚Üí+* S

  eval‚ÇÇ_C {r : R} {S : Type w} [CommSemiring S] (f : R ‚Üí+* S) (x : S) :
    (eval‚ÇÇ f x) (_root_.algebraMap R P r) = f r

  eval‚ÇÇ_X {S : Type w} [CommSemiring S] (f : R ‚Üí+* S) (x : S) : eval‚ÇÇ f x X = x

  eval‚ÇÇ_eq {S : Type w} [CommSemiring S] (g : P ‚Üí+* S) :
    g = eval‚ÇÇ (g.comp (Algebra.ofId R P)) (g X)

partial def verifyCertificate (n' : Q(‚Ñï)) (n : ‚Ñï) :
    UnverifiedPrattCertificate n ‚Üí MetaM Q(Nat.Prime $n')
  | .knownPrime n => verifySmallPrime n'
  | .of n a part => do
      let cert ‚Üê generateCertificate n' n a part
      return q(PrattCertificate.out $cert)
  where
  generateCertificate (n' : Q(‚Ñï)) (_ : ‚Ñï) (a : ‚Ñï) (part : UnverifiedPrattPart) :
      MetaM Q(PrattCertificate $n') := do
    have alit : Q(‚Ñï) := mkRawNatLit a
    let ‚ü®a', pa'‚ü© ‚Üê mkOfNat q(ZMod $n') q(instAddMonoidWithOne) alit
    let hpow : Q($a' ^ ($n' - 1) = 1) ‚Üê verifyEqOne n' alit a' pa'
    let result ‚Üê generatePart n' a' alit pa' part
    haveI : $(result.1) =Q $n' - 1 := ‚ü®‚ü©
    return q(PrattCertificate.mk $a' $hpow $(result.2))
  generatePart (n' : Q(‚Ñï)) (a : Q(ZMod $n')) (a' : Q(‚Ñï)) (pa' : Q(($a' : ZMod $n') = $a)) :
      UnverifiedPrattPart ‚Üí MetaM ((nn : Q(‚Ñï)) √ó Q(PrattPart $n' $a $nn))
    | .prime p k hp => do
      
      have plit : Q(‚Ñï) := mkRawNatLit p
      let inner ‚Üê verifyCertificate plit p hp
      have pklit : Q(‚Ñï) := mkRawNatLit (p ^ k)
      have klit : Q(‚Ñï) := mkRawNatLit k
      let hpow ‚Üê verifyNeOne n' a' plit a pa'
      haveI : $pklit =Q $plit ^ $klit := ‚ü®‚ü©
      return ‚ü®pklit, q(PrattPart.prime $plit $klit _ $inner $hpow (.refl _))‚ü©
    | .split left right => do
      let ‚ü®nleft, pleft‚ü© ‚Üê generatePart n' a a' pa' left
      let ‚ü®nright, pright‚ü© ‚Üê generatePart n' a a' pa' right
      
      have nn : Q(‚Ñï) := mkRawNatLit (nleft.natLit! * nright.natLit!)
      haveI : $nn =Q $nleft * $nright := ‚ü®‚ü©
      return ‚ü®nn, q(PrattPart.split $nleft $nright $pleft $pright (.refl _))‚ü©

@[reducible, inline, specialize]
def messages (transcript : FullTranscript pSpec) (i : MessageIdx pSpec) :=
  transcript i.val

Int.ofNat in Init.Data.Int.Basic

Module.Basis.baseChange in Mathlib.LinearAlgebra.TensorProduct.Basis

Infinite in Mathlib.Data.Finite.Defs

@[simp]
abbrev Witness.AfterSecondSumcheck : Type := Unit

Finset.Icc in Mathlib.Order.Interval.Finset.Defs

@[inline] def ofNat' (k : Nat) : AssocNat :=
  ‚ü®fun m => k + m, fun m => Nat.add_assoc k m 1‚ü©

noncomputable def S_Œ≤ {H : F[X][Y]} (Œ≤ : ùí™ H) : Set F :=
  {z : F | ‚àÉ root : rationalRoot (H_tilde' H) z, (œÄ_z z root) Œ≤ = 0}

def pointToIterateQuotientIndex (i : Fin (‚Ñì + 1)) (steps : ‚Ñï) (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
    (x : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i, by omega‚ü©)) : Fin (2 ^ steps) :=

def Function.extendDomain {Œ± Œ≤ : Type*} [DecidableEq Œ±] [Zero Œ≤] {s : Finset Œ±}
    (f : (x : Œ±) ‚Üí (x ‚àà s) ‚Üí Œ≤) : Œ± ‚Üí Œ≤ :=
  fun x ‚Ü¶ if hx : x ‚àà s then f x hx else 0

def getNextOracle (i : Fin (‚Ñì + 1))
    (oStmt : ‚àÄ j, (OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i) j)
    (j : Fin (toOutCodewordsCount ‚Ñì œë i)) (hj : j.val + 1 < toOutCodewordsCount ‚Ñì œë i) :
    OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®j.val * œë + œë, by
    apply Nat.lt_succ_of_le;
    let h_k_next_le_i := oracle_block_k_next_le (‚Ñì := ‚Ñì) (œë := œë) (i := i) (j := j) (hj := hj)
    calc _ ‚â§ i.val := h_k_next_le_i
      _ ‚â§ ‚Ñì := Fin.is_le i
  ‚ü© :=

Lagrange.basis in Mathlib.LinearAlgebra.Lagrange

Membership.mem in Init.Prelude

def finIdxOfIfTrue [BEq Œ±] [LawfulBEq Œ±] (a : Œ±) (l : List Œ±) (h : a ‚àà l) : Fin l.length :=
  ‚ü®List.idxOf' a l, by admit /- proof elided -/
  ‚ü©

@[reducible, inline, specialize]
def UniPoly (R : Type*) := Array R

OracleComp.simulateQ in VCVio.OracleComp.SimSemantics.SimulateQ

def canonicalAlgMap (k : ‚Ñï) := concreteCanonicalEmbedding (k:=k)
  (prevBTFieldProps:= ((getBTFResult k).toConcreteBTFieldProps))
  (curBTFieldProps:= ((getBTFResult (k + 1)).toConcreteBTFieldProps))

instance : Field ScalarField := ZMod.instField scalarFieldSize

def srSoundnessGame (P : Prover.StateRestoration.Soundness oSpec StmtIn pSpec) :
    OracleComp (oSpec ++‚Çí (srChallengeOracle StmtIn pSpec))
      (pSpec.FullTranscript √ó StmtIn) := do
  let ‚ü®stmtIn, messages‚ü© ‚Üê P
  let transcript ‚Üê messages.deriveTranscriptSR stmtIn
  return ‚ü®transcript, stmtIn‚ü©

instance : DFunEquiv (‚àÄ a : Œ±, Œ≤ a) Œ± Œ≤ where
  equiv := Equiv.refl _

right_inv in ToMathlib.Control.Monad.Equiv

Algebra in Mathlib.Algebra.Algebra.Defs

def ratchetUnchecked [Permute C] (sponge : DuplexSponge U C) : DuplexSponge U C :=
  simulateQ' forwardPermutationOracleImpl (ratchet sponge) (by admit /- proof elided -/
  )

List.splitBy in Init.Data.List.Basic

def InputStatement := R

def join_via_add_smul (k : ‚Ñï) (h_pos : k > 0) (hi_btf lo_btf : ConcreteBTField (k - 1)) :
    ConcreteBTField k :=

def OracleSpec.proverOracle (StmtIn : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n) :
    OracleSpec pSpec.MessageIdx :=
  fun i => (StmtIn √ó pSpec.Transcript i.val.castSucc, pSpec.Message i)

@[simp]
def finRangeTo {k : ‚Ñï} (i : ‚Ñï) : Finset (Fin k) :=
  (List.take i (List.finRange k)).toFinset

def foldStepRelOutProp (i : Fin ‚Ñì)
    (input : (Statement (L := L) Context i.succ √ó
      (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j)) √ó
      Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ) : Prop :=
  let stmt := input.1.1
  let oStmt := input.1.2
  let wit := input.2
  masterKStateProp (mp := mp) (ùìë := ùìë) ùîΩq Œ≤
    (stmtIdx := i.succ) (oracleIdx := i.castSucc)
    (h_le := Nat.le_of_lt (Fin.castSucc_lt_succ i)) stmt wit oStmt (localChecks := True)

@[inline, specialize]
def neg {R : Type*} [Ring R] [BEq R] (p : QuotientUniPoly R) : QuotientUniPoly R :=
  Quotient.lift neg_descending neg_descends p

noncomputable def batchProver :
  OracleProver []‚Çí
    Unit (OracleStatement D x m) (Witness F s d m)
    ((Fin m ‚Üí F) √ó Fri.Spec.Statement F (0 : Fin (k + 1)))
      (OracleStatement D x m) (Fri.Spec.Witness F s d (0 : Fin (k + 2)))
    (batchSpec F m) where
  PrvState
  | 0 => (‚àÄj, OracleStatement D x m j) √ó Witness F s d m
  | 1 => (Fin m ‚Üí F) √ó (‚àÄj, OracleStatement D x m j) √ó Fri.Spec.Witness F s d (0 : Fin (k + 2))

  input := fun i => ‚ü®i.1.2, i.2‚ü©

  sendMessage
  | ‚ü®0, h‚ü© => nomatch h

  receiveChallenge
  | ‚ü®0, _‚ü© => fun ‚ü®os, ps‚ü© => pure <|
    fun (cs : Fin m ‚Üí F) =>
      ‚ü®cs, os,
        ‚ü®
          ps 0 + ‚àë i, Polynomial.C (cs i) * (ps i.succ).1,
          by admit /- proof elided -/
        ‚ü©
      ‚ü©

  output := fun ‚ü®cs, os, p‚ü© => pure <|
    ‚ü®‚ü®‚ü®cs, Fin.elim0‚ü©, os‚ü©, p‚ü©

instance : IsEmpty (OracleQuery []‚Çí Œ±) where
  false := by admit /- proof elided -/

def finSuccEquivNth' (i : Fin n) : Fin n ‚âÉ Option (Fin (n - 1)) :=

instance polyIrreducible (n : ‚Ñï) : Irreducible (poly n) := (BinaryTowerAux n).2.instIrreduciblePoly

noncomputable instance (‚Ñì : Nat) : AddCommGroup (CoeffVecSpace L ‚Ñì) :=

List.Vector.head in Mathlib.Data.Vector.Defs

def Œ≤ (R : F[X][X][Y]) (t : ‚Ñï) : ùí™ H :=
  (Œ≤_regular R H (Nat.le_refl _) t).choose

@[reducible, inline]
instance instPolynomialDegreeLT : OracleInterface (R‚¶É< d‚¶Ñ[X]) where
  Query := R
  Response := R
  answer := fun ‚ü®poly, _‚ü© point => poly.eval point

instance (priority := high) : MonadLiftT (OracleComp []‚Çí) (OracleComp spec) where
  monadLift := OracleComp.construct pure (fun a => by admit /- proof elided -/
  ) failure

instance instDCast‚ÇÅ‚ÇÇ : DCast (Œ≤ a) (Œ≥ a) where
  dcast hb c := dcast‚ÇÇ (Eq.refl a) (by admit /- proof elided -/
  ) c
  dcast_id := by admit /- proof elided -/

def checkSrs (proveSrs : Vector G‚ÇÅ (n + 1)) (verifySrs : Vector G‚ÇÇ 2) : Prop :=
  ‚àÄ i : Fin n,
    pairing (proveSrs[i.succ]) (verifySrs[0]) = pairing (proveSrs[i.castSucc]) (verifySrs[1])

structure StatementRound (i : Fin (n + 1)) where
  
  target : R
  
  challenges : Fin i ‚Üí R

@[inline] def lt [Zero T] [ToNat T] (a b : Cayley T) : Prop :=
  (‚Üëa : Nat) < (‚Üëb : Nat)

verify in VCVio.CryptoFoundations.SignatureAlg

class GenMutualCorrParams (P : Params Œπ F) (S : ‚àÄ i : Fin (M + 1), Finset (Œπ i)) where

  Œ¥ : Fin (M + 1) ‚Üí ‚Ñù‚â•0
  dist : (i : Fin (M + 1)) ‚Üí Fin ((P.foldingParam i) + 1) ‚Üí ‚Ñù‚â•0


  œÜ : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), (indexPowT (S i) (P.œÜ i) j) ‚Ü™ F

  inst1 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Fintype (indexPowT (S i) (P.œÜ i) j)
  inst2 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    Nonempty (indexPowT (S i) (P.œÜ i) j)
  inst3 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    DecidableEq (indexPowT (S i) (P.œÜ i) j)
  inst4 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Smooth (œÜ i j)

  par‚Ñì_type : ‚àÄ i : Fin (M + 1), ‚àÄ _ : Fin ((P.foldingParam i) + 1), Type
  inst5 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Fintype (par‚Ñì_type i j)

  exp : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), (par‚Ñì_type i j) ‚Ü™ ‚Ñï



  Gen_Œ± : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    ProximityGenerator (indexPowT (S i) (P.œÜ i) j) F :=
      fun i j => RSGenerator.genRSC (par‚Ñì_type i j) (œÜ i j) (P.varCount i - j) (exp i j)

  inst6 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Fintype (Gen_Œ± i j).par‚Ñì

  BStar : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    (Set ((indexPowT (S i) (P.œÜ i) j) ‚Üí F)) ‚Üí Type ‚Üí ‚Ñù‚â•0
  errStar : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    (Set ((indexPowT (S i) (P.œÜ i) j) ‚Üí F)) ‚Üí Type ‚Üí ‚Ñù ‚Üí ENNReal

  C : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Set ((indexPowT (S i) (P.œÜ i) j) ‚Üí F)
  hcode : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), (C i j) = (Gen_Œ± i j).C

  h : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    hasMutualCorrAgreement (Gen_Œ± i j)
      (BStar i j (C i j) (Gen_Œ± i j).par‚Ñì)
      (errStar i j (C i j) (Gen_Œ± i j).par‚Ñì)

  h‚Ñì_bound : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    Fintype.card (Gen_Œ± i j).par‚Ñì = 2
  h‚Ñì_bound' : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    Fintype.card (par‚Ñì_type i j) = 2

  hŒ¥Le : ‚àÄ i : Fin (M + 1),
    (Œ¥ i) ‚â§ 1 - Finset.univ.sup (fun j => BStar i j (C i j) (Gen_Œ± i j).par‚Ñì)

  hlistDecode : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    listDecodable (C i j) (Œ¥ i) (dist i j)

def toRoundByRound (E : RoundByRoundOneShot oSpec StmtIn WitIn pSpec) :
    RoundByRound oSpec StmtIn WitIn WitOut pSpec (fun _ => WitIn) where
  eqIn := rfl
  extractMid := fun m stmtIn tr witIn =>
    if m.castSucc = 0 then witIn else E m.castSucc stmtIn (Fin.init tr) default
  extractOut := fun stmtIn tr _ => E (.last n) stmtIn tr default

noncomputable def relayOracleProver (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
  OracleProver (oSpec := []‚Çí)
    
    (StmtIn := Statement (L := L) Context i.succ)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) i.succ)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) i.succ)
    (pSpec := pSpecRelay) where
  PrvState := relayPrvState ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i
  input := fun ‚ü®‚ü®stmtIn, oStmtIn‚ü©, witIn‚ü© => (stmtIn, oStmtIn, witIn)
  sendMessage | ‚ü®x, h‚ü© => by admit /- proof elided -/
| ‚ü®x, h‚ü© => by admit /- proof elided -/

def vconcat {n : ‚Ñï} (v : Fin n ‚Üí Œ±) (a : Œ±) : Fin (n + 1) ‚Üí Œ± :=
  dconcat v a

class Extractor.Lens.IsKnowledgeSound
    {OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut : Type}
    {OuterWitIn OuterWitOut InnerWitIn InnerWitOut : Type}
    (outerRelIn : Set (OuterStmtIn √ó OuterWitIn))
    (innerRelIn : Set (InnerStmtIn √ó InnerWitIn))
    (outerRelOut : Set (OuterStmtOut √ó OuterWitOut))
    (innerRelOut : Set (InnerStmtOut √ó InnerWitOut))
    (compatStmt : OuterStmtIn ‚Üí InnerStmtOut ‚Üí Prop)
    (compatWit : OuterWitOut ‚Üí InnerWitIn ‚Üí Prop)
    (lens : Extractor.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                            OuterWitIn OuterWitOut InnerWitIn InnerWitOut) where

   
  proj_knowledgeSound : ‚àÄ outerStmtIn innerStmtOut outerWitOut,
    compatStmt outerStmtIn innerStmtOut ‚Üí
    (lens.stmt.lift outerStmtIn innerStmtOut, outerWitOut) ‚àà outerRelOut ‚Üí
    (innerStmtOut, lens.wit.proj (outerStmtIn, outerWitOut)) ‚àà innerRelOut

   
  lift_knowledgeSound : ‚àÄ outerStmtIn outerWitOut innerWitIn,
    compatWit outerWitOut innerWitIn ‚Üí
    (lens.stmt.proj outerStmtIn, innerWitIn) ‚àà innerRelIn ‚Üí
    (outerStmtIn, lens.wit.lift (outerStmtIn, outerWitOut) innerWitIn) ‚àà outerRelIn

Div in Init.Prelude

def eval (p : MlPolyEval R n) (x : Vector R n) : R :=
  Vector.dotProduct p (lagrangeBasis x)

@[inline, specialize]
def prover : Prover oSpec Statement Witness (Statement √ó Witness) Unit (pSpec Witness) where
  PrvState
  | 0 => Statement √ó Witness
  | 1 => Statement √ó Witness
  input := id
  sendMessage | ‚ü®0, _‚ü© => fun ‚ü®stmt, wit‚ü© => pure (wit, ‚ü®stmt, wit‚ü©)
  receiveChallenge | ‚ü®0, h‚ü© => nomatch h
  output := fun ‚ü®stmt, wit‚ü© => pure (‚ü®stmt, wit‚ü©, ())

def widthDiv4 : Nat := params.width / 4

abbrev MultilinearPoly (L : Type) [CommSemiring L] (‚Ñì : ‚Ñï) := L‚¶É‚â§ 1‚¶Ñ[X Fin ‚Ñì]

def AlgebraTowerEquiv.toAlgebraOverRight (e : AlgebraTowerEquiv A B) (i j : Œπ)
    (h : i ‚â§ j) : Algebra (B i) (A j) :=

OracleComp.neverFails in VCVio.OracleComp.Traversal

def outputRelation (cond : ‚àë i, (s i).1 ‚â§ n) [DecidableEq F] (Œ¥ : ‚Ñù‚â•0) :
    Set
      (
        (FinalStatement F k √ó ‚àÄ j, FinalOracleStatement D x s j) √ó
        Witness F s d (Fin.last (k + 1))
      ) := sorry

NeZero in Init.Data.NeZero

@[app_unexpander Fin.fcons‚ÇÇ]
def fcons‚ÇÇUnexpander : Lean.PrettyPrinter.Unexpander
  | `($_ $a !h‚¶É$F‚¶Ñ‚ü®$Œ±‚ÇÅ‚ü©‚ü®$Œ±‚ÇÇ‚ü©[$b, $bs,*]) => `(!h‚¶É$F‚¶Ñ‚ü®$Œ±‚ÇÅ‚ü©‚ü®$Œ±‚ÇÇ‚ü©[$a, $b, $bs,*])
  | `($_ $a !h‚¶É$F‚¶Ñ‚ü®$Œ±‚ÇÅ‚ü©‚ü®$Œ±‚ÇÇ‚ü©[$b]) => `(!h‚¶É$F‚¶Ñ‚ü®$Œ±‚ÇÅ‚ü©‚ü®$Œ±‚ÇÇ‚ü©[$a, $b])
  | `($_ $a !h‚¶É$F‚¶Ñ‚ü®$Œ±‚ÇÅ‚ü©‚ü®$Œ±‚ÇÇ‚ü©[]) => `(!h‚¶É$F‚¶Ñ‚ü®$Œ±‚ÇÅ‚ü©‚ü®$Œ±‚ÇÇ‚ü©[$a])
  | _ => throw ()

@[simp]
def oCtxLens (i : Fin n) : OracleContext.Lens
    (StatementRound R n i.castSucc) (StatementRound R n i.succ) (Simple.StmtIn R) (Simple.StmtOut R)
    (OracleStatement R n deg) (OracleStatement R n deg)
    (Simple.OStmtIn R deg) (Simple.OStmtOut R deg)
    Unit Unit Unit Unit where
  wit := Witness.Lens.trivial
  stmt := oStmtLens R n deg D i

def BTField_succ_alg_equiv_adjoinRoot (k : ‚Ñï) :
  AdjoinRoot (poly k) ‚âÉ‚Çê[BTField k] BTField (k + 1) :=

Nat.Coprime in Init.Data.Nat.Coprime

GaloisField in Mathlib.FieldTheory.Finite.GaloisField

def AlgebraTowerEquiv.algebraMapLeftUp (e : AlgebraTowerEquiv A B) (i j : Œπ)
    (h : i ‚â§ j) : (B i) ‚Üí+* (A j) :=

def RAW_CONSTANTS_24 : Vector KoalaBear.Field 215 := #v[
    487143900,
    1829048205,
    1652578477,
    646002781,
    1044144830,
    53279448,
    1519499836,
    22697702,
    1768655004,
    230479744,
    1484895689,
    705130286,
    1429811285,
    1695785093,
    1417332623,
    1115801016,
    1048199020,
    878062617,
    738518649,
    249004596,
    1601837737,
    24601614,
    245692625,
    364803730,
    1857019234,
    1906668230,
    1916890890,
    835590867,
    557228239,
    352829675,
    515301498,
    973918075,
    954515249,
    1142063750,
    1795549558,
    608869266,
    1850421928,
    2028872854,
    1197543771,
    1027240055,
    1976813168,
    963257461,
    652017844,
    2113212249,
    213459679,
    90747280,
    1540619478,
    324138382,
    1377377119,
    294744504,
    512472871,
    668081958,
    907306515,
    518526882,
    1907091534,
    1152942192,
    1572881424,
    720020214,
    729527057,
    1762035789,
    86171731,
    205890068,
    453077400,
    1201344594,
    986483134,
    125174298,
    2050269685,
    1895332113,
    749706654,
    40566555,
    742540942,
    1735551813,
    162985276,
    1943496073,
    1469312688,
    703013107,
    1979485151,
    1278193166,
    548674995,
    2118718736,
    749596440,
    1476142294,
    1293606474,
    918523452,
    890353212,
    1691895663,
    1932240646,
    1180911992,
    86098300,
    1592168978,
    895077289,
    724819849,
    1697986774,
    1608418116,
    1083269213,
    691256798,
    328586442,
    1572520009,
    1375479591,
    322991001,
    967600467,
    1172861548,
    1973891356,
    1503625929,
    1881993531,
    40601941,
    1155570620,
    571547775,
    1361622243,
    1495024047,
    1733254248,
    964808915,
    763558040,
    1887228519,
    994888261,
    718330940,
    213359415,
    603124968,
    1038411577,
    2099454809,
    949846777,
    630926956,
    1168723439,
    222917504,
    1527025973,
    1009157017,
    2029957881,
    805977836,
    1347511739,
    540019059,
    589807745,
    440771316,
    1530063406,
    761076336,
    87974206,
    1412686751,
    1230318064,
    514464425,
    1469011754,
    1770970737,
    1510972858,
    965357206,
    209398053,
    778802532,
    40567006,
    1984217577,
    1545851069,
    879801839,
    1611910970,
    1215591048,
    330802499,
    1051639108,
    321036,
    511927202,
    591603098,
    1775897642,
    115598532,
    278200718,
    233743176,
    525096211,
    1335507608,
    830017835,
    1380629279,
    560028578,
    598425701,
    302162385,
    567434115,
    1859222575,
    958294793,
    1582225556,
    1781487858,
    1570246000,
    1067748446,
    526608119,
    1666453343,
    1786918381,
    348203640,
    1860035017,
    1489902626,
    1904576699,
    860033965,
    1954077639,
    1685771567,
    971513929,
    1877873770,
    137113380,
    520695829,
    806829080,
    1408699405,
    1613277964,
    793223662,
    648443918,
    893435011,
    403879071,
    1363789863,
    1662900517,
    2043370,
    2109755796,
    931751726,
    2091644718,
    606977583,
    185050397,
    946157136,
    1350065230,
    1625860064,
    122045240,
    880989921,
    145137438,
    1059782436,
    1477755661,
    335465138,
    1640704282,
    1757946479,
    1551204074,
    681266718,
]

Matrix.cRank in Mathlib.LinearAlgebra.Matrix.Rank

@[inline, specialize]
def add {R : Type*} [Ring R] [BEq R] [LawfulBEq R] (p q : QuotientUniPoly R) : QuotientUniPoly R :=
  Quotient.lift‚ÇÇ add_descending add_descends p q

OracleSpec.SubSpec in VCVio.OracleComp.Coercions.SubSpec

Mathlib.Meta.NormNum.mkOfNat in Mathlib.Tactic.NormNum.Result

instance : ‚àÄ i, VCVCompatible ((pSpec Witness).Challenge i) | ‚ü®0, h‚ü© => nomatch h

def squeeze (state : HashStateWithInstructions U H) (outputSize : Nat) :
    Except DomainSeparatorMismatch (HashStateWithInstructions U H √ó Array U) := do
  
  sorry

class OracleInterfaces (pSpec : ProtocolSpec n) where
  oracleInterfaces : ‚àÄ i, Option (OracleInterface (pSpec.Message i))

Array.foldlM in Init.Data.Array.Basic

List.ranges in Mathlib.Data.List.Range

def concat' {k : Fin n}
    (messages : (i : Fin k) ‚Üí (pSpec.dir (i.castLE (by admit /- proof elided -/
    )) = .P_to_V
      ‚Üí pSpec.¬´Type¬ª (i.castLE (by admit /- proof elided -/
      ))))
    (msg : (h : pSpec.dir k = .P_to_V) ‚Üí pSpec.Message ‚ü®k, h‚ü©) :
    (i : Fin (k + 1)) ‚Üí (pSpec.dir (i.castLE (by admit /- proof elided -/
    )) = .P_to_V) ‚Üí
      pSpec.¬´Type¬ª (i.castLE (by admit /- proof elided -/
      )) :=
  Fin.dconcat messages msg

@[reducible, simp] def WitOut := Unit

instance : Add (Cayley T) where
  add := add

OracleSpec.QueryCache in VCVio.OracleComp.QueryTracking.Structures

FreeMonad in ToMathlib.Control.Monad.Free

Nat.floor in Mathlib.Algebra.Order.Floor.Defs

Set.Ioc in Mathlib.Order.Interval.Set.Defs

abbrev MatrixSubmodule.{u, v, w} (Œ∫ : Type u) [Fintype Œ∫] (Œπ : Type v) [Fintype Œπ]
                                 (F : Type w) [Semiring F] : Type (max u v w) :=
  Submodule F (Matrix Œ∫ Œπ F)

def mkAddCommGroupInstance {k : ‚Ñï} : AddCommGroup (ConcreteBTField k) := {
  zero := zero
  neg := neg
  sub := fun x y => add x y
  add_assoc := add_assoc
  add_comm := add_comm
  zero_add := zero_add
  add_zero := add_zero
  nsmul := fun n x => if n % 2 = (0 : ‚Ñï) then zero else x
  zsmul := fun (n : ‚Ñ§) x => if n % 2 = 0 then zero else x  
  neg_add_cancel := neg_add_cancel
  nsmul_succ := nsmul_succ
  zsmul_succ' := fun n a => zsmul_succ n a
  add := add
  zsmul_neg' := zsmul_neg' (k := k)
}

instance {Œ± : Type u} : Slice (List Œ±) Nat Nat (fun _ _ _ => True) (fun _ _ _ _ => List Œ±) where
  slice xs start stop _ := xs.extract start stop

orderOf in Mathlib.GroupTheory.OrderOfElement

@[reducible]
def oracleVerifier : OracleVerifier oSpec (StatementRound R n 0) (OracleStatement R n deg)
    (StatementRound R n (.last n)) (OracleStatement R n deg) (pSpec R deg n) :=
  OracleVerifier.seqCompose (oSpec := oSpec)
    (Stmt := StatementRound R n)
    (OStmt := fun _ => OracleStatement R n deg)
    (pSpec := fun _ => SingleRound.pSpec R deg)
    (SingleRound.oracleVerifier R n deg D oSpec)

List.max? in Init.Data.List.Basic

noncomputable def finalFoldProver :
  OracleProver []‚Çí
    (Statement F (Fin.last k)) (OracleStatement D x s (Fin.last k))
      (Witness F s d (Fin.last k).castSucc)
    (FinalStatement F k) (FinalOracleStatement D x s)
      (Witness F s d (Fin.last (k + 1)))
    (pSpec F) where
  PrvState
  | 0 =>
    (Statement F (Fin.last k) √ó ((j : Fin (k + 1)) ‚Üí OracleStatement D x s (Fin.last k) j)) √ó
      Witness F s d (Fin.last k).castSucc
  | _ =>
    (FinalStatement F k √ó ((j : Fin (k + 1)) ‚Üí OracleStatement D x s (Fin.last k) j)) √ó
      Witness F s d (Fin.last (k + 1))

  input := id

  sendMessage
  | ‚ü®0, h‚ü© => nomatch h
  | ‚ü®1, _‚ü© => fun ‚ü®‚ü®chals, o‚ü©, p‚ü© =>
    pure ‚ü®fun x => p.1, ‚ü®‚ü®chals, o‚ü©, p‚ü©‚ü©

  receiveChallenge
  | ‚ü®0, _‚ü© => fun ‚ü®‚ü®chals, o‚ü©, p‚ü© => pure <|
    fun (Œ± : F) =>
      ‚ü®
        ‚ü®Fin.vappend chals !v[Œ±], o‚ü©,
        ‚ü®
          p.1.foldNth (2 ^ (s (Fin.last k)).1) Œ±,
          by admit /- proof elided -/
        ‚ü©
      ‚ü©
  | ‚ü®1, h‚ü© => nomatch h

  output := fun ‚ü®‚ü®chals, o‚ü©, p‚ü© => pure <|
    ‚ü®
      ‚ü®
        chals,
        fun j => by admit /- proof elided -/
      ‚ü©,
      p
    ‚ü©

Polynomial.eval‚ÇÇRingHom in Mathlib.Algebra.Polynomial.Eval.Defs

@[simp]
def BTField (k : ‚Ñï) := (BinaryTowerAux k).1

RatFunc in Mathlib.FieldTheory.RatFunc.Defs

@[reducible]
def pSpecFold : ProtocolSpec (Fin.vsum fun (_ : Fin k) ‚Ü¶ 2) :=
  ProtocolSpec.seqCompose (fun (i : Fin k) => FoldPhase.pSpec D x s i)

def oracleReduction.firstChallenge :
    OracleReduction oSpec
      (Statement.AfterFirstMessage R pp) (OracleStatement.AfterFirstMessage R pp) (Witness R pp)
      (Statement.AfterFirstChallenge R pp) (OracleStatement.AfterFirstChallenge R pp) Unit
      ‚ü®!v[.V_to_P], !v[FirstChallenge R pp]‚ü© :=
  sorry

private def toWeightAssignment
  (p : MvPolynomial (Fin m) F)
  (b : Fin m ‚Üí Fin 2) : Fin (m+1) ‚Üí F :=
    let b' : Fin m ‚Üí F := fun i => ‚Üë(b i : ‚Ñï)
    Fin.cases (MvPolynomial.eval b' p)
              (fun i => ‚Üë(b i : ‚Ñï))

Algebra.ofId in Mathlib.Algebra.Algebra.Hom

def oracleReduction (i : Fin n) : OracleReduction oSpec
    (StatementRound R n i.castSucc) (OracleStatement R n deg) Unit
    (StatementRound R n i.succ) (OracleStatement R n deg) Unit (pSpec R deg) :=
  (Simple.oracleReduction R deg D oSpec).liftContext (oCtxLens R n deg D i)

@[reducible, simp]
def toRelOut : Set ((Statement √ó Witness) √ó Unit) :=
  Prod.fst ‚Åª¬π' relIn

@[inline, reducible]
def proj : OuterStmtIn ‚Üí InnerStmtIn :=
  lens.toFunA

BitVec.ofNat in Init.Prelude

@[reducible, simp]
def rbrSoundness
    (langIn : Set (Statement √ó ‚àÄ i, OStatement i))
    (verifier : OracleVerifier oSpec Statement OStatement Bool (fun _ : Empty => Unit) pSpec)
    (rbrSoundnessError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) : Prop :=
  verifier.rbrSoundness init impl langIn acceptRejectOracleRel.language rbrSoundnessError

instance [Zero T] [ToNat T] : LT (Cayley T) where
  lt := lt

noncomputable def commitOracleProver (i : Fin ‚Ñì) :
  OracleProver (oSpec := []‚Çí)
    
    (StmtIn := Statement (L := L) Context i.succ)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) i.succ)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) i.succ)
    (pSpec := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) where

  PrvState := commitPrvState ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i

  input := fun ‚ü®‚ü®stmt, oStmt‚ü©, wit‚ü© => (stmt, oStmt, wit)

  sendMessage 
  | ‚ü®0, _‚ü© => fun inputPrvState => by admit /- proof elided -/
  | ‚ü®0, h‚ü© => nomatch h 

  output := fun ‚ü®stmt, oStmt, wit‚ü© => by admit /- proof elided -/

Nat.ceil in Mathlib.Algebra.Order.Floor.Defs

noncomputable def H_tilde (H : F[X][Y]) : Polynomial (RatFunc F) :=
  let h·µ¢ (i : ‚Ñï) := H.coeff i
  let d := H.natDegree
  let W := (RingHom.comp Polynomial.C univPolyHom) (h·µ¢ d)
  let S : Polynomial (RatFunc F) := Polynomial.X / W
  let H' := Polynomial.eval‚ÇÇ (RingHom.comp Polynomial.C univPolyHom) S H
  W ^ (d - 1) * H'

@[reducible, inline, specialize]
def Messages' (pSpec : ProtocolSpec n) : Type :=
  ‚àÄ i, (hi : pSpec.dir i = .P_to_V) ‚Üí pSpec.¬´Type¬ª i

@[reducible, inline, specialize]
def challenges (transcript : FullTranscript pSpec) (i : ChallengeIdx pSpec) :=
  transcript i.val

@[reducible]
def addSalt (pSpec : ProtocolSpec n) (Salt : pSpec.MessageIdx ‚Üí Type) :
    ProtocolSpec n :=
  ‚ü®pSpec.dir, fun i => match hDir : pSpec.dir i with
    | .P_to_V => (pSpec.¬´Type¬ª i) √ó Salt ‚ü®i, hDir‚ü©
    | .V_to_P => pSpec.¬´Type¬ª i‚ü©

Sum in Init.Core

StrongRankCondition in Mathlib.LinearAlgebra.InvariantBasisNumber

def ar2 (k0 k1 : ‚Ñï) : Fin 2 ‚Üí ‚Ñï
  | ‚ü®0, _‚ü© => k0
  | ‚ü®1, _‚ü© => k1

def D_YZ (Q : F[Z][X][Y]) : ‚Ñï :=
  Option.getD (dflt := 0) <| Finset.max
    (Finset.image
            (
              fun j =>
                Option.getD (
                  Finset.max (
                    Finset.image
                      (fun k => j + (Bivariate.coeff Q j k).natDegree)
                      (Q.coeff j).support
                  )
                ) 0
            )
            Q.support
    )

def divide_by_2 (s : Finset ‚Ñï) : Finset ‚Ñï :=
  (erase_odd s).image (fun n => n / 2)

Equiv.toEmbedding in Mathlib.Logic.Embedding.Basic

DivisionRing in Mathlib.Algebra.Field.Defs

def checkInitImports : IO Bool := do
  \n\
      The `header` linter is included in Mathlib.Init, and every file in Mathlib \
      should import Mathlib.Init.\nPlease adjust the imports accordingly."
    return true

  e

def isCompliant (i : Fin (‚Ñì)) (steps : ‚Ñï) [NeZero steps]
  (h_i_add_steps : i + steps ‚â§ ‚Ñì)
  (f_i : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i, by admit /- proof elided -/
  ‚ü©)
  (f_i_plus_steps : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      ‚ü®i + steps, by admit /- proof elided -/
      ‚ü©)
  (challenges : Fin steps ‚Üí L) : Prop :=
  ‚àÉ (h_fw_dist_lt : 2 * fiberwiseDistance ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := i)
      (steps := steps) h_i_add_steps f_i < (BBF_CodeDistance ‚Ñì ùì° ‚ü®i + steps, by admit /- proof elided -/
      ‚ü© : ‚Ñï‚àû))
    (h_dist_next_lt : 2 * distFromCode f_i_plus_steps
      (BBF_Code ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i + steps, by admit /- proof elided -/
      ‚ü©)
      < (BBF_CodeDistance ‚Ñì ùì° ‚ü®i + steps, by admit /- proof elided -/
      ‚ü© : ‚Ñï‚àû)), 
    
    let h_dist_curr_lt := fiberwise_dist_lt_imp_dist_lt_unique_decoding_radius ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := i) steps h_i_add_steps f_i
      (h_fw_dist_lt := h_fw_dist_lt)
    let f_bar_i := uniqueClosestCodeword ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (i := ‚ü®i, by admit /- proof elided -/
      ‚ü©) (h_i := fin_‚Ñì_lt_‚Ñì_add_R i) f_i h_dist_curr_lt
    let f_bar_i_plus_steps := uniqueClosestCodeword ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := ‚ü®i + steps, by admit /- proof elided -/
      ‚ü©)
      (h_i := fin_‚Ñì_steps_lt_‚Ñì_add_R i steps h_i_add_steps)
      f_i_plus_steps h_dist_next_lt
    iterated_fold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (steps := ‚ü®steps, by admit /- proof elided -/
      ‚ü©)
      (i := ‚ü®i, by admit /- proof elided -/
      ‚ü©)
      (h_i_add_steps := by admit /- proof elided -/
      )
      f_bar_i challenges = f_bar_i_plus_steps

structure BacktrackSequence (trace : QueryLog (duplexSpongeChallengeOracle StmtIn U))
    (state : CanonicalSpongeState U) where
   
  stmt : StmtIn
   
  inputState : List (CanonicalSpongeState U)
   
  outputState : List (CanonicalSpongeState U)

   
  inputState_length_eq_outputState_length_succ : inputState.length = outputState.length + 1

   
  last_inputState_eq_state : inputState[inputState.length - 1] = state

   
  hash_in_trace : (stmt, (Vector.drop inputState[0] SpongeSize.R)) ‚àà trace.getQ (.inl ())

   
  permute_or_inv_in_trace : ‚àÄ i : Fin outputState.length,
    (inputState[i], outputState[i]) ‚àà trace.getQ (.inr .Fwd)
    ‚à® (outputState[i], inputState[i]) ‚àà trace.getQ (.inr .Bwd)

   
  capacitySegment_output_eq_input : ‚àÄ i : Fin outputState.length,
    outputState[i].capacitySegment = inputState[i.val + 1].capacitySegment

   
  capacitySegment_input_ne_output : ‚àÄ i : Fin outputState.length,
    inputState[i].capacitySegment ‚â† outputState[i].capacitySegment

instance {Œ± : Type u} : SliceLT (List Œ±) Nat (fun _ _ => True) (fun _ _ _ => List Œ±) where
  sliceLT xs stop _ := List.take stop xs

structure PrattCertificate (p : ‚Ñï) : Type where
  a : ZMod p
  pow_eq_one : a ^ (p - 1) = 1
  part : PrattPart p a (p - 1)

List.mergeSort in Init.Data.List.Sort.Basic

def sub (a b : AssocNat) : AssocNat :=
  subNat a b.toNat

def neg_descending (p : UniPoly R) : QuotientUniPoly R :=
  Quotient.mk _ (neg p)

def oStmtLens (i : Fin n) : OracleStatement.Lens
    (StatementRound R n i.castSucc) (StatementRound R n i.succ) (Simple.StmtIn R) (Simple.StmtOut R)
    (OracleStatement R n deg) (OracleStatement R n deg)
    (Simple.OStmtIn R deg) (Simple.OStmtOut R deg) where

  toFunA := fun ‚ü®‚ü®target, challenges‚ü©, oStmt‚ü© =>
    ‚ü®target, fun _ =>
      match h : n with
      | 0 => ‚ü®Polynomial.C <| MvPolynomial.isEmptyAlgEquiv R (Fin 0) (oStmt ()), by admit /- proof elided -/
        ‚ü©
      | n + 1 =>
      ‚ü®‚àë x ‚àà (univ.map D) ^·∂† (n - i), (oStmt ()).val ‚∏®X ‚¶Éi‚¶Ñ, challenges, x‚∏©'(by admit /- proof elided -/
      ),
        sumcheck_roundPoly_degreeLE R n deg D i (oStmt ()).property‚ü©‚ü©

  toFunB := fun ‚ü®‚ü®_oldTarget, challenges‚ü©, oStmt‚ü© ‚ü®‚ü®newTarget, chal‚ü©, oStmt'‚ü© =>
    ‚ü®‚ü®newTarget, Fin.snoc challenges chal‚ü©, oStmt‚ü©

instance instToNat {n : ‚Ñï} : ToNat (CNat n) := match n with
  | 0 => by admit /- proof elided -/
  | .succ n => @Cayley.instToNatOfZero (CNat n) instHasSucc instZero instToNat

Functor.map in Init.Prelude

@[simp]
def extractorLens (i : Fin n) : Extractor.Lens
    (StatementRound R n i.castSucc √ó (‚àÄ i, OracleStatement R n deg i))
    (StatementRound R n i.succ √ó (‚àÄ i, OracleStatement R n deg i))
    (Simple.StmtIn R √ó (‚àÄ i, Simple.OStmtIn R deg i))
    (Simple.StmtOut R √ó (‚àÄ i, Simple.OStmtOut R deg i))
    Unit Unit Unit Unit where
  stmt := oStmtLens R n deg D i
  wit := Witness.InvLens.trivial

def ratchet (ds : DomainSeparator U H) : DomainSeparator U H :=
  { io := ds.io ++ SEP_BYTE ++ "R" }

def oracleFoldingConsistencyProp (i : Fin (‚Ñì + 1)) (challenges : Fin i ‚Üí L)
    (oStmt : ‚àÄ j, (OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i) j) : Prop :=
  ‚àÄ (j : Fin (toOutCodewordsCount ‚Ñì œë i)) (hj : j.val + 1 < toOutCodewordsCount ‚Ñì œë i),
    
    have h_k_bound := oracle_block_k_bound (‚Ñì := ‚Ñì) (œë := œë) (i := i) (j := j)
    have h_k_next_le_i := oracle_block_k_next_le (‚Ñì := ‚Ñì) (œë := œë) (i := i) (j := j) (hj := hj)
    
    isCompliant (i := ‚ü®j.val * œë, by admit /- proof elided -/
    ‚ü©) (steps := œë)
      (h_i_add_steps := by admit /- proof elided -/
      )
      (f_i := oStmt ‚ü®j.val, by admit /- proof elided -/
      ‚ü©)
      (f_i_plus_steps := getNextOracle ùîΩq Œ≤ i oStmt j hj)
      (challenges := getFoldingChallenges (r := r) (ùì° := ùì°) i challenges (k := j.val * œë)
        (h := h_k_next_le_i))

Matrix.vandermonde in Mathlib.LinearAlgebra.Vandermonde

@[reducible]
def MemoryRead (Œπ : Type u) (Œ± : Œπ ‚Üí Type v) := (index : Œπ) √ó (Œ± index)

instance {n : ‚Ñï} : ‚àÄ j, SelectableType ((pSpecFoldRelaySequence (L:=L) n).Challenge j) :=
  instSelectableTypeChallengeSeqCompose

@[reducible]
def GroupExpOracle : OracleSpec Unit := fun _ => (Œπ √ó ZMod p √ó Œπ, Unit)

Eq.mpr in Init.Core

def powFiber (S : Finset Œπ) (œÜ : Œπ ‚Ü™ F) (k : ‚Ñï) (y : indexPow S œÜ k) : Finset Œπ :=
  S.filter (fun x => (œÜ x) ^ k = y)

System.FilePath.fileName in Init.System.FilePath

def Œæ (x‚ÇÄ : F) (R : F[X][X][Y]) (H : F[X][Y]) [œÜ : Fact (Irreducible H)] : ùí™ H :=
  (Œæ_regular x‚ÇÄ R H).choose

instance instCharP2 {k : ‚Ñï} : CharP (ConcreteBTField k) 2 :=
  charP_eq_2_of_add_self_eq_zero (F:=(ConcreteBTField k)) (sumZeroIffEq:=add_eq_zero_iff_eq)

instance [VerifierFirst pSpec] : VerifierLast pSpec where
  verifier_last' := by admit /- proof elided -/

instance : HListRepr (HList []) where
  repr := fun _ => ""

def aeval {A : Type w} [CommSemiring A] [Algebra R A] (s : A) : P ‚Üí‚Çê[R] A :=
  eval‚ÇÇAlgHom (Algebra.ofId R A) s

inductive PrattPart : (p : ‚Ñï) ‚Üí (a : ZMod p) ‚Üí ‚Ñï ‚Üí Prop
  | prime : {p : ‚Ñï} ‚Üí {a : ZMod p} ‚Üí (n k nk : ‚Ñï) ‚Üí n.Prime ‚Üí
      a ^ ((p - 1) / n) ‚â† 1 ‚Üí n ^ k = nk ‚Üí PrattPart p a nk
  | split : {p : ‚Ñï} ‚Üí {a : ZMod p} ‚Üí {n : ‚Ñï} ‚Üí (l r : ‚Ñï) ‚Üí
      PrattPart p a l ‚Üí PrattPart p a r ‚Üí l * r = n ‚Üí PrattPart p a n

Equiv.ofBijective in Mathlib.Logic.Equiv.Defs

Int.natAbs in Init.Data.Int.Basic

@[inline, reducible]
def lift : (OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i)) √ó OuterWitIn ‚Üí
    (InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i)) √ó InnerWitOut ‚Üí
    (OuterStmtOut √ó (‚àÄ i, OuterOStmtOut i)) √ó OuterWitOut :=
  fun ctxIn ctxOut => ‚ü®lens.stmt.lift ctxIn.1 ctxOut.1, lens.wit.lift ctxIn ctxOut‚ü©

@[inline]
def neg [Neg R] (p : MlPolyEval R n) : MlPolyEval R n := p.map (fun a => -a)

def outputRelation :
    Set
      (
        (Fri.Spec.Statement F (0 : Fin (k + 1)) √ó
        (‚àÄ j, Fri.Spec.OracleStatement D x s (0 : Fin (k + 1)) j)) √ó
        Fri.Spec.Witness F s d (0 : Fin (k + 2))
      ) := sorry

Units.mk0 in Mathlib.Algebra.GroupWithZero.Units.Basic

LawfulBEq in Init.Core

def squeezeUnchecked [Permute C] (sponge : DuplexSponge U C) (arr : Array U) :
    DuplexSponge U C √ó Array U :=
  simulateQ' (m := Id) forwardPermutationOracleImpl (squeezeInto sponge arr) (by admit /- proof elided -/
  )

structure ProximityGenerator
  (Œπ : Type) [Fintype Œπ] [Nonempty Œπ]
  (F : Type) [Semiring F] [Fintype F] [DecidableEq F] where
  
  C : LinearCode Œπ F
  
  par‚Ñì : Type
  h‚Ñì : Fintype par‚Ñì
  
  Gen : Finset (par‚Ñì ‚Üí F)
  Gen_nonempty : Nonempty Gen
  
  rate : ‚Ñù
  
  B : (LinearCode Œπ F) ‚Üí Type ‚Üí ‚Ñù
  
  err : (LinearCode Œπ F) ‚Üí Type ‚Üí ‚Ñù ‚Üí ENNReal
   
  proximity:
    ‚àÄ (f : par‚Ñì ‚Üí Œπ ‚Üí F)
      (Œ¥ : ‚Ñù‚â•0) 
      (_hŒ¥ : 0 < Œ¥ ‚àß Œ¥ < 1 - (B C par‚Ñì)) ,
      Pr_{ let r ‚Üê $·µñ Gen }[ (proximityCondition f Œ¥ r C) ] > (err C par‚Ñì Œ¥) ‚Üí
        ‚àÉ S : Finset Œπ,
          S.card ‚â• (1 - Œ¥) * (Fintype.card Œπ) ‚àß
        ‚àÄ i : par‚Ñì, ‚àÉ u ‚àà C, ‚àÄ x ‚àà S, f i x = u x

class ToNat (Œ± : Type u) where
   
  toNat : Œ± ‚Üí Nat

EDist in Mathlib.Topology.EMetricSpace.Defs

@[inline] def ofNat (k : Nat) : AssocNat :=
  ‚ü®fun m => m + k, fun m => Nat.succ_add m k‚ü©

EmbeddingLike in Mathlib.Data.FunLike.Embedding

List.foldl in Init.Prelude

abbrev Fwd : PermuteDir := Sum.inl ()

def ratchet (state : FSVerifierState U H) :
    Except DomainSeparatorMismatch (FSVerifierState U H) := do
  let newHashState ‚Üê state.hashState.ratchet
  .ok { hashState := newHashState, nargString := state.nargString }

noncomputable instance {s : Set (Œπ ‚Üí F)} : Fintype (affineSpan F s) :=
  Fintype.ofFinite ‚Ü•(affineSpan F s)

def toMvPolynomial (p : MlPoly R n) : R[X Fin n] :=
  ‚àë i : Fin (2 ^ n), MvPolynomial.monomial (monomialOfNat i) (a:=p[i])

instance coe_field_adjoinRoot (k : ‚Ñï) : Coe (AdjoinRoot (poly k)) (BTField (k+1)) where
  coe := Eq.mp (BTField_succ_eq_adjoinRoot k)

instance : Field ScalarField := ZMod.instField scalarFieldSize

@[ext]
structure OracleReduction {Œπ : Type} (oSpec : OracleSpec Œπ)
    (StmtIn : Type) {Œπ‚Çõ·µ¢ : Type} (OStmtIn : Œπ‚Çõ·µ¢ ‚Üí Type) (WitIn : Type)
    (StmtOut : Type) {Œπ‚Çõ‚Çí : Type} (OStmtOut : Œπ‚Çõ‚Çí ‚Üí Type) (WitOut : Type)
    {n : ‚Ñï} (pSpec : ProtocolSpec n)
    [O‚Çõ·µ¢ : ‚àÄ i, OracleInterface (OStmtIn i)] [O‚Çò : ‚àÄ i, OracleInterface (pSpec.Message i)]
    where
  prover : OracleProver oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec
  verifier : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec

List.IsPrefix in Init.Data.List.Basic

UInt16.ofFin in Init.Data.UInt.Basic

Setoid in Init.Core

noncomputable def decoder (e k : ‚Ñï) [NeZero n] (œâs f : Fin n ‚Üí F) : Option (Polynomial F) :=
  if ‚Äñf‚Äñ‚ÇÄ ‚â§ e
  then some 0
  else
    let x := linsolve (BerlekampWelchMatrix e k œâs f) (Rhs e œâs f)
    match x with
    | none => none
    | some x =>
      let E := solutionToE e k x
      let Q := solutionToQ e k x
      if Q % E = 0 then
        let p := Q / E
        if Œî‚ÇÄ(f, p.eval ‚àò œâs) ‚â§ e then
          some p
        else
          none
      else
        none

protected def OracleVerifier.id :
    OracleVerifier oSpec Statement OStatement Statement OStatement !p[] where
  verify := fun stmt _ => pure stmt
  embed := Function.Embedding.inl
  hEq := fun _ => rfl

instance [ToString Œ±] (Œ±s : List Type) [HListString (HList Œ±s)] :
    HListString (HList (Œ± :: Œ±s)) where
  toString
  | HList.cons x xs =>
    match xs with
    | HList.nil => toString x
    | HList.cons _ _ => toString x ++ ", " ++ HListString.toString xs

def finToBinaryCoeffs (i : Fin r) (idx : Fin (2 ^ (‚Ñì + R_rate - i.val))) :
  Fin (‚Ñì + R_rate - i.val) ‚Üí ùîΩq := fun j =>
    if (Nat.getBit (k:=j) (n:=idx)) = 1 then (1 : ùîΩq) else (0 : ùîΩq)

LinearMap.ker in Mathlib.Algebra.Module.Submodule.Ker

@[elab_as_elim]
def dappend {m n : ‚Ñï} {motive : Fin (m + n) ‚Üí Sort u}
    (u : (i : Fin m) ‚Üí motive (Fin.castAdd n i))
    (v : (i : Fin n) ‚Üí motive (Fin.natAdd m i))
    (i : Fin (m + n)) : motive i :=
  match n with
  | 0 => u i
  | k + 1 => dconcat (dappend u (fun i => v (Fin.castSucc i))) (v (Fin.last k)) i

Vector.replicate in Init.Data.Vector.Basic

noncomputable def toMLE (A : Matrix (Fin (2 ^ m)) (Fin (2 ^ n)) R) : R[X Fin n][X Fin m] :=
  MLE' (MLE' ‚àò A)

instance {Œ± : Type} [Sampleable Œ±] : DecidableEq Œ± := inferInstance

def nonLastBlockOracleVerifier (bIdx : Fin (‚Ñì / œë - 1)) :=
  let stmt : Fin (œë - 1 + 1) ‚Üí Type :=
    fun i => Statement (L := L) Context ‚ü®bIdx * œë + i, bIdx_mul_œë_add_i_cast_lt_‚Ñì_succ bIdx i‚ü©
  let oStmt := fun i: Fin (œë - 1 + 1) => OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë
    ‚ü®bIdx * œë + i, bIdx_mul_œë_add_i_cast_lt_‚Ñì_succ bIdx i‚ü©
  let firstFoldRelayRoundsOracleVerifier :=
    OracleVerifier.seqCompose (oSpec := []‚Çí)
      (Stmt := stmt)
      (OStmt := oStmt)
      (pSpec := fun i => pSpecFoldRelay (L:=L))
      (V := fun i => by admit /- proof elided -/
      )
  let h1 : ‚ÜëbIdx * œë + (œë - 1) < ‚Ñì := by admit /- proof elided -/

inductive FullData (Œ± : Type) : Skeleton ‚Üí Type
  | leaf (value : Œ±) : FullData Œ± Skeleton.leaf
  | internal {left right} (value : Œ±)
      (leftData : FullData Œ± left)
      (rightData : FullData Œ± right) :
      FullData Œ± (Skeleton.internal left right)
  deriving Repr

@[reducible]
def C : R ‚Üí+* P := algebraMap R P

instance : LawfulHasSucc Nat where
  succ'_eq_add_one := Nat.succ_eq_add_one

def computableAdditiveNTT (a : Fin (2 ^ ‚Ñì) ‚Üí L) : Fin (2^(‚Ñì + R_rate)) ‚Üí L :=
  let b: Fin (2^(‚Ñì + R_rate)) ‚Üí L := tileCoeffs a 
  Fin.foldl (n:=‚Ñì) (f:= fun current_b i  =>
    computableNTTStage (ùîΩq := ùîΩq) (Œ≤ := Œ≤) (‚Ñì := ‚Ñì) (R_rate := R_rate)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := ‚ü®‚Ñì - 1 - i, by admit /- proof elided -/
      ‚ü©) (b:=current_b)
  ) (init:=b)

def LeafData.get {s} {Œ± : Type}
    (tree : LeafData Œ± s) (idx : SkeletonLeafIndex s) : Œ± :=
  match tree, idx with
  | LeafData.leaf value, SkeletonLeafIndex.ofLeaf => value
  | LeafData.internal left _, SkeletonLeafIndex.ofLeft idxLeft =>
    LeafData.get left idxLeft
  | LeafData.internal _ right, SkeletonLeafIndex.ofRight idxRight =>
    LeafData.get right idxRight

LinearMap.range in Mathlib.Algebra.Module.Submodule.Range

MvPolynomial.renameEquiv in Mathlib.Algebra.MvPolynomial.Rename

@[simp]
def AlgebraTower.toAlgebra {i j : Œπ} (h : i ‚â§ j) : Algebra (A i) (A j) :=
  (AlgebraTower.algebraMap (i:=i) (j:=j) (h:=h)).toAlgebra

class Deserialize.CloseToUniform (Œ± : Type u) (Œ≤ : Type u)
    [Fintype Œ±] [Fintype Œ≤] [Nonempty Œ±] [Nonempty Œ≤] [Deserialize Œ± Œ≤] where
  Œµ : ‚Ñù‚â•0
  Œµ_close : dist (PMF.uniformOfFintype Œ±) (deserialize <$> PMF.uniformOfFintype Œ≤) ‚â§ Œµ

noncomputable def funcQuotient (f : Œπ ‚Üí F) (S : Finset F) (Ans Fill : S ‚Üí F) : Œπ ‚Üí F :=
  fun x =>
    if hx : x.val ‚àà S then Fill ‚ü®x.val, hx‚ü© 
    else (f x - (ansPoly S Ans).eval x.val) / (vanishingPoly S).eval x.val

private def f (x : ‚Ñö) : ‚Ñö := x^2 - x

@[reducible]
def Witness := Fin sz.n_w ‚Üí R

def witnessStructuralInvariant {i : Fin (‚Ñì + 1)} (stmt : Statement (L := L) Context i)
    (wit : Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i): Prop :=
  wit.H = projectToMidSumcheckPoly ‚Ñì wit.t (m:=mp.multpoly stmt.ctx) i stmt.challenges ‚àß
  wit.f = getMidCodewords ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) wit.t stmt.challenges

def whirRelation
    {F : Type} [Field F] [Fintype F] [DecidableEq F]
    {Œπ : Type} [Fintype Œπ] [Nonempty Œπ]
    (varCount : ‚Ñï) (œÜ : Œπ ‚Ü™ F) [Smooth œÜ] (err : ‚Ñù)
    : Set ((Unit √ó ‚àÄ i, (OracleStatement Œπ F i)) √ó Unit) :=
  { ‚ü®‚ü®_, oracle‚ü©, _‚ü© | Œ¥·µ£(oracle (), smoothCode œÜ varCount) ‚â§ err }

@[simp]
instance CommRing (k : ‚Ñï) : CommRing (BTField k) := Field.toCommRing

inline in Init.Core

def BindingAdversary (oSpec : OracleSpec Œπ) (Data Commitment AuxState : Type)
    [O : OracleInterface Data] :=
  OracleComp oSpec (Commitment √ó O.Query √ó O.Response √ó O.Response √ó AuxState)

def erase_odd (s : Finset ‚Ñï) : Finset ‚Ñï := s.filter Even

Id in Init.Control.Id

def sumAll (n : ‚Ñï) (D : Fin n ‚Üí Finset R) : MvPolynomial (Fin n) R ‚Üí‚Çó[R] R :=

instance (Œ±s : List Type) [HListRepr (HList Œ±s)] : Repr (HList Œ±s) where
  reprPrec
  | v, _ => "[" ++ HListRepr.repr v ++ "]"

def perfectCompleteness
    (relIn : Set ((StmtIn √ó ‚àÄ i, OStmtIn i) √ó WitIn))
    (relOut : Set ((StmtOut √ó ‚àÄ i, OStmtOut i) √ó WitOut))
    (oracleReduction : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec) :
      Prop :=
  Reduction.perfectCompleteness init impl relIn relOut oracleReduction.toReduction

@[simps]
def subtypeSumComplEquiv {Œ± : Type*} {p : Œ± ‚Üí Prop} [DecidablePred p] :
    {a // p a} ‚äï {a // ¬¨ p a} ‚âÉ Œ± where
  toFun := fun x => match x with
    | Sum.inl a => a.1
    | Sum.inr a => a.1
  invFun := fun x =>
    if h : p x then Sum.inl ‚ü®x, h‚ü© else Sum.inr ‚ü®x, h‚ü©
  left_inv := fun x => match x with
    | Sum.inl a => by admit /- proof elided -/
    | Sum.inr a => by admit /- proof elided -/

Algebra.TensorProduct.comm in Mathlib.RingTheory.TensorProduct.Maps

AddSubmonoidClass in Mathlib.Algebra.Group.Submonoid.Defs

@[simp]
abbrev FirstSumcheckChallenge : Type := Fin pp.‚Ñì_m ‚Üí R

instance : Unique (FullTranscript (default : ProtocolSpec 0)) := inferInstance

structure Scheme extends
    Commit oSpec Data Randomness Commitment,
    Opening oSpec Data Randomness Commitment pSpec

class LawfulPermute (Œ± : Type*) [Permute Œ±] where
  permuteInv : Œ± ‚Üí Œ±
  left_inv : Function.LeftInverse permuteInv Permute.permute
  right_inv : Function.RightInverse permuteInv Permute.permute

def simulateQ' (oa : OracleComp spec Œ±) (h : oa.neverFails) : m Œ± :=

def runWithOracle (f : spec.FunctionType) : OracleComp spec Œ± ‚Üí Option Œ± :=
  OracleComp.construct' (spec := spec) (C := fun _ => Option Œ±)
    
    (fun x => some x)
    
    (fun i q _ g => g (f i q))
    
    (none)

Or.inl in Init.Prelude

def shift_left (s : Finset ‚Ñï) : Finset ‚Ñï :=
  s.filterMap
    (fun n => match n with
      | 0 => .none
      | n + 1 => .some n
      )
    (by admit /- proof elided -/
    )

instance [Zero T] [DecidableEq T] [ToNat T] : Mod (Cayley T) where
  mod := mod

@[reducible, inline, specialize, simp]
def Challenge (pSpec : ProtocolSpec n) (i : ChallengeIdx pSpec) := pSpec.¬´Type¬ª i.val

instance : Neg (UniPoly R) := ‚ü®UniPoly.neg‚ü©

instance : Mul (UniPoly R) := ‚ü®UniPoly.mul‚ü©

@[simp]
def transpose {m n : ‚Ñï} (matrix : Matrix Œ± m n) : Matrix Œ± n m :=
  ofFn (fun j => ofFn (fun i => (matrix.get i).get j))

def Function.interleave‚ÇÇ {Œ± Œ≤ : Type*} (u v : Œ± ‚Üí Œ≤) : (Fin 2) √ó Œ± ‚Üí Œ≤ :=
  Function.uncurry (fun a => if a = 0 then u else v)

Semiring in Mathlib.Algebra.Ring.Defs

def OracleReduction.append (R‚ÇÅ : OracleReduction oSpec Stmt‚ÇÅ OStmt‚ÇÅ Wit‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ Wit‚ÇÇ pSpec‚ÇÅ)
    (R‚ÇÇ : OracleReduction oSpec Stmt‚ÇÇ OStmt‚ÇÇ Wit‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ Wit‚ÇÉ pSpec‚ÇÇ) :
      OracleReduction oSpec Stmt‚ÇÅ OStmt‚ÇÅ Wit‚ÇÅ Stmt‚ÇÉ OStmt‚ÇÉ Wit‚ÇÉ (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ) where
  prover := Prover.append R‚ÇÅ.prover R‚ÇÇ.prover
  verifier := OracleVerifier.append R‚ÇÅ.verifier R‚ÇÇ.verifier

@[reducible]
def pSpecCommit (i : Fin ‚Ñì) : ProtocolSpec 1 :=
  ‚ü®![Direction.P_to_V],
   ![OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i.val + 1, by admit /- proof elided -/
   ‚ü©]‚ü©

@[reducible, inline, specialize]
instance challengeOracleInterface {pSpec : ProtocolSpec n} :
    ‚àÄ i, OracleInterface (pSpec.Challenge i) := fun i =>
  { Query := Unit
    Response := pSpec.Challenge i
    answer := fun c _ => c }

noncomputable def canonicalRepOfùí™ {H : F[X][Y]} (Œ≤ : ùí™ H) : F[X][Y] :=
  Polynomial.modByMonic Œ≤.out (H_tilde' H)

Fin.addCases in Init.Data.Fin.Lemmas

OracleSpec.DecidableEq in VCVio.OracleComp.OracleSpec

abbrev OutputStatement := StatementRound R _ (.last n)

def proximityGap (d : ‚Ñï) (bound : ‚Ñï) : Prop :=
  ‚àÄ u v : n ‚Üí F, (proximityMeasure C u v d > bound)
    ‚Üí (Œî‚ÇÄ( u ‚ãà v , C ^‚ãà Fin 2 ) ‚â§ d)

structure OracleContext.Lens (OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut : Type)
    {Outer_Œπ‚Çõ·µ¢ : Type} (OuterOStmtIn : Outer_Œπ‚Çõ·µ¢ ‚Üí Type) [‚àÄ i, OracleInterface (OuterOStmtIn i)]
    {Outer_Œπ‚Çõ‚Çí : Type} (OuterOStmtOut : Outer_Œπ‚Çõ‚Çí ‚Üí Type) [‚àÄ i, OracleInterface (OuterOStmtOut i)]
    {Inner_Œπ‚Çõ·µ¢ : Type} (InnerOStmtIn : Inner_Œπ‚Çõ·µ¢ ‚Üí Type) [‚àÄ i, OracleInterface (InnerOStmtIn i)]
    {Inner_Œπ‚Çõ‚Çí : Type} (InnerOStmtOut : Inner_Œπ‚Çõ‚Çí ‚Üí Type) [‚àÄ i, OracleInterface (InnerOStmtOut i)]
    (OuterWitIn OuterWitOut InnerWitIn InnerWitOut : Type) where
  stmt : OracleStatement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                                  OuterOStmtIn OuterOStmtOut InnerOStmtIn InnerOStmtOut
  wit : Witness.Lens (OuterStmtIn √ó ‚àÄ i, OuterOStmtIn i) (InnerStmtOut √ó ‚àÄ i, InnerOStmtOut i)
                          OuterWitIn OuterWitOut InnerWitIn InnerWitOut

RingHom in Mathlib.Algebra.Ring.Hom.Defs

def OuterStmtOut_Test := ‚Ñ§[X] √ó ‚Ñ§[X] √ó ‚Ñ§ √ó ‚Ñ§

@[simp]
abbrev OracleStatement.AfterSendEvalClaim : R1CS.MatrixIdx ‚äï R1CS.MatrixIdx ‚äï Fin 1 ‚Üí Type :=
  Sum.elim (EvalClaim R) (OracleStatement.AfterFirstSumcheck R pp)

def extractNextSuffixFromChallenge (v : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®0, by omega‚ü©)
    (i : ‚Ñï) (h_i_add_œë_le_‚Ñì : i + œë ‚â§ ‚Ñì) :
    (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®i + œë, by omega‚ü© :=

def Rhs (e : ‚Ñï) (œâs f : Fin n ‚Üí F) (i : Fin n) : F :=
  let Œ±·µ¢ := œâs i
  (-(f i) * Œ±·µ¢^e)

Set.Pairwise in Mathlib.Logic.Pairwise

def inputRelation : Set ((StmtIn R √ó (‚àÄ i, OStmtIn R deg i)) √ó Unit) :=
  { ‚ü®‚ü®target, oStmt‚ü©, _‚ü© | ‚àë x ‚àà (univ.map D), (oStmt ()).1.eval x = target }

@[inline, specialize, simp]
def oracleReduction : OracleReduction oSpec
    Statement OStatement Witness Statement OStatement Witness !p[] := OracleReduction.id

@[reducible]
def value (op : MemoryWrite Œπ Œ±) := op.2

@[simp]
def poly (k : ‚Ñï) : Polynomial (BTField k) := definingPoly (s:=(Z k))

Fintype in Mathlib.Data.Fintype.Defs

noncomputable def œÄ_z_lift {H : F[X][Y]} (z : F) (root : rationalRoot (H_tilde' H) z) :
  F[X][Y] ‚Üí+* F := Polynomial.evalEvalRingHom z root.1

@[reducible]
def coeffs {R : Type*} (p : UniPoly R) : Array R := p

def dropLastWhile (p : Œ± ‚Üí Bool) (l : List Œ±) : List Œ± :=
  (l.reverse.dropWhile p).reverse

Subtype.fintype in Mathlib.Data.Fintype.Sets

def BBF_SumcheckMultiplierParam : SumcheckMultiplierParam L ‚Ñì (SumcheckBaseContext L ‚Ñì) :=
  { multpoly := fun ctx => BBF_eq_multiplier ctx.t_eval_point }

DivisionSemiring in Mathlib.Algebra.Field.Defs

@[reducible]
def Statement (F : Type) (i : Fin (k + 1)) : Type := Fin i.val ‚Üí F

class DuplexSpongeInterface (U : Type) [SpongeUnit U] (Œ± : Type*)
    extends Inhabited Œ±, Zero Œ±, Initialize Œ± (Vector UInt8 32) where
   
  absorbUnchecked : Œ± √ó Array U ‚Üí Œ±

   
  squeezeUnchecked : Œ± √ó Array U ‚Üí Œ± √ó Array U

   
  ratchetUnchecked : Œ± ‚Üí Œ±

@[reducible, simp]
def OracleContext.Lens.IsComplete {OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut : Type}
    {Outer_Œπ‚Çõ·µ¢ : Type} {OuterOStmtIn : Outer_Œπ‚Çõ·µ¢ ‚Üí Type} [‚àÄ i, OracleInterface (OuterOStmtIn i)]
    {Outer_Œπ‚Çõ‚Çí : Type} {OuterOStmtOut : Outer_Œπ‚Çõ‚Çí ‚Üí Type} [‚àÄ i, OracleInterface (OuterOStmtOut i)]
    {Inner_Œπ‚Çõ·µ¢ : Type} {InnerOStmtIn : Inner_Œπ‚Çõ·µ¢ ‚Üí Type} [‚àÄ i, OracleInterface (InnerOStmtIn i)]
    {Inner_Œπ‚Çõ‚Çí : Type} {InnerOStmtOut : Inner_Œπ‚Çõ‚Çí ‚Üí Type} [‚àÄ i, OracleInterface (InnerOStmtOut i)]
    {OuterWitIn OuterWitOut InnerWitIn InnerWitOut : Type}
    (outerRelIn : Set ((OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i)) √ó OuterWitIn))
    (innerRelIn : Set ((InnerStmtIn √ó (‚àÄ i, InnerOStmtIn i)) √ó InnerWitIn))
    (outerRelOut : Set ((OuterStmtOut √ó (‚àÄ i, OuterOStmtOut i)) √ó OuterWitOut))
    (innerRelOut : Set ((InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i)) √ó InnerWitOut))
    (compat : (OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i)) √ó OuterWitIn ‚Üí
              (InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i)) √ó InnerWitOut ‚Üí Prop)
    (lens : OracleContext.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                                    OuterOStmtIn OuterOStmtOut InnerOStmtIn InnerOStmtOut
                                    OuterWitIn OuterWitOut InnerWitIn InnerWitOut) :=
  Context.Lens.IsComplete outerRelIn innerRelIn outerRelOut innerRelOut compat lens.toContext

def rbrSoundness (langIn : Set StmtIn) (langOut : Set StmtOut)
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    (rbrSoundnessError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) : Prop :=
  ‚àÉ stateFunction : verifier.StateFunction init impl langIn langOut,
  ‚àÄ stmtIn ‚àâ langIn,
  ‚àÄ WitIn WitOut : Type,
  ‚àÄ witIn : WitIn,
  ‚àÄ prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec,
  ‚àÄ i : pSpec.ChallengeIdx,
    [fun ‚ü®transcript, challenge‚ü© =>
      ¬¨ stateFunction i.1.castSucc stmtIn transcript ‚àß
        stateFunction i.1.succ stmtIn (transcript.concat challenge)
    | do
      (simulateQ (impl ++‚Çõ‚Çí challengeQueryImpl : QueryImpl _ (StateT œÉ ProbComp))
        (do
          let ‚ü®transcript, _‚ü© ‚Üê prover.runToRound i.1.castSucc stmtIn witIn
          let challenge ‚Üê liftComp (pSpec.getChallenge i) _
          return (transcript, challenge))).run' (‚Üê init)] ‚â§
      rbrSoundnessError i

class LawfulHasPred (T : Type u) [HasSucc T] [HasPred T] : Prop where
   
  pred'_succ : ‚àÄ x : T, pred' (succ' x) = x

noncomputable def fromConcreteBTF0 : ConcreteBTField 0 ‚Üí (GF(2)) :=
  fun x => if decide (x = zero) then 0 else 1

def OracleVerifier.append (V‚ÇÅ : OracleVerifier oSpec Stmt‚ÇÅ OStmt‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : OracleVerifier oSpec Stmt‚ÇÇ OStmt‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ pSpec‚ÇÇ) :
      OracleVerifier oSpec Stmt‚ÇÅ OStmt‚ÇÅ Stmt‚ÇÉ OStmt‚ÇÉ (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ) where
  verify := fun stmt challenges => by admit /- proof elided -/
|
    
    .trans (.sumMap V‚ÇÅ.embed (.refl _)) <|
    
    .trans (Equiv.sumAssoc _ _ _).toEmbedding <|
    
    .sumMap (.refl _) MessageIdx.sumEquiv.toEmbedding

  hEq := fun i => by admit /- proof elided -/

def toEvalsZeroOne (p : MvPolynomial œÉ R) : (œÉ ‚Üí Fin 2) ‚Üí R :=
  fun x => eval (x : œÉ ‚Üí R) p

def reduction : Reduction oSpec (StmtIn R √ó (‚àÄ i, OStmtIn R deg i)) Unit
                                (StmtOut R √ó (‚àÄ i, OStmtOut R deg i)) Unit (pSpec R deg) where
  prover := prover R deg oSpec
  verifier := verifier R deg D oSpec

LinearMap in Mathlib.Algebra.Module.LinearMap.Defs

def canonicalEmbedding (k : ‚Ñï) : BTField k ‚Üí+* BTField (k+1) :=
  AdjoinRoot.of (poly k)

def pSpecQuery : ProtocolSpec 1 :=
  ‚ü®![Direction.V_to_P],
    ![Fin Œ≥_repetitions ‚Üí sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate 0]‚ü©

noncomputable def distToCode [LinearOrder Œ±] [Zero Œ±]
                             (w : Œπ ‚Üí F) (C : Set (Œπ ‚Üí F))
                             (Œ¥f : (Œπ ‚Üí F) ‚Üí (Œπ ‚Üí F) ‚Üí Œ±)
                             (h : (possibleDistsToCode w C Œ¥f).Finite) : WithTop Œ± :=
  haveI := @Fintype.ofFinite _ h
  (possibleDistsToCode w C Œ¥f).toFinset.min

inductive InternalData (Œ± : Type) : Skeleton ‚Üí Type
  | leaf : InternalData Œ± Skeleton.leaf
  | internal {left right} (value : Œ±)
      (leftData : InternalData Œ± left)
      (rightData : InternalData Œ± right) : InternalData Œ± (Skeleton.internal left right)
  deriving Repr

Mul in Init.Prelude

instance {s} : LawfulFunctor (fun Œ± => InternalData Œ± s) :=

@[reducible, inline]
instance instMvPolynomial : OracleInterface (R[X œÉ]) where
  Query := œÉ ‚Üí R
  Response := R
  answer := fun poly point => eval point poly

@[inline, reducible]
protected def id :
    Context.Lens OuterStmtIn OuterStmtOut OuterStmtIn OuterStmtOut
                OuterWitIn OuterWitOut OuterWitIn OuterWitOut where
  stmt := Statement.Lens.id
  wit := Witness.Lens.id

alias trivial := Context.Lens.id

Coe in Init.Coe

instance (k : ‚Ñï) : Fintype (ConcreteBTField k) := (getBTFResult k).instFintype

@[inline, specialize]
def oracleProver : OracleProver oSpec
    Statement OStatement Unit Statement OStatement Unit !p[] where
  PrvState := fun _ => Statement √ó (‚àÄ i, OStatement i)
  input := Prod.fst
  sendMessage := fun i => nomatch i
  receiveChallenge := fun i => nomatch i
  output := fun stmt => pure (stmt, ())

ZeroMemClass in Mathlib.Algebra.Group.Submonoid.Defs

def evalWAt (i : Fin r) (x : L) : L :=
  ((getUElements (Œ≤ := Œ≤) (‚Ñì := ‚Ñì) (R_rate := R_rate) i).map (fun u => x - u)).prod

def isScalarTower_succ_right (l r : ‚Ñï) (h_le : l ‚â§ r) :=
    instAlgebraTowerConcreteBTF.toIsScalarTower (i:=l) (j:=r) (k:=r+1)
    (h1:=by admit /- proof elided -/
    ) (h2:=by admit /- proof elided -/
    )

instance [Zero T] [ToNat T] : Mul (Cayley T) where
  mul := mul

@[inline, specialize]
def Prover.runToRoundDSFS [‚àÄ i, VCVCompatible (pSpec.Challenge i)] (i : Fin (n + 1))
    (stmt : StmtIn) (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec)
    (state : prover.PrvState 0) :
        OracleComp (oSpec ++‚Çí duplexSpongeChallengeOracle StmtIn U)
          (pSpec.MessagesUpTo i √ó
            DuplexSponge U (Vector U SpongeSize.N) √ó prover.PrvState i) :=
  Fin.induction
    (do
      
      let sponge ‚Üê liftM (DuplexSponge.start stmt)
      return ‚ü®default, sponge, state‚ü©
    )
    (prover.processRoundDSFS)
    i

@[inline] def ge [Zero T] [ToNat T] (a b : Cayley T) : Prop :=
  (a : Nat) ‚â• (b : Nat)

@[inline]
def add [Add R] (p q : MlPolyEval R n) : MlPolyEval R n := Vector.zipWith (¬∑ + ¬∑) p q

class ProverLast (pSpec : ProtocolSpec n) [inst : NeZero n] where
  prover_last' : pSpec.dir ‚ü®n - 1, by admit /- proof elided -/
  ‚ü© = .P_to_V

def powFiberT (i : ‚Ñï) {k : ‚Ñï} {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F} (S' : Finset (indexPowT S œÜ i))
  (œÜ' : (indexPowT S œÜ i) ‚Ü™ F) (y : indexPowT S œÜ k) :=
  { x : (indexPowT S œÜ i) // x ‚àà S' ‚àß (œÜ' x) ^ (2^(k-i)) = y.val }

instance (k : ‚Ñï) : LE (ConcreteBTField k) where
  le := fun x y => by admit /- proof elided -/

Vector.get in Init.Data.Vector.Basic

noncomputable def commitRbrExtractor (i : Fin ‚Ñì) :
  Extractor.RoundByRound []‚Çí
    (StmtIn := (Statement (L := L) Context i.succ) √ó (‚àÄ j, OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc j))
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (pSpec := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)
    (WitMid := fun _messageIdx => Witness (L := L) ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ) where
  eqIn := rfl
  extractMid := fun _ _ _ witMidSucc => witMidSucc
  extractOut := fun _ _ witOut => witOut

QueryImpl.impl in VCVio.OracleComp.SimSemantics.SimulateQ

def eval (x : Fin numWires ‚Üí ùì°) (g : Gate ùì° numWires) : ùì° :=
  g.qL * x g.a + g.qR * x g.b + g.qO * x g.c + g.qM * (x g.a * x g.b) + g.qC

def rationalRoot (H : F[X][Y]) (z : F) : Type :=
  {t_z : F // evalEval z t_z H = 0}

IsCyclic in Mathlib.Algebra.Group.Defs

instance {i : ‚Ñï} : IsCyclicWithGen (evalDomain D i) :=

structure PrattCertificate' (p : ‚Ñï) : Type where
  a : ZMod p
  pow_eq_one : a ^ (p - 1) = 1
  part : PrattPartList p a (p - 1)

Vector.drop in Init.Data.Vector.Basic

inductive member (a : Œ±) : List Œ± ‚Üí Type v where
  | first : member a (a :: is)
  | next : member a is ‚Üí member a (b :: is)

MonomialOrder in Mathlib.Data.Finsupp.MonomialOrder

instance (priority := low) : DCast‚ÇÉ Œ± Œ≤ Œ≥ Œ¥ where
  dcast‚ÇÉ ha hb hc d := by admit /- proof elided -/

def challengeTensorProduct (steps : ‚Ñï) (r_challenges : Fin steps ‚Üí L) : Vector L (2 ^ steps) :=
  if h_steps_zero : steps = 0 then
    
    by
      rw [h_steps_zero, pow_zero]
      exact ‚ü®#[1], rfl‚ü©
  else
    
    Nat.rec
      (motive := fun k => k ‚â§ steps ‚Üí Vector L (2^k))
      (fun _ => ‚ü®#[1], rfl‚ü©)  
      (fun k ih h_k_le =>
        
        let prev_vec := ih (Nat.le_trans (Nat.le_succ k) h_k_le)
        let r_k := r_challenges ‚ü®k, by admit /- proof elided -/
        ‚ü©
        
        Vector.ofFn (fun idx : Fin (2^k.succ) =>
          let prev_idx : Fin (2^k) := ‚ü®idx.val / 2, by admit /- proof elided -/
            ‚ü©
          let bit := idx.val % 2
          let prev_val := prev_vec.get prev_idx
          if bit = 0 then (1 - r_k) * prev_val else r_k * prev_val))
      steps (le_refl steps)

def proximityChecksSpec (Œ≥_challenges :
    Fin Œ≥_repetitions ‚Üí sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®0, by omega‚ü©)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì) j)
    (fold_challenges : Fin ‚Ñì ‚Üí L) (final_constant : L) : Prop :=
  ‚àÄ rep : Fin Œ≥_repetitions,
    let v := Œ≥_challenges rep
    -- For all folding levels k = 0, ..., ‚Ñì/œë - 1, we track c_cur through the iterations
    ‚àÄ k_val : Fin (‚Ñì / œë),
      let i := k_val.val * œë
      have h_k: k_val ‚â§ (‚Ñì/œë - 1) := by omega
      have h_i_add_œë_le_‚Ñì : i + œë ‚â§ ‚Ñì := by
        calc i + œë = k_val * œë + œë := by omega
          _ ‚â§ (‚Ñì/œë - 1) * œë + œë := by
            apply Nat.add_le_add_right; apply Nat.mul_le_mul_right; omega
          _ = ‚Ñì/œë * œë :=

def masterKStateProp (stmtIdx : Fin (‚Ñì + 1))
    (oracleIdx : Fin (‚Ñì + 1))
    (h_le : oracleIdx.val ‚â§ stmtIdx.val) (stmt : Statement (L := L) Context stmtIdx)
    (wit : Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) stmtIdx)
    (oStmt : ‚àÄ j, (OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (i := oracleIdx) j))
    (localChecks : Prop := True) : Prop :=
  let oracleWitnessConsistency: Prop := oracleWitnessConsistency (mp := mp) (ùìë := ùìë) ùîΩq Œ≤
    stmtIdx oracleIdx h_le stmt wit oStmt
  let badEventExists := badEventExistsProp (œë := œë) ùîΩq Œ≤ oracleIdx
    (challenges := Fin.take (m := oracleIdx) (v := stmt.challenges) (h := by admit /- proof elided -/
    ))
    (oStmt := oStmt)
  localChecks ‚àß (badEventExists ‚à® oracleWitnessConsistency)

structure ConcreteBTFRingProps (k : ‚Ñï) extends (ConcreteBTFAddCommGroupProps k) where
  
  mul_eq : ‚àÄ (a b : ConcreteBTField k) (h_k : k > 0)
    {a‚ÇÅ a‚ÇÄ b‚ÇÅ b‚ÇÄ : ConcreteBTField (k - 1)}
    (_h_a : (a‚ÇÅ, a‚ÇÄ) = split h_k a) (_h_b : (b‚ÇÅ, b‚ÇÄ) = split h_k b),
    concrete_mul a b =
      „Ää concrete_mul a‚ÇÄ b‚ÇÅ + concrete_mul b‚ÇÄ a‚ÇÅ + concrete_mul (concrete_mul a‚ÇÅ b‚ÇÅ) (Z (k - 1)),
      concrete_mul a‚ÇÄ b‚ÇÄ + concrete_mul a‚ÇÅ b‚ÇÅ „Äã

  
  zero_mul : ‚àÄ a : ConcreteBTField k, concrete_mul zero a = zero
  zero_mul' : ‚àÄ a : ConcreteBTField k, concrete_mul 0 a = 0
  mul_zero : ‚àÄ a : ConcreteBTField k, concrete_mul a zero = zero
  mul_zero' : ‚àÄ a : ConcreteBTField k, concrete_mul a 0 = 0
  one_mul : ‚àÄ a : ConcreteBTField k, concrete_mul one a = a
  mul_one : ‚àÄ a : ConcreteBTField k, concrete_mul a one = a

  
  mul_assoc : ‚àÄ a b c : ConcreteBTField k, concrete_mul (concrete_mul a b) c
    = concrete_mul a (concrete_mul b c)
  mul_left_distrib : ‚àÄ a b c : ConcreteBTField k, concrete_mul a (b + c)
    = concrete_mul a b + concrete_mul a c
  mul_right_distrib : ‚àÄ a b c : ConcreteBTField k, concrete_mul (a + b) c
    = concrete_mul a c + concrete_mul b c

HPow in Init.Prelude

Module.Basis.smulTower in Mathlib.RingTheory.AlgebraTower

class ByteDomainSeparator (Œ± : Type*) where
   
  addBytes : Œ± ‚Üí Nat ‚Üí String ‚Üí Œ±
   
  hint : Œ± ‚Üí String ‚Üí Œ±
   
  challengeBytes : Œ± ‚Üí Nat ‚Üí String ‚Üí Œ±

def generateProof {s} (cache_tree : FullData Œ± s) :
    BinaryTree.SkeletonLeafIndex s ‚Üí List Œ±
  | .ofLeaf => []
  | .ofLeft idxLeft =>
    (cache_tree.rightSubtree).getRootValue ::
      (generateProof cache_tree.leftSubtree idxLeft)
  | .ofRight idxRight =>
    (cache_tree.leftSubtree).getRootValue ::
      (generateProof cache_tree.rightSubtree idxRight)

def findFinIdx (p : Œ± ‚Üí Bool) (l : List Œ±) : Fin (l.length + 1) :=
  ‚ü®List.findIdx' p l,
    Nat.lt_succ_of_le (by admit /- proof elided -/
    )‚ü©

def fromNat {k : ‚Ñï} (n : Nat) : ConcreteBTField k :=
  BitVec.ofNat (2 ^ k) n

instance : Fintype BTF‚ÇÉ := (inferInstance : Fintype (ConcreteBTField 3))

def pSpecSumcheckFold := (pSpecNonLastBlocks ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)) ++‚Çö
  (pSpecLastBlock (L:=L) (œë:=œë))

@[reducible, simp] def StmtIn := Unit

@[simp]
instance Nontrivial (k : ‚Ñï) : Nontrivial (BTField k) := inferInstance

def inputRelation (cond : ‚àë i, (s i).1 ‚â§ n) [DecidableEq F] (Œ¥ : ‚Ñù‚â•0) :
    Set
      (
        (FinalStatement F k √ó ‚àÄ j, FinalOracleStatement D x s j) √ó
        Witness F s d (Fin.last (k + 1))
      )
  := FinalFoldPhase.outputRelation D x s d cond Œ¥

noncomputable def mVdecode :
  (smoothCode domain m) ‚Üí‚Çó[F] MvPolynomial (Fin m) F :=
    linearMvExtension.comp decodeLT

def take (j : Fin (n + 1)) (messages : Messages pSpec) : MessagesUpTo j pSpec :=

def univPolyHom {F : Type} [CommRing F] [IsDomain F] : F[X] ‚Üí+* RatFunc F :=
  algebraMap (F[X]) (RatFunc F)

Lean.PrettyPrinter.Unexpander in Init.Prelude

inductive Program where
</all_available_defs>

<all_available_lemmas>
BitVec.xor_self in Init.Data.BitVec.Lemmas
BitVec.eq_zero_or_eq_one in Init.Data.BitVec.Lemmas
BitVec.xor_eq_zero_iff in Init.Data.BitVec.Lemmas
if_neg in Init.Core
ne_eq in Init.SimpLemmas
not_false_eq_true in Init.SimpLemmas
one_ne_zero in Mathlib.Algebra.NeZero

theorem List.getElem_append_left{Œ± : Type u_1} {l‚ÇÅ l‚ÇÇ : List Œ±} {i : Nat} (hn : i < l‚ÇÅ.length) :\n(l‚ÇÅ ++ l‚ÇÇ)[i] = l‚ÇÅ[i]

omit [NeZero ‚Ñì] [NeZero r] [NeZero ùì°] in
lemma fin_r_succ_bound {h_‚Ñì_add_R_rate : ‚Ñì + ùì° < r} (i : Fin r) (h_i : i + 1 < ‚Ñì + ùì°)
    : i + 1 < r

omit [Finite F] in
lemma sqr_mem_D_succ_i_of_mem_D_i : ‚àÄ {a : FÀ£} {i : ‚Ñï},
    a ‚àà evalDomain D x i ‚Üí a ^ 2 ‚àà evalDomain D x (i + 1)

@[simp]
lemma constantCode_eq_ofNat_zero_iff [Nonempty Œπ] :
  constantCode x Œπ = 0 ‚Üî x = 0

@[simp]
lemma zero_le_relHammingDist : 0 ‚â§ Œ¥·µ£(u, v)

@[simp]
theorem cast_perfectCompleteness (hComplete : R.perfectCompleteness init impl relIn relOut) :
    (R.cast hn hSpec hO‚Çò).perfectCompleteness init impl relIn relOut

@[simp, grind _=_]
lemma degreeY_mul [IsDomain F] (f g : F[X][Y]) (hf : f ‚â† 0) (hg : g ‚â† 0)
  : natDegreeY (f * g) = natDegreeY f + natDegreeY g

@[simp]
lemma dist_le_length [DecidableEq F] (inj : Function.Injective Œ±) :
    minDist ((ReedSolomon.code ‚ü®Œ±, inj‚ü© n) : Set (Fin m ‚Üí F)) ‚â§ m

lemma listOfCloseCodewords_eq_zero :
  listOfCloseCodewords C y n = 0 ‚Üî IsEmpty (hammingBall C y n) ‚à® Infinite (hammingBall C y n)

theorem prime_7 : Nat.Prime 7

theorem ZMod.powNeOfPowMod :
    ‚àÄ {n a' q c : ‚Ñï} (a : ZMod n), (a' : ZMod n) = a ‚Üí decide (n ‚â• 2) = true ‚Üí
      Nat.mod (Nat.pow a' ((n - 1) / q)) n = c ‚Üí decide (c ‚â† 1) = true ‚Üí a ^ ((n - 1) / q) ‚â† 1

theorem minDist [Field F] [DecidableEq F] (inj : Function.Injective Œ±) [NeZero n] (h : n ‚â§ m) :
  minDist ((ReedSolomon.code ‚ü®Œ±, inj‚ü© n) : Set (Fin m ‚Üí F)) = m - n + 1

@[simp]
theorem fappend_zero {Œ≤ : Fin m ‚Üí A} {Œ± : Fin 0 ‚Üí A}
    (u : (i : Fin m) ‚Üí F (Œ≤ i)) :
    fappend u (!h‚¶ÉF‚¶Ñ‚ü®Œ±‚ü©[] : (i : Fin 0) ‚Üí F (Œ± i)) = u

Finset.sup_lt_iff in Mathlib.Data.Finset.Lattice.Fold

lemma nsmul_succ {k : ‚Ñï} (n : ‚Ñï) (x : ConcreteBTField k) :
  (if ‚Üën.succ % 2 = 0 then zero else x) = (if ‚Üën % 2 = 0 then zero else x) + x

private lemma sum_1_over_n_aux_frac_k_i [Zero F]
  (h_n : 0 < n) : ‚àë i, 1/n * aux_frac B (K B i 0) = aux_frac B (k B)

@[simp]
theorem splitSum_embedSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (i : Fin m) (j : Fin (n i)) :
    splitSum (embedSum i j) = ‚ü®i, j‚ü©

lemma h_middle_sub {k : ‚Ñï} : 2 ^ (k - 1) - 1 - 0 + 1 = 2 ^ (k - 1)

@[simp]
lemma eval_solutionToQ {x : F} :
  eval x (solutionToQ e k v) =
  ‚àë i ‚àà Finset.range (e + k), liftF v (e + i) * x ^ i

@[simp] theorem findIdx'_nil {p : Œ± ‚Üí Bool} : findIdx' p [] = 0

@[simp]
lemma dotProduct_cons [AddCommMonoid R] [Mul R] (a : R) (b : Vector R n) (c : R) (d : Vector R n) :
  dotProduct (cons a b) (cons c d) = a * c + dotProduct b d

lemma and_two_pow_eq_zero_of_getBit_0 {n i : ‚Ñï} (h_getBit : getBit i n = 0)
    : n &&& (2 ^ i) = 0

theorem split_mul_eq_mul_split {k : ‚Ñï} (h_pos : k > 0) (x‚ÇÄ x‚ÇÅ : ConcreteBTField k)
  (hi‚ÇÄ lo‚ÇÄ hi‚ÇÅ lo‚ÇÅ : ConcreteBTField (k - 1))
  (h_split_x‚ÇÄ : split h_pos x‚ÇÄ = (hi‚ÇÄ, lo‚ÇÄ))
  (h_split_x‚ÇÅ : split h_pos x‚ÇÅ = (hi‚ÇÅ, lo‚ÇÅ)) :
  split h_pos (x‚ÇÄ * x‚ÇÅ) =
    (lo‚ÇÄ * hi‚ÇÅ + lo‚ÇÅ * hi‚ÇÄ + hi‚ÇÄ * hi‚ÇÅ * Z (k - 1), lo‚ÇÄ * lo‚ÇÅ + hi‚ÇÄ * hi‚ÇÅ)

lemma and_eq_zero_iff {n m : ‚Ñï} : n &&& m = 0 ‚Üî ‚àÄ k, (n >>> k) &&& (m >>> k) = 0

Nat.lt_succ_of_lt in Init.Data.Nat.Basic

lemma add_shiftRight_distrib {n m k : ‚Ñï} (h_and_zero : n &&& m = 0):
  (n + m) >>> k = (n >>> k) + (m >>> k)

Fin.ext in Init.Data.Fin.Lemmas

lemma rounds_sub_steps_lt : ‚Ñì - œë < ‚Ñì :=
  Nat.sub_lt (pos_of_neZero ‚Ñì) (folding_steps_pos)

lemma œë_sub_one_le_self : œë - 1 < œë

@[simp]
theorem bit_revFinProdFinEquiv_symm_2_pow_succ {n : ‚Ñï} (j : Fin (2 ^ (n + 1))) (i : Fin (n + 1)):
  let e : Fin (2 ^ n * 2) ‚âÉ Fin (2 ^ n) √ó Fin 2 :=revFinProdFinEquiv (m:=2^(n)) (n:=2)
    (h_m:=by exact Nat.two_pow_pos n).symm
  let msb : Fin 2 := (e j).2
  let lsbs : Fin (2 ^ n) := (e j).1
  Nat.getBit (i) j = if i.val < n then Nat.getBit (i.val) lsbs else msb

Nat.add_left_cancel in Init.Data.Nat.Basic

@[simp]
lemma finite_possibleRelHammingDists : (possibleRelHammingDists C).Finite

@[simp]
lemma seqCompose_def {m : ‚Ñï}
    (Stmt : Fin (m + 1) ‚Üí Type) {Œπ‚Çõ : Fin (m + 1) ‚Üí Type} (OStmt : (i : Fin (m + 1)) ‚Üí Œπ‚Çõ i ‚Üí Type)
    (Wit : Fin (m + 1) ‚Üí Type) {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (P : (i : Fin m) ‚Üí
      OracleProver oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Wit i.castSucc)
        (Stmt i.succ) (OStmt i.succ) (Wit i.succ) (pSpec i)) :
    seqCompose Stmt OStmt Wit P = Prover.seqCompose (fun i => Stmt i √ó (‚àÄ j, OStmt i j)) Wit P

@[simp, grind] lemma R_le_N : sz.R ‚â§ sz.N

@[simp]
theorem vappend_vempty (v : Fin m ‚Üí Œ±) : vappend v !v[] = v

@[simp]
lemma dfoldr'_succ {n : ‚Ñï} {Œ± : Fin (n + 1 + 1) ‚Üí Type u}
    (f : (i : Fin (n + 1)) ‚Üí Œ± i.succ ‚Üí Œ± i.castSucc) (x : Œ± (last (n + 1))) :
    dfoldr' (n + 1) Œ± f x = f 0 (dfoldr' n (Œ± ‚àò succ) (fun i => f i.succ) x)

theorem cast_eq_dcast‚ÇÇ {V : Verifier oSpec StmtIn StmtOut pSpec‚ÇÅ} :
    V.cast hn hSpec = dcast‚ÇÇ hn hSpec V

lemma oodSampling_crs_eq_rs
    {f : Œπ ‚Üí F} {m s : ‚Ñï} {œÜ : Œπ ‚Ü™ F} [Smooth œÜ]
    (l Œ¥ : ‚Ñù‚â•0) (hŒ¥Le : Œ¥ ‚â§ 1)
    {C : Set (Œπ ‚Üí F)} (hcode : C = smoothCode œÜ m ‚àß listDecodable C Œ¥ l) :
    Pr_{ let rs ‚Üê$·µñ (Fin s ‚Üí F) }[ (‚àÉ œÉ : Fin s ‚Üí F,
                        let w : Fin s ‚Üí MvPolynomial (Fin (m + 1)) F :=
                          fun i =>
                            let ri := rs i
                            let rVec := fun j : Fin m => ri ^ (2^(j : ‚Ñï))
                            MvPolynomial.X (Fin.last m) * rename Fin.castSucc (eqPolynomial rVec)
                        let multiCRSCode := multiConstrainedCode œÜ m s w œÉ
                        ‚àÉ u u' : Œπ ‚Üí F, u ‚â† u' ‚àß
                          u ‚àà relHammingBall multiCRSCode f Œ¥ ‚àß
                          u' ‚àà relHammingBall multiCRSCode f Œ¥)]
    =
    Pr_{ let rs ‚Üê$·µñ (Fin s ‚Üí F) }[ (‚àÉ u u' : smoothCode œÜ m,
                        u.val ‚â† u'.val ‚àß
                        u.val ‚àà relHammingBall C f Œ¥ ‚àß
                        u'.val ‚àà relHammingBall C f Œ¥ ‚àß
                        ‚àÄ i : Fin s,
                          let ri := rs i
                          let rVec := fun j : Fin m => ri ^ (2^(j : ‚Ñï))
                          (mVdecode u).eval (rVec) = (mVdecode u').eval (rVec))]

@[simp, grind] lemma fin_chunkSize_plus_absorbPos_lt_N (absorbPos arrSize : Nat)
    (i : Fin (min arrSize (SpongeSize.R - absorbPos))) :
    absorbPos + i < SpongeSize.N

lemma zero_is_0 {k : ‚Ñï} : (zero (k:=k)) = (0 : ConcreteBTField k)

@[simp]
theorem induction_two {motive : Fin 3 ‚Üí Sort*} {zero : motive 0}
    {succ : ‚àÄ i : Fin 2, motive i.castSucc ‚Üí motive i.succ} :
      induction (motive := motive) zero succ (last 2) = succ 1 (succ 0 zero)

theorem oracleVerifier_rbrKnowledgeSoundness [Fintype R] :
    (oracleReduction R deg oSpec).verifier.rbrKnowledgeSoundness init impl
      (inputRelation R deg D) (outputRelation R deg)
        (fun _ => (deg : ‚Ñù‚â•0) / (Fintype.card R))

theorem fcons_left_injective {Œ≤ : Fin n ‚Üí A} (b : (i : Fin n) ‚Üí F (Œ≤ i)) :
    Function.Injective (fun (a : F Œ±) => fcons a b)

@[simp]
lemma coeff_polynomialOfCoeffs_eq_coeffs'' :
  (polynomialOfCoeffs coeffs).coeff = Fin.liftF coeffs

lemma fintype_card_gt_one_of_field (K : Type*) [Field K] [Fintype K] :
  1 < Fintype.card K

lemma num_eq_highBits_add_lowBits {n: ‚Ñï} (numLowBits: ‚Ñï) :
  n = getHighBits numLowBits n + getLowBits numLowBits n

@[simp]
theorem LeafData.get_internal_ofRight {Œ±} {s_left s_right : Skeleton}
    (left : LeafData Œ± s_left) (right : LeafData Œ± s_right)
    (idxRight : SkeletonLeafIndex s_right) :
    (LeafData.internal left right).get (SkeletonLeafIndex.ofRight idxRight) =
      right.get idxRight

lemma evenize_is_even {f : Polynomial F} :
    EvenPoly (evenize f)

private lemma cast_eq_cast_same_type {Œ± Œ≤ : Sort u} (h1 h2 : Œ± = Œ≤) {x y : Œ±}
    (h : cast h1 x = cast h2 y) : x = y

lemma towerRingHomBackwardMap_forwardMap_eq (k : ‚Ñï) (x : ConcreteBTField k) :
  towerRingHomBackwardMap (k:=k) (towerRingHomForwardMap (k:=k) x) = x

lemma zero_add {k : ‚Ñï} (a : ConcreteBTField k) : 0 + a = a

lemma add_self_cancel {k : ‚Ñï} (a : ConcreteBTField k) : a + a = 0

theorem cast_eq_dcast {m n : ‚Ñï} (h : m = n) (a : Fin m) :
    Fin.cast h a = dcast h a

lemma testBit_of_sub_two_pow_of_bit_1 {n i : ‚Ñï} (h_testBit_eq_1 : (n).testBit i = true) :
  (n - 2^i).testBit i = false

@[local grind _=_]
private lemma support_eq_support_toFinsupp {f : F[X][Y]} : f.support = f.toFinsupp.support

Nat.lt_of_le_of_lt in Init.Prelude

theorem iteratedQuotientMap_k_eq_1_is_qMap (i : Fin ‚Ñì)
    (h_i_add_1 : i.val + 1 ‚â§ ‚Ñì) (x : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®i, by omega‚ü©) :
    iteratedQuotientMap ùîΩq Œ≤ h_‚Ñì_add_R_rate i 1 h_i_add_1 x =
    ‚ü®(qMap ùîΩq Œ≤ ‚ü®i.val, by omega‚ü©).eval (x.val : L),
      qMap_eval_mem_sDomain_succ ùîΩq Œ≤   h_‚Ñì_add_R_rate i h_i_add_1 x‚ü©

theorem sum_fromNat_eq_from_xor_Nat {k : ‚Ñï} (x y : Nat) :
  fromNat (k:=k) (x ^^^ y) = fromNat (k:=k) x + fromNat (k:=k) y

theorem novelToMonomial_monomialToNovel_inverse
  (‚Ñì : ‚Ñï) (h_‚Ñì : ‚Ñì ‚â§ r) :
  ‚àÄ coeffs : Fin (2^‚Ñì) ‚Üí L,
    monomialToNovelCoeffs ùîΩq Œ≤ ‚Ñì h_‚Ñì
      (novelToMonomialCoeffs ùîΩq Œ≤ ‚Ñì h_‚Ñì coeffs) = coeffs

lemma towerAlgebraMap_id (k : ‚Ñï) : towerAlgebraMap (h_le:=by omega) = RingHom.id (BTField k)

@[simp]
lemma foldl'_succ {n : ‚Ñï} {Œ± : Type u} (f : (i : Fin (n + 1)) ‚Üí Œ± ‚Üí Œ±) (x : Œ±) :
    foldl' (n + 1) f x = f (last n) (foldl' n (fun i => f i.castSucc) x)

@[simp]
theorem Prover.runToRound_zero_of_prover_first
    (stmt : StmtIn) (wit : WitIn) (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      prover.runToRound 0 stmt wit = (pure (default, prover.input (stmt, wit)))

lemma rank_nonsquare_eq_deg_of_deg_le (inj : Function.Injective Œ±) (h : n ‚â§ m) :
  (Vandermonde.nonsquare (Œπ' := n) Œ±).rank = n

lemma eval‚ÇÇ_eq' {S : Type w} [CommSemiring S] (g : P ‚Üí+* S) (p : P) :
    g p = eval‚ÇÇ (g.comp (Algebra.ofId R P)) (g X) p

theorem ZMod.powEqOfPowMod :
   ‚àÄ {n a' c : ‚Ñï} (a : ZMod n), (a' : ZMod n) = a ‚Üí
      Nat.mod (Nat.pow a' (n - 1)) n = c ‚Üí c = 1 ‚Üí a ^ (n - 1) = 1

theorem frobenius_identity_in_algebra [Fact (Nat.Prime (ringChar Fq))]
  (f g : L[X]) : (f + g)^(Fintype.card Fq) = f^(Fintype.card Fq) + g^(Fintype.card Fq)

@[simp]
lemma evenize_coeff {f : Polynomial F} {n : ‚Ñï} :
    (evenize f).coeff n = if Even n then f.coeff (n / 2) else 0

theorem happend_hcons {Œ≤ : Fin m ‚Üí Sort u} {Œ≥ : Fin n ‚Üí Sort u}
    (a : Œ±) (u : (i : Fin m) ‚Üí Œ≤ i) (v : (i : Fin n) ‚Üí Œ≥ i) :
    True

theorem traceMapProperty_of_quadratic_extension
  (F_prev : Type*) [Field F_prev] [Fintype F_prev] (k : ‚Ñï)
  (fintypeCardPrev : Fintype.card F_prev = 2 ^ (2 ^ k))
  (t1 : F_prev) [instNeZero_t1 : NeZero t1]
  {F_cur : Type*} [Field F_cur] (u : F_cur) [instNeZero_u : NeZero u]
  [Algebra F_prev F_cur]
  (h_rel : SpecialElementRelation (t1 := t1) (u := u))
  (prev_trace_map : TraceMapProperty F_prev t1 (k))
  (sumZeroIffEq : ‚àÄ (x y : F_cur), x + y = 0 ‚Üî x = y)
  : TraceMapProperty F_cur u (k + 1)

theorem zipWith_cons {Œ± Œ≤ Œ≥} {n : ‚Ñï} (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥)
    (a : Œ±) (b : Vector Œ± n) (c : Œ≤) (d : Vector Œ≤ n) :
    zipWith f (cons a b) (cons c d) = cons (f a c) (zipWith f b d)

lemma addSalt_Challenge (i : pSpec.ChallengeIdx) :
    (pSpec.addSalt Salt).Challenge i = pSpec.Challenge i

@[simp]
theorem cast_id :
    OracleProver.cast rfl rfl =
      (id : OracleProver oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec‚ÇÅ ‚Üí _)

theorem dcast‚ÇÉ_symm (ha : a = a') (hb : dcast ha b = b') (hc : dcast‚ÇÇ ha hb c = c')
    (hd : dcast‚ÇÉ ha hb hc d = d') :
    dcast‚ÇÉ ha.symm (dcast_symm ha hb) (dcast‚ÇÇ_symm ha hb hc) d' = d

protected lemma roots_of_eloc_poly {x : F}
  (h : (ElocPoly n œâs f p).eval x = 0) :
  ‚àÉ i, i < n ‚àß f i ‚â† p.eval (œâs i)

lemma W_add_U_invariant
  (i : Fin r) :
  ‚àÄ x : L, ‚àÄ y ‚àà U ùîΩq Œ≤ i, (W ùîΩq Œ≤ i).eval (x + y) = (W ùîΩq Œ≤ i).eval x

@[simp]
theorem monomialBasis_zero {w : Vector R 0} : monomialBasis w = #v[1]

@[simp]
theorem fflatten‚ÇÇ_zero {A : Sort u} {B : Sort v} {F : A ‚Üí B ‚Üí Sort w} {n : Fin 0 ‚Üí ‚Ñï}
    {Œ± : (i : Fin 0) ‚Üí (j : Fin (n i)) ‚Üí A}
    {Œ≤ : (i : Fin 0) ‚Üí (j : Fin (n i)) ‚Üí B}
    {v : (i : Fin 0) ‚Üí (j : Fin (n i)) ‚Üí F (Œ± i j) (Œ≤ i j)} : fflatten‚ÇÇ v = !h[]

theorem eq_zero_or_eq_one {a : ConcreteBTField 0} : a = zero ‚à® a = one

theorem prime_17 : Nat.Prime 17

@[simp]
theorem OracleVerifier.run_eq_run_verifier [O‚Çò : ‚àÄ i, OracleInterface (pSpec.Message i)]
    {stmt : StmtIn} {oStmt : ‚àÄ i, OStmtIn i} {transcript : FullTranscript pSpec}
    {verifier : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec} :
      verifier.run stmt oStmt transcript =
        verifier.toVerifier.run ‚ü®stmt, oStmt‚ü© transcript

@[simp]
theorem cast_id :
    Reduction.cast rfl rfl = (id : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec‚ÇÅ ‚Üí _)

lemma concrete_mul_zero
  (prevBTFieldProps : ConcreteBTFieldProps (k := k - 1))
  (a : ConcreteBTField k) : concrete_mul a (zero (k:=k)) = zero (k:=k)

@[simp]
lemma challengeOracleInterface_append_domain_inl (j : pSpec‚ÇÅ.ChallengeIdx) :
    [(pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).Challenge]‚Çí.domain (.inl j) = Unit

omit [NeZero r] [NeZero ùì°] in
lemma isNeCommitmentRound (bIdx : Fin (‚Ñì / œë - 1)) (x : ‚Ñï) {hx : x < œë - 1} :
    ¬¨isCommitmentRound ‚Ñì œë ‚ü®‚ÜëbIdx * œë + x, by
      conv_rhs => rw [‚ÜêNat.add_zero (n:=‚Ñì)]
      change bIdx.val * œë + (‚ü®x, by omega‚ü©: Fin œë).val < ‚Ñì + 0
      apply bIdx_mul_œë_add_i_lt_‚Ñì_succ (m:=0)
    ‚ü©

@[simp]
theorem LeafData.get_internal_ofLeft {Œ±} {s_left s_right : Skeleton}
    (left : LeafData Œ± s_left) (right : LeafData Œ± s_right)
    (idxLeft : SkeletonLeafIndex s_left) :
    (LeafData.internal left right).get (SkeletonLeafIndex.ofLeft idxLeft) =
      left.get idxLeft

theorem concrete_mul_eq
  (prevBTFieldProps : ConcreteBTFieldProps (k := k - 1))
  (a b : ConcreteBTField k) {a‚ÇÅ a‚ÇÄ b‚ÇÅ b‚ÇÄ : ConcreteBTField (k - 1)}
  (h_a : (a‚ÇÅ, a‚ÇÄ) = split h_k a) (h_b : (b‚ÇÅ, b‚ÇÄ) = split h_k b) :
  concrete_mul a b =
    „Ää concrete_mul a‚ÇÄ b‚ÇÅ + concrete_mul b‚ÇÄ a‚ÇÅ + concrete_mul (concrete_mul a‚ÇÅ b‚ÇÅ) (Z (k - 1)),
      concrete_mul a‚ÇÄ b‚ÇÄ + concrete_mul a‚ÇÅ b‚ÇÅ „Äã

theorem embedSum_succ {m : ‚Ñï} {n : Fin (m + 1) ‚Üí ‚Ñï} {i : Fin (m + 1)} (j : Fin (n i)) :
    embedSum i j = (match i with
    | 0 => Fin.castAdd _ j
    | ‚ü®i + 1, h‚ü© => Fin.natAdd _ (embedSum ‚ü®i, Nat.succ_lt_succ_iff.mp h‚ü© j))

@[simp]
theorem OracleReduction.runWithLog_eq_runWithLog_reduction [‚àÄ i, OracleInterface (pSpec.Message i)]
    {stmt : StmtIn} {oStmt : ‚àÄ i, OStmtIn i} {wit : WitIn}
    {oracleReduction : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec} :
      oracleReduction.run stmt oStmt wit =
        oracleReduction.toReduction.run ‚ü®stmt, oStmt‚ü© wit

lemma comm_map_smul_add (s : Right) (x y : Right ‚äó[K] Left)
    (hx : e (s ‚Ä¢ x) = s ‚Ä¢ (e x)) (hy : e (s ‚Ä¢ y) = s ‚Ä¢ (e y)) :
    e (s ‚Ä¢ x) + e (s ‚Ä¢ y) = s ‚Ä¢ e x + s ‚Ä¢ e y

theorem natDegree_finSuccEquivNth (f : MvPolynomial (Fin (n + 1)) R) :
    (finSuccEquivNth R p f).natDegree = degreeOf p f

lemma cast_ConcreteBTField_eq (k m : ‚Ñï) (h_eq : k = m) :
  ConcreteBTField k = ConcreteBTField m

lemma sum_of_and_eq_zero_is_xor {n m : ‚Ñï} (h_n_AND_m : n &&& m = 0) : n + m = n ^^^ m

theorem towerEquiv_commutes_left (i j : ‚Ñï) (h : i ‚â§ j) : ‚àÄ r : ConcreteBTField i,
  (AlgebraTower.algebraMap i j h) ((towerEquiv i).ringEquiv r) =
  (towerEquiv j).ringEquiv ((AlgebraTower.algebraMap i j h) r)

lemma out_of_dom_smpl_1
  {Œ¥ l : ‚Ñù‚â•0} {s : ‚Ñï} {f : Œπ ‚Üí F} {degree : ‚Ñï} {œÜ : Œπ ‚Ü™ F}
  (C : Set (Œπ ‚Üí F)) (hC : C = code œÜ degree)
  (h_decodable : listDecodable C Œ¥ l)
  (h_nonempty : Nonempty (domainComplement œÜ)) :
  listDecodingCollisionProbability œÜ f Œ¥ s degree h_nonempty ‚â§
    ((l * (l-1) / 2)) * ((degree - 1) / (Fintype.card F - Fintype.card Œπ))^s

Nat.add_le_add_left in Init.Data.Nat.Basic

@[simp]
lemma runWithLog_discard_log_eq_run (stmt : StmtIn) (wit : WitIn)
    (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      Prod.fst <$> prover.runWithLog stmt wit = prover.run stmt wit

lemma take_eq_take : transcript‚ü¶:m‚üß = transcript.take m h

lemma W_splits (i : Fin r) : (W ùîΩq Œ≤ i).Splits (RingHom.id L)

theorem pow_exp_of_2_repr_given_x_square_repr {F : Type*} [instField : Field F]
  (sumZeroIffEq : ‚àÄ (x y : F), x + y = 0 ‚Üî x = y) (x z : F) (h_z_non_zero : z ‚â† 0)
  (h_x_square : x ^ 2 = x * z + 1)
  : ‚àÄ i : ‚Ñï, x^(2^i) = x * z^(2^i - 1) + ‚àë j ‚àà Finset.Icc 1 i, z^(2^i - 2^j)

theorem matchSize_toList {a b : Array Œ±} {unit : Œ±} :
    matchSize a b unit =
      let (a', b') := List.matchSize a.toList b.toList unit
      (mk a', mk b')

lemma even_eval {f : Polynomial F} {s : F} (hEven : EvenPoly f) :
  f.eval (-s) = f.eval s

@[simp]
theorem insertNth_zero_zero : insertNth p 0 (0 : Fin n ‚Üí‚ÇÄ M) = 0

theorem findIdxRev?_eq_none {cond} {as : Array Œ±} (h : ‚àÄ i, (hi : i < as.size) ‚Üí ¬¨ cond as[i]) :
  findIdxRev? cond as = none

@[simp]
theorem Ici_succ (i : Fin n) : Ici i.succ = (Ici i).map (Fin.succEmb _)

lemma dappend_right_of_not_lt {motive : Fin (m + n) ‚Üí Sort u}
    (u : (i : Fin m) ‚Üí motive (castAdd n i)) (v : (i : Fin n) ‚Üí motive (natAdd m i))
    (i : Fin (m + n)) (h : ¬¨ i.val < m) :
      dappend (motive := motive) u v i = dcast (by ext; simp; omega) (v ‚ü®i - m, by omega‚ü©)

theorem peval_def (f : œÉ ‚Üí œÉ‚ÇÅ ‚äï œÉ‚ÇÇ) (x : œÉ‚ÇÅ ‚Üí R) (p : MvPolynomial œÉ R) :
    peval f x p = eval‚ÇÇ C (Sum.elim (fun i => C (x i)) X ‚àò f) p

@[simp]
theorem partialSum_succ {a : Œ±} {l : List Œ±} :
    (a :: l).partialSum = [0] ++ (partialSum l).map (a + ¬∑)

theorem seqCompose_knowledgeSoundness
    (rel : (i : Fin (m + 1)) ‚Üí Set ((Stmt i √ó ‚àÄ j, OStmt i j) √ó Wit i))
    (V : (i : Fin m) ‚Üí
      OracleVerifier oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Stmt i.succ) (OStmt i.succ)
        (pSpec i))
    (knowledgeError : Fin m ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (V i).knowledgeSoundness init impl (rel i.castSucc) (rel i.succ) (knowledgeError i)) :
      (OracleVerifier.seqCompose Stmt OStmt V).knowledgeSoundness
        init impl (rel 0) (rel (Fin.last m)) (‚àë i, knowledgeError i)

theorem pow_zero {a : CNat 50} : a ^ 0 = 1

lemma discr_of_irred_components_nonzero
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  : ‚àÉ x‚ÇÄ,
      ‚àÄ R ‚àà (irreducible_factorization_of_gs_solution h_gs).choose_spec.choose,
      Bivariate.evalX x‚ÇÄ (Bivariate.discr_y R) ‚â† 0

@[simp]
lemma evenPart_by_2 :
  2 * (evenPart f) = f + f.comp (-X)

theorem FullData.toLeafData_leftSubtree {Œ±} {s_left s_right : Skeleton}
    (tree : FullData Œ± (Skeleton.internal s_left s_right)) :
    tree.toLeafData.leftSubtree =
      tree.leftSubtree.toLeafData

omit [Fintype L] [DecidableEq L] in
theorem Polynomial.foldl_comp (n : ‚Ñï) (f : Fin n ‚Üí L[X]) : ‚àÄ initInner initOuter: L[X],
    Fin.foldl (n:=n) (fun acc j => (f j).comp acc) (initOuter.comp initInner)
    = (Fin.foldl (n:=n) (fun acc j => (f j).comp acc) (initOuter)).comp initInner

lemma aeval_eq {A : Type w} [CommSemiring A] [Algebra R A] (f : P ‚Üí‚Çê[R] A) : f = aeval (f X)

theorem cast_eq_dcast‚ÇÇ {hn} {hSpec : pSpec‚ÇÅ.cast hn = pSpec‚ÇÇ} {i : ChallengeIdx pSpec‚ÇÅ}:
    i.cast hn hSpec = dcast‚ÇÇ hn hSpec i

theorem lagrangeBasis_getElem {w : Vector R n} (i : Fin (2 ^ n)) :
    (lagrangeBasis w)[i] = ‚àè j : Fin n, if (BitVec.ofFin i).getLsb j then w[j] else 1 - w[j]

@[simp] theorem zero_add {a : AssocNat} : 0 + a = a

theorem mapM_single (f : Œ± ‚Üí m Œ≤) (a : Œ±) : List.mapM f [a] = return [‚Üê f a]

theorem size_eq_degree (p : UniPoly R) : p.trim.size = p.degree

theorem support_finSuccEquivNth (f : MvPolynomial (Fin (n + 1)) R) :
    (finSuccEquivNth R p f).support = Finset.image (fun m : Fin (n + 1) ‚Üí‚ÇÄ ‚Ñï => m p) f.support

theorem setWidth_eq_ofNat_mod {n num_bits : Nat} (x : BitVec n) :
  BitVec.setWidth num_bits x = BitVec.ofNat num_bits (x.toNat % 2 ^ num_bits)

theorem qMap_total_fiber_disjoint
  (i : Fin ‚Ñì) (steps : ‚Ñï) (h_i_add_steps : i + steps ‚â§ ‚Ñì)
  {y‚ÇÅ y‚ÇÇ : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i.val + steps, by omega‚ü©}
  (hy_ne : y‚ÇÅ ‚â† y‚ÇÇ) :
  Disjoint
    ((qMap_total_fiber ùîΩq Œ≤ (i := ‚ü®i, by omega‚ü©) (steps := steps)
      (h_i_add_steps := fin_‚Ñì_steps_lt_‚Ñì_add_R i steps h_i_add_steps) y‚ÇÅ '' Set.univ).toFinset)
    ((qMap_total_fiber ùîΩq Œ≤ (i := ‚ü®i, by omega‚ü©) (steps := steps)
      (h_i_add_steps := fin_‚Ñì_steps_lt_‚Ñì_add_R i steps h_i_add_steps) y‚ÇÇ '' Set.univ).toFinset)

theorem OracleReduction.liftContext_toReduction_comm
    {lens : OracleContext.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                              OuterOStmtIn OuterOStmtOut InnerOStmtIn InnerOStmtOut
                              OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    {R : OracleReduction oSpec InnerStmtIn InnerOStmtIn InnerWitIn
                            InnerStmtOut InnerOStmtOut InnerWitOut pSpec} :
      (R.liftContext lens).toReduction = R.toReduction.liftContext lens.toContext

private lemma almost_johnson_lhs_div_B_card [Zero F]
  (h_n : 0 < n)
  (h_B : 2 ‚â§ B.card)
  :
  (k B * (k B - 1)  +
    (B.card - k B) * ((B.card - k B)/(Fintype.card F - 1) - 1)) / B.card
  =
  (1 - e B 0 / n) ^ 2 * B.card + B.card * (e B 0) ^ 2 / ((Fintype.card F - 1) * n^2) - 1

@[simp]
theorem MLE_eval_zeroOne (x : œÉ ‚Üí Fin 2) (evals : (œÉ ‚Üí Fin 2) ‚Üí R) :
    MvPolynomial.eval (x : œÉ ‚Üí R) (MLE evals) = evals x

theorem singleEqPolynomial_nf (r : R) (x : MvPolynomial œÉ R) :
    singleEqPolynomial r x = (2 * C r - 1) * x + (1 - C r)

theorem seqCompose_rbrKnowledgeSoundness
    (rel : ‚àÄ i, Set (Stmt i √ó Wit i))
    (V : ‚àÄ i, Verifier oSpec (Stmt i.castSucc) (Stmt i.succ) (pSpec i))
    (rbrKnowledgeError : ‚àÄ i, (pSpec i).ChallengeIdx ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (V i).rbrKnowledgeSoundness init impl
      (rel i.castSucc) (rel i.succ) (rbrKnowledgeError i)) :
      (Verifier.seqCompose Stmt V).rbrKnowledgeSoundness init impl (rel 0) (rel (Fin.last m))
        (fun combinedIdx =>
          letI ij := seqComposeChallengeIdxToSigma combinedIdx
          rbrKnowledgeError ij.1 ij.2)

Nat.two_pow_pos in Init.Data.Nat.Basic

omit [Finite F] in
lemma neg_mem_dom_of_mem_dom : ‚àÄ {a : FÀ£} (i : Fin n),
    a ‚àà evalDomain D x i ‚Üí - a ‚àà evalDomain D x i

@[simp]
lemma foldr'_succ {n : ‚Ñï} {Œ± : Type u} (f : (i : Fin (n + 1)) ‚Üí Œ± ‚Üí Œ±) (x : Œ±) :
    foldr' (n + 1) f x = f 0 (foldr' n (f ‚àò succ) x)

@[simp]
theorem eq_refl {Œ± : Type u} (mx : m Œ±) : eq mx mx

@[simp]
private lemma E_ne_zero : (E œâs f p e) ‚â† 0

@[simp]
theorem hconcat_last {Œ± : Fin n ‚Üí Sort u} {Œ≤ : Sort u} (v : (i : Fin n) ‚Üí Œ± i) (b : Œ≤) :
    hconcat v b (last n) = cast (vconcat_last Œ± Œ≤).symm b

lemma zsmul_succ {k : ‚Ñï} (n : ‚Ñï) (x : ConcreteBTField k) :
  (if (‚Üën.succ : ‚Ñ§) % 2 = 0 then zero else x) = (if (‚Üën : ‚Ñ§) % 2 = 0 then zero else x) + x

lemma concrete_mul_left_distrib
  {h_k : k > 0} (prevBTFieldProps : ConcreteBTFieldProps (k := k - 1))
  (a b c : ConcreteBTField k) :
    concrete_mul a (b + c) = concrete_mul a b + concrete_mul a c

lemma sub_descends [LawfulBEq R] (a‚ÇÅ b‚ÇÅ a‚ÇÇ b‚ÇÇ : UniPoly R) :
  equiv a‚ÇÅ a‚ÇÇ ‚Üí equiv b‚ÇÅ b‚ÇÇ ‚Üí sub_descending a‚ÇÅ b‚ÇÅ = sub_descending a‚ÇÇ b‚ÇÇ

private lemma almost_johnson_choose_2_elimed [Zero F]
  (h_n : 0 < n)
  (h_B : 2 ‚â§ B.card)
  (h_card : 2 ‚â§ Fintype.card F)
  :
  (k B * (k B - 1)  +
    (B.card - k B) * ((B.card - k B)/(Fintype.card F-1) - 1))
  ‚â§
  B.card * (B.card - 1) * (n - d B)/n

@[simp]
lemma challengeOracleInterface_append_range_inl (j : pSpec‚ÇÅ.ChallengeIdx) :
    [(pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).Challenge]‚Çí.range (.inl j) = pSpec‚ÇÅ.Challenge j

theorem hcons_right_injective {Œ≤ : Fin n ‚Üí Sort u} (a : Œ±) :
    Function.Injective (hcons a : ((i : Fin n) ‚Üí Œ≤ i) ‚Üí (i : Fin (n + 1)) ‚Üí vcons Œ± Œ≤ i)

lemma getBit_of_shiftLeft {n p : ‚Ñï}:
  ‚àÄ k, getBit (k) (n <<< p) = if k < p then 0 else getBit (k - p) n

@[simp]
theorem hcons_fin_zero {Œ± : Sort u} {Œ≤ : Fin 0 ‚Üí Sort u} (a : Œ±) (v : (i : Fin 0) ‚Üí Œ≤ i) :
    hcons a v = fun i => match i with

@[simp]
theorem vappend_vcons (a : Œ±) (u : Fin m ‚Üí Œ±) (v : Fin n ‚Üí Œ±) :
    vappend (vcons a u) v = (vcons a (vappend u v)) ‚àò Fin.cast (Nat.succ_add m n)

@[simp]
theorem fflatten_embedSum {A : Sort u} {F : A ‚Üí Sort v} {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï}
    {Œ± : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí A}
    (v : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí F (Œ± i j)) (i : Fin m) (j : Fin (n i)) :
    fflatten v (embedSum i j) = cast (by simp) (v i j)

lemma aeval_eq' {A : Type y} [CommSemiring A] [Algebra R A] {F : Type z} [FunEquiv F œÉ A]
    (f : P ‚Üí‚Çê[R] A) (p : P) : f p = aeval (fun s => f (X s) : F) p

theorem simulateQ_bind_fst_comp (oa : OracleComp spec Œ±) (f : Œ± ‚Üí OracleComp spec Œ≤) :
    (do let a ‚Üê (simulateQ loggingOracle oa).run; f a.1) = (do let a ‚Üê oa; f a)

theorem split_of_join {k : ‚Ñï} (h_pos : k > 0) (x : ConcreteBTField k)
    (hi_btf lo_btf : ConcreteBTField (k - 1))
    (h_join : x = „Äähi_btf, lo_btf„Äã) :
    (hi_btf, lo_btf) = split h_pos x

lemma add_descends [LawfulBEq R] (a‚ÇÅ b‚ÇÅ a‚ÇÇ b‚ÇÇ : UniPoly R) :
  equiv a‚ÇÅ a‚ÇÇ ‚Üí equiv b‚ÇÅ b‚ÇÇ ‚Üí add_descending a‚ÇÅ b‚ÇÅ = add_descending a‚ÇÇ b‚ÇÇ

omit [Finite F] in
lemma mul_root_of_unity {x : FÀ£} :
  ‚àÄ {a b : FÀ£} {i j : ‚Ñï},
    i ‚â§ j ‚Üí a ‚àà evalDomain D x i ‚Üí b ‚àà Domain.evalDomain D j ‚Üí
      a * b ‚àà evalDomain D x i

theorem append_completeness (R‚ÇÅ : Reduction oSpec Stmt‚ÇÅ Wit‚ÇÅ Stmt‚ÇÇ Wit‚ÇÇ pSpec‚ÇÅ)
    (R‚ÇÇ : Reduction oSpec Stmt‚ÇÇ Wit‚ÇÇ Stmt‚ÇÉ Wit‚ÇÉ pSpec‚ÇÇ)
    {completenessError‚ÇÅ completenessError‚ÇÇ : ‚Ñù‚â•0}
    (h‚ÇÅ : R‚ÇÅ.completeness init impl rel‚ÇÅ rel‚ÇÇ completenessError‚ÇÅ)
    (h‚ÇÇ : R‚ÇÇ.completeness init impl rel‚ÇÇ rel‚ÇÉ completenessError‚ÇÇ) :
      (R‚ÇÅ.append R‚ÇÇ).completeness init impl
        rel‚ÇÅ rel‚ÇÉ (completenessError‚ÇÅ + completenessError‚ÇÇ)

theorem append_left_injective (b : Fin n ‚Üí Œ±) : Function.Injective (@Fin.append m n Œ± ¬∑ b)

Fin.append_right in Mathlib.Data.Fin.Tuple.Basic

@[simp]
theorem finSuccEquivNth_X_above {i : Fin n} (h : p < i.succ) :
    finSuccEquivNth R p (X i.succ) = Polynomial.C (X i)

@[simp]
lemma two_mul_inv_two : (2 : F) * 2‚Åª¬π = 1

lemma towerRingHomForwardMap_split_eq (k : ‚Ñï) (h_pos : k > 0) (x : ConcreteBTField k) :
  let p := split (k:=k) (h:=h_pos) x
  towerRingHomForwardMap (k:=k) (x) =
    BinaryTower.join_via_add_smul (k:=k) (h_pos:=h_pos)
      (hi_btf := towerRingHomForwardMap (k:=k-1) (p.1))
      (lo_btf := towerRingHomForwardMap (k:=k-1) (p.2))

@[simp]
theorem dcast‚ÇÇ_eq : dcast‚ÇÇ (Eq.refl a) dcast_eq c = c

lemma concreteTowerAlgebraMap_succ (l r : ‚Ñï) (h_le : l ‚â§ r) :
  concreteTowerAlgebraMap (l:=l) (r:=r + 1) (h_le:=by omega) =
  (concreteTowerAlgebraMap (l:=r) (r:=r + 1) (h_le:=by omega)).comp
  (concreteTowerAlgebraMap (l:=l) (r:=r) (h_le:=by omega))

lemma poly_natDegree_eq_2 (k : ‚Ñï) : (poly (k:=k)).natDegree = 2

lemma coe_one_succ (l : ‚Ñï) :
    (@ConcreteBTFieldAlgebra (l:=l) (r:=l + 1) (h_le:=by omega)).algebraMap
    (1 : ConcreteBTField l) = (1 : ConcreteBTField (l + 1))

lemma oracleWitnessConsistency_relay_preserved
    (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i)
    (stmt : Statement (L := L) Context i.succ)
    (wit : Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j) :
    oracleWitnessConsistency (mp := mp) (ùìë := ùìë) ùîΩq Œ≤ i.succ i.castSucc
      (le_succ ‚Üëi.castSucc) stmt wit oStmt =
    oracleWitnessConsistency (mp := mp) (ùìë := ùìë) ùîΩq Œ≤ i.succ i.succ (by rfl) stmt wit
      (mapOStmtOutRelayStep ùîΩq Œ≤ i hNCR oStmt)

theorem SkeletonNodeIndex.rightChild_bind_parent {s : Skeleton}
    (idx : SkeletonNodeIndex s) :
    idx.rightChild >>= parent = idx.rightChild.map (fun _ => idx)

lemma qCompositionChain_eq_foldl (i : Fin r) :
  qCompositionChain ùîΩq Œ≤ (‚Ñì:=‚Ñì) (R_rate:=R_rate) i =
  Fin.foldl (n:=i) (fun acc j =>
    (qMap ùîΩq Œ≤ ‚ü®j, by omega‚ü©).comp acc) (X)

@[simp]
lemma length_eq_domain_size (inj : Function.Injective Œ±) :
  length (ReedSolomon.code ‚ü®Œ±, inj‚ü© deg) = m

@[simp] theorem rightpad_suffix (n : Nat) (unit : Œ±) (l : List Œ±) :
    replicate (n - l.length) unit <:+ rightpad n unit l

@[simp]
theorem fflatten_zero {A : Sort u} {F : A ‚Üí Sort v} {n : Fin 0 ‚Üí ‚Ñï}
    {Œ± : (i : Fin 0) ‚Üí (j : Fin (n i)) ‚Üí A}
    {v : (i : Fin 0) ‚Üí (j : Fin (n i)) ‚Üí F (Œ± i j)} : fflatten v = !h[]

lemma mca_linearCode
  (Gen : ProximityGenerator Œπ F) [Fintype Gen.par‚Ñì] [Nonempty Gen.par‚Ñì]
  (C : LinearCode Œπ F) (hC : C = Gen.C) :
    hasMutualCorrAgreement
     -- Gen
      Gen
    -- BStar (using Œ¥·µ£ produced )
      (min (1 - (Œ¥·µ£ (C : Set (Œπ ‚Üí F))) / 2) (Gen.B Gen.C Gen.par‚Ñì))
    -- errStar
      (fun Œ¥ => Gen.err C Gen.par‚Ñì Œ¥)

theorem vconcat_left_injective {n : ‚Ñï} (a : Œ±) :
    Function.Injective (fun v : Fin n ‚Üí Œ± => vconcat v a)

theorem nsmul_zero : nsmul 0 p = 0

lemma join_via_add_smul_one_zero_eq_Z {k : ‚Ñï} (h_pos : k > 0) :
  ‚ãò 1, 0 ‚ãô = Z k

@[simp]
theorem fappend‚ÇÇ_right {Œ±‚ÇÅ : Fin m ‚Üí A} {Œ±‚ÇÇ : Fin m ‚Üí B} {Œ≤‚ÇÅ : Fin n ‚Üí A} {Œ≤‚ÇÇ : Fin n ‚Üí B}
    (u : (i : Fin m) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i)) (v : (i : Fin n) ‚Üí F‚ÇÇ (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) (i : Fin n) :
    fappend‚ÇÇ (F := F‚ÇÇ) u v (natAdd m i) =
      cast (by simp [vappend_right]) (v i)

theorem binaryTowerAlgebra_apply_assoc (l mid r : ‚Ñï) (h_l_le_mid : l ‚â§ mid) (h_mid_le_r : mid ‚â§ r) :
    ‚àÄ x : BTField l,
    (@binaryAlgebraTower (l:=l) (r:=r) (h_le:=by
      exact Nat.le_trans h_l_le_mid h_mid_le_r)).algebraMap x =
    (@binaryAlgebraTower (l:=mid) (r:=r) (h_le:=h_mid_le_r)).algebraMap
      ((@binaryAlgebraTower (l:=l) (r:=mid) (h_le:=h_l_le_mid)).algebraMap x)

lemma cons_get_eq {Œ±} {n : ‚Ñï} (hd : Œ±) (tl : Vector Œ± n) (i : Fin (n + 1)) :
    (cons hd tl).get i =
      if hi: i.val == 0 then hd else tl.get (‚ü®i.val - 1, by
        simp only [beq_iff_eq, Fin.val_eq_zero_iff] at hi
        apply Nat.sub_lt_left_of_lt_add
        ¬∑ by_contra hi_ne_gt_1
          simp only [not_le, Nat.lt_one_iff, Fin.val_eq_zero_iff] at hi_ne_gt_1
          contradiction
        ¬∑ have hi_lt:= i.isLt; omega
      ‚ü©)

@[simp]
theorem runWithOracle_freeMonad_pure_none (f : spec.FunctionType) :
    runWithOracle f (FreeMonad.pure (none : Option Œ±)) = none

lemma split_join_via_add_smul_eq_iff_split {k : ‚Ñï} (h_pos : k > 0)
    (hi_btf lo_btf : ConcreteBTField (k - 1)) :
    split (k:=k) (h:=by omega) (x:=join_via_add_smul (k:=k) (h_pos:=h_pos) hi_btf lo_btf) =
      (hi_btf, lo_btf)

theorem unique_linear_sum_repr (R : Type*) [CommRing R] (S : Type*) [CommRing S] [Algebra R S]
    (pb : PowerBasis R S) (h_dim : pb.dim = 2) (s : S) :
    ‚àÉ! p : R √ó R, s = p.fst ‚Ä¢ pb.gen + algebraMap R S p.snd

lemma deevenize_comp_x_squared {f : Polynomial F} (hEven : EvenPoly f) :
    (deevenize f).comp (Polynomial.X * Polynomial.X) = f

Nat.mul_le_mul_right in Init.Data.Nat.Basic

@[simp]
theorem dflatten_two_eq_append {n : Fin 2 ‚Üí ‚Ñï} {motive : (k : Fin (vsum n)) ‚Üí Sort*}
    {v : (i : Fin 2) ‚Üí (j : Fin (n i)) ‚Üí motive (embedSum i j)} :
    dflatten (motive := motive) v = dappend (v 0) (v 1)

@[simp] theorem fromNat_toNat_eq_self {k : ‚Ñï} (bv : BitVec (2 ^ k)) :
  (fromNat (BitVec.toNat bv) : ConcreteBTField k) = bv

@[simp]
lemma evenPart_coeff {f : Polynomial F} {n : ‚Ñï} :
    (evenPart f).coeff n = if Even n then f.coeff n else 0

lemma trim_add_trim [LawfulBEq R] (p q : UniPoly R) : p.trim + q = p + q

@[simp]
theorem dflatten_one {n : Fin 1 ‚Üí ‚Ñï} {motive : (k : Fin (vsum n)) ‚Üí Sort*}
    {v : (i : Fin 1) ‚Üí (j : Fin (n i)) ‚Üí motive (embedSum i j)} :
    dflatten (motive := motive) v = v 0

omit [Finite F] in
@[simp]
lemma range_lem‚ÇÇ : [FinalOracleStatement D x s]‚Çí.range (Fin.last (k + 1)) = F[X]

theorem reduction_completeness {Œµ : ‚Ñù‚â•0}
    (hRel : ‚àÄ stmtIn witIn, (stmtIn, witIn) ‚àà relIn ‚Üí
      [fun ‚ü®stmtOut, witOut‚ü© => (stmtOut, witOut) ‚àà relOut|do
        (simulateQ impl <| combineMap mapStmt mapWit ‚ü®stmtIn, witIn‚ü©).run' (‚Üê init)] ‚â• 1 - Œµ) :
    Reduction.completeness init impl relIn relOut (reduction mapStmt mapWit) Œµ

@[grind _=_]
lemma total_deg_as_weighted_deg :
  totalDegree f = natWeightedDegree f 1 1

theorem ext_hcons {Œ≤ : Fin n ‚Üí Sort u} (a‚ÇÅ a‚ÇÇ : Œ±) (v‚ÇÅ v‚ÇÇ : (i : Fin n) ‚Üí Œ≤ i) :
    hcons a‚ÇÅ v‚ÇÅ = hcons a‚ÇÇ v‚ÇÇ ‚Üî a‚ÇÅ = a‚ÇÇ ‚àß v‚ÇÅ = v‚ÇÇ

theorem stir_main
  (secpar : ‚Ñï) [SelectableType F]
  {Œπ : Type} [Fintype Œπ] [Nonempty Œπ] [DecidableEq Œπ]
  {œÜ : Œπ ‚Ü™ F} {degree : ‚Ñï} [hsmooth : Smooth œÜ]
  {k proofLen qNumtoInput qNumtoProofstr : ‚Ñï}
  (hk : ‚àÉ p, k = 2 ^ p) (hkGe : k ‚â• 4)
  (Œ¥ : ‚Ñù‚â•0) (hŒ¥ub : Œ¥ < 1 - 1.05 * Real.sqrt (degree / Fintype.card Œπ))
  (hF : Fintype.card F ‚â§
        secpar * 2 ^ secpar * degree ^ 2 * (Fintype.card Œπ) ^ (7 / 2) /
          Real.log (1 / rate (code œÜ degree))) :
  ‚àÉ n : ‚Ñï,
  ‚àÉ vPSpec : ProtocolSpec.VectorSpec n,
  ‚àÉ Œµ_rbr : vPSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0,
  ‚àÉ œÄ : VectorIOP Unit (OracleStatement Œπ F) Unit vPSpec F,
  IsSecureWithGap (stirRelation degree œÜ 0)
                  (stirRelation degree œÜ Œ¥)
                  Œµ_rbr œÄ
  ‚àß ‚àÄ i, Œµ_rbr i ‚â§ (1 : ‚Ñö‚â•0) / (2 ^ secpar)
  ‚àß ‚àÉ c > 0, M ‚â§ c * (Real.log degree / Real.log k)
  ‚àß ‚àÉ c‚Çñ : ‚Ñï ‚Üí ‚Ñù, proofLen ‚â§ (Fintype.card Œπ) + (c‚Çñ k) * (Real.log degree)
  ‚àß qNumtoInput = secpar / (- Real.log (1 - Œ¥))
  ‚àß ‚àÉ c‚Çñ : ‚Ñï ‚Üí ‚Ñù, qNumtoProofstr ‚â§
    (c‚Çñ k) * ((Real.log degree) +
      secpar * (Real.log ((Real.log degree) / Real.log (1/rate (code œÜ degree)))))

lemma algebraMap_succ_eq_zero_x {k : ‚Ñï} (h_pos : k > 0) (x : BTField (k - 1)) :
  letI instAlgebra := binaryAlgebraTower (l:=k-1) (r:=k) (h_le:=by omega)
  algebraMap (BTField (k - 1)) (BTField k) x = ‚ãò 0, x ‚ãô

@[simp]
theorem verifier_last_of_two (pSpec : ProtocolSpec 2) [VerifierLast pSpec] :
    pSpec.dir 1 = .V_to_P

@[simp] -- main lemma for bIdx: Fin (‚Ñì / œë - 1) bounds
lemma bIdx_mul_œë_add_x_lt_‚Ñì_sub_œë (bIdx : Fin (‚Ñì / œë - 1)) (x : ‚Ñï) {hx : x ‚â§ œë} :
    ‚ÜëbIdx * œë + x ‚â§ ‚Ñì - œë

lemma definingPoly_coeffOf0 {F : Type*} [Field F] [Fintype F] (s : F) [NeZero s] :
    (definingPoly s).coeff 0 = 1

theorem liftContext_runWithLog
    {lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    {outerStmtIn : OuterStmtIn} {outerWitIn : OuterWitIn}
    {R : Reduction oSpec InnerStmtIn InnerWitIn InnerStmtOut InnerWitOut pSpec} :
      (R.liftContext lens).runWithLog outerStmtIn outerWitIn = do
        let ‚ü®‚ü®‚ü®fullTranscript, innerCtxOut‚ü©, verInnerStmtOut‚ü©, queryLog‚ü© ‚Üê
          R.runWithLog.uncurry (lens.proj (outerStmtIn, outerWitIn))
        return ‚ü®‚ü®‚ü®fullTranscript, lens.lift (outerStmtIn, outerWitIn) innerCtxOut‚ü©,
                lens.stmt.lift outerStmtIn verInnerStmtOut‚ü©, queryLog‚ü©

@[simp]
theorem cast_toReduction
    (R : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec‚ÇÅ) :
    (R.cast hn hSpec hO‚Çò).toReduction = Reduction.cast hn hSpec R.toReduction

lemma sup_eq_of_le_of_reach {Œ± Œ≤ : Type} [SemilatticeSup Œ≤] [OrderBot Œ≤] {s : Finset Œ±} {f : Œ± ‚Üí Œ≤}
      (x : Œ±) {y : Œ≤} (h : x ‚àà s) :
    f x = y ‚Üí
    (‚àÄ x ‚àà s, f x ‚â§ y) ‚Üí
    s.sup f = y

theorem succ'_injective : Function.Injective (succ' : Nat ‚Üí Nat)

lemma binaryTowerAlgebra_def (l r : ‚Ñï) (h_le : l ‚â§ r) :
    @binaryAlgebraTower (l:=l) (r:=r) (h_le:=h_le)
    = (towerAlgebraMap l r h_le).toAlgebra

lemma or_by_split_lowBits {n m n1 m1 bn bm : ‚Ñï} (h_bn : bn < 2) (h_bm : bm < 2)
  (h_n : n = n1 * 2 + bn) (h_m : m = m1 * 2 + bm):
  n ||

@[simp]
theorem hflatten_splitSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {Œ± : (k : Fin (vsum n)) ‚Üí Sort*}
    (v : (k : Fin (vsum n)) ‚Üí Œ± k) (k : Fin (vsum n)) :
    hflatten (fun i j => v (embedSum i j)) k = cast (vflatten_splitSum Œ± k).symm (v k)

theorem size_le_size (p : UniPoly R) : p.trim.size ‚â§ p.size

theorem degrees_peval {x : œÉ‚ÇÅ ‚Üí R} {f : œÉ ‚Üí œÉ‚ÇÅ ‚äï œÉ‚ÇÇ} {p : MvPolynomial œÉ R} :
    (peval f x p).degrees ‚â§ (p.degrees.map f).filterMap Sum.getRight?

theorem seqCompose_knowledgeSoundness
    (rel : (i : Fin (m + 1)) ‚Üí Set (Stmt i √ó Wit i))
    (V : (i : Fin m) ‚Üí Verifier oSpec (Stmt i.castSucc) (Stmt i.succ) (pSpec i))
    (knowledgeError : Fin m ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (V i).knowledgeSoundness init impl (rel i.castSucc) (rel i.succ) (knowledgeError i)) :
      (Verifier.seqCompose Stmt V).knowledgeSoundness init impl (rel 0) (rel (Fin.last m))
        (‚àë i, knowledgeError i)

lemma rtake_eq_rtake : transcript‚ü¶m:‚üß = transcript.drop m h

lemma even_index_intermediate_novel_basis_decomposition (i : Fin ‚Ñì) (j : Fin (2 ^ (‚Ñì - i - 1))) :
  intermediateNovelBasisX ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i, by omega‚ü© ‚ü®j * 2, by
    apply mul_two_add_bit_lt_two_pow j (‚Ñì-i-1) (‚Ñì-i) ‚ü®0, by omega‚ü© (by omega) (by omega)
  ‚ü©  = (intermediateNovelBasisX ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i+1, by omega‚ü© ‚ü®j, by
    apply lt_two_pow_of_lt_two_pow_exp_le j (‚Ñì-i-1) (‚Ñì-(i+1)) (by omega) (by omega)
  ‚ü©).comp (qMap ùîΩq Œ≤ ‚ü®i, by omega‚ü©)

@[simp]
theorem FullData.ofFun_get {Œ±} {s} (tree : FullData Œ± s) :
    FullData.ofFun s (fun idx => tree.get idx) = tree

theorem prime_5 : Nat.Prime 5

omit [Finite F] in
@[simp]
lemma range_lem‚ÇÅ {i : Fin (k + 1)} :
    [FinalOracleStatement D x s]‚Çí.range ‚ü®i.1, Nat.lt_succ_of_lt i.2‚ü© = F

lemma proximity_gap
  {F : Type} [Field F] [Fintype F] [DecidableEq F]
  {Œπ : Type} [Fintype Œπ] [Nonempty Œπ] {œÜ : Œπ ‚Ü™ F}
  {degree m : ‚Ñï} {Œ¥ : ‚Ñù‚â•0} {f : Fin m ‚Üí Œπ ‚Üí F} {GenFun : F ‚Üí Fin m ‚Üí F}
  (h : ‚àÄ (hŒ¥Le : Œ¥ < 1 - Bstar (LinearCode.rate (code œÜ degree))) {f : Fin m ‚Üí Œπ ‚Üí F},
        Pr_{
          let r ‚Üê $·µñ F}[Œ¥·µ£((fun x => ‚àë j : Fin m, (GenFun r j) * f j x), code œÜ degree) ‚â§ (Œ¥ : ‚Ñù)]
            > ENNReal.ofReal (proximityError F degree (LinearCode.rate (code œÜ degree)) Œ¥ m)) :

        ‚àÉ S : Finset Œπ,
          S.card ‚â• (1 - Œ¥) * (Fintype.card Œπ) ‚àß
        ‚àÉ u : (Œπ ‚Üí F),
          u ‚àà (code œÜ degree) ‚àß ‚àÄ i : Fin m, ‚àÄ x ‚àà S, f i x = u x

theorem towerAlgebraMap_succ_last (r : ‚Ñï) : ‚àÄ l : ‚Ñï, (h_le : l ‚â§ r) ‚Üí
  towerAlgebraMap (l:=l) (r:=r+1) (h_le:=by
    exact Nat.le_trans (n:=l) (m:=r) (k:=r+1) (h_le) (by omega)) =
  (towerAlgebraMap (l:=l+1) (r:=r+1) (by omega)).comp (towerAlgebraMap
    (l:=l) (r:=l+1) (by omega))

lemma exist_bit_diff_if_diff {n: ‚Ñï} (a: Fin (2^n)) (b: Fin (2^n)) (h_a_ne_b: a ‚â† b):
  ‚àÉ k: Fin n, getBit k a ‚â† getBit k b

lemma sum_inv_Z_next_eq
  (k : ‚Ñï)
  (prev : ConcreteBTFStepResult (k := k)) :
  letI : Field (ConcreteBTField k) := mkFieldInstance (prev.toConcreteBTFieldProps)
  letI : Field (ConcreteBTField (k + 1)) := mkFieldInstance (k:=k+1)
    (props:=liftBTFieldProps (k:=k) (prevBTFResult:=prev))
  letI : Algebra (ConcreteBTField k) (ConcreteBTField (k + 1)) :=
    instAlgebraLiftConcreteBTField k prev
  Z (k + 1) + (Z (k + 1))‚Åª¬π = (algebraMap (ConcreteBTField k) (ConcreteBTField (k + 1))) (Z k)

@[simp]
theorem simulateQ'_query_bind (q : OracleQuery spec Œ±)
    (ob : Œ± ‚Üí OracleComp spec Œ≤) (h : ‚àÄ x, (ob x).neverFails) :
    simulateQ' so (liftM q >>= ob) (by simp [h]) =
      so.impl q >>= (fun x => simulateQ' so (ob x) (h x))

theorem polynomial_sum_ext.{u, u_1}
  {R : Type u}
  [Semiring R]
  {S : Type u_1}
  [AddCommMonoid S]
  {p : Polynomial R} {f g : ‚Ñï ‚Üí R ‚Üí S}
  (h : ‚àÄ i x, f i x = g i x)
  : p.sum f = p.sum g

@[simp] lemma extract_dir : pSpec‚ü¶start:stop‚üß.dir = pSpec.dir‚ü¶start:stop‚üß

lemma getLowBits_succ {n: ‚Ñï} (numLowBits: ‚Ñï) :
    getLowBits (numLowBits + 1) n = getLowBits numLowBits n
    + (getBit numLowBits n) <<< numLowBits

lemma pow_2_pow_i_mem_Di_of_mem_D {F : Type} [NonBinaryField F] [Finite F] {D : Subgroup FÀ£}
  [DIsCyclicC : IsCyclicWithGen ‚Ü•D] {x : FÀ£} :
  ‚àÄ {a : FÀ£} (i : ‚Ñï),
    a ‚àà evalDomain D x 0 ‚Üí a ^ (2 ^ i) ‚àà evalDomain D x i

@[simp]
theorem verifier_rbrKnowledgeSoundness :
    (verifier oSpec Statement).rbrKnowledgeSoundness init impl rel rel 0

theorem append_rbrKnowledgeSoundness (V‚ÇÅ : OracleVerifier oSpec Stmt‚ÇÅ OStmt‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : OracleVerifier oSpec Stmt‚ÇÇ OStmt‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ pSpec‚ÇÇ)
    {rbrKnowledgeError‚ÇÅ : pSpec‚ÇÅ.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    {rbrKnowledgeError‚ÇÇ : pSpec‚ÇÇ.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    (h‚ÇÅ : V‚ÇÅ.rbrKnowledgeSoundness init impl rel‚ÇÅ rel‚ÇÇ rbrKnowledgeError‚ÇÅ)
    (h‚ÇÇ : V‚ÇÇ.rbrKnowledgeSoundness init impl rel‚ÇÇ rel‚ÇÉ rbrKnowledgeError‚ÇÇ) :
      (V‚ÇÅ.append V‚ÇÇ).rbrKnowledgeSoundness init impl rel‚ÇÅ rel‚ÇÉ
        (Sum.elim rbrKnowledgeError‚ÇÅ rbrKnowledgeError‚ÇÇ ‚àò ChallengeIdx.sumEquiv.symm)

@[simp]
theorem cast_toVerifier (V : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec‚ÇÅ) :
    (OracleVerifier.cast hn hSpec hO‚Çò V).toVerifier = Verifier.cast hn hSpec V.toVerifier

theorem two_pow_ne_zero (n : ‚Ñï) : 2 ^ n ‚â† 0

theorem completeness [DecidableEq Œ±] [SelectableType Œ±] {s}
    (leaf_data_tree : LeafData Œ± s) (idx : BinaryTree.SkeletonLeafIndex s)
    (preexisting_cache : (spec Œ±).QueryCache) :
    (((do
      let cache ‚Üê buildMerkleTree leaf_data_tree
      let proof := generateProof cache idx
      let _ ‚Üê verifyProof idx (leaf_data_tree.get idx) (cache.getRootValue) proof
      ).simulateQ (randomOracle)).run preexisting_cache).neverFails

@[simp] theorem equiv_refl (p : UniPoly Q) : equiv p p

lemma concrete_one_ne_zero {k : ‚Ñï} : (one (k:=k)) ‚â† (zero (k:=k))

theorem drop_append_left {n' : ‚Ñï} {Œ± : Sort*} (m : ‚Ñï) (h : m ‚â§ n) (u : (i : Fin n) ‚Üí Œ±)
    (v : (i : Fin n') ‚Üí Œ±) :
      drop m (Nat.le_add_right_of_le h) (append u v) =
          append (drop m h u) v ‚àò Fin.cast (by omega)

@[simp]
lemma eval‚ÇÇAlgHom_apply {A B : Type*} [CommSemiring A] [CommSemiring B] [MvPolynomialLike œÉ A P]
    [Algebra R A] [IsScalarTower R A P] [Algebra R B]
    (f : A ‚Üí‚Çê[R] B) (g : œÉ ‚Üí B) (p : P) :
    (eval‚ÇÇAlgHom f g) p = eval‚ÇÇ f g p

lemma wt_eq_zero_iff [Zero F] {v : Œπ ‚Üí F} :
  wt v = 0 ‚Üî Fintype.card Œπ = 0 ‚à® ‚àÄ i, v i = 0

theorem vcons_inj (a b : Œ±) (v w : Fin n ‚Üí Œ±) : a ::·µõ v = b ::·µõ w ‚Üî a = b ‚àß v = w

@[simp]
lemma toFun_invFun (f : ‚àÄ a, Œ≤ a) : inst.equiv.toFun (equiv.invFun f : F) = f

lemma last_nonzero_unique {p : UniPoly Q} {k k' : Fin p.size} :
  last_nonzero_prop k ‚Üí last_nonzero_prop k' ‚Üí k = k'

theorem prime_29 : Nat.Prime 29

theorem eval_comp_eval_C_finSuccEquiv (p : R[X (Fin (n + 1))]) (y : Fin n ‚Üí R) (x : R) :
    eval y (Polynomial.eval (C x) (finSuccEquiv R n p)) = eval (Fin.cons x y) p

lemma towerRingHomForwardMap_zero {k : ‚Ñï} :
  (towerRingHomForwardMap k) 0 = 0

@[simp]
theorem BTField.RingHom_cast_dest_apply (k m n : ‚Ñï) (h_eq : m = n)
  (f : BTField k ‚Üí+* BTField m) (x : BTField k) :
    (cast (BTField.RingHom_eq_of_dest_eq (k:=k) (m:=m) (n:=n) h_eq) f) x
    = cast (by apply cast_BTField_eq (h_eq:=h_eq)) (f x)

theorem induction_init {n : ‚Ñï} {motive : Fin (n + 2) ‚Üí Sort*} {zero : motive 0}
    {succ : ‚àÄ i : Fin (n + 1), motive i.castSucc ‚Üí motive i.succ} {i : Fin (n + 1)} :
      induction (motive := motive) zero succ i.castSucc =
        induction (motive := Fin.init motive) zero (fun j x => succ j.castSucc x) i

theorem prime_101 : Nat.Prime 101

theorem galois_automorphism_power
    {curBTField : Type*} [Field curBTField]
    (u : curBTField) (t1 : curBTField) -- here t1 is already lifted to curBTField
    (k : ‚Ñï)
    (sumZeroIffEq : ‚àÄ (x y : curBTField), x + y = 0 ‚Üî x = y)
    (specialElementNeZero : u ‚â† 0)
    (prevSpecialElementNeZero : t1 ‚â† 0)
    (u_plus_inv_eq_t1 : u + u‚Åª¬π = t1)
    (h_u_square : u ^ 2 = u * t1 + 1)
    (h_t1_pow : t1 ^ (2 ^ (2 ^ k) - 1) = 1 ‚àß (t1‚Åª¬π) ^ (2 ^ (2 ^ k) - 1) = 1)
    (trace_map_roots : ‚àë i ‚àà Finset.range (2 ^ k), t1 ^ (2 ^ i) = 1 ‚àß
                      ‚àë i ‚àà Finset.range (2 ^ k), t1‚Åª¬π ^ (2 ^ i) = 1) :
    u^(2^(2^k)) = u‚Åª¬π ‚àß (u‚Åª¬π)^(2^(2^k)) = u

@[simp]
theorem vcons_of_one (a : Œ±) {i : Fin 1} : !v[a] i = match i with

theorem seqCompose_rbrKnowledgeSoundness
    (rel : ‚àÄ i, Set ((Stmt i √ó ‚àÄ j, OStmt i j) √ó Wit i))
    (V : (i : Fin m) ‚Üí OracleVerifier oSpec (Stmt i.castSucc) (OStmt i.castSucc)
      (Stmt i.succ) (OStmt i.succ) (pSpec i))
    (rbrKnowledgeError : ‚àÄ i, (pSpec i).ChallengeIdx ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (V i).rbrKnowledgeSoundness init impl
      (rel i.castSucc) (rel i.succ) (rbrKnowledgeError i)) :
    (OracleVerifier.seqCompose Stmt OStmt V).rbrKnowledgeSoundness
        init impl (rel 0) (rel (Fin.last m))
        (fun combinedIdx =>
          letI ij := seqComposeChallengeIdxToSigma combinedIdx
          rbrKnowledgeError ij.1 ij.2)

omit [NeZero r] [Field L] [Fintype L] [DecidableEq L] [DecidableEq ùîΩq] [Field ùîΩq] [Algebra ùîΩq L] in
lemma base_coeffsBySuffix (a : Fin (2 ^ ‚Ñì) ‚Üí L) :
  coeffsBySuffix (r:=r) (R_rate := R_rate) a 0 0 = a

@[simp]
lemma seqCompose_toReduction {m : ‚Ñï}
    (Stmt : Fin (m + 1) ‚Üí Type)
    {Œπ‚Çõ : Fin (m + 1) ‚Üí Type} (OStmt : (i : Fin (m + 1)) ‚Üí Œπ‚Çõ i ‚Üí Type)
    [O‚Çõ : ‚àÄ i, ‚àÄ j, OracleInterface (OStmt i j)]
    (Wit : Fin (m + 1) ‚Üí Type)
    {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    [O‚Çò : ‚àÄ i, ‚àÄ j, OracleInterface ((pSpec i).Message j)]
    (R : (i : Fin m) ‚Üí
      OracleReduction oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Wit i.castSucc)
        (Stmt i.succ) (OStmt i.succ) (Wit i.succ) (pSpec i)) :
    (seqCompose Stmt OStmt Wit R).toReduction =
      Reduction.seqCompose (fun i => Stmt i √ó (‚àÄ j, OStmt i j)) Wit
        (fun i => (R i).toReduction)

@[simp] lemma twoAdicGenerators_succ_square_eq' (idx : Fin twoAdicity) :
    twoAdicGenerators[idx.val + 1] ^ 2 = twoAdicGenerators[idx]

lemma erase_odd_def {s : Finset ‚Ñï} :
    erase_odd s = s.filter Even

theorem sub_add_eq_sub_sub_rev (a b c : Nat) (h1 : c ‚â§ b) (h2 : b ‚â§ a) :
  a - b + c = a - (b - c)

@[simp]
theorem LeafData.rightSubtree_internal {Œ±} {s_left s_right : Skeleton}
    (left : LeafData Œ± s_left) (right : LeafData Œ± s_right) :
    (LeafData.internal left right).rightSubtree = right

@[simp]
lemma ofPolynomialAlgHom_toPolynomialAlgHom_X :
    ofPolynomialAlgHom (toPolynomialAlgHom (X : P)) = (Polynomial.X : R[X])

@[simp]
theorem rdrop_eq_take (m : ‚Ñï) (h : m ‚â§ n) (v : (i : Fin n) ‚Üí Œ± i) :
    rdrop m h v = take (n - m) (by omega) v

@[simp]
theorem add_accepts_iff : (add a b c).accepts x ‚Üî x c = x a + x b

@[simp]
theorem fconcat‚ÇÇ_last {Œ±‚ÇÅ : Fin n ‚Üí A} {Œ±‚ÇÇ : Fin n ‚Üí B} {Œ≤‚ÇÅ : A} {Œ≤‚ÇÇ : B}
    (v : (i : Fin n) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i)) (a : F‚ÇÇ Œ≤‚ÇÅ Œ≤‚ÇÇ) :
    fconcat‚ÇÇ (F := F‚ÇÇ) v a (last n) = cast (by simp [vconcat_last]) a

theorem snoc_ne_zero_iff : snoc s y ‚â† 0 ‚Üî s ‚â† 0 ‚à® y ‚â† 0

theorem mobius_apply_zeta_apply_eq_id (n : ‚Ñï) [NeZero n] (r : Fin n) (l : Fin (r.val + 1))
    (v : Vector R (2 ^ n)) : lagrangeToMono_segment n r l (monoToLagrange_segment n r l v) = v

@[simp]
lemma dfoldr'_zero {Œ± : Fin 1 ‚Üí Type u}
    (f : (i : Fin 0) ‚Üí Œ± i.succ ‚Üí Œ± i.castSucc) (x : Œ± (last 0)) :
    dfoldr' 0 Œ± f x = x

theorem qMap_maps_sDomain (i : Fin r) (h_i_add_1 : i + 1 < r) :
  have q_comp_linear_map := qMap_is_linear_map ùîΩq Œ≤ i
  have q_eval_linear_map := linear_map_of_comp_to_linear_map_of_eval
    (f:=qMap ùîΩq Œ≤ i) q_comp_linear_map
  let q_i_map := polyEvalLinearMap (qMap ùîΩq Œ≤ i) q_eval_linear_map
  let S_i := sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i
  let S_i_plus_1 := sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i+1)
  Submodule.map q_i_map S_i = S_i_plus_1

@[simp]
lemma append_last_of_succ_right {u : Fin m ‚Üí Œ±} {v : Fin (n + 1) ‚Üí Œ±} :
    (append u v) (last (m + n)) = v (last n)

theorem dconcat_right_injective {motive : Fin (n + 1) ‚Üí Sort u}
    (v : (i : Fin n) ‚Üí motive (castSucc i)) :
    Function.Injective (dconcat (motive := motive) v)

@[simp]
theorem LeafData.get_ofFun {Œ±} {s} (f : SkeletonLeafIndex s ‚Üí Œ±) :
    (LeafData.ofFun s f).get = f

lemma folding
  [Nonempty Œπ] {S : Finset Œπ} [Fintype Œπ]
  (œÜ : Œπ ‚Ü™ F) (f : Œπ ‚Üí F) (k : ‚Ñï)
  [Nonempty (indexPow S œÜ k)]
  {degree : ‚Ñï} (Œ¥ : ‚Ñö) (hŒ¥Pos : Œ¥ > 0)
  (hŒ¥Lt : Œ¥ < foldingDistRange degree œÜ f) :
  let C : Set ((indexPow S œÜ k) ‚Üí F) := code (pow S œÜ k) (degree / k)
  Pr_{ let r ‚Üê $·µñ F }[ Œ¥·µ£((fold œÜ f k r), C) ‚â§ Œ¥]
    ‚â§ ENNReal.ofReal (proximityError F (degree / k) (LinearCode.rate (code œÜ degree)) Œ¥ k)

lemma solutionToE_eq_polynomialOfCoeffs
  (h : n < e) : (solutionToE e k v).coeff n = (polynomialOfCoeffs v).coeff n

theorem mul_distrib_add (m n p : ChurchNat Œ±) : mul m (add n p) = add (mul m n) (mul m p)

@[simp]
theorem leftpad_apply_ge (n : ‚Ñï) (a : Œ±) (v : Fin m ‚Üí Œ±) (i : Fin n)
    (h : n - m ‚â§ i.val) : leftpad n a v i = v ‚ü®i.val - (n - m), by omega‚ü©

theorem oracleVerifier_rbrKnowledgeSoundness [Fintype R] :
    (oracleVerifier R deg D oSpec).rbrKnowledgeSoundness init impl
    (inputRelation R deg D) (outputRelation R deg) (fun _ => (deg : ‚Ñù‚â•0) / (Fintype.card R))

private lemma Fis_cover_B : B = Finset.univ.biUnion (Fi B i)

@[simp] lemma mod_two_eq_zero (m : ‚Ñ§) : m % 2 = ( - m) % 2

Nat.pos_of_neZero in Init.Data.Nat.Basic

@[simp]
lemma lastBlockIdx_mul_œë_add_x_lt_‚Ñì_succ (x : ‚Ñï) {hx : x ‚â§ œë} :
    (‚Ñì / œë - 1) * œë + x < ‚Ñì + 1

Nat.le_of_succ_le in Init.Data.Nat.Basic

theorem distanceLE_mvPolynomial_degreeLE {œÉ : Type*} [Fintype œÉ] [DecidableEq œÉ] :
    distanceLE (R‚¶É‚â§ d‚¶Ñ[X œÉ]) (Fintype.card œÉ * d)

lemma mul_by_2_def {s : Finset ‚Ñï} :
    mul_by_2 s = s.map ‚ü®fun n => 2 * n, by {
      intro a b
      simp
    }‚ü©

@[simp]
theorem cast_rbrKnowledgeSoundness (Œµ : pSpec‚ÇÅ.ChallengeIdx ‚Üí ‚Ñù‚â•0)
    (hRbrKs : V.rbrKnowledgeSoundness init impl relIn relOut Œµ) :
    (V.cast hn hSpec hO‚Çò).rbrKnowledgeSoundness init impl relIn relOut
      (Œµ ‚àò (ChallengeIdx.cast hn.symm (cast_symm hSpec)))

lemma vappend_left_of_lt {m n : ‚Ñï} {Œ± : Sort u}
    (u : Fin m ‚Üí Œ±) (v : Fin n ‚Üí Œ±) (i : Fin (m + n)) (h : i.val < m) :
      vappend u v i = u ‚ü®i, h‚ü©

lemma coprime_three_fieldSize_sub_one : Nat.Coprime 3 (fieldSize - 1)

theorem PrattPart.out {p : ‚Ñï} {a : ZMod p} {n : ‚Ñï} (h : PrattPart p a n) :
    ‚àÄ q : ‚Ñï, q.Prime ‚Üí q ‚à£ n ‚Üí a ^ ((p - 1) / q) ‚â† 1

@[simp]
theorem FullData.toLeafData_internal {Œ±} {s_left s_right : Skeleton}
    (value : Œ±) (left : FullData Œ± s_left) (right : FullData Œ± s_right) :
    (FullData.internal value left right).toLeafData =
      LeafData.internal (left.toLeafData) (right.toLeafData)

@[simp]
theorem bool_accepts_iff_of_domain [IsDomain ùì°] :
    (bool j).accepts x ‚Üî x j = 0 ‚à® x j = 1

theorem cast_idx {i : MessageIdx pSpec‚ÇÅ} :
    pSpec‚ÇÇ.Message (i.cast hn hSpec) = pSpec‚ÇÅ.Message i

theorem append_rbrSoundness {lang‚ÇÅ : Set Stmt‚ÇÅ} {lang‚ÇÇ : Set Stmt‚ÇÇ} {lang‚ÇÉ : Set Stmt‚ÇÉ}
    (V‚ÇÅ : Verifier oSpec Stmt‚ÇÅ Stmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : Verifier oSpec Stmt‚ÇÇ Stmt‚ÇÉ pSpec‚ÇÇ)
    {rbrSoundnessError‚ÇÅ : pSpec‚ÇÅ.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    {rbrSoundnessError‚ÇÇ : pSpec‚ÇÇ.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    (h‚ÇÅ : V‚ÇÅ.rbrSoundness init impl lang‚ÇÅ lang‚ÇÇ rbrSoundnessError‚ÇÅ)
    (h‚ÇÇ : V‚ÇÇ.rbrSoundness init impl lang‚ÇÇ lang‚ÇÉ rbrSoundnessError‚ÇÇ) :
      (V‚ÇÅ.append V‚ÇÇ).rbrSoundness init impl lang‚ÇÅ lang‚ÇÉ
        (Sum.elim rbrSoundnessError‚ÇÅ rbrSoundnessError‚ÇÇ ‚àò ChallengeIdx.sumEquiv.symm)

@[simp]
theorem embedSum_succ_succ {n : Fin (m + 1) ‚Üí ‚Ñï} {i : Fin m} (j : Fin (n i.succ)) :
    embedSum (i.succ) j = Fin.natAdd _ (embedSum i j)

lemma fold_f_g_poly
  {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F} {k m : ‚Ñï}
  {œÜ_0 : (indexPowT S œÜ 0) ‚Ü™ F} {œÜ_k : (indexPowT S œÜ k) ‚Ü™ F}
  [Fintype (indexPowT S œÜ 0)] [DecidableEq (indexPowT S œÜ 0)] [Smooth œÜ_0]
  [Fintype (indexPowT S œÜ k)] [DecidableEq (indexPowT S œÜ k)] [Smooth œÜ_k]
  [‚àÄ i : ‚Ñï, Neg (indexPowT S œÜ i)]
  (Œ±s : Fin k ‚Üí F) (hk : k ‚â§ m)
  (f : smoothCode œÜ_0 m) (g : smoothCode œÜ_k (m-k)) :
  let fPoly

@[simp]
theorem append_snd (T‚ÇÅ : FullTranscript pSpec‚ÇÅ) (T‚ÇÇ : FullTranscript pSpec‚ÇÇ) :
    (T‚ÇÅ ++‚Çú T‚ÇÇ).snd = T‚ÇÇ

theorem fcons_right_injective {Œ≤ : Fin n ‚Üí A} (a : F Œ±) :
    Function.Injective (fcons a : ((i : Fin n) ‚Üí F (Œ≤ i)) ‚Üí (i : Fin (n + 1)) ‚Üí _)

theorem dist'_eq_dist : ‚ÄñC‚Äñ‚ÇÄ'.toNat = ‚ÄñC‚Äñ‚ÇÄ

@[simp]
theorem cast_id :
    OracleVerifier.cast rfl rfl (fun i => rfl) =
      (id : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec‚ÇÅ ‚Üí _)

theorem BitVec.extractLsb_eq_and_pow_2_minus_1_ofNat {n num_bits : Nat}
  (h_num_bits : num_bits > 0) (x : BitVec n) :
  BitVec.extractLsb (hi:= num_bits - 1) (lo := 0) x =
    BitVec.ofNat (num_bits - 1 - 0 + 1) (x.toNat &&& (2 ^ num_bits - 1))

theorem dappend_succ {motive : Fin (m + (n + 1)) ‚Üí Sort u}
    (u : (i : Fin m) ‚Üí motive (castAdd (n + 1) i))
    (v : (i : Fin (n + 1)) ‚Üí motive (natAdd m i)) :
    dappend (motive := motive) u v =
      (dappend u (fun i => v (castSucc i))) :+·µà‚ü®motive‚ü© (v (last n))

theorem cast_symm {hn} (hSpec : pSpec‚ÇÅ.cast hn = pSpec‚ÇÇ) : pSpec‚ÇÇ.cast hn.symm = pSpec‚ÇÅ

@[simp]
theorem FullData.get_ofFun {Œ±} {s} (f : SkeletonNodeIndex s ‚Üí Œ±) :
    (FullData.ofFun s f).get = f

@[simp]
theorem ofNat_zero : ofNat 0 = @zero Œ±

private lemma almost_johnson [Zero F]
  (h_n : 0 < n)
  (h_B : 2 ‚â§ B.card)
  (h_card : 2 ‚â§ (Fintype.card F))
  :
  n * (choose_2 (k B) + (Fintype.card F - 1)
    * choose_2 ((B.card - k B) / (Fintype.card F - 1)))
  ‚â§
  choose_2 B.card * (n - d B)

@[simp]
theorem rightpad_apply_lt (n : ‚Ñï) (a : Œ±) (v : Fin m ‚Üí Œ±) (i : Fin n)
    (h : i.val < m) : rightpad n a v i = v ‚ü®i.val, h‚ü©

theorem eqPolynomial_degreeOf (r : œÉ ‚Üí R) (i : œÉ) : degreeOf i (eqPolynomial r) ‚â§ 1

@[to_additive (attr := simp)]
theorem prod_insertNth [CommMonoid Œ≤] {n : ‚Ñï} (x : Œ≤) (f : Fin n ‚Üí Œ≤) (p : Fin (n + 1)) :
    ‚àè i, insertNth p x f i = x * ‚àè i, f i

lemma rootMultiplicity_W (i : Fin r) (a : L) :
    rootMultiplicity a (W ùîΩq Œ≤ i) = if a ‚àà (U ùîΩq Œ≤ i : Set L) then 1 else 0

@[simp]
lemma dfoldlM'_succ {n : ‚Ñï} {Œ± : Fin (n + 2) ‚Üí Type u}
    (f : (i : Fin (n + 1)) ‚Üí Œ± i.castSucc ‚Üí m (Œ± i.succ)) (x : Œ± 0) :
    dfoldlM' (n + 1) Œ± f x = (do
      let y ‚Üê dfoldlM' n (Œ± ‚àò castSucc) (fun i => f i.castSucc) x
      f (last n) y)

theorem add_assoc [LawfulBEq R] : p + q + r = p + (q + r)

@[simp]
theorem cast_id : FullTranscript.cast rfl rfl = (id : pSpec‚ÇÅ.FullTranscript ‚Üí _)

omit [NeZero ‚Ñì] in
lemma fin_‚Ñì_lt_‚Ñì_add_one (i : Fin ‚Ñì) : i < ‚Ñì + 1

theorem getBit_repr {‚Ñì : Nat} : ‚àÄ j, j < 2^‚Ñì ‚Üí
  j = ‚àë k ‚àà Finset.Icc 0 (‚Ñì-1), (getBit k j) * 2^k

lemma evenize_eval {f : Polynomial F} {s : F} :
    (evenize f).eval s = f.eval (s * s)

lemma bwm_of_neg [NeZero n] (h : e ‚â§ j.1) :
  BerlekampWelchMatrix e k œâs f i j = -(œâs i)^(j - e)

@[simp] lemma twoAdicGenerators_length : twoAdicGenerators.length = twoAdicity + 1

@[simp]
theorem impl_run {i : Œπ} {t : spec.domain i} :
    (loggingOracle.impl (query i t)).run = (do let u ‚Üê query i t; return (u, [‚ü®i, ‚ü®t, u‚ü©‚ü©]))

theorem sum_of_root_and_inverse_is_t1
    {curBTField : Type*} [Field curBTField]
    (u : curBTField) (t1 : curBTField) -- here t1 is already lifted to curBTField
    (specialElementNeZero : u ‚â† 0)
    (eval_prevPoly_at_root : u ^ 2 + t1 * u + 1 = 0)
    (sumZeroIffEq : ‚àÄ (x y : curBTField), x + y = 0 ‚Üî x = y) :
    u + u‚Åª¬π = t1

@[simp]
theorem PowerBasis.cast_basis_succ_of_eq_rec_apply
    (r1 r : ‚Ñï) (h_r : r = r1 + 1)
    (k : Fin 2) :
    letI instAlgebra : Algebra (ConcreteBTField r1) (ConcreteBTField r) :=
      ConcreteBTFieldAlgebra (l:=r1) (r:=r) (h_le:=by omega)
    letI instAlgebraSucc : Algebra (ConcreteBTField (r1 + 1)) (ConcreteBTField (r)) :=
      ConcreteBTFieldAlgebra (l:=r1 + 1) (r:=r) (h_le:=by omega)
    let b : PowerBasis (ConcreteBTField r1) (ConcreteBTField (r1 + 1))
      := powerBasisSucc (k:=r1)
    let bCast : PowerBasis (ConcreteBTField r1) (ConcreteBTField r) := Eq.rec (motive:=
      fun (x : ‚Ñï) (_ : r1 + 1 = x) => by
        letI instAlgebraCur : Algebra (ConcreteBTField r1) (ConcreteBTField x) :=
          ConcreteBTFieldAlgebra (l:=r1) (r:=x) (h_le:=by omega)
        exact PowerBasis (ConcreteBTField r1) (ConcreteBTField x)) (refl:=b) (t:=h_r.symm)
    have h_pb_dim : b.dim = 2 := by
      exact powerBasisSucc_dim r1

    have h_pb'_dim : bCast.dim = 2 := by
      dsimp [bCast]
      rw [PowerBasis.dim_of_eq_rec (r1:=r1) (r:=r) (h_r:=h_r) (b:=b)]
      exact h_pb_dim

    have h_pb_type_eq : Basis (Fin bCast.dim) (ConcreteBTField r1) (ConcreteBTField r) =
      Basis (Fin 2) (ConcreteBTField r1) (ConcreteBTField r) := by
      congr

   -- The `cast` needs a proof that `bCast.dim = 2`. We construct it here.
    let left : Basis (Fin 2) (ConcreteBTField r1) (ConcreteBTField r)
      := cast (by exact h_pb_type_eq) bCast.basis
    let right := (algebraMap (ConcreteBTField (r1 + 1)) (ConcreteBTField r))
      (b.basis (Fin.cast h_pb_dim.symm k))
    left k = right

theorem dcast_fun‚ÇÇ {a‚ÇÅ a‚ÇÇ a‚ÇÅ' a‚ÇÇ' : Œ±} {h‚ÇÅ : a‚ÇÅ = a‚ÇÅ'} {h‚ÇÇ : a‚ÇÇ = a‚ÇÇ'} {f : Œ± ‚Üí Œ± ‚Üí Œ±}
    {g : (a‚ÇÅ : Œ±) ‚Üí (a‚ÇÇ : Œ±) ‚Üí Œ≤ a‚ÇÅ ‚Üí Œ≤ a‚ÇÇ ‚Üí Œ≤ (f a‚ÇÅ a‚ÇÇ)} {b‚ÇÅ : Œ≤ a‚ÇÅ} {b‚ÇÇ : Œ≤ a‚ÇÇ} :
    dcast (by cases h‚ÇÅ; cases h‚ÇÇ; rfl) (g a‚ÇÅ a‚ÇÇ b‚ÇÅ b‚ÇÇ) = g a‚ÇÅ' a‚ÇÇ' (dcast h‚ÇÅ b‚ÇÅ) (dcast h‚ÇÇ b‚ÇÇ)

lemma out_of_dom_smpl_2
  {Œ¥ l : ‚Ñù‚â•0} {s : ‚Ñï} {f : Œπ ‚Üí F} {degree : ‚Ñï} {œÜ : Œπ ‚Ü™ F}
  (C : Set (Œπ ‚Üí F)) (hC : C = code œÜ degree)
  (h_decodable : listDecodable C Œ¥ l)
  (h_nonempty : Nonempty (domainComplement œÜ)) :
  listDecodingCollisionProbability œÜ f Œ¥ s degree h_nonempty ‚â§
    ((l^2 / 2)) * (degree / (Fintype.card F - Fintype.card Œπ))^s

lemma getBit_of_middleBits {n offset len k : ‚Ñï} :
  getBit k (getMiddleBits offset len n) =
    if k < len then getBit (k + offset) n else 0

@[simp]
theorem Iic_zero : Iic (0 : Fin (n + 1)) = {0}

Nat.sub_mul in Init.Data.Nat.Basic

private lemma F2i_card {Œ± : F} :
  (F2i B i Œ±).card = 2 * choose_2 (K B i Œ±)

@[simp]
lemma lin_shift_hamming_distance [Field F] {x‚ÇÅ x‚ÇÇ v : Fin n ‚Üí F}
  :
  Œî‚ÇÄ(x‚ÇÅ - v, x‚ÇÇ - v) = Œî‚ÇÄ(x‚ÇÅ, x‚ÇÇ)

@[grind =] theorem idxOf'_cons [BEq Œ±] {a : Œ±} {x : Œ±} {xs : List Œ±} :
    idxOf' a (x :: xs) = bif x == a then 0 else idxOf' a xs + 1

theorem simulateQ'_eq_simulateQ [AlternativeMonad m] [LawfulMonad m]
    {so : QueryImpl spec m} (oa : OracleComp spec Œ±) (h : oa.neverFails) :
      simulateQ' so oa h = simulateQ so oa

theorem rename_ne_zero_of_injective {œÑ : Type*} {f : œÉ ‚Üí œÑ} (hf : Function.Injective f)
    {p : MvPolynomial œÉ R} (h : p ‚â† 0) : rename f p ‚â† 0

theorem correlatedAgreement_affine_spaces {k : ‚Ñï} [NeZero k] {u : Fin (k + 1) ‚Üí Œπ ‚Üí F}
  {deg : ‚Ñï} {domain : Œπ ‚Ü™ F} {Œ¥ : ‚Ñù‚â•0} (hŒ¥ : Œ¥ ‚â§ 1 - (ReedSolomonCode.sqrtRate deg domain))
  (hproximity :
    Pr_{let y ‚Üê $·µñ (u 0 +·µ• affineSpan F (Finset.univ.image (Fin.tail u)).toSet)}[
        Code.relHammingDistToCode (Œπ := Œπ) (F := F) y (ReedSolomon.code domain deg) ‚â§ Œ¥
    ] > errorBound Œ¥ deg domain) :
  correlatedAgreement (ReedSolomon.code domain deg) Œ¥ u

theorem support_C_subset {r : R} : (@C R œÉ _ r).support ‚äÜ { 0 }

lemma matchSize_size {p q : UniPoly Q} :
    let (p', _) := Array.matchSize p q 0
    p'.size = max p.size q.size

Fin.is_le in Init.Data.Fin.Lemmas

lemma getBit_eq_zero_or_one {k n : Nat} :
  getBit k n = 0 ‚à® getBit k n = 1

theorem append_left_injective {pSpec : ProtocolSpec n} :
    Function.Injective (@ProtocolSpec.append m n ¬∑ pSpec)

theorem fconcat_injective2 {Œ± : Fin n ‚Üí A} {Œ≤ : A} :
    Function.Injective2 (@fconcat A F n Œ± Œ≤)

theorem liftContext_soundness
    {soundnessError : ‚Ñù‚â•0}
    {lens : OracleStatement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                                OuterOStmtIn OuterOStmtOut InnerOStmtIn InnerOStmtOut}
    (V : OracleVerifier oSpec InnerStmtIn InnerOStmtIn InnerStmtOut InnerOStmtOut pSpec)
    [lensSound : lens.IsSound outerLangIn outerLangOut innerLangIn innerLangOut
      (V.toVerifier.compatStatement lens)]
    (h : V.soundness init impl innerLangIn innerLangOut soundnessError) :
      (V.liftContext lens).soundness init impl outerLangIn outerLangOut soundnessError

@[simp]
theorem cast_dir_idx_symm {hn} (hSpec : pSpec‚ÇÅ.cast hn = pSpec‚ÇÇ) {i : Fin n‚ÇÇ} :
    pSpec‚ÇÅ.dir (Fin.cast hn.symm i) = pSpec‚ÇÇ.dir i

omit [Finite F] in
@[simp]
lemma domain_lem‚ÇÅ {i : Fin (k + 1)} :
    [FinalOracleStatement D x s]‚Çí.domain ‚ü®i.1, Nat.lt_succ_of_lt i.2‚ü© =
      evalDomain D x (‚àë j' ‚àà finRangeTo i.1, s j')

theorem linearIndependent_fin2' {f : Fin 2 ‚Üí V} :
    LinearIndependent K f ‚Üî f 0 ‚â† 0 ‚àß ‚àÄ a : K, a ‚Ä¢ f 0 ‚â† f 1

omit [Fintype F] in
private lemma hamming_dist_eq_sum {x y : Fin n ‚Üí F} :
  Œî‚ÇÄ(x, y) = ‚àë i, if x i = y i then 0 else 1

theorem OracleVerifier.liftContext_toVerifier_comm
    {lens : OracleStatement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                              OuterOStmtIn OuterOStmtOut InnerOStmtIn InnerOStmtOut}
    {V : OracleVerifier oSpec InnerStmtIn InnerOStmtIn InnerStmtOut InnerOStmtOut pSpec} :
      (V.liftContext lens).toVerifier = V.toVerifier.liftContext lens

omit [NoZeroDivisors ùîΩ] in
lemma splitNth_def (n : ‚Ñï) (f : ùîΩ[X]) [inst : NeZero n] :
    f =
      ‚àë i : Fin n,
        (Polynomial.X ^ i.1) *
          Polynomial.eval‚ÇÇ Polynomial.C (Polynomial.X ^ n) (splitNth f n i)

theorem hconcat_left_injective {Œ± : Fin n ‚Üí Sort u} {Œ≤ : Sort u} (a : Œ≤) :
    Function.Injective (fun v : (i : Fin n) ‚Üí Œ± i => hconcat v a)

@[simp]
theorem vappend_left (u : Fin m ‚Üí Œ±) (v : Fin n ‚Üí Œ±) (i : Fin m) :
    vappend u v (castAdd n i) = u i

lemma algebraMap_adjacent_tower_def (l : ‚Ñï) :
    (algebraMap (ConcreteBTField l) (ConcreteBTField (l + 1))) =
    canonicalAlgMap l

theorem dcast_eq_root_cast (h : a = a') : dcast h b = _root_.cast (congrArg Œ≤ h) b

lemma forwardRange_length (n : ‚Ñï) (r : Fin n) (l : Fin (r.val + 1)) :
    (forwardRange n r l).length = r.val - l.val + 1

theorem congrArg‚ÇÑ {Œ± Œ≤ Œ≥ Œ¥ Œµ : Sort*} {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥ ‚Üí Œ¥ ‚Üí Œµ} {a a' : Œ±} {b b' : Œ≤} {c c' : Œ≥}
    {d d' : Œ¥} (h : a = a') (h' : b = b') (h'' : c = c') (h''' : d = d') :
      f a b c d = f a' b' c' d'

omit [NeZero œë] hdiv in
lemma toOutCodewordsCountOf0 : toOutCodewordsCount ‚Ñì œë 0 = 1

theorem castSum_castLT {l' : List ‚Ñï} {i : ‚Ñï} (j : Fin i) :
    castSum (i :: l') (by simp) j =
      castLT j (Nat.lt_of_lt_of_le j.isLt (List.le_sum_of_mem (by simp)))

@[simp]
theorem tail_vcons (a : Œ±) (v : Fin n ‚Üí Œ±) : tail (a ::·µõ v) = v

theorem append_knowledgeSoundness (V‚ÇÅ : OracleVerifier oSpec Stmt‚ÇÅ OStmt‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : OracleVerifier oSpec Stmt‚ÇÇ OStmt‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ pSpec‚ÇÇ)
    {knowledgeError‚ÇÅ knowledgeError‚ÇÇ : ‚Ñù‚â•0}
    (h‚ÇÅ : V‚ÇÅ.knowledgeSoundness init impl rel‚ÇÅ rel‚ÇÇ knowledgeError‚ÇÅ)
    (h‚ÇÇ : V‚ÇÇ.knowledgeSoundness init impl rel‚ÇÇ rel‚ÇÉ knowledgeError‚ÇÇ) :
      (V‚ÇÅ.append V‚ÇÇ).knowledgeSoundness init impl rel‚ÇÅ rel‚ÇÉ
        (knowledgeError‚ÇÅ + knowledgeError‚ÇÇ)

theorem srKnowledgeSoundness_addSalt_implies_srKnowledgeSoundness_original
    (relIn : Set (StmtIn √ó WitIn)) (relOut : Set (StmtOut √ó WitOut))
    (Salt : pSpec.MessageIdx ‚Üí Type) [‚àÄ i, Nonempty (Salt i)] [‚àÄ i, Fintype (Salt i)]
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    (srInit : ProbComp (srChallengeOracle StmtIn (pSpec.addSalt Salt)).FunctionType)
    (srImpl : QueryImpl oSpec
      (StateT (srChallengeOracle StmtIn (pSpec.addSalt Salt)).FunctionType ProbComp))
    (srKnowledgeError : ‚Ñù‚â•0) :
      Verifier.StateRestoration.knowledgeSoundness srInit srImpl relIn relOut
        (verifier.addSalt Salt) srKnowledgeError ‚Üí
        Verifier.StateRestoration.knowledgeSoundness sorry sorry relIn relOut
          verifier srKnowledgeError

@[simp]
lemma length_nil : nil.length = 0

theorem cast_symm {Œ± Œ≤ : Sort u} {h : Œ± = Œ≤} {a : Œ±} {b : Œ≤} :
    cast h a = b ‚Üî a = cast h.symm b

theorem split_Z {k : ‚Ñï} (h_pos : k > 0) :
    split h_pos (Z k) = (one (k:=k - 1), zero (k:=k - 1))

@[simp] theorem rightpad_length (n : Nat) (unit : Œ±) (l : List Œ±) :
    (rightpad n unit l).length = max n l.length

@[simp]
theorem runWithOracle_failure (f : spec.FunctionType) :
    runWithOracle f (failure : OracleComp spec Œ±) = none

theorem randomOracle_neverFails_iff_runWithOracle_neverFails {Œ≤}
    [DecidableEq Œπ] [spec.DecidableEq] [(i : Œπ) ‚Üí SelectableType (OracleSpec.range spec i)]
    (oa : OracleComp (spec) Œ≤)
    :
    (‚àÄ (preexisting_cache : spec.QueryCache),
      ((oa.simulateQ randomOracle).run preexisting_cache).neverFails)
    ‚Üî
    (‚àÄ (f : spec.FunctionType),
      (runWithOracle f oa).isSome)

lemma add_eq_zero_iff_eq {k : ‚Ñï} (a b : ConcreteBTField k) : a + b = 0 ‚Üî a = b

theorem hcons_eq_hcons_iff {Œ≤ : Fin n ‚Üí Sort u} (a‚ÇÅ a‚ÇÇ : Œ±) (v‚ÇÅ v‚ÇÇ : (i : Fin n) ‚Üí Œ≤ i) :
    hcons a‚ÇÅ v‚ÇÅ = hcons a‚ÇÇ v‚ÇÇ ‚Üî a‚ÇÅ = a‚ÇÇ ‚àß v‚ÇÅ = v‚ÇÇ

@[simp]
theorem Verifier.id_soundness {lang : Set StmtIn} :
    (Verifier.id : Verifier oSpec _ _ _).soundness init impl lang lang 0

theorem addCases_right' {motive : Fin (m + n) ‚Üí Sort*}
    {left : (i : Fin m) ‚Üí motive (castAdd n i)} {right : (j : Fin n) ‚Üí motive (natAdd m j)}
    {i : Fin n} (j : Fin (m + n)) (h : j = natAdd m i) :
      addCases (motive := motive) left right j = h ‚ñ∏ (right i)

lemma coeff_polynomialOfCoeffs_eq_coeffs' :
  (polynomialOfCoeffs coeffs).coeff = fun x ‚Ü¶ if h : x < deg then coeffs ‚ü®x, h‚ü© else 0

@[simp]
theorem embedSum_succ_zero {n : Fin (m + 1) ‚Üí ‚Ñï} {j : Fin (n 0)} :
    embedSum 0 j = Fin.castAdd _ j

theorem coeffs_of_comp_minus_x {f : Polynomial F} {n : ‚Ñï} :
    (f.comp (-X)).coeff n = if Even n then f.coeff n else -f.coeff n

lemma getBit_eq_succ_getBit_of_mul_two_add_one {n k : ‚Ñï} : getBit (k+1) (2*n + 1) = getBit k n

theorem finSigmaFinEquiv'_pair {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (i : Fin m) (k : Fin (n i)) :
    (finSigmaFinEquiv' ‚ü®i, k‚ü© : ‚Ñï) = ‚àë j, n (Fin.castLE i.isLt.le j) + k

@[simp]
lemma Transcript.def_eq {k : Fin (n + 1)} {pSpec : ProtocolSpec n} :
    (pSpec.take k k.is_le).FullTranscript =
      ((i : Fin k) ‚Üí pSpec.¬´Type¬ª (Fin.castLE (by omega) i))

theorem base_intermediateNovelBasisX (j : Fin (2 ^ ‚Ñì)) :
  intermediateNovelBasisX ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®0, by
    by_contra ht
    simp only [not_lt, nonpos_iff_eq_zero] at ht
    contradiction
  ‚ü© j =
  X‚±º ùîΩq Œ≤ ‚Ñì (by omega) j

theorem fconcat_left_injective {Œ± : Fin n ‚Üí A} {Œ≤ : A} (a : F Œ≤) :
    Function.Injective (fun v : (i : Fin n) ‚Üí F (Œ± i) => fconcat v a)

Fin.isLt in Init.Prelude

@[simp]
theorem eqPolynomial_eval_zeroOne (r x : œÉ ‚Üí Fin 2) :
    eval (x : œÉ ‚Üí R) (eqPolynomial r) = if x = r then 1 else 0

omit h_Fq_char_prime in
theorem changeOfBasisMatrix_lower_triangular
  (‚Ñì : Nat) (h_‚Ñì : ‚Ñì ‚â§ r) :
  (changeOfBasisMatrix ùîΩq Œ≤ ‚Ñì h_‚Ñì).BlockTriangular ‚áëOrderDual.toDual

theorem nsmul_succ [LawfulBEq R] (n : ‚Ñï) {p : UniPoly R} : nsmul (n + 1) p = nsmul n p + p

theorem intermediateNormVpoly_comp_qmap_helper (i : Fin (‚Ñì))
    (k : Fin (‚Ñì - (‚Üëi + 1))) :
    (intermediateNormVpoly ùîΩq Œ≤ h_‚Ñì_add_R_rate
      ‚ü®‚Üëi + 1, by omega‚ü© (k:=‚ü®k, by simp only; omega‚ü©)).comp (qMap ùîΩq Œ≤ ‚ü®‚Üëi, by omega‚ü©) =
    intermediateNormVpoly ùîΩq Œ≤ h_‚Ñì_add_R_rate
      ‚ü®‚Üëi, by omega‚ü© ‚ü®k + 1, by simp only; omega‚ü©

lemma isField_of_irreducible {H : F[X][Y]} : Irreducible H ‚Üí IsField (ùïÉ H)

lemma testBit_false_eq_getBit_eq_0 (k n : Nat) :
  (n.testBit k = false) = ((Nat.getBit k n) = 0)

lemma eq_poly_deg_one {a b c d : F} {x‚ÇÅ x‚ÇÇ : F}
  (h1 : a + b * x‚ÇÅ = c + d * x‚ÇÅ)
  (h2 : a + b * x‚ÇÇ = c + d * x‚ÇÇ)
  (h1_2 : x‚ÇÅ ‚â† x‚ÇÇ) :
  Polynomial.C a + Polynomial.C b * Polynomial.X
    = Polynomial.C c + Polynomial.C d * Polynomial.X

@[simp]
theorem dcons_succ {motive : Fin (n + 1) ‚Üí Sort u} (a : motive 0)
    (v : (i : Fin n) ‚Üí motive i.succ) (i : Fin n) : (a ::·µà‚ü®motive‚ü© v) i.succ = v i

private lemma comp_x_square_coeff_pos_deg {f : Polynomial F} {n : ‚Ñï} (h : 0 < f.degree) :
  (f.comp (X * X)).coeff n = if Even n then f.coeff (n / 2) else 0

theorem hconcat_injective2 {Œ± : Fin n ‚Üí Sort u} {Œ≤ : Sort u} :
    Function.Injective2 (@hconcat n Œ± Œ≤)

@[simp]
theorem insertNth_last : insertNth (Fin.last n) y s = snoc s y

lemma cast_mul (m n : ‚Ñï) {x y : ConcreteBTField m} (h_eq : m = n) :
  (cast (by exact cast_ConcreteBTField_eq m n h_eq) (x * y)) =
  (cast (by exact cast_ConcreteBTField_eq m n h_eq) x) *
  (cast (by exact cast_ConcreteBTField_eq m n h_eq) y)

lemma Q'_div_E'_eq_p
  [NeZero n]
  {E' Q' : Polynomial F}
  {œâs f : Fin n ‚Üí F}
  (hp_deg : p.natDegree < k)
  (he : 2 * e < n - k + 1)
  (hk_n : k ‚â§ n)
  (h_ham : (Œî‚ÇÄ(f, p.eval ‚àò œâs) : ‚Ñï) ‚â§ e)
  (h_diff : Function.Injective œâs)
  (h_Q' : Q' ‚â† 0)
  (hp : p ‚â† 0)
  (h_cond : BerlekampWelchCondition e k œâs f E' Q')
  : E' ‚à£ Q' ‚àß Q' / E' = p

@[simp]
theorem seqCompose_one {n : Fin 1 ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)} :
    seqCompose pSpec = pSpec 0

lemma forwardRange_dropLast (n : ‚Ñï) (r : Fin (n - 1)) (l : Fin (r.val + 1)) :
    (forwardRange n ‚ü®r + 1, by omega‚ü© ‚ü®l, by simp only; omega‚ü©).dropLast
    = forwardRange n ‚ü®r, by omega‚ü© ‚ü®l, by simp only [Fin.is_lt]‚ü©

theorem coeff_eq_coeff [LawfulBEq R] (p : UniPoly R) (i : ‚Ñï) :
  p.trim.coeff i = p.coeff i

@[simp]
theorem Prover.run_of_prover_first [ProverOnly pSpec] (stmt : StmtIn) (wit : WitIn)
    (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      prover.run stmt wit = (do
        let state := prover.input (stmt, wit)
        let ‚ü®msg, state‚ü© ‚Üê liftComp (prover.sendMessage ‚ü®0, by simp‚ü© state) _
        let ctxOut ‚Üê prover.output state
        return ((fun i => match i with | ‚ü®0, _‚ü© => msg), ctxOut))

omit [Finite F] in
lemma D_def : D = evalDomain D 0

Nat.cast_ofNat in Mathlib.Data.Nat.Cast.Defs

theorem cast_Type_idx {hn} (hSpec : pSpec‚ÇÅ.cast hn = pSpec‚ÇÇ) {i : Fin n‚ÇÅ} :
    pSpec‚ÇÇ.¬´Type¬ª (Fin.cast hn i) = pSpec‚ÇÅ.¬´Type¬ª i

theorem cast_eq_cast_iff {Œ± Œ≤ Œ≥ : Sort u} {h : Œ± = Œ≥} {h' : Œ≤ = Œ≥} {a : Œ±} {b : Œ≤} :
    cast h a = cast h' b ‚Üî a = cast (h'.trans h.symm) b

lemma contract_eq_liftF_of_lt {k : ‚Ñï} (h‚ÇÅ : k < m) :
  contract m f' k = liftF f' k

lemma solution_gamma_is_linear_in_Z
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  :
  ‚àÉ (v‚ÇÄ v‚ÇÅ : F[X]),
    Œ≥' x‚ÇÄ (R k Œ¥ x‚ÇÄ h_gs) (irreducible_H k (x‚ÇÄ := x‚ÇÄ) (Œ¥ := Œ¥) h_gs) =
        AppendixA.polyToPowerSeriesùïÉ _
          (
            (Polynomial.map Polynomial.C v‚ÇÄ) +
            (Polynomial.C Polynomial.X) * (Polynomial.map Polynomial.C v‚ÇÅ)
          )

theorem mem_restrictDegree_iff_degreeOf_le (p : MvPolynomial œÉ R) (n : ‚Ñï) :
    p ‚àà restrictDegree œÉ R n ‚Üî ‚àÄ i, p.degreeOf i ‚â§ n

@[simp]
theorem vflatten_zero {n : Fin 0 ‚Üí ‚Ñï} {v : (i : Fin 0) ‚Üí Fin (n i) ‚Üí Œ±} : vflatten v = !v[]

lemma folding_preserves_listdecoding_base_ne_subset
  {S : Finset Œπ} {k m : ‚Ñï} (hm : 1 ‚â§ m) {œÜ : Œπ ‚Ü™ F} [Smooth œÜ] {Œ¥ : ‚Ñù‚â•0}
  {S_0 : Finset (indexPowT S œÜ 0)} {S_1 : Finset (indexPowT S œÜ 1)}
  {œÜ_0 : (indexPowT S œÜ 0) ‚Ü™ F} {œÜ_1 : (indexPowT S œÜ 1) ‚Ü™ F}
  [‚àÄ i : ‚Ñï, Fintype (indexPowT S œÜ i)] [‚àÄ i : ‚Ñï, DecidableEq (indexPowT S œÜ i)]
  [Smooth œÜ_0] [Smooth œÜ_1]
  [h : ‚àÄ {f : (indexPowT S œÜ 0) ‚Üí F}, DecidableBlockDisagreement 0 k f S_0 œÜ_0]
  [h : ‚àÄ {f : (indexPowT S œÜ 1) ‚Üí F}, DecidableBlockDisagreement 1 k f S_1 œÜ_1]
  [‚àÄ i : ‚Ñï, Neg (indexPowT S œÜ i)]
  {C : Set ((indexPowT S œÜ 0) ‚Üí F)} (hcode : C = smoothCode œÜ_0 m)
  (C' : Set ((indexPowT S œÜ 1) ‚Üí F)) (hcode' : C' = smoothCode œÜ_1 (m-1))
  {BStar : (Set (indexPowT S œÜ 1 ‚Üí F)) ‚Üí ‚Ñï ‚Üí ‚Ñù‚â•0}
  {errStar : (Set (indexPowT S œÜ 1 ‚Üí F)) ‚Üí ‚Ñï ‚Üí ‚Ñù‚â•0 ‚Üí ‚Ñù‚â•0} :
    Pr_{let Œ± ‚Üê$·µñ F}[ ‚àÄ { f : (indexPowT S œÜ 0) ‚Üí F} (hŒ¥Le: Œ¥ ‚â§ 1 - (BStar C' 2)),
                      let listBlock : Set ((indexPowT S œÜ 0) ‚Üí F) := Œõ·µ£(0, k, f, S_0, C, hcode, Œ¥)
                      let vec_Œ± : Fin 1 ‚Üí F := (fun _ : Fin 1 => Œ±)
                      let foldSet := fold_k_set listBlock vec_Œ± hm
                      let fold := fold_k f vec_Œ± hm
                      let listBlock' : Set ((indexPowT S œÜ 1) ‚Üí F)
                        := Œõ·µ£(1, k, fold, S_1, C', hcode', Œ¥)
                      ¬¨ (listBlock' ‚äÜ foldSet)
                    ] < errStar C' 2 Œ¥

lemma getBit_of_lowBits {n: ‚Ñï} (numLowBits : ‚Ñï) : ‚àÄ k, getBit k (getLowBits numLowBits n) =
    if k < numLowBits then getBit k n else 0

lemma minDist_eq_minDist [DecidableEq F] {IC : LawfulInterleavedCode Œ∫ Œπ F} :
  Code.minDist (IC.1.LC : Set (Œπ ‚Üí F)) = minDist IC.1.MF

private lemma johnson_unrefined_by_M [Zero F]
  (h_n : 0 < n)
  (h_B : 2 ‚â§ B.card)
  (h_card : 2 ‚â§ (Fintype.card F))
  :
  B.card * ((1 - e B 0 / n) ^ 2  + (e B 0) ^ 2 / ((Fintype.card F - 1) * n^2) - 1 + d B/n)
  ‚â§
  d B/n

lemma concrete_mul_one
  (prevBTFieldProps : ConcreteBTFieldProps (k := k - 1))
  (a : ConcreteBTField k) : concrete_mul a (one (k:=k)) = a

@[simp]
lemma bIdx_mul_œë_add_i_cast_lt_‚Ñì_succ (bIdx : Fin (‚Ñì / œë - 1)) (i : Fin (œë - 1 + 1))
    : ‚ÜëbIdx * œë + i < ‚Ñì + 1

lemma num_eq_highBits_xor_lowBits {n: ‚Ñï} (numLowBits: ‚Ñï) :
  n = getHighBits numLowBits n ^^^ getLowBits numLowBits n

private lemma errors_are_roots_of_E {i : Fin n}
  (h : f i ‚â† p.eval (œâs i)) : (E œâs f p e).eval (œâs i) = 0

lemma card_le_card_of_count_inj {Œ± Œ≤ : Type*} [DecidableEq Œ±] [DecidableEq Œ≤]
    {s : Multiset Œ±} {s' : Multiset Œ≤}
  {f : Œ± ‚Üí Œ≤} (inj : Function.Injective f) (h : ‚àÄ a : Œ±, s.count a ‚â§ s'.count (f a)) :
  s.card ‚â§ s'.card

Nat.add_le_of_le_sub in Init.Data.Nat.Basic

lemma rank_eq_if_subUpFull_eq (h : n ‚â§ m) :
   (subUpFull U (Fin.castLE h)).rank = n  ‚Üí U.rank = n

lemma NTTStage_correctness (i : Fin (‚Ñì))
    (input_buffer : Fin (2 ^ (‚Ñì + R_rate)) ‚Üí L) (original_coeffs : Fin (2 ^ ‚Ñì) ‚Üí L) :
    additiveNTTInvariant ùîΩq Œ≤ h_‚Ñì_add_R_rate (evaluation_buffer:=input_buffer)
      (original_coeffs:=original_coeffs) (i := ‚ü®i.val+1, by omega‚ü©) ‚Üí
    additiveNTTInvariant ùîΩq Œ≤ h_‚Ñì_add_R_rate (evaluation_buffer:=NTTStage ùîΩq Œ≤ h_‚Ñì_add_R_rate
      ‚ü®i, by omega‚ü© input_buffer) (original_coeffs:=original_coeffs) ‚ü®i, by omega‚ü©

@[simp]
theorem reduction_completeness (h : init.neverFails) :
    (reduction oSpec Statement Witness).perfectCompleteness init impl relIn (toRelOut relIn)

@[simp]
theorem poly_form (k : ‚Ñï) : poly k = X^2 + (C (Z k) * X + 1)

@[simp]
theorem cast_perfectCompleteness (hComplete : R.perfectCompleteness init impl relIn relOut) :
    (R.cast hn hSpec).perfectCompleteness init impl relIn relOut

@[simp]
lemma bIdx_mul_œë_add_i_fin_‚Ñì_pred_lt_‚Ñì (bIdx : Fin (‚Ñì / œë - 1)) (i : Fin (œë - 1))
    : ‚ÜëbIdx * œë + ‚Üëi < ‚Ñì

theorem dcast‚ÇÇ_dcast : dcast‚ÇÇ rfl rfl c = dcast dcast_eq.symm c

@[csimp]
theorem dappend_eq_addCases : @dappend = @addCases

theorem append_soundness {lang‚ÇÅ : Set Stmt‚ÇÅ} {lang‚ÇÇ : Set Stmt‚ÇÇ} {lang‚ÇÉ : Set Stmt‚ÇÉ}
    (V‚ÇÅ : Verifier oSpec Stmt‚ÇÅ Stmt‚ÇÇ pSpec‚ÇÅ) (V‚ÇÇ : Verifier oSpec Stmt‚ÇÇ Stmt‚ÇÉ pSpec‚ÇÇ)
    {soundnessError‚ÇÅ soundnessError‚ÇÇ : ‚Ñù‚â•0}
    (h‚ÇÅ : V‚ÇÅ.soundness init impl lang‚ÇÅ lang‚ÇÇ soundnessError‚ÇÅ)
    (h‚ÇÇ : V‚ÇÇ.soundness init impl lang‚ÇÇ lang‚ÇÉ soundnessError‚ÇÇ) :
      (V‚ÇÅ.append V‚ÇÇ).soundness init impl lang‚ÇÅ lang‚ÇÉ (soundnessError‚ÇÅ + soundnessError‚ÇÇ)

theorem Nat.shiftRight_eq_sub_mod_then_div_two_pow {n lo_len : ‚Ñï} :
  n >>> lo_len = (n - n % 2 ^ lo_len) / 2 ^ lo_len

lemma mem_image_support_coeff_finSuccEquivNth {f : MvPolynomial (Fin (n + 1)) R} {i : ‚Ñï} {x} :
    x ‚àà Finsupp.insertNth p i '' ((finSuccEquivNth R p f).coeff i).support ‚Üî
      x ‚àà f.support ‚àß x p = i

omit [Ring Q] in
@[simp] theorem zero_def : (0 : UniPoly Q) = #[]

@[simp]
lemma widthDiv4_mul_4_eq_width : params.widthDiv4 * 4 = params.width

lemma distInterleavedCodeToCodeLB
  {IC : LawfulInterleavedCode Œ∫ Œπ F} {U : Matrix Œ∫ Œπ F} {e : ‚Ñï}
  (hF : Fintype.card F ‚â• e)
  (he : (e : ‚Ñö) ‚â§ (minDist (IC.1.LC : Set (Œπ ‚Üí F)) / 3)) (hU : e < Œî(U,IC.1.MF)) :
  ‚àÉ v ‚àà Matrix.rowSpan U , e < distFromCode v IC.1.LC

@[simp]
lemma eval_solutionToQ_zero {x : F} {v} : eval x (solutionToQ 0 k v) =
                                          ‚àë a ‚àà Finset.range k, liftF v a * x ^ a

private lemma sum_add_one {i : Fin (k + 1)} :
  ‚àë j' ‚àà finRangeTo (i.1 + 1), (s j').1 = (‚àë j' ‚àà finRangeTo i.1, (s j').1) + (s i).1

theorem BitVec.dcast_dcast_bitvec_extractLsb_eq {w hi lo : ‚Ñï} (x : BitVec w)
  (h_width_eq : w = hi - lo + 1) : dcast h_width_eq (dcast (h_width_eq.symm)
  (BitVec.extractLsb (hi:=hi) (lo:=lo) x)) = BitVec.extractLsb (hi:=hi) (lo:=lo) x

lemma split_algebraMap_eq_zero_x {k : ‚Ñï} (h_pos : k > 0) (x : BTField (k - 1)) :
  letI instAlgebra := binaryAlgebraTower (l:=k-1) (r:=k) (h_le:=by omega)
  split (k:=k) (h_k:=h_pos) (algebraMap (BTField (k - 1)) (BTField k) x) = (0, x)

lemma liftF_ne_zero_of_lt {i : ‚Ñï} (h : i < n) : liftF f' i ‚â† 0 ‚Üî f' ‚ü®i, h‚ü© ‚â† 0

theorem one_le_two_pow_n (n : ‚Ñï) : 1 ‚â§ 2 ^ n

theorem insertNth_ne_zero_iff : insertNth p y s ‚â† 0 ‚Üî y ‚â† 0 ‚à® s ‚â† 0

theorem dfoldl_congr_dcast {n : ‚Ñï}
    {Œπ : Type v} {Œ± Œ±' : Fin (n + 1) ‚Üí Œπ} {Œ≤ : Œπ ‚Üí Type u} [DCast Œπ Œ≤]
    {f : (i : Fin n) ‚Üí Œ≤ (Œ± i.castSucc) ‚Üí Œ≤ (Œ± i.succ)}
    {f' : (i : Fin n) ‚Üí Œ≤ (Œ±' i.castSucc) ‚Üí Œ≤ (Œ±' i.succ)}
    {init : Œ≤ (Œ± 0)} {init' : Œ≤ (Œ±' 0)}
    (hŒ± : ‚àÄ i, Œ± i = Œ±' i)
    (hf : ‚àÄ i a, f i a = (dcast (hŒ± _).symm (f' i (dcast (hŒ± _) a))))
    (hinit : init = dcast (hŒ± 0).symm init') :
      dfoldl n (fun i => Œ≤ (Œ± i)) f init =
        cast (by have := funext hŒ±; subst this; simp) (dfoldl n (fun i => Œ≤ (Œ±' i)) f' init')

@[simp] lemma my_neg_mod_two (m : ‚Ñ§) : ( - m) % 2 = if m % 2 = 0 then 0 else 1

lemma bIdx_succ_mul_œë_le_‚Ñì_succ (bIdx : Fin (‚Ñì / œë - 1)) : (‚ÜëbIdx + 1) * œë ‚â§ ‚Ñì + 1

omit [DecidableEq L] [DecidableEq ùîΩq] hF‚ÇÇ hŒ≤_lin_indep h_Œ≤‚ÇÄ_eq_1 in
lemma intermediateNormVpoly_eval_is_linear_map (i : Fin (‚Ñì + 1)) (k : Fin (‚Ñì - i + 1)) :
  IsLinearMap ùîΩq (fun x : L =>
    (intermediateNormVpoly ùîΩq Œ≤ h_‚Ñì_add_R_rate i k).eval x)

lemma liftF_liftF'_of_lt (h : m < n) : liftF (liftF' (n := n) f) m = f m

theorem cast_Type_idx_symm {hn} (hSpec : pSpec‚ÇÅ.cast hn = pSpec‚ÇÇ) {i : Fin n‚ÇÇ} :
    pSpec‚ÇÅ.¬´Type¬ª (Fin.cast hn.symm i) = pSpec‚ÇÇ.¬´Type¬ª i

@[simp] theorem leftpad_eq_self (l : List Œ±) (n : Nat) (h : l.length ‚â• n) :
    leftpad n unit l = l

theorem eqPolynomial_mem_restrictDegree (r : œÉ ‚Üí R) : (eqPolynomial r) ‚àà R‚¶É‚â§ 1‚¶Ñ[X œÉ]

@[simp]
private lemma leadingCoeff_E : (E œâs f p e).leadingCoeff = 1

lemma odd_index_intermediate_novel_basis_decomposition
    (i : Fin ‚Ñì) (j : Fin (2 ^ (‚Ñì - i - 1))) :
    intermediateNovelBasisX ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i, by omega‚ü© ‚ü®j * 2 + 1, by
      apply mul_two_add_bit_lt_two_pow j (‚Ñì-i-1) (‚Ñì-i) ‚ü®1, by omega‚ü© (by omega) (by omega)
    ‚ü©  = X * (intermediateNovelBasisX ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i+1, by omega‚ü© ‚ü®j, by
      apply lt_two_pow_of_lt_two_pow_exp_le j (‚Ñì-i-1) (‚Ñì-(i+1)) (by omega) (by omega)
    ‚ü©).comp (qMap ùîΩq Œ≤ ‚ü®i, by omega‚ü©)

congrArg in Init.Prelude

@[simp]
theorem generateProof_ofLeft {sleft sright : Skeleton}
    (cache_tree : FullData Œ± (Skeleton.internal sleft sright))
    (idxLeft : SkeletonLeafIndex sleft) :
    generateProof cache_tree (BinaryTree.SkeletonLeafIndex.ofLeft idxLeft) =
      (cache_tree.rightSubtree).getRootValue ::
        (generateProof cache_tree.leftSubtree idxLeft)

@[simp] lemma twoAdicGenerators_succ_square_eq (idx : Nat) (h : idx < twoAdicity) :
    haveI : idx + 1 < twoAdicGenerators.length

theorem split_zero {k : ‚Ñï} (h_pos : k > 0) : split h_pos zero = (zero, zero)

@[simp]
lemma not_P_to_V_eq_V_to_P {x : Direction} (h : x ‚â† .V_to_P) : x = .P_to_V

@[simp]
protected lemma elocPoly_one :
  ElocPoly 1 œâs f p = if f 0 ‚â† p.eval (œâs 0) then X - (C (œâs 0)) else 1

theorem append_getLast_dropLast {Œ± : Type u} (l : List Œ±) (h : l ‚â† []) :
  l.dropLast ++ [l.getLast h] = l

private lemma BerlekampWelchCondition_to_Solution [NeZero n]
  (hk_or_e : 1 ‚â§ k ‚à® 1 ‚â§ e)
  (h : BerlekampWelchCondition e k œâs f E Q)
  : IsBerlekampWelchSolution e k œâs f (E_and_Q_to_a_solution e E Q)

lemma join_eq_join_iff (k : ‚Ñï) (h_pos : k > 0) (hi‚ÇÅ hi‚ÇÄ lo‚ÇÅ lo‚ÇÄ : BTField (k - 1)) :
    ‚ãò hi‚ÇÅ, lo‚ÇÅ ‚ãô = ‚ãò hi‚ÇÄ, lo‚ÇÄ ‚ãô ‚Üî
  hi‚ÇÅ = hi‚ÇÄ ‚àß lo‚ÇÅ = lo‚ÇÄ

lemma aeval_apply {A : Type w} [CommSemiring A] [Algebra R A] (s : A) :
    aeval (P := P) s = eval‚ÇÇAlgHom (Algebra.ofId R A) s

theorem BitVec.eq_mp_eq_dcast {w w2 : ‚Ñï} (x : BitVec w) (h_width_eq : w = w2)
  (h_bitvec_eq : BitVec w = BitVec w2 := by rw [h_width_eq]) :
  Eq.mp (h:=h_bitvec_eq) (a:=x) = dcast (h_width_eq) (x)

@[simp]
theorem OracleReduction.run_eq_run_reduction [‚àÄ i, OracleInterface (pSpec.Message i)]
    {stmt : StmtIn} {oStmt : ‚àÄ i, OStmtIn i} {wit : WitIn}
    {oracleReduction : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec} :
      oracleReduction.run stmt oStmt wit =
        oracleReduction.toReduction.run ‚ü®stmt, oStmt‚ü© wit

Nat.zero_add in Init.Data.Nat.Basic

theorem fconcat‚ÇÇ_left_injective {Œ±‚ÇÅ : Fin n ‚Üí A} {Œ±‚ÇÇ : Fin n ‚Üí B} {Œ≤‚ÇÅ : A} {Œ≤‚ÇÇ : B} (a : F‚ÇÇ Œ≤‚ÇÅ Œ≤‚ÇÇ) :
    Function.Injective (fun v : (i : Fin n) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i) => fconcat‚ÇÇ (F := F‚ÇÇ) v a)

theorem BaseField_is_prime : Nat.Prime BASE_FIELD_CARD

@[simp]
theorem OracleVerifier.id_soundness {lang : Set (StmtIn √ó ‚àÄ i, OStmtIn i)} :
    (OracleVerifier.id : OracleVerifier oSpec _ _ _ _ _).soundness
      init impl lang lang 0

theorem support_C {r : R} [h : Decidable (r = 0)] :
    (@C R œÉ _ r).support = if r = 0 then ‚àÖ else { 0 }

theorem sum_square_char2 {F : Type*} [Field F] (sumZeroIffEq : ‚àÄ (x y : F), x + y = 0 ‚Üî x = y)
  (s : Finset ‚Ñï) (f : ‚Ñï ‚Üí F) : (‚àë j ‚àà s, f j)^2 = ‚àë j ‚àà s, (f j)^2

@[simp] theorem rightpad_twice_eq_rightpad_max (m n : Nat) (unit : Œ±) (l : List Œ±) :
    rightpad n unit (rightpad m unit l) = rightpad (max m n) unit l

lemma getBit_joinBits {n m k : ‚Ñï} (low : Fin (2 ^ n)) (high : Fin (2 ^ m)) :
  getBit k (joinBits low high).val =
    if k < n then getBit k low.val else getBit (k - n) high.val

protected lemma errors_are_roots_of_elocPoly {i : ‚Ñï}
  (hi : i < n) (h : f i ‚â† p.eval (œâs i)) : (ElocPoly n œâs f p).eval (œâs i) = 0

theorem degrees_C_mul_le (p : MvPolynomial œÉ R) (c : R) : (C c * p).degrees ‚â§ p.degrees

theorem append_run (tr : (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).FullTranscript) :
      (V‚ÇÅ.append V‚ÇÇ).run stmt tr =
        (do
          let stmt‚ÇÇ ‚Üê V‚ÇÅ.run stmt tr.fst
          let stmt‚ÇÉ ‚Üê V‚ÇÇ.run stmt‚ÇÇ tr.snd
          return stmt‚ÇÉ)

lemma roots_comp_X_sub_C (p : L[X]) (a : L) :
    (p.comp (X - C a)).roots = p.roots.map (fun r => r + a)

theorem queryOracleVerifier_rbrKnowledgeSoundness [Fintype L] {œÉ : Type} (init : ProbComp œÉ)
    (impl : QueryImpl []‚Çí (StateT œÉ ProbComp)) :
    (queryOracleVerifier ùîΩq Œ≤ (œë:=œë) Œ≥_repetitions).rbrKnowledgeSoundness init impl
    (relIn := finalSumcheckRelOut ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (relOut := acceptRejectOracleRel)
    (rbrKnowledgeError := queryRbrKnowledgeError ùîΩq Œ≤ Œ≥_repetitions
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))

@[simp]
theorem fflatten‚ÇÇ_two_eq_append {A : Sort u} {B : Sort v} {F : A ‚Üí B ‚Üí Sort w} {n : Fin 2 ‚Üí ‚Ñï}
    {Œ± : (i : Fin 2) ‚Üí (j : Fin (n i)) ‚Üí A}
    {Œ≤ : (i : Fin 2) ‚Üí (j : Fin (n i)) ‚Üí B}
    {v : (i : Fin 2) ‚Üí (j : Fin (n i)) ‚Üí F (Œ± i j) (Œ≤ i j)} :
    fflatten‚ÇÇ v = fappend‚ÇÇ (F := F) (v 0) (v 1)

lemma xor_eq_sub_iff_submask {n m : ‚Ñï} (h: m ‚â§ n) : n ^^^ m = n - m ‚Üî n &&& m = m

theorem buildLayer_neverFails (Œ± : Type) [inst : DecidableEq Œ±] [inst_1 : SelectableType Œ±]
    (preexisting_cache : (spec Œ±).QueryCache) (n : ‚Ñï)
    (leaves : List.Vector Œ± (2 ^ (n + 1))) :
    ((simulateQ randomOracle (buildLayer Œ± n leaves)).run preexisting_cache).neverFails

lemma bwm_of_pos [NeZero n] (h : j.1 < e) :
  BerlekampWelchMatrix e k œâs f i j = -Rhs j.1 œâs f i

lemma cRank_rank_conversion :
  ‚Üë(U.rank) = U.cRank

theorem canonical_empty : (UniPoly.mk (R:=R) #[]).trim = #[]

lemma extract_start_zero_eq_take {n : ‚Ñï} {Œ± : Fin n ‚Üí Sort*} (stop : ‚Ñï) (h : stop ‚â§ n)
    (v : (i : Fin n) ‚Üí Œ± i) : extract 0 stop (Nat.zero_le _) h v = take stop h v

@[simp]
theorem divide_by_2_mem {s : Finset ‚Ñï} {d : ‚Ñï} :
  d ‚àà divide_by_2 s ‚Üî 2 * d ‚àà s

lemma exists_a_set_and_a_matching_polynomial
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  :
  ‚àÉ S', ‚àÉ (h_sub : S' ‚äÜ coeffs_of_close_proximity k œâs Œ¥ u‚ÇÄ u‚ÇÅ), ‚àÉ P : F[Z][X],
    #S' > #(coeffs_of_close_proximity k œâs Œ¥ u‚ÇÄ u‚ÇÅ) / (2 * D_Y Q) ‚àß
    ‚àÄ z : S', Pz (h_sub z.2) = P.map (Polynomial.evalRingHom z.1) ‚àß
    P.natDegree ‚â§ k ‚àß
    Bivariate.degreeX P ‚â§ 1

theorem take_drop_append {Œ± : Sort*} (m : ‚Ñï) (h : m ‚â§ n) (v : Fin n ‚Üí Œ±) :
    Fin.append (take m h v) (drop m h v) = fun i => v (i.cast (by omega))

omit [NeZero ‚Ñì] [NeZero r] [NeZero ùì°] in
lemma fin_‚Ñì_lt_r {h_‚Ñì_add_R_rate : ‚Ñì + ùì° < r} (i : Fin ‚Ñì)
    : i.val < r

@[simp]
theorem lagrangeBasis_zero {w : Vector R 0} : lagrangeBasis w = #v[1]

lemma concrete_exists_pair_ne {k : ‚Ñï} : ‚àÉ x y : ConcreteBTField k, x ‚â† y

@[simp]
theorem ConcreteBTField.RingHom_eq_of_source_eq (k n m : ‚Ñï) (h_eq : k = n) :
    (ConcreteBTField k ‚Üí+* ConcreteBTField m)
    = (ConcreteBTField n ‚Üí+* ConcreteBTField m)

@[to_additive vsum_eq_univ_sum]
lemma vprod_eq_univ_prod [CommMonoid Œ±] {a : Fin n ‚Üí Œ±} : vprod a = ‚àè i, a i

theorem two_le_two_pow_n_plus_1 (n : ‚Ñï) : 2 ‚â§ 2 ^ (n + 1)

@[simp]
theorem happend_right {Œ± : Fin m ‚Üí Sort u} {Œ≤ : Fin n ‚Üí Sort u}
    (u : (i : Fin m) ‚Üí Œ± i) (v : (i : Fin n) ‚Üí Œ≤ i) (i : Fin n) :
    happend u v (natAdd m i) = cast (vappend_right Œ± Œ≤ i).symm (v i)

theorem append_right_injective (a : Fin m ‚Üí Œ±) : Function.Injective (@Fin.append m n Œ± a)

theorem foldl_eq_toList_foldl {Œ± Œ≤} {n : ‚Ñï} (f : Œ≤ ‚Üí Œ± ‚Üí Œ≤) (init : Œ≤) (v : Vector Œ± n) :
  v.foldl (f:=f) (b:=init) = v.toList.foldl (f:=f) (init:=init)

lemma concrete_div_eq_mul_inv {k : ‚Ñï} (a b : ConcreteBTField k) : a / b = a * (concrete_inv b)

lemma inv_eq_pow (a : Field) (ha : a ‚â† 0) : a‚Åª¬π = a ^ (fieldSize - 2)

lemma divide_by_2_def {s : Finset ‚Ñï} :
    divide_by_2 s = (erase_odd s).image (fun n => n / 2)

@[simp]
lemma runWithLogToRound_discard_log_eq_runToRound (i : Fin (n + 1))
    (stmt : StmtIn) (wit : WitIn) (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      Prod.fst <$> prover.runWithLogToRound i stmt wit =
        prover.runToRound i stmt wit

lemma getLowBits_zero_eq_zero {n : ‚Ñï} : getLowBits 0 n = 0

theorem reduction_perfectCompleteness (hInit : init.neverFails) :
    (reduction R deg D n oSpec).perfectCompleteness init impl
      (relationRound R n deg D 0) (relationRound R n deg D (.last n))

lemma towerRingHomForwardMap_join {k : ‚Ñï} (h_pos : k > 0) (hi lo : ConcreteBTField (k - 1)) :
  towerRingHomForwardMap (k:=k) („Ää hi, lo „Äã) =
    BinaryTower.join_via_add_smul (k:=k) (h_pos:=by omega)
      (hi_btf := towerRingHomForwardMap (k:=k-1) hi)
      (lo_btf := towerRingHomForwardMap (k:=k-1) lo)

theorem commitOracleVerifier_rbrKnowledgeSoundness (i : Fin ‚Ñì)
    (hCR : isCommitmentRound ‚Ñì œë i) :
    (commitOracleVerifier ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      i hCR).rbrKnowledgeSoundness init impl
      (relIn := foldStepRelOut (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i.succ)
      (commitKnowledgeError ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))

lemma natDegree_lt_of_mem_degreeLT [NeZero deg] (h : p ‚àà degreeLT F deg) : p.natDegree < deg

@[simp]
lemma zero_mem_relHammingDistRange : 0 ‚àà relHammingDistRange Œπ

@[simp]
private lemma x_times_oddPart'_coeff {f : Polynomial F} {n : ‚Ñï} :
    (x_times_oddPart' f).coeff n = if Odd n then f.coeff n else 0

theorem init_vconcat (v : Fin n ‚Üí Œ±) (a : Œ±) :
    (fun i => vconcat v a (Fin.castSucc i)) = v

lemma is_berlekamp_welch_solution_ext
  (h : ‚àÄ i, (Matrix.mulVec (BerlekampWelchMatrix e k œâs f) v) i = -(f i) * (œâs i) ^ e)
  : IsBerlekampWelchSolution e k œâs f v

theorem ZMod.bla : ‚àÄ {n c : ‚Ñï} (a : ZMod n), c = 1 ‚Üí IsNat (a ^ (n - 1)) c ‚Üí a ^ (n - 1) = 1

@[simp]
theorem ConcreteBTField.RingHom_eq_of_dest_eq (k m n : ‚Ñï) (h_eq : m = n) :
    (ConcreteBTField k ‚Üí+* ConcreteBTField m)
    = (ConcreteBTField k ‚Üí+* ConcreteBTField n)

theorem Basis_cast_dest_eq {Œπ : Type*} (k n m : ‚Ñï) (h_k_le_n : k ‚â§ n)
  (h_k_le_m : k ‚â§ m) (h_eq : m = n) :
  letI instLeftAlgebra := ConcreteBTFieldAlgebra (l:=k) (r:=m) (h_le:=h_k_le_m)
  letI instRightAlgebra := ConcreteBTFieldAlgebra (l:=k) (r:=n) (h_le:=h_k_le_n)
  @Basis Œπ (ConcreteBTField k) (ConcreteBTField m) _ _ instLeftAlgebra.toModule =
  @Basis Œπ (ConcreteBTField k) (ConcreteBTField n) _ _ instRightAlgebra.toModule

theorem degreeOf_X_of_ne (i j : œÉ) (h : i ‚â† j) : degreeOf i (X (R := R) j) = 0

private lemma k_and_e [Zero F]
  (h_n : n ‚â† 0)
  (h_B : B.card ‚â† 0)
  :
  k B = B.card * (n - e B 0) / n

lemma resultant_is_divisible_by_leadingCoeff {F : Type} [CommRing F] [Inhabited F] (f : F[X])
  : ‚àÉ r',
    Polynomial.resultant f (Polynomial.derivative f) = f.leadingCoeff * r'

lemma getMiddleBits_eq_mod {n offset len : ‚Ñï} :
  getMiddleBits offset len n = (n >>> offset) % (2 ^ len)

lemma shift_left_def {s : Finset ‚Ñï} :
    shift_left s = s.filterMap
    (fun n => match n with
      | 0 => .none
      | n + 1 => .some n
      )
    (by aesop)

theorem vconcat_eq_snoc (v : Fin n ‚Üí Œ±) (a : Œ±) : vconcat v a = snoc v a

theorem functional_completeness (Œ± : Type) {s : Skeleton}
  (idx : SkeletonLeafIndex s)
  (leaf_data_tree : LeafData Œ± s)
  (hash : Œ± ‚Üí Œ± ‚Üí Œ±) :
  (getPutativeRoot_with_hash
    idx
    (leaf_data_tree.get idx)
    (generateProof
      (buildMerkleTree_with_hash leaf_data_tree hash) idx)
    (hash)) =
  (buildMerkleTree_with_hash leaf_data_tree hash).getRootValue

theorem rbrKnowledgeSoundness_implies_rbrSoundness
    {relIn : Set (StmtIn √ó WitIn)} {relOut : Set (StmtOut √ó WitOut)}
    {verifier : Verifier oSpec StmtIn StmtOut pSpec}
    {rbrKnowledgeError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    (h : verifier.rbrKnowledgeSoundness init impl relIn relOut rbrKnowledgeError) :
    verifier.rbrSoundness init impl relIn.language relOut.language rbrKnowledgeError

theorem seqCompose_perfectCompleteness (hInit : init.neverFails)
    (rel : (i : Fin (m + 1)) ‚Üí Set ((Stmt i √ó ‚àÄ j, OStmt i j) √ó Wit i))
    (R : ‚àÄ i, OracleReduction oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Wit i.castSucc)
      (Stmt i.succ) (OStmt i.succ) (Wit i.succ) (pSpec i))
    (h : ‚àÄ i, (R i).perfectCompleteness init impl (rel i.castSucc) (rel i.succ)) :
      (OracleReduction.seqCompose Stmt OStmt Wit R).perfectCompleteness
        init impl (rel 0) (rel (Fin.last m))

@[simp]
theorem prover_last_of_two (pSpec : ProtocolSpec 2) [ProverLast pSpec] :
    pSpec.dir 1 = .P_to_V

theorem append_run (stmt : Stmt‚ÇÅ) (wit : Wit‚ÇÅ) :
      (P‚ÇÅ.append P‚ÇÇ).run stmt wit = (do
        let ‚ü®transcript‚ÇÅ, stmt‚ÇÇ, wit‚ÇÇ‚ü© ‚Üê liftM (P‚ÇÅ.run stmt wit)
        let ‚ü®transcript‚ÇÇ, stmt‚ÇÉ, wit‚ÇÉ‚ü© ‚Üê liftM (P‚ÇÇ.run stmt‚ÇÇ wit‚ÇÇ)
        return ‚ü®transcript‚ÇÅ ++‚Çú transcript‚ÇÇ, stmt‚ÇÉ, wit‚ÇÉ‚ü©)

theorem addCases_left' {motive : Fin (m + n) ‚Üí Sort*}
    {left : (i : Fin m) ‚Üí motive (castAdd n i)} {right : (j : Fin n) ‚Üí motive (natAdd m j)}
    {i : Fin m} (j : Fin (m + n)) (h : j = castAdd n i) :
      addCases (motive := motive) left right j = h ‚ñ∏ (left i)

Nat.zero_le in Init.Prelude

Fin.coe_castSucc in Init.Data.Fin.Lemmas

theorem oracleReduction_perfectCompleteness (hInit : init.neverFails) :
    (oracleReduction R n deg D oSpec i).perfectCompleteness init impl
      (relationRound R n deg D i.castSucc) (relationRound R n deg D i.succ)

lemma bIdx_succ_mul_œë_lt_‚Ñì_succ (bIdx : Fin (‚Ñì / œë - 1)) :
    (‚ÜëbIdx + 1) * œë < ‚Ñì + 1

theorem happend_singleton {Œ± : Fin m ‚Üí Sort u} {Œ≤ : Sort u} (u : (i : Fin m) ‚Üí Œ± i) (a : Œ≤) :
    True

@[simp]
lemma List.get_nil (i : Fin 0) (a : Œ±) : [].get i = a

private lemma Bi_biUnion_F2i :
  Bi B i = Finset.univ.biUnion (F2i B i)

@[simp]
theorem fappend‚ÇÇ_zero {Œ±‚ÇÅ : Fin m ‚Üí A} {Œ±‚ÇÇ : Fin m ‚Üí B} {Œ≤‚ÇÅ : Fin 0 ‚Üí A} {Œ≤‚ÇÇ : Fin 0 ‚Üí B}
    (u : (i : Fin m) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i)) :
    fappend‚ÇÇ (F := F‚ÇÇ) u (!h‚¶ÉF‚ÇÇ‚¶Ñ‚ü®Œ≤‚ÇÅ‚ü©‚ü®Œ≤‚ÇÇ‚ü©[] : (i : Fin 0) ‚Üí F‚ÇÇ (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) = u

omit h_Œ≤‚ÇÄ_eq_1 in
theorem sDomainFin_bijective (i : Fin r) (h_i : i < ‚Ñì + R_rate)
: Function.Bijective
  (sDomainFinEquiv ùîΩq Œ≤ h_‚Ñì_add_R_rate i h_i)

theorem liftContext_runWithLogToRound
    {lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    {outerStmtIn : OuterStmtIn} {outerWitIn : OuterWitIn} {i : Fin (n + 1)}
    (P : Prover oSpec InnerStmtIn InnerWitIn InnerStmtOut InnerWitOut pSpec) :
      (P.liftContext lens).runWithLogToRound i outerStmtIn outerWitIn
      = do
        let ‚ü®‚ü®transcript, prvState‚ü©, queryLog‚ü© ‚Üê
          (P.runWithLogToRound i).uncurry (lens.proj (outerStmtIn, outerWitIn))
        return ‚ü®‚ü®transcript, ‚ü®prvState, outerStmtIn, outerWitIn‚ü©‚ü©, queryLog‚ü©

lemma degree_definingPoly {F : Type*} [Field F] [Fintype F] (s : F) [NeZero s] :
  (definingPoly s).degree = 2

theorem decoder_dist_impl_mem
  {k r D e : ‚Ñï}
  (h_e : e ‚â§ n - Real.sqrt (k * n))
  {œâs : Fin n ‚Ü™ F}
  {f : Fin n ‚Üí F}
  {p : F[X]}
  (h_dist : Œî‚ÇÄ(f, p.eval ‚àò œâs) ‚â§ e)
  :
  p ‚àà decoder k r D e œâs f

private lemma K_eq_sum {Œ± : F} : K B i Œ± = ‚àë (x : B), if x.1 i = Œ± then 1 else 0

lemma le_sInf_of_LB {S : Set ‚Ñï} (hne : S.Nonempty) {i : ‚Ñï}
    (hLB : ‚àÄ s ‚àà S, i ‚â§ s) : i ‚â§ sInf S

@[simp]
lemma natDegree_truncate [œÜ : NeZero n] : (truncate p n).natDegree < n

lemma MessageIdxUpTo.eq_MessageIdx {k : Fin (n + 1)} {pSpec : ProtocolSpec n} :
    pSpec.MessageIdxUpTo k = {i : Fin k // pSpec.dir (i.castLE (by omega)) = .P_to_V}

Fin.val_succ in Init.Data.Fin.Lemmas

Fin.is_le' in Init.Data.Fin.Lemmas

Nat.le_add_left in Init.Data.Nat.Basic

@[simp]
theorem hflatten_succ {m : ‚Ñï} {n : Fin (m + 1) ‚Üí ‚Ñï}
    {Œ± : (i : Fin (m + 1)) ‚Üí (j : Fin (n i)) ‚Üí Sort*}
    {v : (i : Fin (m + 1)) ‚Üí (j : Fin (n i)) ‚Üí Œ± i j} :
    hflatten v = happend (v 0) (hflatten (fun i => v i.succ))

@[simp]
lemma Fintype.zero_lt_card {Œπ : Type*} [Fintype Œπ] [Nonempty Œπ] : 0 < Fintype.card Œπ

lemma lin_shift_d [Field F] [Fintype F]
  (h_B : 2 ‚â§ B.card)
  :
  d B = d ({x - v | x ‚àà B} : Finset _)

@[simp]
lemma deevenize_coeff {f : Polynomial F} {n : ‚Ñï} :
    (deevenize f).coeff n = f.coeff (2 * n)

theorem base_intermediateNormVpoly
  (k : Fin (‚Ñì + 1)) :
  intermediateNormVpoly ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®0, by
    by_contra ht
    simp only [not_lt, nonpos_iff_eq_zero] at ht
    contradiction
  ‚ü© ‚ü®k, by simp only [tsub_zero]; omega‚ü© =
  normalizedW ùîΩq Œ≤ ‚ü®k, by omega‚ü©

theorem toMvPolynomial_is_multilinear (p : MlPoly R n) :
  (toMvPolynomial p) ‚àà R‚¶É‚â§ 1‚¶Ñ[X Fin n]

@[simp]
theorem erase_even_mem
  {s : Finset ‚Ñï}
  {n : ‚Ñï}
  : n ‚àà (erase_even s) ‚Üî Odd n ‚àß n ‚àà s

lemma AlgebraTowerEquiv.commutesRight' (e : AlgebraTowerEquiv A B)
    {i j : Œπ} (h : i ‚â§ j) (r : B i) :
  AlgebraTower.algebraMap (AT:=A) (i:=i) (j:=j) (h:=h) ((e.toRingEquiv i).symm r) =
  (e.toRingEquiv j).symm (AlgebraTower.algebraMap (AT:=B) (i:=i) (j:=j) (h:=h) r)

@[simp]
theorem dcast_eq : dcast (Eq.refl a) b = b

theorem vcons_injective2 : Function.Injective2 (@vcons Œ± n)

theorem mul_one (n : ChurchNat Œ±) : mul n one = n

@[simp]
lemma degreeX_monomialXY {n m : ‚Ñï} {a : F} (ha : a ‚â† 0) :
    degreeX (monomialXY n m a) = n

@[simp]
private lemma K_le_card {Œ± : F} : K B i Œ± ‚â§ B.card

theorem succ'_ne_zero (n : Nat) : succ' n ‚â† 0

theorem seqCompose_soundness
    (lang : (i : Fin (m + 1)) ‚Üí Set (Stmt i √ó ‚àÄ j, OStmt i j))
    (V : (i : Fin m) ‚Üí
      OracleVerifier oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Stmt i.succ) (OStmt i.succ)
        (pSpec i))
    (soundnessError : Fin m ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (V i).soundness init impl (lang i.castSucc) (lang i.succ) (soundnessError i)) :
      (OracleVerifier.seqCompose Stmt OStmt V).soundness init impl (lang 0) (lang (Fin.last m))
        (‚àë i, soundnessError i)

lemma getBit_of_lt_two_pow {n: ‚Ñï} (a: Fin (2^n)) (k: ‚Ñï) :
  getBit k a = if k < n then getBit k a else 0

@[simp]
lemma numFullRounds_pos : 0 < params.numFullRounds

lemma wt_eq_hammingNorm [Zero F] {v : Œπ ‚Üí F} :
  wt v = hammingNorm v

theorem reduction_perfectCompleteness (hInit : init.neverFails) :
    (reduction R n deg D oSpec i).perfectCompleteness init impl
    (relationRound R n deg D i.castSucc) (relationRound R n deg D i.succ)

@[simp]
theorem dist_le_card (C : Set (n ‚Üí R)) : dist C ‚â§ Fintype.card n

theorem append_rbrKnowledgeSoundness
    (V‚ÇÅ : Verifier oSpec Stmt‚ÇÅ Stmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : Verifier oSpec Stmt‚ÇÇ Stmt‚ÇÉ pSpec‚ÇÇ)
    {rbrKnowledgeError‚ÇÅ : pSpec‚ÇÅ.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    {rbrKnowledgeError‚ÇÇ : pSpec‚ÇÇ.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    (h‚ÇÅ : V‚ÇÅ.rbrKnowledgeSoundness init impl rel‚ÇÅ rel‚ÇÇ rbrKnowledgeError‚ÇÅ)
    (h‚ÇÇ : V‚ÇÇ.rbrKnowledgeSoundness init impl rel‚ÇÇ rel‚ÇÉ rbrKnowledgeError‚ÇÇ) :
      (V‚ÇÅ.append V‚ÇÇ).rbrKnowledgeSoundness init impl rel‚ÇÅ rel‚ÇÉ
        (Sum.elim rbrKnowledgeError‚ÇÅ rbrKnowledgeError‚ÇÇ ‚àò ChallengeIdx.sumEquiv.symm)

lemma h_sum_two_same_pow2 {k : ‚Ñï} (h_pos : k > 0) : 2 ^ (k - 1) + 2 ^ (k - 1) = 2 ^ k

lemma toCodewordsCount_mul_œë_lt_‚Ñì (‚Ñì œë : ‚Ñï) [NeZero œë] [NeZero ‚Ñì] (i : Fin (‚Ñì + 1)) :
  ‚àÄ j: Fin (toOutCodewordsCount ‚Ñì œë i), j.val * œë < ‚Ñì

@[csimp] lemma dfoldl_eq_dfoldl' : @dfoldl = @dfoldl'

lemma mkLastOracleIndex_last : mkLastOracleIndex ‚Ñì œë (Fin.last ‚Ñì) = ‚Ñì / œë - 1

theorem PrattPartList.out {p : ‚Ñï} {a : ZMod p} {n : ‚Ñï} (h : PrattPartList p a n) :
    ‚àÄ q : ‚Ñï, q.Prime ‚Üí q ‚à£ n ‚Üí a ^ ((p - 1) / q) ‚â† 1

List.length_drop in Init.Data.List.TakeDrop

@[simp]
lemma degreeY_monomialXY {n m : ‚Ñï} {a : F} (ha : a ‚â† 0) :
  natDegreeY (monomialXY n m a) = m

lemma exists_Pz_of_coeffs_of_close_proximity
  {k : ‚Ñï}
  {z : F}
  (hS : z ‚àà coeffs_of_close_proximity (k := k) œâs Œ¥ u‚ÇÄ u‚ÇÅ)
  :
  ‚àÉ Pz : F[X], Pz.natDegree ‚â§ k ‚àß Œ¥·µ£(u‚ÇÄ + z ‚Ä¢ u‚ÇÅ, Pz.eval ‚àò œâs) ‚â§ Œ¥

theorem trim_toImpl [LawfulBEq R] (p : R[X]) : p.toImpl.trim = p.toImpl

@[simp]
theorem Reduction.id_perfectCompleteness {rel : Set (StmtIn √ó WitIn)} (hInit : init.neverFails) :
    (Reduction.id : Reduction oSpec _ _ _ _ _).perfectCompleteness init impl rel rel

theorem vappend_assoc {p : ‚Ñï} (u : Fin m ‚Üí Œ±) (v : Fin n ‚Üí Œ±) (w : Fin p ‚Üí Œ±) :
    (vappend (vappend u v) w) = (vappend u (vappend v w)) ‚àò Fin.cast (add_assoc m n p)

@[simp]
theorem LeafData.leftSubtree_internal {Œ±} {s_left s_right : Skeleton}
    (left : LeafData Œ± s_left) (right : LeafData Œ± s_right) :
    (LeafData.internal left right).leftSubtree = left

@[simp]
lemma addSalt_dir : (pSpec.addSalt Salt).dir = pSpec.dir

omit [Fintype L] [DecidableEq L] in
theorem Polynomial.comp_same_inner_eq_if_same_outer (f g : L[X]) (h_f_eq_g : f = g) :
  ‚àÄ x, f.comp x = g.comp x

theorem computableAdditiveNTT_eq_additiveNTT (a : Fin (2 ^ ‚Ñì) ‚Üí L) :
  computableAdditiveNTT (ùîΩq := ùîΩq) (Œ≤ := Œ≤) (‚Ñì := ‚Ñì) (R_rate := R_rate)
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (a := a) =
  additiveNTT (ùîΩq := ùîΩq) (L := L) (Œ≤ := Œ≤) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (a := a)

theorem foldl_split_inner {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤ ‚Üí Œ±) (init : Œ±)
    (l : List Œ≤) (h : l ‚â† []): foldl (f:=f) (init:=init) (l)
    = foldl (f:=f) (init:=f (init) (l.head (by omega))) (l.tail)

lemma liftF'_liftF_of_lt {k : Fin m} (h : k < n) :
  liftF' (n := m) (liftF (n := n) f') k = f' ‚ü®k, by omega‚ü©

lemma eq_evenize_deevenize {f : Polynomial F} (hEven : EvenPoly f) :
    evenize (deevenize f) = f

theorem generates_quotient_point_if_is_fiber_of_y
    (i : Fin ‚Ñì) (steps : ‚Ñï) (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
    (x : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i, by omega‚ü©))
    (y : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i.val + steps, by omega‚ü©))
    (hx_is_fiber : ‚àÉ (k : Fin (2 ^ steps)), x = qMap_total_fiber ùîΩq Œ≤ (i := ‚ü®i, by omega‚ü©)
      (steps := steps) (h_i_add_steps := by
        simp only; exact fin_‚Ñì_steps_lt_‚Ñì_add_R i steps h_i_add_steps) (y := y) k) :
    y = iteratedQuotientMap ùîΩq Œ≤ h_‚Ñì_add_R_rate i (k := steps) (h_bound := h_i_add_steps) x

omit [DecidableEq ùîΩq] hF‚ÇÇ h_Œ≤‚ÇÄ_eq_1 in
lemma get_sDomain_basis (i : Fin r) (h_i : i < ‚Ñì + R_rate) :
    ‚àÄ (k : Fin (‚Ñì + R_rate - i)),
    (sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate
      i (by omega)) k = eval (Œ≤ ‚ü®i + k.val, by omega‚ü©) (normalizedW ùîΩq Œ≤ i)

@[simp]
theorem codeDist'_subsingleton [Subsingleton C] : ‚ÄñC‚Äñ‚ÇÄ' = ‚ä§

theorem FullData.map_getRootValue {Œ± Œ≤ : Type} {s : Skeleton}
    (f : Œ± ‚Üí Œ≤) (tree : FullData Œ± s) :
    (tree.map f).getRootValue = f (tree.getRootValue)

theorem oracleVerifier_toVerifier_run {stmt : Statement} {oStmt : ‚àÄ i, OStatement i}
    {tr : (oraclePSpec Witness).FullTranscript} :
    (oracleVerifier oSpec Statement OStatement Witness).toVerifier.run ‚ü®stmt, oStmt‚ü© tr =
      pure ‚ü®stmt, Sum.rec oStmt (fun i => match i with | 0 => tr 0)‚ü©

lemma generalised_round_consistency_completeness
  {ùîΩ : Type} [inst1 : Field ùîΩ] [DecidableEq ùîΩ] {f : Polynomial ùîΩ}
  {n : ‚Ñï} [inst : NeZero n]
  {Œ≥ : ùîΩ}
  {s‚ÇÄ : ùîΩ}
  {œâ : Fin n ‚Ü™ ùîΩ}
  (h : ‚àÄ i, (œâ i) ^ n = 1)
  (h‚ÇÅ : s‚ÇÄ ‚â† 0)
  :
    roundConsistencyCheck
      Œ≥
      (List.map (fun i => (œâ i * s‚ÇÄ, f.eval (œâ i * s‚ÇÄ))) (List.finRange n))
      ((foldNth n f Œ≥).eval (s‚ÇÄ^n)) = true

@[simp]
theorem simulateQ_run_liftComp_fst {Œπ' : Type u} {superSpec : OracleSpec Œπ'}
    (oa : OracleComp spec Œ±) [SubSpec spec superSpec] :
      Prod.fst <$> (simulateQ loggingOracle oa).run.liftComp superSpec =
        Prod.fst <$> (simulateQ loggingOracle (oa.liftComp superSpec)).run

@[simp]
theorem embedSum_splitSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (k : Fin (vsum n)) :
    embedSum (splitSum k).1 (splitSum k).2 = k

lemma coeff_vectors_linear_independent
  (‚Ñì : Nat) (h_‚Ñì : ‚Ñì ‚â§ r) :
    LinearIndependent L (toCoeffsVec (‚Ñì := ‚Ñì) ‚àò (basisVectors ùîΩq Œ≤ ‚Ñì h_‚Ñì))

lemma BerlekampWelch_E_ne_zero {e k : ‚Ñï}
  {œâs f : Fin n ‚Üí F}
  {E Q : Polynomial F}
  (h_cond : BerlekampWelchCondition e k œâs f E Q)
  : E ‚â† 0

@[simp]
theorem happend_left {Œ± : Fin m ‚Üí Sort u} {Œ≤ : Fin n ‚Üí Sort u}
    (u : (i : Fin m) ‚Üí Œ± i) (v : (i : Fin n) ‚Üí Œ≤ i) (i : Fin m) :
    happend u v (castAdd n i) = cast (vappend_left Œ± Œ≤ i).symm (u i)

theorem intermediateNormVpoly_comp_qmap (i : Fin (‚Ñì))
    (k : Fin (‚Ñì - i - 1)) : -- corresponds to intermediateNormVpoly_comp

theorem two_eq_zero_in_char2_field {F : Type*} [Field F]
  (sumZeroIffEq : ‚àÄ (x y : F), x + y = 0 ‚Üî x = y) : (2 : F) = 0

theorem BitVec.bitvec_cast_eq_dcast {n m : Nat} (h : n = m) (bv : BitVec n) :
  BitVec.cast h bv = DCast.dcast h bv

@[simp]
lemma isRoot_polynomialsOfCoeffs {x : F} :
  IsRoot (polynomialOfCoeffs coeffs) x ‚Üî eval x (polynomialOfCoeffs coeffs) = 0

theorem oracleReduction_rbr_knowledge_soundness : True

Fin.eta in Init.Data.Fin.Lemmas

theorem singleEqPolynomial_symm (r : R) (s : R) :
    (singleEqPolynomial r (C s) : MvPolynomial œÉ R) = singleEqPolynomial s (C r)

lemma Fin.le_iff_lt_succ (a b : Fin r) (h_b : b + 1 < r) : a ‚â§ b ‚Üî a < b + 1

@[grind]
lemma degreeX_le_degreeX_sub_degreeX [IsDomain F] {f q : F[X][Y]} (hf : f ‚â† 0) (hg : q * f ‚â† 0) :
  degreeX q ‚â§ degreeX (q * f) - degreeX f

private lemma x_times_oddPart'_eq_x_times_oddPart' {f : Polynomial F} :
    Polynomial.X * (oddPart' f) = x_times_oddPart' f

@[simp]
theorem dist_subsingleton {C : Set (n ‚Üí R)} [Subsingleton C] : ‚ÄñC‚Äñ‚ÇÄ = 0

theorem append_rbrSoundness (V‚ÇÅ : OracleVerifier oSpec Stmt‚ÇÅ OStmt‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : OracleVerifier oSpec Stmt‚ÇÇ OStmt‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ pSpec‚ÇÇ)
    {rbrSoundnessError‚ÇÅ : pSpec‚ÇÅ.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    {rbrSoundnessError‚ÇÇ : pSpec‚ÇÇ.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    (h‚ÇÅ : V‚ÇÅ.rbrSoundness init impl lang‚ÇÅ lang‚ÇÇ rbrSoundnessError‚ÇÅ)
    (h‚ÇÇ : V‚ÇÇ.rbrSoundness init impl lang‚ÇÇ lang‚ÇÉ rbrSoundnessError‚ÇÇ) :
      (V‚ÇÅ.append V‚ÇÇ).rbrSoundness init impl lang‚ÇÅ lang‚ÇÉ
        (Sum.elim rbrSoundnessError‚ÇÅ rbrSoundnessError‚ÇÇ ‚àò ChallengeIdx.sumEquiv.symm)

@[simp]
theorem removeNth_update : removeNth p (update s p y) = removeNth p s

theorem snoc_ne_zero_of_right (h : y ‚â† 0) : snoc s y ‚â† 0

lemma getBit_of_sub_two_pow_of_bit_1 {n i j: ‚Ñï} (h_getBit_eq_1: getBit i n = 1) :
  getBit j (n - 2^i) = (if j = i then 0 else getBit j n)

lemma liftF_eq_of_lt {i : ‚Ñï} (h : i < n) : liftF f' i = f' ‚ü®i, h‚ü©

theorem fiberwise_dist_lt_imp_dist_lt_unique_decoding_radius (i : Fin ‚Ñì) (steps : ‚Ñï)
    [NeZero steps] (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
    (f : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i, by omega‚ü©)
  (h_fw_dist_lt : fiberwiseClose ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
    (i := i) (steps := steps) (h_i_add_steps := h_i_add_steps) (f := f)) :
  hammingClose ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i, by omega‚ü© f

theorem happend_hconcat {Œ± : Fin m ‚Üí Sort u} {Œ≤ : Fin n ‚Üí Sort u} {Œ≥ : Sort u}
    (u : (i : Fin m) ‚Üí Œ± i) (v : (i : Fin n) ‚Üí Œ≤ i) (c : Œ≥) :
    True

@[simp]
lemma Rhs_add_one : Rhs (e + 1) œâs f = fun i ‚Ü¶ Rhs e œâs f i * œâs i

omit [(i : Œπ‚Çõ) ‚Üí OracleInterface (OStatement i)] [OracleInterface Witness] in
theorem oracleProver_run {stmt : Statement} {oStmt : ‚àÄ i, OStatement i} {wit : Witness} :
    (oracleProver oSpec Statement OStatement Witness).run ‚ü®stmt, oStmt‚ü© wit =
      pure (fun i => by aesop, ‚ü®stmt, Sum.rec oStmt (fun _ => wit)‚ü©, ())

lemma C_injective : Function.Injective (C : R ‚Üí P)

lemma algebraMap_binaryTowerAlgebra_def (l r : ‚Ñï) (h_le : l ‚â§ r) :
  (@binaryAlgebraTower (l:=l) (r:=r) (h_le:=h_le)).algebraMap = towerAlgebraMap l r h_le

Nat.add_sub_cancel in Init.Data.Nat.Basic

@[simp]
theorem vconcat_castSucc (v : Fin n ‚Üí Œ±) (a : Œ±) (i : Fin n) :
    vconcat v a (castSucc i) = v i

@[grind]
lemma coeff_ne_zero {f q : F[X][Y]} (hg : q * f ‚â† 0) : q.coeff ‚â† 0

@[simp]
theorem Set.not_mem_language_iff {Œ± Œ≤} (rel : Set (Œ± √ó Œ≤)) (stmt : Œ±) :
    stmt ‚àâ rel.language ‚Üî ‚àÄ wit, (stmt, wit) ‚àâ rel

lemma relHammingDist_le_blockRelDistance
  (i k : ‚Ñï) {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F} {œÜ' : (indexPowT S œÜ i) ‚Ü™ F}
  [DecidableEq F] [DecidableEq Œπ] [Smooth œÜ]
  (f g : (indexPowT S œÜ i) ‚Üí F) (S' : Finset (indexPowT S œÜ i))
  [h_fintype : ‚àÄ i : ‚Ñï, Fintype (indexPowT S œÜ i)]
  [DecidableEq (indexPowT S œÜ i)] [Smooth œÜ']
  [h_dec : DecidableBlockDisagreement i k f S' œÜ'] :
  Œ¥·µ£(f, g) ‚â§ Œî·µ£(i, k, f, S', œÜ', g)

theorem linear_sum_repr (R : Type*) [CommRing R] (S : Type*) [CommRing S] [Algebra R S]
    (pb : PowerBasis R S) (h_dim : pb.dim = (2 : ‚Ñï)) (s : S) :
    ‚àÉ a b : R, s = a ‚Ä¢ pb.gen + algebraMap R S b

lemma X‚±º_zero_eq_one (‚Ñì : ‚Ñï) (h_‚Ñì : ‚Ñì ‚â§ r) :
  X‚±º ùîΩq Œ≤ ‚Ñì h_‚Ñì ‚ü®0, by exact Nat.two_pow_pos ‚Ñì‚ü© = 1

lemma zsmul_neg' {k : ‚Ñï} (n : ‚Ñï) (a : ConcreteBTField k) :
  (if ((Int.negSucc n) : ‚Ñ§) % (2 : ‚Ñ§) = (0 : ‚Ñ§) then zero else a) =
    neg (if (‚Üën.succ : ‚Ñ§) % (2 : ‚Ñ§) = (0 : ‚Ñ§) then zero else a)

theorem seqCompose_rbrSoundness
    (lang : (i : Fin (m + 1)) ‚Üí Set (Stmt i))
    (V : (i : Fin m) ‚Üí Verifier oSpec (Stmt i.castSucc) (Stmt i.succ) (pSpec i))
    (rbrSoundnessError : ‚àÄ i, (pSpec i).ChallengeIdx ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (V i).rbrSoundness init impl (lang i.castSucc) (lang i.succ) (rbrSoundnessError i)) :
      (Verifier.seqCompose Stmt V).rbrSoundness init impl (lang 0) (lang (Fin.last m))
        (fun combinedIdx =>
          letI ij := seqComposeChallengeIdxToSigma combinedIdx
          rbrSoundnessError ij.1 ij.2)

theorem liftContext_runToRound
    {lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    {outerStmtIn : OuterStmtIn} {outerWitIn : OuterWitIn} {i : Fin (n + 1)}
    (P : Prover oSpec InnerStmtIn InnerWitIn InnerStmtOut InnerWitOut pSpec) :
      (P.liftContext lens).runToRound i outerStmtIn outerWitIn
      = do
        let ‚ü®transcript, prvState‚ü© ‚Üê
          (P.runToRound i).uncurry (lens.proj (outerStmtIn, outerWitIn))
        return ‚ü®transcript, ‚ü®prvState, outerStmtIn, outerWitIn‚ü©‚ü©

theorem vcons_eq_const (a : Œ±) : a ::·µõ (fun _ : Fin n => a) = fun _ => a

theorem succ_eq_one_add (n : ChurchNat Œ±) : succ n = add one n

lemma concreteTowerAlgebraMap_id (k : ‚Ñï) :
    concreteTowerAlgebraMap (h_le:=by omega) = RingHom.id (ConcreteBTField k)

lemma one_bitvec_shiftRight {d : ‚Ñï} (h_d : d > 0) : 1 >>> d = 0

lemma qMap_total_fiber_basis_sum_repr (i : Fin ‚Ñì) (steps : ‚Ñï) (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
    (y : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) (i := ‚ü®i + steps, by omega‚ü©))
    (k : Fin (2 ^ steps)) :
    let x : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i, by omega‚ü©) := qMap_total_fiber ùîΩq Œ≤
      (i := ‚ü®i, by omega‚ü©) (steps := steps) (h_i_add_steps := by
        apply Nat.lt_add_of_pos_right_of_le; omega) (y := y) (k)
    let basis_x := sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i, by omega‚ü©
      (by simp only; apply Nat.lt_add_of_pos_right_of_le; omega)
    let basis_y := sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i + steps, by omega‚ü©
      (h_i := by apply Nat.lt_add_of_pos_right_of_le; omega)
    let y_coeffs := basis_y.repr y
    x = ‚àë j : Fin (‚Ñì + ùì° - i), (
      fiber_coeff (i := i) (steps := steps) (j := j) (elementIdx := k) (y_coeffs := y_coeffs)
    ) ‚Ä¢ (basis_x j)

@[grind =_]
lemma ne_zero_iff_coeffs_ne_zero (f : F[X][Y]) : f ‚â† 0 ‚Üî f.coeff ‚â† 0

omit [NeZero r] in
theorem hŒ≤_lin_indep_concrete (k : ‚Ñï) :
    letI := ConcreteBTFieldAlgebra (l:=0) (r:=k) (h_le:=by omega)
    LinearIndependent (R := ConcreteBTField 0)
      (v := computableBasisExplicit k)

@[simp]
theorem Set.mem_language_iff {Œ± Œ≤} (rel : Set (Œ± √ó Œ≤)) (stmt : Œ±) :
    stmt ‚àà rel.language ‚Üî ‚àÉ wit, (stmt, wit) ‚àà rel

@[grind _=_]
lemma weightedDegree_eq_natWeightedDegree {u v : ‚Ñï} :
  f ‚â† 0 ‚Üí weightedDegree f u v = natWeightedDegree f u v

lemma oracle_block_k_next_le (i : Fin (‚Ñì + 1)) (j : Fin (toOutCodewordsCount ‚Ñì œë i))
    (hj : j.val + 1 < toOutCodewordsCount ‚Ñì œë i) : j.val * œë + œë ‚â§ i

theorem insertNth_ne_zero_of_right (h : s ‚â† 0) : insertNth p y s ‚â† 0

@[simp]
theorem card_filter_prod_self_eq :
  #({x ‚àà s √óÀ¢ s | x.1 = x.2}) = #s

theorem hconcat_inj {Œ± : Fin n ‚Üí Sort u} {Œ≤ : Sort u} (v‚ÇÅ v‚ÇÇ : (i : Fin n) ‚Üí Œ± i) (a‚ÇÅ a‚ÇÇ : Œ≤) :
    hconcat v‚ÇÅ a‚ÇÅ = hconcat v‚ÇÇ a‚ÇÇ ‚Üî v‚ÇÅ = v‚ÇÇ ‚àß a‚ÇÅ = a‚ÇÇ

omit [NeZero ‚Ñì] [NeZero r] [NeZero ùì°] in
lemma ‚Ñì_lt_r {h_‚Ñì_add_R_rate : ‚Ñì + ùì° < r}
    : ‚Ñì < r

theorem mca_capacity_bound_CONJECTURE
  [DecidableEq Œπ]
  (Œ± : F) (œÜ : Œπ ‚Ü™ F) (m : ‚Ñï) [Smooth œÜ]
  (par‚Ñì_type : Type) [Fintype par‚Ñì_type] (exp : par‚Ñì_type ‚Ü™ ‚Ñï) :
  let Gen := RSGenerator.genRSC par‚Ñì_type œÜ m exp
  let : Fintype Gen.par‚Ñì := Gen.h‚Ñì
  haveI := Gen.Gen_nonempty
  ‚àÉ (c‚ÇÅ c‚ÇÇ : ‚Ñï),
    ‚àÄ (f : Gen.par‚Ñì ‚Üí Œπ ‚Üí F) (Œ∑ : ‚Ñù) (_hŒ∑ : 0 < Œ∑) (Œ¥ : ‚Ñù‚â•0)
      (_hŒ¥ : 0 < Œ¥ ‚àß Œ¥ < 1 - Gen.rate - Œ∑),
      Pr_{let r ‚Üê$·µñ Gen.Gen}[ proximityCondition f Œ¥ r Gen.C ] ‚â§
        ENNReal.ofReal (
          (((Fintype.card par‚Ñì_type - 1) : ‚Ñù)^c‚ÇÇ * ((2^m) : ‚Ñù)^c‚ÇÇ) /
          (Œ∑^c‚ÇÅ * Gen.rate^(c‚ÇÅ+c‚ÇÇ) * (Fintype.card F))
        )

theorem unique_linear_decomposition_succ (k : ‚Ñï) :
  letI : Algebra (ConcreteBTField k) (ConcreteBTField (k+1)) :=
    ConcreteBTFieldAlgebra (l:=k) (r:=k+1) (h_le:=by omega)
  ‚àÄ (x : ConcreteBTField (k+1)), ‚àÉ! (p : ConcreteBTField k √ó ConcreteBTField k),
    x = join_via_add_smul (k+1) (by omega) p.1 p.2

@[simp]
protected lemma elocPoly_leading_coeff_one : (ElocPoly n œâs f p).leadingCoeff = 1

omit [DecidableEq ùîΩq] hF‚ÇÇ in
lemma initial_tiled_coeffs_correctness (h_‚Ñì : ‚Ñì ‚â§ r) (a : Fin (2 ^ ‚Ñì) ‚Üí L) :
    let b: Fin (2^(‚Ñì + R_rate)) ‚Üí L := tileCoeffs a
    additiveNTTInvariant ùîΩq Œ≤ h_‚Ñì_add_R_rate b a (i := ‚ü®‚Ñì, by omega‚ü©)

@[simp]
theorem rtake_append_right :
    (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).rtake n (Nat.le_add_left n m) = pSpec‚ÇÇ

@[to_additive /-- A variant of `Finset.add_sum_erase` with the addition swapped.--/]
theorem prod_mul_erase {Œ± Œ≤ : Type*} [CommMonoid Œ≤] [DecidableEq Œ±] (s : Finset Œ±) (f : Œ± ‚Üí Œ≤)
{a : Œ±} (h : a ‚àà s) : f a * (‚àè x ‚àà s.erase a, f x) = ‚àè x ‚àà s, f x

theorem vcons_right_injective (a : Œ±) :
    Function.Injective (vcons a : (Fin n ‚Üí Œ±) ‚Üí Fin (n + 1) ‚Üí Œ±)

@[simp]
theorem seqCompose_zero {n : Fin 0 ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    {T : ‚àÄ i, FullTranscript (pSpec i)} :
    seqCompose T = !h[]

theorem seqCompose_rbrSoundness
    (lang : (i : Fin (m + 1)) ‚Üí Set (Stmt i √ó ‚àÄ j, OStmt i j))
    (V : (i : Fin m) ‚Üí
      OracleVerifier oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Stmt i.succ) (OStmt i.succ)
        (pSpec i))
    (rbrSoundnessError : ‚àÄ i, (pSpec i).ChallengeIdx ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (V i).rbrSoundness init impl (lang i.castSucc) (lang i.succ) (rbrSoundnessError i)) :
      (OracleVerifier.seqCompose Stmt OStmt V).rbrSoundness
        init impl (lang 0) (lang (Fin.last m))
        (fun combinedIdx =>
          letI ij := seqComposeChallengeIdxToSigma combinedIdx
          rbrSoundnessError ij.1 ij.2)

lemma Œ≤_regular (R : F[X][X][Y])
                (H : F[X][Y]) [H_irreducible : Fact (Irreducible H)]
                {D : ‚Ñï} (hD : D ‚â• Bivariate.totalDegree H) :
    ‚àÄ t : ‚Ñï, ‚àÉ Œ≤ : ùí™ H, weight_Œõ_over_ùí™ Œ≤ ‚â§ (2 * t + 1) * Bivariate.natDegreeY R * D

lemma eq_degree_of_equiv [LawfulBEq R] {p q : UniPoly R} : equiv p q ‚Üí p.degree = q.degree

Nat.lt_trans in Init.Prelude

lemma toImpl_nonzero {p : Q[X]} (hp : p ‚â† 0) : p.toImpl.size > 0

lemma definingPoly_is_monic {F : Type*} [Field F] [Fintype F] (s : F) [NeZero s] :
  (definingPoly s).Monic

lemma mulVec_BerlekampWelchMatrix_eq :
  (BerlekampWelchMatrix e k œâs f).mulVec v i =
  ‚àë x : Fin (2 * e + k), v x * if x < e then f i * œâs i ^ x.1 else -œâs i ^ (x - e)

theorem sum_le_of_divSum?_eq_some {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {k : Fin (‚àë j, n j)} {i : Fin m}
    (hi : divSum? n k = some i) : ‚àë j : Fin i, n (castLE i.isLt.le j) ‚â§ k

@[simp]
lemma natDegree_solutionToQ :
  (solutionToQ e k v).natDegree ‚â§ e + k - 1

lemma irreducible_factorization_of_gs_solution
  {k : ‚Ñï}
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ) :
  ‚àÉ (C : F[Z][X]) (R : List F[Z][X][Y]) (f : List ‚Ñï) (e : List ‚Ñï),
    R.length = f.length ‚àß
    f.length = e.length ‚àß
    ‚àÄ e·µ¢ ‚àà e, 1 ‚â§ e·µ¢ ‚àß
    ‚àÄ R·µ¢ ‚àà R, R·µ¢.Separable ‚àß
    ‚àÄ R·µ¢ ‚àà R, Irreducible R·µ¢ ‚àß
    Q = (Polynomial.C C) *
        ‚àè (R·µ¢ ‚àà R.toFinset) (f·µ¢ ‚àà f.toFinset) (e·µ¢ ‚àà e.toFinset),
          (R·µ¢.comp ((Y : F[Z][X][Y]) ^ f·µ¢))^e·µ¢

theorem castSum_castAdd {n m : ‚Ñï} (i : Fin n) : castSum [n, m] (by simp) i = castAdd m i

theorem fold_advances_evaluation_poly
  (i : Fin (‚Ñì)) (h_i_succ_lt : i + 1 < ‚Ñì + ùì°)
  (coeffs : Fin (2 ^ (‚Ñì - ‚Üëi)) ‚Üí L) (r_chal : L) :
  let P_i : L[X] := intermediateEvaluationPoly ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i, by
    exact Nat.lt_trans (n := i) (k := ‚Ñì+1) (m := ‚Ñì) (h‚ÇÅ := i.isLt) (by exact Nat.lt_add_one ‚Ñì)
  ‚ü©) coeffs
  let f_i

lemma forwardRange_succ_right_ne_empty (n : ‚Ñï) (r : Fin (n - 1)) (l : Fin (r.val + 1)) :
  forwardRange n ‚ü®r + 1, by omega‚ü© ‚ü®l, by simp only; omega‚ü© ‚â† []

@[grind _=_]
theorem monomialXY_mul_monomialXY {n m p q : ‚Ñï} {a b : F} :
    monomialXY n m a * monomialXY p q b = monomialXY (n + p) (m + q) (a * b)

theorem le_iff_toNat_le (a b : AssocNat) : a ‚â§ b ‚Üî toNat a ‚â§ toNat b

theorem comp_x_square_coeff {f : Polynomial F} {n : ‚Ñï} :
  (f.comp (X * X)).coeff n = if Even n then f.coeff (n / 2) else 0

@[simp]
lemma numFullRounds_dvd_by_2 : 2 ‚à£ params.numFullRounds

lemma algebraMap_adjacent_tower_def (l : ‚Ñï) :
  (algebraMap (BTField l) (BTField (l + 1))) = canonicalEmbedding l

nonpos_iff_eq_zero in Mathlib.Algebra.Order.Monoid.Canonical.Defs

@[simp]
theorem bool_accepts_iff : (bool j).accepts x ‚Üî x j * (x j - 1) = 0

@[simp]
lemma range_def : (spec Œ±).range () = Œ±

omit [DecidableEq L] [DecidableEq ùîΩq] h_Fq_char_prime hF‚ÇÇ hŒ≤_lin_indep h_Œ≤‚ÇÄ_eq_1 in
lemma intermediateNovelBasisX_zero_eq_one (i : Fin (‚Ñì + 1)) :
    intermediateNovelBasisX ùîΩq Œ≤ h_‚Ñì_add_R_rate i ‚ü®0, by
      exact Nat.two_pow_pos (‚Ñì - ‚Üëi)‚ü© = 1

@[simp]
theorem hflatten_two_eq_append {n : Fin 2 ‚Üí ‚Ñï} {Œ± : (i : Fin 2) ‚Üí (j : Fin (n i)) ‚Üí Sort*}
    {v : (i : Fin 2) ‚Üí (j : Fin (n i)) ‚Üí Œ± i j} : hflatten v = happend (v 0) (v 1)

@[simp]
theorem simulateQ'_bind (oa : OracleComp spec Œ±) (ob : Œ± ‚Üí OracleComp spec Œ≤)
    -- Could potentially be weakened to `‚àÄ x ‚àà oa.support, (ob x).neverFails`
    -- Would require `bindOnSupport` instead of just `bind`
    (ha : oa.neverFails) (hb : ‚àÄ x, (ob x).neverFails) :
      simulateQ' so (oa >>= ob) (by simp; exact ‚ü®ha, fun x _ => hb x‚ü©) =
      simulateQ' so oa ha >>= fun x ‚Ü¶ simulateQ' so (ob x) (hb x)

lemma runWithOracle_buildMerkleTree {s} (leaf_data_tree : LeafData Œ± s) (f) :
    (runWithOracle f (buildMerkleTree leaf_data_tree))
    = buildMerkleTree_with_hash leaf_data_tree fun (left right : Œ±) =>
      (f () ‚ü®left, right‚ü©)

lemma eval‚ÇÇ_f_eq_C (r : R) (x : P) : eval‚ÇÇ (P := P) (C : R ‚Üí+* P) x (C r) = C r

theorem Nat.reconstruct_from_hi_and_lo_parts_or_ver (n hi_len lo_len : ‚Ñï)
  (h_n : n < 2 ^ (hi_len + lo_len)) :
    n = (((n >>> lo_len) % (2 ^ hi_len)) <<< lo_len) ||

theorem prime_11 : Nat.Prime 11

lemma min_dist_le_d [Field F] {B : Finset (Fin n ‚Üí F)} (v : Fin n ‚Üí F)
  :
  sInf { d | ‚àÉ u ‚àà B, ‚àÉ v ‚àà B, u ‚â† v ‚àß hammingDist u v = d } ‚â§ d B

@[simp] lemma natCast_eq {k : ‚Ñï} (n : ‚Ñï) : (‚Üën : ConcreteBTField k) = natCast n

lemma towerRingHomForwardMap_mul_eq (k : ‚Ñï) (x y : ConcreteBTField k) :
    towerRingHomForwardMap (k:=k) (x * y)
    = towerRingHomForwardMap (k:=k) x * towerRingHomForwardMap (k:=k) y

theorem drop_repeat {Œ± : Type*} {n' : ‚Ñï} (m : ‚Ñï) (h : m ‚â§ n) (a : Fin n' ‚Üí Œ±) :
    drop (m * n') (Nat.mul_le_mul_right n' h) (Fin.repeat n a) =
      fun i : Fin (n * n' - m * n') =>
          (Fin.repeat (n - m) a (i.cast (Nat.sub_mul n m n').symm))

theorem liftContext_knowledgeSoundness [Inhabited InnerStmtOut] [Inhabited InnerWitIn]
    {outerRelIn : Set (OuterStmtIn √ó OuterWitIn)} {outerRelOut : Set (OuterStmtOut √ó OuterWitOut)}
    {innerRelIn : Set (InnerStmtIn √ó InnerWitIn)} {innerRelOut : Set (InnerStmtOut √ó InnerWitOut)}
    {knowledgeError : ‚Ñù‚â•0}
    {stmtLens : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut}
    {witLens : Witness.InvLens OuterStmtIn OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    (V : Verifier oSpec InnerStmtIn InnerStmtOut pSpec)
    [lensKS : Extractor.Lens.IsKnowledgeSound outerRelIn innerRelIn outerRelOut innerRelOut
      (V.compatStatement stmtLens) (fun _ _ => True) ‚ü®stmtLens, witLens‚ü©]
    (h : V.knowledgeSoundness init impl innerRelIn innerRelOut knowledgeError) :
      (V.liftContext stmtLens).knowledgeSoundness init impl outerRelIn outerRelOut
        knowledgeError

@[simp]
theorem dcast_trans (h : a = a') (h' : a' = a'') :
    dcast h' (dcast h b) = dcast (h.trans h') b

Nat.le_trans in Init.Prelude

theorem fappend_ext {Œ± : Fin m ‚Üí A} {Œ≤ : Fin n ‚Üí A}
    (u‚ÇÅ u‚ÇÇ : (i : Fin m) ‚Üí F (Œ± i)) (v‚ÇÅ v‚ÇÇ : (i : Fin n) ‚Üí F (Œ≤ i)) :
    fappend u‚ÇÅ v‚ÇÅ = fappend u‚ÇÇ v‚ÇÇ ‚Üî u‚ÇÅ = u‚ÇÇ ‚àß v‚ÇÅ = v‚ÇÇ

@[csimp]
theorem dcons_eq_cons : @dcons = @cons

theorem congrArg‚ÇÉ {Œ± Œ≤ Œ≥ Œ¥ : Sort*} {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥ ‚Üí Œ¥} {a a' : Œ±} {b b' : Œ≤} {c c' : Œ≥}
    (h : a = a') (h' : b = b') (h'' : c = c') : f a b c = f a' b' c'

omit h_Fq_char_prime hF‚ÇÇ in
lemma inductive_rec_form_W_comp (i : Fin r) (h_i_add_1 : i + 1 < r)
    (h_prev_linear_map : IsLinearMap (R := ùîΩq) (M := L[X]) (M‚ÇÇ := L[X])
      (f := fun inner_p ‚Ü¶ (W ùîΩq Œ≤ i).comp inner_p))
    : ‚àÄ p: L[X], (W ùîΩq Œ≤ (i + 1)).comp p =
      ((W ùîΩq Œ≤ i).comp p) ^ Fintype.card ùîΩq -
        C (eval (Œ≤ i) (W ùîΩq Œ≤ i)) ^ (Fintype.card ùîΩq - 1) * ((W ùîΩq Œ≤ i).comp p)

lemma subUpFull_of_vandermonde_is_vandermonde (h : n ‚â§ m) :
  Matrix.vandermonde (Œ± ‚àò Fin.castLE h) =
  Matrix.subUpFull (nonsquare n Œ±) (Fin.castLE h)

lemma algebra_adjacent_tower_eq_AdjoinRoot_algebra (k : ‚Ñï) :
  (algebra_adjacent_tower k) = (AdjoinRoot.instAlgebra (poly k))

theorem evalNormalizedWAt_eq_normalizedW (i : Fin r) (x : L) :
  evalNormalizedWAt (Œ≤ := Œ≤) (‚Ñì := ‚Ñì) (R_rate := R_rate) (i := i) x
    = (normalizedW (ùîΩq := ùîΩq) (Œ≤ := Œ≤) (i := i)).eval x

lemma rootMultiplicity_some_implies_root {F : Type} [CommSemiring F] [DecidableEq F]
  {x y : F} {f : F[X][Y]} (h : some 0 < (rootMultiplicity (f := f) x y))
  : (f.eval 0).eval 0 = 0

@[simp]
theorem dcons_zero {motive : Fin (n + 1) ‚Üí Sort u} (a : motive 0)
    (v : (i : Fin n) ‚Üí motive i.succ) : (a ::·µà‚ü®motive‚ü© v) 0 = a

private lemma johnson_denom [Zero F]
  (h_card : 2 ‚â§ (Fintype.card F))
  :
  (Fintype.card F / (Fintype.card F - 1)) *
  ((1 - e B 0 / n) ^ 2  + (e B 0) ^ 2 / ((Fintype.card F - 1) * n^2) - 1 + d B/n)
  =
  (1 - ((Fintype.card F) / (Fintype.card F - 1)) *
  (e B 0 / n)) ^ 2 - (1 - ((Fintype.card F) / (Fintype.card F - 1)) * (d B/n))

theorem cast_processRound (j : Fin n‚ÇÅ)
    (P : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec‚ÇÅ)
    (currentResult : OracleComp (oSpec ++‚Çí [pSpec‚ÇÅ.Challenge]‚Çí)
      (Transcript j.castSucc pSpec‚ÇÅ √ó P.PrvState j.castSucc)) :
    P.processRound j currentResult =
      cast (sorry) ((P.cast hn hSpec).processRound (Fin.cast hn j) sorry)

@[simp]
theorem OracleReduction.id_runWithLog (stmt : StmtIn) (oStmt : ‚àÄ i, OStmtIn i) (wit : WitIn) :
    (OracleReduction.id : OracleReduction oSpec StmtIn OStmtIn WitIn _ _ _ _).runWithLog
      stmt oStmt wit = pure ‚ü®‚ü®default, ‚ü®stmt, oStmt‚ü©, wit‚ü©, ‚ü®stmt, oStmt‚ü©, [], []‚ü©

omit [NeZero ‚Ñì] [NeZero r] [NeZero ùì°] in
lemma fin_‚Ñì_steps_lt_r {h_‚Ñì_add_R_rate : ‚Ñì + ùì° < r} (i : Fin ‚Ñì) (steps : ‚Ñï)
    (h : i.val + steps ‚â§ ‚Ñì) : i.val + steps < r

theorem support_finSuccEquivNth_nonempty {f : MvPolynomial (Fin (n + 1)) R} (h : f ‚â† 0) :
    (finSuccEquivNth R p f).support.Nonempty

@[simp]
theorem LeafData.optionComposeBuild_internal {Œ±} {s_left s_right : Skeleton}
    (left : LeafData Œ± s_left) (right : LeafData Œ± s_right)
    (compose : Œ± ‚Üí Œ± ‚Üí Option Œ±) :
    (LeafData.internal left right).optionComposeBuild compose =
      FullData.internal
        (Option.doubleBind compose
          (left.optionComposeBuild compose).getRootValue
          (right.optionComposeBuild compose).getRootValue)
        (left.optionComposeBuild compose)
        (right.optionComposeBuild compose)

theorem neg_trim [LawfulBEq R] (p : UniPoly R) : p.trim = p ‚Üí (-p).trim = -p

lemma getBit_lt_2 {k n : Nat} : getBit k n < 2

lemma rank_eq_colRank : U.rank = colRank U

Fin.val_injective in Mathlib.Data.Fin.Basic

theorem rightpad_getElem_eq_getD {a b : List Œ±} {unit : Œ±} {i : Nat}
  (h : i < (a.rightpad b.length unit).length) :
    (a.rightpad b.length unit)[i] = a.getD i unit

@[simp]
theorem vconcat_last (v : Fin n ‚Üí Œ±) (a : Œ±) : vconcat v a (Fin.last n) = a

theorem degreeOf_eval_C_finSuccEquiv (p : MvPolynomial (Fin (n + 1)) R) (j : Fin n) (x : R) :
    degreeOf j (Polynomial.eval (C x) (finSuccEquiv R n p)) ‚â§ degreeOf j.succ p

theorem range_vconcat {Œ± : Type*} (v : Fin n ‚Üí Œ±) (a : Œ±) :
    Set.range (vconcat v a) = insert a (Set.range v)

theorem and_highBits_lowBits_eq_zero {n : ‚Ñï} (numLowBits : ‚Ñï) :
    getHighBits numLowBits n &&& getLowBits numLowBits n = 0

@[simp]
lemma coe_toFun_of_coe_apply (f : ‚àÄ a, Œ≤ a) (a : Œ±) : (f : F) a = f a

lemma W_prod_comp_decomposition
    (i : Fin r) (hi : i > 0) :
    (W ùîΩq Œ≤ i) = ‚àè c: ùîΩq, (W ùîΩq Œ≤ (i-1)).comp (X - C (c ‚Ä¢ Œ≤ (i-1)))

theorem drop_addCases_right {n' : ‚Ñï} {motive : Fin (n + n') ‚Üí Sort*} (m : ‚Ñï) (h : m ‚â§ n')
    (u : (i : Fin n) ‚Üí motive (castAdd n' i)) (v : (i : Fin n') ‚Üí motive (natAdd n i)) :
      drop (n + m) (Nat.add_le_add_left h n) (addCases u v) =
        fun i => dcast (by simp [natAdd, Fin.cast]; omega) (drop m h v (i.cast (by omega)))

lemma eqRec_fun_eqRec_sort_eq_self {Œ± : Sort*} {Œ≤ : Œ± ‚Üí Sort u} {a a' : Œ±}
    (h : a = a') (h' : Œ≤ a = Œ≤ a') (b : Œ≤ a) :
  b = h ‚ñ∏ h' ‚ñ∏ b

omit [DecidableEq Œ±] [Inhabited Œ±] [Fintype Œ±] in
@[simp]
lemma Cache.upper_cons (n : ‚Ñï) (leaves : List.Vector Œ± (2 ^ (n + 1))) (cache : Cache Œ± n) :
    Cache.upper Œ± n (Cache.cons Œ± n leaves cache) = cache

omit [DecidableEq L] [Fintype ùîΩq] hŒ≤_lin_indep in
lemma W_ne_zero (i : Fin r) : (W ùîΩq Œ≤ i) ‚â† 0

@[simp]
lemma finite_possibleRelHammingDistsToCode [Nonempty Œπ] [DecidableEq F] :
  (possibleDistsToCode w C relHammingDist).Finite

theorem fixFirstVariablesOfMQP_degreeLE {deg : ‚Ñï} (v : Fin (‚Ñì + 1)) {challenges : Fin v ‚Üí L}
    {poly : L[X Fin ‚Ñì]} (hp : poly ‚àà L‚¶É‚â§ deg‚¶Ñ[X Fin ‚Ñì]) :
    fixFirstVariablesOfMQP ‚Ñì v poly challenges ‚àà L‚¶É‚â§ deg‚¶Ñ[X Fin (‚Ñì - v)]

lemma weight_Œæ_bound (x‚ÇÄ : F) {D : ‚Ñï} (hD : D ‚â• Bivariate.totalDegree H) :
  weight_Œõ_over_ùí™ (Œæ x‚ÇÄ R H) D ‚â§
    WithBot.some ((Bivariate.natDegreeY R - 1) * (D - Bivariate.natDegreeY H + 1))

@[simp]
theorem Basis_cast_index_eq (i j k n : ‚Ñï) (h_le : k ‚â§ n) (h_eq : i = j) :
    letI instAlgebra : Algebra (ConcreteBTField k) (ConcreteBTField n) :=
      ConcreteBTFieldAlgebra (l:=k) (r:=n) (h_le:=h_le)
    letI : Module (ConcreteBTField k) (ConcreteBTField n) := instAlgebra.toModule
    (Basis (Fin (i)) (ConcreteBTField k) (ConcreteBTField n)) =
    (Basis (Fin (j)) (ConcreteBTField k) (ConcreteBTField n))

omit [DecidableEq F] in
@[simp]
lemma isBerlekampWelchSolution_zero_zero [NeZero n] {v : Fin (2 * 0 + 0) ‚Üí F} :
  IsBerlekampWelchSolution 0 0 œâs f v ‚Üî f = 0

theorem join_add_join {k : ‚Ñï} (h_pos : k > 0) (hi‚ÇÄ lo‚ÇÄ hi‚ÇÅ lo‚ÇÅ : ConcreteBTField (k - 1)) :
  „Ää hi‚ÇÄ, lo‚ÇÄ „Äã + „Ää hi‚ÇÅ, lo‚ÇÅ „Äã = „Ää hi‚ÇÄ + hi‚ÇÅ, lo‚ÇÄ + lo‚ÇÅ „Äã

@[simp]
lemma Verifier.id_rbrSoundness {lang : Set Statement} :
    (Verifier.id : Verifier oSpec Statement _ _).rbrSoundness init impl lang lang 0

lemma mem_support_coeff_finSuccEquivNth {f : MvPolynomial (Fin (n + 1)) R} {i : ‚Ñï} {x} :
    x ‚àà ((finSuccEquivNth R p f).coeff i).support ‚Üî x.insertNth p i ‚àà f.support

lemma johnson_denominator_def :
  JohnsonDenominator B v = ((1 - ((Fintype.card F) / (Fintype.card F - 1)) * (e B v / n)) ^ 2
      - (1 - ((Fintype.card F) / (Fintype.card F - 1)) * (d B/n)))

lemma getBit_of_multiple_of_power_of_two {n p : ‚Ñï}: ‚àÄ k,
  getBit (k) (2^p * n) = if k < p then 0 else getBit (k-p) n

@[simp]
theorem vflatten_one {n : Fin 1 ‚Üí ‚Ñï} {v : (i : Fin 1) ‚Üí Fin (n i) ‚Üí Œ±} :
    vflatten v = v 0

@[simp] lemma toMvPolynomialAlgHom_X (s : œÉ) :
    toMvPolynomialAlgHom (X s : P) = (MvPolynomial.X s : MvPolynomial œÉ R)

@[simp]
lemma natDegree_polynomialOfCoeffs_deg_lt_deg
  [NeZero deg] {coeffs : Fin deg ‚Üí F} :
  (polynomialOfCoeffs coeffs).natDegree < deg

lemma degree_W (i : Fin r) : (W ùîΩq Œ≤ i).degree = (Fintype.card ùîΩq)^i.val

theorem is_prime : Nat.Prime fieldSize

@[simp]
lemma Rhs_zero_eq_neg' : Rhs 0 œâs f = -f

theorem dcast‚ÇÉ_dcast‚ÇÇ : dcast‚ÇÉ rfl rfl rfl d = dcast‚ÇÇ dcast_eq.symm dcast‚ÇÇ_dcast.symm d

lemma f_eq_evenPart_plus_x_oddPart {f : Polynomial F} :
  f = evenPart f + Polynomial.X * oddPart f

theorem coeff_eq_getElem_of_lt [LawfulBEq R] {p : UniPoly R} {i} (hi : i < p.size) :
  p.trim.coeff i = p[i]

@[simp] theorem equiv_symm {p q : UniPoly Q} : equiv p q ‚Üí equiv q p

theorem buildMerkleTree_neverFails (Œ± : Type) [DecidableEq Œ±] [SelectableType Œ±] {n : ‚Ñï}
    (leaves : List.Vector Œ± (2 ^ n)) (preexisting_cache : (spec Œ±).QueryCache) :
    ((simulateQ randomOracle (buildMerkleTree Œ± n leaves)).run preexisting_cache).neverFails

theorem BitVec.dcast_id {n : Nat} (bv : BitVec n) :
  DCast.dcast (Eq.refl n) bv = bv

theorem linear_map_of_comp_to_linear_map_of_eval (f : L[X])
  (h_f_linear : IsLinearMap (R := Fq) (M := L[X]) (M‚ÇÇ := L[X])
    (f := fun inner_p ‚Ü¶ f.comp inner_p)) :
    IsLinearMap (R := Fq) (M := L) (M‚ÇÇ := L) (f := fun x ‚Ü¶ f.eval x)

lemma sub_middle_of_pow2_with_one_canceled {k : ‚Ñï} (h_k : 1 ‚â§ k) : 2 ^ k - 1 - 2 ^ (k - 1) + 1
  = 2 ^ (k - 1)

theorem append_perfectCompleteness (R‚ÇÅ : Reduction oSpec Stmt‚ÇÅ Wit‚ÇÅ Stmt‚ÇÇ Wit‚ÇÇ pSpec‚ÇÅ)
    (R‚ÇÇ : Reduction oSpec Stmt‚ÇÇ Wit‚ÇÇ Stmt‚ÇÉ Wit‚ÇÉ pSpec‚ÇÇ)
    (h‚ÇÅ : R‚ÇÅ.perfectCompleteness init impl rel‚ÇÅ rel‚ÇÇ)
    (h‚ÇÇ : R‚ÇÇ.perfectCompleteness init impl rel‚ÇÇ rel‚ÇÉ) :
      (R‚ÇÅ.append R‚ÇÇ).perfectCompleteness init impl rel‚ÇÅ rel‚ÇÉ

theorem qMap_is_linear_map (i : Fin r) :
  IsLinearMap ùîΩq (f:=fun inner_p ‚Ü¶ (qMap ùîΩq Œ≤ i).comp inner_p)

@[simp]
theorem eq_accepts (i : Fin numWires) (c : ùì°) (x : Fin numWires ‚Üí ùì°) :
    (eq i c).accepts x ‚Üî x i = c

@[simp]
lemma seqCompose_zero
    (Stmt : Fin 1 ‚Üí Type) (Wit : Fin 1 ‚Üí Type) {n : Fin 0 ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (P : (i : Fin 0) ‚Üí
      Prover oSpec (Stmt i.castSucc) (Wit i.castSucc) (Stmt i.succ) (Wit i.succ) (pSpec i)) :
    seqCompose Stmt Wit P = Prover.id

theorem mul_distrib_add {a b : CNat 1} : a * (b + 1) = a * b + a

@[simp]
protected lemma elocPoly_ne_zero : ElocPoly n œâs f p ‚â† 0

lemma coeff_toPoly {p : UniPoly Q} {n : ‚Ñï} : p.toPoly.coeff n = p.coeff n

@[simp]
lemma OracleVerifier.append_toVerifier
    (V‚ÇÅ : OracleVerifier oSpec Stmt‚ÇÅ OStmt‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : OracleVerifier oSpec Stmt‚ÇÇ OStmt‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ pSpec‚ÇÇ) :
      (OracleVerifier.append V‚ÇÅ V‚ÇÇ).toVerifier =
        Verifier.append V‚ÇÅ.toVerifier V‚ÇÇ.toVerifier

@[simp]
theorem LeafData.map_internal {Œ± Œ≤} {s_left s_right : Skeleton}
    (f : Œ± ‚Üí Œ≤) (left : LeafData Œ± s_left) (right : LeafData Œ± s_right) :
    (LeafData.internal left right).map f =
      LeafData.internal (left.map f) (right.map f)

theorem oddRefinement_eq_novel_poly_of_1_leading_suffix (i : Fin ‚Ñì) (v : Fin (2 ^ i.val))
    (original_coeffs : Fin (2 ^ ‚Ñì) ‚Üí L) :
    have h_v: v.val ||

theorem singletonBound [CommRing F] [StrongRankCondition F]
  (LC : LinearCode Œπ F) :
  dim LC ‚â§ length LC - Code.minDist (LC : Set (Œπ ‚Üí F)) + 1

omit [NeZero ‚Ñì] [NeZero r] [NeZero ùì°] in
lemma fin_‚Ñì_add_one_lt_r {h_‚Ñì_add_R_rate : ‚Ñì + ùì° < r} (i : Fin (‚Ñì + 1))
    : i.val < r

lemma getLowBits_joinBits {n m : ‚Ñï} (low : Fin (2 ^ n)) (high : Fin (2 ^ m)) :
  getLowBits n (joinBits low high).val = low.val

@[simp]
theorem BTField.RingHom_eq_of_dest_AdjoinRoot_eq (k m : ‚Ñï) :
  (BTField k ‚Üí+* BTField (m+1)) = (BTField k ‚Üí+* (AdjoinRoot (poly m)))

@[simp]
theorem cast_idx {i : ChallengeIdx pSpec‚ÇÅ} :
    pSpec‚ÇÇ.Challenge (i.cast hn hSpec) = pSpec‚ÇÅ.Challenge i

theorem zero_lt_pow_n (m : ‚Ñï) (n : ‚Ñï) (h_m : m > 0): 0 < m^n

lemma add_zero {k : ‚Ñï} (a : ConcreteBTField k) : a + 0 = a

omit [DecidableEq ùîΩq] hF‚ÇÇ h_Œ≤‚ÇÄ_eq_1 in
lemma get_sDomain_first_basis_eq_1 (i : Fin r) (h_i : i < ‚Ñì + R_rate) :
    (sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate
    i (by omega)) ‚ü®0, by omega‚ü© = (1: L)

lemma schwartz_zippel' {p : MvPolynomial œÉ R} (hp : p ‚â† 0) (S : œÉ ‚Üí Finset R) :
    #{x ‚àà Finset.pi p.vars S | eval (extendDomain x) p = 0} / ‚àè i ‚àà p.vars, (#(S i) : ‚Ñö‚â•0)
      ‚â§ ‚àë i ‚àà p.vars, (p.degreeOf i / #(S i) : ‚Ñö‚â•0)

@[to_additive]
lemma prod_univ_twos {M : Type*} [CommMonoid M] {n : ‚Ñï} (hn : n = 2) (f : Fin n ‚Üí M) :
    (‚àè i, f i) = f (Fin.cast hn.symm 0) * f (Fin.cast hn.symm 1)

omit [CharP L 2] [DecidableEq ùîΩq] h_Œ≤‚ÇÄ_eq_1 [NeZero ùì°] in
lemma firstOracleWitnessConsistencyProp_relay_preserved (i : Fin ‚Ñì)
    (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) (wit : Witness (L := L) ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j) :
    firstOracleWitnessConsistencyProp ùîΩq Œ≤ wit.t (getFirstOracle ùîΩq Œ≤ oStmt) =
    firstOracleWitnessConsistencyProp ùîΩq Œ≤ wit.t
      (getFirstOracle ùîΩq Œ≤ (mapOStmtOutRelayStep ùîΩq Œ≤ i hNCR oStmt))

omit h_Fq_char_prime in
theorem changeOfBasisMatrix_diag_ne_zero
  (‚Ñì : Nat) (h_‚Ñì : ‚Ñì ‚â§ r) :
  (‚àÄ i, (changeOfBasisMatrix ùîΩq Œ≤ ‚Ñì h_‚Ñì) i i ‚â† 0)

lemma powContraction_is_right_inverse_to_linearMvExtension
  (p : Polynomial.degreeLT F (2^m)) :
    powContraction.comp linearMvExtension p = p

omit [Finite F] in
lemma dom_n_eq_triv : evalDomain D n = ‚ä•

theorem insertNth_support :
    (insertNth p y s).support ‚äÜ insert p (s.support.map (Fin.succAboveEmb p))

@[to_additive]
theorem prod_Iio_succ (i : Fin n) :
    ‚àè j ‚àà Iio i.succ, v j = (‚àè j ‚àà Iio i.castSucc, v j) * v i.castSucc

lemma oddPart_x_eval_eq {f : Polynomial F} {s : F} :
    (oddPart_x f).eval (s * s) = (oddPart f).eval s

theorem liftContext_soundness [Inhabited InnerStmtOut]
    {outerLangIn : Set OuterStmtIn} {outerLangOut : Set OuterStmtOut}
    {innerLangIn : Set InnerStmtIn} {innerLangOut : Set InnerStmtOut}
    {soundnessError : ‚Ñù‚â•0}
    {lens : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut}
    (V : Verifier oSpec InnerStmtIn InnerStmtOut pSpec)
    -- TODO: figure out the right compatibility relation for the IsSound condition
    [lensSound : lens.IsSound outerLangIn outerLangOut innerLangIn innerLangOut
      (V.compatStatement lens)]
    (h : V.soundness init impl innerLangIn innerLangOut soundnessError) :
      (V.liftContext lens).soundness init impl outerLangIn outerLangOut soundnessError

@[simp]
theorem dconcat_last {motive : Fin (n + 1) ‚Üí Sort u} (v : (i : Fin n) ‚Üí motive (castSucc i))
    (a : motive (last n)) : (v :+·µà‚ü®motive‚ü© a) (last n) = a

theorem foldr_split_inner {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤ ‚Üí Œ≤) (init : Œ≤)
    (l : List Œ±) (h : l ‚â† []): foldr (f:=f) (init:=init) (l)
    = foldr (f:=f) (init:=f (l.getLast (by omega)) (init)) (l.dropLast)

theorem eq_zero_of_degreeOf_lt_card_of_eval_eq_zero {p : R[X œÉ]} (S : œÉ ‚Üí Finset R)
    (hDegree : ‚àÄ i, p.degreeOf i < #(S i))
    (hEval : ‚àÄ x ‚àà piFinset fun i ‚Ü¶ S i, eval x p = 0) : p = 0

theorem vappend_succ (u : Fin m ‚Üí Œ±) (v : Fin (n + 1) ‚Üí Œ±) :
    vappend u v = vconcat (vappend u (v ‚àò castSucc)) (v (last n))

theorem singleEqPolynomial_zeroOne_C (r : Fin 2) (x : Fin 2) :
    (singleEqPolynomial (r : R) (C x) : MvPolynomial œÉ R) = if x = r then 1 else 0

theorem add_coeff {p q : UniPoly Q} {i : ‚Ñï} (hi : i < (add_raw p q).size) :
  (add_raw p q)[i] = p.coeff i + q.coeff i

private lemma johnson_condition_strong_implies_2_le_B_card
  (h_johnson : JohnsonConditionStrong B v)
  :
  2 ‚â§ B.card

lemma coeff_eq_zero {p : UniPoly Q} :
    (‚àÄ i, (hi : i < p.size) ‚Üí p[i] = 0) ‚Üî ‚àÄ i, p.coeff i = 0

theorem oracleReduction_perfectCompleteness (hInit : init.neverFails) :
    (oracleReduction R deg D oSpec).perfectCompleteness init impl
      (inputRelation R deg D) (outputRelation R deg)

private lemma solutionToE_from_E
  (h_p_deg : p.natDegree < k)
  (h_dist : (Œî‚ÇÄ(f, p.eval ‚àò œâs) : ‚Ñï) ‚â§ e)
  : solutionToE e k (E_and_Q_to_a_solution e (E œâs f p e) (Q œâs f p e)) = E œâs f p e

theorem join_eq_iff_dcast_extractLsb {k : ‚Ñï} (h_pos : k > 0) (x : ConcreteBTField k)
  (hi_btf lo_btf : ConcreteBTField (k - 1)) :
  x = „Ää hi_btf, lo_btf „Äã ‚Üî
  (hi_btf = dcast (h_sub_middle h_pos) (BitVec.extractLsb (hi := 2 ^ k - 1) (lo := 2 ^ (k - 1)) x) ‚àß
  lo_btf = dcast (h_middle_sub) (BitVec.extractLsb (hi := 2 ^ (k - 1) - 1) (lo := 0) x))

@[simp]
lemma support_polynomialOfCoeffs : (polynomialOfCoeffs coeffs).support =
  Finset.map ‚ü®Fin.val, Fin.val_injective‚ü© {i | coeffs i ‚â† 0}

@[simp]
lemma bIdx_mul_œë_add_i_lt_‚Ñì_succ {m : ‚Ñï} (bIdx : Fin (‚Ñì / œë - 1)) (i : Fin œë) :
    ‚ÜëbIdx * œë + ‚Üëi < ‚Ñì + m

@[simp]
theorem cast_idx_symm {i : MessageIdx pSpec‚ÇÇ} :
    pSpec‚ÇÅ.Message (i.cast hn.symm (cast_symm hSpec)) = pSpec‚ÇÇ.Message i

lemma add_eq_one_iff (a b : ConcreteBTField 0) :
  a + b = 1 ‚Üî (a = 0 ‚àß b = 1) ‚à® (a = 1 ‚àß b = 0)

@[simp]
lemma finite_relHammingDistRange [Nonempty Œπ] : (relHammingDistRange Œπ).Finite

Nat.succ_lt_succ_iff in Init.Data.Nat.Basic

lemma and_eq_zero_iff_and_each_getBit_eq_zero {n m : ‚Ñï} :
    n &&& m = 0 ‚Üî ‚àÄ k, Nat.getBit k n &&& Nat.getBit k m = 0

theorem dcast_symm (ha : a = a') (hb : dcast ha b = b') : dcast (ha.symm) b' = b

@[simp]
theorem hflatten_embedSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {Œ± : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí Sort*}
    (v : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí Œ± i j) (i : Fin m) (j : Fin (n i)) :
    hflatten v (embedSum i j) = cast (vflatten_embedSum Œ± i j).symm (v i j)

theorem GF_2_card : Fintype.card (GF(2)) = 2^(2^0)

@[simp]
theorem list_nonempty (k : ‚Ñï) : (list k).1 ‚â† []

omit [Finite F] in
lemma D_def : evalDomain D x 0 = x ‚Ä¢ D

@[simp]
theorem snoc_zero_zero : snoc (0 : Fin n ‚Üí‚ÇÄ M) 0 = 0

@[simp]
theorem drop_apply (m : ‚Ñï) (h : m ‚â§ n) (v : (i : Fin n) ‚Üí Œ± i) (i : Fin (n - m)) :
    (drop m h v) i = v (Fin.cast (Nat.sub_add_cancel h) (addNat i m))

lemma twoAdicity_maximal : ¬¨ (2 ^ (twoAdicity + 1)) ‚à£ (fieldSize - 1)

theorem fcons‚ÇÇ_right_injective {Œ±‚ÇÅ : A} {Œ±‚ÇÇ : B} {Œ≤‚ÇÅ : Fin n ‚Üí A} {Œ≤‚ÇÇ : Fin n ‚Üí B}
    (a : F‚ÇÇ Œ±‚ÇÅ Œ±‚ÇÇ) :
    Function.Injective
      (fcons‚ÇÇ (F := F‚ÇÇ) a : ((i : Fin n) ‚Üí F‚ÇÇ (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) ‚Üí (i : Fin (n + 1)) ‚Üí _ )

theorem take_drop_eq_drop_take (m‚ÇÅ m‚ÇÇ : ‚Ñï) (h‚ÇÅ : m‚ÇÅ ‚â§ m‚ÇÇ) (h‚ÇÇ : m‚ÇÇ ‚â§ n) (v : (i : Fin n) ‚Üí Œ± i) :
    take (m‚ÇÇ - m‚ÇÅ) (by omega) (drop m‚ÇÅ (by omega) v) =
      drop m‚ÇÅ (by omega) (take m‚ÇÇ h‚ÇÇ v)

List.le_sum_of_mem in Mathlib.Algebra.Order.BigOperators.Group.List

omit [Fintype F] in
private lemma d_eq_sum {B : Finset (Fin n ‚Üí F)}
  (h_B : 2 ‚â§ B.card)
  :
  2 * choose_2 B.card * d B =
  ‚àë i, ‚àë x ‚àà B √óÀ¢ B with x.1 ‚â† x.2, (if x.1 i ‚â† x.2 i then 1 else 0)

theorem foldRelayOracleReduction_perfectCompleteness
    (hInit : init.neverFails) (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
  OracleReduction.perfectCompleteness
    (pSpec := pSpecFoldRelay (L:=L))
    (relIn := roundRelation (mp := mp) ùîΩq Œ≤ (œë:=œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) i.castSucc)
    (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë:=œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) i.succ)
    (oracleReduction := foldRelayOracleReduction ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (ùìë:=ùìë) i hNCR) (init := init) (impl := impl)

lemma algebra_adjacent_tower_def (l : ‚Ñï) :
  (algebra_adjacent_tower l) = (canonicalEmbedding l).toAlgebra

private lemma johnson_unrefined [Zero F]
  (h_n : 0 < n)
  (h_B : 2 ‚â§ B.card)
  (h_card : 2 ‚â§ (Fintype.card F))
  :
  (1 - e B 0 / n) ^ 2 * B.card + B.card * (e B 0) ^ 2 / ((Fintype.card F - 1) * n^2) - 1
  ‚â§
  (B.card - 1) * (1 - d B/n)

@[simp]
theorem PowerBasis.cast_basis_succ_of_eq_rec_apply
    (r1 r : ‚Ñï) (h_r : r = r1 + 1)
    (k : Fin 2) :
    letI instAlgebra : Algebra (BTField r1) (BTField r) :=
      binaryAlgebraTower (l:=r1) (r:=r) (h_le:=by omega)
    letI instAlgebraSucc : Algebra (BTField (r1 + 1)) (BTField (r)) :=
      binaryAlgebraTower (l:=r1 + 1) (r:=r) (h_le:=by omega)
    let b : PowerBasis (BTField r1) (BTField (r1 + 1)) := powerBasisSucc (k:=r1)
    let bCast : PowerBasis (BTField r1) (BTField r) := Eq.rec (motive:=
      fun (x : ‚Ñï) (_ : r1 + 1 = x) => by
        letI instAlgebraCur : Algebra (BTField r1) (BTField x) :=
          binaryAlgebraTower (l:=r1) (r:=x) (h_le:=by omega)
        exact PowerBasis (BTField r1) (BTField x)) (refl:=b) (t:=h_r.symm)
    have h_pb_dim : b.dim = 2 := by
      exact powerBasisSucc_dim r1

    have h_pb'_dim : bCast.dim = 2 := by
      dsimp [bCast]
      rw [BTField.PowerBasis.dim_of_eq_rec (r1:=r1) (r:=r) (h_r:=h_r) (b:=b)]
      exact h_pb_dim

    have h_pb_type_eq : Basis (Fin bCast.dim) (BTField r1) (BTField r) =
      Basis (Fin 2) (BTField r1) (BTField r) := by
      congr

   -- The `cast` needs a proof that `bCast.dim = 2`. We construct it here.
    let left : Basis (Fin 2) (BTField r1) (BTField r) := cast (by exact h_pb_type_eq) bCast.basis
    let right := (algebraMap (BTField (r1 + 1)) (BTField r))
      (b.basis (Fin.cast h_pb_dim.symm k))
    left k = right

theorem mul_two_add_bit_lt_two_pow (a b c : ‚Ñï) (i : Fin 2)
    (h_a : a < 2 ^ b) (h_b : b < c) :
    a * 2 + i.val < 2^c

Polynomial.degree_sum_le in Mathlib.Algebra.Polynomial.Degree.Definitions

lemma eval_solutionToQ_cast {x : F} (h : e = 0) :
  eval x (solutionToQ e k v) = ‚àë i ‚àà Finset.range k, liftF v i * x ^ i

private lemma sum_hamming_weight_sum [Zero F]
  :
  ‚àë x ‚àà B, (‚Äñx‚Äñ‚ÇÄ : ‚Ñö) = n * B.card - ‚àë i, K B i 0

lemma Z_square_eq (k : ‚Ñï) (prevBTFieldProps : ConcreteBTFieldProps (k := k))
    (curBTFieldProps : ConcreteBTFieldProps (k := (k + 1))) :
  letI : Field (ConcreteBTField (k + 1)) := mkFieldInstance curBTFieldProps
  (Z (k + 1)) ^ 2 = „Ää Z (k), 1 „Äã

@[simp]
lemma foldr'_zero {Œ± : Type u} (f : (i : Fin 0) ‚Üí Œ± ‚Üí Œ±) (x : Œ±) :
    foldr' 0 f x = x

@[simp]
lemma oddPart_by_2 :
    2 * (oddPart f) = (f - f.comp (-X)) /‚Çò X

theorem BitVec.dcast_bitvec_eq {l r val : ‚Ñï} (h_width_eq : l = r) :
    dcast h_width_eq (BitVec.ofNat l val) = BitVec.ofNat r val

@[simp]
theorem rightpad_apply_ge (n : ‚Ñï) (a : Œ±) (v : Fin m ‚Üí Œ±) (i : Fin n)
    (h : m ‚â§ i.val) : rightpad n a v i = a

lemma comp_sub_C_of_linear_eval (p : L[X])
  (h_lin : IsLinearMap ùîΩq (f := fun inner_p ‚Ü¶ p.comp inner_p)) (a : L) :
    p.comp (X - C a) = p - C (eval a p)

lemma getLowBits_eq_mod_two_pow {numLowBits : ‚Ñï} (n : ‚Ñï) :
  getLowBits numLowBits n = n % (2 ^ numLowBits)

private lemma evenPart_eq_evenPart' {f : Polynomial F} : evenPart f = evenPart' f

@[simp] lemma ofMvPolynomialAlgHom_X (s : œÉ) :
    ofMvPolynomialAlgHom (MvPolynomial.X s : MvPolynomial œÉ R) = (X s : P)

theorem mca_johnson_bound_CONJECTURE
  [DecidableEq Œπ]
  (Œ± : F) (œÜ : Œπ ‚Ü™ F) (m : ‚Ñï) [Smooth œÜ]
  (par‚Ñì_type : Type) [Fintype par‚Ñì_type] (exp : par‚Ñì_type ‚Ü™ ‚Ñï) :
  let Gen := RSGenerator.genRSC par‚Ñì_type œÜ m exp
  let : Fintype Gen.par‚Ñì := Gen.h‚Ñì
  hasMutualCorrAgreement Gen
    -- Conjectured BStar = ‚àöœÅ
    (Real.sqrt Gen.rate)
    -- Conjectured errStar
    (fun Œ¥ =>
      let min_val := min (1 - Real.sqrt Gen.rate - (Œ¥ : ‚Ñù)) (Real.sqrt Gen.rate / 20)
      ENNReal.ofReal (
        ((Fintype.card par‚Ñì_type - 1) * 2^(2*m)) /
        ((Fintype.card F) * (2 * min_val)^7)
      )
    )

theorem W_linearity (i : Fin r)
    : IsLinearMap ùîΩq (f := fun inner_p ‚Ü¶ (W ùîΩq Œ≤ i).comp inner_p)

@[simp]
theorem vappend_right (u : Fin m ‚Üí Œ±) (v : Fin n ‚Üí Œ±) (i : Fin n) :
    vappend u v (natAdd m i) = v i

@[simp]
theorem finSigmaFinEquiv'_apply {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (k : (i : Fin m) √ó Fin (n i)) :
    (finSigmaFinEquiv' k : ‚Ñï) = ‚àë i : Fin k.1, n (Fin.castLE k.1.isLt.le i) + k.2

theorem frobenius_identity_in_ground_field
  [Fact (Nat.Prime (ringChar Fq))] (f g : Fq[X]) :
    (f + g)^(Fintype.card Fq) = f^(Fintype.card Fq) + g^(Fintype.card Fq)

@[simp] theorem ofNat_toNat (t : AssocNat) : ofNat (toNat t) = t

@[simp]
theorem OracleReduction.id_run (stmt : StmtIn) (oStmt : ‚àÄ i, OStmtIn i) (wit : WitIn) :
    (OracleReduction.id : OracleReduction oSpec StmtIn OStmtIn WitIn _ _ _ _).run stmt oStmt wit =
      pure ‚ü®‚ü®default, ‚ü®stmt, oStmt‚ü©, wit‚ü©, ‚ü®stmt, oStmt‚ü©‚ü©

@[simp]
lemma getTypes_cons (x : Œ£ Œ± : Type u, Œ±) (xs : HList) :
    getTypes (x :: xs) = x.1 :: xs.getTypes

protected theorem heq_fun_iff' {k l : ‚Ñï} {Œ± : Fin k ‚Üí Sort u} {Œ≤ : Fin l ‚Üí Sort u} (h : k = l)
    (h' : ‚àÄ i : Fin k, (Œ± i) = (Œ≤ (Fin.cast h i))) {f : (i : Fin k) ‚Üí Œ± i} {g : (j : Fin l) ‚Üí Œ≤ j} :
    HEq f g ‚Üî ‚àÄ i : Fin k, HEq (f i) (g (Fin.cast h i))

@[simp]
lemma erase_even_empty :
    erase_even ‚àÖ = ‚àÖ

@[simp]
theorem init_update_last : init (update s (Fin.last n) y) = init s

theorem coeff_of_toMvPolynomial_eq_coeff_of_MlPoly (p : MlPoly R n) (m : Fin n ‚Üí‚ÇÄ ‚Ñï) :
  coeff m (toMvPolynomial p) =
    if h_binary: (‚àÄ j: Fin n, m j ‚â§ 1) then
      let i_of_m: ‚Ñï := Nat.binaryFinMapToNat (m:=m) (h_binary:=h_binary)
      p[i_of_m]
    else
      0

@[grind =] theorem findIdx'_cons {p : Œ± ‚Üí Bool} {x : Œ±} {xs : List Œ±} :
    findIdx' p (x :: xs) = bif p x then 0 else findIdx' p xs + 1

@[simp]
private lemma F2i_disjoint :
  Set.PairwiseDisjoint Set.univ (F2i B i)

lemma Œ≤·µ¢_not_in_U·µ¢ (i : Fin r) :
    Œ≤ i ‚àâ U ùîΩq Œ≤ i

@[simp]
theorem removeNth_apply : removeNth p s i = s (p.succAbove i)

@[simp]
theorem Reduction.runWithLog_discard_logs_eq_run
    {stmt : StmtIn} {wit : WitIn}
    {reduction : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec} :
      Prod.fst <$>
        reduction.runWithLog stmt wit = reduction.run stmt wit

Nat.add_zero in Init.Core

lemma getBit_of_add_distrib {n m k : ‚Ñï}
  (h_n_AND_m : n &&& m = 0) : getBit k (n + m) = getBit k n + getBit k m

theorem LeafData.composeBuild_getRootValue {Œ±} {s_left s_right : Skeleton}
    (left : LeafData Œ± s_left) (right : LeafData Œ± s_right)
    (compose : Œ± ‚Üí Œ± ‚Üí Œ±) :
    ((LeafData.internal left right).composeBuild compose).getRootValue =
      compose (left.composeBuild compose).getRootValue (right.composeBuild compose).getRootValue

theorem monomialBasis_getElem {w : Vector R n} (i : Fin (2 ^ n)) :
    (monomialBasis w)[i] = ‚àè j : Fin n, if (BitVec.ofFin i).getLsb j then w[j] else 1

lemma Oracle.containsCache_of_cache {Œπ : Type} {spec : OracleSpec Œπ}
    [(i : Œπ) ‚Üí Inhabited (OracleSpec.range spec i)]
    (cache : spec.QueryCache) :
    ‚àÉ (f : spec.FunctionType), Oracle.containsCache f cache

theorem mul_one {a : CNat 50} : a * 1 = a

theorem dconcat_dcons_eq_dcons_dconcat {motive : Fin (n + 2) ‚Üí Sort u} (a : motive 0)
    (v : (i : Fin n) ‚Üí motive (succ (castSucc i))) (b : motive (last (n + 1))) :
    (a ::·µà v) :+·µà‚ü®motive‚ü© b = a ::·µà‚ü®motive‚ü© (v :+·µà b)

lemma schwartz_zippel_of_fintype {p : MvPolynomial œÉ R} (hp : p ‚â† 0) (S : œÉ ‚Üí Finset R) :
    #{x ‚àà S ^^ œÉ | eval x p = 0} / ‚àè i, (#(S i) : ‚Ñö‚â•0) ‚â§ ‚àë i, (p.degreeOf i / #(S i) : ‚Ñö‚â•0)

@[simp]
theorem dflatten_succ {m : ‚Ñï} {n : Fin (m + 1) ‚Üí ‚Ñï} {motive : (k : Fin (vsum n)) ‚Üí Sort*}
    {v : (i : Fin (m + 1)) ‚Üí (j : Fin (n i)) ‚Üí motive (embedSum i j)} :
    dflatten (motive := motive) v = dappend (v 0) (dflatten (fun i => v i.succ))

@[simp]
lemma elocPolyF_deg {œâs f : Fin n ‚Üí F} : (ElocPolyF œâs f p).natDegree = Œî‚ÇÄ(f, p.eval ‚àò œâs)

@[simp]
lemma seqCompose_succ {m : ‚Ñï}
    (Stmt : Fin (m + 2) ‚Üí Type) (Wit : Fin (m + 2) ‚Üí Type)
    {n : Fin (m + 1) ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (P : (i : Fin (m + 1)) ‚Üí
      Prover oSpec (Stmt i.castSucc) (Wit i.castSucc) (Stmt i.succ) (Wit i.succ) (pSpec i)) :
    seqCompose Stmt Wit P =
      append (P 0) (seqCompose (Stmt ‚àò Fin.succ) (Wit ‚àò Fin.succ) (fun i => P (Fin.succ i)))

@[to_additive vsum_castSucc]
lemma vprod_castSucc [CommMonoid Œ±] {a : Fin (n + 1) ‚Üí Œ±} :
    vprod a = vprod (a ‚àò Fin.castSucc) * a (last n)

Nat.lt_of_add_right_lt in Init.Data.Nat.Basic

theorem induction_append_left {m n : ‚Ñï} {motive : Fin (m + n + 1) ‚Üí Sort*} {zero : motive 0}
    {succ : ‚àÄ i : Fin (m + n), motive i.castSucc ‚Üí motive i.succ} {i : Fin (m + 1)} :
      induction (motive := motive) zero succ ‚ü®i, by omega‚ü© =
        @induction m (fun j => motive ‚ü®j, by omega‚ü©) zero (fun j x => succ ‚ü®j, by omega‚ü© x) i

lemma degree_normalizedW (i : Fin r) :
  (normalizedW ùîΩq Œ≤ i).degree = (Fintype.card ùîΩq)^(i.val)

@[simp]
lemma invFun_toFun (f : F) : inst.equiv.invFun (inst.equiv.toFun f) = f

lemma toOutCodewordsCount_last ‚Ñì œë : toOutCodewordsCount ‚Ñì œë (Fin.last ‚Ñì) = ‚Ñì / œë

theorem fconcat‚ÇÇ_inj {Œ±‚ÇÅ : Fin n ‚Üí A} {Œ±‚ÇÇ : Fin n ‚Üí B} {Œ≤‚ÇÅ : A} {Œ≤‚ÇÇ : B}
    (v‚ÇÅ v‚ÇÇ : (i : Fin n) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i)) (a‚ÇÅ a‚ÇÇ : F‚ÇÇ Œ≤‚ÇÅ Œ≤‚ÇÇ) :
    fconcat‚ÇÇ (F := F‚ÇÇ) v‚ÇÅ a‚ÇÅ = fconcat‚ÇÇ (F := F‚ÇÇ) v‚ÇÇ a‚ÇÇ ‚Üî v‚ÇÅ = v‚ÇÇ ‚àß a‚ÇÅ = a‚ÇÇ

theorem fcons‚ÇÇ_injective2 {Œ±‚ÇÅ : A} {Œ±‚ÇÇ : B} {Œ≤‚ÇÅ : Fin n ‚Üí A} {Œ≤‚ÇÇ : Fin n ‚Üí B} :
    Function.Injective2 (@fcons‚ÇÇ A B F‚ÇÇ n Œ±‚ÇÅ Œ≤‚ÇÅ Œ±‚ÇÇ Œ≤‚ÇÇ)

theorem srSoundness_implies_soundness
    (langIn : Set StmtIn) (langOut : Set StmtOut)
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    (srInit : ProbComp (srChallengeOracle StmtIn pSpec).FunctionType)
    (srImpl : QueryImpl oSpec (StateT (srChallengeOracle StmtIn pSpec).FunctionType ProbComp))
    (srSoundnessError : ‚Ñù‚â•0) :
      Verifier.StateRestoration.soundness srInit srImpl langIn langOut verifier srSoundnessError ‚Üí
        soundness init impl langIn langOut verifier srSoundnessError

theorem prod_X_sub_C_eq_X_pow_card_sub_X_in_L :
  (‚àè c ‚àà (Finset.univ : Finset Fq), (Polynomial.X - Polynomial.C (algebraMap Fq L c))) =
    Polynomial.X^(Fintype.card Fq) - Polynomial.X

@[simp]
theorem oracleReduction_perfectCompleteness (hInit : init.neverFails) :
    (oracleReduction oSpec Statement OStatement Witness).perfectCompleteness init impl rel rel

theorem join_eq_bitvec_iff_fromNat {k : ‚Ñï} (h_pos : k > 0) (x : ConcreteBTField k)
  (hi_btf lo_btf : ConcreteBTField (k - 1)) :
  x = „Ää hi_btf, lo_btf „Äã ‚Üî
  (hi_btf = fromNat (k:=k - 1) (x.toNat >>> 2 ^ (k - 1)) ‚àß
  lo_btf = fromNat (k:=k - 1) (x.toNat &&& (2 ^ (2 ^ (k - 1)) - 1)))

theorem FullData.toLeafData_rightSubtree {Œ±} {s_left s_right : Skeleton}
    (tree : FullData Œ± (Skeleton.internal s_left s_right)) :
    tree.toLeafData.rightSubtree =
      tree.rightSubtree.toLeafData

lemma dist_eq_minWtCodewords [CommRing F] {LC : LinearCode Œπ F} :
  Code.minDist (LC : Set (Œπ ‚Üí F)) = minWtCodewords LC

theorem vconcat_right_injective (v : Fin n ‚Üí Œ±) : Function.Injective (vconcat v)

lemma testBit_true_eq_getBit_eq_1 (k n : Nat) : n.testBit k = ((Nat.getBit k n) = 1)

theorem eqPolynomial_zeroOne (r : œÉ ‚Üí Fin 2) : (eqPolynomial r : MvPolynomial œÉ R) =
    ‚àè i : œÉ, if r i = 0 then 1 - X i else X i

lemma split_join_via_add_smul_eq_iff_split (k : ‚Ñï) (h_pos : k > 0)
    (hi_btf lo_btf : BTField (k - 1)) :
    split (k:=k) (h_k:=h_pos) (‚ãò hi_btf, lo_btf ‚ãô) = (hi_btf, lo_btf)

theorem dinit_hconcat {Œ± : Fin n ‚Üí Sort u} {Œ≤ : Sort u} (v : (i : Fin n) ‚Üí Œ± i) (b : Œ≤) :
    True

@[simp]
theorem fcons_succ {Œ≤ : Fin n ‚Üí A} (a : F Œ±) (v : (i : Fin n) ‚Üí F (Œ≤ i)) (i : Fin n) :
    fcons a v i.succ = cast (by simp [vcons_succ]) (v i)

lemma getBit_of_highBits_no_shl {n: ‚Ñï} (numLowBits : ‚Ñï) :
    ‚àÄ k, getBit k (getHighBits_no_shl numLowBits n)
  = getBit (k + numLowBits) (n)

@[simp]
theorem FullData.toLeafData_leaf {Œ±} (a : Œ±) :
    (FullData.leaf a).toLeafData = LeafData.leaf a

@[simp]
lemma coeffsOfPolynomial_polynomialOfCoeffs :
  coeffsOfPolynomial (polynomialOfCoeffs coeffs) = coeffs

omit [DecidableEq L] h_Fq_char_prime hF‚ÇÇ hŒ≤_lin_indep in
lemma Prod_W_comp_X_sub_C_ne_zero (i : Fin r) :
    (univ : Finset ùîΩq).prod (fun c => (W ùîΩq Œ≤ i).comp (X - C (c ‚Ä¢ Œ≤ i))) ‚â† 0

theorem hammingDist_le_of_decoder_eq_some [NeZero n] {œâs f : Fin n ‚Üí F}
  (h : decoder e k œâs f = some p) : Œî‚ÇÄ(f, p.eval ‚àò œâs) ‚â§ e

@[simp]
theorem verifier_first (pSpec : ProtocolSpec n) [NeZero n] [h : VerifierFirst pSpec] :
    pSpec.dir 0 = .V_to_P

theorem concrete_eq_zero_or_eq_one {k : ‚Ñï} {a : ConcreteBTField k} (h_k_zero : k = 0)
 : a = zero ‚à® a = one

theorem is_unit_iff_deg_0 {R : Type*} [Field R] {p : R[X]} : p.degree = 0 ‚Üî IsUnit p

@[simp]
theorem dflatten_zero {n : Fin 0 ‚Üí ‚Ñï} {motive : (k : Fin (vsum n)) ‚Üí Sort*}
    {v : (i : Fin 0) ‚Üí (j : Fin (n i)) ‚Üí motive (embedSum i j)} :
    dflatten (motive := motive) v = fun k => Fin.elim0 k

theorem Reduction.run_of_prover_first [ProverOnly pSpec] (stmt : StmtIn) (wit : WitIn)
    (reduction : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      reduction.run stmt wit = (do
        let state := reduction.prover.input (stmt, wit)
        let ‚ü®msg, state‚ü© ‚Üê liftComp (reduction.prover.sendMessage ‚ü®0, by simp‚ü© state) _
        let ctxOut ‚Üê reduction.prover.output state
        let transcript : pSpec.FullTranscript := fun i => match i with | ‚ü®0, _‚ü© => msg
        let stmtOut ‚Üê reduction.verifier.verify stmt transcript
        return (‚ü®transcript, ctxOut‚ü©, stmtOut))

theorem mulVecLin_coeff_vandermondens_eq_eval_matrixOfPolynomials
  {n : ‚Ñï} [NeZero n] {v : Œπ ‚Ü™ F} {p : F[X]} (h_deg : p.natDegree < n) :
  (Vandermonde.nonsquare (Œπ' := n) v).mulVecLin (Fin.liftF' p.coeff) =
  fun i => p.eval (v i)

theorem liftContext_runWithLog
    {lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    {outerStmtIn : OuterStmtIn} {outerWitIn : OuterWitIn}
    {P : Prover oSpec InnerStmtIn InnerWitIn InnerStmtOut InnerWitOut pSpec} :
      (P.liftContext lens).runWithLog outerStmtIn outerWitIn
      = do
        let ‚ü®‚ü®fullTranscript, innerCtxOut‚ü©, queryLog‚ü© ‚Üê
          P.runWithLog.uncurry (lens.proj (outerStmtIn, outerWitIn))
        return ‚ü®‚ü®fullTranscript, lens.lift (outerStmtIn, outerWitIn) innerCtxOut‚ü©, queryLog‚ü©

lemma concrete_mul_one0 (a : ConcreteBTField 0) :
  concrete_mul a (one (k:=0)) = a

Nat.pow_lt_pow_right in Init.Data.Nat.Lemmas

@[simp]
lemma OracleVerifier.id_toVerifier :
    (OracleVerifier.id : OracleVerifier oSpec Statement OStatement _ _ _).toVerifier =
      Verifier.id

@[simp]
theorem ConcreteBTFieldAlgebra_id {l r : ‚Ñï} (h_eq : l = r) :
    @ConcreteBTFieldAlgebra l r (h_le:=by omega) =
    (h_eq ‚ñ∏ (Algebra.id (ConcreteBTField l)) :
      Algebra (ConcreteBTField l) (ConcreteBTField r))

theorem distFromCode_eq_top_iff_empty (u : n ‚Üí R) (C : Set (n ‚Üí R)) : Œî‚ÇÄ(u, C) = ‚ä§ ‚Üî C = ‚àÖ

theorem insertNth_zero_eq_cases {n : ‚Ñï} {Œ± : Fin (n + 1) ‚Üí Sort u} :
    insertNth 0 = cases (motive := Œ±)

theorem mul_add {a b c : AssocNat} : a * (b + c) = a * b + a * c

lemma join_split_eq_join {k : ‚Ñï} (h_pos : k > 0) (x : ConcreteBTField k) :
  „Ää (split h_pos x).fst, (split h_pos x).snd „Äã = x

theorem join_of_split {k : ‚Ñï} (h_pos : k > 0) (x : ConcreteBTField k)
    (hi_btf lo_btf : ConcreteBTField (k - 1))
    (h_split_eq : split h_pos x = (hi_btf, lo_btf)) :
    x = „Ää hi_btf, lo_btf „Äã

lemma concrete_mul_inv_cancel
  (prevBTFieldResult : ConcreteBTFStepResult (k := k - 1))
  (a : ConcreteBTField k) (h : a ‚â† 0) :
  concrete_mul a (concrete_inv a) = one

@[simp]
theorem vcons_one (a : Œ±) (v : Fin (n + 1) ‚Üí Œ±) : (a ::·µõ v) 1 = v 0

@[simp]
lemma aeval_X {A : Type w} [CommSemiring A] [Algebra R A] (s : A) : aeval s X (P := P) = s

omit [Finite F] in
lemma sqr_mem_D_succ_i_of_mem_D_i : ‚àÄ {x : FÀ£} {i : ‚Ñï},
  x ‚àà evalDomain D i ‚Üí x ^ 2 ‚àà evalDomain D (i + 1)

private theorem toNat_mulNat (a : AssocNat) (k : Nat) : toNat (mulNat a k) = toNat a * k

@[grind =]
theorem monomialXY_eq_monomialXY_iff {n m p q : ‚Ñï} {a b : F} :
  monomialXY n m a = monomialXY p q b ‚Üî n = p ‚àß m = q ‚àß a = b ‚à® a = 0 ‚àß b = 0

theorem prod_poly_sub_C_eq_poly_pow_card_sub_poly_in_L
  (p : L[X]) :
  (‚àè c ‚àà (Finset.univ : Finset Fq), (p - Polynomial.C (algebraMap Fq L c))) =
    p^(Fintype.card Fq) - p

@[simp]
theorem distanceLE_polynomial_degreeLT : distanceLE (R‚¶É< d‚¶Ñ[X]) (d - 1)

lemma getBit_of_or {n m k: ‚Ñï} : getBit k (n ||| m) = getBit k n ||

@[simp]
theorem seqCompose_succ_dir {m : ‚Ñï} {n : Fin (m + 1) ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)} :
    (seqCompose pSpec).dir = Fin.vflatten (fun i => (pSpec i).dir)

omit O‚Çò in
theorem seqCompose_completeness (hInit : init.neverFails)
    (rel : (i : Fin (m + 1)) ‚Üí Set (Stmt i √ó Wit i))
    (R : ‚àÄ i, Reduction oSpec (Stmt i.castSucc) (Wit i.castSucc) (Stmt i.succ) (Wit i.succ)
      (pSpec i))
    (completenessError : Fin m ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (R i).completeness init impl (rel i.castSucc) (rel i.succ) (completenessError i)) :
      (Reduction.seqCompose Stmt Wit R).completeness init impl (rel 0) (rel (Fin.last m))
        (‚àë i, completenessError i)

theorem liftContext_rbr_knowledgeSoundness [Inhabited InnerStmtOut] [Inhabited InnerWitIn]
    {outerRelIn : Set (OuterStmtIn √ó OuterWitIn)} {outerRelOut : Set (OuterStmtOut √ó OuterWitOut)}
    {innerRelIn : Set (InnerStmtIn √ó InnerWitIn)} {innerRelOut : Set (InnerStmtOut √ó InnerWitOut)}
    {rbrKnowledgeError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    {stmtLens : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut}
    {witLens : Witness.InvLens OuterStmtIn OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    (V : Verifier oSpec InnerStmtIn InnerStmtOut pSpec)
    [lensKS : Extractor.Lens.IsKnowledgeSound outerRelIn innerRelIn outerRelOut innerRelOut
      (V.compatStatement stmtLens) (fun _ _ => True) ‚ü®stmtLens, witLens‚ü©]
    (h : V.rbrKnowledgeSoundness init impl innerRelIn innerRelOut rbrKnowledgeError) :
      (V.liftContext stmtLens).rbrKnowledgeSoundness init impl outerRelIn outerRelOut
        rbrKnowledgeError

lemma getBit_of_two_pow_sub_one {i k: ‚Ñï} : getBit k (2^i - 1) =
    if k < i then 1 else 0

theorem FullData.toLeafData_eq_leaf {Œ±} (a : Œ±) (tree)
    (h : LeafData.leaf a = tree.toLeafData) :
    tree = FullData.leaf a

@[simp]
theorem singleEqPolynomial_zero (x : MvPolynomial œÉ R) : singleEqPolynomial (0 : R) x = 1 - x

@[simp]
lemma solutionToE_zero_eq_C {v : Fin (2 * 0 + k) ‚Üí F} :
  solutionToE 0 k v = C (1 : F)

@[simp]
theorem vcons_fin_zero (a : Œ±) (v : Fin 0 ‚Üí Œ±) : a ::·µõ v = fun i => match i with

private lemma aux_sum [Zero F]
  (h_n : 0 < n)
  : n * choose_2 (aux_frac B (k B)) ‚â§ ‚àë i, choose_2 (aux_frac B (K B i 0))

omit [Finite F] in
lemma domain_surjective (i : ‚Ñï) : i ‚â§ n ‚Üí Function.Surjective (domain D n i)

@[simp]
theorem FullData.leftSubtree_internal {Œ±} {s_left s_right : Skeleton}
    (value : Œ±) (left : FullData Œ± s_left) (right : FullData Œ± s_right) :
    (FullData.internal value left right).leftSubtree = left

theorem SkeletonNodeIndex.parent_of_depth_zero {s : Skeleton}
    (idx : SkeletonNodeIndex s) (h : idx.depth = 0) :
    parent idx = none

theorem commitOracleReduction_perfectCompleteness (hInit : init.neverFails) (i : Fin ‚Ñì)
    (hCR : isCommitmentRound ‚Ñì œë i) :
    OracleReduction.perfectCompleteness
      (pSpec := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)
      (relIn := foldStepRelOut (mp := mp) ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        (ùìë := ùìë) i)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        (ùìë := ùìë) i.succ)
      (oracleReduction := commitOracleReduction ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hCR)
      (init := init)
      (impl := impl)

theorem trim_twice [LawfulBEq R] (p : UniPoly R) : p.trim.trim = p.trim

theorem peval_eq_eval_sumToIter_rename (f : œÉ ‚Üí œÉ‚ÇÅ ‚äï œÉ‚ÇÇ) (x : œÉ‚ÇÅ ‚Üí R) (p : MvPolynomial œÉ R) :
    peval f x p = eval (C ‚àò x) (sumToIter R œÉ‚ÇÅ œÉ‚ÇÇ (rename f p))

theorem stir_rbr_soundness
    [SelectableType F] {s : ‚Ñï}
    {P : Params Œπ F} {œÜ : (i : Fin (M + 1)) ‚Üí (Œπ i ‚Ü™ F)}
    [h_nonempty : ‚àÄ i : Fin (M + 1), Nonempty (Œπ i)]
    {hParams : ParamConditions Œπ P} {Dist : Distances M}
    {Codes : CodeParams Œπ P Dist}
    (h_not_code : ‚àÄ f‚ÇÄ : (Œπ 0) ‚Üí F, f‚ÇÄ ‚àâ (Codes.C 0))
    (hŒ¥‚ÇÄLe : ‚àÄ f‚ÇÄ : (Œπ 0) ‚Üí F, Dist.Œ¥ 0 ‚â§ (Œ¥·µ£(f‚ÇÄ, (Codes.C 0)) : ‚Ñù) ‚àß
      Dist.Œ¥ 0 < (1 - Bstar (rate (code (P.œÜ 0) P.deg))))
    (hŒ¥·µ¢ : ‚àÄ {j : Fin (M + 1)}, j ‚â† 0 ‚Üí
        Dist.Œ¥ j < (1 - rate (code (P.œÜ j) (degree Œπ P j))
          - 1 / Fintype.card (Œπ j) : ‚Ñù) ‚àß
        Dist.Œ¥ j < (1 - Bstar (rate (code (P.œÜ j) (degree Œπ P j)))))
    (Œµ_fold : ‚Ñù‚â•0) (Œµ_out : Fin M ‚Üí ‚Ñù‚â•0) (Œµ_shift : Fin M ‚Üí ‚Ñù‚â•0) (Œµ_fin : ‚Ñù‚â•0) :
    ‚àÉ n : ‚Ñï,
    -- There exists an `n`-message vector IOPP,
    ‚àÉ vPSpec : ProtocolSpec.VectorSpec n,
    -- such that there are `2 * M + 2` challenges from the verifier to the prover,
    Fintype.card (vPSpec.ChallengeIdx) = 2 * M + 2 ‚àß
    -- ‚àÉ vector IOPP œÄ with the aforementioned `vPSpec`, and for
    -- `Statement = Unit, Witness = Unit, OracleStatement(Œπ‚ÇÄ, F)` such that
    ‚àÉ œÄ : VectorIOP Unit (OracleStatement (Œπ 0) F) Unit vPSpec F,
    let Œµ_rbr : vPSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0

theorem canonical_nonempty_iff [LawfulBEq R] {p : UniPoly R} (hp : p.size > 0) :
  p.trim = p ‚Üî p.last_nonzero = some ‚ü® p.size - 1, Nat.pred_lt_self hp ‚ü©

@[simp]
theorem take_append_left (T : FullTranscript pSpec‚ÇÅ) (T' : FullTranscript pSpec‚ÇÇ) :
    (T ++‚Çú T').take m (Nat.le_add_right m n) =
      T.cast rfl (by simp [ProtocolSpec.append])

@[simp] theorem rightpad_prefix (n : Nat) (unit : Œ±) (l : List Œ±) :
    l <+: rightpad n unit l

theorem fcons_injective2 {Œ≤ : Fin n ‚Üí A} :
    Function.Injective2 (@fcons A F n Œ± Œ≤)

theorem toNatInRange {k : ‚Ñï} (b : ConcreteBTField k) :
  BitVec.toNat b ‚â§ 2 ^ (2 ^ k) * 1

theorem nsmul_succ (n : ‚Ñï) (p : UniPolyC R) : nsmul (n + 1) p = nsmul n p + p

@[simp]
theorem fflatten_succ {A : Sort u} {F : A ‚Üí Sort v} {m : ‚Ñï} {n : Fin (m + 1) ‚Üí ‚Ñï}
    {Œ± : (i : Fin (m + 1)) ‚Üí (j : Fin (n i)) ‚Üí A}
    {v : (i : Fin (m + 1)) ‚Üí (j : Fin (n i)) ‚Üí F (Œ± i j)} :
    fflatten v = fappend (v 0) (fflatten (fun i => v i.succ))

@[simp] -- TODO: more general version/class for query impls that never have failures
lemma loggingOracle.probFailure_simulateQ [spec.FiniteRange] (oa : OracleComp spec Œ±) :
    [‚ä• | (simulateQ loggingOracle oa).run] = [‚ä• | oa] := by
  induction oa using OracleComp.induction with

private lemma choose_2_eq_half_f :
  choose_2 = (1/2) * f

theorem pred_succ {T : Type u} [HasSucc T] [Zero T] [ToNat T] (x : Cayley T) :
    pred (succ x) = x

@[simp]
lemma erase_odd_empty :
    erase_odd ‚àÖ = ‚àÖ

@[simp]
lemma challengeOracleInterface_append_range_inr (j : pSpec‚ÇÇ.ChallengeIdx) :
    [(pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).Challenge]‚Çí.range (.inr j) = pSpec‚ÇÇ.Challenge j

lemma towerRingHomForwardMap0_eq :
  towerRingEquivFromConcrete0.toFun = towerRingHomForwardMap 0

lemma mul_trans_inequality {k : ‚Ñï} (x : ‚Ñï) (h_k : k ‚â§ 2) (h_x : x ‚â§ 2 ^ (2 ^ k) - 1) : x < 16

@[simp]
theorem drop_all (v : (i : Fin n) ‚Üí Œ± i) :
    drop n n.le_refl v = fun i => Fin.elim0 (i.cast (Nat.sub_self n))

omit [NeZero ‚Ñì] in
lemma fin_‚Ñì_steps_lt_‚Ñì_add_one (i : Fin ‚Ñì) (steps : ‚Ñï)
    (h : i.val + steps ‚â§ ‚Ñì) : i.val + steps < ‚Ñì + 1

@[csimp]
theorem vappend_eq_append : @vappend = @append

lemma getBit_of_and {n m k: ‚Ñï} : getBit k (n &&& m) = getBit k n &&& getBit k m

@[simp]
theorem seqCompose_two_eq_append {n : Fin 2 ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)} :
    seqCompose pSpec = append (pSpec 0) (pSpec 1)

@[simp]
lemma weight_constantCode [DecidableEq F] :
  wt (constantCode x Œπ) = 0 ‚Üî IsEmpty Œπ ‚à® x = 0

lemma if_self_rfl {Œ± : Type*} [DecidableEq Œ±] (a b : Œ±) :
  (if a = b then b else a) = a

omit [Finite F] in
lemma minus_one_in_doms {i : ‚Ñï} (h : i < n) :
    -1 ‚àà evalDomain D i

theorem eval_eq_eval_mv_eval_finSuccEquivNth (s : Fin n ‚Üí R) (y : R)
    (f : MvPolynomial (Fin (n + 1)) R) :
      eval (Fin.insertNth p y s : Fin (n + 1) ‚Üí R) f =
        Polynomial.eval y (Polynomial.map (eval s) (finSuccEquivNth R p f))

@[simp]
theorem insertNth_apply_succAbove : insertNth p y s (p.succAbove i) = s i

lemma isPrimitiveRoot_twoAdicGenerator (bits : Fin (twoAdicity + 1)) :
    IsPrimitiveRoot (twoAdicGenerators[bits]) (2 ^ (bits : Nat))

@[simp]
lemma BTField_add_eq (k n m) : BTField (k + n + m) = BTField (k + (n + m))

@[simp]
theorem acceptRejectOracleRel_language :
    acceptRejectOracleRel.language = { (true, isEmptyElim) }

lemma W·µ¢_vanishing (i : Fin r) :
  ‚àÄ u ‚àà U ùîΩq Œ≤ i, (W ùîΩq Œ≤ i).eval u = 0
</all_available_lemmas>

<local_ctx>
import ArkLib.Data.Classes.DCast

import ArkLib.Data.FieldTheory.BinaryField.Tower.Basic

namespace ConcreteBinaryTower

open Polynomial

def ConcreteBTField : ‚Ñï ‚Üí Type := fun k => BitVec (2 ^ k)

section BitVecDCast

instance BitVec.instDCast : DCast Nat BitVec where
  dcast h := BitVec.cast h
  dcast_id := by admit /- proof elided -/

end BitVecDCast

section ConversionUtils

instance ConcreteBTField.instDCast_local : DCast ‚Ñï ConcreteBTField where
  dcast h_k_eq term_k1 := BitVec.cast (congrArg (fun n => 2 ^ n) h_k_eq) term_k1
  dcast_id := by admit /- proof elided -/

end ConversionUtils

section NumericLemmas

end NumericLemmas

section FieldOperationsAndInstances

def zero {k : ‚Ñï} : ConcreteBTField k := BitVec.zero (2 ^ k)

def one {k : ‚Ñï} : ConcreteBTField k := 1#(2 ^ k)

def split {k : ‚Ñï} (h : k > 0) (x : ConcreteBTField k) :
    ConcreteBTField (k - 1) √ó ConcreteBTField (k - 1) :=
  let lo_bits : BitVec (2 ^ (k - 1) - 1 - 0 + 1) :=
    BitVec.extractLsb (hi := 2 ^ (k - 1) - 1) (lo := 0) x
  let hi_bits : BitVec (2 ^ k - 1 - 2 ^ (k - 1) + 1) :=
    BitVec.extractLsb (hi := 2 ^ k - 1) (lo := 2 ^ (k - 1)) x
  have h_lo : 2 ^ (k - 1) - 1 - 0 + 1 = 2 ^ (k - 1) := by admit /- proof elided -/

def join {k : ‚Ñï} (h_pos : k > 0) (hi lo : ConcreteBTField (k - 1)) : ConcreteBTField k :=

def Z (k : ‚Ñï) : ConcreteBTField k :=
  if h_k : k = 0 then one
  else
    „Ää one (k:=k-1), zero (k:=k-1) „Äã

def concrete_mul {k : ‚Ñï} (a b : ConcreteBTField k) : ConcreteBTField k :=
  if h_k_zero : k = 0 then
    if a = zero then zero
    else if b = zero then zero
    else if a = one then b
    else if b = one then a
    else zero 
  else
    have h_k_gt_0 : k > 0 := by admit /- proof elided -/

section FieldLemmasOfLevel0
</local_ctx>

<target_theorem>
lemma concrete_mul_left_distrib0 (a b c : ConcreteBTField 0) :
  concrete_mul a (b + c) = concrete_mul a b + concrete_mul a c :=
</target_theorem>

