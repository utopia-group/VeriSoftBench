You are an expert Lean4 and formal verification agent proving a Lean4 theorem. Your output **must** strictly adhere to the specified format.

### Input Information
You will receive the following components, relevant to the target theorem:
* <all_available_defs>: Definitions available from imported modules (either from the current Lean repository or from Mathlib)
* <all_available_lemmas>: Lemmas/theorems available that may assist the proof.
* <local_ctx>...</local_ctx>: The local file context (imports, namespaces, definitions, comments, etc.) from the top of the file up to‚Äîbut not including‚Äîthe target theorem or any previously defined local lemmas/theorems.
* <target_theorem>...</target_theorem>: The target theorem statement, ending with `:=`.

**Notes**
1. Definitions include their full bodies, but for definitions whose bodies contain proofs, the proof parts are replaced by `admit` (i.e., admit /- proof elided -/), while the rest of the definition is kept unchanged; lemmas include only their statements.
2. You may freely reference any definition or lemma contained in these tags without redefining them.
3. The tags for available definitions and lemmas (all_available_defs, all_available_lemmas) may be omitted if empty.

### Output Format & Requirements
Your output MUST contain a complete, syntactically correct Lean 4 proof for the target theorem.

**Strict Output Structure:**
<reasoning> 
...
</reasoning> 

<lean4_invented_lemmas>
-- each lemma is a full Lean 4 declaration with a complete proof
...
</lean4_invented_lemmas>

<lean4_proof>
-- Lean 4 proof body of the target theorem
...
</lean4_proof>

**Requirements:**
1. <reasoning> and <lean4_invented_lemmas> are OPTIONAL. Include them only if they aid proof construction.
2. <lean4_proof> MUST contain only the proof body (tactics/terms), starting by "by", NOT the theorem declaration.
3. <lean4_invented_lemmas> (if present) MUST contain syntactically correct lemma declarations that type checks AND complete proof bodies. Defining a lemma using `axiom` is NOT allowed.
4. <reasoning> contains high-level proof planning.
5. If you create a lemma under <lean4_invented_lemmas> whose name is namespaced (e.g., X.Y.Z), you MUST always refer to it using its fully qualified name. Do NOT rely on shortened names. For example, write rw [X.Y.Z], not rw [Z] for invented lemmas.
6. All Lean 4 code MUST be syntactically correct. No `sorry`, `admit`, or non-Lean text. Comments allowed using `--` or `/- ... -/`.
7. Follow the tags and structure EXACTLY. No extra text before, between, or after the sections.
8. Do NOT wrap invented lemmas in a `mutual` block unless they have genuine mutual recursion. Declare each lemma independently.

### Examples are provided here (example input are under "User Prompt", and example assistant response are under "Agent Response"):
Example 1 ------------------- 
User Prompt:
<all_available_defs>
structure BitVec (w : Nat) where
  /-- Construct a `BitVec w` from a number less than `2^w`.
  O(1), because we use `Fin` as the internal representation of a bitvector. -/
  ofFin ::

  /-- Interpret a bitvector as a number less than `2^w`.
  O(1), because we use `Fin` as the internal representation of a bitvector. -/
  toFin : Fin (hPow 2 w)
</all_available_defs>

<all_available_lemmas>
theorem List.getElem_append_left{Œ± : Type u_1} {l‚ÇÅ l‚ÇÇ : List Œ±} {i : Nat} (hn : i < l‚ÇÅ.length) : (l‚ÇÅ ++ l‚ÇÇ)[i] = l‚ÇÅ[i]
theorem getElem_eq_testBit_toNat (x : BitVec w) (i : Nat) (h : i < w) :
  x[i] = x.toNat.testBit i := rfl
@[simp, grind =] theorem toNat_cons (b : Bool) (x : BitVec w) :
    (cons b x).toNat = (b.toNat <<< w) ||| x.toNat
@[simp, grind =] theorem getLsbD_of_ge (x : BitVec w) (i : Nat) (ge : w ‚â§ i) : getLsbD x i = false
theorem testBit_toNat (x : BitVec w) : x.toNat.testBit i = x.getLsbD i
</all_available_lemmas>

<local_ctx>
import Mathlib.Computability.NFA
import Mathlib.Data.FinEnum
import Mathlib.Data.Rel
import Mathlib.Data.Vector.Basic
import Blase.AutoStructs.ForLean

open Set
open Mathlib
open SetRel

-- this is better because card is defeq to n
instance (Œ± : Type) : Inter (Language Œ±) := ‚ü®Set.inter‚ü©
instance (Œ± : Type) : Union (Language Œ±) := ‚ü®Set.union‚ü©

/--
The set of `n`-tuples of bit vectors of an arbitrary width.
-/
structure BitVecs (n : Nat) where
  w : Nat
  bvs : List.Vector (BitVec w) n

def BitVecs.cast (bvs : BitVecs n) (h : n = n') : BitVecs n' :=
  { w := bvs.w, bvs := h ‚ñ∏ bvs.bvs }

abbrev BitVecs.empty : BitVecs n := ‚ü®0, List.Vector.replicate n .nil‚ü©
abbrev BitVecs.singleton {w : Nat} (bv : BitVec w) : BitVecs 1 := ‚ü®w, bv ::·µ• .nil‚ü©
abbrev BitVecs.pair {w : Nat} (bv1 bv2 : BitVec w) : BitVecs 2 := ‚ü®w, bv1 ::·µ• bv2 ::·µ• .nil‚ü©

/--
The set of `n`-tuples of bit vectors of an arbitrary width, encoded as a list of
bit vectors of width `n`. The width of the encoded bit vectors is the length of
the list.
-/
abbrev BitVecs' (n : Nat) := List (BitVec n)

@[simps]
def dec (bvs' : BitVecs' n) : BitVecs n where
  w := bvs'.length
  bvs := List.Vector.ofFn fun k => BitVec.ofFn fun i => bvs'[i].getLsbD k

@[simp]
</local_ctx>

<target_theorem>
lemma dec_snoc n (bvs' : BitVecs' n) (a : BitVec n) :
  dec (bvs' ++ [a]) =
    { w := bvs'.length + 1
      bvs := List.Vector.ofFn fun k =>
        BitVec.cons (a.getLsbD k) ((dec bvs').bvs.get k) } :=
</target_theorem>

Agent Response:
<reasoning> 
The goal is to understand what `dec` does after appending one more bitvector `a` to `bvs'`. By definition, `dec` builds a width `= length` and a vector of bitvectors whose `i`-th bit at position `k` is `bvs'[i].getLsbD k`. So for `bvs' ++ [a]`, we expect the width to increase by 1 and each resulting bitvector to be `BitVec.cons` of the new bit coming from `a`.

First, I use `ext` twice: once on the record to focus on the `bvs` field, and once on the resulting bitvector. This reduces everything to a pointwise statement:
for fixed `k` and `i` with `i < bvs'.length + 1`,
the bit `(bvs' ++ [a])[i].getLsbD k` should match the bit at index `i` of `BitVec.cons (a.getLsbD k) ((dec bvs').bvs.get k)`.

At this point I need a clean description of indexing into `BitVec.cons`: if we have `x : BitVec n`, then `(cons b x)[i]` should give `b` at the new ‚Äúlast‚Äù index `n` and `x[i]` otherwise. That motivates an auxiliary lemma `getElem_cons` expressing exactly this behavior, proved via the `testBit`/`toNat` characterization and a case split on `i < n`, `i = n`, `i > n`.

Using `getElem_cons`, the RHS becomes an `if` on whether `i = bvs'.length`. So I split into cases:
- If `i = bvs'.length`, then `(bvs' ++ [a])[i]` is the appended `a`, so both sides reduce to `a.getLsbD k`.
- If `i ‚â† bvs'.length`, the bound `i < bvs'.length + 1` forces `i < bvs'.length`. Then `(bvs' ++ [a])[i] = bvs'[i]` by `List.getElem_append_left`, and the RHS takes the ‚Äúelse‚Äù branch and likewise gives the bit from `bvs'[i]`. In both subcases, `simp` (plus the definition of `dec`) finishes.

So the whole proof is: `ext` to bit level, unfold `dec` with `simp_all`, rewrite with `getElem_cons`, split on the boundary index `i = length bvs'`, and in the ‚Äú< length‚Äù branch use `List.getElem_append_left` and bounds to line up both sides.
</reasoning> 

<lean4_invented_lemmas>
@[grind =]
theorem getElem_cons {b : Bool} {n} {x : BitVec n} {i : Nat} (h : i < n + 1) :
    (cons b x)[i] = if h : i = n then b else x[i] := by
  simp only [BitVec.getElem_eq_testBit_toNat, BitVec.toNat_cons, Nat.testBit_or]
  rw [Nat.testBit_shiftLeft]
  rcases Nat.lt_trichotomy i n with i_lt_n | i_eq_n | n_lt_i
  ¬∑ have p1 : ¬¨(n ‚â§ i) := by omega
    have p2 : i ‚â† n := by omega
    simp [p1, p2]
  ¬∑ simp only [i_eq_n, ge_iff_le, Nat.le_refl, decide_true, Nat.sub_self, Nat.testBit_zero,
    Bool.true_and, BitVec.testBit_toNat, BitVec.getLsbD_of_ge, Bool.or_false]
    cases b <;> trivial
  ¬∑ have p1 : i ‚â† n := by omega
    have p2 : i - n ‚â† 0 := by omega
    simp [p1, p2, Nat.testBit_bool_toNat]
</lean4_invented_lemmas>

<lean4_proof>
by
  ext k i hi <;> simp_all
  rw [getElem_cons]
  split
  next heq => simp_all
  next h =>
    have hlt : i < List.length bvs' := by simp at hi; omega
    rw [List.getElem_append_left hlt]
    simp
</lean4_proof>

### Your task:
<all_available_defs>
Fin in Init.Prelude
Subspace in Mathlib.Algebra.Module.Submodule.Basic
Set in Mathlib.Data.Set.Defs
Set.Ico in Mathlib.Order.Interval.Set.Defs
Submodule in Mathlib.Algebra.Module.Submodule.Defs
Submodule.span in Mathlib.LinearAlgebra.Span.Defs
Polynomial.C in Mathlib.Algebra.Polynomial.Basic
Nat in Init.Prelude
Algebra in Mathlib.Algebra.Algebra.Defs
Field in Mathlib.Algebra.Field.Defs
IsLinearMap in Mathlib.Algebra.Module.LinearMap.Defs
toFun in ToMathlib.Control.Monad.Hom
Submodule.map in Mathlib.Algebra.Module.Submodule.Map
Set.range in Mathlib.Data.Set.Operations
DecidableEq in Init.Prelude
Fintype in Mathlib.Data.Fintype.Defs
NeZero in Init.Data.NeZero
Nat.succ in Init.Prelude
Fintype.card in Mathlib.Data.Fintype.Card
Polynomial.eval in Mathlib.Algebra.Polynomial.Eval.Defs
RingHom in Mathlib.Algebra.Ring.Hom.Defs
RingHom.id in Mathlib.Algebra.Ring.Hom.Defs
Finset in Mathlib.Data.Finset.Defs
Finset.univ in Mathlib.Data.Fintype.Defs
Polynomial.rootMultiplicity in Mathlib.Algebra.Polynomial.Div
CommRing in Mathlib.Algebra.Ring.Defs
Polynomial.algEquivOfCompEqX in Mathlib.Algebra.Polynomial.AlgebraMap

noncomputable def normalizedW (i : Fin r) : L[X] :=
  C (1 / (W ùîΩq Œ≤ i).eval (Œ≤ i)) * W ùîΩq Œ≤ i

noncomputable def W (i : Fin r) : L[X] :=
  ‚àè u : U ùîΩq Œ≤ i, (X - C u.val)

def U (i : Fin r) : Subspace ùîΩq L := Submodule.span ùîΩq (Œ≤ '' (Set.Ico 0 i))

def getBit (k n : Nat) : Nat := (n >>> k) &&& 1

noncomputable def polyEvalLinearMap {L ùîΩq : Type*} [Field L] [Field ùîΩq] [Algebra ùîΩq L]
  (p : L[X]) (hp_add : IsLinearMap ùîΩq (fun x : L => p.eval x)) : L ‚Üí‚Çó[ùîΩq] L :=
{
  toFun    := fun x => p.eval x,
  map_add' := hp_add.map_add,
  map_smul' := hp_add.map_smul
}

def g (n : ‚Ñï) (c : ‚Ñï) (x : ‚Ñï) := (x * x + c) % n

@[elab_as_elim] def Fin.succRecOnSameFinType {motive : Fin r ‚Üí Sort _}
    (zero : motive (0 : Fin r))
    (succ : ‚àÄ i : Fin r, i + 1 < r ‚Üí motive i ‚Üí motive (i + 1)) : ‚àÄ (i : Fin r), motive i
  | ‚ü®0, _‚ü© => by admit /- proof elided -/
  | ‚ü®Nat.succ i_val, h‚ü© => by admit /- proof elided -/

@[simps!]
noncomputable def algEquivAevalXSubC {R : Type*} [CommRing R] (t : R) : R[X] ‚âÉ‚Çê[R] R[X] :=

Nat.all in Init.Data.Nat.Fold

instance {Œπ : Type} : OracleInterface (OracleStatement Œπ F ()) := OracleInterface.instFunction

Finset.add in Mathlib.Algebra.Group.Pointwise.Finset.Basic

noncomputable def novelPolynomialBasis (‚Ñì : Nat) (h_‚Ñì : ‚Ñì ‚â§ r) :
  Basis (Fin (2^‚Ñì)) (R := L) (M := L‚¶É<2^‚Ñì‚¶Ñ[X]) :=

def divX (p : UniPoly R) : UniPoly R := p.extract 1 p.size

@[inline, specialize]
def oracleReduction : OracleReduction oSpec
    Statement OStatement Unit Statement OStatement Unit !p[] where
  prover := oracleProver oSpec Statement OStatement
  verifier := oracleVerifier oSpec Statement OStatement pred

GaloisField.equivZmodP in Mathlib.FieldTheory.Finite.GaloisField

noncomputable def hasMutualCorrAgreement
  (Gen : ProximityGenerator Œπ F) [Fintype Gen.par‚Ñì]
  (BStar : ‚Ñù) (errStar : ‚Ñù ‚Üí ENNReal) :=
    haveI := Gen.Gen_nonempty
    ‚àÄ (f : Gen.par‚Ñì ‚Üí Œπ ‚Üí F) (Œ¥ : ‚Ñù‚â•0) (_hŒ¥ : 0 < Œ¥ ‚àß Œ¥ < 1 - BStar),
    Pr_{let r ‚Üê$·µñ Gen.Gen}[ proximityCondition f Œ¥ r Gen.C ] ‚â§ errStar Œ¥

def range (n : ‚Ñï) : Fin n ‚Üí ‚Ñï := fun i => i

@[inline, specialize]
def Reduction.runWithLog (stmt : StmtIn) (wit : WitIn)
    (reduction : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí)
        (((FullTranscript pSpec √ó StmtOut √ó WitOut) √ó StmtOut) √ó
          QueryLog (oSpec ++‚Çí [pSpec.Challenge]‚Çí) √ó QueryLog oSpec) := do
  
  let ‚ü®proverResult, proveQueryLog‚ü© ‚Üê reduction.prover.runWithLog stmt wit
  let ‚ü®stmtOut, verifyQueryLog‚ü© ‚Üê
    liftM (simulateQ loggingOracle (reduction.verifier.run stmt proverResult.1)).run
  return ‚ü®‚ü®proverResult, stmtOut‚ü©, proveQueryLog, verifyQueryLog‚ü©

@[reducible]
def duplexSpongeChallengeOracle (StartType : Type) (U : Type) [SpongeUnit U] [SpongeSize] :
    OracleSpec (Unit ‚äï PermuteDir) :=
  (StartType ‚Üí‚Çí Vector U SpongeSize.C) ++‚Çí permutationOracle (CanonicalSpongeState U)

alias ùíü_ùîñ := duplexSpongeChallengeOracle

def nonLastBlockOracleReduction (bIdx : Fin (‚Ñì / œë - 1)) :=
  let stmt : Fin (œë - 1 + 1) ‚Üí Type :=
    fun i => Statement (L := L) (‚Ñì := ‚Ñì) Context ‚ü®bIdx * œë + i, bIdx_mul_œë_add_i_cast_lt_‚Ñì_succ bIdx i‚ü©
  let oStmt := fun i: Fin (œë - 1 + 1) =>
    OracleStatement ùîΩq Œ≤ œë ‚ü®bIdx * œë + i, bIdx_mul_œë_add_i_cast_lt_‚Ñì_succ bIdx i‚ü©
  let wit := fun i: Fin (œë - 1 + 1) =>
    Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì)
      ‚ü®bIdx * œë + i, bIdx_mul_œë_add_i_cast_lt_‚Ñì_succ bIdx i‚ü©
  let firstFoldRelayRoundsOracleReduction :=
    OracleReduction.seqCompose (oSpec := []‚Çí)
      (Stmt := stmt)
      (OStmt := oStmt)
      (Wit := wit)
      (pSpec := fun i => pSpecFoldRelay (L:=L))
      (R := fun i => by admit /- proof elided -/
      )

  let h1 : ‚ÜëbIdx * œë + (œë - 1) < ‚Ñì := by admit /- proof elided -/

reduceCtorEq in Lean.Meta.Tactic.Simp.BuiltinSimprocs.Core

@[simp]
def BTFieldCard (k : ‚Ñï) : Fintype.card (BTField k) = 2^(2^k)
  := (BinaryTowerAux k).2.fieldFintypeCard

@[simp]
instance BTField_Fintype (k : ‚Ñï) : Fintype (BTField k) := (BinaryTowerAux k).2.instFintype

def LeafData.ofFun {Œ± : Type} (s : Skeleton)
    (f : SkeletonLeafIndex s ‚Üí Œ±) : LeafData Œ± s :=
  match s with
  | .leaf => LeafData.leaf (f SkeletonLeafIndex.ofLeaf)
  | .internal l r =>
      LeafData.internal
        (LeafData.ofFun l (fun idx => f (SkeletonLeafIndex.ofLeft idx)))
        (LeafData.ofFun r (fun idx => f (SkeletonLeafIndex.ofRight idx)))

MvPolynomial.totalDegree in Mathlib.Algebra.MvPolynomial.Degrees

def fappend {A : Sort u} {F : A ‚Üí Sort v} {m n : ‚Ñï} {Œ± : Fin m ‚Üí A} {Œ≤ : Fin n ‚Üí A}
    (u : (i : Fin m) ‚Üí F (Œ± i)) (v : (i : Fin n) ‚Üí F (Œ≤ i)) :
    (i : Fin (m + n)) ‚Üí F (Fin.vappend Œ± Œ≤ i) :=
  match n with
  | 0 => u
  | k + 1 => fconcat (fappend u (fun i => v (Fin.castSucc i))) (v (Fin.last k))

Finsupp.onFinset in Mathlib.Data.Finsupp.Defs

noncomputable def towerEquiv_zero : RingEquiv (R:=GF(2)) (S:=ConcreteBTField 0) :=  {
  toFun := fun x => if x = 0 then 0 else 1,
  invFun := fun x => if x = 0 then 0 else 1,
  left_inv := fun x => by admit /- proof elided -/

structure SumcheckBaseContext (L : Type) (‚Ñì : ‚Ñï) where
  t_eval_point : Fin ‚Ñì ‚Üí L         
  original_claim : L               

def map {Œ± Œ≤ : Fin n ‚Üí Sort*} (f : (i : Fin n) ‚Üí Œ± i ‚Üí Œ≤ i) (a : (i : Fin n) ‚Üí Œ± i) :
    (i : Fin n) ‚Üí Œ≤ i := fun i => f i (a i)

Equivalence in Init.Core

def nonDoomedFoldingProp (i : Fin (‚Ñì + 1)) (challenges : Fin i ‚Üí L)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i j)
    : Prop :=
  let oracleFoldingConsistency := oracleFoldingConsistencyProp ùîΩq Œ≤ i (challenges := challenges)
    (oStmt := oStmt)
  let foldingBadEventExists := badEventExistsProp ùîΩq Œ≤ i (challenges := challenges)
    (oStmt := oStmt)
  oracleFoldingConsistency ‚à® foldingBadEventExists

def Verifier.liftContext
    (lens : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut)
    (V : Verifier oSpec InnerStmtIn InnerStmtOut pSpec) :
      Verifier oSpec OuterStmtIn OuterStmtOut pSpec where
  verify := fun stmtIn transcript => do
    let innerStmtIn := lens.proj stmtIn
    let innerStmtOut ‚Üê V.verify innerStmtIn transcript
    return lens.lift stmtIn innerStmtOut

def dfoldl' (n : ‚Ñï) (Œ± : Fin (n + 1) ‚Üí Type u)
    (f : (i : Fin n) ‚Üí Œ± i.castSucc ‚Üí Œ± i.succ) (init : Œ± 0) : Œ± (last n) :=
  dfoldlM' (m := Id) n Œ± f init

Mathlib.Meta.NormNum.mkOfNat in Mathlib.Tactic.NormNum.Result

def verifier : Verifier oSpec (StmtIn R √ó (‚àÄ i, OStmtIn R deg i))
                              (StmtOut R √ó (‚àÄ i, OStmtOut R deg i)) (pSpec R deg) where
  verify := fun ‚ü®target, oStmt‚ü© transcript => do
    letI polyLE := transcript 0
    guard (‚àë x ‚àà (univ.map D), polyLE.val.eval x = target)
    letI chal := transcript 1
    pure ‚ü®‚ü®(oStmt ()).val.eval chal, chal‚ü©, fun _ => oStmt ()‚ü©

@[reducible]
def GroupEncodeOracle : OracleSpec Unit := fun _ => (Œπ, BitVec bitLength)

class VCVCompatible (Œ± : Type*) extends Fintype Œ±, Inhabited Œ± where
  [type_decidableEq' : DecidableEq Œ±]

def disagreementSet (i : Fin ‚Ñì) (steps : ‚Ñï) [NeZero steps] (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
  (f g : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i.val + steps, by admit /- proof elided -/
    ‚ü©) :
  Set ((sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®i.val + steps, by admit /- proof elided -/
  ‚ü©) :=
  {y | f y ‚â† g y}

abbrev MultilinearPoly (L : Type) [CommSemiring L] (‚Ñì : ‚Ñï) := L‚¶É‚â§ 1‚¶Ñ[X Fin ‚Ñì]

def degree (P : Params Œπ F) : Fin (M + 1) ‚Üí ‚Ñï :=
  fun i => P.deg / ‚àè j < i, (P.foldingParam j)

@[reducible, simp]
def relOut : (StmtOut OStatement √ó ‚àÄ i, OStmtOut OStatement i) ‚Üí WitOut ‚Üí Prop :=
  fun ‚ü®‚ü®q, r‚ü©, oStmt‚ü© () => answer (oStmt 0) q = r

def correlatedAgreement (C : Set (n ‚Üí F)) (Œ¥ : ‚Ñù‚â•0) {k : ‚Ñï} (W : Fin k ‚Üí n ‚Üí F) : Prop :=
  ‚àÉ S : Finset n, #(S) ‚â• (1 - Œ¥) * (Fintype.card n) ‚àß
    ‚àÉ v : Fin k ‚Üí n ‚Üí F, ‚àÄ i, v i ‚àà C ‚àß {j | v i j = W i j} = S

@[reducible, simp] def StmtOut := Query OStatement

class IsSingleRound (pSpec : ProtocolSpec 2) extends ProverFirst pSpec, VerifierLast pSpec

alias ProverThenVerifier := IsSingleRound

def InternalData.map {Œ± Œ≤ : Type} (f : Œ± ‚Üí Œ≤) {s : Skeleton}
    (tree : InternalData Œ± s) : InternalData Œ≤ s :=
  match tree with
  | InternalData.leaf => InternalData.leaf
  | InternalData.internal value left right =>
    InternalData.internal (f value) (left.map f) (right.map f)

def isZero {Œ± : Type} (n : ChurchNat Œ±) : ChurchBool Œ± :=
  fun x y => n (fun _ => y) x

MonomialOrder in Mathlib.Data.Finsupp.MonomialOrder

def hconcat {n : ‚Ñï} {Œ± : Fin n ‚Üí Sort u} {Œ≤ : Sort u} (u : (i : Fin n) ‚Üí Œ± i) (a : Œ≤) :
    (i : Fin (n + 1)) ‚Üí Fin.vconcat Œ± Œ≤ i :=
  fconcat (F := id) u a

def churchFalse : ChurchBool Œ± := fun _ y => y

def LeafData.composeBuild {Œ± : Type} {s : Skeleton} (leaf_data_tree : LeafData Œ± s)
    (compose : Œ± ‚Üí Œ± ‚Üí Œ±) :
    FullData Œ± s :=
  match s, leaf_data_tree with
  | Skeleton.leaf, LeafData.leaf value =>
    FullData.leaf value
  | Skeleton.internal _ _, LeafData.internal left right =>
    let left_tree := LeafData.composeBuild left compose
    let right_tree := LeafData.composeBuild right compose
    FullData.internal
      (compose left_tree.getRootValue right_tree.getRootValue)
      left_tree
      right_tree

invFun in ToMathlib.Control.Monad.Equiv

noncomputable def finalSumcheckOracleReduction :
  OracleReduction
    (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì))
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì))
    (StmtOut := FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì))
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (WitOut := Unit)
    (pSpec := pSpecFinalSumcheckStep (L := L)) where
  prover := finalSumcheckProver ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
  verifier := finalSumcheckVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)

@[inline] def one : AssocNat :=
  ‚ü®Nat.succ, by admit /- proof elided -/
  ‚ü©

instance instDCast‚ÇÇ : DCast‚ÇÇ Nat ProtocolSpec (fun _ pSpec => ChallengeIdx pSpec) where
  dcast‚ÇÇ h := ChallengeIdx.cast h
  dcast‚ÇÇ_id := cast_id

instance [VerifierFirst pSpec] : VerifierLast pSpec where
  verifier_last' := by admit /- proof elided -/

def joinBits {n m : ‚Ñï} (low : Fin (2 ^ n)) (high : Fin (2 ^ m)) : Fin (2 ^ (m+n)) :=
  ‚ü®(high.val <<< n) ||| low.val, by admit /- proof elided -/
  ‚ü©

def churchTrue : ChurchBool Œ± := fun x _ => x

def pSpecNonLastBlocks := seqCompose fun bIdx ‚Ü¶
  pSpecFullNonLastBlock ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) bIdx

class DCast‚ÇÇ (Œ± : Sort*) (Œ≤ : Œ± ‚Üí Sort*) (Œ≥ : (a : Œ±) ‚Üí Œ≤ a ‚Üí Sort*) [DCast Œ± Œ≤] where
  dcast‚ÇÇ : ‚àÄ {a a' : Œ±} {b : Œ≤ a} {b' : Œ≤ a'},
    (ha : a = a') ‚Üí (dcast ha b = b') ‚Üí Œ≥ a b ‚Üí Œ≥ a' b'
  dcast‚ÇÇ_id : ‚àÄ {a : Œ±} {b : Œ≤ a}, dcast‚ÇÇ (Eq.refl a) dcast_eq = (id : Œ≥ a b ‚Üí Œ≥ a b)

def InputStatement := R

abbrev drop (m : ‚Ñï) (h : m ‚â§ n)
    (transcript : FullTranscript pSpec) : FullTranscript (pSpec.drop m h) :=
  Fin.drop m h transcript

def findSumIdxWith (l : List ‚Ñï) (j : Fin l.sum) : (i : Fin l.length) √ó Fin (l.get i) := sorry

structure Gate (ùì° : Type*) (numWires : ‚Ñï) extends Selector ùì°, WireIndices numWires
deriving DecidableEq

def oracleReduction : OracleReduction oSpec
      Statement OStatement Unit
      Unit (OStatement ‚äï·µ• OStatement) Unit (pSpec OStatement) where
  prover := oracleProver oSpec Statement OStatement
  verifier := oracleVerifier oSpec Statement OStatement relComp

Finset.biUnion in Mathlib.Data.Finset.Union

def towerAlgebraMap (l r : ‚Ñï) (h_le : l ‚â§ r) : BTField l ‚Üí+* BTField r :=

def rho' (n : ‚Ñï) (start : ‚Ñï) (c : ‚Ñï) : Option ‚Ñï := Id.run do
  if n % 2 = 0 then
    return some 2

  let mut x := start
  let mut y := x
  let mut d := 1

  while d = 1 do
    x := g n c x
    y := g n c (g n c y)
    d := Nat.gcd (Int.natAbs (x - y)) n

  if d = n then
    return none
  else
    return some d

def internalLinearLayer (state : Vector KoalaBear.Field params.width) :
    Vector KoalaBear.Field params.width :=
  
  
  let sumAll := state.foldl (fun acc x => acc + x) 0

  
  
  state.zipWith (fun s d => sumAll + d * s) params.internalDiagVectors

@[reducible]
def Set.language {Œ± Œ≤} (rel : Set (Œ± √ó Œ≤)) : Set Œ± :=
  Prod.fst '' rel

def LeafData.optionComposeBuild {Œ± : Type} {s : Skeleton} (leaf_data_tree : LeafData Œ± s)
    (compose : Œ± ‚Üí Œ± ‚Üí Option Œ±) :
    FullData (Option Œ±) s :=
  (leaf_data_tree.map (.some)).composeBuild (Option.doubleBind compose)

instance {k : Fin 1} : Unique (ChallengesUpTo k (default : ProtocolSpec 0)) where
  default := fun i => ()
  uniq := by admit /- proof elided -/

List.take in Init.Data.List.Basic

def concat' {k : Fin n}
    (challenges : (i : Fin k) ‚Üí (pSpec.dir (i.castLE (by admit /- proof elided -/
    )) = .V_to_P
      ‚Üí pSpec.¬´Type¬ª (i.castLE (by admit /- proof elided -/
      ))))
    (chal : (h : pSpec.dir k = .V_to_P) ‚Üí pSpec.Challenge ‚ü®k, h‚ü©) :
    (i : Fin (k + 1)) ‚Üí (pSpec.dir (i.castLE (by admit /- proof elided -/
    )) = .V_to_P) ‚Üí
      pSpec.¬´Type¬ª (i.castLE (by admit /- proof elided -/
      )) :=
  Fin.dconcat challenges chal

OracleComp in VCVio.OracleComp.OracleComp

instance extractorLens_rbr_knowledge_soundness :
    Extractor.Lens.IsKnowledgeSound
      (relationRound R n deg D i.castSucc) (Simple.inputRelation R deg D)
      (relationRound R n deg D i.succ) (Simple.outputRelation R deg)
      ((Simple.oracleVerifier R deg D oSpec).toVerifier.compatStatement (oStmtLens R n deg D i))
      (fun _ _ => True)
      ‚ü®oStmtLens R n deg D i, Witness.InvLens.trivial‚ü© where
  proj_knowledgeSound := by admit /- proof elided -/

TensorProduct in Mathlib.LinearAlgebra.TensorProduct.Basic

LinearEquiv.ofBijective in Mathlib.Algebra.Module.Submodule.Equiv

@[inline, reducible]
def toContext :
    Context.Lens (OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i)) (OuterStmtOut √ó (‚àÄ i, OuterOStmtOut i))
                (InnerStmtIn √ó (‚àÄ i, InnerOStmtIn i)) (InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i))
                OuterWitIn OuterWitOut InnerWitIn InnerWitOut :=
  ‚ü®lens.stmt, lens.wit‚ü©

noncomputable def monomialBasisOfDegreeLT {n : ‚Ñï} : Basis (Fin n) L (L‚¶É< n‚¶Ñ[X]) :=

def proximityGap (d : ‚Ñï) (bound : ‚Ñï) : Prop :=
  ‚àÄ u v : n ‚Üí F, (proximityMeasure C u v d > bound)
    ‚Üí (Œî‚ÇÄ( u ‚ãà v , C ^‚ãà Fin 2 ) ‚â§ d)

def KnowledgeStateFunction.toStateFunction
    {relIn : Set (StmtIn √ó WitIn)} {relOut : Set (StmtOut √ó WitOut)}
    {verifier : Verifier oSpec StmtIn StmtOut pSpec} {WitMid : Fin (n + 1) ‚Üí Type}
    {extractor : Extractor.RoundByRound oSpec StmtIn WitIn WitOut pSpec WitMid}
    (kSF : KnowledgeStateFunction init impl relIn relOut verifier extractor) :
      verifier.StateFunction init impl relIn.language relOut.language where
  toFun := fun m stmtIn tr => ‚àÉ witMid, kSF.toFun m stmtIn tr witMid
  toFun_empty := by admit /- proof elided -/

@[simp]
def poly (k : ‚Ñï) : Polynomial (BTField k) := definingPoly (s:=(Z k))

System.FilePath in Init.System.FilePath

Algebra.ofId in Mathlib.Algebra.Algebra.Hom

@[inline, specialize]
def OracleReduction.run [‚àÄ i, OracleInterface (pSpec.Message i)]
    (stmt : StmtIn) (oStmt : ‚àÄ i, OStmtIn i) (wit : WitIn)
    (reduction : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec) :
      OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí)
        ((FullTranscript pSpec √ó (StmtOut √ó ‚àÄ i, OStmtOut i) √ó WitOut) √ó
          (StmtOut √ó ‚àÄ i, OStmtOut i)) := do
  let proverResult ‚Üê reduction.prover.run ‚ü®stmt, oStmt‚ü© wit
  let stmtOut ‚Üê liftM (reduction.verifier.run stmt oStmt proverResult.1)
  return ‚ü®proverResult, stmtOut‚ü©

def relayKnowledgeStateFunction (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
    (relayOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        i hNCR).KnowledgeStateFunction init impl
      (relIn := foldStepRelOut (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i.succ)
      (extractor := relayRbrExtractor ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) where
  toFun := fun m ‚ü®stmtIn, oStmtIn‚ü© tr witMid =>
    relayKStateProp (mp:=mp) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (ùìë := ùìë) i hNCR stmtIn witMid oStmtIn
  toFun_empty := fun ‚ü®stmtIn, oStmtIn‚ü© witIn => by admit /- proof elided -/

@[inline, specialize]
def oracleVerifier : OracleVerifier oSpec
    Statement OStatement Statement (OStatement ‚äï·µ• (fun _ : Fin 1 => Witness))
    (oraclePSpec Witness) where
  verify := fun stmt _ => pure stmt
  embed := .sumMap (.refl _)
    <| Equiv.toEmbedding
    <|.symm (subtypeUnivEquiv (by admit /- proof elided -/
    ))
  hEq := by admit /- proof elided -/

@[inline]
def seqCompose {m : ‚Ñï} (Stmt : Fin (m + 1) ‚Üí Type)
    {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (V : (i : Fin m) ‚Üí Verifier oSpec (Stmt i.castSucc) (Stmt i.succ) (pSpec i)) :
    Verifier oSpec (Stmt 0) (Stmt (Fin.last m)) (seqCompose pSpec) := match m with
  | 0 => Verifier.id
  | _ + 1 => append (V 0) (seqCompose (Stmt ‚àò Fin.succ) (fun i => V (Fin.succ i)))

@[reducible]
def SCALAR_FIELD_CARD : Nat := 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141

Polynomial.eval‚ÇÇ in Mathlib.Algebra.Polynomial.Eval.Defs

abbrev Field := ZMod fieldSize

def knowledgeSoundness
    (relIn : Set ((StmtIn √ó ‚àÄ i, OStmtIn i) √ó WitIn))
    (relOut : Set ((StmtOut √ó ‚àÄ i, OStmtOut i) √ó WitOut))
    (verifier : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec)
    (knowledgeError : ‚Ñù‚â•0) : Prop :=
  verifier.toVerifier.knowledgeSoundness init impl relIn relOut knowledgeError

instance : Fact (Nat.Prime (PrimeOrder.p G)) :=
  PrimeOrder.hPrime

@[app_unexpander Fin.fcons]
def fconsUnexpander : Lean.PrettyPrinter.Unexpander
  | `($_ $a !h‚¶É$F‚¶Ñ‚ü®$Œ±‚ü©[$b, $bs,*]) => `(!h‚¶É$F‚¶Ñ‚ü®$Œ±‚ü©[$a, $b, $bs,*])
  | `($_ $a !h‚¶É$F‚¶Ñ‚ü®$Œ±‚ü©[$b]) => `(!h‚¶É$F‚¶Ñ‚ü®$Œ±‚ü©[$a, $b])
  | `($_ $a !h‚¶É$F‚¶Ñ‚ü®$Œ±‚ü©[]) => `(!h‚¶É$F‚¶Ñ‚ü®$Œ±‚ü©[$a])
  | _ => throw ()

Cardinal in Mathlib.SetTheory.Cardinal.Defs

Nat.gcd in Init.Data.Nat.Gcd

@[simp]
abbrev SecondSumcheckChallenge : Type := Fin pp.‚Ñì_n ‚Üí R

structure Commit where
  commit : Data ‚Üí Randomness ‚Üí OracleComp oSpec Commitment

def D_Y (Q : F[Z][X][Y]) : ‚Ñï := Bivariate.natDegreeY Q

@[inline]
def ofOutputOnly
    (liftWit : OuterStmtIn √ó OuterWitIn ‚Üí InnerStmtOut √ó InnerWitOut ‚Üí OuterWitOut) :
    Witness.Lens OuterStmtIn InnerStmtOut OuterWitIn OuterWitOut OuterWitIn InnerWitOut :=
  ‚ü®Prod.snd, liftWit‚ü©

ringChar in Mathlib.Algebra.CharP.Defs

instance {i : Fin r} : Module (R := ùîΩq) (M := U ùîΩq Œ≤ i) := Submodule.module _

def distanceLE (Message : Type*) [O : OracleInterface Message]
    [Fintype (O.Query)] [DecidableEq (O.Response)] (d : ‚Ñï) : Prop :=
  ‚àÄ a b : Message, a ‚â† b ‚Üí #{q | OracleInterface.answer a q = OracleInterface.answer b q} ‚â§ d

def block (i : ‚Ñï) {k : ‚Ñï} {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F}
  (S' : Finset (indexPowT S œÜ i))
  (œÜ' : (indexPowT S œÜ i) ‚Ü™ F) (z : indexPowT S œÜ k)
  [DecidableEq F] [DecidableEq Œπ] [Smooth œÜ] :=
    powFiberT i S' œÜ' z

@[reducible, simp]
def rbrSoundness (langIn : Set Statement)
    (verifier : Verifier oSpec Statement Bool pSpec)
    (rbrSoundnessError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) : Prop :=
  verifier.rbrSoundness init impl langIn acceptRejectRel.language rbrSoundnessError

AlternativeMonad in Batteries.Control.AlternativeMonad

instance : LawfulHasPred Nat where
  pred'_succ := Nat.pred_succ

Option.bind in Init.Data.Option.Basic

instance {Message : Type u} : Inhabited (OracleInterface Message) :=
  ‚ü®instDefault‚ü©

LawfulFunctor in Init.Control.Lawful.Basic

noncomputable def foldingBadEventAtBlock
    (stmtIdx : Fin (‚Ñì + 1)) (oracleIdx : Fin (‚Ñì + 1))
    (oStmt : ‚àÄ j, (OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (i := oracleIdx) j))
    (challenges : Fin stmtIdx ‚Üí L)
    (j : Fin (toOutCodewordsCount ‚Ñì œë oracleIdx)) : Prop :=
  have h_œë: œë > 0 := by admit /- proof elided -/

Finsupp.sum in Mathlib.Algebra.BigOperators.Finsupp.Basic

Array.zipIdx in Init.Data.Array.Basic

class SmoothPowerOfTwo (n : ‚Ñï) (G : Type) [Pow G ‚Ñ§] [Monoid G] [inst : IsCyclicWithGen G] where
  smooth : orderOf inst.gen = 2 ^ n

def liftingLens :
  OracleContext.Lens
    ((Fin m ‚Üí F) √ó Fri.Spec.Statement F (0 : Fin (k + 1))) (Fri.Spec.FinalStatement F k)
    (Fri.Spec.Statement F (0 : Fin (k + 1))) (Fri.Spec.FinalStatement F k)
    (OracleStatement D x m) (Fri.Spec.FinalOracleStatement D x s)
    (Fri.Spec.OracleStatement D x s 0) (Fri.Spec.FinalOracleStatement D x s)
    (Fri.Spec.Witness F s d 0) (Fri.Spec.Witness F s d (Fin.last (k + 1)))
    (Fri.Spec.Witness F s d 0) (Fri.Spec.Witness F s d (Fin.last (k + 1))) where
  stmt := Witness.InvLens.ofOutputOnly <| fun ‚ü®‚ü®cs, stmt‚ü©, ostmt‚ü© =>
    ‚ü®
      stmt,
      fun j v =>
          have : v.1 ‚àà Fri.CosetDomain.evalDomain D x 0 := by admit /- proof elided -/
    ‚ü©
  wit  := Witness.Lens.id

Finset.sup in Mathlib.Data.Finset.Lattice.Fold

def findFinIdx (p : Œ± ‚Üí Bool) (l : List Œ±) : Fin (l.length + 1) :=
  ‚ü®List.findIdx' p l,
    Nat.lt_succ_of_le (by admit /- proof elided -/
    )‚ü©

def relation : Set (M √ó List (MemoryRead Œπ Œ±)) :=
  { ‚ü®mem, ops‚ü© | ‚àÄ op ‚àà ops, Memory.read mem op.index = op.value }

instance instDCast‚ÇÇ : DCast‚ÇÇ Nat ProtocolSpec (fun _ pSpec => MessageIdx pSpec) where
  dcast‚ÇÇ h := MessageIdx.cast h
  dcast‚ÇÇ_id := cast_id

def start {Œ± : Type} (a : Œ±) : OracleComp (Œ± ‚Üí‚Çí Vector U SpongeSize.C) (DuplexSponge U C) := do
  let capacitySegment : Vector U SpongeSize.C ‚Üê query (spec := Œ± ‚Üí‚Çí Vector U SpongeSize.C) () a
  let vecSponge := (Vector.replicate SpongeSize.R (0 : U)) ++ capacitySegment
  return {
    state := SpongeState.update (Œ± := C) (0 : C) (vecSponge.cast (by admit /- proof elided -/
    )),
    absorbPos := 0,
    squeezePos := Fin.last SpongeSize.R
  }

structure ParamConditions (P : Params Œπ F) where
  m : ‚Ñï 
  h_m : m = P.varCount 0
  h_sumkLt : ‚àë i : Fin (M + 1), P.foldingParam i ‚â§ m
  h_varCount_i : ‚àÄ i : Fin (M + 1),
    P.varCount i = m - ‚àë j : Fin i, P.foldingParam (Fin.castLT j (Nat.lt_trans j.isLt i.isLt))
  h_smooth : ‚àÄ i : Fin (M + 1), Smooth (P.œÜ i)
  h_repeatPLt : ‚àÄ i : Fin (M + 1), P.repeatParam i ‚â§ Fintype.card (Œπ i)

def relayKStateProp (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i)
  (stmtIn : Statement (L := L) Context i.succ)
  (witMid : Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
  (oStmtIn : (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j))
  : Prop :=
  masterKStateProp (mp := mp) (œë := œë) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
    (stmtIdx := i.succ) (oracleIdx := i.succ)
    (h_le := le_refl _)
    (stmt := stmtIn) (wit := witMid) (oStmt := mapOStmtOutRelayStep
      ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hNCR oStmtIn)
    (localChecks := True)

@[reducible, simp]
def MessageIdxUpTo (k : Fin (n + 1)) (pSpec : ProtocolSpec n) : Type :=
  (pSpec‚ü¶:k.val‚üß).MessageIdx

@[reducible, inline, specialize]
def Messages' (pSpec : ProtocolSpec n) : Type :=
  ‚àÄ i, (hi : pSpec.dir i = .P_to_V) ‚Üí pSpec.¬´Type¬ª i

class NonBinaryField (F : Type*) extends Field F where
  char_neq_2 : (2 : F) ‚â† 0

@[inline] def mul [Zero T] [ToNat T] (a b : Cayley T) : Cayley T :=
  mulNat a ‚Üëb

def powMod (a b m : ‚Ñï) : ‚Ñï := Id.run do
  let mut x := a
  let mut n := b
  let mut res := 1

  while n > 0 do
    if n % 2 == 1 then
      res := (x * res) % m
    x := (x * x) % m
    n := n / 2

  return res

@[reducible, inline, specialize]
def Challenges' (pSpec : ProtocolSpec n) : Type :=
  ‚àÄ i, (hi : pSpec.dir i = .V_to_P) ‚Üí pSpec.¬´Type¬ª i

def generator : BaseField √ó BaseField := (1, 2)

False.elim in Init.Prelude

def rootMultiplicity‚ÇÄ.{u} {F : Type u} [Semiring F] [DecidableEq F] (f : F[X][Y]) : Option ‚Ñï :=
  let deg := weightedDegree f 1 1
  match deg with
  | none => none
  | some deg => List.max?
    (List.map
      (fun x => if coeff f x.1 x.2 ‚â† 0 then x.1 + x.2 else 0)
      (List.product (List.range deg.succ) (List.range deg.succ)))

abbrev ScalarField := ZMod scalarFieldSize

@[reducible]
def CanonicalDuplexSponge (U : Type) [SpongeUnit U] [SpongeSize] :=
  DuplexSponge U (CanonicalSpongeState U)

instance : ‚àÄ j, OracleInterface ((pSpecRelay).Message j)
  | ‚ü®x, hj‚ü© => by admit /- proof elided -/

instance instDCast : DCast Nat ProtocolSpec where
  dcast h := ProtocolSpec.cast h
  dcast_id := cast_id

private def k [Zero F] (B : Finset (Fin n ‚Üí F)) : ‚Ñö :=
  (1 : ‚Ñö) / n * ‚àë i, K B i 0

abbrev rtake (m : ‚Ñï) (h : m ‚â§ n)
    (transcript : FullTranscript pSpec) : FullTranscript (pSpec.rtake m h) :=
  Fin.rtake m h transcript

finSuccEquiv' in Mathlib.Logic.Equiv.Fin.Basic

def Œ±' (x‚ÇÄ : F) (R : F[X][X][Y]) (H_irreducible : Irreducible H) (t : ‚Ñï) : ùïÉ H :=
  Œ± x‚ÇÄ R _ (œÜ := ‚ü®H_irreducible‚ü©) t

instance {Œπ : Type u} (v : Œπ ‚Üí Type v) [O : ‚àÄ i, OracleInterface (v i)]
    [h : ‚àÄ i, DecidableEq (Query (v i))]
    [h' : ‚àÄ i, DecidableEq (Response (v i))] :
    [v]‚Çí.DecidableEq where
  domain_decidableEq' := h
  range_decidableEq' := h'

structure SparseMatrix (m n Œ± : Type*) where
  numEntries : ‚Ñï
  row : Fin numEntries ‚Üí m
  col : Fin numEntries ‚Üí n
  val : Fin numEntries ‚Üí Œ±
deriving Inhabited, DecidableEq

abbrev Field := ZMod fieldSize

def projection (S : Finset n) (w : n ‚Üí R) : S ‚Üí R :=
  fun i => w i.val

@[reducible, simp] def OStmtAfterSendClaim : Unit ‚äï Unit ‚Üí Type := fun _ => R‚¶É‚â§ deg‚¶Ñ[X]

instance : SMul R (UniPoly R) := ‚ü®UniPoly.smul‚ü©

Or.inr in Init.Prelude

@[ext]
class OracleInterface (Message : Type u) where
  Query : Type v
  Response : Type w
  answer : Message ‚Üí Query ‚Üí Response

Nat.Prime in Mathlib.Data.Nat.Prime.Defs

def peval (f : œÉ ‚Üí œÉ‚ÇÅ ‚äï œÉ‚ÇÇ) (x : œÉ‚ÇÅ ‚Üí R) : MvPolynomial œÉ R ‚Üí+* MvPolynomial œÉ‚ÇÇ R :=
  eval‚ÇÇHom C (Sum.elim (fun i => C (x i)) X ‚àò f)

noncomputable instance (‚Ñì : Nat) : AddCommGroup (CoeffVecSpace L ‚Ñì) :=

def LawfulInterleavedCode (Œ∫ : Type*) [Fintype Œ∫] (Œπ : Type*) [Fintype Œπ]
                          (F : Type*) [Semiring F] :=
  { IC : InterleavedCode Œ∫ Œπ F // IC.isInterleaved }

Array.foldl in Init.Data.Array.Basic

ZMod in Mathlib.Data.ZMod.Defs

OracleSpec.append in VCVio.OracleComp.OracleSpec

def NestedList (n : ‚Ñï) : Type := dfoldr' n (fun _ => Type) (fun _ T => List T) Nat

example : NestedList 0 = Nat := rfl
example (n : ‚Ñï) : NestedList (n + 1) = List (NestedList n) := rfl

@[reducible, simp]
def knowledgeSoundness
    (relation : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (verifier : OracleVerifier oSpec Statement OStatement Bool (fun _ : Empty => Unit) pSpec)
    (knowledgeError : ‚Ñù‚â•0) : Prop :=
  verifier.toVerifier.knowledgeSoundness init impl relation acceptRejectOracleRel knowledgeError

@[inline] def pred [Zero T] [ToNat T] (a : Cayley T) : Cayley T :=
  match (‚Üëa : Nat) with
  | 0 => zero
  | Nat.succ n => ofNat n

instance : ‚àÄ i, SelectableType (Challenge !p[] i) :=
  fun ‚ü®i, h‚ü© =>
    (Fin.elim0 i : (h' : !p[].dir i = .V_to_P) ‚Üí SelectableType (!p[].Challenge ‚ü®i, h'‚ü©)) h

instance : Add (Cayley T) where
  add := add

@[inline, specialize]
def Prover.runToRoundFS [‚àÄ i, VCVCompatible (pSpec.Challenge i)] (i : Fin (n + 1))
    (stmt : StmtIn) (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec)
    (state : prover.PrvState 0) :
        OracleComp (oSpec ++‚Çí fsChallengeOracle StmtIn pSpec)
          (pSpec.MessagesUpTo i √ó StmtIn √ó prover.PrvState i) :=
  Fin.induction
    (pure ‚ü®default, stmt, state‚ü©)
    prover.processRoundFS
    i

MvPolynomial.aeval in Mathlib.Algebra.MvPolynomial.Eval

def JohnsonDenominator (B : Finset (Fin n ‚Üí F)) (v : Fin n ‚Üí F) : ‚Ñö :=
  let e := e B v
  let d := d B
  let q : ‚Ñö := Fintype.card F
  let frac := q / (q - 1)
  (1- frac * e/n) ^ 2 - (1 - frac * d/n)

instance {i : Fin ‚Ñì} : ‚àÄ j, SelectableType ((pSpecFoldCommit ùîΩq Œ≤
  (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i).Challenge j) := instSelectableTypeChallengeAppend

IsDomain in Mathlib.Algebra.Ring.Defs

instance {Œ± : Type u} [ToNat Œ±] : CoeHead Œ± Nat where
  coe := ToNat.toNat

Fin.succ in Init.Data.Fin.Basic

Fin.succAbove in Mathlib.Data.Fin.SuccPred

def SumFunEquivProd (Œ± Œ≤ Œ≥ : Type) : ((Œ± ‚äï Œ≤) ‚Üí Œ≥) ‚âÉ (Œ± ‚Üí Œ≥) √ó (Œ≤ ‚Üí Œ≥) :=
{ toFun := fun f => (fun a => f (.inl a), fun b => f (.inr b))
  , invFun := fun p x => match x with | .inl a => p.fst a | .inr b => p.snd b
  , left_inv := by admit /- proof elided -/

noncomputable def getSumcheckRoundPoly (i : Fin ‚Ñì) (h : ‚Ü•L‚¶É‚â§ 2‚¶Ñ[X Fin (‚Ñì - ‚Üëi.castSucc)])
    : L‚¶É‚â§ 2‚¶Ñ[X] :=

Polynomial.evalEval in Mathlib.Algebra.Polynomial.Bivariate

@[reducible]
def relation :
    (Fin sz.n_x ‚Üí R) ‚Üí 
    (MatrixIdx ‚Üí Matrix (Fin sz.m) (Fin sz.n) R) ‚Üí 
    (Fin sz.n_w ‚Üí R) ‚Üí 
    Prop :=
  fun stmt matrix wit =>
    letI ùï´ := ùï´ stmt wit
    (matrix .A *·µ• ùï´) * (matrix .B *·µ• ùï´) = (matrix .C *·µ• ùï´)

instance {s} : Functor (fun Œ± => LeafData Œ± s) where
  map f x := x.map f

abbrev Bwd : PermuteDir := Sum.inr ()

def linearMvExtension :
  Polynomial.degreeLT F (2^m) ‚Üí‚Çó[F] MvPolynomial (Fin m) F where
    
    toFun p := (p : Polynomial F).sum fun i a =>
      MvPolynomial.monomial (bitExpo i) a
    map_add' := by admit /- proof elided -/

Subsingleton in Init.Core

instance (s : Finset œÉ) : Fintype { x : œÉ | x ‚àà s } :=

instance : Fact (Nat.Prime baseFieldSize) := ‚ü®BaseField_is_prime‚ü©

Lean.Name in Init.Prelude

Subtype.eq_iff in Init.Ext

def totalNumPermQueriesMessage : Nat :=
  ‚àë i, pSpec.L‚Çö·µ¢ i

def OracleVerifier.addSalt (V : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec) :
    OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut (pSpec.addSalt Salt) where
  verify := fun stmtIn challenges => sorry
  
  
  embed := sorry
  hEq := sorry

def SkeletonNodeIndex.depth {s : Skeleton} : SkeletonNodeIndex s ‚Üí Nat
  | SkeletonNodeIndex.ofLeaf => 0
  | SkeletonNodeIndex.ofInternal => 0
  | SkeletonNodeIndex.ofLeft idxLeft => idxLeft.depth + 1
  | SkeletonNodeIndex.ofRight idxRight => idxRight.depth + 1

noncomputable def decode : (ReedSolomon.code domain deg) ‚Üí‚Çó[F] F[X] :=
  domRestrict
    (interpolate (domain := domain))
    (ReedSolomon.code domain deg)

AdjoinRoot.powerBasis' in Mathlib.RingTheory.AdjoinRoot

@[reducible, simp] def StmtIn : Type := R

@[reducible, simp] def OStmtOut := fun _ : Fin 2 => OStatement

abbrev SEP_CHAR : Char := Char.ofNat 0

def externalLinearLayer (state : Vector KoalaBear.Field params.width) :
    Vector KoalaBear.Field params.width :=
  
  let chunks := Vector.Matrix.ofFlatten (state.cast (params.widthDiv4_mul_4_eq_width).symm)
  let chunksAfterM4 := chunks.map (fun chunk => applyM4 chunk)

  
  

  
  let transposedMatrix := Vector.Matrix.transpose chunksAfterM4

  
  let columnSums := transposedMatrix.map (fun col => col.foldl (¬∑ + ¬∑) 0)

  
  let chunksAfterDiffusion := chunksAfterM4.map (fun row => row.zipWith (¬∑ + ¬∑) columnSums)

  
  (Vector.flatten chunksAfterDiffusion).cast (params.widthDiv4_mul_4_eq_width)

instance {Œ± : Type*} {n : ‚Ñï} [VCVCompatible Œ±] : VCVCompatible (Vector Œ± n) where

@[reducible, simp] def OStmtIn := fun _ : Fin 2 => OStatement

Finset.univ in Mathlib.Data.Fintype.Defs

def deterministicMillerRabin (n : ‚Ñï) : Bool := Id.run do
  if n ‚â§ 2 ‚à® n % 2 = 0 then
    return n = 2

  let ‚ü®s, d‚ü© := factorOutTwos (n - 1)
  for a in millerRabinBases do
    if a % n == 0 then
      continue

    let mut x := powMod a d n
    if x = 1 ‚à® x = n - 1 then
      continue

    for _ in [0:s] do
      x := (x * x) % n
      if x == n - 1 ‚à® x ‚â§ 1 then
        break
    if x ‚â† n - 1 then
      return false

  return true

def discr_y {F : Type} [CommRing F] (f : F[X][Y]) : F[X] :=
   
  Classical.choose (resultant_is_divisible_by_leadingCoeff f)

Polynomial.toFinsupp in Mathlib.Algebra.Polynomial.Basic

def acceptRejectOracleRel : Set ((Bool √ó (‚àÄ _ : Empty, Unit)) √ó Unit) :=
  { ((true, isEmptyElim), ()) }

class ProverFirst (pSpec : ProtocolSpec n) [NeZero n] where
  prover_first' : pSpec.dir 0 = .P_to_V

noncomputable instance changeOfBasisMatrix_invertible
  (‚Ñì : Nat) (h_‚Ñì : ‚Ñì ‚â§ r) :
  Invertible (changeOfBasisMatrix ùîΩq Œ≤ ‚Ñì h_‚Ñì) :=

noncomputable def liftBivariate {H : F[X][Y]} : F[X][Y] ‚Üí+* ùïÉ H :=
  RingHom.comp (Ideal.Quotient.mk (Ideal.span {H_tilde H})) bivPolyHom

Polynomial.derivative in Mathlib.Algebra.Polynomial.Derivative

instance : Field ScalarField := ZMod.instField scalarFieldSize

def SkeletonNodeIndex.isLeaf {s : Skeleton} (idx : SkeletonNodeIndex s) : Bool :=
  match idx with
  | SkeletonNodeIndex.ofLeaf => true
  | SkeletonNodeIndex.ofInternal => false
  | SkeletonNodeIndex.ofLeft _ => false
  | SkeletonNodeIndex.ofRight _ => false

noncomputable def batchOracleReduction :
  OracleReduction []‚Çí
    Unit (OracleStatement D x m) (Witness F s d m)
    ((Fin m ‚Üí F) √ó Fri.Spec.Statement F (0 : Fin (k + 1)))
    (OracleStatement D x m)
    (Fri.Spec.Witness F s d (0 : Fin (k + 2)))
    (batchSpec F m) where
  prover := batchProver D x s d m
  verifier := batchVerifier (k := k) D x m

@[reducible]
def fieldSize : Nat := 2 ^ 31 - 1

@[reducible]
def CanonicalSpongeState (U : Type) [SpongeUnit U] [SpongeSize] : Type :=
  Vector U SpongeSize.N

def coreInteractionOracleRbrKnowledgeError (j : (pSpecCoreInteraction ùîΩq Œ≤ (œë := œë)
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).ChallengeIdx) : ‚Ñù‚â•0 :=
    Sum.elim
      (f := fun i => sumcheckFoldKnowledgeError ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)
      (g := fun i => finalSumcheckKnowledgeError (L := L) i)
      (ChallengeIdx.sumEquiv.symm j)

def rho (n : ‚Ñï) : Option ‚Ñï := Id.run do
  for st in [2:n] do
    for c in [1:n] do
      if let some d := rho' n st c then
        return some d

  return none

ToString in Init.Data.ToString.Basic

Nat.iterate in Mathlib.Logic.Function.Iterate

Inv in Init.Prelude

@[inline, specialize]
def OracleVerifier.run [O‚Çò : ‚àÄ i, OracleInterface (pSpec.Message i)]
    (stmt : StmtIn) (oStmtIn : ‚àÄ i, OStmtIn i) (transcript : FullTranscript pSpec)
    (verifier : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec) :
      OracleComp oSpec (StmtOut √ó (‚àÄ i, OStmtOut i)) := do
  let f := OracleInterface.simOracle2 oSpec oStmtIn transcript.messages
  let stmtOut ‚Üê simulateQ f (verifier.verify stmt transcript.challenges)
  let oStmtOut : ‚àÄ i, OStmtOut i := fun i => match h : verifier.embed i with
  | .inl j => by admit /- proof elided -/
  | .inr j => by admit /- proof elided -/

Unit in Init.Prelude

def eval‚ÇÇAlgHom {A B : Type*} [CommSemiring A] [CommSemiring B] [MvPolynomialLike œÉ A P]
    [Algebra R A] [IsScalarTower R A P] [Algebra R B]
    (f : A ‚Üí‚Çê[R] B) (g : œÉ ‚Üí B) : P ‚Üí‚Çê[R] B where
  toRingHom := eval‚ÇÇ f g
  commutes' r := by admit /- proof elided -/

Vector.finRange in Init.Data.Vector.FinRange

instance instDCast‚ÇÇSigma {Œ± : Type*} {Œ≤ : Œ± ‚Üí Type*} {Œ≥ : (a : Œ±) ‚Üí Œ≤ a ‚Üí Type*}
    {Œ¥ : (a : Œ±) ‚Üí (b : Œ≤ a) ‚Üí Œ≥ a b ‚Üí Type*}
    [DCast Œ± Œ≤] [DCast‚ÇÇ Œ± Œ≤ Œ≥] [DCast‚ÇÉ Œ± Œ≤ Œ≥ Œ¥] :
    DCast‚ÇÇ ((a : Œ±) √ó Œ≤ a) (fun a => Œ≥ a.1 a.2) (fun a => Œ¥ a.1 a.2) where
  dcast‚ÇÇ ha hb c := dcast‚ÇÉ (by admit /- proof elided -/
  ) (by admit /- proof elided -/
  ) (by admit /- proof elided -/
  ) c
  dcast‚ÇÇ_id := by admit /- proof elided -/

def equivProd {k : ‚Ñï} (h_k_pos : k > 0) :
  ConcreteBTField k ‚âÉ ConcreteBTField (k - 1) √ó ConcreteBTField (k - 1) where
  toFun := split h_k_pos
  invFun := fun (hi, lo) => „Ää hi, lo „Äã
  left_inv := fun x => Eq.symm (join_of_split h_k_pos x _ _ rfl)
  right_inv := fun ‚ü®hi, lo‚ü© => Eq.symm (split_of_join h_k_pos _ hi lo rfl)

def powAlgHom :
  MvPolynomial (Fin m) F ‚Üí‚Çê[F] Polynomial F :=
   aeval fun j => Polynomial.X ^ (2 ^ (j : ‚Ñï))

instance [NeZero k] {f : Fin k ‚Üí Œπ ‚Üí F} : Nonempty (Finset.univ.image f) :=

def dist' (C : Set (n ‚Üí R)) [Fintype C] : ‚Ñï‚àû :=
  Finset.min <| ((@Finset.univ (C √ó C) _).filter (fun p => p.1 ‚â† p.2)).image
    (fun ‚ü®u, v‚ü© => hammingDist u.1 v.1)

@[reducible, simp]
def pSpec : ProtocolSpec 1 := ‚ü®!v[.P_to_V], !v[Witness]‚ü©

def prover : OracleProver oSpec (StmtIn R) (OStmtIn R deg) Unit (StmtOut R) (OStmtOut R deg) Unit
    (pSpec R deg) where
  PrvState
    | 0 => R‚¶É‚â§ deg‚¶Ñ[X]
    | 1 => R‚¶É‚â§ deg‚¶Ñ[X]
    | 2 => R‚¶É‚â§ deg‚¶Ñ[X] √ó R

  input := fun ‚ü®‚ü®_, oStmt‚ü©, _‚ü© => oStmt ()

  sendMessage
  | ‚ü®0, _‚ü© => fun polyLE => pure ‚ü®polyLE, polyLE‚ü©
  | ‚ü®1, h‚ü© => nomatch h

  receiveChallenge
  | ‚ü®0, h‚ü© => nomatch h
  | ‚ü®1, _‚ü© => fun polyLE => pure fun chal => ‚ü®polyLE, chal‚ü©

  output := fun ‚ü®polyLE, chal‚ü© => pure (((polyLE.val.eval chal, chal), fun _ => polyLE), ())

structure TowerEquivResult (k : ‚Ñï) where
  ringEquiv : ConcreteBTField k ‚âÉ+* BTField k
  ringEquivForwardMapEq : ringEquiv = towerRingHomForwardMap k

@[simp]
abbrev OracleStatement.AfterFirstMessage : R1CS.MatrixIdx ‚äï Fin 1 ‚Üí Type :=
  Sum.rec (OracleStatement R pp) (fun _ => Witness R pp)

def toVerifier : Verifier oSpec (StmtIn √ó ‚àÄ i, OStmtIn i) (StmtOut √ó (‚àÄ i, OStmtOut i)) pSpec where
  verify := fun ‚ü®stmt, oStmt‚ü© transcript => do
    let stmtOut ‚Üê simulateQ (OracleInterface.simOracle2 oSpec oStmt transcript.messages)
      (verifier.verify stmt transcript.challenges)
    letI oStmtOut := fun i => match h : verifier.embed i with
      | Sum.inl j => by admit /- proof elided -/
      | Sum.inr j => by admit /- proof elided -/

Neg in Init.Prelude

context in Examples.FrankingProtocol

@[simp]
def finRangeTo {k : ‚Ñï} (i : ‚Ñï) : Finset (Fin k) :=
  (List.take i (List.finRange k)).toFinset

class Memory (Œπ : Type u) (Œ± : Œπ ‚Üí Type v) (M : Type w) where
   
  read (m : M) (i : Œπ) : Œ± i
   
  write (m : M) (i : Œπ) (v : Œ± i) : M

noncomputable def P
  (Œ¥ : ‚Ñö) (x‚ÇÄ : F)
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  :
  F[Z][X] :=
  let v‚ÇÄ := Classical.choose (solution_gamma_is_linear_in_Z k (Œ¥ := Œ¥) (x‚ÇÄ := x‚ÇÄ) h_gs)
  let v‚ÇÅ := Classical.choose 
    (Classical.choose_spec <| solution_gamma_is_linear_in_Z k (Œ¥ := Œ¥) (x‚ÇÄ := x‚ÇÄ) h_gs)
  (
    (Polynomial.map Polynomial.C v‚ÇÄ) +
    (Polynomial.C Polynomial.X) * (Polynomial.map Polynomial.C v‚ÇÅ)
  )

def tileCoeffs (a : Fin (2 ^ ‚Ñì) ‚Üí L) : Fin (2^(‚Ñì + R_rate)) ‚Üí L :=
  fun v => a (Fin.mk (v.val % (2^‚Ñì)) (Nat.mod_lt v.val (pow_pos (zero_lt_two) ‚Ñì)))

def FullData.EquivIndexFun {Œ± : Type} (s : Skeleton) :
    FullData Œ± s ‚âÉ (SkeletonNodeIndex s ‚Üí Œ±) where
  toFun := fun tree idx => tree.get idx
  invFun := fun f => FullData.ofFun s f
  left_inv := by admit /- proof elided -/

minpoly in Mathlib.FieldTheory.Minpoly.Basic

def Option.doubleBind_v2 {Œ± Œ≤ Œ≥ : Type} (f : Œ± ‚Üí Œ≤ ‚Üí Option Œ≥)
    (x : Option Œ±) (y : Option Œ≤) : Option Œ≥ := do
  let a ‚Üê x
  let b ‚Üê y
  f a b

def lintStyleCli (args : Cli.Parsed) : IO UInt32 := do
  let style : ErrorFormat := match args.hasFlag "github" with
    | true => ErrorFormat.github
    | false => ErrorFormat.humanReadable
  let fix := args.hasFlag "fix"
  
  let mut allModuleNames := #[]
  for s in ["ArkLib.lean"] do
    allModuleNames := allModuleNames.append (‚Üê findImports s)
  
  allModuleNames := allModuleNames.erase `Batteries
  let mut numberErrors ‚Üê lintModules allModuleNames style fix
  if ‚Üê checkInitImports then numberErrors := numberErrors + 1
  
  
  
  
  if args.hasFlag "fix" then
    return 0
  else return min numberErrors 125

structure ConcreteBTFStepResult (k : ‚Ñï) extends (ConcreteBTFieldProps k) where
  instFintype : Fintype (ConcreteBTField k)
  fieldFintypeCard : Fintype.card (ConcreteBTField k) = 2^(2^k)
  
  sumZeroIffEq : ‚àÄ (x y : ConcreteBTField k), x + y = 0 ‚Üî x = y
  traceMapEvalAtRootsIs1 :
    letI := mkFieldInstance (k:=k) (props:=toConcreteBTFieldProps)
    TraceMapProperty (ConcreteBTField k) (u:=Z k) k
  instIrreduciblePoly :
    letI := mkFieldInstance (k:=k) (props:=toConcreteBTFieldProps)
    (Irreducible (p := (definingPoly (s:=(Z k)))))

def divSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (k : Fin (‚àë j, n j)) : Fin m :=
  (divSum? n k).get (divSum?_is_some_iff_lt_sum.mpr k.isLt)

def churchCons (x : Œ±) (xs : ChurchVec Œ±) : ChurchVec Œ± :=
  fun f base => f x (xs f base)

def FullTranscript.extractSalt (transcript : (pSpec.addSalt Salt).FullTranscript) :
    (i : pSpec.MessageIdx) ‚Üí Salt i :=
  Transcript.extractSalt (pSpec := pSpec) (k := Fin.last n) transcript

def modByMonic [Field R] (p : UniPoly R) (q : UniPoly R) :
    UniPoly R :=
  (divModByMonicAux p q).2

noncomputable def sDomain_basis (i : Fin r) (h_i : i < ‚Ñì + R_rate) :
    Basis (Fin (‚Ñì + R_rate - i)) ùîΩq (
      sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i) :=

noncomputable def ElocPolyF (œâs f : Fin n ‚Üí F) (p : Polynomial F) : Polynomial F :=
  ElocPoly n (liftF œâs) (liftF f) p

def ar2 (k0 k1 : ‚Ñï) : Fin 2 ‚Üí ‚Ñï
  | ‚ü®0, _‚ü© => k0
  | ‚ü®1, _‚ü© => k1

def towerOfExponents (g : G) (a : ZMod p) (n : ‚Ñï) : Vector G (n + 1) :=
  .ofFn (fun i => g ^ (a.val ^ i.val))

def getNextOracle (i : Fin (‚Ñì + 1))
    (oStmt : ‚àÄ j, (OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i) j)
    (j : Fin (toOutCodewordsCount ‚Ñì œë i)) (hj : j.val + 1 < toOutCodewordsCount ‚Ñì œë i) :
    OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®j.val * œë + œë, by
    apply Nat.lt_succ_of_le;
    let h_k_next_le_i := oracle_block_k_next_le (‚Ñì := ‚Ñì) (œë := œë) (i := i) (j := j) (hj := hj)
    calc _ ‚â§ i.val := h_k_next_le_i
      _ ‚â§ ‚Ñì := Fin.is_le i
  ‚ü© :=

instance {k : ‚Ñï} : NatCast (ConcreteBTField k) where
  natCast n:= natCast n

instance (k : ‚Ñï) : DecidableEq (ConcreteBTField k) :=
  fun x y =>
    let p := BitVec.toNat x = BitVec.toNat y
    let q := x = y
    let hp : Decidable p := Nat.decEq (BitVec.toNat x) (BitVec.toNat y)
    let h_iff_pq : p ‚Üî q := (BitVec.toNat_eq).symm 
    match hp with
    | isTrue (proof_p : p) =>
      
      
      isTrue (h_iff_pq.mp proof_p)
    | isFalse (nproof_p : ¬¨p) =>
      
      
      
      
      isFalse (fun (proof_q : q) => nproof_p (h_iff_pq.mpr proof_q))

instance (k : ‚Ñï) : Fintype (ConcreteBTField k) := (getBTFResult k).instFintype

Polynomial.reverse in Mathlib.Algebra.Polynomial.Reverse

OracleComp.construct in VCVio.OracleComp.OracleComp

IsUnit in Mathlib.Algebra.Group.Units.Defs

def InternalData.EquivIndexFun {Œ± : Type} (s : Skeleton) :
    InternalData Œ± s ‚âÉ (SkeletonInternalIndex s ‚Üí Œ±) where
  toFun := fun tree idx => tree.get idx
  invFun := fun f => InternalData.ofFun s f
  left_inv := by admit /- proof elided -/

noncomputable def rate [Semiring F] (LC : LinearCode Œπ F) : ‚Ñö‚â•0 :=
  (dim LC : ‚Ñö‚â•0) / length LC

noncomputable def polynomialFromNovelCoeffs (‚Ñì : ‚Ñï) (h_‚Ñì : ‚Ñì ‚â§ r)
  (a : Fin (2 ^ ‚Ñì) ‚Üí L) : L[X] := ‚àë j, C (a j) * (X‚±º ùîΩq Œ≤ ‚Ñì h_‚Ñì j)

def implGroupOpOracle : QueryImpl (GroupOpOracle Œπ) (StateT (GroupValTable Œπ G) Option) where
  impl | query _ ‚ü®i, j, k‚ü© => fun table =>
    match table i, table j with
    | some g‚ÇÅ, some g‚ÇÇ => some ((), table.update k (some (g‚ÇÅ * g‚ÇÇ)))
    | _, _ => none

@[reducible]
def foldCommitOracleVerifier (i : Fin ‚Ñì) (hCR : isCommitmentRound ‚Ñì œë i) :
  OracleVerifier []‚Çí
    (StmtIn := Statement (L := L) Context i.castSucc)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.succ)
    (pSpec := pSpecFoldCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) :=
    OracleVerifier.append (oSpec:=[]‚Çí)
      (pSpec‚ÇÅ := pSpecFold (L:=L))
      (pSpec‚ÇÇ := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)
      (V‚ÇÅ := foldOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)
      (V‚ÇÇ := commitOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hCR)

def removeRedundantEntryDS (log : QueryLog (duplexSpongeChallengeOracle StmtIn U)) :
    {log : QueryLog (duplexSpongeChallengeOracle StmtIn U) | log.NoRedundantEntryDS} :=
  sorry

def Equiv.precomp {Œ± Œ≤ Œ≥} (e : Œ± ‚âÉ Œ≤) : (Œ≤ ‚Üí Œ≥) ‚âÉ (Œ± ‚Üí Œ≥) :=
{ toFun := fun f a => f (e a)
  , invFun := fun g b => g (e.invFun b)
  , left_inv := by admit /- proof elided -/

@[inline]
def ofOutputOnly
    (liftStmt : OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i) ‚Üí InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i) ‚Üí
                OuterStmtOut √ó (‚àÄ i, OuterOStmtOut i)) :
    OracleStatement.Lens OuterStmtIn OuterStmtOut OuterStmtIn InnerStmtOut
                        OuterOStmtIn OuterOStmtOut OuterOStmtIn InnerOStmtOut :=
  ‚ü®id, liftStmt‚ü©

@[inline, reducible]
def proj : OuterStmtIn √ó OuterWitIn ‚Üí InnerWitIn :=
  lens.toFunA

Nat.reducePow in Lean.Meta.Tactic.Simp.BuiltinSimprocs.Nat

instance (k : ‚Ñï) : NeZero (2^k) :=

@[reducible]
def MemoryWrite (Œπ : Type u) (Œ± : Œπ ‚Üí Type v) := (index : Œπ) √ó (Œ± index)

def monomialY (n : ‚Ñï) : F[X] ‚Üí‚Çó[F[X]] F[X][Y] where
  toFun t := ‚ü®Finsupp.single n t‚ü©
  map_add' x y := by admit /- proof elided -/

instance instSetoidUniPoly : Setoid (UniPoly R) where
  r := equiv
  iseqv := instEquivalenceEquiv

@[inline]
def smul [Mul R] (r : R) (p : MlPolyEval R n) : MlPolyEval R n := p.map (fun a => r * a)

noncomputable def fold_k_set
  {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F} {k m : ‚Ñï}
  [‚àÄ j : ‚Ñï, Neg (indexPowT S œÜ j)]
  (set : Set ((indexPowT S œÜ 0) ‚Üí F)) (Œ±s : Fin k ‚Üí F) (hk : k ‚â§ m): Set (indexPowT S œÜ k ‚Üí F) :=
    { g | ‚àÉ f ‚àà set, g = fold_k f Œ±s hk}

ZMod.charP in Mathlib.Data.ZMod.Basic

private def Fi (B : Finset (Fin n ‚Üí F)) (i : Fin n) (Œ± : F) : Finset (Fin n ‚Üí F) :=
  { x | x ‚àà B ‚àß x i = Œ± }

@[reducible]
def VectorIOP
    (Statement : Type) {Œπ‚Çõ : Type} (OStatement : Œπ‚Çõ ‚Üí Type) (Witness : Type)
    (vPSpec : ProtocolSpec.VectorSpec n) (A : Type)
    [‚àÄ i, OracleInterface (OStatement i)] :=
  OracleProof []‚Çí Statement OStatement Witness (vPSpec.toProtocolSpec A)

@[inline, specialize]
def add (p q : UniPoly R) : UniPoly R :=
  add_raw p q |> trim

def InnerStmtIn_Test := ‚Ñ§[X] √ó ‚Ñ§

Polynomial.C in Mathlib.Algebra.Polynomial.Basic

Irreducible in Mathlib.Algebra.Group.Irreducible.Defs

noncomputable def towerRingEquivFromConcrete0 : ConcreteBTField 0 ‚âÉ+* BTField 0 :=

def evalSetY [DecidableEq F] (f : F[X][Y]) (P : Finset F) [Nonempty P] : Finset (Polynomial F) :=
  P.image (fun a => evalY a f)

def matrixSubmoduleOfLinearCode (Œ∫ : Type*) [Fintype Œ∫]
                                (LC : LinearCode Œπ F) : MatrixSubmodule Œ∫ Œπ F :=
  Submodule.span F { V | ‚àÄ i, V i ‚àà LC }

Function.Bijective in Mathlib.Logic.Function.Defs

Coe in Init.Coe

ringChar.charP in Mathlib.Algebra.CharP.Defs

@[reducible]
def SimOracle.Stateless (spec : OracleSpec Œπ) (spec‚Çú : OracleSpec Œπ‚Çú) :=
  QueryImpl spec (OracleComp spec‚Çú)

@[elab_as_elim]
def dflatten {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {motive : (k : Fin (vsum n)) ‚Üí Sort*}
    (v : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí motive (embedSum i j)) (k : Fin (vsum n)) : motive k :=
  match m with
  | 0 => Fin.elim0 k
  | _ + 1 =>
    dappend
      (fun j => v 0 j)
      (fun j => dflatten (motive := fun j => motive (natAdd _ j)) (fun i => v i.succ) j)
      k

noncomputable def toMvPolynomialAlgHom : P ‚Üí‚Çê[R] MvPolynomial œÉ R := aeval MvPolynomial.X

def oracleWitnessConsistency
    (stmtIdx : Fin (‚Ñì + 1)) (oracleIdx : Fin (‚Ñì + 1))
    (h_le : oracleIdx.val ‚â§ stmtIdx.val) (stmt : Statement (L := L) (Context := Context) stmtIdx)
    (wit : Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) stmtIdx)
    (oStmt : ‚àÄ j, (OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      œë (i := oracleIdx) j)) : Prop :=
  let witnessStructuralInvariant: Prop := witnessStructuralInvariant (mp := mp) (i:=stmtIdx) ùîΩq Œ≤
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) stmt wit
  let sumCheckConsistency: Prop := sumcheckConsistencyProp (ùìë := ùìë) stmt.sumcheck_target wit.H
  let firstOracleConsistency: Prop := firstOracleWitnessConsistencyProp ùîΩq Œ≤
    wit.t (getFirstOracle ùîΩq Œ≤ oStmt)
  let oracleFoldingConsistency: Prop := oracleFoldingConsistencyProp ùîΩq Œ≤ oracleIdx
    (challenges := Fin.take (m := oracleIdx) (v := stmt.challenges) (h := by admit /- proof elided -/
    ))
    (oStmt := oStmt)
  witnessStructuralInvariant ‚àß sumCheckConsistency ‚àß firstOracleConsistency ‚àß
    oracleFoldingConsistency

noncomputable def listBlockRelDistance
  (i k : ‚Ñï) {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F} {œÜ' : (indexPowT S œÜ i) ‚Ü™ F}
  {m : ‚Ñï} [DecidableEq F] [DecidableEq Œπ] [Smooth œÜ]
  (f : (indexPowT S œÜ i) ‚Üí F) (S' : Finset (indexPowT S œÜ i))
  [‚àÄ i : ‚Ñï, Fintype (indexPowT S œÜ i)] [DecidableEq (indexPowT S œÜ i)] [Smooth œÜ']
  (C : Set ((indexPowT S œÜ i) ‚Üí F)) (_hcode : C = smoothCode œÜ' m) (Œ¥ : ‚Ñù‚â•0)
  [h : DecidableBlockDisagreement i k f S' œÜ'] : (Set ((indexPowT S œÜ i) ‚Üí F)) :=
    { u ‚àà C | Œî·µ£(i, k, f, S', œÜ', u) ‚â§ Œ¥ }

@[inline]
def nsmul [SMul ‚Ñï R] (m : ‚Ñï) (p : MlPolyEval R n) : MlPolyEval R n := p.map (fun a => m ‚Ä¢ a)

instance [VCVCompatible A] : ‚àÄ i, VCVCompatible ((vPSpec.toProtocolSpec A).Challenge i) :=
  fun _ => by admit /- proof elided -/

structure TraceMapProperty (F : Type*) [Field F] (u : F) (k : ‚Ñï) : Prop where
  element_trace : ‚àë i ‚àà Finset.range (2 ^ k), u ^ (2 ^ i) = 1
  inverse_trace : ‚àë i ‚àà Finset.range (2 ^ k), (u‚Åª¬π) ^ (2 ^ i) = 1

Vector.flatten in Init.Data.Vector.Basic

@[reducible, simp]
def completeness
    (relation : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (oracleProof : OracleProof oSpec Statement OStatement Witness pSpec)
    (completenessError : ‚Ñù‚â•0) : Prop :=
  OracleReduction.completeness init impl
    relation acceptRejectOracleRel oracleProof completenessError

def MlPoly.mk {R : Type*} (n : ‚Ñï) (v : Vector R (2 ^ n)) : MlPoly R n := v

def domainEnum (i : Fin (n + 1)) : Fin (2 ^ (n - i)) ‚Ü™ evalDomain D i :=
  ‚ü®domain D n i.1, domain_injective D i.1 (by admit /- proof elided -/
  )‚ü©

noncomputable def evenPart (f : Polynomial F) : Polynomial F :=
    C (2‚Åª¬π : F) * (f + f.comp (-X))

instance : Unique (MessagesUpTo 0 pSpec) where
  default := fun ‚ü®i, _‚ü© => Fin.elim0 i
  uniq := fun T => by admit /- proof elided -/

@[inline]
def ofArray [Zero R] (coeffs : Array R) (n : ‚Ñï) : MlPolyEval R n :=
  .ofFn (fun i => if h : i.1 < coeffs.size then coeffs[i] else 0)

private def Bi (B : Finset (Fin n ‚Üí F)) (i : Fin n) : Finset ((Fin n ‚Üí F) √ó (Fin n ‚Üí F)) :=
  { x | x ‚àà B √óÀ¢ B ‚àß x.1 i = x.2 i ‚àß x.1 ‚â† x.2 }

List in Init.Prelude

Algebra.TensorProduct.includeRight in Mathlib.RingTheory.TensorProduct.Basic

abbrev ScalarField := ZMod SCALAR_FIELD_CARD

dotProduct in Mathlib.Data.Matrix.Mul

@[reducible, inline]
instance (priority := low) instTensorForall {Œπ : Type u} (v : Œπ ‚Üí Type v)
    [O : ‚àÄ i, OracleInterface (v i)] : OracleInterface (‚àÄ i, v i) where
  Query := (i : Œπ) ‚Üí (O i).Query
  Response := (i : Œπ) ‚Üí (O i).Response
  answer := fun f q i => (O i).answer (f i) (q i)

@[inline]
def smul [Mul R] (r : R) (p : MlPoly R n) : MlPoly R n := p.map (fun a => r * a)

def bool (j : Fin numWires) : Gate ùì° numWires :=
  { qL := -1, qR := 0, qO := 0, qM := 1, qC := 0, a := j, b := j, c := j }

def zero : ChurchNat Œ± := fun _ x => x

def curve : WeierstrassCurve BaseField := {
  a‚ÇÅ := 0,  
  a‚ÇÇ := 0,  
  a‚ÇÉ := 0,  
  a‚ÇÑ := 0,  
  a‚ÇÜ := 3   
}

@[reducible, simp]
def completeness (relation : Set (Statement √ó Witness)) (completenessError : ‚Ñù‚â•0)
    (proof : Proof oSpec Statement Witness pSpec) : Prop :=
  Reduction.completeness init impl relation acceptRejectRel proof completenessError

@[reducible, inline]
instance instPolynomialDegreeLT : OracleInterface (R‚¶É< d‚¶Ñ[X]) where
  Query := R
  Response := R
  answer := fun ‚ü®poly, _‚ü© point => poly.eval point

def FullData.toLeafData {Œ± : Type} {s : Skeleton}
    (tree : FullData Œ± s) : LeafData Œ± s :=
  match tree with
  | FullData.leaf value => LeafData.leaf value
  | FullData.internal _ left right =>
    LeafData.internal (left.toLeafData) (right.toLeafData)

def DVec {m : Type v} (Œ± : m ‚Üí Type u) : Type (max u v) := ‚àÄ i, Œ± i

protected def cast
    (hO‚Çò : ‚àÄ i, O‚Çò‚ÇÅ i = dcast (Message.cast_idx hSpec) (O‚Çò‚ÇÇ (i.cast hn hSpec)))
    (V : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec‚ÇÅ) :
    OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec‚ÇÇ where
  verify := fun stmt challenges =>
    simulateQ sorry (V.verify stmt (dcast‚ÇÇ hn.symm (dcast_symm hn hSpec) challenges))
  embed := V.embed.trans
    (Embedding.sumMap
      (Equiv.refl _).toEmbedding
      ‚ü®MessageIdx.cast hn hSpec, MessageIdx.cast_injective hn hSpec‚ü©)
  hEq := fun i => by admit /- proof elided -/

Nat.reduceBEq in Lean.Meta.Tactic.Simp.BuiltinSimprocs.Nat

Fin.succEmb in Mathlib.Data.Fin.Embedding

def KnowledgeStateFunctionOneShot.toKnowledgeStateFunction
    {relIn : Set (StmtIn √ó WitIn)} {relOut : Set (StmtOut √ó WitOut)}
    {verifier : Verifier oSpec StmtIn StmtOut pSpec}
    (stF : KnowledgeStateFunctionOneShot init impl relIn.language relOut.language verifier)
    (oneShotE : Extractor.RoundByRoundOneShot oSpec StmtIn WitIn pSpec) :
    verifier.KnowledgeStateFunction init impl relIn relOut oneShotE.toRoundByRound where
  toFun := fun m stmtIn tr witIn => if m = 0 then (stmtIn, witIn) ‚àà relIn else
    stF.toFun m stmtIn tr ‚à® (stmtIn, oneShotE m stmtIn tr default) ‚àà relIn
  toFun_empty := fun stmtIn witIn => by admit /- proof elided -/

@[inline, reducible]
protected def id :
    Witness.Lens OuterStmtIn OuterStmtOut OuterWitIn OuterWitOut OuterWitIn OuterWitOut :=
  ‚ü®Prod.snd, fun _ => Prod.snd‚ü©

alias trivial := Witness.Lens.id

def verifyProof {n : ‚Ñï} (i : Fin (2 ^ n)) (leaf : Œ±) (root : Œ±) (proof : List.Vector Œ± n) :
    OracleComp (spec Œ±) Unit := do
  let putative_root ‚Üê getPutativeRoot Œ± i leaf proof
  guard (putative_root = root)

def extractability (scheme : Scheme oSpec Data Randomness Commitment pSpec)
    (extractabilityError : ‚Ñù‚â•0) : Prop :=
  ‚àÉ extractor : StraightlineExtractor oSpec Data Commitment,
  ‚àÄ AuxState : Type,
  ‚àÄ adversary : ExtractabilityAdversary oSpec Data Commitment AuxState,
  ‚àÄ prover : Prover oSpec (Commitment √ó O.Query √ó O.Response) AuxState Bool Unit pSpec,
    False

instance [Semiring R] : Module R (MlPolyEval R n) where
  smul := smul
  one_smul a := by admit /- proof elided -/

@[reducible]
noncomputable def fullOracleReduction :
  OracleReduction (oSpec:=[]‚Çí)
    (StmtIn := Statement (L := L) (‚Ñì:=‚Ñì) (SumcheckBaseContext L ‚Ñì) 0)
    (OStmtIn:= OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë 0)
    (StmtOut := Bool)
    (OStmtOut := fun _ : Empty => Unit)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) 0)
    (WitOut := Unit)
    (pSpec := fullPSpec ùîΩq Œ≤ Œ≥_repetitions (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)) :=
  OracleReduction.append (oSpec:=[]‚Çí)
    (Stmt‚ÇÅ := Statement (L := L) (‚Ñì:=‚Ñì) (SumcheckBaseContext L ‚Ñì) 0)
    (Stmt‚ÇÇ := FinalSumcheckStatementOut (L:=L) (‚Ñì:=‚Ñì))
    (Stmt‚ÇÉ := Bool)
    (Wit‚ÇÅ := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) 0)
    (Wit‚ÇÇ := Unit)
    (Wit‚ÇÉ := Unit)
    (OStmt‚ÇÅ := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë 0)
    (OStmt‚ÇÇ := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (OStmt‚ÇÉ := fun _ : Empty => Unit)
    (pSpec‚ÇÅ := pSpecCoreInteraction ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (pSpec‚ÇÇ := pSpecQuery ùîΩq Œ≤ Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (R‚ÇÅ := CoreInteraction.coreInteractionOracleReduction ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (œë:=œë) (ùìë:=ùìë))
    (R‚ÇÇ := QueryPhase.queryOracleReduction ùîΩq Œ≤ Œ≥_repetitions
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (œë:=œë))

Finset.val in Mathlib.Data.Finset.Defs

noncomputable def fiber_coeff
    (i : Fin r) (steps : ‚Ñï)
    (j : Fin (‚Ñì + ùì° - i)) (elementIdx : Fin (2 ^ steps))
    (y_coeffs : Fin (‚Ñì + ùì° - (i + steps)) ‚Üí‚ÇÄ ùîΩq) : ùîΩq :=
  if hj : j.val < steps then
    if Nat.getBit (k := j) (n := elementIdx) = 0 then 0 else 1
  else y_coeffs ‚ü®j.val - steps, by admit /- proof elided -/
    ‚ü©

structure DomainSeparator (U : Type) [SpongeUnit U] (H : Type*) [DuplexSpongeInterface U H] where
   
  io : String
deriving Repr

Module.Basis.reindex in Mathlib.LinearAlgebra.Basis.Defs

def generateProof {n : ‚Ñï} (i : Fin (2 ^ n)) (cache : Cache Œ± n) :
    List.Vector Œ± n :=
  match n with
  | 0 => List.Vector.nil
  | n + 1 => List.Vector.snoc (generateProof ‚ü®i.val / 2, by admit /- proof elided -/
  ‚ü© (cache.upper))
                              ((cache.leaves).get (findNeighbors i (Fin.last _)))

structure ModifiedGuruswami
  (m n k : ‚Ñï)
  (œâs : Fin n ‚Ü™ F)
  (Q : F[Z][X][Y])
  (u‚ÇÄ u‚ÇÅ : Fin n ‚Üí F)
  where
  Q_ne_0 : Q ‚â† 0
   
  Q_deg : natWeightedDegree Q 1 k < D_X ((k + 1) / (n : ‚Ñö)) n m
   
  Q_multiplicity : ‚àÄ i, rootMultiplicity Q
              (Polynomial.C <| œâs i)
              ((Polynomial.C <| u‚ÇÄ i) + Polynomial.X * (Polynomial.C <| u‚ÇÅ i))
            ‚â• m
   
  Q_deg_X :
    degreeX Q < D_X ((k + 1) / (n : ‚Ñö)) n m
   
  Q_D_Y :
    D_Y Q < D_X (k + 1 / (n : ‚Ñö)) n m / k
   
  Q_D_YZ :
    D_YZ Q ‚â§ n * (m + 1/(2 : ‚Ñö))^3 / (6 * Real.sqrt ((k + 1) / n))

instance : SliceLT (ProtocolSpec n) ‚Ñï
    (fun _ stop => stop ‚â§ n)
    (fun _ stop _ => ProtocolSpec stop)
    where
  sliceLT := fun v stop h => take stop h v

instance {k : ‚Ñï} : NeZero (1 : ConcreteBTField k) :=

def univPolyHom {F : Type} [CommRing F] [IsDomain F] : F[X] ‚Üí+* RatFunc F :=
  algebraMap (F[X]) (RatFunc F)

Finsupp.mapRange in Mathlib.Data.Finsupp.Defs

def Œ≥' (x‚ÇÄ : F) (R : F[X][X][Y]) (H_irreducible : Irreducible H) : PowerSeries (ùïÉ H) :=
  Œ≥ x‚ÇÄ R H (œÜ := ‚ü®H_irreducible‚ü©)

@[simp]
def ùïè (k : ‚Ñï) : ConcreteBTField (k + 1) := Z (k + 1)

structure GaloisAutomorphism (F : Type*) [Field F] (u : F) (k : ‚Ñï) : Prop where
  forward : u ^ (2 ^ (2 ^ k)) = u‚Åª¬π
  reverse : (u‚Åª¬π) ^ (2 ^ (2 ^ k)) = u

Algebra.id in Mathlib.Algebra.Algebra.Defs

noncomputable def discriminant {F : Type} [Field F] [Inhabited F] (f : F[X]) : F :=
  1/f.leadingCoeff * Polynomial.resultant f (Polynomial.derivative f)

@[inline] def add (a b : AssocNat) : AssocNat :=
  ‚ü®a ‚àò b, by admit /- proof elided -/
  ‚ü©

UInt8 in Init.Prelude

instance domain_neg_inst {i : Fin n} : Neg (evalDomain D i.1) where
  neg := fun x => ‚ü®_, minus_one_in_doms D i.2‚ü© * x

@[reducible]
def GroupDecodeOracle : OracleSpec Unit := fun _ => (BitVec bitLength √ó Œπ, Unit)

List.finRange in Init.Data.List.FinRange

def fflatten‚ÇÇ {A : Sort u} {B : Sort v} {F : A ‚Üí B ‚Üí Sort w} {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï}
    {Œ± : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí A} {Œ≤ : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí B}
    (v : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí F (Œ± i j) (Œ≤ i j)) :
    (k : Fin (vsum n)) ‚Üí F (Fin.vflatten Œ± k) (Fin.vflatten Œ≤ k) :=
  match m with
  | 0 => !h[]
  | _ + 1 => fappend‚ÇÇ (v 0) (fflatten‚ÇÇ (fun i => v i.succ))

Algebra.cast in Mathlib.Algebra.Algebra.Defs

Sum.isLeft in Init.Data.Sum.Basic

@[simp]
def outerRelIn_Test : Set (OuterStmtIn_Test √ó Unit) :=
  setOf (fun ‚ü®‚ü®p, q, t‚ü©, _‚ü© => ‚àë x ‚àà {0, 1}, (p * q).eval x = t)

class Initialize (Œ± : Type u) (Œ≤ : Type v) where
   
  new : Œ≤ ‚Üí Œ±

@[reducible]
def GroupEqOracle : OracleSpec Unit := fun _ => (Œπ √ó Œπ, Bool)

def oracleFoldingConsistencyProp (i : Fin (‚Ñì + 1)) (challenges : Fin i ‚Üí L)
    (oStmt : ‚àÄ j, (OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i) j) : Prop :=
  ‚àÄ (j : Fin (toOutCodewordsCount ‚Ñì œë i)) (hj : j.val + 1 < toOutCodewordsCount ‚Ñì œë i),
    
    have h_k_bound := oracle_block_k_bound (‚Ñì := ‚Ñì) (œë := œë) (i := i) (j := j)
    have h_k_next_le_i := oracle_block_k_next_le (‚Ñì := ‚Ñì) (œë := œë) (i := i) (j := j) (hj := hj)
    
    isCompliant (i := ‚ü®j.val * œë, by admit /- proof elided -/
    ‚ü©) (steps := œë)
      (h_i_add_steps := by admit /- proof elided -/
      )
      (f_i := oStmt ‚ü®j.val, by admit /- proof elided -/
      ‚ü©)
      (f_i_plus_steps := getNextOracle ùîΩq Œ≤ i oStmt j hj)
      (challenges := getFoldingChallenges (r := r) (ùì° := ùì°) i challenges (k := j.val * œë)
        (h := h_k_next_le_i))

Rat in Init.Data.Rat.Basic

List.idxOf in Init.Data.List.Basic

instance [Zero T] [One T] [ToNat T] : NatPow (Cayley T) where
  pow := powNat

noncomputable def matching_set
  (œâs : Fin n ‚Ü™ F)
  (Œ¥ : ‚Ñö)
  (u‚ÇÄ u‚ÇÅ : Fin n ‚Üí F)
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  : Finset F := (exists_a_set_and_a_matching_polynomial k h_gs (Œ¥ := Œ¥)).choose

@[ext]
structure ProverInput (StmtIn WitIn PrvState : Type) where
  input : StmtIn √ó WitIn ‚Üí PrvState

noncomputable def commitOracleVerifier (i : Fin ‚Ñì) (hCR : isCommitmentRound ‚Ñì œë i) :
  OracleVerifier
    (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) Context i.succ)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (O‚Çò := fun i => by admit /- proof elided -/
    )
    
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (pSpec := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) where

  
  
  verify := fun stmtIn pSpecChallenges => do
    pure stmtIn

  embed := ‚ü®fun j => by admit /- proof elided -/
  ‚ü©
  hEq := fun oracleIdx => by admit /- proof elided -/

class RoundByRoundOneShot.IsMonotone (E : RoundByRoundOneShot oSpec StmtIn WitIn pSpec)
    (relIn : Set (StmtIn √ó WitIn)) where
  is_monotone : ‚àÄ roundIdx stmtIn transcript,
    ‚àÄ proveQueryLog‚ÇÅ proveQueryLog‚ÇÇ : oSpec.QueryLog,
    
    proveQueryLog‚ÇÅ.Sublist proveQueryLog‚ÇÇ ‚Üí
    
    
    (stmtIn, E roundIdx stmtIn transcript proveQueryLog‚ÇÅ) ‚àà relIn ‚Üí
      (stmtIn, E roundIdx stmtIn transcript proveQueryLog‚ÇÇ) ‚àà relIn

WithTop in Mathlib.Order.TypeTags

instance instPow {n : ‚Ñï} : Pow (CNat n) Nat := match n with
  | 0 => by admit /- proof elided -/
  | .succ n => by admit /- proof elided -/

@[reducible]
def addSalt (pSpec : ProtocolSpec n) (Salt : pSpec.MessageIdx ‚Üí Type) :
    ProtocolSpec n :=
  ‚ü®pSpec.dir, fun i => match hDir : pSpec.dir i with
    | .P_to_V => (pSpec.¬´Type¬ª i) √ó Salt ‚ü®i, hDir‚ü©
    | .V_to_P => pSpec.¬´Type¬ª i‚ü©

instance instFieldConcrete {k : ‚Ñï} : Field (ConcreteBTField k) :=
  mkFieldInstance (getBTFResult k).toConcreteBTFieldProps

def add {k : ‚Ñï} (x y : ConcreteBTField k) : ConcreteBTField k := BitVec.xor x y

instance instAlgebraLiftConcreteBTField (k : ‚Ñï)
  (prevBTFResult : ConcreteBTFStepResult (k := k)) :
  letI := mkFieldInstance (prevBTFResult.toConcreteBTFieldProps)
  letI := liftConcreteBTField (k:=k) prevBTFResult
  Algebra (ConcreteBTField k) (ConcreteBTField (k + 1)) :=
  letI := mkFieldInstance (prevBTFResult.toConcreteBTFieldProps)
  letI := liftConcreteBTField (k:=k) prevBTFResult
  RingHom.toAlgebra (R:=ConcreteBTField k) (S:=ConcreteBTField (k + 1))
    (i:=(concreteCanonicalEmbedding (k:=k)
      (prevBTFieldProps:=prevBTFResult.toConcreteBTFieldProps)
      (curBTFieldProps:=liftBTFieldProps (k:=k) (prevBTFResult:=prevBTFResult))))

def ConstraintSystem (ùì° : Type) (numWires numGates : ‚Ñï) := Fin numGates ‚Üí Gate ùì° numWires

@[reducible]
def foldRelayOracleReduction (i : Fin ‚Ñì)
    (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
  OracleReduction []‚Çí
    (StmtIn := Statement (L := L) Context i.castSucc)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) i.castSucc)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) i.succ)
    (pSpec := pSpecFoldRelay (L:=L)) :=
  OracleReduction.append
    (pSpec‚ÇÅ := pSpecFold (L:=L))
    (pSpec‚ÇÇ := pSpecRelay)
        (foldOracleReduction ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) i)
    (relayOracleReduction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hNCR)

Algebra.TensorProduct.includeLeftRingHom in Mathlib.RingTheory.TensorProduct.Basic

def BindingAdversary (oSpec : OracleSpec Œπ) (Data Commitment AuxState : Type)
    [O : OracleInterface Data] :=
  OracleComp oSpec (Commitment √ó O.Query √ó O.Response √ó O.Response √ó AuxState)

List.Vector.nil in Mathlib.Data.Vector.Defs

@[reducible, inline, specialize, simp]
def MessageIdx (vPSpec : VectorSpec n) := {i : Fin n // vPSpec.dir i = .P_to_V}

def bitsToU (i : Fin r) (k : Fin (2 ^ i.val)) :
    AdditiveNTT.U (L := L) (ùîΩq := ùîΩq) (Œ≤ := Œ≤) i :=
  let val := (Finset.univ : Finset (Fin i)).sum fun j =>
    if (Nat.getBit (n := k.val) (k := j.val) == 1) then
      Œ≤ ‚ü®j, by admit /- proof elided -/
      ‚ü©
    else 0

  
  ‚ü®val, by admit /- proof elided -/
  ‚ü©

OracleSpec.QueryLog.inr in VCVio.OracleComp.QueryTracking.Structures

def finUInt16Equiv : Fin (2 ^ 16) ‚âÉ UInt16 where
  toFun := fun i => UInt16.ofFin i
  invFun := fun u => u.toFin
  left_inv _ := rfl
  right_inv _ := rfl

def rtake (m : ‚Ñï) (h : m ‚â§ n) (pSpec : ProtocolSpec n) : ProtocolSpec m :=
  {dir := Fin.rtake m h pSpec.dir, ¬´Type¬ª := Fin.rtake m h pSpec.¬´Type¬ª}

def sigmaChallengeIdxToSeqCompose {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (i : Fin m) (j : (pSpec i).ChallengeIdx) : (seqCompose pSpec).ChallengeIdx :=
  ‚ü®Fin.embedSum i j.1, by admit /- proof elided -/
  ‚ü©

def regularElms_set (H : F[X][Y]) : Set (ùïÉ H) :=
  {a : ùïÉ H | ‚àÉ b : ùí™ H, a = embeddingOfùí™IntoùïÉ _ b}

noncomputable instance {v : Œπ ‚Üí F} {s : AffineSubspace F (Œπ ‚Üí F)} [inst : Nonempty s] :
    Nonempty (v +·µ• s) :=

noncomputable def ansPoly (S : Finset F) (Ans : S ‚Üí F) : Polynomial F :=
  Lagrange.interpolate S.attach (fun i => (i : F)) Ans

noncomputable def polynomialAlgEquiv : P ‚âÉ‚Çê[R] R[X] where
  toFun := toPolynomialAlgHom
  invFun := ofPolynomialAlgHom
  left_inv := by admit /- proof elided -/

def rbrKnowledgeSoundness
    (relIn : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (verifier : OracleVerifier oSpec Statement OStatement Bool (fun _ : Empty => Unit) pSpec)
    (rbrKnowledgeError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) : Prop :=
  verifier.rbrKnowledgeSoundness init impl relIn acceptRejectOracleRel rbrKnowledgeError

def relOut : Set ((Unit √ó (‚àÄ i, (Sum.elim OStatement OStatement) i)) √ó Unit) :=
  setOf (fun ‚ü®‚ü®(), oracles‚ü©, _‚ü© => oracles (.inl default) = oracles (.inr default))

@[inline]
def seqCompose {m : ‚Ñï} (Stmt : Fin (m + 1) ‚Üí Type) (Wit : Fin (m + 1) ‚Üí Type)
    {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (R : (i : Fin m) ‚Üí
      Reduction oSpec (Stmt i.castSucc) (Wit i.castSucc) (Stmt i.succ) (Wit i.succ) (pSpec i)) :
    Reduction oSpec (Stmt 0) (Wit 0) (Stmt (Fin.last m)) (Wit (Fin.last m)) (seqCompose pSpec) where
  prover := Prover.seqCompose Stmt Wit (fun i => (R i).prover)
  verifier := Verifier.seqCompose Stmt (fun i => (R i).verifier)

def sumcheckConsistencyProp {k : ‚Ñï} (sumcheckTarget : L) (H : L‚¶É‚â§ 2‚¶Ñ[X Fin (k)]) : Prop :=
  sumcheckTarget = ‚àë x ‚àà (univ.map ùìë) ^·∂† (k), H.val.eval x

class IsSound (langIn : Set StmtIn) (langOut : Set StmtOut)
    (verifier : Verifier oSpec StmtIn StmtOut pSpec) where
  soundnessError : ‚Ñù‚â•0
  is_sound : soundness init impl langIn langOut verifier soundnessError

List.splitBy in Init.Data.List.Basic

abbrev Size.n_x : ‚Ñï := sz.n - sz.n_w

@[ext]
structure Prover {Œπ : Type} (oSpec : OracleSpec Œπ)
    (StmtIn WitIn StmtOut WitOut : Type)
    {n : ‚Ñï} (pSpec : ProtocolSpec n) extends
      ProverState n,
      ProverInput StmtIn WitIn (PrvState 0),
      ProverRound oSpec pSpec,
      ProverOutput oSpec (StmtOut √ó WitOut) (PrvState (Fin.last n))

hammingNorm in Mathlib.InformationTheory.Hamming

USize in Init.Prelude

instance {Œπ : Type} : OracleInterface (OracleStatement Œπ F ()) := OracleInterface.instFunction

ProbComp in VCVio.OracleComp.OracleComp

DivisionRing in Mathlib.Algebra.Field.Defs

def perfectCompleteness
    (relIn : Set ((StmtIn √ó ‚àÄ i, OStmtIn i) √ó WitIn))
    (relOut : Set ((StmtOut √ó ‚àÄ i, OStmtOut i) √ó WitOut))
    (oracleReduction : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec) :
      Prop :=
  Reduction.perfectCompleteness init impl relIn relOut oracleReduction.toReduction

def multiConstrainedCode
  (domain : Œπ ‚Ü™ F) [Smooth domain] (m t : ‚Ñï)
  (w : Fin t ‚Üí MvPolynomial (Fin (m + 1)) F)
  (œÉ : Fin t ‚Üí F) : Set (Œπ ‚Üí F) :=
    { f |
      ‚àÉ (h : f ‚àà smoothCode domain m),
        ‚àÄ i : Fin t, weightConstraint (mVdecode (‚ü®f, h‚ü© : smoothCode domain m)) (w i) (œÉ i)}

@[ext]
structure OracleVerifier {Œπ : Type} (oSpec : OracleSpec Œπ)
    (StmtIn : Type) {Œπ‚Çõ·µ¢ : Type} (OStmtIn : Œπ‚Çõ·µ¢ ‚Üí Type)
    (StmtOut : Type) {Œπ‚Çõ‚Çí : Type} (OStmtOut : Œπ‚Çõ‚Çí ‚Üí Type)
    {n : ‚Ñï} (pSpec : ProtocolSpec n)
    [O‚Çõ·µ¢ : ‚àÄ i, OracleInterface (OStmtIn i)]
    [O‚Çò : ‚àÄ i, OracleInterface (pSpec.Message i)]
    where
    
    

   
  verify : StmtIn ‚Üí pSpec.Challenges ‚Üí
    OracleComp (oSpec ++‚Çí ([OStmtIn]‚Çí ++‚Çí [pSpec.Message]‚Çí)) StmtOut

  
  
  

  

   
  embed : Œπ‚Çõ‚Çí ‚Ü™ Œπ‚Çõ·µ¢ ‚äï pSpec.MessageIdx

   
  hEq : ‚àÄ i, OStmtOut i = match embed i with
    | Sum.inl j => OStmtIn j
    | Sum.inr j => pSpec.Message j

CharP in Mathlib.Algebra.CharP.Defs

class VerifierOnly (pSpec : ProtocolSpec 1) extends VerifierFirst pSpec

Nat.reduceBeqDiff in Lean.Meta.Tactic.Simp.BuiltinSimprocs.Nat

def hint (state : HashStateWithInstructions U H) :
    Except DomainSeparatorMismatch (HashStateWithInstructions U H) := do
  
  sorry

@[reducible]
def pSpec (F : Type) [Semiring F] : ProtocolSpec 2 := ‚ü®!v[.V_to_P, .P_to_V], !v[F, Unit ‚Üí F[X]]‚ü©

right_inv in ToMathlib.Control.Monad.Equiv

def knowledgeStateFunction (hRel : ‚àÄ stmtIn witOut,
      (mapStmt stmtIn, witOut) ‚àà relOut ‚Üí (stmtIn, mapWitInv stmtIn witOut) ‚àà relIn) :
    (verifier oSpec mapStmt).KnowledgeStateFunction
      init impl relIn relOut (extractor mapWitInv) where
  toFun | ‚ü®0, _‚ü© => fun stmtIn _ witIn => ‚ü®stmtIn, witIn‚ü© ‚àà relIn
  toFun_empty := fun stmtIn witIn => by admit /- proof elided -/

@[reducible]
def GroupValTable (Œπ : Type*) (G : Type*) := Œ†‚ÇÄ _ : Œπ, Option G

def finalSumcheckRelOut :
    Set ((FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì) √ó
      (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì) j)) √ó
      (Unit)) :=
  { input | finalSumcheckRelOutProp ùîΩq Œ≤ (input := input) }

VAdd in Mathlib.Algebra.Notation.Defs

BitVec.cast in Init.Data.BitVec.Basic

instance instDCast‚ÇÅ‚ÇÇ : DCast (Œ≤ a) (Œ≥ a) where
  dcast hb c := dcast‚ÇÇ (Eq.refl a) (by admit /- proof elided -/
  ) c
  dcast_id := by admit /- proof elided -/

def toStatement (stmt : FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì)) :
  Statement (L := L) (Context := SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì)  :=
  {
    sumcheck_target := stmt.sumcheck_target,
    challenges := stmt.challenges,
    ctx := stmt.ctx
  }

instance : OracleInterface (Witness R pp) where
  Query := Fin pp.‚Ñì_w ‚Üí R
  Response := R
  answer := fun ùï® evalPoint => (MLE (ùï® ‚àò finFunctionFinEquiv)) ‚∏®evalPoint‚∏©

instance instDecidableEqOption {Œ± : Type*} [DecidableEq Œ±] :
    DecidableEq (Option Œ±) := inferInstance

instance : IsCyclic G :=
  isCyclic_of_prime_card PrimeOrder.hCard

noncomputable def distFromCode (u : n ‚Üí R) (C : Set (n ‚Üí R)) : ‚Ñï‚àû :=
  sInf {d | ‚àÉ v ‚àà C, hammingDist u v ‚â§ d}

Nat.floor in Mathlib.Algebra.Order.Floor.Defs

def uniqueDecodable (C : Code Œπ F) (r : ‚Ñù) : Prop :=
  listDecodable C r 1

def listOfCloseCodewordsRel (C : Code Œπ F) (y : Œπ ‚Üí F) (r : ‚Ñù) : ‚Ñï :=
  Nat.card (relHammingBall C y r)

def MyTypeVec : Fin 3 ‚Üí Type := !v[‚Ñï, Bool, String]

example : !d‚ü®MyTypeVec‚ü©[(1 : ‚Ñï), true, "hello"] =
  (!h[1, true, "hello"] : (i : Fin 3) ‚Üí MyTypeVec i) := rfl


example : !d‚ü®!v[]‚ü©[] = (Fin.dempty : (i : Fin 0) ‚Üí !v[] i) := rfl


example : !d‚ü® !v[‚Ñï, Bool, String] ‚ü©[(1 : ‚Ñï), (true : Bool), ("hello" : String)] =
  Fin.dcons (1 : ‚Ñï) (Fin.dcons true (Fin.dcons "hello" Fin.dempty)) := rfl


example : let motive : Fin 2 ‚Üí Type := fun i => if i = 0 then ‚Ñï else Bool
          !d‚ü®motive‚ü©[(1 : ‚Ñï), (true : Bool)] =
          (Fin.dcons (1 : ‚Ñï) (Fin.dcons (true : Bool) Fin.dempty) : (i : Fin 2) ‚Üí motive i) := rfl

instance {k : ‚Ñï} : IntCast (ConcreteBTField k) where
  intCast n:= intCast n

noncomputable def UniPolyC.toPoly (p : UniPolyC R) : Polynomial R := p.val.toPoly

alias ofPoly := Polynomial.toImpl

instance : ‚àÄ i, SelectableType ((pSpecCoreInteraction ùîΩq Œ≤ (œë:=œë)
  (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).Challenge i) := instSelectableTypeChallengeAppend

@[inline]
def neg [Neg R] (p : MlPolyEval R n) : MlPolyEval R n := p.map (fun a => -a)

def addUnits (state : FSProverState U H R) (input : Array U) :
    Except DomainSeparatorMismatch (FSProverState U H R) :=
  match state.hashState.absorb input with
  | .ok newHashState =>
    
    
    .ok { rng := state.rng, hashState := newHashState, nargString := state.nargString }
  | .error e => .error e

@[inline, specialize]
def nsmul (n : ‚Ñï) (p : UniPoly R) : UniPoly R :=
  nsmul_raw n p |> trim

class Extractor.Straightline.IsMonotone
    (relIn : Set (StmtIn √ó WitIn))
    (E : Extractor.Straightline oSpec StmtIn WitIn WitOut pSpec)
    [oSpec.FiniteRange]
    where
  is_monotone : ‚àÄ witOut stmtIn transcript, ‚àÄ proveQueryLog‚ÇÅ proveQueryLog‚ÇÇ : oSpec.QueryLog,
    ‚àÄ verifyQueryLog‚ÇÅ verifyQueryLog‚ÇÇ : oSpec.QueryLog,
    proveQueryLog‚ÇÅ.Sublist proveQueryLog‚ÇÇ ‚Üí
    verifyQueryLog‚ÇÅ.Sublist verifyQueryLog‚ÇÇ ‚Üí
    
    [fun witIn => (stmtIn, witIn) ‚àà relIn |
      E stmtIn witOut transcript proveQueryLog‚ÇÅ verifyQueryLog‚ÇÅ] ‚â§
    [fun witIn => (stmtIn, witIn) ‚àà relIn |
      E stmtIn witOut transcript proveQueryLog‚ÇÇ verifyQueryLog‚ÇÇ]

instance {k : Fin 1} : Unique (ChallengesUpTo k !p[]) where
  default := fun ‚ü®‚ü®i, h‚ü©, _‚ü© => by admit /- proof elided -/

Nat.div2 in Mathlib.Data.Nat.Bits

Fin.addNat in Init.Data.Fin.Basic

id in Init.Prelude

left_inv in ToMathlib.Control.Monad.Equiv

def FullData.toInternalData {Œ± : Type} {s : Skeleton}
    (tree : FullData Œ± s) : InternalData Œ± s :=
  match tree with
  | FullData.leaf _ => InternalData.leaf
  | FullData.internal value left right =>
    InternalData.internal value (left.toInternalData) (right.toInternalData)

@[simp]
abbrev LinearCombinationChallenge : Type := R1CS.MatrixIdx ‚Üí R

LinearMap.ker in Mathlib.Algebra.Module.Submodule.Ker

instance : ‚àÄ i, SelectableType ((default : ProtocolSpec 0).Challenge i) := fun ‚ü®i, _‚ü© => Fin.elim0 i

instance instST‚ÇÅ : ‚àÄ i, SelectableType ((‚ü®!v[.P_to_V], !v[R‚¶É‚â§ deg‚¶Ñ[X]]‚ü© ++‚Çö !p[]).Challenge i) :=
  instSelectableTypeChallengeAppend

SimOracle.append in VCVio.OracleComp.SimSemantics.Append

class Statement.Lens.IsSound {OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut : Type}
    (outerLangIn : Set OuterStmtIn) (outerLangOut : Set OuterStmtOut)
    (innerLangIn : Set InnerStmtIn) (innerLangOut : Set InnerStmtOut)
    (compatStmt : OuterStmtIn ‚Üí InnerStmtOut ‚Üí Prop)
    (lens : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut) where

  proj_sound : ‚àÄ outerStmtIn,
    outerStmtIn ‚àâ outerLangIn ‚Üí lens.proj outerStmtIn ‚àâ innerLangIn

  lift_sound : ‚àÄ outerStmtIn innerStmtOut,
    compatStmt outerStmtIn innerStmtOut ‚Üí
    innerStmtOut ‚àâ innerLangOut ‚Üí
    lens.lift outerStmtIn innerStmtOut ‚àâ outerLangOut

def fillNextUnits (state : FSVerifierState U H) (count : Nat) :
    Except DomainSeparatorMismatch (FSVerifierState U H √ó Array U) := do
  
  let bytesNeeded := count * HasSize.size U UInt8
  if state.nargString.size < bytesNeeded then
    .error {
      message := s!"Insufficient transcript remaining, need {bytesNeeded} bytes,
        got {state.nargString.size}" }
  else
    
    let readBytes := state.nargString.extract 0 bytesNeeded
    let remaining := state.nargString.extract bytesNeeded state.nargString.size
    
    let units := Array.range count |>.mapM (fun i =>
      let unitBytes := readBytes.extract (i * HasSize.size U UInt8) (HasSize.size U UInt8)
      DeserializeOption.deserialize unitBytes)
    match units with
    | some unitsArray =>
      
      let newHashState ‚Üê state.hashState.absorb unitsArray
      .ok ({ hashState := newHashState, nargString := remaining }, unitsArray)
    | none =>
      .error { message := "Failed to deserialize units from NARG string" }

@[reducible]
def combineMap : StmtIn √ó WitIn ‚Üí OracleComp oSpec (StmtOut √ó WitOut) :=
  fun ‚ü®stmt, wit‚ü© => do return (‚Üê mapStmt stmt, ‚Üê mapWit stmt wit)

UInt16 in Init.Prelude

List.Vector in Mathlib.Data.Vector.Defs

def SkeletonNodeIndex.isRoot {s : Skeleton} (idx : SkeletonNodeIndex s) : Bool :=
  match idx with
  | SkeletonNodeIndex.ofLeaf => true
  | SkeletonNodeIndex.ofInternal => true
  | SkeletonNodeIndex.ofLeft _ => false
  | SkeletonNodeIndex.ofRight _ => false

RingHom.toAlgebra in Mathlib.Algebra.Algebra.Defs

def pointToIterateQuotientIndex (i : Fin (‚Ñì + 1)) (steps : ‚Ñï) (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
    (x : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i, by omega‚ü©)) : Fin (2 ^ steps) :=

Vector.ofFn in Init.Data.Vector.Basic

instance (priority := low) : DCast Œ± Œ≤ where
  dcast h := cast (congrArg Œ≤ h)
  dcast_id := by admit /- proof elided -/

def processMemoryOps (ops : List (MemoryOp Œπ Œ±)) (startMem : M) : Option M :=
  ops.foldlM (fun m op =>
    match op with
    | .read ‚ü®i, v‚ü© => if Memory.read m i = v then some m else none
    | .write ‚ü®i, v‚ü© => some (Memory.write m i v)
  ) startMem

abbrev BaseField := ZMod baseFieldSize

def degCor
  (œÜ : Œπ ‚Ü™ F) (dstar degree : ‚Ñï) (r : F) (f : Œπ ‚Üí F) (x : Œπ) : F :=
    f x * ‚àë l ‚àà range (dstar - degree + 1), ((œÜ x) * r) ^ l

Functor in Init.Prelude

Fin.append in Mathlib.Data.Fin.Tuple.Basic

protected def OracleReduction.id :
    OracleReduction oSpec Statement OStatement Witness Statement OStatement Witness !p[] :=
  ‚ü®OracleProver.id, OracleVerifier.id‚ü©

alias Prover.trivial := Prover.id
alias Verifier.trivial := Verifier.id
alias Reduction.trivial := Reduction.id
alias OracleProver.trivial := OracleProver.id
alias OracleVerifier.trivial := OracleVerifier.id
alias OracleReduction.trivial := OracleReduction.id

Iff in Init.Core

def partialSum {Œ± : Type*} [AddMonoid Œ±] (l : List Œ±) : List Œ± :=
  [0] ++ match l with
  | [] => []
  | a :: l' => (partialSum l').map (a + ¬∑)

def equivFin2 : Direction ‚âÉ Fin 2 where
  toFun := fun dir => match dir with | .V_to_P => ‚ü®0, by admit /- proof elided -/
  ‚ü© | .P_to_V => ‚ü®1, by admit /- proof elided -/
  ‚ü©
  invFun := fun n => match n with | ‚ü®0, _‚ü© => .V_to_P | ‚ü®1, _‚ü© => .P_to_V
  left_inv := fun dir => match dir with | .P_to_V => rfl | .V_to_P => rfl
  right_inv := fun n => match n with | ‚ü®0, _‚ü© => rfl | ‚ü®1, _‚ü© => rfl

def oracleProver : OracleProver oSpec
    Statement OStatement Unit
    Unit (OStatement ‚äï·µ• OStatement) Unit
    (pSpec OStatement) where
  PrvState := fun _ => OStatement default

  input := fun ‚ü®‚ü®_, oStmt‚ü©, _‚ü© => oStmt default

  sendMessage | ‚ü®0, _‚ü© => fun st => pure (st, st)

  receiveChallenge | ‚ü®0, h‚ü© => nomatch h

  output := fun st => pure
    (‚ü®(), fun x => match x with
      | .inl _ => by admit /- proof elided -/
      ‚ü©,
     ())

Nat.decLe in Init.Prelude

noncomputable def Œ∑Star (U : Type) [SpongeUnit U] [Fintype U]
    (t‚Çï t‚Çö t‚Çö·µ¢ : ‚Ñï) (L : ‚Ñï) (Œµcodec : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) : ‚Ñù‚â•0 :=
  let tTotal : ‚Ñï := (t‚Çï + t‚Çö + t‚Çö·µ¢)
  
  
  
  
  let firstTermNumerator : ‚Ñù‚â•0 :=
    7 * tTotal ^2 + (28 * L + 25) * tTotal + (14 * L + 1) * (L + 1)
  let firstTermDenominator : ‚Ñù‚â•0 := 2 * ((Fintype.card U) ^ (SpongeSize.C + 1))
  
  let secondTerm : ‚Ñù‚â•0 := Œ∏Star t‚Çï t‚Çö t‚Çö·µ¢ * (iSup Œµcodec)
  
  let thirdTerm : ‚Ñù‚â•0 := ‚àë i, Œµcodec i
  
  firstTermNumerator / firstTermDenominator + secondTerm + thirdTerm

RatFunc.eval in Mathlib.FieldTheory.RatFunc.AsPolynomial

instance {n : ‚Ñï} : OfNat (Cayley T) n where
  ofNat := ofNat n

def fork : Prop :=
  
  trace = [] ‚àß state = 0

alias E_fork := fork

noncomputable instance : Algebra K (Left ‚äó[K] Right) := Algebra.TensorProduct.instAlgebra

def aeval {A : Type w} [CommSemiring A] [Algebra R A] (s : A) : P ‚Üí‚Çê[R] A :=
  eval‚ÇÇAlgHom (Algebra.ofId R A) s

System.mkFilePath in Init.System.FilePath

@[inline, specialize]
def oracleVerifier : OracleVerifier oSpec
    Unit (fun _ : Fin 2 => OStatement)
    (Query OStatement) (fun _ : Fin 2 => OStatement) (pSpec OStatement) where

  verify := fun _ chal => do
    let q : Query OStatement := chal ‚ü®0, rfl‚ü©
    pure q

  embed := Function.Embedding.inl

  hEq := by admit /- proof elided -/

noncomputable def foldVerifier :
  OracleVerifier []‚Çí
    (Statement F i.castSucc) (OracleStatement D x s i.castSucc)
    (Statement F i.succ) (OracleStatement D x s i.succ)
    (pSpec D x s i) where
  verify := fun prevChallenges roundChallenge =>
    pure (Fin.vappend prevChallenges (fun _ => roundChallenge ‚ü®0, by admit /- proof elided -/
    ‚ü©))
  embed :=
    ‚ü®
      fun j =>
        if h : j.val = (i.val + 1)
        then Sum.inr ‚ü®1, by admit /- proof elided -/
        ‚ü©
        else Sum.inl ‚ü®j.val, by admit /- proof elided -/
        ‚ü©,
      by admit /- proof elided -/
    ‚ü©
  hEq := by admit /- proof elided -/

@[inline, specialize, simp]
def prover : Prover oSpec Statement Witness Statement Witness !p[] := Prover.id

@[reducible]
def StateRestoration.KnowledgeSoundness (oSpec : OracleSpec Œπ)
    (StmtIn : Type) {Œπ‚Çõ·µ¢ : Type} (OStmtIn : Œπ‚Çõ·µ¢ ‚Üí Type) (WitOut : Type)
    {n : ‚Ñï} {pSpec : ProtocolSpec n} :=
  Prover.StateRestoration.KnowledgeSoundness oSpec (StmtIn √ó (‚àÄ i, OStmtIn i)) WitOut pSpec

One in Init.Prelude

instance : Fact (Nat.Prime fieldSize) := ‚ü®is_prime‚ü©

@[inline, specialize]
def Prover.runToRoundDSFS [‚àÄ i, VCVCompatible (pSpec.Challenge i)] (i : Fin (n + 1))
    (stmt : StmtIn) (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec)
    (state : prover.PrvState 0) :
        OracleComp (oSpec ++‚Çí duplexSpongeChallengeOracle StmtIn U)
          (pSpec.MessagesUpTo i √ó
            DuplexSponge U (Vector U SpongeSize.N) √ó prover.PrvState i) :=
  Fin.induction
    (do
      
      let sponge ‚Üê liftM (DuplexSponge.start stmt)
      return ‚ü®default, sponge, state‚ü©
    )
    (prover.processRoundDSFS)
    i

def oracleReduction.checkClaim : OracleReduction oSpec
    (StmtAfterSendClaim R) (OStmtAfterSendClaim R deg) Unit
    (StmtAfterCheckClaim R) (OStmtAfterCheckClaim R deg) Unit !p[] :=
  sorry

Ideal in Mathlib.RingTheory.Ideal.Defs

LinearMap.domRestrict in Mathlib.Algebra.Module.Submodule.LinearMap

@[reducible]
def fieldSize : Nat := 2 ^ 31 - 2 ^ 27 + 1

def renameMessage (pSpec : ProtocolSpec n) (NewMessage : pSpec.MessageIdx ‚Üí Type) :
    ProtocolSpec n :=
  ‚ü® pSpec.dir,
    fun i => if h : pSpec.dir i = Direction.P_to_V then NewMessage ‚ü®i, h‚ü© else pSpec.¬´Type¬ª i‚ü©

Disjoint in Mathlib.Order.Disjoint

@[reducible, simp]
def oraclePSpec : ProtocolSpec 1 := ‚ü®!v[.P_to_V], !v[Witness]‚ü©

noncomputable def queryProver :
  OracleProver []‚Çí
    (FinalStatement F k) (FinalOracleStatement D x s) (Witness F s d (Fin.last (k + 1)))
    (FinalStatement F k) (FinalOracleStatement D x s) (Witness F s d (Fin.last (k + 1)))
    (pSpec D x l) where
  PrvState
  | _ =>
    (FinalStatement F k √ó ((i : Fin (k + 2)) ‚Üí FinalOracleStatement D x s i)) √ó
      Witness F s d (Fin.last (k + 1))

  input := id

  sendMessage
  | ‚ü®0, h‚ü© => nomatch h

  receiveChallenge
  | ‚ü®1, _‚ü© => fun x => pure <| fun _ => x

  output := pure

def Œ± (x‚ÇÄ : F) (R : F[X][X][Y]) (H : F[X][Y]) [œÜ : Fact (Irreducible H)] (t : ‚Ñï) : ùïÉ H :=
  let W : ùïÉ H := liftToFunctionField (H.leadingCoeff)
  embeddingOfùí™IntoùïÉ _ (Œ≤ R t) / (W ^ (t + 1) * (embeddingOfùí™IntoùïÉ _ (Œæ x‚ÇÄ R H)) ^ (2*t - 1))

StrongRankCondition in Mathlib.LinearAlgebra.InvariantBasisNumber

instance {_ : Empty} : OracleInterface (Unit) := OracleInterface.instDefault

@[inline]
def zsmul [SMul ‚Ñ§ R] (m : ‚Ñ§) (p : MlPoly R n) : MlPoly R n := p.map (fun a => m ‚Ä¢ a)

List.max? in Init.Data.List.Basic

Nat.max in Init.Data.Nat.Basic

def example1 : ChurchVec ‚Ñï := churchCons 1 (churchCons 2 (churchCons 3 churchNil))

example : toList example1 = [1, 2, 3] := rfl

def take (m : ‚Ñï) (h : m ‚â§ n) (pSpec : ProtocolSpec n) : ProtocolSpec m :=
  {dir := Fin.take m h pSpec.dir, ¬´Type¬ª := Fin.take m h pSpec.¬´Type¬ª}

instance {s} : LawfulFunctor (fun Œ± => InternalData Œ± s) :=

def closePtsOnAffineLine {Œπ : Type*} [Fintype Œπ]
                         (u v : Œπ ‚Üí F) (deg : ‚Ñï) (Œ± : Œπ ‚Ü™ F) (e : ‚Ñï) : Set (Œπ ‚Üí F) :=
  {x : Œπ ‚Üí F | x ‚àà Affine.line u v ‚àß distFromCode x (ReedSolomon.code Œ± deg) ‚â§ e}

def hli_level_diff_0 (l : ‚Ñï) :
  letI instAlgebra:= binaryAlgebraTower (l:=l) (r:=l) (h_le:=by omega)
  @Basis (Fin 1) (BTField l) (BTField l) _ _ instAlgebra.toModule :=

Ring in Mathlib.Algebra.Ring.Defs

inductive MatrixIdx where | A | B | C deriving Inhabited, DecidableEq

@[inline, specialize]
def runWithLogToRound (i : Fin (n + 1))
    (stmt : StmtIn) (wit : WitIn) (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí)
        ((pSpec.Transcript i √ó prover.PrvState i) √ó QueryLog (oSpec ++‚Çí [pSpec.Challenge]‚Çí)) :=
  (simulateQ loggingOracle (prover.runToRound i stmt wit)).run

Infinite in Mathlib.Data.Finite.Defs

noncomputable instance {s : Set (Œπ ‚Üí F)} : Fintype (affineSpan F s) :=
  Fintype.ofFinite ‚Ü•(affineSpan F s)

def extract {n : ‚Ñï} {Œ± : Fin n ‚Üí Sort*} (start stop : ‚Ñï) (h1 : start ‚â§ stop) (h2 : stop ‚â§ n)
    (v : (i : Fin n) ‚Üí Œ± i) : (i : Fin (stop - start)) ‚Üí Œ± ‚ü®i + start, by admit /- proof elided -/
    ‚ü© :=
  fun i ‚Ü¶ v ‚ü®i + start, by admit /- proof elided -/
  ‚ü©

def MessageIdx.inr (i : MessageIdx pSpec‚ÇÇ) : MessageIdx (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ) :=
  ‚ü®Fin.natAdd m i.1, by admit /- proof elided -/
  ‚ü©

def foldKStateProp {i : Fin ‚Ñì} (m : Fin (2 + 1))
    (tr : Transcript m (pSpecFold (L := L))) (stmt : Statement (L := L) Context i.castSucc)
    (witMid : Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j) :
    Prop :=
  
  let h_star : ‚Ü•L‚¶É‚â§ 2‚¶Ñ[X] := getSumcheckRoundPoly ‚Ñì ùìë (i := i) (h := witMid.H)
  
  let get_H·µ¢ := fun (m: Fin (2 + 1)) (tr: Transcript m pSpecFold) (hm: 1 ‚â§ m.val) =>
    let ‚ü®msgsUpTo, _‚ü© := Transcript.equivMessagesChallenges (k := m)
      (pSpec := pSpecFold (L := L)) tr
    let i_msg1 : ((pSpecFold (L := L)).take m m.is_le).MessageIdx :=
      ‚ü®‚ü®0, Nat.lt_of_succ_le hm‚ü©, by admit /- proof elided -/
      ‚ü©
    let h_i : L‚¶É‚â§ 2‚¶Ñ[X] := msgsUpTo i_msg1
    h_i

  let get_r·µ¢' := fun (m: Fin (2 + 1)) (tr: Transcript m pSpecFold) (hm: 2 ‚â§ m.val) =>
    let ‚ü®msgsUpTo, chalsUpTo‚ü© := Transcript.equivMessagesChallenges (k := m)
      (pSpec := pSpecFold (L := L)) tr
    let i_msg1 : ((pSpecFold (L := L)).take m m.is_le).MessageIdx :=
      ‚ü®‚ü®0, Nat.lt_of_succ_le (Nat.le_trans (by admit /- proof elided -/
      ) hm)‚ü©, by admit /- proof elided -/
      ‚ü©
    let h_i : L‚¶É‚â§ 2‚¶Ñ[X] := msgsUpTo i_msg1
    let i_msg2 : ((pSpecFold (L := L)).take m m.is_le).ChallengeIdx :=
      ‚ü®‚ü®1, Nat.lt_of_succ_le hm‚ü©, by admit /- proof elided -/
      ‚ü©
    let r_i' : L := chalsUpTo i_msg2
    r_i'

  match m with
  | ‚ü®0, _‚ü© => 
    masterKStateProp (mp := mp) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (stmtIdx := i.castSucc) (oracleIdx := i.castSucc)
      (h_le := le_refl _)
      (stmt := stmt) (wit := witMid) (oStmt := oStmt)
      (localChecks := True)
  | ‚ü®1, h1‚ü© => 
    masterKStateProp (mp := mp) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (stmtIdx := i.castSucc) (oracleIdx := i.castSucc)
      (h_le := le_refl _)
      (stmt := stmt) (wit := witMid) (oStmt := oStmt)
      (localChecks :=
        let h_i := get_H·µ¢ (m := ‚ü®1, h1‚ü©) (tr := tr) (hm := by admit /- proof elided -/
        )
        let explicitVCheck := h_i.val.eval 0 + h_i.val.eval 1 = stmt.sumcheck_target
        let localizedRoundPolyCheck := h_i = h_star
        explicitVCheck ‚àß localizedRoundPolyCheck
      )
  | ‚ü®2, h2‚ü© => 
    
    masterKStateProp (mp := mp) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (stmtIdx := i.castSucc) (oracleIdx := i.castSucc)
      (h_le := le_refl _)
      (stmt := stmt) (wit := witMid) (oStmt := oStmt)
      (localChecks :=
        let h_i := get_H·µ¢ (m := ‚ü®2, h2‚ü©) (tr := tr) (hm := by admit /- proof elided -/
        )
        let r_i' := get_r·µ¢' (m := ‚ü®2, h2‚ü©) (tr := tr) (hm := by admit /- proof elided -/
        )
        let localizedRoundPolyCheck := h_i = h_star
        let nextSumcheckTargetCheck := 
          h_i.val.eval r_i' = h_star.val.eval r_i'
        localizedRoundPolyCheck ‚àß nextSumcheckTargetCheck
      ) 

instance {n : ‚Ñï} : ‚àÄ j, SelectableType ((pSpecFoldRelaySequence (L:=L) n).Challenge j) :=
  instSelectableTypeChallengeSeqCompose

def aeval {A : Type y} [CommSemiring A] [Algebra R A] {F : Type z} [FunEquiv F œÉ A] (g : F) :
    P ‚Üí‚Çê[R] A :=
  eval‚ÇÇAlgHom (Algebra.ofId R A) g

noncomputable def divergence (U V : Set (Œπ ‚Üí F)) : ‚Ñö‚â•0 :=
  haveI : Fintype (possibleDeltas U V) := @Fintype.ofFinite _ finite_possibleDeltas
  if h : (possibleDeltas U V).Nonempty
  then (possibleDeltas U V).toFinset.max' (Set.toFinset_nonempty.2 h)
  else 0

def possibleDists (C : Set (Œπ ‚Üí F)) (Œ¥f : (Œπ ‚Üí F) ‚Üí (Œπ ‚Üí F) ‚Üí Œ±) : Set Œ± :=
  {d : Œ± | ‚àÉ p ‚àà Set.offDiag C, Œ¥f p.1 p.2 = d}

abbrev ùí™ (H : F[X][Y]) : Type :=
  (Polynomial (Polynomial F)) ‚ß∏ (Ideal.span {H_tilde' H})

Polynomial.natDegree in Mathlib.Algebra.Polynomial.Degree.Definitions

def partition (cs : ConstraintSystem ùì° numWires numGates) :
    Fin numWires ‚Üí Finset (Fin (3 * numGates)) :=
  
  
  
  
  fun i => Finset.map (Equiv.toEmbedding finProdFinEquiv)
    (Finset.filter (fun j => if j.1 = 0 then (cs j.2).a = i
      else if j.1 = 1 then (cs j.2).b = i else (cs j.2).c = i)
    (Finset.univ : Finset (Fin 3 √ó Fin numGates)))

def findNeighbors {n : ‚Ñï} (i : Fin (2 ^ n)) (layer : Fin n) :
    Fin (2 ^ (layer.val + 1)) :=
  
  
  let bits := (Vector.ofFn (finFunctionFinEquiv.invFun i)).reverse
  
  let neighbor := (bits.set layer (bits.get layer + 1)).take (layer.val + 1)
  have : min (layer.val + 1) n = layer.val + 1 := by admit /- proof elided -/

Finset.max in Mathlib.Data.Finset.Max

def dotProduct [Zero R] [Add R] [Mul R] (a b : Vector R n) : R :=
  a.zipWith (¬∑ * ¬∑) b |>.foldl (¬∑ + ¬∑) 0

def natDegreeY (f : F[X][Y]) : ‚Ñï := Polynomial.natDegree f

class UnitTranscript (Œ± : Type*) (U : Type) where
   
  publicUnits : Œ± ‚Üí Array U ‚Üí Except DomainSeparatorMismatch Œ±
   
  fillChallengeUnits : Œ± ‚Üí Nat ‚Üí Except DomainSeparatorMismatch (Œ± √ó Array U)

@[reducible]
def OracleStatement (i : Fin (k + 1)) : Fin (i.val + 1) ‚Üí Type :=
  fun j =>
    evalDomain D x (‚àë j' ‚àà finRangeTo j.1, s j')
      ‚Üí F

instance : Sub AssocNat where
  sub := sub

@[inline, reducible]
def OracleStatement.Lens (OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut : Type)
    {Outer_Œπ‚Çõ·µ¢ : Type} (OuterOStmtIn : Outer_Œπ‚Çõ·µ¢ ‚Üí Type) [‚àÄ i, OracleInterface (OuterOStmtIn i)]
    {Outer_Œπ‚Çõ‚Çí : Type} (OuterOStmtOut : Outer_Œπ‚Çõ‚Çí ‚Üí Type) [‚àÄ i, OracleInterface (OuterOStmtOut i)]
    {Inner_Œπ‚Çõ·µ¢ : Type} (InnerOStmtIn : Inner_Œπ‚Çõ·µ¢ ‚Üí Type) [‚àÄ i, OracleInterface (InnerOStmtIn i)]
    {Inner_Œπ‚Çõ‚Çí : Type} (InnerOStmtOut : Inner_Œπ‚Çõ‚Çí ‚Üí Type) [‚àÄ i, OracleInterface (InnerOStmtOut i)]
  :=
    Statement.Lens (OuterStmtIn √ó ‚àÄ i, OuterOStmtIn i) (OuterStmtOut √ó ‚àÄ i, OuterOStmtOut i)
                  (InnerStmtIn √ó ‚àÄ i, InnerOStmtIn i) (InnerStmtOut √ó ‚àÄ i, InnerOStmtOut i)

def Equiv.ofLawfulPermute (Œ± : Type*) [Permute Œ±] [LawfulPermute Œ±] : Equiv Œ± Œ± where
  toFun := Permute.permute
  invFun := LawfulPermute.permuteInv
  left_inv := LawfulPermute.left_inv
  right_inv := LawfulPermute.right_inv

instance instDCast : DCast Nat Fin where
  dcast h := Fin.cast h
  dcast_id := by admit /- proof elided -/

Neg.neg in Init.Prelude

SMul in Init.Prelude

head in ToMathlib.Control.Comonad.Instances

List.Vector.cons in Mathlib.Data.Vector.Defs

instance : AlgebraTower (BTField) where
  algebraMap := towerAlgebraMap
  commutes' := by admit /- proof elided -/

def ValidChurchNat : Type :=
  { f : ChurchNat ‚Ñï // ‚àÉ n, ‚àÄ g x, f g x = Nat.iterate g n x }

instance [reduction.IsPerfectComplete init impl relIn relOut] :
    IsComplete init impl relIn relOut reduction where
  completenessError := 0
  is_complete := IsPerfectComplete.is_perfect_complete

Polynomial.degreeLTEquiv in Mathlib.RingTheory.Polynomial.Basic

instance [VerifierFirst pSpec] : Unique (pSpec.ChallengeIdx) where
  default := ‚ü®0, by admit /- proof elided -/
  ‚ü©
  uniq := fun ‚ü®i, _‚ü© => by admit /- proof elided -/

instance : SubSpec [pSpec‚ÇÅ.Challenge]‚Çí ([(pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).Challenge]‚Çí) where
  monadLift | query i t => instSubSpecOfProtocolSpecAppendChallenge.monadLift (query (Sum.inl i) t)

Exists in Init.Core

instance AffSpanSet.instFinite [NeZero k] (u : Fin k ‚Üí Œπ ‚Üí F) : (AffSpanSet u).Finite :=

def rtake {n : ‚Ñï} {Œ± : Fin n ‚Üí Sort*} (m : ‚Ñï) (h : m ‚â§ n) (v : (i : Fin n) ‚Üí Œ± i) :
    (i : Fin m) ‚Üí Œ± (Fin.cast (Nat.sub_add_cancel h) (natAdd (n - m) i)) :=
  fun i => v (Fin.cast (Nat.sub_add_cancel h) (natAdd (n - m) i))

Nontrivial in Mathlib.Logic.Nontrivial.Defs

instance [Zero T] [ToNat T] : DecidableRel (@LT.lt (Cayley T) _) := fun a b =>
  Nat.decLt (‚Üëa) (‚Üëb)

Group in Mathlib.Algebra.Group.Defs

Even in Mathlib.Algebra.Group.Even

List.ofFn in Init.Data.List.OfFn

noncomputable instance finiteDimensionalCoeffVecSpace (‚Ñì : ‚Ñï) :
  FiniteDimensional (K := L) (V := CoeffVecSpace L ‚Ñì) :=

Fin.rev in Init.Data.Fin.Basic

Multiset in Mathlib.Data.Multiset.Defs

def generateProof {s} (cache_tree : FullData Œ± s) :
    BinaryTree.SkeletonLeafIndex s ‚Üí List Œ±
  | .ofLeaf => []
  | .ofLeft idxLeft =>
    (cache_tree.rightSubtree).getRootValue ::
      (generateProof cache_tree.leftSubtree idxLeft)
  | .ofRight idxRight =>
    (cache_tree.leftSubtree).getRootValue ::
      (generateProof cache_tree.rightSubtree idxRight)

instance [ProverFirst pSpec] : Unique (pSpec.MessageIdx) where
  default := ‚ü®0, by admit /- proof elided -/
  ‚ü©
  uniq := fun ‚ü®i, _‚ü© => by admit /- proof elided -/

@[reducible]
def pSpec : ProtocolSpec 1 := ‚ü®!v[.P_to_V], !v[OStatement default]‚ü©

@[ext]
structure VectorSpec (n : ‚Ñï) where
  dir : Fin n ‚Üí Direction
  length : Fin n ‚Üí Nat

def SkeletonNodeIndex.sibling {s : Skeleton} (idx : SkeletonNodeIndex s) :
    Option (SkeletonNodeIndex s) :=
  match idx with
  
  | SkeletonNodeIndex.ofLeaf => none
  
  | SkeletonNodeIndex.ofInternal => none
  
  | @SkeletonNodeIndex.ofLeft left right idxLeft =>
    match idxLeft with
    
    | SkeletonNodeIndex.ofLeaf => some (getRootIndex right).ofRight
    
    | SkeletonNodeIndex.ofInternal => some (getRootIndex right).ofRight
    
    
    | SkeletonNodeIndex.ofLeft idxLeftLeft =>
      idxLeftLeft.ofLeft.sibling.map (SkeletonNodeIndex.ofLeft)
    | SkeletonNodeIndex.ofRight idxLeftRight =>
      idxLeftRight.ofRight.sibling.map (SkeletonNodeIndex.ofLeft)
  | @SkeletonNodeIndex.ofRight left right idxRight =>
    match idxRight with
    | SkeletonNodeIndex.ofLeaf => some (getRootIndex left).ofLeft
    | SkeletonNodeIndex.ofInternal => some (getRootIndex left).ofLeft
    | SkeletonNodeIndex.ofLeft idxRightLeft =>
      idxRightLeft.ofLeft.sibling.map (SkeletonNodeIndex.ofRight)
    | SkeletonNodeIndex.ofRight idxRightRight =>
      idxRightRight.ofRight.sibling.map (SkeletonNodeIndex.ofRight)

noncomputable def toMvPolynomialAlgEquiv : P ‚âÉ‚Çê[R] MvPolynomial œÉ R where
  toFun := toMvPolynomialAlgHom
  invFun := ofMvPolynomialAlgHom
  left_inv p := by admit /- proof elided -/

@[inline] def div [Zero T] [DecidableEq T] [ToNat T]
    (dividend divisor : Cayley T) : Cayley T :=
  
  letI fuel := (‚Üëdividend : Nat) + 1
  divNat dividend divisor fuel

def capacitySegmentDupHash : Prop :=
  let ‚ü®baseTrace, _‚ü© := removeRedundantEntryDS trace
  ‚àÉ j : Fin baseTrace.length, ‚àÉ capSeg : Vector U SpongeSize.C,
    ‚àÉ stmt : StmtIn, baseTrace[j] = ‚ü®.inl (), stmt, capSeg‚ü© ‚àß
      ‚àÉ j' < j,
        ‚àÉ stmt', baseTrace[j'] = ‚ü®.inl (), stmt', capSeg‚ü© ‚à®
        (‚àÉ stateIn1 stateOut1, baseTrace[j'] = ‚ü®.inr .Fwd, stateIn1, stateOut1‚ü©
          ‚àß stateOut1.capacitySegment = capSeg) ‚à®
        (‚àÉ stateOut2 stateIn2, baseTrace[j'] = ‚ü®.inr .Bwd, stateOut2, stateIn2‚ü©
          ‚àß stateIn2.capacitySegment = capSeg) ‚à®
        (‚àÉ stateIn3 stateOut3, baseTrace[j'] = ‚ü®.inr .Fwd, stateIn3, stateOut3‚ü©
          ‚àß stateIn3.capacitySegment = capSeg) ‚à®
        (‚àÉ stateOut4 stateIn4, baseTrace[j'] = ‚ü®.inr .Bwd, stateOut4, stateIn4‚ü©
          ‚àß stateOut4.capacitySegment = capSeg)

alias E_h := capacitySegmentDupHash

instance : Pow (UniPoly R) Nat := ‚ü®UniPoly.pow‚ü©

PFunctor.Lens in ToMathlib.PFunctor.Basic

Int.natAbs in Init.Data.Int.Basic

List.max in Init.Data.List.Basic

SetLike in Mathlib.Data.SetLike.Basic

def IterType (n : ‚Ñï) : Type := dfoldl' n (fun _ => Type) (fun _ T => T √ó T) Nat


example : IterType 0 = Nat := rfl
example (n : ‚Ñï) : IterType (n + 1) = (IterType n √ó IterType n) := rfl

instance : Fintype (pSpec.MessageIdx) := Subtype.fintype (fun i => pSpec.dir i = .P_to_V)

def absorbFast (sponge : DuplexSponge U C) (arr : Array U) :
    OracleComp (forwardPermutationOracle C) (DuplexSponge U C) := do
  
  let sponge1 := { sponge with squeezePos := Fin.last SpongeSize.R }
  
  
  if hEmpty : arr.isEmpty then
    return sponge1
  else
    
    
    if hFull : sponge.absorbPos = SpongeSize.R then do
      
      have : 0 < sponge.absorbPos := by admit /- proof elided -/

def constantCode {Œ± : Type*} (x : Œ±) (Œπ' : Type*) [Fintype Œπ'] : Œπ' ‚Üí Œ± := fun _ ‚Ü¶ x

instance instDCastPSigma : DCast ((a : Œ±) √ó' Œ≤ a) (fun a => Œ≥ a.1 a.2) where
  dcast hab c := dcast‚ÇÇ (by admit /- proof elided -/
  ) (by admit /- proof elided -/
  ) c
  dcast_id := by admit /- proof elided -/

@[reducible]
def coreInteractionOracleVerifier :=
  OracleVerifier.append (oSpec:=[]‚Çí)
    (Stmt‚ÇÅ := Statement (L := L) (‚Ñì:=‚Ñì) (SumcheckBaseContext L ‚Ñì) 0)
    (Stmt‚ÇÇ := Statement (L := L) (‚Ñì:=‚Ñì) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì))
    (Stmt‚ÇÉ := FinalSumcheckStatementOut (L:=L) (‚Ñì:=‚Ñì))
    (OStmt‚ÇÅ := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë 0)
    (OStmt‚ÇÇ := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (OStmt‚ÇÉ := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (pSpec‚ÇÅ := pSpecSumcheckFold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (pSpec‚ÇÇ := pSpecFinalSumcheckStep (L:=L))
    (V‚ÇÅ := sumcheckFoldOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (V‚ÇÇ := finalSumcheckVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))

@[inline] def toT [Zero T] (c : Cayley T) : T := c.toFun 0

BitVec.xor in Init.Data.BitVec.Basic

def ratchet (state : FSProverState U H R) :
    Except DomainSeparatorMismatch (FSProverState U H R) :=
  match state.hashState.ratchet with
  | .ok newHashState =>
    .ok { rng := state.rng, hashState := newHashState, nargString := state.nargString }
  | .error e => .error e

def partialEval {k : ‚Ñï} (f : MvPolynomial (Fin m) F) (Œ± : Fin k ‚Üí F) (h : k ‚â§ m) :
    MvPolynomial (Fin (m - k)) F :=
  let œÜ : Fin m ‚Üí MvPolynomial (Fin (m - k)) F := fun i =>
    if h' : i.val < k then
      C (Œ± ‚ü®i.val, h'‚ü©)
    else
      let j := i.val - k
      let j' : Fin (m - k) := ‚ü®j, sorry‚ü©
      X j'
  eval‚ÇÇ C œÜ f

IO in Init.System.IO

instance : ‚àÄ i, SelectableType ((pSpecLastBlock (L:=L) (œë:=œë)).Challenge i) :=
  instSelectableTypeChallengeSeqCompose

instance [ProverFirst pSpec] [h : OracleInterface (pSpec.¬´Type¬ª 0)] :
    ‚àÄ i, OracleInterface (pSpec.Message i)
  | ‚ü®0, _‚ü© => inferInstance

noncomputable def qMap_total_fiber
    
      (i : Fin r) (steps : ‚Ñï) (h_i_add_steps : i.val + steps < ‚Ñì + ùì°)
        (y : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i.val + steps, by admit /- proof elided -/
        ‚ü©)) :
    Fin (2 ^ steps) ‚Üí sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i :=
  if h_steps : steps = 0 then by
    
    subst h_steps
    simp only [add_zero, Fin.eta] at y
    exact fun _ => y
  else by
    
    let basis_y := sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i+steps,by admit /- proof elided -/
    ‚ü©) (by admit /- proof elided -/
    )
    let y_coeffs : Fin (‚Ñì + ùì° - (‚Üëi + steps)) ‚Üí‚ÇÄ ùîΩq := basis_y.repr y

    let basis_x := sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i, by admit /- proof elided -/
    ‚ü© (by admit /- proof elided -/
    )
    exact fun elementIdx => by admit /- proof elided -/

BitVec.ofNat in Init.Prelude

noncomputable def commitOracleReduction (i : Fin ‚Ñì) (hCR : isCommitmentRound ‚Ñì œë i) :
  OracleReduction (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) Context i.succ)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (pSpec := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) where
  prover := commitOracleProver ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i
  verifier := commitOracleVerifier ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hCR

def backTrack (trace : QueryLog (duplexSpongeChallengeOracle StmtIn U))
    (state : CanonicalSpongeState U) :
    OptionT Option ((StmtIn √ó (i : Fin (n + 1)) √ó (pSpec.MessagesUpTo i))) :=
  sorry

@[reducible]
def FinalStatement (F : Type) (k : ‚Ñï) : Type := Fin (k + 1) ‚Üí F

def Œ≥ (x‚ÇÄ : F) (R : F[X][X][Y]) (H : F[X][Y]) [œÜ : Fact (Irreducible H)] : PowerSeries (ùïÉ H) :=
  let subst (t : ‚Ñï) : ùïÉ H :=
    match t with
    | 0 => fieldToùïÉ (-x‚ÇÄ)
    | 1 => 1
    | _ => 0
  PowerSeries.subst (PowerSeries.mk subst) (PowerSeries.mk (Œ± x‚ÇÄ R H))

def knowledgeStateFunction :
    (oracleVerifier oSpec OStatement).KnowledgeStateFunction init impl
    (relIn OStatement) (relOut OStatement) (rbrExtractor oSpec OStatement) where
  toFun
  | 0 => fun ‚ü®_, oracles‚ü© _ _ => oracles 0 = oracles 1
  | 1 => fun ‚ü®_, oracles‚ü© chal _ =>
    let q : Query OStatement := by admit /- proof elided -/

def Prover.addSalt (P : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec)
    (saltComp : (i : pSpec.MessageIdx) ‚Üí P.PrvState i.1.castSucc ‚Üí OracleComp oSpec (Salt i)) :
  Prover oSpec StmtIn WitIn StmtOut WitOut (pSpec.addSalt Salt) where
  PrvState := P.PrvState
  input := P.input
  sendMessage := fun i st => by admit /- proof elided -/

def snd (T : (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).Transcript k) : pSpec‚ÇÇ.Transcript ‚ü®k - m, by admit /- proof elided -/
‚ü© :=
  if hk : k ‚â§ m then
    fun i => Fin.elim0 (by admit /- proof elided -/
    )
  else
    fun i => sorry

noncomputable def finalSumcheckKnowledgeStateFunction {œÉ : Type} (init : ProbComp œÉ)
    (impl : QueryImpl []‚Çí (StateT œÉ ProbComp)) :
    (finalSumcheckVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).KnowledgeStateFunction init impl
    (relIn := roundRelation ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (ùìë := ùìë) (mp := BBF_SumcheckMultiplierParam) (Fin.last ‚Ñì))
    (relOut := finalSumcheckRelOut ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (extractor := finalSumcheckRbrExtractor ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
  where
  toFun := fun m ‚ü®stmt, oStmt‚ü© tr witMid =>
    finalSumcheckKStateProp ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (ùìë := ùìë) (tr := tr) (stmt := stmt) (witMid := witMid) (oStmt := oStmt)
  toFun_empty := fun stmt witMid => by admit /- proof elided -/

@[inline]
def ofInputOnly
    (liftWit : OuterStmtIn √ó OuterWitOut ‚Üí InnerWitIn ‚Üí OuterWitIn) :
    Witness.InvLens OuterStmtIn OuterWitIn OuterWitOut InnerWitIn OuterWitOut :=
  ‚ü®Prod.snd, liftWit‚ü©

class PrimeOrder (G : Type*) [Group G] where
  p : ‚Ñï
  [hPrime : Fact (Nat.Prime p)]
  hCard : Nat.card G = p

def fst (T : (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).Transcript k) : pSpec‚ÇÅ.Transcript ‚ü®min k m, by admit /- proof elided -/
‚ü© :=
  if hk : k ‚â§ m then
    fun i => by admit /- proof elided -/

def OuterStmtIn_Test := ‚Ñ§[X] √ó ‚Ñ§[X] √ó ‚Ñ§

structure PowTwoRepr where
  two_exp : ‚Ñï
  odd_part : ‚Ñï

def outputRelation (cond : ‚àë i, (s i).1 ‚â§ n) [DecidableEq F] (Œ¥ : ‚Ñù‚â•0) :
    Set
      (
        (Statement F i.succ √ó (‚àÄ j, OracleStatement D x s i.succ j)) √ó
        Witness F s d i.succ.castSucc
      ) := sorry

def hcons {n : ‚Ñï} {Œ± : Sort u} {Œ≤ : Fin n ‚Üí Sort u} (a : Œ±) (b : (i : Fin n) ‚Üí Œ≤ i) :
    (i : Fin (n + 1)) ‚Üí Fin.vcons Œ± Œ≤ i :=
  fcons (F := id) a b

œÜ in ToMathlib.Control.Monad.Relative

Units.mulAction' in Mathlib.Algebra.Group.Action.Units

RatFunc in Mathlib.FieldTheory.RatFunc.Defs

@[reducible, simp] def OStmtIn : Unit ‚Üí Type := fun _ => R‚¶É‚â§ deg‚¶Ñ[X]

@[inline, specialize]
def reduction : Reduction oSpec Statement Unit Statement Unit !p[] where
  prover := prover oSpec Statement
  verifier := verifier oSpec Statement pred

def zero {k : ‚Ñï} : ConcreteBTField k := BitVec.zero (2 ^ k)

def getConst (k : ‚Ñï) (s : Fin (k + 1) ‚Üí ‚Ñï+) : OracleComp [FinalOracleStatement D x s]‚Çí F[X] :=
  OracleComp.lift
    (by admit /- proof elided -/
    )

@[reducible, simp]
def MessageIdx (pSpec : ProtocolSpec n) :=
  {i : Fin n // pSpec.dir i = Direction.P_to_V}

noncomputable def proximity_gap_johnson (rho : ‚Ñö) (m : ‚Ñï) : ‚Ñù :=
  (1 : ‚Ñù) - Real.sqrt rho - Real.sqrt rho / (2 * m)

noncomputable def toPoly (p : UniPoly R) : Polynomial R :=
  p.eval‚ÇÇ Polynomial.C Polynomial.X

def commitKState (i : Fin ‚Ñì) (hCR : isCommitmentRound ‚Ñì œë i) :
    (commitOracleVerifier ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      i hCR).KnowledgeStateFunction init impl
      (relIn := foldStepRelOut (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i.succ)
      (extractor := commitRbrExtractor ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) where
  toFun := fun m ‚ü®stmtIn, oStmtIn‚ü© tr witMid =>
    commitKStateProp ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (i := i) (m := m) (stmtIn := stmtIn) (witMid := witMid) (oStmtIn := oStmtIn) (mp:=mp)
  toFun_empty := fun stmtIn witMid => by admit /- proof elided -/

def computableBasisExplicit (k : ‚Ñï) (i : Fin (2 ^ k)) : ConcreteBTField k :=
  (Finset.univ : Finset (Fin k)).prod fun j =>
    if Nat.getBit (n := i.val) (k := j.val) == 1 then
      concreteTowerAlgebraMap (j.val + 1) k (by admit /- proof elided -/
      ) (Z (j.val + 1))
    else
      1

def OuterStmtOut_Test := ‚Ñ§[X] √ó ‚Ñ§[X] √ó ‚Ñ§ √ó ‚Ñ§

def reduction (i : Fin n) : Reduction oSpec
    ((StatementRound R n i.castSucc) √ó (‚àÄ i, OracleStatement R n deg i)) Unit
    ((StatementRound R n i.succ) √ó (‚àÄ i, OracleStatement R n deg i)) Unit (pSpec R deg) :=
  (Simple.reduction R deg D oSpec).liftContext (oCtxLens R n deg D i).toContext

noncomputable def funcQuotient (f : Œπ ‚Üí F) (S : Finset F) (Ans Fill : S ‚Üí F) : Œπ ‚Üí F :=
  fun x =>
    if hx : x.val ‚àà S then Fill ‚ü®x.val, hx‚ü© 
    else (f x - (ansPoly S Ans).eval x.val) / (vanishingPoly S).eval x.val

def forwardRange (n : ‚Ñï) (r : Fin (n)) (l : Fin (r.val + 1)) : List (Fin n) :=
  let len := r.val - l.val + 1
  List.ofFn (fun (k : Fin len) =>
    let val := l.val + k.val
    have h_bound : val < n := by admit /- proof elided -/
  )

def distCodewords [DecidableEq F] (U V : Matrix Œ∫ Œπ F) : ‚Ñï :=
  (Matrix.neqCols U V).card

noncomputable def foldOracleReduction (i : Fin ‚Ñì) :
  OracleReduction (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) Context i.castSucc)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (pSpec := pSpecFold (L := L)) where
  prover := foldOracleProver ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i
  verifier := foldOracleVerifier ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i

def hammingClose (i : Fin (‚Ñì + 1)) (f : OracleFunction ùîΩq Œ≤
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) : Prop :=
  2 * Code.distFromCode (u := f)
    (C := BBF_Code ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) <
    (BBF_CodeDistance ‚Ñì ùì° i : ‚Ñï‚àû)

def params16 : Params where
  width := 16
  numFullRounds := 8
  numPartialRounds := 20
  internalDiagVectors := #v[
       -2,
        1,
        2,
        1 / 2,
        3,
        4,
        -1 / 2,
        -3,
        -4,
        1 / (2 ^ 8),
        1 / 8,
        1 / (2 ^ 24),
        -1 / (2 ^ 8),
        -1 / 8,
        -1 / 16,
        -1 / (2 ^ 24),
    ]
  roundConstants := rawConstants16
  width_dvd_by_4 := by admit /- proof elided -/

protected def cast (P : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec‚ÇÅ) :
    Prover oSpec StmtIn WitIn StmtOut WitOut pSpec‚ÇÇ where
  PrvState := P.PrvState ‚àò Fin.cast (congrArg (¬∑ + 1) hn.symm)
  input := P.input
  sendMessage := fun i st => do
    let ‚ü®msg, newSt‚ü© ‚Üê P.sendMessage (i.cast hn.symm (cast_symm hSpec)) st
    return ‚ü®(Message.cast_idx_symm hSpec) ‚ñ∏ msg, newSt‚ü©
  receiveChallenge := fun i st => do
    let f ‚Üê P.receiveChallenge (i.cast hn.symm (cast_symm hSpec)) st
    return fun chal => f (Challenge.cast_idx hSpec ‚ñ∏ chal)
  output := P.output ‚àò (fun st => _root_.cast (by admit /- proof elided -/
  ) st)

Array.size in Init.Prelude

instance [Zero T] [ToNat T] : LE (Cayley T) where
  le := le

noncomputable instance {i : Fin r} (x : L) : Decidable (x ‚àà (U ùîΩq Œ≤ i : Set L)) :=

def powFiber (S : Finset Œπ) (œÜ : Œπ ‚Ü™ F) (k : ‚Ñï) (y : indexPow S œÜ k) : Finset Œπ :=
  S.filter (fun x => (œÜ x) ^ k = y)

List.map in Init.Prelude

def weightedDegree.{u} {F : Type u} [Semiring F] (p : F[X][Y]) (u v : ‚Ñï) : Option ‚Ñï :=
  List.max? <|
    List.map (fun n => u * (p.coeff n).natDegree + v * n) (List.range p.natDegree.succ)

Nat.ceil in Mathlib.Algebra.Order.Floor.Defs

class IsRBRSound (langIn : Set StmtIn) (langOut : Set StmtOut)
    (verifier : Verifier oSpec StmtIn StmtOut pSpec) where
  rbrSoundnessError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0
  is_rbr_sound : rbrSoundness init impl langIn langOut verifier rbrSoundnessError

def mul (a b : AssocNat) : AssocNat :=
  mulNat a b.toNat

class IsSecureWithGap
    (completeRelation : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (soundRelation : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (Œµ_rbr : vPSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0)
    (vectorIOP : VectorIOP Statement OStatement Witness vPSpec A) where

   
  is_complete : vectorIOP.perfectCompleteness (pure ()) ‚ü®isEmptyElim‚ü© completeRelation

   
  is_rbr_knowledge_sound :
    OracleProof.rbrKnowledgeSoundness (pure ()) ‚ü®isEmptyElim‚ü© soundRelation vectorIOP.verifier Œµ_rbr

Fin.castSucc in Init.Data.Fin.Basic

@[reducible]
def backwardPermutationOracle (Œ± : Type*) : OracleSpec Unit := Œ± ‚Üí‚Çí Œ±

@[inline, reducible]
def lift : OuterStmtIn √ó OuterWitIn ‚Üí InnerStmtOut √ó InnerWitOut ‚Üí OuterWitOut :=
  lens.toFunB

instance instDCast‚ÇÉ : DCast‚ÇÉ Nat (fun n => Fin (n + 1)) (fun n _ => ProtocolSpec n)
    (fun _ k pSpec => pSpec.Transcript k) where
  dcast‚ÇÉ h h' h'' T := Transcript.cast h
    (by admit /- proof elided -/
    )
    (by admit /- proof elided -/
    )
    T
  dcast‚ÇÉ_id := cast_id

def StateRestoration.Soundness (oSpec : OracleSpec Œπ) (StmtIn : Type)
    {n : ‚Ñï} (pSpec : ProtocolSpec n) :=
  OracleComp (oSpec ++‚Çí (srChallengeOracle StmtIn pSpec)) (StmtIn √ó pSpec.Messages)

def PowerType (n : ‚Ñï) : Type := dfoldr' n (fun _ => Type) (fun _ T => T ‚Üí T) Nat


example : PowerType 0 = Nat := rfl
example (n : ‚Ñï) : PowerType (n + 1) = (PowerType n ‚Üí PowerType n) := rfl

  inductive UnverifiedPrattPart : Type
    | prime : (p : ‚Ñï) ‚Üí (k : ‚Ñï) ‚Üí (hp : UnverifiedPrattCertificate p) ‚Üí UnverifiedPrattPart
    | split : UnverifiedPrattPart ‚Üí UnverifiedPrattPart ‚Üí UnverifiedPrattPart
  deriving Repr

def ratchetUnchecked [Permute C] (sponge : DuplexSponge U C) : DuplexSponge U C :=
  simulateQ' forwardPermutationOracleImpl (ratchet sponge) (by admit /- proof elided -/
  )

def commitKStateProp (i : Fin ‚Ñì) (m : Fin (1 + 1))
  (stmtIn : Statement (L := L) Context i.succ)
  (witMid : Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
  (oStmtIn : (i_1 : Fin (toOutCodewordsCount ‚Ñì œë i.castSucc)) ‚Üí
    OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc i_1)
  : Prop :=

  match m with
  | ‚ü®0, _‚ü© => 
    masterKStateProp (mp := mp) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (stmtIdx := i.succ) (oracleIdx := i.castSucc)
      (h_le := by admit /- proof elided -/
      )
      (stmt := stmtIn) (wit := witMid) (oStmt := oStmtIn)
      (localChecks := True)
  | ‚ü®1, _‚ü© => 
    let ‚ü®_, stmtOut, oStmtOut, witOut‚ü© := getCommitProverFinalOutput ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i ‚ü®stmtIn, oStmtIn, witMid‚ü©
    masterKStateProp (mp := mp) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (stmtIdx := i.succ) (oracleIdx := i.succ)
      (h_le := le_refl _)
      (stmt := stmtOut) (wit := witOut) (oStmt := oStmtOut)
      (localChecks := True)

def OracleReduction.append (R‚ÇÅ : OracleReduction oSpec Stmt‚ÇÅ OStmt‚ÇÅ Wit‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ Wit‚ÇÇ pSpec‚ÇÅ)
    (R‚ÇÇ : OracleReduction oSpec Stmt‚ÇÇ OStmt‚ÇÇ Wit‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ Wit‚ÇÉ pSpec‚ÇÇ) :
      OracleReduction oSpec Stmt‚ÇÅ OStmt‚ÇÅ Wit‚ÇÅ Stmt‚ÇÉ OStmt‚ÇÉ Wit‚ÇÉ (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ) where
  prover := Prover.append R‚ÇÅ.prover R‚ÇÇ.prover
  verifier := OracleVerifier.append R‚ÇÅ.verifier R‚ÇÇ.verifier

noncomputable def polyToPowerSeriesùïÉ (H : F[X][Y])
  (P : F[X][Y])
    : PowerSeries (ùïÉ H) :=
  PowerSeries.mk <| fun n =>
    liftToFunctionField (P.coeff n)

def canonicalAlgMap (k : ‚Ñï) := concreteCanonicalEmbedding (k:=k)
  (prevBTFieldProps:= ((getBTFResult k).toConcreteBTFieldProps))
  (curBTFieldProps:= ((getBTFResult (k + 1)).toConcreteBTFieldProps))

OracleComp.SelectableType in VCVio.OracleComp.Constructions.UniformSelect

Polynomial.evalEvalRingHom in Mathlib.Algebra.Polynomial.Bivariate

noncomputable def relayOracleVerifier (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
  OracleVerifier
    (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) Context i.succ)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (pSpec := pSpecRelay) where
  verify := fun stmtIn _ => pure stmtIn
  embed := ‚ü®fun j => by admit /- proof elided -/
  ‚ü©
  hEq := fun oracleIdx => by admit /- proof elided -/

Mul in Init.Prelude

def testNTTBTF‚ÇÉ : Fin (2 ^ (2 + 2)) ‚Üí BTF‚ÇÉ :=

OracleComp.neverFailsWhen in VCVio.OracleComp.Traversal

@[inline, specialize]
def mulX (p : UniPoly R) : UniPoly R := p.mulPowX 1

HMod.hMod in Init.Prelude

@[reducible]
noncomputable def reduction [DecidableEq F] :
  OracleReduction []‚Çí
    (Statement F (0 : Fin (k + 1))) (OracleStatement D x s (0 : Fin (k + 1)))
      (Witness F s d (0 : Fin (k + 2)))
    (FinalStatement F k) (FinalOracleStatement D x s) (Witness F s d (Fin.last (k + 1)))
    (pSpecFold D x k s ++‚Çö FinalFoldPhase.pSpec F ++‚Çö QueryRound.pSpec D x l) :=
  OracleReduction.append (reductionFold D x k s d)
    (QueryRound.queryOracleReduction (k := k) D x s d dom_size_cond l)

Matrix.det in Mathlib.LinearAlgebra.Matrix.Determinant.Basic

def someTypes : List Type := [Nat, String, Nat]

def sBasis (i : Fin r) (h_i : i < ‚Ñì + R_rate) : Fin (‚Ñì + R_rate - i) ‚Üí L :=
  fun k => Œ≤ ‚ü®i + k.val, by admit /- proof elided -/
  ‚ü©

algebraMap in Mathlib.Algebra.Algebra.Defs

instance {i : ‚Ñï} : SmoothPowerOfTwo (n - i) (evalDomain D i) where
  smooth := by admit /- proof elided -/

def natCast_zero {k : ‚Ñï} : natCast (k:=k) 0 = zero :=

def finalSumcheckKnowledgeError (m : pSpecFinalSumcheckStep (L := L).ChallengeIdx) :
  ‚Ñù‚â•0 :=
  match m with
  | ‚ü®0, h0‚ü© => nomatch h0

Vector.foldl in Init.Data.Vector.Basic

Vector.get in Init.Data.Vector.Basic

instance : Field BTF‚ÇÉ := instFieldConcrete

def ConcreteBTFieldAlgebra {l r : ‚Ñï} (h_le : l ‚â§ r) :
    Algebra (ConcreteBTField l) (ConcreteBTField r) := instAlgebraTowerConcreteBTF.toAlgebra h_le

Algebra.TensorProduct.comm in Mathlib.RingTheory.TensorProduct.Maps

instance [Zero T] [ToNat T] : Mul (Cayley T) where
  mul := mul

def squeezeUnchecked [Permute C] (sponge : DuplexSponge U C) (arr : Array U) :
    DuplexSponge U C √ó Array U :=
  simulateQ' (m := Id) forwardPermutationOracleImpl (squeezeInto sponge arr) (by admit /- proof elided -/
  )

def combine
  (œÜ : Œπ ‚Ü™ F) (dstar : ‚Ñï) (r : F) (fs : Fin m ‚Üí Œπ ‚Üí F) (degs : Fin m ‚Üí ‚Ñï) (x : Œπ) : F :=
    ‚àë i, (ri dstar degs r i) * (fs i x) * (‚àë l ‚àà range (dstar - degs i + 1), ((œÜ x) * r)^l)

Finsupp.equivFunOnFinite in Mathlib.Data.Finsupp.Defs

FreeMonad in ToMathlib.Control.Monad.Free

def dedup {Œπ : Type} (spec : OracleSpec Œπ) : SimOracle.Stateless (spec ++‚Çí spec) spec where
  impl
  | query (.inl i) t => query i t
  | query (.inr i) t => query i t

@[simp]
abbrev OracleStatement.AfterLinearCombination : R1CS.MatrixIdx ‚äï R1CS.MatrixIdx ‚äï Fin 1 ‚Üí Type :=
  Sum.elim (EvalClaim R) (OracleStatement.AfterFirstSumcheck R pp)

inductive FullData (Œ± : Type) : Skeleton ‚Üí Type
  | leaf (value : Œ±) : FullData Œ± Skeleton.leaf
  | internal {left right} (value : Œ±)
      (leftData : FullData Œ± left)
      (rightData : FullData Œ± right) :
      FullData Œ± (Skeleton.internal left right)
  deriving Repr

def line [Ring F] (u v : Œπ ‚Üí F) : AffineSubspace F (Œπ ‚Üí F) :=
  affineSpan _ {u, v}

def fiberwiseDisagreementSet (i : Fin ‚Ñì) (steps : ‚Ñï) [NeZero steps]
    (h_i_add_steps : i.val + steps ‚â§ ‚Ñì) (f g : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate :=
      h_‚Ñì_add_R_rate) ‚ü®i, by admit /- proof elided -/
      ‚ü©) :
  Set ((sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®i.val + steps, by admit /- proof elided -/
  ‚ü©) :=
  
    
  {y | ‚àÉ x, iteratedQuotientMap ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := i)
    (k := steps) (h_bound := by admit /- proof elided -/
    ) x = y ‚àß f x ‚â† g x}

BitVec.append in Init.Data.BitVec.Basic

def toOracleImpl {Œπ : Type u} (v : Œπ ‚Üí Type v) [O : ‚àÄ i, OracleInterface (v i)]
    (data : ‚àÄ i, v i) : QueryImpl [v]‚Çí Id where
  impl | query i t => (O i).answer (data i) t

@[inline] def ge [Zero T] [ToNat T] (a b : Cayley T) : Prop :=
  (a : Nat) ‚â• (b : Nat)

MvPolynomial.degrees in Mathlib.Algebra.MvPolynomial.Degrees

def perm (cs : ConstraintSystem ùì° numWires numGates) : Equiv.Perm (Fin (3 * numGates)) := sorry

WeierstrassCurve in Mathlib.AlgebraicGeometry.EllipticCurve.Weierstrass

@[inline]
def ofOutputOnly
    (witLift :
      OuterStmtIn √ó OuterWitIn ‚Üí InnerStmtOut √ó InnerWitOut ‚Üí OuterWitOut)
    (stmtLift : OuterStmtIn ‚Üí InnerStmtOut ‚Üí OuterStmtOut) :
    Context.Lens OuterStmtIn OuterStmtOut OuterStmtIn InnerStmtOut
                OuterWitIn OuterWitOut OuterWitIn InnerWitOut where
  wit := Witness.Lens.ofOutputOnly witLift
  stmt := Statement.Lens.ofOutputOnly stmtLift

@[ext]
structure Equiv {m n : ‚Ñï} (pSpec : ProtocolSpec m) (pSpec' : ProtocolSpec n) where
  round_eq : m = n
  dir_eq : ‚àÄ i, pSpec.dir i = pSpec'.dir (Fin.cast round_eq i)
  typeEquiv : ‚àÄ i, pSpec.¬´Type¬ª i ‚âÉ pSpec'.¬´Type¬ª (Fin.cast round_eq i)

def indexPow (S : Finset Œπ) (œÜ : Œπ ‚Ü™ F) (k : ‚Ñï) : Finset F :=
  S.image (fun x => (œÜ x) ^ k)

Multiset.map in Mathlib.Data.Multiset.MapFold

@[reducible]
def permutationOracle (Œ± : Type*) : OracleSpec PermuteDir :=
  forwardPermutationOracle Œ± ++‚Çí backwardPermutationOracle Œ±

@[inline, specialize]
def oracleProver : OracleProver oSpec
    Statement OStatement (‚àÄ i, Witness i)
    Statement (OStatement ‚äï·µ• Witness) Unit
    (oraclePSpec Witness) where
  PrvState := fun _ => (Statement √ó (‚àÄ i, OStatement i)) √ó (‚àÄ i, Witness i)
  input := id
  sendMessage | ‚ü®0, _‚ü© => fun ‚ü®stmt, wit‚ü© => pure (wit, ‚ü®stmt, wit‚ü©)
  
  receiveChallenge | ‚ü®0, h‚ü© => nomatch h
  output := fun ‚ü®‚ü®stmt, oStmt‚ü©, wit‚ü© => pure (‚ü®stmt, Sum.rec oStmt wit‚ü©, ())

abbrev ScalarField := ZMod scalarFieldSize

def InternalData.rightSubtree {Œ± : Type} {s_left s_right : Skeleton}
    (tree : InternalData Œ± (Skeleton.internal s_left s_right)) :
    InternalData Œ± s_right :=
  match tree with
  | InternalData.internal _ _left right =>
    right

@[simp]
instance AlgebraTower.toIsScalarTower (a : AlgebraTower C) {i j k : Œπ}
    (h1 : i ‚â§ j) (h2 : j ‚â§ k) :
    letI : Algebra (C i) (C j) :=

@[reducible, simp]
def relOut : Set ((StmtOut OStatement √ó ‚àÄ i, OStmtOut OStatement i) √ó WitOut) :=
  { ‚ü®‚ü®q, oStmt‚ü©, ()‚ü© | answer (oStmt 0) q = answer (oStmt 1) q }

def halfNumFullRounds : Nat := params.numFullRounds / 2

AddMonoid in Mathlib.Algebra.Group.Defs

def intCast_ofNat {k : ‚Ñï} (n : ‚Ñï) : intCast (k:=k) (n : ‚Ñ§) = natCast n :=

noncomputable def listDecodingCollisionProbability
  (œÜ : Œπ ‚Ü™ F) (f : Œπ ‚Üí F) (Œ¥ : ‚Ñù) (s degree : ‚Ñï)
  (h_nonempty : Nonempty (domainComplement œÜ)) : ENNReal :=
  Pr_{let r ‚Üê$·µñ (Fin s ‚Üí domainComplement œÜ)}[ ‚àÉ (u u' : code œÜ degree),
                                    u.val ‚â† u'.val ‚àß
                                    u.val ‚àà relHammingBall (code œÜ degree) f Œ¥ ‚àß
                                    u'.val ‚àà relHammingBall (code œÜ degree) f Œ¥ ‚àß
                                    ‚àÄ i : Fin s,
                                    let uPoly := decodeLT u
                                    let uPoly' := decodeLT u'
                                    (uPoly : F[X]).eval (r i).1
                                      = (uPoly' : F[X]).eval (r i).1
                                    ]

CommGroupWithZero in Mathlib.Algebra.GroupWithZero.Defs

noncomputable def polyFold
  [DecidableEq F] (fPoly : Polynomial F)
  (k : ‚Ñï) (hk0 : 0 < k) (hkfin : k < Fintype.card F)
  (r : F) : Polynomial F :=
    let qPoly : Polynomial F := Polynomial.X ^ k
    let hdeg_q_min : qPoly.natDegree > 0 := sorry
    let hdeg_q_max : qPoly.natDegree < Fintype.card F := sorry
  
    let Q : MvPolynomial (Fin 2) F := polyQ fPoly qPoly
    MvPolynomial.eval‚ÇÇHom
      (Polynomial.C : F ‚Üí+* Polynomial F)
      (fun i : Fin 2 => if i = 0 then Polynomial.X else Polynomial.C r) Q

noncomputable def monomialOfNat (i : ‚Ñï) : (Fin n) ‚Üí‚ÇÄ ‚Ñï :=
  Finsupp.onFinset (s:=Finset.univ (Œ±:=Fin n)) (fun j => Nat.getBit j.val i) (by admit /- proof elided -/
    ) 

@[reducible]
def get {Œ±s : List (Type u)} : HList Œ±s ‚Üí (n : Fin Œ±s.length) ‚Üí Œ±s.get n
  | x ::‚Çï _, ‚ü®0, _‚ü© => x
  | _ ::‚Çï xs, ‚ü®n+1, h‚ü© => xs.get ‚ü®n, Nat.lt_of_succ_lt_succ h‚ü©

abbrev MatrixSubmodule.{u, v, w} (Œ∫ : Type u) [Fintype Œ∫] (Œπ : Type v) [Fintype Œπ]
                                 (F : Type w) [Semiring F] : Type (max u v w) :=
  Submodule F (Matrix Œ∫ Œπ F)

MonadLiftT in Init.Prelude

noncomputable def foldf (S : Finset Œπ) (œÜ : Œπ ‚Ü™ F)
  {k : ‚Ñï} [Neg (indexPowT S œÜ k)] (y : indexPowT S œÜ (k + 1))
  (f : indexPowT S œÜ k ‚Üí F) (Œ± : F) : F :=
  let xPow := extract_x S œÜ k y
  let fx := f xPow
  let f_negx := f (-xPow)
  (fx + f_negx) / 2 + Œ± * ((fx - f_negx) / (2 * (xPow.val : F)))

def minDist [DecidableEq F] (IC : MatrixSubmodule Œ∫ Œπ F) : ‚Ñï :=
  sInf { d : ‚Ñï | ‚àÉ U ‚àà IC, ‚àÉ V ‚àà IC, distCodewords U V = d }

List.IsPrefix in Init.Data.List.Basic

List.mapM' in Init.Data.List.Monadic

structure Selector (ùì° : Type*) where
   
  qL : ùì°
   
  qR : ùì°
   
  qO : ùì°
   
  qM : ùì°
   
  qC : ùì°
deriving DecidableEq

structure ParamConditions (P : Params Œπ F) where
  h_deg : ‚àÉ k : ‚Ñï, P.deg = 2^k
  h_foldingParams : ‚àÄ i : Fin (M + 1), ‚àÉ k : ‚Ñï, (P.foldingParam i) = 2^k
  h_deg_ge : P.deg ‚â• ‚àè i : Fin (M + 1), (P.foldingParam i)
  h_smooth : ‚àÄ i : Fin (M + 1), Smooth (P.œÜ i)
  h_smooth_le : ‚àÄ i : Fin (M + 1), Fintype.card (Œπ i) ‚â§ (degree Œπ P i)
  h_repeatP_le : ‚àÄ i : Fin (M + 1), P.repeatParam i + 1 ‚â§ (degree Œπ P i)

LT in Init.Prelude

def relationAfterRandomQuery :
    Set (((StmtAfterRandomQuery R) √ó (‚àÄ i, OStmtAfterRandomQuery R deg i)) √ó Unit) :=
  { ‚ü®‚ü®chal, oStmt‚ü©, _‚ü© | (oStmt (Sum.inr ())).1.eval chal = (oStmt (Sum.inl ())).1.eval chal }

protected def Reduction.id : Reduction oSpec Statement Witness Statement Witness !p[] where
  prover := Prover.id
  verifier := Verifier.id

instance [inst : ‚àÄ i, SelectableType (pSpec.Challenge i)] :
    ‚àÄ i, SelectableType ((pSpec.addSalt Salt).Challenge i) :=
  fun i => by admit /- proof elided -/

instance : ‚àÄ i, VCVCompatible (Challenge ‚ü®!v[.P_to_V], !v[Msg]‚ü© i)
  | ‚ü®0, h‚ü© => nomatch h

instance : HListRepr (HList []) where
  repr := fun _ => ""

abbrev LinearCode.{u, v} (Œπ : Type u) [Fintype Œπ] (F : Type v) [Semiring F] : Type (max u v) :=
  Submodule F (Œπ ‚Üí F)

@[reducible, simp] def WitIn := Unit

instance : Unique (Fin 0 ‚Üí Œ±) where
  uniq v := by admit /- proof elided -/

instance : Inhabited (UniPolyC R) := ‚ü®#[], Trim.canonical_empty‚ü©

Submodule.module in Mathlib.Algebra.Module.Submodule.Defs

instance : ‚àÄ i, OracleInterface (OracleStatement R pp i) :=
  fun i => {
    Query := (Fin pp.‚Ñì_m ‚Üí R) √ó (Fin pp.‚Ñì_n ‚Üí R)
    Response := R
    answer := fun matrix ‚ü®x, y‚ü© => matrix.toMLE ‚∏®C ‚àò x‚∏© ‚∏®y‚∏©
  }

def concrete_mul {k : ‚Ñï} (a b : ConcreteBTField k) : ConcreteBTField k :=
  if h_k_zero : k = 0 then
    if a = zero then zero
    else if b = zero then zero
    else if a = one then b
    else if b = one then a
    else zero 
  else
    have h_k_gt_0 : k > 0 := by admit /- proof elided -/

instance : LawfulToNat Nat where
  toNat_zero := rfl
  toNat_succ := fun _ => rfl

structure KnowledgeStateFunction
    (relIn : Set (StmtIn √ó WitIn)) (relOut : Set (StmtOut √ó WitOut))
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    {WitMid : Fin (n + 1) ‚Üí Type}
    (extractor : Extractor.RoundByRound oSpec StmtIn WitIn WitOut pSpec WitMid)
    where
   
  toFun : (m : Fin (n + 1)) ‚Üí StmtIn ‚Üí Transcript m pSpec ‚Üí WitMid m ‚Üí Prop
   
  toFun_empty : ‚àÄ stmtIn witMid,
    ‚ü®stmtIn, cast extractor.eqIn witMid‚ü© ‚àà relIn ‚Üî toFun 0 stmtIn default witMid
   
  toFun_next : ‚àÄ m, pSpec.dir m = .P_to_V ‚Üí
    ‚àÄ stmtIn tr msg witMid, toFun m.succ stmtIn (tr.concat msg) witMid ‚Üí
      toFun m.castSucc stmtIn tr (extractor.extractMid m stmtIn (tr.concat msg) witMid)
   
  toFun_full : ‚àÄ stmtIn tr witOut,
    [fun stmtOut => (stmtOut, witOut) ‚àà relOut
    | do (simulateQ impl (verifier.run stmtIn tr)).run' (‚Üê init)] > 0 ‚Üí
    toFun (.last n) stmtIn tr (extractor.extractOut stmtIn tr witOut)

instance [ProverFirst pSpec] : ‚àÄ i, VCVCompatible (pSpec.Challenge i) := isEmptyElim

noncomputable def fromRowGenMat [Semiring F] (G : Matrix Œ∫ Œπ F) : LinearCode Œπ F :=
  LinearMap.range G.vecMulLinear

def erase_odd (s : Finset ‚Ñï) : Finset ‚Ñï := s.filter Even

noncomputable def toMLE (A : Matrix (Fin (2 ^ m)) (Fin (2 ^ n)) R) : R[X Fin n][X Fin m] :=
  MLE' (MLE' ‚àò A)

protected def cast (R : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec‚ÇÅ) :
    OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec‚ÇÇ where
  prover := R.prover.cast hn hSpec
  verifier := R.verifier.cast hn hSpec hO‚Çò

def intCast {k : ‚Ñï} (n : ‚Ñ§) : ConcreteBTField k := if n % 2 = 0 then zero else one

@[reducible]
def Witness (F : Type) [NonBinaryField F] {k : ‚Ñï}
    (s : Fin (k + 1) ‚Üí ‚Ñï+) (d : ‚Ñï+) (i : Fin (k + 2)) :=
  F‚¶É< 2^((‚àë j', (s j').1) - (‚àë j' ‚àà finRangeTo i.1, (s j').1)) * d‚¶Ñ[X]

instance [O‚Çò : ‚àÄ i, OracleInterface (pSpec.Message i)] :
    ‚àÄ i, OracleInterface ((pSpec.addSalt Salt).Message i) :=
  fun i => {
    Query := (O‚Çò i).Query
    Response := (O‚Çò i).Response
    answer := fun msg => (O‚Çò i).answer (by admit /- proof elided -/
      )
  }

Fin.dfoldr in Batteries.Data.Fin.Basic

Function.LeftInverse in Init.Data.Function

structure BinaryTowerResult (F : Type _) (k : ‚Ñï) where
  vec : (List.Vector F (k + 1))
  instField : (Field F)
  instFintype : Fintype F
  specialElement : F
  specialElementNeZero : NeZero specialElement
  firstElementOfVecIsSpecialElement [Inhabited F] : vec.1.headI = specialElement
  instIrreduciblePoly : (Irreducible (p := (definingPoly specialElement)))
  sumZeroIffEq : ‚àÄ (x y : F), x + y = 0 ‚Üî x = y
  fieldFintypeCard : Fintype.card F = 2^(2^k)
  traceMapEvalAtRootsIs1 : TraceMapProperty F specialElement k

def zeroCheckVirtualPolynomial (ùï© : Statement.AfterFirstMessage R pp)
    
    (oStmt : ‚àÄ i, OracleStatement.AfterFirstMessage R pp i) :
      MvPolynomial (Fin pp.‚Ñì_m) R :=
  letI ùï´ := R1CS.ùï´ ùï© (oStmt (.inr 0))
  ‚àë x : Fin (2 ^ pp.‚Ñì_m),
    (eqPolynomial (finFunctionFinEquiv.symm x : Fin pp.‚Ñì_m ‚Üí R)) *
      C ((oStmt (.inl .A) *·µ• ùï´) x * (oStmt (.inl .B) *·µ• ùï´) x - (oStmt (.inl .C) *·µ• ùï´) x)

instance instTestLensComplete : testLens.IsComplete
      outerRelIn_Test innerRelIn_Test outerRelOut_Test innerRelOut_Test
      (fun ‚ü®‚ü®p, q, _‚ü©, _‚ü© ‚ü®‚ü®f, _‚ü©, _‚ü© => p * q = f) where
  proj_complete := fun ‚ü®p, q, t‚ü© () hRelIn => by admit /- proof elided -/

Finset.Icc in Mathlib.Order.Interval.Finset.Defs

instance {i : Fin ‚Ñì} :
    ‚àÄ j, OracleInterface ((pSpecFoldCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i).Message j) :=
  instOracleInterfaceMessageAppend (pSpec‚ÇÅ := pSpecFold (L := L))
    (pSpec‚ÇÇ := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)

instance instCharP2 {k : ‚Ñï} : CharP (ConcreteBTField k) 2 :=
  charP_eq_2_of_add_self_eq_zero (F:=(ConcreteBTField k)) (sumZeroIffEq:=add_eq_zero_iff_eq)

structure Size where
  m : ‚Ñï 
  n : ‚Ñï 
  n_w : ‚Ñï 
  n_w_le_n : n_w ‚â§ n := by admit /- proof elided -/

@[reducible, inline, specialize]
def UniPoly (R : Type*) := Array R

noncomputable def finalSumcheckRbrExtractor :
  Extractor.RoundByRound []‚Çí
    (StmtIn := (Statement (L := L) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì)) √ó (‚àÄ j, OracleStatement ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë  (Fin.last ‚Ñì) j))
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì))
    (WitOut := Unit)
    (pSpec := pSpecFinalSumcheckStep (L := L))
    (WitMid := FinalSumcheckWit (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì)) where
  eqIn := rfl
  extractMid := fun m ‚ü®stmtMid, oStmtMid‚ü© trSucc witMidSucc => by admit /- proof elided -/
    | none => 
      exact dummyLastWitness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
    | some tpoly =>
      
      exact {
        t := tpoly,
        H := projectToMidSumcheckPoly (L := L) (‚Ñì := ‚Ñì) (t := tpoly)
          (m := BBF_SumcheckMultiplierParam.multpoly stmtMid.ctx)
          (i := Fin.last ‚Ñì) (challenges := stmtMid.challenges),
        f := getMidCodewords ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) tpoly stmtMid.challenges
      }
  extractOut := fun ‚ü®stmtIn, oStmtIn‚ü© tr witOut => ()

Odd in Mathlib.Algebra.Ring.Parity

def shift_left (s : Finset ‚Ñï) : Finset ‚Ñï :=
  s.filterMap
    (fun n => match n with
      | 0 => .none
      | n + 1 => .some n
      )
    (by admit /- proof elided -/
    )

instance : DFunLike F Œ± Œ≤ where
  coe := DFunEquiv.equiv.toFun
  coe_injective' := DFunEquiv.equiv.injective

def totalNumPermQueries : Nat :=
  pSpec.totalNumPermQueriesMessage + pSpec.totalNumPermQueriesChallenge

def oracleVerifier (i : Fin n) : OracleVerifier oSpec (StatementRound R n i.castSucc)
    (OracleStatement R n deg) (StatementRound R n i.succ) (OracleStatement R n deg) (pSpec R deg) :=
  (Simple.oracleVerifier R deg D oSpec).liftContext (oStmtLens R n deg D i)

instance inhabited [Inhabited R] : Inhabited (MlPoly R n) :=

Algebra.TensorProduct.leftAlgebra in Mathlib.RingTheory.TensorProduct.Basic

List.rtake in Mathlib.Data.List.DropRight

noncomputable def S_Œ≤ {H : F[X][Y]} (Œ≤ : ùí™ H) : Set F :=
  {z : F | ‚àÉ root : rationalRoot (H_tilde' H) z, (œÄ_z z root) Œ≤ = 0}

def finalSumcheckKStateProp {m : Fin (1 + 1)} (tr : Transcript m (pSpecFinalSumcheckStep (L := L)))
    (stmt : Statement (L := L) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì))
    (witMid : FinalSumcheckWit (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) m)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì) j) : Prop :=
  match m with
  | ‚ü®0, _‚ü© => 
    masterKStateProp ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (mp := BBF_SumcheckMultiplierParam)
      (stmtIdx := Fin.last ‚Ñì) (oracleIdx := Fin.last ‚Ñì) (h_le := le_refl _)
      (stmt := stmt) (wit := witMid) (oStmt := oStmt) (localChecks := True)
  | ‚ü®1, _‚ü© => 
    let tr_so_far := (pSpecFinalSumcheckStep (L := L)).take 1 (by admit /- proof elided -/
    )
    let i_msg0 : tr_so_far.MessageIdx := ‚ü®‚ü®0, by admit /- proof elided -/
    ‚ü©, rfl‚ü©
    let c : L := (ProtocolSpec.Transcript.equivMessagesChallenges (k := 1)
      (pSpec := pSpecFinalSumcheckStep (L := L)) tr).1 i_msg0

    let stmtOut : FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì) := {
      ctx := stmt.ctx,
      sumcheck_target := stmt.sumcheck_target,
      challenges := stmt.challenges,
      final_constant := c
    }

    let sumcheckFinalCheck : Prop := stmt.sumcheck_target = eqTilde r stmt.challenges * c
    let finalFoldingProp := finalNonDoomedFoldingProp ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (h_le := by admit /- proof elided -/
        ) (input := ‚ü®stmtOut, oStmt‚ü©)

    sumcheckFinalCheck ‚àß finalFoldingProp 

structure WireIndices (numWires : ‚Ñï) where
   
  a : Fin numWires
   
  b : Fin numWires
   
  c : Fin numWires
deriving DecidableEq

@[inline, reducible]
def lift : (OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i)) √ó OuterWitIn ‚Üí
    (InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i)) √ó InnerWitOut ‚Üí
    (OuterStmtOut √ó (‚àÄ i, OuterOStmtOut i)) √ó OuterWitOut :=
  fun ctxIn ctxOut => ‚ü®lens.stmt.lift ctxIn.1 ctxOut.1, lens.wit.lift ctxIn ctxOut‚ü©

@[reducible, inline]
instance instMvPolynomial : OracleInterface (R[X œÉ]) where
  Query := œÉ ‚Üí R
  Response := R
  answer := fun poly point => eval point poly

Set.offDiag in Mathlib.Data.Set.Operations

def InternalData.leftSubtree {Œ± : Type} {s_left s_right : Skeleton}
    (tree : InternalData Œ± (Skeleton.internal s_left s_right)) :
    InternalData Œ± s_left :=
  match tree with
  | InternalData.internal _ left _right =>
    left

PFunctor.X in ToMathlib.PFunctor.Basic

def LeafData.get {s} {Œ± : Type}
    (tree : LeafData Œ± s) (idx : SkeletonLeafIndex s) : Œ± :=
  match tree, idx with
  | LeafData.leaf value, SkeletonLeafIndex.ofLeaf => value
  | LeafData.internal left _, SkeletonLeafIndex.ofLeft idxLeft =>
    LeafData.get left idxLeft
  | LeafData.internal _ right, SkeletonLeafIndex.ofRight idxRight =>
    LeafData.get right idxRight

instance [IsSingleRound pSpec] [h : OracleInterface (pSpec.Message default)] :
    (i : pSpec.MessageIdx) ‚Üí OracleInterface (pSpec.Message i) := fun i => by admit /- proof elided -/

commit in VCVio.CryptoFoundations.SigmaAlg

Matrix in Mathlib.LinearAlgebra.Matrix.Defs

Fintype.ofFinite in Mathlib.Data.Fintype.EquivFin

def pSpecQuery : ProtocolSpec 1 :=
  ‚ü®![Direction.V_to_P],
    ![Fin Œ≥_repetitions ‚Üí sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate 0]‚ü©

@[simp]
def extractorLens (i : Fin n) : Extractor.Lens
    (StatementRound R n i.castSucc √ó (‚àÄ i, OracleStatement R n deg i))
    (StatementRound R n i.succ √ó (‚àÄ i, OracleStatement R n deg i))
    (Simple.StmtIn R √ó (‚àÄ i, Simple.OStmtIn R deg i))
    (Simple.StmtOut R √ó (‚àÄ i, Simple.OStmtOut R deg i))
    Unit Unit Unit Unit where
  stmt := oStmtLens R n deg D i
  wit := Witness.InvLens.trivial

def removeNth (p : Fin (n + 1)) (s : Fin (n + 1) ‚Üí‚ÇÄ M) : Fin n ‚Üí‚ÇÄ M :=
  Finsupp.equivFunOnFinite.symm (Fin.removeNth p s : Fin n ‚Üí M)

Finset.filterMap in Mathlib.Data.Finset.Image

def Oracle.containsCache {Œπ : Type} {spec : OracleSpec Œπ}
    (f : spec.FunctionType) (cache : spec.QueryCache) :
    Prop :=
  ‚àÄ i q r, cache i q = some r ‚Üí f i q = r

def equivMonomialLagrangeRepr : MlPoly R n ‚âÉ MlPolyEval R n where
  toFun := monoToLagrange n
  invFun := lagrangeToMono n
  left_inv v := by admit /- proof elided -/

@[reducible, simp] def WitIn := Unit

inductive Data (Œ± : Type) :
    {n : ‚Ñï} ‚Üí {ar : Fin n ‚Üí ‚Ñï} ‚Üí Skeleton n ar ‚Üí Type where
  | leaf {ar0 : Fin 0 ‚Üí ‚Ñï} (value : Œ±) :
      Data Œ± (Skeleton.leaf (ar0 := ar0))
  | node {n : ‚Ñï} {ar : Fin (n+1) ‚Üí ‚Ñï}
      {children : Fin (ar 0) ‚Üí
        Skeleton n (fun i => ar i.succ)}
      (value : Œ±)
      (childrenData : (i : Fin (ar 0)) ‚Üí
        Data Œ± (children i)) :
      Data Œ± (Skeleton.node children)

ConvexOn in Mathlib.Analysis.Convex.Function

class VerifierLast (pSpec : ProtocolSpec n) [NeZero n] where
  verifier_last' : pSpec.dir ‚ü®n - 1, by admit /- proof elided -/
  ‚ü© = .V_to_P

Int in Init.Data.Int.Basic

@[inline, reducible]
def lift : OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i) ‚Üí InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i) ‚Üí
    OuterStmtOut √ó (‚àÄ i, OuterOStmtOut i) :=
  lens.toFunB

def binary_tower_inductive_step
  (k : Nat)
  (prevBTField : Type _) [Field prevBTField]
  (prevBTResult : BinaryTowerResult prevBTField k)
: Œ£' (F : Type _), BinaryTowerInductiveStepResult (k:=k) (prevBTField:=prevBTField)
  (prevBTResult:=prevBTResult) (prevPoly:=definingPoly (F:=prevBTField)
    (instField:=prevBTResult.instField) (s:=prevBTResult.specialElement)) (F:=F)
  (instPrevBTFieldIsField:=prevBTResult.instField) :=

Algebra.TensorProduct.instCommSemiring in Mathlib.RingTheory.TensorProduct.Basic

def toEvalsZeroOne (p : MvPolynomial œÉ R) : (œÉ ‚Üí Fin 2) ‚Üí R :=
  fun x => eval (x : œÉ ‚Üí R) p

Std.Format in Init.Data.Format.Basic

Quotient.lift‚ÇÇ in Init.Core

def twoLevelData {Œ±} (k0 k1 : ‚Ñï)
    (root : Œ±)
    (lvl1 : Fin k0 ‚Üí Œ±)
    (lvl2 : (i : Fin k0) ‚Üí Fin k1 ‚Üí Œ±) :
    ArityTree.Data Œ± (twoLevelSkel k0 k1) :=

def findIdxRev? (cond : Œ± ‚Üí Bool) (as : Array Œ±) : Option (Fin as.size) :=
  find ‚ü® as.size, Nat.lt_succ_self _ ‚ü©
where
  find : Fin (as.size + 1) ‚Üí Option (Fin as.size)
    | 0 => none
    | ‚ü® i+1, h ‚ü© =>
      if (cond as[i]) then
        some ‚ü® i, Nat.lt_of_succ_lt_succ h ‚ü©
      else
        find ‚ü® i, Nat.lt_of_succ_lt h ‚ü©

local instance : Fintype F := Fintype.ofFinite F

instance : ‚àÄ j, OracleInterface ((pSpecFoldRelay (L:=L)).Message j) :=
  instOracleInterfaceMessageAppend

def dfoldlM' (n : ‚Ñï) (Œ± : Fin (n + 1) ‚Üí Type u)
    (f : (i : Fin n) ‚Üí Œ± i.castSucc ‚Üí m (Œ± i.succ)) (init : Œ± 0) : m (Œ± (last n)) :=
  match n with
  | 0 => pure init
  | n + 1 => do
    let x ‚Üê dfoldlM' n (Œ± ‚àò castSucc) (fun i => f i.castSucc) init
    f (last n) x

@[reducible]
def reduction : Reduction oSpec StmtIn WitIn StmtOut WitOut !p[] where
  prover := prover mapStmt mapWit
  verifier := verifier mapStmt

def Adversary (Œπ : Type) (G : Type) (p : ‚Ñï) (bitLength : ‚Ñï) (Œ± : Type) : Type _ :=
  ReaderT (GroupValTable Œπ G)
    (OracleComp (GroupOpOracle Œπ ++‚Çí GroupExpOracle Œπ p ++‚Çí
      GroupEqOracle Œπ ++‚Çí GroupEncodeOracle Œπ bitLength))
    (List Œπ √ó Œ±)

@[reducible]
def MlPoly (R : Type*) (n : ‚Ñï) := Vector R (2 ^ n) 

IsCyclic.commGroup in Mathlib.GroupTheory.SpecificGroups.Cyclic

Set.fintypeMemFinset in Mathlib.Data.Set.Finite.Basic

Polynomial.resultant in Mathlib.RingTheory.Polynomial.Resultant.Basic

noncomputable def generateOpening [Fact (Nat.Prime p)] (srs : Vector G‚ÇÅ (n + 1))
    (coeffs : Fin (n + 1) ‚Üí ZMod p) (z : ZMod p) : G‚ÇÅ :=
  letI poly : degreeLT (ZMod p) (n + 1) := (degreeLTEquiv (ZMod p) (n + 1)).invFun coeffs
  letI q : degreeLT (ZMod p) (n + 1) :=
    ‚ü®Polynomial.div (poly.val - C (poly.val.eval z)) (X - C z), by admit /- proof elided -/
      ‚ü©
  commit srs (degreeLTEquiv (ZMod p) (n + 1) q)

Polynomial.X in Mathlib.Algebra.Polynomial.Basic

def SkeletonNodeIndex.rightChild {s : Skeleton} (idx : SkeletonNodeIndex s) :
    Option (SkeletonNodeIndex s) :=
  match idx with
  | SkeletonNodeIndex.ofLeaf => none
  | @SkeletonNodeIndex.ofInternal left right =>
    some (SkeletonNodeIndex.ofRight (getRootIndex right))
  | SkeletonNodeIndex.ofLeft idxLeft =>
    idxLeft.rightChild.map (SkeletonNodeIndex.ofLeft)
  | SkeletonNodeIndex.ofRight idxRight =>
    idxRight.rightChild.map (SkeletonNodeIndex.ofRight)

@[inline] def zero : AssocNat :=
  ‚ü®id, by admit /- proof elided -/
  ‚ü©

def toChallengesUpTo (transcript : Transcript k pSpec) : ChallengesUpTo k pSpec :=
  fun ‚ü®i, _‚ü© => transcript i

instance {pSpec : ProtocolSpec n} {Statement : Type}
    [DecidableEq Statement]
    [‚àÄ i, DecidableEq (pSpec.Message i)]
    [‚àÄ i, DecidableEq (pSpec.Challenge i)] :
    OracleSpec.DecidableEq (srChallengeOracle Statement pSpec) where
  domain_decidableEq' := fun i => by admit /- proof elided -/

noncomputable def polynomialFromNovelCoeffsF‚ÇÇ
  (‚Ñì : ‚Ñï) (h_‚Ñì : ‚Ñì ‚â§ r) (a : Fin (2 ^ ‚Ñì) ‚Üí L) : L‚¶É<2^‚Ñì‚¶Ñ[X] :=
  ‚ü®polynomialFromNovelCoeffs ùîΩq Œ≤ ‚Ñì h_‚Ñì a, by
    simp only [mem_degreeLT, Nat.cast_pow, Nat.cast_ofNat]
    apply (Polynomial.degree_sum_le Finset.univ (fun j => C (a j) * X‚±º ùîΩq Œ≤ ‚Ñì h_‚Ñì j)).trans_lt
    apply (Finset.sup_lt_iff ?_).mpr ?_
    ¬∑ -- ‚ä¢ ‚ä• < 2 ^ ‚Ñì
      exact compareOfLessAndEq_eq_lt.mp rfl
    ¬∑ -- ‚àÄ b ‚àà univ, (C (a b) * X‚±º ùîΩq Œ≤ ‚Ñì h_‚Ñì b).degree < 2 ^ ‚Ñì
      intro j _
      -- ‚ä¢ (C (a j) * X‚±º ùîΩq Œ≤ ‚Ñì h_‚Ñì j).degree < 2 ^ ‚Ñì
      calc (C (a j) * X‚±º ùîΩq Œ≤ ‚Ñì h_‚Ñì j).degree
        _ ‚â§ (C (a j)).degree + (X‚±º ùîΩq Œ≤ ‚Ñì h_‚Ñì j).degree :=

def FullData.Equiv {Œ±} (s : Skeleton) :
    FullData Œ± s ‚âÉ InternalData Œ± s √ó LeafData Œ± s :=

instance : VAdd (Œπ ‚Üí F) (AffineSubspace F (Œπ ‚Üí F)) := AffineSubspace.pointwiseVAdd

def proximityMeasure (u v : n ‚Üí F) (d : ‚Ñï) : ‚Ñï :=
  Fintype.card {r : F | Œî‚ÇÄ'(r ‚Ä¢ u + (1 - r) ‚Ä¢ v, C) ‚â§ d}

def projectToNextSumcheckPoly (i : Fin (‚Ñì)) (H·µ¢ : MultiquadraticPoly L (‚Ñì - i))
    (r·µ¢ : L) : -- the current challenge
    MultiquadraticPoly L (‚Ñì - i.succ) :=

@[reducible]
def rateSegment (state : CanonicalSpongeState U) : Vector U SpongeSize.R :=
  
  (Vector.take state SpongeSize.R).cast (by admit /- proof elided -/
  )

instance instNatPow {n : ‚Ñï} : NatPow (CNat n) := match n with
  | 0 => by admit /- proof elided -/
  | .succ n => by admit /- proof elided -/

def divByMonic [Field R] (p : UniPoly R) (q : UniPoly R) :
    UniPoly R :=
  (divModByMonicAux p q).1

def domain (n : ‚Ñï) (i : ‚Ñï) : Fin (2 ^ (n - i)) ‚Üí evalDomain D i :=
  fun j => ‚ü®(DIsCyclicC.gen ^ (2 ^ i)) ^ j.1, by admit /- proof elided -/
  ‚ü©

instance instVector : OracleInterface (Vector Œ± n) where
  Query := Fin n
  Response := Œ±
  answer := fun vec i => vec[i]

instance [LawfulBEq R] : AddCommGroup (UniPolyC R) where
  add_assoc := add_assoc
  zero_add := zero_add
  add_zero := add_zero
  add_comm := add_comm
  neg_add_cancel := neg_add_cancel
  nsmul := nsmul 
  nsmul_zero := nsmul_zero
  nsmul_succ := nsmul_succ
  zsmul := zsmulRec 

instance : SpongeUnit UInt8 where

inductive Expr where
  | lit (a : Lit F)
  | var (name : String)
  | sOp (op : ScalarOp) (a : Lit F) (b : Lit F)
  | svOp (op : ScalarVectorOp) (a : Lit F) (v : Lit F)
  | vOp (op : VectorOp) (v1 : Lit F) (v2 : Lit F)

def accepts (x : Fin numWires ‚Üí ùì°) (g : Gate ùì° numWires) : Prop :=
  g.eval x = 0

def snoc_oracle {i : Fin ‚Ñì}
    (oStmtIn : ‚àÄ j : Fin (toOutCodewordsCount ‚Ñì œë i.castSucc),
      OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j)
    (newOracleFn : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ) :
    ‚àÄ j : Fin (toOutCodewordsCount ‚Ñì œë i.succ),
      OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.succ j := fun j =>
  have h_succ_val: i.succ.val = i.val + 1 := rfl
  if hj: j.val < (toOutCodewordsCount ‚Ñì œë i.castSucc) then
    oStmtIn ‚ü®j, by admit /- proof elided -/
    ‚ü©
  else 
    
    if hi: isCommitmentRound ‚Ñì œë i then
      
      
      have h_count_succ : toOutCodewordsCount ‚Ñì œë i.succ =
        toOutCodewordsCount ‚Ñì œë i.castSucc + 1 := by admit /- proof elided -/

structure Context.Lens (OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                          OuterWitIn OuterWitOut InnerWitIn InnerWitOut : Type) where
  stmt : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
  wit : Witness.Lens OuterStmtIn InnerStmtOut OuterWitIn OuterWitOut InnerWitIn InnerWitOut

Monad in Init.Prelude

noncomputable def queryOracleVerifier :
  OracleVerifier
    (oSpec := []‚Çí)
    (StmtIn := FinalSumcheckStatementOut (L:=L) (‚Ñì:=‚Ñì))
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (
    Fin.last ‚Ñì))
    (StmtOut := Bool)
    (OStmtOut := fun _ : Empty => Unit)
    (pSpec := pSpecQuery ùîΩq Œ≤ Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)) where
  verify := fun (stmt: FinalSumcheckStatementOut (L:=L) (‚Ñì:=‚Ñì))
    (challenges: (pSpecQuery ùîΩq Œ≤ Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).Challenges) => do
    
    let c := stmt.final_constant
    let fold_challenges : Fin Œ≥_repetitions ‚Üí sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate 0 :=
      challenges ‚ü®0, by admit /- proof elided -/
      ‚ü©

    
    
    for rep in (List.finRange Œ≥_repetitions) do
      let mut c_cur : L := 0 
      let v := fold_challenges rep

      for k_val in List.finRange (‚Ñì / œë) do
        let i := k_val * œë
        have h_k: k_val ‚â§ (‚Ñì/œë - 1) := by admit /- proof elided -/

def outputRelation (cond : ‚àë i, (s i).1 ‚â§ n) [DecidableEq F] (Œ¥ : ‚Ñù‚â•0) :
    Set
      (
        (FinalStatement F k √ó ‚àÄ j, FinalOracleStatement D x s j) √ó
        Witness F s d (Fin.last (k + 1))
      )
  := FinalFoldPhase.outputRelation D x s d cond Œ¥

def AlgebraTowerEquiv.toAlgebraOverLeft (e : AlgebraTowerEquiv A B) (i j : Œπ)
    (h : i ‚â§ j) : Algebra (A i) (B j) :=

def MLEEquivFin {n : ‚Ñï} : R‚¶É‚â§ 1‚¶Ñ[X (Fin n)] ‚âÉ (Fin (2 ^ n) ‚Üí R) :=
  Equiv.trans MLEEquiv (Equiv.piCongr finFunctionFinEquiv (fun _ => Equiv.refl _))

def finSuccEquivNth : MvPolynomial (Fin (n + 1)) R ‚âÉ‚Çê[R] Polynomial (MvPolynomial (Fin n) R) :=
  (renameEquiv R (_root_.finSuccEquiv' p)).trans (optionEquivLeft R (Fin n))

@[reducible] def NonInteractiveReduction (Message : Type) {Œπ : Type} (oSpec : OracleSpec Œπ)
    (StmtIn WitIn StmtOut WitOut : Type) :=
  Reduction oSpec StmtIn WitIn StmtOut WitOut ‚ü®!v[.P_to_V], !v[Message]‚ü©

@[reducible, inline, specialize]
def PlainMessageIdx := {i : pSpec.MessageIdx // (inst.oracleInterfaces i).isNone }

def sumExceptFirst (n : ‚Ñï) (D : Fin n ‚Üí Finset R) :
    MvPolynomial (Fin (n + 1)) R ‚Üí‚Çó[R] Polynomial R :=

def reduction : Reduction oSpec (StmtIn R √ó (‚àÄ i, OStmtIn R deg i)) Unit
                                (StmtOut R √ó (‚àÄ i, OStmtOut R deg i)) Unit (pSpec R deg) where
  prover := prover R deg oSpec
  verifier := verifier R deg D oSpec

def soundness
    (langIn : Set (StmtIn √ó ‚àÄ i, OStmtIn i))
    (langOut : Set (StmtOut √ó ‚àÄ i, OStmtOut i))
    (verifier : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec)
    (soundnessError : ‚Ñù‚â•0) : Prop :=
  verifier.toVerifier.soundness init impl langIn langOut soundnessError

def liftF (f : Fin n ‚Üí Œ±) : ‚Ñï ‚Üí Œ± :=
  fun m ‚Ü¶ if h : m < n then f ‚ü®m, h‚ü© else 0

Set.toFinset in Mathlib.Data.Fintype.Sets

@[inline, specialize]
def processRound (j : Fin n)
    (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec)
    (currentResult : OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí)
      (pSpec.Transcript j.castSucc √ó prover.PrvState j.castSucc)) :
      OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí)
        (pSpec.Transcript j.succ √ó prover.PrvState j.succ) := do
  let ‚ü®transcript, state‚ü© ‚Üê currentResult
  match hDir : pSpec.dir j with
  | .V_to_P => do
    let challenge ‚Üê pSpec.getChallenge ‚ü®j, hDir‚ü©
    letI newState := (‚Üê prover.receiveChallenge ‚ü®j, hDir‚ü© state) challenge
    return ‚ü®transcript.concat challenge, newState‚ü©
  | .P_to_V => do
    let ‚ü®msg, newState‚ü© ‚Üê prover.sendMessage ‚ü®j, hDir‚ü© state
    return ‚ü®transcript.concat msg, newState‚ü©

AdjoinRoot.root in Mathlib.RingTheory.AdjoinRoot

def insertNth (p : Fin (n + 1)) (y : M) (s : Fin n ‚Üí‚ÇÄ M) : Fin (n + 1) ‚Üí‚ÇÄ M :=
  Finsupp.equivFunOnFinite.symm (Fin.insertNth p y s : Fin (n + 1) ‚Üí M)

@[reducible]
def batchSpec (F : Type) (m : ‚Ñï) : ProtocolSpec 1 := ‚ü®!v[.V_to_P], !v[Fin m ‚Üí F]‚ü©

Module.Basis.smulTower in Mathlib.RingTheory.AlgebraTower

instance instDCast‚ÇÇ : DCast‚ÇÇ Nat ProtocolSpec (fun _ pSpec => FullTranscript pSpec) where
  dcast‚ÇÇ h h' T := FullTranscript.cast h h' T
  dcast‚ÇÇ_id := cast_id

def seqComposeChallengeEquiv {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (pSpec : ‚àÄ i, ProtocolSpec (n i)) :
    (i : Fin m) √ó (pSpec i).ChallengeIdx ‚âÉ (seqCompose pSpec).ChallengeIdx where
  
  toFun := fun ‚ü®i, j‚ü© => sigmaChallengeIdxToSeqCompose i j
  invFun := seqComposeChallengeIdxToSigma
  left_inv := by admit /- proof elided -/

MvPolynomial.eval in Mathlib.Algebra.MvPolynomial.Eval

SMulZeroClass in Mathlib.Algebra.GroupWithZero.Action.Defs

@[simps!]
def equivMessagesChallenges : FullTranscript pSpec ‚âÉ (Messages pSpec √ó Challenges pSpec) :=

def sub (m n : ChurchNat Œ±) : ChurchNat Œ± := sorry 

@[reducible]
def C : R ‚Üí+* P := algebraMap R P

@[reducible, simp] def OStmtAfterRandomQuery : Unit ‚äï Unit ‚Üí Type := fun _ => R‚¶É‚â§ deg‚¶Ñ[X]

def eval‚ÇÇ (p : MlPoly R n) (f : R ‚Üí+* S) (x : Vector S n) : S := eval (map f p) x

@[reducible, simp]
def StmtOut : Type := R √ó R

UInt8.size in Init.Prelude

Mathlib.Linter.TextBased.ErrorFormat.humanReadable in Mathlib.Tactic.Linter.TextBased

def InnerStmtOut_Test := ‚Ñ§[X] √ó ‚Ñ§ √ó ‚Ñ§

inductive VectorOp where | dotProd

def leadingCoeff (p : UniPoly R) : R := p.trim.getLastD 0

noncomputable def coeffs_of_close_proximity (œâs : Fin n ‚Ü™ F) (Œ¥ : ‚Ñö) (u‚ÇÄ u‚ÇÅ : Fin n ‚Üí F)
  : Finset F := Set.toFinset { z | ‚àÉ v : ReedSolomon.code œâs (k + 1), Œ¥·µ£(u‚ÇÄ + z ‚Ä¢ u‚ÇÅ, v) ‚â§ Œ¥}

@[inline, reducible]
def Witness.Lens (OuterStmtIn InnerStmtOut OuterWitIn OuterWitOut InnerWitIn InnerWitOut : Type)
    := PFunctor.Lens ((OuterStmtIn √ó OuterWitIn) X^ OuterWitOut)
                     (InnerWitIn X^ (InnerStmtOut √ó InnerWitOut))

System.FilePath.fileName in Init.System.FilePath

@[inline]
def add [Add R] (p q : MlPoly R n) : MlPoly R n := Vector.zipWith (¬∑ + ¬∑) p q

def hammingBall (C : Code Œπ F) (y : Œπ ‚Üí F) (r : ‚Ñï) : Set (Œπ ‚Üí F) :=
  { c | c ‚àà C ‚àß hammingDist y c ‚â§ r }

class SliceLT (coll : Type u) (stop : Type v) (valid : outParam (coll ‚Üí stop ‚Üí Prop))
    (subcoll : outParam ((xs : coll) ‚Üí (stop : stop) ‚Üí (h : valid xs stop) ‚Üí Type w)) where
  sliceLT : (xs : coll) ‚Üí (stop : stop) ‚Üí (h : valid xs stop) ‚Üí subcoll xs stop h

@[reducible]
def value (op : MemoryWrite Œπ Œ±) := op.2

HDiv in Init.Prelude

@[inline, specialize, simp]
def verifier : Verifier oSpec Statement Statement !p[] := Verifier.id

pos in ToMathlib.Control.Comonad.Instances

structure DuplexSponge (U : Type) [SpongeUnit U] [SpongeSize] (C : Type*)
    [SpongeState U C] where
   
  state : C
   
  absorbPos : Fin (SpongeSize.R + 1)
   
  squeezePos : Fin (SpongeSize.R + 1)
deriving Inhabited

def lastBlockOracleReduction :=
  let bIdx := ‚Ñì / œë - 1
  let stmt : Fin (œë + 1) ‚Üí Type := fun i => Statement (L := L) (‚Ñì := ‚Ñì) Context
    ‚ü®bIdx * œë + i, by admit /- proof elided -/
    ‚ü©
  let oStmt := fun i: Fin (œë + 1) => OracleStatement ùîΩq Œ≤ œë
    ‚ü®bIdx * œë + i, by admit /- proof elided -/
    ‚ü©
  let wit := fun i: Fin (œë + 1) => Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì)
    ‚ü®bIdx * œë + i, by admit /- proof elided -/
    ‚ü©
  let V:  OracleReduction []‚Çí (StmtIn := Statement (L := L) (‚Ñì := ‚Ñì) Context
    ‚ü®bIdx * œë, by admit /- proof elided -/
    ‚ü©)
    (OStmtIn := OracleStatement ùîΩq Œ≤ œë
      ‚ü®bIdx * œë, by admit /- proof elided -/
      ‚ü©)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì)
      ‚ü®bIdx * œë, by admit /- proof elided -/
      ‚ü©)
    (StmtOut := Statement (L := L) (‚Ñì := ‚Ñì) Context (Fin.last ‚Ñì))
    (OStmtOut := OracleStatement ùîΩq Œ≤ œë (Fin.last ‚Ñì))
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) (Fin.last ‚Ñì))
    (pSpec := pSpecLastBlock (L:=L) (œë:=œë)) := by admit /- proof elided -/

List.mapM in Init.Data.List.Control

instance {i : Fin k} : ‚àÄ j, OracleInterface ((pSpec D x s i).Message j)
  | ‚ü®0, h‚ü© => nomatch h
  | ‚ü®1, _‚ü© => by admit /- proof elided -/

OracleSpec.QueryLog in VCVio.OracleComp.QueryTracking.Structures

absurd in Init.Prelude

Real in Mathlib.Data.Real.Basic

def Array.toFinVec {Œ± : Type _} (n : ‚Ñï) (arr : Array Œ±) (h : arr.size = n) : Fin n ‚Üí Œ± :=
  fun i => arr[i]

noncomputable def relayOracleProver (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
  OracleProver (oSpec := []‚Çí)
    
    (StmtIn := Statement (L := L) Context i.succ)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) i.succ)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) i.succ)
    (pSpec := pSpecRelay) where
  PrvState := relayPrvState ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i
  input := fun ‚ü®‚ü®stmtIn, oStmtIn‚ü©, witIn‚ü© => (stmtIn, oStmtIn, witIn)
  sendMessage | ‚ü®x, h‚ü© => by admit /- proof elided -/
| ‚ü®x, h‚ü© => by admit /- proof elided -/

Polynomial.algEquivOfCompEqX in Mathlib.Algebra.Polynomial.AlgebraMap

def extract (start stop : ‚Ñï) (h1 : start ‚â§ stop) (h2 : stop ‚â§ n) (pSpec : ProtocolSpec n) :
    ProtocolSpec (stop - start) where
  dir := Fin.extract start stop h1 h2 pSpec.dir
  ¬´Type¬ª := Fin.extract start stop h1 h2 pSpec.¬´Type¬ª

abbrev eqPolynomial (r : œÉ ‚Üí R) : R[X œÉ] :=
  ‚àè i : œÉ, singleEqPolynomial (r i) (X i)

instance : Fintype BTF‚ÇÉ := (inferInstance : Fintype (ConcreteBTField 3))

def splitSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (k : Fin (vsum n)) : (i : Fin m) √ó Fin (n i) := match m with
  | 0 => Fin.elim0 k
  | _ + 1 => Fin.dappend
    (fun k => ‚ü®0, k‚ü©)
    (fun k => ‚ü®(splitSum k).1.succ, (splitSum k).2‚ü©)
    k

@[reducible, inline]
def OracleProver {Œπ : Type} (oSpec : OracleSpec Œπ)
    (StmtIn : Type) {Œπ‚Çõ·µ¢ : Type} (OStmtIn : Œπ‚Çõ·µ¢ ‚Üí Type) (WitIn : Type)
    (StmtOut : Type) {Œπ‚Çõ‚Çí : Type} (OStmtOut : Œπ‚Çõ‚Çí ‚Üí Type) (WitOut : Type)
    {n : ‚Ñï} (pSpec : ProtocolSpec n) :=
  Prover oSpec (StmtIn √ó (‚àÄ i, OStmtIn i)) WitIn (StmtOut √ó (‚àÄ i, OStmtOut i)) WitOut pSpec

def X : UniPoly R := #[0, 1]

def Prover.liftContext
    (lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut)
    (P : Prover oSpec InnerStmtIn InnerWitIn InnerStmtOut InnerWitOut pSpec) :
      Prover oSpec OuterStmtIn OuterWitIn OuterStmtOut OuterWitOut pSpec where
  PrvState := fun i => P.PrvState i √ó OuterStmtIn √ó OuterWitIn
  input := fun ctxIn => ‚ü®P.input <| lens.proj ctxIn, ctxIn‚ü©
  sendMessage := fun i ‚ü®prvState, stmtIn, witIn‚ü© => do
    let ‚ü®msg, prvState'‚ü© ‚Üê P.sendMessage i prvState
    return ‚ü®msg, ‚ü®prvState', stmtIn, witIn‚ü©‚ü©
  receiveChallenge := fun i ‚ü®prvState, stmtIn, witIn‚ü© => do
    let f ‚Üê P.receiveChallenge i prvState
    return fun chal => ‚ü®f chal, stmtIn, witIn‚ü©
  output := fun ‚ü®prvState, stmtIn, witIn‚ü© => do
    let ‚ü®innerStmtOut, innerWitOut‚ü© ‚Üê P.output prvState
    return lens.lift (stmtIn, witIn) (innerStmtOut, innerWitOut)

OptionT.mk in Init.Control.Option

instance : ‚àÄ j, OracleInterface (OracleStatement D x m j) :=
  fun _ => inferInstance

structure PrimeWithMultiplicity : Type where
  prime : ‚Ñï
  multiplicity : ‚Ñï
deriving Repr

Nat.decLt in Init.Prelude

@[simp]
abbrev FirstSumcheckChallenge : Type := Fin pp.‚Ñì_m ‚Üí R

Matrix.vandermonde in Mathlib.LinearAlgebra.Vandermonde

def implGroupExpOracle : QueryImpl (GroupExpOracle Œπ p) (StateT (GroupValTable Œπ G) Option) where
  impl | query _ ‚ü®i, a, j‚ü© => fun table =>
    match table i with
    | some g => some ((), table.update j (some (g ^ a.val)))
    | none => none

Set.Ico in Mathlib.Order.Interval.Set.Defs

RingHom in Mathlib.Algebra.Ring.Hom.Defs

instance polyIrreducibleFact (n : ‚Ñï) : Fact (Irreducible (poly n)) := ‚ü®polyIrreducible n‚ü©

def deriveTranscriptDSFSAux {Œπ : Type} {oSpec : OracleSpec Œπ} {StmtIn : Type}
    (sponge : CanonicalDuplexSponge U)
    (messages : pSpec.Messages) (i : Fin (n + 1)) :
      OracleComp (oSpec ++‚Çí duplexSpongeChallengeOracle StmtIn U)
        (CanonicalDuplexSponge U √ó pSpec.Transcript i) :=
  Fin.induction
    (pure (sponge, fun i => i.elim0))
    (fun i ih => do
      let ‚ü®curSponge, prevTranscript‚ü© ‚Üê ih
      match hDir : pSpec.dir i with
      | .V_to_P =>
        let ‚ü®challenge, newSponge‚ü© ‚Üê liftM (curSponge.squeeze (challengeSize ‚ü®i, hDir‚ü©))
        let deserializedChallenge : pSpec.Challenge ‚ü®i, hDir‚ü© :=
          Deserialize.deserialize challenge
        return (newSponge, prevTranscript.concat deserializedChallenge)
      | .P_to_V =>
        let serializedMessage : Vector U (messageSize ‚ü®i, hDir‚ü©) :=
          Serialize.serialize (messages ‚ü®i, hDir‚ü©)
        let newSponge ‚Üê liftM (DuplexSponge.absorb curSponge serializedMessage.toList)
        return (newSponge, prevTranscript.concat (messages ‚ü®i, hDir‚ü©)))
    i

def finalSumcheckRelOutProp
    (input : ((FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì) √ó
      (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì) j)) √ó
      (Unit))) : Prop :=
  
  finalNonDoomedFoldingProp ùîΩq Œ≤
    (h_le := by admit /- proof elided -/
    )
    (input := input.1)

LinearMap in Mathlib.Algebra.Module.LinearMap.Defs

instance instSelectableTypeChallengePSpec [SelectableType R] :
    ‚àÄ i, SelectableType ((pSpec R deg).Challenge i) :=
  instSelectableTypeChallengeAppend

def Œæ (x‚ÇÄ : F) (R : F[X][X][Y]) (H : F[X][Y]) [œÜ : Fact (Irreducible H)] : ùí™ H :=
  (Œæ_regular x‚ÇÄ R H).choose

Array.range in Init.Data.Array.Basic

def Extractor.Straightline.compatWit
    (lens : Extractor.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut)
    (E : Extractor.Straightline oSpec InnerStmtIn InnerWitIn InnerWitOut pSpec) :
      OuterStmtIn √ó OuterWitOut ‚Üí InnerWitIn ‚Üí Prop :=
  fun ‚ü®outerStmtIn, outerWitOut‚ü© innerWitIn =>
    ‚àÉ stmt tr logP logV, innerWitIn ‚àà
      (E stmt (lens.wit.proj (outerStmtIn, outerWitOut)) tr logP logV).support

noncomputable def Basis.baseChangeRight (b : Basis Œπ K Left) : Basis Œπ Right (Left ‚äó[K] Right) :=

def two : ChurchNat Œ± := succ one

@[reducible]
def pSpec : ProtocolSpec 1 :=
  ‚ü®!v[.V_to_P], !v[Fin l ‚Üí evalDomain D x 0]‚ü©

noncomputable def toRatFuncPoly (p : F[Z][X][Y]) : (RatFunc F)[X][Y] :=
  p.map (Polynomial.mapRingHom (algebraMap F[X] (RatFunc F)))

def rightpad {m : ‚Ñï} {Œ± : Sort*} (n : ‚Ñï) (a : Œ±) (v : Fin m ‚Üí Œ±) : Fin n ‚Üí Œ± :=
  fun i => if h : i < m then v ‚ü®i, h‚ü© else a

def interleaveCode [Semiring F] [DecidableEq F] (C : Submodule F (n ‚Üí F)) (Œπ : Type*)
  : Submodule F ((Œπ √ó n) ‚Üí F) :=
  Submodule.span F {v | ‚àÄ i, ‚àÉ c ‚àà C, c = fun j => v (i, j)}

def Option.doubleBind {Œ± Œ≤ Œ≥ : Type} (f : Œ± ‚Üí Œ≤ ‚Üí Option Œ≥)
    (x : Option Œ±) (y : Option Œ≤) : Option Œ≥ :=
  match x, y with
  | none, _ => none
  | _, none => none
  | some a, some b => f a b

def toFinset (domain : Œπ ‚Ü™ F) (deg : ‚Ñï) : Finset (Œπ ‚Üí F) :=
  (RScodeSet domain deg).toFinset

protected def basis : F := sorry

PFunctor.Lens.id in ToMathlib.PFunctor.Lens.Basic

def computableAdditiveNTT (a : Fin (2 ^ ‚Ñì) ‚Üí L) : Fin (2^(‚Ñì + R_rate)) ‚Üí L :=
  let b: Fin (2^(‚Ñì + R_rate)) ‚Üí L := tileCoeffs a 
  Fin.foldl (n:=‚Ñì) (f:= fun current_b i  =>
    computableNTTStage (ùîΩq := ùîΩq) (Œ≤ := Œ≤) (‚Ñì := ‚Ñì) (R_rate := R_rate)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := ‚ü®‚Ñì - 1 - i, by admit /- proof elided -/
      ‚ü©) (b:=current_b)
  ) (init:=b)

def OracleReduction.toReduction {Œπ : Type} {oSpec : OracleSpec Œπ}
    {StmtIn : Type} {Œπ‚Çõ·µ¢ : Type} {OStmtIn : Œπ‚Çõ·µ¢ ‚Üí Type} {WitIn : Type}
    {StmtOut : Type} {Œπ‚Çõ‚Çí : Type} {OStmtOut : Œπ‚Çõ‚Çí ‚Üí Type} {WitOut : Type}
    {n : ‚Ñï} {pSpec : ProtocolSpec n}
    [O‚Çõ·µ¢ : ‚àÄ i, OracleInterface (OStmtIn i)] [O‚Çò : ‚àÄ i, OracleInterface (pSpec.Message i)]
    (oracleReduction : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec) :
      Reduction oSpec (StmtIn √ó (‚àÄ i, OStmtIn i)) WitIn
        (StmtOut √ó (‚àÄ i, OStmtOut i)) WitOut pSpec :=
  ‚ü®oracleReduction.prover, oracleReduction.verifier.toVerifier‚ü©

@[ext]
structure ProtocolSpec (n : ‚Ñï) where
   
  dir : Fin n ‚Üí Direction
   
  ¬´Type¬ª : Fin n ‚Üí Type
deriving Inhabited

Equiv.optionCongr in Mathlib.Logic.Equiv.Option

instance : ‚àÄ j, OracleInterface ((batchSpec F m).Message j)
  | ‚ü®0, h‚ü© => nomatch h

def knowledgeSoundness (relIn : Set (StmtIn √ó WitIn)) (relOut : Set (StmtOut √ó WitOut))
    (verifier : Verifier oSpec StmtIn StmtOut pSpec) (knowledgeError : ‚Ñù‚â•0) : Prop :=
  ‚àÉ extractor : Extractor.Straightline oSpec StmtIn WitIn WitOut pSpec,
  ‚àÄ stmtIn : StmtIn,
  ‚àÄ witIn : WitIn,
  ‚àÄ prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec,
    letI reduction := Reduction.mk prover verifier
    [fun ‚ü®stmtIn, witIn, stmtOut, witOut‚ü© =>
      (stmtIn, witIn) ‚àâ relIn ‚àß (stmtOut, witOut) ‚àà relOut
    | do
      let s ‚Üê init
      (simulateQ (impl ++‚Çõ‚Çí challengeQueryImpl : QueryImpl _ (StateT œÉ ProbComp))
        <| do
      let ‚ü®‚ü®‚ü®transcript, ‚ü®_, witOut‚ü©‚ü©, stmtOut‚ü©, proveQueryLog, verifyQueryLog‚ü© ‚Üê
        reduction.runWithLog stmtIn witIn
      let extractedWitIn ‚Üê
        liftComp (extractor stmtIn witOut transcript proveQueryLog.fst verifyQueryLog) _
      return (stmtIn, extractedWitIn, stmtOut, witOut)).run' s] ‚â§ knowledgeError

protected def cast (pSpec : ProtocolSpec n‚ÇÅ) : ProtocolSpec n‚ÇÇ :=
  ‚ü®pSpec.dir ‚àò (Fin.cast hn.symm), pSpec.¬´Type¬ª ‚àò (Fin.cast hn.symm)‚ü©

MvPolynomial.sumAlgEquiv in Mathlib.Algebra.MvPolynomial.Equiv

SemilatticeSup in Mathlib.Order.Lattice

def weightConstraint
  (f : MvPolynomial (Fin m) F)
  (w : MvPolynomial (Fin (m + 1)) F) (œÉ : F) : Prop :=
    ‚àë b : Fin m ‚Üí Fin 2 , w.eval (toWeightAssignment f b) = œÉ

private def f (x : ‚Ñö) : ‚Ñö := x^2 - x

instance {s} : Functor (fun Œ± => FullData Œ± s) where
  map f x := x.map f

Polynomial.mapAlgHom in Mathlib.Algebra.Polynomial.AlgebraMap

instance : LT AssocNat where
  lt a b := a 0 < b 0

def toMvPolynomial (p : MlPoly R n) : R[X Fin n] :=
  ‚àë i : Fin (2 ^ n), MvPolynomial.monomial (monomialOfNat i) (a:=p[i])

def BacktrackSequence.Index (trace : QueryLog (duplexSpongeChallengeOracle StmtIn U))
    (state : CanonicalSpongeState U) (seq : BacktrackSequence trace state) :
    Fin trace.length √ó (Fin seq.inputState.length ‚Üí Fin trace.length) :=
  
  
  
  (‚ü®trace.findIdx sorry, sorry‚ü©, sorry)

@[to_additive existing]
def partialProd {Œ± : Type*} [Monoid Œ±] (l : List Œ±) : List Œ± :=
  [1] ++ match l with
  | [] => []
  | a :: l' => (partialProd l').map (a * ¬∑)

@[reducible, simp] def OStmtOut := fun _ : Fin 1 => OStatement

tag in Examples.FrankingProtocol

def join_via_add_smul (k : ‚Ñï) (h_pos : k > 0) (hi_btf lo_btf : ConcreteBTField (k - 1)) :
    ConcreteBTField k :=

Matrix.rank in Mathlib.LinearAlgebra.Matrix.Rank

instance instDCastPSigmaPSigma :
    DCast ((a : Œ±) √ó' (b : Œ≤ a) √ó' Œ≥ a b) (fun a => Œ¥ a.1 a.2.1 a.2.2) where
  dcast hc d := dcast‚ÇÉ (by admit /- proof elided -/
  ) (by admit /- proof elided -/
  ) (by admit /- proof elided -/
  ) d
  dcast_id := by admit /- proof elided -/

@[reducible, simp] def OStmtOut : Unit ‚Üí Type := fun _ => R‚¶É‚â§ deg‚¶Ñ[X]

inductive PrattPart : (p : ‚Ñï) ‚Üí (a : ZMod p) ‚Üí ‚Ñï ‚Üí Prop
  | prime : {p : ‚Ñï} ‚Üí {a : ZMod p} ‚Üí (n k nk : ‚Ñï) ‚Üí n.Prime ‚Üí
      a ^ ((p - 1) / n) ‚â† 1 ‚Üí n ^ k = nk ‚Üí PrattPart p a nk
  | split : {p : ‚Ñï} ‚Üí {a : ZMod p} ‚Üí {n : ‚Ñï} ‚Üí (l r : ‚Ñï) ‚Üí
      PrattPart p a l ‚Üí PrattPart p a r ‚Üí l * r = n ‚Üí PrattPart p a n

structure LookaheadSequenceFamily
    (trace : QueryLog (forwardPermutationOracle (CanonicalSpongeState U)))
    (state : CanonicalSpongeState U) (i : pSpec.ChallengeIdx) where
   
  seqFamily : Finset (LookaheadSequence trace state)
   
  maximality : ‚àÄ s ‚àà seqFamily, ‚àÄ s' ‚àà seqFamily,
    ¬¨ (s.inputState ‚äÜ s'.inputState) ‚à® ¬¨ (s'.outputState ‚äÜ s.outputState)
   
  length_le_challengeSize : ‚àÄ s ‚àà seqFamily, s.inputState.length ‚â§ challengeSize i

protected def Verifier.id : Verifier oSpec Statement Statement !p[] where
  verify := fun stmt _ => pure stmt

def rootsOfUnity (n s : ‚Ñï) : List (Domain.evalDomain D (n - s)) :=
  List.map
    (fun i =>
      ‚ü®
        (DIsCyclicC.gen.1 ^ (2 ^ (n - s))) ^ i,
        by admit /- proof elided -/
      ‚ü©
    )
    (List.range (2 ^ s))

@[reducible]
def oracleVerifier : OracleVerifier oSpec (StatementRound R n 0) (OracleStatement R n deg)
    (StatementRound R n (.last n)) (OracleStatement R n deg) (pSpec R deg n) :=
  OracleVerifier.seqCompose (oSpec := oSpec)
    (Stmt := StatementRound R n)
    (OStmt := fun _ => OracleStatement R n deg)
    (pSpec := fun _ => SingleRound.pSpec R deg)
    (SingleRound.oracleVerifier R n deg D oSpec)

def proverOutput (i : Fin n) : ProverOutput oSpec
    ((StatementRound R n i.succ √ó (‚àÄ i, OracleStatement R n deg i)) √ó Unit)
    ((proverState R n deg i).PrvState (Fin.last 2)) where
  output := fun x => pure (x, ())

def oStmtLens (i : Fin n) : OracleStatement.Lens
    (StatementRound R n i.castSucc) (StatementRound R n i.succ) (Simple.StmtIn R) (Simple.StmtOut R)
    (OracleStatement R n deg) (OracleStatement R n deg)
    (Simple.OStmtIn R deg) (Simple.OStmtOut R deg) where

  toFunA := fun ‚ü®‚ü®target, challenges‚ü©, oStmt‚ü© =>
    ‚ü®target, fun _ =>
      match h : n with
      | 0 => ‚ü®Polynomial.C <| MvPolynomial.isEmptyAlgEquiv R (Fin 0) (oStmt ()), by admit /- proof elided -/
        ‚ü©
      | n + 1 =>
      ‚ü®‚àë x ‚àà (univ.map D) ^·∂† (n - i), (oStmt ()).val ‚∏®X ‚¶Éi‚¶Ñ, challenges, x‚∏©'(by admit /- proof elided -/
      ),
        sumcheck_roundPoly_degreeLE R n deg D i (oStmt ()).property‚ü©‚ü©

  toFunB := fun ‚ü®‚ü®_oldTarget, challenges‚ü©, oStmt‚ü© ‚ü®‚ü®newTarget, chal‚ü©, oStmt'‚ü© =>
    ‚ü®‚ü®newTarget, Fin.snoc challenges chal‚ü©, oStmt‚ü©

def getPutativeRoot_with_hash {s} (idx : BinaryTree.SkeletonLeafIndex s)
    (leafValue : Œ±) (proof : List Œ±) (hashFn : Œ± ‚Üí Œ± ‚Üí Œ±) : Œ± :=
  match proof with
  | [] => leafValue 
  | siblingBelowRootHash :: restProof =>
    match idx with
    | BinaryTree.SkeletonLeafIndex.ofLeaf =>
      
      
      
      leafValue
    | BinaryTree.SkeletonLeafIndex.ofLeft idxLeft =>
      
      hashFn (getPutativeRoot_with_hash idxLeft leafValue restProof hashFn) siblingBelowRootHash
    | BinaryTree.SkeletonLeafIndex.ofRight idxRight =>
      
      hashFn siblingBelowRootHash (getPutativeRoot_with_hash idxRight leafValue restProof hashFn)

List.foldl in Init.Prelude

instance : IsEmpty (AssocFin AssocNat.zero) :=

def extractNextSuffixFromChallenge (v : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®0, by omega‚ü©)
    (i : ‚Ñï) (h_i_add_œë_le_‚Ñì : i + œë ‚â§ ‚Ñì) :
    (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®i + œë, by omega‚ü© :=

@[reducible, inline, specialize, simp]
def ChallengeIdx (vPSpec : VectorSpec n) := {i : Fin n // vPSpec.dir i = .V_to_P}

def oracleReduction : OracleReduction oSpec (StmtIn R) (OStmtIn R deg) Unit
                                            (StmtOut R) (OStmtOut R deg) Unit (pSpec R deg) where
  prover := prover R deg oSpec
  verifier := oracleVerifier R deg D oSpec

OracleComp.uniformOfFintype in VCVio.OracleComp.Constructions.UniformSelect

Finset.fold in Mathlib.Data.Finset.Fold

def rbrSoundness
    (langIn : Set (StmtIn √ó ‚àÄ i, OStmtIn i))
    (langOut : Set (StmtOut √ó ‚àÄ i, OStmtOut i))
    (verifier : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec)
    (rbrSoundnessError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) : Prop :=
  verifier.toVerifier.rbrSoundness init impl langIn langOut rbrSoundnessError

@[reducible, inline]
instance instProdForall {Œπ : Type u} (v : Œπ ‚Üí Type v) [O : ‚àÄ i, OracleInterface (v i)] :
    OracleInterface (‚àÄ i, v i) where
  Query := (i : Œπ) √ó (O i).Query
  Response := (i : Œπ) √ó (O i).Response
  answer := fun f ‚ü®i, q‚ü© => ‚ü®i, (O i).answer (f i) q‚ü©

@[reducible]
def verifier : Verifier oSpec (StatementRound R n 0 √ó (‚àÄ i, OracleStatement R n deg i))
    (StatementRound R n (.last n) √ó (‚àÄ i, OracleStatement R n deg i)) (pSpec R deg n) :=
  Verifier.seqCompose (oSpec := oSpec)
    (Stmt := fun i => StatementRound R n i √ó (‚àÄ j, OracleStatement R n deg j))
    (pSpec := fun _ => SingleRound.pSpec R deg)
    (SingleRound.verifier R n deg D oSpec)

noncomputable def decodeLT : (ReedSolomon.code domain deg) ‚Üí‚Çó[F] (Polynomial.degreeLT F deg) :=
  codRestrict
    (Polynomial.degreeLT F deg)
    decode
    (fun c => decoded_polynomial_lt_deg c)

@[inline] def min [Zero T] [ToNat T] (a b : Cayley T) : Cayley T :=
  if (a : Nat) ‚â§ (b : Nat) then a else b

private def sum_choose_K_i (B : Finset (Fin n ‚Üí F)) (i : Fin n) : ‚Ñö :=
  ‚àë (Œ± : F), choose_2 (K B i Œ±)

Set.PairwiseDisjoint in Mathlib.Data.Set.Pairwise.Basic

@[inline] def zero : Cayley T :=
  ‚ü®id, by admit /- proof elided -/
  ‚ü©

@[simp]
abbrev OracleStatement.AfterFirstChallenge : R1CS.MatrixIdx ‚äï Fin 1 ‚Üí Type :=
  OracleStatement.AfterFirstMessage R pp

def witnessStructuralInvariant {i : Fin (‚Ñì + 1)} (stmt : Statement (L := L) Context i)
    (wit : Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i): Prop :=
  wit.H = projectToMidSumcheckPoly ‚Ñì wit.t (m:=mp.multpoly stmt.ctx) i stmt.challenges ‚àß
  wit.f = getMidCodewords ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) wit.t stmt.challenges

inductive MemoryOp (Œπ : Type u) (Œ± : Œπ ‚Üí Type v) where
  | read (op : MemoryRead Œπ Œ±)
  | write (op : MemoryWrite Œπ Œ±)

@[reducible]
def randSpec (Œ≤ : Type) : OracleSpec Unit := fun _ => (Unit, Œ≤)

noncomputable def foldOracleProver (i : Fin ‚Ñì) :
  OracleProver (oSpec := []‚Çí)
    
    (StmtIn := Statement (L := L) Context i.castSucc)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) i.castSucc)
    
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) i.succ)
    (pSpec := pSpecFold (L := L)) where

  PrvState := foldPrvState ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i

  input := fun ‚ü®‚ü®stmt, oStmt‚ü©, wit‚ü© => (stmt, oStmt, wit)

  sendMessage 
  | ‚ü®0, _‚ü© => fun ‚ü®stmt, oStmt, wit‚ü© => do
    let curH : ‚Ü•L‚¶É‚â§ 2‚¶Ñ[X Fin (‚Ñì - ‚Üëi.castSucc)] := wit.H
    let h_i : L‚¶É‚â§ 2‚¶Ñ[X] := by admit /- proof elided -/

LawfulMonad in Init.Control.Lawful.Basic

instance : ‚àÄ j, OracleInterface ((pSpecFold D x k s).Message j) :=
  instOracleInterfaceMessageSeqCompose

Polynomial.degree in Mathlib.Algebra.Polynomial.Degree.Definitions

noncomputable def fold
  {S : Finset Œπ} (œÜ : Œπ ‚Ü™ F) (f : Œπ ‚Üí F) (k : ‚Ñï) (Œ± : F) : indexPow S œÜ k ‚Üí F :=
    fun x => (xPoly f œÜ k x).eval Œ±

def toFinMatrix {m n : ‚Ñï} (matrix : Matrix Œ± m n) : _root_.Matrix (Fin m) (Fin n) Œ± :=
  fun i j => (matrix.get i).get j

def verifyProof {Œ±} [DecidableEq Œ±] {s}
    (idx : BinaryTree.SkeletonLeafIndex s) (leafValue : Œ±) (rootValue : Œ±)
    (proof : List Œ±) : OracleComp (spec Œ±) Unit := do
  let putative_root ‚Üê getPutativeRoot idx leafValue proof
  guard (putative_root = rootValue)

OracleComp.neverFails in VCVio.OracleComp.Traversal

def computableTwiddleFactor (i : Fin ‚Ñì) (u : Fin (2 ^ (‚Ñì + R_rate - i - 1))) : L :=
  
  ‚àë (‚ü®k, hk‚ü©: Fin (‚Ñì + R_rate - i - 1)),
  if Nat.getBit k u.val = 1 then
    
      
    (evalNormalizedWAt (Œ≤ := Œ≤) (‚Ñì := ‚Ñì) (R_rate := R_rate)
      (i := ‚ü®i, by admit /- proof elided -/
      ‚ü©) (x := Œ≤ ‚ü®i + 1 + k, by admit /- proof elided -/
      ‚ü©))
  else 0

structure PrattCertificate (p : ‚Ñï) : Type where
  a : ZMod p
  pow_eq_one : a ^ (p - 1) = 1
  part : PrattPart p a (p - 1)

Nat.binaryRec in Mathlib.Data.Nat.BinaryRec

def MLE (evals : (œÉ ‚Üí Fin 2) ‚Üí R) : MvPolynomial œÉ R :=
    ‚àë x : œÉ ‚Üí Fin 2, (eqPolynomial (x : œÉ ‚Üí R)) * C (evals x)

protected def cast (T : FullTranscript pSpec‚ÇÅ) :
    FullTranscript pSpec‚ÇÇ :=
  Transcript.cast (k := Fin.last n‚ÇÅ) (l := Fin.last n‚ÇÇ) hn hn hSpec T

@[inline] def monoToLagrange (n : ‚Ñï) : MlPoly R n ‚Üí MlPolyEval R n :=
  (List.finRange n).foldl (fun acc level => monoToLagrangeLevel level acc)

instance : OracleInterfaces (vPSpec.toProtocolSpec A) where
  oracleInterfaces := fun _ => some OracleInterface.instVector

def deriveTranscriptSRAux {Œπ : Type} {oSpec : OracleSpec Œπ} {StmtIn : Type}
    (stmt : StmtIn) (k : Fin (n + 1)) (messages : pSpec.MessagesUpTo k)
    (j : Fin (k + 1)) :
    OracleComp (oSpec ++‚Çí fsChallengeOracle StmtIn pSpec)
      (pSpec.Transcript (j.castLE (by admit /- proof elided -/
      ))) := do
  Fin.induction (n := k)
    (pure (fun i => i.elim0))
    (fun i ih => do
      let prevTranscript ‚Üê ih
      match hDir : pSpec.dir (i.castLE (by admit /- proof elided -/
      )) with
      | .V_to_P =>
        let challenge : pSpec.Challenge ‚ü®i.castLE (by admit /- proof elided -/
        ), hDir‚ü© ‚Üê
          query (spec := fsChallengeOracle _ _) ‚ü®i.castLE (by admit /- proof elided -/
          ), hDir‚ü©
            (stmt, messages.take i.castSucc)
        return prevTranscript.concat challenge
      | .P_to_V => return prevTranscript.concat (messages ‚ü®i, hDir‚ü©))
    j

Functor.map in Init.Prelude

class IsSecure
    (relation : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (Œµ_rbr : vPSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0)
    (vectorIOP : VectorIOP Statement OStatement Witness vPSpec A) where

   
  is_complete : vectorIOP.perfectCompleteness (pure ()) ‚ü®isEmptyElim‚ü© relation

   
  is_rbr_knowledge_sound :
    OracleProof.rbrKnowledgeSoundness (pure ()) ‚ü®isEmptyElim‚ü© relation vectorIOP.verifier Œµ_rbr

noncomputable def sDomainBasisVectors (i : Fin r) : Fin (‚Ñì + R_rate - i) ‚Üí L :=
  fun k => (normalizedW ùîΩq Œ≤ i).eval (Œ≤ ‚ü®i + k.val, by admit /- proof elided -/
  ‚ü©)

instance : Zero (Cayley T) where
  zero := zero

MvPolynomial.monomial in Mathlib.Algebra.MvPolynomial.Basic

def finUInt8Equiv : Fin (2 ^ 8) ‚âÉ UInt8 where
  toFun := fun i => UInt8.ofFin i
  invFun := fun u => u.toFin
  left_inv _ := rfl
  right_inv _ := rfl

def NBlockMessages := 2 * (œë - 1) + 3

Polynomial.mapAlgEquiv in Mathlib.Algebra.Polynomial.AlgebraMap

@[simp]
def testLensE : Extractor.Lens OuterStmtIn_Test OuterStmtOut_Test InnerStmtIn_Test InnerStmtOut_Test
                Unit Unit Unit Unit where
  stmt := testStmtLens
  wit := Witness.InvLens.id

@[reducible]
def messageLength (vPSpec : VectorSpec n) (i : MessageIdx vPSpec) : Nat := vPSpec.length i

def Rhs (e : ‚Ñï) (œâs f : Fin n ‚Üí F) (i : Fin n) : F :=
  let Œ±·µ¢ := œâs i
  (-(f i) * Œ±·µ¢^e)

noncomputable def weight_Œõ_over_ùí™ {H : F[X][Y]} (f : ùí™ H) (D : ‚Ñï)
  : WithBot ‚Ñï := weight_Œõ (canonicalRepOfùí™ f) H D

class Extractor.Lens.IsKnowledgeSound
    {OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut : Type}
    {OuterWitIn OuterWitOut InnerWitIn InnerWitOut : Type}
    (outerRelIn : Set (OuterStmtIn √ó OuterWitIn))
    (innerRelIn : Set (InnerStmtIn √ó InnerWitIn))
    (outerRelOut : Set (OuterStmtOut √ó OuterWitOut))
    (innerRelOut : Set (InnerStmtOut √ó InnerWitOut))
    (compatStmt : OuterStmtIn ‚Üí InnerStmtOut ‚Üí Prop)
    (compatWit : OuterWitOut ‚Üí InnerWitIn ‚Üí Prop)
    (lens : Extractor.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                            OuterWitIn OuterWitOut InnerWitIn InnerWitOut) where

   
  proj_knowledgeSound : ‚àÄ outerStmtIn innerStmtOut outerWitOut,
    compatStmt outerStmtIn innerStmtOut ‚Üí
    (lens.stmt.lift outerStmtIn innerStmtOut, outerWitOut) ‚àà outerRelOut ‚Üí
    (innerStmtOut, lens.wit.proj (outerStmtIn, outerWitOut)) ‚àà innerRelOut

   
  lift_knowledgeSound : ‚àÄ outerStmtIn outerWitOut innerWitIn,
    compatWit outerWitOut innerWitIn ‚Üí
    (lens.stmt.proj outerStmtIn, innerWitIn) ‚àà innerRelIn ‚Üí
    (outerStmtIn, lens.wit.lift (outerStmtIn, outerWitOut) innerWitIn) ‚àà outerRelIn

Membership.mem in Init.Prelude

def FullData.copath {Œ±} {s} (cache_tree : FullData Œ± s) :
    BinaryTree.SkeletonLeafIndex s ‚Üí List Œ±
  | .ofLeaf => []
  | .ofLeft idxLeft =>
    (cache_tree.rightSubtree).getRootValue ::
      (copath cache_tree.leftSubtree idxLeft)
  | .ofRight idxRight =>
    (cache_tree.leftSubtree).getRootValue ::
      (copath cache_tree.rightSubtree idxRight)

def fnOracle (spec : OracleSpec Œπ) (f : (i : Œπ) ‚Üí spec.domain i ‚Üí spec.range i) :
    SimOracle.Impl spec where
  impl | query i t => pure (f i t)

def extractMiddleFinMask (v : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®0, by exact pos_of_neZero r‚ü©)
    (i : Fin ‚Ñì) (steps : ‚Ñï) : Fin (2 ^ steps) :=

def vflatten {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (v : (i : Fin m) ‚Üí Fin (n i) ‚Üí Œ±) :
    Fin (vsum n) ‚Üí Œ± :=
  dflatten v

@[reducible, simp] def StmtOut := Query OStatement √ó Response OStatement

Set.imageFactorization in Mathlib.Data.Set.Operations

def StraightlineExtractor (oSpec : OracleSpec Œπ) (Data Commitment : Type) :=
  Commitment ‚Üí QueryLog oSpec ‚Üí Data

noncomputable def J (q Œ¥ : ‚Ñö) : ‚Ñù :=
  let frac := q / (q - 1)
  (1 / frac) * (1 - Real.sqrt (1 - frac * Œ¥))

noncomputable def commitRbrExtractor (i : Fin ‚Ñì) :
  Extractor.RoundByRound []‚Çí
    (StmtIn := (Statement (L := L) Context i.succ) √ó (‚àÄ j, OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc j))
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (pSpec := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)
    (WitMid := fun _messageIdx => Witness (L := L) ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ) where
  eqIn := rfl
  extractMid := fun _ _ _ witMidSucc => witMidSucc
  extractOut := fun _ _ witOut => witOut

def hintBytes (state : FSProverState U H R) (hint : ByteArray) :
    Except DomainSeparatorMismatch (FSProverState U H R) :=
  match state.hashState.hint with
  | .ok newHashState =>
    
    
    .ok { rng := state.rng, hashState := newHashState, nargString := state.nargString }
  | .error e => .error e

def relation (cs : ConstraintSystem ùì° numWires numGates) (‚Ñì : ‚Ñï) (h‚Ñì : ‚Ñì ‚â§ numWires) :
    (publicInputs : Fin ‚Ñì ‚Üí ùì°) ‚Üí (privateWitness : Fin (numWires - ‚Ñì) ‚Üí ùì°) ‚Üí Prop :=
  fun (x : Fin ‚Ñì ‚Üí ùì°) (œâ : Fin (numWires - ‚Ñì) ‚Üí ùì°) =>
    let combined := Fin.append x œâ ‚àò Fin.cast (by admit /- proof elided -/
    )
    cs.accepts combined

def stirRelation
    {F : Type} [Field F] [Fintype F] [DecidableEq F]
    {Œπ : Type} [Fintype Œπ] [Nonempty Œπ]
    (degree : ‚Ñï) (œÜ : Œπ ‚Ü™ F) (err : ‚Ñù)
    : Set ((Unit √ó ‚àÄ i, (OracleStatement Œπ F i)) √ó Unit) :=
  fun ‚ü®‚ü®_, oracle‚ü©, _‚ü© => Œ¥·µ£(oracle (), ReedSolomon.code œÜ degree) ‚â§ err

def verifyEqOne (n a' : Q(‚Ñï)) (a : Q(ZMod $n)) (_ : Q(($a' : ZMod $n) = $a)) :
    MetaM Q($a ^ ($n - 1) = 1) := do
  let p : Q(ZMod $n) := q($a ^ ($n - 1))
  let .isNat _ c hc ‚Üê Tactic.ReduceModChar.normIntNumeral n p
    q(CommRing.toRing) q(ZMod.charP $n) | failure
  assumeInstancesCommute
  haveI : $p =Q $a ^ ($n - 1) := ‚ü®‚ü©
  haveI : $c =Q 1 := ‚ü®‚ü©
  return q(ZMod.bla $a (.refl _) $hc)

def take (j : Fin (n + 1)) (messages : Messages pSpec) : MessagesUpTo j pSpec :=

@[simp]
abbrev OracleStatement.AfterSecondSumcheck : R1CS.MatrixIdx ‚äï R1CS.MatrixIdx ‚äï Fin 1 ‚Üí Type :=
  Sum.elim (EvalClaim R) (OracleStatement.AfterFirstSumcheck R pp)

Nat.reduceAdd in Lean.Meta.Tactic.Simp.BuiltinSimprocs.Nat

@[inline] def ofNat (k : Nat) : AssocNat :=
  ‚ü®fun m => m + k, fun m => Nat.succ_add m k‚ü©

class ProverLast (pSpec : ProtocolSpec n) [inst : NeZero n] where
  prover_last' : pSpec.dir ‚ü®n - 1, by admit /- proof elided -/
  ‚ü© = .P_to_V

List.cons in Init.Prelude

def finIdxOf [BEq Œ±] [LawfulBEq Œ±] (a : Œ±) (l : List Œ±) : Fin (l.length + 1) :=
  ‚ü®List.idxOf' a l, Nat.lt_succ_of_le (by admit /- proof elided -/
  )‚ü©

@[inline]
def permute (params : Params) (state : Vector KoalaBear.Field params.width) :
    Vector KoalaBear.Field params.width :=
  letI rcs := params.roundConstants

  
  let st0 := externalLinearLayer params state

  
  let st1 : Vector KoalaBear.Field params.width :=
    Fin.foldl params.halfNumFullRounds (fun st_acc rc_idx =>
      let rc_chunk := (rcs.extract rc_idx (rc_idx + params.width)).cast (by admit /- proof elided -/
      )
      let st_new := fullRound params st_acc rc_chunk
      st_new) st0

  
  let rcs := rcs.drop (params.halfNumFullRounds * params.width)

  
  let st2 := Fin.foldl params.numPartialRounds (fun st_acc rc_idx =>
    let rc_val := rcs[rc_idx]'(sorry)
    let st_new := partialRound params st_acc rc_val
    st_new) st1

  
  let rcs := rcs.drop params.numPartialRounds

  
  let st3 := Fin.foldl params.halfNumFullRounds (fun st_acc rc_idx =>
    let rc_chunk := (rcs.extract rc_idx (rc_idx + params.width)).cast (by admit /- proof elided -/
    )
    let st_new := fullRound params st_acc rc_chunk
    st_new) st2

  st3

instance : Fact (Nat.Prime scalarFieldSize) := ‚ü®ScalarField_is_prime‚ü©

def StateRestoration (oSpec : OracleSpec Œπ)
    (StmtIn WitIn WitOut : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n) :=
  StmtIn ‚Üí 
  WitOut ‚Üí 
  pSpec.FullTranscript ‚Üí 
  QueryLog (oSpec ++‚Çí (srChallengeOracle StmtIn pSpec)) ‚Üí 
  QueryLog oSpec ‚Üí 
  OracleComp oSpec WitIn 

StateT.run in Init.Control.State

AdjoinRoot.powerBasis in Mathlib.RingTheory.AdjoinRoot

def ratchet (sponge : DuplexSponge U C) :
    OracleComp (forwardPermutationOracle C) (DuplexSponge U C) := do
  let permutedState : C ‚Üê query (spec := forwardPermutationOracle C) () sponge.state
  
  let vecState : Vector U SpongeSize.N := SpongeState.get permutedState
  
  let zeroed : Vector U SpongeSize.N :=
    Vector.ofFn (fun i => if i < SpongeSize.R then 0 else vecState[i])
  
  let newVecState := SpongeState.update permutedState zeroed
  
  return { sponge with
    state := newVecState,
    squeezePos := Fin.last SpongeSize.R }

instance : Field ScalarField := ZMod.instField scalarFieldSize

structure ConcreteBTFAddCommGroupProps (k : ‚Ñï) where
  add_assoc : ‚àÄ a b c : ConcreteBTField k, (a + b) + c = a + (b + c) := add_assoc
  add_comm : ‚àÄ a b : ConcreteBTField k, a + b = b + a := add_comm
  add_zero : ‚àÄ a : ConcreteBTField k, a + zero = a := add_zero
  zero_add : ‚àÄ a : ConcreteBTField k, zero + a = a := zero_add
  add_neg : ‚àÄ a : ConcreteBTField k, a + (neg a) = zero := neg_add_cancel

noncomputable def disagreementSet (f : Œπ ‚Üí F) (S : Finset F) (Ans : S ‚Üí F) : Finset F :=
  Set.toFinset ({x : Œπ | x.val ‚àà S ‚àß (ansPoly S Ans).eval x.val ‚â† f x}.image Subtype.val)

def OracleSpec.proverOracle (StmtIn : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n) :
    OracleSpec pSpec.MessageIdx :=
  fun i => (StmtIn √ó pSpec.Transcript i.val.castSucc, pSpec.Message i)

def divide_by_2 (s : Finset ‚Ñï) : Finset ‚Ñï :=
  (erase_odd s).image (fun n => n / 2)

def neg_descending (p : UniPoly R) : QuotientUniPoly R :=
  Quotient.mk _ (neg p)

noncomputable def foldNth (n : ‚Ñï) (f : ùîΩ[X]) (Œ± : ùîΩ) [inst : NeZero n] : ùîΩ[X] :=
  ‚àë i : Fin n, Polynomial.C Œ± ^ i.1 * splitNth f n i

def sumCases {l : List ‚Ñï} {motive : Fin l.sum ‚Üí Sort*}
    (cases : ‚àÄ (n : ‚Ñï) (h : n ‚àà l) (i : Fin n), motive (castSum l h i))
    (i : Fin l.sum) : motive i := match l with
  | [] => by admit /- proof elided -/
  | n' :: l' => by admit /- proof elided -/

instance coe_field_adjoinRoot (k : ‚Ñï) : Coe (AdjoinRoot (poly k)) (BTField (k+1)) where
  coe := Eq.mp (BTField_succ_eq_adjoinRoot k)

Vector in Init.Data.Vector.Basic

OracleSpec.range in VCVio.OracleComp.OracleSpec

Vector.tail in Init.Data.Vector.Basic

@[reducible, inline]
instance instPolynomialDegreeLE : OracleInterface (R‚¶É‚â§ d‚¶Ñ[X]) where
  Query := R
  Response := R
  answer := fun ‚ü®poly, _‚ü© point => poly.eval point

instance : IsEmpty (OracleQuery []‚Çí Œ±) where
  false := by admit /- proof elided -/

instance (priority := low) : DCast‚ÇÇ Œ± Œ≤ Œ≥ where
  dcast‚ÇÇ ha hb c := by admit /- proof elided -/

def generateSrs (n : ‚Ñï) (a : ZMod p) : Vector G‚ÇÅ (n + 1) √ó Vector G‚ÇÇ 2 :=
  (towerOfExponents g‚ÇÅ a n, towerOfExponents g‚ÇÇ a 1)

@[reducible]
def spec : OracleSpec Unit := fun _ => (Œ± √ó Œ±, Œ±)

def modNat [Zero T] [DecidableEq T] [ToNat T]
    (dividend divisor : Cayley T) : Nat ‚Üí Cayley T
  | 0        => dividend  
  | .succ fuel =>
    
    if (‚Üëdivisor : Nat) = 0 then
      dividend
    else
      
      if (‚Üëdivisor : Nat) ‚â§ (‚Üëdividend : Nat) then
        
        modNat (sub dividend divisor) divisor fuel
      else
        dividend

RingHom.id in Mathlib.Algebra.Ring.Hom.Defs

randomOracle in VCVio.OracleComp.QueryTracking.CachingOracle

Function.update in Mathlib.Logic.Function.Basic

class GenMutualCorrParams (P : Params Œπ F) (S : ‚àÄ i : Fin (M + 1), Finset (Œπ i)) where

  Œ¥ : Fin (M + 1) ‚Üí ‚Ñù‚â•0
  dist : (i : Fin (M + 1)) ‚Üí Fin ((P.foldingParam i) + 1) ‚Üí ‚Ñù‚â•0


  œÜ : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), (indexPowT (S i) (P.œÜ i) j) ‚Ü™ F

  inst1 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Fintype (indexPowT (S i) (P.œÜ i) j)
  inst2 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    Nonempty (indexPowT (S i) (P.œÜ i) j)
  inst3 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    DecidableEq (indexPowT (S i) (P.œÜ i) j)
  inst4 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Smooth (œÜ i j)

  par‚Ñì_type : ‚àÄ i : Fin (M + 1), ‚àÄ _ : Fin ((P.foldingParam i) + 1), Type
  inst5 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Fintype (par‚Ñì_type i j)

  exp : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), (par‚Ñì_type i j) ‚Ü™ ‚Ñï



  Gen_Œ± : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    ProximityGenerator (indexPowT (S i) (P.œÜ i) j) F :=
      fun i j => RSGenerator.genRSC (par‚Ñì_type i j) (œÜ i j) (P.varCount i - j) (exp i j)

  inst6 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Fintype (Gen_Œ± i j).par‚Ñì

  BStar : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    (Set ((indexPowT (S i) (P.œÜ i) j) ‚Üí F)) ‚Üí Type ‚Üí ‚Ñù‚â•0
  errStar : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    (Set ((indexPowT (S i) (P.œÜ i) j) ‚Üí F)) ‚Üí Type ‚Üí ‚Ñù ‚Üí ENNReal

  C : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Set ((indexPowT (S i) (P.œÜ i) j) ‚Üí F)
  hcode : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), (C i j) = (Gen_Œ± i j).C

  h : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    hasMutualCorrAgreement (Gen_Œ± i j)
      (BStar i j (C i j) (Gen_Œ± i j).par‚Ñì)
      (errStar i j (C i j) (Gen_Œ± i j).par‚Ñì)

  h‚Ñì_bound : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    Fintype.card (Gen_Œ± i j).par‚Ñì = 2
  h‚Ñì_bound' : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    Fintype.card (par‚Ñì_type i j) = 2

  hŒ¥Le : ‚àÄ i : Fin (M + 1),
    (Œ¥ i) ‚â§ 1 - Finset.univ.sup (fun j => BStar i j (C i j) (Gen_Œ± i j).par‚Ñì)

  hlistDecode : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    listDecodable (C i j) (Œ¥ i) (dist i j)

structure RoundByRound
    (oSpec : OracleSpec Œπ) (StmtIn WitIn WitOut : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n)
    (WitMid : Fin (n + 1) ‚Üí Type) where
   
  eqIn : WitMid 0 = WitIn
   
  extractMid : (m : Fin n) ‚Üí StmtIn ‚Üí Transcript m.succ pSpec ‚Üí WitMid m.succ ‚Üí WitMid m.castSucc
   
  extractOut : StmtIn ‚Üí FullTranscript pSpec ‚Üí WitOut ‚Üí WitMid (.last n)

def relayPrvState (i : Fin ‚Ñì) : Fin (0 + 1) ‚Üí Type := fun
  | ‚ü®0, _‚ü© => Statement (L := L) Context i.succ √ó
    (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j) √ó
    Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ

def vcons {n : ‚Ñï} (a : Œ±) (v : Fin n ‚Üí Œ±) : Fin (n + 1) ‚Üí Œ± :=
  dcons a v

@[reducible, simp]
def OracleStatement.Lens.IsSound {OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut : Type}
    {Outer_Œπ‚Çõ·µ¢ : Type} {OuterOStmtIn : Outer_Œπ‚Çõ·µ¢ ‚Üí Type} [‚àÄ i, OracleInterface (OuterOStmtIn i)]
    {Outer_Œπ‚Çõ‚Çí : Type} {OuterOStmtOut : Outer_Œπ‚Çõ‚Çí ‚Üí Type} [‚àÄ i, OracleInterface (OuterOStmtOut i)]
    {Inner_Œπ‚Çõ·µ¢ : Type} {InnerOStmtIn : Inner_Œπ‚Çõ·µ¢ ‚Üí Type} [‚àÄ i, OracleInterface (InnerOStmtIn i)]
    {Inner_Œπ‚Çõ‚Çí : Type} {InnerOStmtOut : Inner_Œπ‚Çõ‚Çí ‚Üí Type} [‚àÄ i, OracleInterface (InnerOStmtOut i)]
    (outerLangIn : Set (OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i)))
    (outerLangOut : Set (OuterStmtOut √ó (‚àÄ i, OuterOStmtOut i)))
    (innerLangIn : Set (InnerStmtIn √ó (‚àÄ i, InnerOStmtIn i)))
    (innerLangOut : Set (InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i)))
    (compatStmt :
      OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i) ‚Üí InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i) ‚Üí Prop)
    (lens : OracleStatement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                                    OuterOStmtIn OuterOStmtOut InnerOStmtIn InnerOStmtOut) :=
  Statement.Lens.IsSound outerLangIn outerLangOut innerLangIn innerLangOut compatStmt lens

def map (f : R ‚Üí+* S) (p : MlPolyEval R n) : MlPolyEval S n :=
  Vector.map (fun a => f a) p

@[inline, specialize]
def prover : Prover oSpec Statement Witness (Statement √ó Witness) Unit (pSpec Witness) where
  PrvState
  | 0 => Statement √ó Witness
  | 1 => Statement √ó Witness
  input := id
  sendMessage | ‚ü®0, _‚ü© => fun ‚ü®stmt, wit‚ü© => pure (wit, ‚ü®stmt, wit‚ü©)
  receiveChallenge | ‚ü®0, h‚ü© => nomatch h
  output := fun ‚ü®stmt, wit‚ü© => pure (‚ü®stmt, wit‚ü©, ())

structure Params where
  
  width : Nat
  numFullRounds : Nat
  numPartialRounds : Nat
  internalDiagVectors : Vector KoalaBear.Field width
  roundConstants : Vector KoalaBear.Field (numFullRounds * width + numPartialRounds)

  

   
  [width_ne_zero : NeZero width]

   
  [numFullRounds_ne_zero : NeZero numFullRounds]

   
  [numPartialRounds_ne_zero : NeZero numPartialRounds]

   
  width_dvd_by_4 : 4 ‚à£ width
   
  numFullRounds_even : Even numFullRounds

def AlgebraTowerEquiv.algebraMapRightUp (e : AlgebraTowerEquiv A B) (i j : Œπ)
    (h : i ‚â§ j) : (A i) ‚Üí+* (B j) :=

MvPolynomial in Mathlib.Algebra.MvPolynomial.Basic

DFunLike in Mathlib.Data.FunLike.Basic

repr in Init.Data.Repr

def inputRelation (cond : ‚àë i, (s i).1 ‚â§ n) [DecidableEq F] (Œ¥ : ‚Ñù‚â•0) :
    Set
      (
        (
          Statement F (Fin.last k) √ó
          (‚àÄ j, OracleStatement D x s (Fin.last k) j)
        ) √ó
        Witness F s d (Fin.last k).castSucc
      ) := sorry

instance : ‚àÄ i, SelectableType (Challenge ‚ü®!v[.P_to_V], !v[Msg]‚ü© i)
  | ‚ü®0, h‚ü© => nomatch h

def foldingBadEvent (i : Fin ‚Ñì) (steps : ‚Ñï) [NeZero steps] (h_i_add_steps : i + steps ‚â§ ‚Ñì)
  (f_i : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i, by admit /- proof elided -/
  ‚ü©)
  (challenges : Fin steps ‚Üí L) : Prop :=
  let d_i_plus_steps := BBF_CodeDistance ‚Ñì ùì° ‚ü®i + steps, by admit /- proof elided -/
  ‚ü©
  if h_is_close : 2 * fiberwiseDistance ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := i)
      steps h_i_add_steps f_i < (d_i_plus_steps : ‚Ñï‚àû) then
    
    
    
    let h_dist_curr_lt := fiberwise_dist_lt_imp_dist_lt_unique_decoding_radius ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := i) (steps := steps) h_i_add_steps f_i h_is_close

    let f_bar_i := uniqueClosestCodeword ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (i := ‚ü®i, by admit /- proof elided -/
      ‚ü©) (h_i := by admit /- proof elided -/
      ) f_i
      h_dist_curr_lt
    let folded_f_i := iterated_fold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (steps := ‚ü®steps, by admit /- proof elided -/
      ‚ü©) (i := ‚ü®i, by admit /- proof elided -/
      ‚ü©)
      (h_i_add_steps := by admit /- proof elided -/
      ) f_i challenges
    let folded_f_bar_i := iterated_fold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (steps := ‚ü®steps, by admit /- proof elided -/
      ‚ü©) (i := ‚ü®i, by admit /- proof elided -/
      ‚ü©)
      (h_i_add_steps := by admit /- proof elided -/
      ) f_bar_i challenges

    let fiberwise_disagreements := fiberwiseDisagreementSet ùîΩq Œ≤ i steps h_i_add_steps
      f_i f_bar_i
    let folded_disagreements := disagreementSet ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i steps
      h_i_add_steps folded_f_i folded_f_bar_i
    
    ¬¨ (fiberwise_disagreements ‚äÜ folded_disagreements)
  else
    
    
    
    let folded_f_i := iterated_fold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (steps := ‚ü®steps, by admit /- proof elided -/
      ‚ü©) (i := ‚ü®i, by admit /- proof elided -/
      ‚ü©)
      (h_i_add_steps := by admit /- proof elided -/
      ) f_i challenges
    let dist_to_code := distFromCode folded_f_i
      (BBF_Code ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i + steps, by admit /- proof elided -/
      ‚ü©)
    2 * dist_to_code < (d_i_plus_steps : ‚Ñï‚àû)

instance (priority := 1000) algebra_adjacent_tower (l : ‚Ñï) :
  Algebra (BTField l) (BTField (l+1)) :=

Finset.product in Mathlib.Data.Finset.Prod

Multiset.filter in Mathlib.Data.Multiset.Filter

structure AlgebraTowerEquiv (A : Œπ ‚Üí Type*) [‚àÄ i, CommSemiring (A i)] [a : AlgebraTower A]
  (B : Œπ ‚Üí Type*) [‚àÄ i, CommSemiring (B i)] [b : AlgebraTower B]
  where
    toRingEquiv : ‚àÄ i, (A i ‚âÉ+* B i)
    commutesLeft' : ‚àÄ (i j : Œπ) (h : i ‚â§ j) (r : A i),
      (b.algebraMap (i:=i) (j:=j) (h:=h)) ((toRingEquiv i) r) =
      (toRingEquiv j) (a.algebraMap (i:=i) (j:=j) (h:=h) r)

def rawConstants16 : Vector KoalaBear.Field 148 := #v[
    2128964168,
    288780357,
    316938561,
    2126233899,
    426817493,
    1714118888,
    1045008582,
    1738510837,
    889721787,
    8866516,
    681576474,
    419059826,
    1596305521,
    1583176088,
    1584387047,
    1529751136,
    1863858111,
    1072044075,
    517831365,
    1464274176,
    1138001621,
    428001039,
    245709561,
    1641420379,
    1365482496,
    770454828,
    693167409,
    757905735,
    136670447,
    436275702,
    525466355,
    1559174242,
    1030087950,
    869864998,
    322787870,
    267688717,
    948964561,
    740478015,
    679816114,
    113662466,
    2066544572,
    1744924186,
    367094720,
    1380455578,
    1842483872,
    416711434,
    1342291586,
    1692058446,
    1493348999,
    1113949088,
    210900530,
    1071655077,
    610242121,
    1136339326,
    2020858841,
    1019840479,
    678147278,
    1678413261,
    1361743414,
    61132629,
    1209546658,
    64412292,
    1936878279,
    1980661727,
    1423960925,
    2101391318,
    1915532054,
    275400051,
    1168624859,
    1141248885,
    356546469,
    1165250474,
    1320543726,
    932505663,
    1204226364,
    1452576828,
    1774936729,
    926808140,
    1184948056,
    1186493834,
    843181003,
    185193011,
    452207447,
    510054082,
    1139268644,
    630873441,
    669538875,
    462500858,
    876500520,
    1214043330,
    383937013,
    375087302,
    636912601,
    307200505,
    390279673,
    1999916485,
    1518476730,
    1606686591,
    1410677749,
    1581191572,
    1004269969,
    143426723,
    1747283099,
    1016118214,
    1749423722,
    66331533,
    1177761275,
    1581069649,
    1851371119,
    852520128,
    1499632627,
    1820847538,
    150757557,
    884787840,
    619710451,
    1651711087,
    505263814,
    212076987,
    1482432120,
    1458130652,
    382871348,
    417404007,
    2066495280,
    1996518884,
    902934924,
    582892981,
    1337064375,
    1199354861,
    2102596038,
    1533193853,
    1436311464,
    2012303432,
    839997195,
    1225781098,
    2011967775,
    575084315,
    1309329169,
    786393545,
    995788880,
    1702925345,
    1444525226,
    908073383,
    1811535085,
    1531002367,
    1635653662,
    1585100155,
    867006515,
    879151050,
]

Fin.cons in Mathlib.Data.Fin.Tuple.Basic

LinearMap.codRestrict in Mathlib.Algebra.Module.Submodule.LinearMap

def add_descending (p q : UniPoly R) : QuotientUniPoly R :=
  Quotient.mk _ (add p q)

Polynomial.degreeLT in Mathlib.RingTheory.Polynomial.Basic

instance : ‚àÄ i, VCVCompatible ((pSpec Witness).Challenge i) | ‚ü®0, h‚ü© => nomatch h

@[reducible, simp]
def ChallengeIdx (pSpec : ProtocolSpec n) :=
  {i : Fin n // pSpec.dir i = Direction.V_to_P}

def concat' {k : Fin n}
    (messages : (i : Fin k) ‚Üí (pSpec.dir (i.castLE (by admit /- proof elided -/
    )) = .P_to_V
      ‚Üí pSpec.¬´Type¬ª (i.castLE (by admit /- proof elided -/
      ))))
    (msg : (h : pSpec.dir k = .P_to_V) ‚Üí pSpec.Message ‚ü®k, h‚ü©) :
    (i : Fin (k + 1)) ‚Üí (pSpec.dir (i.castLE (by admit /- proof elided -/
    )) = .P_to_V) ‚Üí
      pSpec.¬´Type¬ª (i.castLE (by admit /- proof elided -/
      )) :=
  Fin.dconcat messages msg

Int.ofNat in Init.Data.Int.Basic

EquivLike in Mathlib.Data.FunLike.Equiv

instance : ‚àÄ i, VCVCompatible ((default : ProtocolSpec 0).Challenge i) := fun ‚ü®i, _‚ü© => Fin.elim0 i

HMul in Init.Prelude

@[reducible, simp] def WitOut := Unit

@[inline] def succ (a : Cayley T) : Cayley T := add a one

instance domain_neg_inst {F : Type} [NonBinaryField F] [Finite F] {D : Subgroup FÀ£} {n : ‚Ñï}
    [DIsCyclicC : IsCyclicWithGen ‚Ü•D] [DSmooth : SmoothPowerOfTwo n ‚Ü•D]
    {x : FÀ£} (i : Fin n) : Neg (evalDomain D x i) where
  neg := fun a => ‚ü®_, neg_mem_dom_of_mem_dom D x i a.2‚ü©

structure FSVerifierState (U : Type) [SpongeUnit U] (H : Type*) [DuplexSpongeInterface U H] where
   
  hashState : HashStateWithInstructions U H
   
  nargString : ByteArray
deriving Repr

def inputRelation : Set ((StmtIn R √ó (‚àÄ i, OStmtIn R deg i)) √ó Unit) :=
  { ‚ü®‚ü®target, oStmt‚ü©, _‚ü© | ‚àë x ‚àà (univ.map D), (oStmt ()).1.eval x = target }

instance {Œ± : Type u} : SliceGE (List Œ±) Nat (fun _ _ => True) (fun _ _ _ => List Œ±) where
  sliceGE xs start _ := List.drop start xs

DecidableEq in Init.Prelude

def queryCodeword (j : Fin (toOutCodewordsCount ‚Ñì œë (Fin.last ‚Ñì)))
    (point : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®j.val * œë,
      by admit /- proof elided -/
          ‚ü©) :
  OracleComp ([OracleStatement ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (
  Fin.last ‚Ñì)]‚Çí) L :=
      OracleComp.lift <| by
        simpa using
          OracleSpec.query
            (spec := [OracleStatement ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì)]‚Çí)
            ‚ü®j, by admit /- proof elided -/
            ‚ü©
            (by admit /- proof elided -/
            )

instance {pSpec : ProtocolSpec n} {Statement : Type} [‚àÄ i, VCVCompatible (pSpec.Challenge i)] :
    OracleSpec.FiniteRange (srChallengeOracle Statement pSpec) where
  range_inhabited' := fun i => by admit /- proof elided -/

inductive ScalarOp where | add | sub | mul | div

instance : ‚àÄ j, OracleInterface ((pSpec F).Message j)
  | ‚ü®0, h‚ü© => nomatch h
  | ‚ü®1, _‚ü© => by admit /- proof elided -/

class HasSize (Œ± : Type*) (Œ≤ : Type*) where
  size : Nat
  toFun : Œ± ‚Ü™ Vector Œ≤ size

instance {k : Fin (n + 1)} : Fintype (pSpec.ChallengeIdxUpTo k) :=
  inferInstanceAs (Fintype <| ChallengeIdx (pSpec.take k k.is_le))

def BinaryTowerAux (k : ‚Ñï) : (Œ£' (F : Type 0), BinaryTowerResult F k) :=
  match k with
  | 0 => 
    let curBTField := GF(2)
    let newList : List.Vector (GF(2)) 1 := List.Vector.cons (1 : GF(2)) List.Vector.nil
    let specialElement : GF(2) := newList.1.headI
    let firstElementOfVecIsSpecialElement : newList.1.headI = specialElement := rfl
    let specialElementIs1 : specialElement = 1 := by admit /- proof elided -/

def getFirstOracle {i : Fin (‚Ñì + 1)}
    (oStmt : (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i j)) :
    sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate 0 ‚Üí L :=

@[simp]
abbrev Witness.AfterFirstChallenge : Type := Unit

def smoothCode
  (domain : Œπ ‚Ü™ F) [Smooth domain]
  (m : ‚Ñï) : Submodule F (Œπ ‚Üí F) := ReedSolomon.code domain (2^m)

@[reducible, simp]
def toRelOut : Set ((Statement √ó Witness) √ó Unit) :=
  Prod.fst ‚Åª¬π' relIn

@[inline, reducible]
def Statement.Lens (OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut : Type)
  := PFunctor.Lens (OuterStmtIn X^ OuterStmtOut)
                   (InnerStmtIn X^ InnerStmtOut)

inductive LeafData (Œ± : Type) : Skeleton ‚Üí Type
  | leaf (value : Œ±) : LeafData Œ± Skeleton.leaf
  | internal {left right} (leftData : LeafData Œ± left) (rightData : LeafData Œ± right) :
      LeafData Œ± (Skeleton.internal left right)
  deriving Repr

@[reducible, simp]
def rbrKnowledgeSoundness (relation : Set (Statement √ó Bool))
    (verifier : Verifier oSpec Statement Bool pSpec)
    (rbrKnowledgeError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) : Prop :=
  verifier.rbrKnowledgeSoundness init impl relation acceptRejectRel rbrKnowledgeError

instance polyMonic (n : ‚Ñï) : Monic (poly n) := definingPoly_is_monic (Z n)

@[inline] def mod [Zero T] [DecidableEq T] [ToNat T]
    (dividend divisor : Cayley T) : Cayley T :=
  
  letI fuel := (‚Üëdividend : Nat) + 1
  modNat dividend divisor fuel

def getCommitProverFinalOutput (i : Fin ‚Ñì)
    (inputPrvState : commitPrvState (Context := Context) ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i 0) :
  (‚Ü•(sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®‚Üëi + 1, by admit /- proof elided -/
  ‚ü©) ‚Üí L) √ó
  commitPrvState (Context := Context) ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i 1 :=
  let (stmt, oStmtIn, wit) := inputPrvState
  let f·µ¢_succ := wit.f
  let oStmtOut := snoc_oracle ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
    oStmtIn f·µ¢_succ 
  (f·µ¢_succ, (stmt, oStmtOut, wit))

instance : Unique (ProtocolSpec 0) where
  default := empty
  uniq := fun ‚ü®_, _‚ü© => by admit /- proof elided -/

@[app_unexpander Fin.vempty]
def vemptyUnexpander : Lean.PrettyPrinter.Unexpander
  | `($_:ident) => `(!v[])
  | _ => throw ()

def multilinearBasis (l r : ‚Ñï) (h_le : l ‚â§ r) :
    letI instAlgebra : Algebra (BTField l) (BTField r) := binaryAlgebraTower (h_le:=h_le)
    Basis (Fin (2 ^ (r - l))) (BTField l) (BTField r) :=

Matrix.add in Mathlib.LinearAlgebra.Matrix.Defs

def starData {Œ±} (k : ‚Ñï) (root : Œ±) (leaves : Fin k ‚Üí Œ±) :
    ArityTree.Data Œ± (starSkel k) :=

Mod.mod in Init.Prelude

abbrev CoeffVecSpace (L : Type u) (‚Ñì : Nat) := Fin (2^‚Ñì) ‚Üí L

def mul_by_2 (s : Finset ‚Ñï) : Finset ‚Ñï :=
  s.map ‚ü®fun n => 2 * n, by admit /- proof elided -/
  ‚ü©

instance {i : Fin ‚Ñì} : ‚àÄ j, SelectableType ((pSpecCommit ùîΩq Œ≤
  (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i).Challenge j)
  | ‚ü®0, hj‚ü© => by admit /- proof elided -/

@[reducible]
noncomputable def fullOracleProof :
  OracleProof []‚Çí
    (Statement := Statement (L := L) (‚Ñì:=‚Ñì) (SumcheckBaseContext L ‚Ñì) 0)
    (OStatement := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë 0)
    (Witness := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) 0)
    (pSpec:=fullPSpec ùîΩq Œ≤ Œ≥_repetitions (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)) :=
  fullOracleReduction ùîΩq Œ≤ Œ≥_repetitions (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë)

def uniqueClosestCodeword
  (i : Fin (‚Ñì + 1)) (h_i : i < ‚Ñì + ùì°)
  (f : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i, i.isLt‚ü©)
  (h_within_radius : hammingClose ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i f) :
  OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i, i.isLt‚ü© :=

instance {Œ± : Type u} : Slice (Array Œ±) Nat Nat (fun _ _ _ => True) (fun _ _ _ _ => Array Œ±) where
  slice xs start stop _ := xs.extract start stop

inductive PrattPartList : (p : ‚Ñï) ‚Üí (a : ZMod p) ‚Üí ‚Ñï ‚Üí Prop
  | prime : {p : ‚Ñï} ‚Üí {a : ZMod p} ‚Üí (n k nk : ‚Ñï) ‚Üí n.Prime ‚Üí
      a ^ ((p - 1) / n) ‚â† 1 ‚Üí n ^ k = nk ‚Üí PrattPartList p a nk
  | split : {p : ‚Ñï} ‚Üí {a : ZMod p} ‚Üí {n : ‚Ñï} ‚Üí (list : List ‚Ñï) ‚Üí
      (‚àÄ r ‚àà list, PrattPartList p a r) ‚Üí list.prod = n ‚Üí PrattPartList p a n

Polynomial.map in Mathlib.Algebra.Polynomial.Eval.Defs

def subNat (c : AssocNat) : Nat ‚Üí AssocNat
| 0            => c 
| Nat.succ k   => pred (subNat c k) 

@[inline, specialize]
def add {R : Type*} [Ring R] [BEq R] [LawfulBEq R] (p q : QuotientUniPoly R) : QuotientUniPoly R :=
  Quotient.lift‚ÇÇ add_descending add_descends p q

abbrev CNat (n : ‚Ñï) : Type := (CayleyTower n).1

def roundRelation (i : Fin (‚Ñì + 1)) :
    Set ((Statement (L := L) Context i √ó
      (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i j)) √ó
      Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) :=
  { input | roundRelationProp (mp := mp) (ùìë := ùìë) ùîΩq Œ≤ i input}

@[simp]
def oCtxLens (i : Fin n) : OracleContext.Lens
    (StatementRound R n i.castSucc) (StatementRound R n i.succ) (Simple.StmtIn R) (Simple.StmtOut R)
    (OracleStatement R n deg) (OracleStatement R n deg)
    (Simple.OStmtIn R deg) (Simple.OStmtOut R deg)
    Unit Unit Unit Unit where
  wit := Witness.Lens.trivial
  stmt := oStmtLens R n deg D i

def squeeze (ds : DomainSeparator U H) (count : Nat) (label : String) : DomainSeparator U H :=
  
  
  
  
  { io := ds.io ++ SEP_BYTE ++ s!"S{count}" ++ label }

CoeFun in Init.Coe

Fin.add in Init.Data.Fin.Basic

noncomputable def changeOfBasisMatrix (‚Ñì : Nat) (h_‚Ñì : ‚Ñì ‚â§ r) : Matrix (Fin (2^‚Ñì)) (Fin (2^‚Ñì)) L :=
    fun j i => (toCoeffsVec (L := L) (‚Ñì := ‚Ñì) (
      basisVectors ùîΩq Œ≤ ‚Ñì h_‚Ñì j)) i

instance {Œ± : Type u} : Slice (List Œ±) Nat Nat (fun _ _ _ => True) (fun _ _ _ _ => List Œ±) where
  slice xs start stop _ := xs.extract start stop

noncomputable def towerRingEquiv0 : BTField 0 ‚âÉ+* ConcreteBTField 0 :=

@[reducible]
def GroupOpOracle : OracleSpec Unit := fun _ => (Œπ √ó Œπ √ó Œπ, Unit)

structure SumcheckMultiplierParam (L : Type) [CommRing L] (‚Ñì : ‚Ñï) (Context : Type := Unit) where
  multpoly : (ctx: Context) ‚Üí MultilinearPoly L ‚Ñì

Nonempty in Init.Prelude

def pow (S : Finset Œπ) (œÜ : Œπ ‚Ü™ F) (k : ‚Ñï) : indexPow S œÜ k ‚Ü™ F :=
    Function.Embedding.subtype fun y => y ‚àà indexPow S œÜ k

@[reducible, inline, specialize, simp]
def Message' (pSpec : ProtocolSpec n) (i : Fin n) (_ : pSpec.dir i = .P_to_V) := pSpec.¬´Type¬ª i

def Œ∂ (R : F[X][X][Y]) (x‚ÇÄ : F) (H : F[X][Y]) [H_irreducible : Fact (Irreducible H)] : ùïÉ H :=
  let W  : ùïÉ H := liftToFunctionField (H.leadingCoeff);
  let T : ùïÉ H := liftToFunctionField (Polynomial.X);
    Polynomial.eval‚ÇÇ liftToFunctionField (T / W)
      (Bivariate.evalX (Polynomial.C x‚ÇÄ) R.derivative)

instance [ProverFirst pSpec] : ProverLast pSpec where
  prover_last' := by admit /- proof elided -/

class HListRepr (Œ± : Type _) where
  repr: Œ± ‚Üí Std.Format

def eval‚ÇÇAlgHom {A : Type w} {B : Type*} [CommSemiring A] [CommSemiring B] [PolynomialLike A P]
    [Algebra R A] [IsScalarTower R A P] [Algebra R B] (f : A ‚Üí‚Çê[R] B) (b : B) :
      P ‚Üí‚Çê[R] B where
  toRingHom := eval‚ÇÇ f b
  commutes' := by admit /- proof elided -/

noncomputable def queryOracleProver :
  OracleProver
    (oSpec := []‚Çí)
    (StmtIn := FinalSumcheckStatementOut (L:=L) (‚Ñì:=‚Ñì))
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (
    Fin.last ‚Ñì))
    (WitIn := Unit)
    (StmtOut := Bool)
    (OStmtOut := fun _ : Empty => Unit)
    (WitOut := Unit)
    (pSpec := pSpecQuery ùîΩq Œ≤ Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)) where
  PrvState := fun
    | 0 => Unit
    | 1 => Unit
  input := fun _ => ()

  sendMessage
  | ‚ü®0, h‚ü© => nomatch h

  receiveChallenge
  | ‚ü®0, _‚ü© => fun _ => do
    
    pure (fun _challenges => ())

  output := fun _ => do 
    pure (‚ü®true, fun _ => ()‚ü©, ())

Function.Embedding.subtype in Mathlib.Logic.Embedding.Basic

MvPolynomial.coeff in Mathlib.Algebra.MvPolynomial.Basic

@[inline, reducible]
def proj : (OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i)) √ó OuterWitIn ‚Üí
    (InnerStmtIn √ó (‚àÄ i, InnerOStmtIn i)) √ó InnerWitIn :=
  fun ctxIn => ‚ü®lens.stmt.proj ctxIn.1, lens.wit.proj ctxIn‚ü©

IO.FS.Stream.read in Init.System.IO

AdjoinRoot.instAlgebra in Mathlib.RingTheory.AdjoinRoot

@[inline]
def add [Add R] (p q : MlPolyEval R n) : MlPolyEval R n := Vector.zipWith (¬∑ + ¬∑) p q

def inputRelation :
    Set
      (
        (Unit √ó (‚àÄ j, OracleStatement D x m j)) √ó
        Witness F s d m
      ) := sorry

def deriveTranscriptSR {Œπ : Type} {oSpec : OracleSpec Œπ} {StmtIn : Type}
    (stmt : StmtIn) (messages : pSpec.Messages) :
    OracleComp (oSpec ++‚Çí fsChallengeOracle StmtIn pSpec) pSpec.FullTranscript := do
  MessagesUpTo.deriveTranscriptSR stmt (Fin.last n) messages

alias deriveTranscriptFS := deriveTranscriptSR

Polynomial.compRingHom in Mathlib.Algebra.Polynomial.Eval.Defs

def squeezeInto (sponge : DuplexSponge U C) (arr : Array U) :
    OracleComp (forwardPermutationOracle C) (DuplexSponge U C √ó Array U) := do
  if hEmpty : arr.isEmpty then
    return (sponge, #[])
  else
    
    let sponge1 : DuplexSponge U C := { sponge with absorbPos := 0 }
    
    
    
    let ‚ü®sponge2, h‚ü© ‚Üê
      if hFull : sponge1.squeezePos = SpongeSize.R then do
        let permutedState ‚Üê query (spec := forwardPermutationOracle _) () sponge1.state
        let sponge2 : DuplexSponge U C := { sponge1 with state := permutedState, squeezePos := 0 }
        have : sponge2.squeezePos < SpongeSize.R := by admit /- proof elided -/

List.Vector.snoc in Mathlib.Data.Vector.Snoc

@[inline, specialize, simp]
def oracleReduction : OracleReduction oSpec
    Statement OStatement Witness Statement OStatement Witness !p[] := OracleReduction.id

Fin.foldl in Init.Data.Fin.Fold

noncomputable def Bstar (x : ‚Ñù) : ‚Ñù := x.sqrt

HomogeneousPow in Init.Prelude

abbrev PermuteDir := Unit ‚äï Unit

def take_snoc_oracle (i : Fin ‚Ñì)
    (oStmtIn : (j : Fin (toOutCodewordsCount ‚Ñì œë i.castSucc)) ‚Üí
      OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j)
    (newOracleFn : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ) :
    (j : Fin (toOutCodewordsCount ‚Ñì œë i.castSucc)) ‚Üí 
      OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j
    := fun j => snoc_oracle ùîΩq Œ≤ oStmtIn newOracleFn ‚ü®j, by admit /- proof elided -/
    ‚ü©

noncomputable instance {v : Œπ ‚Üí F} {s : AffineSubspace F (Œπ ‚Üí F)} [Fintype s] :
    Fintype (v +·µ• s) := Fintype.ofFinite ‚Ü•(v +·µ• s)

instance : ‚àÄ i, VCVCompatible (Challenge !p[] i) :=
  fun ‚ü®i, h‚ü© =>
    (Fin.elim0 i : (h' : !p[].dir i = .V_to_P) ‚Üí VCVCompatible (!p[].Challenge ‚ü®i, h'‚ü©)) h

@[simp]
def ùïè (k : ‚Ñï) : BTField (k+1) := Z (k+1)

instance : Fact (Nat.Prime scalarFieldSize) := ‚ü®ScalarField_is_prime‚ü©

@[ext]
structure Reduction {Œπ : Type} (oSpec : OracleSpec Œπ)
    (StmtIn WitIn StmtOut WitOut : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n) where
  prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec
  verifier : Verifier oSpec StmtIn StmtOut pSpec

Preorder in Mathlib.Order.Defs.PartialOrder

def finToBinaryCoeffs (i : Fin r) (idx : Fin (2 ^ (‚Ñì + R_rate - i.val))) :
  Fin (‚Ñì + R_rate - i.val) ‚Üí ùîΩq := fun j =>
    if (Nat.getBit (k:=j) (n:=idx)) = 1 then (1 : ùîΩq) else (0 : ùîΩq)

Set.finrank in Mathlib.LinearAlgebra.Dimension.Constructions

def findIdxRev?_def {cond} {as : Array Œ±} {k : Fin as.size} :
  findIdxRev? cond as = some k ‚Üí cond as[k] :=

def Verifier.KnowledgeStateFunction.id {rel : Set (Statement √ó Witness)} :
    (Verifier.id : Verifier oSpec Statement _ _).KnowledgeStateFunction init impl rel rel
      (Extractor.RoundByRound.id) where
  toFun | ‚ü®0, _‚ü© => fun stmtIn _ witIn => (stmtIn, witIn) ‚àà rel
  toFun_empty := fun _ => by admit /- proof elided -/

protected def OracleProver.id :
    OracleProver oSpec Statement OStatement Witness Statement OStatement Witness !p[] :=
  Prover.id

instance : HListString (HList []) where
  toString
  | HList.nil => ""

RingHom.comp in Mathlib.Algebra.Ring.Hom.Defs

@[elab_as_elim]
def dconcat {n : ‚Ñï} {motive : Fin (n + 1) ‚Üí Sort u}
    (u : (i : Fin n) ‚Üí motive i.castSucc) (a : motive (last n)) (i : Fin (n + 1)) : motive i :=
  match n with
  | 0 => match i with | 0 => a
  | _ + 1 => dcons (u 0) (dconcat (fun i => u (Fin.succ i)) a) i

Fin.natAdd in Init.Data.Fin.Basic

IO.println in Init.System.IO

def leftpad (m‚ÇÇ n‚ÇÇ : ‚Ñï) (a : Œ±) {m‚ÇÅ n‚ÇÅ : ‚Ñï} (M : Matrix (Fin m‚ÇÅ) (Fin n‚ÇÅ) Œ±) :
    Matrix (Fin m‚ÇÇ) (Fin n‚ÇÇ) Œ± :=
  Fin.leftpad m‚ÇÇ (fun _ => a) (Fin.leftpad n‚ÇÇ a ‚àò M)

instance {Œ± : Type} [Sampleable Œ±] : DecidableEq Œ± := inferInstance

@[reducible]
def foldCommitOracleReduction (i : Fin ‚Ñì)
    (hCR : isCommitmentRound ‚Ñì œë i) :
  OracleReduction []‚Çí
    (StmtIn := Statement (L := L) Context i.castSucc)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) i.castSucc)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) i.succ)
    (pSpec := pSpecFoldCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) :=
  OracleReduction.append (oSpec:=[]‚Çí)
    (pSpec‚ÇÅ := pSpecFold (L:=L))
    (pSpec‚ÇÇ := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)
    (R‚ÇÅ := foldOracleReduction ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) i)
    (R‚ÇÇ := commitOracleReduction ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hCR)

inductive InternalData (Œ± : Type) : Skeleton ‚Üí Type
  | leaf : InternalData Œ± Skeleton.leaf
  | internal {left right} (value : Œ±)
      (leftData : InternalData Œ± left)
      (rightData : InternalData Œ± right) : InternalData Œ± (Skeleton.internal left right)
  deriving Repr

def computableNTTStage [Fact (LinearIndependent ùîΩq Œ≤)]
  (i : Fin ‚Ñì) (b : Fin (2 ^ (‚Ñì + R_rate)) ‚Üí L) : Fin (2^(‚Ñì + R_rate)) ‚Üí L :=
  have h_2_pow_i_lt_2_pow_‚Ñì_add_R_rate: 2^i.val < 2^(‚Ñì + R_rate) := by admit /- proof elided -/

def FullData.rightSubtree {Œ± : Type} {s_left s_right : Skeleton}
    (tree : FullData Œ± (Skeleton.internal s_left s_right)) :
    FullData Œ± s_right :=
  match tree with
  | FullData.internal _ _left right =>
    right

class AlgebraTower {Œπ : Type*} [Preorder Œπ] (AT : Œπ ‚Üí Type*)
  [‚àÄ i, CommSemiring (AT i)] where
   
  protected algebraMap : ‚àÄ i j, (h : i ‚â§ j) ‚Üí (AT i ‚Üí+* AT j)
   
  commutes' : ‚àÄ (i j : Œπ) (h : i ‚â§ j) (r : AT i) (x : AT j),
    (algebraMap i j h r) * x = x * (algebraMap i j h r)
  coherence': ‚àÄ (i j k : Œπ) (h1 : i ‚â§ j) (h2 : j ‚â§ k),
    algebraMap i k (h1.trans h2) =
      (algebraMap j k h2).comp (algebraMap i j h1)

instance {Œ± : Type*} [Fintype Œ±] : Dist (PMF Œ±) where
  dist := fun a b => ‚àë x, abs ((a x).toReal - (b x).toReal)

noncomputable def vanishingPoly (S : Finset F) : Polynomial F :=
  ‚àè s ‚àà S, (Polynomial.X - Polynomial.C s)

instance : Unique (ChallengesUpTo 0 pSpec) where
  default := fun ‚ü®i, _‚ü© => Fin.elim0 i
  uniq := fun T => by admit /- proof elided -/

def CEmbedding : R ‚Ü™ MvPolynomial œÉ R := ‚ü®C, C_injective œÉ R‚ü©

@[reducible, simp]
def relOut : Set (Statement √ó Unit) := Set.univ

def whirRelation
    {F : Type} [Field F] [Fintype F] [DecidableEq F]
    {Œπ : Type} [Fintype Œπ] [Nonempty Œπ]
    (varCount : ‚Ñï) (œÜ : Œπ ‚Ü™ F) [Smooth œÜ] (err : ‚Ñù)
    : Set ((Unit √ó ‚àÄ i, (OracleStatement Œπ F i)) √ó Unit) :=
  { ‚ü®‚ü®_, oracle‚ü©, _‚ü© | Œ¥·µ£(oracle (), smoothCode œÜ varCount) ‚â§ err }

@[simp]
instance BTFieldIsField (k : ‚Ñï) : Field (BTField k) := (BinaryTowerAux k).2.instField

Equiv.ofBijective in Mathlib.Logic.Equiv.Defs

AffineSubspace in Mathlib.LinearAlgebra.AffineSpace.AffineSubspace.Defs

List.Vector.ofFn in Mathlib.Data.Vector.Defs

def perfectCorrectness (scheme : Scheme oSpec Data Randomness Commitment pSpec) : Prop :=
  correctness scheme 0

def finIdxOfIfTrue [BEq Œ±] [LawfulBEq Œ±] (a : Œ±) (l : List Œ±) (h : a ‚àà l) : Fin l.length :=
  ‚ü®List.idxOf' a l, by admit /- proof elided -/
  ‚ü©

noncomputable def oddRefinement (i : Fin (‚Ñì))
    (coeffs : Fin (2 ^ (‚Ñì - i)) ‚Üí L) : L[X] :=
  ‚àë (‚ü®j, hj‚ü©: Fin (2^(‚Ñì-i-1))), C (coeffs ‚ü®j*2+1, by admit /- proof elided -/
  ‚ü©) * (intermediateNovelBasisX ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i+1, by admit /- proof elided -/
  ‚ü© ‚ü®j, hj‚ü©)

instance [Repr Œ±] (Œ±s : List Type) [HListRepr (HList Œ±s)] : HListRepr (HList (Œ± :: Œ±s)) where
  repr
  | HList.cons x xs =>
    match xs with
    | HList.nil => reprPrec x 0
    | HList.cons _ _ => reprPrec x 0 ++ ", " ++ HListRepr.repr xs

def completeness
    (relIn : Set ((StmtIn √ó ‚àÄ i, OStmtIn i) √ó WitIn))
    (relOut : Set ((StmtOut √ó ‚àÄ i, OStmtOut i) √ó WitOut))
    (oracleReduction : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec)
    (completenessError : ‚Ñù‚â•0) : Prop :=
  Reduction.completeness init impl relIn relOut oracleReduction.toReduction completenessError

def somePairs : HList' (fun x => x √ó x) someTypes :=
  HList'.cons (1, 1) (HList'.cons ("good", "bad") (HList'.cons (5, 3) HList'.nil))

Function.Surjective in Init.Data.Function

Module.Basis.span in Mathlib.LinearAlgebra.Basis.Basic

Matrix.of in Mathlib.LinearAlgebra.Matrix.Defs

def rightpadPowerOfTwo (unit : Œ±) (a : Array Œ±) : Array Œ± :=
  a.rightpad (2 ^ (Nat.clog 2 a.size)) unit

def oracleReduction.firstChallenge :
    OracleReduction oSpec
      (Statement.AfterFirstMessage R pp) (OracleStatement.AfterFirstMessage R pp) (Witness R pp)
      (Statement.AfterFirstChallenge R pp) (OracleStatement.AfterFirstChallenge R pp) Unit
      ‚ü®!v[.V_to_P], !v[FirstChallenge R pp]‚ü© :=
  sorry

def take (j : Fin (n + 1)) (challenges : Challenges pSpec) : ChallengesUpTo j pSpec :=

structure Opening where
  opening : Proof oSpec (Commitment √ó O.Query √ó O.Response) (Data √ó Randomness) pSpec

class Permute (Œ± : Type*) where
  permute : Œ± ‚Üí Œ±

instance (priority := high) : MonadLiftT (OracleComp []‚Çí) (OracleComp spec) where
  monadLift := OracleComp.construct pure (fun a => by admit /- proof elided -/
  ) failure

def OracleSpec.FunctionType (spec : OracleSpec Œπ) := (i : Œπ) ‚Üí spec.domain i ‚Üí spec.range i

Polynomial.comp in Mathlib.Algebra.Polynomial.Eval.Defs

MvPolynomial.eval‚ÇÇ in Mathlib.Algebra.MvPolynomial.Eval

def erase_even (s : Finset ‚Ñï) : Finset ‚Ñï := s.filter Odd

instance [Zero T] [DecidableEq T] [ToNat T] : Div (Cayley T) where
  div := div

instance {n : ‚Ñï} {Œ± : Fin n ‚Üí Type*} : SliceGE ((i : Fin n) ‚Üí Œ± i) ‚Ñï
    (fun _ start => start ‚â§ n)
    (fun _ start h =>
      (i : Fin (n - start)) ‚Üí Œ± (Fin.cast (Nat.sub_add_cancel h) (i.addNat start)))
    where
  sliceGE := fun v start h => drop start h v

instance : SMul ‚Ñï (UniPoly R) := ‚ü®nsmul‚ü©

instance : Sub (UniPoly R) := ‚ü®UniPoly.sub‚ü©

QueryImpl.impl in VCVio.OracleComp.SimSemantics.SimulateQ

noncomputable def minWtCodewords [Semiring F] (LC : LinearCode Œπ F) : ‚Ñï :=
  sInf {w | ‚àÉ c ‚àà LC, c ‚â† 0 ‚àß Code.wt c = w}

def OracleVerifier.append (V‚ÇÅ : OracleVerifier oSpec Stmt‚ÇÅ OStmt‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : OracleVerifier oSpec Stmt‚ÇÇ OStmt‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ pSpec‚ÇÇ) :
      OracleVerifier oSpec Stmt‚ÇÅ OStmt‚ÇÅ Stmt‚ÇÉ OStmt‚ÇÉ (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ) where
  verify := fun stmt challenges => by admit /- proof elided -/
|
    
    .trans (.sumMap V‚ÇÅ.embed (.refl _)) <|
    
    .trans (Equiv.sumAssoc _ _ _).toEmbedding <|
    
    .sumMap (.refl _) MessageIdx.sumEquiv.toEmbedding

  hEq := fun i => by admit /- proof elided -/

@[reducible]
def pSpecCommit (i : Fin ‚Ñì) : ProtocolSpec 1 :=
  ‚ü®![Direction.P_to_V],
   ![OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i.val + 1, by admit /- proof elided -/
   ‚ü©]‚ü©

noncomputable def œÄ_z {H : F[X][Y]} (z : F) (root : rationalRoot (H_tilde' H) z) : ùí™ H ‚Üí+* F :=
  Ideal.Quotient.lift (Ideal.span {H_tilde' H}) (œÄ_z_lift z root) sorry

Algebra.TensorProduct.rightAlgebra in Mathlib.RingTheory.TensorProduct.Basic

noncomputable def additiveNTT (a : Fin (2 ^ ‚Ñì) ‚Üí L) : Fin (2^(‚Ñì + R_rate)) ‚Üí L :=
  let b: Fin (2^(‚Ñì + R_rate)) ‚Üí L := tileCoeffs a 
  Fin.foldl (n:=‚Ñì) (f:= fun current_b i  =>
    NTTStage ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®‚Ñì - 1 - i, by admit /- proof elided -/
    ‚ü©) current_b
  ) (init:=b)

structure StatementRound (i : Fin (n + 1)) where
  
  target : R
  
  challenges : Fin i ‚Üí R

noncomputable def NTTStage (i : Fin ‚Ñì) (b : Fin (2 ^ (‚Ñì + R_rate)) ‚Üí L) :
    Fin (2^(‚Ñì + R_rate)) ‚Üí L :=
  have h_2_pow_i_lt_2_pow_‚Ñì_add_R_rate: 2^i.val < 2^(‚Ñì + R_rate) := by admit /- proof elided -/

@[inline, reducible]
def lift : OuterStmtIn √ó OuterWitIn ‚Üí InnerStmtOut √ó InnerWitOut ‚Üí OuterStmtOut √ó OuterWitOut :=
  fun ctxIn ctxOut =>
    ‚ü®lens.stmt.toFunB ctxIn.1 ctxOut.1, lens.wit.toFunB ctxIn ctxOut‚ü©

IO.FS.readFile in Init.System.IO

CommMonoid in Mathlib.Algebra.Group.Defs

@[simp]
def innerRelIn_Test : Set (InnerStmtIn_Test √ó Unit) :=
  setOf (fun ‚ü®‚ü®f, t‚ü©, _‚ü© => ‚àë x ‚àà {0, 1}, f.eval x = t)

@[simp]
abbrev Statement.AfterSendEvalClaim : Type := Statement.AfterFirstSumcheck R pp

structure BerlekampWelchCondition (e k : ‚Ñï) (œâs f : Fin n ‚Üí F) (E Q : Polynomial F) : Prop where
  cond: ‚àÄ i : Fin n, Q.eval (œâs i) = (f i) * E.eval (œâs i)
  E_natDegree : E.natDegree = e
  E_leadingCoeff : E.coeff e = 1
  Q_natDegree : Q.natDegree ‚â§ e + k - 1

Function.Embedding in Mathlib.Logic.Embedding.Basic

@[reducible, simp]
def OStmtOut : Unit ‚Üí Type := fun _ => R‚¶É‚â§ deg‚¶Ñ[X]

@[inline, specialize, simp]
def oracleVerifier : OracleVerifier oSpec Statement OStatement Statement OStatement !p[] :=
  OracleVerifier.id

Nat.pow in Init.Prelude

@[reducible]
def index (op : MemoryWrite Œπ Œ±) := op.1

instance {k : ‚Ñï} : NeZero (Z k) := (BinaryTowerAux k).snd.specialElementNeZero

def ofMessagesChallenges (messages : Messages pSpec) (challenges : Challenges pSpec) :
    FullTranscript pSpec :=

HSMul.hSMul in Init.Prelude

def rationalRoot (H : F[X][Y]) (z : F) : Type :=
  {t_z : F // evalEval z t_z H = 0}

@[reducible]
def mk {R : Type*} (coeffs : Array R) : UniPoly R := coeffs

IsCyclic in Mathlib.Algebra.Group.Defs

def dropLastWhile (p : Œ± ‚Üí Bool) (l : List Œ±) : List Œ± :=
  (l.reverse.dropWhile p).reverse

Algebra.TensorProduct.instAlgebra in Mathlib.RingTheory.TensorProduct.Basic

Fintype.piFinset in Mathlib.Data.Fintype.Pi

noncomputable def ofMvPolynomialAlgHom : MvPolynomial œÉ R ‚Üí‚Çê[R] P := MvPolynomial.aeval X

def liftRightNil {Œπ : Type} {œÉ : Type} (oSpec : OracleSpec Œπ) :
    SimOracle.Stateful (oSpec ++‚Çí []‚Çí) oSpec œÉ where impl
  | query (.inl i) q => fun s ‚Ü¶ do return ‚ü®‚Üê query i q, s‚ü©

class SpongeUnit (Œ± : Type) extends Zero Œ±, Serde Œ± ByteArray, HasSize Œ± UInt8 where
   
  write (stream : IO.FS.Stream) : Array Œ± ‚Üí IO Unit :=
    Array.foldlM (fun _ a => IO.FS.Stream.write stream (serialize a)) ()
   
  read (stream : IO.FS.Stream) : Array Œ± ‚Üí IO (Array Œ±) :=
    fun arr => do
      let bytes ‚Üê arr.mapM (fun _ => IO.FS.Stream.read stream (USize.ofNat (HasSize.size Œ± UInt8)))
      let units := bytes.mapM deserialize
      if h : units.isSome
        then return units.get h
        else IO.throwServerError "Failed to read units"

class Context.Lens.IsComplete {OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut : Type}
    {OuterWitIn OuterWitOut InnerWitIn InnerWitOut : Type}
    (outerRelIn : Set (OuterStmtIn √ó OuterWitIn))
    (innerRelIn : Set (InnerStmtIn √ó InnerWitIn))
    (outerRelOut : Set (OuterStmtOut √ó OuterWitOut))
    (innerRelOut : Set (InnerStmtOut √ó InnerWitOut))
    (compat : (OuterStmtIn √ó OuterWitIn) ‚Üí (InnerStmtOut √ó InnerWitOut) ‚Üí Prop)
    (lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut) where

  proj_complete : ‚àÄ stmtIn witIn,
    (stmtIn, witIn) ‚àà outerRelIn ‚Üí
    (lens.stmt.proj stmtIn, lens.wit.proj (stmtIn, witIn)) ‚àà innerRelIn

  lift_complete : ‚àÄ outerStmtIn outerWitIn innerStmtOut innerWitOut,
    compat (outerStmtIn, outerWitIn) (innerStmtOut, innerWitOut) ‚Üí
    (outerStmtIn, outerWitIn) ‚àà outerRelIn ‚Üí
    (innerStmtOut, innerWitOut) ‚àà innerRelOut ‚Üí
    (lens.stmt.lift outerStmtIn innerStmtOut,
    lens.wit.lift (outerStmtIn, outerWitIn) (innerStmtOut, innerWitOut)) ‚àà outerRelOut

instance {relIn : Set (StmtIn √ó WitIn)} {relOut : Set (StmtOut √ó WitOut)}
    {verifier : Verifier oSpec StmtIn StmtOut pSpec} {WitMid : Fin (n + 1) ‚Üí Type}
    {extractor : Extractor.RoundByRound oSpec StmtIn WitIn WitOut pSpec WitMid} :
    CoeFun (verifier.KnowledgeStateFunction init impl relIn relOut extractor)
    (fun _ => (m : Fin (n + 1)) ‚Üí StmtIn ‚Üí Transcript m pSpec ‚Üí WitMid m ‚Üí Prop) :=
      ‚ü®fun f => f.toFun‚ü©

class HasPred (T : Type u) where
   
  pred' : T ‚Üí T

noncomputable def toConcreteBTF0 : GF(2) ‚Üí ConcreteBTField 0 :=
  fun x => if decide (x = 0) then zero else one 

def Reduction.append (R‚ÇÅ : Reduction oSpec Stmt‚ÇÅ Wit‚ÇÅ Stmt‚ÇÇ Wit‚ÇÇ pSpec‚ÇÅ)
    (R‚ÇÇ : Reduction oSpec Stmt‚ÇÇ Wit‚ÇÇ Stmt‚ÇÉ Wit‚ÇÉ pSpec‚ÇÇ) :
      Reduction oSpec Stmt‚ÇÅ Wit‚ÇÅ Stmt‚ÇÉ Wit‚ÇÉ (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ) where
  prover := Prover.append R‚ÇÅ.prover R‚ÇÇ.prover
  verifier := Verifier.append R‚ÇÅ.verifier R‚ÇÇ.verifier

instance Vector.instFintype {Œ± : Type*} {n : ‚Ñï} [VCVCompatible Œ±] : Fintype (Vector Œ± n) :=
  Fintype.ofEquiv _ (Equiv.rootVectorEquivFin).symm

noncomputable def foldOracleReduction :
  OracleReduction []‚Çí
    (Statement F i.castSucc) (OracleStatement D x s i.castSucc) (Witness F s d i.castSucc.castSucc)
    (Statement F i.succ) (OracleStatement D x s i.succ) (Witness F s d i.succ.castSucc)
    (pSpec D x s i) where
  prover := foldProver D x s d i
  verifier := foldVerifier D x s i

def AlgebraTowerEquiv.toAlgEquivOverLeft (e : AlgebraTowerEquiv A B) (i j : Œπ) (h : i ‚â§ j) :
  letI : Algebra (A i) (A j) :=

@[reducible, inline, specialize]
def messages (transcript : FullTranscript pSpec) (i : MessageIdx pSpec) :=
  transcript i.val

noncomputable def definingPoly {F : Type*} [instField : Field F] (s : F)
  := X ^ 2 + C s * X + 1

@[reducible]
def baseFieldSize : Nat :=
  21888242871839275222246405745257275088696311157297823662689037894645226208583

Polynomial.modByMonic in Mathlib.Algebra.Polynomial.Div

def mul (m n : ChurchNat Œ±) : ChurchNat Œ± := fun f => n (m f)

@[reducible, simp]
def soundness
    (langIn : Set (Statement √ó ‚àÄ i, OStatement i))
    (verifier : OracleVerifier oSpec Statement OStatement Bool (fun _ : Empty => Unit) pSpec)
    (soundnessError : ‚Ñù‚â•0) : Prop :=
  verifier.toVerifier.soundness init impl langIn acceptRejectOracleRel.language soundnessError

def relation : Set (M √ó M √ó List (MemoryOp Œπ Œ±)) :=
  { ‚ü®startMem, finalMem, ops‚ü© | processMemoryOps ops startMem = some finalMem }

UInt32.ofFin in Init.Data.UInt.Basic

noncomputable def commitOracleProver (i : Fin ‚Ñì) :
  OracleProver (oSpec := []‚Çí)
    
    (StmtIn := Statement (L := L) Context i.succ)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) i.succ)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) i.succ)
    (pSpec := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) where

  PrvState := commitPrvState ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i

  input := fun ‚ü®‚ü®stmt, oStmt‚ü©, wit‚ü© => (stmt, oStmt, wit)

  sendMessage 
  | ‚ü®0, _‚ü© => fun inputPrvState => by admit /- proof elided -/
  | ‚ü®0, h‚ü© => nomatch h 

  output := fun ‚ü®stmt, oStmt, wit‚ü© => by admit /- proof elided -/

ByteArray in Init.Prelude

noncomputable def Œ¥_Œµ_proximityGap {Œ± : Type} [DecidableEq Œ±] [Nonempty Œ±]
  (P : Finset (Œπ ‚Üí Œ±)) (C : Set (Finset (Œπ ‚Üí Œ±))) (Œ¥ Œµ : ‚Ñù‚â•0) : Prop :=
  ‚àÄ S ‚àà C, ‚àÄ [Nonempty S],
  Xor'
  ( Pr_{let x ‚Üê $·µñ S}[Code.relHammingDistToCode x.1 P ‚â§ Œ¥] = 1 )
  ( Pr_{let x ‚Üê $·µñ S}[Code.relHammingDistToCode x.1 P ‚â§ Œ¥] ‚â§ Œµ )

instance : ‚àÄ j, OracleInterface ((pSpecLastBlock (L:=L) (œë:=œë)).Message j) :=
  instOracleInterfaceMessageSeqCompose

@[inline, specialize]
def eval (x : R) (p : UniPoly R) : R :=
  p.eval‚ÇÇ (RingHom.id R) x

@[reducible]
def pBits : Nat := 31

def relDistCodewords [DecidableEq F] (U V : Matrix Œ∫ Œπ F) : ‚Ñù :=
  (Matrix.neqCols U V).card / Fintype.card Œπ

instance instOracleInterfaceMessagePSpec : ‚àÄ i, OracleInterface ((pSpec R deg).Message i) :=
  instOracleInterfaceMessageAppend

instance : Field ScalarField := ZMod.instField SCALAR_FIELD_CARD

instance {s} : LawfulFunctor (fun Œ± => LeafData Œ± s) :=

Unique in Mathlib.Logic.Unique

BitVec.toNat in Init.Prelude

Field in Mathlib.Algebra.Field.Defs

def OracleVerifier.liftContext
    (lens : OracleStatement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                              OuterOStmtIn OuterOStmtOut InnerOStmtIn InnerOStmtOut)
    (V : OracleVerifier oSpec InnerStmtIn InnerOStmtIn InnerStmtOut InnerOStmtOut pSpec) :
      OracleVerifier oSpec OuterStmtIn OuterOStmtIn OuterStmtOut OuterOStmtOut pSpec where
  verify := fun outerStmtIn transcript => sorry
  embed := by admit /- proof elided -/

inductive SkeletonInternalIndex : Skeleton ‚Üí Type
  | ofInternal {left right} : SkeletonInternalIndex (Skeleton.internal left right)
  | ofLeft {left right : Skeleton} (idxLeft : SkeletonInternalIndex left) :
      SkeletonInternalIndex (Skeleton.internal left right)
  | ofRight {left right : Skeleton} (idxRight : SkeletonInternalIndex right) :
      SkeletonInternalIndex (Skeleton.internal left right)

def relayKnowledgeError (m : pSpecRelay.ChallengeIdx) : ‚Ñù‚â•0 :=
  match m with
  | ‚ü®j, _‚ü© => j.elim0

def getUElements (i : Fin r) : List L :=
  (List.finRange (2^i.val)).map fun k =>
    (Finset.univ : Finset (Fin i)).sum fun j =>
      if Nat.getBit (n := k.val) (k := j.val) == 1 then
        Œ≤ ‚ü®j.val, by admit /- proof elided -/
        ‚ü©
      else 0

def hli_level_diff_0 (l : ‚Ñï) :
  letI instAlgebra:= ConcreteBTFieldAlgebra (l:=l) (r:=l) (h_le:=by omega)
  @Basis (Fin 1) (ConcreteBTField l) (ConcreteBTField l) _ _ instAlgebra.toModule :=

instance [Zero T] [ToNat T] : ToNat (Cayley T) where
  toNat := ToNat.toNat ‚àò toT

@[inline, specialize]
def Prover.processRoundDSFS [‚àÄ i, VCVCompatible (pSpec.Challenge i)] (j : Fin n)
    (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec)
    (currentResult : OracleComp (oSpec ++‚Çí duplexSpongeChallengeOracle StmtIn U)
      (pSpec.MessagesUpTo j.castSucc √ó
        CanonicalDuplexSponge U √ó prover.PrvState j.castSucc)) :
      OracleComp (oSpec ++‚Çí duplexSpongeChallengeOracle StmtIn U)
        (pSpec.MessagesUpTo j.succ √ó
          CanonicalDuplexSponge U √ó prover.PrvState j.succ) := do
  let ‚ü®messages, sponge, state‚ü© ‚Üê currentResult
  match hDir : pSpec.dir j with
  | .V_to_P => do
    let f ‚Üê prover.receiveChallenge ‚ü®j, hDir‚ü© state
    let (challenge, newSponge) ‚Üê
      liftM (DuplexSponge.squeeze sponge (challengeSize ‚ü®j, hDir‚ü©))
    
    let deserializedChallenge : pSpec.Challenge ‚ü®j, hDir‚ü© := Deserialize.deserialize challenge
    return ‚ü®messages.extend hDir, newSponge, f deserializedChallenge‚ü©
  | .P_to_V => do
    let ‚ü®msg, newState‚ü© ‚Üê prover.sendMessage ‚ü®j, hDir‚ü© state
    let serializedMessage : Vector U (messageSize ‚ü®j, hDir‚ü©) := Serialize.serialize msg
    let newSponge ‚Üê liftM (DuplexSponge.absorb sponge serializedMessage.toList)
    return ‚ü®messages.concat hDir msg, newSponge, newState‚ü©

@[inline] def le [Zero T] [ToNat T] (a b : Cayley T) : Prop :=
  (‚Üëa : Nat) ‚â§ (‚Üëb : Nat)

noncomputable def proximityCondition
   (f : par‚Ñì ‚Üí Œπ ‚Üí F) (Œ¥ : ‚Ñù) (r : par‚Ñì ‚Üí F) (C : LinearCode Œπ F) : Prop :=
  Œ¥·µ£( (fun x => ‚àë j : par‚Ñì, (r j) * f j x) , C ) ‚â§ (Œ¥ : ‚Ñù)

CanLift in Mathlib.Tactic.Lift

@[inline]
def zero [Zero R] : MlPolyEval R n := Vector.replicate (2 ^ n) 0

class VerifierFirst (pSpec : ProtocolSpec n) [NeZero n] where
  verifier_first' : pSpec.dir 0 = .V_to_P

def indexPowT (S : Finset Œπ) (œÜ : Œπ ‚Ü™ F) (k : ‚Ñï) := { y : F // ‚àÉ x ‚àà S, y = (œÜ x) ^ (2^k) }

instance (k : ‚Ñï) : LT (ConcreteBTField k) where
  lt := fun x y => by admit /- proof elided -/

Equiv.piCongr in Mathlib.Logic.Equiv.Basic

def commitKnowledgeError {i : Fin ‚Ñì}
    (m : (pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i).ChallengeIdx) : ‚Ñù‚â•0 :=
  match m with
  | ‚ü®j, hj‚ü© => by admit /- proof elided -/

def eval (x : Fin numWires ‚Üí ùì°) (g : Gate ùì° numWires) : ùì° :=
  g.qL * x g.a + g.qR * x g.b + g.qO * x g.c + g.qM * (x g.a * x g.b) + g.qC

Units.val in Mathlib.Algebra.Group.Units.Defs

instance : SliceGE (ProtocolSpec n) ‚Ñï
    (fun _ start => start ‚â§ n)
    (fun _ start _ => ProtocolSpec (n - start))
    where
  sliceGE := fun v start h => drop start h v

def regularElms (H : F[X][Y]) : Type :=
  {a : ùïÉ H // ‚àÉ b : ùí™ H, a = embeddingOfùí™IntoùïÉ _ b}

def domainEmb {i : ‚Ñï} : evalDomain D i ‚Ü™ F :=
  ‚ü®
    fun x => x.1.1,
    by admit /- proof elided -/
  ‚ü©

instance : Fact (Nat.Prime SCALAR_FIELD_CARD) := ‚ü®ScalarField_is_prime‚ü©

finProdFinEquiv in Mathlib.Logic.Equiv.Fin.Basic

IntCast in Init.Data.Int.Basic

inductive HList' {Œ± : Type v} (Œ≤ : Œ± ‚Üí Type u) : List Œ± ‚Üí Type (max u v)
  | nil  : HList' Œ≤ []
  | cons : Œ≤ i ‚Üí HList' Œ≤ is ‚Üí HList' Œ≤ (i :: is)

OneMemClass in Mathlib.Algebra.Group.Submonoid.Defs

class DCast‚ÇÉ (Œ± : Sort*) (Œ≤ : Œ± ‚Üí Sort*) (Œ≥ : (a : Œ±) ‚Üí Œ≤ a ‚Üí Sort*)
    (Œ¥ : (a : Œ±) ‚Üí (b : Œ≤ a) ‚Üí Œ≥ a b ‚Üí Sort*) [DCast Œ± Œ≤] [DCast‚ÇÇ Œ± Œ≤ Œ≥] where
  dcast‚ÇÉ : ‚àÄ {a a' : Œ±} {b : Œ≤ a} {b' : Œ≤ a'} {c : Œ≥ a b} {c' : Œ≥ a' b'},
    (ha : a = a') ‚Üí (hb : dcast ha b = b') ‚Üí (hc : dcast‚ÇÇ ha hb c = c') ‚Üí Œ¥ a b c ‚Üí Œ¥ a' b' c'
  dcast‚ÇÉ_id : ‚àÄ {a : Œ±} {b : Œ≤ a} {c : Œ≥ a b},
    dcast‚ÇÉ (Eq.refl a) dcast_eq dcast‚ÇÇ_eq = (id : Œ¥ a b c ‚Üí Œ¥ a b c)

def iterated_fold (i : Fin r) (steps : Fin (‚Ñì + 1)) (h_i_add_steps : i.val + steps < ‚Ñì + ùì°)
  (f : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := i) ‚Üí L) (r_challenges : Fin steps ‚Üí L) :
    sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate
      (‚ü®i + steps.val, Nat.lt_trans (m := ‚Ñì + ùì°) (h_i_add_steps) h_‚Ñì_add_R_rate‚ü©) ‚Üí L :=

noncomputable def queryOracleReduction :
  OracleReduction
    (oSpec := []‚Çí)
    (StmtIn := FinalSumcheckStatementOut (L:=L) (‚Ñì:=‚Ñì))
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (
    Fin.last ‚Ñì))
    (WitIn := Unit)
    (StmtOut := Bool)
    (OStmtOut := fun _ : Empty => Unit)
    (WitOut := Unit)
    (pSpec := pSpecQuery ùîΩq Œ≤ Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)) where
  prover := queryOracleProver ùîΩq Œ≤ (œë:=œë) Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
  verifier := queryOracleVerifier ùîΩq Œ≤ (œë:=œë) Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)

instance instDivConcreteBTF {k : ‚Ñï} : Div (ConcreteBTField k) where
  div a b := a * (concrete_inv b)

Fin.take in Mathlib.Data.Fin.Tuple.Take

Polynomial.rootMultiplicity in Mathlib.Algebra.Polynomial.Div

def finalize (ds : DomainSeparator U H) : Array Op :=
  let parts := ds.io.splitOn SEP_BYTE
  
  let parseDigits (cs : List Char) : Nat √ó List Char :=
    let rec go : Nat ‚Üí List Char ‚Üí Nat √ó List Char
    | acc, [] => (acc, [])
    | acc, c :: rest =>
      if c.isDigit then
        let d := (c.toNat - '0'.toNat)
        go (acc * 10 + d) rest
      else
        (acc, c :: rest)
    go 0 cs
  let parsePart (s : String) : Option Op :=
    match s.data with
    | [] => none
    | id :: rest =>
      let (n, _rest) := parseDigits rest
      match id with
      | 'A' => if n = 0 then none else some (Op.Absorb n)
      | 'S' => if n = 0 then none else some (Op.Squeeze n)
      | 'R' => some Op.Ratchet
      | 'H' => some Op.Hint
      | _ => none
  let opsList := (parts.drop 1).foldl (fun acc p =>
      match parsePart p with
      | some op => acc.push op
      | none => acc) (#[] : Array Op)
  
  let simplify (acc : Array Op) (op : Op) : Array Op :=
    match acc.back? with
    | some (Op.Absorb a) =>
        match op with
        | Op.Absorb b => acc.pop.push (Op.Absorb (a + b))
        | _ => acc.push op
    | some (Op.Squeeze a) =>
        match op with
        | Op.Squeeze b => acc.pop.push (Op.Squeeze (a + b))
        | _ => acc.push op
    | _ => acc.push op
  opsList.foldl simplify (#[] : Array Op)

def pad (sz‚ÇÅ sz‚ÇÇ : Size)
    (stmt : Statement R sz‚ÇÅ)
    (matrices : MatrixIdx ‚Üí Matrix (Fin sz‚ÇÅ.m) (Fin sz‚ÇÅ.n) R)
    (wit : Witness R sz‚ÇÅ) :
    Statement R sz‚ÇÇ √ó (MatrixIdx ‚Üí Matrix (Fin sz‚ÇÇ.m) (Fin sz‚ÇÇ.n) R) √ó Witness R sz‚ÇÇ :=
  (Fin.rightpad sz‚ÇÇ.n_x 0 stmt,
    fun idx => Matrix.rightpad sz‚ÇÇ.m sz‚ÇÇ.n 0 (matrices idx),
    Fin.rightpad sz‚ÇÇ.n_w 0 wit)

def buildMerkleTree_with_hash {s} (leaf_tree : LeafData Œ± s) (hashFn : Œ± ‚Üí Œ± ‚Üí Œ±) :
    (FullData Œ± s) :=
  match leaf_tree with
  | LeafData.leaf a => FullData.leaf a
  | LeafData.internal left right =>
    let leftTree := buildMerkleTree_with_hash left hashFn
    let rightTree := buildMerkleTree_with_hash right hashFn
    let rootHash := hashFn (leftTree.getRootValue) (rightTree.getRootValue)
    FullData.internal rootHash leftTree rightTree

def idxOf' [BEq Œ±] (a : Œ±) (l : List Œ±) : ‚Ñï := findIdx' (¬∑ == a) l

def computeInitialSumcheckPoly (t : MultilinearPoly L ‚Ñì)
    (m : MultilinearPoly L ‚Ñì) : MultiquadraticPoly L ‚Ñì :=
  ‚ü®m * t, by
    rw [MvPolynomial.mem_restrictDegree_iff_degreeOf_le]
    intro i
    have h_t_deg: degreeOf i t.val ‚â§ 1 :=
      degreeOf_le_iff.mpr fun term a ‚Ü¶ (t.property) a i
    have h_m_deg: degreeOf i m.val ‚â§ 1 :=
      degreeOf_le_iff.mpr fun term a ‚Ü¶ (m.property) a i
    calc
      _ ‚â§ (degreeOf i m.val) + (degreeOf i t.val) :=
        degreeOf_mul_le i m.val t.val
      _ ‚â§ 2 :=

def width (k : ‚Ñï) : ‚Ñï := 2 ^ k

instance : DecidableEq BTF‚ÇÉ := (inferInstance : DecidableEq (ConcreteBTField 3))

def pSpecSumcheckFold := (pSpecNonLastBlocks ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)) ++‚Çö
  (pSpecLastBlock (L:=L) (œë:=œë))

@[reducible, simp] def StmtIn := Unit

finSuccEquiv in Mathlib.Logic.Equiv.Fin.Basic

Eq.mp in Init.Core
</all_available_defs>

<all_available_lemmas>
Fin.mk_le_of_le_val in Init.Data.Fin.Lemmas
Fin.mk_lt_of_lt_val in Init.Data.Fin.Lemmas
Nat.lt_sub_of_add_lt in Init.Data.Nat.Basic
Nat.sub_add_cancel in Init.Data.Nat.Basic
Polynomial.ext in Mathlib.Algebra.Polynomial.Basic
Set.mem_Ico in Mathlib.Order.Interval.Set.Defs
Set.mem_image in Mathlib.Data.Set.Operations
Set.mem_range in Mathlib.Data.Set.Operations
Fin.lt_trans in Init.Data.Fin.Lemmas
Fin.zero_le in Init.Data.Fin.Lemmas
Nat.le_of_not_lt in Init.Data.Nat.Basic
Set.image_union in Mathlib.Data.Set.Image
Set.mem_union in Mathlib.Data.Set.Basic
Submodule.eq_bot_iff in Mathlib.Algebra.Module.Submodule.Lattice
Submodule.map_sup in Mathlib.Algebra.Module.Submodule.Map
Submodule.mem_map in Mathlib.Algebra.Module.Submodule.Map
Submodule.span_union in Mathlib.LinearAlgebra.Span.Defs
bot_sup_eq in Mathlib.Order.BoundedOrder.Lattice
true_and in Init.SimpLemmas

lemma X‚±º_zero_eq_one (‚Ñì : ‚Ñï) (h_‚Ñì : ‚Ñì ‚â§ r) :
  X‚±º ùîΩq Œ≤ ‚Ñì h_‚Ñì ‚ü®0, by exact Nat.two_pow_pos ‚Ñì‚ü© = 1

lemma normalizedW·µ¢_vanishing (i : Fin r) :
  ‚àÄ u ‚àà U ùîΩq Œ≤ i, (normalizedW ùîΩq Œ≤ i).eval u = 0

lemma W·µ¢_vanishing (i : Fin r) :
  ‚àÄ u ‚àà U ùîΩq Œ≤ i, (W ùîΩq Œ≤ i).eval u = 0

omit hF‚ÇÇ in
theorem normalizedW_is_additive (i : Fin r) :
  IsLinearMap ùîΩq (f := fun x ‚Ü¶ (normalizedW ùîΩq Œ≤ i).eval x)

theorem normalizedW_is_linear_map (i : Fin r) :
  IsLinearMap ùîΩq (f := fun inner_p ‚Ü¶ (normalizedW ùîΩq Œ≤ i).comp inner_p)

theorem W_linearity (i : Fin r)
    : IsLinearMap ùîΩq (f := fun inner_p ‚Ü¶ (W ùîΩq Œ≤ i).comp inner_p)

omit hF‚ÇÇ in
lemma inductive_linear_map_W (i : Fin r) (h_i_add_1 : i + 1 < r)
    (h_prev_linear_map : IsLinearMap ùîΩq (f := fun inner_p ‚Ü¶ (W ùîΩq Œ≤ i).comp inner_p))
    : IsLinearMap ùîΩq (f := fun inner_p ‚Ü¶ (W ùîΩq Œ≤ (i + 1)).comp inner_p)

omit h_Fq_char_prime hF‚ÇÇ in
lemma inductive_rec_form_W_comp (i : Fin r) (h_i_add_1 : i + 1 < r)
    (h_prev_linear_map : IsLinearMap (R := ùîΩq) (M := L[X]) (M‚ÇÇ := L[X])
      (f := fun inner_p ‚Ü¶ (W ùîΩq Œ≤ i).comp inner_p))
    : ‚àÄ p: L[X], (W ùîΩq Œ≤ (i + 1)).comp p =
      ((W ùîΩq Œ≤ i).comp p) ^ Fintype.card ùîΩq -
        C (eval (Œ≤ i) (W ùîΩq Œ≤ i)) ^ (Fintype.card ùîΩq - 1) * ((W ùîΩq Œ≤ i).comp p)

lemma W·µ¢_eval_Œ≤·µ¢_neq_zero
    (i : Fin r): (W ùîΩq Œ≤ i).eval (Œ≤ i) ‚â† 0

lemma Œ≤·µ¢_not_in_U·µ¢ (i : Fin r) :
    Œ≤ i ‚àâ U ùîΩq Œ≤ i

lemma W_prod_comp_decomposition
    (i : Fin r) (hi : i > 0) :
    (W ùîΩq Œ≤ i) = ‚àè c: ùîΩq, (W ùîΩq Œ≤ (i-1)).comp (X - C (c ‚Ä¢ Œ≤ (i-1)))

lemma W_splits (i : Fin r) : (W ùîΩq Œ≤ i).Splits (RingHom.id L)

omit h_Fq_char_prime hF‚ÇÇ in
lemma rootMultiplicity_prod_W_comp_X_sub_C
    (i : Fin r) (h_i_add_1 : i + 1 < r) (a : L) :
    rootMultiplicity a ((univ : Finset ùîΩq).prod (fun c => (W ùîΩq Œ≤ i).comp (X - C (c ‚Ä¢ Œ≤ i)))) =
    if a ‚àà (U ùîΩq Œ≤ (i+1) : Set L) then 1 else 0

omit [DecidableEq L] h_Fq_char_prime hF‚ÇÇ hŒ≤_lin_indep in
lemma Prod_W_comp_X_sub_C_ne_zero (i : Fin r) :
    (univ : Finset ùîΩq).prod (fun c => (W ùîΩq Œ≤ i).comp (X - C (c ‚Ä¢ Œ≤ i))) ‚â† 0

omit [DecidableEq L] [Fintype ùîΩq] hŒ≤_lin_indep in
lemma W_ne_zero (i : Fin r) : (W ùîΩq Œ≤ i) ‚â† 0

lemma roots_comp_X_sub_C (p : L[X]) (a : L) :
    (p.comp (X - C a)).roots = p.roots.map (fun r => r + a)

lemma rootMultiplicity_comp_X_sub_C (p : L[X]) (a x : L) :
    rootMultiplicity x (p.comp (X - C a)) = rootMultiplicity (x - a) p

omit [Fintype L] [DecidableEq L] in
lemma comp_X_sub_C_eq_zero_iff (p : L[X]) (a : L) :
  p.comp (X - C a) = 0 ‚Üî p = 0

lemma rootMultiplicity_W (i : Fin r) (a : L) :
    rootMultiplicity a (W ùîΩq Œ≤ i) = if a ‚àà (U ùîΩq Œ≤ i : Set L) then 1 else 0

lemma roots_W (i : Fin r) : -- converts root Multiset into (univ: U·µ¢.val.map)
  (W ùîΩq Œ≤ i).roots = (univ : Finset (U ùîΩq Œ≤ i)).val.map (fun u => u.val)

omit [Fintype L] [DecidableEq L] [Fintype ùîΩq] h_Fq_char_prime hŒ≤_lin_indep in
theorem root_U_lift_up (i : Fin r) (h_i_add_1 : i + 1 < r) (a : L) (x : ùîΩq) :
  a - x ‚Ä¢ Œ≤ i ‚àà (U ùîΩq Œ≤ i) ‚Üí a ‚àà (U ùîΩq Œ≤ (i+1))

omit [Fintype L] [DecidableEq L] [Fintype ùîΩq] h_Fq_char_prime in
theorem root_U_lift_down
  (i : Fin r) (h_i_add_1 : i + 1 < r) (a : L) :
  a ‚àà (U ùîΩq Œ≤ (i+1)) ‚Üí ‚àÉ! x: ùîΩq, a - x ‚Ä¢ Œ≤ i ‚àà (U ùîΩq Œ≤ i)

lemma W_monic (i : Fin r) : (W ùîΩq Œ≤ i).Monic

lemma comp_sub_C_of_linear_eval (p : L[X])
  (h_lin : IsLinearMap ùîΩq (f := fun inner_p ‚Ü¶ p.comp inner_p)) (a : L) :
    p.comp (X - C a) = p - C (eval a p)

theorem qMap_total_fiber_disjoint
  (i : Fin ‚Ñì) (steps : ‚Ñï) (h_i_add_steps : i + steps ‚â§ ‚Ñì)
  {y‚ÇÅ y‚ÇÇ : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i.val + steps, by omega‚ü©}
  (hy_ne : y‚ÇÅ ‚â† y‚ÇÇ) :
  Disjoint
    ((qMap_total_fiber ùîΩq Œ≤ (i := ‚ü®i, by omega‚ü©) (steps := steps)
      (h_i_add_steps := fin_‚Ñì_steps_lt_‚Ñì_add_R i steps h_i_add_steps) y‚ÇÅ '' Set.univ).toFinset)
    ((qMap_total_fiber ùîΩq Œ≤ (i := ‚ü®i, by omega‚ü©) (steps := steps)
      (h_i_add_steps := fin_‚Ñì_steps_lt_‚Ñì_add_R i steps h_i_add_steps) y‚ÇÇ '' Set.univ).toFinset)

Polynomial.degree_sum_le in Mathlib.Algebra.Polynomial.Degree.Definitions

theorem coeff_eq_coeff [LawfulBEq R] (p : UniPoly R) (i : ‚Ñï) :
  p.trim.coeff i = p.coeff i

theorem PrattCertificate'.out {p : ‚Ñï} (c : PrattCertificate' p) : p.Prime

theorem comp_x_square_coeff {f : Polynomial F} {n : ‚Ñï} :
  (f.comp (X * X)).coeff n = if Even n then f.coeff (n / 2) else 0

omit [NeZero œë] hdiv in
lemma toOutCodewordsCountOf0 : toOutCodewordsCount ‚Ñì œë 0 = 1

theorem happend_left_eq_hcons {Œ± : Fin 1 ‚Üí Sort u} {Œ≤ : Fin n ‚Üí Sort u}
    (a : (i : Fin 1) ‚Üí Œ± i) (v : (i : Fin n) ‚Üí Œ≤ i) :
    True

theorem fconcat_injective2 {Œ± : Fin n ‚Üí A} {Œ≤ : A} :
    Function.Injective2 (@fconcat A F n Œ± Œ≤)

@[csimp] lemma dfoldr_eq_dfoldr' : @dfoldr = @dfoldr'

theorem mobius_apply_zeta_apply_eq_id (n : ‚Ñï) [NeZero n] (r : Fin n) (l : Fin (r.val + 1))
    (v : Vector R (2 ^ n)) : lagrangeToMono_segment n r l (monoToLagrange_segment n r l v) = v

theorem computableAdditiveNTT_eq_additiveNTT (a : Fin (2 ^ ‚Ñì) ‚Üí L) :
  computableAdditiveNTT (ùîΩq := ùîΩq) (Œ≤ := Œ≤) (‚Ñì := ‚Ñì) (R_rate := R_rate)
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (a := a) =
  additiveNTT (ùîΩq := ùîΩq) (L := L) (Œ≤ := Œ≤) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (a := a)

@[grind _=_]
lemma weightedDegree_eq_natWeightedDegree {u v : ‚Ñï} :
  f ‚â† 0 ‚Üí weightedDegree f u v = natWeightedDegree f u v

lemma shift_left_def {s : Finset ‚Ñï} :
    shift_left s = s.filterMap
    (fun n => match n with
      | 0 => .none
      | n + 1 => .some n
      )
    (by aesop)

theorem tail_init_eq_init_tail (s : Fin (n + 2) ‚Üí‚ÇÄ M) : tail (init s) = init (tail s)

Nat.pos_of_neZero in Init.Data.Nat.Basic

@[simp]
lemma oddPart_coeff {f : Polynomial F} {n : ‚Ñï} :
    (oddPart f).coeff n = if Even n then f.coeff (n + 1) else 0

omit [Finite F] in
private lemma op_der_eq : Monoid.toMulAction FÀ£ = Units.mulAction'

@[simp]
lemma constantCode_eq_ofNat_zero_iff [Nonempty Œπ] :
  constantCode x Œπ = 0 ‚Üî x = 0

@[simp]
theorem take_append_left :
    (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).take m (Nat.le_add_right m n) = pSpec‚ÇÅ

@[simp, grind =]
theorem monomialXY_add {n m : ‚Ñï} {a b : F} :
  monomialXY n m (a + b) = monomialXY n m a + monomialXY n m b

protected lemma errors_are_roots_of_elocPolyF {i : Fin n} {œâs f : Fin n ‚Üí F}
  (h : f i ‚â† p.eval (œâs i)) : (ElocPolyF œâs f p).eval (œâs i) = 0

lemma getLowBits_succ {n: ‚Ñï} (numLowBits: ‚Ñï) :
    getLowBits (numLowBits + 1) n = getLowBits numLowBits n
    + (getBit numLowBits n) <<< numLowBits

theorem insertNth_ne_zero_of_right (h : s ‚â† 0) : insertNth p y s ‚â† 0

theorem LeafData.composeBuild_internal {Œ±} {s_left s_right : Skeleton}
    (left : LeafData Œ± s_left) (right : LeafData Œ± s_right)
    (compose : Œ± ‚Üí Œ± ‚Üí Œ±) :
    (LeafData.internal left right).composeBuild compose =
      FullData.internal
        (compose (left.composeBuild compose).getRootValue (right.composeBuild compose).getRootValue)
        (left.composeBuild compose)
        (right.composeBuild compose)

theorem cast_runToRound (j : Fin (n‚ÇÅ + 1)) (stmt : StmtIn) (wit : WitIn)
    (P : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec‚ÇÅ) :
    P.runToRound j stmt wit =
      cast (sorry) ((P.cast hn hSpec).runToRound (Fin.cast (congrArg (¬∑ + 1) hn) j) stmt wit)

lemma sub_middle_of_pow2_with_one_canceled {k : ‚Ñï} (h_k : 1 ‚â§ k) : 2 ^ k - 1 - 2 ^ (k - 1) + 1
  = 2 ^ (k - 1)

lemma genMatIsVandermonde [Fintype Œπ] [Field F] [DecidableEq F] [inst : NeZero m] {Œ± : Œπ ‚Ü™ F} :
  fromColGenMat (Vandermonde.nonsquare (Œπ' := m) Œ±) = ReedSolomon.code Œ± m

lemma take_eq_take : transcript‚ü¶:m‚üß = transcript.take m h

@[simp] theorem popWhile_nil_or_last_false (p : Œ± ‚Üí Bool) (as : Array Œ±)
    (h : (as.popWhile p).size > 0) : ¬¨ (p <| (as.popWhile p).getLast h)

lemma lin_shift_d [Field F] [Fintype F]
  (h_B : 2 ‚â§ B.card)
  :
  d B = d ({x - v | x ‚àà B} : Finset _)

@[simp]
lemma challengeOracleInterface_append_range_inl (j : pSpec‚ÇÅ.ChallengeIdx) :
    [(pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).Challenge]‚Çí.range (.inl j) = pSpec‚ÇÅ.Challenge j

theorem cast_idx {i : MessageIdx pSpec‚ÇÅ} :
    pSpec‚ÇÇ.Message (i.cast hn hSpec) = pSpec‚ÇÅ.Message i

@[simp]
theorem rtake_append_right (T : FullTranscript pSpec‚ÇÅ) (T' : FullTranscript pSpec‚ÇÇ) :
    (T ++‚Çú T').rtake n (Nat.le_add_left n m) =
      T'.cast rfl (by simp [ProtocolSpec.append])

theorem sum_zero_iff_eq_of_self_sum_zero {F : Type*} [AddGroup F]
  (h_self_sum_eq_zero : ‚àÄ (x : F), x + x = 0) : ‚àÄ (x y : F), x + y = 0 ‚Üî x = y

theorem ScalarField_is_prime : Nat.Prime scalarFieldSize

@[simp]
theorem seqCompose_succ_eq_append {m : ‚Ñï} {n : Fin (m + 1) ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)} :
    seqCompose pSpec = append (pSpec 0) (seqCompose (fun i => pSpec (Fin.succ i)))

theorem image_support_finSuccEquivNth {f : MvPolynomial (Fin (n + 1)) R} {i : ‚Ñï} :
    Finset.image (Finsupp.insertNth p i) (Polynomial.coeff ((finSuccEquivNth R p) f) i).support =
      f.support.filter fun m => m p = i

theorem vconcat_right_injective (v : Fin n ‚Üí Œ±) : Function.Injective (vconcat v)

Fin.ext in Init.Data.Fin.Lemmas

lemma cast_ConcreteBTField_eq (k m : ‚Ñï) (h_eq : k = m) :
  ConcreteBTField k = ConcreteBTField m

lemma deevenize_evenize {f : Polynomial F} :
    deevenize (evenize f) = f

theorem mem_support_finSuccEquivNth {f : MvPolynomial (Fin (n + 1)) R} {x} :
    x ‚àà (finSuccEquivNth R p f).support ‚Üî x ‚àà (fun m : Fin (n + 1) ‚Üí‚ÇÄ _ ‚Ü¶ m p) '' f.support

theorem liftContext_runWithLog
    {lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    {outerStmtIn : OuterStmtIn} {outerWitIn : OuterWitIn}
    {R : Reduction oSpec InnerStmtIn InnerWitIn InnerStmtOut InnerWitOut pSpec} :
      (R.liftContext lens).runWithLog outerStmtIn outerWitIn = do
        let ‚ü®‚ü®‚ü®fullTranscript, innerCtxOut‚ü©, verInnerStmtOut‚ü©, queryLog‚ü© ‚Üê
          R.runWithLog.uncurry (lens.proj (outerStmtIn, outerWitIn))
        return ‚ü®‚ü®‚ü®fullTranscript, lens.lift (outerStmtIn, outerWitIn) innerCtxOut‚ü©,
                lens.stmt.lift outerStmtIn verInnerStmtOut‚ü©, queryLog‚ü©

theorem vconcat_left_injective {n : ‚Ñï} (a : Œ±) :
    Function.Injective (fun v : Fin n ‚Üí Œ± => vconcat v a)

lemma linsolve_is_berlekamp_welch_solution
  (h_linsolve : linsolve (BerlekampWelchMatrix e k œâs f) (Rhs e œâs f) = some v)
  : IsBerlekampWelchSolution e k œâs f v

@[simp]
lemma evenPart_by_2 :
  2 * (evenPart f) = f + f.comp (-X)

theorem unique_linear_form_of_elements_in_adjoined_commring
    {R : Type*} [CommRing R] (f : R[X]) (hf_deg : f.natDegree = 2)
    (hf_monic : Monic f) (c1 : AdjoinRoot f) :
    ‚àÉ! p : R √ó R, c1 = (AdjoinRoot.of f) p.1 * root f + (AdjoinRoot.of f) p.2

@[simp]
theorem fcons‚ÇÇ_succ {Œ±‚ÇÅ : A} {Œ±‚ÇÇ : B} {Œ≤‚ÇÅ : Fin n ‚Üí A} {Œ≤‚ÇÇ : Fin n ‚Üí B}
    (a : F‚ÇÇ Œ±‚ÇÅ Œ±‚ÇÇ) (b : (i : Fin n) ‚Üí F‚ÇÇ (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) (i : Fin n) :
    fcons‚ÇÇ (F := F‚ÇÇ) a b i.succ =
      cast (by simp [Fin.vcons_succ]) (b i)

@[simp]
theorem Prover.runToRound_one_of_prover_first [ProverOnly pSpec] (stmt : StmtIn) (wit : WitIn)
    (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      prover.runToRound 1 stmt wit = (do
        let state := prover.input (stmt, wit)
        let ‚ü®msg, state‚ü© ‚Üê liftComp (prover.sendMessage ‚ü®0, by simp‚ü© state) _
        return (fun i => match i with | ‚ü®0, _‚ü© => msg, state))

theorem coreInteractionOracleVerifier_rbrKnowledgeSoundness :
    (coreInteractionOracleVerifier ùîΩq Œ≤).rbrKnowledgeSoundness init impl
      (pSpec := pSpecCoreInteraction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
      (relIn := roundRelation (mp := BBF_SumcheckMultiplierParam) ùîΩq Œ≤ (œë:=œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) 0)
      (relOut := finalSumcheckRelOut ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
      (rbrKnowledgeError := coreInteractionOracleRbrKnowledgeError ùîΩq Œ≤ (œë:=œë))

lemma concrete_pow_base_one
  (prevBTFieldProps : ConcreteBTFieldProps (k := k - 1)) (n : ‚Ñï) :
  concrete_pow_nat (k:=k) (x:=1) n = 1

Fin.is_le in Init.Data.Fin.Lemmas

lemma johnson_denominator_def :
  JohnsonDenominator B v = ((1 - ((Fintype.card F) / (Fintype.card F - 1)) * (e B v / n)) ^ 2
      - (1 - ((Fintype.card F) / (Fintype.card F - 1)) * (d B/n)))

lemma and_one_eq_of_eq {a b : ‚Ñï} : a = b ‚Üí a &&& 1 = b &&& 1

lemma MessageIdxUpTo.eq_MessageIdx {k : Fin (n + 1)} {pSpec : ProtocolSpec n} :
    pSpec.MessageIdxUpTo k = {i : Fin k // pSpec.dir (i.castLE (by omega)) = .P_to_V}

@[simp] theorem BitVec.cast_one {n m : ‚Ñï} (h : n = m) : BitVec.cast h 1 = 1#m

theorem succ_eq_one_add (n : ChurchNat Œ±) : succ n = add one n

Nat.add_zero in Init.Core

theorem queryOracleVerifier_rbrKnowledgeSoundness [Fintype L] {œÉ : Type} (init : ProbComp œÉ)
    (impl : QueryImpl []‚Çí (StateT œÉ ProbComp)) :
    (queryOracleVerifier ùîΩq Œ≤ (œë:=œë) Œ≥_repetitions).rbrKnowledgeSoundness init impl
    (relIn := finalSumcheckRelOut ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (relOut := acceptRejectOracleRel)
    (rbrKnowledgeError := queryRbrKnowledgeError ùîΩq Œ≤ Œ≥_repetitions
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))

theorem append_run (stmt : Stmt‚ÇÅ) (wit : Wit‚ÇÅ) :
      (P‚ÇÅ.append P‚ÇÇ).run stmt wit = (do
        let ‚ü®transcript‚ÇÅ, stmt‚ÇÇ, wit‚ÇÇ‚ü© ‚Üê liftM (P‚ÇÅ.run stmt wit)
        let ‚ü®transcript‚ÇÇ, stmt‚ÇÉ, wit‚ÇÉ‚ü© ‚Üê liftM (P‚ÇÇ.run stmt‚ÇÇ wit‚ÇÇ)
        return ‚ü®transcript‚ÇÅ ++‚Çú transcript‚ÇÇ, stmt‚ÇÉ, wit‚ÇÉ‚ü©)

theorem foldOracleReduction_perfectCompleteness (hInit : init.neverFails) (i : Fin ‚Ñì) :
    OracleReduction.perfectCompleteness
      (pSpec := pSpecFold (L := L))
      (relIn := roundRelation ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        (ùìë := ùìë) i.castSucc (mp := mp))
      (relOut := foldStepRelOut ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        (ùìë := ùìë) i (mp := mp))
      (oracleReduction := foldOracleReduction ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i)
      (init := init)
      (impl := impl)

theorem trim_toImpl [LawfulBEq R] (p : R[X]) : p.toImpl.trim = p.toImpl

List.length_drop in Init.Data.List.TakeDrop

theorem Fin.sum_univ_odd_even {n : ‚Ñï} {M : Type*} [AddCommMonoid M] (f : ‚Ñï ‚Üí M) :
    (‚àë i : Fin (2 ^ n), f (2 * i)) + (‚àë i : Fin (2 ^ n), f (2 * i + 1))
    = ‚àë i: Fin (2 ^ (n+1)), f i

lemma quotienting [DecidableEq F] {degree : ‚Ñï} {domain : Œπ ‚Ü™ F} [Nonempty Œπ]
  (S : Finset F) (hS_lt : S.card < degree) (r : F)
  (f : Œπ ‚Üí F) (Ans Fill : S ‚Üí F) (Œ¥ : ‚Ñù) (hŒ¥Pos : Œ¥ > 0) (hŒ¥Lt : Œ¥ < 1)
  (h : ‚àÄ u : code domain degree, u.val ‚àà (relHammingBall ‚Üë(code domain degree) f Œ¥) ‚Üí
    ‚àÉ (x : S) (hx : x.val ‚àà S), ((decodeLT u) : F[X]).eval x.val ‚â† Ans ‚ü®x.val, hx‚ü©) :
    Œ¥·µ£((funcQuotient f S Ans Fill), (code domain (degree - S.card))) +
      ((disagreementSet f S Ans).card : ‚Ñù) / (Œπ.card : ‚Ñù) > Œ¥

theorem towerAlgebraMap_succ_last (r : ‚Ñï) : ‚àÄ l : ‚Ñï, (h_le : l ‚â§ r) ‚Üí
  towerAlgebraMap (l:=l) (r:=r+1) (h_le:=by
    exact Nat.le_trans (n:=l) (m:=r) (k:=r+1) (h_le) (by omega)) =
  (towerAlgebraMap (l:=l+1) (r:=r+1) (by omega)).comp (towerAlgebraMap
    (l:=l) (r:=l+1) (by omega))

lemma contract_eq_liftF_of_lt {k : ‚Ñï} (h‚ÇÅ : k < m) :
  contract m f' k = liftF f' k

lemma qMap_total_fiber_one_level_eq (i : Fin ‚Ñì) (h_i_add_1 : i.val + 1 ‚â§ ‚Ñì)
    (y : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i + 1, by omega‚ü©)) (k : Fin 2) :
    let basis_x := sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i, by omega‚ü© (by simp only; omega)
    let x : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i, by omega‚ü© := qMap_total_fiber ùîΩq Œ≤ (i := ‚ü®i, by omega‚ü©)
      (steps := 1) (h_i_add_steps := by apply Nat.lt_add_of_pos_right_of_le; omega) (y := y) k
    let y_lifted : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i, by omega‚ü© := sDomain.lift ùîΩq Œ≤ h_‚Ñì_add_R_rate
      (i := ‚ü®i, by omega‚ü©) (j := ‚ü®i.val + 1, by omega‚ü©)
      (h_j := by apply Nat.lt_add_of_pos_right_of_le; omega)
      (h_le := by apply Fin.mk_le_mk.mpr (by omega)) y
    let free_coeff_term : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i, by omega‚ü© :=
      (Fin2ToF2 ùîΩq k) ‚Ä¢ (basis_x ‚ü®0, by simp only; omega‚ü©)
    x = free_coeff_term + y_lifted

lemma aeval_apply {A : Type w} [CommSemiring A] [Algebra R A] (s : A) :
    aeval (P := P) s = eval‚ÇÇAlgHom (Algebra.ofId R A) s

@[to_additive]
theorem prod_Iic_eq_univ (i : Fin (n + 1)) :
    ‚àè j ‚àà Iic i, v j = ‚àè j : Fin (i + 1), v (Fin.castLE i.isLt j)

lemma trim_add_trim [LawfulBEq R] (p q : UniPoly R) : p.trim + q = p + q

@[simp]
theorem finSuccEquivNth_X_same : finSuccEquivNth R p (X p) = Polynomial.X

theorem add_assoc (m n p : ChurchNat Œ±) : add (add m n) p = add m (add n p)

theorem fold_advances_evaluation_poly
  (i : Fin (‚Ñì)) (h_i_succ_lt : i + 1 < ‚Ñì + ùì°)
  (coeffs : Fin (2 ^ (‚Ñì - ‚Üëi)) ‚Üí L) (r_chal : L) :
  let P_i : L[X] := intermediateEvaluationPoly ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i, by
    exact Nat.lt_trans (n := i) (k := ‚Ñì+1) (m := ‚Ñì) (h‚ÇÅ := i.isLt) (by exact Nat.lt_add_one ‚Ñì)
  ‚ü©) coeffs
  let f_i

theorem join_eq_bitvec_iff_fromNat {k : ‚Ñï} (h_pos : k > 0) (x : ConcreteBTField k)
  (hi_btf lo_btf : ConcreteBTField (k - 1)) :
  x = „Ää hi_btf, lo_btf „Äã ‚Üî
  (hi_btf = fromNat (k:=k - 1) (x.toNat >>> 2 ^ (k - 1)) ‚àß
  lo_btf = fromNat (k:=k - 1) (x.toNat &&& (2 ^ (2 ^ (k - 1)) - 1)))

lemma rtake_eq_rtake : transcript‚ü¶m:‚üß = transcript.drop m h

@[simp]
theorem LeafData.rightSubtree_internal {Œ±} {s_left s_right : Skeleton}
    (left : LeafData Œ± s_left) (right : LeafData Œ± s_right) :
    (LeafData.internal left right).rightSubtree = right

lemma concrete_inv_zero {k : ‚Ñï} : concrete_inv (k:=k) 0 = 0

theorem concrete_eq_zero_or_eq_one {k : ‚Ñï} {a : ConcreteBTField k} (h_k_zero : k = 0)
 : a = zero ‚à® a = one

lemma discr_of_irred_components_nonzero
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  : ‚àÉ x‚ÇÄ,
      ‚àÄ R ‚àà (irreducible_factorization_of_gs_solution h_gs).choose_spec.choose,
      Bivariate.evalX x‚ÇÄ (Bivariate.discr_y R) ‚â† 0

lemma qMap_total_fiber_repr_coeff (i : Fin ‚Ñì) (steps : ‚Ñï) (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
    (y : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i.val + steps, by omega‚ü©))
    (k : Fin (2 ^ steps)) :
    let x := qMap_total_fiber ùîΩq Œ≤ (i := ‚ü®i, by omega‚ü©)
      (steps := steps)
      (h_i_add_steps := by simp only; exact fin_‚Ñì_steps_lt_‚Ñì_add_R i steps h_i_add_steps) (y := y) k
    let basis_y := sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i.val + steps, by omega‚ü©)
      (h_i := by simp only; exact fin_‚Ñì_steps_lt_‚Ñì_add_R i steps h_i_add_steps)
    let y_coeffs := basis_y.repr y
    ‚àÄ j, -- j refers to bit index of the fiber point x
      ((sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i, by omega‚ü©) (by simp only; omega)).repr x) j
      = fiber_coeff (i := i) (steps := steps) (j := j) (elementIdx := k)
        (y_coeffs := y_coeffs)

@[simp] theorem rightpad_suffix (n : Nat) (unit : Œ±) (l : List Œ±) :
    replicate (n - l.length) unit <:+ rightpad n unit l

Finset.sup_lt_iff in Mathlib.Data.Finset.Lattice.Fold

lemma zero_def [Zero R] : zero = Vector.replicate (2 ^ n) 0

@[simp]
theorem cast_idx_symm {i : ChallengeIdx pSpec‚ÇÇ} :
    pSpec‚ÇÅ.Challenge (i.cast hn.symm (cast_symm hSpec)) = pSpec‚ÇÇ.Challenge i

@[simp]
lemma dfoldlM'_succ {n : ‚Ñï} {Œ± : Fin (n + 2) ‚Üí Type u}
    (f : (i : Fin (n + 1)) ‚Üí Œ± i.castSucc ‚Üí m (Œ± i.succ)) (x : Œ± 0) :
    dfoldlM' (n + 1) Œ± f x = (do
      let y ‚Üê dfoldlM' n (Œ± ‚àò castSucc) (fun i => f i.castSucc) x
      f (last n) y)

@[simp]
lemma foldr'_zero {Œ± : Type u} (f : (i : Fin 0) ‚Üí Œ± ‚Üí Œ±) (x : Œ±) :
    foldr' 0 f x = x

@[simp]
theorem list_nonempty (k : ‚Ñï) : (list k).1 ‚â† []

@[simp]
theorem tail_vcons (a : Œ±) (v : Fin n ‚Üí Œ±) : tail (a ::·µõ v) = v

omit [NoZeroDivisors ùîΩ] in
lemma foldNth_degree_le {n : ‚Ñï} {f : ùîΩ[X]} {Œ± : ùîΩ} [inst : NeZero n] :
    (foldNth n f Œ±).natDegree ‚â§ f.natDegree / n

@[simp]
lemma coeffsOfPolynomial_polynomialOfCoeffs :
  coeffsOfPolynomial (polynomialOfCoeffs coeffs) = coeffs

@[simp]
theorem LeafData.get_ofFun {Œ±} {s} (f : SkeletonLeafIndex s ‚Üí Œ±) :
    (LeafData.ofFun s f).get = f

private lemma F2i_card {Œ± : F} :
  (F2i B i Œ±).card = 2 * choose_2 (K B i Œ±)

@[simp]
lemma foldl'_succ {n : ‚Ñï} {Œ± : Type u} (f : (i : Fin (n + 1)) ‚Üí Œ± ‚Üí Œ±) (x : Œ±) :
    foldl' (n + 1) f x = f (last n) (foldl' n (fun i => f i.castSucc) x)

theorem last_nonzero_last_iff [LawfulBEq R] {p : UniPoly R} (hp : p.size > 0) :
  p.last_nonzero = some ‚ü® p.size - 1, Nat.pred_lt_self hp ‚ü© ‚Üî p.getLast hp ‚â† 0

theorem hcons_eq_cons {Œ≤ : Fin n ‚Üí Sort u} (a : Œ±) (v : (i : Fin n) ‚Üí Œ≤ i) :
    hcons a v = cons (Œ± := vcons Œ± Œ≤) (hcons a v 0) (fun i => hcons a v i.succ)

@[simp] lemma extract_dir : pSpec‚ü¶start:stop‚üß.dir = pSpec.dir‚ü¶start:stop‚üß

theorem support_eval [DecidableEq œÉ] {œÑ : Type*} {f : œÑ ‚Üí R} {p : R[X œÉ][X œÑ]} :
    (eval (C ‚àò f) p).support ‚äÜ p.support.biUnion (fun c => (coeff c p).support)

@[simp]
lemma getTypes_eq_get_fst (l : HList) (i : Fin l.length) : l.getTypes[i] = l[i].1

@[simp]
theorem rdrop_eq_take (m : ‚Ñï) (h : m ‚â§ n) (v : (i : Fin n) ‚Üí Œ± i) :
    rdrop m h v = take (n - m) (by omega) v

lemma twoAdicGenerators_order (bits : Fin (twoAdicity + 1)) :
    orderOf (twoAdicGenerators[bits]) = 2 ^ (bits : Nat)

theorem distanceLE_polynomial_degreeLE : distanceLE (R‚¶É‚â§ d‚¶Ñ[X]) d

theorem nsmul_succ [LawfulBEq R] (n : ‚Ñï) {p : UniPoly R} : nsmul (n + 1) p = nsmul n p + p

@[simp] theorem toNat_ofNat (n : Nat) : toNat (ofNat n) = n

theorem dcast‚ÇÇ_eq_dcast‚ÇÇ_iff (ha : a = a'') (ha' : a' = a'')
    (hb : dcast ha b = b'') (hb' : dcast ha' b' = b'') :
    dcast‚ÇÇ ha hb c = dcast‚ÇÇ ha' hb' c' ‚Üî
      c = dcast‚ÇÇ (ha'.trans ha.symm)
        ((dcast_eq_dcast_iff ha ha').mp (hb.trans hb'.symm)).symm c'

theorem induction_tail {n : ‚Ñï} {motive : Fin (n + 2) ‚Üí Sort*} {zero : motive 0}
    {succ : ‚àÄ i : Fin (n + 1), motive i.castSucc ‚Üí motive i.succ} {i : Fin (n + 1)} :
      induction (motive := motive) zero succ i.succ =
        induction (motive := Fin.tail motive) (succ 0 zero) (fun j x => succ j.succ x) i

theorem rename_eq_zero_of_injective {œÑ : Type*} {f : œÉ ‚Üí œÑ} (hf : Function.Injective f)
    {p : MvPolynomial œÉ R} (h : rename f p = 0) : p = 0

lemma join_via_add_smul_one {k : ‚Ñï} (h_pos : k > 0) :
  ‚ãò 0, 1 ‚ãô = 1

@[simp]
theorem shift_left_mem {s : Finset ‚Ñï} {d : ‚Ñï} : d ‚àà shift_left s ‚Üî (d + 1) ‚àà s

@[simp]
theorem seqCompose_zero {n : Fin 0 ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    {T : ‚àÄ i, FullTranscript (pSpec i)} :
    seqCompose T = !h[]

theorem append_soundness (V‚ÇÅ : OracleVerifier oSpec Stmt‚ÇÅ OStmt‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : OracleVerifier oSpec Stmt‚ÇÇ OStmt‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ pSpec‚ÇÇ)
    {soundnessError‚ÇÅ soundnessError‚ÇÇ : ‚Ñù‚â•0}
    (h‚ÇÅ : V‚ÇÅ.soundness init impl lang‚ÇÅ lang‚ÇÇ soundnessError‚ÇÅ)
    (h‚ÇÇ : V‚ÇÇ.soundness init impl lang‚ÇÇ lang‚ÇÉ soundnessError‚ÇÇ) :
      (V‚ÇÅ.append V‚ÇÇ).soundness init impl lang‚ÇÅ lang‚ÇÉ (soundnessError‚ÇÅ + soundnessError‚ÇÇ)

lemma getLowBits_eq_mod_two_pow {numLowBits : ‚Ñï} (n : ‚Ñï) :
  getLowBits numLowBits n = n % (2 ^ numLowBits)

lemma mul_trans_inequality {k : ‚Ñï} (x : ‚Ñï) (h_k : k ‚â§ 2) (h_x : x ‚â§ 2 ^ (2 ^ k) - 1) : x < 16

@[simp]
protected lemma elocPoly_two :
  ElocPoly 2 œâs f p =
  if f 1 = eval (œâs 1) p
  then if f 0 = eval (œâs 0) p then 1
       else X - C (œâs 0)
  else if f 0 = eval (œâs 0) p then X - C (œâs 1)
       else (X - C (œâs 0)) * (X - C (œâs 1))

theorem PrattPart.out {p : ‚Ñï} {a : ZMod p} {n : ‚Ñï} (h : PrattPart p a n) :
    ‚àÄ q : ‚Ñï, q.Prime ‚Üí q ‚à£ n ‚Üí a ^ ((p - 1) / q) ‚â† 1

protected theorem heq_fun_iff' {k l : ‚Ñï} {Œ± : Fin k ‚Üí Sort u} {Œ≤ : Fin l ‚Üí Sort u} (h : k = l)
    (h' : ‚àÄ i : Fin k, (Œ± i) = (Œ≤ (Fin.cast h i))) {f : (i : Fin k) ‚Üí Œ± i} {g : (j : Fin l) ‚Üí Œ≤ j} :
    HEq f g ‚Üî ‚àÄ i : Fin k, HEq (f i) (g (Fin.cast h i))

theorem BitVec.dcast_bitvec_toNat_eq {w w2 : ‚Ñï} (x : BitVec w) (h_width_eq : w = w2) :
    BitVec.toNat x = BitVec.toNat (dcast (h_width_eq) x)

@[simp]
lemma bIdx_mul_œë_add_i_lt_‚Ñì_succ {m : ‚Ñï} (bIdx : Fin (‚Ñì / œë - 1)) (i : Fin œë) :
    ‚ÜëbIdx * œë + ‚Üëi < ‚Ñì + m

lemma concrete_mul_zero0 (a : ConcreteBTField 0) :
  concrete_mul a (zero (k:=0)) = zero (k:=0)

@[simp]
theorem dappend_zero {motive : Fin (m + 0) ‚Üí Sort u} (u : (i : Fin m) ‚Üí motive (castAdd 0 i)) :
    dappend (motive := motive) u !d‚ü®fun _ : Fin 0 => motive (natAdd m _)‚ü©[] = u

lemma polynomialAlgEquiv_unique (f : P ‚âÉ‚Çê[R] R[X]) : f = polynomialAlgEquiv

omit h_Fq_char_prime in
theorem changeOfBasisMatrix_diag_ne_zero
  (‚Ñì : Nat) (h_‚Ñì : ‚Ñì ‚â§ r) :
  (‚àÄ i, (changeOfBasisMatrix ùîΩq Œ≤ ‚Ñì h_‚Ñì) i i ‚â† 0)

lemma e_ball_le_radius [Field F] [Fintype F] {B : Finset (Fin n ‚Üí F)} (v : Fin n ‚Üí F) (r : ‚Ñö)
  :
  e (B ‚à© ({ x | Œî‚ÇÄ(x, v) ‚â§ r} : Finset _)) v ‚â§ r

@[simp]
theorem fcons‚ÇÇ_zero {Œ±‚ÇÅ : A} {Œ±‚ÇÇ : B} {Œ≤‚ÇÅ : Fin n ‚Üí A} {Œ≤‚ÇÇ : Fin n ‚Üí B}
    (a : F‚ÇÇ Œ±‚ÇÅ Œ±‚ÇÇ) (b : (i : Fin n) ‚Üí F‚ÇÇ (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) :
    fcons‚ÇÇ (F := F‚ÇÇ) a b 0 = cast (by simp [Fin.vcons_zero]) a

@[simp]
lemma natDegree_truncate [œÜ : NeZero n] : (truncate p n).natDegree < n

theorem is_prime : Nat.Prime fieldSize

lemma sDomainBasisVectors_mem_sDomain (i : Fin r) (k : Fin (‚Ñì + R_rate - i)) :
  sDomainBasisVectors ùîΩq Œ≤ h_‚Ñì_add_R_rate i k
    ‚àà sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i

lemma add_eq_one_iff (a b : ConcreteBTField 0) :
  a + b = 1 ‚Üî (a = 0 ‚àß b = 1) ‚à® (a = 1 ‚àß b = 0)

theorem is_multilinear_iff_eq_evals_zeroOne {p : MvPolynomial œÉ R} :
    p ‚àà R‚¶É‚â§ 1‚¶Ñ[X œÉ] ‚Üî MLE p.toEvalsZeroOne = p

@[simp] theorem rightpadPowerOfTwo_size (unit : Œ±) (a : Array Œ±) :
    (a.rightpadPowerOfTwo unit).size = 2 ^ (Nat.clog 2 a.size)

lemma towerAlgebraMap_id (k : ‚Ñï) : towerAlgebraMap (h_le:=by omega) = RingHom.id (BTField k)

theorem toPoly_add {p q : UniPoly Q} : (add_raw p q).toPoly = p.toPoly + q.toPoly

lemma algebra_adjacent_tower_eq_AdjoinRoot_algebra (k : ‚Ñï) :
  (algebra_adjacent_tower k) = (AdjoinRoot.instAlgebra (poly k))

lemma towerRingHomForwardMap_join {k : ‚Ñï} (h_pos : k > 0) (hi lo : ConcreteBTField (k - 1)) :
  towerRingHomForwardMap (k:=k) („Ää hi, lo „Äã) =
    BinaryTower.join_via_add_smul (k:=k) (h_pos:=by omega)
      (hi_btf := towerRingHomForwardMap (k:=k-1) hi)
      (lo_btf := towerRingHomForwardMap (k:=k-1) lo)

NeZero.ne in Init.Data.NeZero

lemma exists_factors_with_large_common_root_set
  (Œ¥ : ‚Ñö) (x‚ÇÄ : F)
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  :
  ‚àÉ R H, R ‚àà (irreducible_factorization_of_gs_solution h_gs).choose_spec.choose ‚àß
    Irreducible H ‚àß H ‚à£ (Bivariate.evalX (Polynomial.C x‚ÇÄ) R) ‚àß
    #(@Set.toFinset _ { z : coeffs_of_close_proximity (F := F) k œâs Œ¥ u‚ÇÄ u‚ÇÅ |
        letI Pz := Pz z.2
        (Trivariate.eval_on_Z R z.1).eval Pz = 0 ‚àß
        (Bivariate.evalX z.1 H).eval (Pz.eval x‚ÇÄ) = 0} sorry)
    ‚â• #(coeffs_of_close_proximity k œâs Œ¥ u‚ÇÄ u‚ÇÅ) / (Bivariate.natDegreeY Q)
    ‚àß #(coeffs_of_close_proximity k œâs Œ¥ u‚ÇÄ u‚ÇÅ) / (Bivariate.natDegreeY Q) >
      2 * D_Y Q ^ 2 * (D_X ((k + 1 : ‚Ñö) / n) n m) * D_YZ Q

theorem add_assoc {n : ‚Ñï} (a b c : CNat (n + 1)) : (a + b) + c = a + (b + c)

theorem cast_injective : Function.Injective (MessageIdx.cast hn hSpec)

@[simp]
theorem cast_idx {i : ChallengeIdx pSpec‚ÇÅ} :
    pSpec‚ÇÇ.Challenge (i.cast hn hSpec) = pSpec‚ÇÅ.Challenge i

lemma forwardRange_pred_le_ne_empty (n : ‚Ñï) (r : Fin n) (l : Fin (r.val + 1))
    (h_l_gt_0 : l.val > 0) : forwardRange n r ‚ü®l.val - 1, by omega‚ü© ‚â† []

@[simp, grind =]
theorem leadingCoeffY_eq_zero (f : F[X][Y]) : leadingCoeffY f = 0 ‚Üî f = 0

@[simp]
theorem cast_id :
    OracleProver.cast rfl rfl =
      (id : OracleProver oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec‚ÇÅ ‚Üí _)

theorem finrank_degreeLT_n (n : ‚Ñï) : Module.finrank L (L‚¶É< n‚¶Ñ[X]) = n

lemma solutionToE_eq_polynomialOfCoeffs
  (h : n < e) : (solutionToE e k v).coeff n = (polynomialOfCoeffs v).coeff n

@[simp]
theorem dcons_zero {motive : Fin (n + 1) ‚Üí Sort u} (a : motive 0)
    (v : (i : Fin n) ‚Üí motive i.succ) : (a ::·µà‚ü®motive‚ü© v) 0 = a

lemma rounds_sub_steps_lt : ‚Ñì - œë < ‚Ñì :=
  Nat.sub_lt (pos_of_neZero ‚Ñì) (folding_steps_pos)

lemma œë_sub_one_le_self : œë - 1 < œë

lemma sum_insertNth' [AddCommMonoid M] [AddCommMonoid N] {n : ‚Ñï} (œÉ : Fin n ‚Üí‚ÇÄ M) (i : M)
    (p : Fin (n + 1)) (f : Fin (n+1) ‚Üí M ‚Üí N) (h : ‚àÄ x, f x 0 = 0) :
    sum (insertNth p i œÉ) f = f p i + sum œÉ (Fin.removeNth p f)

omit O‚Çò in
theorem seqCompose_perfectCompleteness (hInit : init.neverFails)
    (rel : (i : Fin (m + 1)) ‚Üí Set (Stmt i √ó Wit i))
    (R : ‚àÄ i, Reduction oSpec (Stmt i.castSucc) (Wit i.castSucc) (Stmt i.succ) (Wit i.succ)
      (pSpec i))
    (h : ‚àÄ i, (R i).perfectCompleteness init impl (rel i.castSucc) (rel i.succ)) :
      (Reduction.seqCompose Stmt Wit R).perfectCompleteness
        init impl (rel 0) (rel (Fin.last m))

@[simp]
theorem cast_id :
    OracleVerifier.cast rfl rfl (fun i => rfl) =
      (id : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec‚ÇÅ ‚Üí _)

theorem append_left_injective {pSpec : ProtocolSpec n} :
    Function.Injective (@ProtocolSpec.append m n ¬∑ pSpec)

@[simp]
theorem seqCompose_two_eq_append {n : Fin 2 ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)} :
    seqCompose pSpec = append (pSpec 0) (pSpec 1)

@[simp]
theorem FullData.get_ofFun {Œ±} {s} (f : SkeletonNodeIndex s ‚Üí Œ±) :
    (FullData.ofFun s f).get = f

theorem zero_add : 0 + p = p

lemma getLowBits_zero_eq_zero {n : ‚Ñï} : getLowBits 0 n = 0

theorem add_assoc [LawfulBEq R] : p + q + r = p + (q + r)

theorem happend_singleton {Œ± : Fin m ‚Üí Sort u} {Œ≤ : Sort u} (u : (i : Fin m) ‚Üí Œ± i) (a : Œ≤) :
    True

lemma NTTStage_correctness (i : Fin (‚Ñì))
    (input_buffer : Fin (2 ^ (‚Ñì + R_rate)) ‚Üí L) (original_coeffs : Fin (2 ^ ‚Ñì) ‚Üí L) :
    additiveNTTInvariant ùîΩq Œ≤ h_‚Ñì_add_R_rate (evaluation_buffer:=input_buffer)
      (original_coeffs:=original_coeffs) (i := ‚ü®i.val+1, by omega‚ü©) ‚Üí
    additiveNTTInvariant ùîΩq Œ≤ h_‚Ñì_add_R_rate (evaluation_buffer:=NTTStage ùîΩq Œ≤ h_‚Ñì_add_R_rate
      ‚ü®i, by omega‚ü© input_buffer) (original_coeffs:=original_coeffs) ‚ü®i, by omega‚ü©

@[simp]
theorem ofNat_zero : ofNat 0 = @zero Œ±

@[simp]
lemma degreeY_monomialXY {n m : ‚Ñï} {a : F} (ha : a ‚â† 0) :
  natDegreeY (monomialXY n m a) = m

@[simp]
theorem Verifier.id_soundness {lang : Set StmtIn} :
    (Verifier.id : Verifier oSpec _ _ _).soundness init impl lang lang 0

theorem GF_2_value_eq_zero_or_one (x : GF(2)) : x = 0 ‚à® x = 1

@[grind _=_]
theorem monomialXY_mul_monomialXY {n m p q : ‚Ñï} {a b : F} :
    monomialXY n m a * monomialXY p q b = monomialXY (n + p) (m + q) (a * b)

@[simp]
theorem ConcreteBTField.RingHom_eq_of_dest_eq (k m n : ‚Ñï) (h_eq : m = n) :
    (ConcreteBTField k ‚Üí+* ConcreteBTField m)
    = (ConcreteBTField k ‚Üí+* ConcreteBTField n)

theorem Nat.reconstruct_from_hi_and_lo_parts (n hi_len lo_len : ‚Ñï)
    (h_n : n < 2 ^ (hi_len + lo_len)) :
    n = (((n >>> lo_len) % (2 ^ hi_len)) <<< lo_len) + (n % (2 ^ lo_len))

theorem support_mul_C_le (p : MvPolynomial œÉ R) (r : R) : (p * C r).support ‚äÜ p.support

lemma add_equiv_raw [LawfulBEq R] (p q : UniPoly R) : Trim.equiv (p.add q) (p.add_raw q)

@[simp]
lemma toFun_invFun (f : ‚àÄ a, Œ≤ a) : inst.equiv.toFun (equiv.invFun f : F) = f

theorem lagrangeToMonoLevel_monoToLagrangeLevel_id (v : Vector R (2 ^ n)) (i : Fin n) :
  lagrangeToMonoLevel i (monoToLagrangeLevel i v) = v

protected lemma a_lemma_im_not_proud_of_OLD {v a : Fin n ‚Üí F}
  (h_card : 2 ‚â§ Fintype.card F)
  :
  |(1 : ‚Ñö) - ((1 : ‚Ñö) + (1 : ‚Ñö) / ((Fintype.card F : ‚Ñö) - 1)) * ‚ÜëŒî‚ÇÄ(v, a) / ‚Üën

@[simp]
theorem LeafData.map_internal {Œ± Œ≤} {s_left s_right : Skeleton}
    (f : Œ± ‚Üí Œ≤) (left : LeafData Œ± s_left) (right : LeafData Œ± s_right) :
    (LeafData.internal left right).map f =
      LeafData.internal (left.map f) (right.map f)

lemma deevenize_comp_x_squared {f : Polynomial F} (hEven : EvenPoly f) :
    (deevenize f).comp (Polynomial.X * Polynomial.X) = f

@[simp]
theorem rtake_self (v : (i : Fin n) ‚Üí Œ± i) :
    rtake n (by omega) v = fun i : Fin n => dcast (by simp [Fin.cast]) (v i)

@[simp]
theorem cast_completeness (Œµ : ‚Ñù‚â•0) (hComplete : R.completeness init impl relIn relOut Œµ) :
    (R.cast hn hSpec).completeness init impl relIn relOut Œµ

omit [Finite F] in
lemma pow_2_pow_i_mem_Di_of_mem_D :
  ‚àÄ {x : FÀ£} (i : ‚Ñï),
    x ‚àà D ‚Üí x ^ (2 ^ i) ‚àà evalDomain D i

lemma rank_eq_if_subUpFull_eq (h : n ‚â§ m) :
   (subUpFull U (Fin.castLE h)).rank = n  ‚Üí U.rank = n

omit [NeZero ‚Ñì] [NeZero r] [NeZero ùì°] in
lemma fin_‚Ñì_lt_‚Ñì_add_R (i : Fin ‚Ñì)
    : i.val < ‚Ñì + ùì°

theorem two_pow_ne_zero (n : ‚Ñï) : 2 ^ n ‚â† 0

@[simp]
theorem rightpad_apply_ge (n : ‚Ñï) (a : Œ±) (v : Fin m ‚Üí Œ±) (i : Fin n)
    (h : m ‚â§ i.val) : rightpad n a v i = a

theorem oracleReduction_rbr_knowledge_soundness : True

theorem FullData.map_getRootValue {Œ± Œ≤ : Type} {s : Skeleton}
    (f : Œ± ‚Üí Œ≤) (tree : FullData Œ± s) :
    (tree.map f).getRootValue = f (tree.getRootValue)

lemma HList.toDVec_eq_getValue (l : HList) (i : Fin l.length) : l.toDVec i = l.getValue i

lemma wt_eq_hammingNorm [Zero F] {v : Œπ ‚Üí F} :
  wt v = hammingNorm v

@[simp]
theorem BTField.Basis_cast_index_eq (i j k n : ‚Ñï) (h_le : k ‚â§ n) (h_eq : i = j) :
    letI instAlgebra : Algebra (BTField k) (BTField n)
      := binaryAlgebraTower (l:=k) (r:=n) (h_le:=h_le)
    letI : Module (BTField k) (BTField n) := instAlgebra.toModule
    (Basis (Fin (i)) (BTField k) (BTField n)) = (Basis (Fin (j)) (BTField k) (BTField n))

@[simp]
lemma eval‚ÇÇAlgHom_apply {A B : Type*} [CommSemiring A] [CommSemiring B] [MvPolynomialLike œÉ A P]
    [Algebra R A] [IsScalarTower R A P] [Algebra R B]
    (f : A ‚Üí‚Çê[R] B) (g : œÉ ‚Üí B) (p : P) :
    (eval‚ÇÇAlgHom f g) p = eval‚ÇÇ f g p

protected lemma elocPoly_leftF_leftF_eq_contract {œâs f : Fin m ‚Üí F} :
  ElocPoly n (liftF œâs) (liftF f) =
  ElocPoly n (contract n œâs) (contract n f)

lemma coeff_eq_zero {p : UniPoly Q} :
    (‚àÄ i, (hi : i < p.size) ‚Üí p[i] = 0) ‚Üî ‚àÄ i, p.coeff i = 0

lemma toImpl_elim (p : Q[X]) :
    (p = 0 ‚àß p.toImpl = #[])
  ‚à® (p ‚â† 0 ‚àß p.toImpl = .ofFn (fun i : Fin (p.natDegree + 1) => p.coeff i))

theorem degreeOf_linear_le {a b : R} : degreeOf n (C a + C b * p) ‚â§ degreeOf n p

private lemma Fis_pairwise_disjoint : Set.PairwiseDisjoint Set.univ (Fi B i)

lemma powerBasisSucc_gen (k : ‚Ñï) :
  (powerBasisSucc k).gen = (Z (k + 1))

@[simp]
lemma eval‚ÇÇ_monomial {S : Type w} [CommSemiring S] (f : R ‚Üí+* S) (x : S) (n : ‚Ñï) (r : R) :
    eval‚ÇÇ (P := P) f x (monomial n r) = f r * x ^ n

@[simp]
theorem dconcat_zero {motive : Fin 1 ‚Üí Sort u} (a : motive (last 0)) :
    !d‚ü®fun _ : Fin 0 => motive (castSucc _)‚ü©[] :+·µà‚ü®motive‚ü© a = !d‚ü®motive‚ü©[a]

@[simp]
theorem Basis_cast_index_eq (i j k n : ‚Ñï) (h_le : k ‚â§ n) (h_eq : i = j) :
    letI instAlgebra : Algebra (ConcreteBTField k) (ConcreteBTField n) :=
      ConcreteBTFieldAlgebra (l:=k) (r:=n) (h_le:=h_le)
    letI : Module (ConcreteBTField k) (ConcreteBTField n) := instAlgebra.toModule
    (Basis (Fin (i)) (ConcreteBTField k) (ConcreteBTField n)) =
    (Basis (Fin (j)) (ConcreteBTField k) (ConcreteBTField n))

@[simp] theorem rightpad_prefix (n : Nat) (unit : Œ±) (l : List Œ±) :
    l <+: rightpad n unit l

lemma oracle_block_k_next_le (i : Fin (‚Ñì + 1)) (j : Fin (toOutCodewordsCount ‚Ñì œë i))
    (hj : j.val + 1 < toOutCodewordsCount ‚Ñì œë i) : j.val * œë + œë ‚â§ i

lemma sup_eq_of_le_of_reach {Œ± Œ≤ : Type} [SemilatticeSup Œ≤] [OrderBot Œ≤] {s : Finset Œ±} {f : Œ± ‚Üí Œ≤}
      (x : Œ±) {y : Œ≤} (h : x ‚àà s) :
    f x = y ‚Üí
    (‚àÄ x ‚àà s, f x ‚â§ y) ‚Üí
    s.sup f = y

@[simp]
theorem Ici_zero : Ici (0 : Fin (n + 1)) = univ

theorem support_C_mul_le (p : MvPolynomial œÉ R) (r : R) : (C r * p).support ‚äÜ p.support

@[simp]
theorem dcast_trans (h : a = a') (h' : a' = a'') :
    dcast h' (dcast h b) = dcast (h.trans h') b

theorem toNat_ofNat (n : ‚Ñï) : toNat (ofNat n) = n

omit O‚Çò in
theorem seqCompose_completeness (hInit : init.neverFails)
    (rel : (i : Fin (m + 1)) ‚Üí Set (Stmt i √ó Wit i))
    (R : ‚àÄ i, Reduction oSpec (Stmt i.castSucc) (Wit i.castSucc) (Stmt i.succ) (Wit i.succ)
      (pSpec i))
    (completenessError : Fin m ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (R i).completeness init impl (rel i.castSucc) (rel i.succ) (completenessError i)) :
      (Reduction.seqCompose Stmt Wit R).completeness init impl (rel 0) (rel (Fin.last m))
        (‚àë i, completenessError i)

theorem congrArg‚ÇÉ {Œ± Œ≤ Œ≥ Œ¥ : Sort*} {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥ ‚Üí Œ¥} {a a' : Œ±} {b b' : Œ≤} {c c' : Œ≥}
    (h : a = a') (h' : b = b') (h'' : c = c') : f a b c = f a' b' c'

lemma algebraMap_ConcreteBTFieldAlgebra_def (l r : ‚Ñï) (h_le : l ‚â§ r) :
    (@ConcreteBTFieldAlgebra (l:=l) (r:=r) (h_le:=h_le)).algebraMap
    = concreteTowerAlgebraMap l r h_le

theorem add_zero (hp : p.canonical) : p + 0 = p

theorem neg_add_cancel [LawfulBEq R] (p : UniPoly R) : -p + p = 0

lemma Fin.val_add_one' (a : Fin r) (h_a_add_1 : a + 1 < r) : (a + 1).val = a.val + 1

theorem reduction_rbr_knowledge_soundness : True

theorem coeff_eq_getElem_of_lt [LawfulBEq R] {p : UniPoly R} {i} (hi : i < p.size) :
  p.trim.coeff i = p[i]

@[simp]
lemma domain_def : (spec Œ±).domain () = (Œ± √ó Œ±)

theorem PrattPartList.out {p : ‚Ñï} {a : ZMod p} {n : ‚Ñï} (h : PrattPartList p a n) :
    ‚àÄ q : ‚Ñï, q.Prime ‚Üí q ‚à£ n ‚Üí a ^ ((p - 1) / q) ‚â† 1

omit [NeZero r] [NeZero ùì°] in
lemma isNeCommitmentRound (bIdx : Fin (‚Ñì / œë - 1)) (x : ‚Ñï) {hx : x < œë - 1} :
    ¬¨isCommitmentRound ‚Ñì œë ‚ü®‚ÜëbIdx * œë + x, by
      conv_rhs => rw [‚ÜêNat.add_zero (n:=‚Ñì)]
      change bIdx.val * œë + (‚ü®x, by omega‚ü©: Fin œë).val < ‚Ñì + 0
      apply bIdx_mul_œë_add_i_lt_‚Ñì_succ (m:=0)
    ‚ü©

theorem linsolve_some {A : Matrix (Fin n) (Fin m) F} {b : Fin n ‚Üí F} {x : Fin m ‚Üí F}
  (h : linsolve A b = some x)
  : A.mulVec x = b

@[simp]
theorem runWithOracle_pure (f : spec.FunctionType) (a : Œ±) :
    runWithOracle f (pure a) = some a

lemma one_le_sub_middle_of_pow2 {k : ‚Ñï} (h_k : 1 ‚â§ k) : 1 ‚â§ 2 ^ k - 2 ^ (k - 1)

lemma separable_iff_discr_eq_zero {F : Type} [Field F] [Inhabited F] (f : F[X]) :
  f.Separable ‚Üî discriminant f ‚â† 0

theorem getBit_repr_univ {‚Ñì : Nat} : ‚àÄ j, j < 2^‚Ñì ‚Üí
  j = ‚àë k ‚àà Finset.univ (Œ±:=Fin ‚Ñì), (getBit k j) * 2^k.val

omit [Fintype F] in
private lemma d_eq_sum {B : Finset (Fin n ‚Üí F)}
  (h_B : 2 ‚â§ B.card)
  :
  2 * choose_2 B.card * d B =
  ‚àë i, ‚àë x ‚àà B √óÀ¢ B with x.1 ‚â† x.2, (if x.1 i ‚â† x.2 i then 1 else 0)

theorem empty_unique (v : Fin 0 ‚Üí Œ±) : v = !v[]

@[simp]
theorem fappend‚ÇÇ_zero {Œ±‚ÇÅ : Fin m ‚Üí A} {Œ±‚ÇÇ : Fin m ‚Üí B} {Œ≤‚ÇÅ : Fin 0 ‚Üí A} {Œ≤‚ÇÇ : Fin 0 ‚Üí B}
    (u : (i : Fin m) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i)) :
    fappend‚ÇÇ (F := F‚ÇÇ) u (!h‚¶ÉF‚ÇÇ‚¶Ñ‚ü®Œ≤‚ÇÅ‚ü©‚ü®Œ≤‚ÇÇ‚ü©[] : (i : Fin 0) ‚Üí F‚ÇÇ (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) = u

lemma distToCode_of_nonempty {Œ± : Type*} [LinearOrder Œ±] [Zero Œ±]
                             {Œπ F : Type*}
                             {w : Œπ ‚Üí F} {C : Set (Œπ ‚Üí F)}
                             {Œ¥f : (Œπ ‚Üí F) ‚Üí (Œπ ‚Üí F) ‚Üí Œ±}
                             (h‚ÇÅ : (possibleDistsToCode w C Œ¥f).Finite)
                             (h‚ÇÇ : (possibleDistsToCode w C Œ¥f).Nonempty) :
  haveI := @Fintype.ofFinite _ h‚ÇÅ
  distToCode w C Œ¥f h‚ÇÅ = .some ((possibleDistsToCode w C Œ¥f).toFinset.min' (by simpa))

@[simp]
theorem fcons‚ÇÇ_one {Œ±‚ÇÅ : A} {Œ±‚ÇÇ : B} {Œ≤‚ÇÅ : Fin (n + 1) ‚Üí A} {Œ≤‚ÇÇ : Fin (n + 1) ‚Üí B}
    (a : F‚ÇÇ Œ±‚ÇÅ Œ±‚ÇÇ) (b : (i : Fin (n + 1)) ‚Üí F‚ÇÇ (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) :
    fcons‚ÇÇ (F := F‚ÇÇ) a b 1 = b 0

lemma eq_evenize_deevenize {f : Polynomial F} (hEven : EvenPoly f) :
    evenize (deevenize f) = f

@[simp]
theorem PowerBasis.cast_basis_succ_of_eq_rec_apply
    (r1 r : ‚Ñï) (h_r : r = r1 + 1)
    (k : Fin 2) :
    letI instAlgebra : Algebra (BTField r1) (BTField r) :=
      binaryAlgebraTower (l:=r1) (r:=r) (h_le:=by omega)
    letI instAlgebraSucc : Algebra (BTField (r1 + 1)) (BTField (r)) :=
      binaryAlgebraTower (l:=r1 + 1) (r:=r) (h_le:=by omega)
    let b : PowerBasis (BTField r1) (BTField (r1 + 1)) := powerBasisSucc (k:=r1)
    let bCast : PowerBasis (BTField r1) (BTField r) := Eq.rec (motive:=
      fun (x : ‚Ñï) (_ : r1 + 1 = x) => by
        letI instAlgebraCur : Algebra (BTField r1) (BTField x) :=
          binaryAlgebraTower (l:=r1) (r:=x) (h_le:=by omega)
        exact PowerBasis (BTField r1) (BTField x)) (refl:=b) (t:=h_r.symm)
    have h_pb_dim : b.dim = 2 := by
      exact powerBasisSucc_dim r1

    have h_pb'_dim : bCast.dim = 2 := by
      dsimp [bCast]
      rw [BTField.PowerBasis.dim_of_eq_rec (r1:=r1) (r:=r) (h_r:=h_r) (b:=b)]
      exact h_pb_dim

    have h_pb_type_eq : Basis (Fin bCast.dim) (BTField r1) (BTField r) =
      Basis (Fin 2) (BTField r1) (BTField r) := by
      congr

   -- The `cast` needs a proof that `bCast.dim = 2`. We construct it here.
    let left : Basis (Fin 2) (BTField r1) (BTField r) := cast (by exact h_pb_type_eq) bCast.basis
    let right := (algebraMap (BTField (r1 + 1)) (BTField r))
      (b.basis (Fin.cast h_pb_dim.symm k))
    left k = right

@[simp]
theorem vcons_fin_zero (a : Œ±) (v : Fin 0 ‚Üí Œ±) : a ::·µõ v = fun i => match i with

theorem range_vcons {Œ± : Type*} (a : Œ±) (v : Fin n ‚Üí Œ±) :
    Set.range (a ::·µõ v) = insert a (Set.range v)

@[simp]
lemma Rhs_zero_eq_neg : Rhs 0 œâs f i = -f i

@[simp]
theorem FullData.internal_getRootValue {s_left s_right : Skeleton} {Œ± : Type}
    (value : Œ±) (left : FullData Œ± s_left) (right : FullData Œ± s_right) :
    (FullData.internal value left right).getRootValue =
      value

theorem sum_fromNat_eq_from_xor_Nat {k : ‚Ñï} (x y : Nat) :
  fromNat (k:=k) (x ^^^ y) = fromNat (k:=k) x + fromNat (k:=k) y

@[simp]
lemma erase_odd_empty :
    erase_odd ‚àÖ = ‚àÖ

theorem SkeletonNodeIndex.leftChild_bind_parent {s : Skeleton}
    (idx : SkeletonNodeIndex s) :
    idx.leftChild >>= parent = idx.leftChild.map (fun _ => idx)

@[simp, grind] lemma C_pos : 0 < sz.C

lemma algebraMap_adjacent_tower_def (l : ‚Ñï) :
    (algebraMap (ConcreteBTField l) (ConcreteBTField (l + 1))) =
    canonicalAlgMap l

Nat.le_of_succ_le in Init.Data.Nat.Basic

private lemma almost_johnson_choose_2_elimed [Zero F]
  (h_n : 0 < n)
  (h_B : 2 ‚â§ B.card)
  (h_card : 2 ‚â§ Fintype.card F)
  :
  (k B * (k B - 1)  +
    (B.card - k B) * ((B.card - k B)/(Fintype.card F-1) - 1))
  ‚â§
  B.card * (B.card - 1) * (n - d B)/n

private lemma solutionToE_from_E
  (h_p_deg : p.natDegree < k)
  (h_dist : (Œî‚ÇÄ(f, p.eval ‚àò œâs) : ‚Ñï) ‚â§ e)
  : solutionToE e k (E_and_Q_to_a_solution e (E œâs f p e) (Q œâs f p e)) = E œâs f p e

@[simp]
lemma append_last_of_succ_right {u : Fin m ‚Üí Œ±} {v : Fin (n + 1) ‚Üí Œ±} :
    (append u v) (last (m + n)) = v (last n)

theorem OracleReduction.liftContext_toReduction_comm
    {lens : OracleContext.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                              OuterOStmtIn OuterOStmtOut InnerOStmtIn InnerOStmtOut
                              OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    {R : OracleReduction oSpec InnerStmtIn InnerOStmtIn InnerWitIn
                            InnerStmtOut InnerOStmtOut InnerWitOut pSpec} :
      (R.liftContext lens).toReduction = R.toReduction.liftContext lens.toContext

@[simp]
theorem dflatten_two_eq_append {n : Fin 2 ‚Üí ‚Ñï} {motive : (k : Fin (vsum n)) ‚Üí Sort*}
    {v : (i : Fin 2) ‚Üí (j : Fin (n i)) ‚Üí motive (embedSum i j)} :
    dflatten (motive := motive) v = dappend (v 0) (v 1)

theorem dconcat_left_injective {motive : Fin (n + 1) ‚Üí Sort u} (a : motive (last n)) :
    Function.Injective (fun v => dconcat (motive := motive) v a)

@[simp]
theorem Reduction.id_runWithLog (stmt : StmtIn) (wit : WitIn) :
    (Reduction.id : Reduction oSpec StmtIn WitIn _ _ _).runWithLog stmt wit =
      pure ‚ü®‚ü®‚ü®default, stmt, wit‚ü©, stmt‚ü©, [], []‚ü©

theorem fcons_inj {Œ≤ : Fin n ‚Üí A} (a‚ÇÅ a‚ÇÇ : F Œ±) (b‚ÇÅ b‚ÇÇ : (i : Fin n) ‚Üí F (Œ≤ i)) :
    fcons a‚ÇÅ b‚ÇÅ = fcons a‚ÇÇ b‚ÇÇ ‚Üî a‚ÇÅ = a‚ÇÇ ‚àß b‚ÇÅ = b‚ÇÇ

lemma galois_eval_in_BTField
    {curBTField : Type*} [Field curBTField]
    (u : curBTField) (t1 : curBTField) -- here t1 is already lifted to curBTField
    (k : ‚Ñï)
    (sumZeroIffEq : ‚àÄ (x y : curBTField), x + y = 0 ‚Üî x = y)
    (prevSpecialElementNeZero : t1 ‚â† 0)
    (u_plus_inv_eq_t1 : u + u‚Åª¬π = t1)
    (h_u_square : u^2 = u*t1 + 1)
    (h_t1_pow : t1^(2^(2^k)-1) = 1 ‚àß (t1‚Åª¬π)^(2^(2^k)-1) = 1)
    (h_t1_pow_2_pow_2_pow_k :  t1^(2^(2^k)) = t1)
    (h_t1_inv_pow_2_pow_2_pow_k :  (t1‚Åª¬π)^(2^(2^k)) = t1‚Åª¬π)
    (trace_map_at_inv : ‚àë i ‚àà Finset.range (2 ^ k), t1‚Åª¬π ^ (2 ^ i) = 1) :
    u^(2^(2^k)) = u‚Åª¬π

lemma fold_f_g_poly
  {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F} {k m : ‚Ñï}
  {œÜ_0 : (indexPowT S œÜ 0) ‚Ü™ F} {œÜ_k : (indexPowT S œÜ k) ‚Ü™ F}
  [Fintype (indexPowT S œÜ 0)] [DecidableEq (indexPowT S œÜ 0)] [Smooth œÜ_0]
  [Fintype (indexPowT S œÜ k)] [DecidableEq (indexPowT S œÜ k)] [Smooth œÜ_k]
  [‚àÄ i : ‚Ñï, Neg (indexPowT S œÜ i)]
  (Œ±s : Fin k ‚Üí F) (hk : k ‚â§ m)
  (f : smoothCode œÜ_0 m) (g : smoothCode œÜ_k (m-k)) :
  let fPoly

lemma twoAdicGenerator_unit_mem_rootsOfUnity
    (bits : Fin (twoAdicity + 1)) (h : twoAdicGenerators[bits] ‚â† 0) :
    Units.mk0 (twoAdicGenerators[bits]) h ‚àà rootsOfUnity (2 ^ (bits : Nat)) (Field)

@[simp]
theorem fflatten_embedSum {A : Sort u} {F : A ‚Üí Sort v} {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï}
    {Œ± : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí A}
    (v : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí F (Œ± i j)) (i : Fin m) (j : Fin (n i)) :
    fflatten v (embedSum i j) = cast (by simp) (v i j)

lemma irreducibleHTildeOfIrreducible {H : Polynomial (Polynomial F)} :
    (Irreducible H ‚Üí Irreducible (H_tilde H))

@[simp]
theorem vcons_empty (a : Œ±) : a ::·µõ !v[] = !v[a]

@[simp] theorem findIdx'_nil {p : Œ± ‚Üí Bool} : findIdx' p [] = 0

theorem dcast_eq_root_cast (h : a = a') : dcast h b = _root_.cast (congrArg Œ≤ h) b

theorem rsum_eq_t1_square_aux
  {curBTField : Type*} [Field curBTField] -- curBTField ‚âÉ ùîΩ_{2^{2^k}}
  (u : curBTField) -- here u is already lifted to curBTField
  (k : ‚Ñï)
  (x_pow_card : ‚àÄ (x : curBTField), x ^ (2 ^ (2 ^ (k))) = x)
  (u_ne_zero : u ‚â† 0)
  (trace_map_prop : TraceMapProperty curBTField u k):
   ‚àë j ‚àà Finset.Icc 1 (2 ^ (k)), u ^ (2 ^ 2 ^ (k) - 2 ^ j) = u

@[simp]
lemma Transcript.def_eq {k : Fin (n + 1)} {pSpec : ProtocolSpec n} :
    (pSpec.take k k.is_le).FullTranscript =
      ((i : Fin k) ‚Üí pSpec.¬´Type¬ª (Fin.castLE (by omega) i))

lemma W_add_U_invariant
  (i : Fin r) :
  ‚àÄ x : L, ‚àÄ y ‚àà U ùîΩq Œ≤ i, (W ùîΩq Œ≤ i).eval (x + y) = (W ùîΩq Œ≤ i).eval x

theorem mul_two_add_bit_lt_two_pow (a b c : ‚Ñï) (i : Fin 2)
    (h_a : a < 2 ^ b) (h_b : b < c) :
    a * 2 + i.val < 2^c

lemma IsBerlekampWelchSolution_def
  : IsBerlekampWelchSolution e k œâs f v
  ‚Üî Matrix.mulVec (BerlekampWelchMatrix e k œâs f) v = (Rhs e œâs f)

theorem coreInteractionOracleReduction_perfectCompleteness (hInit : init.neverFails) :
    OracleReduction.perfectCompleteness
      (pSpec := pSpecCoreInteraction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
      (relIn := roundRelation (mp := BBF_SumcheckMultiplierParam) ùîΩq Œ≤ (œë:=œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) 0)
      (relOut := finalSumcheckRelOut ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
      (oracleReduction := coreInteractionOracleReduction ùîΩq Œ≤ (œë:=œë) (ùìë:=ùìë))
      (init := init)
      (impl := impl)

@[simp] theorem equiv_refl (p : UniPoly Q) : equiv p p

theorem eq_zero_of_degreeOf_lt_card_of_eval_eq_zero {p : R[X œÉ]} (S : œÉ ‚Üí Finset R)
    (hDegree : ‚àÄ i, p.degreeOf i < #(S i))
    (hEval : ‚àÄ x ‚àà piFinset fun i ‚Ü¶ S i, eval x p = 0) : p = 0

theorem hconcat_right_injective {Œ± : Fin n ‚Üí Sort u} {Œ≤ : Sort u} (v : (i : Fin n) ‚Üí Œ± i) :
    Function.Injective (hconcat v : Œ≤ ‚Üí (i : Fin (n + 1)) ‚Üí vconcat Œ± Œ≤ i)

lemma testBit_of_sub_two_pow_of_bit_1 {n i : ‚Ñï} (h_testBit_eq_1 : (n).testBit i = true) :
  (n - 2^i).testBit i = false

private lemma errors_are_roots_of_E {i : Fin n}
  (h : f i ‚â† p.eval (œâs i)) : (E œâs f p e).eval (œâs i) = 0

@[simp]
theorem seqCompose_succ_dir {m : ‚Ñï} {n : Fin (m + 1) ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)} :
    (seqCompose pSpec).dir = Fin.vflatten (fun i => (pSpec i).dir)

omit [DecidableEq ùîΩq] hF‚ÇÇ in
lemma initial_tiled_coeffs_correctness (h_‚Ñì : ‚Ñì ‚â§ r) (a : Fin (2 ^ ‚Ñì) ‚Üí L) :
    let b: Fin (2^(‚Ñì + R_rate)) ‚Üí L := tileCoeffs a
    additiveNTTInvariant ùîΩq Œ≤ h_‚Ñì_add_R_rate b a (i := ‚ü®‚Ñì, by omega‚ü©)

private lemma almost_johnson_lhs_div_B_card [Zero F]
  (h_n : 0 < n)
  (h_B : 2 ‚â§ B.card)
  :
  (k B * (k B - 1)  +
    (B.card - k B) * ((B.card - k B)/(Fintype.card F - 1) - 1)) / B.card
  =
  (1 - e B 0 / n) ^ 2 * B.card + B.card * (e B 0) ^ 2 / ((Fintype.card F - 1) * n^2) - 1

lemma probOfBadPts {deg : ‚Ñï} {Œ± : Œπ ‚Ü™ F} {e : ‚Ñï} {U : Matrix Œ∫ Œπ F}
  (he : (e : ‚Ñö) < (Code.minDist (RScodeSet Œ± deg) : ‚Ñö) / 3)
  (hU : e < Œî(U, matrixSubmoduleOfLinearCode Œ∫ (ReedSolomon.code Œ± deg))) :
  (PMF.uniformOfFintype (Matrix.rowSpan U)).toOuterMeasure
    { w | distFromCode (n := Œπ) (R := F) w (ReedSolomon.code Œ± deg) ‚â§ e }
  ‚â§ (Code.minDist (RScodeSet Œ± deg) : ‚Ñù‚â•0) /(Fintype.card F : ‚Ñù‚â•0)

lemma sum_inv_Z_next_eq
  (k : ‚Ñï)
  (prev : ConcreteBTFStepResult (k := k)) :
  letI : Field (ConcreteBTField k) := mkFieldInstance (prev.toConcreteBTFieldProps)
  letI : Field (ConcreteBTField (k + 1)) := mkFieldInstance (k:=k+1)
    (props:=liftBTFieldProps (k:=k) (prevBTFResult:=prev))
  letI : Algebra (ConcreteBTField k) (ConcreteBTField (k + 1)) :=
    instAlgebraLiftConcreteBTField k prev
  Z (k + 1) + (Z (k + 1))‚Åª¬π = (algebraMap (ConcreteBTField k) (ConcreteBTField (k + 1))) (Z k)

lemma mkLastOracleIndex_last : mkLastOracleIndex ‚Ñì œë (Fin.last ‚Ñì) = ‚Ñì / œë - 1

omit [SelectableType R] in
@[simp]
lemma oracleReduction_verifier_eq_oracleVerifier :
    (oracleReduction R deg D n oSpec).verifier = oracleVerifier R deg D n oSpec

theorem oracleVerifier_toVerifier_run {stmt : Statement} {oStmt : ‚àÄ i, OStatement i}
    {tr : (oraclePSpec Witness).FullTranscript} :
    (oracleVerifier oSpec Statement OStatement Witness).toVerifier.run ‚ü®stmt, oStmt‚ü© tr =
      pure ‚ü®stmt, Sum.rec oStmt (fun i => match i with | 0 => tr 0)‚ü©

lemma add_shiftRight_distrib {n m k : ‚Ñï} (h_and_zero : n &&& m = 0):
  (n + m) >>> k = (n >>> k) + (m >>> k)

@[simp]
private lemma evenPart'_coeffs {f : Polynomial F} {n : ‚Ñï} :
    (evenPart' f).coeff n = if Even n then f.coeff n else 0

@[simp]
theorem FullData.rightSubtree_internal {Œ±} {s_left s_right : Skeleton}
    (value : Œ±) (left : FullData Œ± s_left) (right : FullData Œ± s_right) :
    (FullData.internal value left right).rightSubtree = right

theorem vconcat_inj (v w : Fin n ‚Üí Œ±) (a b : Œ±) :
    vconcat v a = vconcat w b ‚Üî v = w ‚àß a = b

omit [SelectableType R] in
@[simp]
lemma reduction_verifier_eq_verifier :
    (reduction R deg D n oSpec).verifier = verifier R deg D n oSpec

@[grind]
lemma degreeX_le_degreeX_sub_degreeX [IsDomain F] {f q : F[X][Y]} (hf : f ‚â† 0) (hg : q * f ‚â† 0) :
  degreeX q ‚â§ degreeX (q * f) - degreeX f

@[simp]
theorem drop_of_succ {Œ± : Fin (n + 1) ‚Üí Sort*} (v : (i : Fin (n + 1)) ‚Üí Œ± i) :
    drop n n.le_succ v = fun i => v (Fin.cast (Nat.sub_add_cancel n.le_succ) (addNat i n))

@[simp]
theorem zero_dappend {motive : Fin (0 + n) ‚Üí Sort u} {u : (i : Fin 0) ‚Üí motive (castAdd n i)}
    (v : (i : Fin n) ‚Üí motive (natAdd 0 i)) :
    dappend (motive := motive) u v = fun i => cast (by simp) (v (i.cast (by omega)))

theorem dcast‚ÇÉ_dcast‚ÇÇ : dcast‚ÇÉ rfl rfl rfl d = dcast‚ÇÇ dcast_eq.symm dcast‚ÇÇ_dcast.symm d

Fin.isLt in Init.Prelude

@[simp]
theorem verifier_rbrKnowledgeSoundness (hRel : ‚àÄ stmtIn witOut,
      (mapStmt stmtIn, witOut) ‚àà relOut ‚Üí (stmtIn, mapWitInv stmtIn witOut) ‚àà relIn) :
    (verifier oSpec mapStmt).rbrKnowledgeSoundness init impl relIn relOut 0

theorem last_nonzero_some [LawfulBEq R] {p : UniPoly R} {i} (hi : i < p.size) (h : p[i] ‚â† 0) :
  ‚àÉ k, p.last_nonzero = some k

theorem pow_two_eq_mul {a : CNat 2} : a ^ 2 = a * a

@[simp]
lemma oddPart_by_2 :
    2 * (oddPart f) = (f - f.comp (-X)) /‚Çò X

lemma guruswami_sudan_for_proximity_gap_existence {k m : ‚Ñï} {œâs : Fin n ‚Ü™ F} {f : Fin n ‚Üí F} :
  ‚àÉ Q, Condition (k + 1) m ((proximity_gap_degree_bound ((k + 1 : ‚Ñö) / n) m n)) œâs f Q

@[simp]
theorem FullData.toLeafData_leaf {Œ±} (a : Œ±) :
    (FullData.leaf a).toLeafData = LeafData.leaf a

@[simp]
lemma dotProduct_cons [AddCommMonoid R] [Mul R] (a : R) (b : Vector R n) (c : R) (d : Vector R n) :
  dotProduct (cons a b) (cons c d) = a * c + dotProduct b d

lemma getBit_of_shiftLeft {n p : ‚Ñï}:
  ‚àÄ k, getBit (k) (n <<< p) = if k < p then 0 else getBit (k - p) n

theorem sumcheck_roundPoly_degreeLE (i : Fin (n + 1)) {challenges : Fin i.castSucc ‚Üí R}
    {poly : R[X Fin (n + 1)]} (hp : poly ‚àà R‚¶É‚â§ deg‚¶Ñ[X Fin (n + 1)]) :
      ‚àë x ‚àà (univ.map D) ^·∂† (n - i), poly ‚∏®X ‚¶Éi‚¶Ñ, challenges, x‚∏©'
        (by simp; omega) ‚àà R‚¶É‚â§ deg‚¶Ñ[X]

@[simp]
theorem dist_le_card (C : Set (n ‚Üí R)) : dist C ‚â§ Fintype.card n

@[simp]
theorem FullData.leftSubtree_internal {Œ±} {s_left s_right : Skeleton}
    (value : Œ±) (left : FullData Œ± s_left) (right : FullData Œ± s_right) :
    (FullData.internal value left right).leftSubtree = left

lemma zero_add {k : ‚Ñï} (a : ConcreteBTField k) : 0 + a = a

@[simp]
theorem Vector.ofFn_get {Œ± : Type*} {n : ‚Ñï} (v : Vector Œ± n) : Vector.ofFn (Vector.get v) = v

@[simp]
theorem erase_odd_mem
  {s : Finset ‚Ñï}
  {n : ‚Ñï}
  : n ‚àà (erase_odd s) ‚Üî Even n ‚àß n ‚àà s

lemma and_shl_eq_zero_of_lt_two_pow {a n b : ‚Ñï} (hb : b < 2 ^ n) : (a <<< n) &&& b = 0

@[simp]
theorem OracleReduction.id_run (stmt : StmtIn) (oStmt : ‚àÄ i, OStmtIn i) (wit : WitIn) :
    (OracleReduction.id : OracleReduction oSpec StmtIn OStmtIn WitIn _ _ _ _).run stmt oStmt wit =
      pure ‚ü®‚ü®default, ‚ü®stmt, oStmt‚ü©, wit‚ü©, ‚ü®stmt, oStmt‚ü©‚ü©

@[simp]
lemma dfoldl'_succ_last {n : ‚Ñï} {Œ± : Fin (n + 2) ‚Üí Type u}
    (f : (i : Fin (n + 1)) ‚Üí Œ± i.castSucc ‚Üí Œ± i.succ) (x : Œ± 0) :
    dfoldl' (n + 1) Œ± f x = f (last n) (dfoldl' n (Œ± ‚àò castSucc) (fun i => f i.castSucc) x)

theorem happend_hcons {Œ≤ : Fin m ‚Üí Sort u} {Œ≥ : Fin n ‚Üí Sort u}
    (a : Œ±) (u : (i : Fin m) ‚Üí Œ≤ i) (v : (i : Fin n) ‚Üí Œ≥ i) :
    True

theorem seqCompose_rbrSoundness
    (lang : (i : Fin (m + 1)) ‚Üí Set (Stmt i))
    (V : (i : Fin m) ‚Üí Verifier oSpec (Stmt i.castSucc) (Stmt i.succ) (pSpec i))
    (rbrSoundnessError : ‚àÄ i, (pSpec i).ChallengeIdx ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (V i).rbrSoundness init impl (lang i.castSucc) (lang i.succ) (rbrSoundnessError i)) :
      (Verifier.seqCompose Stmt V).rbrSoundness init impl (lang 0) (lang (Fin.last m))
        (fun combinedIdx =>
          letI ij := seqComposeChallengeIdxToSigma combinedIdx
          rbrSoundnessError ij.1 ij.2)

Nat.lt_of_add_right_lt in Init.Data.Nat.Basic

@[simp]
theorem BTField.RingHom_cast_dest_apply (k m n : ‚Ñï) (h_eq : m = n)
  (f : BTField k ‚Üí+* BTField m) (x : BTField k) :
    (cast (BTField.RingHom_eq_of_dest_eq (k:=k) (m:=m) (n:=n) h_eq) f) x
    = cast (by apply cast_BTField_eq (h_eq:=h_eq)) (f x)

@[simp]
theorem OracleReduction.id_perfectCompleteness
    {rel : Set ((StmtIn √ó ‚àÄ i, OStmtIn i) √ó WitIn)}
    (hInit : init.neverFails) :
    (OracleReduction.id : OracleReduction oSpec _ _ _ _ _ _ _).perfectCompleteness
      init impl rel rel

lemma pow_inj {i : ‚Ñï} {a b : Fin (2 ^ (n - i))} :
    i ‚â§ n ‚Üí (DIsCyclicC.gen.1 ^ 2 ^ i) ^ a.1 = (DIsCyclicC.gen.1 ^ 2 ^ i) ^ b.1 ‚Üí a = b

theorem leftpad_eq_self (v : Fin n ‚Üí Œ±) (a : Œ±) : leftpad n a v = v

@[simp]
theorem removeNth_zero : removeNth 0 s = tail s

private lemma k_and_e [Zero F]
  (h_n : n ‚â† 0)
  (h_B : B.card ‚â† 0)
  :
  k B = B.card * (n - e B 0) / n

theorem two_le_two_pow_n_plus_1 (n : ‚Ñï) : 2 ‚â§ 2 ^ (n + 1)

lemma getBit_eq_pred_getBit_of_div_two {n k : ‚Ñï} (h_k: k > 0) :
    getBit k (n) = getBit (k-1) (n/2)

@[csimp, grind =]
theorem idxOf'_eq_idxOf : @idxOf' = @idxOf

@[simp]
lemma cons_empty_tail_eq_nil {Œ±} (hd : Œ±) (tl : Vector Œ± 0) :
    cons hd tl = ‚ü®#[hd], rfl‚ü©

lemma full_row_rank_via_rank_subLeftFull (h : m ‚â§ n) :
   (subLeftFull U (Fin.castLE h)).rank = m ‚Üí U.rank = m

theorem append_rbrSoundness {lang‚ÇÅ : Set Stmt‚ÇÅ} {lang‚ÇÇ : Set Stmt‚ÇÇ} {lang‚ÇÉ : Set Stmt‚ÇÉ}
    (V‚ÇÅ : Verifier oSpec Stmt‚ÇÅ Stmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : Verifier oSpec Stmt‚ÇÇ Stmt‚ÇÉ pSpec‚ÇÇ)
    {rbrSoundnessError‚ÇÅ : pSpec‚ÇÅ.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    {rbrSoundnessError‚ÇÇ : pSpec‚ÇÇ.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    (h‚ÇÅ : V‚ÇÅ.rbrSoundness init impl lang‚ÇÅ lang‚ÇÇ rbrSoundnessError‚ÇÅ)
    (h‚ÇÇ : V‚ÇÇ.rbrSoundness init impl lang‚ÇÇ lang‚ÇÉ rbrSoundnessError‚ÇÇ) :
      (V‚ÇÅ.append V‚ÇÇ).rbrSoundness init impl lang‚ÇÅ lang‚ÇÉ
        (Sum.elim rbrSoundnessError‚ÇÅ rbrSoundnessError‚ÇÇ ‚àò ChallengeIdx.sumEquiv.symm)

omit [NeZero ‚Ñì] in
lemma fin_‚Ñì_steps_lt_‚Ñì_add_one (i : Fin ‚Ñì) (steps : ‚Ñï)
    (h : i.val + steps ‚â§ ‚Ñì) : i.val + steps < ‚Ñì + 1

@[simp]
theorem lagrangeBasis_zero {w : Vector R 0} : lagrangeBasis w = #v[1]

@[simp]
theorem dcons_one {motive : Fin (n + 2) ‚Üí Sort u} (a : motive 0)
    (v : (i : Fin (n + 1)) ‚Üí motive i.succ) : (a ::·µà‚ü®motive‚ü© v) 1 = v 0

@[simp]
lemma challengeOracleInterface_append_domain_inr (j : pSpec‚ÇÇ.ChallengeIdx) :
    [(pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).Challenge]‚Çí.domain (.inr j) = Unit

lemma cast_join {k n : ‚Ñï} (h_pos : k > 0) (hi lo : ConcreteBTField (k - 1)) (heq : k = n) :
  join (k:=k) h_pos hi lo = cast (by rw [heq])
    (join (k:=n) (by omega) (cast (by subst heq; rfl) hi) (lo:=cast (by subst heq; rfl) lo))

theorem FullData.toLeafData_eq_leaf {Œ±} (a : Œ±) (tree)
    (h : LeafData.leaf a = tree.toLeafData) :
    tree = FullData.leaf a

lemma addSalt_Message (i : pSpec.MessageIdx) :
    (pSpec.addSalt Salt).Message i = (pSpec.Message i √ó Salt i)

theorem fcons_left_injective {Œ≤ : Fin n ‚Üí A} (b : (i : Fin n) ‚Üí F (Œ≤ i)) :
    Function.Injective (fun (a : F Œ±) => fcons a b)

lemma division_by_conjugate {a b : ‚Ñù} (hpos : 0 ‚â§ b) (hnonzero : a + b.sqrt ‚â† 0) :
  a - (b).sqrt = (a^2 - b)/(a + b.sqrt)

lemma eval‚ÇÇ_eq' {S : Type w} [CommSemiring S] (g : P ‚Üí+* S) (p : P) :
    g p = eval‚ÇÇ (g.comp (Algebra.ofId R P)) (g X) p

theorem BitVec.dcast_bitvec_eq_zero {l r : ‚Ñï} (h_width_eq : l = r) :
  dcast (h_width_eq) 0#(l) = 0#(r)

theorem hconcat_hcons {Œ± : Sort u} {Œ≤ : Fin n ‚Üí Sort u} {Œ≥ : Sort u} (a : Œ±) (v : (i : Fin n) ‚Üí Œ≤ i) (c : Œ≥) :
    True

theorem lt_iff_toNat_lt (a b : AssocNat) : a < b ‚Üî toNat a < toNat b

theorem liftContext_run
    {lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    {outerStmtIn : OuterStmtIn} {outerWitIn : OuterWitIn}
    {R : Reduction oSpec InnerStmtIn InnerWitIn InnerStmtOut InnerWitOut pSpec} :
      (R.liftContext lens).run outerStmtIn outerWitIn = do
        let ‚ü®‚ü®fullTranscript, innerCtxOut‚ü©, verInnerStmtOut‚ü© ‚Üê
          R.run.uncurry (lens.proj (outerStmtIn, outerWitIn))
        return ‚ü®‚ü®fullTranscript, lens.lift (outerStmtIn, outerWitIn) innerCtxOut‚ü© ,
                lens.stmt.lift outerStmtIn verInnerStmtOut‚ü©

lemma definingPoly_coeffOf0 {F : Type*} [Field F] [Fintype F] (s : F) [NeZero s] :
    (definingPoly s).coeff 0 = 1

@[simp]
theorem cast_id : MessageIdx.cast (Eq.refl n‚ÇÅ) rfl = (id : pSpec‚ÇÅ.MessageIdx ‚Üí _)

lemma forwardRange_tail (n : ‚Ñï) (r : Fin n) (l : Fin (r.val + 1)) (h_l_gt_0 : l.val > 0) :
  (forwardRange n r ‚ü®l.val - 1, by omega‚ü©).tail = forwardRange n r l

lemma Fin.lt_succ' (a : Fin r) (h_a_add_1 : a + 1 < r) : a < a + 1

lemma or_by_split_lowBits {n m n1 m1 bn bm : ‚Ñï} (h_bn : bn < 2) (h_bm : bm < 2)
  (h_n : n = n1 * 2 + bn) (h_m : m = m1 * 2 + bm):
  n ||

theorem toNatInRange {k : ‚Ñï} (b : ConcreteBTField k) :
  BitVec.toNat b ‚â§ 2 ^ (2 ^ k) * 1

@[ext]
lemma ext {m n : ChurchNat Œ±} (h : ‚àÄ f x, m f x = n f x) : m = n

theorem relayOracleReduction_perfectCompleteness (hInit : init.neverFails) (i : Fin ‚Ñì)
    (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
    OracleReduction.perfectCompleteness
      (pSpec := pSpecRelay)
      (relIn := foldStepRelOut (mp := mp) ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        (ùìë := ùìë) i)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        (ùìë := ùìë) i.succ)
      (oracleReduction := relayOracleReduction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        i hNCR)
      (init := init)
      (impl := impl)

@[simp]
lemma eval‚ÇÇAlgHom_apply {A : Type w} {B : Type*} [CommSemiring A] [CommSemiring B]
    [PolynomialLike A P] [Algebra R A] [IsScalarTower R A P] [Algebra R B]
    (f : A ‚Üí‚Çê[R] B) (b : B) (p : P) :
    (eval‚ÇÇAlgHom f b) p = eval‚ÇÇ f b p

private lemma solutionToQ_from_Q
  (h_p_deg : p.natDegree < k)
  (h_dist : (Œî‚ÇÄ(f, p.eval ‚àò œâs) : ‚Ñï) ‚â§ e)
  : solutionToQ e k (E_and_Q_to_a_solution e (E œâs f p e) (Q œâs f p e)) = Q œâs f p e

theorem fconcat‚ÇÇ_inj {Œ±‚ÇÅ : Fin n ‚Üí A} {Œ±‚ÇÇ : Fin n ‚Üí B} {Œ≤‚ÇÅ : A} {Œ≤‚ÇÇ : B}
    (v‚ÇÅ v‚ÇÇ : (i : Fin n) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i)) (a‚ÇÅ a‚ÇÇ : F‚ÇÇ Œ≤‚ÇÅ Œ≤‚ÇÇ) :
    fconcat‚ÇÇ (F := F‚ÇÇ) v‚ÇÅ a‚ÇÅ = fconcat‚ÇÇ (F := F‚ÇÇ) v‚ÇÇ a‚ÇÇ ‚Üî v‚ÇÅ = v‚ÇÇ ‚àß a‚ÇÅ = a‚ÇÇ

lemma cast_mul (m n : ‚Ñï) {x y : ConcreteBTField m} (h_eq : m = n) :
  (cast (by exact cast_ConcreteBTField_eq m n h_eq) (x * y)) =
  (cast (by exact cast_ConcreteBTField_eq m n h_eq) x) *
  (cast (by exact cast_ConcreteBTField_eq m n h_eq) y)

@[simp]
theorem happend_empty {Œ± : Fin m ‚Üí Sort u} {Œ≤ : Fin 0 ‚Üí Sort u} (v : (i : Fin m) ‚Üí Œ± i) :
    happend v !h‚ü®Œ≤‚ü©[] = v

theorem induct [LawfulBEq R] {motive : UniPoly R ‚Üí Prop}
  (case1 : ‚àÄ p, p.trim = #[] ‚Üí (‚àÄ i, (hi : i < p.size) ‚Üí p[i] = 0) ‚Üí motive p)
  (case2 : ‚àÄ p : UniPoly R, ‚àÄ k : Fin p.size, p.trim = p.extract 0 (k + 1)
    ‚Üí p[k] ‚â† 0 ‚Üí (‚àÄ j : ‚Ñï, (hj : j < p.size) ‚Üí j > k ‚Üí p[j] = 0) ‚Üí motive p)
  (p : UniPoly R) : motive p

lemma sInf_UB_of_le_UB {S : Set ‚Ñï} {i : ‚Ñï} : (‚àÄ s ‚àà S, s ‚â§ i) ‚Üí sInf S ‚â§ i

theorem vconcat_vcons_eq_vcons_vconcat (a : Œ±) (v : Fin n ‚Üí Œ±) (b : Œ±) :
    vconcat (a ::·µõ v) b = a ::·µõ (vconcat v b)

theorem linearIndependent_fin2' {f : Fin 2 ‚Üí V} :
    LinearIndependent K f ‚Üî f 0 ‚â† 0 ‚àß ‚àÄ a : K, a ‚Ä¢ f 0 ‚â† f 1

@[simp]
private lemma E_ne_zero : (E œâs f p e) ‚â† 0

@[simp]
theorem hflatten_two_eq_append {n : Fin 2 ‚Üí ‚Ñï} {Œ± : (i : Fin 2) ‚Üí (j : Fin (n i)) ‚Üí Sort*}
    {v : (i : Fin 2) ‚Üí (j : Fin (n i)) ‚Üí Œ± i j} : hflatten v = happend (v 0) (v 1)

@[simp]
lemma dfoldrM'_succ {n : ‚Ñï} {Œ± : Fin (n + 1 + 1) ‚Üí Type u}
    (f : (i : Fin (n + 1)) ‚Üí Œ± i.succ ‚Üí m (Œ± i.castSucc)) (x : Œ± (last (n + 1))) :
    dfoldrM' (n + 1) Œ± f x = (do
      let y ‚Üê dfoldrM' n (Œ± ‚àò succ) (fun i => f i.succ) x
      f 0 y)

theorem join_eq_iff_dcast_extractLsb {k : ‚Ñï} (h_pos : k > 0) (x : ConcreteBTField k)
  (hi_btf lo_btf : ConcreteBTField (k - 1)) :
  x = „Ää hi_btf, lo_btf „Äã ‚Üî
  (hi_btf = dcast (h_sub_middle h_pos) (BitVec.extractLsb (hi := 2 ^ k - 1) (lo := 2 ^ (k - 1)) x) ‚àß
  lo_btf = dcast (h_middle_sub) (BitVec.extractLsb (hi := 2 ^ (k - 1) - 1) (lo := 0) x))

lemma concrete_mul_left_distrib0 (a b c : ConcreteBTField 0) :
  concrete_mul a (b + c) = concrete_mul a b + concrete_mul a c

@[simp]
theorem finSuccEquivNth_X_below {i : Fin n} (h : i.castSucc < p) :
    finSuccEquivNth R p (X i.castSucc) = Polynomial.C (X i)

theorem mapM_single (f : Œ± ‚Üí m Œ≤) (a : Œ±) : List.mapM f [a] = return [‚Üê f a]

@[simp]
theorem eq_accepts (i : Fin numWires) (c : ùì°) (x : Fin numWires ‚Üí ùì°) :
    (eq i c).accepts x ‚Üî x i = c

lemma and_two_pow_eq_two_pow_of_getBit_eq_one {n i : ‚Ñï} (h_getBit: getBit i n = 1)
    : n &&& (2 ^ i) = 2 ^ i

lemma Œ≤_regular (R : F[X][X][Y])
                (H : F[X][Y]) [H_irreducible : Fact (Irreducible H)]
                {D : ‚Ñï} (hD : D ‚â• Bivariate.totalDegree H) :
    ‚àÄ t : ‚Ñï, ‚àÉ Œ≤ : ùí™ H, weight_Œõ_over_ùí™ Œ≤ ‚â§ (2 * t + 1) * Bivariate.natDegreeY R * D

lemma zero_def [Zero R] : zero = Vector.replicate (2 ^ n) 0

lemma degree_bound_bivariate
  (qPoly : Polynomial F)
  (hdeg_q_min : qPoly.natDegree > 0)
  (hdeg_q_max : qPoly.natDegree < Fintype.card F)
  {t : ‚Ñï} (Q : MvPolynomial (Fin 2) F)
  (hdegX : MvPolynomial.degreeOf 0 Q < t)
  (hdegY : MvPolynomial.degreeOf 1 Q < qPoly.natDegree) :
  (MvPolynomial.eval‚ÇÇHom (Polynomial.C : F ‚Üí+* Polynomial F)
      (fun i : Fin 2 => if i = 0 then qPoly else Polynomial.X) Q).natDegree < t * qPoly.natDegree

lemma degree_definingPoly {F : Type*} [Field F] [Fintype F] (s : F) [NeZero s] :
  (definingPoly s).degree = 2

theorem base_intermediateNormVpoly
  (k : Fin (‚Ñì + 1)) :
  intermediateNormVpoly ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®0, by
    by_contra ht
    simp only [not_lt, nonpos_iff_eq_zero] at ht
    contradiction
  ‚ü© ‚ü®k, by simp only [tsub_zero]; omega‚ü© =
  normalizedW ùîΩq Œ≤ ‚ü®k, by omega‚ü©

Nat.add_left_cancel in Init.Data.Nat.Basic

theorem eqPolynomial_expanded (r : œÉ ‚Üí R) :
    eqPolynomial r = ‚àè i : œÉ, ((1 - C (r i)) * (1 - X i) + C (r i) * X i)

@[simp]
lemma bIdx_mul_œë_add_i_cast_lt_‚Ñì_succ (bIdx : Fin (‚Ñì / œë - 1)) (i : Fin (œë - 1 + 1))
    : ‚ÜëbIdx * œë + i < ‚Ñì + 1

theorem mulVecLin_coeff_vandermondens_eq_eval_matrixOfPolynomials
  {n : ‚Ñï} [NeZero n] {v : Œπ ‚Ü™ F} {p : F[X]} (h_deg : p.natDegree < n) :
  (Vandermonde.nonsquare (Œπ' := n) v).mulVecLin (Fin.liftF' p.coeff) =
  fun i => p.eval (v i)

lemma U_i_is_union_of_cosets (i : Fin r) (hi : 0 < i) :
    (U ùîΩq Œ≤ i : Set L) = ‚ãÉ (c : ùîΩq), (fun u => c ‚Ä¢ Œ≤ (i-1) + u) '' (U ùîΩq Œ≤ (i - 1))

@[simp]
lemma bIdx_mul_œë_add_i_fin_‚Ñì_pred_lt_‚Ñì (bIdx : Fin (‚Ñì / œë - 1)) (i : Fin (œë - 1))
    : ‚ÜëbIdx * œë + ‚Üëi < ‚Ñì

lemma listOfCloseCodewords_eq_zero :
  listOfCloseCodewords C y n = 0 ‚Üî IsEmpty (hammingBall C y n) ‚à® Infinite (hammingBall C y n)

theorem randomOracle_neverFails_iff_runWithOracle_neverFails {Œ≤}
    [DecidableEq Œπ] [spec.DecidableEq] [(i : Œπ) ‚Üí SelectableType (OracleSpec.range spec i)]
    (oa : OracleComp (spec) Œ≤)
    :
    (‚àÄ (preexisting_cache : spec.QueryCache),
      ((oa.simulateQ randomOracle).run preexisting_cache).neverFails)
    ‚Üî
    (‚àÄ (f : spec.FunctionType),
      (runWithOracle f oa).isSome)

lemma Q'_div_E'_eq_p
  [NeZero n]
  {E' Q' : Polynomial F}
  {œâs f : Fin n ‚Üí F}
  (hp_deg : p.natDegree < k)
  (he : 2 * e < n - k + 1)
  (hk_n : k ‚â§ n)
  (h_ham : (Œî‚ÇÄ(f, p.eval ‚àò œâs) : ‚Ñï) ‚â§ e)
  (h_diff : Function.Injective œâs)
  (h_Q' : Q' ‚â† 0)
  (hp : p ‚â† 0)
  (h_cond : BerlekampWelchCondition e k œâs f E' Q')
  : E' ‚à£ Q' ‚àß Q' / E' = p

@[simp] theorem toNat_mul (a b : AssocNat) : toNat (mul a b) = toNat a * toNat b

lemma div_2_form {nD2 b : ‚Ñï} (h_b : b < 2):
  (nD2 * 2 + b) / 2 = nD2

private lemma johnson_bound‚ÇÄ [Zero F]
  (h_n : 0 < n)
  (h_B : 2 ‚â§ B.card)
  (h_card : 2 ‚â§ (Fintype.card F))
  :
  B.card *
    ((1 - ((Fintype.card F : ‚Ñö) / (Fintype.card F - 1)) * (e B 0 / n)) ^ 2
      - (1 - ((Fintype.card F : ‚Ñö) / (Fintype.card F - 1)) * (d B/n)))  ‚â§
  ((Fintype.card F : ‚Ñö) / (Fintype.card F - 1)) * d B/n

beq_iff_eq in Init.Core

@[simp, grind _=_]
theorem smul_monomialXY {n m : ‚Ñï} {a : F} {S} [SMulZeroClass S F] {b : S} :
  monomialXY n m (b ‚Ä¢ a) = b ‚Ä¢ monomialXY n m a

theorem append_perfectCompleteness
    (R‚ÇÅ : OracleReduction oSpec Stmt‚ÇÅ OStmt‚ÇÅ Wit‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ Wit‚ÇÇ pSpec‚ÇÅ)
    (R‚ÇÇ : OracleReduction oSpec Stmt‚ÇÇ OStmt‚ÇÇ Wit‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ Wit‚ÇÉ pSpec‚ÇÇ)
    (h‚ÇÅ : R‚ÇÅ.perfectCompleteness init impl rel‚ÇÅ rel‚ÇÇ)
    (h‚ÇÇ : R‚ÇÇ.perfectCompleteness init impl rel‚ÇÇ rel‚ÇÉ) :
      (R‚ÇÅ.append R‚ÇÇ).perfectCompleteness init impl rel‚ÇÅ rel‚ÇÉ

@[simp]
lemma inv_two_mul_two : 2‚Åª¬π * (2 : F) = 1

@[simp]
theorem leftpad_apply_lt (n : ‚Ñï) (a : Œ±) (v : Fin m ‚Üí Œ±) (i : Fin n)
    (h : i.val < n - m) : leftpad n a v i = a

@[simp] theorem join_nil : List.join ([] : List (List Œ±)) = []

@[simp, grind] lemma R_le_N : sz.R ‚â§ sz.N

theorem mul_two_eq_add {a : CNat 50} : a * 2 = a + a

@[simp]
theorem OracleSpec.append_range_right {Œπ‚ÇÅ Œπ‚ÇÇ : Type} {spec‚ÇÅ : OracleSpec Œπ‚ÇÅ} {spec‚ÇÇ : OracleSpec Œπ‚ÇÇ}
    (i : Œπ‚ÇÇ) : (spec‚ÇÅ ++‚Çí spec‚ÇÇ).range (Sum.inr i) = spec‚ÇÇ.range i

lemma bIdx_succ_mul_œë_le_‚Ñì_succ (bIdx : Fin (‚Ñì / œë - 1)) : (‚ÜëbIdx + 1) * œë ‚â§ ‚Ñì + 1

theorem changeOfBasisMatrix_det_ne_zero
  (‚Ñì : Nat) (h_‚Ñì : ‚Ñì ‚â§ r) :
  (changeOfBasisMatrix ùîΩq Œ≤ ‚Ñì h_‚Ñì).det ‚â† 0

theorem trim_equiv [LawfulBEq R] (p : UniPoly R) : equiv p.trim p

lemma vappend_left_of_lt {m n : ‚Ñï} {Œ± : Sort u}
    (u : Fin m ‚Üí Œ±) (v : Fin n ‚Üí Œ±) (i : Fin (m + n)) (h : i.val < m) :
      vappend u v i = u ‚ü®i, h‚ü©

theorem append_rbrKnowledgeSoundness
    (V‚ÇÅ : Verifier oSpec Stmt‚ÇÅ Stmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : Verifier oSpec Stmt‚ÇÇ Stmt‚ÇÉ pSpec‚ÇÇ)
    {rbrKnowledgeError‚ÇÅ : pSpec‚ÇÅ.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    {rbrKnowledgeError‚ÇÇ : pSpec‚ÇÇ.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    (h‚ÇÅ : V‚ÇÅ.rbrKnowledgeSoundness init impl rel‚ÇÅ rel‚ÇÇ rbrKnowledgeError‚ÇÅ)
    (h‚ÇÇ : V‚ÇÇ.rbrKnowledgeSoundness init impl rel‚ÇÇ rel‚ÇÉ rbrKnowledgeError‚ÇÇ) :
      (V‚ÇÅ.append V‚ÇÇ).rbrKnowledgeSoundness init impl rel‚ÇÅ rel‚ÇÉ
        (Sum.elim rbrKnowledgeError‚ÇÅ rbrKnowledgeError‚ÇÇ ‚àò ChallengeIdx.sumEquiv.symm)

@[simp]
theorem oracleReduction_perfectCompleteness (hInit : init.neverFails) :
    (oracleReduction oSpec Statement OStatement Witness).perfectCompleteness init impl rel rel

lemma nonDoomedFoldingProp_relay_preserved (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i)
    (challenges : Fin i.succ ‚Üí L)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j)
    :
    nonDoomedFoldingProp ùîΩq Œ≤ i.castSucc (Fin.init challenges) oStmt ‚Üî
    nonDoomedFoldingProp ùîΩq Œ≤ i.succ challenges (mapOStmtOutRelayStep ùîΩq Œ≤ i hNCR oStmt)

@[simp]
theorem insertNth_removeNth : insertNth p y (removeNth p t) = update t p y

theorem liftContext_processRound
    {lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    {i : Fin n}
    {P : Prover oSpec InnerStmtIn InnerWitIn InnerStmtOut InnerWitOut pSpec}
    {resultRound : OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí)
      (pSpec.Transcript i.castSucc √ó (P.liftContext lens).PrvState i.castSucc)} :
      (P.liftContext lens).processRound i resultRound
      = do
        let ‚ü®transcript, prvState, outerStmtIn, outerWitIn‚ü© ‚Üê resultRound
        let ‚ü®newTranscript, newPrvState‚ü© ‚Üê P.processRound i (do return ‚ü®transcript, prvState‚ü©)
        return ‚ü®newTranscript, ‚ü®newPrvState, outerStmtIn, outerWitIn‚ü©‚ü©

private lemma johnson_unrefined [Zero F]
  (h_n : 0 < n)
  (h_B : 2 ‚â§ B.card)
  (h_card : 2 ‚â§ (Fintype.card F))
  :
  (1 - e B 0 / n) ^ 2 * B.card + B.card * (e B 0) ^ 2 / ((Fintype.card F - 1) * n^2) - 1
  ‚â§
  (B.card - 1) * (1 - d B/n)

theorem matchSize_eq_iff_forall_eq (l‚ÇÅ l‚ÇÇ : List Œ±) (unit : Œ±) :
    (fun (x, y) => x = y) (matchSize l‚ÇÅ l‚ÇÇ unit) ‚Üî ‚àÄ i : Nat, l‚ÇÅ.getD i unit = l‚ÇÇ.getD i unit

Nat.succ_le_succ in Init.Prelude

lemma mul_by_2_def {s : Finset ‚Ñï} :
    mul_by_2 s = s.map ‚ü®fun n => 2 * n, by {
      intro a b
      simp
    }‚ü©

@[simp] lemma natCast_eq {k : ‚Ñï} (n : ‚Ñï) : (‚Üën : ConcreteBTField k) = natCast n

theorem append_comp {a : Fin m ‚Üí Œ±} {b : Fin n ‚Üí Œ±} (f : Œ± ‚Üí Œ≤) :
    append (f ‚àò a) (f ‚àò b) = f ‚àò append a b

lemma zipWith_const {Œ± Œ≤ : Type _} {f : Œ± ‚Üí Œ≤ ‚Üí Œ≤} {l‚ÇÅ : List Œ±} {l‚ÇÇ : List Œ≤}
  (h‚ÇÅ : l‚ÇÅ.length = l‚ÇÇ.length) (h‚ÇÇ : ‚àÄ a b, f a b = b) : l‚ÇÅ.zipWith f l‚ÇÇ = l‚ÇÇ

@[simp]
theorem generator_is_not_lifted_to_succ (k : ‚Ñï) :
  ‚àÄ x : ConcreteBTField k, canonicalAlgMap (k:=k) x ‚â† Z (k + 1)

lemma concrete_zero_mul0 (b : ConcreteBTField 0) :
  concrete_mul (zero (k:=0)) b = zero (k:=0)

@[simp]
lemma finite_possibleDeltas : (possibleDeltas U V).Finite

lemma add_assoc {k : ‚Ñï} : ‚àÄ (a b c : ConcreteBTField k), a + b + c = a + (b + c)

@[simp]
theorem ConcreteBTField.RingHom_eq_of_source_eq (k n m : ‚Ñï) (h_eq : k = n) :
    (ConcreteBTField k ‚Üí+* ConcreteBTField m)
    = (ConcreteBTField n ‚Üí+* ConcreteBTField m)

@[simp]
theorem FullData.getRootValue_leaf {Œ±} (a : Œ±) :
    (FullData.leaf a).getRootValue = a

Nat.pred_lt_self in Init.Data.Nat.Basic

@[simp]
theorem minPoly_of_powerBasisSucc_generator (k : ‚Ñï) :
  (minpoly (ConcreteBTField k) (powerBasisSucc k).gen) = X^2 + (Z k) ‚Ä¢ X + 1

lemma split_algebraMap_eq_zero_x {k : ‚Ñï} (h_pos : k > 0) (x : ConcreteBTField (k - 1)) :
  letI instAlgebra := ConcreteBTFieldAlgebra (l:=k-1) (r:=k) (h_le:=by omega)
  split h_pos (algebraMap (ConcreteBTField (k - 1)) (ConcreteBTField k) x) = (0, x)

Nat.zero_add in Init.Data.Nat.Basic

@[simp] theorem BitVec.dcast_one {n m : ‚Ñï} (h : n = m) : DCast.dcast h (1#n) = 1#m

@[simp]
theorem Basis_cast_index_apply {Œ± Œ≤ i j : ‚Ñï} {k : Fin j}
    (h_le : Œ± ‚â§ Œ≤) (h_eq : i = j)
    {b : @Basis (Fin (i)) (ConcreteBTField Œ±) (ConcreteBTField Œ≤) _ _
      (@ConcreteBTFieldAlgebra (l := Œ±) (r := Œ≤) (h_le := h_le)).toModule} :
  let castBasis : @Basis (Fin j) (ConcreteBTField Œ±) (ConcreteBTField Œ≤) _ _
    (@ConcreteBTFieldAlgebra (l:=Œ±) (r:=Œ≤) (h_le:=h_le)).toModule :=
    cast (by exact Basis_cast_index_eq i j Œ± Œ≤ h_le h_eq) b
  (castBasis k) = b (Fin.cast (h_eq.symm) k)

@[simp]
protected lemma elocPoly_leading_coeff_one : (ElocPoly n œâs f p).leadingCoeff = 1

omit [NoZeroDivisors ùîΩ] in
lemma splitNth_degree_le {n : ‚Ñï} {f : ùîΩ[X]} [inst : NeZero n] :
  ‚àÄ {i}, (splitNth f n i).natDegree ‚â§ f.natDegree / n

theorem zipWith_cons {Œ± Œ≤ Œ≥} {n : ‚Ñï} (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥)
    (a : Œ±) (b : Vector Œ± n) (c : Œ≤) (d : Vector Œ≤ n) :
    zipWith f (cons a b) (cons c d) = cons (f a c) (zipWith f b d)

@[simp]
theorem bool_accepts_iff_of_domain [IsDomain ùì°] :
    (bool j).accepts x ‚Üî x j = 0 ‚à® x j = 1

@[simp]
lemma ofPolynomialAlgHom_toPolynomialAlgHom_C {r : R} :
    ofPolynomialAlgHom (toPolynomialAlgHom (C r : P)) = (Polynomial.C r : R[X])

@[simp]
lemma degree_polynomialOfCoeffs_deg_lt_deg :
  (polynomialOfCoeffs coeffs).degree < deg

omit [Finite F] in
@[simp]
lemma range_lem‚ÇÅ {i : Fin (k + 1)} :
    [FinalOracleStatement D x s]‚Çí.range ‚ü®i.1, Nat.lt_succ_of_lt i.2‚ü© = F

theorem MLE_expanded (evals : (œÉ ‚Üí Fin 2) ‚Üí R) : MLE evals =
    ‚àë x : œÉ ‚Üí Fin 2, (‚àè i : œÉ, ((1 - C (x i : R)) * (1 - X i) + C (x i : R) * X i))
      * C (evals x)

lemma concrete_mul_left_distrib
  {h_k : k > 0} (prevBTFieldProps : ConcreteBTFieldProps (k := k - 1))
  (a b c : ConcreteBTField k) :
    concrete_mul a (b + c) = concrete_mul a b + concrete_mul a c

theorem take_drop_eq_drop_take (m‚ÇÅ m‚ÇÇ : ‚Ñï) (h‚ÇÅ : m‚ÇÅ ‚â§ m‚ÇÇ) (h‚ÇÇ : m‚ÇÇ ‚â§ n) (v : (i : Fin n) ‚Üí Œ± i) :
    take (m‚ÇÇ - m‚ÇÅ) (by omega) (drop m‚ÇÅ (by omega) v) =
      drop m‚ÇÅ (by omega) (take m‚ÇÇ h‚ÇÇ v)

theorem add_coeff? (p q : UniPoly Q) (i : ‚Ñï) :
  (add_raw p q).coeff i = p.coeff i + q.coeff i

@[simp]
theorem Prover.run_of_prover_first [ProverOnly pSpec] (stmt : StmtIn) (wit : WitIn)
    (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      prover.run stmt wit = (do
        let state := prover.input (stmt, wit)
        let ‚ü®msg, state‚ü© ‚Üê liftComp (prover.sendMessage ‚ü®0, by simp‚ü© state) _
        let ctxOut ‚Üê prover.output state
        return ((fun i => match i with | ‚ü®0, _‚ü© => msg), ctxOut))

theorem drop_append_right {n' : ‚Ñï} {Œ± : Sort*} (m : ‚Ñï) (h : m ‚â§ n') (u : (i : Fin n) ‚Üí Œ±)
    (v : (i : Fin n') ‚Üí Œ±) :
      drop (n + m) (Nat.add_le_add_left h n) (append u v) =
        fun i => (drop m h v (i.cast (by omega)))

protected lemma johnson_bound_lemma [Field F] {v : Fin n ‚Üí F}
  (h_n : 0 < n)
  (h_B : 2 ‚â§ B.card)
  (h_card : 2 ‚â§ (Fintype.card F))
  :
  B.card *
    ((1 - ((Fintype.card F : ‚Ñö) / (Fintype.card F - 1)) * (e B v / n)) ^ 2
      - (1 - ((Fintype.card F : ‚Ñö) / (Fintype.card F - 1)) * (d B/n)))  ‚â§
  ((Fintype.card F : ‚Ñö) / (Fintype.card F - 1)) * d B/n

theorem and_highBits_lowBits_eq_zero {n : ‚Ñï} (numLowBits : ‚Ñï) :
    getHighBits numLowBits n &&& getLowBits numLowBits n = 0

theorem completeness_error_mono {Œµ‚ÇÅ Œµ‚ÇÇ : ‚Ñù‚â•0} (hŒµ : Œµ‚ÇÅ ‚â§ Œµ‚ÇÇ) :
      completeness init impl relIn relOut reduction Œµ‚ÇÅ ‚Üí
        completeness init impl relIn relOut reduction Œµ‚ÇÇ

private lemma sum_choose_K' [Zero F]
  (h_card : 2 ‚â§ (Fintype.card F))
  :
  (Fintype.card (Œ± := F) - 1) * choose_2 ((B.card - K B i 0) / (Fintype.card (Œ± := F) - 1)) ‚â§
  ‚àë (Œ± : F) with Œ± ‚â† 0, choose_2 (K B i Œ±)

@[simp]
theorem runWithOracle_failure (f : spec.FunctionType) :
    runWithOracle f (failure : OracleComp spec Œ±) = none

lemma natDegree_lt_of_mem_degreeLT [NeZero deg] (h : p ‚àà degreeLT F deg) : p.natDegree < deg

@[to_additive vsum_castSucc]
lemma vprod_castSucc [CommMonoid Œ±] {a : Fin (n + 1) ‚Üí Œ±} :
    vprod a = vprod (a ‚àò Fin.castSucc) * a (last n)

theorem vext_iff {v w : Fin n ‚Üí Œ±} : v = w ‚Üî ‚àÄ i, v i = w i

theorem findIdxRev?_emtpy_none {cond} {as : Array Œ±} (h : as = #[]) :
  findIdxRev? cond as = none

theorem sum_square_char2 {F : Type*} [Field F] (sumZeroIffEq : ‚àÄ (x y : F), x + y = 0 ‚Üî x = y)
  (s : Finset ‚Ñï) (f : ‚Ñï ‚Üí F) : (‚àë j ‚àà s, f j)^2 = ‚àë j ‚àà s, (f j)^2

@[simp]
protected lemma elocPoly_succ :
  ElocPoly (n + 1) œâs f p =
  ElocPoly n œâs f p *
    if f n = p.eval (œâs n)
    then 1
    else X - C (œâs n)

@[simp]
theorem cast_completeness (Œµ : ‚Ñù‚â•0) (hComplete : R.completeness init impl relIn relOut Œµ) :
    (R.cast hn hSpec hO‚Çò).completeness init impl relIn relOut Œµ

lemma towerRingHomForwardMap_zero {k : ‚Ñï} :
  (towerRingHomForwardMap k) 0 = 0

@[simp]
theorem BTField_0_is_GF_2 : (BTField 0) = (GF(2))

theorem vappend_right_eq_snoc (u : Fin m ‚Üí Œ±) (a : Fin 1 ‚Üí Œ±) :
    vappend u a = vconcat u (a 0)

lemma getBit_of_shiftRight {n p : ‚Ñï}:
  ‚àÄ k, getBit k (n >>> p) = getBit (k+p) n

theorem simulateQ_bind_fst_comp (oa : OracleComp spec Œ±) (f : Œ± ‚Üí OracleComp spec Œ≤) :
    (do let a ‚Üê (simulateQ loggingOracle oa).run; f a.1) = (do let a ‚Üê oa; f a)

omit [DecidableEq L] [DecidableEq ùîΩq] h_Fq_char_prime hF‚ÇÇ hŒ≤_lin_indep h_Œ≤‚ÇÄ_eq_1 in
theorem intermediateNormVpoly_comp (i : Fin ‚Ñì) (k : Fin (‚Ñì - i + 1))
  (l : Fin (‚Ñì - (i.val + k.val) + 1)) :
  intermediateNormVpoly ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i, by omega‚ü©) (k:=‚ü®k + l, by
      simp only; omega‚ü©) =
    (intermediateNormVpoly ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i+k, by omega‚ü©) (k:=‚ü®l, by
      simp only; omega‚ü©)).comp (
  intermediateNormVpoly ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i, by omega‚ü©) (k:=‚ü®k, by
      simp only; omega‚ü©)
  )

@[to_additive (attr := simp) vsum_succ]
lemma vprod_succ [CommMonoid Œ±] {a : Fin (n + 1) ‚Üí Œ±} : vprod a = a 0 * vprod (a ‚àò Fin.succ)

lemma forwardRange_eq_of_r_eq (n : ‚Ñï) (r1 r2 : Fin n) (h_r_eq : r1 = r2) (l : Fin (r1.val + 1)) :
  forwardRange n r1 l = forwardRange n r2 ‚ü®l, by omega‚ü©

@[grind =] theorem idxOf'_cons [BEq Œ±] {a : Œ±} {x : Œ±} {xs : List Œ±} :
    idxOf' a (x :: xs) = bif x == a then 0 else idxOf' a xs + 1

theorem one_mul (n : ChurchNat Œ±) : mul one n = n

@[simp]
lemma seqCompose_succ {m : ‚Ñï}
    (Stmt : Fin (m + 2) ‚Üí Type)
    {Œπ‚Çõ : Fin (m + 2) ‚Üí Type} (OStmt : (i : Fin (m + 2)) ‚Üí Œπ‚Çõ i ‚Üí Type)
    [O‚Çõ : ‚àÄ i, ‚àÄ j, OracleInterface (OStmt i j)]
    {n : Fin (m + 1) ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    [O‚Çò : ‚àÄ i, ‚àÄ j, OracleInterface ((pSpec i).Message j)]
    (V : (i : Fin (m + 1)) ‚Üí OracleVerifier oSpec
      (Stmt i.castSucc) (OStmt i.castSucc) (Stmt i.succ) (OStmt i.succ) (pSpec i)) :
    seqCompose Stmt OStmt V =
      append (V 0) (seqCompose (Stmt ‚àò Fin.succ) (fun i => OStmt (Fin.succ i))
        (O‚Çõ := fun i => O‚Çõ (Fin.succ i)) (O‚Çò := fun i => O‚Çò (Fin.succ i))
          (fun i => V (Fin.succ i)))

lemma farness_implies_non_compliance (i : Fin ‚Ñì) (steps : ‚Ñï) [NeZero steps]
  (h_i_add_steps : i + steps ‚â§ ‚Ñì)
  (f_i : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i, by omega‚ü©)
  (f_i_plus_steps : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
    ‚ü®i + steps, by omega‚ü©)
  (challenges : Fin steps ‚Üí L)
  (h_far : 2 * Code.distFromCode f_i
      (BBF_Code ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i, by omega‚ü©)
    ‚â• (BBF_CodeDistance ‚Ñì ùì° ‚ü®i, by omega‚ü© : ‚Ñï‚àû)) :
  ¬¨ isCompliant ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := i) (steps := steps)
    h_i_add_steps f_i f_i_plus_steps challenges

@[simp]
lemma append_zero_of_succ_left {u : Fin (m + 1) ‚Üí Œ±} {v : Fin n ‚Üí Œ±} :
    (append u v) 0 = u 0

@[simp]
lemma coeff_polynomialOfCoeffs_eq_coeffs'' :
  (polynomialOfCoeffs coeffs).coeff = Fin.liftF coeffs

lemma generalised_round_consistency_completeness
  {ùîΩ : Type} [inst1 : Field ùîΩ] [DecidableEq ùîΩ] {f : Polynomial ùîΩ}
  {n : ‚Ñï} [inst : NeZero n]
  {Œ≥ : ùîΩ}
  {s‚ÇÄ : ùîΩ}
  {œâ : Fin n ‚Ü™ ùîΩ}
  (h : ‚àÄ i, (œâ i) ^ n = 1)
  (h‚ÇÅ : s‚ÇÄ ‚â† 0)
  :
    roundConsistencyCheck
      Œ≥
      (List.map (fun i => (œâ i * s‚ÇÄ, f.eval (œâ i * s‚ÇÄ))) (List.finRange n))
      ((foldNth n f Œ≥).eval (s‚ÇÄ^n)) = true

theorem BitVec.bitvec_cast_eq_dcast {n m : Nat} (h : n = m) (bv : BitVec n) :
  BitVec.cast h bv = DCast.dcast h bv

theorem commit_eq {a : ZMod p} (hpG1 : Nat.card G‚ÇÅ = p)
    (poly : degreeLT (ZMod p) (n + 1)) :
    commit (towerOfExponents g‚ÇÅ a n) (degreeLTEquiv _ _ poly) = g‚ÇÅ ^ (poly.1.eval a).val

lemma sub_descends [LawfulBEq R] (a‚ÇÅ b‚ÇÅ a‚ÇÇ b‚ÇÇ : UniPoly R) :
  equiv a‚ÇÅ a‚ÇÇ ‚Üí equiv b‚ÇÅ b‚ÇÇ ‚Üí sub_descending a‚ÇÅ b‚ÇÅ = sub_descending a‚ÇÇ b‚ÇÇ

@[simp]
theorem Set.not_mem_language_iff {Œ± Œ≤} (rel : Set (Œ± √ó Œ≤)) (stmt : Œ±) :
    stmt ‚àâ rel.language ‚Üî ‚àÄ wit, (stmt, wit) ‚àâ rel

@[simp]
lemma Rhs_zero_eq_neg' : Rhs 0 œâs f = -f

theorem multilinearBasis_apply (r : ‚Ñï) : ‚àÄ l : ‚Ñï, (h_le : l ‚â§ r) ‚Üí ‚àÄ (j : Fin (2  ^ (r - l))),
  multilinearBasis (l:=l) (r:=r) (h_le:=h_le) j =
    (Finset.univ : Finset (Fin (r - l))).prod (fun i =>
      (binaryAlgebraTower (l:=l + i + 1) (r:=r) (h_le:=by omega)).algebraMap (
        (ùïè (l + i)) ^ (Nat.getBit i j)))

Nat.two_pow_pos in Init.Data.Nat.Basic

theorem folding_listdecoding_if_genMutualCorrAgreement
  {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F} [Smooth œÜ] {k m : ‚Ñï}
  {S' : Finset (indexPowT S œÜ 0)} {œÜ' : (indexPowT S œÜ 0) ‚Ü™ F}
  [‚àÄ i : ‚Ñï, Fintype (indexPowT S œÜ i)] [DecidableEq (indexPowT S œÜ 0)] [Smooth œÜ']
  [h : ‚àÄ {f : (indexPowT S œÜ 0) ‚Üí F}, DecidableBlockDisagreement 0 k f S' œÜ']
  [‚àÄ i : ‚Ñï, Neg (indexPowT S œÜ i)]
  {C : Set ((indexPowT S œÜ 0) ‚Üí F)} (hcode : C = smoothCode œÜ' m) (hLe : k ‚â§ m)
  {Œ¥ : ‚Ñù‚â•0}
  {params : GenMutualCorrParams S œÜ k} :

  -- necessary typeclasses of underlying domain (Œπ·µ¢)^2 ≤ regarding finiteness,
  -- non-emptiness and smoothness
    let _ : ‚àÄ j : Fin (k + 1), Fintype (indexPowT S œÜ j) := params.inst1
    let _ : ‚àÄ j : Fin (k + 1), Nonempty (indexPowT S œÜ j) := params.inst2

    Pr_{let Œ±s ‚Üê$·µñ (Fin k ‚Üí F)}[ -- for every function `f : Œπ ‚Üí F` and
                      ‚àÄ (f : (indexPowT S œÜ 0) ‚Üí F),
                      -- `hŒ¥Le` : `Œ¥ ‚àà (0, max_{j ‚àà [0,k]} BStar(C‚±º, par‚Ñì = 2))`
                       (0 < Œ¥ ‚àß Œ¥ < 1 - Finset.univ.sup
                        (fun j => params.BStar j (params.Gen_Œ± j).C (params.Gen_Œ± j).par‚Ñì)) ‚Üí

                      let listBlock : Set ((indexPowT S œÜ 0) ‚Üí F) := Œõ·µ£(0, k, f, S', C, hcode, Œ¥)
                      let fold := fold_k f Œ±s hLe
                      let foldSet := fold_k_set listBlock Œ±s hLe
                      let kFin : Fin (k + 1) := ‚ü®k, Nat.lt_succ_self k‚ü©
                      let C‚Çñ := (params.Gen_Œ± kFin).C
                      let listHamming := relHammingBall C‚Çñ fold Œ¥

                      foldSet ‚â† listHamming
                    ] < (‚àë i : Fin (k + 1),
                          params.errStar i (params.Gen_Œ± i).C (params.Gen_Œ± i).par‚Ñì Œ¥)

lemma List.prod_finRange_eq_finset_prod {M : Type*} [CommMonoid M] {n : ‚Ñï} (f : Fin n ‚Üí M) :
    ((List.finRange n).map f).prod = ‚àè i : Fin n, f i

@[simp]
theorem cast_dir_idx_symm {hn} (hSpec : pSpec‚ÇÅ.cast hn = pSpec‚ÇÇ) {i : Fin n‚ÇÇ} :
    pSpec‚ÇÅ.dir (Fin.cast hn.symm i) = pSpec‚ÇÇ.dir i

lemma getBit_of_two_pow_sub_one {i k: ‚Ñï} : getBit k (2^i - 1) =
    if k < i then 1 else 0

@[simp]
theorem reduction_completeness (h : init.neverFails) [Nonempty œÉ] :
    (reduction oSpec Statement pred).perfectCompleteness init impl
    (relIn Statement pred) (relOut Statement)

@[simp]
theorem vcons_one (a : Œ±) (v : Fin (n + 1) ‚Üí Œ±) : (a ::·µõ v) 1 = v 0

@[simp]
theorem rtake_self' {Œ± : Sort*} (v : Fin n ‚Üí Œ±) : rtake n (by omega) v = v

omit [Finite F] in
lemma sqr_mem_D_succ_i_of_mem_D_i : ‚àÄ {x : FÀ£} {i : ‚Ñï},
  x ‚àà evalDomain D i ‚Üí x ^ 2 ‚àà evalDomain D (i + 1)

theorem ext_vcons (a b : Œ±) (v w : Fin n ‚Üí Œ±) : vcons a v = vcons b w ‚Üî a = b ‚àß v = w

omit hF‚ÇÇ in
theorem kernel_normalizedW_eq_U (i : Fin r) :
    LinearMap.ker (polyEvalLinearMap (normalizedW ùîΩq Œ≤ i)
    (normalizedW_is_additive ùîΩq Œ≤ i))
    = U ùîΩq Œ≤ i

theorem split_sum_eq_sum_split {k : ‚Ñï} (h_pos : k > 0) (x‚ÇÄ x‚ÇÅ : ConcreteBTField k)
  (hi‚ÇÄ lo‚ÇÄ hi‚ÇÅ lo‚ÇÅ : ConcreteBTField (k - 1))
  (h_split_x‚ÇÄ : split h_pos x‚ÇÄ = (hi‚ÇÄ, lo‚ÇÄ))
  (h_split_x‚ÇÅ : split h_pos x‚ÇÅ = (hi‚ÇÅ, lo‚ÇÅ)) :
  split h_pos (x‚ÇÄ + x‚ÇÅ) = (hi‚ÇÄ + hi‚ÇÅ, lo‚ÇÄ + lo‚ÇÅ)

@[csimp] lemma dfoldl_eq_dfoldl' : @dfoldl = @dfoldl'

lemma bIdx_succ_mul_œë_lt_‚Ñì_succ (bIdx : Fin (‚Ñì / œë - 1)) :
    (‚ÜëbIdx + 1) * œë < ‚Ñì + 1

theorem leftpad_toList {a : Array Œ±} {n : Nat} {unit : Œ±} :
    a.leftpad n unit = mk (a.toList.leftpad n unit)

lemma qMap_total_fiber_basis_sum_repr (i : Fin ‚Ñì) (steps : ‚Ñï) (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
    (y : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) (i := ‚ü®i + steps, by omega‚ü©))
    (k : Fin (2 ^ steps)) :
    let x : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i, by omega‚ü©) := qMap_total_fiber ùîΩq Œ≤
      (i := ‚ü®i, by omega‚ü©) (steps := steps) (h_i_add_steps := by
        apply Nat.lt_add_of_pos_right_of_le; omega) (y := y) (k)
    let basis_x := sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i, by omega‚ü©
      (by simp only; apply Nat.lt_add_of_pos_right_of_le; omega)
    let basis_y := sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i + steps, by omega‚ü©
      (h_i := by apply Nat.lt_add_of_pos_right_of_le; omega)
    let y_coeffs := basis_y.repr y
    x = ‚àë j : Fin (‚Ñì + ùì° - i), (
      fiber_coeff (i := i) (steps := steps) (j := j) (elementIdx := k) (y_coeffs := y_coeffs)
    ) ‚Ä¢ (basis_x j)

lemma towerRingHomForwardMap_one {k : ‚Ñï} :
  (towerRingHomForwardMap k) 1 = 1

@[grind]
lemma degreeY_le_degreeY_sub_degreeY [IsDomain F] {f q : F[X][Y]} (hf : f ‚â† 0) (hg : q * f ‚â† 0) :
  natDegreeY q ‚â§ natDegreeY (q * f) - natDegreeY f

@[simp]
theorem fflatten‚ÇÇ_splitSum {A : Sort u} {B : Sort v} {F : A ‚Üí B ‚Üí Sort w} {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï}
    {Œ± : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí A}
    {Œ≤ : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí B}
    (v : (k : Fin (vsum n)) ‚Üí F (vflatten Œ± k) (vflatten Œ≤ k)) (k : Fin (vsum n)) :
    fflatten‚ÇÇ (fun i j => v (embedSum i j)) k = cast (by simp) (v k)

theorem liftContext_rbr_knowledgeSoundness [Inhabited InnerStmtOut] [Inhabited InnerWitIn]
    {outerRelIn : Set (OuterStmtIn √ó OuterWitIn)} {outerRelOut : Set (OuterStmtOut √ó OuterWitOut)}
    {innerRelIn : Set (InnerStmtIn √ó InnerWitIn)} {innerRelOut : Set (InnerStmtOut √ó InnerWitOut)}
    {rbrKnowledgeError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    {stmtLens : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut}
    {witLens : Witness.InvLens OuterStmtIn OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    (V : Verifier oSpec InnerStmtIn InnerStmtOut pSpec)
    [lensKS : Extractor.Lens.IsKnowledgeSound outerRelIn innerRelIn outerRelOut innerRelOut
      (V.compatStatement stmtLens) (fun _ _ => True) ‚ü®stmtLens, witLens‚ü©]
    (h : V.rbrKnowledgeSoundness init impl innerRelIn innerRelOut rbrKnowledgeError) :
      (V.liftContext stmtLens).rbrKnowledgeSoundness init impl outerRelIn outerRelOut
        rbrKnowledgeError

@[simp]
theorem addCases'_right {m n : ‚Ñï} {Œ± : Fin m ‚Üí Sort u} {Œ≤ : Fin n ‚Üí Sort u}
    (left : (i : Fin m) ‚Üí Œ± i) (right : (j : Fin n) ‚Üí Œ≤ j) (i : Fin n) :
      addCases' left right (Fin.natAdd m i) = (Fin.append_right Œ± Œ≤ i) ‚ñ∏ (right i)

lemma getMiddleBits_lt_two_pow {n offset len : ‚Ñï} :
  getMiddleBits offset len n < 2 ^ len

@[simp]
lemma ofPolynomialAlgHom_X : ofPolynomialAlgHom (Polynomial.X : R[X]) = (X : P)

theorem mul_one {a : CNat 50} : a * 1 = a

theorem vcons_right_injective (a : Œ±) :
    Function.Injective (vcons a : (Fin n ‚Üí Œ±) ‚Üí Fin (n + 1) ‚Üí Œ±)

@[simp]
theorem cast_idx_symm {i : MessageIdx pSpec‚ÇÇ} :
    pSpec‚ÇÅ.Message (i.cast hn.symm (cast_symm hSpec)) = pSpec‚ÇÇ.Message i

Nat.le_add_left in Init.Data.Nat.Basic

lemma getMiddleBits_eq_mod {n offset len : ‚Ñï} :
  getMiddleBits offset len n = (n >>> offset) % (2 ^ len)

@[simp]
theorem fflatten‚ÇÇ_embedSum {A : Sort u} {B : Sort v} {F : A ‚Üí B ‚Üí Sort w} {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï}
    {Œ± : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí A}
    {Œ≤ : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí B}
    (v : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí F (Œ± i j) (Œ≤ i j)) (i : Fin m) (j : Fin (n i)) :
    fflatten‚ÇÇ v (embedSum i j) = cast (by simp) (v i j)

Nat.lt_of_le_of_lt in Init.Prelude

@[simp]
theorem rightpad_apply_lt (n : ‚Ñï) (a : Œ±) (v : Fin m ‚Üí Œ±) (i : Fin n)
    (h : i.val < m) : rightpad n a v i = v ‚ü®i.val, h‚ü©

lemma getBit_of_sub_two_pow_of_bit_1 {n i j: ‚Ñï} (h_getBit_eq_1: getBit i n = 1) :
  getBit j (n - 2^i) = (if j = i then 0 else getBit j n)

theorem mca_capacity_bound_CONJECTURE
  [DecidableEq Œπ]
  (Œ± : F) (œÜ : Œπ ‚Ü™ F) (m : ‚Ñï) [Smooth œÜ]
  (par‚Ñì_type : Type) [Fintype par‚Ñì_type] (exp : par‚Ñì_type ‚Ü™ ‚Ñï) :
  let Gen := RSGenerator.genRSC par‚Ñì_type œÜ m exp
  let : Fintype Gen.par‚Ñì := Gen.h‚Ñì
  haveI := Gen.Gen_nonempty
  ‚àÉ (c‚ÇÅ c‚ÇÇ : ‚Ñï),
    ‚àÄ (f : Gen.par‚Ñì ‚Üí Œπ ‚Üí F) (Œ∑ : ‚Ñù) (_hŒ∑ : 0 < Œ∑) (Œ¥ : ‚Ñù‚â•0)
      (_hŒ¥ : 0 < Œ¥ ‚àß Œ¥ < 1 - Gen.rate - Œ∑),
      Pr_{let r ‚Üê$·µñ Gen.Gen}[ proximityCondition f Œ¥ r Gen.C ] ‚â§
        ENNReal.ofReal (
          (((Fintype.card par‚Ñì_type - 1) : ‚Ñù)^c‚ÇÇ * ((2^m) : ‚Ñù)^c‚ÇÇ) /
          (Œ∑^c‚ÇÅ * Gen.rate^(c‚ÇÅ+c‚ÇÇ) * (Fintype.card F))
        )

@[simp]
theorem induction_two {motive : Fin 3 ‚Üí Sort*} {zero : motive 0}
    {succ : ‚àÄ i : Fin 2, motive i.castSucc ‚Üí motive i.succ} :
      induction (motive := motive) zero succ (last 2) = succ 1 (succ 0 zero)

theorem is_prime : Nat.Prime fieldSize

lemma Œæ_regular (x‚ÇÄ : F) (R : F[X][X][Y]) (H : F[X][Y]) [H_irreducible : Fact (Irreducible H)] :
  ‚àÉ pre : ùí™ H,
    let d := R.natDegree
    let W : ùïÉ H := liftToFunctionField (H.leadingCoeff);
    embeddingOfùí™IntoùïÉ _ pre = W ^ (d - 2) * Œ∂ R x‚ÇÄ H

lemma towerAlgebraMap_succ (l r : ‚Ñï) (h_le : l ‚â§ r) :
  towerAlgebraMap (l:=l) (r:=r+1) (h_le:=by omega) =
  (towerAlgebraMap (l:=r) (r:=r+1) (h_le:=by omega)).comp
  (towerAlgebraMap (l:=l) (r:=r) (h_le:=by omega))

private lemma sum_K_eq_card : ‚àë (Œ± : F), K B i Œ± = B.card

theorem split_bitvec_eq_iff_fromNat {k : ‚Ñï} (h_pos : k > 0) (x : ConcreteBTField k)
  (hi_btf lo_btf : ConcreteBTField (k - 1)) :
  split h_pos x = (hi_btf, lo_btf) ‚Üî
  (hi_btf = fromNat (k:=k - 1) (x.toNat >>> 2 ^ (k - 1)) ‚àß
  lo_btf = fromNat (k:=k - 1) (x.toNat &&& (2 ^ (2 ^ (k - 1)) - 1)))

theorem verifier_rbrKnowledgeSoundness [Fintype R] :
    (verifier R deg D oSpec).rbrKnowledgeSoundness init impl
    (inputRelation R deg D) (outputRelation R deg) (fun _ => (deg : ‚Ñù‚â•0) / (Fintype.card R))

lemma oddPart_even {f : Polynomial F} :
    EvenPoly (oddPart f)

theorem succ'_ne_zero (n : Nat) : succ' n ‚â† 0

@[simp]
theorem BTField.RingHom_comp_cast {Œ± Œ≤ Œ≥ Œ¥ : ‚Ñï} (f : BTField Œ± ‚Üí+* BTField Œ≤)
  (g : BTField Œ≤ ‚Üí+* BTField Œ≥) (h : Œ≥ = Œ¥) :
    ((cast (BTField.RingHom_eq_of_dest_eq (k:=Œ≤) (m:=Œ≥) (n:=Œ¥) h) g).comp f)
    = cast (BTField.RingHom_eq_of_dest_eq (k:=Œ±) (m:=Œ≥) (n:=Œ¥) h) (g.comp f)

@[simp] theorem add_zero {a : AssocNat} : a + 0 = a

lemma eval_solutionToQ_cast {x : F} (h : e = 0) :
  eval x (solutionToQ e k v) = ‚àë i ‚àà Finset.range k, liftF v i * x ^ i

lemma subUpFull_of_vandermonde_is_vandermonde (h : n ‚â§ m) :
  Matrix.vandermonde (Œ± ‚àò Fin.castLE h) =
  Matrix.subUpFull (nonsquare n Œ±) (Fin.castLE h)

@[simp] theorem toNat_succ (t : AssocNat) : toNat (succ t) = (toNat t).succ

theorem cast_eq_dcast‚ÇÇ {hn} {hSpec : pSpec‚ÇÅ.cast hn = pSpec‚ÇÇ} {i : MessageIdx pSpec‚ÇÅ}:
    i.cast hn hSpec = dcast‚ÇÇ hn hSpec i

@[simp] theorem BitVec.dcast_zero {n m : ‚Ñï} (h : n = m) : DCast.dcast h (0#n) = 0#m

@[simp]
theorem vconcat_last (v : Fin n ‚Üí Œ±) (a : Œ±) : vconcat v a (Fin.last n) = a

lemma towerRingHomForwardMap_backwardMap_eq (k : ‚Ñï) (x : BTField k) :
  towerRingHomForwardMap (k:=k) (towerRingHomBackwardMap (k:=k) x) = x

@[simp]
theorem acceptRejectOracleRel_language :
    acceptRejectOracleRel.language = { (true, isEmptyElim) }

lemma oddPart_def :
  oddPart f =
  C (2‚Åª¬π : F) * (f - f.comp (-X)) /‚Çò X

theorem fullOracleReduction_perfectCompleteness (hInit : init.neverFails) :
  OracleReduction.perfectCompleteness
    (oracleReduction := fullOracleReduction ùîΩq Œ≤ Œ≥_repetitions (œë:=œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë))
    (relIn := roundRelation (mp := BBF_SumcheckMultiplierParam) ùîΩq Œ≤ (œë:=œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) 0)
    (relOut := acceptRejectOracleRel)
    (init := init)
    (impl := impl)

theorem findIdxRev?_eq_none {cond} {as : Array Œ±} (h : ‚àÄ i, (hi : i < as.size) ‚Üí ¬¨ cond as[i]) :
  findIdxRev? cond as = none

lemma geometric_sum_units {F : Type*} [Field F] [DecidableEq F] {r : FÀ£} {a : ‚Ñï} :
  ‚àë j ‚àà range (a + 1), (r ^ j : F) =
    if r = 1 then (a + 1 : F)
    else (1 - r ^ (a + 1)) / (1 - r)

theorem finSuccEquivNth_coeff_coeff (m : Fin n ‚Üí‚ÇÄ ‚Ñï) (f : MvPolynomial (Fin (n + 1)) R) (i : ‚Ñï) :
    coeff m (Polynomial.coeff (finSuccEquivNth R p f) i) = coeff (m.insertNth p i) f

theorem vconcat_injective2 : Function.Injective2 (@vconcat Œ± n)

theorem not_exists_of_decoder_eq_none {e k : ‚Ñï} [NeZero n] {œâs f : Fin n ‚Üí F}
  (he : 2 * e < n - k + 1)
  (hn : k ‚â§ n)
  (h_inj : Function.Injective œâs)
  (h_none : decoder e k œâs f = none)
  : ¬¨‚àÉp : F[X], Œî‚ÇÄ(f, p.eval ‚àò œâs) ‚â§ e ‚àß p.natDegree < k

theorem finSuccEquivNth_comp_C_eq_C :
    (‚Üë(finSuccEquivNth R p).symm : Polynomial (MvPolynomial (Fin n) R) ‚Üí+* _).comp
        (Polynomial.C.comp C) = (C : R ‚Üí+* MvPolynomial (Fin n.succ) R)

@[simp]
theorem BTField.PowerBasis.dim_of_eq_rec
    (r1 r : ‚Ñï)
    (h_r : r = r1 + 1)
    (b : PowerBasis (BTField r1) (BTField (r1 + 1))) :
    letI instAlgebra : Algebra (BTField r1) (BTField r) :=
      binaryAlgebraTower (l:=r1) (r:=r) (h_le:=by omega)
    ((Eq.rec (motive:=fun (x : ‚Ñï) (_ : r1 + 1 = x) => by
      letI instAlgebraCur : Algebra (BTField r1) (BTField x) :=
        binaryAlgebraTower (l:=r1) (r:=x) (h_le:=by omega)
      exact PowerBasis (BTField r1) (BTField x)) (refl:=b) (t:=h_r.symm)) :
        PowerBasis (BTField r1) (BTField r)).dim
    = b.dim

theorem add_succ (m n : ChurchNat Œ±) : add (succ m) n = succ (add m n)

lemma liftF'_liftF_of_lt {k : Fin m} (h : k < n) :
  liftF' (n := m) (liftF (n := n) f') k = f' ‚ü®k, by omega‚ü©

theorem happend_assoc {Œ± : Fin m ‚Üí Sort u} {Œ≤ : Fin n ‚Üí Sort u} {p : ‚Ñï} {Œ≥ : Fin p ‚Üí Sort u}
    (u : (i : Fin m) ‚Üí Œ± i) (v : (i : Fin n) ‚Üí Œ≤ i) (w : (i : Fin p) ‚Üí Œ≥ i) :
    happend (happend u v) w =
      fun i => cast (by simp [vappend_assoc])
        (happend u (happend v w) (i.cast (by omega)))

@[simp]
lemma blockIdx_mul_œë_lt_‚Ñì_succ (i : Fin (‚Ñì / œë - 1 + 1)) : ‚Üëi * œë < ‚Ñì + 1

theorem hcons_eq_hcons_iff {Œ≤ : Fin n ‚Üí Sort u} (a‚ÇÅ a‚ÇÇ : Œ±) (v‚ÇÅ v‚ÇÇ : (i : Fin n) ‚Üí Œ≤ i) :
    hcons a‚ÇÅ v‚ÇÅ = hcons a‚ÇÇ v‚ÇÇ ‚Üî a‚ÇÅ = a‚ÇÇ ‚àß v‚ÇÅ = v‚ÇÇ

private lemma le_sum_sum_choose_K [Zero F]
  (h_n : 0 < n)
  (h_B : B.card ‚â† 0)
  (h_card : 2 ‚â§ Fintype.card F)
  :
  n * (choose_2 (k B) + (Fintype.card (Œ± := F) - 1)
    * choose_2 ((B.card - k B) / ((Fintype.card (Œ± := F) - 1))))
  ‚â§ ‚àë i, sum_choose_K_i B i

theorem ScalarField_is_prime : Nat.Prime scalarFieldSize

@[simp]
theorem simulateQ_map_fst (oa : OracleComp spec Œ±) :
    Prod.fst <$> (simulateQ loggingOracle oa).run = oa

@[simp]
lemma seqCompose_type {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)} :
    (seqCompose pSpec).Type = Fin.vflatten (fun i => (pSpec i).Type)

lemma johnson_condition_strong_iff_johnson_denom_pos {B : Finset (Fin n ‚Üí F)} {v : Fin n ‚Üí F} :
  JohnsonConditionStrong B v ‚Üî 0 < JohnsonDenominator B v

omit [Finite F] in
private lemma gen_def {i : ‚Ñï} :
    (IsCyclicWithGen.gen : evalDomain D i) =
      ‚ü®
        DIsCyclicC.gen ^ (2 ^ i),
        by
          apply pow_2_pow_i_mem_Di_of_mem_D
          exact DIsCyclicC.gen.2
      ‚ü©

@[to_additive (attr := simp)]
theorem prod_insertNth [CommMonoid Œ≤] {n : ‚Ñï} (x : Œ≤) (f : Fin n ‚Üí Œ≤) (p : Fin (n + 1)) :
    ‚àè i, insertNth p x f i = x * ‚àè i, f i

lemma folding
  [Nonempty Œπ] {S : Finset Œπ} [Fintype Œπ]
  (œÜ : Œπ ‚Ü™ F) (f : Œπ ‚Üí F) (k : ‚Ñï)
  [Nonempty (indexPow S œÜ k)]
  {degree : ‚Ñï} (Œ¥ : ‚Ñö) (hŒ¥Pos : Œ¥ > 0)
  (hŒ¥Lt : Œ¥ < foldingDistRange degree œÜ f) :
  let C : Set ((indexPow S œÜ k) ‚Üí F) := code (pow S œÜ k) (degree / k)
  Pr_{ let r ‚Üê $·µñ F }[ Œ¥·µ£((fold œÜ f k r), C) ‚â§ Œ¥]
    ‚â§ ENNReal.ofReal (proximityError F (degree / k) (LinearCode.rate (code œÜ degree)) Œ¥ k)

@[simp]
theorem leftpad_apply_ge (n : ‚Ñï) (a : Œ±) (v : Fin m ‚Üí Œ±) (i : Fin n)
    (h : n - m ‚â§ i.val) : leftpad n a v i = v ‚ü®i.val - (n - m), by omega‚ü©

@[simp]
lemma getTypes_hcons (x : Œ£ Œ± : Type u, Œ±) (xs : HList) :
    (x ::‚Çï xs).getTypes = x.1 :: xs.getTypes

lemma listBlock_subset_listHamming
  (i k : ‚Ñï) {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F} {œÜ' : (indexPowT S œÜ i) ‚Ü™ F}
  {m : ‚Ñï} [DecidableEq F] [DecidableEq Œπ] [Smooth œÜ]
  (f : (indexPowT S œÜ i) ‚Üí F) (S' : Finset (indexPowT S œÜ i))
  [h_fintype : ‚àÄ i : ‚Ñï, Fintype (indexPowT S œÜ i)] [DecidableEq (indexPowT S œÜ i)] [Smooth œÜ']
  (C : Set ((indexPowT S œÜ i) ‚Üí F)) (hcode : C = smoothCode œÜ' m)
  [h_dec : DecidableBlockDisagreement i k f S' œÜ']
  (Œ¥ : ‚Ñù‚â•0) (hŒ¥Le : Œ¥ ‚â§ 1) :
  Œõ·µ£(i, k, f, S', C, hcode, Œ¥) ‚äÜ relHammingBall C f Œ¥

@[simp]
lemma lin_shift_hamming_distance [Field F] {x‚ÇÅ x‚ÇÇ v : Fin n ‚Üí F}
  :
  Œî‚ÇÄ(x‚ÇÅ - v, x‚ÇÇ - v) = Œî‚ÇÄ(x‚ÇÅ, x‚ÇÇ)

@[simp] theorem idxOf'_nil [BEq Œ±] {a : Œ±} : idxOf' a [] = 0

congrArg in Init.Prelude

omit [Finite F] in
lemma D_def : evalDomain D x 0 = x ‚Ä¢ D

theorem is_prime : Nat.Prime fieldSize

@[simp]
protected lemma elocPoly_ne_zero : ElocPoly n œâs f p ‚â† 0

omit [DecidableEq L] [DecidableEq ùîΩq] hF‚ÇÇ hŒ≤_lin_indep h_Œ≤‚ÇÄ_eq_1 in
lemma intermediateNormVpoly_eval_is_linear_map (i : Fin (‚Ñì + 1)) (k : Fin (‚Ñì - i + 1)) :
  IsLinearMap ùîΩq (fun x : L =>
    (intermediateNormVpoly ùîΩq Œ≤ h_‚Ñì_add_R_rate i k).eval x)

omit [NoZeroDivisors ùîΩ] in
lemma foldNth_zero {s : ‚Ñï} {Œ± : ùîΩ} : foldNth (2 ^ s) 0 Œ± = 0

lemma neg_mod_2_eq_0_iff_mod_2_eq_0 {n : ‚Ñ§} : ( - n) % 2 = 0 ‚Üî n % 2 = 0

@[simp] theorem mul_zero {a : AssocNat} : a * 0 = 0

@[simp]
lemma finite_possibleRelHammingDistsToCode [Nonempty Œπ] [DecidableEq F] :
  (possibleDistsToCode w C relHammingDist).Finite

omit [Finite F] in
lemma dom_n_eq_triv : evalDomain D x n = {x ^ (2 ^ n)}

private lemma natDegree_E
  (h : (Œî‚ÇÄ(f, p.eval ‚àò œâs) : ‚Ñï) ‚â§ e) :
  (E (œâs := œâs) f p e).natDegree = e

lemma matching_set_is_a_sub_of_coeffs_of_close_proximity
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  : matching_set k œâs Œ¥ u‚ÇÄ u‚ÇÅ h_gs ‚äÜ coeffs_of_close_proximity k œâs Œ¥ u‚ÇÄ u‚ÇÅ

theorem vappend_vconcat (u : Fin m ‚Üí Œ±) (v : Fin n ‚Üí Œ±) (a : Œ±) :
    vappend u (vconcat v a) = vconcat (vappend u v) a

theorem foldCommitOracleReduction_perfectCompleteness
    (hInit : init.neverFails) (i : Fin ‚Ñì) (hCR : isCommitmentRound ‚Ñì œë i) :
    OracleReduction.perfectCompleteness
      (pSpec := pSpecFoldCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)
      (relIn := roundRelation (mp := mp) ùîΩq Œ≤ (œë:=œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) i.castSucc)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë:=œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) i.succ)
      (oracleReduction := foldCommitOracleReduction ùîΩq Œ≤ (œë:=œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) i hCR) (init := init) (impl := impl)

Nat.add_sub_cancel in Init.Data.Nat.Basic

theorem vcons_eq_cons (a : Œ±) (v : Fin n ‚Üí Œ±) : a ::·µõ v = cons a v

theorem add_assoc (a b c : AssocNat) : (a + b) + c = a + (b + c)

@[simp]
lemma addSalt_Type (i : Fin n) :
    (pSpec.addSalt Salt).¬´Type¬ª i = match hDir : pSpec.dir i with

theorem degrees_mul_C_le (p : MvPolynomial œÉ R) (c : R) : (p * C c).degrees ‚â§ p.degrees

@[simp]
theorem dconcat_last {motive : Fin (n + 1) ‚Üí Sort u} (v : (i : Fin n) ‚Üí motive (castSucc i))
    (a : motive (last n)) : (v :+·µà‚ü®motive‚ü© a) (last n) = a

@[simp]
lemma length_nil : nil.length = 0

theorem simulateQ'_eq_simulateQ [AlternativeMonad m] [LawfulMonad m]
    {so : QueryImpl spec m} (oa : OracleComp spec Œ±) (h : oa.neverFails) :
      simulateQ' so oa h = simulateQ so oa

lemma degree_X‚±º (‚Ñì : ‚Ñï) (h_‚Ñì : ‚Ñì ‚â§ r) (j : Fin (2 ^ ‚Ñì)) :
  (X‚±º ùîΩq Œ≤ ‚Ñì h_‚Ñì j).degree = j

theorem distEq_trans (mx my mz : OracleComp spec Œ±)
    (hxy : distEq mx my) (hyz : distEq my mz) : distEq mx mz

theorem castSum_castAdd {n m : ‚Ñï} (i : Fin n) : castSum [n, m] (by simp) i = castAdd m i

lemma out_of_dom_smpl_2
  {Œ¥ l : ‚Ñù‚â•0} {s : ‚Ñï} {f : Œπ ‚Üí F} {degree : ‚Ñï} {œÜ : Œπ ‚Ü™ F}
  (C : Set (Œπ ‚Üí F)) (hC : C = code œÜ degree)
  (h_decodable : listDecodable C Œ¥ l)
  (h_nonempty : Nonempty (domainComplement œÜ)) :
  listDecodingCollisionProbability œÜ f Œ¥ s degree h_nonempty ‚â§
    ((l^2 / 2)) * (degree / (Fintype.card F - Fintype.card Œπ))^s

lemma lt_two_pow_of_lt_two_pow_exp_le (x i j: ‚Ñï)
    (h_x_lt_2_pow_i: x < 2^i) (h_i_le_j: i ‚â§ j): x < 2^j

@[simp]
theorem embedSum_succ_zero {n : Fin (m + 1) ‚Üí ‚Ñï} {j : Fin (n 0)} :
    embedSum 0 j = Fin.castAdd _ j

theorem buildLayer_neverFails (Œ± : Type) [inst : DecidableEq Œ±] [inst_1 : SelectableType Œ±]
    (preexisting_cache : (spec Œ±).QueryCache) (n : ‚Ñï)
    (leaves : List.Vector Œ± (2 ^ (n + 1))) :
    ((simulateQ randomOracle (buildLayer Œ± n leaves)).run preexisting_cache).neverFails

theorem dcast_eq_dcast_iff (h : a = a'') (h' : a' = a'') :
    dcast h b = dcast h' b' ‚Üî b = dcast (h'.trans h.symm) b'

lemma getBit_of_and {n m k: ‚Ñï} : getBit k (n &&& m) = getBit k n &&& getBit k m

theorem prime_13 : Nat.Prime 13

theorem degree_finSuccEquivNth {f : MvPolynomial (Fin (n + 1)) R} (h : f ‚â† 0) :
    (finSuccEquivNth R p f).degree = degreeOf p f

@[simp] lemma drop_dir : pSpec‚ü¶m:‚üß.dir = pSpec.dir‚ü¶m:‚üß

theorem cast_eq_dcast‚ÇÇ {hn} {hSpec : pSpec‚ÇÅ.cast hn = pSpec‚ÇÇ} {i : ChallengeIdx pSpec‚ÇÅ}:
    i.cast hn hSpec = dcast‚ÇÇ hn hSpec i

lemma list_0 : list 0 = List.Vector.cons (1 : GF(2)) List.Vector.nil

theorem zero_mul {a : AssocNat} : 0 * a = 0

lemma sum_insertNth [AddCommMonoid M] {n : ‚Ñï} (œÉ : Fin n ‚Üí‚ÇÄ M) (i : M) (p : Fin (n + 1)) :
    (insertNth p i œÉ).sum (fun _ e ‚Ü¶ e) = i + œÉ.sum (fun _ e ‚Ü¶ e)

@[simp]
theorem vcons_zero (a : Œ±) (v : Fin n ‚Üí Œ±) : (a ::·µõ v) 0 = a

lemma e_leq_dist_over_3 [DecidableEq F] {deg : ‚Ñï} {Œ± : Œπ ‚Ü™ F} {e : ‚Ñï} {u v : Œπ ‚Üí F}
  (he : (e : ‚Ñö) < (Code.minDist (RScodeSet Œ± deg) : ‚Ñö) / 3) :
  ‚àÄ x ‚àà Affine.line u v, distFromCode x (ReedSolomon.code Œ± deg) ‚â§ e
  ‚à® (numberOfClosePts u v deg Œ± e) ‚â§ Code.minDist (RScodeSet Œ± deg)

@[simp]
theorem Basis_cast_dest_apply {Œπ : Type*} (Œ± Œ≤ Œ≥ : ‚Ñï)
    (h_le1 : Œ± ‚â§ Œ≤) (h_le2 : Œ± ‚â§ Œ≥)
    (h_eq : Œ≤ = Œ≥) {k : Œπ} (b : @Basis Œπ (ConcreteBTField Œ±) (ConcreteBTField Œ≤) _ _
    (@ConcreteBTFieldAlgebra (l := Œ±) (r := Œ≤) (h_le := h_le1)).toModule) :
    let castBasis : @Basis Œπ (ConcreteBTField Œ±) (ConcreteBTField Œ≥) _ _
      (@ConcreteBTFieldAlgebra (l := Œ±) (r := Œ≥) (h_le := h_le2)).toModule :=
      cast (by
        exact Basis_cast_dest_eq Œ± Œ≥ Œ≤ h_le2 h_le1 h_eq
      ) b
    (castBasis k) = cast (by
      exact cast_ConcreteBTField_eq Œ≤ Œ≥ h_eq) (b k)

lemma comm_map_smul_tmul (s s' : Right) (m : Left) :
    e (s ‚Ä¢ (s' ‚äó‚Çú[K] m)) = s ‚Ä¢ (e (s' ‚äó‚Çú[K] m))

lemma degree_W (i : Fin r) : (W ùîΩq Œ≤ i).degree = (Fintype.card ùîΩq)^i.val

@[simp]
theorem hconcat_zero {Œ± : Fin 0 ‚Üí Sort u} {Œ≤ : Sort u} (a : Œ≤) :
    hconcat !h‚ü®Œ±‚ü©[] a = fun i => match i with

@[simp]
theorem divide_by_2_mem {s : Finset ‚Ñï} {d : ‚Ñï} :
  d ‚àà divide_by_2 s ‚Üî 2 * d ‚àà s

@[simp]
theorem codeDist'_subsingleton [Subsingleton C] : ‚ÄñC‚Äñ‚ÇÄ' = ‚ä§

@[grind ‚Üê]
lemma mul_ne_zero [IsDomain F] (f g : F[X][Y]) (hf : f ‚â† 0) (hg : g ‚â† 0) :
  f * g ‚â† 0

theorem buildMerkleTree_neverFails (Œ± : Type) [DecidableEq Œ±] [SelectableType Œ±] {n : ‚Ñï}
    (leaves : List.Vector Œ± (2 ^ n)) (preexisting_cache : (spec Œ±).QueryCache) :
    ((simulateQ randomOracle (buildMerkleTree Œ± n leaves)).run preexisting_cache).neverFails

lemma duplexSpongeToFSGameStatDist
    (maliciousProver : OracleComp (oSpec ++‚Çí duplexSpongeChallengeOracle StmtIn U)
      (StmtIn √ó pSpec.Messages))
    (t‚Çí : Œπ ‚Üí ‚Ñï) (t‚Çï t‚Çö t‚Çö·µ¢ : ‚Ñï)
    -- TODO: state query bound only for subset of the oracles
    (hQuery : IsQueryBound maliciousProver (t‚Çí ‚äï·µ• (t‚Çï ‚äï·µ• (t‚Çö ‚äï·µ• t‚Çö·µ¢)))) : True

theorem canonical_iff [LawfulBEq R] {p : UniPoly R} :
   p.trim = p ‚Üî ‚àÄ hp : p.size > 0, p.getLast hp ‚â† 0

@[simp]
protected lemma elocPolyF_eq_elocPoly' {œâs f : Fin n ‚Üí F} :
  ElocPolyF œâs f p = ElocPoly n (liftF œâs) (liftF f) p

theorem liftContext_run
    {lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    {outerStmtIn : OuterStmtIn} {outerWitIn : OuterWitIn}
    {P : Prover oSpec InnerStmtIn InnerWitIn InnerStmtOut InnerWitOut pSpec} :
      (P.liftContext lens).run outerStmtIn outerWitIn
      = do
        let ‚ü®fullTranscript, innerCtxOut‚ü© ‚Üê
          P.run.uncurry (lens.proj (outerStmtIn, outerWitIn))
        return ‚ü®fullTranscript, lens.lift (outerStmtIn, outerWitIn) innerCtxOut‚ü©

@[simp]
theorem distanceLE_polynomial_degreeLT : distanceLE (R‚¶É< d‚¶Ñ[X]) (d - 1)

private lemma choose_2_eq_half_f :
  choose_2 = (1/2) * f

theorem is_prime : Nat.Prime fieldSize

lemma last_nonzero_unique {p : UniPoly Q} {k k' : Fin p.size} :
  last_nonzero_prop k ‚Üí last_nonzero_prop k' ‚Üí k = k'

@[simp]
theorem snoc_zero_zero : snoc (0 : Fin n ‚Üí‚ÇÄ M) 0 = 0

@[simp]
theorem dcast‚ÇÇ_trans (ha : a = a') (ha' : a' = a'')
    (hb : dcast ha b = b') (hb' : dcast ha' b' = b'') :
      dcast‚ÇÇ ha' hb' (dcast‚ÇÇ ha hb c) = dcast‚ÇÇ (ha.trans ha') (by simp [‚Üê hb', ‚Üê hb]) c

lemma combine_eq_cases {F Œπ : Type*} [Field F] [DecidableEq F]
  (œÜ : Œπ ‚Ü™ F) (dstar : ‚Ñï) (r : F) (fs : Fin m ‚Üí Œπ ‚Üí F) (degs : Fin m ‚Üí ‚Ñï)
    (hdegs : ‚àÄ i, degs i ‚â§ dstar) (œÜ_neq_0 : ‚àÄ i, œÜ i ‚â† 0) :
  combine œÜ dstar r fs degs =
    fun x =>
      let q := œÜ x * r
      if q ‚â† 1
      then ‚àë i, (ri dstar degs r i) * (fs i x) * (1 - q^(dstar - degs i + 1)) / (1 - q)
      else ‚àë i, (ri dstar degs r i) * (fs i x) *  (dstar - degs i + 1)

lemma intermediate_poly_P_base (h_‚Ñì : ‚Ñì ‚â§ r) (coeffs : Fin (2 ^ ‚Ñì) ‚Üí L) :
  intermediateEvaluationPoly ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®0, by omega‚ü© coeffs =
    polynomialFromNovelCoeffs ùîΩq Œ≤ ‚Ñì h_‚Ñì coeffs

@[simp]
private lemma leadingCoeff_E : (E œâs f p e).leadingCoeff = 1

lemma sum_eq_xor_plus_twice_and (n : Nat) : ‚àÄ m : ‚Ñï, n + m = (n ^^^ m) + 2 * (n &&& m)

nonpos_iff_eq_zero in Mathlib.Algebra.Order.Monoid.Canonical.Defs

theorem append_knowledgeSoundness (V‚ÇÅ : OracleVerifier oSpec Stmt‚ÇÅ OStmt‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : OracleVerifier oSpec Stmt‚ÇÇ OStmt‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ pSpec‚ÇÇ)
    {knowledgeError‚ÇÅ knowledgeError‚ÇÇ : ‚Ñù‚â•0}
    (h‚ÇÅ : V‚ÇÅ.knowledgeSoundness init impl rel‚ÇÅ rel‚ÇÇ knowledgeError‚ÇÅ)
    (h‚ÇÇ : V‚ÇÇ.knowledgeSoundness init impl rel‚ÇÇ rel‚ÇÉ knowledgeError‚ÇÇ) :
      (V‚ÇÅ.append V‚ÇÇ).knowledgeSoundness init impl rel‚ÇÅ rel‚ÇÉ
        (knowledgeError‚ÇÅ + knowledgeError‚ÇÇ)

lemma BTField.coe_one_succ (l : ‚Ñï) :
  (@binaryAlgebraTower (l:=l) (r:=l+1) (h_le:=by omega)).algebraMap (1 : BTField l) =
    (1 : BTField (l+1))

theorem max_eq_add_sub {m n : Nat} : Nat.max m n = m + (n - m)

@[simp]
theorem OracleVerifier.id_soundness {lang : Set (StmtIn √ó ‚àÄ i, OStmtIn i)} :
    (OracleVerifier.id : OracleVerifier oSpec _ _ _ _ _).soundness
      init impl lang lang 0

theorem oracleVerifier_rbrKnowledgeSoundness [Fintype R] :
    (oracleVerifier R n deg D oSpec i).rbrKnowledgeSoundness init impl
    (relationRound R n deg D i.castSucc) (relationRound R n deg D i.succ)
    (fun _ => (deg : ‚Ñù‚â•0) / Fintype.card R)

theorem mul_zero {a : CNat 50} : a * 0 = 0

@[simp]
lemma E_and_Q_to_a_solution_coeff
  : E_and_Q_to_a_solution e E Q i = if i < e then E.coeff i else Q.coeff (i - e)

lemma and_two_pow_eq_zero_of_getBit_0 {n i : ‚Ñï} (h_getBit : getBit i n = 0)
    : n &&& (2 ^ i) = 0

theorem insertNth_support :
    (insertNth p y s).support ‚äÜ insert p (s.support.map (Fin.succAboveEmb p))

theorem append_completeness (R‚ÇÅ : OracleReduction oSpec Stmt‚ÇÅ OStmt‚ÇÅ Wit‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ Wit‚ÇÇ pSpec‚ÇÅ)
    (R‚ÇÇ : OracleReduction oSpec Stmt‚ÇÇ OStmt‚ÇÇ Wit‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ Wit‚ÇÉ pSpec‚ÇÇ)
    {completenessError‚ÇÅ completenessError‚ÇÇ : ‚Ñù‚â•0}
    (h‚ÇÅ : R‚ÇÅ.completeness init impl rel‚ÇÅ rel‚ÇÇ completenessError‚ÇÅ)
    (h‚ÇÇ : R‚ÇÇ.completeness init impl rel‚ÇÇ rel‚ÇÉ completenessError‚ÇÇ) :
      (R‚ÇÅ.append R‚ÇÇ).completeness init impl
        rel‚ÇÅ rel‚ÇÉ (completenessError‚ÇÅ + completenessError‚ÇÇ)

Nat.le_trans in Init.Prelude

@[grind =]
theorem monomialXY_eq_monomialXY_iff {n m p q : ‚Ñï} {a b : F} :
  monomialXY n m a = monomialXY p q b ‚Üî n = p ‚àß m = q ‚àß a = b ‚à® a = 0 ‚àß b = 0

omit [Fintype F] in
private lemma hamming_weight_eq_sum [Zero F] {x : Fin n ‚Üí F}
  :
  ‚Äñx‚Äñ‚ÇÄ = ‚àë i, if x i = 0 then 0 else 1

@[simp]
theorem take_append_left (T : FullTranscript pSpec‚ÇÅ) (T' : FullTranscript pSpec‚ÇÇ) :
    (T ++‚Çú T').take m (Nat.le_add_right m n) =
      T.cast rfl (by simp [ProtocolSpec.append])

@[simp]
theorem fappend‚ÇÇ_left {Œ±‚ÇÅ : Fin m ‚Üí A} {Œ±‚ÇÇ : Fin m ‚Üí B} {Œ≤‚ÇÅ : Fin n ‚Üí A} {Œ≤‚ÇÇ : Fin n ‚Üí B}
    (u : (i : Fin m) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i)) (v : (i : Fin n) ‚Üí F‚ÇÇ (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) (i : Fin m) :
    fappend‚ÇÇ (F := F‚ÇÇ) u v (castAdd n i) =
      cast (by simp [vappend_left]) (u i)

theorem relayOracleVerifier_rbrKnowledgeSoundness (i : Fin ‚Ñì)
    (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
    (relayOracleVerifier ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        i hNCR).rbrKnowledgeSoundness init impl
      (relIn := foldStepRelOut (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i.succ)
      (relayKnowledgeError)

private lemma Fis_cover_B : B = Finset.univ.biUnion (Fi B i)

@[simp]
lemma Basis.baseChangeRight_apply (b : Basis Œπ K Left) (i : Œπ) :
    (Basis.baseChangeRight (b:=b) (Right:=Right)) i = b i ‚äó‚Çú[K] 1

Fin.eta in Init.Data.Fin.Lemmas

lemma add_comm {k : ‚Ñï} (a b : ConcreteBTField k) : a + b = b + a

lemma Oracle.containsCache_of_cache {Œπ : Type} {spec : OracleSpec Œπ}
    [(i : Œπ) ‚Üí Inhabited (OracleSpec.range spec i)]
    (cache : spec.QueryCache) :
    ‚àÉ (f : spec.FunctionType), Oracle.containsCache f cache

omit [CharP L 2] [DecidableEq ùîΩq] h_Œ≤‚ÇÄ_eq_1 [NeZero ùì°] in
lemma firstOracleWitnessConsistencyProp_relay_preserved (i : Fin ‚Ñì)
    (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) (wit : Witness (L := L) ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j) :
    firstOracleWitnessConsistencyProp ùîΩq Œ≤ wit.t (getFirstOracle ùîΩq Œ≤ oStmt) =
    firstOracleWitnessConsistencyProp ùîΩq Œ≤ wit.t
      (getFirstOracle ùîΩq Œ≤ (mapOStmtOutRelayStep ùîΩq Œ≤ i hNCR oStmt))

theorem Iic_castSucc (i : Fin n) : Iic (castSucc i) = (Iic i).map Fin.castSuccEmb

theorem BitVec.dcast_dcast_bitvec_extractLsb_eq {w hi lo : ‚Ñï} (x : BitVec w)
  (h_width_eq : w = hi - lo + 1) : dcast h_width_eq (dcast (h_width_eq.symm)
  (BitVec.extractLsb (hi:=hi) (lo:=lo) x)) = BitVec.extractLsb (hi:=hi) (lo:=lo) x

theorem rightpad_eq_if_rightpad_eq_of_ge (l l' : List Œ±) (m n n' : Nat) (h : n ‚â§ m) (h' : n' ‚â§ m) :
    rightpad n unit l = rightpad n' unit l' ‚Üí
        rightpad m unit l = rightpad m unit l'

theorem seqCompose_rbrKnowledgeSoundness
    (rel : ‚àÄ i, Set (Stmt i √ó Wit i))
    (V : ‚àÄ i, Verifier oSpec (Stmt i.castSucc) (Stmt i.succ) (pSpec i))
    (rbrKnowledgeError : ‚àÄ i, (pSpec i).ChallengeIdx ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (V i).rbrKnowledgeSoundness init impl
      (rel i.castSucc) (rel i.succ) (rbrKnowledgeError i)) :
      (Verifier.seqCompose Stmt V).rbrKnowledgeSoundness init impl (rel 0) (rel (Fin.last m))
        (fun combinedIdx =>
          letI ij := seqComposeChallengeIdxToSigma combinedIdx
          rbrKnowledgeError ij.1 ij.2)

theorem rightpad_eq_rightpad_append_replicate_of_ge
  (l : List Œ±) (m n : Nat) (h : n ‚â§ m) :
    rightpad m unit l = rightpad n unit l ++ replicate (m - max n l.length) unit

theorem happend_hconcat {Œ± : Fin m ‚Üí Sort u} {Œ≤ : Fin n ‚Üí Sort u} {Œ≥ : Sort u}
    (u : (i : Fin m) ‚Üí Œ± i) (v : (i : Fin n) ‚Üí Œ≤ i) (c : Œ≥) :
    True

lemma getBit_of_highBits_no_shl {n: ‚Ñï} (numLowBits : ‚Ñï) :
    ‚àÄ k, getBit k (getHighBits_no_shl numLowBits n)
  = getBit (k + numLowBits) (n)

Fin.val_injective in Mathlib.Data.Fin.Basic

@[simp]
theorem singleEqPolynomial_zero (x : MvPolynomial œÉ R) : singleEqPolynomial (0 : R) x = 1 - x

@[simp]
lemma liftF'_liftF : Function.LeftInverse liftF' (liftF (Œ± := Œ±) (n := n))

@[simp]
theorem vflatten_succ {m : ‚Ñï} {n : Fin (m + 1) ‚Üí ‚Ñï} {v : (i : Fin (m + 1)) ‚Üí Fin (n i) ‚Üí Œ±} :
    vflatten v = vappend (v 0) (vflatten (fun i => v i.succ))

@[simp]
theorem fflatten‚ÇÇ_one {A : Sort u} {B : Sort v} {F : A ‚Üí B ‚Üí Sort w} {n : Fin 1 ‚Üí ‚Ñï}
    {Œ± : (i : Fin 1) ‚Üí (j : Fin (n i)) ‚Üí A}
    {Œ≤ : (i : Fin 1) ‚Üí (j : Fin (n i)) ‚Üí B}
    {v : (i : Fin 1) ‚Üí (j : Fin (n i)) ‚Üí F (Œ± i j) (Œ≤ i j)} :
    fflatten‚ÇÇ v = v 0

theorem additiveNTT_correctness (h_‚Ñì : ‚Ñì ‚â§ r)
    (original_coeffs : Fin (2 ^ ‚Ñì) ‚Üí L)
    (output_buffer : Fin (2 ^ (‚Ñì + R_rate)) ‚Üí L)
    (h_alg : output_buffer = additiveNTT ùîΩq Œ≤ h_‚Ñì_add_R_rate original_coeffs) :
    let P := polynomialFromNovelCoeffs ùîΩq Œ≤ ‚Ñì h_‚Ñì original_coeffs
    ‚àÄ (j : Fin (2^(‚Ñì + R_rate))),
      output_buffer j = P.eval (evaluationPointœâ ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®0, by omega‚ü© j)

lemma getLast_toImpl {p : Q[X]} (hp : p ‚â† 0) : let h : p.toImpl.size > 0 := toImpl_nonzero hp;
    p.toImpl[p.toImpl.size - 1] = p.leadingCoeff

theorem degreeOf_X_le (i j : œÉ) : degreeOf i (X (R := R) j) ‚â§ 1

@[simp]
theorem oracleReduction_completeness (hInit : init.neverFails) :
    (oracleReduction oSpec OStatement).perfectCompleteness
      init impl (relIn OStatement) (relOut OStatement)

omit [DecidableEq L] [DecidableEq ùîΩq] h_Fq_char_prime hF‚ÇÇ hŒ≤_lin_indep h_Œ≤‚ÇÄ_eq_1 in
lemma intermediateNovelBasisX_zero_eq_one (i : Fin (‚Ñì + 1)) :
    intermediateNovelBasisX ùîΩq Œ≤ h_‚Ñì_add_R_rate i ‚ü®0, by
      exact Nat.two_pow_pos (‚Ñì - ‚Üëi)‚ü© = 1

theorem basisVectors_linear_independent (‚Ñì : Nat) (h_‚Ñì : ‚Ñì ‚â§ r) :
    LinearIndependent L (basisVectors ùîΩq Œ≤ ‚Ñì h_‚Ñì)

@[simp]
theorem partialSum_succ {a : Œ±} {l : List Œ±} :
    (a :: l).partialSum = [0] ++ (partialSum l).map (a + ¬∑)

theorem hconcat_init_self {Œ± : Fin n.succ ‚Üí Sort u} (v : (i : Fin (n + 1)) ‚Üí Œ± i) :
    True

lemma concreteTowerAlgebraMap_succ (l r : ‚Ñï) (h_le : l ‚â§ r) :
  concreteTowerAlgebraMap (l:=l) (r:=r + 1) (h_le:=by omega) =
  (concreteTowerAlgebraMap (l:=r) (r:=r + 1) (h_le:=by omega)).comp
  (concreteTowerAlgebraMap (l:=l) (r:=r) (h_le:=by omega))

theorem eqPolynomial_symm (x : œÉ ‚Üí R) (y : œÉ ‚Üí R) :
    MvPolynomial.eval y (eqPolynomial x) = MvPolynomial.eval x (eqPolynomial y)

lemma BTField_is_BTFieldAux (k : ‚Ñï) :
  BTField k = (BinaryTowerAux k).1

Nat.lt_trans in Init.Prelude

@[simp]
theorem PowerBasis.dim_of_eq_rec
    (r1 r : ‚Ñï)
    (h_r : r = r1 + 1)
    (b : PowerBasis (ConcreteBTField r1) (ConcreteBTField (r1 + 1))) :
    letI instAlgebra : Algebra (ConcreteBTField r1) (ConcreteBTField r) :=
      ConcreteBTFieldAlgebra (l:=r1) (r:=r) (h_le:=by omega)
    ((Eq.rec (motive:=fun (x : ‚Ñï) (_ : r1 + 1 = x) => by
      letI instAlgebraCur : Algebra (ConcreteBTField r1) (ConcreteBTField x) :=
        ConcreteBTFieldAlgebra (l:=r1) (r:=x) (h_le:=by omega)
      exact PowerBasis (ConcreteBTField r1) (ConcreteBTField x)) (refl:=b) (t:=h_r.symm)) :
        PowerBasis (ConcreteBTField r1) (ConcreteBTField r)).dim
    = b.dim

@[simp]
lemma seqCompose_succ {m : ‚Ñï}
    (Stmt : Fin (m + 2) ‚Üí Type) (Wit : Fin (m + 2) ‚Üí Type)
    {n : Fin (m + 1) ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (P : (i : Fin (m + 1)) ‚Üí
      Prover oSpec (Stmt i.castSucc) (Wit i.castSucc) (Stmt i.succ) (Wit i.succ) (pSpec i)) :
    seqCompose Stmt Wit P =
      append (P 0) (seqCompose (Stmt ‚àò Fin.succ) (Wit ‚àò Fin.succ) (fun i => P (Fin.succ i)))

lemma listOfCloseCodewordsRel_eq_zero :
  listOfCloseCodewordsRel C y r = 0 ‚Üî
  IsEmpty (relHammingBall C y r) ‚à® Infinite (relHammingBall C y r)

@[simp, grind] lemma squeezePos_lt_N (sponge : DuplexSponge U C) :
    sponge.squeezePos < SpongeSize.N

theorem sub_add_eq_sub_sub_rev (a b c : Nat) (h1 : c ‚â§ b) (h2 : b ‚â§ a) :
  a - b + c = a - (b - c)

@[simp]
theorem FullData.get_leaf {Œ±} (a : Œ±) :
    (FullData.leaf a).get SkeletonNodeIndex.ofLeaf = a

theorem liftContext_perfectCompleteness
    (h : R.perfectCompleteness init impl innerRelIn innerRelOut) :
      (R.liftContext lens).perfectCompleteness init impl outerRelIn outerRelOut

theorem reduction_perfectCompleteness (hInit : init.neverFails) :
    (reduction R n deg D oSpec i).perfectCompleteness init impl
    (relationRound R n deg D i.castSucc) (relationRound R n deg D i.succ)

theorem monoToLagrangeLevel_lagrangeToMonoLevel_id (v : Vector R (2 ^ n)) (i : Fin n) :
  monoToLagrangeLevel i (lagrangeToMonoLevel i v) = v

theorem take_drop_append {Œ± : Sort*} (m : ‚Ñï) (h : m ‚â§ n) (v : Fin n ‚Üí Œ±) :
    Fin.append (take m h v) (drop m h v) = fun i => v (i.cast (by omega))

private lemma oddPart_eq_oddPart' {f : Polynomial F} : oddPart f = oddPart' f

@[simp]
lemma mul_by_empty :
    mul_by_2 ‚àÖ = ‚àÖ

lemma twoAdicGenerators_pow_twoPow_ne_one_of_lt
    {bits : Fin (twoAdicity + 1)} {m : Nat} (hm : m < bits) :
    (twoAdicGenerators[bits]) ^ (2 ^ m) ‚â† (1 : Field)

theorem liftContext_runToRound
    {lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    {outerStmtIn : OuterStmtIn} {outerWitIn : OuterWitIn} {i : Fin (n + 1)}
    (P : Prover oSpec InnerStmtIn InnerWitIn InnerStmtOut InnerWitOut pSpec) :
      (P.liftContext lens).runToRound i outerStmtIn outerWitIn
      = do
        let ‚ü®transcript, prvState‚ü© ‚Üê
          (P.runToRound i).uncurry (lens.proj (outerStmtIn, outerWitIn))
        return ‚ü®transcript, ‚ü®prvState, outerStmtIn, outerWitIn‚ü©‚ü©

lemma xor_eq_sub_iff_submask {n m : ‚Ñï} (h: m ‚â§ n) : n ^^^ m = n - m ‚Üî n &&& m = m

theorem intermediateNormVpoly_comp_qmap_helper (i : Fin (‚Ñì))
    (k : Fin (‚Ñì - (‚Üëi + 1))) :
    (intermediateNormVpoly ùîΩq Œ≤ h_‚Ñì_add_R_rate
      ‚ü®‚Üëi + 1, by omega‚ü© (k:=‚ü®k, by simp only; omega‚ü©)).comp (qMap ùîΩq Œ≤ ‚ü®‚Üëi, by omega‚ü©) =
    intermediateNormVpoly ùîΩq Œ≤ h_‚Ñì_add_R_rate
      ‚ü®‚Üëi, by omega‚ü© ‚ü®k + 1, by simp only; omega‚ü©

@[simp]
theorem LeafData.get_ofLeft {s_left s_right : Skeleton} {Œ± : Type}
    (tree : LeafData Œ± (Skeleton.internal s_left s_right))
    (idxLeft : SkeletonLeafIndex s_left) :
    tree.get (SkeletonLeafIndex.ofLeft idxLeft) =
      tree.leftSubtree.get idxLeft

lemma one_is_1 {k : ‚Ñï} : (one (k:=k)) = 1

theorem support_C_subset {r : R} : (@C R œÉ _ r).support ‚äÜ { 0 }

theorem GF_2_pow_card (x : GF(2)) : x ^ Fintype.card (GF(2)) = x

theorem heq_of_dcast (ha : a = a') (hb : dcast ha b = b') : HEq b b'

theorem vconcat_eq_snoc (v : Fin n ‚Üí Œ±) (a : Œ±) : vconcat v a = snoc v a

lemma powerBasisSucc_dim (k : ‚Ñï) :
  powerBasisSucc (k:=k).dim = 2

theorem computableNTTStage_eq_NTTStage (i : Fin ‚Ñì) :
  computableNTTStage (ùîΩq := ùîΩq) (r := r) (L := L) (‚Ñì := ‚Ñì) (Œ≤ := Œ≤) (R_rate := R_rate)
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := ‚ü®i, by omega‚ü©) =
  NTTStage (ùîΩq := ùîΩq) (L := L) (Œ≤ := Œ≤) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
    (i := ‚ü®i, by omega‚ü©)

theorem BitVec.dcast_bitvec_eq {l r val : ‚Ñï} (h_width_eq : l = r) :
    dcast h_width_eq (BitVec.ofNat l val) = BitVec.ofNat r val

theorem fcons‚ÇÇ_left_injective {Œ±‚ÇÅ : A} {Œ±‚ÇÇ : B} {Œ≤‚ÇÅ : Fin n ‚Üí A} {Œ≤‚ÇÇ : Fin n ‚Üí B}
    (b : (i : Fin n) ‚Üí F‚ÇÇ (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) :
    Function.Injective (fun a : F‚ÇÇ Œ±‚ÇÅ Œ±‚ÇÇ => fcons‚ÇÇ (F := F‚ÇÇ) a b)

@[simp]
lemma coe_fn_of_coe (f : ‚àÄ a, Œ≤ a) : (f : F) = inst.equiv.invFun f

@[simp]
theorem card_filter_prod_self_eq :
  #({x ‚àà s √óÀ¢ s | x.1 = x.2}) = #s

@[simp]
theorem OracleReduction.run_eq_run_reduction [‚àÄ i, OracleInterface (pSpec.Message i)]
    {stmt : StmtIn} {oStmt : ‚àÄ i, OStmtIn i} {wit : WitIn}
    {oracleReduction : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec} :
      oracleReduction.run stmt oStmt wit =
        oracleReduction.toReduction.run ‚ü®stmt, oStmt‚ü© wit

@[simp]
theorem seqCompose_zero {n : Fin 0 ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)} :
    seqCompose pSpec = !p[]

@[simp]
lemma seqCompose_def {m : ‚Ñï}
    (Stmt : Fin (m + 1) ‚Üí Type) {Œπ‚Çõ : Fin (m + 1) ‚Üí Type} (OStmt : (i : Fin (m + 1)) ‚Üí Œπ‚Çõ i ‚Üí Type)
    (Wit : Fin (m + 1) ‚Üí Type) {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (P : (i : Fin m) ‚Üí
      OracleProver oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Wit i.castSucc)
        (Stmt i.succ) (OStmt i.succ) (Wit i.succ) (pSpec i)) :
    seqCompose Stmt OStmt Wit P = Prover.seqCompose (fun i => Stmt i √ó (‚àÄ j, OStmt i j)) Wit P

theorem eq_of_lt_dist {C : Set (n ‚Üí R)} {u v : n ‚Üí R} (hu : u ‚àà C) (hv : v ‚àà C)
    (huv : Œî‚ÇÄ(u, v) < ‚ÄñC‚Äñ‚ÇÄ) : u = v

omit h_Œ≤‚ÇÄ_eq_1 in
theorem sDomainFin_bijective (i : Fin r) (h_i : i < ‚Ñì + R_rate)
: Function.Bijective
  (sDomainFinEquiv ùîΩq Œ≤ h_‚Ñì_add_R_rate i h_i)

theorem linear_form_of_elements_in_adjoined_commring
    {R : Type*} [CommRing R] (f : R[X]) (hf_deg : f.natDegree = 2)
    (hf_monic : Monic f) (c1 : AdjoinRoot f) :
    ‚àÉ a b : R, c1 = (AdjoinRoot.of f) a * root f + (AdjoinRoot.of f) b

lemma getBit_eq_succ_getBit_of_mul_two {n k : ‚Ñï} : getBit (k+1) (2*n) = getBit k n

theorem evenRefinement_eq_novel_poly_of_0_leading_suffix (i : Fin ‚Ñì) (v : Fin (2 ^ i.val))
    (original_coeffs : Fin (2 ^ ‚Ñì) ‚Üí L) :
    have h_v: v.val < 2 ^ (i.val + 1) := by
      calc v.val < 2 ^ i.val := by omega
        _ < 2 ^ (i.val + 1) := by apply Nat.pow_lt_pow_right (by omega) (by omega)
    evenRefinement ùîΩq Œ≤ h_‚Ñì_add_R_rate i (coeffsBySuffix (r:=r)
      (R_rate:=R_rate) (a:=original_coeffs) ‚ü®i, by omega‚ü© v) =
    intermediateEvaluationPoly ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i + 1, by omega‚ü©
      (coeffsBySuffix (r:=r) (R_rate:=R_rate) original_coeffs ‚ü®i + 1, by omega‚ü© ‚ü®v, h_v‚ü©)

@[simp]
theorem cast_run (stmt : StmtIn) (transcript : FullTranscript pSpec‚ÇÅ) :
    V.run stmt transcript = (V.cast hn hSpec).run stmt (transcript.cast hn hSpec)

@[simp]
theorem card_prod_self_eq :
  #(((s √óÀ¢ s : Finset _) ‚à© ({x : Œ± √ó Œ± | x.1 = x.2} : Finset _)) : Finset _) = #s

@[simp]
theorem LeafData.optionComposeBuild_internal {Œ±} {s_left s_right : Skeleton}
    (left : LeafData Œ± s_left) (right : LeafData Œ± s_right)
    (compose : Œ± ‚Üí Œ± ‚Üí Option Œ±) :
    (LeafData.internal left right).optionComposeBuild compose =
      FullData.internal
        (Option.doubleBind compose
          (left.optionComposeBuild compose).getRootValue
          (right.optionComposeBuild compose).getRootValue)
        (left.optionComposeBuild compose)
        (right.optionComposeBuild compose)

theorem dext_iff {Œ± : Fin n ‚Üí Sort u} {v w : (i : Fin n) ‚Üí Œ± i} :
    v = w ‚Üî ‚àÄ i, v i = w i

theorem foldOracleVerifier_rbrKnowledgeSoundness (i : Fin ‚Ñì) :
    (foldOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i).rbrKnowledgeSoundness init impl
      (relIn := roundRelation (mp := mp) ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        (ùìë := ùìë) i.castSucc)
      (relOut := foldStepRelOut (mp := mp) ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        (ùìë := ùìë) i)
      (foldKnowledgeError ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)

@[simp]
theorem oracleVerifier_rbrKnowledgeSoundness (hRel : ‚àÄ stmtIn oStmtIn witOut,
      ((mapStmt stmtIn, mapOStmt embedIdx hEq oStmtIn), witOut) ‚àà relOut ‚Üí
      ((stmtIn, oStmtIn), mapWitInv (stmtIn, oStmtIn) witOut) ‚àà relIn) :
    (oracleVerifier oSpec mapStmt embedIdx hEq).rbrKnowledgeSoundness init impl relIn relOut 0

@[simp]
lemma probFailure_liftComp {Œπ' : Type w} {superSpec : OracleSpec Œπ'}
    [spec.FiniteRange] [superSpec.FiniteRange]
    [h : MonadLift (OracleQuery spec) (OracleQuery superSpec)]
    (oa : OracleComp spec Œ±) : [‚ä• | liftComp oa superSpec] = [‚ä• | oa]

lemma num_eq_highBits_add_lowBits {n: ‚Ñï} (numLowBits: ‚Ñï) :
  n = getHighBits numLowBits n + getLowBits numLowBits n

theorem ext_hcons {Œ≤ : Fin n ‚Üí Sort u} (a‚ÇÅ a‚ÇÇ : Œ±) (v‚ÇÅ v‚ÇÇ : (i : Fin n) ‚Üí Œ≤ i) :
    hcons a‚ÇÅ v‚ÇÅ = hcons a‚ÇÇ v‚ÇÇ ‚Üî a‚ÇÅ = a‚ÇÇ ‚àß v‚ÇÅ = v‚ÇÇ

theorem randomOracle_cache_neverFails_iff_runWithOracle_neverFails {Œ≤}
    [DecidableEq Œπ] [spec.DecidableEq] [(i : Œπ) ‚Üí SelectableType (OracleSpec.range spec i)]
    (oa : OracleComp (spec) Œ≤) (preexisting_cache : spec.QueryCache)
    :
    ((oa.simulateQ randomOracle).run preexisting_cache).neverFails
    ‚Üî
    (‚àÄ (f : spec.FunctionType),
      Oracle.containsCache f preexisting_cache ‚Üí
      (runWithOracle f oa).isSome)

theorem qMap_maps_sDomain (i : Fin r) (h_i_add_1 : i + 1 < r) :
  have q_comp_linear_map := qMap_is_linear_map ùîΩq Œ≤ i
  have q_eval_linear_map := linear_map_of_comp_to_linear_map_of_eval
    (f:=qMap ùîΩq Œ≤ i) q_comp_linear_map
  let q_i_map := polyEvalLinearMap (qMap ùîΩq Œ≤ i) q_eval_linear_map
  let S_i := sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i
  let S_i_plus_1 := sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i+1)
  Submodule.map q_i_map S_i = S_i_plus_1

@[simp]
theorem dist_empty : ‚Äñ (‚àÖ : Set (n ‚Üí R) ) ‚Äñ‚ÇÄ = 0

@[simp]
theorem generateProof_leaf (a : Œ±) (idx) :
    generateProof (FullData.leaf a) idx = []

@[simp]
theorem dcons_succ {motive : Fin (n + 1) ‚Üí Sort u} (a : motive 0)
    (v : (i : Fin n) ‚Üí motive i.succ) (i : Fin n) : (a ::·µà‚ü®motive‚ü© v) i.succ = v i

lemma algebraMap_adjacent_tower_def (l : ‚Ñï) :
  (algebraMap (BTField l) (BTField (l + 1))) = canonicalEmbedding l

lemma xor_of_and_eq_zero_is_or {n m : ‚Ñï} (h_n_AND_m : n &&& m = 0) : n ^^^ m = n ||

@[simp]
lemma OracleVerifier.id_toVerifier :
    (OracleVerifier.id : OracleVerifier oSpec Statement OStatement _ _ _).toVerifier =
      Verifier.id

theorem seqCompose_knowledgeSoundness
    (rel : (i : Fin (m + 1)) ‚Üí Set ((Stmt i √ó ‚àÄ j, OStmt i j) √ó Wit i))
    (V : (i : Fin m) ‚Üí
      OracleVerifier oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Stmt i.succ) (OStmt i.succ)
        (pSpec i))
    (knowledgeError : Fin m ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (V i).knowledgeSoundness init impl (rel i.castSucc) (rel i.succ) (knowledgeError i)) :
      (OracleVerifier.seqCompose Stmt OStmt V).knowledgeSoundness
        init impl (rel 0) (rel (Fin.last m)) (‚àë i, knowledgeError i)

theorem oracleVerifier_rbrKnowledgeSoundness [Fintype R] :
    (oracleVerifier R deg D n oSpec).rbrKnowledgeSoundness init impl
      (relationRound R n deg D 0) (relationRound R n deg D (.last n))
      (fun _ => (deg : ‚Ñù‚â•0) / (Fintype.card R))

lemma getBit_of_or {n m k: ‚Ñï} : getBit k (n ||| m) = getBit k n ||

theorem rbrSoundness_implies_soundness (langIn : Set StmtIn) (langOut : Set StmtOut)
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    (rbrSoundnessError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) :
      rbrSoundness init impl langIn langOut verifier rbrSoundnessError ‚Üí
        soundness init impl langIn langOut verifier (‚àë i, rbrSoundnessError i)

lemma extract_stop_last_eq_drop {n : ‚Ñï} {Œ± : Fin n ‚Üí Sort*} (start : ‚Ñï) (h : start ‚â§ n)
    (v : (i : Fin n) ‚Üí Œ± i) : extract start n h (Nat.le_refl _) v = drop start h v

@[simp]
theorem sumExceptFirst'_degree_le (n : ‚Ñï) (h : n > 0) (D : Fin (n - 1) ‚Üí Finset R)
    (p : MvPolynomial (Fin n) R) : (sumExceptFirst' n h D p).degree ‚â§ p.degreeOf ‚ü®0, h‚ü©

lemma add_eq_zero_iff_eq {k : ‚Ñï} (a b : ConcreteBTField k) : a + b = 0 ‚Üî a = b

private lemma sum_add_one {i : Fin (k + 1)} :
  ‚àë j' ‚àà finRangeTo (i.1 + 1), (s j').1 = (‚àë j' ‚àà finRangeTo i.1, (s j').1) + (s i).1

theorem divSum?_is_some_iff_lt_sum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {k : ‚Ñï} :
    (divSum? n k).isSome ‚Üî k < ‚àë i, n i

@[simp]
lemma runWithLogToRound_discard_log_eq_runToRound (i : Fin (n + 1))
    (stmt : StmtIn) (wit : WitIn) (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      Prod.fst <$> prover.runWithLogToRound i stmt wit =
        prover.runToRound i stmt wit

theorem oracleReduction_rbr_knowledge_soundness : True

theorem split_of_join {k : ‚Ñï} (h_pos : k > 0) (x : ConcreteBTField k)
    (hi_btf lo_btf : ConcreteBTField (k - 1))
    (h_join : x = „Äähi_btf, lo_btf„Äã) :
    (hi_btf, lo_btf) = split h_pos x

Nat.succ_lt_succ_iff in Init.Data.Nat.Basic

theorem toPoly_toImpl {p : Q[X]} : p.toImpl.toPoly = p

private lemma K_eq_sum {Œ± : F} : K B i Œ± = ‚àë (x : B), if x.1 i = Œ± then 1 else 0

@[to_additive (attr := simp) vsum_zero]
lemma vprod_zero [CommMonoid Œ±] {a : Fin 0 ‚Üí Œ±} : vprod a = 1

lemma C_injective : Function.Injective (C : R ‚Üí P)

theorem seqCompose_rbrSoundness
    (lang : (i : Fin (m + 1)) ‚Üí Set (Stmt i √ó ‚àÄ j, OStmt i j))
    (V : (i : Fin m) ‚Üí
      OracleVerifier oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Stmt i.succ) (OStmt i.succ)
        (pSpec i))
    (rbrSoundnessError : ‚àÄ i, (pSpec i).ChallengeIdx ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (V i).rbrSoundness init impl (lang i.castSucc) (lang i.succ) (rbrSoundnessError i)) :
      (OracleVerifier.seqCompose Stmt OStmt V).rbrSoundness
        init impl (lang 0) (lang (Fin.last m))
        (fun combinedIdx =>
          letI ij := seqComposeChallengeIdxToSigma combinedIdx
          rbrSoundnessError ij.1 ij.2)

@[simp]
lemma evenize_coeff {f : Polynomial F} {n : ‚Ñï} :
    (evenize f).coeff n = if Even n then f.coeff (n / 2) else 0

theorem append_rbrSoundness (V‚ÇÅ : OracleVerifier oSpec Stmt‚ÇÅ OStmt‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : OracleVerifier oSpec Stmt‚ÇÇ OStmt‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ pSpec‚ÇÇ)
    {rbrSoundnessError‚ÇÅ : pSpec‚ÇÅ.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    {rbrSoundnessError‚ÇÇ : pSpec‚ÇÇ.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    (h‚ÇÅ : V‚ÇÅ.rbrSoundness init impl lang‚ÇÅ lang‚ÇÇ rbrSoundnessError‚ÇÅ)
    (h‚ÇÇ : V‚ÇÇ.rbrSoundness init impl lang‚ÇÇ lang‚ÇÉ rbrSoundnessError‚ÇÇ) :
      (V‚ÇÅ.append V‚ÇÇ).rbrSoundness init impl lang‚ÇÅ lang‚ÇÉ
        (Sum.elim rbrSoundnessError‚ÇÅ rbrSoundnessError‚ÇÇ ‚àò ChallengeIdx.sumEquiv.symm)

theorem one_le_sub_consecutive_two_pow (n : ‚Ñï): 1 ‚â§ 2^(n+1) - 2^n

lemma aeval_eq' {A : Type y} [CommSemiring A] [Algebra R A] {F : Type z} [FunEquiv F œÉ A]
    (f : P ‚Üí‚Çê[R] A) (p : P) : f p = aeval (fun s => f (X s) : F) p

theorem srSoundness_implies_soundness
    (langIn : Set StmtIn) (langOut : Set StmtOut)
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    (srInit : ProbComp (srChallengeOracle StmtIn pSpec).FunctionType)
    (srImpl : QueryImpl oSpec (StateT (srChallengeOracle StmtIn pSpec).FunctionType ProbComp))
    (srSoundnessError : ‚Ñù‚â•0) :
      Verifier.StateRestoration.soundness srInit srImpl langIn langOut verifier srSoundnessError ‚Üí
        soundness init impl langIn langOut verifier srSoundnessError

@[simp] -- TODO: more general version/class for query impls that never have failures
lemma loggingOracle.probFailure_simulateQ [spec.FiniteRange] (oa : OracleComp spec Œ±) :
    [‚ä• | (simulateQ loggingOracle oa).run] = [‚ä• | oa] := by
  induction oa using OracleComp.induction with

theorem runWithOracle_succeeds_iff_simulateQ_randomOracle_neverFails
     {Œ≤}
    [DecidableEq Œπ] [spec.DecidableEq] [(i : Œπ) ‚Üí SelectableType (OracleSpec.range spec i)]
    (oa : OracleComp (spec) Œ≤) (f : spec.FunctionType) :
    (runWithOracle f oa).isSome ‚Üî
    ((oa.simulateQ randomOracle).run (fun i q => some (f i q))).neverFails

lemma folding_steps_pos : (œë : ‚Ñï) > 0

lemma dappend_right_of_not_lt {motive : Fin (m + n) ‚Üí Sort u}
    (u : (i : Fin m) ‚Üí motive (castAdd n i)) (v : (i : Fin n) ‚Üí motive (natAdd m i))
    (i : Fin (m + n)) (h : ¬¨ i.val < m) :
      dappend (motive := motive) u v i = dcast (by ext; simp; omega) (v ‚ü®i - m, by omega‚ü©)

theorem verifier_rbr_knowledge_soundness :
    (verifier oSpec Statement pred).rbrKnowledgeSoundness init impl
      (relIn Statement pred) (relOut Statement) 0

lemma shiftRight_and_one_distrib {n m k : ‚Ñï} :
    Nat.getBit k (n &&& m) = Nat.getBit k n &&& Nat.getBit k m

theorem FullData.toLeafData_leftSubtree {Œ±} {s_left s_right : Skeleton}
    (tree : FullData Œ± (Skeleton.internal s_left s_right)) :
    tree.toLeafData.leftSubtree =
      tree.leftSubtree.toLeafData

@[simp] theorem leftpad_eq_self (l : List Œ±) (n : Nat) (h : l.length ‚â• n) :
    leftpad n unit l = l

lemma solution_gamma_is_linear_in_Z
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  :
  ‚àÉ (v‚ÇÄ v‚ÇÅ : F[X]),
    Œ≥' x‚ÇÄ (R k Œ¥ x‚ÇÄ h_gs) (irreducible_H k (x‚ÇÄ := x‚ÇÄ) (Œ¥ := Œ¥) h_gs) =
        AppendixA.polyToPowerSeriesùïÉ _
          (
            (Polynomial.map Polynomial.C v‚ÇÄ) +
            (Polynomial.C Polynomial.X) * (Polynomial.map Polynomial.C v‚ÇÅ)
          )

omit [DecidableEq ùîΩq] hF‚ÇÇ h_Œ≤‚ÇÄ_eq_1 in
lemma getSDomainBasisCoeff_of_sum_repr [NeZero R_rate] (i : Fin (‚Ñì + 1))
    (x : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®i, by omega‚ü©)
    (x_coeffs : Fin (‚Ñì + R_rate - i) ‚Üí ùîΩq)
    (hx : x = ‚àë j_x, (x_coeffs j_x) ‚Ä¢ (sDomain_basis ùîΩq Œ≤
      h_‚Ñì_add_R_rate (i := ‚ü®i, by omega‚ü©) (h_i := by
        simp only; apply Nat.lt_add_of_pos_right_of_le; omega) j_x).val) :
    ‚àÄ (j: Fin (‚Ñì + R_rate - i)), ((sDomain_basis ùîΩq Œ≤
      h_‚Ñì_add_R_rate (i := ‚ü®i, by omega‚ü©) (h_i := by
        simp only; apply Nat.lt_add_of_pos_right_of_le; omega)).repr x) j = x_coeffs j

@[simp]
theorem cast_id :
    Reduction.cast rfl rfl = (id : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec‚ÇÅ ‚Üí _)

@[simp]
lemma list_length (k : ‚Ñï) : (list k).length = k + 1

@[simp]
theorem removeNth_last : removeNth (Fin.last n) s = init s

@[simp]
theorem LeafData.optionComposeBuild_leaf {Œ±} (a : Œ±)
    (compose : Œ± ‚Üí Œ± ‚Üí Option Œ±) :
    (LeafData.leaf a).optionComposeBuild compose = FullData.leaf (.some a)

omit [DecidableEq Œ±] [Inhabited Œ±] [Fintype Œ±] in
@[simp]
lemma Cache.leaves_cons (n : ‚Ñï) (leaves : List.Vector Œ± (2 ^ (n + 1))) (cache : Cache Œ± n) :
    Cache.leaves Œ± n (Cache.cons Œ± n leaves cache) = leaves

@[simp]
theorem induction_one' {motive : Fin 2 ‚Üí Sort*} {zero : motive 0}
    {succ : ‚àÄ i : Fin 1, motive i.castSucc ‚Üí motive i.succ} :
      induction (motive := motive) zero succ (1 : Fin 2) = succ 0 zero

Nat.sub_mul in Init.Data.Nat.Basic

theorem srKnowledgeSoundness_implies_knowledgeSoundness
    (relIn : Set (StmtIn √ó WitIn)) (relOut : Set (StmtOut √ó WitOut))
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    (srInit : ProbComp (srChallengeOracle StmtIn pSpec).FunctionType)
    (srImpl : QueryImpl oSpec (StateT (srChallengeOracle StmtIn pSpec).FunctionType ProbComp))
    (srKnowledgeError : ‚Ñù‚â•0) :
      Verifier.StateRestoration.knowledgeSoundness srInit srImpl relIn relOut
        verifier srKnowledgeError ‚Üí
      knowledgeSoundness init impl relIn relOut verifier srKnowledgeError

@[simp]
theorem init_update_castSucc : init (update s i.castSucc y) = update (init s) i y

@[simp]
theorem insertNth_apply_succAbove : insertNth p y s (p.succAbove i) = s i

lemma evenize_is_even {f : Polynomial F} :
    EvenPoly (evenize f)

theorem zero_lt_pow_n (m : ‚Ñï) (n : ‚Ñï) (h_m : m > 0): 0 < m^n

@[simp] lemma ofMvPolynomialAlgHom_X (s : œÉ) :
    ofMvPolynomialAlgHom (MvPolynomial.X s : MvPolynomial œÉ R) = (X s : P)

theorem eqPolynomial_mem_restrictDegree (r : œÉ ‚Üí R) : (eqPolynomial r) ‚àà R‚¶É‚â§ 1‚¶Ñ[X œÉ]

@[simp]
lemma liftComp_support {Œπ' : Type w} {superSpec : OracleSpec Œπ'}
    [h : MonadLift (OracleQuery spec) (OracleQuery superSpec)]
    (oa : OracleComp spec Œ±) : (liftComp oa superSpec).support = oa.support

@[simp]
theorem fcons_succ {Œ≤ : Fin n ‚Üí A} (a : F Œ±) (v : (i : Fin n) ‚Üí F (Œ≤ i)) (i : Fin n) :
    fcons a v i.succ = cast (by simp [vcons_succ]) (v i)

theorem dcast_fun‚ÇÇ {a‚ÇÅ a‚ÇÇ a‚ÇÅ' a‚ÇÇ' : Œ±} {h‚ÇÅ : a‚ÇÅ = a‚ÇÅ'} {h‚ÇÇ : a‚ÇÇ = a‚ÇÇ'} {f : Œ± ‚Üí Œ± ‚Üí Œ±}
    {g : (a‚ÇÅ : Œ±) ‚Üí (a‚ÇÇ : Œ±) ‚Üí Œ≤ a‚ÇÅ ‚Üí Œ≤ a‚ÇÇ ‚Üí Œ≤ (f a‚ÇÅ a‚ÇÇ)} {b‚ÇÅ : Œ≤ a‚ÇÅ} {b‚ÇÇ : Œ≤ a‚ÇÇ} :
    dcast (by cases h‚ÇÅ; cases h‚ÇÇ; rfl) (g a‚ÇÅ a‚ÇÇ b‚ÇÅ b‚ÇÇ) = g a‚ÇÅ' a‚ÇÇ' (dcast h‚ÇÅ b‚ÇÅ) (dcast h‚ÇÇ b‚ÇÇ)

lemma toOutCodewordsCount_last ‚Ñì œë : toOutCodewordsCount ‚Ñì œë (Fin.last ‚Ñì) = ‚Ñì / œë

@[to_additive]
theorem prod_Iio_succ (i : Fin n) :
    ‚àè j ‚àà Iio i.succ, v j = (‚àè j ‚àà Iio i.castSucc, v j) * v i.castSucc

@[simp]
theorem InternalData.ofFun_get {Œ±} {s} (tree : InternalData Œ± s) :
    InternalData.ofFun s (fun idx => tree.get idx) = tree

lemma neg_descends (a b : UniPoly R) : equiv a b ‚Üí neg_descending a = neg_descending b

lemma sum_of_and_eq_zero_is_or {n m : ‚Ñï} (h_n_AND_m : n &&& m = 0) : n + m = n ||

@[simp]
theorem ofNat_succ (n : ‚Ñï) : @ofNat Œ± (n.succ) = succ (ofNat n)

theorem coeff_of_toMvPolynomial_eq_coeff_of_MlPoly (p : MlPoly R n) (m : Fin n ‚Üí‚ÇÄ ‚Ñï) :
  coeff m (toMvPolynomial p) =
    if h_binary: (‚àÄ j: Fin n, m j ‚â§ 1) then
      let i_of_m: ‚Ñï := Nat.binaryFinMapToNat (m:=m) (h_binary:=h_binary)
      p[i_of_m]
    else
      0

theorem eval_toImpl_eq_eval [LawfulBEq R] (x : R) (p : R[X]) : p.toImpl.eval x = p.eval x

theorem foldl_split_inner {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤ ‚Üí Œ±) (init : Œ±)
    (l : List Œ≤) (h : l ‚â† []): foldl (f:=f) (init:=init) (l)
    = foldl (f:=f) (init:=f (init) (l.head (by omega))) (l.tail)

@[simp]
lemma relHammingDistToCode_mem_relHammingDistRange [Nonempty Œπ] [DecidableEq F] :
  Œ¥·µ£(c, C) ‚àà relHammingDistRange Œπ

Nat.mul_le_mul_right in Init.Data.Nat.Basic

omit [Finite F] in
lemma one_in_doms (i : ‚Ñï) : 1 ‚àà evalDomain D i

@[simp]
theorem simulateQ_run_liftComp_fst {Œπ' : Type u} {superSpec : OracleSpec Œπ'}
    (oa : OracleComp spec Œ±) [SubSpec spec superSpec] :
      Prod.fst <$> (simulateQ loggingOracle oa).run.liftComp superSpec =
        Prod.fst <$> (simulateQ loggingOracle (oa.liftComp superSpec)).run

@[simp, grind =]
lemma totalDegree_monomialXY {n m : ‚Ñï} {a : F} (ha : a ‚â† 0) :
  totalDegree (monomialXY n m a) = n + m

omit [NeZero ‚Ñì] [NeZero r] [NeZero ùì°] in
lemma fin_r_succ_bound {h_‚Ñì_add_R_rate : ‚Ñì + ùì° < r} (i : Fin r) (h_i : i + 1 < ‚Ñì + ùì°)
    : i + 1 < r

theorem evalNormalizedWAt_eq_normalizedW (i : Fin r) (x : L) :
  evalNormalizedWAt (Œ≤ := Œ≤) (‚Ñì := ‚Ñì) (R_rate := R_rate) (i := i) x
    = (normalizedW (ùîΩq := ùîΩq) (Œ≤ := Œ≤) (i := i)).eval x

omit [Finite R] in
theorem projection_injective
    (C : Set (n ‚Üí R))
    (nontriv : ‚ÄñC‚Äñ‚ÇÄ ‚â• 1)
    (S : Finset n)
    (hS : card S = card n - (‚ÄñC‚Äñ‚ÇÄ - 1))
    (u v : n ‚Üí R)
    (hu : u ‚àà C)
    (hv : v ‚àà C) : projection S u = projection S v ‚Üí u = v

theorem init_dconcat {motive : Fin (n + 1) ‚Üí Sort u} (v : (i : Fin n) ‚Üí motive (castSucc i))
    (a : motive (last n)) : (fun i => (v :+·µà‚ü®motive‚ü© a) (castSucc i)) = v

@[simp]
theorem oracleReduction_completeness (h : init.neverFails) :
    (oracleReduction oSpec Statement OStatement pred).perfectCompleteness init impl
    (toRelInput pred hPred) Set.univ

theorem cast_eq_dcast {h : n‚ÇÅ = n‚ÇÇ} {pSpec : ProtocolSpec n‚ÇÅ} :
    pSpec.cast h = dcast h pSpec

theorem vcons_inj (a b : Œ±) (v w : Fin n ‚Üí Œ±) : a ::·µõ v = b ::·µõ w ‚Üî a = b ‚àß v = w

theorem induction_append_left {m n : ‚Ñï} {motive : Fin (m + n + 1) ‚Üí Sort*} {zero : motive 0}
    {succ : ‚àÄ i : Fin (m + n), motive i.castSucc ‚Üí motive i.succ} {i : Fin (m + 1)} :
      induction (motive := motive) zero succ ‚ü®i, by omega‚ü© =
        @induction m (fun j => motive ‚ü®j, by omega‚ü©) zero (fun j x => succ ‚ü®j, by omega‚ü© x) i

lemma natDegree_definingPoly {F : Type*} [Field F] [Fintype F] (s : F) [NeZero s] :
  (definingPoly s).natDegree = 2

@[simp]
theorem Prover.runToRound_zero_of_prover_first
    (stmt : StmtIn) (wit : WitIn) (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      prover.runToRound 0 stmt wit = (pure (default, prover.input (stmt, wit)))

theorem add_assoc : p + q + r = p + (q + r)

lemma normalizedW·µ¢_eval_Œ≤·µ¢_eq_1 {i : Fin r} :
    (normalizedW (ùîΩq := ùîΩq) (Œ≤ := Œ≤) (i :=i)).eval (Œ≤ i) = 1

@[simp]
lemma invFun_toFun (f : F) : inst.equiv.invFun (inst.equiv.toFun f) = f

lemma num_eq_highBits_xor_lowBits {n: ‚Ñï} (numLowBits: ‚Ñï) :
  n = getHighBits numLowBits n ^^^ getLowBits numLowBits n

@[simp]
lemma vappend_last_of_succ_right {u : Fin m ‚Üí Œ±} {v : Fin (n + 1) ‚Üí Œ±} :
    (vappend u v) (last (m + n)) = v (last n)

@[simp]
theorem choose_2_convex : ConvexOn ‚Ñö Set.univ choose_2

@[simp]
theorem vappend_vcons (a : Œ±) (u : Fin m ‚Üí Œ±) (v : Fin n ‚Üí Œ±) :
    vappend (vcons a u) v = (vcons a (vappend u v)) ‚àò Fin.cast (Nat.succ_add m n)

theorem dcast‚ÇÇ_dcast : dcast‚ÇÇ rfl rfl c = dcast dcast_eq.symm c

lemma towerRingHomBackwardMap_forwardMap_eq (k : ‚Ñï) (x : ConcreteBTField k) :
  towerRingHomBackwardMap (k:=k) (towerRingHomForwardMap (k:=k) x) = x

@[simp]
theorem Reduction.id_run (stmt : StmtIn) (wit : WitIn) :
    (Reduction.id : Reduction oSpec StmtIn WitIn _ _ _).run stmt wit =
      pure ‚ü®‚ü®default, stmt, wit‚ü©, stmt‚ü©

theorem Nat.shiftRight_lo_mod_2_pow_hi_shiftLeft_lo (n hi_len lo_len : ‚Ñï)
  (h_n : n < 2 ^ (hi_len + lo_len)) :
  (((n >>> lo_len) % (2 ^ hi_len)) <<< lo_len) = (n - n % 2 ^ lo_len)

@[simp]
theorem fflatten_one {A : Sort u} {F : A ‚Üí Sort v} {n : Fin 1 ‚Üí ‚Ñï}
    {Œ± : (i : Fin 1) ‚Üí (j : Fin (n i)) ‚Üí A}
    {v : (i : Fin 1) ‚Üí (j : Fin (n i)) ‚Üí F (Œ± i j)} :
    fflatten v = v 0

@[simp]
theorem induction_two' {motive : Fin 3 ‚Üí Sort*} {zero : motive 0}
    {succ : ‚àÄ i : Fin 2, motive i.castSucc ‚Üí motive i.succ} :
      induction (motive := motive) zero succ (2 : Fin 3) = succ 1 (succ 0 zero)

lemma forwardRange_length (n : ‚Ñï) (r : Fin n) (l : Fin (r.val + 1)) :
    (forwardRange n r l).length = r.val - l.val + 1

theorem happend_ext {Œ± : Fin m ‚Üí Sort u} {Œ≤ : Fin n ‚Üí Sort u}
    (u‚ÇÅ u‚ÇÇ : (i : Fin m) ‚Üí Œ± i) (v‚ÇÅ v‚ÇÇ : (i : Fin n) ‚Üí Œ≤ i) :
    happend u‚ÇÅ v‚ÇÅ = happend u‚ÇÇ v‚ÇÇ ‚Üî u‚ÇÅ = u‚ÇÇ ‚àß v‚ÇÅ = v‚ÇÇ

lemma getBit_eq_testBit (k n : Nat) : getBit k n = if n.testBit k then 1 else 0

theorem succ'_injective : Function.Injective (succ' : Nat ‚Üí Nat)

theorem fconcat_right_injective {Œ± : Fin n ‚Üí A} {Œ≤ : A} (v : (i : Fin n) ‚Üí F (Œ± i)) :
    Function.Injective (fconcat v : F Œ≤ ‚Üí (i : Fin (n + 1)) ‚Üí F (vconcat Œ± Œ≤ i))

theorem singleton_append (a : Œ±) (v : Fin n ‚Üí Œ±) :
    vappend !v[a] v = vcons a v ‚àò Fin.cast (Nat.add_comm _ n)

lemma getBit_of_multiple_of_power_of_two {n p : ‚Ñï}: ‚àÄ k,
  getBit (k) (2^p * n) = if k < p then 0 else getBit (k-p) n

theorem liftContext_soundness [Inhabited InnerStmtOut]
    {outerLangIn : Set OuterStmtIn} {outerLangOut : Set OuterStmtOut}
    {innerLangIn : Set InnerStmtIn} {innerLangOut : Set InnerStmtOut}
    {soundnessError : ‚Ñù‚â•0}
    {lens : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut}
    (V : Verifier oSpec InnerStmtIn InnerStmtOut pSpec)
    -- TODO: figure out the right compatibility relation for the IsSound condition
    [lensSound : lens.IsSound outerLangIn outerLangOut innerLangIn innerLangOut
      (V.compatStatement lens)]
    (h : V.soundness init impl innerLangIn innerLangOut soundnessError) :
      (V.liftContext lens).soundness init impl outerLangIn outerLangOut soundnessError

theorem oddRefinement_eq_novel_poly_of_1_leading_suffix (i : Fin ‚Ñì) (v : Fin (2 ^ i.val))
    (original_coeffs : Fin (2 ^ ‚Ñì) ‚Üí L) :
    have h_v: v.val ||

@[simp]
theorem simulateQ'_query_bind (q : OracleQuery spec Œ±)
    (ob : Œ± ‚Üí OracleComp spec Œ≤) (h : ‚àÄ x, (ob x).neverFails) :
    simulateQ' so (liftM q >>= ob) (by simp [h]) =
      so.impl q >>= (fun x => simulateQ' so (ob x) (h x))

lemma rank_eq_colRank : U.rank = colRank U

omit [NoZeroDivisors ùîΩ] in
lemma foldNth_degree_le' {n : ‚Ñï} {f : ùîΩ[X]} {Œ± : ùîΩ} [inst : NeZero n] :
    n * (foldNth n f Œ±).natDegree ‚â§ f.natDegree

@[simp]
protected lemma elocPolyF_eq_elocPoly :
  ElocPolyF (n := n) (liftF' œâs) (liftF' f) = ElocPoly n œâs f

theorem reduction_perfectCompleteness (hInit : init.neverFails) :
    (reduction R deg D n oSpec).perfectCompleteness init impl
      (relationRound R n deg D 0) (relationRound R n deg D (.last n))

@[simp]
theorem vflatten_one {n : Fin 1 ‚Üí ‚Ñï} {v : (i : Fin 1) ‚Üí Fin (n i) ‚Üí Œ±} :
    vflatten v = v 0

Nat.add_le_of_le_sub in Init.Data.Nat.Basic

theorem seqCompose_soundness
    (lang : (i : Fin (m + 1)) ‚Üí Set (Stmt i √ó ‚àÄ j, OStmt i j))
    (V : (i : Fin m) ‚Üí
      OracleVerifier oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Stmt i.succ) (OStmt i.succ)
        (pSpec i))
    (soundnessError : Fin m ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (V i).soundness init impl (lang i.castSucc) (lang i.succ) (soundnessError i)) :
      (OracleVerifier.seqCompose Stmt OStmt V).soundness init impl (lang 0) (lang (Fin.last m))
        (‚àë i, soundnessError i)

theorem sumcheckFoldOracleReduction_perfectCompleteness (hInit : init.neverFails) :
    OracleReduction.perfectCompleteness
      (pSpec := pSpecSumcheckFold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
      (relIn := roundRelation (mp := mp) ùîΩq Œ≤ (œë:=œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) 0)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë:=œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) (Fin.last ‚Ñì))
      (oracleReduction := sumcheckFoldOracleReduction ùîΩq Œ≤ (œë:=œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë))
      (init := init)
      (impl := impl)

theorem prime_23 : Nat.Prime 23

lemma getBit_of_lowBits {n: ‚Ñï} (numLowBits : ‚Ñï) : ‚àÄ k, getBit k (getLowBits numLowBits n) =
    if k < numLowBits then getBit k n else 0

Nat.pow_lt_pow_right in Init.Data.Nat.Lemmas

@[simp]
theorem ConcreteBTField.RingHom_cast_dest_apply (k m n : ‚Ñï) (h_eq : m = n)
  (f : ConcreteBTField k ‚Üí+* ConcreteBTField m) (x : ConcreteBTField k) :
    (cast (ConcreteBTField.RingHom_eq_of_dest_eq (k:=k) (m:=m) (n:=n) h_eq) f) x
    = cast (by apply cast_ConcreteBTField_eq (h_eq:=h_eq)) (f x)

@[simp] lemma twoAdicGenerators_succ_square_eq (idx : Nat) (h : idx < twoAdicity) :
    haveI : idx + 1 < twoAdicGenerators.length

theorem add_zero : p + 0 = p

@[simp]
theorem splitSum_embedSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (i : Fin m) (j : Fin (n i)) :
    splitSum (embedSum i j) = ‚ü®i, j‚ü©

lemma if_self_rfl {Œ± : Type*} [DecidableEq Œ±] (a b : Œ±) :
  (if a = b then b else a) = a

lemma neg_add_cancel {k : ‚Ñï} (a : ConcreteBTField k) : neg a + a = 0

@[simp]
theorem append_left_cancel_iff {pSpec : ProtocolSpec n} {p1 p2 : ProtocolSpec m} :
    p1 ++‚Çö pSpec = p2 ++‚Çö pSpec ‚Üî p1 = p2

@[simp]
theorem vflatten_zero {n : Fin 0 ‚Üí ‚Ñï} {v : (i : Fin 0) ‚Üí Fin (n i) ‚Üí Œ±} : vflatten v = !v[]

theorem toFun_eq_const_plus (t : AssocNat) : ‚àÄ m : Nat, t m = t 0 + m

lemma concrete_zero_mul
  (prevBTFieldProps : ConcreteBTFieldProps (k := k - 1))
  (a : ConcreteBTField k) : concrete_mul (zero (k:=k)) a = zero (k:=k)

private lemma sum_sum_K_i_eq_n_sub_d
  (h_B : 2 ‚â§ B.card)
  :
  ‚àë i, sum_choose_K_i B i = choose_2 B.card * (n - d B)

lemma and_two_pow_eq_two_pow_of_getBit_1 {n i : ‚Ñï} (h_getBit: getBit i n = 1) :
    n &&& (2 ^ i) = 2 ^ i

@[simp]
theorem embedSum_splitSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (k : Fin (vsum n)) :
    embedSum (splitSum k).1 (splitSum k).2 = k

lemma h_sum_two_same_pow2 {k : ‚Ñï} (h_pos : k > 0) : 2 ^ (k - 1) + 2 ^ (k - 1) = 2 ^ k

lemma getBit_of_add_distrib {n m k : ‚Ñï}
  (h_n_AND_m : n &&& m = 0) : getBit k (n + m) = getBit k n + getBit k m

theorem qMap_is_linear_map (i : Fin r) :
  IsLinearMap ùîΩq (f:=fun inner_p ‚Ü¶ (qMap ùîΩq Œ≤ i).comp inner_p)

lemma liftF_eq_of_lt {i : ‚Ñï} (h : i < n) : liftF f' i = f' ‚ü®i, h‚ü©

Nat.zero_le in Init.Prelude

theorem distFromCode_eq_top_iff_empty (u : n ‚Üí R) (C : Set (n ‚Üí R)) : Œî‚ÇÄ(u, C) = ‚ä§ ‚Üî C = ‚àÖ

theorem SkeletonNodeIndex.parent_of_depth_zero {s : Skeleton}
    (idx : SkeletonNodeIndex s) (h : idx.depth = 0) :
    parent idx = none

@[simp]
theorem hflatten_zero {n : Fin 0 ‚Üí ‚Ñï} {Œ± : (i : Fin 0) ‚Üí (j : Fin (n i)) ‚Üí Sort*}
    {v : (i : Fin 0) ‚Üí (j : Fin (n i)) ‚Üí Œ± i j} : hflatten v = !h[]

@[simp]
theorem fconcat_castSucc {Œ± : Fin n ‚Üí A} {Œ≤ : A}
    (v : (i : Fin n) ‚Üí F (Œ± i)) (b : F Œ≤) (i : Fin n) :
    (v :+ ∞‚¶ÉF‚¶Ñ b) (castSucc i) = cast (by simp [vconcat_castSucc]) (v i)

lemma eq_degree_of_equiv [LawfulBEq R] {p q : UniPoly R} : equiv p q ‚Üí p.degree = q.degree

theorem append_getLast_dropLast {Œ± : Type u} (l : List Œ±) (h : l ‚â† []) :
  l.dropLast ++ [l.getLast h] = l

omit [Fintype F] [DecidableEq F] in
private lemma choose_2_card_ne_zero (h : 2 ‚â§ B.card) : choose_2 ‚ÜëB.card ‚â† 0

@[grind]
lemma coeff_ne_zero {f q : F[X][Y]} (hg : q * f ‚â† 0) : q.coeff ‚â† 0

Nat.add_le_add_left in Init.Data.Nat.Basic

lemma fieldSize_sub_one_factorization : fieldSize - 1 = 2 ^ twoAdicity * 127

@[simp]
theorem verifier_last_of_two (pSpec : ProtocolSpec 2) [VerifierLast pSpec] :
    pSpec.dir 1 = .V_to_P

Fin.is_le' in Init.Data.Fin.Lemmas

@[simp]
theorem BTField.Basis_cast_dest_apply {Œπ : Type*} (Œ± Œ≤ Œ≥ : ‚Ñï) (h_le1 : Œ± ‚â§ Œ≤) (h_le2 : Œ± ‚â§ Œ≥)
    (h_eq : Œ≤ = Œ≥) {k : Œπ} (b : @Basis Œπ (BTField Œ±) (BTField Œ≤) _ _
    (@binaryAlgebraTower (l := Œ±) (r := Œ≤) (h_le := h_le1)).toModule) :
    let castBasis : @Basis Œπ (BTField Œ±) (BTField Œ≥) _ _
      (@binaryAlgebraTower (l := Œ±) (r := Œ≥) (h_le := h_le2)).toModule :=
      cast (by
        exact Basis_cast_dest_eq Œ± Œ≥ Œ≤ h_le2 h_le1 h_eq
      ) b
    (castBasis k) = cast (by exact BTField.cast_BTField_eq Œ≤ Œ≥ h_eq) (b k)

theorem get_drop_ofFn_eq_drop_comp_cast {Œ± : Type*} {m : ‚Ñï} (v : Fin n ‚Üí Œ±) (h : m ‚â§ n) :
    ((List.ofFn v).drop m).get =
      drop m h v ‚àò Fin.cast (by simp only [List.length_drop, List.length_ofFn])

@[simp]
theorem fappend_zero {Œ≤ : Fin m ‚Üí A} {Œ± : Fin 0 ‚Üí A}
    (u : (i : Fin m) ‚Üí F (Œ≤ i)) :
    fappend u (!h‚¶ÉF‚¶Ñ‚ü®Œ±‚ü©[] : (i : Fin 0) ‚Üí F (Œ± i)) = u

@[simp]
theorem OracleReduction.runWithLog_eq_runWithLog_reduction [‚àÄ i, OracleInterface (pSpec.Message i)]
    {stmt : StmtIn} {oStmt : ‚àÄ i, OStmtIn i} {wit : WitIn}
    {oracleReduction : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec} :
      oracleReduction.run stmt oStmt wit =
        oracleReduction.toReduction.run ‚ü®stmt, oStmt‚ü© wit

theorem degrees_peval {x : œÉ‚ÇÅ ‚Üí R} {f : œÉ ‚Üí œÉ‚ÇÅ ‚äï œÉ‚ÇÇ} {p : MvPolynomial œÉ R} :
    (peval f x p).degrees ‚â§ (p.degrees.map f).filterMap Sum.getRight?

theorem PowerBasis_cast_dest_eq (k n m : ‚Ñï) (h_k_le_n : k ‚â§ n)
  (h_k_le_m : k ‚â§ m) (h_eq : m = n) :
  letI instLeftAlgebra := ConcreteBTFieldAlgebra (l:=k) (r:=m) (h_le:=h_k_le_m)
  letI instRightAlgebra := ConcreteBTFieldAlgebra (l:=k) (r:=n) (h_le:=h_k_le_n)
  @PowerBasis (ConcreteBTField k) (ConcreteBTField m) _ _ instLeftAlgebra =
  @PowerBasis (ConcreteBTField k) (ConcreteBTField n) _ _ instRightAlgebra

lemma mca_list_decoding
  [Fintype Œπ] [Nonempty Œπ]
  (Gen : ProximityGenerator Œπ F) [Fintype Gen.par‚Ñì]
  (Œ¥ BStar : ‚Ñù) (errStar : ‚Ñù ‚Üí ENNReal)
  (fs us : Matrix Gen.par‚Ñì Œπ F)
  (IC : InterleavedCode Gen.par‚Ñì Œπ F)
  (haveIC : IC = codeOfLinearCode Gen.par‚Ñì Gen.C)
      (hGen : hasMutualCorrAgreement Gen BStar errStar)
  (C : Set (Œπ ‚Üí F)) (hC : C = Gen.C) :
    haveI := Gen.Gen_nonempty
    ‚àÄ {fs : Matrix Gen.par‚Ñì Œπ F}
    (hŒ¥Pos : Œ¥ > 0) (hŒ¥Lt : Œ¥ < min (Œ¥·µ£ C : ‚Ñù) (1 - BStar)),
      Pr_{let r ‚Üê$·µñ Gen.Gen}[ proximityListDecodingCondition Gen.C r Œ¥ fs IC ]
        ‚â§ errStar Œ¥

omit [NeZero ‚Ñì] [NeZero r] [NeZero ùì°] in
lemma fin_‚Ñì_lt_r {h_‚Ñì_add_R_rate : ‚Ñì + ùì° < r} (i : Fin ‚Ñì)
    : i.val < r

theorem functional_completeness (Œ± : Type) {s : Skeleton}
  (idx : SkeletonLeafIndex s)
  (leaf_data_tree : LeafData Œ± s)
  (hash : Œ± ‚Üí Œ± ‚Üí Œ±) :
  (getPutativeRoot_with_hash
    idx
    (leaf_data_tree.get idx)
    (generateProof
      (buildMerkleTree_with_hash leaf_data_tree hash) idx)
    (hash)) =
  (buildMerkleTree_with_hash leaf_data_tree hash).getRootValue

lemma divide_by_2_def {s : Finset ‚Ñï} :
    divide_by_2 s = (erase_odd s).image (fun n => n / 2)

lemma forwardRange_dropLast (n : ‚Ñï) (r : Fin (n - 1)) (l : Fin (r.val + 1)) :
    (forwardRange n ‚ü®r + 1, by omega‚ü© ‚ü®l, by simp only; omega‚ü©).dropLast
    = forwardRange n ‚ü®r, by omega‚ü© ‚ü®l, by simp only [Fin.is_lt]‚ü©

lemma lin_shift_card [Field F] [Fintype F]
  :
  B.card = ({ x - v | x ‚àà B} : Finset _).card

theorem matchSize_toList {a b : Array Œ±} {unit : Œ±} :
    matchSize a b unit =
      let (a', b') := List.matchSize a.toList b.toList unit
      (mk a', mk b')

lemma erase_even_def {s : Finset ‚Ñï} :
    erase_even s = s.filter Odd

@[simp]
theorem bool_accepts_iff : (bool j).accepts x ‚Üî x j * (x j - 1) = 0

@[grind]
lemma quotient_nezero {f q : F[X][Y]} (hg : q * f ‚â† 0) : q ‚â† 0

Nat.cast_pow in Mathlib.Data.Nat.Cast.Basic

lemma and_eq_zero_iff {n m : ‚Ñï} : n &&& m = 0 ‚Üî ‚àÄ k, (n >>> k) &&& (m >>> k) = 0

lemma folding_preserves_listdecoding_base_ne_subset
  {S : Finset Œπ} {k m : ‚Ñï} (hm : 1 ‚â§ m) {œÜ : Œπ ‚Ü™ F} [Smooth œÜ] {Œ¥ : ‚Ñù‚â•0}
  {S_0 : Finset (indexPowT S œÜ 0)} {S_1 : Finset (indexPowT S œÜ 1)}
  {œÜ_0 : (indexPowT S œÜ 0) ‚Ü™ F} {œÜ_1 : (indexPowT S œÜ 1) ‚Ü™ F}
  [‚àÄ i : ‚Ñï, Fintype (indexPowT S œÜ i)] [‚àÄ i : ‚Ñï, DecidableEq (indexPowT S œÜ i)]
  [Smooth œÜ_0] [Smooth œÜ_1]
  [h : ‚àÄ {f : (indexPowT S œÜ 0) ‚Üí F}, DecidableBlockDisagreement 0 k f S_0 œÜ_0]
  [h : ‚àÄ {f : (indexPowT S œÜ 1) ‚Üí F}, DecidableBlockDisagreement 1 k f S_1 œÜ_1]
  [‚àÄ i : ‚Ñï, Neg (indexPowT S œÜ i)]
  {C : Set ((indexPowT S œÜ 0) ‚Üí F)} (hcode : C = smoothCode œÜ_0 m)
  (C' : Set ((indexPowT S œÜ 1) ‚Üí F)) (hcode' : C' = smoothCode œÜ_1 (m-1))
  {BStar : (Set (indexPowT S œÜ 1 ‚Üí F)) ‚Üí ‚Ñï ‚Üí ‚Ñù‚â•0}
  {errStar : (Set (indexPowT S œÜ 1 ‚Üí F)) ‚Üí ‚Ñï ‚Üí ‚Ñù‚â•0 ‚Üí ‚Ñù‚â•0} :
    Pr_{let Œ± ‚Üê$·µñ F}[ ‚àÄ { f : (indexPowT S œÜ 0) ‚Üí F} (hŒ¥Le: Œ¥ ‚â§ 1 - (BStar C' 2)),
                      let listBlock : Set ((indexPowT S œÜ 0) ‚Üí F) := Œõ·µ£(0, k, f, S_0, C, hcode, Œ¥)
                      let vec_Œ± : Fin 1 ‚Üí F := (fun _ : Fin 1 => Œ±)
                      let foldSet := fold_k_set listBlock vec_Œ± hm
                      let fold := fold_k f vec_Œ± hm
                      let listBlock' : Set ((indexPowT S œÜ 1) ‚Üí F)
                        := Œõ·µ£(1, k, fold, S_1, C', hcode', Œ¥)
                      ¬¨ (listBlock' ‚äÜ foldSet)
                    ] < errStar C' 2 Œ¥

theorem append_rbrKnowledgeSoundness (V‚ÇÅ : OracleVerifier oSpec Stmt‚ÇÅ OStmt‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : OracleVerifier oSpec Stmt‚ÇÇ OStmt‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ pSpec‚ÇÇ)
    {rbrKnowledgeError‚ÇÅ : pSpec‚ÇÅ.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    {rbrKnowledgeError‚ÇÇ : pSpec‚ÇÇ.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    (h‚ÇÅ : V‚ÇÅ.rbrKnowledgeSoundness init impl rel‚ÇÅ rel‚ÇÇ rbrKnowledgeError‚ÇÅ)
    (h‚ÇÇ : V‚ÇÇ.rbrKnowledgeSoundness init impl rel‚ÇÇ rel‚ÇÉ rbrKnowledgeError‚ÇÇ) :
      (V‚ÇÅ.append V‚ÇÇ).rbrKnowledgeSoundness init impl rel‚ÇÅ rel‚ÇÉ
        (Sum.elim rbrKnowledgeError‚ÇÅ rbrKnowledgeError‚ÇÇ ‚àò ChallengeIdx.sumEquiv.symm)

Fin.append_right in Mathlib.Data.Fin.Tuple.Basic

@[ext] theorem UniPolyC.ext {p q : UniPolyC R} (h : p.val = q.val) : p = q

theorem ZMod.powNeOfPowMod :
    ‚àÄ {n a' q c : ‚Ñï} (a : ZMod n), (a' : ZMod n) = a ‚Üí decide (n ‚â• 2) = true ‚Üí
      Nat.mod (Nat.pow a' ((n - 1) / q)) n = c ‚Üí decide (c ‚â† 1) = true ‚Üí a ^ ((n - 1) / q) ‚â† 1

theorem Nat.shiftRight_eq_sub_mod_then_div_two_pow {n lo_len : ‚Ñï} :
  n >>> lo_len = (n - n % 2 ^ lo_len) / 2 ^ lo_len
</all_available_lemmas>

<local_ctx>
import ArkLib.Data.FieldTheory.AdditiveNTT.NovelPolynomialBasis

import Mathlib.Tactic

import Mathlib.Data.Finsupp.Defs

import Mathlib.LinearAlgebra.LinearIndependent.Defs

open Polynomial AdditiveNTT Module

namespace AdditiveNTT

variable {r : ‚Ñï} [NeZero r]

variable {L : Type u} [Field L] [Fintype L] [DecidableEq L]

variable (ùîΩq : Type u) [Field ùîΩq] [Fintype ùîΩq] [DecidableEq ùîΩq]
  [h_Fq_char_prime : Fact (Nat.Prime (ringChar ùîΩq))] [hF‚ÇÇ : Fact (Fintype.card ùîΩq = 2)]

variable [Algebra ùîΩq L]

variable (Œ≤ : Fin r ‚Üí L) [hŒ≤_lin_indep : Fact (LinearIndependent ùîΩq Œ≤)]
  [h_Œ≤‚ÇÄ_eq_1 : Fact (Œ≤ 0 = 1)]

variable {‚Ñì R_rate : ‚Ñï} (h_‚Ñì_add_R_rate : ‚Ñì + R_rate < r)-- ‚Ñì ‚àà {1, ..., r-1}

section IntermediateStructures

noncomputable def sDomain (i : Fin r) : Subspace ùîΩq L :=
  let W_i_norm := normalizedW ùîΩq Œ≤ i
  let h_W_i_norm_is_additive : IsLinearMap ùîΩq (fun x : L => W_i_norm.eval x) :=
    AdditiveNTT.normalizedW_is_additive ùîΩq Œ≤ i
  Submodule.map (polyEvalLinearMap W_i_norm h_W_i_norm_is_additive)
    (U ùîΩq Œ≤ ‚ü®‚Ñì + R_rate, h_‚Ñì_add_R_rate‚ü©)

def sBasis (i : Fin r) (h_i : i < ‚Ñì + R_rate) : Fin (‚Ñì + R_rate - i) ‚Üí L :=
  fun k => Œ≤ ‚ü®i + k.val, by admit /- proof elided -/
  ‚ü©
</local_ctx>

<target_theorem>
lemma sDomain_eq_image_of_upper_span (i : Fin r) (h_i : i < ‚Ñì + R_rate) :
    let V_i :=
</target_theorem>

