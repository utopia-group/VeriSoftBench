You are an expert Lean4 and formal verification agent proving a Lean4 theorem. Your output **must** strictly adhere to the specified format.

### Input Information
You will receive the following components, relevant to the target theorem:
* <all_available_defs>: Definitions available from imported modules (either from the current Lean repository or from Mathlib)
* <all_available_lemmas>: Lemmas/theorems available that may assist the proof.
* <local_ctx>...</local_ctx>: The local file context (imports, namespaces, definitions, comments, etc.) from the top of the file up to‚Äîbut not including‚Äîthe target theorem or any previously defined local lemmas/theorems.
* <target_theorem>...</target_theorem>: The target theorem statement, ending with `:=`.

**Notes**
1. Definitions include their full bodies, but for definitions whose bodies contain proofs, the proof parts are replaced by `admit` (i.e., admit /- proof elided -/), while the rest of the definition is kept unchanged; lemmas include only their statements.
2. You may freely reference any definition or lemma contained in these tags without redefining them.
3. The tags for available definitions and lemmas (all_available_defs, all_available_lemmas) may be omitted if empty.

### Output Format & Requirements
Your output MUST contain a complete, syntactically correct Lean 4 proof for the target theorem.

**Strict Output Structure:**
<reasoning> 
...
</reasoning> 

<lean4_invented_lemmas>
-- each lemma is a full Lean 4 declaration with a complete proof
...
</lean4_invented_lemmas>

<lean4_proof>
-- Lean 4 proof body of the target theorem
...
</lean4_proof>

**Requirements:**
1. <reasoning> and <lean4_invented_lemmas> are OPTIONAL. Include them only if they aid proof construction.
2. <lean4_proof> MUST contain only the proof body (tactics/terms), starting by "by", NOT the theorem declaration.
3. <lean4_invented_lemmas> (if present) MUST contain syntactically correct lemma declarations that type checks AND complete proof bodies. Defining a lemma using `axiom` is NOT allowed.
4. <reasoning> contains high-level proof planning.
5. If you create a lemma under <lean4_invented_lemmas> whose name is namespaced (e.g., X.Y.Z), you MUST always refer to it using its fully qualified name. Do NOT rely on shortened names. For example, write rw [X.Y.Z], not rw [Z] for invented lemmas.
6. All Lean 4 code MUST be syntactically correct. No `sorry`, `admit`, or non-Lean text. Comments allowed using `--` or `/- ... -/`.
7. Follow the tags and structure EXACTLY. No extra text before, between, or after the sections.
8. Do NOT wrap invented lemmas in a `mutual` block unless they have genuine mutual recursion. Declare each lemma independently.

### Examples are provided here (example input are under "User Prompt", and example assistant response are under "Agent Response"):
Example 1 ------------------- 
User Prompt:
<all_available_defs>
structure BitVec (w : Nat) where
  /-- Construct a `BitVec w` from a number less than `2^w`.
  O(1), because we use `Fin` as the internal representation of a bitvector. -/
  ofFin ::

  /-- Interpret a bitvector as a number less than `2^w`.
  O(1), because we use `Fin` as the internal representation of a bitvector. -/
  toFin : Fin (hPow 2 w)
</all_available_defs>

<all_available_lemmas>
theorem List.getElem_append_left{Œ± : Type u_1} {l‚ÇÅ l‚ÇÇ : List Œ±} {i : Nat} (hn : i < l‚ÇÅ.length) : (l‚ÇÅ ++ l‚ÇÇ)[i] = l‚ÇÅ[i]
theorem getElem_eq_testBit_toNat (x : BitVec w) (i : Nat) (h : i < w) :
  x[i] = x.toNat.testBit i := rfl
@[simp, grind =] theorem toNat_cons (b : Bool) (x : BitVec w) :
    (cons b x).toNat = (b.toNat <<< w) ||| x.toNat
@[simp, grind =] theorem getLsbD_of_ge (x : BitVec w) (i : Nat) (ge : w ‚â§ i) : getLsbD x i = false
theorem testBit_toNat (x : BitVec w) : x.toNat.testBit i = x.getLsbD i
</all_available_lemmas>

<local_ctx>
import Mathlib.Computability.NFA
import Mathlib.Data.FinEnum
import Mathlib.Data.Rel
import Mathlib.Data.Vector.Basic
import Blase.AutoStructs.ForLean

open Set
open Mathlib
open SetRel

-- this is better because card is defeq to n
instance (Œ± : Type) : Inter (Language Œ±) := ‚ü®Set.inter‚ü©
instance (Œ± : Type) : Union (Language Œ±) := ‚ü®Set.union‚ü©

/--
The set of `n`-tuples of bit vectors of an arbitrary width.
-/
structure BitVecs (n : Nat) where
  w : Nat
  bvs : List.Vector (BitVec w) n

def BitVecs.cast (bvs : BitVecs n) (h : n = n') : BitVecs n' :=
  { w := bvs.w, bvs := h ‚ñ∏ bvs.bvs }

abbrev BitVecs.empty : BitVecs n := ‚ü®0, List.Vector.replicate n .nil‚ü©
abbrev BitVecs.singleton {w : Nat} (bv : BitVec w) : BitVecs 1 := ‚ü®w, bv ::·µ• .nil‚ü©
abbrev BitVecs.pair {w : Nat} (bv1 bv2 : BitVec w) : BitVecs 2 := ‚ü®w, bv1 ::·µ• bv2 ::·µ• .nil‚ü©

/--
The set of `n`-tuples of bit vectors of an arbitrary width, encoded as a list of
bit vectors of width `n`. The width of the encoded bit vectors is the length of
the list.
-/
abbrev BitVecs' (n : Nat) := List (BitVec n)

@[simps]
def dec (bvs' : BitVecs' n) : BitVecs n where
  w := bvs'.length
  bvs := List.Vector.ofFn fun k => BitVec.ofFn fun i => bvs'[i].getLsbD k

@[simp]
</local_ctx>

<target_theorem>
lemma dec_snoc n (bvs' : BitVecs' n) (a : BitVec n) :
  dec (bvs' ++ [a]) =
    { w := bvs'.length + 1
      bvs := List.Vector.ofFn fun k =>
        BitVec.cons (a.getLsbD k) ((dec bvs').bvs.get k) } :=
</target_theorem>

Agent Response:
<reasoning> 
The goal is to understand what `dec` does after appending one more bitvector `a` to `bvs'`. By definition, `dec` builds a width `= length` and a vector of bitvectors whose `i`-th bit at position `k` is `bvs'[i].getLsbD k`. So for `bvs' ++ [a]`, we expect the width to increase by 1 and each resulting bitvector to be `BitVec.cons` of the new bit coming from `a`.

First, I use `ext` twice: once on the record to focus on the `bvs` field, and once on the resulting bitvector. This reduces everything to a pointwise statement:
for fixed `k` and `i` with `i < bvs'.length + 1`,
the bit `(bvs' ++ [a])[i].getLsbD k` should match the bit at index `i` of `BitVec.cons (a.getLsbD k) ((dec bvs').bvs.get k)`.

At this point I need a clean description of indexing into `BitVec.cons`: if we have `x : BitVec n`, then `(cons b x)[i]` should give `b` at the new ‚Äúlast‚Äù index `n` and `x[i]` otherwise. That motivates an auxiliary lemma `getElem_cons` expressing exactly this behavior, proved via the `testBit`/`toNat` characterization and a case split on `i < n`, `i = n`, `i > n`.

Using `getElem_cons`, the RHS becomes an `if` on whether `i = bvs'.length`. So I split into cases:
- If `i = bvs'.length`, then `(bvs' ++ [a])[i]` is the appended `a`, so both sides reduce to `a.getLsbD k`.
- If `i ‚â† bvs'.length`, the bound `i < bvs'.length + 1` forces `i < bvs'.length`. Then `(bvs' ++ [a])[i] = bvs'[i]` by `List.getElem_append_left`, and the RHS takes the ‚Äúelse‚Äù branch and likewise gives the bit from `bvs'[i]`. In both subcases, `simp` (plus the definition of `dec`) finishes.

So the whole proof is: `ext` to bit level, unfold `dec` with `simp_all`, rewrite with `getElem_cons`, split on the boundary index `i = length bvs'`, and in the ‚Äú< length‚Äù branch use `List.getElem_append_left` and bounds to line up both sides.
</reasoning> 

<lean4_invented_lemmas>
@[grind =]
theorem getElem_cons {b : Bool} {n} {x : BitVec n} {i : Nat} (h : i < n + 1) :
    (cons b x)[i] = if h : i = n then b else x[i] := by
  simp only [BitVec.getElem_eq_testBit_toNat, BitVec.toNat_cons, Nat.testBit_or]
  rw [Nat.testBit_shiftLeft]
  rcases Nat.lt_trichotomy i n with i_lt_n | i_eq_n | n_lt_i
  ¬∑ have p1 : ¬¨(n ‚â§ i) := by omega
    have p2 : i ‚â† n := by omega
    simp [p1, p2]
  ¬∑ simp only [i_eq_n, ge_iff_le, Nat.le_refl, decide_true, Nat.sub_self, Nat.testBit_zero,
    Bool.true_and, BitVec.testBit_toNat, BitVec.getLsbD_of_ge, Bool.or_false]
    cases b <;> trivial
  ¬∑ have p1 : i ‚â† n := by omega
    have p2 : i - n ‚â† 0 := by omega
    simp [p1, p2, Nat.testBit_bool_toNat]
</lean4_invented_lemmas>

<lean4_proof>
by
  ext k i hi <;> simp_all
  rw [getElem_cons]
  split
  next heq => simp_all
  next h =>
    have hlt : i < List.length bvs' := by simp at hi; omega
    rw [List.getElem_append_left hlt]
    simp
</lean4_proof>

### Your task:
<all_available_defs>
Fin in Init.Prelude
Subspace in Mathlib.Algebra.Module.Submodule.Basic
Set in Mathlib.Data.Set.Defs
Set.Ico in Mathlib.Order.Interval.Set.Defs
Submodule in Mathlib.Algebra.Module.Submodule.Defs
Submodule.span in Mathlib.LinearAlgebra.Span.Defs
Polynomial.C in Mathlib.Algebra.Polynomial.Basic
Nat in Init.Prelude
Fin.castLE in Init.Data.Fin.Basic
Finset in Mathlib.Data.Finset.Defs
Finset.univ in Mathlib.Data.Fintype.Defs
Polynomial.rootMultiplicity in Mathlib.Algebra.Polynomial.Div
Function.Injective in Init.Data.Function
Multiset in Mathlib.Data.Multiset.Defs
Multiset.count in Mathlib.Data.Multiset.Count
Multiset.map in Mathlib.Data.Multiset.MapFold
Polynomial in Mathlib.Algebra.Polynomial.Basic
Polynomial.roots in Mathlib.Algebra.Polynomial.Roots
SetLike in Mathlib.Data.SetLike.Basic
DecidableEq in Init.Prelude
Fintype in Mathlib.Data.Fintype.Defs
Iff in Init.Core
CommRing in Mathlib.Algebra.Ring.Defs
Polynomial.algEquivOfCompEqX in Mathlib.Algebra.Polynomial.AlgebraMap
multiplicity in Mathlib.RingTheory.Multiplicity
EmbeddingLike in Mathlib.Data.FunLike.Embedding
CanLift in Mathlib.Tactic.Lift
Eq in Init.Prelude
Multiset.filter in Mathlib.Data.Multiset.Filter
id in Init.Prelude
Finset.val in Mathlib.Data.Finset.Defs
Set.InjOn in Mathlib.Data.Set.Operations
Subtype in Init.Prelude
Subtype.val in Init.Prelude
LinearIndependent in Mathlib.LinearAlgebra.LinearIndependent.Defs
Set.image in Mathlib.Data.Set.Defs

def getBit (k n : Nat) : Nat := (n >>> k) &&& 1

structure DomainSeparator (U : Type) [SpongeUnit U] (H : Type*) [DuplexSpongeInterface U H] where
   
  io : String
deriving Repr

instance : SliceLT (ProtocolSpec n) ‚Ñï
    (fun _ stop => stop ‚â§ n)
    (fun _ stop _ => ProtocolSpec stop)
    where
  sliceLT := fun v stop h => take stop h v

noncomputable def eval_on_Z‚ÇÄ (p : (RatFunc F)) (z : F) : F :=
  RatFunc.eval (RingHom.id _) z p


notation3:max R "[Z][X]" => Polynomial (Polynomial R)

notation3:max R "[Z][X][Y]" => Polynomial (Polynomial (Polynomial (R)))

notation3:max "Y" => Polynomial.X
notation3:max "X" => Polynomial.C Polynomial.X
notation3:max "Z" => Polynomial.C (Polynomial.C Polynomial.X)

Odd in Mathlib.Algebra.Ring.Parity

@[inline, specialize]
def Reduction.runWithLog (stmt : StmtIn) (wit : WitIn)
    (reduction : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí)
        (((FullTranscript pSpec √ó StmtOut √ó WitOut) √ó StmtOut) √ó
          QueryLog (oSpec ++‚Çí [pSpec.Challenge]‚Çí) √ó QueryLog oSpec) := do
  
  let ‚ü®proverResult, proveQueryLog‚ü© ‚Üê reduction.prover.runWithLog stmt wit
  let ‚ü®stmtOut, verifyQueryLog‚ü© ‚Üê
    liftM (simulateQ loggingOracle (reduction.verifier.run stmt proverResult.1)).run
  return ‚ü®‚ü®proverResult, stmtOut‚ü©, proveQueryLog, verifyQueryLog‚ü©

protected def cast (R : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec‚ÇÅ) :
    OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec‚ÇÇ where
  prover := R.prover.cast hn hSpec
  verifier := R.verifier.cast hn hSpec hO‚Çò

def extractability (scheme : Scheme oSpec Data Randomness Commitment pSpec)
    (extractabilityError : ‚Ñù‚â•0) : Prop :=
  ‚àÉ extractor : StraightlineExtractor oSpec Data Commitment,
  ‚àÄ AuxState : Type,
  ‚àÄ adversary : ExtractabilityAdversary oSpec Data Commitment AuxState,
  ‚àÄ prover : Prover oSpec (Commitment √ó O.Query √ó O.Response) AuxState Bool Unit pSpec,
    False

List.rtake in Mathlib.Data.List.DropRight

def domainEnum (i : Fin (n + 1)) : Fin (2 ^ (n - i)) ‚Ü™ evalDomain D i :=
  ‚ü®domain D n i.1, domain_injective D i.1 (by admit /- proof elided -/
  )‚ü©

abbrev SEP_CHAR : Char := Char.ofNat 0

private def k [Zero F] (B : Finset (Fin n ‚Üí F)) : ‚Ñö :=
  (1 : ‚Ñö) / n * ‚àë i, K B i 0

def ar2 (k0 k1 : ‚Ñï) : Fin 2 ‚Üí ‚Ñï
  | ‚ü®0, _‚ü© => k0
  | ‚ü®1, _‚ü© => k1

noncomputable def basisVectors (‚Ñì : Nat) (h_‚Ñì : ‚Ñì ‚â§ r) :
  Fin (2 ^ ‚Ñì) ‚Üí L‚¶É<2^‚Ñì‚¶Ñ[X] :=
  fun j => ‚ü®X‚±º ùîΩq Œ≤ ‚Ñì h_‚Ñì j, by admit /- proof elided -/
  ‚ü©

def LawfulInterleavedCode (Œ∫ : Type*) [Fintype Œ∫] (Œπ : Type*) [Fintype Œπ]
                          (F : Type*) [Semiring F] :=
  { IC : InterleavedCode Œ∫ Œπ F // IC.isInterleaved }

@[inline, specialize]
def oracleReduction : OracleReduction oSpec
    Statement OStatement Unit Statement OStatement Unit !p[] where
  prover := oracleProver oSpec Statement OStatement
  verifier := oracleVerifier oSpec Statement OStatement pred

def totalNumPermQueriesMessage : Nat :=
  ‚àë i, pSpec.L‚Çö·µ¢ i

class DCast‚ÇÇ (Œ± : Sort*) (Œ≤ : Œ± ‚Üí Sort*) (Œ≥ : (a : Œ±) ‚Üí Œ≤ a ‚Üí Sort*) [DCast Œ± Œ≤] where
  dcast‚ÇÇ : ‚àÄ {a a' : Œ±} {b : Œ≤ a} {b' : Œ≤ a'},
    (ha : a = a') ‚Üí (dcast ha b = b') ‚Üí Œ≥ a b ‚Üí Œ≥ a' b'
  dcast‚ÇÇ_id : ‚àÄ {a : Œ±} {b : Œ≤ a}, dcast‚ÇÇ (Eq.refl a) dcast_eq = (id : Œ≥ a b ‚Üí Œ≥ a b)

BitVec.zero in Init.Data.BitVec.Basic

def getPutativeRoot_with_hash {s} (idx : BinaryTree.SkeletonLeafIndex s)
    (leafValue : Œ±) (proof : List Œ±) (hashFn : Œ± ‚Üí Œ± ‚Üí Œ±) : Œ± :=
  match proof with
  | [] => leafValue 
  | siblingBelowRootHash :: restProof =>
    match idx with
    | BinaryTree.SkeletonLeafIndex.ofLeaf =>
      
      
      
      leafValue
    | BinaryTree.SkeletonLeafIndex.ofLeft idxLeft =>
      
      hashFn (getPutativeRoot_with_hash idxLeft leafValue restProof hashFn) siblingBelowRootHash
    | BinaryTree.SkeletonLeafIndex.ofRight idxRight =>
      
      hashFn siblingBelowRootHash (getPutativeRoot_with_hash idxRight leafValue restProof hashFn)

def churchTrue : ChurchBool Œ± := fun x _ => x

CommGroupWithZero in Mathlib.Algebra.GroupWithZero.Defs

noncomputable def evaluationPointœâ (i : Fin (‚Ñì + 1))
    (x : Fin (2 ^ (‚Ñì + R_rate - i))) : L := 
    
  ‚àë (‚ü®k, hk‚ü©: Fin (‚Ñì + R_rate - i)),
    if Nat.getBit k x.val = 1 then
      (normalizedW ùîΩq Œ≤ ‚ü®i, by admit /- proof elided -/
      ‚ü©).eval (Œ≤ ‚ü®i + k, by admit /- proof elided -/
      ‚ü©)
    else
      0

@[reducible]
def pSpec (F : Type) [Semiring F] : ProtocolSpec 2 := ‚ü®!v[.V_to_P, .P_to_V], !v[F, Unit ‚Üí F[X]]‚ü©

@[reducible, simp] def StmtOut := Query OStatement

hammingDist in Mathlib.InformationTheory.Hamming

@[inline]
def seqCompose {m : ‚Ñï} (Stmt : Fin (m + 1) ‚Üí Type)
    {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (V : (i : Fin m) ‚Üí Verifier oSpec (Stmt i.castSucc) (Stmt i.succ) (pSpec i)) :
    Verifier oSpec (Stmt 0) (Stmt (Fin.last m)) (seqCompose pSpec) := match m with
  | 0 => Verifier.id
  | _ + 1 => append (V 0) (seqCompose (Stmt ‚àò Fin.succ) (fun i => V (Fin.succ i)))

@[reducible]
def fieldSize : Nat := 2 ^ 31 - 2 ^ 27 + 1

def churchCons (x : Œ±) (xs : ChurchVec Œ±) : ChurchVec Œ± :=
  fun f base => f x (xs f base)

@[reducible, inline]
def OracleProver {Œπ : Type} (oSpec : OracleSpec Œπ)
    (StmtIn : Type) {Œπ‚Çõ·µ¢ : Type} (OStmtIn : Œπ‚Çõ·µ¢ ‚Üí Type) (WitIn : Type)
    (StmtOut : Type) {Œπ‚Çõ‚Çí : Type} (OStmtOut : Œπ‚Çõ‚Çí ‚Üí Type) (WitOut : Type)
    {n : ‚Ñï} (pSpec : ProtocolSpec n) :=
  Prover oSpec (StmtIn √ó (‚àÄ i, OStmtIn i)) WitIn (StmtOut √ó (‚àÄ i, OStmtOut i)) WitOut pSpec

noncomputable def commitOracleReduction (i : Fin ‚Ñì) (hCR : isCommitmentRound ‚Ñì œë i) :
  OracleReduction (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) Context i.succ)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (pSpec := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) where
  prover := commitOracleProver ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i
  verifier := commitOracleVerifier ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hCR

def PowerType (n : ‚Ñï) : Type := dfoldr' n (fun _ => Type) (fun _ T => T ‚Üí T) Nat


example : PowerType 0 = Nat := rfl
example (n : ‚Ñï) : PowerType (n + 1) = (PowerType n ‚Üí PowerType n) := rfl

def divX (p : UniPoly R) : UniPoly R := p.extract 1 p.size

@[simp]
def poly (k : ‚Ñï) : Polynomial (BTField k) := definingPoly (s:=(Z k))

def subLeftFull (U : Matrix (Fin m) (Fin n) F) (c_reindex : Fin m ‚Üí Fin n) :
  Matrix (Fin m) (Fin m) F := Matrix.submatrix U id c_reindex

Finset.product in Mathlib.Data.Finset.Prod

noncomputable def queryProver :
  OracleProver []‚Çí
    (FinalStatement F k) (FinalOracleStatement D x s) (Witness F s d (Fin.last (k + 1)))
    (FinalStatement F k) (FinalOracleStatement D x s) (Witness F s d (Fin.last (k + 1)))
    (pSpec D x l) where
  PrvState
  | _ =>
    (FinalStatement F k √ó ((i : Fin (k + 2)) ‚Üí FinalOracleStatement D x s i)) √ó
      Witness F s d (Fin.last (k + 1))

  input := id

  sendMessage
  | ‚ü®0, h‚ü© => nomatch h

  receiveChallenge
  | ‚ü®1, _‚ü© => fun x => pure <| fun _ => x

  output := pure

IsLinearMap in Mathlib.Algebra.Module.LinearMap.Defs

@[reducible, simp]
def StmtIn := R

abbrev Bwd : PermuteDir := Sum.inr ()

instance : SMul R (UniPoly R) := ‚ü®UniPoly.smul‚ü©

Polynomial.support in Mathlib.Algebra.Polynomial.Basic

class IsSecureWithGap
    (completeRelation : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (soundRelation : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (Œµ_rbr : vPSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0)
    (vectorIOP : VectorIOP Statement OStatement Witness vPSpec A) where

   
  is_complete : vectorIOP.perfectCompleteness (pure ()) ‚ü®isEmptyElim‚ü© completeRelation

   
  is_rbr_knowledge_sound :
    OracleProof.rbrKnowledgeSoundness (pure ()) ‚ü®isEmptyElim‚ü© soundRelation vectorIOP.verifier Œµ_rbr

@[reducible]
noncomputable def fullOracleReduction :
  OracleReduction (oSpec:=[]‚Çí)
    (StmtIn := Statement (L := L) (‚Ñì:=‚Ñì) (SumcheckBaseContext L ‚Ñì) 0)
    (OStmtIn:= OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë 0)
    (StmtOut := Bool)
    (OStmtOut := fun _ : Empty => Unit)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) 0)
    (WitOut := Unit)
    (pSpec := fullPSpec ùîΩq Œ≤ Œ≥_repetitions (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)) :=
  OracleReduction.append (oSpec:=[]‚Çí)
    (Stmt‚ÇÅ := Statement (L := L) (‚Ñì:=‚Ñì) (SumcheckBaseContext L ‚Ñì) 0)
    (Stmt‚ÇÇ := FinalSumcheckStatementOut (L:=L) (‚Ñì:=‚Ñì))
    (Stmt‚ÇÉ := Bool)
    (Wit‚ÇÅ := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) 0)
    (Wit‚ÇÇ := Unit)
    (Wit‚ÇÉ := Unit)
    (OStmt‚ÇÅ := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë 0)
    (OStmt‚ÇÇ := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (OStmt‚ÇÉ := fun _ : Empty => Unit)
    (pSpec‚ÇÅ := pSpecCoreInteraction ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (pSpec‚ÇÇ := pSpecQuery ùîΩq Œ≤ Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (R‚ÇÅ := CoreInteraction.coreInteractionOracleReduction ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (œë:=œë) (ùìë:=ùìë))
    (R‚ÇÇ := QueryPhase.queryOracleReduction ùîΩq Œ≤ Œ≥_repetitions
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (œë:=œë))

def monomialY (n : ‚Ñï) : F[X] ‚Üí‚Çó[F[X]] F[X][Y] where
  toFun t := ‚ü®Finsupp.single n t‚ü©
  map_add' x y := by admit /- proof elided -/

multiplicity in Mathlib.RingTheory.Multiplicity

structure Gate (ùì° : Type*) (numWires : ‚Ñï) extends Selector ùì°, WireIndices numWires
deriving DecidableEq

def getPutativeRoot {s} (idx : BinaryTree.SkeletonLeafIndex s) (leafValue : Œ±)
    (proof : List Œ±) : OracleComp (spec Œ±) Œ± :=
  match proof with
  | [] => return leafValue 
  | siblingBelowRootHash :: restProof => do
    match idx with
    | BinaryTree.SkeletonLeafIndex.ofLeaf =>
      
      
      
      return leafValue
    | BinaryTree.SkeletonLeafIndex.ofLeft idxLeft =>
      
      let ancestorBelowRootHash ‚Üê getPutativeRoot idxLeft leafValue restProof
      singleHash ancestorBelowRootHash siblingBelowRootHash
    | BinaryTree.SkeletonLeafIndex.ofRight idxRight =>
      
      let ancestorBelowRootHash ‚Üê getPutativeRoot idxRight leafValue restProof
      singleHash siblingBelowRootHash ancestorBelowRootHash

def pSpecFullNonLastBlock (bIdx : Fin (‚Ñì / œë - 1)) :=
  (pSpecFoldRelaySequence (L:=L) (n:=œë - 1) ++‚Çö
      pSpecFoldCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        ‚ü®‚ÜëbIdx * œë + (œë - 1), by admit /- proof elided -/
          ‚ü©)

class ProverOnly (pSpec : ProtocolSpec 1) extends ProverFirst pSpec

 
alias NonInteractive := ProverOnly

def nonDoomedFoldingProp (i : Fin (‚Ñì + 1)) (challenges : Fin i ‚Üí L)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i j)
    : Prop :=
  let oracleFoldingConsistency := oracleFoldingConsistencyProp ùîΩq Œ≤ i (challenges := challenges)
    (oStmt := oStmt)
  let foldingBadEventExists := badEventExistsProp ùîΩq Œ≤ i (challenges := challenges)
    (oStmt := oStmt)
  oracleFoldingConsistency ‚à® foldingBadEventExists

def concreteCanonicalEmbedding (k : ‚Ñï)
    (prevBTFieldProps : ConcreteBTFieldProps (k := (k)))
    (curBTFieldProps : ConcreteBTFieldProps (k := (k + 1))) :
  letI := mkFieldInstance prevBTFieldProps
  letI := mkFieldInstance curBTFieldProps
  ConcreteBTField k ‚Üí+* ConcreteBTField (k + 1) :=

instance {U : Type} {H : Type*} [SpongeUnit U] [DuplexSpongeInterface U H] :
    UnitTranscript (FSVerifierState U H) U where
  publicUnits state input := do
    let newHashState ‚Üê state.hashState.absorb input
    .ok { hashState := newHashState, nargString := state.nargString }
  fillChallengeUnits state count := do
    let (newHashState, output) ‚Üê state.hashState.squeeze count
    .ok ({ hashState := newHashState, nargString := state.nargString }, output)

def divSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (k : Fin (‚àë j, n j)) : Fin m :=
  (divSum? n k).get (divSum?_is_some_iff_lt_sum.mpr k.isLt)

def dfoldl' (n : ‚Ñï) (Œ± : Fin (n + 1) ‚Üí Type u)
    (f : (i : Fin n) ‚Üí Œ± i.castSucc ‚Üí Œ± i.succ) (init : Œ± 0) : Œ± (last n) :=
  dfoldlM' (m := Id) n Œ± f init

noncomputable def hasMutualCorrAgreement
  (Gen : ProximityGenerator Œπ F) [Fintype Gen.par‚Ñì]
  (BStar : ‚Ñù) (errStar : ‚Ñù ‚Üí ENNReal) :=
    haveI := Gen.Gen_nonempty
    ‚àÄ (f : Gen.par‚Ñì ‚Üí Œπ ‚Üí F) (Œ¥ : ‚Ñù‚â•0) (_hŒ¥ : 0 < Œ¥ ‚àß Œ¥ < 1 - BStar),
    Pr_{let r ‚Üê$·µñ Gen.Gen}[ proximityCondition f Œ¥ r Gen.C ] ‚â§ errStar Œ¥

instance {pSpec : ProtocolSpec n} : CoeHead (MessageIdx pSpec) (Fin n) where
  coe := fun i => i.1

instance {n : ‚Ñï} {Œ± : Fin n ‚Üí Type*} : SliceLT ((i : Fin n) ‚Üí Œ± i) ‚Ñï
    (fun _ stop => stop ‚â§ n)
    (fun _ stop h => (i : Fin stop) ‚Üí Œ± (i.castLE h))
    where
  sliceLT := fun v stop h => take stop h v

Except in Init.Prelude

def Equiv.precomp {Œ± Œ≤ Œ≥} (e : Œ± ‚âÉ Œ≤) : (Œ≤ ‚Üí Œ≥) ‚âÉ (Œ± ‚Üí Œ≥) :=
{ toFun := fun f a => f (e a)
  , invFun := fun g b => g (e.invFun b)
  , left_inv := by admit /- proof elided -/

noncomputable def proximity_gap_johnson (rho : ‚Ñö) (m : ‚Ñï) : ‚Ñù :=
  (1 : ‚Ñù) - Real.sqrt rho - Real.sqrt rho / (2 * m)

def aeval {A : Type w} [CommSemiring A] [Algebra R A] (s : A) : P ‚Üí‚Çê[R] A :=
  eval‚ÇÇAlgHom (Algebra.ofId R A) s

@[reducible]
def SimOracle.Stateless (spec : OracleSpec Œπ) (spec‚Çú : OracleSpec Œπ‚Çú) :=
  QueryImpl spec (OracleComp spec‚Çú)

instance [reduction.IsPerfectComplete init impl relIn relOut] :
    IsComplete init impl relIn relOut reduction where
  completenessError := 0
  is_complete := IsPerfectComplete.is_perfect_complete

abbrev FunEquiv F Œ± Œ≤ := DFunEquiv F Œ± fun _ => Œ≤

@[inline]
def ofOutputOnly
    (witLift :
      OuterStmtIn √ó OuterWitIn ‚Üí InnerStmtOut √ó InnerWitOut ‚Üí OuterWitOut)
    (stmtLift : OuterStmtIn ‚Üí InnerStmtOut ‚Üí OuterStmtOut) :
    Context.Lens OuterStmtIn OuterStmtOut OuterStmtIn InnerStmtOut
                OuterWitIn OuterWitOut OuterWitIn InnerWitOut where
  wit := Witness.Lens.ofOutputOnly witLift
  stmt := Statement.Lens.ofOutputOnly stmtLift

def multiConstrainedCode
  (domain : Œπ ‚Ü™ F) [Smooth domain] (m t : ‚Ñï)
  (w : Fin t ‚Üí MvPolynomial (Fin (m + 1)) F)
  (œÉ : Fin t ‚Üí F) : Set (Œπ ‚Üí F) :=
    { f |
      ‚àÉ (h : f ‚àà smoothCode domain m),
        ‚àÄ i : Fin t, weightConstraint (mVdecode (‚ü®f, h‚ü© : smoothCode domain m)) (w i) (œÉ i)}

@[reducible]
def Set.language {Œ± Œ≤} (rel : Set (Œ± √ó Œ≤)) : Set Œ± :=
  Prod.fst '' rel

def toStatement (stmt : FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì)) :
  Statement (L := L) (Context := SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì)  :=
  {
    sumcheck_target := stmt.sumcheck_target,
    challenges := stmt.challenges,
    ctx := stmt.ctx
  }

@[simp]
def transpose {m n : ‚Ñï} (matrix : Matrix Œ± m n) : Matrix Œ± n m :=
  ofFn (fun j => ofFn (fun i => (matrix.get i).get j))

Equiv in Mathlib.Logic.Equiv.Defs

instance : Fact (Nat.Prime baseFieldSize) := ‚ü®BaseField_is_prime‚ü©

@[simp]
abbrev OracleStatement.AfterFirstMessage : R1CS.MatrixIdx ‚äï Fin 1 ‚Üí Type :=
  Sum.rec (OracleStatement R pp) (fun _ => Witness R pp)

class IsRBRSound (langIn : Set StmtIn) (langOut : Set StmtOut)
    (verifier : Verifier oSpec StmtIn StmtOut pSpec) where
  rbrSoundnessError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0
  is_rbr_sound : rbrSoundness init impl langIn langOut verifier rbrSoundnessError

@[reducible, simp]
def relOut : (StmtOut OStatement √ó ‚àÄ i, OStmtOut OStatement i) ‚Üí WitOut ‚Üí Prop :=
  fun ‚ü®‚ü®q, r‚ü©, oStmt‚ü© () => answer (oStmt 0) q = r

instance instDCast‚ÇÇ : DCast‚ÇÇ Nat ProtocolSpec (fun _ pSpec => ChallengeIdx pSpec) where
  dcast‚ÇÇ h := ChallengeIdx.cast h
  dcast‚ÇÇ_id := cast_id

def getRoot {n : ‚Ñï} (cache : Cache Œ± n) : Œ± :=
  (cache 0).get ‚ü®0, by admit /- proof elided -/
  ‚ü©

instance : Unique (MessagesUpTo 0 pSpec) where
  default := fun ‚ü®i, _‚ü© => Fin.elim0 i
  uniq := fun T => by admit /- proof elided -/

Algebra.ofId in Mathlib.Algebra.Algebra.Hom

Field.toCommRing in Mathlib.Algebra.Field.Defs

def mkLastOracleIndex (i : Fin (‚Ñì + 1)) : Fin (toOutCodewordsCount ‚Ñì œë i) :=

Coe in Init.Coe

instance {n : ‚Ñï} : ‚àÄ j, SelectableType ((pSpecFoldRelaySequence (L:=L) n).Challenge j) :=
  instSelectableTypeChallengeSeqCompose

protected def Prover.id : Prover oSpec Statement Witness Statement Witness !p[] where
  PrvState := fun _ => Statement √ó Witness
  input := _root_.id
  sendMessage := fun i => Fin.elim0 i
  receiveChallenge := fun i => Fin.elim0 i
  output := pure

@[ext]
class OracleInterface (Message : Type u) where
  Query : Type v
  Response : Type w
  answer : Message ‚Üí Query ‚Üí Response

def OracleMessages (pSpec : ProtocolSpec n) [OracleInterfaces pSpec] : Type :=
  ‚àÄ i, pSpec.OracleMessage i

inductive ScalarOp where | add | sub | mul | div

Algebra.TensorProduct.rightAlgebra in Mathlib.RingTheory.TensorProduct.Basic

@[reducible]
def MemoryWrite (Œπ : Type u) (Œ± : Œπ ‚Üí Type v) := (index : Œπ) √ó (Œ± index)

MvPolynomial.C in Mathlib.Algebra.MvPolynomial.Basic

def zeroCheckVirtualPolynomial (ùï© : Statement.AfterFirstMessage R pp)
    
    (oStmt : ‚àÄ i, OracleStatement.AfterFirstMessage R pp i) :
      MvPolynomial (Fin pp.‚Ñì_m) R :=
  letI ùï´ := R1CS.ùï´ ùï© (oStmt (.inr 0))
  ‚àë x : Fin (2 ^ pp.‚Ñì_m),
    (eqPolynomial (finFunctionFinEquiv.symm x : Fin pp.‚Ñì_m ‚Üí R)) *
      C ((oStmt (.inl .A) *·µ• ùï´) x * (oStmt (.inl .B) *·µ• ùï´) x - (oStmt (.inl .C) *·µ• ùï´) x)

@[reducible]
def scalarFieldSize : Nat :=
  8444461749428370424248824938781546531375899335154063827935233455917409239041

def fillNextUnits (state : FSVerifierState U H) (count : Nat) :
    Except DomainSeparatorMismatch (FSVerifierState U H √ó Array U) := do
  
  let bytesNeeded := count * HasSize.size U UInt8
  if state.nargString.size < bytesNeeded then
    .error {
      message := s!"Insufficient transcript remaining, need {bytesNeeded} bytes,
        got {state.nargString.size}" }
  else
    
    let readBytes := state.nargString.extract 0 bytesNeeded
    let remaining := state.nargString.extract bytesNeeded state.nargString.size
    
    let units := Array.range count |>.mapM (fun i =>
      let unitBytes := readBytes.extract (i * HasSize.size U UInt8) (HasSize.size U UInt8)
      DeserializeOption.deserialize unitBytes)
    match units with
    | some unitsArray =>
      
      let newHashState ‚Üê state.hashState.absorb unitsArray
      .ok ({ hashState := newHashState, nargString := remaining }, unitsArray)
    | none =>
      .error { message := "Failed to deserialize units from NARG string" }

class VCVCompatible (Œ± : Type*) extends Fintype Œ±, Inhabited Œ± where
  [type_decidableEq' : DecidableEq Œ±]

def toNum {R : Type _} [Zero R] [DecidableEq R] (a : Array R) : ‚Ñï :=
  (a.map (fun r => if r = 0 then 0 else 1)).reverse.foldl (fun acc elem => (acc * 2) + elem) 0

def line [Ring F] (u v : Œπ ‚Üí F) : AffineSubspace F (Œπ ‚Üí F) :=
  affineSpan _ {u, v}

Lean.PrettyPrinter.Unexpander in Init.Prelude

@[reducible]
def Witness (F : Type) [Semiring F] {k : ‚Ñï} (s : Fin (k + 1) ‚Üí ‚Ñï+) (d : ‚Ñï+) (m : ‚Ñï) :=
  Fin (m + 1) ‚Üí F‚¶É< 2 ^ (‚àë i, (s i).1) * d‚¶Ñ[X]

@[inline, reducible]
def lift : OuterStmtIn √ó OuterWitIn ‚Üí InnerStmtOut √ó InnerWitOut ‚Üí OuterWitOut :=
  lens.toFunB

def internalLinearLayer (state : Vector KoalaBear.Field params.width) :
    Vector KoalaBear.Field params.width :=
  
  
  let sumAll := state.foldl (fun acc x => acc + x) 0

  
  
  state.zipWith (fun s d => sumAll + d * s) params.internalDiagVectors

structure Commit where
  commit : Data ‚Üí Randomness ‚Üí OracleComp oSpec Commitment

Polynomial.eval in Mathlib.Algebra.Polynomial.Eval.Defs

@[simp]
instance AlgebraTower.toIsScalarTower (a : AlgebraTower C) {i j k : Œπ}
    (h1 : i ‚â§ j) (h2 : j ‚â§ k) :
    letI : Algebra (C i) (C j) :=

def linearMvExtension :
  Polynomial.degreeLT F (2^m) ‚Üí‚Çó[F] MvPolynomial (Fin m) F where
    
    toFun p := (p : Polynomial F).sum fun i a =>
      MvPolynomial.monomial (bitExpo i) a
    map_add' := by admit /- proof elided -/

def nonLastBlockOracleReduction (bIdx : Fin (‚Ñì / œë - 1)) :=
  let stmt : Fin (œë - 1 + 1) ‚Üí Type :=
    fun i => Statement (L := L) (‚Ñì := ‚Ñì) Context ‚ü®bIdx * œë + i, bIdx_mul_œë_add_i_cast_lt_‚Ñì_succ bIdx i‚ü©
  let oStmt := fun i: Fin (œë - 1 + 1) =>
    OracleStatement ùîΩq Œ≤ œë ‚ü®bIdx * œë + i, bIdx_mul_œë_add_i_cast_lt_‚Ñì_succ bIdx i‚ü©
  let wit := fun i: Fin (œë - 1 + 1) =>
    Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì)
      ‚ü®bIdx * œë + i, bIdx_mul_œë_add_i_cast_lt_‚Ñì_succ bIdx i‚ü©
  let firstFoldRelayRoundsOracleReduction :=
    OracleReduction.seqCompose (oSpec := []‚Çí)
      (Stmt := stmt)
      (OStmt := oStmt)
      (Wit := wit)
      (pSpec := fun i => pSpecFoldRelay (L:=L))
      (R := fun i => by admit /- proof elided -/
      )

  let h1 : ‚ÜëbIdx * œë + (œë - 1) < ‚Ñì := by admit /- proof elided -/

cast in Init.Prelude

def OracleReduction.append (R‚ÇÅ : OracleReduction oSpec Stmt‚ÇÅ OStmt‚ÇÅ Wit‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ Wit‚ÇÇ pSpec‚ÇÅ)
    (R‚ÇÇ : OracleReduction oSpec Stmt‚ÇÇ OStmt‚ÇÇ Wit‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ Wit‚ÇÉ pSpec‚ÇÇ) :
      OracleReduction oSpec Stmt‚ÇÅ OStmt‚ÇÅ Wit‚ÇÅ Stmt‚ÇÉ OStmt‚ÇÉ Wit‚ÇÉ (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ) where
  prover := Prover.append R‚ÇÅ.prover R‚ÇÇ.prover
  verifier := OracleVerifier.append R‚ÇÅ.verifier R‚ÇÇ.verifier

@[reducible]
def matchSize (a b : Array Œ±) (unit : Œ±) : Array Œ± √ó Array Œ± :=
  (a.rightpad (b.size) unit, b.rightpad (a.size) unit)

Array.zipWith in Init.Data.Array.Basic

MonadLiftT in Init.Prelude

def powFiber (S : Finset Œπ) (œÜ : Œπ ‚Ü™ F) (k : ‚Ñï) (y : indexPow S œÜ k) : Finset Œπ :=
  S.filter (fun x => (œÜ x) ^ k = y)

@[inline, specialize]
def oracleVerifier : OracleVerifier oSpec
    Statement OStatement Statement (OStatement ‚äï·µ• (fun _ : Fin 1 => Witness))
    (oraclePSpec Witness) where
  verify := fun stmt _ => pure stmt
  embed := .sumMap (.refl _)
    <| Equiv.toEmbedding
    <|.symm (subtypeUnivEquiv (by admit /- proof elided -/
    ))
  hEq := by admit /- proof elided -/

@[inline, reducible]
protected def id :
    Witness.Lens OuterStmtIn OuterStmtOut OuterWitIn OuterWitOut OuterWitIn OuterWitOut :=
  ‚ü®Prod.snd, fun _ => Prod.snd‚ü©

alias trivial := Witness.Lens.id

Polynomial.div in Mathlib.Algebra.Polynomial.FieldDivision

def rbrKnowledgeSoundness
    (relIn : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (verifier : OracleVerifier oSpec Statement OStatement Bool (fun _ : Empty => Unit) pSpec)
    (rbrKnowledgeError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) : Prop :=
  verifier.rbrKnowledgeSoundness init impl relIn acceptRejectOracleRel rbrKnowledgeError

@[reducible, simp] def OStmtAfterRandomQuery : Unit ‚äï Unit ‚Üí Type := fun _ => R‚¶É‚â§ deg‚¶Ñ[X]

tag in Examples.FrankingProtocol

def JohnsonDenominator (B : Finset (Fin n ‚Üí F)) (v : Fin n ‚Üí F) : ‚Ñö :=
  let e := e B v
  let d := d B
  let q : ‚Ñö := Fintype.card F
  let frac := q / (q - 1)
  (1- frac * e/n) ^ 2 - (1 - frac * d/n)

instance domain_neg_inst {i : Fin n} : Neg (evalDomain D i.1) where
  neg := fun x => ‚ü®_, minus_one_in_doms D i.2‚ü© * x

noncomputable def W (i : Fin r) : L[X] :=
  ‚àè u : U ùîΩq Œ≤ i, (X - C u.val)

@[inline]
def smul [Mul R] (r : R) (p : MlPolyEval R n) : MlPolyEval R n := p.map (fun a => r * a)

@[reducible, inline, specialize]
def challengeOracleInterfaceSR (StmtIn : Type) (pSpec : ProtocolSpec n) :
    ‚àÄ i, OracleInterface (pSpec.Challenge i) := fun i =>
  { Query := StmtIn √ó pSpec.MessagesUpTo i.1.castSucc
    Response := pSpec.Challenge i
    answer := fun c _ => c }

alias challengeOracleInterfaceFS := challengeOracleInterfaceSR

Algebra.TensorProduct.instAlgebra in Mathlib.RingTheory.TensorProduct.Basic

def map {Œ± Œ≤ : Fin n ‚Üí Sort*} (f : (i : Fin n) ‚Üí Œ± i ‚Üí Œ≤ i) (a : (i : Fin n) ‚Üí Œ± i) :
    (i : Fin n) ‚Üí Œ≤ i := fun i => f i (a i)

System.FilePath.fileName in Init.System.FilePath

def FullTranscript.extractSalt (transcript : (pSpec.addSalt Salt).FullTranscript) :
    (i : pSpec.MessageIdx) ‚Üí Salt i :=
  Transcript.extractSalt (pSpec := pSpec) (k := Fin.last n) transcript

def bitsToU (i : Fin r) (k : Fin (2 ^ i.val)) :
    AdditiveNTT.U (L := L) (ùîΩq := ùîΩq) (Œ≤ := Œ≤) i :=
  let val := (Finset.univ : Finset (Fin i)).sum fun j =>
    if (Nat.getBit (n := k.val) (k := j.val) == 1) then
      Œ≤ ‚ü®j, by admit /- proof elided -/
      ‚ü©
    else 0

  
  ‚ü®val, by admit /- proof elided -/
  ‚ü©

structure SumcheckMultiplierParam (L : Type) [CommRing L] (‚Ñì : ‚Ñï) (Context : Type := Unit) where
  multpoly : (ctx: Context) ‚Üí MultilinearPoly L ‚Ñì

instance {_ : Empty} : OracleInterface (Unit) := OracleInterface.instDefault

@[reducible]
def foldRelayOracleReduction (i : Fin ‚Ñì)
    (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
  OracleReduction []‚Çí
    (StmtIn := Statement (L := L) Context i.castSucc)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) i.castSucc)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) i.succ)
    (pSpec := pSpecFoldRelay (L:=L)) :=
  OracleReduction.append
    (pSpec‚ÇÅ := pSpecFold (L:=L))
    (pSpec‚ÇÇ := pSpecRelay)
        (foldOracleReduction ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) i)
    (relayOracleReduction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hNCR)

AdjoinRoot.instField in Mathlib.RingTheory.AdjoinRoot

BitVec.setWidth in Init.Data.BitVec.Basic

instance : LawfulHasPred Nat where
  pred'_succ := Nat.pred_succ

def findFinIdx (p : Œ± ‚Üí Bool) (l : List Œ±) : Fin (l.length + 1) :=
  ‚ü®List.findIdx' p l,
    Nat.lt_succ_of_le (by admit /- proof elided -/
    )‚ü©

@[simp]
abbrev LinearCombinationChallenge : Type := R1CS.MatrixIdx ‚Üí R

Set.range in Mathlib.Data.Set.Operations

@[inline, specialize]
def OracleReduction.run [‚àÄ i, OracleInterface (pSpec.Message i)]
    (stmt : StmtIn) (oStmt : ‚àÄ i, OStmtIn i) (wit : WitIn)
    (reduction : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec) :
      OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí)
        ((FullTranscript pSpec √ó (StmtOut √ó ‚àÄ i, OStmtOut i) √ó WitOut) √ó
          (StmtOut √ó ‚àÄ i, OStmtOut i)) := do
  let proverResult ‚Üê reduction.prover.run ‚ü®stmt, oStmt‚ü© wit
  let stmtOut ‚Üê liftM (reduction.verifier.run stmt oStmt proverResult.1)
  return ‚ü®proverResult, stmtOut‚ü©

protected def cast (P : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec‚ÇÅ) :
    Prover oSpec StmtIn WitIn StmtOut WitOut pSpec‚ÇÇ where
  PrvState := P.PrvState ‚àò Fin.cast (congrArg (¬∑ + 1) hn.symm)
  input := P.input
  sendMessage := fun i st => do
    let ‚ü®msg, newSt‚ü© ‚Üê P.sendMessage (i.cast hn.symm (cast_symm hSpec)) st
    return ‚ü®(Message.cast_idx_symm hSpec) ‚ñ∏ msg, newSt‚ü©
  receiveChallenge := fun i st => do
    let f ‚Üê P.receiveChallenge (i.cast hn.symm (cast_symm hSpec)) st
    return fun chal => f (Challenge.cast_idx hSpec ‚ñ∏ chal)
  output := P.output ‚àò (fun st => _root_.cast (by admit /- proof elided -/
  ) st)

instance {Œπ : Type u} (v : Œπ ‚Üí Type v) [O : ‚àÄ i, OracleInterface (v i)]
    [h : ‚àÄ i, DecidableEq (Query (v i))]
    [h' : ‚àÄ i, DecidableEq (Response (v i))] :
    [v]‚Çí.DecidableEq where
  domain_decidableEq' := h
  range_decidableEq' := h'

@[reducible]
def GroupDecodeOracle : OracleSpec Unit := fun _ => (BitVec bitLength √ó Œπ, Unit)

def range (n : ‚Ñï) : Fin n ‚Üí ‚Ñï := fun i => i

ringChar.charP in Mathlib.Algebra.CharP.Defs

@[reducible, simp]
def rbrSoundness (langIn : Set Statement)
    (verifier : Verifier oSpec Statement Bool pSpec)
    (rbrSoundnessError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) : Prop :=
  verifier.rbrSoundness init impl langIn acceptRejectRel.language rbrSoundnessError

@[reducible]
def CanonicalSpongeState (U : Type) [SpongeUnit U] [SpongeSize] : Type :=
  Vector U SpongeSize.N

def natCast_succ {k : ‚Ñï} (n : ‚Ñï) : natCast (k:=k) (n + 1) = natCast (k:=k) n + 1 :=

RingHom.comp in Mathlib.Algebra.Ring.Hom.Defs

def getBTFResult (k : ‚Ñï) : ConcreteBTFStepResult k :=
  match k with
  | 0 =>
    let base : ConcreteBTFieldProps 0 := {
      mul_eq := fun a b h_k _ _ _ _ _ _ => by admit /- proof elided -/
| c1_one
        ¬∑ 
          rw [c1_zero] at h_mul
          
          simp at h_mul
        ¬∑ 
          rcases c2_cases with c2_zero | c2_one
          ¬∑ 
            rw [c2_zero] at h_mul
            
            simp at h_mul
          ¬∑ 
            
            exact ‚ü®c1_one, c2_one‚ü©
      
      have specialElement_eq_zero : specialElement = 0 := by admit /- proof elided -/

@[inline] def one : AssocNat :=
  ‚ü®Nat.succ, by admit /- proof elided -/
  ‚ü©

@[simp]
def BTFieldCard (k : ‚Ñï) : Fintype.card (BTField k) = 2^(2^k)
  := (BinaryTowerAux k).2.fieldFintypeCard

noncomputable def monomialBasisOfDegreeLT {n : ‚Ñï} : Basis (Fin n) L (L‚¶É< n‚¶Ñ[X]) :=

def implGroupOpOracle : QueryImpl (GroupOpOracle Œπ) (StateT (GroupValTable Œπ G) Option) where
  impl | query _ ‚ü®i, j, k‚ü© => fun table =>
    match table i, table j with
    | some g‚ÇÅ, some g‚ÇÇ => some ((), table.update k (some (g‚ÇÅ * g‚ÇÇ)))
    | _, _ => none

def SkeletonNodeIndex.depth {s : Skeleton} : SkeletonNodeIndex s ‚Üí Nat
  | SkeletonNodeIndex.ofLeaf => 0
  | SkeletonNodeIndex.ofInternal => 0
  | SkeletonNodeIndex.ofLeft idxLeft => idxLeft.depth + 1
  | SkeletonNodeIndex.ofRight idxRight => idxRight.depth + 1

List.dropLast in Init.Data.List.Basic

def InternalData.map {Œ± Œ≤ : Type} (f : Œ± ‚Üí Œ≤) {s : Skeleton}
    (tree : InternalData Œ± s) : InternalData Œ≤ s :=
  match tree with
  | InternalData.leaf => InternalData.leaf
  | InternalData.internal value left right =>
    InternalData.internal (f value) (left.map f) (right.map f)

noncomputable instance fintype_U (i : Fin r) : Fintype (U ùîΩq Œ≤ i) :=

instance instDCast‚ÇÇ : DCast‚ÇÇ Nat ProtocolSpec (fun _ pSpec => MessageIdx pSpec) where
  dcast‚ÇÇ h := MessageIdx.cast h
  dcast‚ÇÇ_id := cast_id

List.findIdx in Init.Data.List.Basic

structure ParamConditions (P : Params Œπ F) where
  m : ‚Ñï 
  h_m : m = P.varCount 0
  h_sumkLt : ‚àë i : Fin (M + 1), P.foldingParam i ‚â§ m
  h_varCount_i : ‚àÄ i : Fin (M + 1),
    P.varCount i = m - ‚àë j : Fin i, P.foldingParam (Fin.castLT j (Nat.lt_trans j.isLt i.isLt))
  h_smooth : ‚àÄ i : Fin (M + 1), Smooth (P.œÜ i)
  h_repeatPLt : ‚àÄ i : Fin (M + 1), P.repeatParam i ‚â§ Fintype.card (Œπ i)

@[reducible, simp]
def knowledgeSoundness
    (relation : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (verifier : OracleVerifier oSpec Statement OStatement Bool (fun _ : Empty => Unit) pSpec)
    (knowledgeError : ‚Ñù‚â•0) : Prop :=
  verifier.toVerifier.knowledgeSoundness init impl relation acceptRejectOracleRel knowledgeError

@[reducible]
def OracleStatement := fun _ : MatrixIdx => Matrix (Fin sz.m) (Fin sz.n) R

instance instDCast : DCast Nat ProtocolSpec where
  dcast h := ProtocolSpec.cast h
  dcast_id := cast_id

Finsupp.mapRange in Mathlib.Data.Finsupp.Defs

Fin.castSucc in Init.Data.Fin.Basic

instance {k : ‚Ñï} : IntCast (ConcreteBTField k) where
  intCast n:= intCast n

LawfulBEq in Init.Core

def fiberwiseClose (i : Fin ‚Ñì) (steps : ‚Ñï) [NeZero steps] (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
    (f : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      ‚ü®i, by admit /- proof elided -/
      ‚ü©) : Prop :=
  2 * fiberwiseDistance ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := i) steps
    (h_i_add_steps := h_i_add_steps) (f := f) < (BBF_CodeDistance ‚Ñì ùì° ‚ü®i + steps, by admit /- proof elided -/
    ‚ü© : ‚Ñï‚àû)

Preorder in Mathlib.Order.Defs.PartialOrder

def hconcat {n : ‚Ñï} {Œ± : Fin n ‚Üí Sort u} {Œ≤ : Sort u} (u : (i : Fin n) ‚Üí Œ± i) (a : Œ≤) :
    (i : Fin (n + 1)) ‚Üí Fin.vconcat Œ± Œ≤ i :=
  fconcat (F := id) u a

def distanceLE (Message : Type*) [O : OracleInterface Message]
    [Fintype (O.Query)] [DecidableEq (O.Response)] (d : ‚Ñï) : Prop :=
  ‚àÄ a b : Message, a ‚â† b ‚Üí #{q | OracleInterface.answer a q = OracleInterface.answer b q} ‚â§ d

instance {Message : Type u} : Inhabited (OracleInterface Message) :=
  ‚ü®instDefault‚ü©

instance [h : VerifierFirst pSpec] : VerifierFirst pSpec where
  verifier_first' := by admit /- proof elided -/

noncomputable def fiber_coeff
    (i : Fin r) (steps : ‚Ñï)
    (j : Fin (‚Ñì + ùì° - i)) (elementIdx : Fin (2 ^ steps))
    (y_coeffs : Fin (‚Ñì + ùì° - (i + steps)) ‚Üí‚ÇÄ ùîΩq) : ùîΩq :=
  if hj : j.val < steps then
    if Nat.getBit (k := j) (n := elementIdx) = 0 then 0 else 1
  else y_coeffs ‚ü®j.val - steps, by admit /- proof elided -/
    ‚ü©

MvPolynomial in Mathlib.Algebra.MvPolynomial.Basic

def tileCoeffs (a : Fin (2 ^ ‚Ñì) ‚Üí L) : Fin (2^(‚Ñì + R_rate)) ‚Üí L :=
  fun v => a (Fin.mk (v.val % (2^‚Ñì)) (Nat.mod_lt v.val (pow_pos (zero_lt_two) ‚Ñì)))

@[inline, specialize]
def Prover.runToRoundDSFS [‚àÄ i, VCVCompatible (pSpec.Challenge i)] (i : Fin (n + 1))
    (stmt : StmtIn) (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec)
    (state : prover.PrvState 0) :
        OracleComp (oSpec ++‚Çí duplexSpongeChallengeOracle StmtIn U)
          (pSpec.MessagesUpTo i √ó
            DuplexSponge U (Vector U SpongeSize.N) √ó prover.PrvState i) :=
  Fin.induction
    (do
      
      let sponge ‚Üê liftM (DuplexSponge.start stmt)
      return ‚ü®default, sponge, state‚ü©
    )
    (prover.processRoundDSFS)
    i

Nonempty in Init.Prelude

instance {i : Fin ‚Ñì} :
    ‚àÄ j, OracleInterface ((pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i).Message j)
  | ‚ü®0, _‚ü© => by admit /- proof elided -/

Fintype.decidablePiFintype in Mathlib.Data.Fintype.Defs

noncomputable def Pz
  {k : ‚Ñï}
  {z : F}
  (hS : z ‚àà coeffs_of_close_proximity k œâs Œ¥ u‚ÇÄ u‚ÇÅ)
  :
  F[X]
  := (exists_Pz_of_coeffs_of_close_proximity (n := n) (k := k) hS).choose

@[reducible]
def duplexSpongeChallengeOracle (StartType : Type) (U : Type) [SpongeUnit U] [SpongeSize] :
    OracleSpec (Unit ‚äï PermuteDir) :=
  (StartType ‚Üí‚Çí Vector U SpongeSize.C) ++‚Çí permutationOracle (CanonicalSpongeState U)

alias ùíü_ùîñ := duplexSpongeChallengeOracle

def toFinMatrix {m n : ‚Ñï} (matrix : Matrix Œ± m n) : _root_.Matrix (Fin m) (Fin n) Œ± :=
  fun i j => (matrix.get i).get j

OracleSpec.FiniteRange in VCVio.OracleComp.OracleSpec

structure HashStateWithInstructions (U : Type) [SpongeUnit U] (H : Type*)
    [DuplexSpongeInterface U H] where
   
  ds : H
   
  stack : Array DomainSeparator.Op
deriving Inhabited, DecidableEq, Repr

def SumFunEquivProd (Œ± Œ≤ Œ≥ : Type) : ((Œ± ‚äï Œ≤) ‚Üí Œ≥) ‚âÉ (Œ± ‚Üí Œ≥) √ó (Œ≤ ‚Üí Œ≥) :=
{ toFun := fun f => (fun a => f (.inl a), fun b => f (.inr b))
  , invFun := fun p x => match x with | .inl a => p.fst a | .inr b => p.snd b
  , left_inv := by admit /- proof elided -/

instance [VerifierFirst pSpec] [h : VCVCompatible (pSpec.¬´Type¬ª 0)] :
    ‚àÄ i, VCVCompatible (pSpec.Challenge i)
  | ‚ü®0, _‚ü© => inferInstance

def StateRestoration.Soundness (oSpec : OracleSpec Œπ) (StmtIn : Type)
    {n : ‚Ñï} (pSpec : ProtocolSpec n) :=
  OracleComp (oSpec ++‚Çí (srChallengeOracle StmtIn pSpec)) (StmtIn √ó pSpec.Messages)

def fappend {A : Sort u} {F : A ‚Üí Sort v} {m n : ‚Ñï} {Œ± : Fin m ‚Üí A} {Œ≤ : Fin n ‚Üí A}
    (u : (i : Fin m) ‚Üí F (Œ± i)) (v : (i : Fin n) ‚Üí F (Œ≤ i)) :
    (i : Fin (m + n)) ‚Üí F (Fin.vappend Œ± Œ≤ i) :=
  match n with
  | 0 => u
  | k + 1 => fconcat (fappend u (fun i => v (Fin.castSucc i))) (v (Fin.last k))

noncomputable def qMap (i : Fin r) : L[X] :=
  let constMultiplier := ((W ùîΩq Œ≤ i).eval (Œ≤ i))^(Fintype.card ùîΩq)
    / ((W ùîΩq Œ≤ (i + 1)).eval (Œ≤ (i + 1)))
  C constMultiplier * ‚àè c: ùîΩq, (X - C (algebraMap ùîΩq L c))

instance {s} : Functor (fun Œ± => LeafData Œ± s) where
  map f x := x.map f

@[inline, specialize]
def OracleVerifier.run [O‚Çò : ‚àÄ i, OracleInterface (pSpec.Message i)]
    (stmt : StmtIn) (oStmtIn : ‚àÄ i, OStmtIn i) (transcript : FullTranscript pSpec)
    (verifier : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec) :
      OracleComp oSpec (StmtOut √ó (‚àÄ i, OStmtOut i)) := do
  let f := OracleInterface.simOracle2 oSpec oStmtIn transcript.messages
  let stmtOut ‚Üê simulateQ f (verifier.verify stmt transcript.challenges)
  let oStmtOut : ‚àÄ i, OStmtOut i := fun i => match h : verifier.embed i with
  | .inl j => by admit /- proof elided -/
  | .inr j => by admit /- proof elided -/

instance : ‚àÄ i, SelectableType ((pSpecSumcheckFold ùîΩq Œ≤ (œë:=œë)
  (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).Challenge i) := instSelectableTypeChallengeAppend

def rho' (n : ‚Ñï) (start : ‚Ñï) (c : ‚Ñï) : Option ‚Ñï := Id.run do
  if n % 2 = 0 then
    return some 2

  let mut x := start
  let mut y := x
  let mut d := 1

  while d = 1 do
    x := g n c x
    y := g n c (g n c y)
    d := Nat.gcd (Int.natAbs (x - y)) n

  if d = n then
    return none
  else
    return some d

@[simp]
abbrev OracleStatement.AfterLinearCombination : R1CS.MatrixIdx ‚äï R1CS.MatrixIdx ‚äï Fin 1 ‚Üí Type :=
  Sum.elim (EvalClaim R) (OracleStatement.AfterFirstSumcheck R pp)

def findNeighbors {n : ‚Ñï} (i : Fin (2 ^ n)) (layer : Fin n) :
    Fin (2 ^ (layer.val + 1)) :=
  
  
  let bits := (Vector.ofFn (finFunctionFinEquiv.invFun i)).reverse
  
  let neighbor := (bits.set layer (bits.get layer + 1)).take (layer.val + 1)
  have : min (layer.val + 1) n = layer.val + 1 := by admit /- proof elided -/

instance {Œ± : Type u} [ToNat Œ±] : CoeHead Œ± Nat where
  coe := ToNat.toNat

Finset.Iic in Mathlib.Order.Interval.Finset.Defs

instance (s : Finset œÉ) : Fintype { x : œÉ | x ‚àà s } :=

def OracleVerifier.addSalt (V : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec) :
    OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut (pSpec.addSalt Salt) where
  verify := fun stmtIn challenges => sorry
  
  
  embed := sorry
  hEq := sorry

@[reducible, simp]
def ChallengeIdxUpTo (k : Fin (n + 1)) (pSpec : ProtocolSpec n) : Type :=
  (pSpec‚ü¶:k.val‚üß).ChallengeIdx

noncomputable def relayOracleVerifier (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
  OracleVerifier
    (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) Context i.succ)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (pSpec := pSpecRelay) where
  verify := fun stmtIn _ => pure stmtIn
  embed := ‚ü®fun j => by admit /- proof elided -/
  ‚ü©
  hEq := fun oracleIdx => by admit /- proof elided -/

Fin.find in Mathlib.Data.Fin.Tuple.Basic

noncomputable def polyFold
  [DecidableEq F] (fPoly : Polynomial F)
  (k : ‚Ñï) (hk0 : 0 < k) (hkfin : k < Fintype.card F)
  (r : F) : Polynomial F :=
    let qPoly : Polynomial F := Polynomial.X ^ k
    let hdeg_q_min : qPoly.natDegree > 0 := sorry
    let hdeg_q_max : qPoly.natDegree < Fintype.card F := sorry
  
    let Q : MvPolynomial (Fin 2) F := polyQ fPoly qPoly
    MvPolynomial.eval‚ÇÇHom
      (Polynomial.C : F ‚Üí+* Polynomial F)
      (fun i : Fin 2 => if i = 0 then Polynomial.X else Polynomial.C r) Q

Module.Basis.smulTower in Mathlib.RingTheory.AlgebraTower

def relation : Set (M √ó List (MemoryRead Œπ Œ±)) :=
  { ‚ü®mem, ops‚ü© | ‚àÄ op ‚àà ops, Memory.read mem op.index = op.value }

inductive SkeletonInternalIndex : Skeleton ‚Üí Type
  | ofInternal {left right} : SkeletonInternalIndex (Skeleton.internal left right)
  | ofLeft {left right : Skeleton} (idxLeft : SkeletonInternalIndex left) :
      SkeletonInternalIndex (Skeleton.internal left right)
  | ofRight {left right : Skeleton} (idxRight : SkeletonInternalIndex right) :
      SkeletonInternalIndex (Skeleton.internal left right)

instance [Zero T] [ToNat T] : Mul (Cayley T) where
  mul := mul

def externalLinearLayer (state : Vector KoalaBear.Field params.width) :
    Vector KoalaBear.Field params.width :=
  
  let chunks := Vector.Matrix.ofFlatten (state.cast (params.widthDiv4_mul_4_eq_width).symm)
  let chunksAfterM4 := chunks.map (fun chunk => applyM4 chunk)

  
  

  
  let transposedMatrix := Vector.Matrix.transpose chunksAfterM4

  
  let columnSums := transposedMatrix.map (fun col => col.foldl (¬∑ + ¬∑) 0)

  
  let chunksAfterDiffusion := chunksAfterM4.map (fun row => row.zipWith (¬∑ + ¬∑) columnSums)

  
  (Vector.flatten chunksAfterDiffusion).cast (params.widthDiv4_mul_4_eq_width)

instance {Œ± : Type*} {n : ‚Ñï} [VCVCompatible Œ±] : VCVCompatible (Vector Œ± n) where

@[reducible, simp] def OStmtIn := fun _ : Fin 2 => OStatement

liftM in Init.Prelude

def DVec {m : Type v} (Œ± : m ‚Üí Type u) : Type (max u v) := ‚àÄ i, Œ± i

def buildMerkleTree_with_hash {s} (leaf_tree : LeafData Œ± s) (hashFn : Œ± ‚Üí Œ± ‚Üí Œ±) :
    (FullData Œ± s) :=
  match leaf_tree with
  | LeafData.leaf a => FullData.leaf a
  | LeafData.internal left right =>
    let leftTree := buildMerkleTree_with_hash left hashFn
    let rightTree := buildMerkleTree_with_hash right hashFn
    let rootHash := hashFn (leftTree.getRootValue) (rightTree.getRootValue)
    FullData.internal rootHash leftTree rightTree

noncomputable def monomialOfNat (i : ‚Ñï) : (Fin n) ‚Üí‚ÇÄ ‚Ñï :=
  Finsupp.onFinset (s:=Finset.univ (Œ±:=Fin n)) (fun j => Nat.getBit j.val i) (by admit /- proof elided -/
    ) 

instance :
    ‚àÄ i, OracleInterface
          ((pSpecFold D x k s ++‚Çö FinalFoldPhase.pSpec F ++‚Çö QueryRound.pSpec D x l).Message i) :=
  instOracleInterfaceMessageAppend

@[inline, specialize]
def Prover.runToRoundFS [‚àÄ i, VCVCompatible (pSpec.Challenge i)] (i : Fin (n + 1))
    (stmt : StmtIn) (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec)
    (state : prover.PrvState 0) :
        OracleComp (oSpec ++‚Çí fsChallengeOracle StmtIn pSpec)
          (pSpec.MessagesUpTo i √ó StmtIn √ó prover.PrvState i) :=
  Fin.induction
    (pure ‚ü®default, stmt, state‚ü©)
    prover.processRoundFS
    i

noncomputable def qCompositionChain (i : Fin r) : L[X] :=
  match i with
  | ‚ü®0, _‚ü© => X
  | ‚ü®k + 1, h_k_add_1‚ü© => (qMap ùîΩq Œ≤ ‚ü®k, by admit /- proof elided -/
  ‚ü©).comp (qCompositionChain ‚ü®k, by admit /- proof elided -/
  ‚ü©)

EDist in Mathlib.Topology.EMetricSpace.Defs

@[ext]
structure OracleVerifier {Œπ : Type} (oSpec : OracleSpec Œπ)
    (StmtIn : Type) {Œπ‚Çõ·µ¢ : Type} (OStmtIn : Œπ‚Çõ·µ¢ ‚Üí Type)
    (StmtOut : Type) {Œπ‚Çõ‚Çí : Type} (OStmtOut : Œπ‚Çõ‚Çí ‚Üí Type)
    {n : ‚Ñï} (pSpec : ProtocolSpec n)
    [O‚Çõ·µ¢ : ‚àÄ i, OracleInterface (OStmtIn i)]
    [O‚Çò : ‚àÄ i, OracleInterface (pSpec.Message i)]
    where
    
    

   
  verify : StmtIn ‚Üí pSpec.Challenges ‚Üí
    OracleComp (oSpec ++‚Çí ([OStmtIn]‚Çí ++‚Çí [pSpec.Message]‚Çí)) StmtOut

  
  
  

  

   
  embed : Œπ‚Çõ‚Çí ‚Ü™ Œπ‚Çõ·µ¢ ‚äï pSpec.MessageIdx

   
  hEq : ‚àÄ i, OStmtOut i = match embed i with
    | Sum.inl j => OStmtIn j
    | Sum.inr j => pSpec.Message j

def getMiddleBits (offset len n : ‚Ñï) : ‚Ñï :=
  getLowBits (numLowBits:=len) (n:=n >>> offset)

@[reducible, simp]
def OStmtOut : Unit ‚Üí Type := fun _ => R‚¶É‚â§ deg‚¶Ñ[X]

Units.mulAction' in Mathlib.Algebra.Group.Action.Units

class Extractor.Straightline.IsMonotone
    (relIn : Set (StmtIn √ó WitIn))
    (E : Extractor.Straightline oSpec StmtIn WitIn WitOut pSpec)
    [oSpec.FiniteRange]
    where
  is_monotone : ‚àÄ witOut stmtIn transcript, ‚àÄ proveQueryLog‚ÇÅ proveQueryLog‚ÇÇ : oSpec.QueryLog,
    ‚àÄ verifyQueryLog‚ÇÅ verifyQueryLog‚ÇÇ : oSpec.QueryLog,
    proveQueryLog‚ÇÅ.Sublist proveQueryLog‚ÇÇ ‚Üí
    verifyQueryLog‚ÇÅ.Sublist verifyQueryLog‚ÇÇ ‚Üí
    
    [fun witIn => (stmtIn, witIn) ‚àà relIn |
      E stmtIn witOut transcript proveQueryLog‚ÇÅ verifyQueryLog‚ÇÅ] ‚â§
    [fun witIn => (stmtIn, witIn) ‚àà relIn |
      E stmtIn witOut transcript proveQueryLog‚ÇÇ verifyQueryLog‚ÇÇ]

Set.Ico in Mathlib.Order.Interval.Set.Defs

@[inline, specialize]
def mulX (p : UniPoly R) : UniPoly R := p.mulPowX 1

def powAlgHom :
  MvPolynomial (Fin m) F ‚Üí‚Çê[F] Polynomial F :=
   aeval fun j => Polynomial.X ^ (2 ^ (j : ‚Ñï))

abbrev LinearCode.{u, v} (Œπ : Type u) [Fintype Œπ] (F : Type v) [Semiring F] : Type (max u v) :=
  Submodule F (Œπ ‚Üí F)

@[reducible, inline, specialize]
def messages (transcript : FullTranscript pSpec) (i : MessageIdx pSpec) :=
  transcript i.val

class Initialize (Œ± : Type u) (Œ≤ : Type v) where
   
  new : Œ≤ ‚Üí Œ±

@[reducible]
def addSalt (pSpec : ProtocolSpec n) (Salt : pSpec.MessageIdx ‚Üí Type) :
    ProtocolSpec n :=
  ‚ü®pSpec.dir, fun i => match hDir : pSpec.dir i with
    | .P_to_V => (pSpec.¬´Type¬ª i) √ó Salt ‚ü®i, hDir‚ü©
    | .V_to_P => pSpec.¬´Type¬ª i‚ü©

instance instDCast‚ÇÇSigma {Œ± : Type*} {Œ≤ : Œ± ‚Üí Type*} {Œ≥ : (a : Œ±) ‚Üí Œ≤ a ‚Üí Type*}
    {Œ¥ : (a : Œ±) ‚Üí (b : Œ≤ a) ‚Üí Œ≥ a b ‚Üí Type*}
    [DCast Œ± Œ≤] [DCast‚ÇÇ Œ± Œ≤ Œ≥] [DCast‚ÇÉ Œ± Œ≤ Œ≥ Œ¥] :
    DCast‚ÇÇ ((a : Œ±) √ó Œ≤ a) (fun a => Œ≥ a.1 a.2) (fun a => Œ¥ a.1 a.2) where
  dcast‚ÇÇ ha hb c := dcast‚ÇÉ (by admit /- proof elided -/
  ) (by admit /- proof elided -/
  ) (by admit /- proof elided -/
  ) c
  dcast‚ÇÇ_id := by admit /- proof elided -/

Matrix.of in Mathlib.LinearAlgebra.Matrix.Defs

instance : Unique (FullTranscript (default : ProtocolSpec 0)) := inferInstance

def sigmaChallengeIdxToSeqCompose {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (i : Fin m) (j : (pSpec i).ChallengeIdx) : (seqCompose pSpec).ChallengeIdx :=
  ‚ü®Fin.embedSum i j.1, by admit /- proof elided -/
  ‚ü©

@[reducible, simp]
def pSpec : ProtocolSpec 1 := ‚ü®!v[.P_to_V], !v[Witness]‚ü©

RingEquiv in Mathlib.Algebra.Ring.Equiv

def Verifier.liftContext
    (lens : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut)
    (V : Verifier oSpec InnerStmtIn InnerStmtOut pSpec) :
      Verifier oSpec OuterStmtIn OuterStmtOut pSpec where
  verify := fun stmtIn transcript => do
    let innerStmtIn := lens.proj stmtIn
    let innerStmtOut ‚Üê V.verify innerStmtIn transcript
    return lens.lift stmtIn innerStmtOut

noncomputable def oddPart_x (f : Polynomial F) : Polynomial F := deevenize (oddPart f)

def relayKnowledgeError (m : pSpecRelay.ChallengeIdx) : ‚Ñù‚â•0 :=
  match m with
  | ‚ü®j, _‚ü© => j.elim0

def mul (a b : AssocNat) : AssocNat :=
  mulNat a b.toNat

Classical.propDecidable in Init.Classical

EmbeddingLike in Mathlib.Data.FunLike.Embedding

@[reducible]
def baseFieldSize : Nat :=
  21888242871839275222246405745257275088696311157297823662689037894645226208583

OracleSpec.QueryCache in VCVio.OracleComp.QueryTracking.Structures

@[simp]
def finRangeTo {k : ‚Ñï} (i : ‚Ñï) : Finset (Fin k) :=
  (List.take i (List.finRange k)).toFinset

Nontrivial in Mathlib.Logic.Nontrivial.Defs

def Œ± (x‚ÇÄ : F) (R : F[X][X][Y]) (H : F[X][Y]) [œÜ : Fact (Irreducible H)] (t : ‚Ñï) : ùïÉ H :=
  let W : ùïÉ H := liftToFunctionField (H.leadingCoeff)
  embeddingOfùí™IntoùïÉ _ (Œ≤ R t) / (W ^ (t + 1) * (embeddingOfùí™IntoùïÉ _ (Œæ x‚ÇÄ R H)) ^ (2*t - 1))

def LeafData.ofFun {Œ± : Type} (s : Skeleton)
    (f : SkeletonLeafIndex s ‚Üí Œ±) : LeafData Œ± s :=
  match s with
  | .leaf => LeafData.leaf (f SkeletonLeafIndex.ofLeaf)
  | .internal l r =>
      LeafData.internal
        (LeafData.ofFun l (fun idx => f (SkeletonLeafIndex.ofLeft idx)))
        (LeafData.ofFun r (fun idx => f (SkeletonLeafIndex.ofRight idx)))

def factor' (n : ‚Ñï) : Option (List PrimeWithMultiplicity) := do
  let facts := List.mergeSort (‚Üê factor n)
  let groups := List.splitBy (¬∑ = ¬∑) facts
  return groups.map (fun g => ‚ü®g[0]!, g.length‚ü©)

def modByMonic [Field R] (p : UniPoly R) (q : UniPoly R) :
    UniPoly R :=
  (divModByMonicAux p q).2

def discr_y {F : Type} [CommRing F] (f : F[X][Y]) : F[X] :=
   
  Classical.choose (resultant_is_divisible_by_leadingCoeff f)

noncomputable def funcQuotient (f : Œπ ‚Üí F) (S : Finset F) (Ans Fill : S ‚Üí F) : Œπ ‚Üí F :=
  fun x =>
    if hx : x.val ‚àà S then Fill ‚ü®x.val, hx‚ü© 
    else (f x - (ansPoly S Ans).eval x.val) / (vanishingPoly S).eval x.val

noncomputable def ElocPolyF (œâs f : Fin n ‚Üí F) (p : Polynomial F) : Polynomial F :=
  ElocPoly n (liftF œâs) (liftF f) p

def getFoldingChallenges (i : Fin (‚Ñì + 1)) (challenges : Fin i ‚Üí L)
    (k : ‚Ñï) (h : k + œë ‚â§ i) : Fin œë ‚Üí L :=
  fun cId => challenges ‚ü®k + cId, by admit /- proof elided -/
  ‚ü©

def SkeletonNodeIndex.sibling {s : Skeleton} (idx : SkeletonNodeIndex s) :
    Option (SkeletonNodeIndex s) :=
  match idx with
  
  | SkeletonNodeIndex.ofLeaf => none
  
  | SkeletonNodeIndex.ofInternal => none
  
  | @SkeletonNodeIndex.ofLeft left right idxLeft =>
    match idxLeft with
    
    | SkeletonNodeIndex.ofLeaf => some (getRootIndex right).ofRight
    
    | SkeletonNodeIndex.ofInternal => some (getRootIndex right).ofRight
    
    
    | SkeletonNodeIndex.ofLeft idxLeftLeft =>
      idxLeftLeft.ofLeft.sibling.map (SkeletonNodeIndex.ofLeft)
    | SkeletonNodeIndex.ofRight idxLeftRight =>
      idxLeftRight.ofRight.sibling.map (SkeletonNodeIndex.ofLeft)
  | @SkeletonNodeIndex.ofRight left right idxRight =>
    match idxRight with
    | SkeletonNodeIndex.ofLeaf => some (getRootIndex left).ofLeft
    | SkeletonNodeIndex.ofInternal => some (getRootIndex left).ofLeft
    | SkeletonNodeIndex.ofLeft idxRightLeft =>
      idxRightLeft.ofLeft.sibling.map (SkeletonNodeIndex.ofRight)
    | SkeletonNodeIndex.ofRight idxRightRight =>
      idxRightRight.ofRight.sibling.map (SkeletonNodeIndex.ofRight)

propext in Init.Core

class ProverLast (pSpec : ProtocolSpec n) [inst : NeZero n] where
  prover_last' : pSpec.dir ‚ü®n - 1, by admit /- proof elided -/
  ‚ü© = .P_to_V

def toOutCodewordsCount (i : Fin (‚Ñì + 1)) : ‚Ñï :=

def BacktrackSequence.Index (trace : QueryLog (duplexSpongeChallengeOracle StmtIn U))
    (state : CanonicalSpongeState U) (seq : BacktrackSequence trace state) :
    Fin trace.length √ó (Fin seq.inputState.length ‚Üí Fin trace.length) :=
  
  
  
  (‚ü®trace.findIdx sorry, sorry‚ü©, sorry)

def correlatedAgreement (C : Set (n ‚Üí F)) (Œ¥ : ‚Ñù‚â•0) {k : ‚Ñï} (W : Fin k ‚Üí n ‚Üí F) : Prop :=
  ‚àÉ S : Finset n, #(S) ‚â• (1 - Œ¥) * (Fintype.card n) ‚àß
    ‚àÉ v : Fin k ‚Üí n ‚Üí F, ‚àÄ i, v i ‚àà C ‚àß {j | v i j = W i j} = S

Nat.and_distrib_right in Init.Data.Nat.Bitwise.Lemmas

instance {i : ‚Ñï} : SmoothPowerOfTwo (n - i) (evalDomain D i) where
  smooth := by admit /- proof elided -/

@[ext]
structure Verifier {Œπ : Type} (oSpec : OracleSpec Œπ)
    (StmtIn StmtOut : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n) where
  verify : StmtIn ‚Üí FullTranscript pSpec ‚Üí OracleComp oSpec StmtOut

def curve : WeierstrassCurve BaseField := {
  a‚ÇÅ := 0,  
  a‚ÇÇ := 0,  
  a‚ÇÉ := 0,  
  a‚ÇÑ := 0,  
  a‚ÇÜ := 3   
}

Algebra.TensorProduct.comm in Mathlib.RingTheory.TensorProduct.Maps

def towerAlgebraMap (l r : ‚Ñï) (h_le : l ‚â§ r) : BTField l ‚Üí+* BTField r :=

def dummyLastWitness :
    Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì) := {
  t := ‚ü®0, by admit /- proof elided -/
  ‚ü©,
  H := ‚ü®0, by admit /- proof elided -/
  ‚ü©,
  f := fun _ => 0
}

def evalSetY [DecidableEq F] (f : F[X][Y]) (P : Finset F) [Nonempty P] : Finset (Polynomial F) :=
  P.image (fun a => evalY a f)

@[inline]
def ofOutputOnly
    (liftStmt : OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i) ‚Üí InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i) ‚Üí
                OuterStmtOut √ó (‚àÄ i, OuterOStmtOut i)) :
    OracleStatement.Lens OuterStmtIn OuterStmtOut OuterStmtIn InnerStmtOut
                        OuterOStmtIn OuterOStmtOut OuterOStmtIn InnerOStmtOut :=
  ‚ü®id, liftStmt‚ü©

toFun in ToMathlib.Control.Monad.Hom

structure GaloisAutomorphism (F : Type*) [Field F] (u : F) (k : ‚Ñï) : Prop where
  forward : u ^ (2 ^ (2 ^ k)) = u‚Åª¬π
  reverse : (u‚Åª¬π) ^ (2 ^ (2 ^ k)) = u

noncomputable def P
  (Œ¥ : ‚Ñö) (x‚ÇÄ : F)
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  :
  F[Z][X] :=
  let v‚ÇÄ := Classical.choose (solution_gamma_is_linear_in_Z k (Œ¥ := Œ¥) (x‚ÇÄ := x‚ÇÄ) h_gs)
  let v‚ÇÅ := Classical.choose 
    (Classical.choose_spec <| solution_gamma_is_linear_in_Z k (Œ¥ := Œ¥) (x‚ÇÄ := x‚ÇÄ) h_gs)
  (
    (Polynomial.map Polynomial.C v‚ÇÄ) +
    (Polynomial.C Polynomial.X) * (Polynomial.map Polynomial.C v‚ÇÅ)
  )

instance instSetoidUniPoly : Setoid (UniPoly R) where
  r := equiv
  iseqv := instEquivalenceEquiv

class PrimeOrder (G : Type*) [Group G] where
  p : ‚Ñï
  [hPrime : Fact (Nat.Prime p)]
  hCard : Nat.card G = p

private def Fi (B : Finset (Fin n ‚Üí F)) (i : Fin n) (Œ± : F) : Finset (Fin n ‚Üí F) :=
  { x | x ‚àà B ‚àß x i = Œ± }

@[reducible]
def VectorIOP
    (Statement : Type) {Œπ‚Çõ : Type} (OStatement : Œπ‚Çõ ‚Üí Type) (Witness : Type)
    (vPSpec : ProtocolSpec.VectorSpec n) (A : Type)
    [‚àÄ i, OracleInterface (OStatement i)] :=
  OracleProof []‚Çí Statement OStatement Witness (vPSpec.toProtocolSpec A)

def perfectCompleteness
    (relIn : Set ((StmtIn √ó ‚àÄ i, OStmtIn i) √ó WitIn))
    (relOut : Set ((StmtOut √ó ‚àÄ i, OStmtOut i) √ó WitOut))
    (oracleReduction : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec) :
      Prop :=
  Reduction.perfectCompleteness init impl relIn relOut oracleReduction.toReduction

@[inline, specialize]
def add (p q : UniPoly R) : UniPoly R :=
  add_raw p q |> trim

abbrev Field := ZMod fieldSize

Sum.inr in Init.Core

Function.Embedding in Mathlib.Logic.Embedding.Basic

Nat.bit in Mathlib.Data.Nat.BinaryRec

instance [h : VerifierFirst pSpec] : IsEmpty (pSpec.MessageIdx) where
  false | ‚ü®0, h'‚ü© => by admit /- proof elided -/

toList in ToMathlib.ProbabilityTheory.FinRatPMF

def totalNumPermQueries : Nat :=
  pSpec.totalNumPermQueriesMessage + pSpec.totalNumPermQueriesChallenge

CoeHead in Init.Coe

def ratchet (state : FSProverState U H R) :
    Except DomainSeparatorMismatch (FSProverState U H R) :=
  match state.hashState.ratchet with
  | .ok newHashState =>
    .ok { rng := state.rng, hashState := newHashState, nargString := state.nargString }
  | .error e => .error e

def start {Œ± : Type} (a : Œ±) : OracleComp (Œ± ‚Üí‚Çí Vector U SpongeSize.C) (DuplexSponge U C) := do
  let capacitySegment : Vector U SpongeSize.C ‚Üê query (spec := Œ± ‚Üí‚Çí Vector U SpongeSize.C) () a
  let vecSponge := (Vector.replicate SpongeSize.R (0 : U)) ++ capacitySegment
  return {
    state := SpongeState.update (Œ± := C) (0 : C) (vecSponge.cast (by admit /- proof elided -/
    )),
    absorbPos := 0,
    squeezePos := Fin.last SpongeSize.R
  }

PMF.uniformOfFintype in Mathlib.Probability.Distributions.Uniform

instance {Œπ : Type} : OracleInterface (OracleStatement Œπ F ()) := OracleInterface.instFunction

Submodule.module in Mathlib.Algebra.Module.Submodule.Defs

noncomputable def ansPoly (S : Finset F) (Ans : S ‚Üí F) : Polynomial F :=
  Lagrange.interpolate S.attach (fun i => (i : F)) Ans

IO.FS.Stream.write in Init.System.IO

@[inline]
def nsmul [SMul ‚Ñï R] (m : ‚Ñï) (p : MlPolyEval R n) : MlPolyEval R n := p.map (fun a => m ‚Ä¢ a)

instance [VCVCompatible A] : ‚àÄ i, VCVCompatible ((vPSpec.toProtocolSpec A).Challenge i) :=
  fun _ => by admit /- proof elided -/

structure TraceMapProperty (F : Type*) [Field F] (u : F) (k : ‚Ñï) : Prop where
  element_trace : ‚àë i ‚àà Finset.range (2 ^ k), u ^ (2 ^ i) = 1
  inverse_trace : ‚àë i ‚àà Finset.range (2 ^ k), (u‚Åª¬π) ^ (2 ^ i) = 1

Module.Basis in Mathlib.LinearAlgebra.Basis.Defs

List.foldl in Init.Prelude

def relayKStateProp (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i)
  (stmtIn : Statement (L := L) Context i.succ)
  (witMid : Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
  (oStmtIn : (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j))
  : Prop :=
  masterKStateProp (mp := mp) (œë := œë) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
    (stmtIdx := i.succ) (oracleIdx := i.succ)
    (h_le := le_refl _)
    (stmt := stmtIn) (wit := witMid) (oStmt := mapOStmtOutRelayStep
      ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hNCR oStmtIn)
    (localChecks := True)

def foldKStateProp {i : Fin ‚Ñì} (m : Fin (2 + 1))
    (tr : Transcript m (pSpecFold (L := L))) (stmt : Statement (L := L) Context i.castSucc)
    (witMid : Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j) :
    Prop :=
  
  let h_star : ‚Ü•L‚¶É‚â§ 2‚¶Ñ[X] := getSumcheckRoundPoly ‚Ñì ùìë (i := i) (h := witMid.H)
  
  let get_H·µ¢ := fun (m: Fin (2 + 1)) (tr: Transcript m pSpecFold) (hm: 1 ‚â§ m.val) =>
    let ‚ü®msgsUpTo, _‚ü© := Transcript.equivMessagesChallenges (k := m)
      (pSpec := pSpecFold (L := L)) tr
    let i_msg1 : ((pSpecFold (L := L)).take m m.is_le).MessageIdx :=
      ‚ü®‚ü®0, Nat.lt_of_succ_le hm‚ü©, by admit /- proof elided -/
      ‚ü©
    let h_i : L‚¶É‚â§ 2‚¶Ñ[X] := msgsUpTo i_msg1
    h_i

  let get_r·µ¢' := fun (m: Fin (2 + 1)) (tr: Transcript m pSpecFold) (hm: 2 ‚â§ m.val) =>
    let ‚ü®msgsUpTo, chalsUpTo‚ü© := Transcript.equivMessagesChallenges (k := m)
      (pSpec := pSpecFold (L := L)) tr
    let i_msg1 : ((pSpecFold (L := L)).take m m.is_le).MessageIdx :=
      ‚ü®‚ü®0, Nat.lt_of_succ_le (Nat.le_trans (by admit /- proof elided -/
      ) hm)‚ü©, by admit /- proof elided -/
      ‚ü©
    let h_i : L‚¶É‚â§ 2‚¶Ñ[X] := msgsUpTo i_msg1
    let i_msg2 : ((pSpecFold (L := L)).take m m.is_le).ChallengeIdx :=
      ‚ü®‚ü®1, Nat.lt_of_succ_le hm‚ü©, by admit /- proof elided -/
      ‚ü©
    let r_i' : L := chalsUpTo i_msg2
    r_i'

  match m with
  | ‚ü®0, _‚ü© => 
    masterKStateProp (mp := mp) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (stmtIdx := i.castSucc) (oracleIdx := i.castSucc)
      (h_le := le_refl _)
      (stmt := stmt) (wit := witMid) (oStmt := oStmt)
      (localChecks := True)
  | ‚ü®1, h1‚ü© => 
    masterKStateProp (mp := mp) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (stmtIdx := i.castSucc) (oracleIdx := i.castSucc)
      (h_le := le_refl _)
      (stmt := stmt) (wit := witMid) (oStmt := oStmt)
      (localChecks :=
        let h_i := get_H·µ¢ (m := ‚ü®1, h1‚ü©) (tr := tr) (hm := by admit /- proof elided -/
        )
        let explicitVCheck := h_i.val.eval 0 + h_i.val.eval 1 = stmt.sumcheck_target
        let localizedRoundPolyCheck := h_i = h_star
        explicitVCheck ‚àß localizedRoundPolyCheck
      )
  | ‚ü®2, h2‚ü© => 
    
    masterKStateProp (mp := mp) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (stmtIdx := i.castSucc) (oracleIdx := i.castSucc)
      (h_le := le_refl _)
      (stmt := stmt) (wit := witMid) (oStmt := oStmt)
      (localChecks :=
        let h_i := get_H·µ¢ (m := ‚ü®2, h2‚ü©) (tr := tr) (hm := by admit /- proof elided -/
        )
        let r_i' := get_r·µ¢' (m := ‚ü®2, h2‚ü©) (tr := tr) (hm := by admit /- proof elided -/
        )
        let localizedRoundPolyCheck := h_i = h_star
        let nextSumcheckTargetCheck := 
          h_i.val.eval r_i' = h_star.val.eval r_i'
        localizedRoundPolyCheck ‚àß nextSumcheckTargetCheck
      ) 

PMF in Mathlib.Probability.ProbabilityMassFunction.Basic

def MlPoly.mk {R : Type*} (n : ‚Ñï) (v : Vector R (2 ^ n)) : MlPoly R n := v

Rat.castRec in Mathlib.Algebra.Field.Defs

instance [Semiring R] : Module R (MlPolyEval R n) where
  smul := smul
  one_smul a := by admit /- proof elided -/

instance instST‚ÇÇ [SelectableType R] : ‚àÄ i, SelectableType
    ((‚ü®!v[.P_to_V], !v[R‚¶É‚â§ deg‚¶Ñ[X]]‚ü© ++‚Çö !p[] ++‚Çö ‚ü®!v[.V_to_P], !v[R]‚ü©).Challenge i) :=
  instSelectableTypeChallengeAppend

instance : ‚àÄ j, OracleInterface ((pSpecRelay).Message j)
  | ‚ü®x, hj‚ü© => by admit /- proof elided -/

@[inline]
def ofArray [Zero R] (coeffs : Array R) (n : ‚Ñï) : MlPolyEval R n :=
  .ofFn (fun i => if h : i.1 < coeffs.size then coeffs[i] else 0)

private def Bi (B : Finset (Fin n ‚Üí F)) (i : Fin n) : Finset ((Fin n ‚Üí F) √ó (Fin n ‚Üí F)) :=
  { x | x ‚àà B √óÀ¢ B ‚àß x.1 i = x.2 i ‚àß x.1 ‚â† x.2 }

def fork : Prop :=
  
  trace = [] ‚àß state = 0

alias E_fork := fork

Polynomial.monomial in Mathlib.Algebra.Polynomial.Basic

abbrev ScalarField := ZMod SCALAR_FIELD_CARD

class Memory (Œπ : Type u) (Œ± : Œπ ‚Üí Type v) (M : Type w) where
   
  read (m : M) (i : Œπ) : Œ± i
   
  write (m : M) (i : Œπ) (v : Œ± i) : M

Polynomial.comp in Mathlib.Algebra.Polynomial.Eval.Defs

@[ext]
structure ProverState (n : ‚Ñï) where
  PrvState : Fin (n + 1) ‚Üí Type

@[inline]
def smul [Mul R] (r : R) (p : MlPoly R n) : MlPoly R n := p.map (fun a => r * a)

finCongr in Mathlib.Data.Fin.SuccPred

def bool (j : Fin numWires) : Gate ùì° numWires :=
  { qL := -1, qR := 0, qO := 0, qM := 1, qC := 0, a := j, b := j, c := j }

instance : ‚àÄ j, SelectableType ((pSpecFoldRelay (L:=L)).Challenge j) :=
  instSelectableTypeChallengeAppend

structure ParamConditions (P : Params Œπ F) where
  h_deg : ‚àÉ k : ‚Ñï, P.deg = 2^k
  h_foldingParams : ‚àÄ i : Fin (M + 1), ‚àÉ k : ‚Ñï, (P.foldingParam i) = 2^k
  h_deg_ge : P.deg ‚â• ‚àè i : Fin (M + 1), (P.foldingParam i)
  h_smooth : ‚àÄ i : Fin (M + 1), Smooth (P.œÜ i)
  h_smooth_le : ‚àÄ i : Fin (M + 1), Fintype.card (Œπ i) ‚â§ (degree Œπ P i)
  h_repeatP_le : ‚àÄ i : Fin (M + 1), P.repeatParam i + 1 ‚â§ (degree Œπ P i)

@[reducible]
def backwardPermutationOracle (Œ± : Type*) : OracleSpec Unit := Œ± ‚Üí‚Çí Œ±

@[elab_as_elim]
def dflatten {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {motive : (k : Fin (vsum n)) ‚Üí Sort*}
    (v : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí motive (embedSum i j)) (k : Fin (vsum n)) : motive k :=
  match m with
  | 0 => Fin.elim0 k
  | _ + 1 =>
    dappend
      (fun j => v 0 j)
      (fun j => dflatten (motive := fun j => motive (natAdd _ j)) (fun i => v i.succ) j)
      k

def drop (m : ‚Ñï) (h : m ‚â§ n) (pSpec : ProtocolSpec n) : ProtocolSpec (n - m) :=
  {dir := Fin.drop m h pSpec.dir, ¬´Type¬ª := Fin.drop m h pSpec.¬´Type¬ª}

structure ProverPrivateRng (R : Type*) where
   
  ds : Unit 
   
  csrng : R
deriving Repr

noncomputable def rate [Semiring F] (LC : LinearCode Œπ F) : ‚Ñö‚â•0 :=
  (dim LC : ‚Ñö‚â•0) / length LC

def towerOfExponents (g : G) (a : ZMod p) (n : ‚Ñï) : Vector G (n + 1) :=
  .ofFn (fun i => g ^ (a.val ^ i.val))

def InternalData.EquivIndexFun {Œ± : Type} (s : Skeleton) :
    InternalData Œ± s ‚âÉ (SkeletonInternalIndex s ‚Üí Œ±) where
  toFun := fun tree idx => tree.get idx
  invFun := fun f => InternalData.ofFun s f
  left_inv := by admit /- proof elided -/

@[reducible, simp] def OStmtOut := fun _ : Fin 2 => OStatement

def Œ≤ (R : F[X][X][Y]) (t : ‚Ñï) : ùí™ H :=
  (Œ≤_regular R H (Nat.le_refl _) t).choose

instance [ProverFirst pSpec] : Unique (pSpec.MessageIdx) where
  default := ‚ü®0, by admit /- proof elided -/
  ‚ü©
  uniq := fun ‚ü®i, _‚ü© => by admit /- proof elided -/

One in Init.Prelude

def rootMultiplicity‚ÇÄ.{u} {F : Type u} [Semiring F] [DecidableEq F] (f : F[X][Y]) : Option ‚Ñï :=
  let deg := weightedDegree f 1 1
  match deg with
  | none => none
  | some deg => List.max?
    (List.map
      (fun x => if coeff f x.1 x.2 ‚â† 0 then x.1 + x.2 else 0)
      (List.product (List.range deg.succ) (List.range deg.succ)))

noncomputable def towerRingHomBackwardMap (k : ‚Ñï) : BTField k ‚Üí ConcreteBTField k :=

def ValidChurchNat : Type :=
  { f : ChurchNat ‚Ñï // ‚àÉ n, ‚àÄ g x, f g x = Nat.iterate g n x }

def coeffsBySuffix (a : Fin (2 ^ ‚Ñì) ‚Üí L) (i : Fin (‚Ñì + 1)) (v : Fin (2 ^ i.val)) :
  Fin (2 ^ (‚Ñì - i)) ‚Üí L :=
  fun ‚ü®j, hj‚ü© => by admit /- proof elided -/

def univPolyHom {F : Type} [CommRing F] [IsDomain F] : F[X] ‚Üí+* RatFunc F :=
  algebraMap (F[X]) (RatFunc F)

noncomputable def towerEquiv_zero : RingEquiv (R:=GF(2)) (S:=ConcreteBTField 0) :=  {
  toFun := fun x => if x = 0 then 0 else 1,
  invFun := fun x => if x = 0 then 0 else 1,
  left_inv := fun x => by admit /- proof elided -/

def commitKStateProp (i : Fin ‚Ñì) (m : Fin (1 + 1))
  (stmtIn : Statement (L := L) Context i.succ)
  (witMid : Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
  (oStmtIn : (i_1 : Fin (toOutCodewordsCount ‚Ñì œë i.castSucc)) ‚Üí
    OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc i_1)
  : Prop :=

  match m with
  | ‚ü®0, _‚ü© => 
    masterKStateProp (mp := mp) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (stmtIdx := i.succ) (oracleIdx := i.castSucc)
      (h_le := by admit /- proof elided -/
      )
      (stmt := stmtIn) (wit := witMid) (oStmt := oStmtIn)
      (localChecks := True)
  | ‚ü®1, _‚ü© => 
    let ‚ü®_, stmtOut, oStmtOut, witOut‚ü© := getCommitProverFinalOutput ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i ‚ü®stmtIn, oStmtIn, witMid‚ü©
    masterKStateProp (mp := mp) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (stmtIdx := i.succ) (oracleIdx := i.succ)
      (h_le := le_refl _)
      (stmt := stmtOut) (wit := witOut) (oStmt := oStmtOut)
      (localChecks := True)

instance {i : Fin (‚Ñì / œë - 1)} : ‚àÄ j, SelectableType ((pSpecFullNonLastBlock ùîΩq Œ≤
  (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i).Challenge j) := instSelectableTypeChallengeAppend

@[inline] def add (a b : AssocNat) : AssocNat :=
  ‚ü®a ‚àò b, by admit /- proof elided -/
  ‚ü©

def ConcreteBTFieldAlgebra {l r : ‚Ñï} (h_le : l ‚â§ r) :
    Algebra (ConcreteBTField l) (ConcreteBTField r) := instAlgebraTowerConcreteBTF.toAlgebra h_le

Set.Nontrivial in Mathlib.Data.Set.Subsingleton

noncomputable def towerRingEquiv0 : BTField 0 ‚âÉ+* ConcreteBTField 0 :=

def fflatten‚ÇÇ {A : Sort u} {B : Sort v} {F : A ‚Üí B ‚Üí Sort w} {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï}
    {Œ± : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí A} {Œ≤ : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí B}
    (v : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí F (Œ± i j) (Œ≤ i j)) :
    (k : Fin (vsum n)) ‚Üí F (Fin.vflatten Œ± k) (Fin.vflatten Œ≤ k) :=
  match m with
  | 0 => !h[]
  | _ + 1 => fappend‚ÇÇ (v 0) (fflatten‚ÇÇ (fun i => v i.succ))

instance {n : ‚Ñï} : OfNat (Cayley T) n where
  ofNat := ofNat n

noncomputable def discriminant {F : Type} [Field F] [Inhabited F] (f : F[X]) : F :=
  1/f.leadingCoeff * Polynomial.resultant f (Polynomial.derivative f)

@[inline, reducible]
def OracleStatement.Lens (OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut : Type)
    {Outer_Œπ‚Çõ·µ¢ : Type} (OuterOStmtIn : Outer_Œπ‚Çõ·µ¢ ‚Üí Type) [‚àÄ i, OracleInterface (OuterOStmtIn i)]
    {Outer_Œπ‚Çõ‚Çí : Type} (OuterOStmtOut : Outer_Œπ‚Çõ‚Çí ‚Üí Type) [‚àÄ i, OracleInterface (OuterOStmtOut i)]
    {Inner_Œπ‚Çõ·µ¢ : Type} (InnerOStmtIn : Inner_Œπ‚Çõ·µ¢ ‚Üí Type) [‚àÄ i, OracleInterface (InnerOStmtIn i)]
    {Inner_Œπ‚Çõ‚Çí : Type} (InnerOStmtOut : Inner_Œπ‚Çõ‚Çí ‚Üí Type) [‚àÄ i, OracleInterface (InnerOStmtOut i)]
  :=
    Statement.Lens (OuterStmtIn √ó ‚àÄ i, OuterOStmtIn i) (OuterStmtOut √ó ‚àÄ i, OuterOStmtOut i)
                  (InnerStmtIn √ó ‚àÄ i, InnerOStmtIn i) (InnerStmtOut √ó ‚àÄ i, InnerOStmtOut i)

HomogeneousPow in Init.Prelude

HSMul in Init.Prelude

Polynomial.leadingCoeff in Mathlib.Algebra.Polynomial.Degree.Definitions

def partialSum {Œ± : Type*} [AddMonoid Œ±] (l : List Œ±) : List Œ± :=
  [0] ++ match l with
  | [] => []
  | a :: l' => (partialSum l').map (a + ¬∑)

instance (k : ‚Ñï) : NeZero (2^k) :=

@[simp]
instance BTField_Fintype (k : ‚Ñï) : Fintype (BTField k) := (BinaryTowerAux k).2.instFintype

def isZero {Œ± : Type} (n : ChurchNat Œ±) : ChurchBool Œ± :=
  fun x y => n (fun _ => y) x

@[reducible]
def GroupValTable (Œπ : Type*) (G : Type*) := Œ†‚ÇÄ _ : Œπ, Option G

@[reducible, simp] def StmtOut : Type := R √ó R

instance instNatPow {n : ‚Ñï} : NatPow (CNat n) := match n with
  | 0 => by admit /- proof elided -/
  | .succ n => by admit /- proof elided -/

def FullData.EquivIndexFun {Œ± : Type} (s : Skeleton) :
    FullData Œ± s ‚âÉ (SkeletonNodeIndex s ‚Üí Œ±) where
  toFun := fun tree idx => tree.get idx
  invFun := fun f => FullData.ofFun s f
  left_inv := by admit /- proof elided -/

def LeafData.composeBuild {Œ± : Type} {s : Skeleton} (leaf_data_tree : LeafData Œ± s)
    (compose : Œ± ‚Üí Œ± ‚Üí Œ±) :
    FullData Œ± s :=
  match s, leaf_data_tree with
  | Skeleton.leaf, LeafData.leaf value =>
    FullData.leaf value
  | Skeleton.internal _ _, LeafData.internal left right =>
    let left_tree := LeafData.composeBuild left compose
    let right_tree := LeafData.composeBuild right compose
    FullData.internal
      (compose left_tree.getRootValue right_tree.getRootValue)
      left_tree
      right_tree

def churchFalse : ChurchBool Œ± := fun _ y => y

noncomputable def ofMvPolynomialAlgHom : MvPolynomial œÉ R ‚Üí‚Çê[R] P := MvPolynomial.aeval X

Fintype.piFinset in Mathlib.Data.Fintype.Pi

FreeMonad in ToMathlib.Control.Monad.Free

def powFiberT (i : ‚Ñï) {k : ‚Ñï} {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F} (S' : Finset (indexPowT S œÜ i))
  (œÜ' : (indexPowT S œÜ i) ‚Ü™ F) (y : indexPowT S œÜ k) :=
  { x : (indexPowT S œÜ i) // x ‚àà S' ‚àß (œÜ' x) ^ (2^(k-i)) = y.val }

noncomputable def foldVerifier :
  OracleVerifier []‚Çí
    (Statement F i.castSucc) (OracleStatement D x s i.castSucc)
    (Statement F i.succ) (OracleStatement D x s i.succ)
    (pSpec D x s i) where
  verify := fun prevChallenges roundChallenge =>
    pure (Fin.vappend prevChallenges (fun _ => roundChallenge ‚ü®0, by admit /- proof elided -/
    ‚ü©))
  embed :=
    ‚ü®
      fun j =>
        if h : j.val = (i.val + 1)
        then Sum.inr ‚ü®1, by admit /- proof elided -/
        ‚ü©
        else Sum.inl ‚ü®j.val, by admit /- proof elided -/
        ‚ü©,
      by admit /- proof elided -/
    ‚ü©
  hEq := by admit /- proof elided -/

def ConstraintSystem (ùì° : Type) (numWires numGates : ‚Ñï) := Fin numGates ‚Üí Gate ùì° numWires

instance instOracleInterfaceMessagePSpec : ‚àÄ i, OracleInterface ((pSpec R deg).Message i) :=
  instOracleInterfaceMessageAppend

def BindingAdversary (oSpec : OracleSpec Œπ) (Data Commitment AuxState : Type)
    [O : OracleInterface Data] :=
  OracleComp oSpec (Commitment √ó O.Query √ó O.Response √ó O.Response √ó AuxState)

Vector.ofFn in Init.Data.Vector.Basic

def checkInitImports : IO Bool := do
  \n\
      The `header` linter is included in Mathlib.Init, and every file in Mathlib \
      should import Mathlib.Init.\nPlease adjust the imports accordingly."
    return true

  e

@[reducible, inline, specialize, simp]
def MessageIdx (vPSpec : VectorSpec n) := {i : Fin n // vPSpec.dir i = .P_to_V}

instance : Fintype (pSpec.MessageIdx) := Subtype.fintype (fun i => pSpec.dir i = .P_to_V)

Equiv.toEmbedding in Mathlib.Logic.Embedding.Basic

@[inline] def pred [Zero T] [ToNat T] (a : Cayley T) : Cayley T :=
  match (‚Üëa : Nat) with
  | 0 => zero
  | Nat.succ n => ofNat n

noncomputable def distFromCode (u : n ‚Üí R) (C : Set (n ‚Üí R)) : ‚Ñï‚àû :=
  sInf {d | ‚àÉ v ‚àà C, hammingDist u v ‚â§ d}

def new (domainSeparator : DomainSeparator U H) : HashStateWithInstructions U H :=
  letI stack := domainSeparator.finalize
  letI tag := generateTag domainSeparator.asBytes
  { ds := Initialize.new tag, stack := stack }

instance : Field ScalarField := ZMod.instField scalarFieldSize

OracleSpec.QueryLog.inr in VCVio.OracleComp.QueryTracking.Structures

Ideal in Mathlib.RingTheory.Ideal.Defs

Id.run in Init.Control.Id

def KnowledgeStateFunctionOneShot.toKnowledgeStateFunction
    {relIn : Set (StmtIn √ó WitIn)} {relOut : Set (StmtOut √ó WitOut)}
    {verifier : Verifier oSpec StmtIn StmtOut pSpec}
    (stF : KnowledgeStateFunctionOneShot init impl relIn.language relOut.language verifier)
    (oneShotE : Extractor.RoundByRoundOneShot oSpec StmtIn WitIn pSpec) :
    verifier.KnowledgeStateFunction init impl relIn relOut oneShotE.toRoundByRound where
  toFun := fun m stmtIn tr witIn => if m = 0 then (stmtIn, witIn) ‚àà relIn else
    stF.toFun m stmtIn tr ‚à® (stmtIn, oneShotE m stmtIn tr default) ‚àà relIn
  toFun_empty := fun stmtIn witIn => by admit /- proof elided -/

Pow in Init.Prelude

def relayKnowledgeStateFunction (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
    (relayOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        i hNCR).KnowledgeStateFunction init impl
      (relIn := foldStepRelOut (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i.succ)
      (extractor := relayRbrExtractor ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) where
  toFun := fun m ‚ü®stmtIn, oStmtIn‚ü© tr witMid =>
    relayKStateProp (mp:=mp) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (ùìë := ùìë) i hNCR stmtIn witMid oStmtIn
  toFun_empty := fun ‚ü®stmtIn, oStmtIn‚ü© witIn => by admit /- proof elided -/

reduceCtorEq in Lean.Meta.Tactic.Simp.BuiltinSimprocs.Core

@[inline]
def seqCompose {m : ‚Ñï} (Stmt : Fin (m + 1) ‚Üí Type) (Wit : Fin (m + 1) ‚Üí Type)
    {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (R : (i : Fin m) ‚Üí
      Reduction oSpec (Stmt i.castSucc) (Wit i.castSucc) (Stmt i.succ) (Wit i.succ) (pSpec i)) :
    Reduction oSpec (Stmt 0) (Wit 0) (Stmt (Fin.last m)) (Wit (Fin.last m)) (seqCompose pSpec) where
  prover := Prover.seqCompose Stmt Wit (fun i => (R i).prover)
  verifier := Verifier.seqCompose Stmt (fun i => (R i).verifier)

def relation : Set (M √ó M √ó List (MemoryOp Œπ Œ±)) :=
  { ‚ü®startMem, finalMem, ops‚ü© | processMemoryOps ops startMem = some finalMem }

@[inline, reducible]
def toContext :
    Context.Lens (OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i)) (OuterStmtOut √ó (‚àÄ i, OuterOStmtOut i))
                (InnerStmtIn √ó (‚àÄ i, InnerOStmtIn i)) (InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i))
                OuterWitIn OuterWitOut InnerWitIn InnerWitOut :=
  ‚ü®lens.stmt, lens.wit‚ü©

NoZeroDivisors in Mathlib.Algebra.GroupWithZero.Defs

@[simp]
def outerRelIn_Test : Set (OuterStmtIn_Test √ó Unit) :=
  setOf (fun ‚ü®‚ü®p, q, t‚ü©, _‚ü© => ‚àë x ‚àà {0, 1}, (p * q).eval x = t)

Polynomial.erase in Mathlib.Algebra.Polynomial.Basic

Lagrange.basis in Mathlib.LinearAlgebra.Lagrange

Subtype.fintype in Mathlib.Data.Fintype.Sets

def InnerStmtIn_Test := ‚Ñ§[X] √ó ‚Ñ§

instance {Œπ : Type} : OracleInterface (OracleStatement Œπ F ()) := OracleInterface.instFunction

OracleComp.neverFailsWhen in VCVio.OracleComp.Traversal

HSMul.hSMul in Init.Prelude

Nat.reduceBeqDiff in Lean.Meta.Tactic.Simp.BuiltinSimprocs.Nat

instance instOI‚ÇÇ : ‚àÄ i, OracleInterface
    ((‚ü®!v[.P_to_V], !v[R‚¶É‚â§ deg‚¶Ñ[X]]‚ü© ++‚Çö !p[] ++‚Çö ‚ü®!v[.V_to_P], !v[R]‚ü©).Message i) :=
  instOracleInterfaceMessageAppend

NatCast in Init.Data.Cast

Function.Injective2 in Mathlib.Logic.Function.Basic

List.max? in Init.Data.List.Basic

@[inline] def toT [Zero T] (c : Cayley T) : T := c.toFun 0

def oracleReduction : OracleReduction oSpec (StmtIn R) (OStmtIn R deg) Unit
                                            (StmtOut R) (OStmtOut R deg) Unit (pSpec R deg) where
  prover := prover R deg oSpec
  verifier := oracleVerifier R deg D oSpec

AlternativeMonad in Batteries.Control.AlternativeMonad

Polynomial.toFinsupp in Mathlib.Algebra.Polynomial.Basic

def deriveTranscriptSR {Œπ : Type} {oSpec : OracleSpec Œπ} {StmtIn : Type}
    (stmt : StmtIn) (messages : pSpec.Messages) :
    OracleComp (oSpec ++‚Çí fsChallengeOracle StmtIn pSpec) pSpec.FullTranscript := do
  MessagesUpTo.deriveTranscriptSR stmt (Fin.last n) messages

alias deriveTranscriptFS := deriveTranscriptSR

OracleSpec.DecidableEq in VCVio.OracleComp.OracleSpec

@[reducible]
def GroupEncodeOracle : OracleSpec Unit := fun _ => (Œπ, BitVec bitLength)

message in Examples.FrankingProtocol

Fin.castSuccEmb in Mathlib.Data.Fin.Embedding

def testNTTBTF‚ÇÉ : Fin (2 ^ (2 + 2)) ‚Üí BTF‚ÇÉ :=

def knowledgeStateFunction (hRel : ‚àÄ stmtIn witOut,
      (mapStmt stmtIn, witOut) ‚àà relOut ‚Üí (stmtIn, mapWitInv stmtIn witOut) ‚àà relIn) :
    (verifier oSpec mapStmt).KnowledgeStateFunction
      init impl relIn relOut (extractor mapWitInv) where
  toFun | ‚ü®0, _‚ü© => fun stmtIn _ witIn => ‚ü®stmtIn, witIn‚ü© ‚àà relIn
  toFun_empty := fun stmtIn witIn => by admit /- proof elided -/

Mod in Init.Prelude

Module.Basis.reindex in Mathlib.LinearAlgebra.Basis.Defs

Eq.mp in Init.Core

@[inline, reducible]
def proj : OuterStmtIn √ó OuterWitIn ‚Üí InnerWitIn :=
  lens.toFunA

instance instDCast‚ÇÅ‚ÇÇ : DCast (Œ≤ a) (Œ≥ a) where
  dcast hb c := dcast‚ÇÇ (Eq.refl a) (by admit /- proof elided -/
  ) c
  dcast_id := by admit /- proof elided -/

@[reducible]
def scalarFieldSize : Nat :=
  21888242871839275222246405745257275088548364400416034343698204186575808495617

noncomputable def H_tilde' (H : F[X][Y]) : F[X][Y] :=
  let h·µ¢ (i : ‚Ñï) := H.coeff i
  let d := H.natDegree
  let W := h·µ¢ d
  Polynomial.X ^ d +
    ‚àë i ‚àà (List.range d).toFinset,
      Polynomial.X^(d - 1 - i) *
      Polynomial.C (h·µ¢ (i + 1) * W ^ i)

def Function.extendDomain {Œ± Œ≤ : Type*} [DecidableEq Œ±] [Zero Œ≤] {s : Finset Œ±}
    (f : (x : Œ±) ‚Üí (x ‚àà s) ‚Üí Œ≤) : Œ± ‚Üí Œ≤ :=
  fun x ‚Ü¶ if hx : x ‚àà s then f x hx else 0

def finUInt16Equiv : Fin (2 ^ 16) ‚âÉ UInt16 where
  toFun := fun i => UInt16.ofFin i
  invFun := fun u => u.toFin
  left_inv _ := rfl
  right_inv _ := rfl

def multilinearBasis (l r : ‚Ñï) (h_le : l ‚â§ r) :
    letI instAlgebra := ConcreteBTFieldAlgebra (h_le:=h_le)
    Basis (Fin (2 ^ (r - l))) (ConcreteBTField l) (ConcreteBTField r) :=

UInt32.ofFin in Init.Data.UInt.Basic

instance instDecidableEqOption {Œ± : Type*} [DecidableEq Œ±] :
    DecidableEq (Option Œ±) := inferInstance

Polynomial.eval‚ÇÇ in Mathlib.Algebra.Polynomial.Eval.Defs

OracleComp.construct in VCVio.OracleComp.OracleComp

def concat' {k : Fin n}
    (messages : (i : Fin k) ‚Üí (pSpec.dir (i.castLE (by admit /- proof elided -/
    )) = .P_to_V
      ‚Üí pSpec.¬´Type¬ª (i.castLE (by admit /- proof elided -/
      ))))
    (msg : (h : pSpec.dir k = .P_to_V) ‚Üí pSpec.Message ‚ü®k, h‚ü©) :
    (i : Fin (k + 1)) ‚Üí (pSpec.dir (i.castLE (by admit /- proof elided -/
    )) = .P_to_V) ‚Üí
      pSpec.¬´Type¬ª (i.castLE (by admit /- proof elided -/
      )) :=
  Fin.dconcat messages msg

@[reducible, simp] def StmtAfterSendClaim : Type := R

Nat.cast in Init.Data.Cast

def uniqueDecodable (C : Code Œπ F) (r : ‚Ñù) : Prop :=
  listDecodable C r 1

noncomputable def minBlockRelDistance
  (i k : ‚Ñï) {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F}
  [DecidableEq F] [DecidableEq Œπ] [Smooth œÜ]
  (f : (indexPowT S œÜ i) ‚Üí F) (S' : Finset (indexPowT S œÜ i))
  (œÜ' : (indexPowT S œÜ i) ‚Ü™ F) (Set : Set ((indexPowT S œÜ i) ‚Üí F))
  [‚àÄ i : ‚Ñï, Fintype (indexPowT S œÜ i)]
  [h : DecidableBlockDisagreement i k f S' œÜ'] : ‚Ñù‚â•0 :=
    sInf { d : ‚Ñù‚â•0 | ‚àÉ g ‚àà Set, Œî·µ£(i, k, f, S', œÜ', g) = d}

Algebra.cast in Mathlib.Algebra.Algebra.Defs

@[reducible]
def coreInteractionOracleVerifier :=
  OracleVerifier.append (oSpec:=[]‚Çí)
    (Stmt‚ÇÅ := Statement (L := L) (‚Ñì:=‚Ñì) (SumcheckBaseContext L ‚Ñì) 0)
    (Stmt‚ÇÇ := Statement (L := L) (‚Ñì:=‚Ñì) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì))
    (Stmt‚ÇÉ := FinalSumcheckStatementOut (L:=L) (‚Ñì:=‚Ñì))
    (OStmt‚ÇÅ := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë 0)
    (OStmt‚ÇÇ := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (OStmt‚ÇÉ := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (pSpec‚ÇÅ := pSpecSumcheckFold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (pSpec‚ÇÇ := pSpecFinalSumcheckStep (L:=L))
    (V‚ÇÅ := sumcheckFoldOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (V‚ÇÇ := finalSumcheckVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))

instance [VerifierFirst pSpec] : ‚àÄ i, OracleInterface (pSpec.Message i) := isEmptyElim

def listOfCloseCodewordsRel (C : Code Œπ F) (y : Œπ ‚Üí F) (r : ‚Ñù) : ‚Ñï :=
  Nat.card (relHammingBall C y r)

WithTop in Mathlib.Order.TypeTags

Quotient in Init.Core

SMul in Init.Prelude

noncomputable def UniPolyC.toPoly (p : UniPolyC R) : Polynomial R := p.val.toPoly

alias ofPoly := Polynomial.toImpl

@[inline]
def neg [Neg R] (p : MlPolyEval R n) : MlPolyEval R n := p.map (fun a => -a)

@[inline, specialize]
def nsmul (n : ‚Ñï) (p : UniPoly R) : UniPoly R :=
  nsmul_raw n p |> trim

@[reducible]
def foldCommitOracleVerifier (i : Fin ‚Ñì) (hCR : isCommitmentRound ‚Ñì œë i) :
  OracleVerifier []‚Çí
    (StmtIn := Statement (L := L) Context i.castSucc)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.succ)
    (pSpec := pSpecFoldCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) :=
    OracleVerifier.append (oSpec:=[]‚Çí)
      (pSpec‚ÇÅ := pSpecFold (L:=L))
      (pSpec‚ÇÇ := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)
      (V‚ÇÅ := foldOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)
      (V‚ÇÇ := commitOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hCR)

Eq.mpr in Init.Core

@[reducible]
def CanonicalDuplexSponge (U : Type) [SpongeUnit U] [SpongeSize] :=
  DuplexSponge U (CanonicalSpongeState U)

@[simp]
abbrev SecondSumcheckChallenge : Type := Fin pp.‚Ñì_n ‚Üí R

def matrixSubmoduleOfLinearCode (Œ∫ : Type*) [Fintype Œ∫]
                                (LC : LinearCode Œπ F) : MatrixSubmodule Œ∫ Œπ F :=
  Submodule.span F { V | ‚àÄ i, V i ‚àà LC }

abbrev BaseField := ZMod baseFieldSize

Fin.succAboveCases in Mathlib.Data.Fin.Tuple.Basic

def Option.doubleBind_v2 {Œ± Œ≤ Œ≥ : Type} (f : Œ± ‚Üí Œ≤ ‚Üí Option Œ≥)
    (x : Option Œ±) (y : Option Œ≤) : Option Œ≥ := do
  let a ‚Üê x
  let b ‚Üê y
  f a b

setOf in Mathlib.Data.Set.Defs

def powMod (a b m : ‚Ñï) : ‚Ñï := Id.run do
  let mut x := a
  let mut n := b
  let mut res := 1

  while n > 0 do
    if n % 2 == 1 then
      res := (x * res) % m
    x := (x * x) % m
    n := n / 2

  return res

RingHomCompTriple in Mathlib.Algebra.Ring.CompTypeclasses

instance {k : Fin 1} : Unique (MessagesUpTo k !p[]) where
  default := fun ‚ü®‚ü®i, h‚ü©, _‚ü© => by admit /- proof elided -/

def ratchetUnchecked [Permute C] (sponge : DuplexSponge U C) : DuplexSponge U C :=
  simulateQ' forwardPermutationOracleImpl (ratchet sponge) (by admit /- proof elided -/
  )

noncomputable def polynomialFromNovelCoeffs (‚Ñì : ‚Ñï) (h_‚Ñì : ‚Ñì ‚â§ r)
  (a : Fin (2 ^ ‚Ñì) ‚Üí L) : L[X] := ‚àë j, C (a j) * (X‚±º ùîΩq Œ≤ ‚Ñì h_‚Ñì j)

def knowledgeSoundness
    (relIn : Set ((StmtIn √ó ‚àÄ i, OStmtIn i) √ó WitIn))
    (relOut : Set ((StmtOut √ó ‚àÄ i, OStmtOut i) √ó WitOut))
    (verifier : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec)
    (knowledgeError : ‚Ñù‚â•0) : Prop :=
  verifier.toVerifier.knowledgeSoundness init impl relIn relOut knowledgeError

@[reducible, simp]
def completeness
    (relation : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (oracleProof : OracleProof oSpec Statement OStatement Witness pSpec)
    (completenessError : ‚Ñù‚â•0) : Prop :=
  OracleReduction.completeness init impl
    relation acceptRejectOracleRel oracleProof completenessError

def intCast {k : ‚Ñï} (n : ‚Ñ§) : ConcreteBTField k := if n % 2 = 0 then zero else one

def relDistCodewords [DecidableEq F] (U V : Matrix Œ∫ Œπ F) : ‚Ñù :=
  (Matrix.neqCols U V).card / Fintype.card Œπ

noncomputable def queryOracleVerifier :
  OracleVerifier
    (oSpec := []‚Çí)
    (StmtIn := FinalSumcheckStatementOut (L:=L) (‚Ñì:=‚Ñì))
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (
    Fin.last ‚Ñì))
    (StmtOut := Bool)
    (OStmtOut := fun _ : Empty => Unit)
    (pSpec := pSpecQuery ùîΩq Œ≤ Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)) where
  verify := fun (stmt: FinalSumcheckStatementOut (L:=L) (‚Ñì:=‚Ñì))
    (challenges: (pSpecQuery ùîΩq Œ≤ Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).Challenges) => do
    
    let c := stmt.final_constant
    let fold_challenges : Fin Œ≥_repetitions ‚Üí sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate 0 :=
      challenges ‚ü®0, by admit /- proof elided -/
      ‚ü©

    
    
    for rep in (List.finRange Œ≥_repetitions) do
      let mut c_cur : L := 0 
      let v := fold_challenges rep

      for k_val in List.finRange (‚Ñì / œë) do
        let i := k_val * œë
        have h_k: k_val ‚â§ (‚Ñì/œë - 1) := by admit /- proof elided -/

noncomputable def fixFirstVariablesOfMQP (v : Fin (‚Ñì + 1))
  (H : MvPolynomial (Fin ‚Ñì) L) (challenges : Fin v ‚Üí L) : MvPolynomial (Fin (‚Ñì - v)) L :=
  have h_l_eq : ‚Ñì = (‚Ñì - v) + v := by rw [Nat.add_comm]; exact (Nat.add_sub_of_le v.is_le).symm
  -- Step 1 : Rename L[X Fin ‚Ñì] to L[X (Fin (‚Ñì - v) ‚äï Fin v)]
  let finEquiv := finSumFinEquiv (m := ‚Ñì - v) (n := v).symm
  let H_sum : L[X (Fin (‚Ñì - v) ‚äï Fin v)] :=

@[reducible]
def combineMap : StmtIn √ó WitIn ‚Üí OracleComp oSpec (StmtOut √ó WitOut) :=
  fun ‚ü®stmt, wit‚ü© => do return (‚Üê mapStmt stmt, ‚Üê mapWit stmt wit)

noncomputable def queryRbrExtractor :
  Extractor.RoundByRound []‚Çí
    (StmtIn := (FinalSumcheckStatementOut (L:=L) (‚Ñì:=‚Ñì))
      √ó (‚àÄ j, OracleStatement ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì) j))
    (WitIn := Unit)
    Unit
    (pSpec := pSpecQuery ùîΩq Œ≤ Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (fun _ => Unit) where
  eqIn := rfl
  extractMid := fun _ _ _ witMidSucc => witMidSucc
  extractOut := fun _ _ _ => ()

def finalSumcheckKnowledgeError (m : pSpecFinalSumcheckStep (L := L).ChallengeIdx) :
  ‚Ñù‚â•0 :=
  match m with
  | ‚ü®0, h0‚ü© => nomatch h0

instance (priority := low) : DCast Œ± Œ≤ where
  dcast h := cast (congrArg Œ≤ h)
  dcast_id := by admit /- proof elided -/

def mkFieldInstance {k : ‚Ñï} (props : ConcreteBTFieldProps k) : Field (ConcreteBTField k) where
  toDivisionRing := mkDivisionRingInstance (k:=k) props
  mul_comm := props.mul_comm

def processMemoryOps (ops : List (MemoryOp Œπ Œ±)) (startMem : M) : Option M :=
  ops.foldlM (fun m op =>
    match op with
    | .read ‚ü®i, v‚ü© => if Memory.read m i = v then some m else none
    | .write ‚ü®i, v‚ü© => some (Memory.write m i v)
  ) startMem

instance : Fact (Nat.Prime scalarFieldSize) := ‚ü®ScalarField_is_prime‚ü©

def commitKState (i : Fin ‚Ñì) (hCR : isCommitmentRound ‚Ñì œë i) :
    (commitOracleVerifier ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      i hCR).KnowledgeStateFunction init impl
      (relIn := foldStepRelOut (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i.succ)
      (extractor := commitRbrExtractor ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) where
  toFun := fun m ‚ü®stmtIn, oStmtIn‚ü© tr witMid =>
    commitKStateProp ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (i := i) (m := m) (stmtIn := stmtIn) (witMid := witMid) (oStmtIn := oStmtIn) (mp:=mp)
  toFun_empty := fun stmtIn witMid => by admit /- proof elided -/

abbrev CoeffVecSpace (L : Type u) (‚Ñì : Nat) := Fin (2^‚Ñì) ‚Üí L

private noncomputable def Q (œâs : Fin n ‚Üí F)
  (f : Fin n ‚Üí F) (p : Polynomial F) (e : ‚Ñï) : Polynomial F :=
  p * (E œâs f p e)

def KnowledgeStateFunction.toStateFunction
    {relIn : Set (StmtIn √ó WitIn)} {relOut : Set (StmtOut √ó WitOut)}
    {verifier : Verifier oSpec StmtIn StmtOut pSpec} {WitMid : Fin (n + 1) ‚Üí Type}
    {extractor : Extractor.RoundByRound oSpec StmtIn WitIn WitOut pSpec WitMid}
    (kSF : KnowledgeStateFunction init impl relIn relOut verifier extractor) :
      verifier.StateFunction init impl relIn.language relOut.language where
  toFun := fun m stmtIn tr => ‚àÉ witMid, kSF.toFun m stmtIn tr witMid
  toFun_empty := by admit /- proof elided -/

Finsupp.linearCombination in Mathlib.LinearAlgebra.Finsupp.LinearCombination

List.Vector.cons in Mathlib.Data.Vector.Defs

def findIdxRev?_def {cond} {as : Array Œ±} {k : Fin as.size} :
  findIdxRev? cond as = some k ‚Üí cond as[k] :=

def equivFin2 : Direction ‚âÉ Fin 2 where
  toFun := fun dir => match dir with | .V_to_P => ‚ü®0, by admit /- proof elided -/
  ‚ü© | .P_to_V => ‚ü®1, by admit /- proof elided -/
  ‚ü©
  invFun := fun n => match n with | ‚ü®0, _‚ü© => .V_to_P | ‚ü®1, _‚ü© => .P_to_V
  left_inv := fun dir => match dir with | .P_to_V => rfl | .V_to_P => rfl
  right_inv := fun n => match n with | ‚ü®0, _‚ü© => rfl | ‚ü®1, _‚ü© => rfl

@[inline]
def ofOutputOnly
    (liftWit : OuterStmtIn √ó OuterWitIn ‚Üí InnerStmtOut √ó InnerWitOut ‚Üí OuterWitOut) :
    Witness.Lens OuterStmtIn InnerStmtOut OuterWitIn OuterWitOut OuterWitIn InnerWitOut :=
  ‚ü®Prod.snd, liftWit‚ü©

noncomputable def extractMLP (i : Fin ‚Ñì) (f : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®i, by omega‚ü© ‚Üí L) :
    Option (L‚¶É‚â§ 1‚¶Ñ[X Fin (‚Ñì - i)]) :=

@[ext]
structure ProtocolSpec (n : ‚Ñï) where
   
  dir : Fin n ‚Üí Direction
   
  ¬´Type¬ª : Fin n ‚Üí Type
deriving Inhabited

noncomputable def Œ∑Star (U : Type) [SpongeUnit U] [Fintype U]
    (t‚Çï t‚Çö t‚Çö·µ¢ : ‚Ñï) (L : ‚Ñï) (Œµcodec : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) : ‚Ñù‚â•0 :=
  let tTotal : ‚Ñï := (t‚Çï + t‚Çö + t‚Çö·µ¢)
  
  
  
  
  let firstTermNumerator : ‚Ñù‚â•0 :=
    7 * tTotal ^2 + (28 * L + 25) * tTotal + (14 * L + 1) * (L + 1)
  let firstTermDenominator : ‚Ñù‚â•0 := 2 * ((Fintype.card U) ^ (SpongeSize.C + 1))
  
  let secondTerm : ‚Ñù‚â•0 := Œ∏Star t‚Çï t‚Çö t‚Çö·µ¢ * (iSup Œµcodec)
  
  let thirdTerm : ‚Ñù‚â•0 := ‚àë i, Œµcodec i
  
  firstTermNumerator / firstTermDenominator + secondTerm + thirdTerm

DecidableRel in Init.Prelude

instance [Zero T] [ToNat T] : DecidableRel (@LT.lt (Cayley T) _) := fun a b =>
  Nat.decLt (‚Üëa) (‚Üëb)

instance [Zero T] [One T] [ToNat T] : NatPow (Cayley T) where
  pow := powNat

instance [ProverFirst pSpec] : ProverLast pSpec where
  prover_last' := by admit /- proof elided -/

noncomputable instance : Algebra K (Left ‚äó[K] Right) := Algebra.TensorProduct.instAlgebra

def indexPow (S : Finset Œπ) (œÜ : Œπ ‚Ü™ F) (k : ‚Ñï) : Finset F :=
  S.image (fun x => (œÜ x) ^ k)

noncomputable def finalSumcheckOracleReduction :
  OracleReduction
    (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì))
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì))
    (StmtOut := FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì))
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (WitOut := Unit)
    (pSpec := pSpecFinalSumcheckStep (L := L)) where
  prover := finalSumcheckProver ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
  verifier := finalSumcheckVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)

@[inline, specialize]
def oracleVerifier : OracleVerifier oSpec
    Unit (fun _ : Fin 2 => OStatement)
    (Query OStatement) (fun _ : Fin 2 => OStatement) (pSpec OStatement) where

  verify := fun _ chal => do
    let q : Query OStatement := chal ‚ü®0, rfl‚ü©
    pure q

  embed := Function.Embedding.inl

  hEq := by admit /- proof elided -/

def eq {Œ± : Type u} (mx my : m Œ±) : Prop :=
  evalDist mx = evalDist my

def getPutativeRoot {n : ‚Ñï} (i : Fin (2 ^ n)) (leaf : Œ±) (proof : List.Vector Œ± n) :
    OracleComp (spec Œ±) Œ± := do
  match h : n with
  | 0 => do
    
    return leaf
  | n + 1 => do
    
    let signBit := i.val % 2
    
    let i' : Fin (2 ^ n) := ‚ü®i.val / 2, by admit /- proof elided -/
    ‚ü©
    if signBit = 0 then
      
      let newLeaf ‚Üê query (spec := spec Œ±) () ‚ü®leaf, proof.get (Fin.last n)‚ü©
      getPutativeRoot i' newLeaf (proof.drop 1)
    else
      
      let newLeaf ‚Üê query (spec := spec Œ±) () ‚ü®proof.get (Fin.last n), leaf‚ü©
      getPutativeRoot i' newLeaf (proof.drop 1)

@[inline, specialize, simp]
def prover : Prover oSpec Statement Witness Statement Witness !p[] := Prover.id

GroupWithZero in Mathlib.Algebra.GroupWithZero.Defs

@[reducible]
def fieldSize : Nat := 2 ^ 31 - 1

Infinite in Mathlib.Data.Finite.Defs

Quotient.mk in Init.Core

Fin.foldl in Init.Data.Fin.Fold

@[inline, reducible]
def lift : (OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i)) √ó OuterWitIn ‚Üí
    (InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i)) √ó InnerWitOut ‚Üí
    (OuterStmtOut √ó (‚àÄ i, OuterOStmtOut i)) √ó OuterWitOut :=
  fun ctxIn ctxOut => ‚ü®lens.stmt.lift ctxIn.1 ctxOut.1, lens.wit.lift ctxIn ctxOut‚ü©

Monoid.toMulAction in Mathlib.Algebra.Group.Action.Defs

MvPolynomial.restrictDegree in Mathlib.RingTheory.MvPolynomial.Basic

noncomputable def divergence (U V : Set (Œπ ‚Üí F)) : ‚Ñö‚â•0 :=
  haveI : Fintype (possibleDeltas U V) := @Fintype.ofFinite _ finite_possibleDeltas
  if h : (possibleDeltas U V).Nonempty
  then (possibleDeltas U V).toFinset.max' (Set.toFinset_nonempty.2 h)
  else 0

def renameMessage (pSpec : ProtocolSpec n) (NewMessage : pSpec.MessageIdx ‚Üí Type) :
    ProtocolSpec n :=
  ‚ü® pSpec.dir,
    fun i => if h : pSpec.dir i = Direction.P_to_V then NewMessage ‚ü®i, h‚ü© else pSpec.¬´Type¬ª i‚ü©

Nat.pow in Init.Prelude

instance [Zero T] [ToNat T] : LE (Cayley T) where
  le := le

@[reducible, simp]
def oraclePSpec : ProtocolSpec 1 := ‚ü®!v[.P_to_V], !v[Witness]‚ü©

def generator : BaseField √ó BaseField := (1, 2)

Algebra in Mathlib.Algebra.Algebra.Defs

noncomputable def twiddleFactor (i : Fin ‚Ñì) (u : Fin (2 ^ (‚Ñì + R_rate - i - 1))) : L :=
  ‚àë (‚ü®k, hk‚ü©: Fin (‚Ñì + R_rate - i - 1)),
    if Nat.getBit k u.val = 1 then
      
        
      (normalizedW ùîΩq Œ≤ ‚ü®i, by admit /- proof elided -/
      ‚ü©).eval (Œ≤ ‚ü®i + 1 + k, by admit /- proof elided -/
      ‚ü©)
    else 0

def Equiv.ofLawfulPermute (Œ± : Type*) [Permute Œ±] [LawfulPermute Œ±] : Equiv Œ± Œ± where
  toFun := Permute.permute
  invFun := LawfulPermute.permuteInv
  left_inv := LawfulPermute.left_inv
  right_inv := LawfulPermute.right_inv

class IsSound (langIn : Set StmtIn) (langOut : Set StmtOut)
    (verifier : Verifier oSpec StmtIn StmtOut pSpec) where
  soundnessError : ‚Ñù‚â•0
  is_sound : soundness init impl langIn langOut verifier soundnessError

@[inline]
def zsmul [SMul ‚Ñ§ R] (m : ‚Ñ§) (p : MlPoly R n) : MlPoly R n := p.map (fun a => m ‚Ä¢ a)

def absorbFast (sponge : DuplexSponge U C) (arr : Array U) :
    OracleComp (forwardPermutationOracle C) (DuplexSponge U C) := do
  
  let sponge1 := { sponge with squeezePos := Fin.last SpongeSize.R }
  
  
  if hEmpty : arr.isEmpty then
    return sponge1
  else
    
    
    if hFull : sponge.absorbPos = SpongeSize.R then do
      
      have : 0 < sponge.absorbPos := by admit /- proof elided -/

protected def OracleReduction.id :
    OracleReduction oSpec Statement OStatement Witness Statement OStatement Witness !p[] :=
  ‚ü®OracleProver.id, OracleVerifier.id‚ü©

alias Prover.trivial := Prover.id
alias Verifier.trivial := Verifier.id
alias Reduction.trivial := Reduction.id
alias OracleProver.trivial := OracleProver.id
alias OracleVerifier.trivial := OracleVerifier.id
alias OracleReduction.trivial := OracleReduction.id

DecidablePred in Init.Prelude

Algebra.TensorProduct.includeRight in Mathlib.RingTheory.TensorProduct.Basic

@[reducible, inline, specialize]
def ChallengesUpTo (k : Fin (n + 1)) (pSpec : ProtocolSpec n) : Type :=
  ‚àÄ i, (pSpec.take k k.is_le).Challenge i

structure ProverInteractionWithOutput {Œπ : Type} (oSpec : OracleSpec Œπ) (Output : Type)
    {n : ‚Ñï} (pSpec : ProtocolSpec n) extends
      ProverState n,
      ProverInit (PrvState 0),
      ProverRound oSpec pSpec,
      ProverOutput oSpec Output (PrvState (Fin.last n))

def hintBytes (state : FSVerifierState U H) :
    Except DomainSeparatorMismatch (FSVerifierState U H √ó ByteArray) := do
  let newHashState ‚Üê state.hashState.hint

    
  if state.nargString.size < 4 then
    .error { message := "Insufficient transcript remaining for hint" }
  else
    
    let byte0 := state.nargString[0]!.toNat
    let byte1 := state.nargString[1]!.toNat
    let byte2 := state.nargString[2]!.toNat
    let byte3 := state.nargString[3]!.toNat
    let length := byte0 + (byte1 <<< 8) + (byte2 <<< 16) + (byte3 <<< 24)
    let rest := state.nargString.extract 4 state.nargString.size

    
    if rest.size < length then
      .error { message := s!"Insufficient transcript remaining, got {rest.size}, need {length}" }
    else
      
      let hint := rest.extract 0 length
      let remaining := rest.extract length rest.size
      .ok ({ hashState := newHashState, nargString := remaining }, hint)

def closePtsOnAffineLine {Œπ : Type*} [Fintype Œπ]
                         (u v : Œπ ‚Üí F) (deg : ‚Ñï) (Œ± : Œπ ‚Ü™ F) (e : ‚Ñï) : Set (Œπ ‚Üí F) :=
  {x : Œπ ‚Üí F | x ‚àà Affine.line u v ‚àß distFromCode x (ReedSolomon.code Œ± deg) ‚â§ e}

def hli_level_diff_0 (l : ‚Ñï) :
  letI instAlgebra:= binaryAlgebraTower (l:=l) (r:=l) (h_le:=by omega)
  @Basis (Fin 1) (BTField l) (BTField l) _ _ instAlgebra.toModule :=

def SkeletonNodeIndex.isLeaf {s : Skeleton} (idx : SkeletonNodeIndex s) : Bool :=
  match idx with
  | SkeletonNodeIndex.ofLeaf => true
  | SkeletonNodeIndex.ofInternal => false
  | SkeletonNodeIndex.ofLeft _ => false
  | SkeletonNodeIndex.ofRight _ => false

OracleComp.simulateQ in VCVio.OracleComp.SimSemantics.SimulateQ

@[inline, specialize]
def runWithLogToRound (i : Fin (n + 1))
    (stmt : StmtIn) (wit : WitIn) (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí)
        ((pSpec.Transcript i √ó prover.PrvState i) √ó QueryLog (oSpec ++‚Çí [pSpec.Challenge]‚Çí)) :=
  (simulateQ loggingOracle (prover.runToRound i stmt wit)).run

structure Size where
  m : ‚Ñï 
  n : ‚Ñï 
  n_w : ‚Ñï 
  n_w_le_n : n_w ‚â§ n := by admit /- proof elided -/

@[reducible, simp]
def completeness (relation : Set (Statement √ó Witness)) (completenessError : ‚Ñù‚â•0)
    (proof : Proof oSpec Statement Witness pSpec) : Prop :=
  Reduction.completeness init impl relation acceptRejectRel proof completenessError

def extract {n : ‚Ñï} {Œ± : Fin n ‚Üí Sort*} (start stop : ‚Ñï) (h1 : start ‚â§ stop) (h2 : stop ‚â§ n)
    (v : (i : Fin n) ‚Üí Œ± i) : (i : Fin (stop - start)) ‚Üí Œ± ‚ü®i + start, by admit /- proof elided -/
    ‚ü© :=
  fun i ‚Ü¶ v ‚ü®i + start, by admit /- proof elided -/
  ‚ü©

def MessageIdx.inr (i : MessageIdx pSpec‚ÇÇ) : MessageIdx (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ) :=
  ‚ü®Fin.natAdd m i.1, by admit /- proof elided -/
  ‚ü©

Units.mk0 in Mathlib.Algebra.GroupWithZero.Units.Basic

abbrev Field := ZMod fieldSize

instance [inst : VCVCompatible Chal] : ‚àÄ i, VCVCompatible (Challenge ‚ü®!v[.V_to_P], !v[Chal]‚ü© i)
  | ‚ü®0, _‚ü© => inst

noncomputable def definingPoly {F : Type*} [instField : Field F] (s : F)
  := X ^ 2 + C s * X + 1

OneMemClass in Mathlib.Algebra.Group.Submonoid.Defs

instance instSelectableTypeChallengePSpec [SelectableType R] :
    ‚àÄ i, SelectableType ((pSpec R deg).Challenge i) :=
  instSelectableTypeChallengeAppend

def partition (cs : ConstraintSystem ùì° numWires numGates) :
    Fin numWires ‚Üí Finset (Fin (3 * numGates)) :=
  
  
  
  
  fun i => Finset.map (Equiv.toEmbedding finProdFinEquiv)
    (Finset.filter (fun j => if j.1 = 0 then (cs j.2).a = i
      else if j.1 = 1 then (cs j.2).b = i else (cs j.2).c = i)
    (Finset.univ : Finset (Fin 3 √ó Fin numGates)))

Nat.reduceBEq in Lean.Meta.Tactic.Simp.BuiltinSimprocs.Nat

Matrix.det in Mathlib.LinearAlgebra.Matrix.Determinant.Basic

def LeafData.optionComposeBuild {Œ± : Type} {s : Skeleton} (leaf_data_tree : LeafData Œ± s)
    (compose : Œ± ‚Üí Œ± ‚Üí Option Œ±) :
    FullData (Option Œ±) s :=
  (leaf_data_tree.map (.some)).composeBuild (Option.doubleBind compose)

instance instAlgebraTowerConcreteBTF : AlgebraTower (ConcreteBTField) where
  algebraMap := concreteTowerAlgebraMap
  commutes' := by admit /- proof elided -/

def FullData.toLeafData {Œ± : Type} {s : Skeleton}
    (tree : FullData Œ± s) : LeafData Œ± s :=
  match tree with
  | FullData.leaf value => LeafData.leaf value
  | FullData.internal _ left right =>
    LeafData.internal (left.toLeafData) (right.toLeafData)

def natDegreeY (f : F[X][Y]) : ‚Ñï := Polynomial.natDegree f

@[reducible]
def OracleStatement (i : Fin (k + 1)) : Fin (i.val + 1) ‚Üí Type :=
  fun j =>
    evalDomain D x (‚àë j' ‚àà finRangeTo j.1, s j')
      ‚Üí F

def ofMessagesChallenges (messages : Messages pSpec) (challenges : Challenges pSpec) :
    FullTranscript pSpec :=

instance : Sub AssocNat where
  sub := sub

RingHom.id in Mathlib.Algebra.Ring.Hom.Defs

instance instDCast : DCast Nat Fin where
  dcast h := Fin.cast h
  dcast_id := by admit /- proof elided -/

noncomputable def polynomialFromNovelCoeffsF‚ÇÇ
  (‚Ñì : ‚Ñï) (h_‚Ñì : ‚Ñì ‚â§ r) (a : Fin (2 ^ ‚Ñì) ‚Üí L) : L‚¶É<2^‚Ñì‚¶Ñ[X] :=
  ‚ü®polynomialFromNovelCoeffs ùîΩq Œ≤ ‚Ñì h_‚Ñì a, by
    simp only [mem_degreeLT, Nat.cast_pow, Nat.cast_ofNat]
    apply (Polynomial.degree_sum_le Finset.univ (fun j => C (a j) * X‚±º ùîΩq Œ≤ ‚Ñì h_‚Ñì j)).trans_lt
    apply (Finset.sup_lt_iff ?_).mpr ?_
    ¬∑ -- ‚ä¢ ‚ä• < 2 ^ ‚Ñì
      exact compareOfLessAndEq_eq_lt.mp rfl
    ¬∑ -- ‚àÄ b ‚àà univ, (C (a b) * X‚±º ùîΩq Œ≤ ‚Ñì h_‚Ñì b).degree < 2 ^ ‚Ñì
      intro j _
      -- ‚ä¢ (C (a j) * X‚±º ùîΩq Œ≤ ‚Ñì h_‚Ñì j).degree < 2 ^ ‚Ñì
      calc (C (a j) * X‚±º ùîΩq Œ≤ ‚Ñì h_‚Ñì j).degree
        _ ‚â§ (C (a j)).degree + (X‚±º ùîΩq Œ≤ ‚Ñì h_‚Ñì j).degree :=

noncomputable def foldOracleReduction (i : Fin ‚Ñì) :
  OracleReduction (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) Context i.castSucc)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (pSpec := pSpecFold (L := L)) where
  prover := foldOracleProver ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i
  verifier := foldOracleVerifier ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i

Module.Basis.baseChange in Mathlib.LinearAlgebra.TensorProduct.Basis

instance : AlgebraTower (BTField) where
  algebraMap := towerAlgebraMap
  commutes' := by admit /- proof elided -/

noncomputable instance {v : Œπ ‚Üí F} {s : AffineSubspace F (Œπ ‚Üí F)} [Fintype s] :
    Fintype (v +·µ• s) := Fintype.ofFinite ‚Ü•(v +·µ• s)

class VerifierFirst (pSpec : ProtocolSpec n) [NeZero n] where
  verifier_first' : pSpec.dir 0 = .V_to_P

@[ext]
structure OracleReduction {Œπ : Type} (oSpec : OracleSpec Œπ)
    (StmtIn : Type) {Œπ‚Çõ·µ¢ : Type} (OStmtIn : Œπ‚Çõ·µ¢ ‚Üí Type) (WitIn : Type)
    (StmtOut : Type) {Œπ‚Çõ‚Çí : Type} (OStmtOut : Œπ‚Çõ‚Çí ‚Üí Type) (WitOut : Type)
    {n : ‚Ñï} (pSpec : ProtocolSpec n)
    [O‚Çõ·µ¢ : ‚àÄ i, OracleInterface (OStmtIn i)] [O‚Çò : ‚àÄ i, OracleInterface (pSpec.Message i)]
    where
  prover : OracleProver oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec
  verifier : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec

Prod in Init.Prelude

noncomputable instance {s : Set (Œπ ‚Üí F)} : Fintype (affineSpan F s) :=
  Fintype.ofFinite ‚Ü•(affineSpan F s)

def oracleReduction.sendClaim : OracleReduction oSpec (StmtIn R) (OStmtIn R deg) Unit
    (StmtAfterSendClaim R) (OStmtAfterSendClaim R deg) Unit ‚ü®!v[.P_to_V], !v[R‚¶É‚â§ deg‚¶Ñ[X]]‚ü© := sorry

instance : SubSpec [pSpec‚ÇÅ.Challenge]‚Çí ([(pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).Challenge]‚Çí) where
  monadLift | query i t => instSubSpecOfProtocolSpecAppendChallenge.monadLift (query (Sum.inl i) t)

@[elab_as_elim] def Fin.predRecOnSameFinType {motive : Fin r ‚Üí Sort _}
    (last : motive (‚ü®r - 1, by
      have h_r_ne_0: r ‚â† 0 := by exact NeZero.ne r
      omega
    ‚ü© : Fin r))
    (succ : ‚àÄ i : Fin r, i.val > 0 ‚Üí motive i ‚Üí motive (‚ü®i.val - 1, by omega‚ü© : Fin r))
    (i : Fin r): motive i :=

MvPolynomial.totalDegree in Mathlib.Algebra.MvPolynomial.Degrees

def rtake {n : ‚Ñï} {Œ± : Fin n ‚Üí Sort*} (m : ‚Ñï) (h : m ‚â§ n) (v : (i : Fin n) ‚Üí Œ± i) :
    (i : Fin m) ‚Üí Œ± (Fin.cast (Nat.sub_add_cancel h) (natAdd (n - m) i)) :=
  fun i => v (Fin.cast (Nat.sub_add_cancel h) (natAdd (n - m) i))

def deterministicMillerRabin (n : ‚Ñï) : Bool := Id.run do
  if n ‚â§ 2 ‚à® n % 2 = 0 then
    return n = 2

  let ‚ü®s, d‚ü© := factorOutTwos (n - 1)
  for a in millerRabinBases do
    if a % n == 0 then
      continue

    let mut x := powMod a d n
    if x = 1 ‚à® x = n - 1 then
      continue

    for _ in [0:s] do
      x := (x * x) % n
      if x == n - 1 ‚à® x ‚â§ 1 then
        break
    if x ‚â† n - 1 then
      return false

  return true

Finsupp.equivFunOnFinite in Mathlib.Data.Finsupp.Defs

Real in Mathlib.Data.Real.Basic

instance : Fact (Nat.Prime fieldSize) := ‚ü®is_prime‚ü©

Finset.Icc in Mathlib.Order.Interval.Finset.Defs

OrderDual.toDual in Mathlib.Order.Synonym

LinearIndepOn in Mathlib.LinearAlgebra.LinearIndependent.Defs

ZMod.charP in Mathlib.Data.ZMod.Basic

@[ext]
structure VectorSpec (n : ‚Ñï) where
  dir : Fin n ‚Üí Direction
  length : Fin n ‚Üí Nat

@[app_unexpander Fin.vempty]
def vemptyUnexpander : Lean.PrettyPrinter.Unexpander
  | `($_:ident) => `(!v[])
  | _ => throw ()

instance : Pow (UniPoly R) Nat := ‚ü®UniPoly.pow‚ü©

instance (k : ‚Ñï) : Fintype (ConcreteBTField k) := (getBTFResult k).instFintype

class RoundByRoundOneShot.IsMonotone (E : RoundByRoundOneShot oSpec StmtIn WitIn pSpec)
    (relIn : Set (StmtIn √ó WitIn)) where
  is_monotone : ‚àÄ roundIdx stmtIn transcript,
    ‚àÄ proveQueryLog‚ÇÅ proveQueryLog‚ÇÇ : oSpec.QueryLog,
    
    proveQueryLog‚ÇÅ.Sublist proveQueryLog‚ÇÇ ‚Üí
    
    
    (stmtIn, E roundIdx stmtIn transcript proveQueryLog‚ÇÅ) ‚àà relIn ‚Üí
      (stmtIn, E roundIdx stmtIn transcript proveQueryLog‚ÇÇ) ‚àà relIn

noncomputable def polynomialAlgEquiv : P ‚âÉ‚Çê[R] R[X] where
  toFun := toPolynomialAlgHom
  invFun := ofPolynomialAlgHom
  left_inv := by admit /- proof elided -/

Fin.dfoldr in Batteries.Data.Fin.Basic

protected def cast
    (hO‚Çò : ‚àÄ i, O‚Çò‚ÇÅ i = dcast (Message.cast_idx hSpec) (O‚Çò‚ÇÇ (i.cast hn hSpec)))
    (V : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec‚ÇÅ) :
    OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec‚ÇÇ where
  verify := fun stmt challenges =>
    simulateQ sorry (V.verify stmt (dcast‚ÇÇ hn.symm (dcast_symm hn hSpec) challenges))
  embed := V.embed.trans
    (Embedding.sumMap
      (Equiv.refl _).toEmbedding
      ‚ü®MessageIdx.cast hn hSpec, MessageIdx.cast_injective hn hSpec‚ü©)
  hEq := fun i => by admit /- proof elided -/

def joinBits {n m : ‚Ñï} (low : Fin (2 ^ n)) (high : Fin (2 ^ m)) : Fin (2 ^ (m+n)) :=
  ‚ü®(high.val <<< n) ||| low.val, by admit /- proof elided -/
  ‚ü©

instance instDCastPSigma : DCast ((a : Œ±) √ó' Œ≤ a) (fun a => Œ≥ a.1 a.2) where
  dcast hab c := dcast‚ÇÇ (by admit /- proof elided -/
  ) (by admit /- proof elided -/
  ) c
  dcast_id := by admit /- proof elided -/

def outputRelation :
    Set
      (
        (Fri.Spec.Statement F (0 : Fin (k + 1)) √ó
        (‚àÄ j, Fri.Spec.OracleStatement D x s (0 : Fin (k + 1)) j)) √ó
        Fri.Spec.Witness F s d (0 : Fin (k + 2))
      ) := sorry

Mod.mod in Init.Prelude

protected def Verifier.id : Verifier oSpec Statement Statement !p[] where
  verify := fun stmt _ => pure stmt

def disagreementSet (i : Fin ‚Ñì) (steps : ‚Ñï) [NeZero steps] (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
  (f g : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i.val + steps, by admit /- proof elided -/
    ‚ü©) :
  Set ((sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®i.val + steps, by admit /- proof elided -/
  ‚ü©) :=
  {y | f y ‚â† g y}

def weightedDegree.{u} {F : Type u} [Semiring F] (p : F[X][Y]) (u v : ‚Ñï) : Option ‚Ñï :=
  List.max? <|
    List.map (fun n => u * (p.coeff n).natDegree + v * n) (List.range p.natDegree.succ)

ByteArray.empty in Init.Prelude

def partialEval {k : ‚Ñï} (f : MvPolynomial (Fin m) F) (Œ± : Fin k ‚Üí F) (h : k ‚â§ m) :
    MvPolynomial (Fin (m - k)) F :=
  let œÜ : Fin m ‚Üí MvPolynomial (Fin (m - k)) F := fun i =>
    if h' : i.val < k then
      C (Œ± ‚ü®i.val, h'‚ü©)
    else
      let j := i.val - k
      let j' : Fin (m - k) := ‚ü®j, sorry‚ü©
      X j'
  eval‚ÇÇ C œÜ f

class NonBinaryField (F : Type*) extends Field F where
  char_neq_2 : (2 : F) ‚â† 0

def someTypes : List Type := [Nat, String, Nat]

def Œ≥ (x‚ÇÄ : F) (R : F[X][X][Y]) (H : F[X][Y]) [œÜ : Fact (Irreducible H)] : PowerSeries (ùïÉ H) :=
  let subst (t : ‚Ñï) : ùïÉ H :=
    match t with
    | 0 => fieldToùïÉ (-x‚ÇÄ)
    | 1 => 1
    | _ => 0
  PowerSeries.subst (PowerSeries.mk subst) (PowerSeries.mk (Œ± x‚ÇÄ R H))

Finset.Nonempty in Mathlib.Data.Finset.Empty

BitVec.ofNat in Init.Prelude

LinearMap.codRestrict in Mathlib.Algebra.Module.Submodule.LinearMap

noncomputable def finalSumcheckKnowledgeStateFunction {œÉ : Type} (init : ProbComp œÉ)
    (impl : QueryImpl []‚Çí (StateT œÉ ProbComp)) :
    (finalSumcheckVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).KnowledgeStateFunction init impl
    (relIn := roundRelation ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (ùìë := ùìë) (mp := BBF_SumcheckMultiplierParam) (Fin.last ‚Ñì))
    (relOut := finalSumcheckRelOut ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (extractor := finalSumcheckRbrExtractor ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
  where
  toFun := fun m ‚ü®stmt, oStmt‚ü© tr witMid =>
    finalSumcheckKStateProp ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (ùìë := ùìë) (tr := tr) (stmt := stmt) (witMid := witMid) (oStmt := oStmt)
  toFun_empty := fun stmt witMid => by admit /- proof elided -/

instance : OracleInterface (Witness R pp) where
  Query := Fin pp.‚Ñì_w ‚Üí R
  Response := R
  answer := fun ùï® evalPoint => (MLE (ùï® ‚àò finFunctionFinEquiv)) ‚∏®evalPoint‚∏©

@[reducible]
def FinalStatement (F : Type) (k : ‚Ñï) : Type := Fin (k + 1) ‚Üí F

def knowledgeStateFunction :
    (oracleVerifier oSpec OStatement).KnowledgeStateFunction init impl
    (relIn OStatement) (relOut OStatement) (rbrExtractor oSpec OStatement) where
  toFun
  | 0 => fun ‚ü®_, oracles‚ü© _ _ => oracles 0 = oracles 1
  | 1 => fun ‚ü®_, oracles‚ü© chal _ =>
    let q : Query OStatement := by admit /- proof elided -/

def Prover.addSalt (P : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec)
    (saltComp : (i : pSpec.MessageIdx) ‚Üí P.PrvState i.1.castSucc ‚Üí OracleComp oSpec (Salt i)) :
  Prover oSpec StmtIn WitIn StmtOut WitOut (pSpec.addSalt Salt) where
  PrvState := P.PrvState
  input := P.input
  sendMessage := fun i st => by admit /- proof elided -/

def snd (T : (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).Transcript k) : pSpec‚ÇÇ.Transcript ‚ü®k - m, by admit /- proof elided -/
‚ü© :=
  if hk : k ‚â§ m then
    fun i => Fin.elim0 (by admit /- proof elided -/
    )
  else
    fun i => sorry

instance {k : ‚Ñï} : NatCast (ConcreteBTField k) where
  natCast n:= natCast n

noncomputable def commitOracleVerifier (i : Fin ‚Ñì) (hCR : isCommitmentRound ‚Ñì œë i) :
  OracleVerifier
    (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) Context i.succ)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (O‚Çò := fun i => by admit /- proof elided -/
    )
    
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (pSpec := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) where

  
  
  verify := fun stmtIn pSpecChallenges => do
    pure stmtIn

  embed := ‚ü®fun j => by admit /- proof elided -/
  ‚ü©
  hEq := fun oracleIdx => by admit /- proof elided -/

Set.Ioc in Mathlib.Order.Interval.Set.Defs

def localized_fold_eval (i : Fin ‚Ñì) (steps : ‚Ñï) (h_i_add_steps : i + steps ‚â§ ‚Ñì)
    (f : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate)
      ‚ü®i, by exact Nat.lt_of_le_of_lt (n := i) (k := r) (m := ‚Ñì) (h‚ÇÅ := by
        exact Fin.is_le') (by exact lt_of_add_right_lt h_‚Ñì_add_R_rate)‚ü© ‚Üí L)
    (r_challenges : Fin steps ‚Üí L)
    (y : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®‚Üëi + steps, by omega‚ü©) : L :=

noncomputable def qMap_total_fiber
    
      (i : Fin r) (steps : ‚Ñï) (h_i_add_steps : i.val + steps < ‚Ñì + ùì°)
        (y : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i.val + steps, by admit /- proof elided -/
        ‚ü©)) :
    Fin (2 ^ steps) ‚Üí sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i :=
  if h_steps : steps = 0 then by
    
    subst h_steps
    simp only [add_zero, Fin.eta] at y
    exact fun _ => y
  else by
    
    let basis_y := sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i+steps,by admit /- proof elided -/
    ‚ü©) (by admit /- proof elided -/
    )
    let y_coeffs : Fin (‚Ñì + ùì° - (‚Üëi + steps)) ‚Üí‚ÇÄ ùîΩq := basis_y.repr y

    let basis_x := sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i, by admit /- proof elided -/
    ‚ü© (by admit /- proof elided -/
    )
    exact fun elementIdx => by admit /- proof elided -/

Polynomial.eval‚ÇÇRingHom in Mathlib.Algebra.Polynomial.Eval.Defs

def fst (T : (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).Transcript k) : pSpec‚ÇÅ.Transcript ‚ü®min k m, by admit /- proof elided -/
‚ü© :=
  if hk : k ‚â§ m then
    fun i => by admit /- proof elided -/

def OuterStmtIn_Test := ‚Ñ§[X] √ó ‚Ñ§[X] √ó ‚Ñ§

def outputRelation (cond : ‚àë i, (s i).1 ‚â§ n) [DecidableEq F] (Œ¥ : ‚Ñù‚â•0) :
    Set
      (
        (Statement F i.succ √ó (‚àÄ j, OracleStatement D x s i.succ j)) √ó
        Witness F s d i.succ.castSucc
      ) := sorry

def coreInteractionOracleRbrKnowledgeError (j : (pSpecCoreInteraction ùîΩq Œ≤ (œë := œë)
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).ChallengeIdx) : ‚Ñù‚â•0 :=
    Sum.elim
      (f := fun i => sumcheckFoldKnowledgeError ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)
      (g := fun i => finalSumcheckKnowledgeError (L := L) i)
      (ChallengeIdx.sumEquiv.symm j)

def liftingLens :
  OracleContext.Lens
    ((Fin m ‚Üí F) √ó Fri.Spec.Statement F (0 : Fin (k + 1))) (Fri.Spec.FinalStatement F k)
    (Fri.Spec.Statement F (0 : Fin (k + 1))) (Fri.Spec.FinalStatement F k)
    (OracleStatement D x m) (Fri.Spec.FinalOracleStatement D x s)
    (Fri.Spec.OracleStatement D x s 0) (Fri.Spec.FinalOracleStatement D x s)
    (Fri.Spec.Witness F s d 0) (Fri.Spec.Witness F s d (Fin.last (k + 1)))
    (Fri.Spec.Witness F s d 0) (Fri.Spec.Witness F s d (Fin.last (k + 1))) where
  stmt := Witness.InvLens.ofOutputOnly <| fun ‚ü®‚ü®cs, stmt‚ü©, ostmt‚ü© =>
    ‚ü®
      stmt,
      fun j v =>
          have : v.1 ‚àà Fri.CosetDomain.evalDomain D x 0 := by admit /- proof elided -/
    ‚ü©
  wit  := Witness.Lens.id

def hcons {n : ‚Ñï} {Œ± : Sort u} {Œ≤ : Fin n ‚Üí Sort u} (a : Œ±) (b : (i : Fin n) ‚Üí Œ≤ i) :
    (i : Fin (n + 1)) ‚Üí Fin.vcons Œ± Œ≤ i :=
  fcons (F := id) a b

@[reducible]
def pBits : Nat := 31

@[inline, specialize]
def reduction : Reduction oSpec Statement Unit Statement Unit !p[] where
  prover := prover oSpec Statement
  verifier := verifier oSpec Statement pred

NNRat.castRec in Mathlib.Algebra.Field.Defs

def getConst (k : ‚Ñï) (s : Fin (k + 1) ‚Üí ‚Ñï+) : OracleComp [FinalOracleStatement D x s]‚Çí F[X] :=
  OracleComp.lift
    (by admit /- proof elided -/
    )

noncomputable def toPoly (p : UniPoly R) : Polynomial R :=
  p.eval‚ÇÇ Polynomial.C Polynomial.X

def computableBasisExplicit (k : ‚Ñï) (i : Fin (2 ^ k)) : ConcreteBTField k :=
  (Finset.univ : Finset (Fin k)).prod fun j =>
    if Nat.getBit (n := i.val) (k := j.val) == 1 then
      concreteTowerAlgebraMap (j.val + 1) k (by admit /- proof elided -/
      ) (Z (j.val + 1))
    else
      1

@[reducible]
def GroupEqOracle : OracleSpec Unit := fun _ => (Œπ √ó Œπ, Bool)

def OuterStmtOut_Test := ‚Ñ§[X] √ó ‚Ñ§[X] √ó ‚Ñ§ √ó ‚Ñ§

class DFunEquiv (F : Sort*) (Œ± : outParam (Sort*)) (Œ≤ : outParam <| Œ± ‚Üí Sort*) where
  equiv : F ‚âÉ ‚àÄ a : Œ±, Œ≤ a

instance {pSpec : ProtocolSpec n} {Statement : Type}
    [DecidableEq Statement]
    [‚àÄ i, DecidableEq (pSpec.Message i)]
    [‚àÄ i, DecidableEq (pSpec.Challenge i)] :
    OracleSpec.DecidableEq (srChallengeOracle Statement pSpec) where
  domain_decidableEq' := fun i => by admit /- proof elided -/

def forwardRange (n : ‚Ñï) (r : Fin (n)) (l : Fin (r.val + 1)) : List (Fin n) :=
  let len := r.val - l.val + 1
  List.ofFn (fun (k : Fin len) =>
    let val := l.val + k.val
    have h_bound : val < n := by admit /- proof elided -/
  )

def distCodewords [DecidableEq F] (U V : Matrix Œ∫ Œπ F) : ‚Ñï :=
  (Matrix.neqCols U V).card

instance instDCast‚ÇÉ : DCast‚ÇÉ Nat (fun n => Fin (n + 1)) (fun n _ => ProtocolSpec n)
    (fun _ k pSpec => pSpec.Transcript k) where
  dcast‚ÇÉ h h' h'' T := Transcript.cast h
    (by admit /- proof elided -/
    )
    (by admit /- proof elided -/
    )
    T
  dcast‚ÇÉ_id := cast_id

def outputRelation : Set ((StmtOut R √ó (‚àÄ i, OStmtOut R deg i)) √ó Unit) :=
  { ‚ü®‚ü®‚ü®newTarget, chal‚ü©, oStmt‚ü©, _‚ü© | (oStmt ()).1.eval chal = newTarget }

def params16 : Params where
  width := 16
  numFullRounds := 8
  numPartialRounds := 20
  internalDiagVectors := #v[
       -2,
        1,
        2,
        1 / 2,
        3,
        4,
        -1 / 2,
        -3,
        -4,
        1 / (2 ^ 8),
        1 / 8,
        1 / (2 ^ 24),
        -1 / (2 ^ 8),
        -1 / 8,
        -1 / 16,
        -1 / (2 ^ 24),
    ]
  roundConstants := rawConstants16
  width_dvd_by_4 := by admit /- proof elided -/

def possibleDists (C : Set (Œπ ‚Üí F)) (Œ¥f : (Œπ ‚Üí F) ‚Üí (Œπ ‚Üí F) ‚Üí Œ±) : Set Œ± :=
  {d : Œ± | ‚àÉ p ‚àà Set.offDiag C, Œ¥f p.1 p.2 = d}

def SkeletonNodeIndex.isRoot {s : Skeleton} (idx : SkeletonNodeIndex s) : Bool :=
  match idx with
  | SkeletonNodeIndex.ofLeaf => true
  | SkeletonNodeIndex.ofInternal => true
  | SkeletonNodeIndex.ofLeft _ => false
  | SkeletonNodeIndex.ofRight _ => false

abbrev AffSpanSet [NeZero k] (U : Fin k ‚Üí Œπ ‚Üí F) : Set (Œπ ‚Üí F) :=
  (affineSpan F (Finset.univ.image U : Set (Œπ ‚Üí F))).carrier

def example1 : ChurchVec ‚Ñï := churchCons 1 (churchCons 2 (churchCons 3 churchNil))

example : toList example1 = [1, 2, 3] := rfl

noncomputable def weight_Œõ_over_ùí™ {H : F[X][Y]} (f : ùí™ H) (D : ‚Ñï)
  : WithBot ‚Ñï := weight_Œõ (canonicalRepOfùí™ f) H D

private noncomputable def interpolate : (Œπ ‚Üí F) ‚Üí‚Çó[F] F[X] :=
  Lagrange.interpolate univ domain

def IterType (n : ‚Ñï) : Type := dfoldl' n (fun _ => Type) (fun _ T => T √ó T) Nat


example : IterType 0 = Nat := rfl
example (n : ‚Ñï) : IterType (n + 1) = (IterType n √ó IterType n) := rfl

instance : ‚àÄ i, OracleInterface (Message !p[] i) :=
  fun ‚ü®i, h‚ü© =>
    (Fin.elim0 i : (h' : !p[].dir i = .P_to_V) ‚Üí OracleInterface (!p[].Message ‚ü®i, h'‚ü©)) h

def acceptRejectOracleRel : Set ((Bool √ó (‚àÄ _ : Empty, Unit)) √ó Unit) :=
  { ((true, isEmptyElim), ()) }

instance [NeZero k] {f : Fin k ‚Üí Œπ ‚Üí F} : Nonempty (Finset.univ.image f) :=

def OracleVerifier.liftContext
    (lens : OracleStatement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                              OuterOStmtIn OuterOStmtOut InnerOStmtIn InnerOStmtOut)
    (V : OracleVerifier oSpec InnerStmtIn InnerOStmtIn InnerStmtOut InnerOStmtOut pSpec) :
      OracleVerifier oSpec OuterStmtIn OuterOStmtIn OuterStmtOut OuterOStmtOut pSpec where
  verify := fun outerStmtIn transcript => sorry
  embed := by admit /- proof elided -/

instance : Field BTF‚ÇÉ := instFieldConcrete

def NestedList (n : ‚Ñï) : Type := dfoldr' n (fun _ => Type) (fun _ T => List T) Nat

example : NestedList 0 = Nat := rfl
example (n : ‚Ñï) : NestedList (n + 1) = List (NestedList n) := rfl

@[reducible, inline]
instance (priority := low) instTensorForall {Œπ : Type u} (v : Œπ ‚Üí Type v)
    [O : ‚àÄ i, OracleInterface (v i)] : OracleInterface (‚àÄ i, v i) where
  Query := (i : Œπ) ‚Üí (O i).Query
  Response := (i : Œπ) ‚Üí (O i).Response
  answer := fun f q i => (O i).answer (f i) (q i)

Nat.gcd in Init.Data.Nat.Gcd

@[reducible]
def StateRestoration.KnowledgeSoundness (oSpec : OracleSpec Œπ)
    (StmtIn : Type) {Œπ‚Çõ·µ¢ : Type} (OStmtIn : Œπ‚Çõ·µ¢ ‚Üí Type) (WitOut : Type)
    {n : ‚Ñï} {pSpec : ProtocolSpec n} :=
  Prover.StateRestoration.KnowledgeSoundness oSpec (StmtIn √ó (‚àÄ i, OStmtIn i)) WitOut pSpec

noncomputable def batchVerifier :
  OracleVerifier []‚Çí
    Unit (OracleStatement D x m)
    ((Fin m ‚Üí F) √ó Fri.Spec.Statement F (0 : Fin (k + 1)))
    (OracleStatement D x m)
    (batchSpec F m) where
  verify := fun _ chals => pure ‚ü®chals ‚ü®0, by admit /- proof elided -/
  ‚ü©, Fin.elim0‚ü©
  embed :=
    ‚ü®
      fun i => Sum.inl i,
      by admit /- proof elided -/
    ‚ü©
  hEq := by admit /- proof elided -/

abbrev RScodeSet (domain : Œπ ‚Ü™ F) (deg : ‚Ñï) : Set (Œπ ‚Üí F) := (ReedSolomon.code domain deg).carrier

def squeezeUnchecked [Permute C] (sponge : DuplexSponge U C) (arr : Array U) :
    DuplexSponge U C √ó Array U :=
  simulateQ' (m := Id) forwardPermutationOracleImpl (squeezeInto sponge arr) (by admit /- proof elided -/
  )

instance {s} : LawfulFunctor (fun Œ± => LeafData Œ± s) :=

RingHom in Mathlib.Algebra.Ring.Hom.Defs

noncomputable def Œ¥_Œµ_proximityGap {Œ± : Type} [DecidableEq Œ±] [Nonempty Œ±]
  (P : Finset (Œπ ‚Üí Œ±)) (C : Set (Finset (Œπ ‚Üí Œ±))) (Œ¥ Œµ : ‚Ñù‚â•0) : Prop :=
  ‚àÄ S ‚àà C, ‚àÄ [Nonempty S],
  Xor'
  ( Pr_{let x ‚Üê $·µñ S}[Code.relHammingDistToCode x.1 P ‚â§ Œ¥] = 1 )
  ( Pr_{let x ‚Üê $·µñ S}[Code.relHammingDistToCode x.1 P ‚â§ Œ¥] ‚â§ Œµ )

def dedup {Œπ : Type} (spec : OracleSpec Œπ) : SimOracle.Stateless (spec ++‚Çí spec) spec where
  impl
  | query (.inl i) t => query i t
  | query (.inr i) t => query i t

def oracleFoldingConsistencyProp (i : Fin (‚Ñì + 1)) (challenges : Fin i ‚Üí L)
    (oStmt : ‚àÄ j, (OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i) j) : Prop :=
  ‚àÄ (j : Fin (toOutCodewordsCount ‚Ñì œë i)) (hj : j.val + 1 < toOutCodewordsCount ‚Ñì œë i),
    
    have h_k_bound := oracle_block_k_bound (‚Ñì := ‚Ñì) (œë := œë) (i := i) (j := j)
    have h_k_next_le_i := oracle_block_k_next_le (‚Ñì := ‚Ñì) (œë := œë) (i := i) (j := j) (hj := hj)
    
    isCompliant (i := ‚ü®j.val * œë, by admit /- proof elided -/
    ‚ü©) (steps := œë)
      (h_i_add_steps := by admit /- proof elided -/
      )
      (f_i := oStmt ‚ü®j.val, by admit /- proof elided -/
      ‚ü©)
      (f_i_plus_steps := getNextOracle ùîΩq Œ≤ i oStmt j hj)
      (challenges := getFoldingChallenges (r := r) (ùì° := ùì°) i challenges (k := j.val * œë)
        (h := h_k_next_le_i))

def AlgebraTowerEquiv.toAlgebraOverLeft (e : AlgebraTowerEquiv A B) (i j : Œπ)
    (h : i ‚â§ j) : Algebra (A i) (B j) :=

inductive FullData (Œ± : Type) : Skeleton ‚Üí Type
  | leaf (value : Œ±) : FullData Œ± Skeleton.leaf
  | internal {left right} (value : Œ±)
      (leftData : FullData Œ± left)
      (rightData : FullData Œ± right) :
      FullData Œ± (Skeleton.internal left right)
  deriving Repr

Multiset.map in Mathlib.Data.Multiset.MapFold

def peval (f : œÉ ‚Üí œÉ‚ÇÅ ‚äï œÉ‚ÇÇ) (x : œÉ‚ÇÅ ‚Üí R) : MvPolynomial œÉ R ‚Üí+* MvPolynomial œÉ‚ÇÇ R :=
  eval‚ÇÇHom C (Sum.elim (fun i => C (x i)) X ‚àò f)

noncomputable def liftToFunctionField {H : F[X][Y]} : F[X] ‚Üí+* ùïÉ H :=
  RingHom.comp (Ideal.Quotient.mk (Ideal.span {H_tilde H})) coeffAsRatFunc

Nat.ceil in Mathlib.Algebra.Order.Floor.Defs

def toOracleImpl {Œπ : Type u} (v : Œπ ‚Üí Type v) [O : ‚àÄ i, OracleInterface (v i)]
    (data : ‚àÄ i, v i) : QueryImpl [v]‚Çí Id where
  impl | query i t => (O i).answer (data i) t

def perm (cs : ConstraintSystem ùì° numWires numGates) : Equiv.Perm (Fin (3 * numGates)) := sorry

Lean.Name in Init.Prelude

@[ext]
structure Equiv {m n : ‚Ñï} (pSpec : ProtocolSpec m) (pSpec' : ProtocolSpec n) where
  round_eq : m = n
  dir_eq : ‚àÄ i, pSpec.dir i = pSpec'.dir (Fin.cast round_eq i)
  typeEquiv : ‚àÄ i, pSpec.¬´Type¬ª i ‚âÉ pSpec'.¬´Type¬ª (Fin.cast round_eq i)

@[reducible]
def permutationOracle (Œ± : Type*) : OracleSpec PermuteDir :=
  forwardPermutationOracle Œ± ++‚Çí backwardPermutationOracle Œ±

@[inline, specialize]
def oracleProver : OracleProver oSpec
    Statement OStatement (‚àÄ i, Witness i)
    Statement (OStatement ‚äï·µ• Witness) Unit
    (oraclePSpec Witness) where
  PrvState := fun _ => (Statement √ó (‚àÄ i, OStatement i)) √ó (‚àÄ i, Witness i)
  input := id
  sendMessage | ‚ü®0, _‚ü© => fun ‚ü®stmt, wit‚ü© => pure (wit, ‚ü®stmt, wit‚ü©)
  
  receiveChallenge | ‚ü®0, h‚ü© => nomatch h
  output := fun ‚ü®‚ü®stmt, oStmt‚ü©, wit‚ü© => pure (‚ü®stmt, Sum.rec oStmt wit‚ü©, ())

def BBF_CodeDistance (‚Ñì ùì° : ‚Ñï) (i : Fin (‚Ñì + 1)) : ‚Ñï :=
  2^(‚Ñì + ùì° - i.val) - 2^(‚Ñì - i.val) + 1

Div in Init.Prelude

def InternalData.rightSubtree {Œ± : Type} {s_left s_right : Skeleton}
    (tree : InternalData Œ± (Skeleton.internal s_left s_right)) :
    InternalData Œ± s_right :=
  match tree with
  | InternalData.internal _ _left right =>
    right

noncomputable def fromRowGenMat [Semiring F] (G : Matrix Œ∫ Œπ F) : LinearCode Œπ F :=
  LinearMap.range G.vecMulLinear

@[reducible, simp]
def relOut : Set ((StmtOut OStatement √ó ‚àÄ i, OStmtOut OStatement i) √ó WitOut) :=
  { ‚ü®‚ü®q, oStmt‚ü©, ()‚ü© | answer (oStmt 0) q = answer (oStmt 1) q }

def halfNumFullRounds : Nat := params.numFullRounds / 2

noncomputable instance : Algebra Right (Left ‚äó[K] Right) := Algebra.TensorProduct.rightAlgebra


local notation "e" => Algebra.TensorProduct.comm K Right Left

StrongRankCondition in Mathlib.LinearAlgebra.InvariantBasisNumber

noncomputable def listDecodingCollisionProbability
  (œÜ : Œπ ‚Ü™ F) (f : Œπ ‚Üí F) (Œ¥ : ‚Ñù) (s degree : ‚Ñï)
  (h_nonempty : Nonempty (domainComplement œÜ)) : ENNReal :=
  Pr_{let r ‚Üê$·µñ (Fin s ‚Üí domainComplement œÜ)}[ ‚àÉ (u u' : code œÜ degree),
                                    u.val ‚â† u'.val ‚àß
                                    u.val ‚àà relHammingBall (code œÜ degree) f Œ¥ ‚àß
                                    u'.val ‚àà relHammingBall (code œÜ degree) f Œ¥ ‚àß
                                    ‚àÄ i : Fin s,
                                    let uPoly := decodeLT u
                                    let uPoly' := decodeLT u'
                                    (uPoly : F[X]).eval (r i).1
                                      = (uPoly' : F[X]).eval (r i).1
                                    ]

@[reducible, simp]
def soundness
    (langIn : Set (Statement √ó ‚àÄ i, OStatement i))
    (verifier : OracleVerifier oSpec Statement OStatement Bool (fun _ : Empty => Unit) pSpec)
    (soundnessError : ‚Ñù‚â•0) : Prop :=
  verifier.toVerifier.soundness init impl langIn acceptRejectOracleRel.language soundnessError

Fin.take in Mathlib.Data.Fin.Tuple.Take

def concat {k : Fin n} (challenges : ChallengesUpTo k.castSucc pSpec)
    (h : pSpec.dir k = .V_to_P) (chal : pSpec.Challenge ‚ü®k, h‚ü©) : ChallengesUpTo k.succ pSpec :=
  fun ‚ü®i, h‚ü© => (concat' (pSpec := pSpec) (fun i hi => challenges ‚ü®i, hi‚ü©) (fun _ => chal)) i h

@[reducible]
def get {Œ±s : List (Type u)} : HList Œ±s ‚Üí (n : Fin Œ±s.length) ‚Üí Œ±s.get n
  | x ::‚Çï _, ‚ü®0, _‚ü© => x
  | _ ::‚Çï xs, ‚ü®n+1, h‚ü© => xs.get ‚ü®n, Nat.lt_of_succ_lt_succ h‚ü©

abbrev MatrixSubmodule.{u, v, w} (Œ∫ : Type u) [Fintype Œ∫] (Œπ : Type v) [Fintype Œπ]
                                 (F : Type w) [Semiring F] : Type (max u v w) :=
  Submodule F (Matrix Œ∫ Œπ F)

def foldingBadEvent (i : Fin ‚Ñì) (steps : ‚Ñï) [NeZero steps] (h_i_add_steps : i + steps ‚â§ ‚Ñì)
  (f_i : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i, by admit /- proof elided -/
  ‚ü©)
  (challenges : Fin steps ‚Üí L) : Prop :=
  let d_i_plus_steps := BBF_CodeDistance ‚Ñì ùì° ‚ü®i + steps, by admit /- proof elided -/
  ‚ü©
  if h_is_close : 2 * fiberwiseDistance ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := i)
      steps h_i_add_steps f_i < (d_i_plus_steps : ‚Ñï‚àû) then
    
    
    
    let h_dist_curr_lt := fiberwise_dist_lt_imp_dist_lt_unique_decoding_radius ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := i) (steps := steps) h_i_add_steps f_i h_is_close

    let f_bar_i := uniqueClosestCodeword ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (i := ‚ü®i, by admit /- proof elided -/
      ‚ü©) (h_i := by admit /- proof elided -/
      ) f_i
      h_dist_curr_lt
    let folded_f_i := iterated_fold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (steps := ‚ü®steps, by admit /- proof elided -/
      ‚ü©) (i := ‚ü®i, by admit /- proof elided -/
      ‚ü©)
      (h_i_add_steps := by admit /- proof elided -/
      ) f_i challenges
    let folded_f_bar_i := iterated_fold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (steps := ‚ü®steps, by admit /- proof elided -/
      ‚ü©) (i := ‚ü®i, by admit /- proof elided -/
      ‚ü©)
      (h_i_add_steps := by admit /- proof elided -/
      ) f_bar_i challenges

    let fiberwise_disagreements := fiberwiseDisagreementSet ùîΩq Œ≤ i steps h_i_add_steps
      f_i f_bar_i
    let folded_disagreements := disagreementSet ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i steps
      h_i_add_steps folded_f_i folded_f_bar_i
    
    ¬¨ (fiberwise_disagreements ‚äÜ folded_disagreements)
  else
    
    
    
    let folded_f_i := iterated_fold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (steps := ‚ü®steps, by admit /- proof elided -/
      ‚ü©) (i := ‚ü®i, by admit /- proof elided -/
      ‚ü©)
      (h_i_add_steps := by admit /- proof elided -/
      ) f_i challenges
    let dist_to_code := distFromCode folded_f_i
      (BBF_Code ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i + steps, by admit /- proof elided -/
      ‚ü©)
    2 * dist_to_code < (d_i_plus_steps : ‚Ñï‚àû)

@[inline] def div [Zero T] [DecidableEq T] [ToNat T]
    (dividend divisor : Cayley T) : Cayley T :=
  
  letI fuel := (‚Üëdividend : Nat) + 1
  divNat dividend divisor fuel

Polynomial.derivative in Mathlib.Algebra.Polynomial.Derivative

def minDist [DecidableEq F] (IC : MatrixSubmodule Œ∫ Œπ F) : ‚Ñï :=
  sInf { d : ‚Ñï | ‚àÉ U ‚àà IC, ‚àÉ V ‚àà IC, distCodewords U V = d }

AddMonoidAlgebra in Mathlib.Algebra.MonoidAlgebra.Defs

structure Selector (ùì° : Type*) where
   
  qL : ùì°
   
  qR : ùì°
   
  qO : ùì°
   
  qM : ùì°
   
  qC : ùì°
deriving DecidableEq

MvPolynomial.monomial in Mathlib.Algebra.MvPolynomial.Basic

Function.RightInverse in Init.Data.Function

noncomputable def embeddingOfùí™IntoùïÉ (H : F[X][Y]) : ùí™ H ‚Üí+* ùïÉ H :=
  Ideal.quotientMap
        (I := Ideal.span {H_tilde' H}) (Ideal.span {H_tilde H})
        bivPolyHom sorry

instance [inst : ‚àÄ i, SelectableType (pSpec.Challenge i)] :
    ‚àÄ i, SelectableType ((pSpec.addSalt Salt).Challenge i) :=
  fun i => by admit /- proof elided -/

def toProverState (ds : DomainSeparator U H) (rng : R) : FSProverState U H R :=
  FSProverState.new ds rng

instance : HListRepr (HList []) where
  repr := fun _ => ""

instance : DFunEquiv (‚àÄ a : Œ±, Œ≤ a) Œ± Œ≤ where
  equiv := Equiv.refl _

@[reducible, simp] def WitIn := Unit

@[inline] def mul [Zero T] [ToNat T] (a b : Cayley T) : Cayley T :=
  mulNat a ‚Üëb

instance : Inhabited (UniPolyC R) := ‚ü®#[], Trim.canonical_empty‚ü©

Prod.mk in Init.Prelude

instance : LawfulToNat Nat where
  toNat_zero := rfl
  toNat_succ := fun _ => rfl

instance : Fact (Nat.Prime (PrimeOrder.p G)) :=
  PrimeOrder.hPrime

structure KnowledgeStateFunction
    (relIn : Set (StmtIn √ó WitIn)) (relOut : Set (StmtOut √ó WitOut))
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    {WitMid : Fin (n + 1) ‚Üí Type}
    (extractor : Extractor.RoundByRound oSpec StmtIn WitIn WitOut pSpec WitMid)
    where
   
  toFun : (m : Fin (n + 1)) ‚Üí StmtIn ‚Üí Transcript m pSpec ‚Üí WitMid m ‚Üí Prop
   
  toFun_empty : ‚àÄ stmtIn witMid,
    ‚ü®stmtIn, cast extractor.eqIn witMid‚ü© ‚àà relIn ‚Üî toFun 0 stmtIn default witMid
   
  toFun_next : ‚àÄ m, pSpec.dir m = .P_to_V ‚Üí
    ‚àÄ stmtIn tr msg witMid, toFun m.succ stmtIn (tr.concat msg) witMid ‚Üí
      toFun m.castSucc stmtIn tr (extractor.extractMid m stmtIn (tr.concat msg) witMid)
   
  toFun_full : ‚àÄ stmtIn tr witOut,
    [fun stmtOut => (stmtOut, witOut) ‚àà relOut
    | do (simulateQ impl (verifier.run stmtIn tr)).run' (‚Üê init)] > 0 ‚Üí
    toFun (.last n) stmtIn tr (extractor.extractOut stmtIn tr witOut)

noncomputable def toMvPolynomialAlgEquiv : P ‚âÉ‚Çê[R] MvPolynomial œÉ R where
  toFun := toMvPolynomialAlgHom
  invFun := ofMvPolynomialAlgHom
  left_inv p := by admit /- proof elided -/

Fintype.card in Mathlib.Data.Fintype.Card

PFunctor in Mathlib.Data.PFunctor.Univariate.Basic

instance : Add (Cayley T) where
  add := add

@[reducible]
def SCALAR_FIELD_CARD : Nat := 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141

def erase_odd (s : Finset ‚Ñï) : Finset ‚Ñï := s.filter Even

List.cons in Init.Prelude

noncomputable def toMLE (A : Matrix (Fin (2 ^ m)) (Fin (2 ^ n)) R) : R[X Fin n][X Fin m] :=
  MLE' (MLE' ‚àò A)

class Statement.Lens.IsSound {OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut : Type}
    (outerLangIn : Set OuterStmtIn) (outerLangOut : Set OuterStmtOut)
    (innerLangIn : Set InnerStmtIn) (innerLangOut : Set InnerStmtOut)
    (compatStmt : OuterStmtIn ‚Üí InnerStmtOut ‚Üí Prop)
    (lens : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut) where

  proj_sound : ‚àÄ outerStmtIn,
    outerStmtIn ‚àâ outerLangIn ‚Üí lens.proj outerStmtIn ‚àâ innerLangIn

  lift_sound : ‚àÄ outerStmtIn innerStmtOut,
    compatStmt outerStmtIn innerStmtOut ‚Üí
    innerStmtOut ‚àâ innerLangOut ‚Üí
    lens.lift outerStmtIn innerStmtOut ‚àâ outerLangOut

Finset.Iio in Mathlib.Order.Interval.Finset.Defs

@[reducible]
def Witness (F : Type) [NonBinaryField F] {k : ‚Ñï}
    (s : Fin (k + 1) ‚Üí ‚Ñï+) (d : ‚Ñï+) (i : Fin (k + 2)) :=
  F‚¶É< 2^((‚àë j', (s j').1) - (‚àë j' ‚àà finRangeTo i.1, (s j').1)) * d‚¶Ñ[X]

instance [O‚Çò : ‚àÄ i, OracleInterface (pSpec.Message i)] :
    ‚àÄ i, OracleInterface ((pSpec.addSalt Salt).Message i) :=
  fun i => {
    Query := (O‚Çò i).Query
    Response := (O‚Çò i).Response
    answer := fun msg => (O‚Çò i).answer (by admit /- proof elided -/
      )
  }

structure BinaryTowerResult (F : Type _) (k : ‚Ñï) where
  vec : (List.Vector F (k + 1))
  instField : (Field F)
  instFintype : Fintype F
  specialElement : F
  specialElementNeZero : NeZero specialElement
  firstElementOfVecIsSpecialElement [Inhabited F] : vec.1.headI = specialElement
  instIrreduciblePoly : (Irreducible (p := (definingPoly specialElement)))
  sumZeroIffEq : ‚àÄ (x y : F), x + y = 0 ‚Üî x = y
  fieldFintypeCard : Fintype.card F = 2^(2^k)
  traceMapEvalAtRootsIs1 : TraceMapProperty F specialElement k

CommGroup in Mathlib.Algebra.Group.Defs

instance instTestLensComplete : testLens.IsComplete
      outerRelIn_Test innerRelIn_Test outerRelOut_Test innerRelOut_Test
      (fun ‚ü®‚ü®p, q, _‚ü©, _‚ü© ‚ü®‚ü®f, _‚ü©, _‚ü© => p * q = f) where
  proj_complete := fun ‚ü®p, q, t‚ü© () hRelIn => by admit /- proof elided -/

instance {Œ± : Fin 0 ‚Üí Sort u} : Unique ((i : Fin 0) ‚Üí Œ± i) where
  uniq := fun v => by admit /- proof elided -/

Finset.Ici in Mathlib.Order.Interval.Finset.Defs

@[reducible, inline, specialize]
def UniPoly (R : Type*) := Array R

noncomputable def foldOracleReduction :
  OracleReduction []‚Çí
    (Statement F i.castSucc) (OracleStatement D x s i.castSucc) (Witness F s d i.castSucc.castSucc)
    (Statement F i.succ) (OracleStatement D x s i.succ) (Witness F s d i.succ.castSucc)
    (pSpec D x s i) where
  prover := foldProver D x s d i
  verifier := foldVerifier D x s i

LinearMap in Mathlib.Algebra.Module.LinearMap.Defs

noncomputable def finalSumcheckRbrExtractor :
  Extractor.RoundByRound []‚Çí
    (StmtIn := (Statement (L := L) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì)) √ó (‚àÄ j, OracleStatement ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë  (Fin.last ‚Ñì) j))
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì))
    (WitOut := Unit)
    (pSpec := pSpecFinalSumcheckStep (L := L))
    (WitMid := FinalSumcheckWit (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì)) where
  eqIn := rfl
  extractMid := fun m ‚ü®stmtMid, oStmtMid‚ü© trSucc witMidSucc => by admit /- proof elided -/
    | none => 
      exact dummyLastWitness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
    | some tpoly =>
      
      exact {
        t := tpoly,
        H := projectToMidSumcheckPoly (L := L) (‚Ñì := ‚Ñì) (t := tpoly)
          (m := BBF_SumcheckMultiplierParam.multpoly stmtMid.ctx)
          (i := Fin.last ‚Ñì) (challenges := stmtMid.challenges),
        f := getMidCodewords ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) tpoly stmtMid.challenges
      }
  extractOut := fun ‚ü®stmtIn, oStmtIn‚ü© tr witOut => ()

Lean.mkRawNatLit in Lean.Expr

def shift_left (s : Finset ‚Ñï) : Finset ‚Ñï :=
  s.filterMap
    (fun n => match n with
      | 0 => .none
      | n + 1 => .some n
      )
    (by admit /- proof elided -/
    )

instance : ‚àÄ i, NeZero (toOutCodewordsCount ‚Ñì œë i) :=

noncomputable def intermediateEvaluationPoly (i : Fin (‚Ñì + 1))
    (coeffs : Fin (2 ^ (‚Ñì - i)) ‚Üí L) : L[X] :=
  ‚àë (‚ü®j, hj‚ü©: Fin (2^(‚Ñì-i))), C (coeffs ‚ü®j, by admit /- proof elided -/
  ‚ü©) *
    (intermediateNovelBasisX ùîΩq Œ≤ h_‚Ñì_add_R_rate i ‚ü®j, by admit /- proof elided -/
    ‚ü©)

instance inhabited [Inhabited R] : Inhabited (MlPoly R n) :=

def foldStepRelOut (i : Fin ‚Ñì) :
    Set ((Statement (L := L) Context i.succ √ó
      (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j)) √ó
      Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ) :=
  { input | foldStepRelOutProp (mp := mp) (ùìë := ùìë) ùîΩq Œ≤ i input}

instance : Fact (Nat.Prime scalarFieldSize) := ‚ü®ScalarField_is_prime‚ü©

def finalSumcheckKStateProp {m : Fin (1 + 1)} (tr : Transcript m (pSpecFinalSumcheckStep (L := L)))
    (stmt : Statement (L := L) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì))
    (witMid : FinalSumcheckWit (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) m)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì) j) : Prop :=
  match m with
  | ‚ü®0, _‚ü© => 
    masterKStateProp ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (mp := BBF_SumcheckMultiplierParam)
      (stmtIdx := Fin.last ‚Ñì) (oracleIdx := Fin.last ‚Ñì) (h_le := le_refl _)
      (stmt := stmt) (wit := witMid) (oStmt := oStmt) (localChecks := True)
  | ‚ü®1, _‚ü© => 
    let tr_so_far := (pSpecFinalSumcheckStep (L := L)).take 1 (by admit /- proof elided -/
    )
    let i_msg0 : tr_so_far.MessageIdx := ‚ü®‚ü®0, by admit /- proof elided -/
    ‚ü©, rfl‚ü©
    let c : L := (ProtocolSpec.Transcript.equivMessagesChallenges (k := 1)
      (pSpec := pSpecFinalSumcheckStep (L := L)) tr).1 i_msg0

    let stmtOut : FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì) := {
      ctx := stmt.ctx,
      sumcheck_target := stmt.sumcheck_target,
      challenges := stmt.challenges,
      final_constant := c
    }

    let sumcheckFinalCheck : Prop := stmt.sumcheck_target = eqTilde r stmt.challenges * c
    let finalFoldingProp := finalNonDoomedFoldingProp ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (h_le := by admit /- proof elided -/
        ) (input := ‚ü®stmtOut, oStmt‚ü©)

    sumcheckFinalCheck ‚àß finalFoldingProp 

structure WireIndices (numWires : ‚Ñï) where
   
  a : Fin numWires
   
  b : Fin numWires
   
  c : Fin numWires
deriving DecidableEq

def degree (P : Params Œπ F) : Fin (M + 1) ‚Üí ‚Ñï :=
  fun i => P.deg / ‚àè j < i, (P.foldingParam j)

@[reducible, inline]
instance instMvPolynomial : OracleInterface (R[X œÉ]) where
  Query := œÉ ‚Üí R
  Response := R
  answer := fun poly point => eval point poly

Array.rightpad in Init.Data.Array.Basic

def InternalData.leftSubtree {Œ± : Type} {s_left s_right : Skeleton}
    (tree : InternalData Œ± (Skeleton.internal s_left s_right)) :
    InternalData Œ± s_left :=
  match tree with
  | InternalData.internal _ left _right =>
    left

instance : ‚àÄ j, OracleInterface ((fullPSpec ùîΩq Œ≤ Œ≥_repetitions (œë:=œë)
  (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).Message j) := instOracleInterfaceMessageAppend

instance : ‚àÄ j, OracleInterface ((pSpecRelay).Message j)
  | ‚ü®x, h‚ü© => by admit /- proof elided -/

def LeafData.get {s} {Œ± : Type}
    (tree : LeafData Œ± s) (idx : SkeletonLeafIndex s) : Œ± :=
  match tree, idx with
  | LeafData.leaf value, SkeletonLeafIndex.ofLeaf => value
  | LeafData.internal left _, SkeletonLeafIndex.ofLeft idxLeft =>
    LeafData.get left idxLeft
  | LeafData.internal _ right, SkeletonLeafIndex.ofRight idxRight =>
    LeafData.get right idxRight

CommRing.toRing in Mathlib.Algebra.Ring.Defs

instance instPow {n : ‚Ñï} : Pow (CNat n) Nat := match n with
  | 0 => by admit /- proof elided -/
  | .succ n => by admit /- proof elided -/

Mathlib.Linter.TextBased.ErrorFormat.github in Mathlib.Tactic.Linter.TextBased

Algebra.algebraMap in Mathlib.Algebra.Algebra.Defs

def projection (S : Finset n) (w : n ‚Üí R) : S ‚Üí R :=
  fun i => w i.val

def sumPartial (m : ‚Ñï) (n : ‚Ñï) (D : Fin n ‚Üí Finset R) :
    MvPolynomial (Fin (m + n)) R ‚Üí‚Çó[R] MvPolynomial (Fin m) R where
  toFun := fun p => ‚àë x ‚àà Fintype.piFinset D, peval (Fin.sumCommEquiv m n) x p
  map_add' := fun p q => by admit /- proof elided -/

LinearOrder in Mathlib.Order.Defs.LinearOrder

def removeNth (p : Fin (n + 1)) (s : Fin (n + 1) ‚Üí‚ÇÄ M) : Fin n ‚Üí‚ÇÄ M :=
  Finsupp.equivFunOnFinite.symm (Fin.removeNth p s : Fin n ‚Üí M)

ToString in Init.Data.ToString.Basic

def Oracle.containsCache {Œπ : Type} {spec : OracleSpec Œπ}
    (f : spec.FunctionType) (cache : spec.QueryCache) :
    Prop :=
  ‚àÄ i q r, cache i q = some r ‚Üí f i q = r

def equivMonomialLagrangeRepr : MlPoly R n ‚âÉ MlPolyEval R n where
  toFun := monoToLagrange n
  invFun := lagrangeToMono n
  left_inv v := by admit /- proof elided -/

inductive Data (Œ± : Type) :
    {n : ‚Ñï} ‚Üí {ar : Fin n ‚Üí ‚Ñï} ‚Üí Skeleton n ar ‚Üí Type where
  | leaf {ar0 : Fin 0 ‚Üí ‚Ñï} (value : Œ±) :
      Data Œ± (Skeleton.leaf (ar0 := ar0))
  | node {n : ‚Ñï} {ar : Fin (n+1) ‚Üí ‚Ñï}
      {children : Fin (ar 0) ‚Üí
        Skeleton n (fun i => ar i.succ)}
      (value : Œ±)
      (childrenData : (i : Fin (ar 0)) ‚Üí
        Data Œ± (children i)) :
      Data Œ± (Skeleton.node children)

protected def OracleVerifier.id :
    OracleVerifier oSpec Statement OStatement Statement OStatement !p[] where
  verify := fun stmt _ => pure stmt
  embed := Function.Embedding.inl
  hEq := fun _ => rfl

AddHom in Mathlib.Algebra.Group.Hom.Defs

def weight_Œõ (f H : F[X][Y]) (D : ‚Ñï) : WithBot ‚Ñï :=
  Finset.sup
    f.support
    (fun deg =>
      WithBot.some <| deg * (D + 1 - Bivariate.natDegreeY H) + (f.coeff deg).natDegree
    )

Nat.reduceAdd in Lean.Meta.Tactic.Simp.BuiltinSimprocs.Nat

@[inline, reducible]
def lift : OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i) ‚Üí InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i) ‚Üí
    OuterStmtOut √ó (‚àÄ i, OuterOStmtOut i) :=
  lens.toFunB

def binary_tower_inductive_step
  (k : Nat)
  (prevBTField : Type _) [Field prevBTField]
  (prevBTResult : BinaryTowerResult prevBTField k)
: Œ£' (F : Type _), BinaryTowerInductiveStepResult (k:=k) (prevBTField:=prevBTField)
  (prevBTResult:=prevBTResult) (prevPoly:=definingPoly (F:=prevBTField)
    (instField:=prevBTResult.instField) (s:=prevBTResult.specialElement)) (F:=F)
  (instPrevBTFieldIsField:=prevBTResult.instField) :=

def toEvalsZeroOne (p : MvPolynomial œÉ R) : (œÉ ‚Üí Fin 2) ‚Üí R :=
  fun x => eval (x : œÉ ‚Üí R) p

HAdd in Init.Prelude

abbrev sqrtRate [Fintype Œπ] (deg : ‚Ñï) (domain : Œπ ‚Ü™ F) : ‚Ñù‚â•0 :=
  (LinearCode.rate (ReedSolomon.code domain deg) : ‚Ñù‚â•0).sqrt

Equiv.sumComm in Mathlib.Logic.Equiv.Sum

List.Vector.nil in Mathlib.Data.Vector.Defs

IsField in Mathlib.Algebra.Field.IsField

def twoLevelData {Œ±} (k0 k1 : ‚Ñï)
    (root : Œ±)
    (lvl1 : Fin k0 ‚Üí Œ±)
    (lvl2 : (i : Fin k0) ‚Üí Fin k1 ‚Üí Œ±) :
    ArityTree.Data Œ± (twoLevelSkel k0 k1) :=

Ideal.Quotient.mk in Mathlib.RingTheory.Ideal.Quotient.Defs

local instance : Fintype F := Fintype.ofFinite F

Nat.max in Init.Data.Nat.Basic

def dfoldlM' (n : ‚Ñï) (Œ± : Fin (n + 1) ‚Üí Type u)
    (f : (i : Fin n) ‚Üí Œ± i.castSucc ‚Üí m (Œ± i.succ)) (init : Œ± 0) : m (Œ± (last n)) :=
  match n with
  | 0 => pure init
  | n + 1 => do
    let x ‚Üê dfoldlM' n (Œ± ‚àò castSucc) (fun i => f i.castSucc) init
    f (last n) x

@[reducible]
def reduction : Reduction oSpec StmtIn WitIn StmtOut WitOut !p[] where
  prover := prover mapStmt mapWit
  verifier := verifier mapStmt

def Adversary (Œπ : Type) (G : Type) (p : ‚Ñï) (bitLength : ‚Ñï) (Œ± : Type) : Type _ :=
  ReaderT (GroupValTable Œπ G)
    (OracleComp (GroupOpOracle Œπ ++‚Çí GroupExpOracle Œπ p ++‚Çí
      GroupEqOracle Œπ ++‚Çí GroupEncodeOracle Œπ bitLength))
    (List Œπ √ó Œ±)

@[reducible]
def MlPoly (R : Type*) (n : ‚Ñï) := Vector R (2 ^ n) 

def findSumIdx' (l : List ‚Ñï) (j : Fin l.sum) : Fin l.length := ‚ü®findSumIdx l j, sorry‚ü©

def getHighBits_no_shl (numLowBits : ‚Ñï) (n : ‚Ñï) : ‚Ñï := n >>> numLowBits

def g (n : ‚Ñï) (c : ‚Ñï) (x : ‚Ñï) := (x * x + c) % n

List.ofFn in Init.Data.List.OfFn

CanLift in Mathlib.Tactic.Lift

noncomputable def generateOpening [Fact (Nat.Prime p)] (srs : Vector G‚ÇÅ (n + 1))
    (coeffs : Fin (n + 1) ‚Üí ZMod p) (z : ZMod p) : G‚ÇÅ :=
  letI poly : degreeLT (ZMod p) (n + 1) := (degreeLTEquiv (ZMod p) (n + 1)).invFun coeffs
  letI q : degreeLT (ZMod p) (n + 1) :=
    ‚ü®Polynomial.div (poly.val - C (poly.val.eval z)) (X - C z), by admit /- proof elided -/
      ‚ü©
  commit srs (degreeLTEquiv (ZMod p) (n + 1) q)

noncomputable def fieldToùïÉ {H : F[X][Y]} : F ‚Üí+* ùïÉ H :=
  RingHom.comp liftToFunctionField Polynomial.C

def SkeletonNodeIndex.rightChild {s : Skeleton} (idx : SkeletonNodeIndex s) :
    Option (SkeletonNodeIndex s) :=
  match idx with
  | SkeletonNodeIndex.ofLeaf => none
  | @SkeletonNodeIndex.ofInternal left right =>
    some (SkeletonNodeIndex.ofRight (getRootIndex right))
  | SkeletonNodeIndex.ofLeft idxLeft =>
    idxLeft.rightChild.map (SkeletonNodeIndex.ofLeft)
  | SkeletonNodeIndex.ofRight idxRight =>
    idxRight.rightChild.map (SkeletonNodeIndex.ofRight)

@[inline] def zero : AssocNat :=
  ‚ü®id, by admit /- proof elided -/
  ‚ü©

instance {k : Fin (n + 1)} : Fintype (pSpec.ChallengeIdxUpTo k) :=
  inferInstanceAs (Fintype <| ChallengeIdx (pSpec.take k k.is_le))

@[reducible, simp]
def MessageIdxUpTo (k : Fin (n + 1)) (pSpec : ProtocolSpec n) : Type :=
  (pSpec‚ü¶:k.val‚üß).MessageIdx

Quotient.lift in Init.Core

noncomputable def matching_set
  (œâs : Fin n ‚Ü™ F)
  (Œ¥ : ‚Ñö)
  (u‚ÇÄ u‚ÇÅ : Fin n ‚Üí F)
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  : Finset F := (exists_a_set_and_a_matching_polynomial k h_gs (Œ¥ := Œ¥)).choose

def FullData.Equiv {Œ±} (s : Skeleton) :
    FullData Œ± s ‚âÉ InternalData Œ± s √ó LeafData Œ± s :=

def natCast {k : ‚Ñï} (n : ‚Ñï) : ConcreteBTField k := if n % 2 = 0 then zero else one

def CEmbedding : R ‚Ü™ MvPolynomial œÉ R := ‚ü®C, C_injective œÉ R‚ü©

def verifier (i : Fin n) : Verifier oSpec
    (StatementRound R n i.castSucc √ó (‚àÄ i, OracleStatement R n deg i))
    (StatementRound R n i.succ √ó (‚àÄ i, OracleStatement R n deg i)) (pSpec R deg) :=
  (Simple.verifier R deg D oSpec).liftContext (oStmtLens R n deg D i)

def divByMonic [Field R] (p : UniPoly R) (q : UniPoly R) :
    UniPoly R :=
  (divModByMonicAux p q).1

def domain (n : ‚Ñï) (i : ‚Ñï) : Fin (2 ^ (n - i)) ‚Üí evalDomain D i :=
  fun j => ‚ü®(DIsCyclicC.gen ^ (2 ^ i)) ^ j.1, by admit /- proof elided -/
  ‚ü©

instance instVector : OracleInterface (Vector Œ± n) where
  Query := Fin n
  Response := Œ±
  answer := fun vec i => vec[i]

instance [LawfulBEq R] : AddCommGroup (UniPolyC R) where
  add_assoc := add_assoc
  zero_add := zero_add
  add_zero := add_zero
  add_comm := add_comm
  neg_add_cancel := neg_add_cancel
  nsmul := nsmul 
  nsmul_zero := nsmul_zero
  nsmul_succ := nsmul_succ
  zsmul := zsmulRec 

instance : SpongeUnit UInt8 where

Polynomial.modByMonic in Mathlib.Algebra.Polynomial.Div

def accepts (x : Fin numWires ‚Üí ùì°) (g : Gate ùì° numWires) : Prop :=
  g.eval x = 0

structure Context.Lens (OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                          OuterWitIn OuterWitOut InnerWitIn InnerWitOut : Type) where
  stmt : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
  wit : Witness.Lens OuterStmtIn InnerStmtOut OuterWitIn OuterWitOut InnerWitIn InnerWitOut

@[reducible]
def OracleStatement (œë : ‚Ñï) [NeZero œë] (i : Fin (‚Ñì + 1)) :
    Fin (toOutCodewordsCount ‚Ñì œë (i:=i)) ‚Üí Type := fun j =>
  by admit /- proof elided -/

instance : ‚àÄ i, OracleInterface (OracleStatement R pp i) :=
  fun i => {
    Query := (Fin pp.‚Ñì_m ‚Üí R) √ó (Fin pp.‚Ñì_n ‚Üí R)
    Response := R
    answer := fun matrix ‚ü®x, y‚ü© => matrix.toMLE ‚∏®C ‚àò x‚∏© ‚∏®y‚∏©
  }

def lintStyleCli (args : Cli.Parsed) : IO UInt32 := do
  let style : ErrorFormat := match args.hasFlag "github" with
    | true => ErrorFormat.github
    | false => ErrorFormat.humanReadable
  let fix := args.hasFlag "fix"
  
  let mut allModuleNames := #[]
  for s in ["ArkLib.lean"] do
    allModuleNames := allModuleNames.append (‚Üê findImports s)
  
  allModuleNames := allModuleNames.erase `Batteries
  let mut numberErrors ‚Üê lintModules allModuleNames style fix
  if ‚Üê checkInitImports then numberErrors := numberErrors + 1
  
  
  
  
  if args.hasFlag "fix" then
    return 0
  else return min numberErrors 125

def outputRelation (cond : ‚àë i, (s i).1 ‚â§ n) [DecidableEq F] (Œ¥ : ‚Ñù‚â•0) :
    Set
      (
        (FinalStatement F k √ó ‚àÄ j, FinalOracleStatement D x s j) √ó
        Witness F s d (Fin.last (k + 1))
      )
  := FinalFoldPhase.outputRelation D x s d cond Œ¥

def MLEEquivFin {n : ‚Ñï} : R‚¶É‚â§ 1‚¶Ñ[X (Fin n)] ‚âÉ (Fin (2 ^ n) ‚Üí R) :=
  Equiv.trans MLEEquiv (Equiv.piCongr finFunctionFinEquiv (fun _ => Equiv.refl _))

@[reducible] def NonInteractiveVerifier (Message : Type) {Œπ : Type} (oSpec : OracleSpec Œπ)
    (StmtIn StmtOut : Type) :=
  Verifier oSpec StmtIn StmtOut ‚ü®!v[.P_to_V], !v[Message]‚ü©

noncomputable def D_X (rho : ‚Ñö) (n m : ‚Ñï) : ‚Ñù := (m + 1/2) * (Real.sqrt rho) * n

def mul (m n : ChurchNat Œ±) : ChurchNat Œ± := fun f => n (m f)

def soundness
    (langIn : Set (StmtIn √ó ‚àÄ i, OStmtIn i))
    (langOut : Set (StmtOut √ó ‚àÄ i, OStmtOut i))
    (verifier : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec)
    (soundnessError : ‚Ñù‚â•0) : Prop :=
  verifier.toVerifier.soundness init impl langIn langOut soundnessError

Field in Mathlib.Algebra.Field.Defs

@[inline, specialize]
def processRound (j : Fin n)
    (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec)
    (currentResult : OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí)
      (pSpec.Transcript j.castSucc √ó prover.PrvState j.castSucc)) :
      OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí)
        (pSpec.Transcript j.succ √ó prover.PrvState j.succ) := do
  let ‚ü®transcript, state‚ü© ‚Üê currentResult
  match hDir : pSpec.dir j with
  | .V_to_P => do
    let challenge ‚Üê pSpec.getChallenge ‚ü®j, hDir‚ü©
    letI newState := (‚Üê prover.receiveChallenge ‚ü®j, hDir‚ü© state) challenge
    return ‚ü®transcript.concat challenge, newState‚ü©
  | .P_to_V => do
    let ‚ü®msg, newState‚ü© ‚Üê prover.sendMessage ‚ü®j, hDir‚ü© state
    return ‚ü®transcript.concat msg, newState‚ü©

def insertNth (p : Fin (n + 1)) (y : M) (s : Fin n ‚Üí‚ÇÄ M) : Fin (n + 1) ‚Üí‚ÇÄ M :=
  Finsupp.equivFunOnFinite.symm (Fin.insertNth p y s : Fin (n + 1) ‚Üí M)

Nat.decEq in Init.Prelude

List.rightpad in Init.Data.List.Basic

instance instDCast‚ÇÇ : DCast‚ÇÇ Nat ProtocolSpec (fun _ pSpec => FullTranscript pSpec) where
  dcast‚ÇÇ h h' T := FullTranscript.cast h h' T
  dcast‚ÇÇ_id := cast_id

def seqComposeChallengeEquiv {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (pSpec : ‚àÄ i, ProtocolSpec (n i)) :
    (i : Fin m) √ó (pSpec i).ChallengeIdx ‚âÉ (seqCompose pSpec).ChallengeIdx where
  
  toFun := fun ‚ü®i, j‚ü© => sigmaChallengeIdxToSeqCompose i j
  invFun := seqComposeChallengeIdxToSigma
  left_inv := by admit /- proof elided -/

Int in Init.Data.Int.Basic

def sub (m n : ChurchNat Œ±) : ChurchNat Œ± := sorry 

instance ConcreteBTField.instDCast_local : DCast ‚Ñï ConcreteBTField where
  dcast h_k_eq term_k1 := BitVec.cast (congrArg (fun n => 2 ^ n) h_k_eq) term_k1
  dcast_id := by admit /- proof elided -/

def eval‚ÇÇ (p : MlPoly R n) (f : R ‚Üí+* S) (x : Vector S n) : S := eval (map f p) x

def verifier : Verifier oSpec (StmtIn R √ó (‚àÄ i, OStmtIn R deg i))
                              (StmtOut R √ó (‚àÄ i, OStmtOut R deg i)) (pSpec R deg) where
  verify := fun ‚ü®target, oStmt‚ü© transcript => do
    letI polyLE := transcript 0
    guard (‚àë x ‚àà (univ.map D), polyLE.val.eval x = target)
    letI chal := transcript 1
    pure ‚ü®‚ü®(oStmt ()).val.eval chal, chal‚ü©, fun _ => oStmt ()‚ü©

@[reducible, inline, specialize]
def Challenges' (pSpec : ProtocolSpec n) : Type :=
  ‚àÄ i, (hi : pSpec.dir i = .V_to_P) ‚Üí pSpec.¬´Type¬ª i

Invertible in Mathlib.Algebra.Group.Invertible.Defs

def InnerStmtOut_Test := ‚Ñ§[X] √ó ‚Ñ§ √ó ‚Ñ§

MvPolynomial.coeff in Mathlib.Algebra.MvPolynomial.Basic

def leadingCoeff (p : UniPoly R) : R := p.trim.getLastD 0

@[inline, specialize]
def eval (x : R) (p : UniPoly R) : R :=
  p.eval‚ÇÇ (RingHom.id R) x

@[inline, reducible]
def Witness.Lens (OuterStmtIn InnerStmtOut OuterWitIn OuterWitOut InnerWitIn InnerWitOut : Type)
    := PFunctor.Lens ((OuterStmtIn √ó OuterWitIn) X^ OuterWitOut)
                     (InnerWitIn X^ (InnerStmtOut √ó InnerWitOut))

right_inv in ToMathlib.Control.Monad.Equiv

@[inline]
def add [Add R] (p q : MlPoly R n) : MlPoly R n := Vector.zipWith (¬∑ + ¬∑) p q

List.idxOf in Init.Data.List.Basic

def hammingBall (C : Code Œπ F) (y : Œπ ‚Üí F) (r : ‚Ñï) : Set (Œπ ‚Üí F) :=
  { c | c ‚àà C ‚àß hammingDist y c ‚â§ r }

class SliceLT (coll : Type u) (stop : Type v) (valid : outParam (coll ‚Üí stop ‚Üí Prop))
    (subcoll : outParam ((xs : coll) ‚Üí (stop : stop) ‚Üí (h : valid xs stop) ‚Üí Type w)) where
  sliceLT : (xs : coll) ‚Üí (stop : stop) ‚Üí (h : valid xs stop) ‚Üí subcoll xs stop h

@[reducible]
def value (op : MemoryWrite Œπ Œ±) := op.2

noncomputable instance : DecidableEq (GF(2)) :=
  fun x y =>
    
    let œÜ : GF(2) ‚âÉ‚Çê[ZMod 2] ZMod 2 := GaloisField.equivZmodP 2
    
    if h : œÜ x = œÜ y then
      isTrue (by admit /- proof elided -/
        )
    else
      isFalse (by admit /- proof elided -/
        )

@[inline, specialize, simp]
def verifier : Verifier oSpec Statement Statement !p[] := Verifier.id

@[inline] def ge [Zero T] [ToNat T] (a b : Cayley T) : Prop :=
  (a : Nat) ‚â• (b : Nat)

@[reducible, simp] def StmtAfterRandomQuery : Type := R

structure DuplexSponge (U : Type) [SpongeUnit U] [SpongeSize] (C : Type*)
    [SpongeState U C] where
   
  state : C
   
  absorbPos : Fin (SpongeSize.R + 1)
   
  squeezePos : Fin (SpongeSize.R + 1)
deriving Inhabited

def lastBlockOracleReduction :=
  let bIdx := ‚Ñì / œë - 1
  let stmt : Fin (œë + 1) ‚Üí Type := fun i => Statement (L := L) (‚Ñì := ‚Ñì) Context
    ‚ü®bIdx * œë + i, by admit /- proof elided -/
    ‚ü©
  let oStmt := fun i: Fin (œë + 1) => OracleStatement ùîΩq Œ≤ œë
    ‚ü®bIdx * œë + i, by admit /- proof elided -/
    ‚ü©
  let wit := fun i: Fin (œë + 1) => Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì)
    ‚ü®bIdx * œë + i, by admit /- proof elided -/
    ‚ü©
  let V:  OracleReduction []‚Çí (StmtIn := Statement (L := L) (‚Ñì := ‚Ñì) Context
    ‚ü®bIdx * œë, by admit /- proof elided -/
    ‚ü©)
    (OStmtIn := OracleStatement ùîΩq Œ≤ œë
      ‚ü®bIdx * œë, by admit /- proof elided -/
      ‚ü©)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì)
      ‚ü®bIdx * œë, by admit /- proof elided -/
      ‚ü©)
    (StmtOut := Statement (L := L) (‚Ñì := ‚Ñì) Context (Fin.last ‚Ñì))
    (OStmtOut := OracleStatement ùîΩq Œ≤ œë (Fin.last ‚Ñì))
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) (Fin.last ‚Ñì))
    (pSpec := pSpecLastBlock (L:=L) (œë:=œë)) := by admit /- proof elided -/

PowerSeries.mk in Mathlib.RingTheory.PowerSeries.Basic

AddSubmonoidClass in Mathlib.Algebra.Group.Submonoid.Defs

instance {i : Fin k} : ‚àÄ j, OracleInterface ((pSpec D x s i).Message j)
  | ‚ü®0, h‚ü© => nomatch h
  | ‚ü®1, _‚ü© => by admit /- proof elided -/

head in ToMathlib.Control.Comonad.Instances

Fin.elim0 in Init.Data.Fin.Basic

Subgroup.zpowers in Mathlib.Algebra.Group.Subgroup.ZPowers.Basic

Array.mk in Init.Prelude

noncomputable instance (‚Ñì : Nat) : AddCommGroup (CoeffVecSpace L ‚Ñì) :=

Submodule in Mathlib.Algebra.Module.Submodule.Defs

def Array.toFinVec {Œ± : Type _} (n : ‚Ñï) (arr : Array Œ±) (h : arr.size = n) : Fin n ‚Üí Œ± :=
  fun i => arr[i]

noncomputable def relayOracleProver (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
  OracleProver (oSpec := []‚Çí)
    
    (StmtIn := Statement (L := L) Context i.succ)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) i.succ)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) i.succ)
    (pSpec := pSpecRelay) where
  PrvState := relayPrvState ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i
  input := fun ‚ü®‚ü®stmtIn, oStmtIn‚ü©, witIn‚ü© => (stmtIn, oStmtIn, witIn)
  sendMessage | ‚ü®x, h‚ü© => by admit /- proof elided -/
| ‚ü®x, h‚ü© => by admit /- proof elided -/

abbrev eqPolynomial (r : œÉ ‚Üí R) : R[X œÉ] :=
  ‚àè i : œÉ, singleEqPolynomial (r i) (X i)

instance : Fintype BTF‚ÇÉ := (inferInstance : Fintype (ConcreteBTField 3))

def splitSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (k : Fin (vsum n)) : (i : Fin m) √ó Fin (n i) := match m with
  | 0 => Fin.elim0 k
  | _ + 1 => Fin.dappend
    (fun k => ‚ü®0, k‚ü©)
    (fun k => ‚ü®(splitSum k).1.succ, (splitSum k).2‚ü©)
    k

def X : UniPoly R := #[0, 1]

def Prover.liftContext
    (lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut)
    (P : Prover oSpec InnerStmtIn InnerWitIn InnerStmtOut InnerWitOut pSpec) :
      Prover oSpec OuterStmtIn OuterWitIn OuterStmtOut OuterWitOut pSpec where
  PrvState := fun i => P.PrvState i √ó OuterStmtIn √ó OuterWitIn
  input := fun ctxIn => ‚ü®P.input <| lens.proj ctxIn, ctxIn‚ü©
  sendMessage := fun i ‚ü®prvState, stmtIn, witIn‚ü© => do
    let ‚ü®msg, prvState'‚ü© ‚Üê P.sendMessage i prvState
    return ‚ü®msg, ‚ü®prvState', stmtIn, witIn‚ü©‚ü©
  receiveChallenge := fun i ‚ü®prvState, stmtIn, witIn‚ü© => do
    let f ‚Üê P.receiveChallenge i prvState
    return fun chal => ‚ü®f chal, stmtIn, witIn‚ü©
  output := fun ‚ü®prvState, stmtIn, witIn‚ü© => do
    let ‚ü®innerStmtOut, innerWitOut‚ü© ‚Üê P.output prvState
    return lens.lift (stmtIn, witIn) (innerStmtOut, innerWitOut)

def AlgebraTowerEquiv.toAlgEquivOverLeft (e : AlgebraTowerEquiv A B) (i j : Œπ) (h : i ‚â§ j) :
  letI : Algebra (A i) (A j) :=

Rat in Init.Data.Rat.Basic

private def toWeightAssignment
  (p : MvPolynomial (Fin m) F)
  (b : Fin m ‚Üí Fin 2) : Fin (m+1) ‚Üí F :=
    let b' : Fin m ‚Üí F := fun i => ‚Üë(b i : ‚Ñï)
    Fin.cases (MvPolynomial.eval b' p)
              (fun i => ‚Üë(b i : ‚Ñï))

Fin.add in Init.Data.Fin.Basic

@[simp]
abbrev FirstSumcheckChallenge : Type := Fin pp.‚Ñì_m ‚Üí R

def implGroupExpOracle : QueryImpl (GroupExpOracle Œπ p) (StateT (GroupValTable Œπ G) Option) where
  impl | query _ ‚ü®i, a, j‚ü© => fun table =>
    match table i with
    | some g => some ((), table.update j (some (g ^ a.val)))
    | none => none

@[reducible, inline, specialize]
def MessagesUpTo (k : Fin (n + 1)) (pSpec : ProtocolSpec n) : Type :=
  ‚àÄ i, pSpec.MessageUpTo k i

instance polyIrreducibleFact (n : ‚Ñï) : Fact (Irreducible (poly n)) := ‚ü®polyIrreducible n‚ü©

@[reducible, inline, specialize]
def MessageUpTo (k : Fin (n + 1)) (pSpec : ProtocolSpec n) (i : pSpec.MessageIdxUpTo k) :=
  (pSpec‚ü¶:k.val‚üß).Message i

def deriveTranscriptDSFSAux {Œπ : Type} {oSpec : OracleSpec Œπ} {StmtIn : Type}
    (sponge : CanonicalDuplexSponge U)
    (messages : pSpec.Messages) (i : Fin (n + 1)) :
      OracleComp (oSpec ++‚Çí duplexSpongeChallengeOracle StmtIn U)
        (CanonicalDuplexSponge U √ó pSpec.Transcript i) :=
  Fin.induction
    (pure (sponge, fun i => i.elim0))
    (fun i ih => do
      let ‚ü®curSponge, prevTranscript‚ü© ‚Üê ih
      match hDir : pSpec.dir i with
      | .V_to_P =>
        let ‚ü®challenge, newSponge‚ü© ‚Üê liftM (curSponge.squeeze (challengeSize ‚ü®i, hDir‚ü©))
        let deserializedChallenge : pSpec.Challenge ‚ü®i, hDir‚ü© :=
          Deserialize.deserialize challenge
        return (newSponge, prevTranscript.concat deserializedChallenge)
      | .P_to_V =>
        let serializedMessage : Vector U (messageSize ‚ü®i, hDir‚ü©) :=
          Serialize.serialize (messages ‚ü®i, hDir‚ü©)
        let newSponge ‚Üê liftM (DuplexSponge.absorb curSponge serializedMessage.toList)
        return (newSponge, prevTranscript.concat (messages ‚ü®i, hDir‚ü©)))
    i

MvPolynomial.renameEquiv in Mathlib.Algebra.MvPolynomial.Rename

def proverRound (i : Fin n) : ProverRound oSpec (pSpec R deg) where
  PrvState := (proverState R n deg i).PrvState

  sendMessage
  | ‚ü®0, _‚ü© => fun state =>
    match n with
    | 0 => sorry
    | n + 1 =>
      let ‚ü®‚ü®_, challenges‚ü©, oStmt‚ü© := state
      let ‚ü®poly, hp‚ü© := oStmt 0
      pure ‚ü® ‚ü®‚àë x ‚àà (univ.map D) ^·∂† (n - i), poly ‚∏®X ‚¶Éi‚¶Ñ, challenges, x‚∏©'(by admit /- proof elided -/
      ),
        sumcheck_roundPoly_degreeLE R n deg D i hp‚ü©,
          state‚ü©
  | ‚ü®1, h‚ü© => nomatch h

  receiveChallenge
  | ‚ü®0, h‚ü© => nomatch h
  | ‚ü®1, _‚ü© => fun ‚ü®‚ü®target, challenges‚ü©, oStmt‚ü© => pure fun chal =>
    let ‚ü®poly, hp‚ü© := oStmt 0
    letI newChallenges : Fin i.succ ‚Üí R := Fin.snoc challenges chal
    letI newTarget := ‚àë x ‚àà (univ.map D) ^·∂† (n - i - 1), poly ‚∏®newChallenges, x‚∏©'(by admit /- proof elided -/
    )
    ‚ü®‚ü®newTarget, newChallenges‚ü©, fun _ => ‚ü®poly, hp‚ü©‚ü©

structure PowTwoRepr where
  two_exp : ‚Ñï
  odd_part : ‚Ñï

Inv in Init.Prelude

def Extractor.Straightline.compatWit
    (lens : Extractor.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut)
    (E : Extractor.Straightline oSpec InnerStmtIn InnerWitIn InnerWitOut pSpec) :
      OuterStmtIn √ó OuterWitOut ‚Üí InnerWitIn ‚Üí Prop :=
  fun ‚ü®outerStmtIn, outerWitOut‚ü© innerWitIn =>
    ‚àÉ stmt tr logP logV, innerWitIn ‚àà
      (E stmt (lens.wit.proj (outerStmtIn, outerWitOut)) tr logP logV).support

noncomputable def Basis.baseChangeRight (b : Basis Œπ K Left) : Basis Œπ Right (Left ‚äó[K] Right) :=

def two : ChurchNat Œ± := succ one

@[reducible]
def pSpec : ProtocolSpec 1 :=
  ‚ü®!v[.V_to_P], !v[Fin l ‚Üí evalDomain D x 0]‚ü©

partial def factor (n : ‚Ñï) : Option (List ‚Ñï) :=
  if deterministicMillerRabin n then
    [n]
  else do
    let f ‚Üê rho n
    let lhs ‚Üê factor f
    let rhs ‚Üê factor (n / f)
    return (lhs ++ rhs)

noncomputable def commitOracleProver (i : Fin ‚Ñì) :
  OracleProver (oSpec := []‚Çí)
    
    (StmtIn := Statement (L := L) Context i.succ)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) i.succ)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) i.succ)
    (pSpec := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) where

  PrvState := commitPrvState ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i

  input := fun ‚ü®‚ü®stmt, oStmt‚ü©, wit‚ü© => (stmt, oStmt, wit)

  sendMessage 
  | ‚ü®0, _‚ü© => fun inputPrvState => by admit /- proof elided -/
  | ‚ü®0, h‚ü© => nomatch h 

  output := fun ‚ü®stmt, oStmt, wit‚ü© => by admit /- proof elided -/

def rightpad {m : ‚Ñï} {Œ± : Sort*} (n : ‚Ñï) (a : Œ±) (v : Fin m ‚Üí Œ±) : Fin n ‚Üí Œ± :=
  fun i => if h : i < m then v ‚ü®i, h‚ü© else a

@[app_unexpander Fin.hcons]
def hconsUnexpander : Lean.PrettyPrinter.Unexpander
  | `($_ $term !h[$term2, $terms,*]) => `(!h[$term, $term2, $terms,*])
  | `($_ $term !h[$term2]) => `(!h[$term, $term2])
  | `($_ $term !h[]) => `(!h[$term])
  | _ => throw ()

def interleaveCode [Semiring F] [DecidableEq F] (C : Submodule F (n ‚Üí F)) (Œπ : Type*)
  : Submodule F ((Œπ √ó n) ‚Üí F) :=
  Submodule.span F {v | ‚àÄ i, ‚àÉ c ‚àà C, c = fun j => v (i, j)}

def Option.doubleBind {Œ± Œ≤ Œ≥ : Type} (f : Œ± ‚Üí Œ≤ ‚Üí Option Œ≥)
    (x : Option Œ±) (y : Option Œ≤) : Option Œ≥ :=
  match x, y with
  | none, _ => none
  | _, none => none
  | some a, some b => f a b

List.Vector.get in Mathlib.Data.Vector.Defs

noncomputable def fold_k_core {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F} (f : (indexPowT S œÜ 0) ‚Üí F)
  [‚àÄ i : ‚Ñï, Neg (indexPowT S œÜ i)] : (i : ‚Ñï) ‚Üí (Œ±s : Fin i ‚Üí F) ‚Üí
    indexPowT S œÜ i ‚Üí F
| 0, _ => fun x‚ÇÄ => f x‚ÇÄ
| k+1, Œ±s => fun y =>
    let Œ± := Œ±s 0
    let Œ±s' : Fin k ‚Üí F := fun i => Œ±s (Fin.succ i)
    let fk := fold_k_core f k Œ±s'
    foldf S œÜ y fk Œ±

List.IsSuffix in Init.Data.List.Basic

def computableAdditiveNTT (a : Fin (2 ^ ‚Ñì) ‚Üí L) : Fin (2^(‚Ñì + R_rate)) ‚Üí L :=
  let b: Fin (2^(‚Ñì + R_rate)) ‚Üí L := tileCoeffs a 
  Fin.foldl (n:=‚Ñì) (f:= fun current_b i  =>
    computableNTTStage (ùîΩq := ùîΩq) (Œ≤ := Œ≤) (‚Ñì := ‚Ñì) (R_rate := R_rate)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := ‚ü®‚Ñì - 1 - i, by admit /- proof elided -/
      ‚ü©) (b:=current_b)
  ) (init:=b)

structure ConcreteBTFAddCommGroupProps (k : ‚Ñï) where
  add_assoc : ‚àÄ a b c : ConcreteBTField k, (a + b) + c = a + (b + c) := add_assoc
  add_comm : ‚àÄ a b : ConcreteBTField k, a + b = b + a := add_comm
  add_zero : ‚àÄ a : ConcreteBTField k, a + zero = a := add_zero
  zero_add : ‚àÄ a : ConcreteBTField k, zero + a = a := zero_add
  add_neg : ‚àÄ a : ConcreteBTField k, a + (neg a) = zero := neg_add_cancel

Finset.map in Mathlib.Data.Finset.Image

def mapOStmtOutRelayStep (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j) :
    ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.succ j := fun j => by admit /- proof elided -/

def knowledgeSoundness (relIn : Set (StmtIn √ó WitIn)) (relOut : Set (StmtOut √ó WitOut))
    (verifier : Verifier oSpec StmtIn StmtOut pSpec) (knowledgeError : ‚Ñù‚â•0) : Prop :=
  ‚àÉ extractor : Extractor.Straightline oSpec StmtIn WitIn WitOut pSpec,
  ‚àÄ stmtIn : StmtIn,
  ‚àÄ witIn : WitIn,
  ‚àÄ prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec,
    letI reduction := Reduction.mk prover verifier
    [fun ‚ü®stmtIn, witIn, stmtOut, witOut‚ü© =>
      (stmtIn, witIn) ‚àâ relIn ‚àß (stmtOut, witOut) ‚àà relOut
    | do
      let s ‚Üê init
      (simulateQ (impl ++‚Çõ‚Çí challengeQueryImpl : QueryImpl _ (StateT œÉ ProbComp))
        <| do
      let ‚ü®‚ü®‚ü®transcript, ‚ü®_, witOut‚ü©‚ü©, stmtOut‚ü©, proveQueryLog, verifyQueryLog‚ü© ‚Üê
        reduction.runWithLog stmtIn witIn
      let extractedWitIn ‚Üê
        liftComp (extractor stmtIn witOut transcript proveQueryLog.fst verifyQueryLog) _
      return (stmtIn, extractedWitIn, stmtOut, witOut)).run' s] ‚â§ knowledgeError

protected def cast (pSpec : ProtocolSpec n‚ÇÅ) : ProtocolSpec n‚ÇÇ :=
  ‚ü®pSpec.dir ‚àò (Fin.cast hn.symm), pSpec.¬´Type¬ª ‚àò (Fin.cast hn.symm)‚ü©

@[reducible, simp] def StmtIn : Type := R

MvPolynomial.degreeOf in Mathlib.Algebra.MvPolynomial.Degrees

instance {s} : Functor (fun Œ± => FullData Œ± s) where
  map f x := x.map f

instance oCtxLens_complete :
    (oCtxLens R n deg D i).toContext.IsComplete
      (relationRound R n deg D i.castSucc) (Simple.inputRelation R deg D)
      (relationRound R n deg D i.succ) (Simple.outputRelation R deg)
      ((Simple.oracleReduction R deg D oSpec).toReduction.compatContext
        (oCtxLens R n deg D i).toContext)
where
  proj_complete := by admit /- proof elided -/

Polynomial.mapRingHom in Mathlib.Algebra.Polynomial.Eval.Defs

MonoidHom in Mathlib.Algebra.Group.Hom.Defs

instance : LT AssocNat where
  lt a b := a 0 < b 0

PFunctor.Lens in ToMathlib.PFunctor.Basic

@[reducible, simp] def OStmtOut := fun _ : Fin 1 => OStatement

OracleSpec.append in VCVio.OracleComp.OracleSpec

OneHom in Mathlib.Algebra.Group.Hom.Defs

private noncomputable def oddPart' (f : Polynomial F) : Polynomial F :=
  match f with
  | ‚ü®‚ü®supp, f, pr‚ü©‚ü© => ‚ü®‚ü®
      shift_left (erase_even supp),
      fun n => if Even n then f (n + 1) else 0, by admit /- proof elided -/
      ‚ü©‚ü©

instance instDCastPSigmaPSigma :
    DCast ((a : Œ±) √ó' (b : Œ≤ a) √ó' Œ≥ a b) (fun a => Œ¥ a.1 a.2.1 a.2.2) where
  dcast hc d := dcast‚ÇÉ (by admit /- proof elided -/
  ) (by admit /- proof elided -/
  ) (by admit /- proof elided -/
  ) d
  dcast_id := by admit /- proof elided -/

inductive PrattPart : (p : ‚Ñï) ‚Üí (a : ZMod p) ‚Üí ‚Ñï ‚Üí Prop
  | prime : {p : ‚Ñï} ‚Üí {a : ZMod p} ‚Üí (n k nk : ‚Ñï) ‚Üí n.Prime ‚Üí
      a ^ ((p - 1) / n) ‚â† 1 ‚Üí n ^ k = nk ‚Üí PrattPart p a nk
  | split : {p : ‚Ñï} ‚Üí {a : ZMod p} ‚Üí {n : ‚Ñï} ‚Üí (l r : ‚Ñï) ‚Üí
      PrattPart p a l ‚Üí PrattPart p a r ‚Üí l * r = n ‚Üí PrattPart p a n

@[elab_as_elim] def Fin.succRecOnSameFinType {motive : Fin r ‚Üí Sort _}
    (zero : motive (0 : Fin r))
    (succ : ‚àÄ i : Fin r, i + 1 < r ‚Üí motive i ‚Üí motive (i + 1)) : ‚àÄ (i : Fin r), motive i
  | ‚ü®0, _‚ü© => by admit /- proof elided -/
  | ‚ü®Nat.succ i_val, h‚ü© => by admit /- proof elided -/

structure LookaheadSequenceFamily
    (trace : QueryLog (forwardPermutationOracle (CanonicalSpongeState U)))
    (state : CanonicalSpongeState U) (i : pSpec.ChallengeIdx) where
   
  seqFamily : Finset (LookaheadSequence trace state)
   
  maximality : ‚àÄ s ‚àà seqFamily, ‚àÄ s' ‚àà seqFamily,
    ¬¨ (s.inputState ‚äÜ s'.inputState) ‚à® ¬¨ (s'.outputState ‚äÜ s.outputState)
   
  length_le_challengeSize : ‚àÄ s ‚àà seqFamily, s.inputState.length ‚â§ challengeSize i

def rootsOfUnity (n s : ‚Ñï) : List (Domain.evalDomain D (n - s)) :=
  List.map
    (fun i =>
      ‚ü®
        (DIsCyclicC.gen.1 ^ (2 ^ (n - s))) ^ i,
        by admit /- proof elided -/
      ‚ü©
    )
    (List.range (2 ^ s))

noncomputable def normalizedW (i : Fin r) : L[X] :=
  C (1 / (W ùîΩq Œ≤ i).eval (Œ≤ i)) * W ùîΩq Œ≤ i

def constrainedCode
  (domain : Œπ ‚Ü™ F) [Smooth domain] (m : ‚Ñï)
  (w : MvPolynomial (Fin (m + 1)) F) (œÉ : F) : Set (Œπ ‚Üí F) :=
    { f | ‚àÉ (h : f ‚àà smoothCode domain m),
      weightConstraint (mVdecode (‚ü®f, h‚ü© : smoothCode domain m)) w œÉ }

instance instOneConcreteBTField (k : ‚Ñï) : One (ConcreteBTField k) where
  one := one

def coeffsToBitVec {n : ‚Ñï} (coeffs : List (ZMod 2)) : BitVec n :=
  let val := List.foldr (fun c acc => acc * 2 + c.val) 0 (coeffs.take n)
  BitVec.ofNat n val

Subtype in Init.Prelude

instance : IsEmpty (AssocFin AssocNat.zero) :=

instance [IsSingleRound pSpec] : Unique (pSpec.ChallengeIdx) where
  default := ‚ü®1, by admit /- proof elided -/
  ‚ü©
  uniq := fun ‚ü®i, hi‚ü© => by admit /- proof elided -/

instance : Coe (‚àÄ a : Œ±, Œ≤ a) F where
  coe := DFunEquiv.equiv.invFun

MonomialOrder.lex in Mathlib.Data.Finsupp.MonomialOrder

class LawfulHasSucc (T : Type u) [HasSucc T] [Add T] [One T] : Prop where
   
  succ'_eq_add_one : ‚àÄ x : T, succ' x = x + 1

Function.Surjective in Init.Data.Function

@[reducible, inline, specialize, simp]
def ChallengeIdx (vPSpec : VectorSpec n) := {i : Fin n // vPSpec.dir i = .V_to_P}

@[app_unexpander Fin.fcons]
def fconsUnexpander : Lean.PrettyPrinter.Unexpander
  | `($_ $a !h‚¶É$F‚¶Ñ‚ü®$Œ±‚ü©[$b, $bs,*]) => `(!h‚¶É$F‚¶Ñ‚ü®$Œ±‚ü©[$a, $b, $bs,*])
  | `($_ $a !h‚¶É$F‚¶Ñ‚ü®$Œ±‚ü©[$b]) => `(!h‚¶É$F‚¶Ñ‚ü®$Œ±‚ü©[$a, $b])
  | `($_ $a !h‚¶É$F‚¶Ñ‚ü®$Œ±‚ü©[]) => `(!h‚¶É$F‚¶Ñ‚ü®$Œ±‚ü©[$a])
  | _ => throw ()

OracleComp.liftComp in VCVio.OracleComp.Coercions.SubSpec

def rbrSoundness
    (langIn : Set (StmtIn √ó ‚àÄ i, OStmtIn i))
    (langOut : Set (StmtOut √ó ‚àÄ i, OStmtOut i))
    (verifier : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec)
    (rbrSoundnessError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) : Prop :=
  verifier.toVerifier.rbrSoundness init impl langIn langOut rbrSoundnessError

UInt8.ofFin in Init.Data.UInt.Basic

@[reducible, inline]
instance instProdForall {Œπ : Type u} (v : Œπ ‚Üí Type v) [O : ‚àÄ i, OracleInterface (v i)] :
    OracleInterface (‚àÄ i, v i) where
  Query := (i : Œπ) √ó (O i).Query
  Response := (i : Œπ) √ó (O i).Response
  answer := fun f ‚ü®i, q‚ü© => ‚ü®i, (O i).answer (f i) q‚ü©

noncomputable def decode : (ReedSolomon.code domain deg) ‚Üí‚Çó[F] F[X] :=
  domRestrict
    (interpolate (domain := domain))
    (ReedSolomon.code domain deg)

@[reducible]
def Statement := Fin sz.n_x ‚Üí R

@[inline] def min [Zero T] [ToNat T] (a b : Cayley T) : Cayley T :=
  if (a : Nat) ‚â§ (b : Nat) then a else b

DFunLike in Mathlib.Data.FunLike.Basic

private def sum_choose_K_i (B : Finset (Fin n ‚Üí F)) (i : Fin n) : ‚Ñö :=
  ‚àë (Œ± : F), choose_2 (K B i Œ±)

evalDist in VCVio.EvalDist.Basic

@[inline] def zero : Cayley T :=
  ‚ü®id, by admit /- proof elided -/
  ‚ü©

@[simp]
abbrev OracleStatement.AfterFirstChallenge : R1CS.MatrixIdx ‚äï Fin 1 ‚Üí Type :=
  OracleStatement.AfterFirstMessage R pp

@[reducible]
noncomputable def reductionFold :
  OracleReduction []‚Çí
    (Statement F (0 : Fin (k + 1))) (OracleStatement D x s (0 : Fin (k + 1)))
      (Witness F s d (0 : Fin (k + 2)))
    (FinalStatement F k) (FinalOracleStatement D x s)
      (Witness F s d (Fin.last (k + 1)))
    (pSpecFold D x k s ++‚Çö FinalFoldPhase.pSpec F)
 := OracleReduction.append
      (OracleReduction.seqCompose _ _ (fun (i : Fin (k + 1)) => Witness F s d i.castSucc)
        (FoldPhase.foldOracleReduction D x s d))
      (FinalFoldPhase.finalFoldOracleReduction D x (k := k) s d)

inductive MemoryOp (Œπ : Type u) (Œ± : Œπ ‚Üí Type v) where
  | read (op : MemoryRead Œπ Œ±)
  | write (op : MemoryWrite Œπ Œ±)

noncomputable def foldOracleProver (i : Fin ‚Ñì) :
  OracleProver (oSpec := []‚Çí)
    
    (StmtIn := Statement (L := L) Context i.castSucc)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) i.castSucc)
    
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) i.succ)
    (pSpec := pSpecFold (L := L)) where

  PrvState := foldPrvState ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i

  input := fun ‚ü®‚ü®stmt, oStmt‚ü©, wit‚ü© => (stmt, oStmt, wit)

  sendMessage 
  | ‚ü®0, _‚ü© => fun ‚ü®stmt, oStmt, wit‚ü© => do
    let curH : ‚Ü•L‚¶É‚â§ 2‚¶Ñ[X Fin (‚Ñì - ‚Üëi.castSucc)] := wit.H
    let h_i : L‚¶É‚â§ 2‚¶Ñ[X] := by admit /- proof elided -/

Fintype.elems in Mathlib.Data.Fintype.Defs

noncomputable def fold
  {S : Finset Œπ} (œÜ : Œπ ‚Ü™ F) (f : Œπ ‚Üí F) (k : ‚Ñï) (Œ± : F) : indexPow S œÜ k ‚Üí F :=
    fun x => (xPoly f œÜ k x).eval Œ±

LinearIndependent in Mathlib.LinearAlgebra.LinearIndependent.Defs

def computableTwiddleFactor (i : Fin ‚Ñì) (u : Fin (2 ^ (‚Ñì + R_rate - i - 1))) : L :=
  
  ‚àë (‚ü®k, hk‚ü©: Fin (‚Ñì + R_rate - i - 1)),
  if Nat.getBit k u.val = 1 then
    
      
    (evalNormalizedWAt (Œ≤ := Œ≤) (‚Ñì := ‚Ñì) (R_rate := R_rate)
      (i := ‚ü®i, by admit /- proof elided -/
      ‚ü©) (x := Œ≤ ‚ü®i + 1 + k, by admit /- proof elided -/
      ‚ü©))
  else 0

GaloisField.equivZmodP in Mathlib.FieldTheory.Finite.GaloisField

structure PrattCertificate (p : ‚Ñï) : Type where
  a : ZMod p
  pow_eq_one : a ^ (p - 1) = 1
  part : PrattPart p a (p - 1)

Fin.isValue in Lean.Meta.Tactic.Simp.BuiltinSimprocs.Fin

def MLE (evals : (œÉ ‚Üí Fin 2) ‚Üí R) : MvPolynomial œÉ R :=
    ‚àë x : œÉ ‚Üí Fin 2, (eqPolynomial (x : œÉ ‚Üí R)) * C (evals x)

protected def cast (T : FullTranscript pSpec‚ÇÅ) :
    FullTranscript pSpec‚ÇÇ :=
  Transcript.cast (k := Fin.last n‚ÇÅ) (l := Fin.last n‚ÇÇ) hn hn hSpec T

@[inline] def monoToLagrange (n : ‚Ñï) : MlPoly R n ‚Üí MlPolyEval R n :=
  (List.finRange n).foldl (fun acc level => monoToLagrangeLevel level acc)

instance : OracleInterfaces (vPSpec.toProtocolSpec A) where
  oracleInterfaces := fun _ => some OracleInterface.instVector

class IsSecure
    (relation : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (Œµ_rbr : vPSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0)
    (vectorIOP : VectorIOP Statement OStatement Witness vPSpec A) where

   
  is_complete : vectorIOP.perfectCompleteness (pure ()) ‚ü®isEmptyElim‚ü© relation

   
  is_rbr_knowledge_sound :
    OracleProof.rbrKnowledgeSoundness (pure ()) ‚ü®isEmptyElim‚ü© relation vectorIOP.verifier Œµ_rbr

instance {pSpec : ProtocolSpec n} {Statement : Type} [‚àÄ i, VCVCompatible (pSpec.Challenge i)] :
    OracleSpec.FiniteRange (srChallengeOracle Statement pSpec) where
  range_inhabited' := fun i => by admit /- proof elided -/

Set.toFinset in Mathlib.Data.Fintype.Sets

instance [Fintype F] [Nonempty F] [Semiring F] [DecidableEq Œπ] [DecidableEq F] {l : ‚Ñï}
  {u : Fin l ‚Üí Œπ ‚Üí F} : Nonempty {x // x ‚àà parametrisedCurveFinite u} :=

instance : Zero (Cayley T) where
  zero := zero

def finUInt8Equiv : Fin (2 ^ 8) ‚âÉ UInt8 where
  toFun := fun i => UInt8.ofFin i
  invFun := fun u => u.toFin
  left_inv _ := rfl
  right_inv _ := rfl

def NBlockMessages := 2 * (œë - 1) + 3

Mathlib.Meta.NormNum.mkOfNat in Mathlib.Tactic.NormNum.Result

@[simp]
def testLensE : Extractor.Lens OuterStmtIn_Test OuterStmtOut_Test InnerStmtIn_Test InnerStmtOut_Test
                Unit Unit Unit Unit where
  stmt := testStmtLens
  wit := Witness.InvLens.id

@[reducible]
def messageLength (vPSpec : VectorSpec n) (i : MessageIdx vPSpec) : Nat := vPSpec.length i

def Rhs (e : ‚Ñï) (œâs f : Fin n ‚Üí F) (i : Fin n) : F :=
  let Œ±·µ¢ := œâs i
  (-(f i) * Œ±·µ¢^e)

class Extractor.Lens.IsKnowledgeSound
    {OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut : Type}
    {OuterWitIn OuterWitOut InnerWitIn InnerWitOut : Type}
    (outerRelIn : Set (OuterStmtIn √ó OuterWitIn))
    (innerRelIn : Set (InnerStmtIn √ó InnerWitIn))
    (outerRelOut : Set (OuterStmtOut √ó OuterWitOut))
    (innerRelOut : Set (InnerStmtOut √ó InnerWitOut))
    (compatStmt : OuterStmtIn ‚Üí InnerStmtOut ‚Üí Prop)
    (compatWit : OuterWitOut ‚Üí InnerWitIn ‚Üí Prop)
    (lens : Extractor.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                            OuterWitIn OuterWitOut InnerWitIn InnerWitOut) where

   
  proj_knowledgeSound : ‚àÄ outerStmtIn innerStmtOut outerWitOut,
    compatStmt outerStmtIn innerStmtOut ‚Üí
    (lens.stmt.lift outerStmtIn innerStmtOut, outerWitOut) ‚àà outerRelOut ‚Üí
    (innerStmtOut, lens.wit.proj (outerStmtIn, outerWitOut)) ‚àà innerRelOut

   
  lift_knowledgeSound : ‚àÄ outerStmtIn outerWitOut innerWitIn,
    compatWit outerWitOut innerWitIn ‚Üí
    (lens.stmt.proj outerStmtIn, innerWitIn) ‚àà innerRelIn ‚Üí
    (outerStmtIn, lens.wit.lift (outerStmtIn, outerWitOut) innerWitIn) ‚àà outerRelIn

def FullData.copath {Œ±} {s} (cache_tree : FullData Œ± s) :
    BinaryTree.SkeletonLeafIndex s ‚Üí List Œ±
  | .ofLeaf => []
  | .ofLeft idxLeft =>
    (cache_tree.rightSubtree).getRootValue ::
      (copath cache_tree.leftSubtree idxLeft)
  | .ofRight idxRight =>
    (cache_tree.leftSubtree).getRootValue ::
      (copath cache_tree.rightSubtree idxRight)

def fnOracle (spec : OracleSpec Œπ) (f : (i : Œπ) ‚Üí spec.domain i ‚Üí spec.range i) :
    SimOracle.Impl spec where
  impl | query i t => pure (f i t)

def vflatten {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (v : (i : Fin m) ‚Üí Fin (n i) ‚Üí Œ±) :
    Fin (vsum n) ‚Üí Œ± :=
  dflatten v

@[reducible, simp] def StmtOut := Query OStatement √ó Response OStatement

def StraightlineExtractor (oSpec : OracleSpec Œπ) (Data Commitment : Type) :=
  Commitment ‚Üí QueryLog oSpec ‚Üí Data

noncomputable def J (q Œ¥ : ‚Ñö) : ‚Ñù :=
  let frac := q / (q - 1)
  (1 / frac) * (1 - Real.sqrt (1 - frac * Œ¥))

noncomputable def commitRbrExtractor (i : Fin ‚Ñì) :
  Extractor.RoundByRound []‚Çí
    (StmtIn := (Statement (L := L) Context i.succ) √ó (‚àÄ j, OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc j))
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (pSpec := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)
    (WitMid := fun _messageIdx => Witness (L := L) ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ) where
  eqIn := rfl
  extractMid := fun _ _ _ witMidSucc => witMidSucc
  extractOut := fun _ _ witOut => witOut

def relation (cs : ConstraintSystem ùì° numWires numGates) (‚Ñì : ‚Ñï) (h‚Ñì : ‚Ñì ‚â§ numWires) :
    (publicInputs : Fin ‚Ñì ‚Üí ùì°) ‚Üí (privateWitness : Fin (numWires - ‚Ñì) ‚Üí ùì°) ‚Üí Prop :=
  fun (x : Fin ‚Ñì ‚Üí ùì°) (œâ : Fin (numWires - ‚Ñì) ‚Üí ùì°) =>
    let combined := Fin.append x œâ ‚àò Fin.cast (by admit /- proof elided -/
    )
    cs.accepts combined

@[reducible, inline, specialize, simp]
def Challenge' (pSpec : ProtocolSpec n) (i : Fin n) (_ : pSpec.dir i = .V_to_P) := pSpec.¬´Type¬ª i

def stirRelation
    {F : Type} [Field F] [Fintype F] [DecidableEq F]
    {Œπ : Type} [Fintype Œπ] [Nonempty Œπ]
    (degree : ‚Ñï) (œÜ : Œπ ‚Ü™ F) (err : ‚Ñù)
    : Set ((Unit √ó ‚àÄ i, (OracleStatement Œπ F i)) √ó Unit) :=
  fun ‚ü®‚ü®_, oracle‚ü©, _‚ü© => Œ¥·µ£(oracle (), ReedSolomon.code œÜ degree) ‚â§ err

def verifySmallPrime (n' : Q(‚Ñï)) : MetaM Q(Nat.Prime $n') :=
  match n'.natLit! with
    | 2 => do haveI : $n' =Q 2 := ‚ü®‚ü©; return q(prime_2)
    | 3 => do haveI : $n' =Q 3 := ‚ü®‚ü©; return q(prime_3)
    | 5 => do haveI : $n' =Q 5 := ‚ü®‚ü©; return q(prime_5)
    | 7 => do haveI : $n' =Q 7 := ‚ü®‚ü©; return q(prime_7)
    | 11 => do haveI : $n' =Q 11 := ‚ü®‚ü©; return q(prime_11)
    | 13 => do haveI : $n' =Q 13 := ‚ü®‚ü©; return q(prime_13)
    | 17 => do haveI : $n' =Q 17 := ‚ü®‚ü©; return q(prime_17)
    | 19 => do haveI : $n' =Q 19 := ‚ü®‚ü©; return q(prime_19)
    | 23 => do haveI : $n' =Q 23 := ‚ü®‚ü©; return q(prime_23)
    | 29 => do haveI : $n' =Q 29 := ‚ü®‚ü©; return q(prime_29)
    | 31 => do haveI : $n' =Q 31 := ‚ü®‚ü©; return q(prime_31)
    | 37 => do haveI : $n' =Q 37 := ‚ü®‚ü©; return q(prime_37)
    | 41 => do haveI : $n' =Q 41 := ‚ü®‚ü©; return q(prime_41)
    | 43 => do haveI : $n' =Q 43 := ‚ü®‚ü©; return q(prime_43)
    | 47 => do haveI : $n' =Q 47 := ‚ü®‚ü©; return q(prime_47)
    | _ => failure

def toMessagesChallenges (transcript : Transcript k pSpec) :
    MessagesUpTo k pSpec √ó ChallengesUpTo k pSpec :=
  (transcript.toMessagesUpTo, transcript.toChallengesUpTo)

def masterKStateProp (stmtIdx : Fin (‚Ñì + 1))
    (oracleIdx : Fin (‚Ñì + 1))
    (h_le : oracleIdx.val ‚â§ stmtIdx.val) (stmt : Statement (L := L) Context stmtIdx)
    (wit : Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) stmtIdx)
    (oStmt : ‚àÄ j, (OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (i := oracleIdx) j))
    (localChecks : Prop := True) : Prop :=
  let oracleWitnessConsistency: Prop := oracleWitnessConsistency (mp := mp) (ùìë := ùìë) ùîΩq Œ≤
    stmtIdx oracleIdx h_le stmt wit oStmt
  let badEventExists := badEventExistsProp (œë := œë) ùîΩq Œ≤ oracleIdx
    (challenges := Fin.take (m := oracleIdx) (v := stmt.challenges) (h := by admit /- proof elided -/
    ))
    (oStmt := oStmt)
  localChecks ‚àß (badEventExists ‚à® oracleWitnessConsistency)

Algebra.TensorProduct.includeLeftRingHom in Mathlib.RingTheory.TensorProduct.Basic

@[simp]
abbrev OracleStatement.AfterSecondSumcheck : R1CS.MatrixIdx ‚äï R1CS.MatrixIdx ‚äï Fin 1 ‚Üí Type :=
  Sum.elim (EvalClaim R) (OracleStatement.AfterFirstSumcheck R pp)

@[inline] def ofNat (k : Nat) : AssocNat :=
  ‚ü®fun m => m + k, fun m => Nat.succ_add m k‚ü©

def relOut : Set ((Unit √ó (‚àÄ i, (Sum.elim OStatement OStatement) i)) √ó Unit) :=
  setOf (fun ‚ü®‚ü®(), oracles‚ü©, _‚ü© => oracles (.inl default) = oracles (.inr default))

noncomputable def sDomainBasisVectors (i : Fin r) : Fin (‚Ñì + R_rate - i) ‚Üí L :=
  fun k => (normalizedW ùîΩq Œ≤ i).eval (Œ≤ ‚ü®i + k.val, by admit /- proof elided -/
  ‚ü©)

def Fin2ToF2 (ùîΩq : Type*) [Ring ùîΩq] (k : Fin 2) : ùîΩq :=
  if k = 0 then 0 else 1

def Œ±' (x‚ÇÄ : F) (R : F[X][X][Y]) (H_irreducible : Irreducible H) (t : ‚Ñï) : ùïÉ H :=
  Œ± x‚ÇÄ R _ (œÜ := ‚ü®H_irreducible‚ü©) t

@[reducible]
def reduction : Reduction oSpec
    (StatementRound R n 0 √ó ‚àÄ i, OracleStatement R n deg i) Unit
    (StatementRound R n (.last n) √ó ‚àÄ i, OracleStatement R n deg i) Unit
    (pSpec R deg n) :=
  Reduction.seqCompose (oSpec := oSpec)
    (Stmt := fun i => StatementRound R n i √ó (‚àÄ j, OracleStatement R n deg j))
    (Wit := fun _ => Unit)
    (pSpec := fun _ => SingleRound.pSpec R deg)
    (SingleRound.reduction R n deg D oSpec)

def finIdxOf [BEq Œ±] [LawfulBEq Œ±] (a : Œ±) (l : List Œ±) : Fin (l.length + 1) :=
  ‚ü®List.idxOf' a l, Nat.lt_succ_of_le (by admit /- proof elided -/
  )‚ü©

@[inline]
def permute (params : Params) (state : Vector KoalaBear.Field params.width) :
    Vector KoalaBear.Field params.width :=
  letI rcs := params.roundConstants

  
  let st0 := externalLinearLayer params state

  
  let st1 : Vector KoalaBear.Field params.width :=
    Fin.foldl params.halfNumFullRounds (fun st_acc rc_idx =>
      let rc_chunk := (rcs.extract rc_idx (rc_idx + params.width)).cast (by admit /- proof elided -/
      )
      let st_new := fullRound params st_acc rc_chunk
      st_new) st0

  
  let rcs := rcs.drop (params.halfNumFullRounds * params.width)

  
  let st2 := Fin.foldl params.numPartialRounds (fun st_acc rc_idx =>
    let rc_val := rcs[rc_idx]'(sorry)
    let st_new := partialRound params st_acc rc_val
    st_new) st1

  
  let rcs := rcs.drop params.numPartialRounds

  
  let st3 := Fin.foldl params.halfNumFullRounds (fun st_acc rc_idx =>
    let rc_chunk := (rcs.extract rc_idx (rc_idx + params.width)).cast (by admit /- proof elided -/
    )
    let st_new := fullRound params st_acc rc_chunk
    st_new) st2

  st3

ReaderT in Init.Prelude

instance instCharP2 {k : ‚Ñï} : CharP (ConcreteBTField k) 2 :=
  charP_eq_2_of_add_self_eq_zero (F:=(ConcreteBTField k)) (sumZeroIffEq:=add_eq_zero_iff_eq)

instance : Fact (Nat.Prime scalarFieldSize) := ‚ü®ScalarField_is_prime‚ü©

def StateRestoration (oSpec : OracleSpec Œπ)
    (StmtIn WitIn WitOut : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n) :=
  StmtIn ‚Üí 
  WitOut ‚Üí 
  pSpec.FullTranscript ‚Üí 
  QueryLog (oSpec ++‚Çí (srChallengeOracle StmtIn pSpec)) ‚Üí 
  QueryLog oSpec ‚Üí 
  OracleComp oSpec WitIn 

class GenMutualCorrParams (S : Finset Œπ) (œÜ : Œπ ‚Ü™ F) (k : ‚Ñï) where
  m : ‚Ñï

  inst1 : ‚àÄ i : Fin (k + 1), Fintype (indexPowT S œÜ i)
  inst2 : ‚àÄ i : Fin (k + 1), Nonempty (indexPowT S œÜ i)
  inst3 : ‚àÄ i : Fin (k + 1), DecidableEq (indexPowT S œÜ i)

  œÜ_i : ‚àÄ i : Fin (k + 1), (indexPowT S œÜ i) ‚Ü™ F
  inst4 : ‚àÄ i : Fin (k + 1), Smooth (œÜ_i i)

  par‚Ñì_type : ‚àÄ _ : Fin (k + 1), Type
  inst5 : ‚àÄ i : Fin (k + 1), Fintype (par‚Ñì_type i)

  exp : ‚àÄ i : Fin (k + 1), (par‚Ñì_type i) ‚Ü™ ‚Ñï

  Gen_Œ± : ‚àÄ i : Fin (k + 1), ProximityGenerator (indexPowT S œÜ i) F :=
    fun i => RSGenerator.genRSC (par‚Ñì_type i) (œÜ_i i) (m - i) (exp i)
  inst6 : ‚àÄ i : Fin (k + 1), Fintype (Gen_Œ± i).par‚Ñì

  BStar : ‚àÄ i : Fin (k + 1), (Set (indexPowT S œÜ i ‚Üí F)) ‚Üí Type ‚Üí ‚Ñù‚â•0
  errStar : ‚àÄ i : Fin (k + 1), (Set (indexPowT S œÜ i ‚Üí F)) ‚Üí Type ‚Üí ‚Ñù ‚Üí ENNReal

  h : ‚àÄ i : Fin (k + 1), hasMutualCorrAgreement (Gen_Œ± i)
                                             (BStar i (Gen_Œ± i).C (Gen_Œ± i).par‚Ñì)
                                             (errStar i (Gen_Œ± i).C (Gen_Œ± i).par‚Ñì)

  hcard : ‚àÄ i : Fin (k + 1), Fintype.card ((Gen_Œ± i).par‚Ñì) = 2
  hcard' : ‚àÄ i : Fin (k + 1), Fintype.card (par‚Ñì_type i) = 2

def PlainMessages (pSpec : ProtocolSpec n) [OracleInterfaces pSpec] : Type :=
  ‚àÄ i, pSpec.PlainMessage i

@[reducible, inline, specialize, simp]
def Message (pSpec : ProtocolSpec n) (i : MessageIdx pSpec) := pSpec.¬´Type¬ª i.val

def ratchet (sponge : DuplexSponge U C) :
    OracleComp (forwardPermutationOracle C) (DuplexSponge U C) := do
  let permutedState : C ‚Üê query (spec := forwardPermutationOracle C) () sponge.state
  
  let vecState : Vector U SpongeSize.N := SpongeState.get permutedState
  
  let zeroed : Vector U SpongeSize.N :=
    Vector.ofFn (fun i => if i < SpongeSize.R then 0 else vecState[i])
  
  let newVecState := SpongeState.update permutedState zeroed
  
  return { sponge with
    state := newVecState,
    squeezePos := Fin.last SpongeSize.R }

@[reducible, inline, specialize]
def FullTranscript (pSpec : ProtocolSpec n) := (i : Fin n) ‚Üí pSpec.¬´Type¬ª i

def OracleSpec.proverOracle (StmtIn : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n) :
    OracleSpec pSpec.MessageIdx :=
  fun i => (StmtIn √ó pSpec.Transcript i.val.castSucc, pSpec.Message i)

def divide_by_2 (s : Finset ‚Ñï) : Finset ‚Ñï :=
  (erase_odd s).image (fun n => n / 2)

def oracleWitnessConsistency
    (stmtIdx : Fin (‚Ñì + 1)) (oracleIdx : Fin (‚Ñì + 1))
    (h_le : oracleIdx.val ‚â§ stmtIdx.val) (stmt : Statement (L := L) (Context := Context) stmtIdx)
    (wit : Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) stmtIdx)
    (oStmt : ‚àÄ j, (OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      œë (i := oracleIdx) j)) : Prop :=
  let witnessStructuralInvariant: Prop := witnessStructuralInvariant (mp := mp) (i:=stmtIdx) ùîΩq Œ≤
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) stmt wit
  let sumCheckConsistency: Prop := sumcheckConsistencyProp (ùìë := ùìë) stmt.sumcheck_target wit.H
  let firstOracleConsistency: Prop := firstOracleWitnessConsistencyProp ùîΩq Œ≤
    wit.t (getFirstOracle ùîΩq Œ≤ oStmt)
  let oracleFoldingConsistency: Prop := oracleFoldingConsistencyProp ùîΩq Œ≤ oracleIdx
    (challenges := Fin.take (m := oracleIdx) (v := stmt.challenges) (h := by admit /- proof elided -/
    ))
    (oStmt := oStmt)
  witnessStructuralInvariant ‚àß sumCheckConsistency ‚àß firstOracleConsistency ‚àß
    oracleFoldingConsistency

def neg_descending (p : UniPoly R) : QuotientUniPoly R :=
  Quotient.mk _ (neg p)

@[reducible]
def batchSpec (F : Type) (m : ‚Ñï) : ProtocolSpec 1 := ‚ü®!v[.V_to_P], !v[Fin m ‚Üí F]‚ü©

noncomputable def foldNth (n : ‚Ñï) (f : ùîΩ[X]) (Œ± : ùîΩ) [inst : NeZero n] : ùîΩ[X] :=
  ‚àë i : Fin n, Polynomial.C Œ± ^ i.1 * splitNth f n i

def sumCases {l : List ‚Ñï} {motive : Fin l.sum ‚Üí Sort*}
    (cases : ‚àÄ (n : ‚Ñï) (h : n ‚àà l) (i : Fin n), motive (castSum l h i))
    (i : Fin l.sum) : motive i := match l with
  | [] => by admit /- proof elided -/
  | n' :: l' => by admit /- proof elided -/

instance coe_field_adjoinRoot (k : ‚Ñï) : Coe (AdjoinRoot (poly k)) (BTField (k+1)) where
  coe := Eq.mp (BTField_succ_eq_adjoinRoot k)

noncomputable def X‚±º (‚Ñì : ‚Ñï) (h_‚Ñì : ‚Ñì ‚â§ r) (j : Fin (2 ^ ‚Ñì)) : L[X] :=
  (Finset.univ : Finset (Fin ‚Ñì)).prod
    (fun i => (normalizedW ùîΩq Œ≤ (Fin.castLE h_‚Ñì i))^(Nat.getBit i j))

Vector in Init.Data.Vector.Basic

def Œ∂ (R : F[X][X][Y]) (x‚ÇÄ : F) (H : F[X][Y]) [H_irreducible : Fact (Irreducible H)] : ùïÉ H :=
  let W  : ùïÉ H := liftToFunctionField (H.leadingCoeff);
  let T : ùïÉ H := liftToFunctionField (Polynomial.X);
    Polynomial.eval‚ÇÇ liftToFunctionField (T / W)
      (Bivariate.evalX (Polynomial.C x‚ÇÄ) R.derivative)

@[simp]
def oCtxLens (i : Fin n) : OracleContext.Lens
    (StatementRound R n i.castSucc) (StatementRound R n i.succ) (Simple.StmtIn R) (Simple.StmtOut R)
    (OracleStatement R n deg) (OracleStatement R n deg)
    (Simple.OStmtIn R deg) (Simple.OStmtOut R deg)
    Unit Unit Unit Unit where
  wit := Witness.Lens.trivial
  stmt := oStmtLens R n deg D i

@[reducible, inline]
instance instPolynomialDegreeLE : OracleInterface (R‚¶É‚â§ d‚¶Ñ[X]) where
  Query := R
  Response := R
  answer := fun ‚ü®poly, _‚ü© point => poly.eval point

instance : IsEmpty (OracleQuery []‚Çí Œ±) where
  false := by admit /- proof elided -/

instance (priority := low) : DCast‚ÇÇ Œ± Œ≤ Œ≥ where
  dcast‚ÇÇ ha hb c := by admit /- proof elided -/

def generateSrs (n : ‚Ñï) (a : ZMod p) : Vector G‚ÇÅ (n + 1) √ó Vector G‚ÇÇ 2 :=
  (towerOfExponents g‚ÇÅ a n, towerOfExponents g‚ÇÇ a 1)

def isCompliant (i : Fin (‚Ñì)) (steps : ‚Ñï) [NeZero steps]
  (h_i_add_steps : i + steps ‚â§ ‚Ñì)
  (f_i : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i, by admit /- proof elided -/
  ‚ü©)
  (f_i_plus_steps : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      ‚ü®i + steps, by admit /- proof elided -/
      ‚ü©)
  (challenges : Fin steps ‚Üí L) : Prop :=
  ‚àÉ (h_fw_dist_lt : 2 * fiberwiseDistance ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := i)
      (steps := steps) h_i_add_steps f_i < (BBF_CodeDistance ‚Ñì ùì° ‚ü®i + steps, by admit /- proof elided -/
      ‚ü© : ‚Ñï‚àû))
    (h_dist_next_lt : 2 * distFromCode f_i_plus_steps
      (BBF_Code ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i + steps, by admit /- proof elided -/
      ‚ü©)
      < (BBF_CodeDistance ‚Ñì ùì° ‚ü®i + steps, by admit /- proof elided -/
      ‚ü© : ‚Ñï‚àû)), 
    
    let h_dist_curr_lt := fiberwise_dist_lt_imp_dist_lt_unique_decoding_radius ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := i) steps h_i_add_steps f_i
      (h_fw_dist_lt := h_fw_dist_lt)
    let f_bar_i := uniqueClosestCodeword ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (i := ‚ü®i, by admit /- proof elided -/
      ‚ü©) (h_i := fin_‚Ñì_lt_‚Ñì_add_R i) f_i h_dist_curr_lt
    let f_bar_i_plus_steps := uniqueClosestCodeword ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := ‚ü®i + steps, by admit /- proof elided -/
      ‚ü©)
      (h_i := fin_‚Ñì_steps_lt_‚Ñì_add_R i steps h_i_add_steps)
      f_i_plus_steps h_dist_next_lt
    iterated_fold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (steps := ‚ü®steps, by admit /- proof elided -/
      ‚ü©)
      (i := ‚ü®i, by admit /- proof elided -/
      ‚ü©)
      (h_i_add_steps := by admit /- proof elided -/
      )
      f_bar_i challenges = f_bar_i_plus_steps

def modNat [Zero T] [DecidableEq T] [ToNat T]
    (dividend divisor : Cayley T) : Nat ‚Üí Cayley T
  | 0        => dividend  
  | .succ fuel =>
    
    if (‚Üëdivisor : Nat) = 0 then
      dividend
    else
      
      if (‚Üëdivisor : Nat) ‚â§ (‚Üëdividend : Nat) then
        
        modNat (sub dividend divisor) divisor fuel
      else
        dividend

List.take in Init.Data.List.Basic

class GenMutualCorrParams (P : Params Œπ F) (S : ‚àÄ i : Fin (M + 1), Finset (Œπ i)) where

  Œ¥ : Fin (M + 1) ‚Üí ‚Ñù‚â•0
  dist : (i : Fin (M + 1)) ‚Üí Fin ((P.foldingParam i) + 1) ‚Üí ‚Ñù‚â•0


  œÜ : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), (indexPowT (S i) (P.œÜ i) j) ‚Ü™ F

  inst1 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Fintype (indexPowT (S i) (P.œÜ i) j)
  inst2 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    Nonempty (indexPowT (S i) (P.œÜ i) j)
  inst3 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    DecidableEq (indexPowT (S i) (P.œÜ i) j)
  inst4 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Smooth (œÜ i j)

  par‚Ñì_type : ‚àÄ i : Fin (M + 1), ‚àÄ _ : Fin ((P.foldingParam i) + 1), Type
  inst5 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Fintype (par‚Ñì_type i j)

  exp : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), (par‚Ñì_type i j) ‚Ü™ ‚Ñï



  Gen_Œ± : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    ProximityGenerator (indexPowT (S i) (P.œÜ i) j) F :=
      fun i j => RSGenerator.genRSC (par‚Ñì_type i j) (œÜ i j) (P.varCount i - j) (exp i j)

  inst6 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Fintype (Gen_Œ± i j).par‚Ñì

  BStar : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    (Set ((indexPowT (S i) (P.œÜ i) j) ‚Üí F)) ‚Üí Type ‚Üí ‚Ñù‚â•0
  errStar : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    (Set ((indexPowT (S i) (P.œÜ i) j) ‚Üí F)) ‚Üí Type ‚Üí ‚Ñù ‚Üí ENNReal

  C : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Set ((indexPowT (S i) (P.œÜ i) j) ‚Üí F)
  hcode : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), (C i j) = (Gen_Œ± i j).C

  h : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    hasMutualCorrAgreement (Gen_Œ± i j)
      (BStar i j (C i j) (Gen_Œ± i j).par‚Ñì)
      (errStar i j (C i j) (Gen_Œ± i j).par‚Ñì)

  h‚Ñì_bound : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    Fintype.card (Gen_Œ± i j).par‚Ñì = 2
  h‚Ñì_bound' : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    Fintype.card (par‚Ñì_type i j) = 2

  hŒ¥Le : ‚àÄ i : Fin (M + 1),
    (Œ¥ i) ‚â§ 1 - Finset.univ.sup (fun j => BStar i j (C i j) (Gen_Œ± i j).par‚Ñì)

  hlistDecode : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    listDecodable (C i j) (Œ¥ i) (dist i j)

structure SparseMatrix (m n Œ± : Type*) where
  numEntries : ‚Ñï
  row : Fin numEntries ‚Üí m
  col : Fin numEntries ‚Üí n
  val : Fin numEntries ‚Üí Œ±
deriving Inhabited, DecidableEq

structure RoundByRound
    (oSpec : OracleSpec Œπ) (StmtIn WitIn WitOut : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n)
    (WitMid : Fin (n + 1) ‚Üí Type) where
   
  eqIn : WitMid 0 = WitIn
   
  extractMid : (m : Fin n) ‚Üí StmtIn ‚Üí Transcript m.succ pSpec ‚Üí WitMid m.succ ‚Üí WitMid m.castSucc
   
  extractOut : StmtIn ‚Üí FullTranscript pSpec ‚Üí WitOut ‚Üí WitMid (.last n)

def relayPrvState (i : Fin ‚Ñì) : Fin (0 + 1) ‚Üí Type := fun
  | ‚ü®0, _‚ü© => Statement (L := L) Context i.succ √ó
    (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j) √ó
    Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ

def vcons {n : ‚Ñï} (a : Œ±) (v : Fin n ‚Üí Œ±) : Fin (n + 1) ‚Üí Œ± :=
  dcons a v

@[reducible, simp]
def OracleStatement.Lens.IsSound {OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut : Type}
    {Outer_Œπ‚Çõ·µ¢ : Type} {OuterOStmtIn : Outer_Œπ‚Çõ·µ¢ ‚Üí Type} [‚àÄ i, OracleInterface (OuterOStmtIn i)]
    {Outer_Œπ‚Çõ‚Çí : Type} {OuterOStmtOut : Outer_Œπ‚Çõ‚Çí ‚Üí Type} [‚àÄ i, OracleInterface (OuterOStmtOut i)]
    {Inner_Œπ‚Çõ·µ¢ : Type} {InnerOStmtIn : Inner_Œπ‚Çõ·µ¢ ‚Üí Type} [‚àÄ i, OracleInterface (InnerOStmtIn i)]
    {Inner_Œπ‚Çõ‚Çí : Type} {InnerOStmtOut : Inner_Œπ‚Çõ‚Çí ‚Üí Type} [‚àÄ i, OracleInterface (InnerOStmtOut i)]
    (outerLangIn : Set (OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i)))
    (outerLangOut : Set (OuterStmtOut √ó (‚àÄ i, OuterOStmtOut i)))
    (innerLangIn : Set (InnerStmtIn √ó (‚àÄ i, InnerOStmtIn i)))
    (innerLangOut : Set (InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i)))
    (compatStmt :
      OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i) ‚Üí InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i) ‚Üí Prop)
    (lens : OracleStatement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                                    OuterOStmtIn OuterOStmtOut InnerOStmtIn InnerOStmtOut) :=
  Statement.Lens.IsSound outerLangIn outerLangOut innerLangIn innerLangOut compatStmt lens

def Z (k : ‚Ñï) : ConcreteBTField k :=
  if h_k : k = 0 then one
  else
    „Ää one (k:=k-1), zero (k:=k-1) „Äã

def map (f : R ‚Üí+* S) (p : MlPolyEval R n) : MlPolyEval S n :=
  Vector.map (fun a => f a) p

@[inline, specialize]
def prover : Prover oSpec Statement Witness (Statement √ó Witness) Unit (pSpec Witness) where
  PrvState
  | 0 => Statement √ó Witness
  | 1 => Statement √ó Witness
  input := id
  sendMessage | ‚ü®0, _‚ü© => fun ‚ü®stmt, wit‚ü© => pure (wit, ‚ü®stmt, wit‚ü©)
  receiveChallenge | ‚ü®0, h‚ü© => nomatch h
  output := fun ‚ü®stmt, wit‚ü© => pure (‚ü®stmt, wit‚ü©, ())

structure Params where
  
  width : Nat
  numFullRounds : Nat
  numPartialRounds : Nat
  internalDiagVectors : Vector KoalaBear.Field width
  roundConstants : Vector KoalaBear.Field (numFullRounds * width + numPartialRounds)

  

   
  [width_ne_zero : NeZero width]

   
  [numFullRounds_ne_zero : NeZero numFullRounds]

   
  [numPartialRounds_ne_zero : NeZero numPartialRounds]

   
  width_dvd_by_4 : 4 ‚à£ width
   
  numFullRounds_even : Even numFullRounds

def AlgebraTowerEquiv.algebraMapRightUp (e : AlgebraTowerEquiv A B) (i j : Œπ)
    (h : i ‚â§ j) : (A i) ‚Üí+* (B j) :=

@[reducible, simp]
def StmtIn : Type := R

Finset.image in Mathlib.Data.Finset.Image

@[simps!]
noncomputable def algEquivAevalXSubC {R : Type*} [CommRing R] (t : R) : R[X] ‚âÉ‚Çê[R] R[X] :=

MonadLift in Init.Prelude

def inputRelation (cond : ‚àë i, (s i).1 ‚â§ n) [DecidableEq F] (Œ¥ : ‚Ñù‚â•0) :
    Set
      (
        (
          Statement F (Fin.last k) √ó
          (‚àÄ j, OracleStatement D x s (Fin.last k) j)
        ) √ó
        Witness F s d (Fin.last k).castSucc
      ) := sorry

instance (priority := 1000) algebra_adjacent_tower (l : ‚Ñï) :
  Algebra (BTField l) (BTField (l+1)) :=

MulOneClass in Mathlib.Algebra.Group.Defs

structure AlgebraTowerEquiv (A : Œπ ‚Üí Type*) [‚àÄ i, CommSemiring (A i)] [a : AlgebraTower A]
  (B : Œπ ‚Üí Type*) [‚àÄ i, CommSemiring (B i)] [b : AlgebraTower B]
  where
    toRingEquiv : ‚àÄ i, (A i ‚âÉ+* B i)
    commutesLeft' : ‚àÄ (i j : Œπ) (h : i ‚â§ j) (r : A i),
      (b.algebraMap (i:=i) (j:=j) (h:=h)) ((toRingEquiv i) r) =
      (toRingEquiv j) (a.algebraMap (i:=i) (j:=j) (h:=h) r)

def rawConstants16 : Vector KoalaBear.Field 148 := #v[
    2128964168,
    288780357,
    316938561,
    2126233899,
    426817493,
    1714118888,
    1045008582,
    1738510837,
    889721787,
    8866516,
    681576474,
    419059826,
    1596305521,
    1583176088,
    1584387047,
    1529751136,
    1863858111,
    1072044075,
    517831365,
    1464274176,
    1138001621,
    428001039,
    245709561,
    1641420379,
    1365482496,
    770454828,
    693167409,
    757905735,
    136670447,
    436275702,
    525466355,
    1559174242,
    1030087950,
    869864998,
    322787870,
    267688717,
    948964561,
    740478015,
    679816114,
    113662466,
    2066544572,
    1744924186,
    367094720,
    1380455578,
    1842483872,
    416711434,
    1342291586,
    1692058446,
    1493348999,
    1113949088,
    210900530,
    1071655077,
    610242121,
    1136339326,
    2020858841,
    1019840479,
    678147278,
    1678413261,
    1361743414,
    61132629,
    1209546658,
    64412292,
    1936878279,
    1980661727,
    1423960925,
    2101391318,
    1915532054,
    275400051,
    1168624859,
    1141248885,
    356546469,
    1165250474,
    1320543726,
    932505663,
    1204226364,
    1452576828,
    1774936729,
    926808140,
    1184948056,
    1186493834,
    843181003,
    185193011,
    452207447,
    510054082,
    1139268644,
    630873441,
    669538875,
    462500858,
    876500520,
    1214043330,
    383937013,
    375087302,
    636912601,
    307200505,
    390279673,
    1999916485,
    1518476730,
    1606686591,
    1410677749,
    1581191572,
    1004269969,
    143426723,
    1747283099,
    1016118214,
    1749423722,
    66331533,
    1177761275,
    1581069649,
    1851371119,
    852520128,
    1499632627,
    1820847538,
    150757557,
    884787840,
    619710451,
    1651711087,
    505263814,
    212076987,
    1482432120,
    1458130652,
    382871348,
    417404007,
    2066495280,
    1996518884,
    902934924,
    582892981,
    1337064375,
    1199354861,
    2102596038,
    1533193853,
    1436311464,
    2012303432,
    839997195,
    1225781098,
    2011967775,
    575084315,
    1309329169,
    786393545,
    995788880,
    1702925345,
    1444525226,
    908073383,
    1811535085,
    1531002367,
    1635653662,
    1585100155,
    867006515,
    879151050,
]

Nat.iterate in Mathlib.Logic.Function.Iterate

@[reducible]
def Witness := Fin sz.n_w ‚Üí R

def add_descending (p q : UniPoly R) : QuotientUniPoly R :=
  Quotient.mk _ (add p q)

@[simp]
def ùïè (k : ‚Ñï) : ConcreteBTField (k + 1) := Z (k + 1)

instance : ‚àÄ i, VCVCompatible ((pSpec Witness).Challenge i) | ‚ü®0, h‚ü© => nomatch h

abbrev rtake (m : ‚Ñï) (h : m ‚â§ n)
    (transcript : FullTranscript pSpec) : FullTranscript (pSpec.rtake m h) :=
  Fin.rtake m h transcript

Matrix.submatrix in Mathlib.LinearAlgebra.Matrix.Defs

instance {k : Fin 1} : Unique (MessagesUpTo k (default : ProtocolSpec 0)) where
  default := fun i => ()
  uniq := by admit /- proof elided -/

def oracleVerifier : OracleVerifier oSpec Statement OStatement Unit (OStatement ‚äï·µ• OStatement)
    (pSpec OStatement) where

  verify := fun stmt _ => relComp stmt

  embed := sorry

  hEq := sorry

AddGroup in Mathlib.Algebra.Group.Defs

@[reducible, simp] def WitOut := Unit

@[inline] def succ (a : Cayley T) : Cayley T := add a one

OracleSpec.range in VCVio.OracleComp.OracleSpec

RatFunc.eval in Mathlib.FieldTheory.RatFunc.AsPolynomial

LinearMap.domRestrict in Mathlib.Algebra.Module.Submodule.LinearMap

instance domain_neg_inst {F : Type} [NonBinaryField F] [Finite F] {D : Subgroup FÀ£} {n : ‚Ñï}
    [DIsCyclicC : IsCyclicWithGen ‚Ü•D] [DSmooth : SmoothPowerOfTwo n ‚Ü•D]
    {x : FÀ£} (i : Fin n) : Neg (evalDomain D x i) where
  neg := fun a => ‚ü®_, neg_mem_dom_of_mem_dom D x i a.2‚ü©

def join {k : ‚Ñï} (h_pos : k > 0) (hi lo : ConcreteBTField (k - 1)) : ConcreteBTField k :=

instance {Œ± : Type u} : SliceGE (List Œ±) Nat (fun _ _ => True) (fun _ _ _ => List Œ±) where
  sliceGE xs start _ := List.drop start xs

Polynomial.degreeLTEquiv in Mathlib.RingTheory.Polynomial.Basic

@[reducible]
def pSpec : ProtocolSpec (Fin.vsum (fun _ : Fin n => 2)) :=
  ProtocolSpec.seqCompose (fun _ => SingleRound.pSpec R deg)

instance : ‚àÄ j, OracleInterface ((pSpec F).Message j)
  | ‚ü®0, h‚ü© => nomatch h
  | ‚ü®1, _‚ü© => by admit /- proof elided -/

Fin.snoc in Mathlib.Data.Fin.Tuple.Basic

def BinaryTowerAux (k : ‚Ñï) : (Œ£' (F : Type 0), BinaryTowerResult F k) :=
  match k with
  | 0 => 
    let curBTField := GF(2)
    let newList : List.Vector (GF(2)) 1 := List.Vector.cons (1 : GF(2)) List.Vector.nil
    let specialElement : GF(2) := newList.1.headI
    let firstElementOfVecIsSpecialElement : newList.1.headI = specialElement := rfl
    let specialElementIs1 : specialElement = 1 := by admit /- proof elided -/

Xor' in Mathlib.Logic.Basic

@[simp]
abbrev Witness.AfterFirstChallenge : Type := Unit

class Smooth
  (domain : Œπ ‚Ü™ F) where
    H : Subgroup (Units F)
    a           : Units F
    h_coset     : Finset.image domain Finset.univ
                  = (fun h : Units F => (a : F) * (h : F)) '' (H : Set (Units F))
    h_card_pow2 : ‚àÉ k : ‚Ñï, Fintype.card Œπ = 2 ^ k

def oracleVerifier (i : Fin n) : OracleVerifier oSpec (StatementRound R n i.castSucc)
    (OracleStatement R n deg) (StatementRound R n i.succ) (OracleStatement R n deg) (pSpec R deg) :=
  (Simple.oracleVerifier R deg D oSpec).liftContext (oStmtLens R n deg D i)

@[reducible, simp]
def toRelOut : Set ((Statement √ó Witness) √ó Unit) :=
  Prod.fst ‚Åª¬π' relIn

@[inline, reducible]
def Statement.Lens (OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut : Type)
  := PFunctor.Lens (OuterStmtIn X^ OuterStmtOut)
                   (InnerStmtIn X^ InnerStmtOut)

@[reducible, simp]
def rbrKnowledgeSoundness (relation : Set (Statement √ó Bool))
    (verifier : Verifier oSpec Statement Bool pSpec)
    (rbrKnowledgeError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) : Prop :=
  verifier.rbrKnowledgeSoundness init impl relation acceptRejectRel rbrKnowledgeError

class SmoothPowerOfTwo (n : ‚Ñï) (G : Type) [Pow G ‚Ñ§] [Monoid G] [inst : IsCyclicWithGen G] where
  smooth : orderOf inst.gen = 2 ^ n

@[inline] def mod [Zero T] [DecidableEq T] [ToNat T]
    (dividend divisor : Cayley T) : Cayley T :=
  
  letI fuel := (‚Üëdividend : Nat) + 1
  modNat dividend divisor fuel

def getCommitProverFinalOutput (i : Fin ‚Ñì)
    (inputPrvState : commitPrvState (Context := Context) ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i 0) :
  (‚Ü•(sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®‚Üëi + 1, by admit /- proof elided -/
  ‚ü©) ‚Üí L) √ó
  commitPrvState (Context := Context) ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i 1 :=
  let (stmt, oStmtIn, wit) := inputPrvState
  let f·µ¢_succ := wit.f
  let oStmtOut := snoc_oracle ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
    oStmtIn f·µ¢_succ 
  (f·µ¢_succ, (stmt, oStmtOut, wit))

def take (j : Fin (k + 1)) (messages : MessagesUpTo k pSpec) :
    MessagesUpTo (j.castLE (by admit /- proof elided -/
    )) pSpec :=
  fun i => messages ‚ü®i.val.castLE (by admit /- proof elided -/
  ), i.property‚ü©

class Verifier.IsPure (V : Verifier oSpec StmtIn StmtOut pSpec) where
    is_pure : ‚àÉ verify : _ ‚Üí _ ‚Üí _, ‚àÄ stmtIn transcript,
      V.verify stmtIn transcript = pure (verify stmtIn transcript)

@[reducible, inline, specialize, simp]
def Challenge (pSpec : ProtocolSpec n) (i : ChallengeIdx pSpec) := pSpec.¬´Type¬ª i.val

def ofMessagesChallenges (messages : MessagesUpTo k pSpec)
    (challenges : ChallengesUpTo k pSpec) : Transcript k pSpec :=
  fun i => match h : pSpec.dir (i.castLE (by admit /- proof elided -/
  )) with
  | Direction.P_to_V => messages ‚ü®i.castLE (by admit /- proof elided -/
  ), h‚ü©
  | Direction.V_to_P => challenges ‚ü®i.castLE (by admit /- proof elided -/
  ), h‚ü©

def multilinearBasis (l r : ‚Ñï) (h_le : l ‚â§ r) :
    letI instAlgebra : Algebra (BTField l) (BTField r) := binaryAlgebraTower (h_le:=h_le)
    Basis (Fin (2 ^ (r - l))) (BTField l) (BTField r) :=

instance : Unique (ChallengeIdx ‚ü®!v[.V_to_P], !v[Chal]‚ü©) where
  default := ‚ü®0, by admit /- proof elided -/
  ‚ü©
  uniq := fun i => by admit /- proof elided -/

LinearMap.ker in Mathlib.Algebra.Module.Submodule.Ker

def starData {Œ±} (k : ‚Ñï) (root : Œ±) (leaves : Fin k ‚Üí Œ±) :
    ArityTree.Data Œ± (starSkel k) :=

Vector.insertIdx in Init.Data.Vector.Basic

def mul_by_2 (s : Finset ‚Ñï) : Finset ‚Ñï :=
  s.map ‚ü®fun n => 2 * n, by admit /- proof elided -/
  ‚ü©

def splitPointIntoCoeffs (i : Fin r) (h_i : i < ‚Ñì + R_rate)
  (x : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i) :
  Fin (‚Ñì + R_rate - i.val) ‚Üí ‚Ñï := fun j =>
    if ((sDomain_basis ùîΩq Œ≤
    h_‚Ñì_add_R_rate i h_i).repr x j = 0) then
      0 else 1

@[reducible]
noncomputable def fullOracleProof :
  OracleProof []‚Çí
    (Statement := Statement (L := L) (‚Ñì:=‚Ñì) (SumcheckBaseContext L ‚Ñì) 0)
    (OStatement := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë 0)
    (Witness := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) 0)
    (pSpec:=fullPSpec ùîΩq Œ≤ Œ≥_repetitions (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)) :=
  fullOracleReduction ùîΩq Œ≤ Œ≥_repetitions (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë)

def hammingClose (i : Fin (‚Ñì + 1)) (f : OracleFunction ùîΩq Œ≤
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) : Prop :=
  2 * Code.distFromCode (u := f)
    (C := BBF_Code ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) <
    (BBF_CodeDistance ‚Ñì ùì° i : ‚Ñï‚àû)

Finset.Ico in Mathlib.Order.Interval.Finset.Defs

Fin.init in Mathlib.Data.Fin.Tuple.Basic

instance {Œ± : Type u} : Slice (Array Œ±) Nat Nat (fun _ _ _ => True) (fun _ _ _ _ => Array Œ±) where
  slice xs start stop _ := xs.extract start stop

inductive PrattPartList : (p : ‚Ñï) ‚Üí (a : ZMod p) ‚Üí ‚Ñï ‚Üí Prop
  | prime : {p : ‚Ñï} ‚Üí {a : ZMod p} ‚Üí (n k nk : ‚Ñï) ‚Üí n.Prime ‚Üí
      a ^ ((p - 1) / n) ‚â† 1 ‚Üí n ^ k = nk ‚Üí PrattPartList p a nk
  | split : {p : ‚Ñï} ‚Üí {a : ZMod p} ‚Üí {n : ‚Ñï} ‚Üí (list : List ‚Ñï) ‚Üí
      (‚àÄ r ‚àà list, PrattPartList p a r) ‚Üí list.prod = n ‚Üí PrattPartList p a n

def subNat (c : AssocNat) : Nat ‚Üí AssocNat
| 0            => c 
| Nat.succ k   => pred (subNat c k) 

@[inline, specialize]
def add {R : Type*} [Ring R] [BEq R] [LawfulBEq R] (p q : QuotientUniPoly R) : QuotientUniPoly R :=
  Quotient.lift‚ÇÇ add_descending add_descends p q

def oracleVerifier : OracleVerifier oSpec (StmtIn R) (OStmtIn R deg) (StmtOut R) (OStmtOut R deg)
    (pSpec R deg) where
  verify := fun target chal => do
    let evals : Vector R m ‚Üê (Vector.finRange m).mapM
      (fun i => query (spec := [OStmtIn R deg]‚Çí) () (D i))
    guard (evals.sum = target)
    
    pure (sorry, chal default)
  embed := .inl
  hEq := fun i => by admit /- proof elided -/

abbrev CNat (n : ‚Ñï) : Type := (CayleyTower n).1

def combined : Prop :=
  capacitySegmentDup trace ‚à® notFunction trace

alias E := combined

def oStmtLens (i : Fin n) : OracleStatement.Lens
    (StatementRound R n i.castSucc) (StatementRound R n i.succ) (Simple.StmtIn R) (Simple.StmtOut R)
    (OracleStatement R n deg) (OracleStatement R n deg)
    (Simple.OStmtIn R deg) (Simple.OStmtOut R deg) where

  toFunA := fun ‚ü®‚ü®target, challenges‚ü©, oStmt‚ü© =>
    ‚ü®target, fun _ =>
      match h : n with
      | 0 => ‚ü®Polynomial.C <| MvPolynomial.isEmptyAlgEquiv R (Fin 0) (oStmt ()), by admit /- proof elided -/
        ‚ü©
      | n + 1 =>
      ‚ü®‚àë x ‚àà (univ.map D) ^·∂† (n - i), (oStmt ()).val ‚∏®X ‚¶Éi‚¶Ñ, challenges, x‚∏©'(by admit /- proof elided -/
      ),
        sumcheck_roundPoly_degreeLE R n deg D i (oStmt ()).property‚ü©‚ü©

  toFunB := fun ‚ü®‚ü®_oldTarget, challenges‚ü©, oStmt‚ü© ‚ü®‚ü®newTarget, chal‚ü©, oStmt'‚ü© =>
    ‚ü®‚ü®newTarget, Fin.snoc challenges chal‚ü©, oStmt‚ü©

def squeeze (ds : DomainSeparator U H) (count : Nat) (label : String) : DomainSeparator U H :=
  
  
  
  
  { io := ds.io ++ SEP_BYTE ++ s!"S{count}" ++ label }

def getFirstOracle {i : Fin (‚Ñì + 1)}
    (oStmt : (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i j)) :
    sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate 0 ‚Üí L :=

Subtype.mk in Init.Prelude

instance {bIdx : Fin (‚Ñì / œë - 1)} : ‚àÄ j, OracleInterface ((pSpecFullNonLastBlock ùîΩq Œ≤
  (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) bIdx).Message j) :=
  instOracleInterfaceMessageAppend

structure ModifiedGuruswami
  (m n k : ‚Ñï)
  (œâs : Fin n ‚Ü™ F)
  (Q : F[Z][X][Y])
  (u‚ÇÄ u‚ÇÅ : Fin n ‚Üí F)
  where
  Q_ne_0 : Q ‚â† 0
   
  Q_deg : natWeightedDegree Q 1 k < D_X ((k + 1) / (n : ‚Ñö)) n m
   
  Q_multiplicity : ‚àÄ i, rootMultiplicity Q
              (Polynomial.C <| œâs i)
              ((Polynomial.C <| u‚ÇÄ i) + Polynomial.X * (Polynomial.C <| u‚ÇÅ i))
            ‚â• m
   
  Q_deg_X :
    degreeX Q < D_X ((k + 1) / (n : ‚Ñö)) n m
   
  Q_D_Y :
    D_Y Q < D_X (k + 1 / (n : ‚Ñö)) n m / k
   
  Q_D_YZ :
    D_YZ Q ‚â§ n * (m + 1/(2 : ‚Ñö))^3 / (6 * Real.sqrt ((k + 1) / n))

instance {Œ± : Type u} : Slice (List Œ±) Nat Nat (fun _ _ _ => True) (fun _ _ _ _ => List Œ±) where
  slice xs start stop _ := xs.extract start stop

instance : ‚àÄ j, SelectableType ((pSpecRelay).Challenge j)
  | ‚ü®x, hj‚ü© => by admit /- proof elided -/

@[reducible]
def GroupOpOracle : OracleSpec Unit := fun _ => (Œπ √ó Œπ √ó Œπ, Unit)

def pow (S : Finset Œπ) (œÜ : Œπ ‚Ü™ F) (k : ‚Ñï) : indexPow S œÜ k ‚Ü™ F :=
    Function.Embedding.subtype fun y => y ‚àà indexPow S œÜ k

noncomputable def polyToPowerSeriesùïÉ (H : F[X][Y])
  (P : F[X][Y])
    : PowerSeries (ùïÉ H) :=
  PowerSeries.mk <| fun n =>
    liftToFunctionField (P.coeff n)

PowerBasis in Mathlib.RingTheory.PowerBasis

class VerifierOnly (pSpec : ProtocolSpec 1) extends VerifierFirst pSpec

class HListRepr (Œ± : Type _) where
  repr: Œ± ‚Üí Std.Format

UInt8.size in Init.Prelude

def eval‚ÇÇAlgHom {A : Type w} {B : Type*} [CommSemiring A] [CommSemiring B] [PolynomialLike A P]
    [Algebra R A] [IsScalarTower R A P] [Algebra R B] (f : A ‚Üí‚Çê[R] B) (b : B) :
      P ‚Üí‚Çê[R] B where
  toRingHom := eval‚ÇÇ f b
  commutes' := by admit /- proof elided -/

instance : Field ScalarField := ZMod.instField SCALAR_FIELD_CARD

Or.inr in Init.Prelude

@[inline, reducible]
def proj : (OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i)) √ó OuterWitIn ‚Üí
    (InnerStmtIn √ó (‚àÄ i, InnerOStmtIn i)) √ó InnerWitIn :=
  fun ctxIn => ‚ü®lens.stmt.proj ctxIn.1, lens.wit.proj ctxIn‚ü©

DivisionRing in Mathlib.Algebra.Field.Defs

instance : Unique (Transcript 0 pSpec) where
  default := fun i => Fin.elim0 i
  uniq := fun T => by admit /- proof elided -/

@[inline]
def add [Add R] (p q : MlPolyEval R n) : MlPolyEval R n := Vector.zipWith (¬∑ + ¬∑) p q

instance : ‚àÄ j, OracleInterface (OracleStatement D x m j) :=
  fun _ => inferInstance

structure BacktrackSequenceFamily (trace : QueryLog (duplexSpongeChallengeOracle StmtIn U))
    (state : CanonicalSpongeState U) where
   
  seqFamily : Finset (BacktrackSequence trace state)
   
  maximality : ‚àÄ s ‚àà seqFamily, ‚àÄ s' ‚àà seqFamily,
    (s.stmt ‚â† s'.stmt) ‚à® ¬¨ (s.inputState ‚äÜ s'.inputState) ‚à® ¬¨ (s'.outputState ‚äÜ s.outputState)

Bool in Init.Prelude

Fin.tail in Mathlib.Data.Fin.Tuple.Basic

def squeezeInto (sponge : DuplexSponge U C) (arr : Array U) :
    OracleComp (forwardPermutationOracle C) (DuplexSponge U C √ó Array U) := do
  if hEmpty : arr.isEmpty then
    return (sponge, #[])
  else
    
    let sponge1 : DuplexSponge U C := { sponge with absorbPos := 0 }
    
    
    
    let ‚ü®sponge2, h‚ü© ‚Üê
      if hFull : sponge1.squeezePos = SpongeSize.R then do
        let permutedState ‚Üê query (spec := forwardPermutationOracle _) () sponge1.state
        let sponge2 : DuplexSponge U C := { sponge1 with state := permutedState, squeezePos := 0 }
        have : sponge2.squeezePos < SpongeSize.R := by admit /- proof elided -/

private noncomputable def E (œâs : Fin n ‚Üí F)
  (f : Fin n ‚Üí F) (p : Polynomial F) (e : ‚Ñï) : Polynomial F :=
  X ^ (e - (Œî‚ÇÄ(f, p.eval ‚àò œâs) : ‚Ñï)) * ElocPolyF œâs f p

@[inline, specialize, simp]
def oracleReduction : OracleReduction oSpec
    Statement OStatement Witness Statement OStatement Witness !p[] := OracleReduction.id

noncomputable instance changeOfBasisMatrix_invertible
  (‚Ñì : Nat) (h_‚Ñì : ‚Ñì ‚â§ r) :
  Invertible (changeOfBasisMatrix ùîΩq Œ≤ ‚Ñì h_‚Ñì) :=

@[inline] def succ (n : AssocNat) : AssocNat :=
  add n one

MvPolynomial.support in Mathlib.Algebra.MvPolynomial.Basic

abbrev PermuteDir := Unit ‚äï Unit

def new (domainSeparator : DomainSeparator U H) (nargString : ByteArray) :
    FSVerifierState U H :=
  { hashState := HashStateWithInstructions.new domainSeparator,
    nargString := nargString }

instance : VAdd (Œπ ‚Üí F) (AffineSubspace F (Œπ ‚Üí F)) := AffineSubspace.pointwiseVAdd

PFunctor.X in ToMathlib.PFunctor.Basic

@[simp]
def ùïè (k : ‚Ñï) : BTField (k+1) := Z (k+1)

abbrev ScalarField := ZMod scalarFieldSize

Vector.take in Init.Data.Vector.Basic

def totalNumQueries (stmt : StmtIn) (challenges : ‚àÄ i, pSpec.Challenge i)
    (naVerifier : OracleVerifier.NonAdaptive oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec) : ‚Ñï :=
  (naVerifier.queryOStmt stmt challenges).length + (naVerifier.queryMsg stmt challenges).length

inductive Program where

def U (i : Fin r) : Subspace ùîΩq L := Submodule.span ùîΩq (Œ≤ '' (Set.Ico 0 i))

instance {pSpec : ProtocolSpec n} {Statement : Type} [‚àÄ i, VCVCompatible (pSpec.Challenge i)] :
    OracleSpec.FiniteRange (fsChallengeOracle Statement pSpec) :=
  inferInstanceAs (OracleSpec.FiniteRange (srChallengeOracle Statement pSpec))

def Verifier.KnowledgeStateFunction.id {rel : Set (Statement √ó Witness)} :
    (Verifier.id : Verifier oSpec Statement _ _).KnowledgeStateFunction init impl rel rel
      (Extractor.RoundByRound.id) where
  toFun | ‚ü®0, _‚ü© => fun stmtIn _ witIn => (stmtIn, witIn) ‚àà rel
  toFun_empty := fun _ => by admit /- proof elided -/

protected def Reduction.id : Reduction oSpec Statement Witness Statement Witness !p[] where
  prover := Prover.id
  verifier := Verifier.id

instance : HListString (HList []) where
  toString
  | HList.nil => ""

def collisionPerm : Prop :=
  collisionFwdFwd trace ‚à® collisionBwdBwd trace ‚à® collisionFwdBwd trace ‚à® collisionBwdFwd trace

alias E_prp := collisionPerm

@[elab_as_elim]
def dconcat {n : ‚Ñï} {motive : Fin (n + 1) ‚Üí Sort u}
    (u : (i : Fin n) ‚Üí motive i.castSucc) (a : motive (last n)) (i : Fin (n + 1)) : motive i :=
  match n with
  | 0 => match i with | 0 => a
  | _ + 1 => dcons (u 0) (dconcat (fun i => u (Fin.succ i)) a) i

USize.ofNat in Init.Data.UInt.BasicAux

def leftpad (m‚ÇÇ n‚ÇÇ : ‚Ñï) (a : Œ±) {m‚ÇÅ n‚ÇÅ : ‚Ñï} (M : Matrix (Fin m‚ÇÅ) (Fin n‚ÇÅ) Œ±) :
    Matrix (Fin m‚ÇÇ) (Fin n‚ÇÇ) Œ± :=
  Fin.leftpad m‚ÇÇ (fun _ => a) (Fin.leftpad n‚ÇÇ a ‚àò M)

instance {Œ± : Type} [Sampleable Œ±] : DecidableEq Œ± := inferInstance

@[reducible]
def foldCommitOracleReduction (i : Fin ‚Ñì)
    (hCR : isCommitmentRound ‚Ñì œë i) :
  OracleReduction []‚Çí
    (StmtIn := Statement (L := L) Context i.castSucc)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) i.castSucc)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) i.succ)
    (pSpec := pSpecFoldCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) :=
  OracleReduction.append (oSpec:=[]‚Çí)
    (pSpec‚ÇÅ := pSpecFold (L:=L))
    (pSpec‚ÇÇ := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)
    (R‚ÇÅ := foldOracleReduction ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) i)
    (R‚ÇÇ := commitOracleReduction ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hCR)

inductive InternalData (Œ± : Type) : Skeleton ‚Üí Type
  | leaf : InternalData Œ± Skeleton.leaf
  | internal {left right} (value : Œ±)
      (leftData : InternalData Œ± left)
      (rightData : InternalData Œ± right) : InternalData Œ± (Skeleton.internal left right)
  deriving Repr

instance : DFunLike F Œ± Œ≤ where
  coe := DFunEquiv.equiv.toFun
  coe_injective' := DFunEquiv.equiv.injective

class HasSucc (T : Type u) where
   
  succ' : T ‚Üí T

def computableNTTStage [Fact (LinearIndependent ùîΩq Œ≤)]
  (i : Fin ‚Ñì) (b : Fin (2 ^ (‚Ñì + R_rate)) ‚Üí L) : Fin (2^(‚Ñì + R_rate)) ‚Üí L :=
  have h_2_pow_i_lt_2_pow_‚Ñì_add_R_rate: 2^i.val < 2^(‚Ñì + R_rate) := by admit /- proof elided -/

def FullData.rightSubtree {Œ± : Type} {s_left s_right : Skeleton}
    (tree : FullData Œ± (Skeleton.internal s_left s_right)) :
    FullData Œ± s_right :=
  match tree with
  | FullData.internal _ _left right =>
    right

Classical.typeDecidableEq in Init.Classical

Sum in Init.Core

class AlgebraTower {Œπ : Type*} [Preorder Œπ] (AT : Œπ ‚Üí Type*)
  [‚àÄ i, CommSemiring (AT i)] where
   
  protected algebraMap : ‚àÄ i j, (h : i ‚â§ j) ‚Üí (AT i ‚Üí+* AT j)
   
  commutes' : ‚àÄ (i j : Œπ) (h : i ‚â§ j) (r : AT i) (x : AT j),
    (algebraMap i j h r) * x = x * (algebraMap i j h r)
  coherence': ‚àÄ (i j k : Œπ) (h1 : i ‚â§ j) (h2 : j ‚â§ k),
    algebraMap i k (h1.trans h2) =
      (algebraMap j k h2).comp (algebraMap i j h1)

instance {Œ± : Type*} [Fintype Œ±] : Dist (PMF Œ±) where
  dist := fun a b => ‚àë x, abs ((a x).toReal - (b x).toReal)

noncomputable def vanishingPoly (S : Finset F) : Polynomial F :=
  ‚àè s ‚àà S, (Polynomial.X - Polynomial.C s)

noncomputable def batchOracleReduction :
  OracleReduction []‚Çí
    Unit (OracleStatement D x m) (Witness F s d m)
    ((Fin m ‚Üí F) √ó Fri.Spec.Statement F (0 : Fin (k + 1)))
    (OracleStatement D x m)
    (Fri.Spec.Witness F s d (0 : Fin (k + 2)))
    (batchSpec F m) where
  prover := batchProver D x s d m
  verifier := batchVerifier (k := k) D x m

CommSemiring in Mathlib.Algebra.Ring.Defs

def whirRelation
    {F : Type} [Field F] [Fintype F] [DecidableEq F]
    {Œπ : Type} [Fintype Œπ] [Nonempty Œπ]
    (varCount : ‚Ñï) (œÜ : Œπ ‚Ü™ F) [Smooth œÜ] (err : ‚Ñù)
    : Set ((Unit √ó ‚àÄ i, (OracleStatement Œπ F i)) √ó Unit) :=
  { ‚ü®‚ü®_, oracle‚ü©, _‚ü© | Œ¥·µ£(oracle (), smoothCode œÜ varCount) ‚â§ err }

@[simp]
instance BTFieldIsField (k : ‚Ñï) : Field (BTField k) := (BinaryTowerAux k).2.instField

Nat.testBit in Init.Data.Nat.Bitwise.Basic

def perfectCorrectness (scheme : Scheme oSpec Data Randomness Commitment pSpec) : Prop :=
  correctness scheme 0

def finIdxOfIfTrue [BEq Œ±] [LawfulBEq Œ±] (a : Œ±) (l : List Œ±) (h : a ‚àà l) : Fin l.length :=
  ‚ü®List.idxOf' a l, by admit /- proof elided -/
  ‚ü©

def Fin.sumCommEquiv (m : ‚Ñï) (n : ‚Ñï) : Fin (m + n) ‚âÉ (Fin n) ‚äï (Fin m) :=
  (@finSumFinEquiv m n).symm.trans (Equiv.sumComm (Fin m) (Fin n))

instance [Repr Œ±] (Œ±s : List Type) [HListRepr (HList Œ±s)] : HListRepr (HList (Œ± :: Œ±s)) where
  repr
  | HList.cons x xs =>
    match xs with
    | HList.nil => reprPrec x 0
    | HList.cons _ _ => reprPrec x 0 ++ ", " ++ HListRepr.repr xs

def completeness
    (relIn : Set ((StmtIn √ó ‚àÄ i, OStmtIn i) √ó WitIn))
    (relOut : Set ((StmtOut √ó ‚àÄ i, OStmtOut i) √ó WitOut))
    (oracleReduction : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec)
    (completenessError : ‚Ñù‚â•0) : Prop :=
  Reduction.completeness init impl relIn relOut oracleReduction.toReduction completenessError

def somePairs : HList' (fun x => x √ó x) someTypes :=
  HList'.cons (1, 1) (HList'.cons ("good", "bad") (HList'.cons (5, 3) HList'.nil))

Decidable in Init.Prelude

DivisionSemiring in Mathlib.Algebra.Field.Defs

Set.imageFactorization in Mathlib.Data.Set.Operations

def BBF_SumcheckMultiplierParam : SumcheckMultiplierParam L ‚Ñì (SumcheckBaseContext L ‚Ñì) :=
  { multpoly := fun ctx => BBF_eq_multiplier ctx.t_eval_point }

def oracleReduction.firstChallenge :
    OracleReduction oSpec
      (Statement.AfterFirstMessage R pp) (OracleStatement.AfterFirstMessage R pp) (Witness R pp)
      (Statement.AfterFirstChallenge R pp) (OracleStatement.AfterFirstChallenge R pp) Unit
      ‚ü®!v[.V_to_P], !v[FirstChallenge R pp]‚ü© :=
  sorry

@[simps!]
def equivMessagesChallenges :
    Transcript k pSpec ‚âÉ (MessagesUpTo k pSpec √ó ChallengesUpTo k pSpec) where
  toFun := toMessagesChallenges
  invFun := ofMessagesChallenges.uncurry
  left_inv := fun T => by admit /- proof elided -/

structure Opening where
  opening : Proof oSpec (Commitment √ó O.Query √ó O.Response) (Data √ó Randomness) pSpec

class Permute (Œ± : Type*) where
  permute : Œ± ‚Üí Œ±

instance (priority := high) : MonadLiftT (OracleComp []‚Çí) (OracleComp spec) where
  monadLift := OracleComp.construct pure (fun a => by admit /- proof elided -/
  ) failure

def OracleSpec.FunctionType (spec : OracleSpec Œπ) := (i : Œπ) ‚Üí spec.domain i ‚Üí spec.range i

List.finRange in Init.Data.List.FinRange

def Matrix (Œ± : Type*) (m n : ‚Ñï) := Vector (Vector Œ± n) m

def erase_even (s : Finset ‚Ñï) : Finset ‚Ñï := s.filter Odd

instance [Zero T] [DecidableEq T] [ToNat T] : Div (Cayley T) where
  div := div

AddCommGroup in Mathlib.Algebra.Group.Defs

instance : SMul ‚Ñï (UniPoly R) := ‚ü®nsmul‚ü©

instance : Sub (UniPoly R) := ‚ü®UniPoly.sub‚ü©

noncomputable def minWtCodewords [Semiring F] (LC : LinearCode Œπ F) : ‚Ñï :=
  sInf {w | ‚àÉ c ‚àà LC, c ‚â† 0 ‚àß Code.wt c = w}

def OracleVerifier.append (V‚ÇÅ : OracleVerifier oSpec Stmt‚ÇÅ OStmt‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : OracleVerifier oSpec Stmt‚ÇÇ OStmt‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ pSpec‚ÇÇ) :
      OracleVerifier oSpec Stmt‚ÇÅ OStmt‚ÇÅ Stmt‚ÇÉ OStmt‚ÇÉ (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ) where
  verify := fun stmt challenges => by admit /- proof elided -/
|
    
    .trans (.sumMap V‚ÇÅ.embed (.refl _)) <|
    
    .trans (Equiv.sumAssoc _ _ _).toEmbedding <|
    
    .sumMap (.refl _) MessageIdx.sumEquiv.toEmbedding

  hEq := fun i => by admit /- proof elided -/

noncomputable def roundConsistencyCheck [Field ùîΩ] [DecidableEq ùîΩ]
    (Œ≥ : ùîΩ) (pts : List (ùîΩ √ó ùîΩ)) (Œ≤ : ùîΩ) : Bool :=
  let p := Lagrange.interpolate Finset.univ (fun i => (pts.get i).1) (fun i => (pts.get i).2)
  p.eval Œ≥ == Œ≤

Nat.binaryRec in Mathlib.Data.Nat.BinaryRec

noncomputable def œÄ_z_lift {H : F[X][Y]} (z : F) (root : rationalRoot (H_tilde' H) z) :
  F[X][Y] ‚Üí+* F := Polynomial.evalEvalRingHom z root.1

HMod.hMod in Init.Prelude

HMul.hMul in Init.Prelude

def sumExceptFirst' (n : ‚Ñï) (h : n > 0) (D : Fin (n - 1) ‚Üí Finset R) :
    MvPolynomial (Fin n) R ‚Üí‚Çó[R] Polynomial R :=

def InputStatement := R

@[inline, reducible]
def lift : OuterStmtIn √ó OuterWitIn ‚Üí InnerStmtOut √ó InnerWitOut ‚Üí OuterStmtOut √ó OuterWitOut :=
  fun ctxIn ctxOut =>
    ‚ü®lens.stmt.toFunB ctxIn.1 ctxOut.1, lens.wit.toFunB ctxIn ctxOut‚ü©

OracleSpec in VCVio.OracleComp.OracleSpec

MvPolynomial.eval‚ÇÇHom in Mathlib.Algebra.MvPolynomial.Eval

@[simp]
def innerRelIn_Test : Set (InnerStmtIn_Test √ó Unit) :=
  setOf (fun ‚ü®‚ü®f, t‚ü©, _‚ü© => ‚àë x ‚àà {0, 1}, f.eval x = t)

@[simp]
abbrev Statement.AfterSendEvalClaim : Type := Statement.AfterFirstSumcheck R pp

instance {U : Type} {H : Type*} {R : Type*} [SpongeUnit U] [DuplexSpongeInterface U H] :
    UnitTranscript (FSProverState U H R) U where
  publicUnits state input := do
    
    
    let newState ‚Üê state.addUnits input
    .ok { rng := newState.rng, hashState := newState.hashState,
          nargString := state.nargString } 
  fillChallengeUnits state count :=
    match state.hashState.squeeze count with
    | .ok (newHashState, output) =>
      .ok ({ rng := state.rng, hashState := newHashState, nargString := state.nargString }, output)
    | .error e => .error e

structure BerlekampWelchCondition (e k : ‚Ñï) (œâs f : Fin n ‚Üí F) (E Q : Polynomial F) : Prop where
  cond: ‚àÄ i : Fin n, Q.eval (œâs i) = (f i) * E.eval (œâs i)
  E_natDegree : E.natDegree = e
  E_leadingCoeff : E.coeff e = 1
  Q_natDegree : Q.natDegree ‚â§ e + k - 1

@[reducible, simp]
def OStmtIn : Unit ‚Üí Type := fun _ => R‚¶É‚â§ deg‚¶Ñ[X]

@[inline, specialize, simp]
def oracleVerifier : OracleVerifier oSpec Statement OStatement Statement OStatement !p[] :=
  OracleVerifier.id

def Mymotive : Fin 3 ‚Üí Type := !v[‚Ñï, Bool, String]

example : !d‚ü®Mymotive‚ü©[(1 : ‚Ñï), (true : Bool), ("hello" : String)] =
  (Fin.dcons (1 : ‚Ñï) (Fin.dcons (true : Bool) (Fin.dcons ("hello" : String) Fin.dempty)) :
   (i : Fin 3) ‚Üí Mymotive i) := rfl


example : !v[1, 2] ++·µõ !v[3, 4] = !v[1, 2, 3, 4] := rfl
example : (0 : ‚Ñï) ::·µõ !v[1, 2] = !v[0, 1, 2] := rfl
example : !v[1, 2] :+·µõ (3 : ‚Ñï) = !v[1, 2, 3] := rfl


example : (1 : ‚Ñï) :: ∞ (Fin.dempty : (i : Fin 0) ‚Üí Fin.vempty i) =
  (!h[(1 : ‚Ñï)] : (i : Fin 1) ‚Üí !v[‚Ñï] i) := rfl


example : !h[(1 : ‚Ñï), (true : Bool), ("hello" : String)] =
  Fin.hcons 1 (Fin.hcons true ("hello" :: ∞‚ü®String ; !v[]‚ü© !h[])) := rfl

@[reducible]
def index (op : MemoryWrite Œπ Œ±) := op.1

instance {k : ‚Ñï} : NeZero (Z k) := (BinaryTowerAux k).snd.specialElementNeZero

Nat.bodd in Mathlib.Data.Nat.Bits

def regularElms (H : F[X][Y]) : Type :=
  {a : ùïÉ H // ‚àÉ b : ùí™ H, a = embeddingOfùí™IntoùïÉ _ b}

@[reducible]
def mk {R : Type*} (coeffs : Array R) : UniPoly R := coeffs

Equivalence in Init.Core

def dropLastWhile (p : Œ± ‚Üí Bool) (l : List Œ±) : List Œ± :=
  (l.reverse.dropWhile p).reverse

Nat.reducePow in Lean.Meta.Tactic.Simp.BuiltinSimprocs.Nat

def liftRightNil {Œπ : Type} {œÉ : Type} (oSpec : OracleSpec Œπ) :
    SimOracle.Stateful (oSpec ++‚Çí []‚Çí) oSpec œÉ where impl
  | query (.inl i) q => fun s ‚Ü¶ do return ‚ü®‚Üê query i q, s‚ü©

class SpongeUnit (Œ± : Type) extends Zero Œ±, Serde Œ± ByteArray, HasSize Œ± UInt8 where
   
  write (stream : IO.FS.Stream) : Array Œ± ‚Üí IO Unit :=
    Array.foldlM (fun _ a => IO.FS.Stream.write stream (serialize a)) ()
   
  read (stream : IO.FS.Stream) : Array Œ± ‚Üí IO (Array Œ±) :=
    fun arr => do
      let bytes ‚Üê arr.mapM (fun _ => IO.FS.Stream.read stream (USize.ofNat (HasSize.size Œ± UInt8)))
      let units := bytes.mapM deserialize
      if h : units.isSome
        then return units.get h
        else IO.throwServerError "Failed to read units"

class Context.Lens.IsComplete {OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut : Type}
    {OuterWitIn OuterWitOut InnerWitIn InnerWitOut : Type}
    (outerRelIn : Set (OuterStmtIn √ó OuterWitIn))
    (innerRelIn : Set (InnerStmtIn √ó InnerWitIn))
    (outerRelOut : Set (OuterStmtOut √ó OuterWitOut))
    (innerRelOut : Set (InnerStmtOut √ó InnerWitOut))
    (compat : (OuterStmtIn √ó OuterWitIn) ‚Üí (InnerStmtOut √ó InnerWitOut) ‚Üí Prop)
    (lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut) where

  proj_complete : ‚àÄ stmtIn witIn,
    (stmtIn, witIn) ‚àà outerRelIn ‚Üí
    (lens.stmt.proj stmtIn, lens.wit.proj (stmtIn, witIn)) ‚àà innerRelIn

  lift_complete : ‚àÄ outerStmtIn outerWitIn innerStmtOut innerWitOut,
    compat (outerStmtIn, outerWitIn) (innerStmtOut, innerWitOut) ‚Üí
    (outerStmtIn, outerWitIn) ‚àà outerRelIn ‚Üí
    (innerStmtOut, innerWitOut) ‚àà innerRelOut ‚Üí
    (lens.stmt.lift outerStmtIn innerStmtOut,
    lens.wit.lift (outerStmtIn, outerWitIn) (innerStmtOut, innerWitOut)) ‚àà outerRelOut

instance {relIn : Set (StmtIn √ó WitIn)} {relOut : Set (StmtOut √ó WitOut)}
    {verifier : Verifier oSpec StmtIn StmtOut pSpec} {WitMid : Fin (n + 1) ‚Üí Type}
    {extractor : Extractor.RoundByRound oSpec StmtIn WitIn WitOut pSpec WitMid} :
    CoeFun (verifier.KnowledgeStateFunction init impl relIn relOut extractor)
    (fun _ => (m : Fin (n + 1)) ‚Üí StmtIn ‚Üí Transcript m pSpec ‚Üí WitMid m ‚Üí Prop) :=
      ‚ü®fun f => f.toFun‚ü©

class HasPred (T : Type u) where
   
  pred' : T ‚Üí T

instance (k : ‚Ñï) : DecidableEq (ConcreteBTField k) :=
  fun x y =>
    let p := BitVec.toNat x = BitVec.toNat y
    let q := x = y
    let hp : Decidable p := Nat.decEq (BitVec.toNat x) (BitVec.toNat y)
    let h_iff_pq : p ‚Üî q := (BitVec.toNat_eq).symm 
    match hp with
    | isTrue (proof_p : p) =>
      
      
      isTrue (h_iff_pq.mp proof_p)
    | isFalse (nproof_p : ¬¨p) =>
      
      
      
      
      isFalse (fun (proof_q : q) => nproof_p (h_iff_pq.mpr proof_q))

def Reduction.append (R‚ÇÅ : Reduction oSpec Stmt‚ÇÅ Wit‚ÇÅ Stmt‚ÇÇ Wit‚ÇÇ pSpec‚ÇÅ)
    (R‚ÇÇ : Reduction oSpec Stmt‚ÇÇ Wit‚ÇÇ Stmt‚ÇÉ Wit‚ÇÉ pSpec‚ÇÇ) :
      Reduction oSpec Stmt‚ÇÅ Wit‚ÇÅ Stmt‚ÇÉ Wit‚ÇÉ (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ) where
  prover := Prover.append R‚ÇÅ.prover R‚ÇÇ.prover
  verifier := Verifier.append R‚ÇÅ.verifier R‚ÇÇ.verifier

instance Vector.instFintype {Œ± : Type*} {n : ‚Ñï} [VCVCompatible Œ±] : Fintype (Vector Œ± n) :=
  Fintype.ofEquiv _ (Equiv.rootVectorEquivFin).symm

def inputRelation [DecidableEq F] (Œ¥ : ‚Ñù‚â•0) :
    Set
      (
        (Statement (k := k) F 0 √ó (‚àÄ j, OracleStatement (k := k) D x s 0 j)) √ó
        Witness F s d (0 : Fin (k + 2))
      ) :=
  match k with
  | 0 => FinalFoldPhase.inputRelation D x s d (round_bound dom_size_cond) Œ¥
  | .succ _ => FoldPhase.inputRelation D x s d 0 (round_bound dom_size_cond) Œ¥

def prover : OracleProver oSpec (StmtIn R) (OStmtIn R deg) Unit (StmtOut R) (OStmtOut R deg) Unit
    (pSpec R deg) where
  PrvState
    | 0 => R‚¶É‚â§ deg‚¶Ñ[X]
    | 1 => R‚¶É‚â§ deg‚¶Ñ[X]
    | 2 => R‚¶É‚â§ deg‚¶Ñ[X] √ó R

  input := fun ‚ü®‚ü®_, oStmt‚ü©, _‚ü© => oStmt ()

  sendMessage
  | ‚ü®0, _‚ü© => fun polyLE => pure ‚ü®polyLE, polyLE‚ü©
  | ‚ü®1, h‚ü© => nomatch h

  receiveChallenge
  | ‚ü®0, h‚ü© => nomatch h
  | ‚ü®1, _‚ü© => fun polyLE => pure fun chal => ‚ü®polyLE, chal‚ü©

  output := fun ‚ü®polyLE, chal‚ü© => pure (((polyLE.val.eval chal, chal), fun _ => polyLE), ())

instance polyMonic (n : ‚Ñï) : Monic (poly n) := definingPoly_is_monic (Z n)

def pSpecSumcheckFold := (pSpecNonLastBlocks ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)) ++‚Çö
  (pSpecLastBlock (L:=L) (œë:=œë))

def dist' (C : Set (n ‚Üí R)) [Fintype C] : ‚Ñï‚àû :=
  Finset.min <| ((@Finset.univ (C √ó C) _).filter (fun p => p.1 ‚â† p.2)).image
    (fun ‚ü®u, v‚ü© => hammingDist u.1 v.1)

inductive LeafData (Œ± : Type) : Skeleton ‚Üí Type
  | leaf (value : Œ±) : LeafData Œ± Skeleton.leaf
  | internal {left right} (leftData : LeafData Œ± left) (rightData : LeafData Œ± right) :
      LeafData Œ± (Skeleton.internal left right)
  deriving Repr

Option.bind in Init.Data.Option.Basic

instance {s} : LawfulFunctor (fun Œ± => InternalData Œ± s) :=

@[reducible, inline]
instance instPolynomialDegreeLT : OracleInterface (R‚¶É< d‚¶Ñ[X]) where
  Query := R
  Response := R
  answer := fun ‚ü®poly, _‚ü© point => poly.eval point

@[inline]
def ofInputOnly
    (liftWit : OuterStmtIn √ó OuterWitOut ‚Üí InnerWitIn ‚Üí OuterWitIn) :
    Witness.InvLens OuterStmtIn OuterWitIn OuterWitOut InnerWitIn OuterWitOut :=
  ‚ü®Prod.snd, liftWit‚ü©

tail in ToMathlib.Control.Comonad.Instances

instance instFieldConcrete {k : ‚Ñï} : Field (ConcreteBTField k) :=
  mkFieldInstance (getBTFResult k).toConcreteBTFieldProps

@[reducible, simp]
def relOut : Set (Statement √ó Unit) := Set.univ

instDecidableEqOfLawfulBEq in Init.Core

def getUElements (i : Fin r) : List L :=
  (List.finRange (2^i.val)).map fun k =>
    (Finset.univ : Finset (Fin i)).sum fun j =>
      if Nat.getBit (n := k.val) (k := j.val) == 1 then
        Œ≤ ‚ü®j.val, by admit /- proof elided -/
        ‚ü©
      else 0

def powerBasisSucc (k : ‚Ñï) :
    PowerBasis (ConcreteBTField k) (ConcreteBTField (k + 1)) :=

instance [Zero T] [ToNat T] : ToNat (Cayley T) where
  toNat := ToNat.toNat ‚àò toT

@[inline, specialize]
def Prover.processRoundDSFS [‚àÄ i, VCVCompatible (pSpec.Challenge i)] (j : Fin n)
    (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec)
    (currentResult : OracleComp (oSpec ++‚Çí duplexSpongeChallengeOracle StmtIn U)
      (pSpec.MessagesUpTo j.castSucc √ó
        CanonicalDuplexSponge U √ó prover.PrvState j.castSucc)) :
      OracleComp (oSpec ++‚Çí duplexSpongeChallengeOracle StmtIn U)
        (pSpec.MessagesUpTo j.succ √ó
          CanonicalDuplexSponge U √ó prover.PrvState j.succ) := do
  let ‚ü®messages, sponge, state‚ü© ‚Üê currentResult
  match hDir : pSpec.dir j with
  | .V_to_P => do
    let f ‚Üê prover.receiveChallenge ‚ü®j, hDir‚ü© state
    let (challenge, newSponge) ‚Üê
      liftM (DuplexSponge.squeeze sponge (challengeSize ‚ü®j, hDir‚ü©))
    
    let deserializedChallenge : pSpec.Challenge ‚ü®j, hDir‚ü© := Deserialize.deserialize challenge
    return ‚ü®messages.extend hDir, newSponge, f deserializedChallenge‚ü©
  | .P_to_V => do
    let ‚ü®msg, newState‚ü© ‚Üê prover.sendMessage ‚ü®j, hDir‚ü© state
    let serializedMessage : Vector U (messageSize ‚ü®j, hDir‚ü©) := Serialize.serialize msg
    let newSponge ‚Üê liftM (DuplexSponge.absorb sponge serializedMessage.toList)
    return ‚ü®messages.concat hDir msg, newSponge, newState‚ü©

@[inline] def le [Zero T] [ToNat T] (a b : Cayley T) : Prop :=
  (‚Üëa : Nat) ‚â§ (‚Üëb : Nat)

def rdrop (m : ‚Ñï) (h : m ‚â§ n) (pSpec : ProtocolSpec n) : ProtocolSpec (n - m) :=
  {dir := Fin.rdrop m h pSpec.dir, ¬´Type¬ª := Fin.rdrop m h pSpec.¬´Type¬ª}

Neg in Init.Prelude

@[inline]
def zero [Zero R] : MlPolyEval R n := Vector.replicate (2 ^ n) 0

Polynomial.C in Mathlib.Algebra.Polynomial.Basic

class ProverFirst (pSpec : ProtocolSpec n) [NeZero n] where
  prover_first' : pSpec.dir 0 = .P_to_V

def commitmentScheme : Commitment.Scheme (oSpec Œ± Œ≤ Œ≥) Œ± Œ≤ Œ≥ !p[] where
  commit := fun v r => commit v
  opening := .mk (sorry) (.mk (sorry))

instance {k : ‚Ñï} : Mul (ConcreteBTField k) where
  mul := concrete_mul

Unique in Mathlib.Logic.Unique

def commitKnowledgeError {i : Fin ‚Ñì}
    (m : (pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i).ChallengeIdx) : ‚Ñù‚â•0 :=
  match m with
  | ‚ü®j, hj‚ü© => by admit /- proof elided -/

IsEmpty in Mathlib.Logic.IsEmpty

def eval (x : Fin numWires ‚Üí ùì°) (g : Gate ùì° numWires) : ùì° :=
  g.qL * x g.a + g.qR * x g.b + g.qO * x g.c + g.qM * (x g.a * x g.b) + g.qC

instance : ‚àÄ i, VCVCompatible ((default : ProtocolSpec 0).Challenge i) := fun ‚ü®i, _‚ü© => Fin.elim0 i

def regularElms_set (H : F[X][Y]) : Set (ùïÉ H) :=
  {a : ùïÉ H | ‚àÉ b : ùí™ H, a = embeddingOfùí™IntoùïÉ _ b}

UInt64.ofFin in Init.Data.UInt.Basic

def domainEmb {i : ‚Ñï} : evalDomain D i ‚Ü™ F :=
  ‚ü®
    fun x => x.1.1,
    by admit /- proof elided -/
  ‚ü©

instance : Fact (Nat.Prime SCALAR_FIELD_CARD) := ‚ü®ScalarField_is_prime‚ü©

Units.val in Mathlib.Algebra.Group.Units.Defs

USize in Init.Prelude

inductive HList' {Œ± : Type v} (Œ≤ : Œ± ‚Üí Type u) : List Œ± ‚Üí Type (max u v)
  | nil  : HList' Œ≤ []
  | cons : Œ≤ i ‚Üí HList' Œ≤ is ‚Üí HList' Œ≤ (i :: is)

Finset.sup in Mathlib.Data.Finset.Lattice.Fold

class DCast‚ÇÉ (Œ± : Sort*) (Œ≤ : Œ± ‚Üí Sort*) (Œ≥ : (a : Œ±) ‚Üí Œ≤ a ‚Üí Sort*)
    (Œ¥ : (a : Œ±) ‚Üí (b : Œ≤ a) ‚Üí Œ≥ a b ‚Üí Sort*) [DCast Œ± Œ≤] [DCast‚ÇÇ Œ± Œ≤ Œ≥] where
  dcast‚ÇÉ : ‚àÄ {a a' : Œ±} {b : Œ≤ a} {b' : Œ≤ a'} {c : Œ≥ a b} {c' : Œ≥ a' b'},
    (ha : a = a') ‚Üí (hb : dcast ha b = b') ‚Üí (hc : dcast‚ÇÇ ha hb c = c') ‚Üí Œ¥ a b c ‚Üí Œ¥ a' b' c'
  dcast‚ÇÉ_id : ‚àÄ {a : Œ±} {b : Œ≤ a} {c : Œ≥ a b},
    dcast‚ÇÉ (Eq.refl a) dcast_eq dcast‚ÇÇ_eq = (id : Œ¥ a b c ‚Üí Œ¥ a b c)

def foldMatrix (i : Fin r) (steps : Fin (‚Ñì + 1)) (h_i_add_steps : i.val + steps < ‚Ñì + ùì°)
    (y : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate)
      ‚ü®‚Üëi + steps, by apply Nat.lt_trans (m := ‚Ñì + ùì°) (h_i_add_steps) h_‚Ñì_add_R_rate‚ü©)
    : Matrix (Fin (2 ^ steps.val)) (Fin (2 ^ steps.val)) L :=

def toVerifierState (ds : DomainSeparator U H) (transcript : ByteArray) : FSVerifierState U H :=
  FSVerifierState.new ds transcript

Fin.insertNth in Mathlib.Data.Fin.Tuple.Basic

inline in Init.Core
</all_available_defs>

<all_available_lemmas>
Finset.prod_eq_zero_iff in Mathlib.Algebra.BigOperators.GroupWithZero.Finset
Nat.not_lt_zero in Init.Prelude
Polynomial.X_sub_C_ne_zero in Mathlib.Algebra.Polynomial.Degree.Operations
Set.Ico_eq_empty_iff in Mathlib.Order.Interval.Set.Basic
Polynomial.X_ne_zero in Mathlib.Algebra.Polynomial.Basic
Polynomial.coeff_C_zero in Mathlib.Algebra.Polynomial.Basic
Polynomial.coeff_X_zero in Mathlib.Algebra.Polynomial.Basic
Polynomial.coeff_sub in Mathlib.Algebra.Polynomial.Basic
Polynomial.comp_eq_zero_iff in Mathlib.Algebra.Polynomial.Degree.Lemmas
and_false in Init.SimpLemmas
map_neg in Mathlib.Algebra.Group.Hom.Defs
sub_eq_neg_self in Mathlib.Algebra.Group.Basic
zero_sub in Mathlib.Algebra.Group.Defs
EmbeddingLike.map_eq_zero_iff in Mathlib.Algebra.Group.Equiv.Defs
Polynomial.aeval_C in Mathlib.Algebra.Polynomial.AlgebraMap
Polynomial.aeval_X in Mathlib.Algebra.Polynomial.AlgebraMap
Polynomial.algEquivOfCompEqX_apply in Mathlib.Algebra.Polynomial.AlgebraMap
Polynomial.algebraMap_eq in Mathlib.Algebra.Polynomial.AlgebraMap
Polynomial.rootMultiplicity_eq_multiplicity in Mathlib.Algebra.Polynomial.Div
if_false in Init.ByCases
if_true in Init.ByCases
map_sub in Mathlib.Algebra.Group.Hom.Defs
multiplicity_map_eq in Mathlib.RingTheory.Multiplicity
sub_sub_sub_cancel_right in Mathlib.Algebra.Group.Basic
Multiset.countP_eq_card_filter in Mathlib.Data.Multiset.Filter
Multiset.count_map in Mathlib.Data.Multiset.Filter
Multiset.filter_congr in Mathlib.Data.Multiset.Filter
Polynomial.count_roots in Mathlib.Algebra.Polynomial.Roots
Polynomial.ext in Mathlib.Algebra.Polynomial.Basic
add_comm in Mathlib.Algebra.Group.Defs
eq_comm in Init.Core
eq_sub_iff_add_eq in Mathlib.Algebra.Group.Basic
Finset.image_val_of_injOn in Mathlib.Data.Finset.Image
Finset.prod_image in Mathlib.Algebra.BigOperators.Group.Finset.Basic
Polynomial.roots_prod_X_sub_C in Mathlib.Algebra.Polynomial.Roots
Subtype.val_injective in Mathlib.Data.Subtype
CanLift.prf in Mathlib.Tactic.Lift
Multiset.card_singleton in Mathlib.Data.Multiset.ZeroCons
Multiset.card_zero in Mathlib.Data.Multiset.ZeroCons
Multiset.count_filter in Mathlib.Data.Multiset.Filter
Multiset.count_singleton in Mathlib.Data.Multiset.Count
Multiset.count_univ in Mathlib.Data.Fintype.Basic
Multiset.count_zero in Mathlib.Data.Multiset.Count
SetLike.coe_eq_coe in Mathlib.Data.SetLike.Basic
SetLike.mem_coe in Mathlib.Data.SetLike.Basic
imp_false in Init.Core
ite_eq_right_iff in Init.PropLemmas
one_ne_zero in Mathlib.Algebra.NeZero
Fin.zero_le in Init.Data.Fin.Lemmas
Set.Ico_subset_Ico_right in Mathlib.Order.Interval.Set.Basic
Set.image_mono in Mathlib.Data.Set.Image
Set.mem_Ico in Mathlib.Order.Interval.Set.Defs
Set.mem_image_of_mem in Mathlib.Data.Set.Operations
Submodule.add_mem in Mathlib.Algebra.Module.Submodule.Defs
Submodule.smul_mem in Mathlib.Algebra.Module.Submodule.Defs
Submodule.span_mono in Mathlib.LinearAlgebra.Span.Defs
Submodule.subset_span in Mathlib.LinearAlgebra.Span.Defs
sub_add_cancel in Mathlib.Algebra.Group.Defs
true_and in Init.SimpLemmas
Fact.out in Mathlib.Logic.Basic
Fin.le_zero_iff' in Mathlib.Data.Fin.SuccPred
LinearIndependent.injective in Mathlib.LinearAlgebra.LinearIndependent.Defs
Set.compl_eq_univ_diff in Mathlib.Order.BooleanAlgebra.Set
Set.empty_subset in Mathlib.Data.Set.Basic
Set.image_empty in Mathlib.Data.Set.Image
Set.image_subset_image_iff in Mathlib.Data.Set.Image
Set.subset_compl_singleton_iff in Mathlib.Order.BooleanAlgebra.Set
linearIndependent_iff_notMem_span in Mathlib.LinearAlgebra.LinearIndependent.Defs
Set.Ico_insert_right in Mathlib.Order.Interval.Set.Basic
Set.image_singleton in Mathlib.Data.Set.Image
Set.image_union in Mathlib.Data.Set.Image
Set.mem_Icc in Mathlib.Order.Interval.Set.Defs
Set.union_singleton in Mathlib.Data.Set.Insert
Submodule.mem_span_singleton in Mathlib.LinearAlgebra.Span.Defs
Submodule.mem_sup in Mathlib.LinearAlgebra.Span.Defs
Submodule.smul_mem_iff in Mathlib.Algebra.Module.Submodule.Basic
Submodule.span_union in Mathlib.LinearAlgebra.Span.Defs
Submodule.sub_mem in Mathlib.Algebra.Module.Submodule.Defs
existsUnique_of_exists_of_unique in Mathlib.Logic.ExistsUnique
sub_eq_zero in Mathlib.Algebra.Group.Basic
sub_smul in Mathlib.Algebra.Module.Defs
sub_sub_sub_cancel_left in Mathlib.Algebra.Group.Basic
Finset.mem_univ in Mathlib.Data.Fintype.Defs
Finset.sum_const_zero in Mathlib.Algebra.BigOperators.Group.Finset.Defs
Finset.sum_ite_eq' in Mathlib.Algebra.BigOperators.Group.Finset.Piecewise
Finset.sum_map_val in Mathlib.Algebra.BigOperators.Group.Finset.Defs
Multiset.count_bind in Mathlib.Data.Multiset.Bind
Multiset.count_map_eq_count' in Mathlib.Data.Multiset.Filter
Polynomial.roots_prod in Mathlib.Algebra.Polynomial.Roots
add_left_injective in Mathlib.Algebra.Group.Defs
and_true in Init.SimpLemmas
eq_iff_iff in Init.Core
forall_const in Init.PropLemmas
if_false_right in Init.PropLemmas
if_neg in Init.Core
if_pos in Init.Core
iff_false in Init.SimpLemmas
implies_true in Init.SimpLemmas
ite_false in Init.SimpLemmas
ite_true in Init.SimpLemmas
ne_eq in Init.SimpLemmas

lemma Fin.lt_succ' (a : Fin r) (h_a_add_1 : a + 1 < r) : a < a + 1

lemma Fin.val_add_one' (a : Fin r) (h_a_add_1 : a + 1 < r) : (a + 1).val = a.val + 1

lemma Fin.le_succ (a : Fin r) (h_a_add_1 : a + 1 < r) : a ‚â§ a + 1

lemma Fin.le_iff_lt_succ (a b : Fin r) (h_b : b + 1 < r) : a ‚â§ b ‚Üî a < b + 1

@[simp]
theorem codeDist'_subsingleton [Subsingleton C] : ‚ÄñC‚Äñ‚ÇÄ' = ‚ä§

@[simp]
theorem append_fst (T‚ÇÅ : FullTranscript pSpec‚ÇÅ) (T‚ÇÇ : FullTranscript pSpec‚ÇÇ) :
    (T‚ÇÅ ++‚Çú T‚ÇÇ).fst = T‚ÇÅ

@[simp]
theorem fflatten_splitSum {A : Sort u} {F : A ‚Üí Sort v} {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï}
    {Œ± : (i : Fin (vsum n)) ‚Üí A}
    (v : (k : Fin (vsum n)) ‚Üí F (Œ± k)) (k : Fin (vsum n)) :
    fflatten (fun i j => v (embedSum i j)) k = cast (by simp) (v k)

@[simp]
theorem oracleVerifier_rbrKnowledgeSoundness [Nonempty (Query OStatement)]
    {d : ‚Ñï} (hDist : distanceLE OStatement d) :
    (oracleVerifier oSpec OStatement).rbrKnowledgeSoundness init impl
      (relIn OStatement)
      (relOut OStatement)
      (fun _ => (d : ‚Ñù‚â•0) / (Fintype.card (Query OStatement) : ‚Ñù‚â•0))

theorem support_finSuccEquivNth_nonempty {f : MvPolynomial (Fin (n + 1)) R} (h : f ‚â† 0) :
    (finSuccEquivNth R p f).support.Nonempty

@[simp]
lemma not_P_to_V_eq_V_to_P {x : Direction} (h : x ‚â† .V_to_P) : x = .P_to_V

theorem prod_X_sub_C_eq_X_pow_card_sub_X_in_L :
  (‚àè c ‚àà (Finset.univ : Finset Fq), (Polynomial.X - Polynomial.C (algebraMap Fq L c))) =
    Polynomial.X^(Fintype.card Fq) - Polynomial.X

theorem PrattCertificate.out {p : ‚Ñï} (c : PrattCertificate p) : p.Prime

lemma sInf_UB_of_le_UB {S : Set ‚Ñï} {i : ‚Ñï} : (‚àÄ s ‚àà S, s ‚â§ i) ‚Üí sInf S ‚â§ i

@[simp]
theorem prover_first (pSpec : ProtocolSpec n) [NeZero n] [h : ProverFirst pSpec] :
    pSpec.dir 0 = .P_to_V

@[simp]
lemma truncate_zero_eq_zero : (truncate p 0) = 0

theorem not_irreducible_of_isRoot_of_degree_gt_one
  (p : R[X]) (h_root : ‚àÉ r : R, IsRoot p r) (h_deg : p.degree > 1) :
  ¬¨ Irreducible p

@[simp]
theorem fappend_zero {Œ≤ : Fin m ‚Üí A} {Œ± : Fin 0 ‚Üí A}
    (u : (i : Fin m) ‚Üí F (Œ≤ i)) :
    fappend u (!h‚¶ÉF‚¶Ñ‚ü®Œ±‚ü©[] : (i : Fin 0) ‚Üí F (Œ± i)) = u

Finset.sup_lt_iff in Mathlib.Data.Finset.Lattice.Fold

theorem zipWith_cons {Œ± Œ≤ Œ≥} {n : ‚Ñï} (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥)
    (a : Œ±) (b : Vector Œ± n) (c : Œ≤) (d : Vector Œ≤ n) :
    zipWith f (cons a b) (cons c d) = cons (f a c) (zipWith f b d)

@[simp]
theorem vappend_right (u : Fin m ‚Üí Œ±) (v : Fin n ‚Üí Œ±) (i : Fin n) :
    vappend u v (natAdd m i) = v i

theorem base_intermediateNovelBasisX (j : Fin (2 ^ ‚Ñì)) :
  intermediateNovelBasisX ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®0, by
    by_contra ht
    simp only [not_lt, nonpos_iff_eq_zero] at ht
    contradiction
  ‚ü© j =
  X‚±º ùîΩq Œ≤ ‚Ñì (by omega) j

lemma isInterleaved_codeOfLinearCode : (codeOfLinearCode Œ∫ LC).isInterleaved

@[to_additive (attr := simp) vsum_zero]
lemma vprod_zero [CommMonoid Œ±] {a : Fin 0 ‚Üí Œ±} : vprod a = 1

@[simp]
theorem oracleReduction_completeness (h : init.neverFails) :
    (oracleReduction oSpec Statement OStatement Witness).perfectCompleteness init impl oRelIn
    (toORelOut oRelIn)

@[simp]
theorem addCases'_left {m n : ‚Ñï} {Œ± : Fin m ‚Üí Sort u} {Œ≤ : Fin n ‚Üí Sort u}
    (left : (i : Fin m) ‚Üí Œ± i) (right : (j : Fin n) ‚Üí Œ≤ j) (i : Fin m) :
      addCases' left right (Fin.castAdd n i) = (Fin.append_left Œ± Œ≤ i) ‚ñ∏ (left i)

omit hF‚ÇÇ in
theorem W_linear_comp_decomposition (i : Fin r) (h_i_add_1 : i + 1 < r) :
    ‚àÄ p: L[X], (W ùîΩq Œ≤ (i + 1)).comp p =
      ((W ùîΩq Œ≤ i).comp p) ^ Fintype.card ùîΩq -
        C (eval (Œ≤ i) (W ùîΩq Œ≤ i)) ^ (Fintype.card ùîΩq - 1) * ((W ùîΩq Œ≤ i).comp p)

lemma oracle_block_k_next_le (i : Fin (‚Ñì + 1)) (j : Fin (toOutCodewordsCount ‚Ñì œë i))
    (hj : j.val + 1 < toOutCodewordsCount ‚Ñì œë i) : j.val * œë + œë ‚â§ i

@[simp]
lemma natDegree_solutionToQ :
  (solutionToQ e k v).natDegree ‚â§ e + k - 1

@[simp]
theorem getLastI_append_single [Inhabited Œ±] (x : Œ±) : (l ++ [x]).getLastI = x

lemma towerRingHomForwardMap_Z (k : ‚Ñï) :
  towerRingHomForwardMap k (Z k) = BinaryTower.Z k

theorem BitVec.dcast_dcast_bitvec_extractLsb_eq {w hi lo : ‚Ñï} (x : BitVec w)
  (h_width_eq : w = hi - lo + 1) : dcast h_width_eq (dcast (h_width_eq.symm)
  (BitVec.extractLsb (hi:=hi) (lo:=lo) x)) = BitVec.extractLsb (hi:=hi) (lo:=lo) x

theorem is_multilinear_eq_iff_eq_evals_zeroOne (p : MvPolynomial œÉ R) (q : MvPolynomial œÉ R)
    (hp : p ‚àà R‚¶É‚â§ 1‚¶Ñ[X œÉ]) (hq : q ‚àà R‚¶É‚â§ 1‚¶Ñ[X œÉ]) :
    p = q ‚Üî p.toEvalsZeroOne = q.toEvalsZeroOne

omit [DecidableEq ùîΩq] hF‚ÇÇ in
lemma getSDomainBasisCoeff_of_iteratedQuotientMap
    [NeZero R_rate] (i : Fin ‚Ñì) (k : ‚Ñï)
    (h_bound : i.val + k ‚â§ ‚Ñì) (x : (sDomain ùîΩq Œ≤
    h_‚Ñì_add_R_rate) ‚ü®i, by omega‚ü©) :
    let y := iteratedQuotientMap (i := i) (k:=k) (h_bound:=h_bound) (x:=x)
    ‚àÄ (j: Fin (‚Ñì + R_rate - (i + k))),
    ((sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®‚Üëi + k, by omega‚ü©) (h_i := by
      simp only;
      apply Nat.lt_add_of_pos_right_of_le; omega)).repr y) j =
    ((sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®‚Üëi, by omega‚ü©)
      (h_i := by simp only; omega)).repr x) ‚ü®j + k, by simp only; omega‚ü©

@[to_additive vsum_castSucc]
lemma vprod_castSucc [CommMonoid Œ±] {a : Fin (n + 1) ‚Üí Œ±} :
    vprod a = vprod (a ‚àò Fin.castSucc) * a (last n)

lemma rounds_sub_steps_lt : ‚Ñì - œë < ‚Ñì :=
  Nat.sub_lt (pos_of_neZero ‚Ñì) (folding_steps_pos)

lemma œë_sub_one_le_self : œë - 1 < œë

theorem support_mul_C_le (p : MvPolynomial œÉ R) (r : R) : (p * C r).support ‚äÜ p.support

lemma aeval_apply {A : Type w} [CommSemiring A] [Algebra R A] (s : A) :
    aeval (P := P) s = eval‚ÇÇAlgHom (Algebra.ofId R A) s

theorem evalNormalizedWAt_eq_normalizedW (i : Fin r) (x : L) :
  evalNormalizedWAt (Œ≤ := Œ≤) (‚Ñì := ‚Ñì) (R_rate := R_rate) (i := i) x
    = (normalizedW (ùîΩq := ùîΩq) (Œ≤ := Œ≤) (i := i)).eval x

theorem induction_append_left {m n : ‚Ñï} {motive : Fin (m + n + 1) ‚Üí Sort*} {zero : motive 0}
    {succ : ‚àÄ i : Fin (m + n), motive i.castSucc ‚Üí motive i.succ} {i : Fin (m + 1)} :
      induction (motive := motive) zero succ ‚ü®i, by omega‚ü© =
        @induction m (fun j => motive ‚ü®j, by omega‚ü©) zero (fun j x => succ ‚ü®j, by omega‚ü© x) i

theorem coeff_eq_coeff [LawfulBEq R] (p : UniPoly R) (i : ‚Ñï) :
  p.trim.coeff i = p.coeff i

lemma min_dist_le_d [Field F] {B : Finset (Fin n ‚Üí F)} (v : Fin n ‚Üí F)
  :
  sInf { d | ‚àÉ u ‚àà B, ‚àÉ v ‚àà B, u ‚â† v ‚àß hammingDist u v = d } ‚â§ d B

lemma getBit_eq_succ_getBit_of_mul_two_add_one {n k : ‚Ñï} : getBit (k+1) (2*n + 1) = getBit k n

@[simp]
theorem insertNth_removeNth : insertNth p y (removeNth p t) = update t p y

@[simp, grind] lemma N_pos : 0 < sz.N

theorem singletonBound [CommRing F] [StrongRankCondition F]
  (LC : LinearCode Œπ F) :
  dim LC ‚â§ length LC - Code.minDist (LC : Set (Œπ ‚Üí F)) + 1

omit [DecidableEq L] [Fintype ùîΩq] h_Fq_char_prime hŒ≤_lin_indep in
lemma normalizedW‚ÇÄ_eq_1_div_Œ≤‚ÇÄ : normalizedW (ùîΩq := ùîΩq) (Œ≤ := Œ≤) (i :=0) = X * C (1 / (Œ≤ 0))

@[simp]
theorem dcast‚ÇÇ_trans (ha : a = a') (ha' : a' = a'')
    (hb : dcast ha b = b') (hb' : dcast ha' b' = b'') :
      dcast‚ÇÇ ha' hb' (dcast‚ÇÇ ha hb c) = dcast‚ÇÇ (ha.trans ha') (by simp [‚Üê hb', ‚Üê hb]) c

lemma Z_square_eq (k : ‚Ñï) (prevBTFieldProps : ConcreteBTFieldProps (k := k))
    (curBTFieldProps : ConcreteBTFieldProps (k := (k + 1))) :
  letI : Field (ConcreteBTField (k + 1)) := mkFieldInstance curBTFieldProps
  (Z (k + 1)) ^ 2 = „Ää Z (k), 1 „Äã

theorem fcons_left_injective {Œ≤ : Fin n ‚Üí A} (b : (i : Fin n) ‚Üí F (Œ≤ i)) :
    Function.Injective (fun (a : F Œ±) => fcons a b)

@[simp]
lemma degree_polynomialOfCoeffs_deg_lt_deg :
  (polynomialOfCoeffs coeffs).degree < deg

theorem BerlekampWelchCondition_iff_Solution {e k : ‚Ñï} [NeZero n]
  {œâs f : Fin n ‚Üí F} {v : Fin (2 * e + k) ‚Üí F}
  :
  IsBerlekampWelchSolution e k œâs f v
  ‚Üî
  (BerlekampWelchCondition e k œâs f (solutionToE e k v) (solutionToQ e k v))

lemma C_injective : Function.Injective (C : R ‚Üí P)

omit [Finite F] in
lemma pow_2_pow_i_mem_Di_of_mem_D :
  ‚àÄ {x : FÀ£} (i : ‚Ñï),
    x ‚àà D ‚Üí x ^ (2 ^ i) ‚àà evalDomain D i

@[simp]
theorem cast_id : ChallengeIdx.cast (Eq.refl n‚ÇÅ) rfl = (id : pSpec‚ÇÅ.ChallengeIdx ‚Üí _)

omit h_Œ≤‚ÇÄ_eq_1 in
theorem sDomainFin_bijective (i : Fin r) (h_i : i < ‚Ñì + R_rate)
: Function.Bijective
  (sDomainFinEquiv ùîΩq Œ≤ h_‚Ñì_add_R_rate i h_i)

omit [Fintype L] [Fintype ùîΩq] h_Fq_char_prime in
lemma finrank_U (i : Fin r) :
  Module.finrank ùîΩq (U ùîΩq Œ≤ i) = i

lemma forwardRange_tail (n : ‚Ñï) (r : Fin n) (l : Fin (r.val + 1)) (h_l_gt_0 : l.val > 0) :
  (forwardRange n r ‚ü®l.val - 1, by omega‚ü©).tail = forwardRange n r l

@[simp]
theorem simulateQ_bind_fst (oa : OracleComp spec Œ±) (f : Œ± ‚Üí OracleComp spec Œ≤) :
    (do let a ‚Üê (simulateQ loggingOracle oa).run; f a.1) = oa >>= f

lemma toCodewordsCount_mul_œë_lt_‚Ñì (‚Ñì œë : ‚Ñï) [NeZero œë] [NeZero ‚Ñì] (i : Fin (‚Ñì + 1)) :
  ‚àÄ j: Fin (toOutCodewordsCount ‚Ñì œë i), j.val * œë < ‚Ñì

lemma runWithOracle_buildMerkleTree {s} (leaf_data_tree : LeafData Œ± s) (f) :
    (runWithOracle f (buildMerkleTree leaf_data_tree))
    = buildMerkleTree_with_hash leaf_data_tree fun (left right : Œ±) =>
      (f () ‚ü®left, right‚ü©)

theorem cast_eq_dcast {m n : ‚Ñï} (h : m = n) (a : Fin m) :
    Fin.cast h a = dcast h a

@[simp]
theorem BTField.RingHom_eq_of_dest_eq (k m n : ‚Ñï) (h_eq : m = n) :
  (BTField k ‚Üí+* BTField m) = (BTField k ‚Üí+* BTField n)

@[simp]
theorem Verifier.id_knowledgeSoundness {rel : Set (StmtIn √ó WitIn)} :
    (Verifier.id : Verifier oSpec _ _ _).knowledgeSoundness init impl rel rel 0

private lemma Monad.map_of_prod_fst_eq_prod_fst {m : Type u ‚Üí Type v} [Monad m] [LawfulMonad m]
    {Œ± Œ≤ Œ≥ : Type u} (ma : m (Œ± √ó Œ≤)) (c : Œ≥) :
    (fun a => (c, a.1)) <$> ma = Prod.mk c <$> Prod.fst <$> ma

omit [Finite F] in
private lemma op_der_eq : Monoid.toMulAction FÀ£ = Units.mulAction'

@[simp]
theorem LeafData.optionComposeBuild_leaf {Œ±} (a : Œ±)
    (compose : Œ± ‚Üí Œ± ‚Üí Option Œ±) :
    (LeafData.leaf a).optionComposeBuild compose = FullData.leaf (.some a)

theorem prime_41 : Nat.Prime 41

lemma oodSampling_crs_eq_rs
    {f : Œπ ‚Üí F} {m s : ‚Ñï} {œÜ : Œπ ‚Ü™ F} [Smooth œÜ]
    (l Œ¥ : ‚Ñù‚â•0) (hŒ¥Le : Œ¥ ‚â§ 1)
    {C : Set (Œπ ‚Üí F)} (hcode : C = smoothCode œÜ m ‚àß listDecodable C Œ¥ l) :
    Pr_{ let rs ‚Üê$·µñ (Fin s ‚Üí F) }[ (‚àÉ œÉ : Fin s ‚Üí F,
                        let w : Fin s ‚Üí MvPolynomial (Fin (m + 1)) F :=
                          fun i =>
                            let ri := rs i
                            let rVec := fun j : Fin m => ri ^ (2^(j : ‚Ñï))
                            MvPolynomial.X (Fin.last m) * rename Fin.castSucc (eqPolynomial rVec)
                        let multiCRSCode := multiConstrainedCode œÜ m s w œÉ
                        ‚àÉ u u' : Œπ ‚Üí F, u ‚â† u' ‚àß
                          u ‚àà relHammingBall multiCRSCode f Œ¥ ‚àß
                          u' ‚àà relHammingBall multiCRSCode f Œ¥)]
    =
    Pr_{ let rs ‚Üê$·µñ (Fin s ‚Üí F) }[ (‚àÉ u u' : smoothCode œÜ m,
                        u.val ‚â† u'.val ‚àß
                        u.val ‚àà relHammingBall C f Œ¥ ‚àß
                        u'.val ‚àà relHammingBall C f Œ¥ ‚àß
                        ‚àÄ i : Fin s,
                          let ri := rs i
                          let rVec := fun j : Fin m => ri ^ (2^(j : ‚Ñï))
                          (mVdecode u).eval (rVec) = (mVdecode u').eval (rVec))]

@[simp]
theorem list_nonempty (k : ‚Ñï) : (list k).1 ‚â† []

omit [Fintype F] in
private lemma hamming_weight_eq_sum [Zero F] {x : Fin n ‚Üí F}
  :
  ‚Äñx‚Äñ‚ÇÄ = ‚àë i, if x i = 0 then 0 else 1

@[simp]
theorem take_rtake_append {Œ± : Sort*} (m : ‚Ñï) (h : m ‚â§ n) (v : Fin n ‚Üí Œ±) :
    Fin.append (take m h v) (rtake (n - m) (by omega) v) = fun i => v (i.cast (by omega))

theorem zero_lt_pow_n (m : ‚Ñï) (n : ‚Ñï) (h_m : m > 0): 0 < m^n

theorem verifier_rbr_knowledge_soundness :
    (verifier oSpec Statement pred).rbrKnowledgeSoundness init impl
      (relIn Statement pred) (relOut Statement) 0

@[simp]
theorem fflatten_one {A : Sort u} {F : A ‚Üí Sort v} {n : Fin 1 ‚Üí ‚Ñï}
    {Œ± : (i : Fin 1) ‚Üí (j : Fin (n i)) ‚Üí A}
    {v : (i : Fin 1) ‚Üí (j : Fin (n i)) ‚Üí F (Œ± i j)} :
    fflatten v = v 0

lemma Z_ne_zero {k : ‚Ñï} : Z k ‚â† zero

theorem prime_5 : Nat.Prime 5

@[simp]
lemma dfoldrM'_zero {Œ± : Fin 1 ‚Üí Type u}
    (f : (i : Fin 0) ‚Üí Œ± i.succ ‚Üí m (Œ± i.castSucc)) (x : Œ± (last 0)) :
    dfoldrM' 0 Œ± f x = pure x

@[simp] lemma mod_two_eq_zero (m : ‚Ñ§) : m % 2 = ( - m) % 2

@[simp]
lemma foldl'_zero {Œ± : Type u} (f : (i : Fin 0) ‚Üí Œ± ‚Üí Œ±) (x : Œ±) :
    foldl' 0 f x = x

@[simp]
lemma Rhs_zero_eq_neg : Rhs 0 œâs f i = -f i

lemma U_card (i : Fin r) :
    Fintype.card (U ùîΩq Œ≤ i) = (Fintype.card ùîΩq)^i.val

lemma E_and_Q_unique
  [NeZero n]
  {e k : ‚Ñï}
  {E Q E' Q' : Polynomial F}
  {œâs f : Fin n ‚Üí F}
  (he : 2 * e < n - k + 1)
  (hk_n : k ‚â§ n)
  (h_Q : Q ‚â† 0)
  (h_Q' : Q' ‚â† 0)
  (h_inj : Function.Injective œâs)
  (h_bw‚ÇÅ : BerlekampWelchCondition e k œâs f E Q)
  (h_bw‚ÇÇ : BerlekampWelchCondition e k œâs f E' Q')
: E * Q' = E' * Q

omit [NeZero ‚Ñì] [NeZero r] [NeZero ùì°] in
lemma ‚Ñì_lt_r {h_‚Ñì_add_R_rate : ‚Ñì + ùì° < r}
    : ‚Ñì < r

@[simp] lemma natCast_eq {k : ‚Ñï} (n : ‚Ñï) : (‚Üën : ConcreteBTField k) = natCast n

@[to_additive (attr := simp) vsum_succ]
lemma vprod_succ [CommMonoid Œ±] {a : Fin (n + 1) ‚Üí Œ±} : vprod a = a 0 * vprod (a ‚àò Fin.succ)

@[simp]
theorem OracleVerifier.run_eq_run_verifier [O‚Çò : ‚àÄ i, OracleInterface (pSpec.Message i)]
    {stmt : StmtIn} {oStmt : ‚àÄ i, OStmtIn i} {transcript : FullTranscript pSpec}
    {verifier : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec} :
      verifier.run stmt oStmt transcript =
        verifier.toVerifier.run ‚ü®stmt, oStmt‚ü© transcript

theorem hcons_eq_cons {Œ≤ : Fin n ‚Üí Sort u} (a : Œ±) (v : (i : Fin n) ‚Üí Œ≤ i) :
    hcons a v = cons (Œ± := vcons Œ± Œ≤) (hcons a v 0) (fun i => hcons a v i.succ)

omit [DecidableEq Œ±] [Inhabited Œ±] [Fintype Œ±] in
@[simp]
lemma Cache.leaves_cons (n : ‚Ñï) (leaves : List.Vector Œ± (2 ^ (n + 1))) (cache : Cache Œ± n) :
    Cache.leaves Œ± n (Cache.cons Œ± n leaves cache) = leaves

@[simp]
theorem verifier_rbrKnowledgeSoundness :
    (verifier oSpec Statement).rbrKnowledgeSoundness init impl rel rel 0

theorem natDegree_finSuccEquivNth (f : MvPolynomial (Fin (n + 1)) R) :
    (finSuccEquivNth R p f).natDegree = degreeOf p f

@[simp]
theorem drop_one {Œ± : Fin (n + 1) ‚Üí Sort*} (v : (i : Fin (n + 1)) ‚Üí Œ± i) :
    drop 1 (Nat.le_add_left 1 n) v = tail v

lemma xor_by_split_lowBits {n m n1 m1 bn bm : ‚Ñï} (h_bn : bn < 2) (h_bm : bm < 2)
  (h_n : n = n1 * 2 + bn) (h_m : m = m1 * 2 + bm):
  n ^^^ m = (n1 ^^^ m1) * 2 + (bn ^^^ bm)

theorem liftContext_processRound
    {lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    {i : Fin n}
    {P : Prover oSpec InnerStmtIn InnerWitIn InnerStmtOut InnerWitOut pSpec}
    {resultRound : OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí)
      (pSpec.Transcript i.castSucc √ó (P.liftContext lens).PrvState i.castSucc)} :
      (P.liftContext lens).processRound i resultRound
      = do
        let ‚ü®transcript, prvState, outerStmtIn, outerWitIn‚ü© ‚Üê resultRound
        let ‚ü®newTranscript, newPrvState‚ü© ‚Üê P.processRound i (do return ‚ü®transcript, prvState‚ü©)
        return ‚ü®newTranscript, ‚ü®newPrvState, outerStmtIn, outerWitIn‚ü©‚ü©

@[simp]
theorem vappend_left (u : Fin m ‚Üí Œ±) (v : Fin n ‚Üí Œ±) (i : Fin m) :
    vappend u v (castAdd n i) = u i

omit [SelectableType R] in
@[simp]
lemma reduction_verifier_eq_verifier {i : Fin n} :
    (reduction R n deg D oSpec i).verifier = verifier R n deg D oSpec i

lemma take_eq_take : transcript‚ü¶:m‚üß = transcript.take m h

theorem randomOracle_neverFails_iff_runWithOracle_neverFails {Œ≤}
    [DecidableEq Œπ] [spec.DecidableEq] [(i : Œπ) ‚Üí SelectableType (OracleSpec.range spec i)]
    (oa : OracleComp (spec) Œ≤)
    :
    (‚àÄ (preexisting_cache : spec.QueryCache),
      ((oa.simulateQ randomOracle).run preexisting_cache).neverFails)
    ‚Üî
    (‚àÄ (f : spec.FunctionType),
      (runWithOracle f oa).isSome)

theorem eq_zero_or_eq_one {a : ConcreteBTField 0} : a = zero ‚à® a = one

lemma concrete_mul_left_distrib0 (a b c : ConcreteBTField 0) :
  concrete_mul a (b + c) = concrete_mul a b + concrete_mul a c

theorem addCases_right' {motive : Fin (m + n) ‚Üí Sort*}
    {left : (i : Fin m) ‚Üí motive (castAdd n i)} {right : (j : Fin n) ‚Üí motive (natAdd m j)}
    {i : Fin n} (j : Fin (m + n)) (h : j = natAdd m i) :
      addCases (motive := motive) left right j = h ‚ñ∏ (right i)

@[simp]
theorem Ici_zero : Ici (0 : Fin (n + 1)) = univ

@[simp]
lemma Transcript.def_eq {k : Fin (n + 1)} {pSpec : ProtocolSpec n} :
    (pSpec.take k k.is_le).FullTranscript =
      ((i : Fin k) ‚Üí pSpec.¬´Type¬ª (Fin.castLE (by omega) i))

theorem ZMod.bla : ‚àÄ {n c : ‚Ñï} (a : ZMod n), c = 1 ‚Üí IsNat (a ^ (n - 1)) c ‚Üí a ^ (n - 1) = 1

theorem neg_trim [LawfulBEq R] (p : UniPoly R) : p.trim = p ‚Üí (-p).trim = -p

lemma discr_of_irred_components_nonzero
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  : ‚àÉ x‚ÇÄ,
      ‚àÄ R ‚àà (irreducible_factorization_of_gs_solution h_gs).choose_spec.choose,
      Bivariate.evalX x‚ÇÄ (Bivariate.discr_y R) ‚â† 0

@[simp]
theorem LeafData.get_ofRight {s_left s_right : Skeleton} {Œ± : Type}
    (tree : LeafData Œ± (Skeleton.internal s_left s_right))
    (idxRight : SkeletonLeafIndex s_right) :
    tree.get (SkeletonLeafIndex.ofRight idxRight) =
      tree.rightSubtree.get idxRight

lemma coeff_toPoly {p : UniPoly Q} {n : ‚Ñï} : p.toPoly.coeff n = p.coeff n

omit [NeZero ‚Ñì] [NeZero r] [NeZero ùì°] in
lemma fin_‚Ñì_lt_‚Ñì_add_R (i : Fin ‚Ñì)
    : i.val < ‚Ñì + ùì°

theorem induction_heq {n n' : ‚Ñï} {motive : Fin (n + 1) ‚Üí Sort u} {motive' : Fin (n' + 1) ‚Üí Sort u}
    {zero : motive 0} {zero' : motive' 0}
    {succ : ‚àÄ i : Fin n, motive i.castSucc ‚Üí motive i.succ}
    {succ' : ‚àÄ i : Fin n', motive' i.castSucc ‚Üí motive' i.succ}
    {i : Fin (n + 1)} {i' : Fin (n' + 1)}
    (hn : n = n') (hmotive : HEq motive motive') (hzero : HEq zero zero')
    (hsucc : HEq succ succ') (hi : HEq i i') :
      HEq (induction (motive := motive) zero succ i)
        (induction (motive := motive') zero' succ' i')

theorem lagrangeBasis_getElem {w : Vector R n} (i : Fin (2 ^ n)) :
    (lagrangeBasis w)[i] = ‚àè j : Fin n, if (BitVec.ofFin i).getLsb j then w[j] else 1 - w[j]

lemma join_eq_join_iff (k : ‚Ñï) (h_pos : k > 0) (hi‚ÇÅ hi‚ÇÄ lo‚ÇÅ lo‚ÇÄ : BTField (k - 1)) :
    ‚ãò hi‚ÇÅ, lo‚ÇÅ ‚ãô = ‚ãò hi‚ÇÄ, lo‚ÇÄ ‚ãô ‚Üî
  hi‚ÇÅ = hi‚ÇÄ ‚àß lo‚ÇÅ = lo‚ÇÄ

theorem decoder_dist_impl_mem
  {k r D e : ‚Ñï}
  (h_e : e ‚â§ n - Real.sqrt (k * n))
  {œâs : Fin n ‚Ü™ F}
  {f : Fin n ‚Üí F}
  {p : F[X]}
  (h_dist : Œî‚ÇÄ(f, p.eval ‚àò œâs) ‚â§ e)
  :
  p ‚àà decoder k r D e œâs f

theorem support_finSuccEquivNth (f : MvPolynomial (Fin (n + 1)) R) :
    (finSuccEquivNth R p f).support = Finset.image (fun m : Fin (n + 1) ‚Üí‚ÇÄ ‚Ñï => m p) f.support

lemma zero_is_0 {k : ‚Ñï} : (zero (k:=k)) = (0 : ConcreteBTField k)

omit [Fintype F] in
private lemma d_eq_sum {B : Finset (Fin n ‚Üí F)}
  (h_B : 2 ‚â§ B.card)
  :
  2 * choose_2 B.card * d B =
  ‚àë i, ‚àë x ‚àà B √óÀ¢ B with x.1 ‚â† x.2, (if x.1 i ‚â† x.2 i then 1 else 0)

theorem oracleVerifier_rbrKnowledgeSoundness [Fintype R] :
    (oracleReduction R deg oSpec).verifier.rbrKnowledgeSoundness init impl
      (inputRelation R deg D) (outputRelation R deg)
        (fun _ => (deg : ‚Ñù‚â•0) / (Fintype.card R))

theorem eqPolynomial_symm (x : œÉ ‚Üí R) (y : œÉ ‚Üí R) :
    MvPolynomial.eval y (eqPolynomial x) = MvPolynomial.eval x (eqPolynomial y)

@[simp]
lemma evenPart_by_2 :
  2 * (evenPart f) = f + f.comp (-X)

@[simp]
theorem FullData.get_leaf {Œ±} (a : Œ±) :
    (FullData.leaf a).get SkeletonNodeIndex.ofLeaf = a

theorem join_add_join {k : ‚Ñï} (h_pos : k > 0) (hi‚ÇÄ lo‚ÇÄ hi‚ÇÅ lo‚ÇÅ : ConcreteBTField (k - 1)) :
  „Ää hi‚ÇÄ, lo‚ÇÄ „Äã + „Ää hi‚ÇÅ, lo‚ÇÅ „Äã = „Ää hi‚ÇÄ + hi‚ÇÅ, lo‚ÇÄ + lo‚ÇÅ „Äã

@[simp]
lemma seqCompose_succ {m : ‚Ñï}
    (Stmt : Fin (m + 2) ‚Üí Type) (Wit : Fin (m + 2) ‚Üí Type)
    {n : Fin (m + 1) ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (P : (i : Fin (m + 1)) ‚Üí
      Prover oSpec (Stmt i.castSucc) (Wit i.castSucc) (Stmt i.succ) (Wit i.succ) (pSpec i)) :
    seqCompose Stmt Wit P =
      append (P 0) (seqCompose (Stmt ‚àò Fin.succ) (Wit ‚àò Fin.succ) (fun i => P (Fin.succ i)))

@[simp]
theorem removeNth_zero : removeNth 0 s = tail s

lemma add_zero {k : ‚Ñï} (a : ConcreteBTField k) : a + 0 = a

@[simp] theorem equiv_symm {p q : UniPoly Q} : equiv p q ‚Üí equiv q p

omit [Fintype F] [DecidableEq F] in
private lemma choose_2_card_ne_zero (h : 2 ‚â§ B.card) : choose_2 ‚ÜëB.card ‚â† 0

omit [DecidableEq ùîΩq] hF‚ÇÇ in
lemma initial_tiled_coeffs_correctness (h_‚Ñì : ‚Ñì ‚â§ r) (a : Fin (2 ^ ‚Ñì) ‚Üí L) :
    let b: Fin (2^(‚Ñì + R_rate)) ‚Üí L := tileCoeffs a
    additiveNTTInvariant ùîΩq Œ≤ h_‚Ñì_add_R_rate b a (i := ‚ü®‚Ñì, by omega‚ü©)

@[simp]
theorem cast_id : ProtocolSpec.cast (Eq.refl n‚ÇÅ) = id

@[simp]
lemma seqCompose_succ {m : ‚Ñï}
    (Stmt : Fin (m + 2) ‚Üí Type)
    {Œπ‚Çõ : Fin (m + 2) ‚Üí Type} (OStmt : (i : Fin (m + 2)) ‚Üí Œπ‚Çõ i ‚Üí Type)
    [O‚Çõ : ‚àÄ i, ‚àÄ j, OracleInterface (OStmt i j)]
    (Wit : Fin (m + 2) ‚Üí Type)
    {n : Fin (m + 1) ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    [O‚Çò : ‚àÄ i, ‚àÄ j, OracleInterface ((pSpec i).Message j)]
    (R : (i : Fin (m + 1)) ‚Üí
      OracleReduction oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Wit i.castSucc)
        (Stmt i.succ) (OStmt i.succ) (Wit i.succ) (pSpec i)) :
    seqCompose Stmt OStmt Wit R =
      append (R 0) (seqCompose (Stmt ‚àò Fin.succ) (fun i => OStmt (Fin.succ i)) (Wit ‚àò Fin.succ)
        (O‚Çõ := fun i => O‚Çõ (Fin.succ i)) (O‚Çò := fun i => O‚Çò (Fin.succ i))
          (fun i => R (Fin.succ i)))

@[simp]
theorem hcons_fin_zero {Œ± : Sort u} {Œ≤ : Fin 0 ‚Üí Sort u} (a : Œ±) (v : (i : Fin 0) ‚Üí Œ≤ i) :
    hcons a v = fun i => match i with

@[simp]
lemma ofPolynomialAlgHom_X : ofPolynomialAlgHom (Polynomial.X : R[X]) = (X : P)

lemma concrete_mul_right_distrib
  {h_k : k > 0} (prevBTFieldProps : ConcreteBTFieldProps (k := k - 1))
  (a b c : ConcreteBTField k) :
    concrete_mul (a + b) c = concrete_mul a c + concrete_mul b c

@[simp]
theorem vappend_vcons (a : Œ±) (u : Fin m ‚Üí Œ±) (v : Fin n ‚Üí Œ±) :
    vappend (vcons a u) v = (vcons a (vappend u v)) ‚àò Fin.cast (Nat.succ_add m n)

@[simp]
theorem fflatten_succ {A : Sort u} {F : A ‚Üí Sort v} {m : ‚Ñï} {n : Fin (m + 1) ‚Üí ‚Ñï}
    {Œ± : (i : Fin (m + 1)) ‚Üí (j : Fin (n i)) ‚Üí A}
    {v : (i : Fin (m + 1)) ‚Üí (j : Fin (n i)) ‚Üí F (Œ± i j)} :
    fflatten v = fappend (v 0) (fflatten (fun i => v i.succ))

theorem fixFirstVariablesOfMQP_degreeLE {deg : ‚Ñï} (v : Fin (‚Ñì + 1)) {challenges : Fin v ‚Üí L}
    {poly : L[X Fin ‚Ñì]} (hp : poly ‚àà L‚¶É‚â§ deg‚¶Ñ[X Fin ‚Ñì]) :
    fixFirstVariablesOfMQP ‚Ñì v poly challenges ‚àà L‚¶É‚â§ deg‚¶Ñ[X Fin (‚Ñì - v)]

lemma fieldSize_sub_one_factorization : fieldSize - 1 = 2 ^ twoAdicity * 127

@[grind =]
theorem monomialXY_eq_monomialXY_iff {n m p q : ‚Ñï} {a b : F} :
  monomialXY n m a = monomialXY p q b ‚Üî n = p ‚àß m = q ‚àß a = b ‚à® a = 0 ‚àß b = 0

theorem oracleReduction_perfectCompleteness (hInit : init.neverFails) :
    (oracleReduction R n deg D oSpec i).perfectCompleteness init impl
      (relationRound R n deg D i.castSucc) (relationRound R n deg D i.succ)

lemma eval_trim_eq_eval [LawfulBEq R] (x : R) (p : UniPoly R) : p.trim.eval x = p.eval x

omit [Fintype L] [DecidableEq L] in
theorem Polynomial.comp_same_inner_eq_if_same_outer (f g : L[X]) (h_f_eq_g : f = g) :
  ‚àÄ x, f.comp x = g.comp x

lemma rtake_eq_rtake : transcript‚ü¶m:‚üß = transcript.drop m h

lemma zsmul_neg' {k : ‚Ñï} (n : ‚Ñï) (a : ConcreteBTField k) :
  (if ((Int.negSucc n) : ‚Ñ§) % (2 : ‚Ñ§) = (0 : ‚Ñ§) then zero else a) =
    neg (if (‚Üën.succ : ‚Ñ§) % (2 : ‚Ñ§) = (0 : ‚Ñ§) then zero else a)

theorem findIdxRev?_eq_none {cond} {as : Array Œ±} (h : ‚àÄ i, (hi : i < as.size) ‚Üí ¬¨ cond as[i]) :
  findIdxRev? cond as = none

theorem append_comp' {a : Fin m ‚Üí Œ±} {b : Fin n ‚Üí Œ±} (f : Œ± ‚Üí Œ≤)
    (i : Fin (m + n)) : append (f ‚àò a) (f ‚àò b) i = f (append a b i)

lemma split_join_via_add_smul_eq_iff_split {k : ‚Ñï} (h_pos : k > 0)
    (hi_btf lo_btf : ConcreteBTField (k - 1)) :
    split (k:=k) (h:=by omega) (x:=join_via_add_smul (k:=k) (h_pos:=h_pos) hi_btf lo_btf) =
      (hi_btf, lo_btf)

Nat.lt_trans in Init.Prelude

@[simp]
theorem finSuccEquivNth_X_above {i : Fin n} (h : p < i.succ) :
    finSuccEquivNth R p (X i.succ) = Polynomial.C (X i)

omit [SelectableType R] in
@[simp]
lemma oracleReduction_verifier_eq_verifier {i : Fin n} :
    (oracleReduction R n deg D oSpec i).verifier = oracleVerifier R n deg D oSpec i

lemma guruswami_sudan_for_proximity_gap_property {k m : ‚Ñï} {œâs : Fin n ‚Ü™ F}
  {w : Fin n ‚Üí F}
  {Q : F[X][Y]}
  (cond : Condition (k + 1) m (proximity_gap_degree_bound ((k + 1 : ‚Ñö) / n) m n) œâs w Q)
  {p : ReedSolomon.code œâs n}
  (h : Œ¥·µ£(w, p) ‚â§ proximity_gap_johnson ((k + 1 : ‚Ñö) / n) m)
  :
  (X - Polynomial.C (ReedSolomon.codewordToPoly p)) ‚à£ Q

theorem heq_of_dcast (ha : a = a') (hb : dcast ha b = b') : HEq b b'

@[simp]
theorem LeafData.leftSubtree_internal {Œ±} {s_left s_right : Skeleton}
    (left : LeafData Œ± s_left) (right : LeafData Œ± s_right) :
    (LeafData.internal left right).leftSubtree = left

@[simp]
protected lemma elocPolyF_leading_coeff_one {œâs f : Fin n ‚Üí F}
  : (ElocPolyF œâs f p).leadingCoeff = 1

theorem hcons_happend_comm {Œ≤ : Fin m ‚Üí Sort u} {Œ≥ : Fin n ‚Üí Sort u}
    (a : Œ±) (u : (i : Fin m) ‚Üí Œ≤ i) (v : (i : Fin n) ‚Üí Œ≥ i) :
    True

private lemma Fis_pairwise_disjoint : Set.PairwiseDisjoint Set.univ (Fi B i)

theorem mul_zero {a : CNat 50} : a * 0 = 0

theorem funext_heq_iff {Œ± Œ±' : Sort u} {Œ≤ : Œ± ‚Üí Sort v} {Œ≤' : Œ±' ‚Üí Sort v}
    {f : (x : Œ±) ‚Üí Œ≤ x} {g : (x : Œ±') ‚Üí Œ≤' x} (ha : Œ± = Œ±') (hb : ‚àÄ x, Œ≤ x = Œ≤' (cast ha x)) :
      HEq f g ‚Üî ‚àÄ x, HEq (f x) (g (cast ha x))

theorem cast_injective : Function.Injective (ChallengeIdx.cast hn hSpec)

theorem degrees_peval {x : œÉ‚ÇÅ ‚Üí R} {f : œÉ ‚Üí œÉ‚ÇÅ ‚äï œÉ‚ÇÇ} {p : MvPolynomial œÉ R} :
    (peval f x p).degrees ‚â§ (p.degrees.map f).filterMap Sum.getRight?

@[simp]
theorem vflatten_two_eq_append {n : Fin 2 ‚Üí ‚Ñï} {v : (i : Fin 2) ‚Üí Fin (n i) ‚Üí Œ±} :
    vflatten v = vappend (v 0) (v 1)

protected lemma elocPolyF_ne_zero {œâs f : Fin m ‚Üí F} :
  ElocPolyF œâs f p ‚â† 0

@[simp]
theorem dcons_zero {motive : Fin (n + 1) ‚Üí Sort u} (a : motive 0)
    (v : (i : Fin n) ‚Üí motive i.succ) : (a ::·µà‚ü®motive‚ü© v) 0 = a

lemma getBit_joinBits {n m k : ‚Ñï} (low : Fin (2 ^ n)) (high : Fin (2 ^ m)) :
  getBit k (joinBits low high).val =
    if k < n then getBit k low.val else getBit (k - n) high.val

@[simp]
theorem vflatten_splitSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (v : (k : Fin (vsum n)) ‚Üí Œ±) (k : Fin (vsum n)) :
    vflatten (fun i j => v (embedSum i j)) k = v k

@[simp]
lemma seqCompose_toVerifier {m : ‚Ñï}
    (Stmt : Fin (m + 1) ‚Üí Type)
    {Œπ‚Çõ : Fin (m + 1) ‚Üí Type} (OStmt : (i : Fin (m + 1)) ‚Üí Œπ‚Çõ i ‚Üí Type)
    [O‚Çõ : ‚àÄ i, ‚àÄ j, OracleInterface (OStmt i j)]
    {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    [O‚Çò : ‚àÄ i, ‚àÄ j, OracleInterface ((pSpec i).Message j)]
    (V : (i : Fin m) ‚Üí
      OracleVerifier oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Stmt i.succ) (OStmt i.succ)
        (pSpec i)) :
    (seqCompose Stmt OStmt V).toVerifier =
      Verifier.seqCompose (fun i => Stmt i √ó (‚àÄ j, OStmt i j)) (fun i => (V i).toVerifier)

theorem BitVec.dcast_bitvec_eq_zero {l r : ‚Ñï} (h_width_eq : l = r) :
  dcast (h_width_eq) 0#(l) = 0#(r)

lemma dappend_left_of_lt {motive : Fin (m + n) ‚Üí Sort u}
    (u : (i : Fin m) ‚Üí motive (castAdd n i)) (v : (i : Fin n) ‚Üí motive (natAdd m i))
    (i : Fin (m + n)) (h : i.val < m) :
      dappend (motive := motive) u v i = cast (by simp) (u ‚ü®i, h‚ü©)

theorem insertNth_self_removeNth : insertNth p (t p) (removeNth p t) = t

theorem vconcat_right_injective (v : Fin n ‚Üí Œ±) : Function.Injective (vconcat v)

@[simp]
theorem InternalData.ofFun_get {Œ±} {s} (tree : InternalData Œ± s) :
    InternalData.ofFun s (fun idx => tree.get idx) = tree

@[simp] theorem fromNat_toNat_eq_self {k : ‚Ñï} (bv : BitVec (2 ^ k)) :
  (fromNat (BitVec.toNat bv) : ConcreteBTField k) = bv

@[simp]
theorem rightpad_apply_ge (n : ‚Ñï) (a : Œ±) (v : Fin m ‚Üí Œ±) (i : Fin n)
    (h : m ‚â§ i.val) : rightpad n a v i = a

omit [Finite F] in
lemma pow_lift : ‚àÄ {a : FÀ£} {i : ‚Ñï} (s : ‚Ñï),
    a ‚àà evalDomain D x i ‚Üí a ^ (2 ^ s) ‚àà evalDomain D x (i + s)

@[simp]
theorem splitSum_embedSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (i : Fin m) (j : Fin (n i)) :
    splitSum (embedSum i j) = ‚ü®i, j‚ü©

lemma wt_eq_hammingNorm [Zero F] {v : Œπ ‚Üí F} :
  wt v = hammingNorm v

private lemma evenPart_eq_evenPart' {f : Polynomial F} : evenPart f = evenPart' f

@[simp]
lemma seqCompose_zero (Stmt : Fin 1 ‚Üí Type) (Wit : Fin 1 ‚Üí Type)
    {n : Fin 0 ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (R : (i : Fin 0) ‚Üí
      Reduction oSpec (Stmt i.castSucc) (Wit i.castSucc) (Stmt i.succ) (Wit i.succ) (pSpec i)) :
    seqCompose Stmt Wit R = Reduction.id

@[simp]
theorem embedSum_splitSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (k : Fin (vsum n)) :
    embedSum (splitSum k).1 (splitSum k).2 = k

theorem completeness [DecidableEq Œ±] [SelectableType Œ±] {s}
    (leaf_data_tree : LeafData Œ± s) (idx : BinaryTree.SkeletonLeafIndex s)
    (preexisting_cache : (spec Œ±).QueryCache) :
    (((do
      let cache ‚Üê buildMerkleTree leaf_data_tree
      let proof := generateProof cache idx
      let _ ‚Üê verifyProof idx (leaf_data_tree.get idx) (cache.getRootValue) proof
      ).simulateQ (randomOracle)).run preexisting_cache).neverFails

@[csimp]
theorem vappend_eq_append : @vappend = @append

@[simp]
theorem cast_perfectCompleteness (hComplete : R.perfectCompleteness init impl relIn relOut) :
    (R.cast hn hSpec).perfectCompleteness init impl relIn relOut

theorem castSum_castAdd {n m : ‚Ñï} (i : Fin n) : castSum [n, m] (by simp) i = castAdd m i

@[simp]
theorem verifier_first (pSpec : ProtocolSpec n) [NeZero n] [h : VerifierFirst pSpec] :
    pSpec.dir 0 = .V_to_P

theorem insertNth_support :
    (insertNth p y s).support ‚äÜ insert p (s.support.map (Fin.succAboveEmb p))

lemma degree_definingPoly {F : Type*} [Field F] [Fintype F] (s : F) [NeZero s] :
  (definingPoly s).degree = 2

theorem matchSize_toList {a b : Array Œ±} {unit : Œ±} :
    matchSize a b unit =
      let (a', b') := List.matchSize a.toList b.toList unit
      (mk a', mk b')

omit [Finite F] in
lemma minus_one_in_doms {i : ‚Ñï} (h : i < n) :
    -1 ‚àà evalDomain D i

lemma H_tilde_equiv_H_tilde' (H : F[X][Y]) : (H_tilde' H).map univPolyHom = H_tilde H

@[simp]
theorem vcons_fin_zero (a : Œ±) (v : Fin 0 ‚Üí Œ±) : a ::·µõ v = fun i => match i with

@[simp]
theorem add_accepts_iff : (add a b c).accepts x ‚Üî x c = x a + x b

lemma eq_zero_or_eq_one_of_lt_two {n : ‚Ñï} (h_lt : n < 2) : n = 0 ‚à® n = 1

lemma coe_one_succ (l : ‚Ñï) :
    (@ConcreteBTFieldAlgebra (l:=l) (r:=l + 1) (h_le:=by omega)).algebraMap
    (1 : ConcreteBTField l) = (1 : ConcreteBTField (l + 1))

theorem ZMod.powNeOfPowMod :
    ‚àÄ {n a' q c : ‚Ñï} (a : ZMod n), (a' : ZMod n) = a ‚Üí decide (n ‚â• 2) = true ‚Üí
      Nat.mod (Nat.pow a' ((n - 1) / q)) n = c ‚Üí decide (c ‚â† 1) = true ‚Üí a ^ ((n - 1) / q) ‚â† 1

@[simp]
lemma eval‚ÇÇAlgHom_apply {A : Type w} {B : Type*} [CommSemiring A] [CommSemiring B]
    [PolynomialLike A P] [Algebra R A] [IsScalarTower R A P] [Algebra R B]
    (f : A ‚Üí‚Çê[R] B) (b : B) (p : P) :
    (eval‚ÇÇAlgHom f b) p = eval‚ÇÇ f b p

theorem srKnowledgeSoundness_implies_knowledgeSoundness
    (relIn : Set (StmtIn √ó WitIn)) (relOut : Set (StmtOut √ó WitOut))
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    (srInit : ProbComp (srChallengeOracle StmtIn pSpec).FunctionType)
    (srImpl : QueryImpl oSpec (StateT (srChallengeOracle StmtIn pSpec).FunctionType ProbComp))
    (srKnowledgeError : ‚Ñù‚â•0) :
      Verifier.StateRestoration.knowledgeSoundness srInit srImpl relIn relOut
        verifier srKnowledgeError ‚Üí
      knowledgeSoundness init impl relIn relOut verifier srKnowledgeError

@[simp]
theorem LeafData.ofFun_get {Œ±} {s} (tree : LeafData Œ± s) :
    LeafData.ofFun s (fun idx => tree.get idx) = tree

lemma split_algebraMap_eq_zero_x {k : ‚Ñï} (h_pos : k > 0) (x : ConcreteBTField (k - 1)) :
  letI instAlgebra := ConcreteBTFieldAlgebra (l:=k-1) (r:=k) (h_le:=by omega)
  split h_pos (algebraMap (ConcreteBTField (k - 1)) (ConcreteBTField k) x) = (0, x)

omit [DecidableEq L] [DecidableEq ùîΩq] h_Fq_char_prime hF‚ÇÇ hŒ≤_lin_indep h_Œ≤‚ÇÄ_eq_1 in
lemma intermediateNovelBasisX_zero_eq_one (i : Fin (‚Ñì + 1)) :
    intermediateNovelBasisX ùîΩq Œ≤ h_‚Ñì_add_R_rate i ‚ü®0, by
      exact Nat.two_pow_pos (‚Ñì - ‚Üëi)‚ü© = 1

Nat.pred_lt_self in Init.Data.Nat.Basic

@[simp] lemma twoAdicGenerators_succ_square_eq' (idx : Fin twoAdicity) :
    twoAdicGenerators[idx.val + 1] ^ 2 = twoAdicGenerators[idx]

theorem pow_exp_of_2_repr_given_x_square_repr {F : Type*} [instField : Field F]
  (sumZeroIffEq : ‚àÄ (x y : F), x + y = 0 ‚Üî x = y) (x z : F) (h_z_non_zero : z ‚â† 0)
  (h_x_square : x ^ 2 = x * z + 1)
  : ‚àÄ i : ‚Ñï, x^(2^i) = x * z^(2^i - 1) + ‚àë j ‚àà Finset.Icc 1 i, z^(2^i - 2^j)

@[simp]
theorem bit_finProdFinEquiv_symm_2_pow_succ {n : ‚Ñï} (j : Fin (2 ^ (n + 1))) (i : Fin (n + 1)) :
  let e:=finProdFinEquiv (m:=2^(n)) (n:=2).symm
  Nat.getBit (i) j = if i.val > 0 then Nat.getBit (i.val-1) (e j).1 else (e j).2

@[simp] lemma extract_dir : pSpec‚ü¶start:stop‚üß.dir = pSpec.dir‚ü¶start:stop‚üß

lemma Œæ_regular (x‚ÇÄ : F) (R : F[X][X][Y]) (H : F[X][Y]) [H_irreducible : Fact (Irreducible H)] :
  ‚àÉ pre : ùí™ H,
    let d := R.natDegree
    let W : ùïÉ H := liftToFunctionField (H.leadingCoeff);
    embeddingOfùí™IntoùïÉ _ pre = W ^ (d - 2) * Œ∂ R x‚ÇÄ H

theorem generates_quotient_point_if_is_fiber_of_y
    (i : Fin ‚Ñì) (steps : ‚Ñï) (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
    (x : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i, by omega‚ü©))
    (y : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i.val + steps, by omega‚ü©))
    (hx_is_fiber : ‚àÉ (k : Fin (2 ^ steps)), x = qMap_total_fiber ùîΩq Œ≤ (i := ‚ü®i, by omega‚ü©)
      (steps := steps) (h_i_add_steps := by
        simp only; exact fin_‚Ñì_steps_lt_‚Ñì_add_R i steps h_i_add_steps) (y := y) k) :
    y = iteratedQuotientMap ùîΩq Œ≤ h_‚Ñì_add_R_rate i (k := steps) (h_bound := h_i_add_steps) x

theorem append_perfectCompleteness
    (R‚ÇÅ : OracleReduction oSpec Stmt‚ÇÅ OStmt‚ÇÅ Wit‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ Wit‚ÇÇ pSpec‚ÇÅ)
    (R‚ÇÇ : OracleReduction oSpec Stmt‚ÇÇ OStmt‚ÇÇ Wit‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ Wit‚ÇÉ pSpec‚ÇÇ)
    (h‚ÇÅ : R‚ÇÅ.perfectCompleteness init impl rel‚ÇÅ rel‚ÇÇ)
    (h‚ÇÇ : R‚ÇÇ.perfectCompleteness init impl rel‚ÇÇ rel‚ÇÉ) :
      (R‚ÇÅ.append R‚ÇÇ).perfectCompleteness init impl rel‚ÇÅ rel‚ÇÉ

theorem succ'_injective : Function.Injective (succ' : Nat ‚Üí Nat)

theorem two_le_two_pow_n_plus_1 (n : ‚Ñï) : 2 ‚â§ 2 ^ (n + 1)

theorem knowledgeSoundness_implies_soundness (relIn : Set (StmtIn √ó WitIn))
    (relOut : Set (StmtOut √ó WitOut))
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    (knowledgeError : ‚Ñù‚â•0) (hLt : knowledgeError < 1) :
      knowledgeSoundness init impl relIn relOut verifier knowledgeError ‚Üí
        soundness init impl relIn.language relOut.language verifier knowledgeError

@[simp]
theorem cast_id :
    OracleProver.cast rfl rfl =
      (id : OracleProver oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec‚ÇÅ ‚Üí _)

lemma concrete_exists_pair_ne {k : ‚Ñï} : ‚àÉ x y : ConcreteBTField k, x ‚â† y

lemma algebraMap_adjacent_tower_def (l : ‚Ñï) :
    (algebraMap (ConcreteBTField l) (ConcreteBTField (l + 1))) =
    canonicalAlgMap l

@[simp]
lemma eval‚ÇÇAlgHom_apply {A B : Type*} [CommSemiring A] [CommSemiring B] [MvPolynomialLike œÉ A P]
    [Algebra R A] [IsScalarTower R A P] [Algebra R B]
    (f : A ‚Üí‚Çê[R] B) (g : œÉ ‚Üí B) (p : P) :
    (eval‚ÇÇAlgHom f g) p = eval‚ÇÇ f g p

@[simp]
lemma Rhs_zero_eq_neg' : Rhs 0 œâs f = -f

lemma eq_degree_of_equiv [LawfulBEq R] {p q : UniPoly R} : equiv p q ‚Üí p.degree = q.degree

theorem vcons_inj (a b : Œ±) (v w : Fin n ‚Üí Œ±) : a ::·µõ v = b ::·µõ w ‚Üî a = b ‚àß v = w

@[simp]
lemma toFun_invFun (f : ‚àÄ a, Œ≤ a) : inst.equiv.toFun (equiv.invFun f : F) = f

@[simp]
lemma halfNumFullRounds_mul_2_eq_numFullRounds :
    params.halfNumFullRounds * 2 = params.numFullRounds

theorem append_run (tr : (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).FullTranscript) :
      (V‚ÇÅ.append V‚ÇÇ).run stmt tr =
        (do
          let stmt‚ÇÇ ‚Üê V‚ÇÅ.run stmt tr.fst
          let stmt‚ÇÉ ‚Üê V‚ÇÇ.run stmt‚ÇÇ tr.snd
          return stmt‚ÇÉ)

theorem prime_13 : Nat.Prime 13

lemma sDomain_eq_image_of_upper_span (i : Fin r) (h_i : i < ‚Ñì + R_rate) :
    let V_i := Submodule.span ùîΩq (Set.range (sBasis Œ≤ h_‚Ñì_add_R_rate i h_i))
    let W_i_map := polyEvalLinearMap (normalizedW ùîΩq Œ≤ i)
      (normalizedW_is_additive ùîΩq Œ≤ i)
    sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i
    = Submodule.map W_i_map V_i

theorem add_comm : p + q = q + p

theorem cast_run (stmt : StmtIn) (wit : WitIn) :
    R.run stmt wit = cast (sorry) ((R.cast hn hSpec).run stmt wit)

theorem qMap_total_fiber_disjoint
  (i : Fin ‚Ñì) (steps : ‚Ñï) (h_i_add_steps : i + steps ‚â§ ‚Ñì)
  {y‚ÇÅ y‚ÇÇ : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i.val + steps, by omega‚ü©}
  (hy_ne : y‚ÇÅ ‚â† y‚ÇÇ) :
  Disjoint
    ((qMap_total_fiber ùîΩq Œ≤ (i := ‚ü®i, by omega‚ü©) (steps := steps)
      (h_i_add_steps := fin_‚Ñì_steps_lt_‚Ñì_add_R i steps h_i_add_steps) y‚ÇÅ '' Set.univ).toFinset)
    ((qMap_total_fiber ùîΩq Œ≤ (i := ‚ü®i, by omega‚ü©) (steps := steps)
      (h_i_add_steps := fin_‚Ñì_steps_lt_‚Ñì_add_R i steps h_i_add_steps) y‚ÇÇ '' Set.univ).toFinset)

theorem prime_37 : Nat.Prime 37

private lemma johnson_condition_strong_implies_2_le_B_card
  (h_johnson : JohnsonConditionStrong B v)
  :
  2 ‚â§ B.card

theorem nsmul_succ [LawfulBEq R] (n : ‚Ñï) {p : UniPoly R} : nsmul (n + 1) p = nsmul n p + p

theorem seqCompose_perfectCompleteness (hInit : init.neverFails)
    (rel : (i : Fin (m + 1)) ‚Üí Set ((Stmt i √ó ‚àÄ j, OStmt i j) √ó Wit i))
    (R : ‚àÄ i, OracleReduction oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Wit i.castSucc)
      (Stmt i.succ) (OStmt i.succ) (Wit i.succ) (pSpec i))
    (h : ‚àÄ i, (R i).perfectCompleteness init impl (rel i.castSucc) (rel i.succ)) :
      (OracleReduction.seqCompose Stmt OStmt Wit R).perfectCompleteness
        init impl (rel 0) (rel (Fin.last m))

@[simp]
theorem lagrangeBasis_zero {w : Vector R 0} : lagrangeBasis w = #v[1]

theorem take_drop_eq_drop_take (m‚ÇÅ m‚ÇÇ : ‚Ñï) (h‚ÇÅ : m‚ÇÅ ‚â§ m‚ÇÇ) (h‚ÇÇ : m‚ÇÇ ‚â§ n) (v : (i : Fin n) ‚Üí Œ± i) :
    take (m‚ÇÇ - m‚ÇÅ) (by omega) (drop m‚ÇÅ (by omega) v) =
      drop m‚ÇÅ (by omega) (take m‚ÇÇ h‚ÇÇ v)

lemma sub_middle_of_pow2_with_one_canceled {k : ‚Ñï} (h_k : 1 ‚â§ k) : 2 ^ k - 1 - 2 ^ (k - 1) + 1
  = 2 ^ (k - 1)

@[simp, grind =]
lemma totalDegree_monomialXY {n m : ‚Ñï} {a : F} (ha : a ‚â† 0) :
  totalDegree (monomialXY n m a) = n + m

theorem coreInteractionOracleReduction_perfectCompleteness (hInit : init.neverFails) :
    OracleReduction.perfectCompleteness
      (pSpec := pSpecCoreInteraction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
      (relIn := roundRelation (mp := BBF_SumcheckMultiplierParam) ùîΩq Œ≤ (œë:=œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) 0)
      (relOut := finalSumcheckRelOut ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
      (oracleReduction := coreInteractionOracleReduction ùîΩq Œ≤ (œë:=œë) (ùìë:=ùìë))
      (init := init)
      (impl := impl)

Nat.le_trans in Init.Prelude

theorem divSum?_is_some_iff_lt_sum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {k : ‚Ñï} :
    (divSum? n k).isSome ‚Üî k < ‚àë i, n i

@[simp]
theorem Iic_zero : Iic (0 : Fin (n + 1)) = {0}

Nat.add_left_cancel in Init.Data.Nat.Basic

lemma lagrangeToMono_eq_lagrangeToMono_segment (n : ‚Ñï) [NeZero n] (v : Vector R (2 ^ n)) :
  have h_n_ne_zero: n ‚â† 0

@[csimp] lemma dfoldl_eq_dfoldl' : @dfoldl = @dfoldl'

theorem findIdxRev?_eq_some {cond} {as : Array Œ±} (h : ‚àÉ i, ‚àÉ hi : i < as.size, cond as[i]) :
  ‚àÉ k : Fin as.size, findIdxRev? cond as = some k

theorem dconcat_right_injective {motive : Fin (n + 1) ‚Üí Sort u}
    (v : (i : Fin n) ‚Üí motive (castSucc i)) :
    Function.Injective (dconcat (motive := motive) v)

@[simp]
lemma support_polynomialOfCoeffs : (polynomialOfCoeffs coeffs).support =
  Finset.map ‚ü®Fin.val, Fin.val_injective‚ü© {i | coeffs i ‚â† 0}

private lemma comp_x_square_coeff_pos_deg {f : Polynomial F} {n : ‚Ñï} (h : 0 < f.degree) :
  (f.comp (X * X)).coeff n = if Even n then f.coeff (n / 2) else 0

@[simp]
lemma coeff_truncate : (truncate p n).coeff k = if k < n then p.coeff k else 0

theorem toFun_eq_const_plus (t : AssocNat) : ‚àÄ m : Nat, t m = t 0 + m

Polynomial.degree_sum_le in Mathlib.Algebra.Polynomial.Degree.Definitions

theorem sum_fromNat_eq_from_xor_Nat {k : ‚Ñï} (x y : Nat) :
  fromNat (k:=k) (x ^^^ y) = fromNat (k:=k) x + fromNat (k:=k) y

Nat.pos_of_neZero in Init.Data.Nat.Basic

Nat.le_of_succ_le in Init.Data.Nat.Basic

theorem dcast‚ÇÉ_dcast‚ÇÇ : dcast‚ÇÉ rfl rfl rfl d = dcast‚ÇÇ dcast_eq.symm dcast‚ÇÇ_dcast.symm d

lemma erase_even_def {s : Finset ‚Ñï} :
    erase_even s = s.filter Odd

@[simp]
theorem cast_completeness (Œµ : ‚Ñù‚â•0) (hComplete : R.completeness init impl relIn relOut Œµ) :
    (R.cast hn hSpec).completeness init impl relIn relOut Œµ

theorem hcons_right_injective {Œ≤ : Fin n ‚Üí Sort u} (a : Œ±) :
    Function.Injective (hcons a : ((i : Fin n) ‚Üí Œ≤ i) ‚Üí (i : Fin (n + 1)) ‚Üí vcons Œ± Œ≤ i)

theorem withBot_lt_one_cases (x : WithBot ‚Ñï) (h : x < (1 : ‚Ñï)) : x = ‚ä• ‚à® x = (0 : ‚Ñï)

omit [Finite F] in
@[simp]
lemma domain_lem‚ÇÇ :
  [FinalOracleStatement D x s]‚Çí.domain (Fin.last (k + 1)) = Unit

lemma fold_f_g_poly
  {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F} {k m : ‚Ñï}
  {œÜ_0 : (indexPowT S œÜ 0) ‚Ü™ F} {œÜ_k : (indexPowT S œÜ k) ‚Ü™ F}
  [Fintype (indexPowT S œÜ 0)] [DecidableEq (indexPowT S œÜ 0)] [Smooth œÜ_0]
  [Fintype (indexPowT S œÜ k)] [DecidableEq (indexPowT S œÜ k)] [Smooth œÜ_k]
  [‚àÄ i : ‚Ñï, Neg (indexPowT S œÜ i)]
  (Œ±s : Fin k ‚Üí F) (hk : k ‚â§ m)
  (f : smoothCode œÜ_0 m) (g : smoothCode œÜ_k (m-k)) :
  let fPoly

@[simp]
theorem rtake_append_right :
    (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).rtake n (Nat.le_add_left n m) = pSpec‚ÇÇ

theorem fcons_right_injective {Œ≤ : Fin n ‚Üí A} (a : F Œ±) :
    Function.Injective (fcons a : ((i : Fin n) ‚Üí F (Œ≤ i)) ‚Üí (i : Fin (n + 1)) ‚Üí _)

theorem liftContext_runWithLogToRound
    {lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    {outerStmtIn : OuterStmtIn} {outerWitIn : OuterWitIn} {i : Fin (n + 1)}
    (P : Prover oSpec InnerStmtIn InnerWitIn InnerStmtOut InnerWitOut pSpec) :
      (P.liftContext lens).runWithLogToRound i outerStmtIn outerWitIn
      = do
        let ‚ü®‚ü®transcript, prvState‚ü©, queryLog‚ü© ‚Üê
          (P.runWithLogToRound i).uncurry (lens.proj (outerStmtIn, outerWitIn))
        return ‚ü®‚ü®transcript, ‚ü®prvState, outerStmtIn, outerWitIn‚ü©‚ü©, queryLog‚ü©

@[simp]
lemma evenize_coeff {f : Polynomial F} {n : ‚Ñï} :
    (evenize f).coeff n = if Even n then f.coeff (n / 2) else 0

theorem last_nonzero_last_iff [LawfulBEq R] {p : UniPoly R} (hp : p.size > 0) :
  p.last_nonzero = some ‚ü® p.size - 1, Nat.pred_lt_self hp ‚ü© ‚Üî p.getLast hp ‚â† 0

@[simp]
theorem cast_dir_idx {hn} (hSpec : pSpec‚ÇÅ.cast hn = pSpec‚ÇÇ) {i : Fin n‚ÇÅ} :
    pSpec‚ÇÇ.dir (Fin.cast hn i) = pSpec‚ÇÅ.dir i

lemma W·µ¢_vanishing (i : Fin r) :
  ‚àÄ u ‚àà U ùîΩq Œ≤ i, (W ùîΩq Œ≤ i).eval u = 0

omit [Fintype F] in
private lemma hamming_dist_eq_sum {x y : Fin n ‚Üí F} :
  Œî‚ÇÄ(x, y) = ‚àë i, if x i = y i then 0 else 1

@[simp]
theorem rightpad_apply_lt (n : ‚Ñï) (a : Œ±) (v : Fin m ‚Üí Œ±) (i : Fin n)
    (h : i.val < m) : rightpad n a v i = v ‚ü®i.val, h‚ü©

lemma rootMultiplicity_W (i : Fin r) (a : L) :
    rootMultiplicity a (W ùîΩq Œ≤ i) = if a ‚àà (U ùîΩq Œ≤ i : Set L) then 1 else 0

@[simp]
theorem divide_by_2_mem {s : Finset ‚Ñï} {d : ‚Ñï} :
  d ‚àà divide_by_2 s ‚Üî 2 * d ‚àà s

lemma eq_poly_deg_one {a b c d : F} {x‚ÇÅ x‚ÇÇ : F}
  (h1 : a + b * x‚ÇÅ = c + d * x‚ÇÅ)
  (h2 : a + b * x‚ÇÇ = c + d * x‚ÇÇ)
  (h1_2 : x‚ÇÅ ‚â† x‚ÇÇ) :
  Polynomial.C a + Polynomial.C b * Polynomial.X
    = Polynomial.C c + Polynomial.C d * Polynomial.X

lemma liftF_ne_zero_of_lt {i : ‚Ñï} (h : i < n) : liftF f' i ‚â† 0 ‚Üî f' ‚ü®i, h‚ü© ‚â† 0

theorem funext‚ÇÇ_iff {Œ± : Sort u} {Œ≤ : Œ± ‚Üí Sort v} {Œ≥ : (a : Œ±) ‚Üí Œ≤ a ‚Üí Sort w}
    {f g : (a : Œ±) ‚Üí (b : Œ≤ a) ‚Üí Œ≥ a b} : f = g ‚Üî ‚àÄ a b, f a b = g a b

lemma degreesY_nonempty {f : F[X][Y]} (hf : f ‚â† 0) : (f.toFinsupp.support).Nonempty

@[simp]
lemma coeff_solutionToE :
  (solutionToE e k v).coeff n = if n = e then 1 else if n < e then liftF v n else 0

lemma getBit_of_lowBits {n: ‚Ñï} (numLowBits : ‚Ñï) : ‚àÄ k, getBit k (getLowBits numLowBits n) =
    if k < numLowBits then getBit k n else 0

lemma evenize_is_even {f : Polynomial F} :
    EvenPoly (evenize f)

theorem relayOracleReduction_perfectCompleteness (hInit : init.neverFails) (i : Fin ‚Ñì)
    (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
    OracleReduction.perfectCompleteness
      (pSpec := pSpecRelay)
      (relIn := foldStepRelOut (mp := mp) ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        (ùìë := ùìë) i)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        (ùìë := ùìë) i.succ)
      (oracleReduction := relayOracleReduction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        i hNCR)
      (init := init)
      (impl := impl)

lemma towerRingHomForwardMap0_eq :
  towerRingEquivFromConcrete0.toFun = towerRingHomForwardMap 0

@[simp]
lemma List.get_nil (i : Fin 0) (a : Œ±) : [].get i = a

theorem one_le_sub_consecutive_two_pow (n : ‚Ñï): 1 ‚â§ 2^(n+1) - 2^n

@[local grind _=_]
private lemma support_eq_support_toFinsupp {f : F[X][Y]} : f.support = f.toFinsupp.support

theorem eqPolynomial_degreeOf (r : œÉ ‚Üí R) (i : œÉ) : degreeOf i (eqPolynomial r) ‚â§ 1

theorem fcons‚ÇÇ_inj {Œ±‚ÇÅ : A} {Œ±‚ÇÇ : B} {Œ≤‚ÇÅ : Fin n ‚Üí A} {Œ≤‚ÇÇ : Fin n ‚Üí B}
    (a‚ÇÅ a‚ÇÇ : F‚ÇÇ Œ±‚ÇÅ Œ±‚ÇÇ) (b‚ÇÅ b‚ÇÇ : (i : Fin n) ‚Üí F‚ÇÇ (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) :
    fcons‚ÇÇ (F := F‚ÇÇ) a‚ÇÅ b‚ÇÅ = fcons‚ÇÇ (F := F‚ÇÇ) a‚ÇÇ b‚ÇÇ ‚Üî a‚ÇÅ = a‚ÇÇ ‚àß b‚ÇÅ = b‚ÇÇ

@[simp]
lemma width_pos : 0 < params.width

lemma neg_mod_2_eq_0_iff_mod_2_eq_0 {n : ‚Ñ§} : ( - n) % 2 = 0 ‚Üî n % 2 = 0

theorem seqCompose_knowledgeSoundness
    (rel : (i : Fin (m + 1)) ‚Üí Set (Stmt i √ó Wit i))
    (V : (i : Fin m) ‚Üí Verifier oSpec (Stmt i.castSucc) (Stmt i.succ) (pSpec i))
    (knowledgeError : Fin m ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (V i).knowledgeSoundness init impl (rel i.castSucc) (rel i.succ) (knowledgeError i)) :
      (Verifier.seqCompose Stmt V).knowledgeSoundness init impl (rel 0) (rel (Fin.last m))
        (‚àë i, knowledgeError i)

private lemma aux_sum [Zero F]
  (h_n : 0 < n)
  : n * choose_2 (aux_frac B (k B)) ‚â§ ‚àë i, choose_2 (aux_frac B (K B i 0))

@[simp]
lemma Verifier.id_rbrKnowledgeSoundness {rel : Set (Statement √ó Witness)} :
    (Verifier.id : Verifier oSpec Statement _ _).rbrKnowledgeSoundness
      init impl rel rel 0

lemma matchSize_size_eq {p q : UniPoly Q} :
    let (p', q') := Array.matchSize p q 0
    p'.size = q'.size

theorem commit_eq {a : ZMod p} (hpG1 : Nat.card G‚ÇÅ = p)
    (poly : degreeLT (ZMod p) (n + 1)) :
    commit (towerOfExponents g‚ÇÅ a n) (degreeLTEquiv _ _ poly) = g‚ÇÅ ^ (poly.1.eval a).val

theorem polynomial_sum_ext.{u, u_1}
  {R : Type u}
  [Semiring R]
  {S : Type u_1}
  [AddCommMonoid S]
  {p : Polynomial R} {f g : ‚Ñï ‚Üí R ‚Üí S}
  (h : ‚àÄ i x, f i x = g i x)
  : p.sum f = p.sum g

theorem support_C_subset {r : R} : (@C R œÉ _ r).support ‚äÜ { 0 }

theorem correlatedAgreement_affine_spaces {k : ‚Ñï} [NeZero k] {u : Fin (k + 1) ‚Üí Œπ ‚Üí F}
  {deg : ‚Ñï} {domain : Œπ ‚Ü™ F} {Œ¥ : ‚Ñù‚â•0} (hŒ¥ : Œ¥ ‚â§ 1 - (ReedSolomonCode.sqrtRate deg domain))
  (hproximity :
    Pr_{let y ‚Üê $·µñ (u 0 +·µ• affineSpan F (Finset.univ.image (Fin.tail u)).toSet)}[
        Code.relHammingDistToCode (Œπ := Œπ) (F := F) y (ReedSolomon.code domain deg) ‚â§ Œ¥
    ] > errorBound Œ¥ deg domain) :
  correlatedAgreement (ReedSolomon.code domain deg) Œ¥ u

lemma eval_solutionToQ_cast {x : F} (h : e = 0) :
  eval x (solutionToQ e k v) = ‚àë i ‚àà Finset.range k, liftF v i * x ^ i

Fin.is_le in Init.Data.Fin.Lemmas

theorem Nat.shiftRight_lo_mod_2_pow_hi_shiftLeft_lo (n hi_len lo_len : ‚Ñï)
  (h_n : n < 2 ^ (hi_len + lo_len)) :
  (((n >>> lo_len) % (2 ^ hi_len)) <<< lo_len) = (n - n % 2 ^ lo_len)

omit [Fintype œÉ] in
theorem singleEqPolynomial_degreeOf (r : R) (i j : œÉ) :
    degreeOf i (singleEqPolynomial r (X j)) ‚â§ if i = j then 1 else 0

theorem BTField.PowerBasis_cast_dest_eq (k n m : ‚Ñï) (h_k_le_n : k ‚â§ n)
  (h_k_le_m : k ‚â§ m) (h_eq : m = n) :
  letI instLeftAlgebra := binaryAlgebraTower (l:=k) (r:=m) (h_le:=h_k_le_m)
  letI instRightAlgebra := binaryAlgebraTower (l:=k) (r:=n) (h_le:=h_k_le_n)
  @PowerBasis (BTField k) (BTField m) _ _ instLeftAlgebra =
  @PowerBasis (BTField k) (BTField n) _ _ instRightAlgebra

lemma nonDoomedFoldingProp_relay_preserved (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i)
    (challenges : Fin i.succ ‚Üí L)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j)
    :
    nonDoomedFoldingProp ùîΩq Œ≤ i.castSucc (Fin.init challenges) oStmt ‚Üî
    nonDoomedFoldingProp ùîΩq Œ≤ i.succ challenges (mapOStmtOutRelayStep ùîΩq Œ≤ i hNCR oStmt)

theorem simulateQ'_eq_simulateQ [AlternativeMonad m] [LawfulMonad m]
    {so : QueryImpl spec m} (oa : OracleComp spec Œ±) (h : oa.neverFails) :
      simulateQ' so oa h = simulateQ so oa

@[simp]
theorem eq_refl {Œ± : Type u} (mx : m Œ±) : eq mx mx

lemma sub_descends [LawfulBEq R] (a‚ÇÅ b‚ÇÅ a‚ÇÇ b‚ÇÇ : UniPoly R) :
  equiv a‚ÇÅ a‚ÇÇ ‚Üí equiv b‚ÇÅ b‚ÇÇ ‚Üí sub_descending a‚ÇÅ b‚ÇÅ = sub_descending a‚ÇÇ b‚ÇÇ

private lemma Bi_biUnion_F2i :
  Bi B i = Finset.univ.biUnion (F2i B i)

theorem multilinearBasis_apply (r : ‚Ñï) : ‚àÄ l : ‚Ñï, (h_le : l ‚â§ r) ‚Üí ‚àÄ (j : Fin (2  ^ (r - l))),
  multilinearBasis (l:=l) (r:=r) (h_le:=h_le) j =
    (Finset.univ : Finset (Fin (r - l))).prod (fun i =>
      (binaryAlgebraTower (l:=l + i + 1) (r:=r) (h_le:=by omega)).algebraMap (
        (ùïè (l + i)) ^ (Nat.getBit i j)))

lemma towerRingHomForwardMap_backwardMap_eq (k : ‚Ñï) (x : BTField k) :
  towerRingHomForwardMap (k:=k) (towerRingHomBackwardMap (k:=k) x) = x

theorem coeffs_of_comp_minus_x {f : Polynomial F} {n : ‚Ñï} :
    (f.comp (-X)).coeff n = if Even n then f.coeff n else -f.coeff n

Nat.add_zero in Init.Core

theorem monomialBasis_getElem {w : Vector R n} (i : Fin (2 ^ n)) :
    (monomialBasis w)[i] = ‚àè j : Fin n, if (BitVec.ofFin i).getLsb j then w[j] else 1

@[simp]
theorem erase_even_mem
  {s : Finset ‚Ñï}
  {n : ‚Ñï}
  : n ‚àà (erase_even s) ‚Üî Odd n ‚àß n ‚àà s

protected lemma abs_one_sub_div_le_one {v a : Fin n ‚Üí F}
  (h_card : 2 ‚â§ Fintype.card F)
  :
  |1 - (1 + 1 / ((Fintype.card F : ‚Ñö) - 1)) * Œî‚ÇÄ(v, a) / n

private lemma johnson_condition_strong_implies_2_le_F_card
  (h_johnson : JohnsonConditionStrong B v)
  :
  2 ‚â§ Fintype.card F

theorem oracleVerifier_toVerifier_run {stmt : Statement} {oStmt : ‚àÄ i, OStatement i}
    {tr : (oraclePSpec Witness).FullTranscript} :
    (oracleVerifier oSpec Statement OStatement Witness).toVerifier.run ‚ü®stmt, oStmt‚ü© tr =
      pure ‚ü®stmt, Sum.rec oStmt (fun i => match i with | 0 => tr 0)‚ü©

theorem seqCompose_rbrKnowledgeSoundness
    (rel : ‚àÄ i, Set (Stmt i √ó Wit i))
    (V : ‚àÄ i, Verifier oSpec (Stmt i.castSucc) (Stmt i.succ) (pSpec i))
    (rbrKnowledgeError : ‚àÄ i, (pSpec i).ChallengeIdx ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (V i).rbrKnowledgeSoundness init impl
      (rel i.castSucc) (rel i.succ) (rbrKnowledgeError i)) :
      (Verifier.seqCompose Stmt V).rbrKnowledgeSoundness init impl (rel 0) (rel (Fin.last m))
        (fun combinedIdx =>
          letI ij := seqComposeChallengeIdxToSigma combinedIdx
          rbrKnowledgeError ij.1 ij.2)

@[simp]
private lemma E_ne_zero : (E œâs f p e) ‚â† 0

private lemma Fis_cover_B : B = Finset.univ.biUnion (Fi B i)

@[simp]
theorem vcons_zero (a : Œ±) (v : Fin n ‚Üí Œ±) : (a ::·µõ v) 0 = a

lemma evenize_eq_comp_x_squared {f : Polynomial F} :
    evenize f = f.comp (Polynomial.X * Polynomial.X)

protected lemma johnson_bound_lemma [Field F] {v : Fin n ‚Üí F}
  (h_n : 0 < n)
  (h_B : 2 ‚â§ B.card)
  (h_card : 2 ‚â§ (Fintype.card F))
  :
  B.card *
    ((1 - ((Fintype.card F : ‚Ñö) / (Fintype.card F - 1)) * (e B v / n)) ^ 2
      - (1 - ((Fintype.card F : ‚Ñö) / (Fintype.card F - 1)) * (d B/n)))  ‚â§
  ((Fintype.card F : ‚Ñö) / (Fintype.card F - 1)) * d B/n

theorem eq_iff_split_eq {k : ‚Ñï} (h_pos : k > 0) (x‚ÇÄ x‚ÇÅ : ConcreteBTField k) :
  x‚ÇÄ = x‚ÇÅ ‚Üî (split h_pos x‚ÇÄ = split h_pos x‚ÇÅ)

@[simp, grind _=_]
lemma degreeY_mul [IsDomain F] (f g : F[X][Y]) (hf : f ‚â† 0) (hg : g ‚â† 0)
  : natDegreeY (f * g) = natDegreeY f + natDegreeY g

theorem computableAdditiveNTT_eq_additiveNTT (a : Fin (2 ^ ‚Ñì) ‚Üí L) :
  computableAdditiveNTT (ùîΩq := ùîΩq) (Œ≤ := Œ≤) (‚Ñì := ‚Ñì) (R_rate := R_rate)
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (a := a) =
  additiveNTT (ùîΩq := ùîΩq) (L := L) (Œ≤ := Œ≤) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (a := a)

private lemma k_and_e' [Zero F]
  (h_n : n ‚â† 0)
  (h_B : B.card ‚â† 0)
  :
  k B / B.card = (n - e B 0) / n

@[simp]
theorem vcons_one (a : Œ±) (v : Fin (n + 1) ‚Üí Œ±) : (a ::·µõ v) 1 = v 0

lemma h_middle_sub {k : ‚Ñï} : 2 ^ (k - 1) - 1 - 0 + 1 = 2 ^ (k - 1)

theorem hcons_eq_hcons_iff {Œ≤ : Fin n ‚Üí Sort u} (a‚ÇÅ a‚ÇÇ : Œ±) (v‚ÇÅ v‚ÇÇ : (i : Fin n) ‚Üí Œ≤ i) :
    hcons a‚ÇÅ v‚ÇÅ = hcons a‚ÇÇ v‚ÇÇ ‚Üî a‚ÇÅ = a‚ÇÇ ‚àß v‚ÇÅ = v‚ÇÇ

theorem completeness_error_mono {Œµ‚ÇÅ Œµ‚ÇÇ : ‚Ñù‚â•0} (hŒµ : Œµ‚ÇÅ ‚â§ Œµ‚ÇÇ) :
      completeness init impl relIn relOut reduction Œµ‚ÇÅ ‚Üí
        completeness init impl relIn relOut reduction Œµ‚ÇÇ

lemma split_smul_Z_eq_zero_x {k : ‚Ñï} (h_pos : k > 0) (x : ConcreteBTField (k - 1)) :
  letI instAlgebra := ConcreteBTFieldAlgebra (l:=k-1) (r:=k) (h_le:=by omega)
  split h_pos (x ‚Ä¢ Z k) = (x, 0)

@[simp]
theorem perfectCompleteness_eq_prob_one :
    reduction.perfectCompleteness init impl relIn relOut ‚Üî
      ‚àÄ stmtIn witIn, (stmtIn, witIn) ‚àà relIn ‚Üí
        [fun ‚ü®‚ü®_, (prvStmtOut, witOut)‚ü©, stmtOut‚ü© =>
          (stmtOut, witOut) ‚àà relOut ‚àß prvStmtOut = stmtOut
        | do (simulateQ (impl ++‚Çõ‚Çí challengeQueryImpl : QueryImpl _ (StateT œÉ ProbComp))
            <| reduction.run stmtIn witIn).run' (‚Üê init)] = 1

omit O‚Çò in
theorem seqCompose_perfectCompleteness (hInit : init.neverFails)
    (rel : (i : Fin (m + 1)) ‚Üí Set (Stmt i √ó Wit i))
    (R : ‚àÄ i, Reduction oSpec (Stmt i.castSucc) (Wit i.castSucc) (Stmt i.succ) (Wit i.succ)
      (pSpec i))
    (h : ‚àÄ i, (R i).perfectCompleteness init impl (rel i.castSucc) (rel i.succ)) :
      (Reduction.seqCompose Stmt Wit R).perfectCompleteness
        init impl (rel 0) (rel (Fin.last m))

@[simp]
lemma solutionToE_ne_zero : (solutionToE e k v) ‚â† 0

omit [NeZero ‚Ñì] [NeZero r] [NeZero ùì°] in
lemma fin_‚Ñì_add_one_lt_r {h_‚Ñì_add_R_rate : ‚Ñì + ùì° < r} (i : Fin (‚Ñì + 1))
    : i.val < r

lemma mca_rsc
  [DecidableEq Œπ]
  (Œ± : F) (œÜ : Œπ ‚Ü™ F) (m : ‚Ñï) [Smooth œÜ]
  (par‚Ñì_type : Type) [Fintype par‚Ñì_type] (exp : par‚Ñì_type ‚Ü™ ‚Ñï) :
  let Gen := RSGenerator.genRSC par‚Ñì_type œÜ m exp
  let : Fintype Gen.par‚Ñì := Gen.h‚Ñì
  hasMutualCorrAgreement
    -- Generator
    Gen
    -- BStar
    ((1 + Gen.rate) / 2)
    -- errStar
    (fun Œ¥ => ENNReal.ofReal
        ((Fintype.card par‚Ñì_type - 1) * (2^m / (Gen.rate * (Fintype.card F)))))

theorem linsolve_some {A : Matrix (Fin n) (Fin m) F} {b : Fin n ‚Üí F} {x : Fin m ‚Üí F}
  (h : linsolve A b = some x)
  : A.mulVec x = b

lemma getBit_of_two_pow_sub_one {i k: ‚Ñï} : getBit k (2^i - 1) =
    if k < i then 1 else 0

@[simp]
theorem hflatten_embedSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {Œ± : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí Sort*}
    (v : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí Œ± i j) (i : Fin m) (j : Fin (n i)) :
    hflatten v (embedSum i j) = cast (vflatten_embedSum Œ± i j).symm (v i j)

theorem rightpad_getElem_eq_getD {a b : List Œ±} {unit : Œ±} {i : Nat}
  (h : i < (a.rightpad b.length unit).length) :
    (a.rightpad b.length unit)[i] = a.getD i unit

theorem W_linearity (i : Fin r)
    : IsLinearMap ùîΩq (f := fun inner_p ‚Ü¶ (W ùîΩq Œ≤ i).comp inner_p)

theorem eq_zero_of_degreeOf_lt_card_of_eval_eq_zero {p : R[X œÉ]} (S : œÉ ‚Üí Finset R)
    (hDegree : ‚àÄ i, p.degreeOf i < #(S i))
    (hEval : ‚àÄ x ‚àà piFinset fun i ‚Ü¶ S i, eval x p = 0) : p = 0

@[simp]
theorem partialSum_nil : [].partialSum = [0]

theorem fconcat_left_injective {Œ± : Fin n ‚Üí A} {Œ≤ : A} (a : F Œ≤) :
    Function.Injective (fun v : (i : Fin n) ‚Üí F (Œ± i) => fconcat v a)

Fin.isLt in Init.Prelude

omit [NeZero œë] hdiv in
lemma toOutCodewordsCountOf0 : toOutCodewordsCount ‚Ñì œë 0 = 1

@[coe]
theorem BTField_succ_eq_adjoinRoot (k : ‚Ñï) : AdjoinRoot (poly k) = BTField (k+1)

theorem add_zero (hp : p.canonical) : p + 0 = p

@[simp] -- main lemma for bIdx: Fin (‚Ñì / œë - 1) bounds
lemma bIdx_mul_œë_add_x_lt_‚Ñì_sub_œë (bIdx : Fin (‚Ñì / œë - 1)) (x : ‚Ñï) {hx : x ‚â§ œë} :
    ‚ÜëbIdx * œë + x ‚â§ ‚Ñì - œë

theorem happend_hcons {Œ≤ : Fin m ‚Üí Sort u} {Œ≥ : Fin n ‚Üí Sort u}
    (a : Œ±) (u : (i : Fin m) ‚Üí Œ≤ i) (v : (i : Fin n) ‚Üí Œ≥ i) :
    True

@[simp]
lemma inv_two_mul_two : 2‚Åª¬π * (2 : F) = 1

lemma divide_by_2_def {s : Finset ‚Ñï} :
    divide_by_2 s = (erase_odd s).image (fun n => n / 2)

@[simp]
theorem dcons_succ {motive : Fin (n + 1) ‚Üí Sort u} (a : motive 0)
    (v : (i : Fin n) ‚Üí motive i.succ) (i : Fin n) : (a ::·µà‚ü®motive‚ü© v) i.succ = v i

theorem seqCompose_rbrKnowledgeSoundness
    (rel : ‚àÄ i, Set ((Stmt i √ó ‚àÄ j, OStmt i j) √ó Wit i))
    (V : (i : Fin m) ‚Üí OracleVerifier oSpec (Stmt i.castSucc) (OStmt i.castSucc)
      (Stmt i.succ) (OStmt i.succ) (pSpec i))
    (rbrKnowledgeError : ‚àÄ i, (pSpec i).ChallengeIdx ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (V i).rbrKnowledgeSoundness init impl
      (rel i.castSucc) (rel i.succ) (rbrKnowledgeError i)) :
    (OracleVerifier.seqCompose Stmt OStmt V).rbrKnowledgeSoundness
        init impl (rel 0) (rel (Fin.last m))
        (fun combinedIdx =>
          letI ij := seqComposeChallengeIdxToSigma combinedIdx
          rbrKnowledgeError ij.1 ij.2)

lemma join_zero_zero {k : ‚Ñï} (h_k : k > 0) :
  „Ää zero (k:=k - 1), zero (k:=k - 1) „Äã = zero (k:=k)

theorem dcast_fun {Œ≥ : (a : Œ±) ‚Üí Œ≤ a ‚Üí Sort*} {f : (b : Œ≤ a) ‚Üí Œ≥ a b} :
    f (dcast rfl b) = dcast (Œ± := Œ≤ a) (Œ≤ := Œ≥ a) dcast_eq.symm (f b)

@[simp]
theorem append_snd (T‚ÇÅ : FullTranscript pSpec‚ÇÅ) (T‚ÇÇ : FullTranscript pSpec‚ÇÇ) :
    (T‚ÇÅ ++‚Çú T‚ÇÇ).snd = T‚ÇÇ

lemma forwardRange_eq_of_r_eq (n : ‚Ñï) (r1 r2 : Fin n) (h_r_eq : r1 = r2) (l : Fin (r1.val + 1)) :
  forwardRange n r1 l = forwardRange n r2 ‚ü®l, by omega‚ü©

lemma gamma_eq_P
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  :
  Œ≥' x‚ÇÄ (R k Œ¥ x‚ÇÄ h_gs) (irreducible_H k (x‚ÇÄ := x‚ÇÄ) (Œ¥ := Œ¥) h_gs) =
  AppendixA.polyToPowerSeriesùïÉ _ 
    (P k Œ¥ x‚ÇÄ h_gs)

omit hF‚ÇÇ in
theorem kernel_normalizedW_eq_U (i : Fin r) :
    LinearMap.ker (polyEvalLinearMap (normalizedW ùîΩq Œ≤ i)
    (normalizedW_is_additive ùîΩq Œ≤ i))
    = U ùîΩq Œ≤ i

@[simp]
theorem leftpad_apply_ge (n : ‚Ñï) (a : Œ±) (v : Fin m ‚Üí Œ±) (i : Fin n)
    (h : n - m ‚â§ i.val) : leftpad n a v i = v ‚ü®i.val - (n - m), by omega‚ü©

@[simp]
theorem acceptRejectOracleRel_language :
    acceptRejectOracleRel.language = { (true, isEmptyElim) }

theorem seqCompose_knowledgeSoundness
    (rel : (i : Fin (m + 1)) ‚Üí Set ((Stmt i √ó ‚àÄ j, OStmt i j) √ó Wit i))
    (V : (i : Fin m) ‚Üí
      OracleVerifier oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Stmt i.succ) (OStmt i.succ)
        (pSpec i))
    (knowledgeError : Fin m ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (V i).knowledgeSoundness init impl (rel i.castSucc) (rel i.succ) (knowledgeError i)) :
      (OracleVerifier.seqCompose Stmt OStmt V).knowledgeSoundness
        init impl (rel 0) (rel (Fin.last m)) (‚àë i, knowledgeError i)

lemma guruswami_sudan_for_proximity_gap_existence {k m : ‚Ñï} {œâs : Fin n ‚Ü™ F} {f : Fin n ‚Üí F} :
  ‚àÉ Q, Condition k m (proximity_gap_degree_bound (n := n) k m) œâs f Q

theorem degrees_eval [DecidableEq œÉ] {œÑ : Type*} {f : œÑ ‚Üí R} {p : R[X œÉ][X œÑ]} :
    (eval (C ‚àò f) p).degrees ‚â§ p.support.sup (fun c => (coeff c p).degrees)

lemma roots_comp_X_sub_C (p : L[X]) (a : L) :
    (p.comp (X - C a)).roots = p.roots.map (fun r => r + a)

theorem BaseField_is_prime : Nat.Prime BASE_FIELD_CARD

lemma last_nonzero_unique {p : UniPoly Q} {k k' : Fin p.size} :
  last_nonzero_prop k ‚Üí last_nonzero_prop k' ‚Üí k = k'

@[simp]
theorem dflatten_succ {m : ‚Ñï} {n : Fin (m + 1) ‚Üí ‚Ñï} {motive : (k : Fin (vsum n)) ‚Üí Sort*}
    {v : (i : Fin (m + 1)) ‚Üí (j : Fin (n i)) ‚Üí motive (embedSum i j)} :
    dflatten (motive := motive) v = dappend (v 0) (dflatten (fun i => v i.succ))

Fin.ext in Init.Data.Fin.Lemmas

omit [Finite F] in
lemma neg_mem_dom_of_mem_dom : ‚àÄ {a : FÀ£} (i : Fin n),
    a ‚àà evalDomain D x i ‚Üí - a ‚àà evalDomain D x i

lemma dim_eq_deg_of_le [NeZero n] (inj : Function.Injective Œ±) (h : n ‚â§ m) :
  dim (ReedSolomon.code ‚ü®Œ±, inj‚ü© n) = n

@[simp]
theorem mul_accepts_iff : (mul a b c).accepts x ‚Üî x c = x a * x b

theorem concrete_mul_eq
  (prevBTFieldProps : ConcreteBTFieldProps (k := k - 1))
  (a b : ConcreteBTField k) {a‚ÇÅ a‚ÇÄ b‚ÇÅ b‚ÇÄ : ConcreteBTField (k - 1)}
  (h_a : (a‚ÇÅ, a‚ÇÄ) = split h_k a) (h_b : (b‚ÇÅ, b‚ÇÄ) = split h_k b) :
  concrete_mul a b =
    „Ää concrete_mul a‚ÇÄ b‚ÇÅ + concrete_mul b‚ÇÄ a‚ÇÅ + concrete_mul (concrete_mul a‚ÇÅ b‚ÇÅ) (Z (k - 1)),
      concrete_mul a‚ÇÄ b‚ÇÄ + concrete_mul a‚ÇÅ b‚ÇÅ „Äã

@[simp]
lemma bIdx_mul_œë_add_i_cast_lt_‚Ñì_succ (bIdx : Fin (‚Ñì / œë - 1)) (i : Fin (œë - 1 + 1))
    : ‚ÜëbIdx * œë + i < ‚Ñì + 1

private lemma errors_are_roots_of_E {i : Fin n}
  (h : f i ‚â† p.eval (œâs i)) : (E œâs f p e).eval (œâs i) = 0

lemma concentration_bounds {deg : ‚Ñï} {domain : Œπ ‚Ü™ F}
  {U : AffineSubspace F (Œπ ‚Üí F)} [Nonempty U]
  (hdiv_pos : 0 < (divergence U (RScodeSet domain deg) : ‚Ñù‚â•0))
  (hdiv_lt : (divergence U (RScodeSet domain deg) : ‚Ñù‚â•0) < 1 - ReedSolomonCode.sqrtRate deg domain)
  : let Œ¥' := divergence U (RScodeSet domain deg)
    Pr_{let u ‚Üê $·µñ U}[Code.relHammingDistToCode u (RScodeSet domain deg) ‚â† Œ¥']
    ‚â§ errorBound Œ¥' deg domain

lemma getHighBits_no_shl_joinBits {n m : ‚Ñï} (low : Fin (2 ^ n)) (high : Fin (2 ^ m)) :
  getHighBits_no_shl n (joinBits low high).val = high.val

lemma W_is_additive
  (i : Fin r) :
  IsLinearMap (R := ùîΩq) (M := L) (M‚ÇÇ := L) (f := fun x ‚Ü¶ (W ùîΩq Œ≤ i).eval x)

@[simp]
theorem Z_succ_eq_adjointRoot_root (k : ‚Ñï) : Z (k+1) = AdjoinRoot.root (poly k)

theorem cast_runToRound (j : Fin (n‚ÇÅ + 1)) (stmt : StmtIn) (wit : WitIn)
    (P : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec‚ÇÅ) :
    P.runToRound j stmt wit =
      cast (sorry) ((P.cast hn hSpec).runToRound (Fin.cast (congrArg (¬∑ + 1) hn) j) stmt wit)

@[simp]
lemma bIdx_mul_œë_add_i_fin_‚Ñì_pred_lt_‚Ñì (bIdx : Fin (‚Ñì / œë - 1)) (i : Fin (œë - 1))
    : ‚ÜëbIdx * œë + ‚Üëi < ‚Ñì

lemma towerRingHomForwardMap_zero {k : ‚Ñï} :
  (towerRingHomForwardMap k) 0 = 0

@[simp]
theorem happend_left {Œ± : Fin m ‚Üí Sort u} {Œ≤ : Fin n ‚Üí Sort u}
    (u : (i : Fin m) ‚Üí Œ± i) (v : (i : Fin n) ‚Üí Œ≤ i) (i : Fin m) :
    happend u v (castAdd n i) = cast (vappend_left Œ± Œ≤ i).symm (u i)

@[simp]
lemma OracleReduction.append_toReduction
    (R‚ÇÅ : OracleReduction oSpec Stmt‚ÇÅ OStmt‚ÇÅ Wit‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ Wit‚ÇÇ pSpec‚ÇÅ)
    (R‚ÇÇ : OracleReduction oSpec Stmt‚ÇÇ OStmt‚ÇÇ Wit‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ Wit‚ÇÉ pSpec‚ÇÇ) :
      (OracleReduction.append R‚ÇÅ R‚ÇÇ).toReduction =
        Reduction.append R‚ÇÅ.toReduction R‚ÇÇ.toReduction

lemma getBit_zero_eq_self {n : ‚Ñï} (h_n : n < 2) : getBit 0 n = n

lemma mem_image_support_coeff_finSuccEquivNth {f : MvPolynomial (Fin (n + 1)) R} {i : ‚Ñï} {x} :
    x ‚àà Finsupp.insertNth p i '' ((finSuccEquivNth R p f).coeff i).support ‚Üî
      x ‚àà f.support ‚àß x p = i

theorem finrank_degreeLT_n (n : ‚Ñï) : Module.finrank L (L‚¶É< n‚¶Ñ[X]) = n

@[simp]
lemma solutionToQ_coeff :
  (solutionToQ e k v).coeff n = if n < e + k then liftF v (e + n) else 0

theorem Fin.sum_univ_odd_even {n : ‚Ñï} {M : Type*} [AddCommMonoid M] (f : ‚Ñï ‚Üí M) :
    (‚àë i : Fin (2 ^ n), f (2 * i)) + (‚àë i : Fin (2 ^ n), f (2 * i + 1))
    = ‚àë i: Fin (2 ^ (n+1)), f i

lemma eq_iff_eq_all_getBits {n m : ‚Ñï} : n = m ‚Üî ‚àÄ k, getBit k n = getBit k m

theorem add_assoc {n : ‚Ñï} (a b c : CNat (n + 1)) : (a + b) + c = a + (b + c)

theorem sum_of_pow_exp_of_2 {F : Type*} [Field F]
  (sumZeroIffEq : ‚àÄ (x y : F), x + y = 0 ‚Üî x = y)
  (i : ‚Ñï) : ‚àÄ (a b c : F), a + b = c ‚Üí a^(2^i) + b^(2^i) = c^(2^i)

theorem snoc_ne_zero_of_right (h : y ‚â† 0) : snoc s y ‚â† 0

theorem is_prime : Nat.Prime fieldSize

theorem frobenius_identity_in_ground_field
  [Fact (Nat.Prime (ringChar Fq))] (f g : Fq[X]) :
    (f + g)^(Fintype.card Fq) = f^(Fintype.card Fq) + g^(Fintype.card Fq)

private lemma k_choose_2 [Zero F] {B : Finset (Fin n ‚Üí F)}
  (h_n : n ‚â† 0)
  (h_B : B.card ‚â† 0)
  :
  n * choose_2 (k B) ‚â§ ‚àë i, choose_2 (K B i 0)

lemma concrete_mul_right_distrib0 (a b c : ConcreteBTField 0) :
  concrete_mul (a + b) c = concrete_mul a c + concrete_mul b c

lemma evenPart_def :
  evenPart f = C (2‚Åª¬π : F) * (f + f.comp (-X))

lemma bIdx_succ_mul_œë_le_‚Ñì_succ (bIdx : Fin (‚Ñì / œë - 1)) : (‚ÜëbIdx + 1) * œë ‚â§ ‚Ñì + 1

lemma polynomialOfCoeffs_coeffsOfPolynomial {p : F[X]}
  (h : p.natDegree + 1 = deg) : polynomialOfCoeffs (coeffsOfPolynomial (deg := deg) p) = p

@[simp] theorem rightpad_length (n : Nat) (unit : Œ±) (l : List Œ±) :
    (rightpad n unit l).length = max n l.length

lemma probOfBadPts {deg : ‚Ñï} {Œ± : Œπ ‚Ü™ F} {e : ‚Ñï} {U : Matrix Œ∫ Œπ F}
  (he : (e : ‚Ñö) < (Code.minDist (RScodeSet Œ± deg) : ‚Ñö) / 3)
  (hU : e < Œî(U, matrixSubmoduleOfLinearCode Œ∫ (ReedSolomon.code Œ± deg))) :
  (PMF.uniformOfFintype (Matrix.rowSpan U)).toOuterMeasure
    { w | distFromCode (n := Œπ) (R := F) w (ReedSolomon.code Œ± deg) ‚â§ e }
  ‚â§ (Code.minDist (RScodeSet Œ± deg) : ‚Ñù‚â•0) /(Fintype.card F : ‚Ñù‚â•0)

theorem frobenius_identity_in_algebra [Fact (Nat.Prime (ringChar Fq))]
  (f g : L[X]) : (f + g)^(Fintype.card Fq) = f^(Fintype.card Fq) + g^(Fintype.card Fq)

lemma exists_Pz_of_coeffs_of_close_proximity
  {k : ‚Ñï}
  {z : F}
  (hS : z ‚àà coeffs_of_close_proximity (k := k) œâs Œ¥ u‚ÇÄ u‚ÇÅ)
  :
  ‚àÉ Pz : F[X], Pz.natDegree ‚â§ k ‚àß Œ¥·µ£(u‚ÇÄ + z ‚Ä¢ u‚ÇÅ, Pz.eval ‚àò œâs) ‚â§ Œ¥

theorem evenRefinement_eq_novel_poly_of_0_leading_suffix (i : Fin ‚Ñì) (v : Fin (2 ^ i.val))
    (original_coeffs : Fin (2 ^ ‚Ñì) ‚Üí L) :
    have h_v: v.val < 2 ^ (i.val + 1) := by
      calc v.val < 2 ^ i.val := by omega
        _ < 2 ^ (i.val + 1) := by apply Nat.pow_lt_pow_right (by omega) (by omega)
    evenRefinement ùîΩq Œ≤ h_‚Ñì_add_R_rate i (coeffsBySuffix (r:=r)
      (R_rate:=R_rate) (a:=original_coeffs) ‚ü®i, by omega‚ü© v) =
    intermediateEvaluationPoly ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i + 1, by omega‚ü©
      (coeffsBySuffix (r:=r) (R_rate:=R_rate) original_coeffs ‚ü®i + 1, by omega‚ü© ‚ü®v, h_v‚ü©)

theorem hammingDist_le_of_outer_comp_injective {Œπ‚ÇÅ Œπ‚ÇÇ : Type*} [Fintype Œπ‚ÇÅ] [Fintype Œπ‚ÇÇ]
    {Œ≤ : Œπ‚ÇÇ ‚Üí Type*} [‚àÄ i, DecidableEq (Œ≤ i)] [DecidableEq Œπ‚ÇÇ]
    (x y : ‚àÄ i, Œ≤ i) (g : Œπ‚ÇÅ ‚Üí Œπ‚ÇÇ) (hg : Function.Injective g) :
    hammingDist (fun i => x (g i)) (fun i => y (g i)) ‚â§ hammingDist x y

lemma Lemma_A_1 {H : F[X][Y]} (Œ≤ : ùí™ H) (D : ‚Ñï) (hD : D ‚â• Bivariate.totalDegree H)
    (S_Œ≤_card : Set.ncard (S_Œ≤ Œ≤) > (weight_Œõ_over_ùí™ Œ≤ D) * H.natDegree) :
  embeddingOfùí™IntoùïÉ _ Œ≤ = 0

theorem drop_eq_rtake' {Œ± : Sort*} (m : ‚Ñï) (h : m ‚â§ n) (v : Fin n ‚Üí Œ±) :
    drop m h v = rtake (n - m) (by omega) v

@[simp]
theorem splitSum_zero {n : Fin 0 ‚Üí ‚Ñï} {k : Fin (vsum n)} : splitSum k = Fin.elim0 k

lemma getBit_of_add_distrib {n m k : ‚Ñï}
  (h_n_AND_m : n &&& m = 0) : getBit k (n + m) = getBit k n + getBit k m

@[simp]
theorem cast_dir_idx_symm {hn} (hSpec : pSpec‚ÇÅ.cast hn = pSpec‚ÇÇ) {i : Fin n‚ÇÇ} :
    pSpec‚ÇÅ.dir (Fin.cast hn.symm i) = pSpec‚ÇÇ.dir i

theorem liftContext_runToRound
    {lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    {outerStmtIn : OuterStmtIn} {outerWitIn : OuterWitIn} {i : Fin (n + 1)}
    (P : Prover oSpec InnerStmtIn InnerWitIn InnerStmtOut InnerWitOut pSpec) :
      (P.liftContext lens).runToRound i outerStmtIn outerWitIn
      = do
        let ‚ü®transcript, prvState‚ü© ‚Üê
          (P.runToRound i).uncurry (lens.proj (outerStmtIn, outerWitIn))
        return ‚ü®transcript, ‚ü®prvState, outerStmtIn, outerWitIn‚ü©‚ü©

theorem ofFn_drop_eq_drop_ofFn {Œ± : Type*} {m : ‚Ñï} (h : m ‚â§ n) (v : Fin n ‚Üí Œ±) :
    List.ofFn (drop m h v) = (List.ofFn v).drop m

@[simp]
theorem leftpad_apply_lt (n : ‚Ñï) (a : Œ±) (v : Fin m ‚Üí Œ±) (i : Fin n)
    (h : i.val < n - m) : leftpad n a v i = a

theorem foldOracleReduction_perfectCompleteness (hInit : init.neverFails) (i : Fin ‚Ñì) :
    OracleReduction.perfectCompleteness
      (pSpec := pSpecFold (L := L))
      (relIn := roundRelation ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        (ùìë := ùìë) i.castSucc (mp := mp))
      (relOut := foldStepRelOut ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        (ùìë := ùìë) i (mp := mp))
      (oracleReduction := foldOracleReduction ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i)
      (init := init)
      (impl := impl)

lemma join_split_eq_join {k : ‚Ñï} (h_pos : k > 0) (x : ConcreteBTField k) :
  „Ää (split h_pos x).fst, (split h_pos x).snd „Äã = x

@[grind _=_]
lemma weightedDegree_eq_natWeightedDegree {u v : ‚Ñï} :
  f ‚â† 0 ‚Üí weightedDegree f u v = natWeightedDegree f u v

theorem liftContext_runWithLog
    {lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    {outerStmtIn : OuterStmtIn} {outerWitIn : OuterWitIn}
    {P : Prover oSpec InnerStmtIn InnerWitIn InnerStmtOut InnerWitOut pSpec} :
      (P.liftContext lens).runWithLog outerStmtIn outerWitIn
      = do
        let ‚ü®‚ü®fullTranscript, innerCtxOut‚ü©, queryLog‚ü© ‚Üê
          P.runWithLog.uncurry (lens.proj (outerStmtIn, outerWitIn))
        return ‚ü®‚ü®fullTranscript, lens.lift (outerStmtIn, outerWitIn) innerCtxOut‚ü©, queryLog‚ü©

Nat.add_le_of_le_sub in Init.Data.Nat.Basic

theorem BitVec.dcast_bitvec_toNat_eq {w w2 : ‚Ñï} (x : BitVec w) (h_width_eq : w = w2) :
    BitVec.toNat x = BitVec.toNat (dcast (h_width_eq) x)

Fin.val_succ in Init.Data.Fin.Lemmas

Nat.zero_le in Init.Prelude

Nat.zero_add in Init.Data.Nat.Basic

@[simp]
lemma relHammingDist_mem_relHammingDistRange [DecidableEq F] : Œ¥·µ£(u, v) ‚àà relHammingDistRange Œπ

theorem pow_one {a : CNat 50} : a ^ 1 = a

@[simp]
lemma numFullRounds_pos : 0 < params.numFullRounds

@[simp]
theorem runWithOracle_freeMonad_pure_some (f : spec.FunctionType) (a : Œ±) :
    runWithOracle f (FreeMonad.pure (a : Option Œ±)) = a

theorem mul_assoc (m n p : ChurchNat Œ±) : mul (mul m n) p = mul m (mul n p)

lemma cons_get_eq {Œ±} {n : ‚Ñï} (hd : Œ±) (tl : Vector Œ± n) (i : Fin (n + 1)) :
    (cons hd tl).get i =
      if hi: i.val == 0 then hd else tl.get (‚ü®i.val - 1, by
        simp only [beq_iff_eq, Fin.val_eq_zero_iff] at hi
        apply Nat.sub_lt_left_of_lt_add
        ¬∑ by_contra hi_ne_gt_1
          simp only [not_le, Nat.lt_one_iff, Fin.val_eq_zero_iff] at hi_ne_gt_1
          contradiction
        ¬∑ have hi_lt:= i.isLt; omega
      ‚ü©)

lemma extract_start_zero_eq_take {n : ‚Ñï} {Œ± : Fin n ‚Üí Sort*} (stop : ‚Ñï) (h : stop ‚â§ n)
    (v : (i : Fin n) ‚Üí Œ± i) : extract 0 stop (Nat.zero_le _) h v = take stop h v

@[simp] theorem BitVec.dcast_zero {n m : ‚Ñï} (h : n = m) : DCast.dcast h (0#n) = 0#m

private lemma f_convex {x‚ÇÅ x‚ÇÇ : ‚Ñö} {Œ±‚ÇÅ Œ±‚ÇÇ : ‚Ñö}
  (h_noneg_1 : 0 ‚â§ Œ±‚ÇÅ)
  (h_noneg_2 : 0 ‚â§ Œ±‚ÇÇ)
  (h_conv : Œ±‚ÇÅ + Œ±‚ÇÇ = 1)
  :
  f (Œ±‚ÇÅ * x‚ÇÅ + Œ±‚ÇÇ * x‚ÇÇ) ‚â§ Œ±‚ÇÅ * f x‚ÇÅ + Œ±‚ÇÇ * f x‚ÇÇ

theorem traceMapProperty_of_quadratic_extension
  (F_prev : Type*) [Field F_prev] [Fintype F_prev] (k : ‚Ñï)
  (fintypeCardPrev : Fintype.card F_prev = 2 ^ (2 ^ k))
  (t1 : F_prev) [instNeZero_t1 : NeZero t1]
  {F_cur : Type*} [Field F_cur] (u : F_cur) [instNeZero_u : NeZero u]
  [Algebra F_prev F_cur]
  (h_rel : SpecialElementRelation (t1 := t1) (u := u))
  (prev_trace_map : TraceMapProperty F_prev t1 (k))
  (sumZeroIffEq : ‚àÄ (x y : F_cur), x + y = 0 ‚Üî x = y)
  : TraceMapProperty F_cur u (k + 1)

theorem linear_form_of_elements_in_adjoined_commring
    {R : Type*} [CommRing R] (f : R[X]) (hf_deg : f.natDegree = 2)
    (hf_monic : Monic f) (c1 : AdjoinRoot f) :
    ‚àÉ a b : R, c1 = (AdjoinRoot.of f) a * root f + (AdjoinRoot.of f) b

theorem not_exists_of_decoder_eq_none {e k : ‚Ñï} [NeZero n] {œâs f : Fin n ‚Üí F}
  (he : 2 * e < n - k + 1)
  (hn : k ‚â§ n)
  (h_inj : Function.Injective œâs)
  (h_none : decoder e k œâs f = none)
  : ¬¨‚àÉp : F[X], Œî‚ÇÄ(f, p.eval ‚àò œâs) ‚â§ e ‚àß p.natDegree < k

@[simp]
theorem cast_val {m n : ‚Ñï} (h : m = n) (a : Fin m) : (Fin.cast h a).val = a.val

lemma distToCode_of_nonempty {Œ± : Type*} [LinearOrder Œ±] [Zero Œ±]
                             {Œπ F : Type*}
                             {w : Œπ ‚Üí F} {C : Set (Œπ ‚Üí F)}
                             {Œ¥f : (Œπ ‚Üí F) ‚Üí (Œπ ‚Üí F) ‚Üí Œ±}
                             (h‚ÇÅ : (possibleDistsToCode w C Œ¥f).Finite)
                             (h‚ÇÇ : (possibleDistsToCode w C Œ¥f).Nonempty) :
  haveI := @Fintype.ofFinite _ h‚ÇÅ
  distToCode w C Œ¥f h‚ÇÅ = .some ((possibleDistsToCode w C Œ¥f).toFinset.min' (by simpa))

theorem foldr_split_outer {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤ ‚Üí Œ≤) (init : Œ≤)
    (l : List Œ±) (h : l ‚â† []): foldr (f:=f) (init:=init) (l)
    = f (l.head (by omega)) (foldr (f:=f) (init:=init) (l.tail))

theorem eval_toImpl_eq_eval [LawfulBEq R] (x : R) (p : R[X]) : p.toImpl.eval x = p.eval x

@[simp]
theorem fcons_zero {Œ≤ : Fin n ‚Üí A} (a : F Œ±) (b : (i : Fin n) ‚Üí F (Œ≤ i)) :
    fcons a b 0 = cast (by simp [vcons_zero]) a

lemma algebraMap_succ_eq_zero_x {k : ‚Ñï} (h_pos : k > 0) (x : ConcreteBTField (k - 1)) :
  letI instAlgebra := ConcreteBTFieldAlgebra (l:=k-1) (r:=k) (h_le:=by omega)
  algebraMap (ConcreteBTField (k - 1)) (ConcreteBTField k) x = „Ää 0, x „Äã

lemma and_by_split_lowBits {n m n1 m1 bn bm : ‚Ñï} (h_bn : bn < 2) (h_bm : bm < 2)
  (h_n : n = n1 * 2 + bn) (h_m : m = m1 * 2 + bm):
  n &&& m = (n1 &&& m1) * 2 + (bn &&& bm)

lemma blockRelDistance_eq_relHammingDist_of_k_eq_i -- Renamed for clarity
  (i : ‚Ñï) {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F}
  [DecidableEq F] [DecidableEq Œπ] [Smooth œÜ]
  -- The Fintype instance is now declared before it is needed by `hS'`.
  [h_fintype : ‚àÄ i : ‚Ñï, Fintype (indexPowT S œÜ i)]
  (f g : (indexPowT S œÜ i) ‚Üí F) (S' : Finset (indexPowT S œÜ i))
  (hS' : S' = Finset.univ) -- This now works.
  (œÜ' : (indexPowT S œÜ i) ‚Ü™ F)
  [h_dec : DecidableBlockDisagreement i i f S' œÜ'] [DecidableEq (indexPowT S œÜ i)] :
  Œî·µ£(i, i, f, S', œÜ', g) = Œ¥·µ£(f, g)

theorem congrArg‚ÇÑ {Œ± Œ≤ Œ≥ Œ¥ Œµ : Sort*} {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥ ‚Üí Œ¥ ‚Üí Œµ} {a a' : Œ±} {b b' : Œ≤} {c c' : Œ≥}
    {d d' : Œ¥} (h : a = a') (h' : b = b') (h'' : c = c') (h''' : d = d') :
      f a b c d = f a' b' c' d'

theorem mobius_apply_zeta_apply_eq_id (n : ‚Ñï) [NeZero n] (r : Fin n) (l : Fin (r.val + 1))
    (v : Vector R (2 ^ n)) : lagrangeToMono_segment n r l (monoToLagrange_segment n r l v) = v

@[simp]
lemma coe_toFun_of_coe_apply (f : ‚àÄ a, Œ≤ a) (a : Œ±) : (f : F) a = f a

lemma toImpl_nonzero {p : Q[X]} (hp : p ‚â† 0) : p.toImpl.size > 0

@[simp]
lemma oddPart_coeff {f : Polynomial F} {n : ‚Ñï} :
    (oddPart f).coeff n = if Even n then f.coeff (n + 1) else 0

lemma zero_def [Zero R] : zero = Vector.replicate (2 ^ n) 0

@[simp]
theorem PowerBasis.cast_basis_succ_of_eq_rec_apply
    (r1 r : ‚Ñï) (h_r : r = r1 + 1)
    (k : Fin 2) :
    letI instAlgebra : Algebra (ConcreteBTField r1) (ConcreteBTField r) :=
      ConcreteBTFieldAlgebra (l:=r1) (r:=r) (h_le:=by omega)
    letI instAlgebraSucc : Algebra (ConcreteBTField (r1 + 1)) (ConcreteBTField (r)) :=
      ConcreteBTFieldAlgebra (l:=r1 + 1) (r:=r) (h_le:=by omega)
    let b : PowerBasis (ConcreteBTField r1) (ConcreteBTField (r1 + 1))
      := powerBasisSucc (k:=r1)
    let bCast : PowerBasis (ConcreteBTField r1) (ConcreteBTField r) := Eq.rec (motive:=
      fun (x : ‚Ñï) (_ : r1 + 1 = x) => by
        letI instAlgebraCur : Algebra (ConcreteBTField r1) (ConcreteBTField x) :=
          ConcreteBTFieldAlgebra (l:=r1) (r:=x) (h_le:=by omega)
        exact PowerBasis (ConcreteBTField r1) (ConcreteBTField x)) (refl:=b) (t:=h_r.symm)
    have h_pb_dim : b.dim = 2 := by
      exact powerBasisSucc_dim r1

    have h_pb'_dim : bCast.dim = 2 := by
      dsimp [bCast]
      rw [PowerBasis.dim_of_eq_rec (r1:=r1) (r:=r) (h_r:=h_r) (b:=b)]
      exact h_pb_dim

    have h_pb_type_eq : Basis (Fin bCast.dim) (ConcreteBTField r1) (ConcreteBTField r) =
      Basis (Fin 2) (ConcreteBTField r1) (ConcreteBTField r) := by
      congr

   -- The `cast` needs a proof that `bCast.dim = 2`. We construct it here.
    let left : Basis (Fin 2) (ConcreteBTField r1) (ConcreteBTField r)
      := cast (by exact h_pb_type_eq) bCast.basis
    let right := (algebraMap (ConcreteBTField (r1 + 1)) (ConcreteBTField r))
      (b.basis (Fin.cast h_pb_dim.symm k))
    left k = right

theorem singleton_subset_Icc (n : ‚Ñï) : {1} ‚äÜ Finset.Icc 1 (n + 1)

lemma algebraMap_eq_zero_x {i j : ‚Ñï} (h_le : i < j) (x : ConcreteBTField i) :
    letI instAlgebra := ConcreteBTFieldAlgebra (l:=i) (r:=j) (h_le:=by omega)
    letI instAlgebraPred := ConcreteBTFieldAlgebra (l:=i) (r:=j-1) (h_le:=by omega)
    algebraMap (ConcreteBTField i) (ConcreteBTField j) x
      = „Ää 0, algebraMap (ConcreteBTField i) (ConcreteBTField (j-1)) x „Äã

theorem fconcat‚ÇÇ_left_injective {Œ±‚ÇÅ : Fin n ‚Üí A} {Œ±‚ÇÇ : Fin n ‚Üí B} {Œ≤‚ÇÅ : A} {Œ≤‚ÇÇ : B} (a : F‚ÇÇ Œ≤‚ÇÅ Œ≤‚ÇÇ) :
    Function.Injective (fun v : (i : Fin n) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i) => fconcat‚ÇÇ (F := F‚ÇÇ) v a)

theorem degreeOf_linear_le {a b : R} : degreeOf n (C a + C b * p) ‚â§ degreeOf n p

@[simp, grind _=_]
lemma degreeX_mul [IsDomain F] (f g : F[X][Y]) (hf : f ‚â† 0) (hg : g ‚â† 0) :
  degreeX (f * g) = degreeX f + degreeX g

theorem two_eq_zero_in_char2_field {F : Type*} [Field F]
  (sumZeroIffEq : ‚àÄ (x y : F), x + y = 0 ‚Üî x = y) : (2 : F) = 0

lemma towerRingHomForwardMap_split_eq (k : ‚Ñï) (h_pos : k > 0) (x : ConcreteBTField k) :
  let p := split (k:=k) (h:=h_pos) x
  towerRingHomForwardMap (k:=k) (x) =
    BinaryTower.join_via_add_smul (k:=k) (h_pos:=h_pos)
      (hi_btf := towerRingHomForwardMap (k:=k-1) (p.1))
      (lo_btf := towerRingHomForwardMap (k:=k-1) (p.2))

theorem Reduction.run_of_prover_first [ProverOnly pSpec] (stmt : StmtIn) (wit : WitIn)
    (reduction : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      reduction.run stmt wit = (do
        let state := reduction.prover.input (stmt, wit)
        let ‚ü®msg, state‚ü© ‚Üê liftComp (reduction.prover.sendMessage ‚ü®0, by simp‚ü© state) _
        let ctxOut ‚Üê reduction.prover.output state
        let transcript : pSpec.FullTranscript := fun i => match i with | ‚ü®0, _‚ü© => msg
        let stmtOut ‚Üê reduction.verifier.verify stmt transcript
        return (‚ü®transcript, ctxOut‚ü©, stmtOut))

lemma getLowBits_le_self {n : ‚Ñï} (numLowBits : ‚Ñï) : getLowBits numLowBits n ‚â§ n

List.length_drop in Init.Data.List.TakeDrop

Nat.lt_of_le_of_lt in Init.Prelude

@[simp]
lemma concrete_natCast_one_eq_one {k : ‚Ñï} : natCast 1 = (1 : ConcreteBTField k)

lemma shift_left_def {s : Finset ‚Ñï} :
    shift_left s = s.filterMap
    (fun n => match n with
      | 0 => .none
      | n + 1 => .some n
      )
    (by aesop)

@[simp]
theorem simulateQ_map_fst (oa : OracleComp spec Œ±) :
    Prod.fst <$> (simulateQ loggingOracle oa).run = oa

theorem getBit_repr {‚Ñì : Nat} : ‚àÄ j, j < 2^‚Ñì ‚Üí
  j = ‚àë k ‚àà Finset.Icc 0 (‚Ñì-1), (getBit k j) * 2^k

private lemma sum_sum_K_i_eq_n_sub_d
  (h_B : 2 ‚â§ B.card)
  :
  ‚àë i, sum_choose_K_i B i = choose_2 B.card * (n - d B)

theorem reduction_perfectCompleteness (hInit : init.neverFails) :
    (reduction R deg D n oSpec).perfectCompleteness init impl
      (relationRound R n deg D 0) (relationRound R n deg D (.last n))

Fin.append_right in Mathlib.Data.Fin.Tuple.Basic

theorem johnson_bound [Field F]
  (h_condition : JohnsonConditionStrong B v)
  :
  let d := d B
  let q : ‚Ñö := Fintype.card F
  let frac := q / (q - 1)
  B.card ‚â§ (frac * d/n) / JohnsonDenominator B v

@[csimp, grind =]
theorem idxOf'_eq_idxOf : @idxOf' = @idxOf

lemma algebraMap_adjacent_tower_def (l : ‚Ñï) :
  (algebraMap (BTField l) (BTField (l + 1))) = canonicalEmbedding l

@[simp]
lemma oddPart_by_2 :
    2 * (oddPart f) = (f - f.comp (-X)) /‚Çò X

theorem eval_zeroOne_eq_MLE_toEvalsZeroOne (p : MvPolynomial œÉ R) (x : œÉ ‚Üí Fin 2) :
    eval (x : œÉ ‚Üí R) p = eval (x : œÉ ‚Üí R) (MLE p.toEvalsZeroOne)

lemma bwm_of_neg [NeZero n] (h : e ‚â§ j.1) :
  BerlekampWelchMatrix e k œâs f i j = -(œâs i)^(j - e)

theorem verifier_rbrKnowledgeSoundness [Fintype R] :
    (verifier R deg D oSpec).rbrKnowledgeSoundness init impl
    (inputRelation R deg D) (outputRelation R deg) (fun _ => (deg : ‚Ñù‚â•0) / (Fintype.card R))

theorem zero_add (hp : p.canonical) : 0 + p = p

theorem liftContext_rbr_knowledgeSoundness [Inhabited InnerWitIn]
    {rbrKnowledgeError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    {stmtLens : OracleStatement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                                OuterOStmtIn OuterOStmtOut InnerOStmtIn InnerOStmtOut}
    {witLens : Witness.InvLens (OuterStmtIn √ó ‚àÄ i, OuterOStmtIn i)
                            OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    (V : OracleVerifier oSpec InnerStmtIn InnerOStmtIn InnerStmtOut InnerOStmtOut pSpec)
    [lensKS : Extractor.Lens.IsKnowledgeSound
      outerRelIn innerRelIn outerRelOut innerRelOut
      (V.toVerifier.compatStatement stmtLens) (fun _ _ => True) ‚ü®stmtLens, witLens‚ü©]
    (h : V.rbrKnowledgeSoundness init impl innerRelIn innerRelOut rbrKnowledgeError) :
      (V.liftContext stmtLens).rbrKnowledgeSoundness init impl outerRelIn outerRelOut
        rbrKnowledgeError

theorem ConcreteBTFieldAlgebra_apply_assoc (l mid r : ‚Ñï)
    (h_l_le_mid : l ‚â§ mid) (h_mid_le_r : mid ‚â§ r) :
    ‚àÄ x : ConcreteBTField l,
    (@ConcreteBTFieldAlgebra (l:=l) (r:=r) (h_le:=by
      exact Nat.le_trans h_l_le_mid h_mid_le_r)).algebraMap x =
    (@ConcreteBTFieldAlgebra (l:=mid) (r:=r) (h_le:=h_mid_le_r)).algebraMap
      ((@ConcreteBTFieldAlgebra (l:=l) (r:=mid) (h_le:=h_l_le_mid)).algebraMap x)

@[simp]
protected lemma elocPoly_zero : ElocPoly 0 œâs f p = 1

@[simp]
lemma seqCompose_toReduction {m : ‚Ñï}
    (Stmt : Fin (m + 1) ‚Üí Type)
    {Œπ‚Çõ : Fin (m + 1) ‚Üí Type} (OStmt : (i : Fin (m + 1)) ‚Üí Œπ‚Çõ i ‚Üí Type)
    [O‚Çõ : ‚àÄ i, ‚àÄ j, OracleInterface (OStmt i j)]
    (Wit : Fin (m + 1) ‚Üí Type)
    {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    [O‚Çò : ‚àÄ i, ‚àÄ j, OracleInterface ((pSpec i).Message j)]
    (R : (i : Fin m) ‚Üí
      OracleReduction oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Wit i.castSucc)
        (Stmt i.succ) (OStmt i.succ) (Wit i.succ) (pSpec i)) :
    (seqCompose Stmt OStmt Wit R).toReduction =
      Reduction.seqCompose (fun i => Stmt i √ó (‚àÄ j, OStmt i j)) Wit
        (fun i => (R i).toReduction)

lemma exist_bit_diff_if_diff {n: ‚Ñï} (a: Fin (2^n)) (b: Fin (2^n)) (h_a_ne_b: a ‚â† b):
  ‚àÉ k: Fin n, getBit k a ‚â† getBit k b

lemma inv_eq_pow (a : Field) (ha : a ‚â† 0) : a‚Åª¬π = a ^ (fieldSize - 2)

theorem oracleReduction_eq_reduction :
    (oracleReduction R deg D oSpec).toReduction = reduction R deg D oSpec

theorem vconcat_eq_snoc (v : Fin n ‚Üí Œ±) (a : Œ±) : vconcat v a = snoc v a

@[simp]
theorem generateProof_leaf (a : Œ±) (idx) :
    generateProof (FullData.leaf a) idx = []

lemma mem_support_coeff_finSuccEquivNth {f : MvPolynomial (Fin (n + 1)) R} {i : ‚Ñï} {x} :
    x ‚àà ((finSuccEquivNth R p f).coeff i).support ‚Üî x.insertNth p i ‚àà f.support

@[simp]
theorem happend_right {Œ± : Fin m ‚Üí Sort u} {Œ≤ : Fin n ‚Üí Sort u}
    (u : (i : Fin m) ‚Üí Œ± i) (v : (i : Fin n) ‚Üí Œ≤ i) (i : Fin n) :
    happend u v (natAdd m i) = cast (vappend_right Œ± Œ≤ i).symm (v i)

lemma testBit_false_eq_getBit_eq_0 (k n : Nat) :
  (n.testBit k = false) = ((Nat.getBit k n) = 0)

@[simp, grind =]
theorem monomialXY_eq_zero_iff {n m : ‚Ñï} {a : F} : monomialXY n m a = 0 ‚Üî a = 0

theorem randomOracle_cache_neverFails_iff_runWithOracle_neverFails {Œ≤}
    [DecidableEq Œπ] [spec.DecidableEq] [(i : Œπ) ‚Üí SelectableType (OracleSpec.range spec i)]
    (oa : OracleComp (spec) Œ≤) (preexisting_cache : spec.QueryCache)
    :
    ((oa.simulateQ randomOracle).run preexisting_cache).neverFails
    ‚Üî
    (‚àÄ (f : spec.FunctionType),
      Oracle.containsCache f preexisting_cache ‚Üí
      (runWithOracle f oa).isSome)

lemma bIdx_succ_mul_œë_lt_‚Ñì_succ (bIdx : Fin (‚Ñì / œë - 1)) :
    (‚ÜëbIdx + 1) * œë < ‚Ñì + 1

lemma decoded_polynomial_lt_deg (c : ReedSolomon.code domain deg) :
  decode c ‚àà (degreeLT F deg : Submodule F F[X])

@[simp]
lemma list_eq (k : ‚Ñï) :
  list (k+1) = (Z (k+1)) ::·µ• (list k).map (AdjoinRoot.of (poly k))

@[simp]
lemma bIdx_mul_œë_add_i_lt_‚Ñì_succ {m : ‚Ñï} (bIdx : Fin (‚Ñì / œë - 1)) (i : Fin œë) :
    ‚ÜëbIdx * œë + ‚Üëi < ‚Ñì + m

@[simp]
lemma challengeOracleInterface_append_range_inl (j : pSpec‚ÇÅ.ChallengeIdx) :
    [(pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).Challenge]‚Çí.range (.inl j) = pSpec‚ÇÅ.Challenge j

@[simp]
theorem fappend‚ÇÇ_zero {Œ±‚ÇÅ : Fin m ‚Üí A} {Œ±‚ÇÇ : Fin m ‚Üí B} {Œ≤‚ÇÅ : Fin 0 ‚Üí A} {Œ≤‚ÇÇ : Fin 0 ‚Üí B}
    (u : (i : Fin m) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i)) :
    fappend‚ÇÇ (F := F‚ÇÇ) u (!h‚¶ÉF‚ÇÇ‚¶Ñ‚ü®Œ≤‚ÇÅ‚ü©‚ü®Œ≤‚ÇÇ‚ü©[] : (i : Fin 0) ‚Üí F‚ÇÇ (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) = u

@[simp]
lemma challengeOracleInterface_append_domain_inr (j : pSpec‚ÇÇ.ChallengeIdx) :
    [(pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).Challenge]‚Çí.domain (.inr j) = Unit

theorem append_knowledgeSoundness (V‚ÇÅ : OracleVerifier oSpec Stmt‚ÇÅ OStmt‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : OracleVerifier oSpec Stmt‚ÇÇ OStmt‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ pSpec‚ÇÇ)
    {knowledgeError‚ÇÅ knowledgeError‚ÇÇ : ‚Ñù‚â•0}
    (h‚ÇÅ : V‚ÇÅ.knowledgeSoundness init impl rel‚ÇÅ rel‚ÇÇ knowledgeError‚ÇÅ)
    (h‚ÇÇ : V‚ÇÇ.knowledgeSoundness init impl rel‚ÇÇ rel‚ÇÉ knowledgeError‚ÇÇ) :
      (V‚ÇÅ.append V‚ÇÇ).knowledgeSoundness init impl rel‚ÇÅ rel‚ÇÉ
        (knowledgeError‚ÇÅ + knowledgeError‚ÇÇ)

lemma poly_natDegree_eq_2 (k : ‚Ñï) : (poly (k:=k)).natDegree = 2

lemma rowRank_eq_colRank : rowRank U = colRank U

lemma contract_eq_liftF_of_lt {k : ‚Ñï} (h‚ÇÅ : k < m) :
  contract m f' k = liftF f' k

theorem vcons_left_injective (v : Fin n ‚Üí Œ±) : Function.Injective (fun a => a ::·µõ v)

Fin.is_le' in Init.Data.Fin.Lemmas

Nat.le_add_left in Init.Data.Nat.Basic

theorem join_eq_iff_dcast_extractLsb {k : ‚Ñï} (h_pos : k > 0) (x : ConcreteBTField k)
  (hi_btf lo_btf : ConcreteBTField (k - 1)) :
  x = „Ää hi_btf, lo_btf „Äã ‚Üî
  (hi_btf = dcast (h_sub_middle h_pos) (BitVec.extractLsb (hi := 2 ^ k - 1) (lo := 2 ^ (k - 1)) x) ‚àß
  lo_btf = dcast (h_middle_sub) (BitVec.extractLsb (hi := 2 ^ (k - 1) - 1) (lo := 0) x))

lemma rank_eq_rowRank : U.rank = rowRank U

lemma concrete_zero_mul
  (prevBTFieldProps : ConcreteBTFieldProps (k := k - 1))
  (a : ConcreteBTField k) : concrete_mul (zero (k:=k)) a = zero (k:=k)

theorem base_intermediateNormVpoly
  (k : Fin (‚Ñì + 1)) :
  intermediateNormVpoly ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®0, by
    by_contra ht
    simp only [not_lt, nonpos_iff_eq_zero] at ht
    contradiction
  ‚ü© ‚ü®k, by simp only [tsub_zero]; omega‚ü© =
  normalizedW ùîΩq Œ≤ ‚ü®k, by omega‚ü©

@[simp]
theorem fflatten‚ÇÇ_splitSum {A : Sort u} {B : Sort v} {F : A ‚Üí B ‚Üí Sort w} {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï}
    {Œ± : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí A}
    {Œ≤ : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí B}
    (v : (k : Fin (vsum n)) ‚Üí F (vflatten Œ± k) (vflatten Œ≤ k)) (k : Fin (vsum n)) :
    fflatten‚ÇÇ (fun i j => v (embedSum i j)) k = cast (by simp) (v k)

lemma evenPart_even {f : Polynomial F} :
    EvenPoly (evenPart f)

lemma mul_by_2_def {s : Finset ‚Ñï} :
    mul_by_2 s = s.map ‚ü®fun n => 2 * n, by {
      intro a b
      simp
    }‚ü©

lemma twoAdicGenerators_order (bits : Fin (twoAdicity + 1)) :
    orderOf (twoAdicGenerators[bits]) = 2 ^ (bits : Nat)

theorem cast_eq_cast_iff {Œ± Œ≤ Œ≥ : Sort u} {h : Œ± = Œ≥} {h' : Œ≤ = Œ≥} {a : Œ±} {b : Œ≤} :
    cast h a = cast h' b ‚Üî a = cast (h'.trans h.symm) b

lemma round_bound {n k : ‚Ñï} {s : Fin (k + 1) ‚Üí ‚Ñï+} {d : ‚Ñï+}
    (domain_size_cond : (2 ^ (‚àë i, (s i).1)) * d ‚â§ 2 ^ n) :
  (‚àë i, (s i).1) ‚â§ n

@[simp, grind _=_]
theorem smul_monomialXY {n m : ‚Ñï} {a : F} {S} [SMulZeroClass S F] {b : S} :
  monomialXY n m (b ‚Ä¢ a) = b ‚Ä¢ monomialXY n m a

theorem oracleReduction_rbr_knowledge_soundness : True

lemma not_outOfOrder_of_not_combined (h : ¬¨ E trace) : ¬¨ E_time trace state

theorem cast_injective : Function.Injective (MessageIdx.cast hn hSpec)

@[simp, grind =]
theorem leadingCoeffY_eq_zero (f : F[X][Y]) : leadingCoeffY f = 0 ‚Üî f = 0

theorem succ'_ne_zero (n : Nat) : succ' n ‚â† 0

theorem hconcat_inj {Œ± : Fin n ‚Üí Sort u} {Œ≤ : Sort u} (v‚ÇÅ v‚ÇÇ : (i : Fin n) ‚Üí Œ± i) (a‚ÇÅ a‚ÇÇ : Œ≤) :
    hconcat v‚ÇÅ a‚ÇÅ = hconcat v‚ÇÇ a‚ÇÇ ‚Üî v‚ÇÅ = v‚ÇÇ ‚àß a‚ÇÅ = a‚ÇÇ

@[simp]
lemma possibleRelHammingDistsToC_subset_relHammingDistRange [DecidableEq F] :
  possibleDistsToCode w C relHammingDist ‚äÜ relHammingDistRange Œπ

theorem oracleVerifier_rbrKnowledgeSoundness [Fintype R] :
    (oracleVerifier R deg D oSpec).rbrKnowledgeSoundness init impl
    (inputRelation R deg D) (outputRelation R deg) (fun _ => (deg : ‚Ñù‚â•0) / (Fintype.card R))

@[simp, grind _=_]
theorem totalDegree_mul {f g : F[X][Y]} (hf : f ‚â† 0) (hg : g ‚â† 0) :
    totalDegree (f * g) = totalDegree f + totalDegree g

theorem append_perfectCompleteness (R‚ÇÅ : Reduction oSpec Stmt‚ÇÅ Wit‚ÇÅ Stmt‚ÇÇ Wit‚ÇÇ pSpec‚ÇÅ)
    (R‚ÇÇ : Reduction oSpec Stmt‚ÇÇ Wit‚ÇÇ Stmt‚ÇÉ Wit‚ÇÉ pSpec‚ÇÇ)
    (h‚ÇÅ : R‚ÇÅ.perfectCompleteness init impl rel‚ÇÅ rel‚ÇÇ)
    (h‚ÇÇ : R‚ÇÇ.perfectCompleteness init impl rel‚ÇÇ rel‚ÇÉ) :
      (R‚ÇÅ.append R‚ÇÇ).perfectCompleteness init impl rel‚ÇÅ rel‚ÇÉ

@[simp]
lemma OracleVerifier.append_toVerifier
    (V‚ÇÅ : OracleVerifier oSpec Stmt‚ÇÅ OStmt‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : OracleVerifier oSpec Stmt‚ÇÇ OStmt‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ pSpec‚ÇÇ) :
      (OracleVerifier.append V‚ÇÅ V‚ÇÇ).toVerifier =
        Verifier.append V‚ÇÅ.toVerifier V‚ÇÇ.toVerifier

lemma rank_nonsquare_eq_deg_of_deg_le (inj : Function.Injective Œ±) (h : n ‚â§ m) :
  (Vandermonde.nonsquare (Œπ' := n) Œ±).rank = n

lemma one_le_sub_middle_of_pow2 {k : ‚Ñï} (h_k : 1 ‚â§ k) : 1 ‚â§ 2 ^ k - 2 ^ (k - 1)

@[simp]
theorem zero_dappend {motive : Fin (0 + n) ‚Üí Sort u} {u : (i : Fin 0) ‚Üí motive (castAdd n i)}
    (v : (i : Fin n) ‚Üí motive (natAdd 0 i)) :
    dappend (motive := motive) u v = fun i => cast (by simp) (v (i.cast (by omega)))

lemma folding
  [Nonempty Œπ] {S : Finset Œπ} [Fintype Œπ]
  (œÜ : Œπ ‚Ü™ F) (f : Œπ ‚Üí F) (k : ‚Ñï)
  [Nonempty (indexPow S œÜ k)]
  {degree : ‚Ñï} (Œ¥ : ‚Ñö) (hŒ¥Pos : Œ¥ > 0)
  (hŒ¥Lt : Œ¥ < foldingDistRange degree œÜ f) :
  let C : Set ((indexPow S œÜ k) ‚Üí F) := code (pow S œÜ k) (degree / k)
  Pr_{ let r ‚Üê $·µñ F }[ Œ¥·µ£((fold œÜ f k r), C) ‚â§ Œ¥]
    ‚â§ ENNReal.ofReal (proximityError F (degree / k) (LinearCode.rate (code œÜ degree)) Œ¥ k)

@[simp]
lemma possibleRelHammingDists_subset_relHammingDistRange :
  possibleRelHammingDists C ‚äÜ relHammingDistRange Œπ

beq_iff_eq in Init.Core

theorem degreeOf_X_of_ne (i j : œÉ) (h : i ‚â† j) : degreeOf i (X (R := R) j) = 0

theorem mul_distrib_add {a b : CNat 1} : a * (b + 1) = a * b + a

theorem induction_append_right {m n : ‚Ñï} {motive : Fin (m + n + 1) ‚Üí Sort*} {zero : motive 0}
  {succ : ‚àÄ i : Fin (m + n), motive i.castSucc ‚Üí motive i.succ} {i : Fin (n + 1)} :
    induction zero succ (i.natAdd m) =
      @induction n (fun i => motive (i.natAdd m))
        (@induction m (fun j => motive (Fin.cast (by omega) (j.castAdd n)))
          zero (fun j x => succ (j.castAdd n) x) (last m))
        (fun i x => succ (i.natAdd m) x) i

theorem setWidth_eq_ofNat_mod {n num_bits : Nat} (x : BitVec n) :
  BitVec.setWidth num_bits x = BitVec.ofNat num_bits (x.toNat % 2 ^ num_bits)

theorem toPoly_add {p q : UniPoly Q} : (add_raw p q).toPoly = p.toPoly + q.toPoly

theorem BitVec.eq_append_iff_extract {lo_size hi_size : ‚Ñï} (lo : BitVec lo_size)
  (hi : BitVec hi_size) (h_hi_gt_0 : hi_size > 0) (h_lo_gt_0 : lo_size > 0)
  (x : BitVec (hi_size + lo_size)) : x = dcast (by rfl) (BitVec.append (msbs:=hi) (lsbs:=lo)) ‚Üî
  hi = dcast (by omega) (BitVec.extractLsb (hi:=hi_size + lo_size - 1) (lo:=lo_size) x) ‚àß
  lo = dcast (by omega) (BitVec.extractLsb (hi:=lo_size - 1) (lo:=0) x)

theorem fconcat_injective2 {Œ± : Fin n ‚Üí A} {Œ≤ : A} :
    Function.Injective2 (@fconcat A F n Œ± Œ≤)

theorem vappend_assoc {p : ‚Ñï} (u : Fin m ‚Üí Œ±) (v : Fin n ‚Üí Œ±) (w : Fin p ‚Üí Œ±) :
    (vappend (vappend u v) w) = (vappend u (vappend v w)) ‚àò Fin.cast (add_assoc m n p)

@[simp]
theorem FullData.leftSubtree_internal {Œ±} {s_left s_right : Skeleton}
    (value : Œ±) (left : FullData Œ± s_left) (right : FullData Œ± s_right) :
    (FullData.internal value left right).leftSubtree = left

theorem srSoundness_addSalt_implies_srSoundness_original
    (langIn : Set StmtIn) (langOut : Set StmtOut)
    (Salt : pSpec.MessageIdx ‚Üí Type) [‚àÄ i, Nonempty (Salt i)] [‚àÄ i, Fintype (Salt i)]
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    (srInit : ProbComp (srChallengeOracle StmtIn (pSpec.addSalt Salt)).FunctionType)
    (srImpl : QueryImpl oSpec
      (StateT (srChallengeOracle StmtIn (pSpec.addSalt Salt)).FunctionType ProbComp))
    (srSoundnessError : ‚Ñù‚â•0) :
      Verifier.StateRestoration.soundness srInit srImpl langIn langOut
        (verifier.addSalt Salt) srSoundnessError ‚Üí
        Verifier.StateRestoration.soundness sorry sorry langIn langOut
          verifier srSoundnessError

lemma algebraMap_eq_zero_x {i j : ‚Ñï} (h_le : i < j) (x : BTField i) :
    letI instAlgebra := binaryAlgebraTower (l:=i) (r:=j) (h_le:=by omega)
    letI instAlgebraPred := binaryAlgebraTower (l:=i) (r:=j-1) (h_le:=by omega)
    algebraMap (BTField i) (BTField j) x
      = ‚ãò 0, algebraMap (BTField i) (BTField (j-1)) x ‚ãô

theorem size_le_size (p : UniPoly R) : p.trim.size ‚â§ p.size

theorem bitsToU_bijective (i : Fin r) :
  Function.Bijective (bitsToU (ùîΩq := ùîΩq) (Œ≤ := Œ≤) (‚Ñì := ‚Ñì) (R_rate := R_rate) i)

@[simp]
theorem dcast_eq : dcast (Eq.refl a) b = b

theorem dconcat_dcons_eq_dcons_dconcat {motive : Fin (n + 2) ‚Üí Sort u} (a : motive 0)
    (v : (i : Fin n) ‚Üí motive (succ (castSucc i))) (b : motive (last (n + 1))) :
    (a ::·µà v) :+·µà‚ü®motive‚ü© b = a ::·µà‚ü®motive‚ü© (v :+·µà b)

lemma liftF'_liftF_of_lt {k : Fin m} (h : k < n) :
  liftF' (n := m) (liftF (n := n) f') k = f' ‚ü®k, by omega‚ü©

@[simp]
lemma seqCompose_succ {m : ‚Ñï}
    (Stmt : Fin (m + 2) ‚Üí Type)
    {Œπ‚Çõ : Fin (m + 2) ‚Üí Type} (OStmt : (i : Fin (m + 2)) ‚Üí Œπ‚Çõ i ‚Üí Type)
    [O‚Çõ : ‚àÄ i, ‚àÄ j, OracleInterface (OStmt i j)]
    {n : Fin (m + 1) ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    [O‚Çò : ‚àÄ i, ‚àÄ j, OracleInterface ((pSpec i).Message j)]
    (V : (i : Fin (m + 1)) ‚Üí OracleVerifier oSpec
      (Stmt i.castSucc) (OStmt i.castSucc) (Stmt i.succ) (OStmt i.succ) (pSpec i)) :
    seqCompose Stmt OStmt V =
      append (V 0) (seqCompose (Stmt ‚àò Fin.succ) (fun i => OStmt (Fin.succ i))
        (O‚Çõ := fun i => O‚Çõ (Fin.succ i)) (O‚Çò := fun i => O‚Çò (Fin.succ i))
          (fun i => V (Fin.succ i)))

theorem snoc_ne_zero_of_left (h : s ‚â† 0) : snoc s y ‚â† 0

@[simp]
theorem OracleReduction.runWithLog_eq_runWithLog_reduction [‚àÄ i, OracleInterface (pSpec.Message i)]
    {stmt : StmtIn} {oStmt : ‚àÄ i, OStmtIn i} {wit : WitIn}
    {oracleReduction : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec} :
      oracleReduction.run stmt oStmt wit =
        oracleReduction.toReduction.run ‚ü®stmt, oStmt‚ü© wit

omit [DecidableEq ùîΩq] hF‚ÇÇ h_Œ≤‚ÇÄ_eq_1 in
lemma get_sDomain_basis (i : Fin r) (h_i : i < ‚Ñì + R_rate) :
    ‚àÄ (k : Fin (‚Ñì + R_rate - i)),
    (sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate
      i (by omega)) k = eval (Œ≤ ‚ü®i + k.val, by omega‚ü©) (normalizedW ùîΩq Œ≤ i)

@[simp]
theorem FullData.internal_getRootValue {s_left s_right : Skeleton} {Œ± : Type}
    (value : Œ±) (left : FullData Œ± s_left) (right : FullData Œ± s_right) :
    (FullData.internal value left right).getRootValue =
      value

lemma folding_preserves_listdecoding_base_ne_subset
  {S : Finset Œπ} {k m : ‚Ñï} (hm : 1 ‚â§ m) {œÜ : Œπ ‚Ü™ F} [Smooth œÜ] {Œ¥ : ‚Ñù‚â•0}
  {S_0 : Finset (indexPowT S œÜ 0)} {S_1 : Finset (indexPowT S œÜ 1)}
  {œÜ_0 : (indexPowT S œÜ 0) ‚Ü™ F} {œÜ_1 : (indexPowT S œÜ 1) ‚Ü™ F}
  [‚àÄ i : ‚Ñï, Fintype (indexPowT S œÜ i)] [‚àÄ i : ‚Ñï, DecidableEq (indexPowT S œÜ i)]
  [Smooth œÜ_0] [Smooth œÜ_1]
  [h : ‚àÄ {f : (indexPowT S œÜ 0) ‚Üí F}, DecidableBlockDisagreement 0 k f S_0 œÜ_0]
  [h : ‚àÄ {f : (indexPowT S œÜ 1) ‚Üí F}, DecidableBlockDisagreement 1 k f S_1 œÜ_1]
  [‚àÄ i : ‚Ñï, Neg (indexPowT S œÜ i)]
  {C : Set ((indexPowT S œÜ 0) ‚Üí F)} (hcode : C = smoothCode œÜ_0 m)
  (C' : Set ((indexPowT S œÜ 1) ‚Üí F)) (hcode' : C' = smoothCode œÜ_1 (m-1))
  {BStar : (Set (indexPowT S œÜ 1 ‚Üí F)) ‚Üí ‚Ñï ‚Üí ‚Ñù‚â•0}
  {errStar : (Set (indexPowT S œÜ 1 ‚Üí F)) ‚Üí ‚Ñï ‚Üí ‚Ñù‚â•0 ‚Üí ‚Ñù‚â•0} :
    Pr_{let Œ± ‚Üê$·µñ F}[ ‚àÄ { f : (indexPowT S œÜ 0) ‚Üí F} (hŒ¥Le: Œ¥ ‚â§ 1 - (BStar C' 2)),
                      let listBlock : Set ((indexPowT S œÜ 0) ‚Üí F) := Œõ·µ£(0, k, f, S_0, C, hcode, Œ¥)
                      let vec_Œ± : Fin 1 ‚Üí F := (fun _ : Fin 1 => Œ±)
                      let foldSet := fold_k_set listBlock vec_Œ± hm
                      let fold := fold_k f vec_Œ± hm
                      let listBlock' : Set ((indexPowT S œÜ 1) ‚Üí F)
                        := Œõ·µ£(1, k, fold, S_1, C', hcode', Œ¥)
                      ¬¨ (listBlock' ‚äÜ foldSet)
                    ] < errStar C' 2 Œ¥

@[simp]
theorem vconcat_zero (a : Œ±) : vconcat !v[] a = !v[a]

lemma relHammingDist_le_blockRelDistance
  (i k : ‚Ñï) {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F} {œÜ' : (indexPowT S œÜ i) ‚Ü™ F}
  [DecidableEq F] [DecidableEq Œπ] [Smooth œÜ]
  (f g : (indexPowT S œÜ i) ‚Üí F) (S' : Finset (indexPowT S œÜ i))
  [h_fintype : ‚àÄ i : ‚Ñï, Fintype (indexPowT S œÜ i)]
  [DecidableEq (indexPowT S œÜ i)] [Smooth œÜ']
  [h_dec : DecidableBlockDisagreement i k f S' œÜ'] :
  Œ¥·µ£(f, g) ‚â§ Œî·µ£(i, k, f, S', œÜ', g)

@[simp]
theorem cast_id : MessageIdx.cast (Eq.refl n‚ÇÅ) rfl = (id : pSpec‚ÇÅ.MessageIdx ‚Üí _)

@[simp]
theorem fflatten‚ÇÇ_embedSum {A : Sort u} {B : Sort v} {F : A ‚Üí B ‚Üí Sort w} {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï}
    {Œ± : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí A}
    {Œ≤ : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí B}
    (v : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí F (Œ± i j) (Œ≤ i j)) (i : Fin m) (j : Fin (n i)) :
    fflatten‚ÇÇ v (embedSum i j) = cast (by simp) (v i j)

private lemma BerlekampWelchCondition_to_Solution' [NeZero n]
  (h : BerlekampWelchCondition e k œâs f (solutionToE e k v) (solutionToQ e k v))
  : IsBerlekampWelchSolution e k œâs f v

@[simp]
theorem Fin.cast_val_eq_val {n m : ‚Ñï} [NeZero n] (a : Fin n) (h_eq : n = m):
  (Fin.cast (h_eq) a).val = a.val

@[simp]
theorem LeafData.map_leaf {Œ± Œ≤} (f : Œ± ‚Üí Œ≤) (a : Œ±) :
    (LeafData.leaf a).map f = LeafData.leaf (f a)

theorem intermediateNormVpoly_comp_qmap (i : Fin (‚Ñì))
    (k : Fin (‚Ñì - i - 1)) : -- corresponds to intermediateNormVpoly_comp

@[csimp]
theorem dcons_eq_cons : @dcons = @cons

theorem oracleReduction_rbr_knowledge_soundness : True

theorem totalDegree_coeff_finSuccEquivNth_add_le (f : MvPolynomial (Fin (n + 1)) R) (i : ‚Ñï)
    (hi : (finSuccEquivNth R p f).coeff i ‚â† 0) :
      totalDegree ((finSuccEquivNth R p f).coeff i) + i ‚â§ totalDegree f

theorem prime_3 : Nat.Prime 3

@[simp]
theorem Reduction.id_runWithLog (stmt : StmtIn) (wit : WitIn) :
    (Reduction.id : Reduction oSpec StmtIn WitIn _ _ _).runWithLog stmt wit =
      pure ‚ü®‚ü®‚ü®default, stmt, wit‚ü©, stmt‚ü©, [], []‚ü©

lemma separable_iff_discr_eq_zero {F : Type} [Field F] [Inhabited F] (f : F[X]) :
  f.Separable ‚Üî discriminant f ‚â† 0

lemma dappend_right_of_not_lt {motive : Fin (m + n) ‚Üí Sort u}
    (u : (i : Fin m) ‚Üí motive (castAdd n i)) (v : (i : Fin n) ‚Üí motive (natAdd m i))
    (i : Fin (m + n)) (h : ¬¨ i.val < m) :
      dappend (motive := motive) u v i = dcast (by ext; simp; omega) (v ‚ü®i - m, by omega‚ü©)

lemma liftF_eq_of_lt {i : ‚Ñï} (h : i < n) : liftF f' i = f' ‚ü®i, h‚ü©

theorem hcons_injective2 {Œ± : Sort u} {Œ≤ : Fin n ‚Üí Sort u} :
    Function.Injective2 (@hcons n Œ± Œ≤)

Fin.eta in Init.Data.Fin.Lemmas

lemma qCompositionChain_eq_foldl (i : Fin r) :
  qCompositionChain ùîΩq Œ≤ (‚Ñì:=‚Ñì) (R_rate:=R_rate) i =
  Fin.foldl (n:=i) (fun acc j =>
    (qMap ùîΩq Œ≤ ‚ü®j, by omega‚ü©).comp acc) (X)

Nat.sub_mul in Init.Data.Nat.Basic

theorem getBit_repr_univ {‚Ñì : Nat} : ‚àÄ j, j < 2^‚Ñì ‚Üí
  j = ‚àë k ‚àà Finset.univ (Œ±:=Fin ‚Ñì), (getBit k j) * 2^k.val

theorem happend_hconcat {Œ± : Fin m ‚Üí Sort u} {Œ≤ : Fin n ‚Üí Sort u} {Œ≥ : Sort u}
    (u : (i : Fin m) ‚Üí Œ± i) (v : (i : Fin n) ‚Üí Œ≤ i) (c : Œ≥) :
    True

@[simp]
theorem LeafData.get_ofFun {Œ±} {s} (f : SkeletonLeafIndex s ‚Üí Œ±) :
    (LeafData.ofFun s f).get = f

omit [NeZero ‚Ñì] [NeZero r] [NeZero ùì°] in
lemma fin_r_succ_bound {h_‚Ñì_add_R_rate : ‚Ñì + ùì° < r} (i : Fin r) (h_i : i + 1 < ‚Ñì + ùì°)
    : i + 1 < r

lemma join_via_add_smul_one {k : ‚Ñï} (h_pos : k > 0) :
  ‚ãò 0, 1 ‚ãô = 1

lemma eval‚ÇÇ_f_eq_C (r : R) (x : P) : eval‚ÇÇ (P := P) (C : R ‚Üí+* P) x (C r) = C r

theorem get_drop_ofFn_eq_drop_comp_cast {Œ± : Type*} {m : ‚Ñï} (v : Fin n ‚Üí Œ±) (h : m ‚â§ n) :
    ((List.ofFn v).drop m).get =
      drop m h v ‚àò Fin.cast (by simp only [List.length_drop, List.length_ofFn])

Nat.add_sub_cancel in Init.Data.Nat.Basic

@[simp]
theorem vconcat_castSucc (v : Fin n ‚Üí Œ±) (a : Œ±) (i : Fin n) :
    vconcat v a (castSucc i) = v i

lemma natDeg_sum_eq_of_unique {Œ± : Type} {s : Finset Œ±} {f : Œ± ‚Üí F[X]} {deg : ‚Ñï}
  (mx : Œ±) (h : mx ‚àà s) :
    (f mx).natDegree = deg ‚Üí
    (‚àÄ y ‚àà s, y ‚â† mx ‚Üí (f y).natDegree < deg ‚à® f y = 0) ‚Üí
    (‚àë x ‚àà s, f x).natDegree = deg

@[simp]
theorem Vector.ofFn_get {Œ± : Type*} {n : ‚Ñï} (v : Vector Œ± n) : Vector.ofFn (Vector.get v) = v

lemma linsolve_is_berlekamp_welch_solution
  (h_linsolve : linsolve (BerlekampWelchMatrix e k œâs f) (Rhs e œâs f) = some v)
  : IsBerlekampWelchSolution e k œâs f v

theorem FullTranscript.mk2_eq_snoc_snoc {pSpec : ProtocolSpec 2} (msg0 : pSpec.¬´Type¬ª 0)
    (msg1 : pSpec.¬´Type¬ª 1) :
      FullTranscript.mk2 msg0 msg1 = ((default : pSpec.Transcript 0).concat msg0).concat msg1

theorem is_unit_iff_deg_0 {R : Type*} [Field R] {p : R[X]} : p.degree = 0 ‚Üî IsUnit p

lemma X‚±º_zero_eq_one (‚Ñì : ‚Ñï) (h_‚Ñì : ‚Ñì ‚â§ r) :
  X‚±º ùîΩq Œ≤ ‚Ñì h_‚Ñì ‚ü®0, by exact Nat.two_pow_pos ‚Ñì‚ü© = 1

lemma if_self_rfl {Œ± : Type*} [DecidableEq Œ±] (a b : Œ±) :
  (if a = b then b else a) = a

theorem drop_eq_rtake (m : ‚Ñï) (h : m ‚â§ n) (v : (i : Fin n) ‚Üí Œ± i) :
    drop m h v = fun i => dcast (by simp [Fin.cast]; omega) (rtake (n - m) (by omega) v i)

theorem vcons_eq_const (a : Œ±) : a ::·µõ (fun _ : Fin n => a) = fun _ => a

theorem append_knowledgeSoundness (V‚ÇÅ : Verifier oSpec Stmt‚ÇÅ Stmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : Verifier oSpec Stmt‚ÇÇ Stmt‚ÇÉ pSpec‚ÇÇ)
    {knowledgeError‚ÇÅ knowledgeError‚ÇÇ : ‚Ñù‚â•0}
    (h‚ÇÅ : V‚ÇÅ.knowledgeSoundness init impl rel‚ÇÅ rel‚ÇÇ knowledgeError‚ÇÅ)
    (h‚ÇÇ : V‚ÇÇ.knowledgeSoundness init impl rel‚ÇÇ rel‚ÇÉ knowledgeError‚ÇÇ) :
      (V‚ÇÅ.append V‚ÇÇ).knowledgeSoundness init impl
        rel‚ÇÅ rel‚ÇÉ (knowledgeError‚ÇÅ + knowledgeError‚ÇÇ)

theorem sub_add_eq_sub_sub_rev (a b c : Nat) (h1 : c ‚â§ b) (h2 : b ‚â§ a) :
  a - b + c = a - (b - c)

@[simp]
theorem seqCompose_zero {n : Fin 0 ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    {T : ‚àÄ i, FullTranscript (pSpec i)} :
    seqCompose T = !h[]

Nat.add_le_add_left in Init.Data.Nat.Basic

@[grind ‚Üê]
lemma mul_ne_zero [IsDomain F] (f g : F[X][Y]) (hf : f ‚â† 0) (hg : g ‚â† 0) :
  f * g ‚â† 0

@[simp]
theorem hcons_one {Œ≤ : Fin (n + 1) ‚Üí Sort u} (a : Œ±) (v : (i : Fin (n + 1)) ‚Üí Œ≤ i) :
    hcons a v 1 = cast (vcons_succ Œ± Œ≤ 0).symm (v 0)

@[simp]
theorem eq_accepts (i : Fin numWires) (c : ùì°) (x : Fin numWires ‚Üí ùì°) :
    (eq i c).accepts x ‚Üî x i = c

theorem unique_linear_decomposition_succ (k : ‚Ñï) :
  ‚àÄ (x : BTField (k+1)), ‚àÉ! (p : BTField k √ó BTField k),
    x = ‚ãò p.1, p.2 ‚ãô

@[simp]
theorem BTField.Basis_cast_dest_apply {Œπ : Type*} (Œ± Œ≤ Œ≥ : ‚Ñï) (h_le1 : Œ± ‚â§ Œ≤) (h_le2 : Œ± ‚â§ Œ≥)
    (h_eq : Œ≤ = Œ≥) {k : Œπ} (b : @Basis Œπ (BTField Œ±) (BTField Œ≤) _ _
    (@binaryAlgebraTower (l := Œ±) (r := Œ≤) (h_le := h_le1)).toModule) :
    let castBasis : @Basis Œπ (BTField Œ±) (BTField Œ≥) _ _
      (@binaryAlgebraTower (l := Œ±) (r := Œ≥) (h_le := h_le2)).toModule :=
      cast (by
        exact Basis_cast_dest_eq Œ± Œ≥ Œ≤ h_le2 h_le1 h_eq
      ) b
    (castBasis k) = cast (by exact BTField.cast_BTField_eq Œ≤ Œ≥ h_eq) (b k)

lemma NTTStage_correctness (i : Fin (‚Ñì))
    (input_buffer : Fin (2 ^ (‚Ñì + R_rate)) ‚Üí L) (original_coeffs : Fin (2 ^ ‚Ñì) ‚Üí L) :
    additiveNTTInvariant ùîΩq Œ≤ h_‚Ñì_add_R_rate (evaluation_buffer:=input_buffer)
      (original_coeffs:=original_coeffs) (i := ‚ü®i.val+1, by omega‚ü©) ‚Üí
    additiveNTTInvariant ùîΩq Œ≤ h_‚Ñì_add_R_rate (evaluation_buffer:=NTTStage ùîΩq Œ≤ h_‚Ñì_add_R_rate
      ‚ü®i, by omega‚ü© input_buffer) (original_coeffs:=original_coeffs) ‚ü®i, by omega‚ü©

lemma powerBasisSucc_gen (k : ‚Ñï) :
  (powerBasisSucc k).gen = (Z (k + 1))

theorem eqPolynomial_expanded (r : œÉ ‚Üí R) :
    eqPolynomial r = ‚àè i : œÉ, ((1 - C (r i)) * (1 - X i) + C (r i) * X i)

@[simp]
theorem removeNth_update : removeNth p (update s p y) = removeNth p s

theorem BitVec.extractLsb_eq_and_pow_2_minus_1_ofNat {n num_bits : Nat}
  (h_num_bits : num_bits > 0) (x : BitVec n) :
  BitVec.extractLsb (hi:= num_bits - 1) (lo := 0) x =
    BitVec.ofNat (num_bits - 1 - 0 + 1) (x.toNat &&& (2 ^ num_bits - 1))

lemma approximate_solution_is_exact_solution_coeffs'
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  :
    Œ≥' x‚ÇÄ (R k Œ¥ x‚ÇÄ h_gs) (irreducible_H k h_gs) =
        PowerSeries.mk (fun t =>
          if t ‚â• k
          then (0 : AppendixA.ùïÉ (H k Œ¥ x‚ÇÄ h_gs))
          else PowerSeries.coeff _ t
            (Œ≥' 
              x‚ÇÄ
              (R k (x‚ÇÄ := x‚ÇÄ) (Œ¥ := Œ¥) h_gs)
              (irreducible_H k h_gs)))

@[simp]
protected lemma elocPoly_succ :
  ElocPoly (n + 1) œâs f p =
  ElocPoly n œâs f p *
    if f n = p.eval (œâs n)
    then 1
    else X - C (œâs n)

theorem mul_join_via_add_smul (k : ‚Ñï) (h_pos : k > 0) (a‚ÇÅ a‚ÇÄ b‚ÇÅ b‚ÇÄ : BTField (k - 1)) :
  ‚ãò a‚ÇÅ, a‚ÇÄ ‚ãô * ‚ãò b‚ÇÅ, b‚ÇÄ ‚ãô = ‚ãò a‚ÇÅ * b‚ÇÅ * Z (k - 1) + a‚ÇÅ * b‚ÇÄ + a‚ÇÄ * b‚ÇÅ, a‚ÇÄ * b‚ÇÄ + a‚ÇÅ * b‚ÇÅ ‚ãô

lemma towerRingHomForwardMap_mul_eq (k : ‚Ñï) (x y : ConcreteBTField k) :
    towerRingHomForwardMap (k:=k) (x * y)
    = towerRingHomForwardMap (k:=k) x * towerRingHomForwardMap (k:=k) y

@[simp]
theorem hflatten_two_eq_append {n : Fin 2 ‚Üí ‚Ñï} {Œ± : (i : Fin 2) ‚Üí (j : Fin (n i)) ‚Üí Sort*}
    {v : (i : Fin 2) ‚Üí (j : Fin (n i)) ‚Üí Œ± i j} : hflatten v = happend (v 0) (v 1)

theorem BaseField_is_prime : Nat.Prime baseFieldSize

@[simp]
theorem seqCompose_two_eq_append {n : Fin 2 ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)} :
    seqCompose pSpec = append (pSpec 0) (pSpec 1)

theorem seqCompose_completeness (hInit : init.neverFails)
    (rel : (i : Fin (m + 1)) ‚Üí Set ((Stmt i √ó ‚àÄ j, OStmt i j) √ó Wit i))
    (R : ‚àÄ i, OracleReduction oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Wit i.castSucc)
      (Stmt i.succ) (OStmt i.succ) (Wit i.succ) (pSpec i))
    (completenessError : Fin m ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (R i).completeness init impl (rel i.castSucc) (rel i.succ) (completenessError i)) :
      (OracleReduction.seqCompose Stmt OStmt Wit R).completeness
        init impl (rel 0) (rel (Fin.last m)) (‚àë i, completenessError i)

@[simp]
theorem happend_empty {Œ± : Fin m ‚Üí Sort u} {Œ≤ : Fin 0 ‚Üí Sort u} (v : (i : Fin m) ‚Üí Œ± i) :
    happend v !h‚ü®Œ≤‚ü©[] = v

private theorem toNat_mulNat (a : AssocNat) (k : Nat) : toNat (mulNat a k) = toNat a * k

theorem insertNth_ne_zero_iff : insertNth p y s ‚â† 0 ‚Üî y ‚â† 0 ‚à® s ‚â† 0

lemma concreteTowerAlgebraMap_succ_1 (k : ‚Ñï) :
  concreteTowerAlgebraMap (l:=k) (r:=k + 1) (h_le:=by omega) = canonicalAlgMap k

lemma algebraMap_succ_eq_zero_x {k : ‚Ñï} (h_pos : k > 0) (x : BTField (k - 1)) :
  letI instAlgebra := binaryAlgebraTower (l:=k-1) (r:=k) (h_le:=by omega)
  algebraMap (BTField (k - 1)) (BTField k) x = ‚ãò 0, x ‚ãô

theorem cast_Type_idx {hn} (hSpec : pSpec‚ÇÅ.cast hn = pSpec‚ÇÇ) {i : Fin n‚ÇÅ} :
    pSpec‚ÇÇ.¬´Type¬ª (Fin.cast hn i) = pSpec‚ÇÅ.¬´Type¬ª i

theorem lagrangeToMonoLevel_monoToLagrangeLevel_id (v : Vector R (2 ^ n)) (i : Fin n) :
  lagrangeToMonoLevel i (monoToLagrangeLevel i v) = v

lemma vappend_left_of_lt {m n : ‚Ñï} {Œ± : Sort u}
    (u : Fin m ‚Üí Œ±) (v : Fin n ‚Üí Œ±) (i : Fin (m + n)) (h : i.val < m) :
      vappend u v i = u ‚ü®i, h‚ü©

@[simp]
lemma Rhs_add_one : Rhs (e + 1) œâs f = fun i ‚Ü¶ Rhs e œâs f i * œâs i

theorem add_zero : p + 0 = p

theorem rtake_rev_eq_take_of_rev {Œ± : Sort*} (m : ‚Ñï) (h : m ‚â§ n) (v : Fin n ‚Üí Œ±) :
    rtake m h v ‚àò Fin.rev = (take m h (v ‚àò Fin.rev))

theorem towerAlgebraMap_assoc : ‚àÄ r mid l : ‚Ñï, (h_l_le_mid : l ‚â§ mid) ‚Üí (h_mid_le_r : mid ‚â§ r) ‚Üí
    towerAlgebraMap (l:=l) (r:=r) (h_le:=by exact Nat.le_trans h_l_le_mid h_mid_le_r) =
    (towerAlgebraMap (l:=mid) (r:=r) (h_le:=h_mid_le_r)).comp
    (towerAlgebraMap (l:=l) (r:=mid) (h_le:=h_l_le_mid))

@[simp]
lemma two_mul_inv_two : (2 : F) * 2‚Åª¬π = 1

lemma algebraMap_binaryTowerAlgebra_def (l r : ‚Ñï) (h_le : l ‚â§ r) :
  (@binaryAlgebraTower (l:=l) (r:=r) (h_le:=h_le)).algebraMap = towerAlgebraMap l r h_le

nonpos_iff_eq_zero in Mathlib.Algebra.Order.Monoid.Canonical.Defs

@[simp]
theorem Ici_succ (i : Fin n) : Ici i.succ = (Ici i).map (Fin.succEmb _)

@[simp]
theorem rdrop_eq_take (m : ‚Ñï) (h : m ‚â§ n) (v : (i : Fin n) ‚Üí Œ± i) :
    rdrop m h v = take (n - m) (by omega) v

@[simp] lemma twoAdicGenerators_length : twoAdicGenerators.length = twoAdicity + 1

@[grind _=_]
lemma degreeX_as_weighted_deg :
  degreeX f = natWeightedDegree f 1 0

theorem singleton_bound_linear [CommRing F] [StrongRankCondition F]
    (LC : LinearCode Œπ F) :
    Module.finrank F LC ‚â§ card Œπ - (Code.dist LC.carrier) + 1

lemma and_eq_zero_iff {n m : ‚Ñï} : n &&& m = 0 ‚Üî ‚àÄ k, (n >>> k) &&& (m >>> k) = 0

@[simp]
theorem cast_perfectCompleteness (hComplete : R.perfectCompleteness init impl relIn relOut) :
    (R.cast hn hSpec hO‚Çò).perfectCompleteness init impl relIn relOut

theorem BitVec.extractLsb_concat_lo {hi_size lo_size : ‚Ñï} (hi : BitVec hi_size)
  (lo : BitVec lo_size) (h_lo : lo_size > 0) : BitVec.extractLsb (hi:=lo_size - 1) (lo:=0)
  (BitVec.append (msbs:=hi) (lsbs:=lo)) = dcast (by
    rw [‚ÜêNat.sub_add_comm (h:=by omega), Nat.sub_add_cancel (h:=by omega), Nat.sub_zero]
  ) lo

theorem prime_2 : Nat.Prime 2

lemma lin_shift_card [Field F] [Fintype F]
  :
  B.card = ({ x - v | x ‚àà B} : Finset _).card

@[simp]
theorem BTField.Basis_cast_index_eq (i j k n : ‚Ñï) (h_le : k ‚â§ n) (h_eq : i = j) :
    letI instAlgebra : Algebra (BTField k) (BTField n)
      := binaryAlgebraTower (l:=k) (r:=n) (h_le:=h_le)
    letI : Module (BTField k) (BTField n) := instAlgebra.toModule
    (Basis (Fin (i)) (BTField k) (BTField n)) = (Basis (Fin (j)) (BTField k) (BTField n))

theorem Nat.Prime_of_isNat : ‚àÄ {n n' : ‚Ñï}, IsNat n n' ‚Üí n'.Prime ‚Üí n.Prime

theorem liftContext_runWithLog
    {lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    {outerStmtIn : OuterStmtIn} {outerWitIn : OuterWitIn}
    {R : Reduction oSpec InnerStmtIn InnerWitIn InnerStmtOut InnerWitOut pSpec} :
      (R.liftContext lens).runWithLog outerStmtIn outerWitIn = do
        let ‚ü®‚ü®‚ü®fullTranscript, innerCtxOut‚ü©, verInnerStmtOut‚ü©, queryLog‚ü© ‚Üê
          R.runWithLog.uncurry (lens.proj (outerStmtIn, outerWitIn))
        return ‚ü®‚ü®‚ü®fullTranscript, lens.lift (outerStmtIn, outerWitIn) innerCtxOut‚ü©,
                lens.stmt.lift outerStmtIn verInnerStmtOut‚ü©, queryLog‚ü©

theorem congrArg‚ÇÉ {Œ± Œ≤ Œ≥ Œ¥ : Sort*} {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥ ‚Üí Œ¥} {a a' : Œ±} {b b' : Œ≤} {c c' : Œ≥}
    (h : a = a') (h' : b = b') (h'' : c = c') : f a b c = f a' b' c'

lemma Œ≤·µ¢_not_in_U·µ¢ (i : Fin r) :
    Œ≤ i ‚àâ U ùîΩq Œ≤ i

omit [Finite F] in
lemma one_in_doms (i : ‚Ñï) : 1 ‚àà evalDomain D i

theorem fappend_ext {Œ± : Fin m ‚Üí A} {Œ≤ : Fin n ‚Üí A}
    (u‚ÇÅ u‚ÇÇ : (i : Fin m) ‚Üí F (Œ± i)) (v‚ÇÅ v‚ÇÇ : (i : Fin n) ‚Üí F (Œ≤ i)) :
    fappend u‚ÇÅ v‚ÇÅ = fappend u‚ÇÇ v‚ÇÇ ‚Üî u‚ÇÅ = u‚ÇÇ ‚àß v‚ÇÅ = v‚ÇÇ

@[simp]
theorem seqCompose_succ_type {m : ‚Ñï} {n : Fin (m + 1) ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)} :
    (seqCompose pSpec).Type = Fin.vflatten (fun i => (pSpec i).Type)

@[to_additive]
lemma prod_univ_twos {M : Type*} [CommMonoid M] {n : ‚Ñï} (hn : n = 2) (f : Fin n ‚Üí M) :
    (‚àè i, f i) = f (Fin.cast hn.symm 0) * f (Fin.cast hn.symm 1)

protected lemma a_lemma_im_not_proud_of_OLD {v a : Fin n ‚Üí F}
  (h_card : 2 ‚â§ Fintype.card F)
  :
  |(1 : ‚Ñö) - ((1 : ‚Ñö) + (1 : ‚Ñö) / ((Fintype.card F : ‚Ñö) - 1)) * ‚ÜëŒî‚ÇÄ(v, a) / ‚Üën

@[simp]
theorem take_append_left' : (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ)‚ü¶:m‚üß = pSpec‚ÇÅ

theorem prime_47 : Nat.Prime 47

theorem queryOracleVerifier_rbrKnowledgeSoundness [Fintype L] {œÉ : Type} (init : ProbComp œÉ)
    (impl : QueryImpl []‚Çí (StateT œÉ ProbComp)) :
    (queryOracleVerifier ùîΩq Œ≤ (œë:=œë) Œ≥_repetitions).rbrKnowledgeSoundness init impl
    (relIn := finalSumcheckRelOut ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (relOut := acceptRejectOracleRel)
    (rbrKnowledgeError := queryRbrKnowledgeError ùîΩq Œ≤ Œ≥_repetitions
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))

@[simp]
theorem toNat_zero : toNat zero = 0

theorem is_prime : Nat.Prime fieldSize

lemma BTField.coe_one_succ (l : ‚Ñï) :
  (@binaryAlgebraTower (l:=l) (r:=l+1) (h_le:=by omega)).algebraMap (1 : BTField l) =
    (1 : BTField (l+1))

lemma linsolve_to_BerlekampWelch_condition {e k : ‚Ñï}
  [NeZero n]
  {œâs f : Fin n ‚Üí F}
  {v : Fin (2 * e + k) ‚Üí F}
  (h_sol : linsolve (BerlekampWelchMatrix e k œâs f) (Rhs e œâs f) = some v)
  : BerlekampWelchCondition e k œâs f (solutionToE e k v) (solutionToQ e k v)

@[simp]
theorem cast_idx_symm {i : ChallengeIdx pSpec‚ÇÇ} :
    pSpec‚ÇÅ.Challenge (i.cast hn.symm (cast_symm hSpec)) = pSpec‚ÇÇ.Challenge i

private lemma almost_johnson_lhs_div_B_card [Zero F]
  (h_n : 0 < n)
  (h_B : 2 ‚â§ B.card)
  :
  (k B * (k B - 1)  +
    (B.card - k B) * ((B.card - k B)/(Fintype.card F - 1) - 1)) / B.card
  =
  (1 - e B 0 / n) ^ 2 * B.card + B.card * (e B 0) ^ 2 / ((Fintype.card F - 1) * n^2) - 1

private lemma cast_eq_cast_same_type {Œ± Œ≤ : Sort u} (h1 h2 : Œ± = Œ≤) {x y : Œ±}
    (h : cast h1 x = cast h2 y) : x = y

@[simp]
theorem Prover.runToRound_zero_of_prover_first
    (stmt : StmtIn) (wit : WitIn) (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      prover.runToRound 0 stmt wit = (pure (default, prover.input (stmt, wit)))

@[simp]
theorem Basis_cast_index_apply {Œ± Œ≤ i j : ‚Ñï} {k : Fin j}
    (h_le : Œ± ‚â§ Œ≤) (h_eq : i = j)
    {b : @Basis (Fin (i)) (ConcreteBTField Œ±) (ConcreteBTField Œ≤) _ _
      (@ConcreteBTFieldAlgebra (l := Œ±) (r := Œ≤) (h_le := h_le)).toModule} :
  let castBasis : @Basis (Fin j) (ConcreteBTField Œ±) (ConcreteBTField Œ≤) _ _
    (@ConcreteBTFieldAlgebra (l:=Œ±) (r:=Œ≤) (h_le:=h_le)).toModule :=
    cast (by exact Basis_cast_index_eq i j Œ± Œ≤ h_le h_eq) b
  (castBasis k) = b (Fin.cast (h_eq.symm) k)

@[simp]
theorem runWithOracle_freeMonad_query_roll (f : spec.FunctionType)
    (i : Œπ) (t : spec.domain i)
    (r : (spec.range i) ‚Üí FreeMonad (spec.OracleQuery) (Option Œ±)) :
    runWithOracle f (FreeMonad.roll (query i t) r) = runWithOracle f (r (f i t))

private lemma almost_johnson_choose_2_elimed [Zero F]
  (h_n : 0 < n)
  (h_B : 2 ‚â§ B.card)
  (h_card : 2 ‚â§ Fintype.card F)
  :
  (k B * (k B - 1)  +
    (B.card - k B) * ((B.card - k B)/(Fintype.card F-1) - 1))
  ‚â§
  B.card * (B.card - 1) * (n - d B)/n

theorem oracleVerifier_rbrKnowledgeSoundness [Fintype R] :
    (oracleVerifier R n deg D oSpec i).rbrKnowledgeSoundness init impl
    (relationRound R n deg D i.castSucc) (relationRound R n deg D i.succ)
    (fun _ => (deg : ‚Ñù‚â•0) / Fintype.card R)

theorem add_comm (m n : ChurchNat Œ±) : add m n = add n m

lemma toOutCodewordsCount_last ‚Ñì œë : toOutCodewordsCount ‚Ñì œë (Fin.last ‚Ñì) = ‚Ñì / œë

Fin.val_injective in Mathlib.Data.Fin.Basic

theorem rightpad_eq_rightpad_append_replicate_of_ge
  (l : List Œ±) (m n : Nat) (h : n ‚â§ m) :
    rightpad m unit l = rightpad n unit l ++ replicate (m - max n l.length) unit

theorem is_prime : Nat.Prime fieldSize

lemma getBit_of_xor {n m k: ‚Ñï} : getBit k (n ^^^ m) = getBit k n ^^^ getBit k m

theorem degreeOf_X_le (i j : œÉ) : degreeOf i (X (R := R) j) ‚â§ 1

theorem init_dconcat {motive : Fin (n + 1) ‚Üí Sort u} (v : (i : Fin n) ‚Üí motive (castSucc i))
    (a : motive (last n)) : (fun i => (v :+·µà‚ü®motive‚ü© a) (castSucc i)) = v

theorem zero_add (n : ChurchNat Œ±) : add zero n = n

lemma rank_eq_min_row_col_rank : U.rank = min (rowRank U) (colRank U)

theorem Iic_castSucc (i : Fin n) : Iic (castSucc i) = (Iic i).map Fin.castSuccEmb

lemma W_prod_comp_decomposition
    (i : Fin r) (hi : i > 0) :
    (W ùîΩq Œ≤ i) = ‚àè c: ùîΩq, (W ùîΩq Œ≤ (i-1)).comp (X - C (c ‚Ä¢ Œ≤ (i-1)))

theorem append_right' {u : Fin m ‚Üí Œ±} {v : Fin n ‚Üí Œ±} {i : Fin n}
    (j : Fin (m + n)) (h : j = natAdd m i) : append u v j = v i

lemma runWithOracle_getPutativeRoot {s} (idx : BinaryTree.SkeletonLeafIndex s)
    (leafValue : Œ±) (proof : List Œ±) (f) :
    (runWithOracle f (getPutativeRoot idx leafValue proof))
      =
    getPutativeRoot_with_hash idx leafValue proof fun (left right : Œ±) => (f () ‚ü®left, right‚ü©)

@[simp] theorem rightpad_prefix (n : Nat) (unit : Œ±) (l : List Œ±) :
    l <+: rightpad n unit l

theorem append_right_injective {pSpec : ProtocolSpec m} :
    Function.Injective (@ProtocolSpec.append m n pSpec)

omit [DecidableEq L] [Fintype ùîΩq] hŒ≤_lin_indep in
lemma W_ne_zero (i : Fin r) : (W ùîΩq Œ≤ i) ‚â† 0

@[simp]
lemma weight_constantCode [DecidableEq F] :
  wt (constantCode x Œπ) = 0 ‚Üî IsEmpty Œπ ‚à® x = 0

lemma add_self_cancel {k : ‚Ñï} (a : ConcreteBTField k) : a + a = 0

@[simp]
theorem ConcreteBTFieldAlgebra_id {l r : ‚Ñï} (h_eq : l = r) :
    @ConcreteBTFieldAlgebra l r (h_le:=by omega) =
    (h_eq ‚ñ∏ (Algebra.id (ConcreteBTField l)) :
      Algebra (ConcreteBTField l) (ConcreteBTField r))

lemma num_eq_highBits_xor_lowBits {n: ‚Ñï} (numLowBits: ‚Ñï) :
  n = getHighBits numLowBits n ^^^ getLowBits numLowBits n

lemma isPrimitiveRoot_twoAdicGenerator (bits : Fin (twoAdicity + 1)) :
    IsPrimitiveRoot (twoAdicGenerators[bits]) (2 ^ (bits : Nat))

@[simp]
lemma addSalt_Type (i : Fin n) :
    (pSpec.addSalt Salt).¬´Type¬ª i = match hDir : pSpec.dir i with

theorem qMap_maps_sDomain (i : Fin r) (h_i_add_1 : i + 1 < r) :
  have q_comp_linear_map := qMap_is_linear_map ùîΩq Œ≤ i
  have q_eval_linear_map := linear_map_of_comp_to_linear_map_of_eval
    (f:=qMap ùîΩq Œ≤ i) q_comp_linear_map
  let q_i_map := polyEvalLinearMap (qMap ùîΩq Œ≤ i) q_eval_linear_map
  let S_i := sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i
  let S_i_plus_1 := sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i+1)
  Submodule.map q_i_map S_i = S_i_plus_1

theorem liftContext_completeness
    (h : R.completeness init impl innerRelIn innerRelOut completenessError) :
      (R.liftContext lens).completeness init impl outerRelIn outerRelOut completenessError

@[simp]
theorem rtake_apply (v : (i : Fin n) ‚Üí Œ± i) (m : ‚Ñï) (h : m ‚â§ n)
    (i : Fin m) : rtake m h v i = v (Fin.cast (Nat.sub_add_cancel h) (natAdd (n - m) i))

lemma BTField_is_BTFieldAux (k : ‚Ñï) :
  BTField k = (BinaryTowerAux k).1

theorem LeafData.composeBuild_internal {Œ±} {s_left s_right : Skeleton}
    (left : LeafData Œ± s_left) (right : LeafData Œ± s_right)
    (compose : Œ± ‚Üí Œ± ‚Üí Œ±) :
    (LeafData.internal left right).composeBuild compose =
      FullData.internal
        (compose (left.composeBuild compose).getRootValue (right.composeBuild compose).getRootValue)
        (left.composeBuild compose)
        (right.composeBuild compose)

lemma sum_of_and_eq_zero_is_or {n m : ‚Ñï} (h_n_AND_m : n &&& m = 0) : n + m = n ||

@[simp]
theorem dflatten_splitSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {motive : (k : Fin (vsum n)) ‚Üí Sort*}
    (v : (k : Fin (vsum n)) ‚Üí motive k) (k : Fin (vsum n)) :
    dflatten (motive := motive) (fun i j => v (embedSum i j)) k = v k

@[simp]
private lemma leadingCoeff_E : (E œâs f p e).leadingCoeff = 1

@[simp]
lemma liftComp_support {Œπ' : Type w} {superSpec : OracleSpec Œπ'}
    [h : MonadLift (OracleQuery spec) (OracleQuery superSpec)]
    (oa : OracleComp spec Œ±) : (liftComp oa superSpec).support = oa.support

theorem degrees_C_mul_le (p : MvPolynomial œÉ R) (c : R) : (C c * p).degrees ‚â§ p.degrees

@[simp]
theorem eval_poly_at_root (k : ‚Ñï) : (Z (k+1))^2 + (Z (k+1)) * Z k + 1 = 0

lemma degree_W (i : Fin r) : (W ùîΩq Œ≤ i).degree = (Fintype.card ùîΩq)^i.val

lemma guruswami_sudan_for_proximity_gap_property {k m : ‚Ñï} {œâs : Fin n ‚Ü™ F}
  {f : Fin n ‚Üí F}
  {Q : F[X][X]}
  {p : ReedSolomon.code œâs n}
  (h : Œî‚ÇÄ(f, (ReedSolomon.codewordToPoly p).eval ‚àò f) ‚â§ proximity_gap_johnson (n := n) k m)
  :
  ((X : F[X][X]) - C (ReedSolomon.codewordToPoly p)) ‚à£ Q

theorem finalSumcheckOracleReduction_perfectCompleteness {œÉ : Type}
  (init : ProbComp œÉ)
  (impl : QueryImpl []‚Çí (StateT œÉ ProbComp))
  (hInit : init.neverFails) :
  OracleReduction.perfectCompleteness
    (pSpec := pSpecFinalSumcheckStep (L := L))
    (relIn := roundRelation ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (ùìë := ùìë) (mp := BBF_SumcheckMultiplierParam) (Fin.last ‚Ñì))
    (relOut := finalSumcheckRelOut ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (oracleReduction := finalSumcheckOracleReduction ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)) (init := init) (impl := impl)

@[simp]
theorem dcast‚ÇÉ_eq : dcast‚ÇÉ (Eq.refl a) dcast_eq dcast‚ÇÇ_eq d = d

lemma degree_s_smul_X {F : Type*} [Field F] [Fintype F] (s : F) [NeZero s] :
  (C s * (X : (F)[X])).degree = 1

theorem induct [LawfulBEq R] {motive : UniPoly R ‚Üí Prop}
  (case1 : ‚àÄ p, p.trim = #[] ‚Üí (‚àÄ i, (hi : i < p.size) ‚Üí p[i] = 0) ‚Üí motive p)
  (case2 : ‚àÄ p : UniPoly R, ‚àÄ k : Fin p.size, p.trim = p.extract 0 (k + 1)
    ‚Üí p[k] ‚â† 0 ‚Üí (‚àÄ j : ‚Ñï, (hj : j < p.size) ‚Üí j > k ‚Üí p[j] = 0) ‚Üí motive p)
  (p : UniPoly R) : motive p

theorem toImpl_toPoly [LawfulBEq R] (p : UniPoly R) : p.toPoly.toImpl = p.trim

@[simp]
theorem OracleSpec.append_range_left {Œπ‚ÇÅ Œπ‚ÇÇ : Type} {spec‚ÇÅ : OracleSpec Œπ‚ÇÅ} {spec‚ÇÇ : OracleSpec Œπ‚ÇÇ}
    (i : Œπ‚ÇÅ) : (spec‚ÇÅ ++‚Çí spec‚ÇÇ).range (Sum.inl i) = spec‚ÇÅ.range i

theorem prod_X_sub_C_eq_X_pow_card_sub_X :
  (‚àè c ‚àà (Finset.univ : Finset Fq), (Polynomial.X - Polynomial.C c)) =
    Polynomial.X^(Fintype.card Fq) - Polynomial.X

theorem Nat.reconstruct_from_hi_and_lo_parts_or_ver (n hi_len lo_len : ‚Ñï)
  (h_n : n < 2 ^ (hi_len + lo_len)) :
    n = (((n >>> lo_len) % (2 ^ hi_len)) <<< lo_len) ||

theorem qMap_is_linear_map (i : Fin r) :
  IsLinearMap ùîΩq (f:=fun inner_p ‚Ü¶ (qMap ùîΩq Œ≤ i).comp inner_p)

theorem hammingDist_le_of_decoder_eq_some [NeZero n] {œâs f : Fin n ‚Üí F}
  (h : decoder e k œâs f = some p) : Œî‚ÇÄ(f, p.eval ‚àò œâs) ‚â§ e

omit [Finite F] in
@[simp]
lemma range_lem‚ÇÇ : [FinalOracleStatement D x s]‚Çí.range (Fin.last (k + 1)) = F[X]

theorem pow_zero {a : CNat 50} : a ^ 0 = 1

@[simp]
theorem fconcat_zero {Œ± : Fin 0 ‚Üí A} {Œ≤ : A} (a : F Œ≤) : !h‚¶ÉF‚¶Ñ‚ü®Œ±‚ü©[] :+ ∞ a =
  fun i => match i with

theorem nsmul_zero : nsmul 0 p = 0

@[simp] theorem ofNat_add (n m : Nat) : ofNat (n + m) = add (ofNat n) (ofNat m)

theorem runWithOracle_succeeds_iff_simulateQ_randomOracle_neverFails
     {Œ≤}
    [DecidableEq Œπ] [spec.DecidableEq] [(i : Œπ) ‚Üí SelectableType (OracleSpec.range spec i)]
    (oa : OracleComp (spec) Œ≤) (f : spec.FunctionType) :
    (runWithOracle f oa).isSome ‚Üî
    ((oa.simulateQ randomOracle).run (fun i q => some (f i q))).neverFails

theorem oddRefinement_eq_novel_poly_of_1_leading_suffix (i : Fin ‚Ñì) (v : Fin (2 ^ i.val))
    (original_coeffs : Fin (2 ^ ‚Ñì) ‚Üí L) :
    have h_v: v.val ||

@[simp]
theorem reduction_completeness (h : init.neverFails) [Nonempty œÉ] :
    (reduction oSpec Statement pred).perfectCompleteness init impl
    (relIn Statement pred) (relOut Statement)

lemma getMiddleBits_lt_two_pow {n offset len : ‚Ñï} :
  getMiddleBits offset len n < 2 ^ len

lemma add_eq_one_iff (a b : ConcreteBTField 0) :
  a + b = 1 ‚Üî (a = 0 ‚àß b = 1) ‚à® (a = 1 ‚àß b = 0)

theorem concrete_eq_zero_or_eq_one {k : ‚Ñï} {a : ConcreteBTField k} (h_k_zero : k = 0)
 : a = zero ‚à® a = one

theorem add_assoc [LawfulBEq R] : p + q + r = p + (q + r)

@[simp]
protected lemma elocPoly_two :
  ElocPoly 2 œâs f p =
  if f 1 = eval (œâs 1) p
  then if f 0 = eval (œâs 0) p then 1
       else X - C (œâs 0)
  else if f 0 = eval (œâs 0) p then X - C (œâs 1)
       else (X - C (œâs 0)) * (X - C (œâs 1))

@[simp]
lemma coe_fn_of_coe (f : ‚àÄ a, Œ≤ a) : (f : F) = inst.equiv.invFun f

theorem sum_square_char2 {F : Type*} [Field F] (sumZeroIffEq : ‚àÄ (x y : F), x + y = 0 ‚Üî x = y)
  (s : Finset ‚Ñï) (f : ‚Ñï ‚Üí F) : (‚àë j ‚àà s, f j)^2 = ‚àë j ‚àà s, (f j)^2

lemma sDomain_card (i : Fin r) (h_i : i < ‚Ñì + R_rate) :
    Fintype.card (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i) = (Fintype.card ùîΩq)^(‚Ñì + R_rate - i)

@[simp]
lemma domain_def : (spec Œ±).domain () = (Œ± √ó Œ±)

theorem dist_eq_dist_from_HammingNorm [CommRing F] [DecidableEq F] (LC : LinearCode Œπ F) :
    Code.dist LC.carrier = disFromHammingNorm LC

theorem GF_2_one_add_one_eq_zero : (1 + 1 : GF(2)) = 0

theorem seqCompose_soundness
    (lang : (i : Fin (m + 1)) ‚Üí Set (Stmt i))
    (V : (i : Fin m) ‚Üí Verifier oSpec (Stmt i.castSucc) (Stmt i.succ) (pSpec i))
    (soundnessError : Fin m ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (V i).soundness init impl (lang i.castSucc) (lang i.succ) (soundnessError i)) :
      (Verifier.seqCompose Stmt V).soundness init impl (lang 0) (lang (Fin.last m))
        (‚àë i, soundnessError i)

theorem reduction_rbr_knowledge_soundness : True

Nat.cast_pow in Mathlib.Data.Nat.Cast.Basic

lemma definingPoly_coeffOf0 {F : Type*} [Field F] [Fintype F] (s : F) [NeZero s] :
    (definingPoly s).coeff 0 = 1

omit [Finite F] in
lemma sqr_mem_D_succ_i_of_mem_D_i : ‚àÄ {x : FÀ£} {i : ‚Ñï},
  x ‚àà evalDomain D i ‚Üí x ^ 2 ‚àà evalDomain D (i + 1)

theorem insertNth_ne_zero_of_right (h : s ‚â† 0) : insertNth p y s ‚â† 0

theorem mul_succ (m n : ChurchNat Œ±) : mul n (succ m) = add n (mul n m)

theorem liftContext_run
    {lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    {outerStmtIn : OuterStmtIn} {outerWitIn : OuterWitIn}
    {R : Reduction oSpec InnerStmtIn InnerWitIn InnerStmtOut InnerWitOut pSpec} :
      (R.liftContext lens).run outerStmtIn outerWitIn = do
        let ‚ü®‚ü®fullTranscript, innerCtxOut‚ü©, verInnerStmtOut‚ü© ‚Üê
          R.run.uncurry (lens.proj (outerStmtIn, outerWitIn))
        return ‚ü®‚ü®fullTranscript, lens.lift (outerStmtIn, outerWitIn) innerCtxOut‚ü© ,
                lens.stmt.lift outerStmtIn verInnerStmtOut‚ü©

@[simp]
theorem dconcat_last {motive : Fin (n + 1) ‚Üí Sort u} (v : (i : Fin n) ‚Üí motive (castSucc i))
    (a : motive (last n)) : (v :+·µà‚ü®motive‚ü© a) (last n) = a

theorem rbrSoundness_implies_soundness (langIn : Set StmtIn) (langOut : Set StmtOut)
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    (rbrSoundnessError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) :
      rbrSoundness init impl langIn langOut verifier rbrSoundnessError ‚Üí
        soundness init impl langIn langOut verifier (‚àë i, rbrSoundnessError i)

theorem append_getLast_dropLast {Œ± : Type u} (l : List Œ±) (h : l ‚â† []) :
  l.dropLast ++ [l.getLast h] = l

lemma Œ≤_regular (R : F[X][X][Y])
                (H : F[X][Y]) [H_irreducible : Fact (Irreducible H)]
                {D : ‚Ñï} (hD : D ‚â• Bivariate.totalDegree H) :
    ‚àÄ t : ‚Ñï, ‚àÉ Œ≤ : ùí™ H, weight_Œõ_over_ùí™ Œ≤ ‚â§ (2 * t + 1) * Bivariate.natDegreeY R * D

@[simp]
theorem vappend_vempty (v : Fin m ‚Üí Œ±) : vappend v !v[] = v

@[simp]
theorem fappend_left {Œ± : Fin m ‚Üí A} {Œ≤ : Fin n ‚Üí A}
    (u : (i : Fin m) ‚Üí F (Œ± i)) (v : (i : Fin n) ‚Üí F (Œ≤ i)) (i : Fin m) :
    fappend u v (castAdd n i) = cast (by simp [vappend_left]) (u i)

theorem toNat_ofNat (n : ‚Ñï) : toNat (ofNat n) = n

omit [CharP L 2] [DecidableEq ùîΩq] h_Œ≤‚ÇÄ_eq_1 [NeZero ùì°] in
lemma firstOracleWitnessConsistencyProp_relay_preserved (i : Fin ‚Ñì)
    (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) (wit : Witness (L := L) ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j) :
    firstOracleWitnessConsistencyProp ùîΩq Œ≤ wit.t (getFirstOracle ùîΩq Œ≤ oStmt) =
    firstOracleWitnessConsistencyProp ùîΩq Œ≤ wit.t
      (getFirstOracle ùîΩq Œ≤ (mapOStmtOutRelayStep ùîΩq Œ≤ i hNCR oStmt))

lemma division_by_conjugate {a b : ‚Ñù} (hpos : 0 ‚â§ b) (hnonzero : a + b.sqrt ‚â† 0) :
  a - (b).sqrt = (a^2 - b)/(a + b.sqrt)

@[simp]
lemma ofPolynomialAlgHom_toPolynomialAlgHom_X :
    ofPolynomialAlgHom (toPolynomialAlgHom (X : P)) = (Polynomial.X : R[X])

@[simp]
theorem cons_toList_eq_List_cons {Œ±} {n : ‚Ñï} (hd : Œ±) (tl : Vector Œ± n) :
    (cons hd tl).toList = hd :: tl.toList

private lemma solutionToE_from_E
  (h_p_deg : p.natDegree < k)
  (h_dist : (Œî‚ÇÄ(f, p.eval ‚àò œâs) : ‚Ñï) ‚â§ e)
  : solutionToE e k (E_and_Q_to_a_solution e (E œâs f p e) (Q œâs f p e)) = E œâs f p e

@[simp]
theorem removeNth_apply : removeNth p s i = s (p.succAbove i)

theorem BitVec.extractLsb_eq_shift_ofNat {n : Nat} (x : BitVec n) (l r : Nat) :
    BitVec.extractLsb r l x = BitVec.ofNat (r - l + 1) (x.toNat >>> l)

@[simp] theorem rightpadPowerOfTwo_size (unit : Œ±) (a : Array Œ±) :
    (a.rightpadPowerOfTwo unit).size = 2 ^ (Nat.clog 2 a.size)

protected lemma errors_are_roots_of_elocPolyF {i : Fin n} {œâs f : Fin n ‚Üí F}
  (h : f i ‚â† p.eval (œâs i)) : (ElocPolyF œâs f p).eval (œâs i) = 0

Nat.cast_ofNat in Mathlib.Data.Nat.Cast.Defs

congrArg in Init.Prelude

lemma cast_mul (m n : ‚Ñï) {x y : ConcreteBTField m} (h_eq : m = n) :
  (cast (by exact cast_ConcreteBTField_eq m n h_eq) (x * y)) =
  (cast (by exact cast_ConcreteBTField_eq m n h_eq) x) *
  (cast (by exact cast_ConcreteBTField_eq m n h_eq) y)

theorem fiberwise_dist_lt_imp_dist_lt_unique_decoding_radius (i : Fin ‚Ñì) (steps : ‚Ñï)
    [NeZero steps] (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
    (f : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i, by omega‚ü©)
  (h_fw_dist_lt : fiberwiseClose ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
    (i := i) (steps := steps) (h_i_add_steps := h_i_add_steps) (f := f)) :
  hammingClose ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i, by omega‚ü© f

Nat.succ_lt_succ_iff in Init.Data.Nat.Basic

theorem append_comp {a : Fin m ‚Üí Œ±} {b : Fin n ‚Üí Œ±} (f : Œ± ‚Üí Œ≤) :
    append (f ‚àò a) (f ‚àò b) = f ‚àò append a b

theorem cast_symm {Œ± Œ≤ : Sort u} {h : Œ± = Œ≤} {a : Œ±} {b : Œ≤} :
    cast h a = b ‚Üî a = cast h.symm b

@[simp]
theorem hflatten_succ {m : ‚Ñï} {n : Fin (m + 1) ‚Üí ‚Ñï}
    {Œ± : (i : Fin (m + 1)) ‚Üí (j : Fin (n i)) ‚Üí Sort*}
    {v : (i : Fin (m + 1)) ‚Üí (j : Fin (n i)) ‚Üí Œ± i j} :
    hflatten v = happend (v 0) (hflatten (fun i => v i.succ))

@[simp]
theorem Prover.runToRound_one_of_prover_first [ProverOnly pSpec] (stmt : StmtIn) (wit : WitIn)
    (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      prover.runToRound 1 stmt wit = (do
        let state := prover.input (stmt, wit)
        let ‚ü®msg, state‚ü© ‚Üê liftComp (prover.sendMessage ‚ü®0, by simp‚ü© state) _
        return (fun i => match i with | ‚ü®0, _‚ü© => msg, state))

theorem simulateQ_bind_fst_comp (oa : OracleComp spec Œ±) (f : Œ± ‚Üí OracleComp spec Œ≤) :
    (do let a ‚Üê (simulateQ loggingOracle oa).run; f a.1) = (do let a ‚Üê oa; f a)

@[simp]
lemma numPartialRounds_pos : 0 < params.numPartialRounds

@[simp]
theorem FullData.rightSubtree_internal {Œ±} {s_left s_right : Skeleton}
    (value : Œ±) (left : FullData Œ± s_left) (right : FullData Œ± s_right) :
    (FullData.internal value left right).rightSubtree = right

lemma generalised_round_consistency_completeness
  {ùîΩ : Type} [inst1 : Field ùîΩ] [DecidableEq ùîΩ] {f : Polynomial ùîΩ}
  {n : ‚Ñï} [inst : NeZero n]
  {Œ≥ : ùîΩ}
  {s‚ÇÄ : ùîΩ}
  {œâ : Fin n ‚Ü™ ùîΩ}
  (h : ‚àÄ i, (œâ i) ^ n = 1)
  (h‚ÇÅ : s‚ÇÄ ‚â† 0)
  :
    roundConsistencyCheck
      Œ≥
      (List.map (fun i => (œâ i * s‚ÇÄ, f.eval (œâ i * s‚ÇÄ))) (List.finRange n))
      ((foldNth n f Œ≥).eval (s‚ÇÄ^n)) = true

@[simp]
theorem oracleReduction_perfectCompleteness (hInit : init.neverFails) :
    (oracleReduction oSpec Statement OStatement Witness).perfectCompleteness init impl rel rel

@[simp] theorem findIdx'_nil {p : Œ± ‚Üí Bool} : findIdx' p [] = 0

lemma oracleWitnessConsistency_relay_preserved
    (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i)
    (stmt : Statement (L := L) Context i.succ)
    (wit : Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j) :
    oracleWitnessConsistency (mp := mp) (ùìë := ùìë) ùîΩq Œ≤ i.succ i.castSucc
      (le_succ ‚Üëi.castSucc) stmt wit oStmt =
    oracleWitnessConsistency (mp := mp) (ùìë := ùìë) ùîΩq Œ≤ i.succ i.succ (by rfl) stmt wit
      (mapOStmtOutRelayStep ùîΩq Œ≤ i hNCR oStmt)

lemma xor_of_and_eq_zero_is_or {n m : ‚Ñï} (h_n_AND_m : n &&& m = 0) : n ^^^ m = n ||

theorem canonical_empty : (UniPoly.mk (R:=R) #[]).trim = #[]

private lemma F2i_card {Œ± : F} :
  (F2i B i Œ±).card = 2 * choose_2 (K B i Œ±)

lemma getBit_of_lt_two_pow {n: ‚Ñï} (a: Fin (2^n)) (k: ‚Ñï) :
  getBit k a = if k < n then getBit k a else 0

@[simp]
theorem binaryTowerAlgebra_id {l r : ‚Ñï} (h_eq : l = r) :
    @binaryAlgebraTower l r (h_le:=by omega) =
    (h_eq ‚ñ∏ (Algebra.id (BTField l)) : Algebra (BTField l) (BTField r))

lemma getBit_of_or {n m k: ‚Ñï} : getBit k (n ||| m) = getBit k n ||

lemma split_algebraMap_eq_zero_x {k : ‚Ñï} (h_pos : k > 0) (x : BTField (k - 1)) :
  letI instAlgebra := binaryAlgebraTower (l:=k-1) (r:=k) (h_le:=by omega)
  split (k:=k) (h_k:=h_pos) (algebraMap (BTField (k - 1)) (BTField k) x) = (0, x)

lemma and_two_pow_eq_two_pow_of_getBit_1 {n i : ‚Ñï} (h_getBit: getBit i n = 1) :
    n &&& (2 ^ i) = 2 ^ i

@[to_additive (attr := simp)]
theorem prod_insertNth [CommMonoid Œ≤] {n : ‚Ñï} (x : Œ≤) (f : Fin n ‚Üí Œ≤) (p : Fin (n + 1)) :
    ‚àè i, insertNth p x f i = x * ‚àè i, f i

@[simp]
theorem LeafData.get_ofLeft {s_left s_right : Skeleton} {Œ± : Type}
    (tree : LeafData Œ± (Skeleton.internal s_left s_right))
    (idxLeft : SkeletonLeafIndex s_left) :
    tree.get (SkeletonLeafIndex.ofLeft idxLeft) =
      tree.leftSubtree.get idxLeft

lemma num_eq_highBits_add_lowBits {n: ‚Ñï} (numLowBits: ‚Ñï) :
  n = getHighBits numLowBits n + getLowBits numLowBits n

theorem novelToMonomial_monomialToNovel_inverse
  (‚Ñì : ‚Ñï) (h_‚Ñì : ‚Ñì ‚â§ r) :
  ‚àÄ coeffs : Fin (2^‚Ñì) ‚Üí L,
    monomialToNovelCoeffs ùîΩq Œ≤ ‚Ñì h_‚Ñì
      (novelToMonomialCoeffs ùîΩq Œ≤ ‚Ñì h_‚Ñì coeffs) = coeffs

@[simp]
lemma mul_by_empty :
    mul_by_2 ‚àÖ = ‚àÖ

theorem insertNth_ne_zero_of_left (h : y ‚â† 0) : insertNth p y s ‚â† 0

@[simp]
theorem bool_accepts_iff : (bool j).accepts x ‚Üî x j * (x j - 1) = 0

theorem max_eq_add_sub {m n : Nat} : Nat.max m n = m + (n - m)

theorem fullOracleVerifier_rbrKnowledgeSoundness :
  (fullOracleVerifier ùîΩq Œ≤ Œ≥_repetitions (œë:=œë)
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).rbrKnowledgeSoundness init impl
    (relIn := roundRelation (mp := BBF_SumcheckMultiplierParam) ùîΩq Œ≤ (œë:=œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) 0)
    (relOut := acceptRejectOracleRel)
    (rbrKnowledgeError := fullRbrKnowledgeError ùîΩq Œ≤ Œ≥_repetitions (œë:=œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))

lemma getBit_eq_zero_or_one {k n : Nat} :
  getBit k n = 0 ‚à® getBit k n = 1

@[simp] lemma ofMvPolynomialAlgHom_X (s : œÉ) :
    ofMvPolynomialAlgHom (MvPolynomial.X s : MvPolynomial œÉ R) = (X s : P)

lemma evenize_eval {f : Polynomial F} {s : F} :
    (evenize f).eval s = f.eval (s * s)

@[simp]
theorem OracleReduction.id_perfectCompleteness
    {rel : Set ((StmtIn √ó ‚àÄ i, OStmtIn i) √ó WitIn)}
    (hInit : init.neverFails) :
    (OracleReduction.id : OracleReduction oSpec _ _ _ _ _ _ _).perfectCompleteness
      init impl rel rel

lemma folding_steps_pos : (œë : ‚Ñï) > 0

theorem size_eq_degree (p : UniPoly R) : p.trim.size = p.degree

@[simp]
lemma dfoldlM'_succ {n : ‚Ñï} {Œ± : Fin (n + 2) ‚Üí Type u}
    (f : (i : Fin (n + 1)) ‚Üí Œ± i.castSucc ‚Üí m (Œ± i.succ)) (x : Œ± 0) :
    dfoldlM' (n + 1) Œ± f x = (do
      let y ‚Üê dfoldlM' n (Œ± ‚àò castSucc) (fun i => f i.castSucc) x
      f (last n) y)

@[simp]
theorem reduction_completeness (h : init.neverFails) :
    (reduction oSpec Statement Witness).perfectCompleteness init impl relIn (toRelOut relIn)

theorem singleEqPolynomial_zeroOne_C (r : Fin 2) (x : Fin 2) :
    (singleEqPolynomial (r : R) (C x) : MvPolynomial œÉ R) = if x = r then 1 else 0

@[simp] theorem ofNat_toNat (t : AssocNat) : ofNat (toNat t) = t

@[grind =] theorem idxOf'_cons [BEq Œ±] {a : Œ±} {x : Œ±} {xs : List Œ±} :
    idxOf' a (x :: xs) = bif x == a then 0 else idxOf' a xs + 1

theorem coeff_of_toMvPolynomial_eq_coeff_of_MlPoly (p : MlPoly R n) (m : Fin n ‚Üí‚ÇÄ ‚Ñï) :
  coeff m (toMvPolynomial p) =
    if h_binary: (‚àÄ j: Fin n, m j ‚â§ 1) then
      let i_of_m: ‚Ñï := Nat.binaryFinMapToNat (m:=m) (h_binary:=h_binary)
      p[i_of_m]
    else
      0

@[simp]
theorem addCases'_right {m n : ‚Ñï} {Œ± : Fin m ‚Üí Sort u} {Œ≤ : Fin n ‚Üí Sort u}
    (left : (i : Fin m) ‚Üí Œ± i) (right : (j : Fin n) ‚Üí Œ≤ j) (i : Fin n) :
      addCases' left right (Fin.natAdd m i) = (Fin.append_right Œ± Œ≤ i) ‚ñ∏ (right i)

@[simp]
theorem generator_is_not_lifted_to_succ (k : ‚Ñï) :
  ‚àÄ x : ConcreteBTField k, canonicalAlgMap (k:=k) x ‚â† Z (k + 1)

@[csimp]
theorem dappend_eq_addCases : @dappend = @addCases

@[simp]
lemma aeval_X {A : Type y} [CommSemiring A] [Algebra R A] {F : Type z} [FunEquiv F œÉ A] (g : F)
    (s : œÉ) : aeval g (X s : P) = g s

@[simp]
theorem InternalData.get_ofFun {Œ±} {s} (f : SkeletonInternalIndex s ‚Üí Œ±) :
    (InternalData.ofFun s f).get = f

lemma solution_gamma_is_linear_in_Z
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  :
  ‚àÉ (v‚ÇÄ v‚ÇÅ : F[X]),
    Œ≥' x‚ÇÄ (R k Œ¥ x‚ÇÄ h_gs) (irreducible_H k (x‚ÇÄ := x‚ÇÄ) (Œ¥ := Œ¥) h_gs) =
        AppendixA.polyToPowerSeriesùïÉ _
          (
            (Polynomial.map Polynomial.C v‚ÇÄ) +
            (Polynomial.C Polynomial.X) * (Polynomial.map Polynomial.C v‚ÇÅ)
          )

lemma aeval_eq' {A : Type y} [CommSemiring A] [Algebra R A] {F : Type z} [FunEquiv F œÉ A]
    (f : P ‚Üí‚Çê[R] A) (p : P) : f p = aeval (fun s => f (X s) : F) p

theorem liftContext_completeness
    (h : R.completeness init impl innerRelIn innerRelOut completenessError) :
      (R.liftContext lens).completeness init impl outerRelIn outerRelOut completenessError

theorem towerAlgebraMap_succ_last (r : ‚Ñï) : ‚àÄ l : ‚Ñï, (h_le : l ‚â§ r) ‚Üí
  towerAlgebraMap (l:=l) (r:=r+1) (h_le:=by
    exact Nat.le_trans (n:=l) (m:=r) (k:=r+1) (h_le) (by omega)) =
  (towerAlgebraMap (l:=l+1) (r:=r+1) (by omega)).comp (towerAlgebraMap
    (l:=l) (r:=l+1) (by omega))

theorem cast_eq_dcast {h : n‚ÇÅ = n‚ÇÇ} {pSpec : ProtocolSpec n‚ÇÅ} :
    pSpec.cast h = dcast h pSpec

lemma getFoldingChallenges_init_succ_eq (i : Fin ‚Ñì)
    (j : Fin (toOutCodewordsCount ‚Ñì œë i.castSucc)) (challenges : Fin i.succ ‚Üí L)
    (h : ‚Üëj * œë + œë ‚â§ ‚Üëi.castSucc) :
    getFoldingChallenges (r := r) (ùì° := ùì°) (œë := œë) i.castSucc (Fin.init challenges) (‚Üëj * œë)
      (h := by omega) =
    getFoldingChallenges (r := r) (ùì° := ùì°) i.succ challenges (‚Üëj * œë)
      (h := by simp only [Fin.val_succ]; simp only [Fin.coe_castSucc] at h; omega)

@[simp]
lemma dfoldrM'_succ {n : ‚Ñï} {Œ± : Fin (n + 1 + 1) ‚Üí Type u}
    (f : (i : Fin (n + 1)) ‚Üí Œ± i.succ ‚Üí m (Œ± i.castSucc)) (x : Œ± (last (n + 1))) :
    dfoldrM' (n + 1) Œ± f x = (do
      let y ‚Üê dfoldrM' n (Œ± ‚àò succ) (fun i => f i.succ) x
      f 0 y)

@[simp]
theorem splitSum_succ {n : Fin (m + 1) ‚Üí ‚Ñï} {k : Fin (vsum n)} :
    splitSum k = Fin.dappend
      (fun k => ‚ü®0, k‚ü©)
      (fun k => ‚ü®(splitSum k).1.succ, (splitSum k).2‚ü©)
      k

lemma mkLastOracleIndex_last : mkLastOracleIndex ‚Ñì œë (Fin.last ‚Ñì) = ‚Ñì / œë - 1

@[simp]
lemma cons_eq_List.cons : x ::‚Çï xs = x :: xs

@[simp]
theorem mul_by_2_mem {s : Finset ‚Ñï} {d : ‚Ñï} :
    d ‚àà mul_by_2 s ‚Üî Even d ‚àß (d / 2) ‚àà s

lemma listOfCloseCodewordsRel_eq_zero :
  listOfCloseCodewordsRel C y r = 0 ‚Üî
  IsEmpty (relHammingBall C y r) ‚à® Infinite (relHammingBall C y r)

lemma oddPart_def :
  oddPart f =
  C (2‚Åª¬π : F) * (f - f.comp (-X)) /‚Çò X

@[simp]
lemma dotProduct_cons [AddCommMonoid R] [Mul R] (a : R) (b : Vector R n) (c : R) (d : Vector R n) :
  dotProduct (cons a b) (cons c d) = a * c + dotProduct b d

@[simp]
theorem induction_two' {motive : Fin 3 ‚Üí Sort*} {zero : motive 0}
    {succ : ‚àÄ i : Fin 2, motive i.castSucc ‚Üí motive i.succ} :
      induction (motive := motive) zero succ (2 : Fin 3) = succ 1 (succ 0 zero)

lemma degree_normalizedW (i : Fin r) :
  (normalizedW ùîΩq Œ≤ i).degree = (Fintype.card ùîΩq)^(i.val)

@[simp]
lemma invFun_toFun (f : F) : inst.equiv.invFun (inst.equiv.toFun f) = f

lemma listBlock_subset_listHamming
  (i k : ‚Ñï) {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F} {œÜ' : (indexPowT S œÜ i) ‚Ü™ F}
  {m : ‚Ñï} [DecidableEq F] [DecidableEq Œπ] [Smooth œÜ]
  (f : (indexPowT S œÜ i) ‚Üí F) (S' : Finset (indexPowT S œÜ i))
  [h_fintype : ‚àÄ i : ‚Ñï, Fintype (indexPowT S œÜ i)] [DecidableEq (indexPowT S œÜ i)] [Smooth œÜ']
  (C : Set ((indexPowT S œÜ i) ‚Üí F)) (hcode : C = smoothCode œÜ' m)
  [h_dec : DecidableBlockDisagreement i k f S' œÜ']
  (Œ¥ : ‚Ñù‚â•0) (hŒ¥Le : Œ¥ ‚â§ 1) :
  Œõ·µ£(i, k, f, S', C, hcode, Œ¥) ‚äÜ relHammingBall C f Œ¥

theorem fconcat‚ÇÇ_inj {Œ±‚ÇÅ : Fin n ‚Üí A} {Œ±‚ÇÇ : Fin n ‚Üí B} {Œ≤‚ÇÅ : A} {Œ≤‚ÇÇ : B}
    (v‚ÇÅ v‚ÇÇ : (i : Fin n) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i)) (a‚ÇÅ a‚ÇÇ : F‚ÇÇ Œ≤‚ÇÅ Œ≤‚ÇÇ) :
    fconcat‚ÇÇ (F := F‚ÇÇ) v‚ÇÅ a‚ÇÅ = fconcat‚ÇÇ (F := F‚ÇÇ) v‚ÇÇ a‚ÇÇ ‚Üî v‚ÇÅ = v‚ÇÇ ‚àß a‚ÇÅ = a‚ÇÇ

theorem fcons‚ÇÇ_injective2 {Œ±‚ÇÅ : A} {Œ±‚ÇÇ : B} {Œ≤‚ÇÅ : Fin n ‚Üí A} {Œ≤‚ÇÇ : Fin n ‚Üí B} :
    Function.Injective2 (@fcons‚ÇÇ A B F‚ÇÇ n Œ±‚ÇÅ Œ≤‚ÇÅ Œ±‚ÇÇ Œ≤‚ÇÇ)

theorem dconcat_inj {motive : Fin (n + 1) ‚Üí Sort u} (v w : (i : Fin n) ‚Üí motive (castSucc i))
    (a b : motive (last n)) :
    (v :+·µà‚ü®motive‚ü© a) = (w :+·µà‚ü®motive‚ü© b) ‚Üî v = w ‚àß a = b

theorem SkeletonNodeIndex.leftChild_bind_parent {s : Skeleton}
    (idx : SkeletonNodeIndex s) :
    idx.leftChild >>= parent = idx.leftChild.map (fun _ => idx)

theorem lt_iff_toNat_lt (a b : AssocNat) : a < b ‚Üî toNat a < toNat b

@[simp]
theorem embedSum_zero {n : Fin 0 ‚Üí ‚Ñï} {i : Fin 0} (j : Fin (n i)) : embedSum i j = i

lemma le_sInf_of_LB {S : Set ‚Ñï} (hne : S.Nonempty) {i : ‚Ñï}
    (hLB : ‚àÄ s ‚àà S, i ‚â§ s) : i ‚â§ sInf S

@[simp]
lemma dfoldr'_zero {Œ± : Fin 1 ‚Üí Type u}
    (f : (i : Fin 0) ‚Üí Œ± i.succ ‚Üí Œ± i.castSucc) (x : Œ± (last 0)) :
    dfoldr' 0 Œ± f x = x

lemma definingPoly_ne_zero {F : Type*} [Field F] [Fintype F] (s : F) [NeZero s] :
  (definingPoly s) ‚â† 0

@[simp]
theorem append_left_cancel_iff {pSpec : ProtocolSpec n} {p1 p2 : ProtocolSpec m} :
    p1 ++‚Çö pSpec = p2 ++‚Çö pSpec ‚Üî p1 = p2

theorem div_two_pow_lt_two_pow (x i j : ‚Ñï) (h_x_lt_2_pow_i : x < 2 ^ (i + j)): x / 2^j < 2^(i)

theorem mem_restrictDegree_iff_degreeOf_le (p : MvPolynomial œÉ R) (n : ‚Ñï) :
    p ‚àà restrictDegree œÉ R n ‚Üî ‚àÄ i, p.degreeOf i ‚â§ n

theorem dinit_hconcat {Œ± : Fin n ‚Üí Sort u} {Œ≤ : Sort u} (v : (i : Fin n) ‚Üí Œ± i) (b : Œ≤) :
    True

@[simp]
theorem fcons_succ {Œ≤ : Fin n ‚Üí A} (a : F Œ±) (v : (i : Fin n) ‚Üí F (Œ≤ i)) (i : Fin n) :
    fcons a v i.succ = cast (by simp [vcons_succ]) (v i)

theorem and_highBits_lowBits_eq_zero {n : ‚Ñï} (numLowBits : ‚Ñï) :
    getHighBits numLowBits n &&& getLowBits numLowBits n = 0

lemma coeff_polynomialOfCoeffs_eq_coeffs' :
  (polynomialOfCoeffs coeffs).coeff = fun x ‚Ü¶ if h : x < deg then coeffs ‚ü®x, h‚ü© else 0

omit [DecidableEq L] h_Fq_char_prime hF‚ÇÇ hŒ≤_lin_indep in
lemma Prod_W_comp_X_sub_C_ne_zero (i : Fin r) :
    (univ : Finset ùîΩq).prod (fun c => (W ùîΩq Œ≤ i).comp (X - C (c ‚Ä¢ Œ≤ i))) ‚â† 0

@[simp, grind] lemma fin_chunkSize_plus_absorbPos_lt_N (absorbPos arrSize : Nat)
    (i : Fin (min arrSize (SpongeSize.R - absorbPos))) :
    absorbPos + i < SpongeSize.N

@[simp]
theorem ranges_succ {a : ‚Ñï} {l : List ‚Ñï} :
    List.ranges (a :: l) = range a :: l.ranges.map (map (a + ¬∑))

lemma add_shiftRight_distrib {n m k : ‚Ñï} (h_and_zero : n &&& m = 0):
  (n + m) >>> k = (n >>> k) + (m >>> k)

lemma schwartz_zippel' {p : MvPolynomial œÉ R} (hp : p ‚â† 0) (S : œÉ ‚Üí Finset R) :
    #{x ‚àà Finset.pi p.vars S | eval (extendDomain x) p = 0} / ‚àè i ‚àà p.vars, (#(S i) : ‚Ñö‚â•0)
      ‚â§ ‚àë i ‚àà p.vars, (p.degreeOf i / #(S i) : ‚Ñö‚â•0)

theorem init_vconcat (v : Fin n ‚Üí Œ±) (a : Œ±) :
    (fun i => vconcat v a (Fin.castSucc i)) = v

theorem elim [LawfulBEq R] (p : UniPoly R) :
    (p.trim = #[] ‚àß  (‚àÄ i, (hi : i < p.size) ‚Üí p[i] = 0))
  ‚à® (‚àÉ k : Fin p.size,
        p.trim = p.extract 0 (k + 1)
      ‚àß p[k] ‚â† 0
      ‚àß (‚àÄ j : ‚Ñï, (hj : j < p.size) ‚Üí j > k ‚Üí p[j] = 0))

@[simp]
theorem fcons‚ÇÇ_one {Œ±‚ÇÅ : A} {Œ±‚ÇÇ : B} {Œ≤‚ÇÅ : Fin (n + 1) ‚Üí A} {Œ≤‚ÇÇ : Fin (n + 1) ‚Üí B}
    (a : F‚ÇÇ Œ±‚ÇÅ Œ±‚ÇÇ) (b : (i : Fin (n + 1)) ‚Üí F‚ÇÇ (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) :
    fcons‚ÇÇ (F := F‚ÇÇ) a b 1 = b 0

omit [Finite F] in
private lemma gen_def {i : ‚Ñï} :
    (IsCyclicWithGen.gen : evalDomain D i) =
      ‚ü®
        DIsCyclicC.gen ^ (2 ^ i),
        by
          apply pow_2_pow_i_mem_Di_of_mem_D
          exact DIsCyclicC.gen.2
      ‚ü©

lemma getBit_of_multiple_of_power_of_two {n p : ‚Ñï}: ‚àÄ k,
  getBit (k) (2^p * n) = if k < p then 0 else getBit (k-p) n

lemma twoAdicGenerator_unit_mem_rootsOfUnity
    (bits : Fin (twoAdicity + 1)) (h : twoAdicGenerators[bits] ‚â† 0) :
    Units.mk0 (twoAdicGenerators[bits]) h ‚àà rootsOfUnity (2 ^ (bits : Nat)) (Field)

Nat.pow_lt_pow_right in Init.Data.Nat.Lemmas

@[simp]
theorem cast_completeness (Œµ : ‚Ñù‚â•0) (hComplete : R.completeness init impl relIn relOut Œµ) :
    (R.cast hn hSpec hO‚Çò).completeness init impl relIn relOut Œµ

lemma ConcreteBTFieldAlgebra_def (l r : ‚Ñï) (h_le : l ‚â§ r) :
    @ConcreteBTFieldAlgebra (l:=l) (r:=r) (h_le:=h_le)
    = (concreteTowerAlgebraMap l r h_le).toAlgebra

@[simp]
theorem dist_subsingleton {C : Set (n ‚Üí R)} [Subsingleton C] : ‚ÄñC‚Äñ‚ÇÄ = 0

@[simp]
lemma runWithLogToRound_discard_log_eq_runToRound (i : Fin (n + 1))
    (stmt : StmtIn) (wit : WitIn) (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      Prod.fst <$> prover.runWithLogToRound i stmt wit =
        prover.runToRound i stmt wit

theorem induction_init {n : ‚Ñï} {motive : Fin (n + 2) ‚Üí Sort*} {zero : motive 0}
    {succ : ‚àÄ i : Fin (n + 1), motive i.castSucc ‚Üí motive i.succ} {i : Fin (n + 1)} :
      induction (motive := motive) zero succ i.castSucc =
        induction (motive := Fin.init motive) zero (fun j x => succ j.castSucc x) i

@[simp] theorem mul_zero {a : AssocNat} : a * 0 = 0

theorem join_eq_bitvec_iff_fromNat {k : ‚Ñï} (h_pos : k > 0) (x : ConcreteBTField k)
  (hi_btf lo_btf : ConcreteBTField (k - 1)) :
  x = „Ää hi_btf, lo_btf „Äã ‚Üî
  (hi_btf = fromNat (k:=k - 1) (x.toNat >>> 2 ^ (k - 1)) ‚àß
  lo_btf = fromNat (k:=k - 1) (x.toNat &&& (2 ^ (2 ^ (k - 1)) - 1)))

@[simp]
theorem card_filter_prod_self_eq :
  #({x ‚àà s √óÀ¢ s | x.1 = x.2}) = #s

theorem join_eq_join_iff {k : ‚Ñï} (h_pos : k > 0) (hi‚ÇÄ lo‚ÇÄ hi‚ÇÅ lo‚ÇÅ : ConcreteBTField (k - 1)) :
  „Ää hi‚ÇÄ, lo‚ÇÄ „Äã = „Ää hi‚ÇÅ, lo‚ÇÅ „Äã ‚Üî (hi‚ÇÄ = hi‚ÇÅ ‚àß lo‚ÇÄ = lo‚ÇÅ)

@[simp]
theorem cast_toVerifier (V : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec‚ÇÅ) :
    (OracleVerifier.cast hn hSpec hO‚Çò V).toVerifier = Verifier.cast hn hSpec V.toVerifier

lemma pow_inj {i : ‚Ñï} {a b : Fin (2 ^ (n - i))} :
    i ‚â§ n ‚Üí (DIsCyclicC.gen.1 ^ 2 ^ i) ^ a.1 = (DIsCyclicC.gen.1 ^ 2 ^ i) ^ b.1 ‚Üí a = b

@[ext]
theorem ext' {a b : AssocNat} (h : a 0 = b 0) : a = b

theorem vconcat_left_injective {n : ‚Ñï} (a : Œ±) :
    Function.Injective (fun v : Fin n ‚Üí Œ± => vconcat v a)

theorem peval_def (f : œÉ ‚Üí œÉ‚ÇÅ ‚äï œÉ‚ÇÇ) (x : œÉ‚ÇÅ ‚Üí R) (p : MvPolynomial œÉ R) :
    peval f x p = eval‚ÇÇ C (Sum.elim (fun i => C (x i)) X ‚àò f) p

@[grind _=_]
theorem monomialXY_mul_monomialXY {n m p q : ‚Ñï} {a b : F} :
    monomialXY n m a * monomialXY p q b = monomialXY (n + p) (m + q) (a * b)

@[simp]
theorem dcast‚ÇÉ_trans (ha : a = a') (ha' : a' = a'')
    (hb : dcast ha b = b') (hb' : dcast ha' b' = b'')
    (hc : dcast‚ÇÇ ha hb c = c') (hc' : dcast‚ÇÇ ha' hb' c' = c'') :
    dcast‚ÇÉ ha' hb' hc' (dcast‚ÇÉ ha hb hc d) =
    dcast‚ÇÉ (ha.trans ha') (by simp [‚Üê hb', ‚Üê hb]) (by simp [‚Üê hc', ‚Üê hc]) d

lemma add_two_pow_of_getBit_eq_zero_lt_two_pow {n m i : ‚Ñï} (h_n: n < 2^m) (h_i: i < m)
  (h_getBit_at_i_eq_zero: getBit i n = 0) :
  n + 2^i < 2^m

theorem add_assoc (a b c : AssocNat) : (a + b) + c = a + (b + c)

@[simp]
theorem tail_vcons (a : Œ±) (v : Fin n ‚Üí Œ±) : tail (a ::·µõ v) = v

theorem liftContext_perfectCompleteness
    (h : R.perfectCompleteness init impl innerRelIn innerRelOut) :
      (R.liftContext lens).perfectCompleteness init impl outerRelIn outerRelOut

lemma getBit_of_shiftRight {n p : ‚Ñï}:
  ‚àÄ k, getBit k (n >>> p) = getBit (k+p) n

@[simp]
theorem LeafData.get_internal_ofRight {Œ±} {s_left s_right : Skeleton}
    (left : LeafData Œ± s_left) (right : LeafData Œ± s_right)
    (idxRight : SkeletonLeafIndex s_right) :
    (LeafData.internal left right).get (SkeletonLeafIndex.ofRight idxRight) =
      right.get idxRight

@[simp]
theorem oracleReduction_completeness (hInit : init.neverFails) :
    (oracleReduction oSpec OStatement).perfectCompleteness
      init impl (relIn OStatement) (relOut OStatement)

lemma sum_of_and_eq_zero_is_xor {n m : ‚Ñï} (h_n_AND_m : n &&& m = 0) : n + m = n ^^^ m

Fin.coe_castSucc in Init.Data.Fin.Lemmas

@[simp]
theorem hflatten_one {n : Fin 1 ‚Üí ‚Ñï} {Œ± : (i : Fin 1) ‚Üí (j : Fin (n i)) ‚Üí Sort*}
    {v : (i : Fin 1) ‚Üí (j : Fin (n i)) ‚Üí Œ± i j} : hflatten v = v 0

private lemma really_glorious_lemma {f f' : Polynomial F} (h : 2 * f = 2 * f') :
    f = f'

NeZero.ne in Init.Data.NeZero

lemma solutionToQ_ne_zero {e k : ‚Ñï}
  [NeZero n]
  {œâs f : Fin n ‚Üí F}
  {v : Fin (2 * e + k) ‚Üí F}
  (h_dist : e < Œî‚ÇÄ(f, 0))
  (h_sol : IsBerlekampWelchSolution e k œâs f v)
  (h_inj : Function.Injective œâs)
  : solutionToQ e k v ‚â† 0

lemma johnson_condition_strong_iff_johnson_denom_pos {B : Finset (Fin n ‚Üí F)} {v : Fin n ‚Üí F} :
  JohnsonConditionStrong B v ‚Üî 0 < JohnsonDenominator B v

theorem eq_of_equiv [LawfulBEq R] {p q : UniPoly R} : equiv p q ‚Üí p.trim = q.trim

theorem peval_eq_eval_sumToIter_rename (f : œÉ ‚Üí œÉ‚ÇÅ ‚äï œÉ‚ÇÇ) (x : œÉ‚ÇÅ ‚Üí R) (p : MvPolynomial œÉ R) :
    peval f x p = eval (C ‚àò x) (sumToIter R œÉ‚ÇÅ œÉ‚ÇÇ (rename f p))

@[simp]
theorem cast_rbrKnowledgeSoundness (Œµ : pSpec‚ÇÅ.ChallengeIdx ‚Üí ‚Ñù‚â•0)
    (hRbrKs : V.rbrKnowledgeSoundness init impl relIn relOut Œµ) :
    (V.cast hn hSpec).rbrKnowledgeSoundness init impl relIn relOut
      (Œµ ‚àò (ChallengeIdx.cast hn.symm (cast_symm hSpec)))

theorem mapM_single (f : Œ± ‚Üí m Œ≤) (a : Œ±) : List.mapM f [a] = return [‚Üê f a]

lemma iterated_fold_transitivity
    (i : Fin r) (steps‚ÇÅ steps‚ÇÇ : Fin (‚Ñì + 1))
    (h_bounds : i.val + steps‚ÇÅ + steps‚ÇÇ ‚â§ ‚Ñì) -- A single, sufficient bounds check
    (f : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := i) ‚Üí L)
    (r_challenges‚ÇÅ : Fin steps‚ÇÅ ‚Üí L) (r_challenges‚ÇÇ : Fin steps‚ÇÇ ‚Üí L) :
    -- LHS : The nested fold (folding twice)
    have hi1 : i.val + steps‚ÇÅ ‚â§ ‚Ñì := by exact le_of_add_right_le h_bounds
    have hi2 : i.val + steps‚ÇÇ ‚â§ ‚Ñì := by
      rw [Nat.add_assoc, Nat.add_comm steps‚ÇÅ steps‚ÇÇ, ‚ÜêNat.add_assoc] at h_bounds
      exact le_of_add_right_le h_bounds
    have hi12 : steps‚ÇÅ + steps‚ÇÇ < ‚Ñì + 1 := by
      apply Nat.lt_succ_of_le; rw [Nat.add_assoc] at h_bounds;
      exact Nat.le_of_add_left_le h_bounds
    let lhs := iterated_fold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (i := ‚ü®i.val + steps‚ÇÅ, by -- ‚ä¢ ‚Üëi + ‚Üësteps‚ÇÅ < r
        apply Nat.lt_of_le_of_lt (m := ‚Ñì) (hi1) (‚Ñì_lt_r (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))‚ü©)
      (steps := steps‚ÇÇ)
      (h_i_add_steps := by simp only; apply Nat.lt_add_of_pos_right_of_le; exact h_bounds)
      (f := by
        exact iterated_fold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := i) (steps := steps‚ÇÅ)
          (h_i_add_steps := by apply Nat.lt_add_of_pos_right_of_le; exact hi1) (f := f)
          (r_challenges := r_challenges‚ÇÅ)
      ) r_challenges‚ÇÇ
    let rhs := iterated_fold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := i)
      (steps := ‚ü®steps‚ÇÅ + steps‚ÇÇ, hi12‚ü©)
      (h_i_add_steps := by
        simp only; rw [‚ÜêNat.add_assoc]; apply Nat.lt_add_of_pos_right_of_le; exact h_bounds)
      (f := f) (r_challenges := Fin.append r_challenges‚ÇÅ r_challenges‚ÇÇ)
    lhs = by
      simp only [‚ÜêNat.add_assoc] at ‚ä¢ rhs
      exact rhs

theorem get_rtake_eq_rtake_get_comp_cast {Œ± : Type*} {m : ‚Ñï} (l : List Œ±) (h : m ‚â§ l.length) :
    (l.rtake m).get = rtake m h l.get ‚àò Fin.cast (by simp [List.rtake]; omega)

lemma zsmul_succ {k : ‚Ñï} (n : ‚Ñï) (x : ConcreteBTField k) :
  (if (‚Üën.succ : ‚Ñ§) % 2 = 0 then zero else x) = (if (‚Üën : ‚Ñ§) % 2 = 0 then zero else x) + x

theorem vflatten_eq_vappend_last {m : ‚Ñï} {n : Fin (m + 1) ‚Üí ‚Ñï}
    {v : (i : Fin (m + 1)) ‚Üí Fin (n i) ‚Üí Œ±} :
    vflatten v =
      vappend (vflatten (fun i => v i.castSucc)) (v (last _)) ‚àò Fin.cast vsum_castSucc

@[simp]
theorem InternalData.leftSubtree_internal {Œ±} {s_left s_right : Skeleton}
    (value : Œ±) (left : InternalData Œ± s_left) (right : InternalData Œ± s_right) :
    (InternalData.internal value left right).leftSubtree = left

theorem fullOracleReduction_perfectCompleteness (hInit : init.neverFails) :
  OracleReduction.perfectCompleteness
    (oracleReduction := fullOracleReduction ùîΩq Œ≤ Œ≥_repetitions (œë:=œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë))
    (relIn := roundRelation (mp := BBF_SumcheckMultiplierParam) ùîΩq Œ≤ (œë:=œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) 0)
    (relOut := acceptRejectOracleRel)
    (init := init)
    (impl := impl)

@[csimp, grind =]
theorem findIdx'_eq_findIdx : @findIdx' = @findIdx

@[simp]
theorem seqCompose_embedSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    {T : ‚àÄ i, FullTranscript (pSpec i)} (i : Fin m) (j : Fin (n i)) :
    seqCompose T (Fin.embedSum i j) = cast (by simp) (T i j)

omit [Finite F] in
lemma D_def : evalDomain D x 0 = x ‚Ä¢ D

lemma toPoly_trim [LawfulBEq R] {p : UniPoly R} : p.trim.toPoly = p.toPoly
</all_available_lemmas>

<local_ctx>
import ArkLib.Data.Nat.Bitwise

import ArkLib.Data.Polynomial.Frobenius

import ArkLib.Data.Polynomial.MonomialBasis

import Mathlib.LinearAlgebra.StdBasis

import Mathlib.Algebra.Polynomial.Degree.Definitions

open Polynomial FiniteDimensional Finset Module

namespace AdditiveNTT

variable {r : ‚Ñï} [NeZero r]

variable {L : Type u} [Field L] [Fintype L] [DecidableEq L]

variable (ùîΩq : Type u) [Field ùîΩq] [Fintype ùîΩq]
  [h_Fq_char_prime : Fact (Nat.Prime (ringChar ùîΩq))] [hF‚ÇÇ : Fact (Fintype.card ùîΩq = 2)]

variable [Algebra ùîΩq L]

variable (h_dim : Module.finrank ùîΩq L = r)

variable (Œ≤ : Fin r ‚Üí L) [hŒ≤_lin_indep : Fact (LinearIndependent ùîΩq Œ≤)]

section LinearSubspaces

def U (i : Fin r) : Subspace ùîΩq L := Submodule.span ùîΩq (Œ≤ '' (Set.Ico 0 i))

noncomputable def W (i : Fin r) : L[X] :=
  ‚àè u : U ùîΩq Œ≤ i, (X - C u.val)

end LinearSubspaces

section LinearityOfSubspaceVanishingPolynomials

@[simps!]
noncomputable def algEquivAevalXSubC {R : Type*} [CommRing R] (t : R) : R[X] ‚âÉ‚Çê[R] R[X] :=
</local_ctx>

<target_theorem>
omit h_Fq_char_prime hF‚ÇÇ in
lemma rootMultiplicity_prod_W_comp_X_sub_C
    (i : Fin r) (h_i_add_1 : i + 1 < r) (a : L) :
    rootMultiplicity a ((univ : Finset ùîΩq).prod (fun c => (W ùîΩq Œ≤ i).comp (X - C (c ‚Ä¢ Œ≤ i)))) =
    if a ‚àà (U ùîΩq Œ≤ (i+1) : Set L) then 1 else 0 :=
</target_theorem>

