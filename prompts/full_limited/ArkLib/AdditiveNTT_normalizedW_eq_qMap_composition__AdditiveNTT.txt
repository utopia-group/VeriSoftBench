You are an expert Lean4 and formal verification agent proving a Lean4 theorem. Your output **must** strictly adhere to the specified format.

### Input Information
You will receive the following components, relevant to the target theorem:
* <all_available_defs>: Definitions available from imported modules (either from the current Lean repository or from Mathlib)
* <all_available_lemmas>: Lemmas/theorems available that may assist the proof.
* <local_ctx>...</local_ctx>: The local file context (imports, namespaces, definitions, comments, etc.) from the top of the file up to‚Äîbut not including‚Äîthe target theorem or any previously defined local lemmas/theorems.
* <target_theorem>...</target_theorem>: The target theorem statement, ending with `:=`.

**Notes**
1. Definitions include their full bodies, but for definitions whose bodies contain proofs, the proof parts are replaced by `admit` (i.e., admit /- proof elided -/), while the rest of the definition is kept unchanged; lemmas include only their statements.
2. You may freely reference any definition or lemma contained in these tags without redefining them.
3. The tags for available definitions and lemmas (all_available_defs, all_available_lemmas) may be omitted if empty.

### Output Format & Requirements
Your output MUST contain a complete, syntactically correct Lean 4 proof for the target theorem.

**Strict Output Structure:**
<reasoning> 
...
</reasoning> 

<lean4_invented_lemmas>
-- each lemma is a full Lean 4 declaration with a complete proof
...
</lean4_invented_lemmas>

<lean4_proof>
-- Lean 4 proof body of the target theorem
...
</lean4_proof>

**Requirements:**
1. <reasoning> and <lean4_invented_lemmas> are OPTIONAL. Include them only if they aid proof construction.
2. <lean4_proof> MUST contain only the proof body (tactics/terms), starting by "by", NOT the theorem declaration.
3. <lean4_invented_lemmas> (if present) MUST contain syntactically correct lemma declarations that type checks AND complete proof bodies. Defining a lemma using `axiom` is NOT allowed.
4. <reasoning> contains high-level proof planning.
5. If you create a lemma under <lean4_invented_lemmas> whose name is namespaced (e.g., X.Y.Z), you MUST always refer to it using its fully qualified name. Do NOT rely on shortened names. For example, write rw [X.Y.Z], not rw [Z] for invented lemmas.
6. All Lean 4 code MUST be syntactically correct. No `sorry`, `admit`, or non-Lean text. Comments allowed using `--` or `/- ... -/`.
7. Follow the tags and structure EXACTLY. No extra text before, between, or after the sections.
8. Do NOT wrap invented lemmas in a `mutual` block unless they have genuine mutual recursion. Declare each lemma independently.

### Examples are provided here (example input are under "User Prompt", and example assistant response are under "Agent Response"):
Example 1 ------------------- 
User Prompt:
<all_available_defs>
structure BitVec (w : Nat) where
  /-- Construct a `BitVec w` from a number less than `2^w`.
  O(1), because we use `Fin` as the internal representation of a bitvector. -/
  ofFin ::

  /-- Interpret a bitvector as a number less than `2^w`.
  O(1), because we use `Fin` as the internal representation of a bitvector. -/
  toFin : Fin (hPow 2 w)
</all_available_defs>

<all_available_lemmas>
theorem List.getElem_append_left{Œ± : Type u_1} {l‚ÇÅ l‚ÇÇ : List Œ±} {i : Nat} (hn : i < l‚ÇÅ.length) : (l‚ÇÅ ++ l‚ÇÇ)[i] = l‚ÇÅ[i]
theorem getElem_eq_testBit_toNat (x : BitVec w) (i : Nat) (h : i < w) :
  x[i] = x.toNat.testBit i := rfl
@[simp, grind =] theorem toNat_cons (b : Bool) (x : BitVec w) :
    (cons b x).toNat = (b.toNat <<< w) ||| x.toNat
@[simp, grind =] theorem getLsbD_of_ge (x : BitVec w) (i : Nat) (ge : w ‚â§ i) : getLsbD x i = false
theorem testBit_toNat (x : BitVec w) : x.toNat.testBit i = x.getLsbD i
</all_available_lemmas>

<local_ctx>
import Mathlib.Computability.NFA
import Mathlib.Data.FinEnum
import Mathlib.Data.Rel
import Mathlib.Data.Vector.Basic
import Blase.AutoStructs.ForLean

open Set
open Mathlib
open SetRel

-- this is better because card is defeq to n
instance (Œ± : Type) : Inter (Language Œ±) := ‚ü®Set.inter‚ü©
instance (Œ± : Type) : Union (Language Œ±) := ‚ü®Set.union‚ü©

/--
The set of `n`-tuples of bit vectors of an arbitrary width.
-/
structure BitVecs (n : Nat) where
  w : Nat
  bvs : List.Vector (BitVec w) n

def BitVecs.cast (bvs : BitVecs n) (h : n = n') : BitVecs n' :=
  { w := bvs.w, bvs := h ‚ñ∏ bvs.bvs }

abbrev BitVecs.empty : BitVecs n := ‚ü®0, List.Vector.replicate n .nil‚ü©
abbrev BitVecs.singleton {w : Nat} (bv : BitVec w) : BitVecs 1 := ‚ü®w, bv ::·µ• .nil‚ü©
abbrev BitVecs.pair {w : Nat} (bv1 bv2 : BitVec w) : BitVecs 2 := ‚ü®w, bv1 ::·µ• bv2 ::·µ• .nil‚ü©

/--
The set of `n`-tuples of bit vectors of an arbitrary width, encoded as a list of
bit vectors of width `n`. The width of the encoded bit vectors is the length of
the list.
-/
abbrev BitVecs' (n : Nat) := List (BitVec n)

@[simps]
def dec (bvs' : BitVecs' n) : BitVecs n where
  w := bvs'.length
  bvs := List.Vector.ofFn fun k => BitVec.ofFn fun i => bvs'[i].getLsbD k

@[simp]
</local_ctx>

<target_theorem>
lemma dec_snoc n (bvs' : BitVecs' n) (a : BitVec n) :
  dec (bvs' ++ [a]) =
    { w := bvs'.length + 1
      bvs := List.Vector.ofFn fun k =>
        BitVec.cons (a.getLsbD k) ((dec bvs').bvs.get k) } :=
</target_theorem>

Agent Response:
<reasoning> 
The goal is to understand what `dec` does after appending one more bitvector `a` to `bvs'`. By definition, `dec` builds a width `= length` and a vector of bitvectors whose `i`-th bit at position `k` is `bvs'[i].getLsbD k`. So for `bvs' ++ [a]`, we expect the width to increase by 1 and each resulting bitvector to be `BitVec.cons` of the new bit coming from `a`.

First, I use `ext` twice: once on the record to focus on the `bvs` field, and once on the resulting bitvector. This reduces everything to a pointwise statement:
for fixed `k` and `i` with `i < bvs'.length + 1`,
the bit `(bvs' ++ [a])[i].getLsbD k` should match the bit at index `i` of `BitVec.cons (a.getLsbD k) ((dec bvs').bvs.get k)`.

At this point I need a clean description of indexing into `BitVec.cons`: if we have `x : BitVec n`, then `(cons b x)[i]` should give `b` at the new ‚Äúlast‚Äù index `n` and `x[i]` otherwise. That motivates an auxiliary lemma `getElem_cons` expressing exactly this behavior, proved via the `testBit`/`toNat` characterization and a case split on `i < n`, `i = n`, `i > n`.

Using `getElem_cons`, the RHS becomes an `if` on whether `i = bvs'.length`. So I split into cases:
- If `i = bvs'.length`, then `(bvs' ++ [a])[i]` is the appended `a`, so both sides reduce to `a.getLsbD k`.
- If `i ‚â† bvs'.length`, the bound `i < bvs'.length + 1` forces `i < bvs'.length`. Then `(bvs' ++ [a])[i] = bvs'[i]` by `List.getElem_append_left`, and the RHS takes the ‚Äúelse‚Äù branch and likewise gives the bit from `bvs'[i]`. In both subcases, `simp` (plus the definition of `dec`) finishes.

So the whole proof is: `ext` to bit level, unfold `dec` with `simp_all`, rewrite with `getElem_cons`, split on the boundary index `i = length bvs'`, and in the ‚Äú< length‚Äù branch use `List.getElem_append_left` and bounds to line up both sides.
</reasoning> 

<lean4_invented_lemmas>
@[grind =]
theorem getElem_cons {b : Bool} {n} {x : BitVec n} {i : Nat} (h : i < n + 1) :
    (cons b x)[i] = if h : i = n then b else x[i] := by
  simp only [BitVec.getElem_eq_testBit_toNat, BitVec.toNat_cons, Nat.testBit_or]
  rw [Nat.testBit_shiftLeft]
  rcases Nat.lt_trichotomy i n with i_lt_n | i_eq_n | n_lt_i
  ¬∑ have p1 : ¬¨(n ‚â§ i) := by omega
    have p2 : i ‚â† n := by omega
    simp [p1, p2]
  ¬∑ simp only [i_eq_n, ge_iff_le, Nat.le_refl, decide_true, Nat.sub_self, Nat.testBit_zero,
    Bool.true_and, BitVec.testBit_toNat, BitVec.getLsbD_of_ge, Bool.or_false]
    cases b <;> trivial
  ¬∑ have p1 : i ‚â† n := by omega
    have p2 : i - n ‚â† 0 := by omega
    simp [p1, p2, Nat.testBit_bool_toNat]
</lean4_invented_lemmas>

<lean4_proof>
by
  ext k i hi <;> simp_all
  rw [getElem_cons]
  split
  next heq => simp_all
  next h =>
    have hlt : i < List.length bvs' := by simp at hi; omega
    rw [List.getElem_append_left hlt]
    simp
</lean4_proof>

### Your task:
<all_available_defs>
Fin in Init.Prelude
Subspace in Mathlib.Algebra.Module.Submodule.Basic
Set in Mathlib.Data.Set.Defs
Set.Ico in Mathlib.Order.Interval.Set.Defs
Submodule in Mathlib.Algebra.Module.Submodule.Defs
Submodule.span in Mathlib.LinearAlgebra.Span.Defs
Polynomial.C in Mathlib.Algebra.Polynomial.Basic
Nat in Init.Prelude
Fintype in Mathlib.Data.Fintype.Defs
Fintype.card in Mathlib.Data.Fintype.Card
algebraMap in Mathlib.Algebra.Algebra.Defs
Nat.succ in Init.Prelude
Polynomial.eval in Mathlib.Algebra.Polynomial.Eval.Defs
IsLinearMap in Mathlib.Algebra.Module.LinearMap.Defs
RingHom in Mathlib.Algebra.Ring.Hom.Defs
RingHom.id in Mathlib.Algebra.Ring.Hom.Defs
Finset in Mathlib.Data.Finset.Defs
Finset.univ in Mathlib.Data.Fintype.Defs
Polynomial.rootMultiplicity in Mathlib.Algebra.Polynomial.Div
DecidableEq in Init.Prelude
CommRing in Mathlib.Algebra.Ring.Defs
Polynomial.algEquivOfCompEqX in Mathlib.Algebra.Polynomial.AlgebraMap
Polynomial in Mathlib.Algebra.Polynomial.Basic
Polynomial.X in Mathlib.Algebra.Polynomial.Basic

noncomputable def W (i : Fin r) : L[X] :=
  ‚àè u : U ùîΩq Œ≤ i, (X - C u.val)

def U (i : Fin r) : Subspace ùîΩq L := Submodule.span ùîΩq (Œ≤ '' (Set.Ico 0 i))

noncomputable def normalizedW (i : Fin r) : L[X] :=
  C (1 / (W ùîΩq Œ≤ i).eval (Œ≤ i)) * W ùîΩq Œ≤ i

def getBit (k n : Nat) : Nat := (n >>> k) &&& 1

@[elab_as_elim] def Fin.succRecOnSameFinType {motive : Fin r ‚Üí Sort _}
    (zero : motive (0 : Fin r))
    (succ : ‚àÄ i : Fin r, i + 1 < r ‚Üí motive i ‚Üí motive (i + 1)) : ‚àÄ (i : Fin r), motive i
  | ‚ü®0, _‚ü© => by admit /- proof elided -/
  | ‚ü®Nat.succ i_val, h‚ü© => by admit /- proof elided -/

@[simps!]
noncomputable def algEquivAevalXSubC {R : Type*} [CommRing R] (t : R) : R[X] ‚âÉ‚Çê[R] R[X] :=

finCongr in Mathlib.Data.Fin.SuccPred

instance {Œπ : Type} : OracleInterface (OracleStatement Œπ F ()) := OracleInterface.instFunction

Set.offDiag in Mathlib.Data.Set.Operations

noncomputable def changeOfBasisMatrix (‚Ñì : Nat) (h_‚Ñì : ‚Ñì ‚â§ r) : Matrix (Fin (2^‚Ñì)) (Fin (2^‚Ñì)) L :=
    fun j i => (toCoeffsVec (L := L) (‚Ñì := ‚Ñì) (
      basisVectors ùîΩq Œ≤ ‚Ñì h_‚Ñì j)) i

def divX (p : UniPoly R) : UniPoly R := p.extract 1 p.size

@[inline, specialize]
def oracleReduction : OracleReduction oSpec
    Statement OStatement Unit Statement OStatement Unit !p[] where
  prover := oracleProver oSpec Statement OStatement
  verifier := oracleVerifier oSpec Statement OStatement pred

Algebra.cast in Mathlib.Algebra.Algebra.Defs

noncomputable def hasMutualCorrAgreement
  (Gen : ProximityGenerator Œπ F) [Fintype Gen.par‚Ñì]
  (BStar : ‚Ñù) (errStar : ‚Ñù ‚Üí ENNReal) :=
    haveI := Gen.Gen_nonempty
    ‚àÄ (f : Gen.par‚Ñì ‚Üí Œπ ‚Üí F) (Œ¥ : ‚Ñù‚â•0) (_hŒ¥ : 0 < Œ¥ ‚àß Œ¥ < 1 - BStar),
    Pr_{let r ‚Üê$·µñ Gen.Gen}[ proximityCondition f Œ¥ r Gen.C ] ‚â§ errStar Œ¥

def range (n : ‚Ñï) : Fin n ‚Üí ‚Ñï := fun i => i

@[inline, specialize]
def Reduction.runWithLog (stmt : StmtIn) (wit : WitIn)
    (reduction : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí)
        (((FullTranscript pSpec √ó StmtOut √ó WitOut) √ó StmtOut) √ó
          QueryLog (oSpec ++‚Çí [pSpec.Challenge]‚Çí) √ó QueryLog oSpec) := do
  
  let ‚ü®proverResult, proveQueryLog‚ü© ‚Üê reduction.prover.runWithLog stmt wit
  let ‚ü®stmtOut, verifyQueryLog‚ü© ‚Üê
    liftM (simulateQ loggingOracle (reduction.verifier.run stmt proverResult.1)).run
  return ‚ü®‚ü®proverResult, stmtOut‚ü©, proveQueryLog, verifyQueryLog‚ü©

@[reducible]
def duplexSpongeChallengeOracle (StartType : Type) (U : Type) [SpongeUnit U] [SpongeSize] :
    OracleSpec (Unit ‚äï PermuteDir) :=
  (StartType ‚Üí‚Çí Vector U SpongeSize.C) ++‚Çí permutationOracle (CanonicalSpongeState U)

alias ùíü_ùîñ := duplexSpongeChallengeOracle

def nonLastBlockOracleReduction (bIdx : Fin (‚Ñì / œë - 1)) :=
  let stmt : Fin (œë - 1 + 1) ‚Üí Type :=
    fun i => Statement (L := L) (‚Ñì := ‚Ñì) Context ‚ü®bIdx * œë + i, bIdx_mul_œë_add_i_cast_lt_‚Ñì_succ bIdx i‚ü©
  let oStmt := fun i: Fin (œë - 1 + 1) =>
    OracleStatement ùîΩq Œ≤ œë ‚ü®bIdx * œë + i, bIdx_mul_œë_add_i_cast_lt_‚Ñì_succ bIdx i‚ü©
  let wit := fun i: Fin (œë - 1 + 1) =>
    Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì)
      ‚ü®bIdx * œë + i, bIdx_mul_œë_add_i_cast_lt_‚Ñì_succ bIdx i‚ü©
  let firstFoldRelayRoundsOracleReduction :=
    OracleReduction.seqCompose (oSpec := []‚Çí)
      (Stmt := stmt)
      (OStmt := oStmt)
      (Wit := wit)
      (pSpec := fun i => pSpecFoldRelay (L:=L))
      (R := fun i => by admit /- proof elided -/
      )

  let h1 : ‚ÜëbIdx * œë + (œë - 1) < ‚Ñì := by admit /- proof elided -/

message in Examples.FrankingProtocol

@[simp]
def BTFieldCard (k : ‚Ñï) : Fintype.card (BTField k) = 2^(2^k)
  := (BinaryTowerAux k).2.fieldFintypeCard

@[simp]
instance BTField_Fintype (k : ‚Ñï) : Fintype (BTField k) := (BinaryTowerAux k).2.instFintype

def LeafData.ofFun {Œ± : Type} (s : Skeleton)
    (f : SkeletonLeafIndex s ‚Üí Œ±) : LeafData Œ± s :=
  match s with
  | .leaf => LeafData.leaf (f SkeletonLeafIndex.ofLeaf)
  | .internal l r =>
      LeafData.internal
        (LeafData.ofFun l (fun idx => f (SkeletonLeafIndex.ofLeft idx)))
        (LeafData.ofFun r (fun idx => f (SkeletonLeafIndex.ofRight idx)))

Polynomial.aeval in Mathlib.Algebra.Polynomial.AlgebraMap

def fappend {A : Sort u} {F : A ‚Üí Sort v} {m n : ‚Ñï} {Œ± : Fin m ‚Üí A} {Œ≤ : Fin n ‚Üí A}
    (u : (i : Fin m) ‚Üí F (Œ± i)) (v : (i : Fin n) ‚Üí F (Œ≤ i)) :
    (i : Fin (m + n)) ‚Üí F (Fin.vappend Œ± Œ≤ i) :=
  match n with
  | 0 => u
  | k + 1 => fconcat (fappend u (fun i => v (Fin.castSucc i))) (v (Fin.last k))

Fintype.piFinset in Mathlib.Data.Fintype.Pi

def multilinearBasis (l r : ‚Ñï) (h_le : l ‚â§ r) :
    letI instAlgebra := ConcreteBTFieldAlgebra (h_le:=h_le)
    Basis (Fin (2 ^ (r - l))) (ConcreteBTField l) (ConcreteBTField r) :=

def projectToMidSumcheckPoly (t : MultilinearPoly L ‚Ñì)
    (m : MultilinearPoly L ‚Ñì) (i : Fin (‚Ñì + 1))
    (challenges : Fin i ‚Üí L)
    : MultiquadraticPoly L (‚Ñì-i) :=
  let H‚ÇÄ: MultiquadraticPoly L ‚Ñì := computeInitialSumcheckPoly (‚Ñì:=‚Ñì) t m
  let H·µ¢ := fixFirstVariablesOfMQP (‚Ñì := ‚Ñì) (v := ‚ü®i, by admit /- proof elided -/
  ‚ü©)
    (H := H‚ÇÄ) (challenges := challenges)
  ‚ü®H·µ¢, by admit /- proof elided -/
  ‚ü©

def map {Œ± Œ≤ : Fin n ‚Üí Sort*} (f : (i : Fin n) ‚Üí Œ± i ‚Üí Œ≤ i) (a : (i : Fin n) ‚Üí Œ± i) :
    (i : Fin n) ‚Üí Œ≤ i := fun i => f i (a i)

Array.foldl in Init.Data.Array.Basic

noncomputable def foldingBadEventAtBlock
    (stmtIdx : Fin (‚Ñì + 1)) (oracleIdx : Fin (‚Ñì + 1))
    (oStmt : ‚àÄ j, (OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (i := oracleIdx) j))
    (challenges : Fin stmtIdx ‚Üí L)
    (j : Fin (toOutCodewordsCount ‚Ñì œë oracleIdx)) : Prop :=
  have h_œë: œë > 0 := by admit /- proof elided -/

def Verifier.liftContext
    (lens : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut)
    (V : Verifier oSpec InnerStmtIn InnerStmtOut pSpec) :
      Verifier oSpec OuterStmtIn OuterStmtOut pSpec where
  verify := fun stmtIn transcript => do
    let innerStmtIn := lens.proj stmtIn
    let innerStmtOut ‚Üê V.verify innerStmtIn transcript
    return lens.lift stmtIn innerStmtOut

def dfoldl' (n : ‚Ñï) (Œ± : Fin (n + 1) ‚Üí Type u)
    (f : (i : Fin n) ‚Üí Œ± i.castSucc ‚Üí Œ± i.succ) (init : Œ± 0) : Œ± (last n) :=
  dfoldlM' (m := Id) n Œ± f init

Lean.mkRawNatLit in Lean.Expr

def prover : OracleProver oSpec (StmtIn R) (OStmtIn R deg) Unit (StmtOut R) (OStmtOut R deg) Unit
    (pSpec R deg) where
  PrvState
    | 0 => R‚¶É‚â§ deg‚¶Ñ[X]
    | 1 => R‚¶É‚â§ deg‚¶Ñ[X]
    | 2 => R‚¶É‚â§ deg‚¶Ñ[X] √ó R

  input := fun ‚ü®‚ü®_, oStmt‚ü©, _‚ü© => oStmt ()

  sendMessage
  | ‚ü®0, _‚ü© => fun polyLE => pure ‚ü®polyLE, polyLE‚ü©
  | ‚ü®1, h‚ü© => nomatch h

  receiveChallenge
  | ‚ü®0, h‚ü© => nomatch h
  | ‚ü®1, _‚ü© => fun polyLE => pure fun chal => ‚ü®polyLE, chal‚ü©

  output := fun ‚ü®polyLE, chal‚ü© => pure (((polyLE.val.eval chal, chal), fun _ => polyLE), ())

@[reducible]
def GroupEncodeOracle : OracleSpec Unit := fun _ => (Œπ, BitVec bitLength)

class VCVCompatible (Œ± : Type*) extends Fintype Œ±, Inhabited Œ± where
  [type_decidableEq' : DecidableEq Œ±]

def BBF_CodeDistance (‚Ñì ùì° : ‚Ñï) (i : Fin (‚Ñì + 1)) : ‚Ñï :=
  2^(‚Ñì + ùì° - i.val) - 2^(‚Ñì - i.val) + 1

instance : ‚àÄ i, NeZero (toOutCodewordsCount ‚Ñì œë i) :=

def degree (P : Params Œπ F) : Fin (M + 1) ‚Üí ‚Ñï :=
  fun i => P.deg / ‚àè j < i, (P.foldingParam j)

@[reducible, simp]
def relOut : (StmtOut OStatement √ó ‚àÄ i, OStmtOut OStatement i) ‚Üí WitOut ‚Üí Prop :=
  fun ‚ü®‚ü®q, r‚ü©, oStmt‚ü© () => answer (oStmt 0) q = r

def proximityMeasure (u v : n ‚Üí F) (d : ‚Ñï) : ‚Ñï :=
  Fintype.card {r : F | Œî‚ÇÄ'(r ‚Ä¢ u + (1 - r) ‚Ä¢ v, C) ‚â§ d}

@[reducible, simp] def StmtOut := Query OStatement

instance [VerifierFirst pSpec] [h : VCVCompatible (pSpec.¬´Type¬ª 0)] :
    ‚àÄ i, VCVCompatible (pSpec.Challenge i)
  | ‚ü®0, _‚ü© => inferInstance

def InternalData.map {Œ± Œ≤ : Type} (f : Œ± ‚Üí Œ≤) {s : Skeleton}
    (tree : InternalData Œ± s) : InternalData Œ≤ s :=
  match tree with
  | InternalData.leaf => InternalData.leaf
  | InternalData.internal value left right =>
    InternalData.internal (f value) (left.map f) (right.map f)

def isZero {Œ± : Type} (n : ChurchNat Œ±) : ChurchBool Œ± :=
  fun x y => n (fun _ => y) x

Function.Embedding.subtype in Mathlib.Logic.Embedding.Basic

def hconcat {n : ‚Ñï} {Œ± : Fin n ‚Üí Sort u} {Œ≤ : Sort u} (u : (i : Fin n) ‚Üí Œ± i) (a : Œ≤) :
    (i : Fin (n + 1)) ‚Üí Fin.vconcat Œ± Œ≤ i :=
  fconcat (F := id) u a

def churchFalse : ChurchBool Œ± := fun _ y => y

def LeafData.composeBuild {Œ± : Type} {s : Skeleton} (leaf_data_tree : LeafData Œ± s)
    (compose : Œ± ‚Üí Œ± ‚Üí Œ±) :
    FullData Œ± s :=
  match s, leaf_data_tree with
  | Skeleton.leaf, LeafData.leaf value =>
    FullData.leaf value
  | Skeleton.internal _ _, LeafData.internal left right =>
    let left_tree := LeafData.composeBuild left compose
    let right_tree := LeafData.composeBuild right compose
    FullData.internal
      (compose left_tree.getRootValue right_tree.getRootValue)
      left_tree
      right_tree

Fintype.ofEquiv in Mathlib.Data.Fintype.OfMap

noncomputable def finalSumcheckOracleReduction :
  OracleReduction
    (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì))
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì))
    (StmtOut := FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì))
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (WitOut := Unit)
    (pSpec := pSpecFinalSumcheckStep (L := L)) where
  prover := finalSumcheckProver ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
  verifier := finalSumcheckVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)

@[inline] def one : AssocNat :=
  ‚ü®Nat.succ, by admit /- proof elided -/
  ‚ü©

instance instDCast‚ÇÇ : DCast‚ÇÇ Nat ProtocolSpec (fun _ pSpec => ChallengeIdx pSpec) where
  dcast‚ÇÇ h := ChallengeIdx.cast h
  dcast‚ÇÇ_id := cast_id

instance [ProverFirst pSpec] : ProverLast pSpec where
  prover_last' := by admit /- proof elided -/

def getMiddleBits (offset len n : ‚Ñï) : ‚Ñï :=
  getLowBits (numLowBits:=len) (n:=n >>> offset)

def churchTrue : ChurchBool Œ± := fun x _ => x

def pSpecLastBlock := pSpecFoldRelaySequence (L:=L) (n:=œë)

class DCast‚ÇÇ (Œ± : Sort*) (Œ≤ : Œ± ‚Üí Sort*) (Œ≥ : (a : Œ±) ‚Üí Œ≤ a ‚Üí Sort*) [DCast Œ± Œ≤] where
  dcast‚ÇÇ : ‚àÄ {a a' : Œ±} {b : Œ≤ a} {b' : Œ≤ a'},
    (ha : a = a') ‚Üí (dcast ha b = b') ‚Üí Œ≥ a b ‚Üí Œ≥ a' b'
  dcast‚ÇÇ_id : ‚àÄ {a : Œ±} {b : Œ≤ a}, dcast‚ÇÇ (Eq.refl a) dcast_eq = (id : Œ≥ a b ‚Üí Œ≥ a b)

def foldingBadEvent (i : Fin ‚Ñì) (steps : ‚Ñï) [NeZero steps] (h_i_add_steps : i + steps ‚â§ ‚Ñì)
  (f_i : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i, by admit /- proof elided -/
  ‚ü©)
  (challenges : Fin steps ‚Üí L) : Prop :=
  let d_i_plus_steps := BBF_CodeDistance ‚Ñì ùì° ‚ü®i + steps, by admit /- proof elided -/
  ‚ü©
  if h_is_close : 2 * fiberwiseDistance ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := i)
      steps h_i_add_steps f_i < (d_i_plus_steps : ‚Ñï‚àû) then
    
    
    
    let h_dist_curr_lt := fiberwise_dist_lt_imp_dist_lt_unique_decoding_radius ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := i) (steps := steps) h_i_add_steps f_i h_is_close

    let f_bar_i := uniqueClosestCodeword ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (i := ‚ü®i, by admit /- proof elided -/
      ‚ü©) (h_i := by admit /- proof elided -/
      ) f_i
      h_dist_curr_lt
    let folded_f_i := iterated_fold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (steps := ‚ü®steps, by admit /- proof elided -/
      ‚ü©) (i := ‚ü®i, by admit /- proof elided -/
      ‚ü©)
      (h_i_add_steps := by admit /- proof elided -/
      ) f_i challenges
    let folded_f_bar_i := iterated_fold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (steps := ‚ü®steps, by admit /- proof elided -/
      ‚ü©) (i := ‚ü®i, by admit /- proof elided -/
      ‚ü©)
      (h_i_add_steps := by admit /- proof elided -/
      ) f_bar_i challenges

    let fiberwise_disagreements := fiberwiseDisagreementSet ùîΩq Œ≤ i steps h_i_add_steps
      f_i f_bar_i
    let folded_disagreements := disagreementSet ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i steps
      h_i_add_steps folded_f_i folded_f_bar_i
    
    ¬¨ (fiberwise_disagreements ‚äÜ folded_disagreements)
  else
    
    
    
    let folded_f_i := iterated_fold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (steps := ‚ü®steps, by admit /- proof elided -/
      ‚ü©) (i := ‚ü®i, by admit /- proof elided -/
      ‚ü©)
      (h_i_add_steps := by admit /- proof elided -/
      ) f_i challenges
    let dist_to_code := distFromCode folded_f_i
      (BBF_Code ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i + steps, by admit /- proof elided -/
      ‚ü©)
    2 * dist_to_code < (d_i_plus_steps : ‚Ñï‚àû)

abbrev take (m : ‚Ñï) (h : m ‚â§ n)
    (transcript : FullTranscript pSpec) : FullTranscript (pSpec.take m h) :=
  Fin.take m h transcript

def findSumIdx' (l : List ‚Ñï) (j : Fin l.sum) : Fin l.length := ‚ü®findSumIdx l j, sorry‚ü©

structure Gate (ùì° : Type*) (numWires : ‚Ñï) extends Selector ùì°, WireIndices numWires
deriving DecidableEq

def oracleProver : OracleProver oSpec
    Statement OStatement Unit
    Unit (OStatement ‚äï·µ• OStatement) Unit
    (pSpec OStatement) where
  PrvState := fun _ => OStatement default

  input := fun ‚ü®‚ü®_, oStmt‚ü©, _‚ü© => oStmt default

  sendMessage | ‚ü®0, _‚ü© => fun st => pure (st, st)

  receiveChallenge | ‚ü®0, h‚ü© => nomatch h

  output := fun st => pure
    (‚ü®(), fun x => match x with
      | .inl _ => by admit /- proof elided -/
      ‚ü©,
     ())

LinearMap in Mathlib.Algebra.Module.LinearMap.Defs

def towerAlgebraMap (l r : ‚Ñï) (h_le : l ‚â§ r) : BTField l ‚Üí+* BTField r :=

def g (n : ‚Ñï) (c : ‚Ñï) (x : ‚Ñï) := (x * x + c) % n

def internalLinearLayer (state : Vector KoalaBear.Field params.width) :
    Vector KoalaBear.Field params.width :=
  
  
  let sumAll := state.foldl (fun acc x => acc + x) 0

  
  
  state.zipWith (fun s d => sumAll + d * s) params.internalDiagVectors

@[reducible]
def Set.language {Œ± Œ≤} (rel : Set (Œ± √ó Œ≤)) : Set Œ± :=
  Prod.fst '' rel

def LeafData.optionComposeBuild {Œ± : Type} {s : Skeleton} (leaf_data_tree : LeafData Œ± s)
    (compose : Œ± ‚Üí Œ± ‚Üí Option Œ±) :
    FullData (Option Œ±) s :=
  (leaf_data_tree.map (.some)).composeBuild (Option.doubleBind compose)

def extend {k : Fin n} (messages : MessagesUpTo k.castSucc pSpec)
    (h : pSpec.dir k = .V_to_P) : MessagesUpTo k.succ pSpec :=
  fun ‚ü®i, h‚ü© => (concat' (pSpec := pSpec) (fun i hi => messages ‚ü®i, hi‚ü©) (fun h' => by admit /- proof elided -/
  )) i h

Odd in Mathlib.Algebra.Ring.Parity

instance {k : Fin 1} : Unique (ChallengesUpTo k !p[]) where
  default := fun ‚ü®‚ü®i, h‚ü©, _‚ü© => by admit /- proof elided -/

impl in Mathlib.Deprecated.MLList.BestFirst

instance oCtxLens_complete :
    (oCtxLens R n deg D i).toContext.IsComplete
      (relationRound R n deg D i.castSucc) (Simple.inputRelation R deg D)
      (relationRound R n deg D i.succ) (Simple.outputRelation R deg)
      ((Simple.oracleReduction R deg D oSpec).toReduction.compatContext
        (oCtxLens R n deg D i).toContext)
where
  proj_complete := by admit /- proof elided -/

Algebra.TensorProduct.includeRight in Mathlib.RingTheory.TensorProduct.Basic

Submodule.map in Mathlib.Algebra.Module.Submodule.Map

@[inline, reducible]
def toContext :
    Context.Lens (OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i)) (OuterStmtOut √ó (‚àÄ i, OuterOStmtOut i))
                (InnerStmtIn √ó (‚àÄ i, InnerOStmtIn i)) (InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i))
                OuterWitIn OuterWitOut InnerWitIn InnerWitOut :=
  ‚ü®lens.stmt, lens.wit‚ü©

noncomputable def monomialBasisOfDegreeLT {n : ‚Ñï} : Basis (Fin n) L (L‚¶É< n‚¶Ñ[X]) :=

def sumExceptFirst' (n : ‚Ñï) (h : n > 0) (D : Fin (n - 1) ‚Üí Finset R) :
    MvPolynomial (Fin n) R ‚Üí‚Çó[R] Polynomial R :=

def KnowledgeStateFunction.toStateFunction
    {relIn : Set (StmtIn √ó WitIn)} {relOut : Set (StmtOut √ó WitOut)}
    {verifier : Verifier oSpec StmtIn StmtOut pSpec} {WitMid : Fin (n + 1) ‚Üí Type}
    {extractor : Extractor.RoundByRound oSpec StmtIn WitIn WitOut pSpec WitMid}
    (kSF : KnowledgeStateFunction init impl relIn relOut verifier extractor) :
      verifier.StateFunction init impl relIn.language relOut.language where
  toFun := fun m stmtIn tr => ‚àÉ witMid, kSF.toFun m stmtIn tr witMid
  toFun_empty := by admit /- proof elided -/

@[simp]
def poly (k : ‚Ñï) : Polynomial (BTField k) := definingPoly (s:=(Z k))

IO in Init.System.IO

Equiv.piCongr in Mathlib.Logic.Equiv.Basic

@[inline, specialize]
def OracleReduction.run [‚àÄ i, OracleInterface (pSpec.Message i)]
    (stmt : StmtIn) (oStmt : ‚àÄ i, OStmtIn i) (wit : WitIn)
    (reduction : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec) :
      OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí)
        ((FullTranscript pSpec √ó (StmtOut √ó ‚àÄ i, OStmtOut i) √ó WitOut) √ó
          (StmtOut √ó ‚àÄ i, OStmtOut i)) := do
  let proverResult ‚Üê reduction.prover.run ‚ü®stmt, oStmt‚ü© wit
  let stmtOut ‚Üê liftM (reduction.verifier.run stmt oStmt proverResult.1)
  return ‚ü®proverResult, stmtOut‚ü©

def relayKnowledgeStateFunction (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
    (relayOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        i hNCR).KnowledgeStateFunction init impl
      (relIn := foldStepRelOut (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i.succ)
      (extractor := relayRbrExtractor ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) where
  toFun := fun m ‚ü®stmtIn, oStmtIn‚ü© tr witMid =>
    relayKStateProp (mp:=mp) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (ùìë := ùìë) i hNCR stmtIn witMid oStmtIn
  toFun_empty := fun ‚ü®stmtIn, oStmtIn‚ü© witIn => by admit /- proof elided -/

@[inline, specialize]
def oracleVerifier : OracleVerifier oSpec
    Statement OStatement Statement (OStatement ‚äï·µ• (fun _ : Fin 1 => Witness))
    (oraclePSpec Witness) where
  verify := fun stmt _ => pure stmt
  embed := .sumMap (.refl _)
    <| Equiv.toEmbedding
    <|.symm (subtypeUnivEquiv (by admit /- proof elided -/
    ))
  hEq := by admit /- proof elided -/

@[inline]
def seqCompose {m : ‚Ñï} (Stmt : Fin (m + 1) ‚Üí Type)
    {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (V : (i : Fin m) ‚Üí Verifier oSpec (Stmt i.castSucc) (Stmt i.succ) (pSpec i)) :
    Verifier oSpec (Stmt 0) (Stmt (Fin.last m)) (seqCompose pSpec) := match m with
  | 0 => Verifier.id
  | _ + 1 => append (V 0) (seqCompose (Stmt ‚àò Fin.succ) (fun i => V (Fin.succ i)))

@[reducible]
def SCALAR_FIELD_CARD : Nat := 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141

Finset.range in Mathlib.Data.Finset.Range

abbrev Field := ZMod fieldSize

def knowledgeSoundness
    (relIn : Set ((StmtIn √ó ‚àÄ i, OStmtIn i) √ó WitIn))
    (relOut : Set ((StmtOut √ó ‚àÄ i, OStmtOut i) √ó WitOut))
    (verifier : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec)
    (knowledgeError : ‚Ñù‚â•0) : Prop :=
  verifier.toVerifier.knowledgeSoundness init impl relIn relOut knowledgeError

class PrimeOrder (G : Type*) [Group G] where
  p : ‚Ñï
  [hPrime : Fact (Nat.Prime p)]
  hCard : Nat.card G = p

@[app_unexpander Fin.vcons]
def vconsUnexpander : Lean.PrettyPrinter.Unexpander
  | `($_ $term !v[$term2, $terms,*]) => `(!v[$term, $term2, $terms,*])
  | `($_ $term !v[$term2]) => `(!v[$term, $term2])
  | `($_ $term !v[]) => `(!v[$term])
  | _ => throw ()

Matrix.rank in Mathlib.LinearAlgebra.Matrix.Rank

Int in Init.Data.Int.Basic

@[simp]
abbrev SecondSumcheckChallenge : Type := Fin pp.‚Ñì_n ‚Üí R

structure Commit where
  commit : Data ‚Üí Randomness ‚Üí OracleComp oSpec Commitment

noncomputable def proximity_gap_degree_bound (rho : ‚Ñö) (m n : ‚Ñï) : ‚Ñï :=
  let b := D_X rho m n
  if h : ‚àÉ n : ‚Ñï, b = n
  then h.choose - 1
  else Nat.floor b

@[inline]
def ofOutputOnly
    (liftWit : OuterStmtIn √ó OuterWitIn ‚Üí InnerStmtOut √ó InnerWitOut ‚Üí OuterWitOut) :
    Witness.Lens OuterStmtIn InnerStmtOut OuterWitIn OuterWitOut OuterWitIn InnerWitOut :=
  ‚ü®Prod.snd, liftWit‚ü©

Polynomial.toFinsupp in Mathlib.Algebra.Polynomial.Basic

def additiveNTTInvariant (evaluation_buffer : Fin (2 ^ (‚Ñì + R_rate)) ‚Üí L)
    (original_coeffs : Fin (2 ^ ‚Ñì) ‚Üí L) (i : Fin (‚Ñì + 1)) : Prop :=
  ‚àÄ (j : Fin (2^(‚Ñì + R_rate))),
    let u_b_v := j.val
    let v: Fin (2^i.val) := ‚ü®Nat.getLowBits i.val u_b_v, by admit /- proof elided -/
    ‚ü© 
    let u_b := u_b_v / (2^i.val) 
    have h_u_b : u_b = u_b_v / (2^i.val) := by admit /- proof elided -/

def distanceLE (Message : Type*) [O : OracleInterface Message]
    [Fintype (O.Query)] [DecidableEq (O.Response)] (d : ‚Ñï) : Prop :=
  ‚àÄ a b : Message, a ‚â† b ‚Üí #{q | OracleInterface.answer a q = OracleInterface.answer b q} ‚â§ d

def powFiberT (i : ‚Ñï) {k : ‚Ñï} {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F} (S' : Finset (indexPowT S œÜ i))
  (œÜ' : (indexPowT S œÜ i) ‚Ü™ F) (y : indexPowT S œÜ k) :=
  { x : (indexPowT S œÜ i) // x ‚àà S' ‚àß (œÜ' x) ^ (2^(k-i)) = y.val }

@[reducible, simp]
def rbrSoundness (langIn : Set Statement)
    (verifier : Verifier oSpec Statement Bool pSpec)
    (rbrSoundnessError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) : Prop :=
  verifier.rbrSoundness init impl langIn acceptRejectRel.language rbrSoundnessError

OptionT in Init.Control.Option

instance : LawfulHasPred Nat where
  pred'_succ := Nat.pred_succ

Finset.univ in Mathlib.Data.Fintype.Defs

instance {Message : Type u} : Inhabited (OracleInterface Message) :=
  ‚ü®instDefault‚ü©

Fin.succEmb in Mathlib.Data.Fin.Embedding

def sumcheckConsistencyProp {k : ‚Ñï} (sumcheckTarget : L) (H : L‚¶É‚â§ 2‚¶Ñ[X Fin (k)]) : Prop :=
  sumcheckTarget = ‚àë x ‚àà (univ.map ùìë) ^·∂† (k), H.val.eval x

Fin.succAboveEmb in Mathlib.Data.Fin.Embedding

Polynomial.ofFinsupp in Mathlib.Algebra.Polynomial.Basic

class IsCyclicWithGen (G : Type) [Pow G ‚Ñ§] where
  gen : G
  zpow_surjective : Function.Surjective (gen ^ ¬∑ : ‚Ñ§ ‚Üí G)

def liftingLens :
  OracleContext.Lens
    ((Fin m ‚Üí F) √ó Fri.Spec.Statement F (0 : Fin (k + 1))) (Fri.Spec.FinalStatement F k)
    (Fri.Spec.Statement F (0 : Fin (k + 1))) (Fri.Spec.FinalStatement F k)
    (OracleStatement D x m) (Fri.Spec.FinalOracleStatement D x s)
    (Fri.Spec.OracleStatement D x s 0) (Fri.Spec.FinalOracleStatement D x s)
    (Fri.Spec.Witness F s d 0) (Fri.Spec.Witness F s d (Fin.last (k + 1)))
    (Fri.Spec.Witness F s d 0) (Fri.Spec.Witness F s d (Fin.last (k + 1))) where
  stmt := Witness.InvLens.ofOutputOnly <| fun ‚ü®‚ü®cs, stmt‚ü©, ostmt‚ü© =>
    ‚ü®
      stmt,
      fun j v =>
          have : v.1 ‚àà Fri.CosetDomain.evalDomain D x 0 := by admit /- proof elided -/
    ‚ü©
  wit  := Witness.Lens.id

œÜ in ToMathlib.Control.Monad.Relative

def findFinIdx (p : Œ± ‚Üí Bool) (l : List Œ±) : Fin (l.length + 1) :=
  ‚ü®List.findIdx' p l,
    Nat.lt_succ_of_le (by admit /- proof elided -/
    )‚ü©

def relation : Set (M √ó List (MemoryRead Œπ Œ±)) :=
  { ‚ü®mem, ops‚ü© | ‚àÄ op ‚àà ops, Memory.read mem op.index = op.value }

instance instDCast‚ÇÇ : DCast‚ÇÇ Nat ProtocolSpec (fun _ pSpec => MessageIdx pSpec) where
  dcast‚ÇÇ h := MessageIdx.cast h
  dcast‚ÇÇ_id := cast_id

def start {Œ± : Type} (a : Œ±) : OracleComp (Œ± ‚Üí‚Çí Vector U SpongeSize.C) (DuplexSponge U C) := do
  let capacitySegment : Vector U SpongeSize.C ‚Üê query (spec := Œ± ‚Üí‚Çí Vector U SpongeSize.C) () a
  let vecSponge := (Vector.replicate SpongeSize.R (0 : U)) ++ capacitySegment
  return {
    state := SpongeState.update (Œ± := C) (0 : C) (vecSponge.cast (by admit /- proof elided -/
    )),
    absorbPos := 0,
    squeezePos := Fin.last SpongeSize.R
  }

structure ParamConditions (P : Params Œπ F) where
  m : ‚Ñï 
  h_m : m = P.varCount 0
  h_sumkLt : ‚àë i : Fin (M + 1), P.foldingParam i ‚â§ m
  h_varCount_i : ‚àÄ i : Fin (M + 1),
    P.varCount i = m - ‚àë j : Fin i, P.foldingParam (Fin.castLT j (Nat.lt_trans j.isLt i.isLt))
  h_smooth : ‚àÄ i : Fin (M + 1), Smooth (P.œÜ i)
  h_repeatPLt : ‚àÄ i : Fin (M + 1), P.repeatParam i ‚â§ Fintype.card (Œπ i)

def relayKStateProp (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i)
  (stmtIn : Statement (L := L) Context i.succ)
  (witMid : Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
  (oStmtIn : (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j))
  : Prop :=
  masterKStateProp (mp := mp) (œë := œë) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
    (stmtIdx := i.succ) (oracleIdx := i.succ)
    (h_le := le_refl _)
    (stmt := stmtIn) (wit := witMid) (oStmt := mapOStmtOutRelayStep
      ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hNCR oStmtIn)
    (localChecks := True)

instance : SliceGE (FullTranscript pSpec) ‚Ñï
    (fun _ start => start ‚â§ n)
    (fun _ start _ => FullTranscript (pSpec‚ü¶start:‚üß))
    where
  sliceGE := fun v start h => drop start h v

@[reducible, inline, specialize, simp]
def Challenge' (pSpec : ProtocolSpec n) (i : Fin n) (_ : pSpec.dir i = .V_to_P) := pSpec.¬´Type¬ª i

class NonBinaryField (F : Type*) extends Field F where
  char_neq_2 : (2 : F) ‚â† 0

@[inline] def mul [Zero T] [ToNat T] (a b : Cayley T) : Cayley T :=
  mulNat a ‚Üëb

def powMod (a b m : ‚Ñï) : ‚Ñï := Id.run do
  let mut x := a
  let mut n := b
  let mut res := 1

  while n > 0 do
    if n % 2 == 1 then
      res := (x * res) % m
    x := (x * x) % m
    n := n / 2

  return res

@[reducible, inline, specialize]
def Messages' (pSpec : ProtocolSpec n) : Type :=
  ‚àÄ i, (hi : pSpec.dir i = .P_to_V) ‚Üí pSpec.¬´Type¬ª i

def generator : BaseField √ó BaseField := (1, 2)

Matrix.neg in Mathlib.LinearAlgebra.Matrix.Defs

def rootMultiplicity‚ÇÄ.{u} {F : Type u} [Semiring F] [DecidableEq F] (f : F[X][Y]) : Option ‚Ñï :=
  let deg := weightedDegree f 1 1
  match deg with
  | none => none
  | some deg => List.max?
    (List.map
      (fun x => if coeff f x.1 x.2 ‚â† 0 then x.1 + x.2 else 0)
      (List.product (List.range deg.succ) (List.range deg.succ)))

@[reducible]
def scalarFieldSize : Nat :=
  8444461749428370424248824938781546531375899335154063827935233455917409239041

@[reducible]
def CanonicalDuplexSponge (U : Type) [SpongeUnit U] [SpongeSize] :=
  DuplexSponge U (CanonicalSpongeState U)

instance {i : Fin ‚Ñì} :
    ‚àÄ j, OracleInterface ((pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i).Message j)
  | ‚ü®0, _‚ü© => by admit /- proof elided -/

instance instDCast : DCast Nat ProtocolSpec where
  dcast h := ProtocolSpec.cast h
  dcast_id := cast_id

private def k [Zero F] (B : Finset (Fin n ‚Üí F)) : ‚Ñö :=
  (1 : ‚Ñö) / n * ‚àë i, K B i 0

instance : Slice (ProtocolSpec n) ‚Ñï ‚Ñï
    (fun _ start stop => start ‚â§ stop ‚àß stop ‚â§ n)
    (fun _ start stop _ => ProtocolSpec (stop - start))
    where
  slice := fun v start stop h => extract start stop h.1 h.2 v

MvPolynomial.optionEquivLeft in Mathlib.Algebra.MvPolynomial.Equiv

def Œ± (x‚ÇÄ : F) (R : F[X][X][Y]) (H : F[X][Y]) [œÜ : Fact (Irreducible H)] (t : ‚Ñï) : ùïÉ H :=
  let W : ùïÉ H := liftToFunctionField (H.leadingCoeff)
  embeddingOfùí™IntoùïÉ _ (Œ≤ R t) / (W ^ (t + 1) * (embeddingOfùí™IntoùïÉ _ (Œæ x‚ÇÄ R H)) ^ (2*t - 1))

instance {Œπ : Type u} (v : Œπ ‚Üí Type v) [O : ‚àÄ i, OracleInterface (v i)]
    [h : ‚àÄ i, DecidableEq (Query (v i))]
    [h' : ‚àÄ i, DecidableEq (Response (v i))] :
    [v]‚Çí.DecidableEq where
  domain_decidableEq' := h
  range_decidableEq' := h'

instance {Œ± : Fin 0 ‚Üí Sort u} : Unique ((i : Fin 0) ‚Üí Œ± i) where
  default := fun i => elim0 i
  uniq v := by admit /- proof elided -/

abbrev Field := ZMod fieldSize

def projection (S : Finset n) (w : n ‚Üí R) : S ‚Üí R :=
  fun i => w i.val

@[reducible, simp] def StmtAfterSendClaim : Type := R

instance : SMul R (UniPoly R) := ‚ü®UniPoly.smul‚ü©

Or in Init.Prelude

@[ext]
class OracleInterface (Message : Type u) where
  Query : Type v
  Response : Type w
  answer : Message ‚Üí Query ‚Üí Response

orderOf in Mathlib.GroupTheory.OrderOfElement

@[simp]
def transpose {m n : ‚Ñï} (matrix : Matrix Œ± m n) : Matrix Œ± n m :=
  ofFn (fun j => ofFn (fun i => (matrix.get i).get j))

noncomputable def basisVectors (‚Ñì : Nat) (h_‚Ñì : ‚Ñì ‚â§ r) :
  Fin (2 ^ ‚Ñì) ‚Üí L‚¶É<2^‚Ñì‚¶Ñ[X] :=
  fun j => ‚ü®X‚±º ùîΩq Œ≤ ‚Ñì h_‚Ñì j, by admit /- proof elided -/
  ‚ü©

def LawfulInterleavedCode (Œ∫ : Type*) [Fintype Œ∫] (Œπ : Type*) [Fintype Œπ]
                          (F : Type*) [Semiring F] :=
  { IC : InterleavedCode Œ∫ Œπ F // IC.isInterleaved }

zsmulRec in Mathlib.Algebra.Group.Defs

Nat in Init.Prelude

Sum in Init.Core

def NestedList (n : ‚Ñï) : Type := dfoldr' n (fun _ => Type) (fun _ T => List T) Nat

example : NestedList 0 = Nat := rfl
example (n : ‚Ñï) : NestedList (n + 1) = List (NestedList n) := rfl

@[reducible, simp]
def knowledgeSoundness
    (relation : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (verifier : OracleVerifier oSpec Statement OStatement Bool (fun _ : Empty => Unit) pSpec)
    (knowledgeError : ‚Ñù‚â•0) : Prop :=
  verifier.toVerifier.knowledgeSoundness init impl relation acceptRejectOracleRel knowledgeError

@[inline] def pred [Zero T] [ToNat T] (a : Cayley T) : Cayley T :=
  match (‚Üëa : Nat) with
  | 0 => zero
  | Nat.succ n => ofNat n

instance : Unique (ProtocolSpec 0) where
  default := empty
  uniq := fun ‚ü®_, _‚ü© => by admit /- proof elided -/

instance : Add (Cayley T) where
  add := add

@[inline, specialize]
def Prover.runToRoundFS [‚àÄ i, VCVCompatible (pSpec.Challenge i)] (i : Fin (n + 1))
    (stmt : StmtIn) (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec)
    (state : prover.PrvState 0) :
        OracleComp (oSpec ++‚Çí fsChallengeOracle StmtIn pSpec)
          (pSpec.MessagesUpTo i √ó StmtIn √ó prover.PrvState i) :=
  Fin.induction
    (pure ‚ü®default, stmt, state‚ü©)
    prover.processRoundFS
    i

Polynomial.map in Mathlib.Algebra.Polynomial.Eval.Defs

def JohnsonDenominator (B : Finset (Fin n ‚Üí F)) (v : Fin n ‚Üí F) : ‚Ñö :=
  let e := e B v
  let d := d B
  let q : ‚Ñö := Fintype.card F
  let frac := q / (q - 1)
  (1- frac * e/n) ^ 2 - (1 - frac * d/n)

instance : ‚àÄ j, SelectableType ((pSpecFoldRelay (L:=L)).Challenge j) :=
  instSelectableTypeChallengeAppend

Subtype in Init.Prelude

instance {Œ± : Type u} [ToNat Œ±] : CoeHead Œ± Nat where
  coe := ToNat.toNat

PMF.uniformOfFintype in Mathlib.Probability.Distributions.Uniform

Finsupp.equivFunOnFinite in Mathlib.Data.Finsupp.Defs

def SumFunEquivProd (Œ± Œ≤ Œ≥ : Type) : ((Œ± ‚äï Œ≤) ‚Üí Œ≥) ‚âÉ (Œ± ‚Üí Œ≥) √ó (Œ≤ ‚Üí Œ≥) :=
{ toFun := fun f => (fun a => f (.inl a), fun b => f (.inr b))
  , invFun := fun p x => match x with | .inl a => p.fst a | .inr b => p.snd b
  , left_inv := by admit /- proof elided -/

noncomputable def fixFirstVariablesOfMQP (v : Fin (‚Ñì + 1))
  (H : MvPolynomial (Fin ‚Ñì) L) (challenges : Fin v ‚Üí L) : MvPolynomial (Fin (‚Ñì - v)) L :=
  have h_l_eq : ‚Ñì = (‚Ñì - v) + v := by rw [Nat.add_comm]; exact (Nat.add_sub_of_le v.is_le).symm
  -- Step 1 : Rename L[X Fin ‚Ñì] to L[X (Fin (‚Ñì - v) ‚äï Fin v)]
  let finEquiv := finSumFinEquiv (m := ‚Ñì - v) (n := v).symm
  let H_sum : L[X (Fin (‚Ñì - v) ‚äï Fin v)] :=

IsField in Mathlib.Algebra.Field.IsField

@[reducible]
def Witness := Fin sz.n_w ‚Üí R

instance {s} : Functor (fun Œ± => LeafData Œ± s) where
  map f x := x.map f

abbrev Bwd : PermuteDir := Sum.inr ()

def linearMvExtension :
  Polynomial.degreeLT F (2^m) ‚Üí‚Çó[F] MvPolynomial (Fin m) F where
    
    toFun p := (p : Polynomial F).sum fun i a =>
      MvPolynomial.monomial (bitExpo i) a
    map_add' := by admit /- proof elided -/

Dist in Mathlib.Topology.MetricSpace.Pseudo.Defs

def Function.extendDomain {Œ± Œ≤ : Type*} [DecidableEq Œ±] [Zero Œ≤] {s : Finset Œ±}
    (f : (x : Œ±) ‚Üí (x ‚àà s) ‚Üí Œ≤) : Œ± ‚Üí Œ≤ :=
  fun x ‚Ü¶ if hx : x ‚àà s then f x hx else 0

instance : Fact (Nat.Prime baseFieldSize) := ‚ü®BaseField_is_prime‚ü©

Array in Init.Prelude

AddSubmonoidClass in Mathlib.Algebra.Group.Submonoid.Defs

def totalNumPermQueriesMessage : Nat :=
  ‚àë i, pSpec.L‚Çö·µ¢ i

def OracleVerifier.addSalt (V : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec) :
    OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut (pSpec.addSalt Salt) where
  verify := fun stmtIn challenges => sorry
  
  
  embed := sorry
  hEq := sorry

def SkeletonNodeIndex.depth {s : Skeleton} : SkeletonNodeIndex s ‚Üí Nat
  | SkeletonNodeIndex.ofLeaf => 0
  | SkeletonNodeIndex.ofInternal => 0
  | SkeletonNodeIndex.ofLeft idxLeft => idxLeft.depth + 1
  | SkeletonNodeIndex.ofRight idxRight => idxRight.depth + 1

private noncomputable def interpolate : (Œπ ‚Üí F) ‚Üí‚Çó[F] F[X] :=
  Lagrange.interpolate univ domain

Nontrivial in Mathlib.Logic.Nontrivial.Defs

instance instSelectableTypeChallengePSpec [SelectableType R] :
    ‚àÄ i, SelectableType ((pSpec R deg).Challenge i) :=
  instSelectableTypeChallengeAppend

@[reducible, simp] def OStmtOut := fun _ : Fin 2 => OStatement

abbrev SEP_CHAR : Char := Char.ofNat 0

def externalLinearLayer (state : Vector KoalaBear.Field params.width) :
    Vector KoalaBear.Field params.width :=
  
  let chunks := Vector.Matrix.ofFlatten (state.cast (params.widthDiv4_mul_4_eq_width).symm)
  let chunksAfterM4 := chunks.map (fun chunk => applyM4 chunk)

  
  

  
  let transposedMatrix := Vector.Matrix.transpose chunksAfterM4

  
  let columnSums := transposedMatrix.map (fun col => col.foldl (¬∑ + ¬∑) 0)

  
  let chunksAfterDiffusion := chunksAfterM4.map (fun row => row.zipWith (¬∑ + ¬∑) columnSums)

  
  (Vector.flatten chunksAfterDiffusion).cast (params.widthDiv4_mul_4_eq_width)

instance {Œ± : Type*} {n : ‚Ñï} [VCVCompatible Œ±] : VCVCompatible (Vector Œ± n) where

@[reducible, simp] def OStmtIn := fun _ : Fin 2 => OStatement

Nat.reduceAdd in Lean.Meta.Tactic.Simp.BuiltinSimprocs.Nat

def deterministicMillerRabin (n : ‚Ñï) : Bool := Id.run do
  if n ‚â§ 2 ‚à® n % 2 = 0 then
    return n = 2

  let ‚ü®s, d‚ü© := factorOutTwos (n - 1)
  for a in millerRabinBases do
    if a % n == 0 then
      continue

    let mut x := powMod a d n
    if x = 1 ‚à® x = n - 1 then
      continue

    for _ in [0:s] do
      x := (x * x) % n
      if x == n - 1 ‚à® x ‚â§ 1 then
        break
    if x ‚â† n - 1 then
      return false

  return true

def discr_y {F : Type} [CommRing F] (f : F[X][Y]) : F[X] :=
   
  Classical.choose (resultant_is_divisible_by_leadingCoeff f)

Finset.fold in Mathlib.Data.Finset.Fold

def acceptRejectOracleRel : Set ((Bool √ó (‚àÄ _ : Empty, Unit)) √ó Unit) :=
  { ((true, isEmptyElim), ()) }

protected def OracleReduction.id :
    OracleReduction oSpec Statement OStatement Witness Statement OStatement Witness !p[] :=
  ‚ü®OracleProver.id, OracleVerifier.id‚ü©

alias Prover.trivial := Prover.id
alias Verifier.trivial := Verifier.id
alias Reduction.trivial := Reduction.id
alias OracleProver.trivial := OracleProver.id
alias OracleVerifier.trivial := OracleVerifier.id
alias OracleReduction.trivial := OracleReduction.id

def toCoeffsVec (‚Ñì : Nat) : L‚¶É<2^‚Ñì‚¶Ñ[X] ‚Üí‚Çó[L] CoeffVecSpace L ‚Ñì where
  toFun := fun p => fun i => p.val.coeff i.val
  map_add' := fun p q => by admit /- proof elided -/

noncomputable def liftToFunctionField {H : F[X][Y]} : F[X] ‚Üí+* ùïÉ H :=
  RingHom.comp (Ideal.Quotient.mk (Ideal.span {H_tilde H})) coeffAsRatFunc

ringChar.charP in Mathlib.Algebra.CharP.Defs

instance : Fact (Nat.Prime scalarFieldSize) := ‚ü®ScalarField_is_prime‚ü©

def SkeletonNodeIndex.isLeaf {s : Skeleton} (idx : SkeletonNodeIndex s) : Bool :=
  match idx with
  | SkeletonNodeIndex.ofLeaf => true
  | SkeletonNodeIndex.ofInternal => false
  | SkeletonNodeIndex.ofLeft _ => false
  | SkeletonNodeIndex.ofRight _ => false

noncomputable def batchVerifier :
  OracleVerifier []‚Çí
    Unit (OracleStatement D x m)
    ((Fin m ‚Üí F) √ó Fri.Spec.Statement F (0 : Fin (k + 1)))
    (OracleStatement D x m)
    (batchSpec F m) where
  verify := fun _ chals => pure ‚ü®chals ‚ü®0, by admit /- proof elided -/
  ‚ü©, Fin.elim0‚ü©
  embed :=
    ‚ü®
      fun i => Sum.inl i,
      by admit /- proof elided -/
    ‚ü©
  hEq := by admit /- proof elided -/

@[reducible]
def fieldSize : Nat := 2 ^ 31 - 1

@[reducible]
def CanonicalSpongeState (U : Type) [SpongeUnit U] [SpongeSize] : Type :=
  Vector U SpongeSize.N

def coreInteractionOracleRbrKnowledgeError (j : (pSpecCoreInteraction ùîΩq Œ≤ (œë := œë)
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).ChallengeIdx) : ‚Ñù‚â•0 :=
    Sum.elim
      (f := fun i => sumcheckFoldKnowledgeError ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)
      (g := fun i => finalSumcheckKnowledgeError (L := L) i)
      (ChallengeIdx.sumEquiv.symm j)

def rho' (n : ‚Ñï) (start : ‚Ñï) (c : ‚Ñï) : Option ‚Ñï := Id.run do
  if n % 2 = 0 then
    return some 2

  let mut x := start
  let mut y := x
  let mut d := 1

  while d = 1 do
    x := g n c x
    y := g n c (g n c y)
    d := Nat.gcd (Int.natAbs (x - y)) n

  if d = n then
    return none
  else
    return some d

List.mergeSort in Init.Data.List.Sort.Basic

CommGroup in Mathlib.Algebra.Group.Defs

HMul in Init.Prelude

@[inline, specialize]
def OracleVerifier.run [O‚Çò : ‚àÄ i, OracleInterface (pSpec.Message i)]
    (stmt : StmtIn) (oStmtIn : ‚àÄ i, OStmtIn i) (transcript : FullTranscript pSpec)
    (verifier : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec) :
      OracleComp oSpec (StmtOut √ó (‚àÄ i, OStmtOut i)) := do
  let f := OracleInterface.simOracle2 oSpec oStmtIn transcript.messages
  let stmtOut ‚Üê simulateQ f (verifier.verify stmt transcript.challenges)
  let oStmtOut : ‚àÄ i, OStmtOut i := fun i => match h : verifier.embed i with
  | .inl j => by admit /- proof elided -/
  | .inr j => by admit /- proof elided -/

Zero in Init.Prelude

class MvPolynomialLike (œÉ : outParam (Type u)) (R : outParam (Type v)) [CommSemiring R]
    (P : Type w) [CommSemiring P] extends Algebra R P where
   
  X : œÉ ‚Üí P

   
  eval‚ÇÇ {S : Type y} [CommSemiring S] {F : Type z} [FunEquiv F œÉ S] (f : R ‚Üí+* S) (g : F) : P ‚Üí+* S

   
  eval‚ÇÇ_C {S : Type y} [CommSemiring S] {F : Type z} [FunEquiv F œÉ S]
    (f : R ‚Üí+* S) (g : F) (r : R) : (eval‚ÇÇ f g) (_root_.algebraMap R P r) = f r

   
  eval‚ÇÇ_X {S : Type y} [CommSemiring S] {F : Type z} [FunEquiv F œÉ S]
    (f : R ‚Üí+* S) (g : F) (s : œÉ) : (eval‚ÇÇ f g) (X s) = g s

   
  eval‚ÇÇ_eq {S : Type y} [CommSemiring S] {F : Type z} [FunEquiv F œÉ S] (h : P ‚Üí+* S) :
    h = eval‚ÇÇ (h.comp (Algebra.ofId R P)) (fun s => h (X s) : F)

Vector.head in Init.Data.Vector.Basic

instance instDCast‚ÇÇSigma {Œ± : Type*} {Œ≤ : Œ± ‚Üí Type*} {Œ≥ : (a : Œ±) ‚Üí Œ≤ a ‚Üí Type*}
    {Œ¥ : (a : Œ±) ‚Üí (b : Œ≤ a) ‚Üí Œ≥ a b ‚Üí Type*}
    [DCast Œ± Œ≤] [DCast‚ÇÇ Œ± Œ≤ Œ≥] [DCast‚ÇÉ Œ± Œ≤ Œ≥ Œ¥] :
    DCast‚ÇÇ ((a : Œ±) √ó Œ≤ a) (fun a => Œ≥ a.1 a.2) (fun a => Œ¥ a.1 a.2) where
  dcast‚ÇÇ ha hb c := dcast‚ÇÉ (by admit /- proof elided -/
  ) (by admit /- proof elided -/
  ) (by admit /- proof elided -/
  ) c
  dcast‚ÇÇ_id := by admit /- proof elided -/

def Z (k : ‚Ñï) : ConcreteBTField k :=
  if h_k : k = 0 then one
  else
    „Ää one (k:=k-1), zero (k:=k-1) „Äã

def powAlgHom :
  MvPolynomial (Fin m) F ‚Üí‚Çê[F] Polynomial F :=
   aeval fun j => Polynomial.X ^ (2 ^ (j : ‚Ñï))

noncomputable instance {s : Set (Œπ ‚Üí F)} : Fintype (affineSpan F s) :=
  Fintype.ofFinite ‚Ü•(affineSpan F s)

def dist' (C : Set (n ‚Üí R)) [Fintype C] : ‚Ñï‚àû :=
  Finset.min <| ((@Finset.univ (C √ó C) _).filter (fun p => p.1 ‚â† p.2)).image
    (fun ‚ü®u, v‚ü© => hammingDist u.1 v.1)

@[reducible, simp]
def pSpec : ProtocolSpec 1 := ‚ü®!v[.P_to_V], !v[Witness]‚ü©

def outputRelation : Set ((StmtOut R √ó (‚àÄ i, OStmtOut R deg i)) √ó Unit) :=
  { ‚ü®‚ü®‚ü®newTarget, chal‚ü©, oStmt‚ü©, _‚ü© | (oStmt ()).1.eval chal = newTarget }

noncomputable def towerRingHomBackwardMap (k : ‚Ñï) : BTField k ‚Üí ConcreteBTField k :=

@[simp]
abbrev OracleStatement.AfterFirstMessage : R1CS.MatrixIdx ‚äï Fin 1 ‚Üí Type :=
  Sum.rec (OracleStatement R pp) (fun _ => Witness R pp)

@[ext]
structure OracleVerifier {Œπ : Type} (oSpec : OracleSpec Œπ)
    (StmtIn : Type) {Œπ‚Çõ·µ¢ : Type} (OStmtIn : Œπ‚Çõ·µ¢ ‚Üí Type)
    (StmtOut : Type) {Œπ‚Çõ‚Çí : Type} (OStmtOut : Œπ‚Çõ‚Çí ‚Üí Type)
    {n : ‚Ñï} (pSpec : ProtocolSpec n)
    [O‚Çõ·µ¢ : ‚àÄ i, OracleInterface (OStmtIn i)]
    [O‚Çò : ‚àÄ i, OracleInterface (pSpec.Message i)]
    where
    
    

   
  verify : StmtIn ‚Üí pSpec.Challenges ‚Üí
    OracleComp (oSpec ++‚Çí ([OStmtIn]‚Çí ++‚Çí [pSpec.Message]‚Çí)) StmtOut

  
  
  

  

   
  embed : Œπ‚Çõ‚Çí ‚Ü™ Œπ‚Çõ·µ¢ ‚äï pSpec.MessageIdx

   
  hEq : ‚àÄ i, OStmtOut i = match embed i with
    | Sum.inl j => OStmtIn j
    | Sum.inr j => pSpec.Message j

Units in Mathlib.Algebra.Group.Units.Defs

Module.Basis.span in Mathlib.LinearAlgebra.Basis.Basic

@[simp]
def finRangeTo {k : ‚Ñï} (i : ‚Ñï) : Finset (Fin k) :=
  (List.take i (List.finRange k)).toFinset

class Memory (Œπ : Type u) (Œ± : Œπ ‚Üí Type v) (M : Type w) where
   
  read (m : M) (i : Œπ) : Œ± i
   
  write (m : M) (i : Œπ) (v : Œ± i) : M

noncomputable def R
  (Œ¥ : ‚Ñö) (x‚ÇÄ : F)
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  : F[Z][X][Y] := (exists_factors_with_large_common_root_set k Œ¥ x‚ÇÄ h_gs).choose

noncomputable def twiddleFactor (i : Fin ‚Ñì) (u : Fin (2 ^ (‚Ñì + R_rate - i - 1))) : L :=
  ‚àë (‚ü®k, hk‚ü©: Fin (‚Ñì + R_rate - i - 1)),
    if Nat.getBit k u.val = 1 then
      
        
      (normalizedW ùîΩq Œ≤ ‚ü®i, by admit /- proof elided -/
      ‚ü©).eval (Œ≤ ‚ü®i + 1 + k, by admit /- proof elided -/
      ‚ü©)
    else 0

def FullData.EquivIndexFun {Œ± : Type} (s : Skeleton) :
    FullData Œ± s ‚âÉ (SkeletonNodeIndex s ‚Üí Œ±) where
  toFun := fun tree idx => tree.get idx
  invFun := fun f => FullData.ofFun s f
  left_inv := by admit /- proof elided -/

PowerBasis in Mathlib.RingTheory.PowerBasis

def Option.doubleBind_v2 {Œ± Œ≤ Œ≥ : Type} (f : Œ± ‚Üí Œ≤ ‚Üí Option Œ≥)
    (x : Option Œ±) (y : Option Œ≤) : Option Œ≥ := do
  let a ‚Üê x
  let b ‚Üê y
  f a b

def lintStyleCli (args : Cli.Parsed) : IO UInt32 := do
  let style : ErrorFormat := match args.hasFlag "github" with
    | true => ErrorFormat.github
    | false => ErrorFormat.humanReadable
  let fix := args.hasFlag "fix"
  
  let mut allModuleNames := #[]
  for s in ["ArkLib.lean"] do
    allModuleNames := allModuleNames.append (‚Üê findImports s)
  
  allModuleNames := allModuleNames.erase `Batteries
  let mut numberErrors ‚Üê lintModules allModuleNames style fix
  if ‚Üê checkInitImports then numberErrors := numberErrors + 1
  
  
  
  
  if args.hasFlag "fix" then
    return 0
  else return min numberErrors 125

def mkFieldInstance {k : ‚Ñï} (props : ConcreteBTFieldProps k) : Field (ConcreteBTField k) where
  toDivisionRing := mkDivisionRingInstance (k:=k) props
  mul_comm := props.mul_comm

def divSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (k : Fin (‚àë j, n j)) : Fin m :=
  (divSum? n k).get (divSum?_is_some_iff_lt_sum.mpr k.isLt)

def churchCons (x : Œ±) (xs : ChurchVec Œ±) : ChurchVec Œ± :=
  fun f base => f x (xs f base)

def FullTranscript.extractSalt (transcript : (pSpec.addSalt Salt).FullTranscript) :
    (i : pSpec.MessageIdx) ‚Üí Salt i :=
  Transcript.extractSalt (pSpec := pSpec) (k := Fin.last n) transcript

def modByMonic [Field R] (p : UniPoly R) (q : UniPoly R) :
    UniPoly R :=
  (divModByMonicAux p q).2

def sBasis (i : Fin r) (h_i : i < ‚Ñì + R_rate) : Fin (‚Ñì + R_rate - i) ‚Üí L :=
  fun k => Œ≤ ‚ü®i + k.val, by admit /- proof elided -/
  ‚ü©

noncomputable def ElocPolyF (œâs f : Fin n ‚Üí F) (p : Polynomial F) : Polynomial F :=
  ElocPoly n (liftF œâs) (liftF f) p

def ar2 (k0 k1 : ‚Ñï) : Fin 2 ‚Üí ‚Ñï
  | ‚ü®0, _‚ü© => k0
  | ‚ü®1, _‚ü© => k1

def towerOfExponents (g : G) (a : ZMod p) (n : ‚Ñï) : Vector G (n + 1) :=
  .ofFn (fun i => g ^ (a.val ^ i.val))

def getFirstOracle {i : Fin (‚Ñì + 1)}
    (oStmt : (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i j)) :
    sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate 0 ‚Üí L :=

def natCast_succ {k : ‚Ñï} (n : ‚Ñï) : natCast (k:=k) (n + 1) = natCast (k:=k) n + 1 :=

noncomputable instance : DecidableEq (GF(2)) :=
  fun x y =>
    
    let œÜ : GF(2) ‚âÉ‚Çê[ZMod 2] ZMod 2 := GaloisField.equivZmodP 2
    
    if h : œÜ x = œÜ y then
      isTrue (by admit /- proof elided -/
        )
    else
      isFalse (by admit /- proof elided -/
        )

instance instCharP2 {k : ‚Ñï} : CharP (ConcreteBTField k) 2 :=
  charP_eq_2_of_add_self_eq_zero (F:=(ConcreteBTField k)) (sumZeroIffEq:=add_eq_zero_iff_eq)

DivisionRing in Mathlib.Algebra.Field.Defs

IsEmpty in Mathlib.Logic.IsEmpty

Finset.sup in Mathlib.Data.Finset.Lattice.Fold

def InternalData.EquivIndexFun {Œ± : Type} (s : Skeleton) :
    InternalData Œ± s ‚âÉ (SkeletonInternalIndex s ‚Üí Œ±) where
  toFun := fun tree idx => tree.get idx
  invFun := fun f => InternalData.ofFun s f
  left_inv := by admit /- proof elided -/

noncomputable def rate [Semiring F] (LC : LinearCode Œπ F) : ‚Ñö‚â•0 :=
  (dim LC : ‚Ñö‚â•0) / length LC

noncomputable instance changeOfBasisMatrix_invertible
  (‚Ñì : Nat) (h_‚Ñì : ‚Ñì ‚â§ r) :
  Invertible (changeOfBasisMatrix ùîΩq Œ≤ ‚Ñì h_‚Ñì) :=

def implGroupOpOracle : QueryImpl (GroupOpOracle Œπ) (StateT (GroupValTable Œπ G) Option) where
  impl | query _ ‚ü®i, j, k‚ü© => fun table =>
    match table i, table j with
    | some g‚ÇÅ, some g‚ÇÇ => some ((), table.update k (some (g‚ÇÅ * g‚ÇÇ)))
    | _, _ => none

@[reducible]
def foldCommitOracleVerifier (i : Fin ‚Ñì) (hCR : isCommitmentRound ‚Ñì œë i) :
  OracleVerifier []‚Çí
    (StmtIn := Statement (L := L) Context i.castSucc)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.succ)
    (pSpec := pSpecFoldCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) :=
    OracleVerifier.append (oSpec:=[]‚Çí)
      (pSpec‚ÇÅ := pSpecFold (L:=L))
      (pSpec‚ÇÇ := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)
      (V‚ÇÅ := foldOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)
      (V‚ÇÇ := commitOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hCR)

def redundantEntryDS (log : QueryLog (duplexSpongeChallengeOracle StmtIn U))
    (idx : Fin log.length) : Prop :=
  match log[idx] with
   
  | ‚ü®.inl _, ‚ü®stmt, state‚ü©‚ü© => ‚àÉ j' < idx, log[j'] = ‚ü®.inl _, ‚ü®stmt, state‚ü©‚ü©
   
  | ‚ü®.inr .Fwd, stateIn, stateOut‚ü© =>
    ‚àÉ j' < idx, log[j'] = ‚ü®.inr .Fwd, stateIn, stateOut‚ü© ‚à® log[j'] = ‚ü®.inr .Bwd, stateOut, stateIn‚ü©
  | ‚ü®.inr .Bwd, stateOut, stateIn‚ü© =>
    ‚àÉ j' < idx, log[j'] = ‚ü®.inr .Bwd, stateOut, stateIn‚ü© ‚à® log[j'] = ‚ü®.inr .Fwd, stateIn, stateOut‚ü©

def Equiv.precomp {Œ± Œ≤ Œ≥} (e : Œ± ‚âÉ Œ≤) : (Œ≤ ‚Üí Œ≥) ‚âÉ (Œ± ‚Üí Œ≥) :=
{ toFun := fun f a => f (e a)
  , invFun := fun g b => g (e.invFun b)
  , left_inv := by admit /- proof elided -/

@[inline]
def ofOutputOnly
    (liftStmt : OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i) ‚Üí InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i) ‚Üí
                OuterStmtOut √ó (‚àÄ i, OuterOStmtOut i)) :
    OracleStatement.Lens OuterStmtIn OuterStmtOut OuterStmtIn InnerStmtOut
                        OuterOStmtIn OuterOStmtOut OuterOStmtIn InnerOStmtOut :=
  ‚ü®id, liftStmt‚ü©

@[inline, reducible]
def proj : OuterStmtIn √ó OuterWitIn ‚Üí InnerWitIn :=
  lens.toFunA

Module.Basis in Mathlib.LinearAlgebra.Basis.Defs

instance (k : ‚Ñï) : NeZero (2^k) :=

@[reducible]
def MemoryWrite (Œπ : Type u) (Œ± : Œπ ‚Üí Type v) := (index : Œπ) √ó (Œ± index)

def monomialY (n : ‚Ñï) : F[X] ‚Üí‚Çó[F[X]] F[X][Y] where
  toFun t := ‚ü®Finsupp.single n t‚ü©
  map_add' x y := by admit /- proof elided -/

instance instSetoidUniPoly : Setoid (UniPoly R) where
  r := equiv
  iseqv := instEquivalenceEquiv

@[inline]
def smul [Mul R] (r : R) (p : MlPolyEval R n) : MlPolyEval R n := p.map (fun a => r * a)

noncomputable def fold_k_core {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F} (f : (indexPowT S œÜ 0) ‚Üí F)
  [‚àÄ i : ‚Ñï, Neg (indexPowT S œÜ i)] : (i : ‚Ñï) ‚Üí (Œ±s : Fin i ‚Üí F) ‚Üí
    indexPowT S œÜ i ‚Üí F
| 0, _ => fun x‚ÇÄ => f x‚ÇÄ
| k+1, Œ±s => fun y =>
    let Œ± := Œ±s 0
    let Œ±s' : Fin k ‚Üí F := fun i => Œ±s (Fin.succ i)
    let fk := fold_k_core f k Œ±s'
    foldf S œÜ y fk Œ±

CommRing.toRing in Mathlib.Algebra.Ring.Defs

private def Fi (B : Finset (Fin n ‚Üí F)) (i : Fin n) (Œ± : F) : Finset (Fin n ‚Üí F) :=
  { x | x ‚àà B ‚àß x i = Œ± }

@[reducible]
def VectorIOP
    (Statement : Type) {Œπ‚Çõ : Type} (OStatement : Œπ‚Çõ ‚Üí Type) (Witness : Type)
    (vPSpec : ProtocolSpec.VectorSpec n) (A : Type)
    [‚àÄ i, OracleInterface (OStatement i)] :=
  OracleProof []‚Çí Statement OStatement Witness (vPSpec.toProtocolSpec A)

@[inline, specialize]
def add (p q : UniPoly R) : UniPoly R :=
  add_raw p q |> trim

def InnerStmtIn_Test := ‚Ñ§[X] √ó ‚Ñ§

Nat.Prime in Mathlib.Data.Nat.Prime.Defs

Ideal in Mathlib.RingTheory.Ideal.Defs

noncomputable def towerRingEquiv0 : BTField 0 ‚âÉ+* ConcreteBTField 0 :=

def evalSetY [DecidableEq F] (f : F[X][Y]) (P : Finset F) [Nonempty P] : Finset (Polynomial F) :=
  P.image (fun a => evalY a f)

def matrixSubmoduleOfLinearCode (Œ∫ : Type*) [Fintype Œ∫]
                                (LC : LinearCode Œπ F) : MatrixSubmodule Œ∫ Œπ F :=
  Submodule.span F { V | ‚àÄ i, V i ‚àà LC }

cond in Init.Prelude

right_inv in ToMathlib.Control.Monad.Equiv

ringChar in Mathlib.Algebra.CharP.Defs

@[reducible]
def SimOracle.Stateless (spec : OracleSpec Œπ) (spec‚Çú : OracleSpec Œπ‚Çú) :=
  QueryImpl spec (OracleComp spec‚Çú)

@[elab_as_elim]
def dflatten {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {motive : (k : Fin (vsum n)) ‚Üí Sort*}
    (v : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí motive (embedSum i j)) (k : Fin (vsum n)) : motive k :=
  match m with
  | 0 => Fin.elim0 k
  | _ + 1 =>
    dappend
      (fun j => v 0 j)
      (fun j => dflatten (motive := fun j => motive (natAdd _ j)) (fun i => v i.succ) j)
      k

def eval‚ÇÇAlgHom {A B : Type*} [CommSemiring A] [CommSemiring B] [MvPolynomialLike œÉ A P]
    [Algebra R A] [IsScalarTower R A P] [Algebra R B]
    (f : A ‚Üí‚Çê[R] B) (g : œÉ ‚Üí B) : P ‚Üí‚Çê[R] B where
  toRingHom := eval‚ÇÇ f g
  commutes' r := by admit /- proof elided -/

def badEventExistsProp
    (stmtIdx : Fin (‚Ñì + 1)) (oracleIdx : Fin (‚Ñì + 1))
    (oStmt : ‚àÄ j, (OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (i := oracleIdx) j))
    (challenges : Fin stmtIdx ‚Üí L) : Prop :=
  ‚àÉ j, foldingBadEventAtBlock ùîΩq Œ≤ (stmtIdx := stmtIdx) (oracleIdx := oracleIdx)
    (oStmt := oStmt) (challenges := challenges) j

noncomputable def minBlockRelDistance
  (i k : ‚Ñï) {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F}
  [DecidableEq F] [DecidableEq Œπ] [Smooth œÜ]
  (f : (indexPowT S œÜ i) ‚Üí F) (S' : Finset (indexPowT S œÜ i))
  (œÜ' : (indexPowT S œÜ i) ‚Ü™ F) (Set : Set ((indexPowT S œÜ i) ‚Üí F))
  [‚àÄ i : ‚Ñï, Fintype (indexPowT S œÜ i)]
  [h : DecidableBlockDisagreement i k f S' œÜ'] : ‚Ñù‚â•0 :=
    sInf { d : ‚Ñù‚â•0 | ‚àÉ g ‚àà Set, Œî·µ£(i, k, f, S', œÜ', g) = d}

@[inline]
def nsmul [SMul ‚Ñï R] (m : ‚Ñï) (p : MlPolyEval R n) : MlPolyEval R n := p.map (fun a => m ‚Ä¢ a)

instance [VCVCompatible A] : ‚àÄ i, VCVCompatible ((vPSpec.toProtocolSpec A).Challenge i) :=
  fun _ => by admit /- proof elided -/

structure TraceMapProperty (F : Type*) [Field F] (u : F) (k : ‚Ñï) : Prop where
  element_trace : ‚àë i ‚àà Finset.range (2 ^ k), u ^ (2 ^ i) = 1
  inverse_trace : ‚àë i ‚àà Finset.range (2 ^ k), (u‚Åª¬π) ^ (2 ^ i) = 1

ByteArray.mk in Init.Prelude

@[reducible, simp]
def completeness
    (relation : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (oracleProof : OracleProof oSpec Statement OStatement Witness pSpec)
    (completenessError : ‚Ñù‚â•0) : Prop :=
  OracleReduction.completeness init impl
    relation acceptRejectOracleRel oracleProof completenessError

def MlPoly.mk {R : Type*} (n : ‚Ñï) (v : Vector R (2 ^ n)) : MlPoly R n := v

def domainEnum (i : Fin (n + 1)) : Fin (2 ^ (n - i)) ‚Ü™ evalDomain D i :=
  ‚ü®domain D n i.1, domain_injective D i.1 (by admit /- proof elided -/
  )‚ü©

def multiConstrainedCode
  (domain : Œπ ‚Ü™ F) [Smooth domain] (m t : ‚Ñï)
  (w : Fin t ‚Üí MvPolynomial (Fin (m + 1)) F)
  (œÉ : Fin t ‚Üí F) : Set (Œπ ‚Üí F) :=
    { f |
      ‚àÉ (h : f ‚àà smoothCode domain m),
        ‚àÄ i : Fin t, weightConstraint (mVdecode (‚ü®f, h‚ü© : smoothCode domain m)) (w i) (œÉ i)}

instance {k : Fin 1} : Unique (MessagesUpTo k (default : ProtocolSpec 0)) where
  default := fun i => ()
  uniq := by admit /- proof elided -/

@[inline]
def ofArray [Zero R] (coeffs : Array R) (n : ‚Ñï) : MlPolyEval R n :=
  .ofFn (fun i => if h : i.1 < coeffs.size then coeffs[i] else 0)

private def Bi (B : Finset (Fin n ‚Üí F)) (i : Fin n) : Finset ((Fin n ‚Üí F) √ó (Fin n ‚Üí F)) :=
  { x | x ‚àà B √óÀ¢ B ‚àß x.1 i = x.2 i ‚àß x.1 ‚â† x.2 }

Mathlib.Linter.TextBased.ErrorFormat.humanReadable in Mathlib.Tactic.Linter.TextBased

Algebra.TensorProduct.rightAlgebra in Mathlib.RingTheory.TensorProduct.Basic

abbrev ScalarField := ZMod SCALAR_FIELD_CARD

Polynomial.erase in Mathlib.Algebra.Polynomial.Basic

@[reducible, inline]
instance (priority := low) instTensorForall {Œπ : Type u} (v : Œπ ‚Üí Type v)
    [O : ‚àÄ i, OracleInterface (v i)] : OracleInterface (‚àÄ i, v i) where
  Query := (i : Œπ) ‚Üí (O i).Query
  Response := (i : Œπ) ‚Üí (O i).Response
  answer := fun f q i => (O i).answer (f i) (q i)

@[inline]
def smul [Mul R] (r : R) (p : MlPoly R n) : MlPoly R n := p.map (fun a => r * a)

def bool (j : Fin numWires) : Gate ùì° numWires :=
  { qL := -1, qR := 0, qO := 0, qM := 1, qC := 0, a := j, b := j, c := j }

def zero : ChurchNat Œ± := fun _ x => x

def curve : WeierstrassCurve BaseField := {
  a‚ÇÅ := 0,  
  a‚ÇÇ := 0,  
  a‚ÇÉ := 0,  
  a‚ÇÑ := 0,  
  a‚ÇÜ := 3   
}

@[reducible, simp]
def completeness (relation : Set (Statement √ó Witness)) (completenessError : ‚Ñù‚â•0)
    (proof : Proof oSpec Statement Witness pSpec) : Prop :=
  Reduction.completeness init impl relation acceptRejectRel proof completenessError

@[reducible, inline]
instance instPolynomialDegreeLT : OracleInterface (R‚¶É< d‚¶Ñ[X]) where
  Query := R
  Response := R
  answer := fun ‚ü®poly, _‚ü© point => poly.eval point

def FullData.toLeafData {Œ± : Type} {s : Skeleton}
    (tree : FullData Œ± s) : LeafData Œ± s :=
  match tree with
  | FullData.leaf value => LeafData.leaf value
  | FullData.internal _ left right =>
    LeafData.internal (left.toLeafData) (right.toLeafData)

def DVec {m : Type v} (Œ± : m ‚Üí Type u) : Type (max u v) := ‚àÄ i, Œ± i

protected def cast
    (hO‚Çò : ‚àÄ i, O‚Çò‚ÇÅ i = dcast (Message.cast_idx hSpec) (O‚Çò‚ÇÇ (i.cast hn hSpec)))
    (V : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec‚ÇÅ) :
    OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec‚ÇÇ where
  verify := fun stmt challenges =>
    simulateQ sorry (V.verify stmt (dcast‚ÇÇ hn.symm (dcast_symm hn hSpec) challenges))
  embed := V.embed.trans
    (Embedding.sumMap
      (Equiv.refl _).toEmbedding
      ‚ü®MessageIdx.cast hn hSpec, MessageIdx.cast_injective hn hSpec‚ü©)
  hEq := fun i => by admit /- proof elided -/

Submodule.subtype in Mathlib.Algebra.Module.Submodule.LinearMap

Finset.Ici in Mathlib.Order.Interval.Finset.Defs

def KnowledgeStateFunctionOneShot.toKnowledgeStateFunction
    {relIn : Set (StmtIn √ó WitIn)} {relOut : Set (StmtOut √ó WitOut)}
    {verifier : Verifier oSpec StmtIn StmtOut pSpec}
    (stF : KnowledgeStateFunctionOneShot init impl relIn.language relOut.language verifier)
    (oneShotE : Extractor.RoundByRoundOneShot oSpec StmtIn WitIn pSpec) :
    verifier.KnowledgeStateFunction init impl relIn relOut oneShotE.toRoundByRound where
  toFun := fun m stmtIn tr witIn => if m = 0 then (stmtIn, witIn) ‚àà relIn else
    stF.toFun m stmtIn tr ‚à® (stmtIn, oneShotE m stmtIn tr default) ‚àà relIn
  toFun_empty := fun stmtIn witIn => by admit /- proof elided -/

@[inline, reducible]
protected def id :
    Witness.Lens OuterStmtIn OuterStmtOut OuterWitIn OuterWitOut OuterWitIn OuterWitOut :=
  ‚ü®Prod.snd, fun _ => Prod.snd‚ü©

alias trivial := Witness.Lens.id

def getPutativeRoot {n : ‚Ñï} (i : Fin (2 ^ n)) (leaf : Œ±) (proof : List.Vector Œ± n) :
    OracleComp (spec Œ±) Œ± := do
  match h : n with
  | 0 => do
    
    return leaf
  | n + 1 => do
    
    let signBit := i.val % 2
    
    let i' : Fin (2 ^ n) := ‚ü®i.val / 2, by admit /- proof elided -/
    ‚ü©
    if signBit = 0 then
      
      let newLeaf ‚Üê query (spec := spec Œ±) () ‚ü®leaf, proof.get (Fin.last n)‚ü©
      getPutativeRoot i' newLeaf (proof.drop 1)
    else
      
      let newLeaf ‚Üê query (spec := spec Œ±) () ‚ü®proof.get (Fin.last n), leaf‚ü©
      getPutativeRoot i' newLeaf (proof.drop 1)

def extractability (scheme : Scheme oSpec Data Randomness Commitment pSpec)
    (extractabilityError : ‚Ñù‚â•0) : Prop :=
  ‚àÉ extractor : StraightlineExtractor oSpec Data Commitment,
  ‚àÄ AuxState : Type,
  ‚àÄ adversary : ExtractabilityAdversary oSpec Data Commitment AuxState,
  ‚àÄ prover : Prover oSpec (Commitment √ó O.Query √ó O.Response) AuxState Bool Unit pSpec,
    False

instance [Semiring R] : Module R (MlPolyEval R n) where
  smul := smul
  one_smul a := by admit /- proof elided -/

@[reducible]
noncomputable def fullOracleReduction :
  OracleReduction (oSpec:=[]‚Çí)
    (StmtIn := Statement (L := L) (‚Ñì:=‚Ñì) (SumcheckBaseContext L ‚Ñì) 0)
    (OStmtIn:= OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë 0)
    (StmtOut := Bool)
    (OStmtOut := fun _ : Empty => Unit)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) 0)
    (WitOut := Unit)
    (pSpec := fullPSpec ùîΩq Œ≤ Œ≥_repetitions (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)) :=
  OracleReduction.append (oSpec:=[]‚Çí)
    (Stmt‚ÇÅ := Statement (L := L) (‚Ñì:=‚Ñì) (SumcheckBaseContext L ‚Ñì) 0)
    (Stmt‚ÇÇ := FinalSumcheckStatementOut (L:=L) (‚Ñì:=‚Ñì))
    (Stmt‚ÇÉ := Bool)
    (Wit‚ÇÅ := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) 0)
    (Wit‚ÇÇ := Unit)
    (Wit‚ÇÉ := Unit)
    (OStmt‚ÇÅ := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë 0)
    (OStmt‚ÇÇ := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (OStmt‚ÇÉ := fun _ : Empty => Unit)
    (pSpec‚ÇÅ := pSpecCoreInteraction ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (pSpec‚ÇÇ := pSpecQuery ùîΩq Œ≤ Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (R‚ÇÅ := CoreInteraction.coreInteractionOracleReduction ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (œë:=œë) (ùìë:=ùìë))
    (R‚ÇÇ := QueryPhase.queryOracleReduction ùîΩq Œ≤ Œ≥_repetitions
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (œë:=œë))

OracleComp.lift in VCVio.OracleComp.OracleComp

def Fin2ToF2 (ùîΩq : Type*) [Ring ùîΩq] (k : Fin 2) : ùîΩq :=
  if k = 0 then 0 else 1

structure DomainSeparator (U : Type) [SpongeUnit U] (H : Type*) [DuplexSpongeInterface U H] where
   
  io : String
deriving Repr

minpoly in Mathlib.FieldTheory.Minpoly.Basic

def findNeighbors {n : ‚Ñï} (i : Fin (2 ^ n)) (layer : Fin n) :
    Fin (2 ^ (layer.val + 1)) :=
  
  
  let bits := (Vector.ofFn (finFunctionFinEquiv.invFun i)).reverse
  
  let neighbor := (bits.set layer (bits.get layer + 1)).take (layer.val + 1)
  have : min (layer.val + 1) n = layer.val + 1 := by admit /- proof elided -/

def D_Y (Q : F[Z][X][Y]) : ‚Ñï := Bivariate.natDegreeY Q

def rdrop (m : ‚Ñï) (h : m ‚â§ n) (pSpec : ProtocolSpec n) : ProtocolSpec (n - m) :=
  {dir := Fin.rdrop m h pSpec.dir, ¬´Type¬ª := Fin.rdrop m h pSpec.¬´Type¬ª}

structure ConcreteBTFAddCommGroupProps (k : ‚Ñï) where
  add_assoc : ‚àÄ a b c : ConcreteBTField k, (a + b) + c = a + (b + c) := add_assoc
  add_comm : ‚àÄ a b : ConcreteBTField k, a + b = b + a := add_comm
  add_zero : ‚àÄ a : ConcreteBTField k, a + zero = a := add_zero
  zero_add : ‚àÄ a : ConcreteBTField k, zero + a = a := zero_add
  add_neg : ‚àÄ a : ConcreteBTField k, a + (neg a) = zero := neg_add_cancel

def univPolyHom {F : Type} [CommRing F] [IsDomain F] : F[X] ‚Üí+* RatFunc F :=
  algebraMap (F[X]) (RatFunc F)

OrderBot in Mathlib.Order.BoundedOrder.Basic

def Œ≥ (x‚ÇÄ : F) (R : F[X][X][Y]) (H : F[X][Y]) [œÜ : Fact (Irreducible H)] : PowerSeries (ùïÉ H) :=
  let subst (t : ‚Ñï) : ùïÉ H :=
    match t with
    | 0 => fieldToùïÉ (-x‚ÇÄ)
    | 1 => 1
    | _ => 0
  PowerSeries.subst (PowerSeries.mk subst) (PowerSeries.mk (Œ± x‚ÇÄ R H))

instance (k : ‚Ñï) : Fintype (ConcreteBTField k) := (getBTFResult k).instFintype

structure GaloisAutomorphism (F : Type*) [Field F] (u : F) (k : ‚Ñï) : Prop where
  forward : u ^ (2 ^ (2 ^ k)) = u‚Åª¬π
  reverse : (u‚Åª¬π) ^ (2 ^ (2 ^ k)) = u

Field.toCommRing in Mathlib.Algebra.Field.Defs

noncomputable def discriminant {F : Type} [Field F] [Inhabited F] (f : F[X]) : F :=
  1/f.leadingCoeff * Polynomial.resultant f (Polynomial.derivative f)

@[inline] def add (a b : AssocNat) : AssocNat :=
  ‚ü®a ‚àò b, by admit /- proof elided -/
  ‚ü©

Empty in Init.Prelude

instance domain_neg_inst {i : Fin n} : Neg (evalDomain D i.1) where
  neg := fun x => ‚ü®_, minus_one_in_doms D i.2‚ü© * x

@[reducible]
def GroupDecodeOracle : OracleSpec Unit := fun _ => (BitVec bitLength √ó Œπ, Unit)

Even in Mathlib.Algebra.Group.Even

def fflatten‚ÇÇ {A : Sort u} {B : Sort v} {F : A ‚Üí B ‚Üí Sort w} {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï}
    {Œ± : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí A} {Œ≤ : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí B}
    (v : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí F (Œ± i j) (Œ≤ i j)) :
    (k : Fin (vsum n)) ‚Üí F (Fin.vflatten Œ± k) (Fin.vflatten Œ≤ k) :=
  match m with
  | 0 => !h[]
  | _ + 1 => fappend‚ÇÇ (v 0) (fflatten‚ÇÇ (fun i => v i.succ))

Module.Basis.reindex in Mathlib.LinearAlgebra.Basis.Defs

Equiv.sumComm in Mathlib.Logic.Equiv.Sum

@[simp]
def outerRelIn_Test : Set (OuterStmtIn_Test √ó Unit) :=
  setOf (fun ‚ü®‚ü®p, q, t‚ü©, _‚ü© => ‚àë x ‚àà {0, 1}, (p * q).eval x = t)

class Initialize (Œ± : Type u) (Œ≤ : Type v) where
   
  new : Œ≤ ‚Üí Œ±

@[reducible]
def GroupEqOracle : OracleSpec Unit := fun _ => (Œπ √ó Œπ, Bool)

def getFoldingChallenges (i : Fin (‚Ñì + 1)) (challenges : Fin i ‚Üí L)
    (k : ‚Ñï) (h : k + œë ‚â§ i) : Fin œë ‚Üí L :=
  fun cId => challenges ‚ü®k + cId, by admit /- proof elided -/
  ‚ü©

Finset.Nonempty in Mathlib.Data.Finset.Empty

List.ranges in Mathlib.Data.List.Range

instance [Zero T] [One T] [ToNat T] : NatPow (Cayley T) where
  pow := powNat

noncomputable def coeffs_of_close_proximity (œâs : Fin n ‚Ü™ F) (Œ¥ : ‚Ñö) (u‚ÇÄ u‚ÇÅ : Fin n ‚Üí F)
  : Finset F := Set.toFinset { z | ‚àÉ v : ReedSolomon.code œâs (k + 1), Œ¥·µ£(u‚ÇÄ + z ‚Ä¢ u‚ÇÅ, v) ‚â§ Œ¥}

@[ext]
structure ProverState (n : ‚Ñï) where
  PrvState : Fin (n + 1) ‚Üí Type

noncomputable def commitOracleVerifier (i : Fin ‚Ñì) (hCR : isCommitmentRound ‚Ñì œë i) :
  OracleVerifier
    (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) Context i.succ)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (O‚Çò := fun i => by admit /- proof elided -/
    )
    
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (pSpec := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) where

  
  
  verify := fun stmtIn pSpecChallenges => do
    pure stmtIn

  embed := ‚ü®fun j => by admit /- proof elided -/
  ‚ü©
  hEq := fun oracleIdx => by admit /- proof elided -/

class RoundByRoundOneShot.IsMonotone (E : RoundByRoundOneShot oSpec StmtIn WitIn pSpec)
    (relIn : Set (StmtIn √ó WitIn)) where
  is_monotone : ‚àÄ roundIdx stmtIn transcript,
    ‚àÄ proveQueryLog‚ÇÅ proveQueryLog‚ÇÇ : oSpec.QueryLog,
    
    proveQueryLog‚ÇÅ.Sublist proveQueryLog‚ÇÇ ‚Üí
    
    
    (stmtIn, E roundIdx stmtIn transcript proveQueryLog‚ÇÅ) ‚àà relIn ‚Üí
      (stmtIn, E roundIdx stmtIn transcript proveQueryLog‚ÇÇ) ‚àà relIn

Fintype.ofFinite in Mathlib.Data.Fintype.EquivFin

instance instPow {n : ‚Ñï} : Pow (CNat n) Nat := match n with
  | 0 => by admit /- proof elided -/
  | .succ n => by admit /- proof elided -/

@[reducible]
def addSalt (pSpec : ProtocolSpec n) (Salt : pSpec.MessageIdx ‚Üí Type) :
    ProtocolSpec n :=
  ‚ü®pSpec.dir, fun i => match hDir : pSpec.dir i with
    | .P_to_V => (pSpec.¬´Type¬ª i) √ó Salt ‚ü®i, hDir‚ü©
    | .V_to_P => pSpec.¬´Type¬ª i‚ü©

def getBTFResult (k : ‚Ñï) : ConcreteBTFStepResult k :=
  match k with
  | 0 =>
    let base : ConcreteBTFieldProps 0 := {
      mul_eq := fun a b h_k _ _ _ _ _ _ => by admit /- proof elided -/
| c1_one
        ¬∑ 
          rw [c1_zero] at h_mul
          
          simp at h_mul
        ¬∑ 
          rcases c2_cases with c2_zero | c2_one
          ¬∑ 
            rw [c2_zero] at h_mul
            
            simp at h_mul
          ¬∑ 
            
            exact ‚ü®c1_one, c2_one‚ü©
      
      have specialElement_eq_zero : specialElement = 0 := by admit /- proof elided -/

iSup in Mathlib.Order.SetNotation

instance instOneConcreteBTField (k : ‚Ñï) : One (ConcreteBTField k) where
  one := one

def concreteCanonicalEmbedding (k : ‚Ñï)
    (prevBTFieldProps : ConcreteBTFieldProps (k := (k)))
    (curBTFieldProps : ConcreteBTFieldProps (k := (k + 1))) :
  letI := mkFieldInstance prevBTFieldProps
  letI := mkFieldInstance curBTFieldProps
  ConcreteBTField k ‚Üí+* ConcreteBTField (k + 1) :=

def ConstraintSystem (ùì° : Type) (numWires numGates : ‚Ñï) := Fin numGates ‚Üí Gate ùì° numWires

@[reducible]
def foldRelayOracleReduction (i : Fin ‚Ñì)
    (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
  OracleReduction []‚Çí
    (StmtIn := Statement (L := L) Context i.castSucc)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) i.castSucc)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) i.succ)
    (pSpec := pSpecFoldRelay (L:=L)) :=
  OracleReduction.append
    (pSpec‚ÇÅ := pSpecFold (L:=L))
    (pSpec‚ÇÇ := pSpecRelay)
        (foldOracleReduction ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) i)
    (relayOracleReduction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hNCR)

Algebra.TensorProduct.comm in Mathlib.RingTheory.TensorProduct.Maps

def BindingAdversary (oSpec : OracleSpec Œπ) (Data Commitment AuxState : Type)
    [O : OracleInterface Data] :=
  OracleComp oSpec (Commitment √ó O.Query √ó O.Response √ó O.Response √ó AuxState)

List.Vector.head in Mathlib.Data.Vector.Defs

@[reducible, inline, specialize, simp]
def MessageIdx (vPSpec : VectorSpec n) := {i : Fin n // vPSpec.dir i = .P_to_V}

def bitsToU (i : Fin r) (k : Fin (2 ^ i.val)) :
    AdditiveNTT.U (L := L) (ùîΩq := ùîΩq) (Œ≤ := Œ≤) i :=
  let val := (Finset.univ : Finset (Fin i)).sum fun j =>
    if (Nat.getBit (n := k.val) (k := j.val) == 1) then
      Œ≤ ‚ü®j, by admit /- proof elided -/
      ‚ü©
    else 0

  
  ‚ü®val, by admit /- proof elided -/
  ‚ü©

ByteArray.empty in Init.Prelude

def finUInt16Equiv : Fin (2 ^ 16) ‚âÉ UInt16 where
  toFun := fun i => UInt16.ofFin i
  invFun := fun u => u.toFin
  left_inv _ := rfl
  right_inv _ := rfl

@[reducible, inline, specialize]
def FullTranscript (pSpec : ProtocolSpec n) := (i : Fin n) ‚Üí pSpec.¬´Type¬ª i

def sigmaChallengeIdxToSeqCompose {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (i : Fin m) (j : (pSpec i).ChallengeIdx) : (seqCompose pSpec).ChallengeIdx :=
  ‚ü®Fin.embedSum i j.1, by admit /- proof elided -/
  ‚ü©

noncomputable def embeddingOfùí™IntoùïÉ (H : F[X][Y]) : ùí™ H ‚Üí+* ùïÉ H :=
  Ideal.quotientMap
        (I := Ideal.span {H_tilde' H}) (Ideal.span {H_tilde H})
        bivPolyHom sorry

instance [NeZero k] {f : Fin k ‚Üí Œπ ‚Üí F} : Nonempty (Finset.univ.image f) :=

noncomputable def ansPoly (S : Finset F) (Ans : S ‚Üí F) : Polynomial F :=
  Lagrange.interpolate S.attach (fun i => (i : F)) Ans

noncomputable def polynomialAlgEquiv : P ‚âÉ‚Çê[R] R[X] where
  toFun := toPolynomialAlgHom
  invFun := ofPolynomialAlgHom
  left_inv := by admit /- proof elided -/

def rbrKnowledgeSoundness
    (relIn : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (verifier : OracleVerifier oSpec Statement OStatement Bool (fun _ : Empty => Unit) pSpec)
    (rbrKnowledgeError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) : Prop :=
  verifier.rbrKnowledgeSoundness init impl relIn acceptRejectOracleRel rbrKnowledgeError

def oracleVerifier : OracleVerifier oSpec Statement OStatement Unit (OStatement ‚äï·µ• OStatement)
    (pSpec OStatement) where

  verify := fun stmt _ => relComp stmt

  embed := sorry

  hEq := sorry

@[inline]
def seqCompose {m : ‚Ñï} (Stmt : Fin (m + 1) ‚Üí Type) (Wit : Fin (m + 1) ‚Üí Type)
    {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (R : (i : Fin m) ‚Üí
      Reduction oSpec (Stmt i.castSucc) (Wit i.castSucc) (Stmt i.succ) (Wit i.succ) (pSpec i)) :
    Reduction oSpec (Stmt 0) (Wit 0) (Stmt (Fin.last m)) (Wit (Fin.last m)) (seqCompose pSpec) where
  prover := Prover.seqCompose Stmt Wit (fun i => (R i).prover)
  verifier := Verifier.seqCompose Stmt (fun i => (R i).verifier)

def getMidCodewords {i : Fin (‚Ñì + 1)} (t : L‚¶É‚â§ 1‚¶Ñ[X Fin ‚Ñì]) 
    (challenges : Fin i ‚Üí L) : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i, by admit /- proof elided -/
    ‚ü©) ‚Üí L) :=
  let P‚ÇÄ : L‚¶É< 2^‚Ñì‚¶Ñ[X] := polynomialFromNovelCoeffsF‚ÇÇ ùîΩq Œ≤ ‚Ñì (by admit /- proof elided -/
  ) (fun œâ => t.val.eval œâ)
  let f‚ÇÄ : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate 0) ‚Üí L := fun x => P‚ÇÄ.val.eval x.val
  let f·µ¢ := iterated_fold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
    (i := 0)
    (steps := i)
    (h_i_add_steps := by admit /- proof elided -/
      )
    (f := f‚ÇÄ)
    (r_challenges := challenges)
  fun x => f·µ¢ ‚ü®x, by admit /- proof elided -/
  ‚ü©

class IsSound (langIn : Set StmtIn) (langOut : Set StmtOut)
    (verifier : Verifier oSpec StmtIn StmtOut pSpec) where
  soundnessError : ‚Ñù‚â•0
  is_sound : soundness init impl langIn langOut verifier soundnessError

multiplicity in Mathlib.RingTheory.Multiplicity

inductive MatrixIdx where | A | B | C deriving Inhabited, DecidableEq

structure ProverInteractionWithOutput {Œπ : Type} (oSpec : OracleSpec Œπ) (Output : Type)
    {n : ‚Ñï} (pSpec : ProtocolSpec n) extends
      ProverState n,
      ProverInit (PrvState 0),
      ProverRound oSpec pSpec,
      ProverOutput oSpec Output (PrvState (Fin.last n))

EDist in Mathlib.Topology.EMetricSpace.Defs

IO.FS.Stream.write in Init.System.IO

instance {Œπ : Type} : OracleInterface (OracleStatement Œπ F ()) := OracleInterface.instFunction

Set.toFinset in Mathlib.Data.Fintype.Sets

CommMonoidWithZero in Mathlib.Algebra.GroupWithZero.Defs

def perfectCompleteness
    (relIn : Set ((StmtIn √ó ‚àÄ i, OStmtIn i) √ó WitIn))
    (relOut : Set ((StmtOut √ó ‚àÄ i, OStmtOut i) √ó WitOut))
    (oracleReduction : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec) :
      Prop :=
  Reduction.perfectCompleteness init impl relIn relOut oracleReduction.toReduction

def constrainedCode
  (domain : Œπ ‚Ü™ F) [Smooth domain] (m : ‚Ñï)
  (w : MvPolynomial (Fin (m + 1)) F) (œÉ : F) : Set (Œπ ‚Üí F) :=
    { f | ‚àÉ (h : f ‚àà smoothCode domain m),
      weightConstraint (mVdecode (‚ü®f, h‚ü© : smoothCode domain m)) w œÉ }

@[reducible, inline]
def OracleProver {Œπ : Type} (oSpec : OracleSpec Œπ)
    (StmtIn : Type) {Œπ‚Çõ·µ¢ : Type} (OStmtIn : Œπ‚Çõ·µ¢ ‚Üí Type) (WitIn : Type)
    (StmtOut : Type) {Œπ‚Çõ‚Çí : Type} (OStmtOut : Œπ‚Çõ‚Çí ‚Üí Type) (WitOut : Type)
    {n : ‚Ñï} (pSpec : ProtocolSpec n) :=
  Prover oSpec (StmtIn √ó (‚àÄ i, OStmtIn i)) WitIn (StmtOut √ó (‚àÄ i, OStmtOut i)) WitOut pSpec

Nat.mod in Init.Prelude

class ProverOnly (pSpec : ProtocolSpec 1) extends ProverFirst pSpec

 
alias NonInteractive := ProverOnly

Vector.tail in Init.Data.Vector.Basic

def absorb (state : HashStateWithInstructions U H) (input : Array U) :
    Except DomainSeparatorMismatch (HashStateWithInstructions U H) := do
  
  sorry

@[reducible]
def pSpec (F : Type) [Semiring F] : ProtocolSpec 2 := ‚ü®!v[.V_to_P, .P_to_V], !v[F, Unit ‚Üí F[X]]‚ü©

invFun in ToMathlib.Control.Monad.Equiv

def knowledgeStateFunction (hRel : ‚àÄ stmtIn witOut,
      (mapStmt stmtIn, witOut) ‚àà relOut ‚Üí (stmtIn, mapWitInv stmtIn witOut) ‚àà relIn) :
    (verifier oSpec mapStmt).KnowledgeStateFunction
      init impl relIn relOut (extractor mapWitInv) where
  toFun | ‚ü®0, _‚ü© => fun stmtIn _ witIn => ‚ü®stmtIn, witIn‚ü© ‚àà relIn
  toFun_empty := fun stmtIn witIn => by admit /- proof elided -/

@[reducible]
def GroupValTable (Œπ : Type*) (G : Type*) := Œ†‚ÇÄ _ : Œπ, Option G

def roundRelation (i : Fin (‚Ñì + 1)) :
    Set ((Statement (L := L) Context i √ó
      (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i j)) √ó
      Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) :=
  { input | roundRelationProp (mp := mp) (ùìë := ùìë) ùîΩq Œ≤ i input}

AffineSubspace in Mathlib.LinearAlgebra.AffineSpace.AffineSubspace.Defs

TensorProduct in Mathlib.LinearAlgebra.TensorProduct.Basic

instance instDCast‚ÇÅ‚ÇÇ : DCast (Œ≤ a) (Œ≥ a) where
  dcast hb c := dcast‚ÇÇ (Eq.refl a) (by admit /- proof elided -/
  ) c
  dcast_id := by admit /- proof elided -/

structure Statement (Context : Type) (i : Fin (‚Ñì + 1)) where
  
  sumcheck_target : L              
  challenges : Fin i ‚Üí L           
  ctx : Context 

instance : OracleInterface (Witness R pp) where
  Query := Fin pp.‚Ñì_w ‚Üí R
  Response := R
  answer := fun ùï® evalPoint => (MLE (ùï® ‚àò finFunctionFinEquiv)) ‚∏®evalPoint‚∏©

instance instDecidableEqOption {Œ± : Type*} [DecidableEq Œ±] :
    DecidableEq (Option Œ±) := inferInstance

instance : Fact (Nat.Prime (PrimeOrder.p G)) :=
  PrimeOrder.hPrime

noncomputable def distFromCode (u : n ‚Üí R) (C : Set (n ‚Üí R)) : ‚Ñï‚àû :=
  sInf {d | ‚àÉ v ‚àà C, hammingDist u v ‚â§ d}

RingHom.id in Mathlib.Algebra.Ring.Hom.Defs

def uniqueDecodable (C : Code Œπ F) (r : ‚Ñù) : Prop :=
  listDecodable C r 1

def listOfCloseCodewordsRel (C : Code Œπ F) (y : Œπ ‚Üí F) (r : ‚Ñù) : ‚Ñï :=
  Nat.card (relHammingBall C y r)

@[app_unexpander Fin.dcons]
def dconsUnexpander : Lean.PrettyPrinter.Unexpander
  | `($_ $term !d[$term2, $terms,*]) => `(!d[$term, $term2, $terms,*])
  | `($_ $term !d[$term2]) => `(!d[$term, $term2])
  | `($_ $term !d[]) => `(!d[$term])
  | _ => throw ()

def intCast {k : ‚Ñï} (n : ‚Ñ§) : ConcreteBTField k := if n % 2 = 0 then zero else one

noncomputable def UniPolyC.toPoly (p : UniPolyC R) : Polynomial R := p.val.toPoly

alias ofPoly := Polynomial.toImpl

instance : ‚àÄ i, SelectableType ((pSpecFinalSumcheckStep (L:=L)).Challenge i)
  | ‚ü®0, _‚ü© => by admit /- proof elided -/

@[inline]
def neg [Neg R] (p : MlPolyEval R n) : MlPolyEval R n := p.map (fun a => -a)

structure FSProverState (U : Type) [SpongeUnit U] (H : Type*) [DuplexSpongeInterface U H]
    (R : Type*) extends FSVerifierState U H where
   
  rng : ProverPrivateRng R
deriving Repr

@[inline, specialize]
def nsmul (n : ‚Ñï) (p : UniPoly R) : UniPoly R :=
  nsmul_raw n p |> trim

class Extractor.Straightline.IsMonotone
    (relIn : Set (StmtIn √ó WitIn))
    (E : Extractor.Straightline oSpec StmtIn WitIn WitOut pSpec)
    [oSpec.FiniteRange]
    where
  is_monotone : ‚àÄ witOut stmtIn transcript, ‚àÄ proveQueryLog‚ÇÅ proveQueryLog‚ÇÇ : oSpec.QueryLog,
    ‚àÄ verifyQueryLog‚ÇÅ verifyQueryLog‚ÇÇ : oSpec.QueryLog,
    proveQueryLog‚ÇÅ.Sublist proveQueryLog‚ÇÇ ‚Üí
    verifyQueryLog‚ÇÅ.Sublist verifyQueryLog‚ÇÇ ‚Üí
    
    [fun witIn => (stmtIn, witIn) ‚àà relIn |
      E stmtIn witOut transcript proveQueryLog‚ÇÅ verifyQueryLog‚ÇÅ] ‚â§
    [fun witIn => (stmtIn, witIn) ‚àà relIn |
      E stmtIn witOut transcript proveQueryLog‚ÇÇ verifyQueryLog‚ÇÇ]

instance [inst : ‚àÄ i, DecidableEq (pSpec.Message i)] {k : Fin (n + 1)} :
    DecidableEq (MessagesUpTo k pSpec) :=
  @Fintype.decidablePiFintype _ _ (fun i => inst ‚ü®i.1.castLE (by admit /- proof elided -/
  ), i.property‚ü©) _

Nat.bodd in Mathlib.Data.Nat.Bits

Function.Injective2 in Mathlib.Logic.Function.Basic

Fin.elim0 in Init.Data.Fin.Basic

Repr in Init.Data.Repr

def FullData.toInternalData {Œ± : Type} {s : Skeleton}
    (tree : FullData Œ± s) : InternalData Œ± s :=
  match tree with
  | FullData.leaf _ => InternalData.leaf
  | FullData.internal value left right =>
    InternalData.internal value (left.toInternalData) (right.toInternalData)

@[simp]
abbrev LinearCombinationChallenge : Type := R1CS.MatrixIdx ‚Üí R

Set.imageFactorization in Mathlib.Data.Set.Operations

instance : ‚àÄ i, OracleInterface (Message !p[] i) :=
  fun ‚ü®i, h‚ü© =>
    (Fin.elim0 i : (h' : !p[].dir i = .P_to_V) ‚Üí OracleInterface (!p[].Message ‚ü®i, h'‚ü©)) h

instance instOracleInterfaceMessagePSpec : ‚àÄ i, OracleInterface ((pSpec R deg).Message i) :=
  instOracleInterfaceMessageAppend

MonadLift.monadLift in Init.Prelude

class Statement.Lens.IsSound {OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut : Type}
    (outerLangIn : Set OuterStmtIn) (outerLangOut : Set OuterStmtOut)
    (innerLangIn : Set InnerStmtIn) (innerLangOut : Set InnerStmtOut)
    (compatStmt : OuterStmtIn ‚Üí InnerStmtOut ‚Üí Prop)
    (lens : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut) where

  proj_sound : ‚àÄ outerStmtIn,
    outerStmtIn ‚àâ outerLangIn ‚Üí lens.proj outerStmtIn ‚àâ innerLangIn

  lift_sound : ‚àÄ outerStmtIn innerStmtOut,
    compatStmt outerStmtIn innerStmtOut ‚Üí
    innerStmtOut ‚àâ innerLangOut ‚Üí
    lens.lift outerStmtIn innerStmtOut ‚àâ outerLangOut

structure FSVerifierState (U : Type) [SpongeUnit U] (H : Type*) [DuplexSpongeInterface U H] where
   
  hashState : HashStateWithInstructions U H
   
  nargString : ByteArray
deriving Repr

@[reducible]
def combineMap : StmtIn √ó WitIn ‚Üí OracleComp oSpec (StmtOut √ó WitOut) :=
  fun ‚ü®stmt, wit‚ü© => do return (‚Üê mapStmt stmt, ‚Üê mapWit stmt wit)

UInt8 in Init.Prelude

OracleComp.SelectableType in VCVio.OracleComp.Constructions.UniformSelect

def SkeletonNodeIndex.isRoot {s : Skeleton} (idx : SkeletonNodeIndex s) : Bool :=
  match idx with
  | SkeletonNodeIndex.ofLeaf => true
  | SkeletonNodeIndex.ofInternal => true
  | SkeletonNodeIndex.ofLeft _ => false
  | SkeletonNodeIndex.ofRight _ => false

NNRat.castRec in Mathlib.Algebra.Field.Defs

noncomputable def qMap_total_fiber
    
      (i : Fin r) (steps : ‚Ñï) (h_i_add_steps : i.val + steps < ‚Ñì + ùì°)
        (y : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i.val + steps, by admit /- proof elided -/
        ‚ü©)) :
    Fin (2 ^ steps) ‚Üí sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i :=
  if h_steps : steps = 0 then by
    
    subst h_steps
    simp only [add_zero, Fin.eta] at y
    exact fun _ => y
  else by
    
    let basis_y := sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i+steps,by admit /- proof elided -/
    ‚ü©) (by admit /- proof elided -/
    )
    let y_coeffs : Fin (‚Ñì + ùì° - (‚Üëi + steps)) ‚Üí‚ÇÄ ùîΩq := basis_y.repr y

    let basis_x := sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i, by admit /- proof elided -/
    ‚ü© (by admit /- proof elided -/
    )
    exact fun elementIdx => by admit /- proof elided -/

List.min in Init.Data.List.Basic

instance (priority := low) : DCast Œ± Œ≤ where
  dcast h := cast (congrArg Œ≤ h)
  dcast_id := by admit /- proof elided -/

def processMemoryOps (ops : List (MemoryOp Œπ Œ±)) (startMem : M) : Option M :=
  ops.foldlM (fun m op =>
    match op with
    | .read ‚ü®i, v‚ü© => if Memory.read m i = v then some m else none
    | .write ‚ü®i, v‚ü© => some (Memory.write m i v)
  ) startMem

abbrev BaseField := ZMod baseFieldSize

def ri (dstar : ‚Ñï) (degs : Fin m ‚Üí ‚Ñï) (r : F) (i : Fin m) : F :=
          match i.1 with
          | 0 => 1
          | .succ i' =>
            let exp := i' + ‚àë j < i, (dstar - degs j)
            r ^ exp

run in VCVio.CryptoFoundations.SecExp

Finset.filter in Mathlib.Data.Finset.Filter

protected def OracleVerifier.id :
    OracleVerifier oSpec Statement OStatement Statement OStatement !p[] where
  verify := fun stmt _ => pure stmt
  embed := Function.Embedding.inl
  hEq := fun _ => rfl

pos in ToMathlib.Control.Comonad.Instances

instance [Fintype F] [Nonempty F] [Semiring F] [DecidableEq Œπ] [DecidableEq F] {l : ‚Ñï}
  {u : Fin l ‚Üí Œπ ‚Üí F} : Nonempty {x // x ‚àà parametrisedCurveFinite u} :=

def equivFin2 : Direction ‚âÉ Fin 2 where
  toFun := fun dir => match dir with | .V_to_P => ‚ü®0, by admit /- proof elided -/
  ‚ü© | .P_to_V => ‚ü®1, by admit /- proof elided -/
  ‚ü©
  invFun := fun n => match n with | ‚ü®0, _‚ü© => .V_to_P | ‚ü®1, _‚ü© => .P_to_V
  left_inv := fun dir => match dir with | .P_to_V => rfl | .V_to_P => rfl
  right_inv := fun n => match n with | ‚ü®0, _‚ü© => rfl | ‚ü®1, _‚ü© => rfl

instance : LawfulHasSucc Nat where
  succ'_eq_add_one := Nat.succ_eq_add_one

Nat.decLt in Init.Prelude

noncomputable def Œ∑Star (U : Type) [SpongeUnit U] [Fintype U]
    (t‚Çï t‚Çö t‚Çö·µ¢ : ‚Ñï) (L : ‚Ñï) (Œµcodec : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) : ‚Ñù‚â•0 :=
  let tTotal : ‚Ñï := (t‚Çï + t‚Çö + t‚Çö·µ¢)
  
  
  
  
  let firstTermNumerator : ‚Ñù‚â•0 :=
    7 * tTotal ^2 + (28 * L + 25) * tTotal + (14 * L + 1) * (L + 1)
  let firstTermDenominator : ‚Ñù‚â•0 := 2 * ((Fintype.card U) ^ (SpongeSize.C + 1))
  
  let secondTerm : ‚Ñù‚â•0 := Œ∏Star t‚Çï t‚Çö t‚Çö·µ¢ * (iSup Œµcodec)
  
  let thirdTerm : ‚Ñù‚â•0 := ‚àë i, Œµcodec i
  
  firstTermNumerator / firstTermDenominator + secondTerm + thirdTerm

RatFunc in Mathlib.FieldTheory.RatFunc.Defs

instance {n : ‚Ñï} : OfNat (Cayley T) n where
  ofNat := ofNat n

def collisionPerm : Prop :=
  collisionFwdFwd trace ‚à® collisionBwdBwd trace ‚à® collisionFwdBwd trace ‚à® collisionBwdFwd trace

alias E_prp := collisionPerm

noncomputable instance : Algebra K (Left ‚äó[K] Right) := Algebra.TensorProduct.instAlgebra

def aeval {A : Type w} [CommSemiring A] [Algebra R A] (s : A) : P ‚Üí‚Çê[R] A :=
  eval‚ÇÇAlgHom (Algebra.ofId R A) s

IO.eprintln in Init.System.IO

@[inline, specialize]
def oracleVerifier : OracleVerifier oSpec
    Unit (fun _ : Fin 2 => OStatement)
    (Query OStatement) (fun _ : Fin 2 => OStatement) (pSpec OStatement) where

  verify := fun _ chal => do
    let q : Query OStatement := chal ‚ü®0, rfl‚ü©
    pure q

  embed := Function.Embedding.inl

  hEq := by admit /- proof elided -/

noncomputable def foldVerifier :
  OracleVerifier []‚Çí
    (Statement F i.castSucc) (OracleStatement D x s i.castSucc)
    (Statement F i.succ) (OracleStatement D x s i.succ)
    (pSpec D x s i) where
  verify := fun prevChallenges roundChallenge =>
    pure (Fin.vappend prevChallenges (fun _ => roundChallenge ‚ü®0, by admit /- proof elided -/
    ‚ü©))
  embed :=
    ‚ü®
      fun j =>
        if h : j.val = (i.val + 1)
        then Sum.inr ‚ü®1, by admit /- proof elided -/
        ‚ü©
        else Sum.inl ‚ü®j.val, by admit /- proof elided -/
        ‚ü©,
      by admit /- proof elided -/
    ‚ü©
  hEq := by admit /- proof elided -/

@[inline, specialize, simp]
def prover : Prover oSpec Statement Witness Statement Witness !p[] := Prover.id

@[reducible]
def StateRestoration.KnowledgeSoundness (oSpec : OracleSpec Œπ)
    (StmtIn : Type) {Œπ‚Çõ·µ¢ : Type} (OStmtIn : Œπ‚Çõ·µ¢ ‚Üí Type) (WitOut : Type)
    {n : ‚Ñï} {pSpec : ProtocolSpec n} :=
  Prover.StateRestoration.KnowledgeSoundness oSpec (StmtIn √ó (‚àÄ i, OStmtIn i)) WitOut pSpec

tag in Examples.FrankingProtocol

instance : Fact (Nat.Prime fieldSize) := ‚ü®is_prime‚ü©

@[inline, specialize]
def Prover.runToRoundDSFS [‚àÄ i, VCVCompatible (pSpec.Challenge i)] (i : Fin (n + 1))
    (stmt : StmtIn) (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec)
    (state : prover.PrvState 0) :
        OracleComp (oSpec ++‚Çí duplexSpongeChallengeOracle StmtIn U)
          (pSpec.MessagesUpTo i √ó
            DuplexSponge U (Vector U SpongeSize.N) √ó prover.PrvState i) :=
  Fin.induction
    (do
      
      let sponge ‚Üê liftM (DuplexSponge.start stmt)
      return ‚ü®default, sponge, state‚ü©
    )
    (prover.processRoundDSFS)
    i

def oracleReduction.sendClaim : OracleReduction oSpec (StmtIn R) (OStmtIn R deg) Unit
    (StmtAfterSendClaim R) (OStmtAfterSendClaim R deg) Unit ‚ü®!v[.P_to_V], !v[R‚¶É‚â§ deg‚¶Ñ[X]]‚ü© := sorry

Nat.reduceBeqDiff in Lean.Meta.Tactic.Simp.BuiltinSimprocs.Nat

Eq.mp in Init.Core

@[reducible]
def fieldSize : Nat := 2 ^ 31 - 2 ^ 27 + 1

def renameMessage (pSpec : ProtocolSpec n) (NewMessage : pSpec.MessageIdx ‚Üí Type) :
    ProtocolSpec n :=
  ‚ü® pSpec.dir,
    fun i => if h : pSpec.dir i = Direction.P_to_V then NewMessage ‚ü®i, h‚ü© else pSpec.¬´Type¬ª i‚ü©

Pi.single in Mathlib.Algebra.Notation.Pi.Basic

@[reducible, simp]
def oraclePSpec : ProtocolSpec 1 := ‚ü®!v[.P_to_V], !v[Witness]‚ü©

noncomputable def queryProver :
  OracleProver []‚Çí
    (FinalStatement F k) (FinalOracleStatement D x s) (Witness F s d (Fin.last (k + 1)))
    (FinalStatement F k) (FinalOracleStatement D x s) (Witness F s d (Fin.last (k + 1)))
    (pSpec D x l) where
  PrvState
  | _ =>
    (FinalStatement F k √ó ((i : Fin (k + 2)) ‚Üí FinalOracleStatement D x s i)) √ó
      Witness F s d (Fin.last (k + 1))

  input := id

  sendMessage
  | ‚ü®0, h‚ü© => nomatch h

  receiveChallenge
  | ‚ü®1, _‚ü© => fun x => pure <| fun _ => x

  output := pure

def Œ≤ (R : F[X][X][Y]) (t : ‚Ñï) : ùí™ H :=
  (Œ≤_regular R H (Nat.le_refl _) t).choose

propext in Init.Core

instance {_ : Empty} : OracleInterface (Unit) := OracleInterface.instDefault

@[inline]
def zsmul [SMul ‚Ñ§ R] (m : ‚Ñ§) (p : MlPoly R n) : MlPoly R n := p.map (fun a => m ‚Ä¢ a)

AddMonoidAlgebra in Mathlib.Algebra.MonoidAlgebra.Defs

Sum.isRight in Init.Data.Sum.Basic

def example1 : ChurchVec ‚Ñï := churchCons 1 (churchCons 2 (churchCons 3 churchNil))

example : toList example1 = [1, 2, 3] := rfl

@[reducible, inline, specialize]
def Challenges' (pSpec : ProtocolSpec n) : Type :=
  ‚àÄ i, (hi : pSpec.dir i = .V_to_P) ‚Üí pSpec.¬´Type¬ª i

instance {s} : LawfulFunctor (fun Œ± => InternalData Œ± s) :=

def closePtsOnAffineLine {Œπ : Type*} [Fintype Œπ]
                         (u v : Œπ ‚Üí F) (deg : ‚Ñï) (Œ± : Œπ ‚Ü™ F) (e : ‚Ñï) : Set (Œπ ‚Üí F) :=
  {x : Œπ ‚Üí F | x ‚àà Affine.line u v ‚àß distFromCode x (ReedSolomon.code Œ± deg) ‚â§ e}

def hli_level_diff_0 (l : ‚Ñï) :
  letI instAlgebra:= binaryAlgebraTower (l:=l) (r:=l) (h_le:=by omega)
  @Basis (Fin 1) (BTField l) (BTField l) _ _ instAlgebra.toModule :=

finSumFinEquiv in Mathlib.Logic.Equiv.Fin.Basic

def equivMvPolynomialDeg1 : MlPoly R n ‚âÉ R‚¶É‚â§ 1‚¶Ñ[X Fin n] where
  toFun := toMvPolynomialDeg1
  invFun := ofMvPolynomialDeg1
  left_inv v := by admit /- proof elided -/

@[inline, specialize]
def runWithLogToRound (i : Fin (n + 1))
    (stmt : StmtIn) (wit : WitIn) (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí)
        ((pSpec.Transcript i √ó prover.PrvState i) √ó QueryLog (oSpec ++‚Çí [pSpec.Challenge]‚Çí)) :=
  (simulateQ loggingOracle (prover.runToRound i stmt wit)).run

Array.mk in Init.Prelude

noncomputable instance {v : Œπ ‚Üí F} {s : AffineSubspace F (Œπ ‚Üí F)} [Fintype s] :
    Fintype (v +·µ• s) := Fintype.ofFinite ‚Ü•(v +·µ• s)

def extract {n : ‚Ñï} {Œ± : Fin n ‚Üí Sort*} (start stop : ‚Ñï) (h1 : start ‚â§ stop) (h2 : stop ‚â§ n)
    (v : (i : Fin n) ‚Üí Œ± i) : (i : Fin (stop - start)) ‚Üí Œ± ‚ü®i + start, by admit /- proof elided -/
    ‚ü© :=
  fun i ‚Ü¶ v ‚ü®i + start, by admit /- proof elided -/
  ‚ü©

def MessageIdx.inr (i : MessageIdx pSpec‚ÇÇ) : MessageIdx (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ) :=
  ‚ü®Fin.natAdd m i.1, by admit /- proof elided -/
  ‚ü©

def foldKStateProp {i : Fin ‚Ñì} (m : Fin (2 + 1))
    (tr : Transcript m (pSpecFold (L := L))) (stmt : Statement (L := L) Context i.castSucc)
    (witMid : Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j) :
    Prop :=
  
  let h_star : ‚Ü•L‚¶É‚â§ 2‚¶Ñ[X] := getSumcheckRoundPoly ‚Ñì ùìë (i := i) (h := witMid.H)
  
  let get_H·µ¢ := fun (m: Fin (2 + 1)) (tr: Transcript m pSpecFold) (hm: 1 ‚â§ m.val) =>
    let ‚ü®msgsUpTo, _‚ü© := Transcript.equivMessagesChallenges (k := m)
      (pSpec := pSpecFold (L := L)) tr
    let i_msg1 : ((pSpecFold (L := L)).take m m.is_le).MessageIdx :=
      ‚ü®‚ü®0, Nat.lt_of_succ_le hm‚ü©, by admit /- proof elided -/
      ‚ü©
    let h_i : L‚¶É‚â§ 2‚¶Ñ[X] := msgsUpTo i_msg1
    h_i

  let get_r·µ¢' := fun (m: Fin (2 + 1)) (tr: Transcript m pSpecFold) (hm: 2 ‚â§ m.val) =>
    let ‚ü®msgsUpTo, chalsUpTo‚ü© := Transcript.equivMessagesChallenges (k := m)
      (pSpec := pSpecFold (L := L)) tr
    let i_msg1 : ((pSpecFold (L := L)).take m m.is_le).MessageIdx :=
      ‚ü®‚ü®0, Nat.lt_of_succ_le (Nat.le_trans (by admit /- proof elided -/
      ) hm)‚ü©, by admit /- proof elided -/
      ‚ü©
    let h_i : L‚¶É‚â§ 2‚¶Ñ[X] := msgsUpTo i_msg1
    let i_msg2 : ((pSpecFold (L := L)).take m m.is_le).ChallengeIdx :=
      ‚ü®‚ü®1, Nat.lt_of_succ_le hm‚ü©, by admit /- proof elided -/
      ‚ü©
    let r_i' : L := chalsUpTo i_msg2
    r_i'

  match m with
  | ‚ü®0, _‚ü© => 
    masterKStateProp (mp := mp) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (stmtIdx := i.castSucc) (oracleIdx := i.castSucc)
      (h_le := le_refl _)
      (stmt := stmt) (wit := witMid) (oStmt := oStmt)
      (localChecks := True)
  | ‚ü®1, h1‚ü© => 
    masterKStateProp (mp := mp) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (stmtIdx := i.castSucc) (oracleIdx := i.castSucc)
      (h_le := le_refl _)
      (stmt := stmt) (wit := witMid) (oStmt := oStmt)
      (localChecks :=
        let h_i := get_H·µ¢ (m := ‚ü®1, h1‚ü©) (tr := tr) (hm := by admit /- proof elided -/
        )
        let explicitVCheck := h_i.val.eval 0 + h_i.val.eval 1 = stmt.sumcheck_target
        let localizedRoundPolyCheck := h_i = h_star
        explicitVCheck ‚àß localizedRoundPolyCheck
      )
  | ‚ü®2, h2‚ü© => 
    
    masterKStateProp (mp := mp) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (stmtIdx := i.castSucc) (oracleIdx := i.castSucc)
      (h_le := le_refl _)
      (stmt := stmt) (wit := witMid) (oStmt := oStmt)
      (localChecks :=
        let h_i := get_H·µ¢ (m := ‚ü®2, h2‚ü©) (tr := tr) (hm := by admit /- proof elided -/
        )
        let r_i' := get_r·µ¢' (m := ‚ü®2, h2‚ü©) (tr := tr) (hm := by admit /- proof elided -/
        )
        let localizedRoundPolyCheck := h_i = h_star
        let nextSumcheckTargetCheck := 
          h_i.val.eval r_i' = h_star.val.eval r_i'
        localizedRoundPolyCheck ‚àß nextSumcheckTargetCheck
      ) 

instance {i : Fin ‚Ñì} : ‚àÄ j, SelectableType ((pSpecFoldCommit ùîΩq Œ≤
  (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i).Challenge j) := instSelectableTypeChallengeAppend

@[reducible]
def C : R ‚Üí+* P := algebraMap R P

noncomputable def divergence (U V : Set (Œπ ‚Üí F)) : ‚Ñö‚â•0 :=
  haveI : Fintype (possibleDeltas U V) := @Fintype.ofFinite _ finite_possibleDeltas
  if h : (possibleDeltas U V).Nonempty
  then (possibleDeltas U V).toFinset.max' (Set.toFinset_nonempty.2 h)
  else 0

def possibleDists (C : Set (Œπ ‚Üí F)) (Œ¥f : (Œπ ‚Üí F) ‚Üí (Œπ ‚Üí F) ‚Üí Œ±) : Set Œ± :=
  {d : Œ± | ‚àÉ p ‚àà Set.offDiag C, Œ¥f p.1 p.2 = d}

noncomputable def H_tilde' (H : F[X][Y]) : F[X][Y] :=
  let h·µ¢ (i : ‚Ñï) := H.coeff i
  let d := H.natDegree
  let W := h·µ¢ d
  Polynomial.X ^ d +
    ‚àë i ‚àà (List.range d).toFinset,
      Polynomial.X^(d - 1 - i) *
      Polynomial.C (h·µ¢ (i + 1) * W ^ i)

Nat.cast in Init.Data.Cast

def partition (cs : ConstraintSystem ùì° numWires numGates) :
    Fin numWires ‚Üí Finset (Fin (3 * numGates)) :=
  
  
  
  
  fun i => Finset.map (Equiv.toEmbedding finProdFinEquiv)
    (Finset.filter (fun j => if j.1 = 0 then (cs j.2).a = i
      else if j.1 = 1 then (cs j.2).b = i else (cs j.2).c = i)
    (Finset.univ : Finset (Fin 3 √ó Fin numGates)))

def getRoot {n : ‚Ñï} (cache : Cache Œ± n) : Œ± :=
  (cache 0).get ‚ü®0, by admit /- proof elided -/
  ‚ü©

Set.Ioo in Mathlib.Order.Interval.Set.Defs

def nil {Œ±} : Vector Œ± 0 := ‚ü®#[], rfl‚ü© 

def natDegreeY (f : F[X][Y]) : ‚Ñï := Polynomial.natDegree f

def ratchet (state : FSProverState U H R) :
    Except DomainSeparatorMismatch (FSProverState U H R) :=
  match state.hashState.ratchet with
  | .ok newHashState =>
    .ok { rng := state.rng, hashState := newHashState, nargString := state.nargString }
  | .error e => .error e

@[reducible]
def OracleStatement (i : Fin (k + 1)) : Fin (i.val + 1) ‚Üí Type :=
  fun j =>
    evalDomain D x (‚àë j' ‚àà finRangeTo j.1, s j')
      ‚Üí F

instance : Sub AssocNat where
  sub := sub

@[inline, reducible]
def OracleStatement.Lens (OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut : Type)
    {Outer_Œπ‚Çõ·µ¢ : Type} (OuterOStmtIn : Outer_Œπ‚Çõ·µ¢ ‚Üí Type) [‚àÄ i, OracleInterface (OuterOStmtIn i)]
    {Outer_Œπ‚Çõ‚Çí : Type} (OuterOStmtOut : Outer_Œπ‚Çõ‚Çí ‚Üí Type) [‚àÄ i, OracleInterface (OuterOStmtOut i)]
    {Inner_Œπ‚Çõ·µ¢ : Type} (InnerOStmtIn : Inner_Œπ‚Çõ·µ¢ ‚Üí Type) [‚àÄ i, OracleInterface (InnerOStmtIn i)]
    {Inner_Œπ‚Çõ‚Çí : Type} (InnerOStmtOut : Inner_Œπ‚Çõ‚Çí ‚Üí Type) [‚àÄ i, OracleInterface (InnerOStmtOut i)]
  :=
    Statement.Lens (OuterStmtIn √ó ‚àÄ i, OuterOStmtIn i) (OuterStmtOut √ó ‚àÄ i, OuterOStmtOut i)
                  (InnerStmtIn √ó ‚àÄ i, InnerOStmtIn i) (InnerStmtOut √ó ‚àÄ i, InnerOStmtOut i)

def Equiv.ofLawfulPermute (Œ± : Type*) [Permute Œ±] [LawfulPermute Œ±] : Equiv Œ± Œ± where
  toFun := Permute.permute
  invFun := LawfulPermute.permuteInv
  left_inv := LawfulPermute.left_inv
  right_inv := LawfulPermute.right_inv

instance instDCast : DCast Nat Fin where
  dcast h := Fin.cast h
  dcast_id := by admit /- proof elided -/

Array.rightpad in Init.Data.Array.Basic

Vector.zipWith in Init.Data.Vector.Basic

List.findIdx in Init.Data.List.Basic

AdjoinRoot.root in Mathlib.RingTheory.AdjoinRoot

instance : AlgebraTower (BTField) where
  algebraMap := towerAlgebraMap
  commutes' := by admit /- proof elided -/

def ValidChurchNat : Type :=
  { f : ChurchNat ‚Ñï // ‚àÉ n, ‚àÄ g x, f g x = Nat.iterate g n x }

instance [reduction.IsPerfectComplete init impl relIn relOut] :
    IsComplete init impl relIn relOut reduction where
  completenessError := 0
  is_complete := IsPerfectComplete.is_perfect_complete

Nat.card in Mathlib.SetTheory.Cardinal.Finite

instance [ProverFirst pSpec] : Unique (pSpec.MessageIdx) where
  default := ‚ü®0, by admit /- proof elided -/
  ‚ü©
  uniq := fun ‚ü®i, _‚ü© => by admit /- proof elided -/

instance : SubSpec [pSpec‚ÇÅ.Challenge]‚Çí ([(pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).Challenge]‚Çí) where
  monadLift | query i t => instSubSpecOfProtocolSpecAppendChallenge.monadLift (query (Sum.inl i) t)

Fin.succAboveCases in Mathlib.Data.Fin.Tuple.Basic

abbrev AffSpanSet [NeZero k] (U : Fin k ‚Üí Œπ ‚Üí F) : Set (Œπ ‚Üí F) :=
  (affineSpan F (Finset.univ.image U : Set (Œπ ‚Üí F))).carrier

def rtake {n : ‚Ñï} {Œ± : Fin n ‚Üí Sort*} (m : ‚Ñï) (h : m ‚â§ n) (v : (i : Fin n) ‚Üí Œ± i) :
    (i : Fin m) ‚Üí Œ± (Fin.cast (Nat.sub_add_cancel h) (natAdd (n - m) i)) :=
  fun i => v (Fin.cast (Nat.sub_add_cancel h) (natAdd (n - m) i))

GaloisField.equivZmodP in Mathlib.FieldTheory.Finite.GaloisField

instance [Zero T] [ToNat T] : DecidableRel (@LT.lt (Cayley T) _) := fun a b =>
  Nat.decLt (‚Üëa) (‚Üëb)

Fin in Init.Prelude

Equiv.optionCongr in Mathlib.Logic.Equiv.Option

HSMul.hSMul in Init.Prelude

abbrev CoeffVecSpace (L : Type u) (‚Ñì : Nat) := Fin (2^‚Ñì) ‚Üí L

Fin.subNat in Init.Data.Fin.Basic

Membership in Init.Prelude

def buildMerkleTree_with_hash {s} (leaf_tree : LeafData Œ± s) (hashFn : Œ± ‚Üí Œ± ‚Üí Œ±) :
    (FullData Œ± s) :=
  match leaf_tree with
  | LeafData.leaf a => FullData.leaf a
  | LeafData.internal left right =>
    let leftTree := buildMerkleTree_with_hash left hashFn
    let rightTree := buildMerkleTree_with_hash right hashFn
    let rootHash := hashFn (leftTree.getRootValue) (rightTree.getRootValue)
    FullData.internal rootHash leftTree rightTree

instance [h : VerifierFirst pSpec] : VerifierFirst pSpec where
  verifier_first' := by admit /- proof elided -/

instance : HasSucc Nat where
  succ' := Nat.succ

@[ext]
structure VectorSpec (n : ‚Ñï) where
  dir : Fin n ‚Üí Direction
  length : Fin n ‚Üí Nat

def SkeletonNodeIndex.sibling {s : Skeleton} (idx : SkeletonNodeIndex s) :
    Option (SkeletonNodeIndex s) :=
  match idx with
  
  | SkeletonNodeIndex.ofLeaf => none
  
  | SkeletonNodeIndex.ofInternal => none
  
  | @SkeletonNodeIndex.ofLeft left right idxLeft =>
    match idxLeft with
    
    | SkeletonNodeIndex.ofLeaf => some (getRootIndex right).ofRight
    
    | SkeletonNodeIndex.ofInternal => some (getRootIndex right).ofRight
    
    
    | SkeletonNodeIndex.ofLeft idxLeftLeft =>
      idxLeftLeft.ofLeft.sibling.map (SkeletonNodeIndex.ofLeft)
    | SkeletonNodeIndex.ofRight idxLeftRight =>
      idxLeftRight.ofRight.sibling.map (SkeletonNodeIndex.ofLeft)
  | @SkeletonNodeIndex.ofRight left right idxRight =>
    match idxRight with
    | SkeletonNodeIndex.ofLeaf => some (getRootIndex left).ofLeft
    | SkeletonNodeIndex.ofInternal => some (getRootIndex left).ofLeft
    | SkeletonNodeIndex.ofLeft idxRightLeft =>
      idxRightLeft.ofLeft.sibling.map (SkeletonNodeIndex.ofRight)
    | SkeletonNodeIndex.ofRight idxRightRight =>
      idxRightRight.ofRight.sibling.map (SkeletonNodeIndex.ofRight)

noncomputable def toMvPolynomialAlgHom : P ‚Üí‚Çê[R] MvPolynomial œÉ R := aeval MvPolynomial.X

@[inline] def div [Zero T] [DecidableEq T] [ToNat T]
    (dividend divisor : Cayley T) : Cayley T :=
  
  letI fuel := (‚Üëdividend : Nat) + 1
  divNat dividend divisor fuel

def NoRedundantEntryDS (log : QueryLog (duplexSpongeChallengeOracle StmtIn U)) : Prop :=
  ‚àÄ idx : Fin log.length, ¬¨ log.redundantEntryDS idx

instance : Pow (UniPoly R) Nat := ‚ü®UniPoly.pow‚ü©

OracleSpec.DecidableEq in VCVio.OracleComp.OracleSpec

Id.run in Init.Control.Id

List.mapM' in Init.Data.List.Monadic

Fin.dfoldl in Batteries.Data.Fin.Basic

def IterType (n : ‚Ñï) : Type := dfoldl' n (fun _ => Type) (fun _ T => T √ó T) Nat


example : IterType 0 = Nat := rfl
example (n : ‚Ñï) : IterType (n + 1) = (IterType n √ó IterType n) := rfl

instance [inst : VCVCompatible Chal] : ‚àÄ i, VCVCompatible (Challenge ‚ü®!v[.V_to_P], !v[Chal]‚ü© i)
  | ‚ü®0, _‚ü© => inst

def absorbFast (sponge : DuplexSponge U C) (arr : Array U) :
    OracleComp (forwardPermutationOracle C) (DuplexSponge U C) := do
  
  let sponge1 := { sponge with squeezePos := Fin.last SpongeSize.R }
  
  
  if hEmpty : arr.isEmpty then
    return sponge1
  else
    
    
    if hFull : sponge.absorbPos = SpongeSize.R then do
      
      have : 0 < sponge.absorbPos := by admit /- proof elided -/

abbrev sqrtRate [Fintype Œπ] (deg : ‚Ñï) (domain : Œπ ‚Ü™ F) : ‚Ñù‚â•0 :=
  (LinearCode.rate (ReedSolomon.code domain deg) : ‚Ñù‚â•0).sqrt

instance instDCastPSigma : DCast ((a : Œ±) √ó' Œ≤ a) (fun a => Œ≥ a.1 a.2) where
  dcast hab c := dcast‚ÇÇ (by admit /- proof elided -/
  ) (by admit /- proof elided -/
  ) c
  dcast_id := by admit /- proof elided -/

@[reducible]
def coreInteractionOracleVerifier :=
  OracleVerifier.append (oSpec:=[]‚Çí)
    (Stmt‚ÇÅ := Statement (L := L) (‚Ñì:=‚Ñì) (SumcheckBaseContext L ‚Ñì) 0)
    (Stmt‚ÇÇ := Statement (L := L) (‚Ñì:=‚Ñì) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì))
    (Stmt‚ÇÉ := FinalSumcheckStatementOut (L:=L) (‚Ñì:=‚Ñì))
    (OStmt‚ÇÅ := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë 0)
    (OStmt‚ÇÇ := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (OStmt‚ÇÉ := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (pSpec‚ÇÅ := pSpecSumcheckFold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (pSpec‚ÇÇ := pSpecFinalSumcheckStep (L:=L))
    (V‚ÇÅ := sumcheckFoldOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (V‚ÇÇ := finalSumcheckVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))

@[inline] def toT [Zero T] (c : Cayley T) : T := c.toFun 0

BitVec.getLsb in Init.Data.BitVec.Basic

def addUnits (state : FSProverState U H R) (input : Array U) :
    Except DomainSeparatorMismatch (FSProverState U H R) :=
  match state.hashState.absorb input with
  | .ok newHashState =>
    
    
    .ok { rng := state.rng, hashState := newHashState, nargString := state.nargString }
  | .error e => .error e

def partialEval {k : ‚Ñï} (f : MvPolynomial (Fin m) F) (Œ± : Fin k ‚Üí F) (h : k ‚â§ m) :
    MvPolynomial (Fin (m - k)) F :=
  let œÜ : Fin m ‚Üí MvPolynomial (Fin (m - k)) F := fun i =>
    if h' : i.val < k then
      C (Œ± ‚ü®i.val, h'‚ü©)
    else
      let j := i.val - k
      let j' : Fin (m - k) := ‚ü®j, sorry‚ü©
      X j'
  eval‚ÇÇ C œÜ f

def pad (sz‚ÇÅ sz‚ÇÇ : Size)
    (stmt : Statement R sz‚ÇÅ)
    (matrices : MatrixIdx ‚Üí Matrix (Fin sz‚ÇÅ.m) (Fin sz‚ÇÅ.n) R)
    (wit : Witness R sz‚ÇÅ) :
    Statement R sz‚ÇÇ √ó (MatrixIdx ‚Üí Matrix (Fin sz‚ÇÇ.m) (Fin sz‚ÇÇ.n) R) √ó Witness R sz‚ÇÇ :=
  (Fin.rightpad sz‚ÇÇ.n_x 0 stmt,
    fun idx => Matrix.rightpad sz‚ÇÇ.m sz‚ÇÇ.n 0 (matrices idx),
    Fin.rightpad sz‚ÇÇ.n_w 0 wit)

instance : ‚àÄ i, SelectableType ((pSpecNonLastBlocks ùîΩq Œ≤ (œë:=œë)
  (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).Challenge i) := instSelectableTypeChallengeSeqCompose

instance [VerifierFirst pSpec] : ‚àÄ i, OracleInterface (pSpec.Message i) := isEmptyElim

noncomputable def fiber_coeff
    (i : Fin r) (steps : ‚Ñï)
    (j : Fin (‚Ñì + ùì° - i)) (elementIdx : Fin (2 ^ steps))
    (y_coeffs : Fin (‚Ñì + ùì° - (i + steps)) ‚Üí‚ÇÄ ùîΩq) : ùîΩq :=
  if hj : j.val < steps then
    if Nat.getBit (k := j) (n := elementIdx) = 0 then 0 else 1
  else y_coeffs ‚ü®j.val - steps, by admit /- proof elided -/
    ‚ü©

Module.Basis.baseChange in Mathlib.LinearAlgebra.TensorProduct.Basis

noncomputable def commitOracleReduction (i : Fin ‚Ñì) (hCR : isCommitmentRound ‚Ñì œë i) :
  OracleReduction (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) Context i.succ)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (pSpec := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) where
  prover := commitOracleProver ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i
  verifier := commitOracleVerifier ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hCR

def BacktrackSequence.Index (trace : QueryLog (duplexSpongeChallengeOracle StmtIn U))
    (state : CanonicalSpongeState U) (seq : BacktrackSequence trace state) :
    Fin trace.length √ó (Fin seq.inputState.length ‚Üí Fin trace.length) :=
  
  
  
  (‚ü®trace.findIdx sorry, sorry‚ü©, sorry)

@[reducible]
def FinalStatement (F : Type) (k : ‚Ñï) : Type := Fin (k + 1) ‚Üí F

def Œ±' (x‚ÇÄ : F) (R : F[X][X][Y]) (H_irreducible : Irreducible H) (t : ‚Ñï) : ùïÉ H :=
  Œ± x‚ÇÄ R _ (œÜ := ‚ü®H_irreducible‚ü©) t

def knowledgeStateFunction :
    (oracleVerifier oSpec OStatement).KnowledgeStateFunction init impl
    (relIn OStatement) (relOut OStatement) (rbrExtractor oSpec OStatement) where
  toFun
  | 0 => fun ‚ü®_, oracles‚ü© _ _ => oracles 0 = oracles 1
  | 1 => fun ‚ü®_, oracles‚ü© chal _ =>
    let q : Query OStatement := by admit /- proof elided -/

def Prover.addSalt (P : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec)
    (saltComp : (i : pSpec.MessageIdx) ‚Üí P.PrvState i.1.castSucc ‚Üí OracleComp oSpec (Salt i)) :
  Prover oSpec StmtIn WitIn StmtOut WitOut (pSpec.addSalt Salt) where
  PrvState := P.PrvState
  input := P.input
  sendMessage := fun i st => by admit /- proof elided -/

def snd (T : (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).Transcript k) : pSpec‚ÇÇ.Transcript ‚ü®k - m, by admit /- proof elided -/
‚ü© :=
  if hk : k ‚â§ m then
    fun i => Fin.elim0 (by admit /- proof elided -/
    )
  else
    fun i => sorry

noncomputable def finalSumcheckKnowledgeStateFunction {œÉ : Type} (init : ProbComp œÉ)
    (impl : QueryImpl []‚Çí (StateT œÉ ProbComp)) :
    (finalSumcheckVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).KnowledgeStateFunction init impl
    (relIn := roundRelation ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (ùìë := ùìë) (mp := BBF_SumcheckMultiplierParam) (Fin.last ‚Ñì))
    (relOut := finalSumcheckRelOut ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (extractor := finalSumcheckRbrExtractor ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
  where
  toFun := fun m ‚ü®stmt, oStmt‚ü© tr witMid =>
    finalSumcheckKStateProp ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (ùìë := ùìë) (tr := tr) (stmt := stmt) (witMid := witMid) (oStmt := oStmt)
  toFun_empty := fun stmt witMid => by admit /- proof elided -/

@[inline]
def ofInputOnly
    (liftWit : OuterStmtIn √ó OuterWitOut ‚Üí InnerWitIn ‚Üí OuterWitIn) :
    Witness.InvLens OuterStmtIn OuterWitIn OuterWitOut InnerWitIn OuterWitOut :=
  ‚ü®Prod.snd, liftWit‚ü©

private noncomputable def oddPart' (f : Polynomial F) : Polynomial F :=
  match f with
  | ‚ü®‚ü®supp, f, pr‚ü©‚ü© => ‚ü®‚ü®
      shift_left (erase_even supp),
      fun n => if Even n then f (n + 1) else 0, by admit /- proof elided -/
      ‚ü©‚ü©

def fst (T : (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).Transcript k) : pSpec‚ÇÅ.Transcript ‚ü®min k m, by admit /- proof elided -/
‚ü© :=
  if hk : k ‚â§ m then
    fun i => by admit /- proof elided -/

def OuterStmtIn_Test := ‚Ñ§[X] √ó ‚Ñ§[X] √ó ‚Ñ§

structure PowTwoRepr where
  two_exp : ‚Ñï
  odd_part : ‚Ñï

def outputRelation (cond : ‚àë i, (s i).1 ‚â§ n) [DecidableEq F] (Œ¥ : ‚Ñù‚â•0) :
    Set
      (
        (Statement F i.succ √ó (‚àÄ j, OracleStatement D x s i.succ j)) √ó
        Witness F s d i.succ.castSucc
      ) := sorry

def hcons {n : ‚Ñï} {Œ± : Sort u} {Œ≤ : Fin n ‚Üí Sort u} (a : Œ±) (b : (i : Fin n) ‚Üí Œ≤ i) :
    (i : Fin (n + 1)) ‚Üí Fin.vcons Œ± Œ≤ i :=
  fcons (F := id) a b

Decidable in Init.Prelude

Monoid in Mathlib.Algebra.Group.Defs

Set.Ioc in Mathlib.Order.Interval.Set.Defs

@[reducible, simp] def StmtIn : Type := R

@[inline, specialize]
def reduction : Reduction oSpec Statement Unit Statement Unit !p[] where
  prover := prover oSpec Statement
  verifier := verifier oSpec Statement pred

instance ConcreteBTField.instDCast_local : DCast ‚Ñï ConcreteBTField where
  dcast h_k_eq term_k1 := BitVec.cast (congrArg (fun n => 2 ^ n) h_k_eq) term_k1
  dcast_id := by admit /- proof elided -/

def getConst (k : ‚Ñï) (s : Fin (k + 1) ‚Üí ‚Ñï+) : OracleComp [FinalOracleStatement D x s]‚Çí F[X] :=
  OracleComp.lift
    (by admit /- proof elided -/
    )

@[ext]
structure ProtocolSpec (n : ‚Ñï) where
   
  dir : Fin n ‚Üí Direction
   
  ¬´Type¬ª : Fin n ‚Üí Type
deriving Inhabited

noncomputable def D_X (rho : ‚Ñö) (n m : ‚Ñï) : ‚Ñù := (m + 1/2) * (Real.sqrt rho) * n

noncomputable def toPoly (p : UniPoly R) : Polynomial R :=
  p.eval‚ÇÇ Polynomial.C Polynomial.X

def commitKState (i : Fin ‚Ñì) (hCR : isCommitmentRound ‚Ñì œë i) :
    (commitOracleVerifier ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      i hCR).KnowledgeStateFunction init impl
      (relIn := foldStepRelOut (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i.succ)
      (extractor := commitRbrExtractor ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) where
  toFun := fun m ‚ü®stmtIn, oStmtIn‚ü© tr witMid =>
    commitKStateProp ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (i := i) (m := m) (stmtIn := stmtIn) (witMid := witMid) (oStmtIn := oStmtIn) (mp:=mp)
  toFun_empty := fun stmtIn witMid => by admit /- proof elided -/

def computableBasisExplicit (k : ‚Ñï) (i : Fin (2 ^ k)) : ConcreteBTField k :=
  (Finset.univ : Finset (Fin k)).prod fun j =>
    if Nat.getBit (n := i.val) (k := j.val) == 1 then
      concreteTowerAlgebraMap (j.val + 1) k (by admit /- proof elided -/
      ) (Z (j.val + 1))
    else
      1

def OuterStmtOut_Test := ‚Ñ§[X] √ó ‚Ñ§[X] √ó ‚Ñ§ √ó ‚Ñ§

def oracleVerifier (i : Fin n) : OracleVerifier oSpec (StatementRound R n i.castSucc)
    (OracleStatement R n deg) (StatementRound R n i.succ) (OracleStatement R n deg) (pSpec R deg) :=
  (Simple.oracleVerifier R deg D oSpec).liftContext (oStmtLens R n deg D i)

noncomputable def funcQuotient (f : Œπ ‚Üí F) (S : Finset F) (Ans Fill : S ‚Üí F) : Œπ ‚Üí F :=
  fun x =>
    if hx : x.val ‚àà S then Fill ‚ü®x.val, hx‚ü© 
    else (f x - (ansPoly S Ans).eval x.val) / (vanishingPoly S).eval x.val

def forwardRange (n : ‚Ñï) (r : Fin (n)) (l : Fin (r.val + 1)) : List (Fin n) :=
  let len := r.val - l.val + 1
  List.ofFn (fun (k : Fin len) =>
    let val := l.val + k.val
    have h_bound : val < n := by admit /- proof elided -/
  )

def distCodewords [DecidableEq F] (U V : Matrix Œ∫ Œπ F) : ‚Ñï :=
  (Matrix.neqCols U V).card

noncomputable def foldOracleReduction (i : Fin ‚Ñì) :
  OracleReduction (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) Context i.castSucc)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (pSpec := pSpecFold (L := L)) where
  prover := foldOracleProver ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i
  verifier := foldOracleVerifier ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i

def fiberwiseClose (i : Fin ‚Ñì) (steps : ‚Ñï) [NeZero steps] (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
    (f : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      ‚ü®i, by admit /- proof elided -/
      ‚ü©) : Prop :=
  2 * fiberwiseDistance ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := i) steps
    (h_i_add_steps := h_i_add_steps) (f := f) < (BBF_CodeDistance ‚Ñì ùì° ‚ü®i + steps, by admit /- proof elided -/
    ‚ü© : ‚Ñï‚àû)

def params16 : Params where
  width := 16
  numFullRounds := 8
  numPartialRounds := 20
  internalDiagVectors := #v[
       -2,
        1,
        2,
        1 / 2,
        3,
        4,
        -1 / 2,
        -3,
        -4,
        1 / (2 ^ 8),
        1 / 8,
        1 / (2 ^ 24),
        -1 / (2 ^ 8),
        -1 / 8,
        -1 / 16,
        -1 / (2 ^ 24),
    ]
  roundConstants := rawConstants16
  width_dvd_by_4 := by admit /- proof elided -/

protected def cast (P : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec‚ÇÅ) :
    Prover oSpec StmtIn WitIn StmtOut WitOut pSpec‚ÇÇ where
  PrvState := P.PrvState ‚àò Fin.cast (congrArg (¬∑ + 1) hn.symm)
  input := P.input
  sendMessage := fun i st => do
    let ‚ü®msg, newSt‚ü© ‚Üê P.sendMessage (i.cast hn.symm (cast_symm hSpec)) st
    return ‚ü®(Message.cast_idx_symm hSpec) ‚ñ∏ msg, newSt‚ü©
  receiveChallenge := fun i st => do
    let f ‚Üê P.receiveChallenge (i.cast hn.symm (cast_symm hSpec)) st
    return fun chal => f (Challenge.cast_idx hSpec ‚ñ∏ chal)
  output := P.output ‚àò (fun st => _root_.cast (by admit /- proof elided -/
  ) st)

IntCast in Init.Data.Int.Basic

instance [Zero T] [ToNat T] : LE (Cayley T) where
  le := le

instance {i : Fin r} : DecidableEq (U ùîΩq Œ≤ i) :=

def powFiber (S : Finset Œπ) (œÜ : Œπ ‚Ü™ F) (k : ‚Ñï) (y : indexPow S œÜ k) : Finset Œπ :=
  S.filter (fun x => (œÜ x) ^ k = y)

CommSemiring in Mathlib.Algebra.Ring.Defs

def weightedDegree.{u} {F : Type u} [Semiring F] (p : F[X][Y]) (u v : ‚Ñï) : Option ‚Ñï :=
  List.max? <|
    List.map (fun n => u * (p.coeff n).natDegree + v * n) (List.range p.natDegree.succ)

PFunctor.Lens.id in ToMathlib.PFunctor.Lens.Basic

class IsRBRSound (langIn : Set StmtIn) (langOut : Set StmtOut)
    (verifier : Verifier oSpec StmtIn StmtOut pSpec) where
  rbrSoundnessError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0
  is_rbr_sound : rbrSoundness init impl langIn langOut verifier rbrSoundnessError

def mul (a b : AssocNat) : AssocNat :=
  mulNat a b.toNat

class IsSecureWithGap
    (completeRelation : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (soundRelation : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (Œµ_rbr : vPSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0)
    (vectorIOP : VectorIOP Statement OStatement Witness vPSpec A) where

   
  is_complete : vectorIOP.perfectCompleteness (pure ()) ‚ü®isEmptyElim‚ü© completeRelation

   
  is_rbr_knowledge_sound :
    OracleProof.rbrKnowledgeSoundness (pure ()) ‚ü®isEmptyElim‚ü© soundRelation vectorIOP.verifier Œµ_rbr

tail in ToMathlib.Control.Comonad.Instances

@[reducible]
def backwardPermutationOracle (Œ± : Type*) : OracleSpec Unit := Œ± ‚Üí‚Çí Œ±

@[inline, reducible]
def lift : OuterStmtIn √ó OuterWitIn ‚Üí InnerStmtOut √ó InnerWitOut ‚Üí OuterWitOut :=
  lens.toFunB

instance instDCast‚ÇÉ : DCast‚ÇÉ Nat (fun n => Fin (n + 1)) (fun n _ => ProtocolSpec n)
    (fun _ k pSpec => pSpec.Transcript k) where
  dcast‚ÇÉ h h' h'' T := Transcript.cast h
    (by admit /- proof elided -/
    )
    (by admit /- proof elided -/
    )
    T
  dcast‚ÇÉ_id := cast_id

def StateRestoration.Soundness (oSpec : OracleSpec Œπ) (StmtIn : Type)
    {n : ‚Ñï} (pSpec : ProtocolSpec n) :=
  OracleComp (oSpec ++‚Çí (srChallengeOracle StmtIn pSpec)) (StmtIn √ó pSpec.Messages)

def PowerType (n : ‚Ñï) : Type := dfoldr' n (fun _ => Type) (fun _ T => T ‚Üí T) Nat


example : PowerType 0 = Nat := rfl
example (n : ‚Ñï) : PowerType (n + 1) = (PowerType n ‚Üí PowerType n) := rfl

def factor' (n : ‚Ñï) : Option (List PrimeWithMultiplicity) := do
  let facts := List.mergeSort (‚Üê factor n)
  let groups := List.splitBy (¬∑ = ¬∑) facts
  return groups.map (fun g => ‚ü®g[0]!, g.length‚ü©)

def ratchetUnchecked [Permute C] (sponge : DuplexSponge U C) : DuplexSponge U C :=
  simulateQ' forwardPermutationOracleImpl (ratchet sponge) (by admit /- proof elided -/
  )

def commitKStateProp (i : Fin ‚Ñì) (m : Fin (1 + 1))
  (stmtIn : Statement (L := L) Context i.succ)
  (witMid : Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
  (oStmtIn : (i_1 : Fin (toOutCodewordsCount ‚Ñì œë i.castSucc)) ‚Üí
    OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc i_1)
  : Prop :=

  match m with
  | ‚ü®0, _‚ü© => 
    masterKStateProp (mp := mp) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (stmtIdx := i.succ) (oracleIdx := i.castSucc)
      (h_le := by admit /- proof elided -/
      )
      (stmt := stmtIn) (wit := witMid) (oStmt := oStmtIn)
      (localChecks := True)
  | ‚ü®1, _‚ü© => 
    let ‚ü®_, stmtOut, oStmtOut, witOut‚ü© := getCommitProverFinalOutput ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i ‚ü®stmtIn, oStmtIn, witMid‚ü©
    masterKStateProp (mp := mp) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (stmtIdx := i.succ) (oracleIdx := i.succ)
      (h_le := le_refl _)
      (stmt := stmtOut) (wit := witOut) (oStmt := oStmtOut)
      (localChecks := True)

def OracleReduction.append (R‚ÇÅ : OracleReduction oSpec Stmt‚ÇÅ OStmt‚ÇÅ Wit‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ Wit‚ÇÇ pSpec‚ÇÅ)
    (R‚ÇÇ : OracleReduction oSpec Stmt‚ÇÇ OStmt‚ÇÇ Wit‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ Wit‚ÇÉ pSpec‚ÇÇ) :
      OracleReduction oSpec Stmt‚ÇÅ OStmt‚ÇÅ Wit‚ÇÅ Stmt‚ÇÉ OStmt‚ÇÉ Wit‚ÇÉ (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ) where
  prover := Prover.append R‚ÇÅ.prover R‚ÇÇ.prover
  verifier := OracleVerifier.append R‚ÇÅ.verifier R‚ÇÇ.verifier

noncomputable def fieldToùïÉ {H : F[X][Y]} : F ‚Üí+* ùïÉ H :=
  RingHom.comp liftToFunctionField Polynomial.C

@[simp]
def ùïè (k : ‚Ñï) : ConcreteBTField (k + 1) := Z (k + 1)

DecidableEq in Init.Prelude

IsField.toField in Mathlib.Algebra.Field.IsField

noncomputable def relayOracleVerifier (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
  OracleVerifier
    (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) Context i.succ)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (pSpec := pSpecRelay) where
  verify := fun stmtIn _ => pure stmtIn
  embed := ‚ü®fun j => by admit /- proof elided -/
  ‚ü©
  hEq := fun oracleIdx => by admit /- proof elided -/

Nat.and_distrib_right in Init.Data.Nat.Bitwise.Lemmas

def testNTTBTF‚ÇÉ : Fin (2 ^ (2 + 2)) ‚Üí BTF‚ÇÉ :=

OracleSpec.OracleQuery in VCVio.OracleComp.OracleComp

@[inline, specialize]
def mulX (p : UniPoly R) : UniPoly R := p.mulPowX 1

Fin.tail in Mathlib.Data.Fin.Tuple.Basic

instance :
    ‚àÄ i, OracleInterface
          ((pSpecFold D x k s ++‚Çö FinalFoldPhase.pSpec F ++‚Çö QueryRound.pSpec D x l).Message i) :=
  instOracleInterfaceMessageAppend

Matrix.cRank in Mathlib.LinearAlgebra.Matrix.Rank

def someTypes : List Type := [Nat, String, Nat]

noncomputable def sDomainBasisVectors (i : Fin r) : Fin (‚Ñì + R_rate - i) ‚Üí L :=
  fun k => (normalizedW ùîΩq Œ≤ i).eval (Œ≤ ‚ü®i + k.val, by admit /- proof elided -/
  ‚ü©)

RatFunc.eval in Mathlib.FieldTheory.RatFunc.AsPolynomial

instance {i : ‚Ñï} : SmoothPowerOfTwo (n - i) (evalDomain D i) where
  smooth := by admit /- proof elided -/

def natCast {k : ‚Ñï} (n : ‚Ñï) : ConcreteBTField k := if n % 2 = 0 then zero else one

def finalSumcheckKnowledgeError (m : pSpecFinalSumcheckStep (L := L).ChallengeIdx) :
  ‚Ñù‚â•0 :=
  match m with
  | ‚ü®0, h0‚ü© => nomatch h0

Vector.insertIdx in Init.Data.Vector.Basic

reduceCtorEq in Lean.Meta.Tactic.Simp.BuiltinSimprocs.Core

instance : Field BTF‚ÇÉ := instFieldConcrete

instance instAlgebraTowerConcreteBTF : AlgebraTower (ConcreteBTField) where
  algebraMap := concreteTowerAlgebraMap
  commutes' := by admit /- proof elided -/

Algebra.TensorProduct.instAlgebra in Mathlib.RingTheory.TensorProduct.Basic

instance [Zero T] [ToNat T] : Mul (Cayley T) where
  mul := mul

def squeezeUnchecked [Permute C] (sponge : DuplexSponge U C) (arr : Array U) :
    DuplexSponge U C √ó Array U :=
  simulateQ' (m := Id) forwardPermutationOracleImpl (squeezeInto sponge arr) (by admit /- proof elided -/
  )

noncomputable def matching_set_at_x
  (Œ¥ : ‚Ñö)
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  (x : Fin n)
  : Finset F := @Set.toFinset _ {z : F | ‚àÉ h : z ‚àà matching_set k œâs Œ¥ u‚ÇÄ u‚ÇÅ h_gs,
    u‚ÇÄ x + z * u‚ÇÅ x = 
      (Pz (matching_set_is_a_sub_of_coeffs_of_close_proximity k h_gs h)).eval (œâs x)} sorry

Fin.insertNth in Mathlib.Data.Fin.Tuple.Basic

evalDist in VCVio.EvalDist.Basic

def dedup {Œπ : Type} (spec : OracleSpec Œπ) : SimOracle.Stateless (spec ++‚Çí spec) spec where
  impl
  | query (.inl i) t => query i t
  | query (.inr i) t => query i t

@[simp]
abbrev OracleStatement.AfterLinearCombination : R1CS.MatrixIdx ‚äï R1CS.MatrixIdx ‚äï Fin 1 ‚Üí Type :=
  Sum.elim (EvalClaim R) (OracleStatement.AfterFirstSumcheck R pp)

inductive FullData (Œ± : Type) : Skeleton ‚Üí Type
  | leaf (value : Œ±) : FullData Œ± Skeleton.leaf
  | internal {left right} (value : Œ±)
      (leftData : FullData Œ± left)
      (rightData : FullData Œ± right) :
      FullData Œ± (Skeleton.internal left right)
  deriving Repr

def subLeftFull (U : Matrix (Fin m) (Fin n) F) (c_reindex : Fin m ‚Üí Fin n) :
  Matrix (Fin m) (Fin m) F := Matrix.submatrix U id c_reindex

def disagreementSet (i : Fin ‚Ñì) (steps : ‚Ñï) [NeZero steps] (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
  (f g : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i.val + steps, by admit /- proof elided -/
    ‚ü©) :
  Set ((sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®i.val + steps, by admit /- proof elided -/
  ‚ü©) :=
  {y | f y ‚â† g y}

BitVec.extractLsb in Init.Data.BitVec.Basic

def toOracleImpl {Œπ : Type u} (v : Œπ ‚Üí Type v) [O : ‚àÄ i, OracleInterface (v i)]
    (data : ‚àÄ i, v i) : QueryImpl [v]‚Çí Id where
  impl | query i t => (O i).answer (data i) t

@[inline] def ge [Zero T] [ToNat T] (a b : Cayley T) : Prop :=
  (a : Nat) ‚â• (b : Nat)

Finsupp.onFinset in Mathlib.Data.Finsupp.Defs

def perm (cs : ConstraintSystem ùì° numWires numGates) : Equiv.Perm (Fin (3 * numGates)) := sorry

DecidablePred in Init.Prelude

@[inline]
def ofOutputOnly
    (witLift :
      OuterStmtIn √ó OuterWitIn ‚Üí InnerStmtOut √ó InnerWitOut ‚Üí OuterWitOut)
    (stmtLift : OuterStmtIn ‚Üí InnerStmtOut ‚Üí OuterStmtOut) :
    Context.Lens OuterStmtIn OuterStmtOut OuterStmtIn InnerStmtOut
                OuterWitIn OuterWitOut OuterWitIn InnerWitOut where
  wit := Witness.Lens.ofOutputOnly witLift
  stmt := Statement.Lens.ofOutputOnly stmtLift

@[ext]
structure Equiv {m n : ‚Ñï} (pSpec : ProtocolSpec m) (pSpec' : ProtocolSpec n) where
  round_eq : m = n
  dir_eq : ‚àÄ i, pSpec.dir i = pSpec'.dir (Fin.cast round_eq i)
  typeEquiv : ‚àÄ i, pSpec.¬´Type¬ª i ‚âÉ pSpec'.¬´Type¬ª (Fin.cast round_eq i)

def indexPow (S : Finset Œπ) (œÜ : Œπ ‚Ü™ F) (k : ‚Ñï) : Finset F :=
  S.image (fun x => (œÜ x) ^ k)

Polynomial.support in Mathlib.Algebra.Polynomial.Basic

@[reducible]
def permutationOracle (Œ± : Type*) : OracleSpec PermuteDir :=
  forwardPermutationOracle Œ± ++‚Çí backwardPermutationOracle Œ±

@[inline, specialize]
def oracleProver : OracleProver oSpec
    Statement OStatement (‚àÄ i, Witness i)
    Statement (OStatement ‚äï·µ• Witness) Unit
    (oraclePSpec Witness) where
  PrvState := fun _ => (Statement √ó (‚àÄ i, OStatement i)) √ó (‚àÄ i, Witness i)
  input := id
  sendMessage | ‚ü®0, _‚ü© => fun ‚ü®stmt, wit‚ü© => pure (wit, ‚ü®stmt, wit‚ü©)
  
  receiveChallenge | ‚ü®0, h‚ü© => nomatch h
  output := fun ‚ü®‚ü®stmt, oStmt‚ü©, wit‚ü© => pure (‚ü®stmt, Sum.rec oStmt wit‚ü©, ())

@[reducible]
def scalarFieldSize : Nat :=
  21888242871839275222246405745257275088548364400416034343698204186575808495617

def InternalData.rightSubtree {Œ± : Type} {s_left s_right : Skeleton}
    (tree : InternalData Œ± (Skeleton.internal s_left s_right)) :
    InternalData Œ± s_right :=
  match tree with
  | InternalData.internal _ _left right =>
    right

@[simp]
instance AlgebraTower.toIsScalarTower (a : AlgebraTower C) {i j k : Œπ}
    (h1 : i ‚â§ j) (h2 : j ‚â§ k) :
    letI : Algebra (C i) (C j) :=

@[reducible, simp]
def relOut : Set ((StmtOut OStatement √ó ‚àÄ i, OStmtOut OStatement i) √ó WitOut) :=
  { ‚ü®‚ü®q, oStmt‚ü©, ()‚ü© | answer (oStmt 0) q = answer (oStmt 1) q }

def halfNumFullRounds : Nat := params.numFullRounds / 2

Mul in Init.Prelude

instance {k : ‚Ñï} : IntCast (ConcreteBTField k) where
  intCast n:= intCast n

noncomputable def listDecodingCollisionProbability
  (œÜ : Œπ ‚Ü™ F) (f : Œπ ‚Üí F) (Œ¥ : ‚Ñù) (s degree : ‚Ñï)
  (h_nonempty : Nonempty (domainComplement œÜ)) : ENNReal :=
  Pr_{let r ‚Üê$·µñ (Fin s ‚Üí domainComplement œÜ)}[ ‚àÉ (u u' : code œÜ degree),
                                    u.val ‚â† u'.val ‚àß
                                    u.val ‚àà relHammingBall (code œÜ degree) f Œ¥ ‚àß
                                    u'.val ‚àà relHammingBall (code œÜ degree) f Œ¥ ‚àß
                                    ‚àÄ i : Fin s,
                                    let uPoly := decodeLT u
                                    let uPoly' := decodeLT u'
                                    (uPoly : F[X]).eval (r i).1
                                      = (uPoly' : F[X]).eval (r i).1
                                    ]

CanLift in Mathlib.Tactic.Lift

noncomputable def polyFold
  [DecidableEq F] (fPoly : Polynomial F)
  (k : ‚Ñï) (hk0 : 0 < k) (hkfin : k < Fintype.card F)
  (r : F) : Polynomial F :=
    let qPoly : Polynomial F := Polynomial.X ^ k
    let hdeg_q_min : qPoly.natDegree > 0 := sorry
    let hdeg_q_max : qPoly.natDegree < Fintype.card F := sorry
  
    let Q : MvPolynomial (Fin 2) F := polyQ fPoly qPoly
    MvPolynomial.eval‚ÇÇHom
      (Polynomial.C : F ‚Üí+* Polynomial F)
      (fun i : Fin 2 => if i = 0 then Polynomial.X else Polynomial.C r) Q

def deriveTranscriptSR {Œπ : Type} {oSpec : OracleSpec Œπ} {StmtIn : Type}
    (stmt : StmtIn) (k : Fin (n + 1)) (messages : pSpec.MessagesUpTo k) :
    OracleComp (oSpec ++‚Çí fsChallengeOracle StmtIn pSpec) (pSpec.Transcript k) := do
  deriveTranscriptSRAux stmt k messages (Fin.last k)

alias deriveTranscriptFS := deriveTranscriptSR

@[reducible]
def get {Œ±s : List (Type u)} : HList Œ±s ‚Üí (n : Fin Œ±s.length) ‚Üí Œ±s.get n
  | x ::‚Çï _, ‚ü®0, _‚ü© => x
  | _ ::‚Çï xs, ‚ü®n+1, h‚ü© => xs.get ‚ü®n, Nat.lt_of_succ_lt_succ h‚ü©

abbrev MatrixSubmodule.{u, v, w} (Œ∫ : Type u) [Fintype Œ∫] (Œπ : Type v) [Fintype Œπ]
                                 (F : Type w) [Semiring F] : Type (max u v w) :=
  Submodule F (Matrix Œ∫ Œπ F)

OracleComp.neverFailsWhen in VCVio.OracleComp.Traversal

noncomputable def queryKnowledgeStateFunction {œÉ : Type} (init : ProbComp œÉ)
    (impl : QueryImpl []‚Çí (StateT œÉ ProbComp)) :
  (queryOracleVerifier ùîΩq Œ≤ (œë:=œë) Œ≥_repetitions).KnowledgeStateFunction init impl
  (relIn := finalSumcheckRelOut ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
  (relOut := acceptRejectOracleRel)
  (extractor := queryRbrExtractor ùîΩq Œ≤ (œë:=œë) Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)) where
  toFun := fun m ‚ü®stmt, oStmt‚ü© tr witMid =>
    queryKStateProp ùîΩq Œ≤ (œë:=œë) (Œ≥_repetitions:=Œ≥_repetitions)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (m:=m) (tr:=tr) (stmt:=stmt) (witMid:=witMid) (oStmt:=oStmt)
  toFun_empty := fun stmt witMid => by admit /- proof elided -/

def minDist [DecidableEq F] (IC : MatrixSubmodule Œ∫ Œπ F) : ‚Ñï :=
  sInf { d : ‚Ñï | ‚àÉ U ‚àà IC, ‚àÉ V ‚àà IC, distCodewords U V = d }

List.max in Init.Data.List.Basic

List.cons in Init.Prelude

structure Selector (ùì° : Type*) where
   
  qL : ùì°
   
  qR : ùì°
   
  qO : ùì°
   
  qM : ùì°
   
  qC : ùì°
deriving DecidableEq

structure ParamConditions (P : Params Œπ F) where
  h_deg : ‚àÉ k : ‚Ñï, P.deg = 2^k
  h_foldingParams : ‚àÄ i : Fin (M + 1), ‚àÉ k : ‚Ñï, (P.foldingParam i) = 2^k
  h_deg_ge : P.deg ‚â• ‚àè i : Fin (M + 1), (P.foldingParam i)
  h_smooth : ‚àÄ i : Fin (M + 1), Smooth (P.œÜ i)
  h_smooth_le : ‚àÄ i : Fin (M + 1), Fintype.card (Œπ i) ‚â§ (degree Œπ P i)
  h_repeatP_le : ‚àÄ i : Fin (M + 1), P.repeatParam i + 1 ‚â§ (degree Œπ P i)

Function.onFun in Mathlib.Logic.Function.Defs

@[reducible, simp] def OStmtAfterRandomQuery : Unit ‚äï Unit ‚Üí Type := fun _ => R‚¶É‚â§ deg‚¶Ñ[X]

protected def Verifier.id : Verifier oSpec Statement Statement !p[] where
  verify := fun stmt _ => pure stmt

instance [inst : ‚àÄ i, SelectableType (pSpec.Challenge i)] :
    ‚àÄ i, SelectableType ((pSpec.addSalt Salt).Challenge i) :=
  fun i => by admit /- proof elided -/

instance : Unique (MessageIdx ‚ü®!v[.P_to_V], !v[Msg]‚ü©) where
  default := ‚ü®0, by admit /- proof elided -/
  ‚ü©
  uniq := fun i => by admit /- proof elided -/

instance : HListRepr (HList []) where
  repr := fun _ => ""

abbrev LinearCode.{u, v} (Œπ : Type u) [Fintype Œπ] (F : Type v) [Semiring F] : Type (max u v) :=
  Submodule F (Œπ ‚Üí F)

@[reducible, simp] def WitIn := Unit

@[reducible]
def oracleReduction : OracleReduction oSpec
    (StatementRound R n 0) (OracleStatement R n deg) Unit
    (StatementRound R n (.last n)) (OracleStatement R n deg) Unit
    (pSpec R deg n) :=
  OracleReduction.seqCompose (oSpec := oSpec)
    (Stmt := StatementRound R n)
    (OStmt := fun _ => OracleStatement R n deg)
    (Wit := fun _ => Unit)
    (pSpec := fun _ => SingleRound.pSpec R deg)
    (SingleRound.oracleReduction R n deg D oSpec)

instance : Inhabited (UniPolyC R) := ‚ü®#[], Trim.canonical_empty‚ü©

Subspace in Mathlib.Algebra.Module.Submodule.Basic

instance : ‚àÄ i, OracleInterface (OracleStatement R pp i) :=
  fun i => {
    Query := (Fin pp.‚Ñì_m ‚Üí R) √ó (Fin pp.‚Ñì_n ‚Üí R)
    Response := R
    answer := fun matrix ‚ü®x, y‚ü© => matrix.toMLE ‚∏®C ‚àò x‚∏© ‚∏®y‚∏©
  }

def coeffsToBitVec {n : ‚Ñï} (coeffs : List (ZMod 2)) : BitVec n :=
  let val := List.foldr (fun c acc => acc * 2 + c.val) 0 (coeffs.take n)
  BitVec.ofNat n val

instance : LawfulToNat Nat where
  toNat_zero := rfl
  toNat_succ := fun _ => rfl

structure KnowledgeStateFunction
    (relIn : Set (StmtIn √ó WitIn)) (relOut : Set (StmtOut √ó WitOut))
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    {WitMid : Fin (n + 1) ‚Üí Type}
    (extractor : Extractor.RoundByRound oSpec StmtIn WitIn WitOut pSpec WitMid)
    where
   
  toFun : (m : Fin (n + 1)) ‚Üí StmtIn ‚Üí Transcript m pSpec ‚Üí WitMid m ‚Üí Prop
   
  toFun_empty : ‚àÄ stmtIn witMid,
    ‚ü®stmtIn, cast extractor.eqIn witMid‚ü© ‚àà relIn ‚Üî toFun 0 stmtIn default witMid
   
  toFun_next : ‚àÄ m, pSpec.dir m = .P_to_V ‚Üí
    ‚àÄ stmtIn tr msg witMid, toFun m.succ stmtIn (tr.concat msg) witMid ‚Üí
      toFun m.castSucc stmtIn tr (extractor.extractMid m stmtIn (tr.concat msg) witMid)
   
  toFun_full : ‚àÄ stmtIn tr witOut,
    [fun stmtOut => (stmtOut, witOut) ‚àà relOut
    | do (simulateQ impl (verifier.run stmtIn tr)).run' (‚Üê init)] > 0 ‚Üí
    toFun (.last n) stmtIn tr (extractor.extractOut stmtIn tr witOut)

instance [h : VerifierFirst pSpec] : IsEmpty (pSpec.MessageIdx) where
  false | ‚ü®0, h'‚ü© => by admit /- proof elided -/

noncomputable def fromRowGenMat [Semiring F] (G : Matrix Œ∫ Œπ F) : LinearCode Œπ F :=
  LinearMap.range G.vecMulLinear

def erase_odd (s : Finset ‚Ñï) : Finset ‚Ñï := s.filter Even

noncomputable def toMLE (A : Matrix (Fin (2 ^ m)) (Fin (2 ^ n)) R) : R[X Fin n][X Fin m] :=
  MLE' (MLE' ‚àò A)

protected def cast (R : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec‚ÇÅ) :
    OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec‚ÇÇ where
  prover := R.prover.cast hn hSpec
  verifier := R.verifier.cast hn hSpec hO‚Çò

instance {k : ‚Ñï} : NatCast (ConcreteBTField k) where
  natCast n:= natCast n

@[reducible]
def Witness (F : Type) [NonBinaryField F] {k : ‚Ñï}
    (s : Fin (k + 1) ‚Üí ‚Ñï+) (d : ‚Ñï+) (i : Fin (k + 2)) :=
  F‚¶É< 2^((‚àë j', (s j').1) - (‚àë j' ‚àà finRangeTo i.1, (s j').1)) * d‚¶Ñ[X]

instance [O‚Çò : ‚àÄ i, OracleInterface (pSpec.Message i)] :
    ‚àÄ i, OracleInterface ((pSpec.addSalt Salt).Message i) :=
  fun i => {
    Query := (O‚Çò i).Query
    Response := (O‚Çò i).Response
    answer := fun msg => (O‚Çò i).answer (by admit /- proof elided -/
      )
  }

Fin.addCases in Init.Data.Fin.Lemmas

absurd in Init.Prelude

structure BinaryTowerResult (F : Type _) (k : ‚Ñï) where
  vec : (List.Vector F (k + 1))
  instField : (Field F)
  instFintype : Fintype F
  specialElement : F
  specialElementNeZero : NeZero specialElement
  firstElementOfVecIsSpecialElement [Inhabited F] : vec.1.headI = specialElement
  instIrreduciblePoly : (Irreducible (p := (definingPoly specialElement)))
  sumZeroIffEq : ‚àÄ (x y : F), x + y = 0 ‚Üî x = y
  fieldFintypeCard : Fintype.card F = 2^(2^k)
  traceMapEvalAtRootsIs1 : TraceMapProperty F specialElement k

def zeroCheckVirtualPolynomial (ùï© : Statement.AfterFirstMessage R pp)
    
    (oStmt : ‚àÄ i, OracleStatement.AfterFirstMessage R pp i) :
      MvPolynomial (Fin pp.‚Ñì_m) R :=
  letI ùï´ := R1CS.ùï´ ùï© (oStmt (.inr 0))
  ‚àë x : Fin (2 ^ pp.‚Ñì_m),
    (eqPolynomial (finFunctionFinEquiv.symm x : Fin pp.‚Ñì_m ‚Üí R)) *
      C ((oStmt (.inl .A) *·µ• ùï´) x * (oStmt (.inl .B) *·µ• ùï´) x - (oStmt (.inl .C) *·µ• ùï´) x)

instance instTestLensComplete : testLens.IsComplete
      outerRelIn_Test innerRelIn_Test outerRelOut_Test innerRelOut_Test
      (fun ‚ü®‚ü®p, q, _‚ü©, _‚ü© ‚ü®‚ü®f, _‚ü©, _‚ü© => p * q = f) where
  proj_complete := fun ‚ü®p, q, t‚ü© () hRelIn => by admit /- proof elided -/

Mathlib.Meta.NormNum.mkOfNat in Mathlib.Tactic.NormNum.Result

instance : ‚àÄ j, OracleInterface ((pSpecRelay).Message j)
  | ‚ü®x, hj‚ü© => by admit /- proof elided -/

instance instFieldConcrete {k : ‚Ñï} : Field (ConcreteBTField k) :=
  mkFieldInstance (getBTFResult k).toConcreteBTFieldProps

noncomputable def linearEquivMvPolynomialDeg1 : MlPoly R n ‚âÉ‚Çó[R] R‚¶É‚â§ 1‚¶Ñ[X Fin n] :=
  { toEquiv := equivMvPolynomialDeg1
    map_add' := by admit /- proof elided -/

@[reducible, inline, specialize]
def UniPoly (R : Type*) := Array R

noncomputable def finalSumcheckRbrExtractor :
  Extractor.RoundByRound []‚Çí
    (StmtIn := (Statement (L := L) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì)) √ó (‚àÄ j, OracleStatement ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë  (Fin.last ‚Ñì) j))
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì))
    (WitOut := Unit)
    (pSpec := pSpecFinalSumcheckStep (L := L))
    (WitMid := FinalSumcheckWit (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì)) where
  eqIn := rfl
  extractMid := fun m ‚ü®stmtMid, oStmtMid‚ü© trSucc witMidSucc => by admit /- proof elided -/
    | none => 
      exact dummyLastWitness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
    | some tpoly =>
      
      exact {
        t := tpoly,
        H := projectToMidSumcheckPoly (L := L) (‚Ñì := ‚Ñì) (t := tpoly)
          (m := BBF_SumcheckMultiplierParam.multpoly stmtMid.ctx)
          (i := Fin.last ‚Ñì) (challenges := stmtMid.challenges),
        f := getMidCodewords ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) tpoly stmtMid.challenges
      }
  extractOut := fun ‚ü®stmtIn, oStmtIn‚ü© tr witOut => ()

Polynomial.mapRingHom in Mathlib.Algebra.Polynomial.Eval.Defs

def shift_left (s : Finset ‚Ñï) : Finset ‚Ñï :=
  s.filterMap
    (fun n => match n with
      | 0 => .none
      | n + 1 => .some n
      )
    (by admit /- proof elided -/
    )

abbrev FunEquiv F Œ± Œ≤ := DFunEquiv F Œ± fun _ => Œ≤

def totalNumPermQueries : Nat :=
  pSpec.totalNumPermQueriesMessage + pSpec.totalNumPermQueriesChallenge

def verifier (i : Fin n) : Verifier oSpec
    (StatementRound R n i.castSucc √ó (‚àÄ i, OracleStatement R n deg i))
    (StatementRound R n i.succ √ó (‚àÄ i, OracleStatement R n deg i)) (pSpec R deg) :=
  (Simple.verifier R deg D oSpec).liftContext (oStmtLens R n deg D i)

instance inhabited [Inhabited R] : Inhabited (MlPoly R n) :=

Algebra.TensorProduct.instCommSemiring in Mathlib.RingTheory.TensorProduct.Basic

Fin.addNat in Init.Data.Fin.Basic

noncomputable def weight_Œõ_over_ùí™ {H : F[X][Y]} (f : ùí™ H) (D : ‚Ñï)
  : WithBot ‚Ñï := weight_Œõ (canonicalRepOfùí™ f) H D

def finalSumcheckKStateProp {m : Fin (1 + 1)} (tr : Transcript m (pSpecFinalSumcheckStep (L := L)))
    (stmt : Statement (L := L) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì))
    (witMid : FinalSumcheckWit (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) m)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì) j) : Prop :=
  match m with
  | ‚ü®0, _‚ü© => 
    masterKStateProp ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (mp := BBF_SumcheckMultiplierParam)
      (stmtIdx := Fin.last ‚Ñì) (oracleIdx := Fin.last ‚Ñì) (h_le := le_refl _)
      (stmt := stmt) (wit := witMid) (oStmt := oStmt) (localChecks := True)
  | ‚ü®1, _‚ü© => 
    let tr_so_far := (pSpecFinalSumcheckStep (L := L)).take 1 (by admit /- proof elided -/
    )
    let i_msg0 : tr_so_far.MessageIdx := ‚ü®‚ü®0, by admit /- proof elided -/
    ‚ü©, rfl‚ü©
    let c : L := (ProtocolSpec.Transcript.equivMessagesChallenges (k := 1)
      (pSpec := pSpecFinalSumcheckStep (L := L)) tr).1 i_msg0

    let stmtOut : FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì) := {
      ctx := stmt.ctx,
      sumcheck_target := stmt.sumcheck_target,
      challenges := stmt.challenges,
      final_constant := c
    }

    let sumcheckFinalCheck : Prop := stmt.sumcheck_target = eqTilde r stmt.challenges * c
    let finalFoldingProp := finalNonDoomedFoldingProp ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (h_le := by admit /- proof elided -/
        ) (input := ‚ü®stmtOut, oStmt‚ü©)

    sumcheckFinalCheck ‚àß finalFoldingProp 

structure WireIndices (numWires : ‚Ñï) where
   
  a : Fin numWires
   
  b : Fin numWires
   
  c : Fin numWires
deriving DecidableEq

@[inline, reducible]
def lift : (OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i)) √ó OuterWitIn ‚Üí
    (InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i)) √ó InnerWitOut ‚Üí
    (OuterStmtOut √ó (‚àÄ i, OuterOStmtOut i)) √ó OuterWitOut :=
  fun ctxIn ctxOut => ‚ü®lens.stmt.lift ctxIn.1 ctxOut.1, lens.wit.lift ctxIn ctxOut‚ü©

@[reducible, inline]
instance instMvPolynomial : OracleInterface (R[X œÉ]) where
  Query := œÉ ‚Üí R
  Response := R
  answer := fun poly point => eval point poly

Subsingleton in Init.Core

def InternalData.leftSubtree {Œ± : Type} {s_left s_right : Skeleton}
    (tree : InternalData Œ± (Skeleton.internal s_left s_right)) :
    InternalData Œ± s_left :=
  match tree with
  | InternalData.internal _ left _right =>
    left

PFunctor in Mathlib.Data.PFunctor.Univariate.Basic

def LeafData.get {s} {Œ± : Type}
    (tree : LeafData Œ± s) (idx : SkeletonLeafIndex s) : Œ± :=
  match tree, idx with
  | LeafData.leaf value, SkeletonLeafIndex.ofLeaf => value
  | LeafData.internal left _, SkeletonLeafIndex.ofLeft idxLeft =>
    LeafData.get left idxLeft
  | LeafData.internal _ right, SkeletonLeafIndex.ofRight idxRight =>
    LeafData.get right idxRight

instance [IsSingleRound pSpec] : Unique (pSpec.ChallengeIdx) where
  default := ‚ü®1, by admit /- proof elided -/
  ‚ü©
  uniq := fun ‚ü®i, hi‚ü© => by admit /- proof elided -/

List.Vector.nil in Mathlib.Data.Vector.Defs

finProdFinEquiv in Mathlib.Logic.Equiv.Fin.Basic

ENat.toNat in Mathlib.Data.ENat.Basic

def pSpecCoreInteraction := (pSpecSumcheckFold ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)) ++‚Çö
  (pSpecFinalSumcheckStep (L:=L))

@[simp]
def oCtxLens (i : Fin n) : OracleContext.Lens
    (StatementRound R n i.castSucc) (StatementRound R n i.succ) (Simple.StmtIn R) (Simple.StmtOut R)
    (OracleStatement R n deg) (OracleStatement R n deg)
    (Simple.OStmtIn R deg) (Simple.OStmtOut R deg)
    Unit Unit Unit Unit where
  wit := Witness.Lens.trivial
  stmt := oStmtLens R n deg D i

def removeNth (p : Fin (n + 1)) (s : Fin (n + 1) ‚Üí‚ÇÄ M) : Fin n ‚Üí‚ÇÄ M :=
  Finsupp.equivFunOnFinite.symm (Fin.removeNth p s : Fin n ‚Üí M)

Module.Basis.mk in Mathlib.LinearAlgebra.Basis.Basic

def Oracle.containsCache {Œπ : Type} {spec : OracleSpec Œπ}
    (f : spec.FunctionType) (cache : spec.QueryCache) :
    Prop :=
  ‚àÄ i q r, cache i q = some r ‚Üí f i q = r

def equivMonomialLagrangeRepr : MlPoly R n ‚âÉ MlPolyEval R n where
  toFun := monoToLagrange n
  invFun := lagrangeToMono n
  left_inv v := by admit /- proof elided -/

@[reducible, simp] def WitIn := Unit

inductive Data (Œ± : Type) :
    {n : ‚Ñï} ‚Üí {ar : Fin n ‚Üí ‚Ñï} ‚Üí Skeleton n ar ‚Üí Type where
  | leaf {ar0 : Fin 0 ‚Üí ‚Ñï} (value : Œ±) :
      Data Œ± (Skeleton.leaf (ar0 := ar0))
  | node {n : ‚Ñï} {ar : Fin (n+1) ‚Üí ‚Ñï}
      {children : Fin (ar 0) ‚Üí
        Skeleton n (fun i => ar i.succ)}
      (value : Œ±)
      (childrenData : (i : Fin (ar 0)) ‚Üí
        Data Œ± (children i)) :
      Data Œ± (Skeleton.node children)

Fin.modNat in Batteries.Data.Fin.Basic

class ProverLast (pSpec : ProtocolSpec n) [inst : NeZero n] where
  prover_last' : pSpec.dir ‚ü®n - 1, by admit /- proof elided -/
  ‚ü© = .P_to_V

Or.inr in Init.Prelude

@[inline, reducible]
def lift : OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i) ‚Üí InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i) ‚Üí
    OuterStmtOut √ó (‚àÄ i, OuterOStmtOut i) :=
  lens.toFunB

def binary_tower_inductive_step
  (k : Nat)
  (prevBTField : Type _) [Field prevBTField]
  (prevBTResult : BinaryTowerResult prevBTField k)
: Œ£' (F : Type _), BinaryTowerInductiveStepResult (k:=k) (prevBTField:=prevBTField)
  (prevBTResult:=prevBTResult) (prevPoly:=definingPoly (F:=prevBTField)
    (instField:=prevBTResult.instField) (s:=prevBTResult.specialElement)) (F:=F)
  (instPrevBTFieldIsField:=prevBTResult.instField) :=

AddGroup in Mathlib.Algebra.Group.Defs

def toEvalsZeroOne (p : MvPolynomial œÉ R) : (œÉ ‚Üí Fin 2) ‚Üí R :=
  fun x => eval (x : œÉ ‚Üí R) p

Quotient.lift‚ÇÇ in Init.Core

Quotient in Init.Core

def twoLevelData {Œ±} (k0 k1 : ‚Ñï)
    (root : Œ±)
    (lvl1 : Fin k0 ‚Üí Œ±)
    (lvl2 : (i : Fin k0) ‚Üí Fin k1 ‚Üí Œ±) :
    ArityTree.Data Œ± (twoLevelSkel k0 k1) :=

@[reducible]
def matchSize (a b : Array Œ±) (unit : Œ±) : Array Œ± √ó Array Œ± :=
  (a.rightpad (b.size) unit, b.rightpad (a.size) unit)

local instance : Fintype F := Fintype.ofFinite F

instance {i : Fin ‚Ñì} :
    ‚àÄ j, OracleInterface ((pSpecFoldCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i).Message j) :=
  instOracleInterfaceMessageAppend (pSpec‚ÇÅ := pSpecFold (L := L))
    (pSpec‚ÇÇ := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)

def dfoldlM' (n : ‚Ñï) (Œ± : Fin (n + 1) ‚Üí Type u)
    (f : (i : Fin n) ‚Üí Œ± i.castSucc ‚Üí m (Œ± i.succ)) (init : Œ± 0) : m (Œ± (last n)) :=
  match n with
  | 0 => pure init
  | n + 1 => do
    let x ‚Üê dfoldlM' n (Œ± ‚àò castSucc) (fun i => f i.castSucc) init
    f (last n) x

@[reducible]
def reduction : Reduction oSpec StmtIn WitIn StmtOut WitOut !p[] where
  prover := prover mapStmt mapWit
  verifier := verifier mapStmt

def Adversary (Œπ : Type) (G : Type) (p : ‚Ñï) (bitLength : ‚Ñï) (Œ± : Type) : Type _ :=
  ReaderT (GroupValTable Œπ G)
    (OracleComp (GroupOpOracle Œπ ++‚Çí GroupExpOracle Œπ p ++‚Çí
      GroupEqOracle Œπ ++‚Çí GroupEncodeOracle Œπ bitLength))
    (List Œπ √ó Œ±)

@[reducible]
def MlPoly (R : Type*) (n : ‚Ñï) := Vector R (2 ^ n) 

IsCyclic in Mathlib.Algebra.Group.Defs

MvPolynomial.eval‚ÇÇ in Mathlib.Algebra.MvPolynomial.Eval

IsLinearMap in Mathlib.Algebra.Module.LinearMap.Defs

noncomputable def generateOpening [Fact (Nat.Prime p)] (srs : Vector G‚ÇÅ (n + 1))
    (coeffs : Fin (n + 1) ‚Üí ZMod p) (z : ZMod p) : G‚ÇÅ :=
  letI poly : degreeLT (ZMod p) (n + 1) := (degreeLTEquiv (ZMod p) (n + 1)).invFun coeffs
  letI q : degreeLT (ZMod p) (n + 1) :=
    ‚ü®Polynomial.div (poly.val - C (poly.val.eval z)) (X - C z), by admit /- proof elided -/
      ‚ü©
  commit srs (degreeLTEquiv (ZMod p) (n + 1) q)

Polynomial in Mathlib.Algebra.Polynomial.Basic

def SkeletonNodeIndex.rightChild {s : Skeleton} (idx : SkeletonNodeIndex s) :
    Option (SkeletonNodeIndex s) :=
  match idx with
  | SkeletonNodeIndex.ofLeaf => none
  | @SkeletonNodeIndex.ofInternal left right =>
    some (SkeletonNodeIndex.ofRight (getRootIndex right))
  | SkeletonNodeIndex.ofLeft idxLeft =>
    idxLeft.rightChild.map (SkeletonNodeIndex.ofLeft)
  | SkeletonNodeIndex.ofRight idxRight =>
    idxRight.rightChild.map (SkeletonNodeIndex.ofRight)

@[inline] def zero : AssocNat :=
  ‚ü®id, by admit /- proof elided -/
  ‚ü©

@[inline]
abbrev concat {m : Fin n} (msg : pSpec.¬´Type¬ª m) (T : Transcript m.castSucc pSpec) :
    Transcript m.succ pSpec :=
  Fin.snoc T msg

@[reducible, inline, specialize]
def challengeOracleInterfaceSR (StmtIn : Type) (pSpec : ProtocolSpec n) :
    ‚àÄ i, OracleInterface (pSpec.Challenge i) := fun i =>
  { Query := StmtIn √ó pSpec.MessagesUpTo i.1.castSucc
    Response := pSpec.Challenge i
    answer := fun c _ => c }

alias challengeOracleInterfaceFS := challengeOracleInterfaceSR

noncomputable def novelPolynomialBasis (‚Ñì : Nat) (h_‚Ñì : ‚Ñì ‚â§ r) :
  Basis (Fin (2^‚Ñì)) (R := L) (M := L‚¶É<2^‚Ñì‚¶Ñ[X]) :=

def FullData.Equiv {Œ±} (s : Skeleton) :
    FullData Œ± s ‚âÉ InternalData Œ± s √ó LeafData Œ± s :=

def line [Ring F] (u v : Œπ ‚Üí F) : AffineSubspace F (Œπ ‚Üí F) :=
  affineSpan _ {u, v}

def sumExceptFirst (n : ‚Ñï) (D : Fin n ‚Üí Finset R) :
    MvPolynomial (Fin (n + 1)) R ‚Üí‚Çó[R] Polynomial R :=

def computeInitialSumcheckPoly (t : MultilinearPoly L ‚Ñì)
    (m : MultilinearPoly L ‚Ñì) : MultiquadraticPoly L ‚Ñì :=
  ‚ü®m * t, by
    rw [MvPolynomial.mem_restrictDegree_iff_degreeOf_le]
    intro i
    have h_t_deg: degreeOf i t.val ‚â§ 1 :=
      degreeOf_le_iff.mpr fun term a ‚Ü¶ (t.property) a i
    have h_m_deg: degreeOf i m.val ‚â§ 1 :=
      degreeOf_le_iff.mpr fun term a ‚Ü¶ (m.property) a i
    calc
      _ ‚â§ (degreeOf i m.val) + (degreeOf i t.val) :=
        degreeOf_mul_le i m.val t.val
      _ ‚â§ 2 :=

@[reducible]
def rateSegment (state : CanonicalSpongeState U) : Vector U SpongeSize.R :=
  
  (Vector.take state SpongeSize.R).cast (by admit /- proof elided -/
  )

instance instNatPow {n : ‚Ñï} : NatPow (CNat n) := match n with
  | 0 => by admit /- proof elided -/
  | .succ n => by admit /- proof elided -/

def divByMonic [Field R] (p : UniPoly R) (q : UniPoly R) :
    UniPoly R :=
  (divModByMonicAux p q).1

def domain (n : ‚Ñï) (i : ‚Ñï) : Fin (2 ^ (n - i)) ‚Üí evalDomain D i :=
  fun j => ‚ü®(DIsCyclicC.gen ^ (2 ^ i)) ^ j.1, by admit /- proof elided -/
  ‚ü©

instance instVector : OracleInterface (Vector Œ± n) where
  Query := Fin n
  Response := Œ±
  answer := fun vec i => vec[i]

instance [LawfulBEq R] : AddCommGroup (UniPolyC R) where
  add_assoc := add_assoc
  zero_add := zero_add
  add_zero := add_zero
  add_comm := add_comm
  neg_add_cancel := neg_add_cancel
  nsmul := nsmul 
  nsmul_zero := nsmul_zero
  nsmul_succ := nsmul_succ
  zsmul := zsmulRec 

instance : SpongeUnit UInt8 where

inductive ScalarVectorOp where | scale

def accepts (x : Fin numWires ‚Üí ùì°) (g : Gate ùì° numWires) : Prop :=
  g.eval x = 0

def dummyLastWitness :
    Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì) := {
  t := ‚ü®0, by admit /- proof elided -/
  ‚ü©,
  H := ‚ü®0, by admit /- proof elided -/
  ‚ü©,
  f := fun _ => 0
}

structure Context.Lens (OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                          OuterWitIn OuterWitOut InnerWitIn InnerWitOut : Type) where
  stmt : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
  wit : Witness.Lens OuterStmtIn InnerStmtOut OuterWitIn OuterWitOut InnerWitIn InnerWitOut

OracleSpec.QueryCache in VCVio.OracleComp.QueryTracking.Structures

def queryCodeword (j : Fin (toOutCodewordsCount ‚Ñì œë (Fin.last ‚Ñì)))
    (point : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®j.val * œë,
      by admit /- proof elided -/
          ‚ü©) :
  OracleComp ([OracleStatement ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (
  Fin.last ‚Ñì)]‚Çí) L :=
      OracleComp.lift <| by
        simpa using
          OracleSpec.query
            (spec := [OracleStatement ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì)]‚Çí)
            ‚ü®j, by admit /- proof elided -/
            ‚ü©
            (by admit /- proof elided -/
            )

def outputRelation (cond : ‚àë i, (s i).1 ‚â§ n) [DecidableEq F] (Œ¥ : ‚Ñù‚â•0) :
    Set
      (
        (FinalStatement F k √ó ‚àÄ j, FinalOracleStatement D x s j) √ó
        Witness F s d (Fin.last (k + 1))
      )
  := FinalFoldPhase.outputRelation D x s d cond Œ¥

def AlgebraTowerEquiv.toAlgebraOverLeft (e : AlgebraTowerEquiv A B) (i j : Œπ)
    (h : i ‚â§ j) : Algebra (A i) (B j) :=

def MLEEquivFin {n : ‚Ñï} : R‚¶É‚â§ 1‚¶Ñ[X (Fin n)] ‚âÉ (Fin (2 ^ n) ‚Üí R) :=
  Equiv.trans MLEEquiv (Equiv.piCongr finFunctionFinEquiv (fun _ => Equiv.refl _))

@[elab_as_elim] def Fin.predRecOnSameFinType {motive : Fin r ‚Üí Sort _}
    (last : motive (‚ü®r - 1, by
      have h_r_ne_0: r ‚â† 0 := by exact NeZero.ne r
      omega
    ‚ü© : Fin r))
    (succ : ‚àÄ i : Fin r, i.val > 0 ‚Üí motive i ‚Üí motive (‚ü®i.val - 1, by omega‚ü© : Fin r))
    (i : Fin r): motive i :=

@[reducible] def NonInteractiveVerifier (Message : Type) {Œπ : Type} (oSpec : OracleSpec Œπ)
    (StmtIn StmtOut : Type) :=
  Verifier oSpec StmtIn StmtOut ‚ü®!v[.P_to_V], !v[Message]‚ü©

@[reducible, inline, specialize]
def OracleMessageIdx := {i : pSpec.MessageIdx // (inst.oracleInterfaces i).isSome }

def sumPartial (m : ‚Ñï) (n : ‚Ñï) (D : Fin n ‚Üí Finset R) :
    MvPolynomial (Fin (m + n)) R ‚Üí‚Çó[R] MvPolynomial (Fin m) R where
  toFun := fun p => ‚àë x ‚àà Fintype.piFinset D, peval (Fin.sumCommEquiv m n) x p
  map_add' := fun p q => by admit /- proof elided -/

def verifier : Verifier oSpec (StmtIn R √ó (‚àÄ i, OStmtIn R deg i))
                              (StmtOut R √ó (‚àÄ i, OStmtOut R deg i)) (pSpec R deg) where
  verify := fun ‚ü®target, oStmt‚ü© transcript => do
    letI polyLE := transcript 0
    guard (‚àë x ‚àà (univ.map D), polyLE.val.eval x = target)
    letI chal := transcript 1
    pure ‚ü®‚ü®(oStmt ()).val.eval chal, chal‚ü©, fun _ => oStmt ()‚ü©

def soundness
    (langIn : Set (StmtIn √ó ‚àÄ i, OStmtIn i))
    (langOut : Set (StmtOut √ó ‚àÄ i, OStmtOut i))
    (verifier : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec)
    (soundnessError : ‚Ñù‚â•0) : Prop :=
  verifier.toVerifier.soundness init impl langIn langOut soundnessError

def eq {Œ± : Type u} (mx my : m Œ±) : Prop :=
  evalDist mx = evalDist my

Real in Mathlib.Data.Real.Basic

@[inline, specialize]
def processRound (j : Fin n)
    (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec)
    (currentResult : OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí)
      (pSpec.Transcript j.castSucc √ó prover.PrvState j.castSucc)) :
      OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí)
        (pSpec.Transcript j.succ √ó prover.PrvState j.succ) := do
  let ‚ü®transcript, state‚ü© ‚Üê currentResult
  match hDir : pSpec.dir j with
  | .V_to_P => do
    let challenge ‚Üê pSpec.getChallenge ‚ü®j, hDir‚ü©
    letI newState := (‚Üê prover.receiveChallenge ‚ü®j, hDir‚ü© state) challenge
    return ‚ü®transcript.concat challenge, newState‚ü©
  | .P_to_V => do
    let ‚ü®msg, newState‚ü© ‚Üê prover.sendMessage ‚ü®j, hDir‚ü© state
    return ‚ü®transcript.concat msg, newState‚ü©

AdjoinRoot in Mathlib.RingTheory.AdjoinRoot

def insertNth (p : Fin (n + 1)) (y : M) (s : Fin n ‚Üí‚ÇÄ M) : Fin (n + 1) ‚Üí‚ÇÄ M :=
  Finsupp.equivFunOnFinite.symm (Fin.insertNth p y s : Fin (n + 1) ‚Üí M)

def outputRelation :
    Set
      (
        (Fri.Spec.Statement F (0 : Fin (k + 1)) √ó
        (‚àÄ j, Fri.Spec.OracleStatement D x s (0 : Fin (k + 1)) j)) √ó
        Fri.Spec.Witness F s d (0 : Fin (k + 2))
      ) := sorry

MulOneClass in Mathlib.Algebra.Group.Defs

instance instDCast‚ÇÇ : DCast‚ÇÇ Nat ProtocolSpec (fun _ pSpec => FullTranscript pSpec) where
  dcast‚ÇÇ h h' T := FullTranscript.cast h h' T
  dcast‚ÇÇ_id := cast_id

def seqComposeChallengeEquiv {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (pSpec : ‚àÄ i, ProtocolSpec (n i)) :
    (i : Fin m) √ó (pSpec i).ChallengeIdx ‚âÉ (seqCompose pSpec).ChallengeIdx where
  
  toFun := fun ‚ü®i, j‚ü© => sigmaChallengeIdxToSeqCompose i j
  invFun := seqComposeChallengeIdxToSigma
  left_inv := by admit /- proof elided -/

MvPolynomial.coeff in Mathlib.Algebra.MvPolynomial.Basic

Finsupp.mapRange in Mathlib.Data.Finsupp.Defs

def toMessagesChallenges (transcript : FullTranscript pSpec) : Messages pSpec √ó Challenges pSpec :=

def sub (m n : ChurchNat Œ±) : ChurchNat Œ± := sorry 

instance : Coe (‚àÄ a : Œ±, Œ≤ a) F where
  coe := DFunEquiv.equiv.invFun

@[reducible, simp] def StmtAfterRandomQuery : Type := R

def eval‚ÇÇ (p : MlPoly R n) (f : R ‚Üí+* S) (x : Vector S n) : S := eval (map f p) x

@[reducible, simp]
def StmtIn : Type := R

Fin.foldl in Init.Data.Fin.Fold

UInt32 in Init.Prelude

def InnerStmtOut_Test := ‚Ñ§[X] √ó ‚Ñ§ √ó ‚Ñ§

inductive ScalarOp where | add | sub | mul | div

def leadingCoeff (p : UniPoly R) : R := p.trim.getLastD 0

structure ModifiedGuruswami
  (m n k : ‚Ñï)
  (œâs : Fin n ‚Ü™ F)
  (Q : F[Z][X][Y])
  (u‚ÇÄ u‚ÇÅ : Fin n ‚Üí F)
  where
  Q_ne_0 : Q ‚â† 0
   
  Q_deg : natWeightedDegree Q 1 k < D_X ((k + 1) / (n : ‚Ñö)) n m
   
  Q_multiplicity : ‚àÄ i, rootMultiplicity Q
              (Polynomial.C <| œâs i)
              ((Polynomial.C <| u‚ÇÄ i) + Polynomial.X * (Polynomial.C <| u‚ÇÅ i))
            ‚â• m
   
  Q_deg_X :
    degreeX Q < D_X ((k + 1) / (n : ‚Ñö)) n m
   
  Q_D_Y :
    D_Y Q < D_X (k + 1 / (n : ‚Ñö)) n m / k
   
  Q_D_YZ :
    D_YZ Q ‚â§ n * (m + 1/(2 : ‚Ñö))^3 / (6 * Real.sqrt ((k + 1) / n))

@[inline, reducible]
def Witness.Lens (OuterStmtIn InnerStmtOut OuterWitIn OuterWitOut InnerWitIn InnerWitOut : Type)
    := PFunctor.Lens ((OuterStmtIn √ó OuterWitIn) X^ OuterWitOut)
                     (InnerWitIn X^ (InnerStmtOut √ó InnerWitOut))

String in Init.Prelude

@[inline]
def add [Add R] (p q : MlPoly R n) : MlPoly R n := Vector.zipWith (¬∑ + ¬∑) p q

def hammingBall (C : Code Œπ F) (y : Œπ ‚Üí F) (r : ‚Ñï) : Set (Œπ ‚Üí F) :=
  { c | c ‚àà C ‚àß hammingDist y c ‚â§ r }

class SliceLT (coll : Type u) (stop : Type v) (valid : outParam (coll ‚Üí stop ‚Üí Prop))
    (subcoll : outParam ((xs : coll) ‚Üí (stop : stop) ‚Üí (h : valid xs stop) ‚Üí Type w)) where
  sliceLT : (xs : coll) ‚Üí (stop : stop) ‚Üí (h : valid xs stop) ‚Üí subcoll xs stop h

@[reducible]
def value (op : MemoryWrite Œπ Œ±) := op.2

Eq.mpr in Init.Core

@[inline, specialize, simp]
def verifier : Verifier oSpec Statement Statement !p[] := Verifier.id

Finite in Mathlib.Data.Finite.Defs

structure DuplexSponge (U : Type) [SpongeUnit U] [SpongeSize] (C : Type*)
    [SpongeState U C] where
   
  state : C
   
  absorbPos : Fin (SpongeSize.R + 1)
   
  squeezePos : Fin (SpongeSize.R + 1)
deriving Inhabited

def lastBlockOracleReduction :=
  let bIdx := ‚Ñì / œë - 1
  let stmt : Fin (œë + 1) ‚Üí Type := fun i => Statement (L := L) (‚Ñì := ‚Ñì) Context
    ‚ü®bIdx * œë + i, by admit /- proof elided -/
    ‚ü©
  let oStmt := fun i: Fin (œë + 1) => OracleStatement ùîΩq Œ≤ œë
    ‚ü®bIdx * œë + i, by admit /- proof elided -/
    ‚ü©
  let wit := fun i: Fin (œë + 1) => Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì)
    ‚ü®bIdx * œë + i, by admit /- proof elided -/
    ‚ü©
  let V:  OracleReduction []‚Çí (StmtIn := Statement (L := L) (‚Ñì := ‚Ñì) Context
    ‚ü®bIdx * œë, by admit /- proof elided -/
    ‚ü©)
    (OStmtIn := OracleStatement ùîΩq Œ≤ œë
      ‚ü®bIdx * œë, by admit /- proof elided -/
      ‚ü©)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì)
      ‚ü®bIdx * œë, by admit /- proof elided -/
      ‚ü©)
    (StmtOut := Statement (L := L) (‚Ñì := ‚Ñì) Context (Fin.last ‚Ñì))
    (OStmtOut := OracleStatement ùîΩq Œ≤ œë (Fin.last ‚Ñì))
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) (Fin.last ‚Ñì))
    (pSpec := pSpecLastBlock (L:=L) (œë:=œë)) := by admit /- proof elided -/

Fin.mk in Init.Prelude

instance {i : Fin k} : ‚àÄ j, OracleInterface ((pSpec D x s i).Message j)
  | ‚ü®0, h‚ü© => nomatch h
  | ‚ü®1, _‚ü© => by admit /- proof elided -/

List.Vector.snoc in Mathlib.Data.Vector.Snoc

Fin.dfoldr in Batteries.Data.Fin.Basic

Subtype.val in Init.Prelude

def Array.toFinVec {Œ± : Type _} (n : ‚Ñï) (arr : Array Œ±) (h : arr.size = n) : Fin n ‚Üí Œ± :=
  fun i => arr[i]

noncomputable def relayOracleProver (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
  OracleProver (oSpec := []‚Çí)
    
    (StmtIn := Statement (L := L) Context i.succ)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) i.succ)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) i.succ)
    (pSpec := pSpecRelay) where
  PrvState := relayPrvState ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i
  input := fun ‚ü®‚ü®stmtIn, oStmtIn‚ü©, witIn‚ü© => (stmtIn, oStmtIn, witIn)
  sendMessage | ‚ü®x, h‚ü© => by admit /- proof elided -/
| ‚ü®x, h‚ü© => by admit /- proof elided -/

Polynomial.Monic in Mathlib.Algebra.Polynomial.Degree.Definitions

def drop (m : ‚Ñï) (h : m ‚â§ n) (pSpec : ProtocolSpec n) : ProtocolSpec (n - m) :=
  {dir := Fin.drop m h pSpec.dir, ¬´Type¬ª := Fin.drop m h pSpec.¬´Type¬ª}

abbrev eqPolynomial (r : œÉ ‚Üí R) : R[X œÉ] :=
  ‚àè i : œÉ, singleEqPolynomial (r i) (X i)

instance : Fintype BTF‚ÇÉ := (inferInstance : Fintype (ConcreteBTField 3))

def splitSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (k : Fin (vsum n)) : (i : Fin m) √ó Fin (n i) := match m with
  | 0 => Fin.elim0 k
  | _ + 1 => Fin.dappend
    (fun k => ‚ü®0, k‚ü©)
    (fun k => ‚ü®(splitSum k).1.succ, (splitSum k).2‚ü©)
    k

@[ext]
structure Verifier {Œπ : Type} (oSpec : OracleSpec Œπ)
    (StmtIn StmtOut : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n) where
  verify : StmtIn ‚Üí FullTranscript pSpec ‚Üí OracleComp oSpec StmtOut

def X : UniPoly R := #[0, 1]

def Prover.liftContext
    (lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut)
    (P : Prover oSpec InnerStmtIn InnerWitIn InnerStmtOut InnerWitOut pSpec) :
      Prover oSpec OuterStmtIn OuterWitIn OuterStmtOut OuterWitOut pSpec where
  PrvState := fun i => P.PrvState i √ó OuterStmtIn √ó OuterWitIn
  input := fun ctxIn => ‚ü®P.input <| lens.proj ctxIn, ctxIn‚ü©
  sendMessage := fun i ‚ü®prvState, stmtIn, witIn‚ü© => do
    let ‚ü®msg, prvState'‚ü© ‚Üê P.sendMessage i prvState
    return ‚ü®msg, ‚ü®prvState', stmtIn, witIn‚ü©‚ü©
  receiveChallenge := fun i ‚ü®prvState, stmtIn, witIn‚ü© => do
    let f ‚Üê P.receiveChallenge i prvState
    return fun chal => ‚ü®f chal, stmtIn, witIn‚ü©
  output := fun ‚ü®prvState, stmtIn, witIn‚ü© => do
    let ‚ü®innerStmtOut, innerWitOut‚ü© ‚Üê P.output prvState
    return lens.lift (stmtIn, witIn) (innerStmtOut, innerWitOut)

liftM in Init.Prelude

@[reducible]
def Witness (F : Type) [Semiring F] {k : ‚Ñï} (s : Fin (k + 1) ‚Üí ‚Ñï+) (d : ‚Ñï+) (m : ‚Ñï) :=
  Fin (m + 1) ‚Üí F‚¶É< 2 ^ (‚àë i, (s i).1) * d‚¶Ñ[X]

partial def factor (n : ‚Ñï) : Option (List ‚Ñï) :=
  if deterministicMillerRabin n then
    [n]
  else do
    let f ‚Üê rho n
    let lhs ‚Üê factor f
    let rhs ‚Üê factor (n / f)
    return (lhs ++ rhs)

LE in Init.Prelude

@[simp]
abbrev FirstSumcheckChallenge : Type := Fin pp.‚Ñì_m ‚Üí R

Infinite in Mathlib.Data.Finite.Defs

def implGroupExpOracle : QueryImpl (GroupExpOracle Œπ p) (StateT (GroupValTable Œπ G) Option) where
  impl | query _ ‚ü®i, a, j‚ü© => fun table =>
    match table i with
    | some g => some ((), table.update j (some (g ^ a.val)))
    | none => none

List.prod in Batteries.Data.List.Basic

Polynomial.comp in Mathlib.Algebra.Polynomial.Eval.Defs

instance polyIrreducibleFact (n : ‚Ñï) : Fact (Irreducible (poly n)) := ‚ü®polyIrreducible n‚ü©

def deriveTranscriptDSFSAux {Œπ : Type} {oSpec : OracleSpec Œπ} {StmtIn : Type}
    (sponge : CanonicalDuplexSponge U)
    (messages : pSpec.Messages) (i : Fin (n + 1)) :
      OracleComp (oSpec ++‚Çí duplexSpongeChallengeOracle StmtIn U)
        (CanonicalDuplexSponge U √ó pSpec.Transcript i) :=
  Fin.induction
    (pure (sponge, fun i => i.elim0))
    (fun i ih => do
      let ‚ü®curSponge, prevTranscript‚ü© ‚Üê ih
      match hDir : pSpec.dir i with
      | .V_to_P =>
        let ‚ü®challenge, newSponge‚ü© ‚Üê liftM (curSponge.squeeze (challengeSize ‚ü®i, hDir‚ü©))
        let deserializedChallenge : pSpec.Challenge ‚ü®i, hDir‚ü© :=
          Deserialize.deserialize challenge
        return (newSponge, prevTranscript.concat deserializedChallenge)
      | .P_to_V =>
        let serializedMessage : Vector U (messageSize ‚ü®i, hDir‚ü©) :=
          Serialize.serialize (messages ‚ü®i, hDir‚ü©)
        let newSponge ‚Üê liftM (DuplexSponge.absorb curSponge serializedMessage.toList)
        return (newSponge, prevTranscript.concat (messages ‚ü®i, hDir‚ü©)))
    i

def foldStepRelOut (i : Fin ‚Ñì) :
    Set ((Statement (L := L) Context i.succ √ó
      (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j)) √ó
      Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ) :=
  { input | foldStepRelOutProp (mp := mp) (ùìë := ùìë) ùîΩq Œ≤ i input}

AddHom in Mathlib.Algebra.Group.Hom.Defs

instance instST‚ÇÇ [SelectableType R] : ‚àÄ i, SelectableType
    ((‚ü®!v[.P_to_V], !v[R‚¶É‚â§ deg‚¶Ñ[X]]‚ü© ++‚Çö !p[] ++‚Çö ‚ü®!v[.V_to_P], !v[R]‚ü©).Challenge i) :=
  instSelectableTypeChallengeAppend

def Œ∂ (R : F[X][X][Y]) (x‚ÇÄ : F) (H : F[X][Y]) [H_irreducible : Fact (Irreducible H)] : ùïÉ H :=
  let W  : ùïÉ H := liftToFunctionField (H.leadingCoeff);
  let T : ùïÉ H := liftToFunctionField (Polynomial.X);
    Polynomial.eval‚ÇÇ liftToFunctionField (T / W)
      (Bivariate.evalX (Polynomial.C x‚ÇÄ) R.derivative)

Nat.ceil in Mathlib.Algebra.Order.Floor.Defs

def Extractor.Straightline.compatWit
    (lens : Extractor.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut)
    (E : Extractor.Straightline oSpec InnerStmtIn InnerWitIn InnerWitOut pSpec) :
      OuterStmtIn √ó OuterWitOut ‚Üí InnerWitIn ‚Üí Prop :=
  fun ‚ü®outerStmtIn, outerWitOut‚ü© innerWitIn =>
    ‚àÉ stmt tr logP logV, innerWitIn ‚àà
      (E stmt (lens.wit.proj (outerStmtIn, outerWitOut)) tr logP logV).support

noncomputable def Basis.baseChangeRight (b : Basis Œπ K Left) : Basis Œπ Right (Left ‚äó[K] Right) :=

def two : ChurchNat Œ± := succ one

@[reducible]
def pSpec : ProtocolSpec 1 :=
  ‚ü®!v[.V_to_P], !v[Fin l ‚Üí evalDomain D x 0]‚ü©

noncomputable def errorBound (Œ¥ : ‚Ñù‚â•0) (deg : ‚Ñï) (domain : Œπ ‚Ü™ F) : ‚Ñù‚â•0 :=
  letI œÅ : ‚Ñù‚â•0 := œÅ (ReedSolomon.code domain deg)
  if Œ¥ ‚àà Set.Ioc 0 ((1 - œÅ)/2)
  then Fintype.card Œπ / Fintype.card F
  else if Œ¥ ‚àà Set.Ioo ((1 - œÅ)/2) (1 - œÅ.sqrt)
       then letI m := min (1 - œÅ.sqrt - Œ¥) (œÅ.sqrt / 20)
            ‚ü®(deg ^ 2 : ‚Ñù‚â•0) / ((2 * m) ^ 7 * (Fintype.card F : ‚Ñù)), by admit /- proof elided -/
            ‚ü©
       else 0

def rightpad {m : ‚Ñï} {Œ± : Sort*} (n : ‚Ñï) (a : Œ±) (v : Fin m ‚Üí Œ±) : Fin n ‚Üí Œ± :=
  fun i => if h : i < m then v ‚ü®i, h‚ü© else a

def interleaveCode [Semiring F] [DecidableEq F] (C : Submodule F (n ‚Üí F)) (Œπ : Type*)
  : Submodule F ((Œπ √ó n) ‚Üí F) :=
  Submodule.span F {v | ‚àÄ i, ‚àÉ c ‚àà C, c = fun j => v (i, j)}

def Option.doubleBind {Œ± Œ≤ Œ≥ : Type} (f : Œ± ‚Üí Œ≤ ‚Üí Option Œ≥)
    (x : Option Œ±) (y : Option Œ≤) : Option Œ≥ :=
  match x, y with
  | none, _ => none
  | _, none => none
  | some a, some b => f a b

abbrev RScodeSet (domain : Œπ ‚Ü™ F) (deg : ‚Ñï) : Set (Œπ ‚Üí F) := (ReedSolomon.code domain deg).carrier

instance (s : Finset œÉ) : Fintype { x : œÉ | x ‚àà s } :=

PFunctor.X in ToMathlib.PFunctor.Basic

def computableAdditiveNTT (a : Fin (2 ^ ‚Ñì) ‚Üí L) : Fin (2^(‚Ñì + R_rate)) ‚Üí L :=
  let b: Fin (2^(‚Ñì + R_rate)) ‚Üí L := tileCoeffs a 
  Fin.foldl (n:=‚Ñì) (f:= fun current_b i  =>
    computableNTTStage (ùîΩq := ùîΩq) (Œ≤ := Œ≤) (‚Ñì := ‚Ñì) (R_rate := R_rate)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := ‚ü®‚Ñì - 1 - i, by admit /- proof elided -/
      ‚ü©) (b:=current_b)
  ) (init:=b)

@[ext]
structure OracleReduction {Œπ : Type} (oSpec : OracleSpec Œπ)
    (StmtIn : Type) {Œπ‚Çõ·µ¢ : Type} (OStmtIn : Œπ‚Çõ·µ¢ ‚Üí Type) (WitIn : Type)
    (StmtOut : Type) {Œπ‚Çõ‚Çí : Type} (OStmtOut : Œπ‚Çõ‚Çí ‚Üí Type) (WitOut : Type)
    {n : ‚Ñï} (pSpec : ProtocolSpec n)
    [O‚Çõ·µ¢ : ‚àÄ i, OracleInterface (OStmtIn i)] [O‚Çò : ‚àÄ i, OracleInterface (pSpec.Message i)]
    where
  prover : OracleProver oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec
  verifier : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec

structure ProximityGenerator
  (Œπ : Type) [Fintype Œπ] [Nonempty Œπ]
  (F : Type) [Semiring F] [Fintype F] [DecidableEq F] where
  
  C : LinearCode Œπ F
  
  par‚Ñì : Type
  h‚Ñì : Fintype par‚Ñì
  
  Gen : Finset (par‚Ñì ‚Üí F)
  Gen_nonempty : Nonempty Gen
  
  rate : ‚Ñù
  
  B : (LinearCode Œπ F) ‚Üí Type ‚Üí ‚Ñù
  
  err : (LinearCode Œπ F) ‚Üí Type ‚Üí ‚Ñù ‚Üí ENNReal
   
  proximity:
    ‚àÄ (f : par‚Ñì ‚Üí Œπ ‚Üí F)
      (Œ¥ : ‚Ñù‚â•0) 
      (_hŒ¥ : 0 < Œ¥ ‚àß Œ¥ < 1 - (B C par‚Ñì)) ,
      Pr_{ let r ‚Üê $·µñ Gen }[ (proximityCondition f Œ¥ r C) ] > (err C par‚Ñì Œ¥) ‚Üí
        ‚àÉ S : Finset Œπ,
          S.card ‚â• (1 - Œ¥) * (Fintype.card Œπ) ‚àß
        ‚àÄ i : par‚Ñì, ‚àÉ u ‚àà C, ‚àÄ x ‚àà S, f i x = u x

Polynomial.degree in Mathlib.Algebra.Polynomial.Degree.Definitions

@[reducible]
def batchSpec (F : Type) (m : ‚Ñï) : ProtocolSpec 1 := ‚ü®!v[.V_to_P], !v[Fin m ‚Üí F]‚ü©

def knowledgeSoundness (relIn : Set (StmtIn √ó WitIn)) (relOut : Set (StmtOut √ó WitOut))
    (verifier : Verifier oSpec StmtIn StmtOut pSpec) (knowledgeError : ‚Ñù‚â•0) : Prop :=
  ‚àÉ extractor : Extractor.Straightline oSpec StmtIn WitIn WitOut pSpec,
  ‚àÄ stmtIn : StmtIn,
  ‚àÄ witIn : WitIn,
  ‚àÄ prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec,
    letI reduction := Reduction.mk prover verifier
    [fun ‚ü®stmtIn, witIn, stmtOut, witOut‚ü© =>
      (stmtIn, witIn) ‚àâ relIn ‚àß (stmtOut, witOut) ‚àà relOut
    | do
      let s ‚Üê init
      (simulateQ (impl ++‚Çõ‚Çí challengeQueryImpl : QueryImpl _ (StateT œÉ ProbComp))
        <| do
      let ‚ü®‚ü®‚ü®transcript, ‚ü®_, witOut‚ü©‚ü©, stmtOut‚ü©, proveQueryLog, verifyQueryLog‚ü© ‚Üê
        reduction.runWithLog stmtIn witIn
      let extractedWitIn ‚Üê
        liftComp (extractor stmtIn witOut transcript proveQueryLog.fst verifyQueryLog) _
      return (stmtIn, extractedWitIn, stmtOut, witOut)).run' s] ‚â§ knowledgeError

protected def cast (pSpec : ProtocolSpec n‚ÇÅ) : ProtocolSpec n‚ÇÇ :=
  ‚ü®pSpec.dir ‚àò (Fin.cast hn.symm), pSpec.¬´Type¬ª ‚àò (Fin.cast hn.symm)‚ü©

Finset.zero in Mathlib.Algebra.Group.Pointwise.Finset.Basic

Polynomial.compRingHom in Mathlib.Algebra.Polynomial.Eval.Defs

private def toWeightAssignment
  (p : MvPolynomial (Fin m) F)
  (b : Fin m ‚Üí Fin 2) : Fin (m+1) ‚Üí F :=
    let b' : Fin m ‚Üí F := fun i => ‚Üë(b i : ‚Ñï)
    Fin.cases (MvPolynomial.eval b' p)
              (fun i => ‚Üë(b i : ‚Ñï))

def CEmbedding : R ‚Ü™ MvPolynomial œÉ R := ‚ü®C, C_injective œÉ R‚ü©

instance {s} : Functor (fun Œ± => FullData Œ± s) where
  map f x := x.map f

MvPolynomial.aeval in Mathlib.Algebra.MvPolynomial.Eval

instance : LT AssocNat where
  lt a b := a 0 < b 0

def deriveTranscriptSR {Œπ : Type} {oSpec : OracleSpec Œπ} {StmtIn : Type}
    (stmt : StmtIn) (messages : pSpec.Messages) :
    OracleComp (oSpec ++‚Çí fsChallengeOracle StmtIn pSpec) pSpec.FullTranscript := do
  MessagesUpTo.deriveTranscriptSR stmt (Fin.last n) messages

alias deriveTranscriptFS := deriveTranscriptSR

def outOfOrder : Prop :=
  outOfOrderHash trace state ‚à® outOfOrderPerm trace state

alias E_time := outOfOrder

def partialSum {Œ± : Type*} [AddMonoid Œ±] (l : List Œ±) : List Œ± :=
  [0] ++ match l with
  | [] => []
  | a :: l' => (partialSum l').map (a + ¬∑)

@[reducible, simp] def OStmtOut := fun _ : Fin 1 => OStatement

Char.ofNat in Init.Prelude

def ConcreteBTFieldAlgebra {l r : ‚Ñï} (h_le : l ‚â§ r) :
    Algebra (ConcreteBTField l) (ConcreteBTField r) := instAlgebraTowerConcreteBTF.toAlgebra h_le

Function.uncurry in Init.Data.Function

instance instDCastPSigmaPSigma :
    DCast ((a : Œ±) √ó' (b : Œ≤ a) √ó' Œ≥ a b) (fun a => Œ¥ a.1 a.2.1 a.2.2) where
  dcast hc d := dcast‚ÇÉ (by admit /- proof elided -/
  ) (by admit /- proof elided -/
  ) (by admit /- proof elided -/
  ) d
  dcast_id := by admit /- proof elided -/

@[reducible, simp] def StmtOut : Type := R √ó R

inductive PrattPart : (p : ‚Ñï) ‚Üí (a : ZMod p) ‚Üí ‚Ñï ‚Üí Prop
  | prime : {p : ‚Ñï} ‚Üí {a : ZMod p} ‚Üí (n k nk : ‚Ñï) ‚Üí n.Prime ‚Üí
      a ^ ((p - 1) / n) ‚â† 1 ‚Üí n ^ k = nk ‚Üí PrattPart p a nk
  | split : {p : ‚Ñï} ‚Üí {a : ZMod p} ‚Üí {n : ‚Ñï} ‚Üí (l r : ‚Ñï) ‚Üí
      PrattPart p a l ‚Üí PrattPart p a r ‚Üí l * r = n ‚Üí PrattPart p a n

structure LookaheadSequenceFamily
    (trace : QueryLog (forwardPermutationOracle (CanonicalSpongeState U)))
    (state : CanonicalSpongeState U) (i : pSpec.ChallengeIdx) where
   
  seqFamily : Finset (LookaheadSequence trace state)
   
  maximality : ‚àÄ s ‚àà seqFamily, ‚àÄ s' ‚àà seqFamily,
    ¬¨ (s.inputState ‚äÜ s'.inputState) ‚à® ¬¨ (s'.outputState ‚äÜ s.outputState)
   
  length_le_challengeSize : ‚àÄ s ‚àà seqFamily, s.inputState.length ‚â§ challengeSize i

protected def Prover.id : Prover oSpec Statement Witness Statement Witness !p[] where
  PrvState := fun _ => Statement √ó Witness
  input := _root_.id
  sendMessage := fun i => Fin.elim0 i
  receiveChallenge := fun i => Fin.elim0 i
  output := pure

def rootsOfUnity (n s : ‚Ñï) : List (Domain.evalDomain D (n - s)) :=
  List.map
    (fun i =>
      ‚ü®
        (DIsCyclicC.gen.1 ^ (2 ^ (n - s))) ^ i,
        by admit /- proof elided -/
      ‚ü©
    )
    (List.range (2 ^ s))

@[reducible]
def verifier : Verifier oSpec (StatementRound R n 0 √ó (‚àÄ i, OracleStatement R n deg i))
    (StatementRound R n (.last n) √ó (‚àÄ i, OracleStatement R n deg i)) (pSpec R deg n) :=
  Verifier.seqCompose (oSpec := oSpec)
    (Stmt := fun i => StatementRound R n i √ó (‚àÄ j, OracleStatement R n deg j))
    (pSpec := fun _ => SingleRound.pSpec R deg)
    (SingleRound.verifier R n deg D oSpec)

def proverRound (i : Fin n) : ProverRound oSpec (pSpec R deg) where
  PrvState := (proverState R n deg i).PrvState

  sendMessage
  | ‚ü®0, _‚ü© => fun state =>
    match n with
    | 0 => sorry
    | n + 1 =>
      let ‚ü®‚ü®_, challenges‚ü©, oStmt‚ü© := state
      let ‚ü®poly, hp‚ü© := oStmt 0
      pure ‚ü® ‚ü®‚àë x ‚àà (univ.map D) ^·∂† (n - i), poly ‚∏®X ‚¶Éi‚¶Ñ, challenges, x‚∏©'(by admit /- proof elided -/
      ),
        sumcheck_roundPoly_degreeLE R n deg D i hp‚ü©,
          state‚ü©
  | ‚ü®1, h‚ü© => nomatch h

  receiveChallenge
  | ‚ü®0, h‚ü© => nomatch h
  | ‚ü®1, _‚ü© => fun ‚ü®‚ü®target, challenges‚ü©, oStmt‚ü© => pure fun chal =>
    let ‚ü®poly, hp‚ü© := oStmt 0
    letI newChallenges : Fin i.succ ‚Üí R := Fin.snoc challenges chal
    letI newTarget := ‚àë x ‚àà (univ.map D) ^·∂† (n - i - 1), poly ‚∏®newChallenges, x‚∏©'(by admit /- proof elided -/
    )
    ‚ü®‚ü®newTarget, newChallenges‚ü©, fun _ => ‚ü®poly, hp‚ü©‚ü©

def oracleReduction : OracleReduction oSpec (StmtIn R) (OStmtIn R deg) Unit
                                            (StmtOut R) (OStmtOut R deg) Unit (pSpec R deg) where
  prover := prover R deg oSpec
  verifier := oracleVerifier R deg D oSpec

def getPutativeRoot {s} (idx : BinaryTree.SkeletonLeafIndex s) (leafValue : Œ±)
    (proof : List Œ±) : OracleComp (spec Œ±) Œ± :=
  match proof with
  | [] => return leafValue 
  | siblingBelowRootHash :: restProof => do
    match idx with
    | BinaryTree.SkeletonLeafIndex.ofLeaf =>
      
      
      
      return leafValue
    | BinaryTree.SkeletonLeafIndex.ofLeft idxLeft =>
      
      let ancestorBelowRootHash ‚Üê getPutativeRoot idxLeft leafValue restProof
      singleHash ancestorBelowRootHash siblingBelowRootHash
    | BinaryTree.SkeletonLeafIndex.ofRight idxRight =>
      
      let ancestorBelowRootHash ‚Üê getPutativeRoot idxRight leafValue restProof
      singleHash siblingBelowRootHash ancestorBelowRootHash

List.dropLast in Init.Data.List.Basic

instance : IsEmpty (AssocFin AssocNat.zero) :=

def toProverState (ds : DomainSeparator U H) (rng : R) : FSProverState U H R :=
  FSProverState.new ds rng

@[reducible, inline, specialize, simp]
def ChallengeIdx (vPSpec : VectorSpec n) := {i : Fin n // vPSpec.dir i = .V_to_P}

def oracleVerifier : OracleVerifier oSpec (StmtIn R) (OStmtIn R deg) (StmtOut R) (OStmtOut R deg)
    (pSpec R deg) where
  verify := fun target chal => do
    let evals : Vector R m ‚Üê (Vector.finRange m).mapM
      (fun i => query (spec := [OStmtIn R deg]‚Çí) () (D i))
    guard (evals.sum = target)
    
    pure (sorry, chal default)
  embed := .inl
  hEq := fun i => by admit /- proof elided -/

Subtype.fintype in Mathlib.Data.Fintype.Sets

Finset.filterMap in Mathlib.Data.Finset.Image

def rbrSoundness
    (langIn : Set (StmtIn √ó ‚àÄ i, OStmtIn i))
    (langOut : Set (StmtOut √ó ‚àÄ i, OStmtOut i))
    (verifier : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec)
    (rbrSoundnessError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) : Prop :=
  verifier.toVerifier.rbrSoundness init impl langIn langOut rbrSoundnessError

@[reducible, inline]
instance instProdForall {Œπ : Type u} (v : Œπ ‚Üí Type v) [O : ‚àÄ i, OracleInterface (v i)] :
    OracleInterface (‚àÄ i, v i) where
  Query := (i : Œπ) √ó (O i).Query
  Response := (i : Œπ) √ó (O i).Response
  answer := fun f ‚ü®i, q‚ü© => ‚ü®i, (O i).answer (f i) q‚ü©

@[reducible, simp]
def StmtIn := R

noncomputable def decode : (ReedSolomon.code domain deg) ‚Üí‚Çó[F] F[X] :=
  domRestrict
    (interpolate (domain := domain))
    (ReedSolomon.code domain deg)

@[inline] def min [Zero T] [ToNat T] (a b : Cayley T) : Cayley T :=
  if (a : Nat) ‚â§ (b : Nat) then a else b

private def sum_choose_K_i (B : Finset (Fin n ‚Üí F)) (i : Fin n) : ‚Ñö :=
  ‚àë (Œ± : F), choose_2 (K B i Œ±)

List.rtake in Mathlib.Data.List.DropRight

@[inline] def zero : Cayley T :=
  ‚ü®id, by admit /- proof elided -/
  ‚ü©

@[simp]
abbrev OracleStatement.AfterFirstChallenge : R1CS.MatrixIdx ‚äï Fin 1 ‚Üí Type :=
  OracleStatement.AfterFirstMessage R pp

def BBF_SumcheckMultiplierParam : SumcheckMultiplierParam L ‚Ñì (SumcheckBaseContext L ‚Ñì) :=
  { multpoly := fun ctx => BBF_eq_multiplier ctx.t_eval_point }

inductive MemoryOp (Œπ : Type u) (Œ± : Œπ ‚Üí Type v) where
  | read (op : MemoryRead Œπ Œ±)
  | write (op : MemoryWrite Œπ Œ±)

def joinBits {n m : ‚Ñï} (low : Fin (2 ^ n)) (high : Fin (2 ^ m)) : Fin (2 ^ (m+n)) :=
  ‚ü®(high.val <<< n) ||| low.val, by admit /- proof elided -/
  ‚ü©

noncomputable def foldOracleProver (i : Fin ‚Ñì) :
  OracleProver (oSpec := []‚Çí)
    
    (StmtIn := Statement (L := L) Context i.castSucc)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) i.castSucc)
    
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) i.succ)
    (pSpec := pSpecFold (L := L)) where

  PrvState := foldPrvState ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i

  input := fun ‚ü®‚ü®stmt, oStmt‚ü©, wit‚ü© => (stmt, oStmt, wit)

  sendMessage 
  | ‚ü®0, _‚ü© => fun ‚ü®stmt, oStmt, wit‚ü© => do
    let curH : ‚Ü•L‚¶É‚â§ 2‚¶Ñ[X Fin (‚Ñì - ‚Üëi.castSucc)] := wit.H
    let h_i : L‚¶É‚â§ 2‚¶Ñ[X] := by admit /- proof elided -/

OptionT.mk in Init.Control.Option

def outputRelation [DecidableEq F] (Œ¥ : ‚Ñù‚â•0) :
    Set
      (
        (FinalStatement F k √ó ‚àÄ j, FinalOracleStatement D x s j) √ó
        Witness F s d (Fin.last (k + 1))
      )
  := QueryRound.outputRelation D x s d (round_bound dom_size_cond) Œ¥

MvPolynomial.degreeOf in Mathlib.Algebra.MvPolynomial.Degrees

noncomputable def fold
  {S : Finset Œπ} (œÜ : Œπ ‚Ü™ F) (f : Œπ ‚Üí F) (k : ‚Ñï) (Œ± : F) : indexPow S œÜ k ‚Üí F :=
    fun x => (xPoly f œÜ k x).eval Œ±

def mulVec [Zero Œ±] [Add Œ±] [Mul Œ±] {numRows numCols : Nat}
    (M : Vector (Vector Œ± numCols) numRows)
    (x : Vector Œ± numCols) : Vector Œ± numRows :=
  M.map (fun row => row *·µ• x)

def getPutativeRoot_with_hash {s} (idx : BinaryTree.SkeletonLeafIndex s)
    (leafValue : Œ±) (proof : List Œ±) (hashFn : Œ± ‚Üí Œ± ‚Üí Œ±) : Œ± :=
  match proof with
  | [] => leafValue 
  | siblingBelowRootHash :: restProof =>
    match idx with
    | BinaryTree.SkeletonLeafIndex.ofLeaf =>
      
      
      
      leafValue
    | BinaryTree.SkeletonLeafIndex.ofLeft idxLeft =>
      
      hashFn (getPutativeRoot_with_hash idxLeft leafValue restProof hashFn) siblingBelowRootHash
    | BinaryTree.SkeletonLeafIndex.ofRight idxRight =>
      
      hashFn siblingBelowRootHash (getPutativeRoot_with_hash idxRight leafValue restProof hashFn)

OracleComp.liftComp in VCVio.OracleComp.Coercions.SubSpec

def computableTwiddleFactor (i : Fin ‚Ñì) (u : Fin (2 ^ (‚Ñì + R_rate - i - 1))) : L :=
  
  ‚àë (‚ü®k, hk‚ü©: Fin (‚Ñì + R_rate - i - 1)),
  if Nat.getBit k u.val = 1 then
    
      
    (evalNormalizedWAt (Œ≤ := Œ≤) (‚Ñì := ‚Ñì) (R_rate := R_rate)
      (i := ‚ü®i, by admit /- proof elided -/
      ‚ü©) (x := Œ≤ ‚ü®i + 1 + k, by admit /- proof elided -/
      ‚ü©))
  else 0

structure PrattCertificate (p : ‚Ñï) : Type where
  a : ZMod p
  pow_eq_one : a ^ (p - 1) = 1
  part : PrattPart p a (p - 1)

Nat.max in Init.Data.Nat.Basic

def MLE (evals : (œÉ ‚Üí Fin 2) ‚Üí R) : MvPolynomial œÉ R :=
    ‚àë x : œÉ ‚Üí Fin 2, (eqPolynomial (x : œÉ ‚Üí R)) * C (evals x)

protected def cast (T : FullTranscript pSpec‚ÇÅ) :
    FullTranscript pSpec‚ÇÇ :=
  Transcript.cast (k := Fin.last n‚ÇÅ) (l := Fin.last n‚ÇÇ) hn hn hSpec T

@[inline] def monoToLagrange (n : ‚Ñï) : MlPoly R n ‚Üí MlPolyEval R n :=
  (List.finRange n).foldl (fun acc level => monoToLagrangeLevel level acc)

instance : OracleInterfaces (vPSpec.toProtocolSpec A) where
  oracleInterfaces := fun _ => some OracleInterface.instVector

@[reducible, inline, specialize, simp]
def srChallengeQueryImpl {Statement : Type} {pSpec : ProtocolSpec n}
    [‚àÄ i, SelectableType (pSpec.Challenge i)] :
    QueryImpl (srChallengeOracle Statement pSpec) ProbComp where
  impl | query i _ => uniformOfFintype (pSpec.Challenge i)

Option.bind in Init.Data.Option.Basic

class IsSecure
    (relation : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (Œµ_rbr : vPSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0)
    (vectorIOP : VectorIOP Statement OStatement Witness vPSpec A) where

   
  is_complete : vectorIOP.perfectCompleteness (pure ()) ‚ü®isEmptyElim‚ü© relation

   
  is_rbr_knowledge_sound :
    OracleProof.rbrKnowledgeSoundness (pure ()) ‚ü®isEmptyElim‚ü© relation vectorIOP.verifier Œµ_rbr

noncomputable def qCompositionChain (i : Fin r) : L[X] :=
  match i with
  | ‚ü®0, _‚ü© => X
  | ‚ü®k + 1, h_k_add_1‚ü© => (qMap ùîΩq Œ≤ ‚ü®k, by admit /- proof elided -/
  ‚ü©).comp (qCompositionChain ‚ü®k, by admit /- proof elided -/
  ‚ü©)

instance : Zero (Cayley T) where
  zero := zero

Finset.sum in Mathlib.Algebra.BigOperators.Group.Finset.Defs

def finUInt8Equiv : Fin (2 ^ 8) ‚âÉ UInt8 where
  toFun := fun i => UInt8.ofFin i
  invFun := fun u => u.toFin
  left_inv _ := rfl
  right_inv _ := rfl

def NBlockMessages := 2 * (œë - 1) + 3

Sum.isLeft in Init.Data.Sum.Basic

@[simp]
def testLensE : Extractor.Lens OuterStmtIn_Test OuterStmtOut_Test InnerStmtIn_Test InnerStmtOut_Test
                Unit Unit Unit Unit where
  stmt := testStmtLens
  wit := Witness.InvLens.id

@[reducible]
def messageLength (vPSpec : VectorSpec n) (i : MessageIdx vPSpec) : Nat := vPSpec.length i

def Rhs (e : ‚Ñï) (œâs f : Fin n ‚Üí F) (i : Fin n) : F :=
  let Œ±·µ¢ := œâs i
  (-(f i) * Œ±·µ¢^e)

def weight_Œõ (f H : F[X][Y]) (D : ‚Ñï) : WithBot ‚Ñï :=
  Finset.sup
    f.support
    (fun deg =>
      WithBot.some <| deg * (D + 1 - Bivariate.natDegreeY H) + (f.coeff deg).natDegree
    )

class Extractor.Lens.IsKnowledgeSound
    {OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut : Type}
    {OuterWitIn OuterWitOut InnerWitIn InnerWitOut : Type}
    (outerRelIn : Set (OuterStmtIn √ó OuterWitIn))
    (innerRelIn : Set (InnerStmtIn √ó InnerWitIn))
    (outerRelOut : Set (OuterStmtOut √ó OuterWitOut))
    (innerRelOut : Set (InnerStmtOut √ó InnerWitOut))
    (compatStmt : OuterStmtIn ‚Üí InnerStmtOut ‚Üí Prop)
    (compatWit : OuterWitOut ‚Üí InnerWitIn ‚Üí Prop)
    (lens : Extractor.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                            OuterWitIn OuterWitOut InnerWitIn InnerWitOut) where

   
  proj_knowledgeSound : ‚àÄ outerStmtIn innerStmtOut outerWitOut,
    compatStmt outerStmtIn innerStmtOut ‚Üí
    (lens.stmt.lift outerStmtIn innerStmtOut, outerWitOut) ‚àà outerRelOut ‚Üí
    (innerStmtOut, lens.wit.proj (outerStmtIn, outerWitOut)) ‚àà innerRelOut

   
  lift_knowledgeSound : ‚àÄ outerStmtIn outerWitOut innerWitIn,
    compatWit outerWitOut innerWitIn ‚Üí
    (lens.stmt.proj outerStmtIn, innerWitIn) ‚àà innerRelIn ‚Üí
    (outerStmtIn, lens.wit.lift (outerStmtIn, outerWitOut) innerWitIn) ‚àà outerRelIn

inferInstanceAs in Init.Prelude

def FullData.copath {Œ±} {s} (cache_tree : FullData Œ± s) :
    BinaryTree.SkeletonLeafIndex s ‚Üí List Œ±
  | .ofLeaf => []
  | .ofLeft idxLeft =>
    (cache_tree.rightSubtree).getRootValue ::
      (copath cache_tree.leftSubtree idxLeft)
  | .ofRight idxRight =>
    (cache_tree.leftSubtree).getRootValue ::
      (copath cache_tree.rightSubtree idxRight)

def fnOracle (spec : OracleSpec Œπ) (f : (i : Œπ) ‚Üí spec.domain i ‚Üí spec.range i) :
    SimOracle.Impl spec where
  impl | query i t => pure (f i t)

def localized_fold_eval (i : Fin ‚Ñì) (steps : ‚Ñï) (h_i_add_steps : i + steps ‚â§ ‚Ñì)
    (f : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate)
      ‚ü®i, by exact Nat.lt_of_le_of_lt (n := i) (k := r) (m := ‚Ñì) (h‚ÇÅ := by
        exact Fin.is_le') (by exact lt_of_add_right_lt h_‚Ñì_add_R_rate)‚ü© ‚Üí L)
    (r_challenges : Fin steps ‚Üí L)
    (y : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®‚Üëi + steps, by omega‚ü©) : L :=

def vflatten {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (v : (i : Fin m) ‚Üí Fin (n i) ‚Üí Œ±) :
    Fin (vsum n) ‚Üí Œ± :=
  dflatten v

@[reducible, simp] def StmtOut := Query OStatement √ó Response OStatement

Classical.typeDecidableEq in Init.Classical

def StraightlineExtractor (oSpec : OracleSpec Œπ) (Data Commitment : Type) :=
  Commitment ‚Üí QueryLog oSpec ‚Üí Data

noncomputable def J (q Œ¥ : ‚Ñö) : ‚Ñù :=
  let frac := q / (q - 1)
  (1 / frac) * (1 - Real.sqrt (1 - frac * Œ¥))

noncomputable def commitRbrExtractor (i : Fin ‚Ñì) :
  Extractor.RoundByRound []‚Çí
    (StmtIn := (Statement (L := L) Context i.succ) √ó (‚àÄ j, OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc j))
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (pSpec := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)
    (WitMid := fun _messageIdx => Witness (L := L) ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ) where
  eqIn := rfl
  extractMid := fun _ _ _ witMidSucc => witMidSucc
  extractOut := fun _ _ witOut => witOut

def new (domainSeparator : DomainSeparator U H) (csrng : R) : FSProverState U H R :=
  let hashState := HashStateWithInstructions.new domainSeparator
  
  let rng : ProverPrivateRng R := { ds := (), csrng := csrng }
  { rng := rng, hashState := hashState, nargString := ByteArray.empty }

def relation (cs : ConstraintSystem ùì° numWires numGates) (‚Ñì : ‚Ñï) (h‚Ñì : ‚Ñì ‚â§ numWires) :
    (publicInputs : Fin ‚Ñì ‚Üí ùì°) ‚Üí (privateWitness : Fin (numWires - ‚Ñì) ‚Üí ùì°) ‚Üí Prop :=
  fun (x : Fin ‚Ñì ‚Üí ùì°) (œâ : Fin (numWires - ‚Ñì) ‚Üí ùì°) =>
    let combined := Fin.append x œâ ‚àò Fin.cast (by admit /- proof elided -/
    )
    cs.accepts combined

def stirRelation
    {F : Type} [Field F] [Fintype F] [DecidableEq F]
    {Œπ : Type} [Fintype Œπ] [Nonempty Œπ]
    (degree : ‚Ñï) (œÜ : Œπ ‚Ü™ F) (err : ‚Ñù)
    : Set ((Unit √ó ‚àÄ i, (OracleStatement Œπ F i)) √ó Unit) :=
  fun ‚ü®‚ü®_, oracle‚ü©, _‚ü© => Œ¥·µ£(oracle (), ReedSolomon.code œÜ degree) ‚â§ err

def verifySmallPrime (n' : Q(‚Ñï)) : MetaM Q(Nat.Prime $n') :=
  match n'.natLit! with
    | 2 => do haveI : $n' =Q 2 := ‚ü®‚ü©; return q(prime_2)
    | 3 => do haveI : $n' =Q 3 := ‚ü®‚ü©; return q(prime_3)
    | 5 => do haveI : $n' =Q 5 := ‚ü®‚ü©; return q(prime_5)
    | 7 => do haveI : $n' =Q 7 := ‚ü®‚ü©; return q(prime_7)
    | 11 => do haveI : $n' =Q 11 := ‚ü®‚ü©; return q(prime_11)
    | 13 => do haveI : $n' =Q 13 := ‚ü®‚ü©; return q(prime_13)
    | 17 => do haveI : $n' =Q 17 := ‚ü®‚ü©; return q(prime_17)
    | 19 => do haveI : $n' =Q 19 := ‚ü®‚ü©; return q(prime_19)
    | 23 => do haveI : $n' =Q 23 := ‚ü®‚ü©; return q(prime_23)
    | 29 => do haveI : $n' =Q 29 := ‚ü®‚ü©; return q(prime_29)
    | 31 => do haveI : $n' =Q 31 := ‚ü®‚ü©; return q(prime_31)
    | 37 => do haveI : $n' =Q 37 := ‚ü®‚ü©; return q(prime_37)
    | 41 => do haveI : $n' =Q 41 := ‚ü®‚ü©; return q(prime_41)
    | 43 => do haveI : $n' =Q 43 := ‚ü®‚ü©; return q(prime_43)
    | 47 => do haveI : $n' =Q 47 := ‚ü®‚ü©; return q(prime_47)
    | _ => failure

instance {k : Fin (n + 1)} : Fintype (pSpec.ChallengeIdxUpTo k) :=
  inferInstanceAs (Fintype <| ChallengeIdx (pSpec.take k k.is_le))

@[simp]
abbrev OracleStatement.AfterSecondSumcheck : R1CS.MatrixIdx ‚äï R1CS.MatrixIdx ‚äï Fin 1 ‚Üí Type :=
  Sum.elim (EvalClaim R) (OracleStatement.AfterFirstSumcheck R pp)

Finset.Ico in Mathlib.Order.Interval.Finset.Defs

@[inline] def ofNat (k : Nat) : AssocNat :=
  ‚ü®fun m => m + k, fun m => Nat.succ_add m k‚ü©

class VerifierFirst (pSpec : ProtocolSpec n) [NeZero n] where
  verifier_first' : pSpec.dir 0 = .V_to_P

List.getLast in Init.Data.List.Basic

def finIdxOf [BEq Œ±] [LawfulBEq Œ±] (a : Œ±) (l : List Œ±) : Fin (l.length + 1) :=
  ‚ü®List.idxOf' a l, Nat.lt_succ_of_le (by admit /- proof elided -/
  )‚ü©

@[inline]
def permute (params : Params) (state : Vector KoalaBear.Field params.width) :
    Vector KoalaBear.Field params.width :=
  letI rcs := params.roundConstants

  
  let st0 := externalLinearLayer params state

  
  let st1 : Vector KoalaBear.Field params.width :=
    Fin.foldl params.halfNumFullRounds (fun st_acc rc_idx =>
      let rc_chunk := (rcs.extract rc_idx (rc_idx + params.width)).cast (by admit /- proof elided -/
      )
      let st_new := fullRound params st_acc rc_chunk
      st_new) st0

  
  let rcs := rcs.drop (params.halfNumFullRounds * params.width)

  
  let st2 := Fin.foldl params.numPartialRounds (fun st_acc rc_idx =>
    let rc_val := rcs[rc_idx]'(sorry)
    let st_new := partialRound params st_acc rc_val
    st_new) st1

  
  let rcs := rcs.drop params.numPartialRounds

  
  let st3 := Fin.foldl params.halfNumFullRounds (fun st_acc rc_idx =>
    let rc_chunk := (rcs.extract rc_idx (rc_idx + params.width)).cast (by admit /- proof elided -/
    )
    let st_new := fullRound params st_acc rc_chunk
    st_new) st2

  st3

instance : Fact (Nat.Prime scalarFieldSize) := ‚ü®ScalarField_is_prime‚ü©

def StateRestoration (oSpec : OracleSpec Œπ)
    (StmtIn WitIn WitOut : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n) :=
  StmtIn ‚Üí 
  WitOut ‚Üí 
  pSpec.FullTranscript ‚Üí 
  QueryLog (oSpec ++‚Çí (srChallengeOracle StmtIn pSpec)) ‚Üí 
  QueryLog oSpec ‚Üí 
  OracleComp oSpec WitIn 

SimOracle.append in VCVio.OracleComp.SimSemantics.Append

instAlgebra in Mathlib.LinearAlgebra.TensorAlgebra.Basic

def ratchet (sponge : DuplexSponge U C) :
    OracleComp (forwardPermutationOracle C) (DuplexSponge U C) := do
  let permutedState : C ‚Üê query (spec := forwardPermutationOracle C) () sponge.state
  
  let vecState : Vector U SpongeSize.N := SpongeState.get permutedState
  
  let zeroed : Vector U SpongeSize.N :=
    Vector.ofFn (fun i => if i < SpongeSize.R then 0 else vecState[i])
  
  let newVecState := SpongeState.update permutedState zeroed
  
  return { sponge with
    state := newVecState,
    squeezePos := Fin.last SpongeSize.R }

instance : Fact (Nat.Prime scalarFieldSize) := ‚ü®ScalarField_is_prime‚ü©

def join {k : ‚Ñï} (h_pos : k > 0) (hi lo : ConcreteBTField (k - 1)) : ConcreteBTField k :=

noncomputable def disagreementSet (f : Œπ ‚Üí F) (S : Finset F) (Ans : S ‚Üí F) : Finset F :=
  Set.toFinset ({x : Œπ | x.val ‚àà S ‚àß (ansPoly S Ans).eval x.val ‚â† f x}.image Subtype.val)

def OracleSpec.proverOracle (StmtIn : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n) :
    OracleSpec pSpec.MessageIdx :=
  fun i => (StmtIn √ó pSpec.Transcript i.val.castSucc, pSpec.Message i)

def divide_by_2 (s : Finset ‚Ñï) : Finset ‚Ñï :=
  (erase_odd s).image (fun n => n / 2)

def neg_descending (p : UniPoly R) : QuotientUniPoly R :=
  Quotient.mk _ (neg p)

noncomputable def foldNth (n : ‚Ñï) (f : ùîΩ[X]) (Œ± : ùîΩ) [inst : NeZero n] : ùîΩ[X] :=
  ‚àë i : Fin n, Polynomial.C Œ± ^ i.1 * splitNth f n i

def sumCases {l : List ‚Ñï} {motive : Fin l.sum ‚Üí Sort*}
    (cases : ‚àÄ (n : ‚Ñï) (h : n ‚àà l) (i : Fin n), motive (castSum l h i))
    (i : Fin l.sum) : motive i := match l with
  | [] => by admit /- proof elided -/
  | n' :: l' => by admit /- proof elided -/

instance coe_field_adjoinRoot (k : ‚Ñï) : Coe (AdjoinRoot (poly k)) (BTField (k+1)) where
  coe := Eq.mp (BTField_succ_eq_adjoinRoot k)

List.Vector.ofFn in Mathlib.Data.Vector.Defs

OracleComp.inductionOn in VCVio.OracleComp.OracleComp

Vector.foldl in Init.Data.Vector.Basic

@[reducible, inline]
instance instPolynomialDegreeLE : OracleInterface (R‚¶É‚â§ d‚¶Ñ[X]) where
  Query := R
  Response := R
  answer := fun ‚ü®poly, _‚ü© point => poly.eval point

instance : IsEmpty (OracleQuery []‚Çí Œ±) where
  false := by admit /- proof elided -/

instance (priority := low) : DCast‚ÇÇ Œ± Œ≤ Œ≥ where
  dcast‚ÇÇ ha hb c := by admit /- proof elided -/

def generateSrs (n : ‚Ñï) (a : ZMod p) : Vector G‚ÇÅ (n + 1) √ó Vector G‚ÇÇ 2 :=
  (towerOfExponents g‚ÇÅ a n, towerOfExponents g‚ÇÇ a 1)

instance : Field ScalarField := ZMod.instField scalarFieldSize

def modNat [Zero T] [DecidableEq T] [ToNat T]
    (dividend divisor : Cayley T) : Nat ‚Üí Cayley T
  | 0        => dividend  
  | .succ fuel =>
    
    if (‚Üëdivisor : Nat) = 0 then
      dividend
    else
      
      if (‚Üëdivisor : Nat) ‚â§ (‚Üëdividend : Nat) then
        
        modNat (sub dividend divisor) divisor fuel
      else
        dividend

Finset.max in Mathlib.Data.Finset.Max

guard in Init.Control.Basic

Fin.castSucc in Init.Data.Fin.Basic

class GenMutualCorrParams (P : Params Œπ F) (S : ‚àÄ i : Fin (M + 1), Finset (Œπ i)) where

  Œ¥ : Fin (M + 1) ‚Üí ‚Ñù‚â•0
  dist : (i : Fin (M + 1)) ‚Üí Fin ((P.foldingParam i) + 1) ‚Üí ‚Ñù‚â•0


  œÜ : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), (indexPowT (S i) (P.œÜ i) j) ‚Ü™ F

  inst1 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Fintype (indexPowT (S i) (P.œÜ i) j)
  inst2 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    Nonempty (indexPowT (S i) (P.œÜ i) j)
  inst3 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    DecidableEq (indexPowT (S i) (P.œÜ i) j)
  inst4 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Smooth (œÜ i j)

  par‚Ñì_type : ‚àÄ i : Fin (M + 1), ‚àÄ _ : Fin ((P.foldingParam i) + 1), Type
  inst5 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Fintype (par‚Ñì_type i j)

  exp : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), (par‚Ñì_type i j) ‚Ü™ ‚Ñï



  Gen_Œ± : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    ProximityGenerator (indexPowT (S i) (P.œÜ i) j) F :=
      fun i j => RSGenerator.genRSC (par‚Ñì_type i j) (œÜ i j) (P.varCount i - j) (exp i j)

  inst6 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Fintype (Gen_Œ± i j).par‚Ñì

  BStar : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    (Set ((indexPowT (S i) (P.œÜ i) j) ‚Üí F)) ‚Üí Type ‚Üí ‚Ñù‚â•0
  errStar : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    (Set ((indexPowT (S i) (P.œÜ i) j) ‚Üí F)) ‚Üí Type ‚Üí ‚Ñù ‚Üí ENNReal

  C : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Set ((indexPowT (S i) (P.œÜ i) j) ‚Üí F)
  hcode : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), (C i j) = (Gen_Œ± i j).C

  h : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    hasMutualCorrAgreement (Gen_Œ± i j)
      (BStar i j (C i j) (Gen_Œ± i j).par‚Ñì)
      (errStar i j (C i j) (Gen_Œ± i j).par‚Ñì)

  h‚Ñì_bound : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    Fintype.card (Gen_Œ± i j).par‚Ñì = 2
  h‚Ñì_bound' : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    Fintype.card (par‚Ñì_type i j) = 2

  hŒ¥Le : ‚àÄ i : Fin (M + 1),
    (Œ¥ i) ‚â§ 1 - Finset.univ.sup (fun j => BStar i j (C i j) (Gen_Œ± i j).par‚Ñì)

  hlistDecode : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    listDecodable (C i j) (Œ¥ i) (dist i j)

structure RoundByRound
    (oSpec : OracleSpec Œπ) (StmtIn WitIn WitOut : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n)
    (WitMid : Fin (n + 1) ‚Üí Type) where
   
  eqIn : WitMid 0 = WitIn
   
  extractMid : (m : Fin n) ‚Üí StmtIn ‚Üí Transcript m.succ pSpec ‚Üí WitMid m.succ ‚Üí WitMid m.castSucc
   
  extractOut : StmtIn ‚Üí FullTranscript pSpec ‚Üí WitOut ‚Üí WitMid (.last n)

def relayPrvState (i : Fin ‚Ñì) : Fin (0 + 1) ‚Üí Type := fun
  | ‚ü®0, _‚ü© => Statement (L := L) Context i.succ √ó
    (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j) √ó
    Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ

def vcons {n : ‚Ñï} (a : Œ±) (v : Fin n ‚Üí Œ±) : Fin (n + 1) ‚Üí Œ± :=
  dcons a v

@[reducible, simp]
def OracleStatement.Lens.IsSound {OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut : Type}
    {Outer_Œπ‚Çõ·µ¢ : Type} {OuterOStmtIn : Outer_Œπ‚Çõ·µ¢ ‚Üí Type} [‚àÄ i, OracleInterface (OuterOStmtIn i)]
    {Outer_Œπ‚Çõ‚Çí : Type} {OuterOStmtOut : Outer_Œπ‚Çõ‚Çí ‚Üí Type} [‚àÄ i, OracleInterface (OuterOStmtOut i)]
    {Inner_Œπ‚Çõ·µ¢ : Type} {InnerOStmtIn : Inner_Œπ‚Çõ·µ¢ ‚Üí Type} [‚àÄ i, OracleInterface (InnerOStmtIn i)]
    {Inner_Œπ‚Çõ‚Çí : Type} {InnerOStmtOut : Inner_Œπ‚Çõ‚Çí ‚Üí Type} [‚àÄ i, OracleInterface (InnerOStmtOut i)]
    (outerLangIn : Set (OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i)))
    (outerLangOut : Set (OuterStmtOut √ó (‚àÄ i, OuterOStmtOut i)))
    (innerLangIn : Set (InnerStmtIn √ó (‚àÄ i, InnerOStmtIn i)))
    (innerLangOut : Set (InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i)))
    (compatStmt :
      OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i) ‚Üí InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i) ‚Üí Prop)
    (lens : OracleStatement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                                    OuterOStmtIn OuterOStmtOut InnerOStmtIn InnerOStmtOut) :=
  Statement.Lens.IsSound outerLangIn outerLangOut innerLangIn innerLangOut compatStmt lens

def map (f : R ‚Üí+* S) (p : MlPolyEval R n) : MlPolyEval S n :=
  Vector.map (fun a => f a) p

@[inline, specialize]
def prover : Prover oSpec Statement Witness (Statement √ó Witness) Unit (pSpec Witness) where
  PrvState
  | 0 => Statement √ó Witness
  | 1 => Statement √ó Witness
  input := id
  sendMessage | ‚ü®0, _‚ü© => fun ‚ü®stmt, wit‚ü© => pure (wit, ‚ü®stmt, wit‚ü©)
  receiveChallenge | ‚ü®0, h‚ü© => nomatch h
  output := fun ‚ü®stmt, wit‚ü© => pure (‚ü®stmt, wit‚ü©, ())

structure Params where
  
  width : Nat
  numFullRounds : Nat
  numPartialRounds : Nat
  internalDiagVectors : Vector KoalaBear.Field width
  roundConstants : Vector KoalaBear.Field (numFullRounds * width + numPartialRounds)

  

   
  [width_ne_zero : NeZero width]

   
  [numFullRounds_ne_zero : NeZero numFullRounds]

   
  [numPartialRounds_ne_zero : NeZero numPartialRounds]

   
  width_dvd_by_4 : 4 ‚à£ width
   
  numFullRounds_even : Even numFullRounds

def AlgebraTowerEquiv.algebraMapRightUp (e : AlgebraTowerEquiv A B) (i j : Œπ)
    (h : i ‚â§ j) : (A i) ‚Üí+* (B j) :=

AddCommMonoid in Mathlib.Algebra.Group.Defs

Exists in Init.Core

List.splitBy in Init.Data.List.Basic

def inputRelation (cond : ‚àë i, (s i).1 ‚â§ n) [DecidableEq F] (Œ¥ : ‚Ñù‚â•0) :
    Set
      (
        (
          Statement F (Fin.last k) √ó
          (‚àÄ j, OracleStatement D x s (Fin.last k) j)
        ) √ó
        Witness F s d (Fin.last k).castSucc
      ) := sorry

instance [inst : OracleInterface Msg] : ‚àÄ i, OracleInterface (Message ‚ü®!v[.P_to_V], !v[Msg]‚ü© i)
  | ‚ü®0, _‚ü© => inst

def isCompliant (i : Fin (‚Ñì)) (steps : ‚Ñï) [NeZero steps]
  (h_i_add_steps : i + steps ‚â§ ‚Ñì)
  (f_i : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i, by admit /- proof elided -/
  ‚ü©)
  (f_i_plus_steps : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      ‚ü®i + steps, by admit /- proof elided -/
      ‚ü©)
  (challenges : Fin steps ‚Üí L) : Prop :=
  ‚àÉ (h_fw_dist_lt : 2 * fiberwiseDistance ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := i)
      (steps := steps) h_i_add_steps f_i < (BBF_CodeDistance ‚Ñì ùì° ‚ü®i + steps, by admit /- proof elided -/
      ‚ü© : ‚Ñï‚àû))
    (h_dist_next_lt : 2 * distFromCode f_i_plus_steps
      (BBF_Code ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i + steps, by admit /- proof elided -/
      ‚ü©)
      < (BBF_CodeDistance ‚Ñì ùì° ‚ü®i + steps, by admit /- proof elided -/
      ‚ü© : ‚Ñï‚àû)), 
    
    let h_dist_curr_lt := fiberwise_dist_lt_imp_dist_lt_unique_decoding_radius ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := i) steps h_i_add_steps f_i
      (h_fw_dist_lt := h_fw_dist_lt)
    let f_bar_i := uniqueClosestCodeword ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (i := ‚ü®i, by admit /- proof elided -/
      ‚ü©) (h_i := fin_‚Ñì_lt_‚Ñì_add_R i) f_i h_dist_curr_lt
    let f_bar_i_plus_steps := uniqueClosestCodeword ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := ‚ü®i + steps, by admit /- proof elided -/
      ‚ü©)
      (h_i := fin_‚Ñì_steps_lt_‚Ñì_add_R i steps h_i_add_steps)
      f_i_plus_steps h_dist_next_lt
    iterated_fold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (steps := ‚ü®steps, by admit /- proof elided -/
      ‚ü©)
      (i := ‚ü®i, by admit /- proof elided -/
      ‚ü©)
      (h_i_add_steps := by admit /- proof elided -/
      )
      f_bar_i challenges = f_bar_i_plus_steps

instance (priority := 1000) algebra_adjacent_tower (l : ‚Ñï) :
  Algebra (BTField l) (BTField (l+1)) :=

Set.Pairwise in Mathlib.Logic.Pairwise

Polynomial.rootMultiplicity in Mathlib.Algebra.Polynomial.Div

structure AlgebraTowerEquiv (A : Œπ ‚Üí Type*) [‚àÄ i, CommSemiring (A i)] [a : AlgebraTower A]
  (B : Œπ ‚Üí Type*) [‚àÄ i, CommSemiring (B i)] [b : AlgebraTower B]
  where
    toRingEquiv : ‚àÄ i, (A i ‚âÉ+* B i)
    commutesLeft' : ‚àÄ (i j : Œπ) (h : i ‚â§ j) (r : A i),
      (b.algebraMap (i:=i) (j:=j) (h:=h)) ((toRingEquiv i) r) =
      (toRingEquiv j) (a.algebraMap (i:=i) (j:=j) (h:=h) r)

def rawConstants16 : Vector KoalaBear.Field 148 := #v[
    2128964168,
    288780357,
    316938561,
    2126233899,
    426817493,
    1714118888,
    1045008582,
    1738510837,
    889721787,
    8866516,
    681576474,
    419059826,
    1596305521,
    1583176088,
    1584387047,
    1529751136,
    1863858111,
    1072044075,
    517831365,
    1464274176,
    1138001621,
    428001039,
    245709561,
    1641420379,
    1365482496,
    770454828,
    693167409,
    757905735,
    136670447,
    436275702,
    525466355,
    1559174242,
    1030087950,
    869864998,
    322787870,
    267688717,
    948964561,
    740478015,
    679816114,
    113662466,
    2066544572,
    1744924186,
    367094720,
    1380455578,
    1842483872,
    416711434,
    1342291586,
    1692058446,
    1493348999,
    1113949088,
    210900530,
    1071655077,
    610242121,
    1136339326,
    2020858841,
    1019840479,
    678147278,
    1678413261,
    1361743414,
    61132629,
    1209546658,
    64412292,
    1936878279,
    1980661727,
    1423960925,
    2101391318,
    1915532054,
    275400051,
    1168624859,
    1141248885,
    356546469,
    1165250474,
    1320543726,
    932505663,
    1204226364,
    1452576828,
    1774936729,
    926808140,
    1184948056,
    1186493834,
    843181003,
    185193011,
    452207447,
    510054082,
    1139268644,
    630873441,
    669538875,
    462500858,
    876500520,
    1214043330,
    383937013,
    375087302,
    636912601,
    307200505,
    390279673,
    1999916485,
    1518476730,
    1606686591,
    1410677749,
    1581191572,
    1004269969,
    143426723,
    1747283099,
    1016118214,
    1749423722,
    66331533,
    1177761275,
    1581069649,
    1851371119,
    852520128,
    1499632627,
    1820847538,
    150757557,
    884787840,
    619710451,
    1651711087,
    505263814,
    212076987,
    1482432120,
    1458130652,
    382871348,
    417404007,
    2066495280,
    1996518884,
    902934924,
    582892981,
    1337064375,
    1199354861,
    2102596038,
    1533193853,
    1436311464,
    2012303432,
    839997195,
    1225781098,
    2011967775,
    575084315,
    1309329169,
    786393545,
    995788880,
    1702925345,
    1444525226,
    908073383,
    1811535085,
    1531002367,
    1635653662,
    1585100155,
    867006515,
    879151050,
]

MvPolynomial.restrictDegree in Mathlib.RingTheory.MvPolynomial.Basic

Multiset.count in Mathlib.Data.Multiset.Count

def add_descending (p q : UniPoly R) : QuotientUniPoly R :=
  Quotient.mk _ (add p q)

Polynomial.ofFn in Mathlib.Algebra.Polynomial.OfFn

instance : ‚àÄ i, VCVCompatible ((pSpec Witness).Challenge i) | ‚ü®0, h‚ü© => nomatch h

@[reducible]
def empty : ProtocolSpec 0 := ‚ü®!v[], !v[]‚ü©

instance {k : Fin 1} : Unique (MessagesUpTo k !p[]) where
  default := fun ‚ü®‚ü®i, h‚ü©, _‚ü© => by admit /- proof elided -/

Function.Surjective in Init.Data.Function

Algebra.algebraMap in Mathlib.Algebra.Algebra.Defs

instance : ‚àÄ i, SelectableType (Challenge !p[] i) :=
  fun ‚ü®i, h‚ü© =>
    (Fin.elim0 i : (h' : !p[].dir i = .V_to_P) ‚Üí SelectableType (!p[].Challenge ‚ü®i, h'‚ü©)) h

Int.negSucc in Init.Data.Int.Basic

@[reducible, simp] def WitOut := Unit

@[inline] def succ (a : Cayley T) : Cayley T := add a one

instance domain_neg_inst {F : Type} [NonBinaryField F] [Finite F] {D : Subgroup FÀ£} {n : ‚Ñï}
    [DIsCyclicC : IsCyclicWithGen ‚Ü•D] [DSmooth : SmoothPowerOfTwo n ‚Ü•D]
    {x : FÀ£} (i : Fin n) : Neg (evalDomain D x i) where
  neg := fun a => ‚ü®_, neg_mem_dom_of_mem_dom D x i a.2‚ü©

def hint (state : HashStateWithInstructions U H) :
    Except DomainSeparatorMismatch (HashStateWithInstructions U H) := do
  
  sorry

@[reducible, simp]
def OStmtOut : Unit ‚Üí Type := fun _ => R‚¶É‚â§ deg‚¶Ñ[X]

instance {Œ± : Type u} : SliceGE (List Œ±) Nat (fun _ _ => True) (fun _ _ _ => List Œ±) where
  sliceGE xs start _ := List.drop start xs

Inhabited in Init.Prelude

def proximityChecksSpec (Œ≥_challenges :
    Fin Œ≥_repetitions ‚Üí sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®0, by omega‚ü©)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì) j)
    (fold_challenges : Fin ‚Ñì ‚Üí L) (final_constant : L) : Prop :=
  ‚àÄ rep : Fin Œ≥_repetitions,
    let v := Œ≥_challenges rep
    -- For all folding levels k = 0, ..., ‚Ñì/œë - 1, we track c_cur through the iterations
    ‚àÄ k_val : Fin (‚Ñì / œë),
      let i := k_val.val * œë
      have h_k: k_val ‚â§ (‚Ñì/œë - 1) := by omega
      have h_i_add_œë_le_‚Ñì : i + œë ‚â§ ‚Ñì := by
        calc i + œë = k_val * œë + œë := by omega
          _ ‚â§ (‚Ñì/œë - 1) * œë + œë := by
            apply Nat.add_le_add_right; apply Nat.mul_le_mul_right; omega
          _ = ‚Ñì/œë * œë :=

@[inline, reducible]
def srChallengeOracle (Statement : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n) :
    OracleSpec pSpec.ChallengeIdx :=
  [pSpec.Challenge]‚Çí'(challengeOracleInterfaceSR Statement pSpec)

alias fsChallengeOracle := srChallengeOracle

noncomputable def novelToMonomialCoeffs

  (‚Ñì : ‚Ñï) (h_‚Ñì : ‚Ñì ‚â§ r) (novel_coeffs : Fin (2 ^ ‚Ñì) ‚Üí L) : Fin (2^‚Ñì) ‚Üí L :=
  let A := changeOfBasisMatrix ùîΩq Œ≤ ‚Ñì h_‚Ñì
  Matrix.vecMul novel_coeffs A

instance : ‚àÄ j, OracleInterface ((pSpec F).Message j)
  | ‚ü®0, h‚ü© => nomatch h
  | ‚ü®1, _‚ü© => by admit /- proof elided -/

def finSuccEquivNth : MvPolynomial (Fin (n + 1)) R ‚âÉ‚Çê[R] Polynomial (MvPolynomial (Fin n) R) :=
  (renameEquiv R (_root_.finSuccEquiv' p)).trans (optionEquivLeft R (Fin n))

instance : Fintype (pSpec.ChallengeIdx) := Subtype.fintype (fun i => pSpec.dir i = .V_to_P)

def BinaryTowerAux (k : ‚Ñï) : (Œ£' (F : Type 0), BinaryTowerResult F k) :=
  match k with
  | 0 => 
    let curBTField := GF(2)
    let newList : List.Vector (GF(2)) 1 := List.Vector.cons (1 : GF(2)) List.Vector.nil
    let specialElement : GF(2) := newList.1.headI
    let firstElementOfVecIsSpecialElement : newList.1.headI = specialElement := rfl
    let specialElementIs1 : specialElement = 1 := by admit /- proof elided -/

def snoc_oracle {i : Fin ‚Ñì}
    (oStmtIn : ‚àÄ j : Fin (toOutCodewordsCount ‚Ñì œë i.castSucc),
      OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j)
    (newOracleFn : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ) :
    ‚àÄ j : Fin (toOutCodewordsCount ‚Ñì œë i.succ),
      OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.succ j := fun j =>
  have h_succ_val: i.succ.val = i.val + 1 := rfl
  if hj: j.val < (toOutCodewordsCount ‚Ñì œë i.castSucc) then
    oStmtIn ‚ü®j, by admit /- proof elided -/
    ‚ü©
  else 
    
    if hi: isCommitmentRound ‚Ñì œë i then
      
      
      have h_count_succ : toOutCodewordsCount ‚Ñì œë i.succ =
        toOutCodewordsCount ‚Ñì œë i.castSucc + 1 := by admit /- proof elided -/

@[simp]
abbrev Witness.AfterFirstChallenge : Type := Unit

class Smooth
  (domain : Œπ ‚Ü™ F) where
    H : Subgroup (Units F)
    a           : Units F
    h_coset     : Finset.image domain Finset.univ
                  = (fun h : Units F => (a : F) * (h : F)) '' (H : Set (Units F))
    h_card_pow2 : ‚àÉ k : ‚Ñï, Fintype.card Œπ = 2 ^ k

@[reducible, simp]
def toRelOut : Set ((Statement √ó Witness) √ó Unit) :=
  Prod.fst ‚Åª¬π' relIn

@[inline, reducible]
def Statement.Lens (OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut : Type)
  := PFunctor.Lens (OuterStmtIn X^ OuterStmtOut)
                   (InnerStmtIn X^ InnerStmtOut)

inductive LeafData (Œ± : Type) : Skeleton ‚Üí Type
  | leaf (value : Œ±) : LeafData Œ± Skeleton.leaf
  | internal {left right} (leftData : LeafData Œ± left) (rightData : LeafData Œ± right) :
      LeafData Œ± (Skeleton.internal left right)
  deriving Repr

@[reducible, simp]
def rbrKnowledgeSoundness (relation : Set (Statement √ó Bool))
    (verifier : Verifier oSpec Statement Bool pSpec)
    (rbrKnowledgeError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) : Prop :=
  verifier.rbrKnowledgeSoundness init impl relation acceptRejectRel rbrKnowledgeError

instance polyMonic (n : ‚Ñï) : Monic (poly n) := definingPoly_is_monic (Z n)

@[inline] def mod [Zero T] [DecidableEq T] [ToNat T]
    (dividend divisor : Cayley T) : Cayley T :=
  
  letI fuel := (‚Üëdividend : Nat) + 1
  modNat dividend divisor fuel

def getCommitProverFinalOutput (i : Fin ‚Ñì)
    (inputPrvState : commitPrvState (Context := Context) ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i 0) :
  (‚Ü•(sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®‚Üëi + 1, by admit /- proof elided -/
  ‚ü©) ‚Üí L) √ó
  commitPrvState (Context := Context) ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i 1 :=
  let (stmt, oStmtIn, wit) := inputPrvState
  let f·µ¢_succ := wit.f
  let oStmtOut := snoc_oracle ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
    oStmtIn f·µ¢_succ 
  (f·µ¢_succ, (stmt, oStmtOut, wit))

@[reducible, inline, specialize]
def ChallengesUpTo (k : Fin (n + 1)) (pSpec : ProtocolSpec n) : Type :=
  ‚àÄ i, (pSpec.take k k.is_le).Challenge i

instance {n : ‚Ñï} {Œ± : Fin n ‚Üí Type*} : Slice ((i : Fin n) ‚Üí Œ± i) ‚Ñï ‚Ñï
    (fun _ start stop => start ‚â§ stop ‚àß stop ‚â§ n)
    (fun _ start stop h =>
      (i : Fin (stop - start)) ‚Üí
        Œ± (castLE h.2 (Fin.cast (Nat.sub_add_cancel h.1) (i.addNat start))))
    where
  slice := fun v start stop h => Fin.drop start h.1 (Fin.take stop h.2 v)

def multilinearBasis (l r : ‚Ñï) (h_le : l ‚â§ r) :
    letI instAlgebra : Algebra (BTField l) (BTField r) := binaryAlgebraTower (h_le:=h_le)
    Basis (Fin (2 ^ (r - l))) (BTField l) (BTField r) :=

Matrix.of in Mathlib.LinearAlgebra.Matrix.Defs

def starData {Œ±} (k : ‚Ñï) (root : Œ±) (leaves : Fin k ‚Üí Œ±) :
    ArityTree.Data Œ± (starSkel k) :=

HMod.hMod in Init.Prelude

noncomputable def X‚±º (‚Ñì : ‚Ñï) (h_‚Ñì : ‚Ñì ‚â§ r) (j : Fin (2 ^ ‚Ñì)) : L[X] :=
  (Finset.univ : Finset (Fin ‚Ñì)).prod
    (fun i => (normalizedW ùîΩq Œ≤ (Fin.castLE h_‚Ñì i))^(Nat.getBit i j))

def mul_by_2 (s : Finset ‚Ñï) : Finset ‚Ñï :=
  s.map ‚ü®fun n => 2 * n, by admit /- proof elided -/
  ‚ü©

instance instOracleStatementBinaryBasefold {i : Fin (‚Ñì + 1)} :
    ‚àÄ j, OracleInterface (OracleStatement ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i j) :=
  fun j => {
    Query := (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®j.val * œë, by admit /- proof elided -/
      ‚ü©
    Response := L
    answer := fun oracleData queryPoint => oracleData queryPoint
  }

@[reducible]
noncomputable def fullOracleProof :
  OracleProof []‚Çí
    (Statement := Statement (L := L) (‚Ñì:=‚Ñì) (SumcheckBaseContext L ‚Ñì) 0)
    (OStatement := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë 0)
    (Witness := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) 0)
    (pSpec:=fullPSpec ùîΩq Œ≤ Œ≥_repetitions (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)) :=
  fullOracleReduction ùîΩq Œ≤ Œ≥_repetitions (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë)

def hammingClose (i : Fin (‚Ñì + 1)) (f : OracleFunction ùîΩq Œ≤
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) : Prop :=
  2 * Code.distFromCode (u := f)
    (C := BBF_Code ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) <
    (BBF_CodeDistance ‚Ñì ùì° i : ‚Ñï‚àû)

instance {Œ± : Type u} : Slice (Array Œ±) Nat Nat (fun _ _ _ => True) (fun _ _ _ _ => Array Œ±) where
  slice xs start stop _ := xs.extract start stop

inductive PrattPartList : (p : ‚Ñï) ‚Üí (a : ZMod p) ‚Üí ‚Ñï ‚Üí Prop
  | prime : {p : ‚Ñï} ‚Üí {a : ZMod p} ‚Üí (n k nk : ‚Ñï) ‚Üí n.Prime ‚Üí
      a ^ ((p - 1) / n) ‚â† 1 ‚Üí n ^ k = nk ‚Üí PrattPartList p a nk
  | split : {p : ‚Ñï} ‚Üí {a : ZMod p} ‚Üí {n : ‚Ñï} ‚Üí (list : List ‚Ñï) ‚Üí
      (‚àÄ r ‚àà list, PrattPartList p a r) ‚Üí list.prod = n ‚Üí PrattPartList p a n

Polynomial.coeff in Mathlib.Algebra.Polynomial.Basic

def subNat (c : AssocNat) : Nat ‚Üí AssocNat
| 0            => c 
| Nat.succ k   => pred (subNat c k) 

@[inline, specialize]
def add {R : Type*} [Ring R] [BEq R] [LawfulBEq R] (p q : QuotientUniPoly R) : QuotientUniPoly R :=
  Quotient.lift‚ÇÇ add_descending add_descends p q

abbrev CNat (n : ‚Ñï) : Type := (CayleyTower n).1

def finalNonDoomedFoldingProp {h_le : œë ‚â§ ‚Ñì}
    (input : (FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì) √ó
      (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì) j))) :
    Prop :=
  let stmt := input.1
  let oStmt := input.2
  let f_‚Ñì: (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®‚Ñì, by admit /- proof elided -/
  ‚ü© ‚Üí L := fun x => stmt.final_constant
  let j := mkLastOracleIndex ‚Ñì œë (Fin.last ‚Ñì) 
  let k := j.val * œë
  have h_k: k = ‚Ñì - œë := by admit /- proof elided -/

def oStmtLens (i : Fin n) : OracleStatement.Lens
    (StatementRound R n i.castSucc) (StatementRound R n i.succ) (Simple.StmtIn R) (Simple.StmtOut R)
    (OracleStatement R n deg) (OracleStatement R n deg)
    (Simple.OStmtIn R deg) (Simple.OStmtOut R deg) where

  toFunA := fun ‚ü®‚ü®target, challenges‚ü©, oStmt‚ü© =>
    ‚ü®target, fun _ =>
      match h : n with
      | 0 => ‚ü®Polynomial.C <| MvPolynomial.isEmptyAlgEquiv R (Fin 0) (oStmt ()), by admit /- proof elided -/
        ‚ü©
      | n + 1 =>
      ‚ü®‚àë x ‚àà (univ.map D) ^·∂† (n - i), (oStmt ()).val ‚∏®X ‚¶Éi‚¶Ñ, challenges, x‚∏©'(by admit /- proof elided -/
      ),
        sumcheck_roundPoly_degreeLE R n deg D i (oStmt ()).property‚ü©‚ü©

  toFunB := fun ‚ü®‚ü®_oldTarget, challenges‚ü©, oStmt‚ü© ‚ü®‚ü®newTarget, chal‚ü©, oStmt'‚ü© =>
    ‚ü®‚ü®newTarget, Fin.snoc challenges chal‚ü©, oStmt‚ü©

def squeeze (ds : DomainSeparator U H) (count : Nat) (label : String) : DomainSeparator U H :=
  
  
  
  
  { io := ds.io ++ SEP_BYTE ++ s!"S{count}" ++ label }

LawfulFunctor in Init.Control.Lawful.Basic

Nat.succ in Init.Prelude

noncomputable instance finiteDimensionalCoeffVecSpace (‚Ñì : ‚Ñï) :
  FiniteDimensional (K := L) (V := CoeffVecSpace L ‚Ñì) :=

instance {Œ± : Type u} : Slice (List Œ±) Nat Nat (fun _ _ _ => True) (fun _ _ _ _ => List Œ±) where
  slice xs start stop _ := xs.extract start stop

noncomputable def towerEquiv_zero : RingEquiv (R:=GF(2)) (S:=ConcreteBTField 0) :=  {
  toFun := fun x => if x = 0 then 0 else 1,
  invFun := fun x => if x = 0 then 0 else 1,
  left_inv := fun x => by admit /- proof elided -/

@[reducible]
def GroupOpOracle : OracleSpec Unit := fun _ => (Œπ √ó Œπ √ó Œπ, Unit)

abbrev MultilinearPoly (L : Type) [CommSemiring L] (‚Ñì : ‚Ñï) := L‚¶É‚â§ 1‚¶Ñ[X Fin ‚Ñì]

Fin.append in Mathlib.Data.Fin.Tuple.Basic

def pow (S : Finset Œπ) (œÜ : Œπ ‚Ü™ F) (k : ‚Ñï) : indexPow S œÜ k ‚Ü™ F :=
    Function.Embedding.subtype fun y => y ‚àà indexPow S œÜ k

instance {pSpec : ProtocolSpec n} : CoeHead (ChallengeIdx pSpec) (Fin n) where
  coe := fun i => i.1

noncomputable def polyToPowerSeriesùïÉ (H : F[X][Y])
  (P : F[X][Y])
    : PowerSeries (ùïÉ H) :=
  PowerSeries.mk <| fun n =>
    liftToFunctionField (P.coeff n)

class VerifierOnly (pSpec : ProtocolSpec 1) extends VerifierFirst pSpec

class HListRepr (Œ± : Type _) where
  repr: Œ± ‚Üí Std.Format

def eval‚ÇÇAlgHom {A : Type w} {B : Type*} [CommSemiring A] [CommSemiring B] [PolynomialLike A P]
    [Algebra R A] [IsScalarTower R A P] [Algebra R B] (f : A ‚Üí‚Çê[R] B) (b : B) :
      P ‚Üí‚Çê[R] B where
  toRingHom := eval‚ÇÇ f b
  commutes' := by admit /- proof elided -/

def queryRbrKnowledgeError := fun _ : (pSpecQuery ùîΩq Œ≤ Œ≥_repetitions
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).ChallengeIdx =>
  ((1/2 : ‚Ñù‚â•0) + (1 : ‚Ñù‚â•0) / (2 * 2^ùì°))^Œ≥_repetitions

Fin.castLT in Init.Data.Fin.Basic

RingHom in Mathlib.Algebra.Ring.Hom.Defs

@[inline, reducible]
def proj : (OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i)) √ó OuterWitIn ‚Üí
    (InnerStmtIn √ó (‚àÄ i, InnerOStmtIn i)) √ó InnerWitIn :=
  fun ctxIn => ‚ü®lens.stmt.proj ctxIn.1, lens.wit.proj ctxIn‚ü©

Array.foldlM in Init.Data.Array.Basic

List.length in Init.Prelude

@[inline]
def add [Add R] (p q : MlPolyEval R n) : MlPolyEval R n := Vector.zipWith (¬∑ + ¬∑) p q

instance : ‚àÄ j, OracleInterface (OracleStatement D x m j) :=
  fun _ => inferInstance

def deriveTranscriptSRAux {Œπ : Type} {oSpec : OracleSpec Œπ} {StmtIn : Type}
    (stmt : StmtIn) (k : Fin (n + 1)) (messages : pSpec.MessagesUpTo k)
    (j : Fin (k + 1)) :
    OracleComp (oSpec ++‚Çí fsChallengeOracle StmtIn pSpec)
      (pSpec.Transcript (j.castLE (by admit /- proof elided -/
      ))) := do
  Fin.induction (n := k)
    (pure (fun i => i.elim0))
    (fun i ih => do
      let prevTranscript ‚Üê ih
      match hDir : pSpec.dir (i.castLE (by admit /- proof elided -/
      )) with
      | .V_to_P =>
        let challenge : pSpec.Challenge ‚ü®i.castLE (by admit /- proof elided -/
        ), hDir‚ü© ‚Üê
          query (spec := fsChallengeOracle _ _) ‚ü®i.castLE (by admit /- proof elided -/
          ), hDir‚ü©
            (stmt, messages.take i.castSucc)
        return prevTranscript.concat challenge
      | .P_to_V => return prevTranscript.concat (messages ‚ü®i, hDir‚ü©))
    j

List.max? in Init.Data.List.Basic

def squeezeInto (sponge : DuplexSponge U C) (arr : Array U) :
    OracleComp (forwardPermutationOracle C) (DuplexSponge U C √ó Array U) := do
  if hEmpty : arr.isEmpty then
    return (sponge, #[])
  else
    
    let sponge1 : DuplexSponge U C := { sponge with absorbPos := 0 }
    
    
    
    let ‚ü®sponge2, h‚ü© ‚Üê
      if hFull : sponge1.squeezePos = SpongeSize.R then do
        let permutedState ‚Üê query (spec := forwardPermutationOracle _) () sponge1.state
        let sponge2 : DuplexSponge U C := { sponge1 with state := permutedState, squeezePos := 0 }
        have : sponge2.squeezePos < SpongeSize.R := by admit /- proof elided -/

List.Vector.get in Mathlib.Data.Vector.Defs

@[inline, specialize, simp]
def oracleReduction : OracleReduction oSpec
    Statement OStatement Witness Statement OStatement Witness !p[] := OracleReduction.id

Vector.drop in Init.Data.Vector.Basic

def SparseMatrix.toMatrix {m n Œ± : Type*} [DecidableEq m] [DecidableEq n] [AddCommMonoid Œ±]
    (A : SparseMatrix m n Œ±) : Matrix m n Œ± :=
  fun i j => ‚àë k : Fin A.numEntries, if A.row k = i ‚àß A.col k = j then A.val k else 0

Sub in Init.Prelude

abbrev PermuteDir := Unit ‚äï Unit

structure InitialStatement where
  
  t_eval_point : Fin ‚Ñì ‚Üí L         
  original_claim : L               

instance : VAdd (Œπ ‚Üí F) (AffineSubspace F (Œπ ‚Üí F)) := AffineSubspace.pointwiseVAdd

@[reducible, inline, specialize]
def Transcript (k : Fin (n + 1)) (pSpec : ProtocolSpec n) : Type :=
  (pSpec‚ü¶:k.val‚üß).FullTranscript

@[simp]
def ùïè (k : ‚Ñï) : BTField (k+1) := Z (k+1)

abbrev ScalarField := ZMod scalarFieldSize

def totalNumQueries (stmt : StmtIn) (challenges : ‚àÄ i, pSpec.Challenge i)
    (naVerifier : OracleVerifier.NonAdaptive oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec) : ‚Ñï :=
  (naVerifier.queryOStmt stmt challenges).length + (naVerifier.queryMsg stmt challenges).length

LE.le in Init.Prelude

noncomputable def sDomainToFin (i : Fin r) (h_i : i < ‚Ñì + R_rate)
  (x : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i) :
  Fin (2^(‚Ñì + R_rate - i.val)) :=

LinearIndependent in Mathlib.LinearAlgebra.LinearIndependent.Defs

def findIdxRev? (cond : Œ± ‚Üí Bool) (as : Array Œ±) : Option (Fin as.size) :=
  find ‚ü® as.size, Nat.lt_succ_self _ ‚ü©
where
  find : Fin (as.size + 1) ‚Üí Option (Fin as.size)
    | 0 => none
    | ‚ü® i+1, h ‚ü© =>
      if (cond as[i]) then
        some ‚ü® i, Nat.lt_of_succ_lt_succ h ‚ü©
      else
        find ‚ü® i, Nat.lt_of_succ_lt h ‚ü©

def Verifier.KnowledgeStateFunction.id {rel : Set (Statement √ó Witness)} :
    (Verifier.id : Verifier oSpec Statement _ _).KnowledgeStateFunction init impl rel rel
      (Extractor.RoundByRound.id) where
  toFun | ‚ü®0, _‚ü© => fun stmtIn _ witIn => (stmtIn, witIn) ‚àà rel
  toFun_empty := fun _ => by admit /- proof elided -/

protected def Reduction.id : Reduction oSpec Statement Witness Statement Witness !p[] where
  prover := Prover.id
  verifier := Verifier.id

instance : HListString (HList []) where
  toString
  | HList.nil => ""

Vector.finRange in Init.Data.Vector.FinRange

@[elab_as_elim]
def dconcat {n : ‚Ñï} {motive : Fin (n + 1) ‚Üí Sort u}
    (u : (i : Fin n) ‚Üí motive i.castSucc) (a : motive (last n)) (i : Fin (n + 1)) : motive i :=
  match n with
  | 0 => match i with | 0 => a
  | _ + 1 => dcons (u 0) (dconcat (fun i => u (Fin.succ i)) a) i

WeierstrassCurve in Mathlib.AlgebraicGeometry.EllipticCurve.Weierstrass

System.FilePath.addExtension in Init.System.FilePath

def leftpad (m‚ÇÇ n‚ÇÇ : ‚Ñï) (a : Œ±) {m‚ÇÅ n‚ÇÅ : ‚Ñï} (M : Matrix (Fin m‚ÇÅ) (Fin n‚ÇÅ) Œ±) :
    Matrix (Fin m‚ÇÇ) (Fin n‚ÇÇ) Œ± :=
  Fin.leftpad m‚ÇÇ (fun _ => a) (Fin.leftpad n‚ÇÇ a ‚àò M)

instance {Œ± : Type} [Sampleable Œ±] : DecidableEq Œ± := inferInstance

@[reducible]
def foldCommitOracleReduction (i : Fin ‚Ñì)
    (hCR : isCommitmentRound ‚Ñì œë i) :
  OracleReduction []‚Çí
    (StmtIn := Statement (L := L) Context i.castSucc)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) i.castSucc)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) i.succ)
    (pSpec := pSpecFoldCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) :=
  OracleReduction.append (oSpec:=[]‚Çí)
    (pSpec‚ÇÅ := pSpecFold (L:=L))
    (pSpec‚ÇÇ := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)
    (R‚ÇÅ := foldOracleReduction ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) i)
    (R‚ÇÇ := commitOracleReduction ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hCR)

inductive InternalData (Œ± : Type) : Skeleton ‚Üí Type
  | leaf : InternalData Œ± Skeleton.leaf
  | internal {left right} (value : Œ±)
      (leftData : InternalData Œ± left)
      (rightData : InternalData Œ± right) : InternalData Œ± (Skeleton.internal left right)
  deriving Repr

def computableNTTStage [Fact (LinearIndependent ùîΩq Œ≤)]
  (i : Fin ‚Ñì) (b : Fin (2 ^ (‚Ñì + R_rate)) ‚Üí L) : Fin (2^(‚Ñì + R_rate)) ‚Üí L :=
  have h_2_pow_i_lt_2_pow_‚Ñì_add_R_rate: 2^i.val < 2^(‚Ñì + R_rate) := by admit /- proof elided -/

def FullData.rightSubtree {Œ± : Type} {s_left s_right : Skeleton}
    (tree : FullData Œ± (Skeleton.internal s_left s_right)) :
    FullData Œ± s_right :=
  match tree with
  | FullData.internal _ _left right =>
    right

class AlgebraTower {Œπ : Type*} [Preorder Œπ] (AT : Œπ ‚Üí Type*)
  [‚àÄ i, CommSemiring (AT i)] where
   
  protected algebraMap : ‚àÄ i j, (h : i ‚â§ j) ‚Üí (AT i ‚Üí+* AT j)
   
  commutes' : ‚àÄ (i j : Œπ) (h : i ‚â§ j) (r : AT i) (x : AT j),
    (algebraMap i j h r) * x = x * (algebraMap i j h r)
  coherence': ‚àÄ (i j k : Œπ) (h1 : i ‚â§ j) (h2 : j ‚â§ k),
    algebraMap i k (h1.trans h2) =
      (algebraMap j k h2).comp (algebraMap i j h1)

instance {Œ± : Type*} [Fintype Œ±] : Dist (PMF Œ±) where
  dist := fun a b => ‚àë x, abs ((a x).toReal - (b x).toReal)

noncomputable def vanishingPoly (S : Finset F) : Polynomial F :=
  ‚àè s ‚àà S, (Polynomial.X - Polynomial.C s)

instance {k : Fin 1} : Unique (ChallengesUpTo k (default : ProtocolSpec 0)) where
  default := fun i => ()
  uniq := by admit /- proof elided -/

noncomputable def batchOracleReduction :
  OracleReduction []‚Çí
    Unit (OracleStatement D x m) (Witness F s d m)
    ((Fin m ‚Üí F) √ó Fri.Spec.Statement F (0 : Fin (k + 1)))
    (OracleStatement D x m)
    (Fri.Spec.Witness F s d (0 : Fin (k + 2)))
    (batchSpec F m) where
  prover := batchProver D x s d m
  verifier := batchVerifier (k := k) D x m

@[reducible, simp]
def relOut : Set (Statement √ó Unit) := Set.univ

def whirRelation
    {F : Type} [Field F] [Fintype F] [DecidableEq F]
    {Œπ : Type} [Fintype Œπ] [Nonempty Œπ]
    (varCount : ‚Ñï) (œÜ : Œπ ‚Ü™ F) [Smooth œÜ] (err : ‚Ñù)
    : Set ((Unit √ó ‚àÄ i, (OracleStatement Œπ F i)) √ó Unit) :=
  { ‚ü®‚ü®_, oracle‚ü©, _‚ü© | Œ¥·µ£(oracle (), smoothCode œÜ varCount) ‚â§ err }

@[simp]
instance BTFieldIsField (k : ‚Ñï) : Field (BTField k) := (BinaryTowerAux k).2.instField

AdjoinRoot.of in Mathlib.RingTheory.AdjoinRoot

Matrix.col in Mathlib.LinearAlgebra.Matrix.Defs

Fintype in Mathlib.Data.Fintype.Defs

def perfectCorrectness (scheme : Scheme oSpec Data Randomness Commitment pSpec) : Prop :=
  correctness scheme 0

def finIdxOfIfTrue [BEq Œ±] [LawfulBEq Œ±] (a : Œ±) (l : List Œ±) (h : a ‚àà l) : Fin l.length :=
  ‚ü®List.idxOf' a l, by admit /- proof elided -/
  ‚ü©

noncomputable def evenRefinement (i : Fin (‚Ñì))
    (coeffs : Fin (2 ^ (‚Ñì - i)) ‚Üí L) : L[X] :=
  ‚àë (‚ü®j, hj‚ü©: Fin (2^(‚Ñì-i-1))), C (coeffs ‚ü®j*2, by admit /- proof elided -/
  ‚ü©) * (intermediateNovelBasisX ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i+1, by admit /- proof elided -/
  ‚ü© ‚ü®j, hj‚ü©)

instance [Repr Œ±] (Œ±s : List Type) [HListRepr (HList Œ±s)] : HListRepr (HList (Œ± :: Œ±s)) where
  repr
  | HList.cons x xs =>
    match xs with
    | HList.nil => reprPrec x 0
    | HList.cons _ _ => reprPrec x 0 ++ ", " ++ HListRepr.repr xs

def completeness
    (relIn : Set ((StmtIn √ó ‚àÄ i, OStmtIn i) √ó WitIn))
    (relOut : Set ((StmtOut √ó ‚àÄ i, OStmtOut i) √ó WitOut))
    (oracleReduction : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec)
    (completenessError : ‚Ñù‚â•0) : Prop :=
  Reduction.completeness init impl relIn relOut oracleReduction.toReduction completenessError

def somePairs : HList' (fun x => x √ó x) someTypes :=
  HList'.cons (1, 1) (HList'.cons ("good", "bad") (HList'.cons (5, 3) HList'.nil))

Subgroup.zpowers in Mathlib.Algebra.Group.Subgroup.ZPowers.Basic

LinearEquiv in Mathlib.Algebra.Module.Equiv.Defs

Nat.clog in Mathlib.Data.Nat.Log

def findIdxRev?_maximal {cond} {as : Array Œ±} {k : Fin as.size} :
  findIdxRev? cond as = some k ‚Üí ‚àÄ j : Fin as.size, j > k ‚Üí ¬¨ cond as[j] :=

def oracleReduction.firstChallenge :
    OracleReduction oSpec
      (Statement.AfterFirstMessage R pp) (OracleStatement.AfterFirstMessage R pp) (Witness R pp)
      (Statement.AfterFirstChallenge R pp) (OracleStatement.AfterFirstChallenge R pp) Unit
      ‚ü®!v[.V_to_P], !v[FirstChallenge R pp]‚ü© :=
  sorry

def take (j : Fin (n + 1)) (messages : Messages pSpec) : MessagesUpTo j pSpec :=

structure Opening where
  opening : Proof oSpec (Commitment √ó O.Query √ó O.Response) (Data √ó Randomness) pSpec

class Permute (Œ± : Type*) where
  permute : Œ± ‚Üí Œ±

instance (priority := high) : MonadLiftT (OracleComp []‚Çí) (OracleComp spec) where
  monadLift := OracleComp.construct pure (fun a => by admit /- proof elided -/
  ) failure

def OracleSpec.FunctionType (spec : OracleSpec Œπ) := (i : Œπ) ‚Üí spec.domain i ‚Üí spec.range i

MvPolynomial.X in Mathlib.Algebra.MvPolynomial.Basic

MonoidHom in Mathlib.Algebra.Group.Hom.Defs

def erase_even (s : Finset ‚Ñï) : Finset ‚Ñï := s.filter Odd

instance [Zero T] [DecidableEq T] [ToNat T] : Div (Cayley T) where
  div := div

def backTrack (trace : QueryLog (duplexSpongeChallengeOracle StmtIn U))
    (state : CanonicalSpongeState U) :
    OptionT Option ((StmtIn √ó (i : Fin (n + 1)) √ó (pSpec.MessagesUpTo i))) :=
  sorry

instance : SMul ‚Ñï (UniPoly R) := ‚ü®nsmul‚ü©

instance : Sub (UniPoly R) := ‚ü®UniPoly.sub‚ü©

MonadLiftT in Init.Prelude

noncomputable def minWtCodewords [Semiring F] (LC : LinearCode Œπ F) : ‚Ñï :=
  sInf {w | ‚àÉ c ‚àà LC, c ‚â† 0 ‚àß Code.wt c = w}

def OracleVerifier.append (V‚ÇÅ : OracleVerifier oSpec Stmt‚ÇÅ OStmt‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : OracleVerifier oSpec Stmt‚ÇÇ OStmt‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ pSpec‚ÇÇ) :
      OracleVerifier oSpec Stmt‚ÇÅ OStmt‚ÇÅ Stmt‚ÇÉ OStmt‚ÇÉ (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ) where
  verify := fun stmt challenges => by admit /- proof elided -/
|
    
    .trans (.sumMap V‚ÇÅ.embed (.refl _)) <|
    
    .trans (Equiv.sumAssoc _ _ _).toEmbedding <|
    
    .sumMap (.refl _) MessageIdx.sumEquiv.toEmbedding

  hEq := fun i => by admit /- proof elided -/

@[reducible]
def pSpecFold : ProtocolSpec 2 := ‚ü®![Direction.P_to_V, Direction.V_to_P], ![L‚¶É‚â§ 2‚¶Ñ[X], L]‚ü©

noncomputable def œÄ_z_lift {H : F[X][Y]} (z : F) (root : rationalRoot (H_tilde' H) z) :
  F[X][Y] ‚Üí+* F := Polynomial.evalEvalRingHom z root.1

Algebra.TensorProduct.leftAlgebra in Mathlib.RingTheory.TensorProduct.Basic

noncomputable def NTTStage (i : Fin ‚Ñì) (b : Fin (2 ^ (‚Ñì + R_rate)) ‚Üí L) :
    Fin (2^(‚Ñì + R_rate)) ‚Üí L :=
  have h_2_pow_i_lt_2_pow_‚Ñì_add_R_rate: 2^i.val < 2^(‚Ñì + R_rate) := by admit /- proof elided -/

def InputStatement := R

def tileCoeffs (a : Fin (2 ^ ‚Ñì) ‚Üí L) : Fin (2^(‚Ñì + R_rate)) ‚Üí L :=
  fun v => a (Fin.mk (v.val % (2^‚Ñì)) (Nat.mod_lt v.val (pow_pos (zero_lt_two) ‚Ñì)))

@[inline, reducible]
def lift : OuterStmtIn √ó OuterWitIn ‚Üí InnerStmtOut √ó InnerWitOut ‚Üí OuterStmtOut √ó OuterWitOut :=
  fun ctxIn ctxOut =>
    ‚ü®lens.stmt.toFunB ctxIn.1 ctxOut.1, lens.wit.toFunB ctxIn ctxOut‚ü©

Lean.Name in Init.Prelude

UInt64.ofFin in Init.Data.UInt.Basic

@[simp]
def innerRelIn_Test : Set (InnerStmtIn_Test √ó Unit) :=
  setOf (fun ‚ü®‚ü®f, t‚ü©, _‚ü© => ‚àë x ‚àà {0, 1}, f.eval x = t)

@[simp]
abbrev Statement.AfterSendEvalClaim : Type := Statement.AfterFirstSumcheck R pp

structure BerlekampWelchCondition (e k : ‚Ñï) (œâs f : Fin n ‚Üí F) (E Q : Polynomial F) : Prop where
  cond: ‚àÄ i : Fin n, Q.eval (œâs i) = (f i) * E.eval (œâs i)
  E_natDegree : E.natDegree = e
  E_leadingCoeff : E.coeff e = 1
  Q_natDegree : Q.natDegree ‚â§ e + k - 1

Functor in Init.Prelude

@[reducible, simp]
def OStmtIn : Unit ‚Üí Type := fun _ => R‚¶É‚â§ deg‚¶Ñ[X]

@[inline, specialize, simp]
def oracleVerifier : OracleVerifier oSpec Statement OStatement Statement OStatement !p[] :=
  OracleVerifier.id

repr in Init.Data.Repr

@[reducible]
def index (op : MemoryWrite Œπ Œ±) := op.1

instance {k : ‚Ñï} : NeZero (Z k) := (BinaryTowerAux k).snd.specialElementNeZero

instance : Unique (FullTranscript (default : ProtocolSpec 0)) := inferInstance

Vector.map in Init.Data.Vector.Basic

def regularElms (H : F[X][Y]) : Type :=
  {a : ùïÉ H // ‚àÉ b : ùí™ H, a = embeddingOfùí™IntoùïÉ _ b}

@[reducible]
def mk {R : Type*} (coeffs : Array R) : UniPoly R := coeffs

Pow in Init.Prelude

def dropLastWhile (p : Œ± ‚Üí Bool) (l : List Œ±) : List Œ± :=
  (l.reverse.dropWhile p).reverse

DivisionSemiring in Mathlib.Algebra.Field.Defs

Fintype.equivFin in Mathlib.Data.Fintype.EquivFin

def aeval {A : Type y} [CommSemiring A] [Algebra R A] {F : Type z} [FunEquiv F œÉ A] (g : F) :
    P ‚Üí‚Çê[R] A :=
  eval‚ÇÇAlgHom (Algebra.ofId R A) g

def liftRightNil {Œπ : Type} {œÉ : Type} (oSpec : OracleSpec Œπ) :
    SimOracle.Stateful (oSpec ++‚Çí []‚Çí) oSpec œÉ where impl
  | query (.inl i) q => fun s ‚Ü¶ do return ‚ü®‚Üê query i q, s‚ü©

class SpongeUnit (Œ± : Type) extends Zero Œ±, Serde Œ± ByteArray, HasSize Œ± UInt8 where
   
  write (stream : IO.FS.Stream) : Array Œ± ‚Üí IO Unit :=
    Array.foldlM (fun _ a => IO.FS.Stream.write stream (serialize a)) ()
   
  read (stream : IO.FS.Stream) : Array Œ± ‚Üí IO (Array Œ±) :=
    fun arr => do
      let bytes ‚Üê arr.mapM (fun _ => IO.FS.Stream.read stream (USize.ofNat (HasSize.size Œ± UInt8)))
      let units := bytes.mapM deserialize
      if h : units.isSome
        then return units.get h
        else IO.throwServerError "Failed to read units"

class Context.Lens.IsComplete {OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut : Type}
    {OuterWitIn OuterWitOut InnerWitIn InnerWitOut : Type}
    (outerRelIn : Set (OuterStmtIn √ó OuterWitIn))
    (innerRelIn : Set (InnerStmtIn √ó InnerWitIn))
    (outerRelOut : Set (OuterStmtOut √ó OuterWitOut))
    (innerRelOut : Set (InnerStmtOut √ó InnerWitOut))
    (compat : (OuterStmtIn √ó OuterWitIn) ‚Üí (InnerStmtOut √ó InnerWitOut) ‚Üí Prop)
    (lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut) where

  proj_complete : ‚àÄ stmtIn witIn,
    (stmtIn, witIn) ‚àà outerRelIn ‚Üí
    (lens.stmt.proj stmtIn, lens.wit.proj (stmtIn, witIn)) ‚àà innerRelIn

  lift_complete : ‚àÄ outerStmtIn outerWitIn innerStmtOut innerWitOut,
    compat (outerStmtIn, outerWitIn) (innerStmtOut, innerWitOut) ‚Üí
    (outerStmtIn, outerWitIn) ‚àà outerRelIn ‚Üí
    (innerStmtOut, innerWitOut) ‚àà innerRelOut ‚Üí
    (lens.stmt.lift outerStmtIn innerStmtOut,
    lens.wit.lift (outerStmtIn, outerWitIn) (innerStmtOut, innerWitOut)) ‚àà outerRelOut

instance {relIn : Set (StmtIn √ó WitIn)} {relOut : Set (StmtOut √ó WitOut)}
    {verifier : Verifier oSpec StmtIn StmtOut pSpec} {WitMid : Fin (n + 1) ‚Üí Type}
    {extractor : Extractor.RoundByRound oSpec StmtIn WitIn WitOut pSpec WitMid} :
    CoeFun (verifier.KnowledgeStateFunction init impl relIn relOut extractor)
    (fun _ => (m : Fin (n + 1)) ‚Üí StmtIn ‚Üí Transcript m pSpec ‚Üí WitMid m ‚Üí Prop) :=
      ‚ü®fun f => f.toFun‚ü©

class HasPred (T : Type u) where
   
  pred' : T ‚Üí T

instance (k : ‚Ñï) : DecidableEq (ConcreteBTField k) :=
  fun x y =>
    let p := BitVec.toNat x = BitVec.toNat y
    let q := x = y
    let hp : Decidable p := Nat.decEq (BitVec.toNat x) (BitVec.toNat y)
    let h_iff_pq : p ‚Üî q := (BitVec.toNat_eq).symm 
    match hp with
    | isTrue (proof_p : p) =>
      
      
      isTrue (h_iff_pq.mp proof_p)
    | isFalse (nproof_p : ¬¨p) =>
      
      
      
      
      isFalse (fun (proof_q : q) => nproof_p (h_iff_pq.mpr proof_q))

def Reduction.append (R‚ÇÅ : Reduction oSpec Stmt‚ÇÅ Wit‚ÇÅ Stmt‚ÇÇ Wit‚ÇÇ pSpec‚ÇÅ)
    (R‚ÇÇ : Reduction oSpec Stmt‚ÇÇ Wit‚ÇÇ Stmt‚ÇÉ Wit‚ÇÉ pSpec‚ÇÇ) :
      Reduction oSpec Stmt‚ÇÅ Wit‚ÇÅ Stmt‚ÇÉ Wit‚ÇÉ (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ) where
  prover := Prover.append R‚ÇÅ.prover R‚ÇÇ.prover
  verifier := Verifier.append R‚ÇÅ.verifier R‚ÇÇ.verifier

instance Vector.instFintype {Œ± : Type*} {n : ‚Ñï} [VCVCompatible Œ±] : Fintype (Vector Œ± n) :=
  Fintype.ofEquiv _ (Equiv.rootVectorEquivFin).symm

noncomputable def foldOracleReduction :
  OracleReduction []‚Çí
    (Statement F i.castSucc) (OracleStatement D x s i.castSucc) (Witness F s d i.castSucc.castSucc)
    (Statement F i.succ) (OracleStatement D x s i.succ) (Witness F s d i.succ.castSucc)
    (pSpec D x s i) where
  prover := foldProver D x s d i
  verifier := foldVerifier D x s i

def AlgebraTowerEquiv.toAlgEquivOverLeft (e : AlgebraTowerEquiv A B) (i j : Œπ) (h : i ‚â§ j) :
  letI : Algebra (A i) (A j) :=

def ofMessagesChallenges (messages : MessagesUpTo k pSpec)
    (challenges : ChallengesUpTo k pSpec) : Transcript k pSpec :=
  fun i => match h : pSpec.dir (i.castLE (by admit /- proof elided -/
  )) with
  | Direction.P_to_V => messages ‚ü®i.castLE (by admit /- proof elided -/
  ), h‚ü©
  | Direction.V_to_P => challenges ‚ü®i.castLE (by admit /- proof elided -/
  ), h‚ü©

noncomputable def definingPoly {F : Type*} [instField : Field F] (s : F)
  := X ^ 2 + C s * X + 1

@[reducible]
def baseFieldSize : Nat :=
  21888242871839275222246405745257275088696311157297823662689037894645226208583

Polynomial.evalEval in Mathlib.Algebra.Polynomial.Bivariate

def mul (m n : ChurchNat Œ±) : ChurchNat Œ± := fun f => n (m f)

@[reducible, simp]
def soundness
    (langIn : Set (Statement √ó ‚àÄ i, OStatement i))
    (verifier : OracleVerifier oSpec Statement OStatement Bool (fun _ : Empty => Unit) pSpec)
    (soundnessError : ‚Ñù‚â•0) : Prop :=
  verifier.toVerifier.soundness init impl langIn acceptRejectOracleRel.language soundnessError

def relation : Set (M √ó M √ó List (MemoryOp Œπ Œ±)) :=
  { ‚ü®startMem, finalMem, ops‚ü© | processMemoryOps ops startMem = some finalMem }

UInt16 in Init.Prelude

noncomputable def commitOracleProver (i : Fin ‚Ñì) :
  OracleProver (oSpec := []‚Çí)
    
    (StmtIn := Statement (L := L) Context i.succ)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) i.succ)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) i.succ)
    (pSpec := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) where

  PrvState := commitPrvState ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i

  input := fun ‚ü®‚ü®stmt, oStmt‚ü©, wit‚ü© => (stmt, oStmt, wit)

  sendMessage 
  | ‚ü®0, _‚ü© => fun inputPrvState => by admit /- proof elided -/
  | ‚ü®0, h‚ü© => nomatch h 

  output := fun ‚ü®stmt, oStmt, wit‚ü© => by admit /- proof elided -/

HasSum in Mathlib.Topology.Algebra.InfiniteSum.Defs

def proximityGap (d : ‚Ñï) (bound : ‚Ñï) : Prop :=
  ‚àÄ u v : n ‚Üí F, (proximityMeasure C u v d > bound)
    ‚Üí (Œî‚ÇÄ( u ‚ãà v , C ^‚ãà Fin 2 ) ‚â§ d)

instance : ‚àÄ j, OracleInterface ((pSpecNonLastBlocks ùîΩq Œ≤ (œë:=œë)
  (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).Message j) := instOracleInterfaceMessageSeqCompose

@[inline, specialize]
def eval (x : R) (p : UniPoly R) : R :=
  p.eval‚ÇÇ (RingHom.id R) x

@[reducible]
def pBits : Nat := 31

def relDistCodewords [DecidableEq F] (U V : Matrix Œ∫ Œπ F) : ‚Ñù :=
  (Matrix.neqCols U V).card / Fintype.card Œπ

instance instOI‚ÇÇ : ‚àÄ i, OracleInterface
    ((‚ü®!v[.P_to_V], !v[R‚¶É‚â§ deg‚¶Ñ[X]]‚ü© ++‚Çö !p[] ++‚Çö ‚ü®!v[.V_to_P], !v[R]‚ü©).Message i) :=
  instOracleInterfaceMessageAppend

instance : Field ScalarField := ZMod.instField SCALAR_FIELD_CARD

instance {s} : LawfulFunctor (fun Œ± => LeafData Œ± s) :=

NeZero in Init.Data.NeZero

BitVec.cast in Init.Data.BitVec.Basic

Functor.map in Init.Prelude

def OracleVerifier.liftContext
    (lens : OracleStatement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                              OuterOStmtIn OuterOStmtOut InnerOStmtIn InnerOStmtOut)
    (V : OracleVerifier oSpec InnerStmtIn InnerOStmtIn InnerStmtOut InnerOStmtOut pSpec) :
      OracleVerifier oSpec OuterStmtIn OuterOStmtIn OuterStmtOut OuterOStmtOut pSpec where
  verify := fun outerStmtIn transcript => sorry
  embed := by admit /- proof elided -/

inductive SkeletonInternalIndex : Skeleton ‚Üí Type
  | ofInternal {left right} : SkeletonInternalIndex (Skeleton.internal left right)
  | ofLeft {left right : Skeleton} (idxLeft : SkeletonInternalIndex left) :
      SkeletonInternalIndex (Skeleton.internal left right)
  | ofRight {left right : Skeleton} (idxRight : SkeletonInternalIndex right) :
      SkeletonInternalIndex (Skeleton.internal left right)

def relayKnowledgeError (m : pSpecRelay.ChallengeIdx) : ‚Ñù‚â•0 :=
  match m with
  | ‚ü®j, _‚ü© => j.elim0

def getUElements (i : Fin r) : List L :=
  (List.finRange (2^i.val)).map fun k =>
    (Finset.univ : Finset (Fin i)).sum fun j =>
      if Nat.getBit (n := k.val) (k := j.val) == 1 then
        Œ≤ ‚ü®j.val, by admit /- proof elided -/
        ‚ü©
      else 0

def powerBasisSucc (k : ‚Ñï) :
    PowerBasis (ConcreteBTField k) (ConcreteBTField (k + 1)) :=

instance [Zero T] [ToNat T] : ToNat (Cayley T) where
  toNat := ToNat.toNat ‚àò toT

@[inline, specialize]
def Prover.processRoundDSFS [‚àÄ i, VCVCompatible (pSpec.Challenge i)] (j : Fin n)
    (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec)
    (currentResult : OracleComp (oSpec ++‚Çí duplexSpongeChallengeOracle StmtIn U)
      (pSpec.MessagesUpTo j.castSucc √ó
        CanonicalDuplexSponge U √ó prover.PrvState j.castSucc)) :
      OracleComp (oSpec ++‚Çí duplexSpongeChallengeOracle StmtIn U)
        (pSpec.MessagesUpTo j.succ √ó
          CanonicalDuplexSponge U √ó prover.PrvState j.succ) := do
  let ‚ü®messages, sponge, state‚ü© ‚Üê currentResult
  match hDir : pSpec.dir j with
  | .V_to_P => do
    let f ‚Üê prover.receiveChallenge ‚ü®j, hDir‚ü© state
    let (challenge, newSponge) ‚Üê
      liftM (DuplexSponge.squeeze sponge (challengeSize ‚ü®j, hDir‚ü©))
    
    let deserializedChallenge : pSpec.Challenge ‚ü®j, hDir‚ü© := Deserialize.deserialize challenge
    return ‚ü®messages.extend hDir, newSponge, f deserializedChallenge‚ü©
  | .P_to_V => do
    let ‚ü®msg, newState‚ü© ‚Üê prover.sendMessage ‚ü®j, hDir‚ü© state
    let serializedMessage : Vector U (messageSize ‚ü®j, hDir‚ü©) := Serialize.serialize msg
    let newSponge ‚Üê liftM (DuplexSponge.absorb sponge serializedMessage.toList)
    return ‚ü®messages.concat hDir msg, newSponge, newState‚ü©

@[inline] def le [Zero T] [ToNat T] (a b : Cayley T) : Prop :=
  (‚Üëa : Nat) ‚â§ (‚Üëb : Nat)

private noncomputable def E (œâs : Fin n ‚Üí F)
  (f : Fin n ‚Üí F) (p : Polynomial F) (e : ‚Ñï) : Polynomial F :=
  X ^ (e - (Œî‚ÇÄ(f, p.eval ‚àò œâs) : ‚Ñï)) * ElocPolyF œâs f p

Polynomial.algEquivOfCompEqX in Mathlib.Algebra.Polynomial.AlgebraMap

@[inline]
def zero [Zero R] : MlPolyEval R n := Vector.replicate (2 ^ n) 0

class ProverFirst (pSpec : ProtocolSpec n) [NeZero n] where
  prover_first' : pSpec.dir 0 = .P_to_V

def commitmentScheme : Commitment.Scheme (oSpec Œ± Œ≤ Œ≥) Œ± Œ≤ Œ≥ !p[] where
  commit := fun v r => commit v
  opening := .mk (sorry) (.mk (sorry))

instance {k : ‚Ñï} : Mul (ConcreteBTField k) where
  mul := concrete_mul

List.drop in Init.Data.List.Basic

def commitKnowledgeError {i : Fin ‚Ñì}
    (m : (pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i).ChallengeIdx) : ‚Ñù‚â•0 :=
  match m with
  | ‚ü®j, hj‚ü© => by admit /- proof elided -/

def eval (x : Fin numWires ‚Üí ùì°) (g : Gate ùì° numWires) : ùì° :=
  g.qL * x g.a + g.qR * x g.b + g.qO * x g.c + g.qM * (x g.a * x g.b) + g.qC

Matrix.vecMul in Mathlib.Data.Matrix.Mul

def extract (start stop : ‚Ñï) (h1 : start ‚â§ stop) (h2 : stop ‚â§ n) (pSpec : ProtocolSpec n) :
    ProtocolSpec (stop - start) where
  dir := Fin.extract start stop h1 h2 pSpec.dir
  ¬´Type¬ª := Fin.extract start stop h1 h2 pSpec.¬´Type¬ª

def regularElms_set (H : F[X][Y]) : Set (ùïÉ H) :=
  {a : ùïÉ H | ‚àÉ b : ùí™ H, a = embeddingOfùí™IntoùïÉ _ b}

def domainEmb {i : ‚Ñï} : evalDomain D i ‚Ü™ F :=
  ‚ü®
    fun x => x.1.1,
    by admit /- proof elided -/
  ‚ü©

instance : Fact (Nat.Prime SCALAR_FIELD_CARD) := ‚ü®ScalarField_is_prime‚ü©

Equiv.toEmbedding in Mathlib.Logic.Embedding.Basic

Array.map in Init.Data.Array.Basic

inductive HList' {Œ± : Type v} (Œ≤ : Œ± ‚Üí Type u) : List Œ± ‚Üí Type (max u v)
  | nil  : HList' Œ≤ []
  | cons : Œ≤ i ‚Üí HList' Œ≤ is ‚Üí HList' Œ≤ (i :: is)

Int.ofNat in Init.Data.Int.Basic

class DCast‚ÇÉ (Œ± : Sort*) (Œ≤ : Œ± ‚Üí Sort*) (Œ≥ : (a : Œ±) ‚Üí Œ≤ a ‚Üí Sort*)
    (Œ¥ : (a : Œ±) ‚Üí (b : Œ≤ a) ‚Üí Œ≥ a b ‚Üí Sort*) [DCast Œ± Œ≤] [DCast‚ÇÇ Œ± Œ≤ Œ≥] where
  dcast‚ÇÉ : ‚àÄ {a a' : Œ±} {b : Œ≤ a} {b' : Œ≤ a'} {c : Œ≥ a b} {c' : Œ≥ a' b'},
    (ha : a = a') ‚Üí (hb : dcast ha b = b') ‚Üí (hc : dcast‚ÇÇ ha hb c = c') ‚Üí Œ¥ a b c ‚Üí Œ¥ a' b' c'
  dcast‚ÇÉ_id : ‚àÄ {a : Œ±} {b : Œ≤ a} {c : Œ≥ a b},
    dcast‚ÇÉ (Eq.refl a) dcast_eq dcast‚ÇÇ_eq = (id : Œ¥ a b c ‚Üí Œ¥ a b c)

def foldMatrix (i : Fin r) (steps : Fin (‚Ñì + 1)) (h_i_add_steps : i.val + steps < ‚Ñì + ùì°)
    (y : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate)
      ‚ü®‚Üëi + steps, by apply Nat.lt_trans (m := ‚Ñì + ùì°) (h_i_add_steps) h_‚Ñì_add_R_rate‚ü©)
    : Matrix (Fin (2 ^ steps.val)) (Fin (2 ^ steps.val)) L :=

noncomputable def queryOracleProver :
  OracleProver
    (oSpec := []‚Çí)
    (StmtIn := FinalSumcheckStatementOut (L:=L) (‚Ñì:=‚Ñì))
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (
    Fin.last ‚Ñì))
    (WitIn := Unit)
    (StmtOut := Bool)
    (OStmtOut := fun _ : Empty => Unit)
    (WitOut := Unit)
    (pSpec := pSpecQuery ùîΩq Œ≤ Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)) where
  PrvState := fun
    | 0 => Unit
    | 1 => Unit
  input := fun _ => ()

  sendMessage
  | ‚ü®0, h‚ü© => nomatch h

  receiveChallenge
  | ‚ü®0, _‚ü© => fun _ => do
    
    pure (fun _challenges => ())

  output := fun _ => do 
    pure (‚ü®true, fun _ => ()‚ü©, ())

instance instHPowConcreteBTF‚Ñ§ {k : ‚Ñï} : HPow (ConcreteBTField k) ‚Ñ§ (ConcreteBTField k) where
  hPow a n :=
    match n with
    | Int.ofNat m => concrete_pow_nat a m
    | Int.negSucc m =>
      
      if a = 0 then 0
      else concrete_pow_nat (concrete_inv a) (m + 1) 

Lean.Elab.WF.paramLet in Lean.Elab.PreDefinition.WF.Preprocess

ZeroMemClass in Mathlib.Algebra.Group.Submonoid.Defs

@[reducible, inline]
def ùï´ {R} {sz} (stmt : Statement R sz) (wit : Witness R sz) : Fin sz.n ‚Üí R :=
  Fin.append stmt wit ‚àò Fin.cast (by admit /- proof elided -/
  )

def idxOf' [BEq Œ±] (a : Œ±) (l : List Œ±) : ‚Ñï := findIdx' (¬∑ == a) l

@[reducible, simp] def StmtIn := Unit

id in Init.Prelude
</all_available_defs>

<all_available_lemmas>
Fintype.card_pos in Mathlib.Data.Fintype.Card
Polynomial.C_1 in Mathlib.Algebra.Polynomial.Basic
Polynomial.C_comp in Mathlib.Algebra.Polynomial.Eval.Defs
Polynomial.C_mul in Mathlib.Algebra.Polynomial.Basic
Polynomial.C_pow in Mathlib.Algebra.Polynomial.Basic
Polynomial.X_comp in Mathlib.Algebra.Polynomial.Eval.Defs
Polynomial.comp_X in Mathlib.Algebra.Polynomial.Eval.Defs
Polynomial.mul_comp in Mathlib.Algebra.Polynomial.Eval.Defs
Polynomial.prod_comp in Mathlib.Algebra.Polynomial.Eval.Defs
Polynomial.sub_comp in Mathlib.Algebra.Polynomial.Eval.Defs
inv_eq_one_div in Mathlib.Algebra.Group.Defs
map_pow in Mathlib.Algebra.Group.Hom.Defs
mul_assoc in Mathlib.Algebra.Group.Defs
mul_comm in Mathlib.Algebra.Group.Defs
mul_inv_cancel‚ÇÄ in Mathlib.Algebra.GroupWithZero.Defs
mul_one in Mathlib.Algebra.Group.Defs
mul_pow in Mathlib.Algebra.Group.Basic
mul_pow_sub_one in Mathlib.Algebra.Group.Basic
mul_sub in Mathlib.Algebra.Ring.Defs
one_div in Mathlib.Algebra.Group.Defs
one_mul in Mathlib.Algebra.Group.Defs
one_pow in Mathlib.Algebra.Group.Defs
Fin.eta in Init.Data.Fin.Lemmas
Fin.mk_eq_mk in Mathlib.Data.Fin.Basic
Nat.succ_eq_add_one in Init.Data.Nat.Basic
Polynomial.eval_X in Mathlib.Algebra.Polynomial.Eval.Defs
div_one in Mathlib.Algebra.Group.Basic

lemma X‚±º_zero_eq_one (‚Ñì : ‚Ñï) (h_‚Ñì : ‚Ñì ‚â§ r) :
  X‚±º ùîΩq Œ≤ ‚Ñì h_‚Ñì ‚ü®0, by exact Nat.two_pow_pos ‚Ñì‚ü© = 1

omit hF‚ÇÇ in
theorem W_linear_comp_decomposition (i : Fin r) (h_i_add_1 : i + 1 < r) :
    ‚àÄ p: L[X], (W ùîΩq Œ≤ (i + 1)).comp p =
      ((W ùîΩq Œ≤ i).comp p) ^ Fintype.card ùîΩq -
        C (eval (Œ≤ i) (W ùîΩq Œ≤ i)) ^ (Fintype.card ùîΩq - 1) * ((W ùîΩq Œ≤ i).comp p)

theorem W_linearity (i : Fin r)
    : IsLinearMap ùîΩq (f := fun inner_p ‚Ü¶ (W ùîΩq Œ≤ i).comp inner_p)

omit hF‚ÇÇ in
lemma inductive_linear_map_W (i : Fin r) (h_i_add_1 : i + 1 < r)
    (h_prev_linear_map : IsLinearMap ùîΩq (f := fun inner_p ‚Ü¶ (W ùîΩq Œ≤ i).comp inner_p))
    : IsLinearMap ùîΩq (f := fun inner_p ‚Ü¶ (W ùîΩq Œ≤ (i + 1)).comp inner_p)

omit h_Fq_char_prime hF‚ÇÇ in
lemma inductive_rec_form_W_comp (i : Fin r) (h_i_add_1 : i + 1 < r)
    (h_prev_linear_map : IsLinearMap (R := ùîΩq) (M := L[X]) (M‚ÇÇ := L[X])
      (f := fun inner_p ‚Ü¶ (W ùîΩq Œ≤ i).comp inner_p))
    : ‚àÄ p: L[X], (W ùîΩq Œ≤ (i + 1)).comp p =
      ((W ùîΩq Œ≤ i).comp p) ^ Fintype.card ùîΩq -
        C (eval (Œ≤ i) (W ùîΩq Œ≤ i)) ^ (Fintype.card ùîΩq - 1) * ((W ùîΩq Œ≤ i).comp p)

lemma W·µ¢_eval_Œ≤·µ¢_neq_zero
    (i : Fin r): (W ùîΩq Œ≤ i).eval (Œ≤ i) ‚â† 0

lemma Œ≤·µ¢_not_in_U·µ¢ (i : Fin r) :
    Œ≤ i ‚àâ U ùîΩq Œ≤ i

lemma W_prod_comp_decomposition
    (i : Fin r) (hi : i > 0) :
    (W ùîΩq Œ≤ i) = ‚àè c: ùîΩq, (W ùîΩq Œ≤ (i-1)).comp (X - C (c ‚Ä¢ Œ≤ (i-1)))

lemma W_splits (i : Fin r) : (W ùîΩq Œ≤ i).Splits (RingHom.id L)

omit h_Fq_char_prime hF‚ÇÇ in
lemma rootMultiplicity_prod_W_comp_X_sub_C
    (i : Fin r) (h_i_add_1 : i + 1 < r) (a : L) :
    rootMultiplicity a ((univ : Finset ùîΩq).prod (fun c => (W ùîΩq Œ≤ i).comp (X - C (c ‚Ä¢ Œ≤ i)))) =
    if a ‚àà (U ùîΩq Œ≤ (i+1) : Set L) then 1 else 0

omit [DecidableEq L] h_Fq_char_prime hF‚ÇÇ hŒ≤_lin_indep in
lemma Prod_W_comp_X_sub_C_ne_zero (i : Fin r) :
    (univ : Finset ùîΩq).prod (fun c => (W ùîΩq Œ≤ i).comp (X - C (c ‚Ä¢ Œ≤ i))) ‚â† 0

omit [DecidableEq L] [Fintype ùîΩq] hŒ≤_lin_indep in
lemma W_ne_zero (i : Fin r) : (W ùîΩq Œ≤ i) ‚â† 0

lemma roots_comp_X_sub_C (p : L[X]) (a : L) :
    (p.comp (X - C a)).roots = p.roots.map (fun r => r + a)

lemma rootMultiplicity_comp_X_sub_C (p : L[X]) (a x : L) :
    rootMultiplicity x (p.comp (X - C a)) = rootMultiplicity (x - a) p

omit [Fintype L] [DecidableEq L] in
lemma comp_X_sub_C_eq_zero_iff (p : L[X]) (a : L) :
  p.comp (X - C a) = 0 ‚Üî p = 0

lemma rootMultiplicity_W (i : Fin r) (a : L) :
    rootMultiplicity a (W ùîΩq Œ≤ i) = if a ‚àà (U ùîΩq Œ≤ i : Set L) then 1 else 0

lemma roots_W (i : Fin r) : -- converts root Multiset into (univ: U·µ¢.val.map)
  (W ùîΩq Œ≤ i).roots = (univ : Finset (U ùîΩq Œ≤ i)).val.map (fun u => u.val)

omit [Fintype L] [DecidableEq L] [Fintype ùîΩq] h_Fq_char_prime hŒ≤_lin_indep in
theorem root_U_lift_up (i : Fin r) (h_i_add_1 : i + 1 < r) (a : L) (x : ùîΩq) :
  a - x ‚Ä¢ Œ≤ i ‚àà (U ùîΩq Œ≤ i) ‚Üí a ‚àà (U ùîΩq Œ≤ (i+1))

omit [Fintype L] [DecidableEq L] [Fintype ùîΩq] h_Fq_char_prime in
theorem root_U_lift_down
  (i : Fin r) (h_i_add_1 : i + 1 < r) (a : L) :
  a ‚àà (U ùîΩq Œ≤ (i+1)) ‚Üí ‚àÉ! x: ùîΩq, a - x ‚Ä¢ Œ≤ i ‚àà (U ùîΩq Œ≤ i)

lemma W_monic (i : Fin r) : (W ùîΩq Œ≤ i).Monic

lemma comp_sub_C_of_linear_eval (p : L[X])
  (h_lin : IsLinearMap ùîΩq (f := fun inner_p ‚Ü¶ p.comp inner_p)) (a : L) :
    p.comp (X - C a) = p - C (eval a p)

theorem prod_poly_sub_C_eq_poly_pow_card_sub_poly_in_L
  (p : L[X]) :
  (‚àè c ‚àà (Finset.univ : Finset Fq), (p - Polynomial.C (algebraMap Fq L c))) =
    p^(Fintype.card Fq) - p

theorem prod_X_sub_C_eq_X_pow_card_sub_X_in_L :
  (‚àè c ‚àà (Finset.univ : Finset Fq), (Polynomial.X - Polynomial.C (algebraMap Fq L c))) =
    Polynomial.X^(Fintype.card Fq) - Polynomial.X

theorem prod_X_sub_C_eq_X_pow_card_sub_X :
  (‚àè c ‚àà (Finset.univ : Finset Fq), (Polynomial.X - Polynomial.C c)) =
    Polynomial.X^(Fintype.card Fq) - Polynomial.X

omit [DecidableEq L] [Fintype ùîΩq] hŒ≤_lin_indep in
lemma W‚ÇÄ_eq_X : W ùîΩq Œ≤ 0 = X

lemma Fin.val_add_one' (a : Fin r) (h_a_add_1 : a + 1 < r) : (a + 1).val = a.val + 1

lemma iterated_fold_transitivity
    (i : Fin r) (steps‚ÇÅ steps‚ÇÇ : Fin (‚Ñì + 1))
    (h_bounds : i.val + steps‚ÇÅ + steps‚ÇÇ ‚â§ ‚Ñì) -- A single, sufficient bounds check
    (f : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := i) ‚Üí L)
    (r_challenges‚ÇÅ : Fin steps‚ÇÅ ‚Üí L) (r_challenges‚ÇÇ : Fin steps‚ÇÇ ‚Üí L) :
    -- LHS : The nested fold (folding twice)
    have hi1 : i.val + steps‚ÇÅ ‚â§ ‚Ñì := by exact le_of_add_right_le h_bounds
    have hi2 : i.val + steps‚ÇÇ ‚â§ ‚Ñì := by
      rw [Nat.add_assoc, Nat.add_comm steps‚ÇÅ steps‚ÇÇ, ‚ÜêNat.add_assoc] at h_bounds
      exact le_of_add_right_le h_bounds
    have hi12 : steps‚ÇÅ + steps‚ÇÇ < ‚Ñì + 1 := by
      apply Nat.lt_succ_of_le; rw [Nat.add_assoc] at h_bounds;
      exact Nat.le_of_add_left_le h_bounds
    let lhs := iterated_fold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (i := ‚ü®i.val + steps‚ÇÅ, by -- ‚ä¢ ‚Üëi + ‚Üësteps‚ÇÅ < r
        apply Nat.lt_of_le_of_lt (m := ‚Ñì) (hi1) (‚Ñì_lt_r (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))‚ü©)
      (steps := steps‚ÇÇ)
      (h_i_add_steps := by simp only; apply Nat.lt_add_of_pos_right_of_le; exact h_bounds)
      (f := by
        exact iterated_fold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := i) (steps := steps‚ÇÅ)
          (h_i_add_steps := by apply Nat.lt_add_of_pos_right_of_le; exact hi1) (f := f)
          (r_challenges := r_challenges‚ÇÅ)
      ) r_challenges‚ÇÇ
    let rhs := iterated_fold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := i)
      (steps := ‚ü®steps‚ÇÅ + steps‚ÇÇ, hi12‚ü©)
      (h_i_add_steps := by
        simp only; rw [‚ÜêNat.add_assoc]; apply Nat.lt_add_of_pos_right_of_le; exact h_bounds)
      (f := f) (r_challenges := Fin.append r_challenges‚ÇÅ r_challenges‚ÇÇ)
    lhs = by
      simp only [‚ÜêNat.add_assoc] at ‚ä¢ rhs
      exact rhs

Polynomial.degree_sum_le in Mathlib.Algebra.Polynomial.Degree.Definitions

theorem size_le_size (p : UniPoly R) : p.trim.size ‚â§ p.size

theorem PrattPart.out {p : ‚Ñï} {a : ZMod p} {n : ‚Ñï} (h : PrattPart p a n) :
    ‚àÄ q : ‚Ñï, q.Prime ‚Üí q ‚à£ n ‚Üí a ^ ((p - 1) / q) ‚â† 1

lemma eq_poly_deg_one {a b c d : F} {x‚ÇÅ x‚ÇÇ : F}
  (h1 : a + b * x‚ÇÅ = c + d * x‚ÇÅ)
  (h2 : a + b * x‚ÇÇ = c + d * x‚ÇÇ)
  (h1_2 : x‚ÇÅ ‚â† x‚ÇÇ) :
  Polynomial.C a + Polynomial.C b * Polynomial.X
    = Polynomial.C c + Polynomial.C d * Polynomial.X

omit [NeZero œë] hdiv in
lemma toOutCodewordsCountOf0 : toOutCodewordsCount ‚Ñì œë 0 = 1

theorem happend_ext {Œ± : Fin m ‚Üí Sort u} {Œ≤ : Fin n ‚Üí Sort u}
    (u‚ÇÅ u‚ÇÇ : (i : Fin m) ‚Üí Œ± i) (v‚ÇÅ v‚ÇÇ : (i : Fin n) ‚Üí Œ≤ i) :
    happend u‚ÇÅ v‚ÇÅ = happend u‚ÇÇ v‚ÇÇ ‚Üî u‚ÇÅ = u‚ÇÇ ‚àß v‚ÇÅ = v‚ÇÇ

theorem fconcat_right_injective {Œ± : Fin n ‚Üí A} {Œ≤ : A} (v : (i : Fin n) ‚Üí F (Œ± i)) :
    Function.Injective (fconcat v : F Œ≤ ‚Üí (i : Fin (n + 1)) ‚Üí F (vconcat Œ± Œ≤ i))

@[simp]
lemma foldr'_zero {Œ± : Type u} (f : (i : Fin 0) ‚Üí Œ± ‚Üí Œ±) (x : Œ±) :
    foldr' 0 f x = x

theorem lagrangeToMonoLevel_monoToLagrangeLevel_id (v : Vector R (2 ^ n)) (i : Fin n) :
  lagrangeToMonoLevel i (monoToLagrangeLevel i v) = v

theorem computableTwiddleFactor_eq_twiddleFactor (i : Fin ‚Ñì) :
  computableTwiddleFactor (r := r) (‚Ñì := ‚Ñì) (Œ≤ := Œ≤) (L := L)
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := ‚ü®i, by omega‚ü©) =
  twiddleFactor (ùîΩq := ùîΩq) (L := L) (Œ≤ := Œ≤) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
    (i := ‚ü®i, by omega‚ü©)

@[grind =_]
lemma ne_zero_iff_coeffs_ne_zero (f : F[X][Y]) : f ‚â† 0 ‚Üî f.coeff ‚â† 0

lemma erase_even_def {s : Finset ‚Ñï} :
    erase_even s = s.filter Odd

@[simp]
theorem init_update_last : init (update s (Fin.last n) y) = init s

Nat.pos_of_neZero in Init.Data.Nat.Basic

@[simp]
lemma evenPart_coeff {f : Polynomial F} {n : ‚Ñï} :
    (evenPart f).coeff n = if Even n then f.coeff n else 0

omit [Finite F] in
lemma minus_one_in_doms {i : ‚Ñï} (h : i < n) :
    -1 ‚àà evalDomain D i

@[simp]
lemma wt_constantCode [DecidableEq F] [NeZero x] :
  wt (constantCode x Œπ) = Fintype.card Œπ

@[simp]
theorem append_right_cancel_iff {pSpec : ProtocolSpec m} {p1 p2 : ProtocolSpec n} :
    pSpec ++‚Çö p1 = pSpec ++‚Çö p2 ‚Üî p1 = p2

@[simp, grind _=_]
theorem totalDegree_mul {f g : F[X][Y]} (hf : f ‚â† 0) (hg : g ‚â† 0) :
    totalDegree (f * g) = totalDegree f + totalDegree g

protected lemma elocPoly_leftF_leftF_eq_contract {œâs f : Fin m ‚Üí F} :
  ElocPoly n (liftF œâs) (liftF f) =
  ElocPoly n (contract n œâs) (contract n f)

theorem and_highBits_lowBits_eq_zero {n : ‚Ñï} (numLowBits : ‚Ñï) :
    getHighBits numLowBits n &&& getLowBits numLowBits n = 0

theorem snoc_ne_zero_iff : snoc s y ‚â† 0 ‚Üî s ‚â† 0 ‚à® y ‚â† 0

theorem LeafData.composeBuild_getRootValue {Œ±} {s_left s_right : Skeleton}
    (left : LeafData Œ± s_left) (right : LeafData Œ± s_right)
    (compose : Œ± ‚Üí Œ± ‚Üí Œ±) :
    ((LeafData.internal left right).composeBuild compose).getRootValue =
      compose (left.composeBuild compose).getRootValue (right.composeBuild compose).getRootValue

theorem cast_run (stmt : StmtIn) (wit : WitIn)
    (P : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec‚ÇÅ) :
    P.run stmt wit =
      cast (sorry) ((P.cast hn hSpec).run stmt wit)

lemma h_sub_middle {k : ‚Ñï} (h_pos : k > 0) : 2 ^ k - 1 - 2 ^ (k - 1) + 1 = 2 ^ (k - 1)

lemma dim_eq_deg_of_le [NeZero n] (inj : Function.Injective Œ±) (h : n ‚â§ m) :
  dim (ReedSolomon.code ‚ü®Œ±, inj‚ü© n) = n

lemma take_eq_take : transcript‚ü¶:m‚üß = transcript.take m h

omit [SelectableType R] in
@[simp]
lemma oracleReduction_verifier_eq_oracleVerifier :
    (oracleReduction R deg D n oSpec).verifier = oracleVerifier R deg D n oSpec

@[simp]
lemma lin_shift_hamming_distance [Field F] {x‚ÇÅ x‚ÇÇ v : Fin n ‚Üí F}
  :
  Œî‚ÇÄ(x‚ÇÅ - v, x‚ÇÇ - v) = Œî‚ÇÄ(x‚ÇÅ, x‚ÇÇ)

@[simp]
theorem seqCompose_embedSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    {T : ‚àÄ i, FullTranscript (pSpec i)} (i : Fin m) (j : Fin (n i)) :
    seqCompose T (Fin.embedSum i j) = cast (by simp) (T i j)

theorem cast_eq_dcast‚ÇÇ {hn} {hSpec : pSpec‚ÇÅ.cast hn = pSpec‚ÇÇ} {i : MessageIdx pSpec‚ÇÅ}:
    i.cast hn hSpec = dcast‚ÇÇ hn hSpec i

@[simp]
theorem rtake_append_right :
    (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).rtake n (Nat.le_add_left n m) = pSpec‚ÇÇ

theorem sum_of_root_and_inverse_is_t1
    {curBTField : Type*} [Field curBTField]
    (u : curBTField) (t1 : curBTField) -- here t1 is already lifted to curBTField
    (specialElementNeZero : u ‚â† 0)
    (eval_prevPoly_at_root : u ^ 2 + t1 * u + 1 = 0)
    (sumZeroIffEq : ‚àÄ (x y : curBTField), x + y = 0 ‚Üî x = y) :
    u + u‚Åª¬π = t1

@[simp]
lemma domain_def : (spec Œ±).domain () = (Œ± √ó Œ±)

@[simp]
theorem seqCompose_one {n : Fin 1 ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)} :
    seqCompose pSpec = pSpec 0

lemma mem_support_coeff_finSuccEquivNth {f : MvPolynomial (Fin (n + 1)) R} {i : ‚Ñï} {x} :
    x ‚àà ((finSuccEquivNth R p f).coeff i).support ‚Üî x.insertNth p i ‚àà f.support

theorem vconcat_left_injective {n : ‚Ñï} (a : Œ±) :
    Function.Injective (fun v : Fin n ‚Üí Œ± => vconcat v a)

Fin.ext in Init.Data.Fin.Lemmas

theorem BitVec.bitvec_cast_eq_dcast {n m : Nat} (h : n = m) (bv : BitVec n) :
  BitVec.cast h bv = DCast.dcast h bv

lemma evenize_eval {f : Polynomial F} {s : F} :
    (evenize f).eval s = f.eval (s * s)

lemma mem_image_support_coeff_finSuccEquivNth {f : MvPolynomial (Fin (n + 1)) R} {i : ‚Ñï} {x} :
    x ‚àà Finsupp.insertNth p i '' ((finSuccEquivNth R p f).coeff i).support ‚Üî
      x ‚àà f.support ‚àß x p = i

theorem liftContext_runWithLog
    {lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    {outerStmtIn : OuterStmtIn} {outerWitIn : OuterWitIn}
    {P : Prover oSpec InnerStmtIn InnerWitIn InnerStmtOut InnerWitOut pSpec} :
      (P.liftContext lens).runWithLog outerStmtIn outerWitIn
      = do
        let ‚ü®‚ü®fullTranscript, innerCtxOut‚ü©, queryLog‚ü© ‚Üê
          P.runWithLog.uncurry (lens.proj (outerStmtIn, outerWitIn))
        return ‚ü®‚ü®fullTranscript, lens.lift (outerStmtIn, outerWitIn) innerCtxOut‚ü©, queryLog‚ü©

@[simp]
theorem zero_vappend {u : Fin 0 ‚Üí Œ±} (v : Fin n ‚Üí Œ±) :
    vappend u v = v ‚àò Fin.cast (Nat.zero_add n)

lemma is_berlekamp_welch_solution_ext
  (h : ‚àÄ i, (Matrix.mulVec (BerlekampWelchMatrix e k œâs f) v) i = -(f i) * (œâs i) ^ e)
  : IsBerlekampWelchSolution e k œâs f v

lemma oddPart_def :
  oddPart f =
  C (2‚Åª¬π : F) * (f - f.comp (-X)) /‚Çò X

theorem unique_linear_sum_repr (R : Type*) [CommRing R] (S : Type*) [CommRing S] [Algebra R S]
    (pb : PowerBasis R S) (h_dim : pb.dim = 2) (s : S) :
    ‚àÉ! p : R √ó R, s = p.fst ‚Ä¢ pb.gen + algebraMap R S p.snd

theorem fcons‚ÇÇ_right_injective {Œ±‚ÇÅ : A} {Œ±‚ÇÇ : B} {Œ≤‚ÇÅ : Fin n ‚Üí A} {Œ≤‚ÇÇ : Fin n ‚Üí B}
    (a : F‚ÇÇ Œ±‚ÇÅ Œ±‚ÇÇ) :
    Function.Injective
      (fcons‚ÇÇ (F := F‚ÇÇ) a : ((i : Fin n) ‚Üí F‚ÇÇ (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) ‚Üí (i : Fin (n + 1)) ‚Üí _ )

@[simp]
theorem OracleReduction.id_run (stmt : StmtIn) (oStmt : ‚àÄ i, OStmtIn i) (wit : WitIn) :
    (OracleReduction.id : OracleReduction oSpec StmtIn OStmtIn WitIn _ _ _ _).run stmt oStmt wit =
      pure ‚ü®‚ü®default, ‚ü®stmt, oStmt‚ü©, wit‚ü©, ‚ü®stmt, oStmt‚ü©‚ü©

theorem fiatShamir_completeness (relIn : Set (StmtIn √ó WitIn)) (relOut : Set (StmtOut √ó WitOut))
    (completenessError : ‚Ñù‚â•0) (R : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec) :
  R.completeness init impl relIn relOut completenessError ‚Üí
    R.fiatShamir.completeness (do return (‚Üê init, by unfold FunctionType; sorry))
      (impl ++‚Çõ‚Çí fsChallengeQueryImpl' :
        QueryImpl (oSpec ++‚Çí srChallengeOracle StmtIn pSpec)
          (StateT (œÉ √ó (srChallengeOracle StmtIn pSpec).FunctionType) ProbComp))
        relIn relOut completenessError

lemma concrete_mul_comm
  {h_k : k > 0} (prevBTFieldProps : ConcreteBTFieldProps (k := k - 1))
  (a b : ConcreteBTField k) :
  concrete_mul a b = concrete_mul b a

Fin.is_le in Init.Data.Fin.Lemmas

lemma division_by_conjugate {a b : ‚Ñù} (hpos : 0 ‚â§ b) (hnonzero : a + b.sqrt ‚â† 0) :
  a - (b).sqrt = (a^2 - b)/(a + b.sqrt)

lemma eq_zero_or_eq_one_of_lt_two {n : ‚Ñï} (h_lt : n < 2) : n = 0 ‚à® n = 1

lemma MessageIdxUpTo.eq_MessageIdx {k : Fin (n + 1)} {pSpec : ProtocolSpec n} :
    pSpec.MessageIdxUpTo k = {i : Fin k // pSpec.dir (i.castLE (by omega)) = .P_to_V}

@[simp] theorem BitVec.dcast_zero {n m : ‚Ñï} (h : n = m) : DCast.dcast h (0#n) = 0#m

theorem zero_add (n : ChurchNat Œ±) : add zero n = n

Nat.add_zero in Init.Core

theorem queryOracleVerifier_rbrKnowledgeSoundness [Fintype L] {œÉ : Type} (init : ProbComp œÉ)
    (impl : QueryImpl []‚Çí (StateT œÉ ProbComp)) :
    (queryOracleVerifier ùîΩq Œ≤ (œë:=œë) Œ≥_repetitions).rbrKnowledgeSoundness init impl
    (relIn := finalSumcheckRelOut ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (relOut := acceptRejectOracleRel)
    (rbrKnowledgeError := queryRbrKnowledgeError ùîΩq Œ≤ Œ≥_repetitions
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))

theorem append_run (tr : (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).FullTranscript) :
      (V‚ÇÅ.append V‚ÇÇ).run stmt tr =
        (do
          let stmt‚ÇÇ ‚Üê V‚ÇÅ.run stmt tr.fst
          let stmt‚ÇÉ ‚Üê V‚ÇÇ.run stmt‚ÇÇ tr.snd
          return stmt‚ÇÉ)

theorem foldOracleVerifier_rbrKnowledgeSoundness (i : Fin ‚Ñì) :
    (foldOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i).rbrKnowledgeSoundness init impl
      (relIn := roundRelation (mp := mp) ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        (ùìë := ùìë) i.castSucc)
      (relOut := foldStepRelOut (mp := mp) ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        (ùìë := ùìë) i)
      (foldKnowledgeError ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)

lemma toImpl_nonzero {p : Q[X]} (hp : p ‚â† 0) : p.toImpl.size > 0

List.length_drop in Init.Data.List.TakeDrop

theorem finSuccEquivNth_eq :
    (finSuccEquivNth R p : MvPolynomial (Fin (n + 1)) R ‚Üí+* Polynomial (MvPolynomial (Fin n) R)) =
      eval‚ÇÇHom (Polynomial.C.comp (C : R ‚Üí+* MvPolynomial (Fin n) R))
        (Fin.insertNth p Polynomial.X (Polynomial.C ‚àò X))

theorem foldRelayOracleReduction_perfectCompleteness
    (hInit : init.neverFails) (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
  OracleReduction.perfectCompleteness
    (pSpec := pSpecFoldRelay (L:=L))
    (relIn := roundRelation (mp := mp) ùîΩq Œ≤ (œë:=œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) i.castSucc)
    (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë:=œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) i.succ)
    (oracleReduction := foldRelayOracleReduction ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (ùìë:=ùìë) i hNCR) (init := init) (impl := impl)

lemma towerAlgebraMap_succ_1 (k : ‚Ñï) :
  towerAlgebraMap (l:=k) (r:=k+1) (h_le:=by omega) = canonicalEmbedding k

lemma contract_eq_liftF_of_lt {k : ‚Ñï} (h‚ÇÅ : k < m) :
  contract m f' k = liftF f' k

theorem generates_quotient_point_if_is_fiber_of_y
    (i : Fin ‚Ñì) (steps : ‚Ñï) (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
    (x : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i, by omega‚ü©))
    (y : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i.val + steps, by omega‚ü©))
    (hx_is_fiber : ‚àÉ (k : Fin (2 ^ steps)), x = qMap_total_fiber ùîΩq Œ≤ (i := ‚ü®i, by omega‚ü©)
      (steps := steps) (h_i_add_steps := by
        simp only; exact fin_‚Ñì_steps_lt_‚Ñì_add_R i steps h_i_add_steps) (y := y) k) :
    y = iteratedQuotientMap ùîΩq Œ≤ h_‚Ñì_add_R_rate i (k := steps) (h_bound := h_i_add_steps) x

@[simp]
lemma aeval_C {A : Type w} [CommSemiring A] [Algebra R A] (x : A) (r : R) :
    (aeval x) (C r : P) = algebraMap R A r

@[to_additive (attr := simp)]
theorem prod_Iic_zero : ‚àè j ‚àà Iic 0, v j = v 0

lemma add_equiv_raw [LawfulBEq R] (p q : UniPoly R) : Trim.equiv (p.add q) (p.add_raw q)

@[simp]
theorem finSuccEquivNth_X_below {i : Fin n} (h : i.castSucc < p) :
    finSuccEquivNth R p (X i.castSucc) = Polynomial.C (X i)

@[ext]
lemma ext {m n : ChurchNat Œ±} (h : ‚àÄ f x, m f x = n f x) : m = n

theorem fiberwise_dist_lt_imp_dist_lt_unique_decoding_radius (i : Fin ‚Ñì) (steps : ‚Ñï)
    [NeZero steps] (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
    (f : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i, by omega‚ü©)
  (h_fw_dist_lt : fiberwiseClose ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
    (i := i) (steps := steps) (h_i_add_steps := h_i_add_steps) (f := f)) :
  hammingClose ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i, by omega‚ü© f

theorem join_of_split {k : ‚Ñï} (h_pos : k > 0) (x : ConcreteBTField k)
    (hi_btf lo_btf : ConcreteBTField (k - 1))
    (h_split_eq : split h_pos x = (hi_btf, lo_btf)) :
    x = „Ää hi_btf, lo_btf „Äã

lemma rtake_eq_rtake : transcript‚ü¶m:‚üß = transcript.drop m h

@[simp]
theorem InternalData.leftSubtree_internal {Œ±} {s_left s_right : Skeleton}
    (value : Œ±) (left : InternalData Œ± s_left) (right : InternalData Œ± s_right) :
    (InternalData.internal value left right).leftSubtree = left

lemma concrete_exists_pair_ne {k : ‚Ñï} : ‚àÉ x y : ConcreteBTField k, x ‚â† y

lemma add_eq_one_iff (a b : ConcreteBTField 0) :
  a + b = 1 ‚Üî (a = 0 ‚àß b = 1) ‚à® (a = 1 ‚àß b = 0)

lemma discr_of_irred_components_nonzero
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  : ‚àÉ x‚ÇÄ,
      ‚àÄ R ‚àà (irreducible_factorization_of_gs_solution h_gs).choose_spec.choose,
      Bivariate.evalX x‚ÇÄ (Bivariate.discr_y R) ‚â† 0

lemma qMap_total_fiber_one_level_eq (i : Fin ‚Ñì) (h_i_add_1 : i.val + 1 ‚â§ ‚Ñì)
    (y : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i + 1, by omega‚ü©)) (k : Fin 2) :
    let basis_x := sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i, by omega‚ü© (by simp only; omega)
    let x : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i, by omega‚ü© := qMap_total_fiber ùîΩq Œ≤ (i := ‚ü®i, by omega‚ü©)
      (steps := 1) (h_i_add_steps := by apply Nat.lt_add_of_pos_right_of_le; omega) (y := y) k
    let y_lifted : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i, by omega‚ü© := sDomain.lift ùîΩq Œ≤ h_‚Ñì_add_R_rate
      (i := ‚ü®i, by omega‚ü©) (j := ‚ü®i.val + 1, by omega‚ü©)
      (h_j := by apply Nat.lt_add_of_pos_right_of_le; omega)
      (h_le := by apply Fin.mk_le_mk.mpr (by omega)) y
    let free_coeff_term : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i, by omega‚ü© :=
      (Fin2ToF2 ùîΩq k) ‚Ä¢ (basis_x ‚ü®0, by simp only; omega‚ü©)
    x = free_coeff_term + y_lifted

@[simp] theorem rightpad_length (n : Nat) (unit : Œ±) (l : List Œ±) :
    (rightpad n unit l).length = max n l.length

Finset.sup_lt_iff in Mathlib.Data.Finset.Lattice.Fold

@[simp]
theorem oracleReduction_completeness (h : init.neverFails) :
    (oracleReduction oSpec Statement OStatement pred).perfectCompleteness init impl
    (toRelInput pred hPred) Set.univ

theorem cast_eq_dcast‚ÇÇ {hn} {hSpec : pSpec‚ÇÅ.cast hn = pSpec‚ÇÇ} {i : ChallengeIdx pSpec‚ÇÅ}:
    i.cast hn hSpec = dcast‚ÇÇ hn hSpec i

@[simp]
lemma dfoldl'_zero {Œ± : Fin 1 ‚Üí Type u}
    (f : (i : Fin 0) ‚Üí Œ± i.castSucc ‚Üí Œ± i.succ) (x : Œ± 0) :
    dfoldl' 0 Œ± f x = x

@[simp]
lemma foldr'_succ {n : ‚Ñï} {Œ± : Type u} (f : (i : Fin (n + 1)) ‚Üí Œ± ‚Üí Œ±) (x : Œ±) :
    foldr' (n + 1) f x = f 0 (foldr' n (f ‚àò succ) x)

@[simp]
theorem eval_mapped_poly_at_root (k : ‚Ñï) :
    eval‚ÇÇ (AdjoinRoot.of (poly k)) (Z (k+1)) (poly k) = 0

theorem vcons_right_injective (a : Œ±) :
    Function.Injective (vcons a : (Fin n ‚Üí Œ±) ‚Üí Fin (n + 1) ‚Üí Œ±)

omit [NoZeroDivisors ùîΩ] in
lemma splitNth_degree_le {n : ‚Ñï} {f : ùîΩ[X]} [inst : NeZero n] :
  ‚àÄ {i}, (splitNth f n i).natDegree ‚â§ f.natDegree / n

@[simp]
lemma polynomialOfCoeffs_eq_zero :
  polynomialOfCoeffs coeffs = 0 ‚Üî ‚àÄ (x : ‚Ñï) (h : x < deg), coeffs ‚ü®x, h‚ü© = 0

@[simp]
lemma isRoot_polynomialsOfCoeffs {x : F} :
  IsRoot (polynomialOfCoeffs coeffs) x ‚Üî eval x (polynomialOfCoeffs coeffs) = 0

private lemma Bi_biUnion_F2i :
  Bi B i = Finset.univ.biUnion (F2i B i)

@[simp]
lemma dfoldrM'_zero {Œ± : Fin 1 ‚Üí Type u}
    (f : (i : Fin 0) ‚Üí Œ± i.succ ‚Üí m (Œ± i.castSucc)) (x : Œ± (last 0)) :
    dfoldrM' 0 Œ± f x = pure x

theorem canonical_of_size_zero {p : UniPoly R} : p.size = 0 ‚Üí p.trim = p

@[simp]
theorem hconcat_castSucc {Œ± : Fin n ‚Üí Sort u} {Œ≤ : Sort u}
    (v : (i : Fin n) ‚Üí Œ± i) (b : Œ≤) (i : Fin n) :
    hconcat v b (castSucc i) = cast (vconcat_castSucc Œ± Œ≤ i).symm (v i)

@[simp] lemma extract_dir : pSpec‚ü¶start:stop‚üß.dir = pSpec.dir‚ü¶start:stop‚üß

theorem rename_ne_zero_of_injective {œÑ : Type*} {f : œÉ ‚Üí œÑ} (hf : Function.Injective f)
    {p : MvPolynomial œÉ R} (h : p ‚â† 0) : rename f p ‚â† 0

@[simp]
lemma getTypes_hcons (x : Œ£ Œ± : Type u, Œ±) (xs : HList) :
    (x ::‚Çï xs).getTypes = x.1 :: xs.getTypes

theorem ScalarField_is_prime : Nat.Prime scalarFieldSize

lemma resultant_is_divisible_by_leadingCoeff {F : Type} [CommRing F] [Inhabited F] (f : F[X])
  : ‚àÉ r',
    Polynomial.resultant f (Polynomial.derivative f) = f.leadingCoeff * r'

theorem cast_eq_dcast {m n : ‚Ñï} (h : m = n) (a : Fin m) :
    Fin.cast h a = dcast h a

theorem nsmul_zero [LawfulBEq R] (p : UniPoly R) : nsmul 0 p = 0

@[simp] theorem toNat_mul (a b : AssocNat) : toNat (mul a b) = toNat a * toNat b

theorem dcast‚ÇÇ_symm (ha : a = a') (hb : dcast ha b = b') (hc : dcast‚ÇÇ ha hb c = c') :
    dcast‚ÇÇ ha.symm (dcast_symm ha hb) c' = c

theorem induction_heq {n n' : ‚Ñï} {motive : Fin (n + 1) ‚Üí Sort u} {motive' : Fin (n' + 1) ‚Üí Sort u}
    {zero : motive 0} {zero' : motive' 0}
    {succ : ‚àÄ i : Fin n, motive i.castSucc ‚Üí motive i.succ}
    {succ' : ‚àÄ i : Fin n', motive' i.castSucc ‚Üí motive' i.succ}
    {i : Fin (n + 1)} {i' : Fin (n' + 1)}
    (hn : n = n') (hmotive : HEq motive motive') (hzero : HEq zero zero')
    (hsucc : HEq succ succ') (hi : HEq i i') :
      HEq (induction (motive := motive) zero succ i)
        (induction (motive := motive') zero' succ' i')

theorem degrees_C_mul_le (p : MvPolynomial œÉ R) (c : R) : (C c * p).degrees ‚â§ p.degrees

lemma join_via_add_smul_zero {k : ‚Ñï} (h_pos : k > 0) :
  ‚ãò 0, 0 ‚ãô = 0

@[simp]
theorem mul_by_2_mem {s : Finset ‚Ñï} {d : ‚Ñï} :
    d ‚àà mul_by_2 s ‚Üî Even d ‚àß (d / 2) ‚àà s

@[simp]
theorem seqCompose_succ_dir {m : ‚Ñï} {n : Fin (m + 1) ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)} :
    (seqCompose pSpec).dir = Fin.vflatten (fun i => (pSpec i).dir)

theorem append_knowledgeSoundness (V‚ÇÅ : OracleVerifier oSpec Stmt‚ÇÅ OStmt‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : OracleVerifier oSpec Stmt‚ÇÇ OStmt‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ pSpec‚ÇÇ)
    {knowledgeError‚ÇÅ knowledgeError‚ÇÇ : ‚Ñù‚â•0}
    (h‚ÇÅ : V‚ÇÅ.knowledgeSoundness init impl rel‚ÇÅ rel‚ÇÇ knowledgeError‚ÇÅ)
    (h‚ÇÇ : V‚ÇÇ.knowledgeSoundness init impl rel‚ÇÇ rel‚ÇÉ knowledgeError‚ÇÇ) :
      (V‚ÇÅ.append V‚ÇÇ).knowledgeSoundness init impl rel‚ÇÅ rel‚ÇÉ
        (knowledgeError‚ÇÅ + knowledgeError‚ÇÇ)

lemma getLowBits_lt_two_pow {n : ‚Ñï} (numLowBits : ‚Ñï) :
    getLowBits numLowBits n < 2 ^ numLowBits

lemma cast_mul (m n : ‚Ñï) {x y : ConcreteBTField m} (h_eq : m = n) :
  (cast (by exact cast_ConcreteBTField_eq m n h_eq) (x * y)) =
  (cast (by exact cast_ConcreteBTField_eq m n h_eq) x) *
  (cast (by exact cast_ConcreteBTField_eq m n h_eq) y)

@[simp]
protected lemma elocPoly_zero : ElocPoly 0 œâs f p = 1

theorem PrattCertificate.out {p : ‚Ñï} (c : PrattCertificate p) : p.Prime

theorem funext‚ÇÇ_iff {Œ± : Sort u} {Œ≤ : Œ± ‚Üí Sort v} {Œ≥ : (a : Œ±) ‚Üí Œ≤ a ‚Üí Sort w}
    {f g : (a : Œ±) ‚Üí (b : Œ≤ a) ‚Üí Œ≥ a b} : f = g ‚Üî ‚àÄ a b, f a b = g a b

theorem BitVec.dcast_bitvec_eq_zero {l r : ‚Ñï} (h_width_eq : l = r) :
  dcast (h_width_eq) 0#(l) = 0#(r)

@[simp]
lemma bIdx_mul_œë_add_i_lt_‚Ñì_succ {m : ‚Ñï} (bIdx : Fin (‚Ñì / œë - 1)) (i : Fin œë) :
    ‚ÜëbIdx * œë + ‚Üëi < ‚Ñì + m

lemma concrete_one_mul0 (a : ConcreteBTField 0) :
  concrete_mul (one (k:=0)) a = a

theorem dappend_succ {motive : Fin (m + (n + 1)) ‚Üí Sort u}
    (u : (i : Fin m) ‚Üí motive (castAdd (n + 1) i))
    (v : (i : Fin (n + 1)) ‚Üí motive (natAdd m i)) :
    dappend (motive := motive) u v =
      (dappend u (fun i => v (castSucc i))) :+·µà‚ü®motive‚ü© (v (last n))

@[simp]
lemma evalDist_cast (h : Œ± = Œ≤) [spec.FiniteRange] :
    evalDist (cast (congrArg (OracleComp spec) h) oa) =
      cast (congrArg (PMF ‚àò Option) h) (evalDist oa)

omit h_Fq_char_prime in
theorem changeOfBasisMatrix_diag_ne_zero
  (‚Ñì : Nat) (h_‚Ñì : ‚Ñì ‚â§ r) :
  (‚àÄ i, (changeOfBasisMatrix ùîΩq Œ≤ ‚Ñì h_‚Ñì) i i ‚â† 0)

lemma lin_shift_e [Field F] [Fintype F]
  (h_B : B.card ‚â† 0)
  :
  e B v = e ({ x - v | x ‚àà B} : Finset _) 0

@[simp]
theorem fcons‚ÇÇ_one {Œ±‚ÇÅ : A} {Œ±‚ÇÇ : B} {Œ≤‚ÇÅ : Fin (n + 1) ‚Üí A} {Œ≤‚ÇÇ : Fin (n + 1) ‚Üí B}
    (a : F‚ÇÇ Œ±‚ÇÅ Œ±‚ÇÇ) (b : (i : Fin (n + 1)) ‚Üí F‚ÇÇ (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) :
    fcons‚ÇÇ (F := F‚ÇÇ) a b 1 = b 0

lemma mulVec_BerlekampWelchMatrix_eq :
  (BerlekampWelchMatrix e k œâs f).mulVec v i =
  ‚àë x : Fin (2 * e + k), v x * if x < e then f i * œâs i ^ x.1 else -œâs i ^ (x - e)

lemma johnson_denominator_def :
  JohnsonDenominator B v = ((1 - ((Fintype.card F) / (Fintype.card F - 1)) * (e B v / n)) ^ 2
      - (1 - ((Fintype.card F) / (Fintype.card F - 1)) * (d B/n)))

lemma sDomain_eq_image_of_upper_span (i : Fin r) (h_i : i < ‚Ñì + R_rate) :
    let V_i := Submodule.span ùîΩq (Set.range (sBasis Œ≤ h_‚Ñì_add_R_rate i h_i))
    let W_i_map := polyEvalLinearMap (normalizedW ùîΩq Œ≤ i)
      (normalizedW_is_additive ùîΩq Œ≤ i)
    sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i
    = Submodule.map W_i_map V_i

lemma concrete_inv_zero {k : ‚Ñï} : concrete_inv (k:=k) 0 = 0

theorem MLE_degreeOf (evals : (œÉ ‚Üí Fin 2) ‚Üí R) (i : œÉ) : degreeOf i (MLE evals) ‚â§ 1

omit [SelectableType R] in
@[simp]
lemma reduction_verifier_eq_verifier :
    (reduction R deg D n oSpec).verifier = verifier R deg D n oSpec

@[simp]
theorem BTField.RingHom_cast_dest_apply (k m n : ‚Ñï) (h_eq : m = n)
  (f : BTField k ‚Üí+* BTField m) (x : BTField k) :
    (cast (BTField.RingHom_eq_of_dest_eq (k:=k) (m:=m) (n:=n) h_eq) f) x
    = cast (by apply cast_BTField_eq (h_eq:=h_eq)) (f x)

lemma toImpl_elim (p : Q[X]) :
    (p = 0 ‚àß p.toImpl = #[])
  ‚à® (p ‚â† 0 ‚àß p.toImpl = .ofFn (fun i : Fin (p.natDegree + 1) => p.coeff i))

lemma algebraMap_adjacent_tower_succ_eq_Adjoin_of (k : ‚Ñï) :
  (algebraMap (BTField k) (BTField (k + 1))) = of (poly k)

lemma towerEquiv_commutes_left_diff (i d : ‚Ñï) : ‚àÄ r : ConcreteBTField i,
  (AlgebraTower.algebraMap i (i+d) (by omega)) ((towerEquiv i).ringEquiv r) =
  (towerEquiv (i+d)).ringEquiv ((AlgebraTower.algebraMap i (i+d) (by omega)) r)

NeZero.ne in Init.Data.NeZero

lemma exists_factors_with_large_common_root_set
  (Œ¥ : ‚Ñö) (x‚ÇÄ : F)
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  :
  ‚àÉ R H, R ‚àà (irreducible_factorization_of_gs_solution h_gs).choose_spec.choose ‚àß
    Irreducible H ‚àß H ‚à£ (Bivariate.evalX (Polynomial.C x‚ÇÄ) R) ‚àß
    #(@Set.toFinset _ { z : coeffs_of_close_proximity (F := F) k œâs Œ¥ u‚ÇÄ u‚ÇÅ |
        letI Pz := Pz z.2
        (Trivariate.eval_on_Z R z.1).eval Pz = 0 ‚àß
        (Bivariate.evalX z.1 H).eval (Pz.eval x‚ÇÄ) = 0} sorry)
    ‚â• #(coeffs_of_close_proximity k œâs Œ¥ u‚ÇÄ u‚ÇÅ) / (Bivariate.natDegreeY Q)
    ‚àß #(coeffs_of_close_proximity k œâs Œ¥ u‚ÇÄ u‚ÇÅ) / (Bivariate.natDegreeY Q) >
      2 * D_Y Q ^ 2 * (D_X ((k + 1 : ‚Ñö) / n) n m) * D_YZ Q

theorem mul_zero {a : CNat 50} : a * 0 = 0

theorem cast_symm {hn} (hSpec : pSpec‚ÇÅ.cast hn = pSpec‚ÇÇ) : pSpec‚ÇÇ.cast hn.symm = pSpec‚ÇÅ

theorem cast_injective : Function.Injective (ChallengeIdx.cast hn hSpec)

lemma forwardRange_getElem (n : ‚Ñï) (r : Fin n) (l : Fin (r.val + 1)) (k : Fin (r.val - l.val + 1)) :
    (forwardRange n r l).get ‚ü®k, by
      rw [forwardRange]; simp only [List.length_ofFn]; omega‚ü© = ‚ü®l.val + k, by omega‚ü©

lemma Basis.baseChangeRight_repr_tmul (b : Basis Œπ K Left) (x y i) :
    (Basis.baseChangeRight (b:=b) (Right:=Right)).repr (x ‚äó‚Çú y) i = b.repr x i ‚Ä¢ y

@[simp]
theorem cast_id : Verifier.cast rfl rfl = (id : Verifier oSpec StmtIn StmtOut pSpec‚ÇÅ ‚Üí _)

theorem distanceLE_mvPolynomial_degreeLE {œÉ : Type*} [Fintype œÉ] [DecidableEq œÉ] :
    distanceLE (R‚¶É‚â§ d‚¶Ñ[X œÉ]) (Fintype.card œÉ * d)

@[simp]
lemma eval_solutionToE {x : F} :
  eval x (solutionToE e k v) = x ^ e + ‚àë y : Fin e, v ‚ü®y, by omega‚ü© * x ^ y.1

@[simp]
theorem dcons_succ {motive : Fin (n + 1) ‚Üí Sort u} (a : motive 0)
    (v : (i : Fin n) ‚Üí motive i.succ) (i : Fin n) : (a ::·µà‚ü®motive‚ü© v) i.succ = v i

lemma rounds_sub_steps_lt : ‚Ñì - œë < ‚Ñì :=
  Nat.sub_lt (pos_of_neZero ‚Ñì) (folding_steps_pos)

lemma œë_sub_one_le_self : œë - 1 < œë

theorem insertNth_right_injective :
    Injective (Finsupp.insertNth p y : (Fin n ‚Üí‚ÇÄ M) ‚Üí Fin (n + 1) ‚Üí‚ÇÄ M)

@[simp]
lemma seqCompose_toReduction {m : ‚Ñï}
    (Stmt : Fin (m + 1) ‚Üí Type)
    {Œπ‚Çõ : Fin (m + 1) ‚Üí Type} (OStmt : (i : Fin (m + 1)) ‚Üí Œπ‚Çõ i ‚Üí Type)
    [O‚Çõ : ‚àÄ i, ‚àÄ j, OracleInterface (OStmt i j)]
    (Wit : Fin (m + 1) ‚Üí Type)
    {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    [O‚Çò : ‚àÄ i, ‚àÄ j, OracleInterface ((pSpec i).Message j)]
    (R : (i : Fin m) ‚Üí
      OracleReduction oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Wit i.castSucc)
        (Stmt i.succ) (OStmt i.succ) (Wit i.succ) (pSpec i)) :
    (seqCompose Stmt OStmt Wit R).toReduction =
      Reduction.seqCompose (fun i => Stmt i √ó (‚àÄ j, OStmt i j)) Wit
        (fun i => (R i).toReduction)

@[simp]
theorem cast_toVerifier (V : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec‚ÇÅ) :
    (OracleVerifier.cast hn hSpec hO‚Çò V).toVerifier = Verifier.cast hn hSpec V.toVerifier

@[simp]
theorem append_cast_left {n m : ‚Ñï} {pSpec : ProtocolSpec n} {pSpec' : ProtocolSpec m} (n' : ‚Ñï)
    (h : n + m = n' + m) :
      dcast h (pSpec ++‚Çö pSpec') = (dcast (Nat.add_right_cancel h) pSpec) ++‚Çö pSpec'

@[simp]
theorem seqCompose_zero {n : Fin 0 ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)} :
    seqCompose pSpec = !p[]

@[simp]
theorem InternalData.get_ofFun {Œ±} {s} (f : SkeletonInternalIndex s ‚Üí Œ±) :
    (InternalData.ofFun s f).get = f

theorem add_comm : p + q = q + p

lemma getLowBits_eq_mod_two_pow {numLowBits : ‚Ñï} (n : ‚Ñï) :
  getLowBits numLowBits n = n % (2 ^ numLowBits)

theorem zero_add (hp : p.canonical) : 0 + p = p

@[simp]
theorem rightpad_apply_lt (n : ‚Ñï) (a : Œ±) (v : Fin m ‚Üí Œ±) (i : Fin n)
    (h : i.val < m) : rightpad n a v i = v ‚ü®i.val, h‚ü©

theorem additiveNTT_correctness (h_‚Ñì : ‚Ñì ‚â§ r)
    (original_coeffs : Fin (2 ^ ‚Ñì) ‚Üí L)
    (output_buffer : Fin (2 ^ (‚Ñì + R_rate)) ‚Üí L)
    (h_alg : output_buffer = additiveNTT ùîΩq Œ≤ h_‚Ñì_add_R_rate original_coeffs) :
    let P := polynomialFromNovelCoeffs ùîΩq Œ≤ ‚Ñì h_‚Ñì original_coeffs
    ‚àÄ (j : Fin (2^(‚Ñì + R_rate))),
      output_buffer j = P.eval (evaluationPointœâ ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®0, by omega‚ü© j)

@[simp]
theorem toNat_zero : toNat zero = 0

@[simp, grind =]
lemma totalDegree_monomialXY {n m : ‚Ñï} {a : F} (ha : a ‚â† 0) :
  totalDegree (monomialXY n m a) = n + m

@[simp]
theorem Verifier.id_knowledgeSoundness {rel : Set (StmtIn √ó WitIn)} :
    (Verifier.id : Verifier oSpec _ _ _).knowledgeSoundness init impl rel rel 0

theorem GF_2_card : Fintype.card (GF(2)) = 2^(2^0)

@[grind _=_]
theorem monomialXY_def {n m : ‚Ñï} {a : F} : monomialXY n m a = monomial m (monomial n a)

@[simp]
theorem ConcreteBTField.RingHom_eq_of_source_eq (k n m : ‚Ñï) (h_eq : k = n) :
    (ConcreteBTField k ‚Üí+* ConcreteBTField m)
    = (ConcreteBTField n ‚Üí+* ConcreteBTField m)

theorem Nat.reconstruct_from_hi_and_lo_parts_or_ver (n hi_len lo_len : ‚Ñï)
  (h_n : n < 2 ^ (hi_len + lo_len)) :
    n = (((n >>> lo_len) % (2 ^ hi_len)) <<< lo_len) ||

theorem support_eval [DecidableEq œÉ] {œÑ : Type*} {f : œÑ ‚Üí R} {p : R[X œÉ][X œÑ]} :
    (eval (C ‚àò f) p).support ‚äÜ p.support.biUnion (fun c => (coeff c p).support)

theorem add_coeff {p q : UniPoly Q} {i : ‚Ñï} (hi : i < (add_raw p q).size) :
  (add_raw p q)[i] = p.coeff i + q.coeff i

@[simp]
lemma toFun_invFun (f : ‚àÄ a, Œ≤ a) : inst.equiv.toFun (equiv.invFun f : F) = f

lemma lagrangeToMono_eq_lagrangeToMono_segment (n : ‚Ñï) [NeZero n] (v : Vector R (2 ^ n)) :
  have h_n_ne_zero: n ‚â† 0

private lemma johnson_bound‚ÇÄ [Zero F]
  (h_n : 0 < n)
  (h_B : 2 ‚â§ B.card)
  (h_card : 2 ‚â§ (Fintype.card F))
  :
  B.card *
    ((1 - ((Fintype.card F : ‚Ñö) / (Fintype.card F - 1)) * (e B 0 / n)) ^ 2
      - (1 - ((Fintype.card F : ‚Ñö) / (Fintype.card F - 1)) * (d B/n)))  ‚â§
  ((Fintype.card F : ‚Ñö) / (Fintype.card F - 1)) * d B/n

theorem FullData.map_getRootValue {Œ± Œ≤ : Type} {s : Skeleton}
    (f : Œ± ‚Üí Œ≤) (tree : FullData Œ± s) :
    (tree.map f).getRootValue = f (tree.getRootValue)

lemma evenize_is_even {f : Polynomial F} :
    EvenPoly (evenize f)

@[simp]
theorem rtake_self' {Œ± : Sort*} (v : Fin n ‚Üí Œ±) : rtake n (by omega) v = v

@[simp]
theorem cast_perfectCompleteness (hComplete : R.perfectCompleteness init impl relIn relOut) :
    (R.cast hn hSpec).perfectCompleteness init impl relIn relOut

lemma domain_injective (i : ‚Ñï) : i ‚â§ n ‚Üí Function.Injective (domain D n i)

lemma cRank_rank_conversion :
  ‚Üë(U.rank) = U.cRank

omit [NeZero ‚Ñì] [NeZero r] [NeZero ùì°] in
lemma fin_‚Ñì_lt_r {h_‚Ñì_add_R_rate : ‚Ñì + ùì° < r} (i : Fin ‚Ñì)
    : i.val < r

theorem zero_lt_pow_n (m : ‚Ñï) (n : ‚Ñï) (h_m : m > 0): 0 < m^n

@[simp]
theorem leftpad_apply_ge (n : ‚Ñï) (a : Œ±) (v : Fin m ‚Üí Œ±) (i : Fin n)
    (h : n - m ‚â§ i.val) : leftpad n a v i = v ‚ü®i.val - (n - m), by omega‚ü©

theorem verifier_rbr_knowledge_soundness :
    (verifier oSpec Statement pred).rbrKnowledgeSoundness init impl
      (relIn Statement pred) (relOut Statement) 0

theorem LeafData.composeBuild_leaf {Œ±} (a : Œ±)
    (compose : Œ± ‚Üí Œ± ‚Üí Œ±) :
    (LeafData.leaf a).composeBuild compose = FullData.leaf a

@[simp]
lemma getTypes_eq_get_fst (l : HList) (i : Fin l.length) : l.getTypes[i] = l[i].1

lemma wt_eq_zero_iff [Zero F] {v : Œπ ‚Üí F} :
  wt v = 0 ‚Üî Fintype.card Œπ = 0 ‚à® ‚àÄ i, v i = 0

lemma algebra_adjacent_tower_def (l : ‚Ñï) :
  (algebra_adjacent_tower l) = (canonicalEmbedding l).toAlgebra

@[simp]
lemma eval‚ÇÇAlgHom_apply {A B : Type*} [CommSemiring A] [CommSemiring B] [MvPolynomialLike œÉ A P]
    [Algebra R A] [IsScalarTower R A P] [Algebra R B]
    (f : A ‚Üí‚Çê[R] B) (g : œÉ ‚Üí B) (p : P) :
    (eval‚ÇÇAlgHom f g) p = eval‚ÇÇ f g p

@[simp]
protected lemma elocPolyF_eq_elocPoly :
  ElocPolyF (n := n) (liftF' œâs) (liftF' f) = ElocPoly n œâs f

theorem coeff_eq_coeff [LawfulBEq R] (p : UniPoly R) (i : ‚Ñï) :
  p.trim.coeff i = p.coeff i

theorem eval_toPoly_eq_eval (x : Q) (p : UniPoly Q) : p.toPoly.eval x = p.eval x

theorem mem_restrictDegree_iff_degreeOf_le (p : MvPolynomial œÉ R) (n : ‚Ñï) :
    p ‚àà restrictDegree œÉ R n ‚Üî ‚àÄ i, p.degreeOf i ‚â§ n

lemma zipWith_const {Œ± Œ≤ : Type _} {f : Œ± ‚Üí Œ≤ ‚Üí Œ≤} {l‚ÇÅ : List Œ±} {l‚ÇÇ : List Œ≤}
  (h‚ÇÅ : l‚ÇÅ.length = l‚ÇÇ.length) (h‚ÇÇ : ‚àÄ a b, f a b = b) : l‚ÇÅ.zipWith f l‚ÇÇ = l‚ÇÇ

@[simp]
theorem minPoly_of_powerBasisSucc_generator (k : ‚Ñï) :
  (minpoly (ConcreteBTField k) (powerBasisSucc k).gen) = X^2 + (Z k) ‚Ä¢ X + 1

lemma eval‚ÇÇ_induction_on : True

@[simp]
theorem dconcat_last {motive : Fin (n + 1) ‚Üí Sort u} (v : (i : Fin n) ‚Üí motive (castSucc i))
    (a : motive (last n)) : (v :+·µà‚ü®motive‚ü© a) (last n) = a

theorem Basis_cast_dest_eq {Œπ : Type*} (k n m : ‚Ñï) (h_k_le_n : k ‚â§ n)
  (h_k_le_m : k ‚â§ m) (h_eq : m = n) :
  letI instLeftAlgebra := ConcreteBTFieldAlgebra (l:=k) (r:=m) (h_le:=h_k_le_m)
  letI instRightAlgebra := ConcreteBTFieldAlgebra (l:=k) (r:=n) (h_le:=h_k_le_n)
  @Basis Œπ (ConcreteBTField k) (ConcreteBTField m) _ _ instLeftAlgebra.toModule =
  @Basis Œπ (ConcreteBTField k) (ConcreteBTField n) _ _ instRightAlgebra.toModule

@[simp] theorem leftpad_eq_self (l : List Œ±) (n : Nat) (h : l.length ‚â• n) :
    leftpad n unit l = l

lemma oracle_block_k_next_le (i : Fin (‚Ñì + 1)) (j : Fin (toOutCodewordsCount ‚Ñì œë i))
    (hj : j.val + 1 < toOutCodewordsCount ‚Ñì œë i) : j.val * œë + œë ‚â§ i

@[local grind _=_]
private lemma support_eq_support_toFinsupp {f : F[X][Y]} : f.support = f.toFinsupp.support

@[to_additive]
theorem prod_Iic_succ (i : Fin n) :
    ‚àè j ‚àà Iic i.succ, v j = (‚àè j ‚àà Iic i.castSucc, v j) * v i.succ

theorem support_mul_C_le (p : MvPolynomial œÉ R) (r : R) : (p * C r).support ‚äÜ p.support

@[simp]
theorem dcast_eq : dcast (Eq.refl a) b = b

@[simp]
theorem ofNat_zero : ofNat 0 = @zero Œ±

@[simp]
lemma seqCompose_succ {m : ‚Ñï}
    (Stmt : Fin (m + 2) ‚Üí Type)
    {Œπ‚Çõ : Fin (m + 2) ‚Üí Type} (OStmt : (i : Fin (m + 2)) ‚Üí Œπ‚Çõ i ‚Üí Type)
    [O‚Çõ : ‚àÄ i, ‚àÄ j, OracleInterface (OStmt i j)]
    (Wit : Fin (m + 2) ‚Üí Type)
    {n : Fin (m + 1) ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    [O‚Çò : ‚àÄ i, ‚àÄ j, OracleInterface ((pSpec i).Message j)]
    (R : (i : Fin (m + 1)) ‚Üí
      OracleReduction oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Wit i.castSucc)
        (Stmt i.succ) (OStmt i.succ) (Wit i.succ) (pSpec i)) :
    seqCompose Stmt OStmt Wit R =
      append (R 0) (seqCompose (Stmt ‚àò Fin.succ) (fun i => OStmt (Fin.succ i)) (Wit ‚àò Fin.succ)
        (O‚Çõ := fun i => O‚Çõ (Fin.succ i)) (O‚Çò := fun i => O‚Çò (Fin.succ i))
          (fun i => R (Fin.succ i)))

theorem cast_eq_cast_iff {Œ± Œ≤ Œ≥ : Sort u} {h : Œ± = Œ≥} {h' : Œ≤ = Œ≥} {a : Œ±} {b : Œ≤} :
    cast h a = cast h' b ‚Üî a = cast (h'.trans h.symm) b

lemma coe_one_succ (l : ‚Ñï) :
    (@ConcreteBTFieldAlgebra (l:=l) (r:=l + 1) (h_le:=by omega)).algebraMap
    (1 : ConcreteBTField l) = (1 : ConcreteBTField (l + 1))

theorem zero_canonical : (0 : UniPoly R).trim = 0

theorem nsmul_succ [LawfulBEq R] (n : ‚Ñï) {p : UniPoly R} : nsmul (n + 1) p = nsmul n p + p

lemma Fin.val_sub_one (a : Fin r) (h_a_sub_1 : a > 0) : (a - 1).val = a.val - 1

theorem size_eq_degree (p : UniPoly R) : p.trim.size = p.degree

@[simp]
lemma range_def : (spec Œ±).range () = Œ±

theorem PrattCertificate'.out {p : ‚Ñï} (c : PrattCertificate' p) : p.Prime

@[simp]
lemma blockIdx_mul_œë_lt_‚Ñì_succ (i : Fin (‚Ñì / œë - 1 + 1)) : ‚Üëi * œë < ‚Ñì + 1

theorem linsolve_none {A : Matrix (Fin n) (Fin m) F} {b : Fin n ‚Üí F}
  (h : linsolve A b = none)
  : ¬¨‚àÉ x, A.mulVec x = b

@[simp]
theorem runWithOracle_freeMonad_pure_some (f : spec.FunctionType) (a : Œ±) :
    runWithOracle f (FreeMonad.pure (a : Option Œ±)) = a

lemma sub_middle_of_pow2_with_one_canceled {k : ‚Ñï} (h_k : 1 ‚â§ k) : 2 ^ k - 1 - 2 ^ (k - 1) + 1
  = 2 ^ (k - 1)

lemma principal_is_maximal_iff_irred {F : Type} [Field F] (f : F[X]) :
  (principalIdeal f).IsMaximal ‚Üî Irreducible f

lemma getLowBits_succ {n: ‚Ñï} (numLowBits: ‚Ñï) :
    getLowBits (numLowBits + 1) n = getLowBits numLowBits n
    + (getBit numLowBits n) <<< numLowBits

omit [Fintype F] in
private lemma hamming_dist_eq_sum {x y : Fin n ‚Üí F} :
  Œî‚ÇÄ(x, y) = ‚àë i, if x i = y i then 0 else 1

@[simp]
theorem fcons‚ÇÇ_succ {Œ±‚ÇÅ : A} {Œ±‚ÇÇ : B} {Œ≤‚ÇÅ : Fin n ‚Üí A} {Œ≤‚ÇÇ : Fin n ‚Üí B}
    (a : F‚ÇÇ Œ±‚ÇÅ Œ±‚ÇÇ) (b : (i : Fin n) ‚Üí F‚ÇÇ (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) (i : Fin n) :
    fcons‚ÇÇ (F := F‚ÇÇ) a b i.succ =
      cast (by simp [Fin.vcons_succ]) (b i)

@[simp]
theorem fappend‚ÇÇ_left {Œ±‚ÇÅ : Fin m ‚Üí A} {Œ±‚ÇÇ : Fin m ‚Üí B} {Œ≤‚ÇÅ : Fin n ‚Üí A} {Œ≤‚ÇÇ : Fin n ‚Üí B}
    (u : (i : Fin m) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i)) (v : (i : Fin n) ‚Üí F‚ÇÇ (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) (i : Fin m) :
    fappend‚ÇÇ (F := F‚ÇÇ) u v (castAdd n i) =
      cast (by simp [vappend_left]) (u i)

@[simp]
lemma relHammingDist_le_one : Œ¥·µ£(u, v) ‚â§ 1

theorem fcons‚ÇÇ_left_injective {Œ±‚ÇÅ : A} {Œ±‚ÇÇ : B} {Œ≤‚ÇÅ : Fin n ‚Üí A} {Œ≤‚ÇÇ : Fin n ‚Üí B}
    (b : (i : Fin n) ‚Üí F‚ÇÇ (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) :
    Function.Injective (fun a : F‚ÇÇ Œ±‚ÇÅ Œ±‚ÇÇ => fcons‚ÇÇ (F := F‚ÇÇ) a b)

lemma even_eval {f : Polynomial F} {s : F} (hEven : EvenPoly f) :
  f.eval (-s) = f.eval s

@[simp]
theorem minPoly_of_powerBasisSucc_generator (k : ‚Ñï) :
  (minpoly (BTField k) (powerBasisSucc k).gen) = X^2 + (Z k) ‚Ä¢ X + 1

theorem range_vcons {Œ± : Type*} (a : Œ±) (v : Fin n ‚Üí Œ±) :
    Set.range (a ::·µõ v) = insert a (Set.range v)

@[simp]
theorem vconcat_zero (a : Œ±) : vconcat !v[] a = !v[a]

@[simp]
lemma Rhs_zero_eq_neg' : Rhs 0 œâs f = -f

@[simp]
theorem FullData.map_leaf {Œ± Œ≤} (f : Œ± ‚Üí Œ≤) (a : Œ±) :
    (FullData.leaf a).map f = FullData.leaf (f a)

lemma add_self_cancel {k : ‚Ñï} (a : ConcreteBTField k) : a + a = 0

@[grind =] theorem idxOf'_cons [BEq Œ±] {a : Œ±} {x : Œ±} {xs : List Œ±} :
    idxOf' a (x :: xs) = bif x == a then 0 else idxOf' a xs + 1

theorem mca_capacity_bound_CONJECTURE
  [DecidableEq Œπ]
  (Œ± : F) (œÜ : Œπ ‚Ü™ F) (m : ‚Ñï) [Smooth œÜ]
  (par‚Ñì_type : Type) [Fintype par‚Ñì_type] (exp : par‚Ñì_type ‚Ü™ ‚Ñï) :
  let Gen := RSGenerator.genRSC par‚Ñì_type œÜ m exp
  let : Fintype Gen.par‚Ñì := Gen.h‚Ñì
  haveI := Gen.Gen_nonempty
  ‚àÉ (c‚ÇÅ c‚ÇÇ : ‚Ñï),
    ‚àÄ (f : Gen.par‚Ñì ‚Üí Œπ ‚Üí F) (Œ∑ : ‚Ñù) (_hŒ∑ : 0 < Œ∑) (Œ¥ : ‚Ñù‚â•0)
      (_hŒ¥ : 0 < Œ¥ ‚àß Œ¥ < 1 - Gen.rate - Œ∑),
      Pr_{let r ‚Üê$·µñ Gen.Gen}[ proximityCondition f Œ¥ r Gen.C ] ‚â§
        ENNReal.ofReal (
          (((Fintype.card par‚Ñì_type - 1) : ‚Ñù)^c‚ÇÇ * ((2^m) : ‚Ñù)^c‚ÇÇ) /
          (Œ∑^c‚ÇÅ * Gen.rate^(c‚ÇÅ+c‚ÇÇ) * (Fintype.card F))
        )

@[simp, grind] lemma R_le_N : sz.R ‚â§ sz.N

lemma aeval_definingPoly_at_Z_succ (k : ‚Ñï) :
  (aeval (Z (k + 1))) (definingPoly (s:=Z (k))) = 0

Nat.le_of_succ_le in Init.Data.Nat.Basic

private lemma sum_sum_K_i_eq_n_sub_d
  (h_B : 2 ‚â§ B.card)
  :
  ‚àë i, sum_choose_K_i B i = choose_2 B.card * (n - d B)

private lemma solutionToE_from_E
  (h_p_deg : p.natDegree < k)
  (h_dist : (Œî‚ÇÄ(f, p.eval ‚àò œâs) : ‚Ñï) ‚â§ e)
  : solutionToE e k (E_and_Q_to_a_solution e (E œâs f p e) (Q œâs f p e)) = E œâs f p e

theorem insertNth_zero_eq_cases {n : ‚Ñï} {Œ± : Fin (n + 1) ‚Üí Sort u} :
    insertNth 0 = cases (motive := Œ±)

theorem liftContext_completeness
    (h : R.completeness init impl innerRelIn innerRelOut completenessError) :
      (R.liftContext lens).completeness init impl outerRelIn outerRelOut completenessError

@[simp]
theorem dflatten_succ {m : ‚Ñï} {n : Fin (m + 1) ‚Üí ‚Ñï} {motive : (k : Fin (vsum n)) ‚Üí Sort*}
    {v : (i : Fin (m + 1)) ‚Üí (j : Fin (n i)) ‚Üí motive (embedSum i j)} :
    dflatten (motive := motive) v = dappend (v 0) (dflatten (fun i => v i.succ))

@[simp]
theorem zero_dappend {motive : Fin (0 + n) ‚Üí Sort u} {u : (i : Fin 0) ‚Üí motive (castAdd n i)}
    (v : (i : Fin n) ‚Üí motive (natAdd 0 i)) :
    dappend (motive := motive) u v = fun i => cast (by simp) (v (i.cast (by omega)))

@[simp]
theorem Prover.runToRound_zero_of_prover_first
    (stmt : StmtIn) (wit : WitIn) (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      prover.runToRound 0 stmt wit = (pure (default, prover.input (stmt, wit)))

@[simp]
theorem fconcat_castSucc {Œ± : Fin n ‚Üí A} {Œ≤ : A}
    (v : (i : Fin n) ‚Üí F (Œ± i)) (b : F Œ≤) (i : Fin n) :
    (v :+ ∞‚¶ÉF‚¶Ñ b) (castSucc i) = cast (by simp [vconcat_castSucc]) (v i)

@[to_additive /-- A variant of `Finset.add_sum_erase` with the addition swapped.--/]
theorem prod_mul_erase {Œ± Œ≤ : Type*} [CommMonoid Œ≤] [DecidableEq Œ±] (s : Finset Œ±) (f : Œ± ‚Üí Œ≤)
{a : Œ±} (h : a ‚àà s) : f a * (‚àè x ‚àà s.erase a, f x) = ‚àè x ‚àà s, f x

lemma fold_f_g_poly
  {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F} {k m : ‚Ñï}
  {œÜ_0 : (indexPowT S œÜ 0) ‚Ü™ F} {œÜ_k : (indexPowT S œÜ k) ‚Ü™ F}
  [Fintype (indexPowT S œÜ 0)] [DecidableEq (indexPowT S œÜ 0)] [Smooth œÜ_0]
  [Fintype (indexPowT S œÜ k)] [DecidableEq (indexPowT S œÜ k)] [Smooth œÜ_k]
  [‚àÄ i : ‚Ñï, Neg (indexPowT S œÜ i)]
  (Œ±s : Fin k ‚Üí F) (hk : k ‚â§ m)
  (f : smoothCode œÜ_0 m) (g : smoothCode œÜ_k (m-k)) :
  let fPoly

lemma twoAdicGenerators_pow_twoPow_eq_one (bits : Fin (twoAdicity + 1)) :
    (twoAdicGenerators[bits]) ^ (2 ^ (bits : Nat)) = (1 : Field)

@[simp]
theorem fflatten_two_eq_append {A : Sort u} {F : A ‚Üí Sort v} {n : Fin 2 ‚Üí ‚Ñï}
    {Œ± : (i : Fin 2) ‚Üí (j : Fin (n i)) ‚Üí A}
    {v : (i : Fin 2) ‚Üí (j : Fin (n i)) ‚Üí F (Œ± i j)} :
    fflatten v = fappend (F := F) (v 0) (v 1)

lemma isField_of_irreducible {H : F[X][Y]} : Irreducible H ‚Üí IsField (ùïÉ H)

@[simp]
theorem tail_vcons (a : Œ±) (v : Fin n ‚Üí Œ±) : tail (a ::·µõ v) = v

theorem castSum_castLT {l' : List ‚Ñï} {i : ‚Ñï} (j : Fin i) :
    castSum (i :: l') (by simp) j =
      castLT j (Nat.lt_of_lt_of_le j.isLt (List.le_sum_of_mem (by simp)))

theorem dcast_fun {Œ≥ : (a : Œ±) ‚Üí Œ≤ a ‚Üí Sort*} {f : (b : Œ≤ a) ‚Üí Œ≥ a b} :
    f (dcast rfl b) = dcast (Œ± := Œ≤ a) (Œ≤ := Œ≥ a) dcast_eq.symm (f b)

theorem galois_automorphism_power
    {curBTField : Type*} [Field curBTField]
    (u : curBTField) (t1 : curBTField) -- here t1 is already lifted to curBTField
    (k : ‚Ñï)
    (sumZeroIffEq : ‚àÄ (x y : curBTField), x + y = 0 ‚Üî x = y)
    (specialElementNeZero : u ‚â† 0)
    (prevSpecialElementNeZero : t1 ‚â† 0)
    (u_plus_inv_eq_t1 : u + u‚Åª¬π = t1)
    (h_u_square : u ^ 2 = u * t1 + 1)
    (h_t1_pow : t1 ^ (2 ^ (2 ^ k) - 1) = 1 ‚àß (t1‚Åª¬π) ^ (2 ^ (2 ^ k) - 1) = 1)
    (trace_map_roots : ‚àë i ‚àà Finset.range (2 ^ k), t1 ^ (2 ^ i) = 1 ‚àß
                      ‚àë i ‚àà Finset.range (2 ^ k), t1‚Åª¬π ^ (2 ^ i) = 1) :
    u^(2^(2^k)) = u‚Åª¬π ‚àß (u‚Åª¬π)^(2^(2^k)) = u

@[simp]
lemma Transcript.def_eq {k : Fin (n + 1)} {pSpec : ProtocolSpec n} :
    (pSpec.take k k.is_le).FullTranscript =
      ((i : Fin k) ‚Üí pSpec.¬´Type¬ª (Fin.castLE (by omega) i))

lemma eval_normalizedW_succ_at_beta_prev (i : Fin r) (h_i_add_1 : i + 1 < r) :
  (normalizedW ùîΩq Œ≤ (i + 1)).eval (Œ≤ i) = 0

theorem div_two_pow_lt_two_pow (x i j : ‚Ñï) (h_x_lt_2_pow_i : x < 2 ^ (i + j)): x / 2^j < 2^(i)

lemma linsolve_is_berlekamp_welch_solution
  (h_linsolve : linsolve (BerlekampWelchMatrix e k œâs f) (Rhs e œâs f) = some v)
  : IsBerlekampWelchSolution e k œâs f v

theorem coreInteractionOracleVerifier_rbrKnowledgeSoundness :
    (coreInteractionOracleVerifier ùîΩq Œ≤).rbrKnowledgeSoundness init impl
      (pSpec := pSpecCoreInteraction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
      (relIn := roundRelation (mp := BBF_SumcheckMultiplierParam) ùîΩq Œ≤ (œë:=œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) 0)
      (relOut := finalSumcheckRelOut ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
      (rbrKnowledgeError := coreInteractionOracleRbrKnowledgeError ùîΩq Œ≤ (œë:=œë))

theorem eval_toImpl_eq_eval [LawfulBEq R] (x : R) (p : R[X]) : p.toImpl.eval x = p.eval x

theorem eq_of_degreeOf_lt_card_of_eval_eq {p q : R[X œÉ]} (S : œÉ ‚Üí Finset R)
    (hDegree : ‚àÄ i, p.degreeOf i < #(S i))
    (hEval : ‚àÄ x ‚àà piFinset fun i ‚Ü¶ S i, eval x p = eval x q) : p = q

@[simp]
theorem happend_zero {Œ≤ : Fin m ‚Üí Sort u} {Œ± : Fin 0 ‚Üí Sort u} (u : (i : Fin m) ‚Üí Œ≤ i) :
    happend u !h‚ü®Œ±‚ü©[] = u

lemma monoToLagrange_eq_monoToLagrange_segment (n : ‚Ñï) [NeZero n] (v : Vector R (2 ^ n)) :
  have h_n_ne_zero: n ‚â† 0

private lemma errors_are_roots_of_E {i : Fin n}
  (h : f i ‚â† p.eval (œâs i)) : (E œâs f p e).eval (œâs i) = 0

@[simp]
theorem seqCompose_two_eq_append {n : Fin 2 ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)} :
    seqCompose pSpec = append (pSpec 0) (pSpec 1)

lemma foldl_NTTStage_inductive_aux (h_‚Ñì : ‚Ñì ‚â§ r) (k : Fin (‚Ñì + 1))
    (original_coeffs : Fin (2 ^ ‚Ñì) ‚Üí L) :
    additiveNTTInvariant ùîΩq Œ≤ h_‚Ñì_add_R_rate
    (Fin.foldl k (fun current_b i ‚Ü¶ NTTStage ùîΩq Œ≤ h_‚Ñì_add_R_rate
      ‚ü®‚Ñì - i -1, by omega‚ü© current_b) (tileCoeffs original_coeffs))
    original_coeffs ‚ü®‚Ñì - k, by omega‚ü©

private lemma almost_johnson [Zero F]
  (h_n : 0 < n)
  (h_B : 2 ‚â§ B.card)
  (h_card : 2 ‚â§ (Fintype.card F))
  :
  n * (choose_2 (k B) + (Fintype.card F - 1)
    * choose_2 ((B.card - k B) / (Fintype.card F - 1)))
  ‚â§
  choose_2 B.card * (n - d B)

lemma distInterleavedCodeToCodeLB
  {IC : LawfulInterleavedCode Œ∫ Œπ F} {U : Matrix Œ∫ Œπ F} {e : ‚Ñï}
  (hF : Fintype.card F ‚â• e)
  (he : (e : ‚Ñö) ‚â§ (minDist (IC.1.LC : Set (Œπ ‚Üí F)) / 3)) (hU : e < Œî(U,IC.1.MF)) :
  ‚àÉ v ‚àà Matrix.rowSpan U , e < distFromCode v IC.1.LC

@[simp]
theorem generator_is_not_lifted_to_succ (k : ‚Ñï) :
  ‚àÄ x : ConcreteBTField k, canonicalAlgMap (k:=k) x ‚â† Z (k + 1)

lemma mkLastOracleIndex_last : mkLastOracleIndex ‚Ñì œë (Fin.last ‚Ñì) = ‚Ñì / œë - 1

theorem oracleVerifier_rbrKnowledgeSoundness [Fintype R] :
    (oracleVerifier R deg D n oSpec).rbrKnowledgeSoundness init impl
      (relationRound R n deg D 0) (relationRound R n deg D (.last n))
      (fun _ => (deg : ‚Ñù‚â•0) / (Fintype.card R))

theorem reduction_rbr_knowledge_soundness : True

lemma sum_of_and_eq_zero_is_xor {n m : ‚Ñï} (h_n_AND_m : n &&& m = 0) : n + m = n ^^^ m

@[simp]
private lemma x_times_oddPart'_coeff {f : Polynomial F} {n : ‚Ñï} :
    (x_times_oddPart' f).coeff n = if Odd n then f.coeff n else 0

@[simp]
theorem LeafData.get_leaf {Œ±} (a : Œ±) :
    (LeafData.leaf a).get SkeletonLeafIndex.ofLeaf = a

theorem vconcat_right_injective (v : Fin n ‚Üí Œ±) : Function.Injective (vconcat v)

theorem reduction_perfectCompleteness (hInit : init.neverFails) :
    (reduction R deg D n oSpec).perfectCompleteness init impl
      (relationRound R n deg D 0) (relationRound R n deg D (.last n))

@[grind]
lemma quotient_nezero {f q : F[X][Y]} (hg : q * f ‚â† 0) : q ‚â† 0

@[simp]
theorem drop_all (v : (i : Fin n) ‚Üí Œ± i) :
    drop n n.le_refl v = fun i => Fin.elim0 (i.cast (Nat.sub_self n))

@[simp]
theorem dappend_zero {motive : Fin (m + 0) ‚Üí Sort u} (u : (i : Fin m) ‚Üí motive (castAdd 0 i)) :
    dappend (motive := motive) u !d‚ü®fun _ : Fin 0 => motive (natAdd m _)‚ü©[] = u

@[simp]
theorem dcast‚ÇÉ_trans (ha : a = a') (ha' : a' = a'')
    (hb : dcast ha b = b') (hb' : dcast ha' b' = b'')
    (hc : dcast‚ÇÇ ha hb c = c') (hc' : dcast‚ÇÇ ha' hb' c' = c'') :
    dcast‚ÇÉ ha' hb' hc' (dcast‚ÇÉ ha hb hc d) =
    dcast‚ÇÉ (ha.trans ha') (by simp [‚Üê hb', ‚Üê hb]) (by simp [‚Üê hc', ‚Üê hc]) d

Fin.isLt in Init.Prelude

lemma duplexSpongeToFSGameStatDist
    (maliciousProver : OracleComp (oSpec ++‚Çí duplexSpongeChallengeOracle StmtIn U)
      (StmtIn √ó pSpec.Messages))
    (t‚Çí : Œπ ‚Üí ‚Ñï) (t‚Çï t‚Çö t‚Çö·µ¢ : ‚Ñï)
    -- TODO: state query bound only for subset of the oracles
    (hQuery : IsQueryBound maliciousProver (t‚Çí ‚äï·µ• (t‚Çï ‚äï·µ• (t‚Çö ‚äï·µ• t‚Çö·µ¢)))) : True

@[simp]
lemma halfNumFullRounds_mul_2_eq_numFullRounds :
    params.halfNumFullRounds * 2 = params.numFullRounds

theorem pow_three_eq_mul_sq {a : CNat 1} : a ^ 3 = a * (a * a)

@[simp]
lemma deevenize_coeff {f : Polynomial F} {n : ‚Ñï} :
    (deevenize f).coeff n = f.coeff (2 * n)

lemma guruswami_sudan_for_proximity_gap_existence {k m : ‚Ñï} {œâs : Fin n ‚Ü™ F} {f : Fin n ‚Üí F} :
  ‚àÉ Q, Condition (k + 1) m ((proximity_gap_degree_bound ((k + 1 : ‚Ñö) / n) m n)) œâs f Q

theorem FullData.toLeafData_leftSubtree {Œ±} {s_left s_right : Skeleton}
    (tree : FullData Œ± (Skeleton.internal s_left s_right)) :
    tree.toLeafData.leftSubtree =
      tree.leftSubtree.toLeafData

@[simp]
lemma dotProduct_cons [AddCommMonoid R] [Mul R] (a : R) (b : Vector R n) (c : R) (d : Vector R n) :
  dotProduct (cons a b) (cons c d) = a * c + dotProduct b d

lemma getBit_of_shiftRight {n p : ‚Ñï}:
  ‚àÄ k, getBit k (n >>> p) = getBit (k+p) n

omit [SelectableType R] in
@[simp]
lemma reduction_verifier_eq_verifier {i : Fin n} :
    (reduction R n deg D oSpec i).verifier = verifier R n deg D oSpec i

theorem eq_of_lt_dist {C : Set (n ‚Üí R)} {u v : n ‚Üí R} (hu : u ‚àà C) (hv : v ‚àà C)
    (huv : Œî‚ÇÄ(u, v) < ‚ÄñC‚Äñ‚ÇÄ) : u = v

@[simp]
theorem FullData.rightSubtree_internal {Œ±} {s_left s_right : Skeleton}
    (value : Œ±) (left : FullData Œ± s_left) (right : FullData Œ± s_right) :
    (FullData.internal value left right).rightSubtree = right

lemma add_zero {k : ‚Ñï} (a : ConcreteBTField k) : a + 0 = a

@[simp]
theorem bool_accepts_iff_of_domain [IsDomain ùì°] :
    (bool j).accepts x ‚Üî x j = 0 ‚à® x j = 1

@[simp]
lemma divide_by_2_empty :
    divide_by_2 ‚àÖ = ‚àÖ

lemma getBit_joinBits {n m k : ‚Ñï} (low : Fin (2 ^ n)) (high : Fin (2 ^ m)) :
  getBit k (joinBits low high).val =
    if k < n then getBit k low.val else getBit (k - n) high.val

@[simp]
theorem Reduction.id_run (stmt : StmtIn) (wit : WitIn) :
    (Reduction.id : Reduction oSpec StmtIn WitIn _ _ _).run stmt wit =
      pure ‚ü®‚ü®default, stmt, wit‚ü©, stmt‚ü©

@[csimp] lemma dfoldl_eq_dfoldl' : @dfoldl = @dfoldl'

theorem happend_left_eq_hcons {Œ± : Fin 1 ‚Üí Sort u} {Œ≤ : Fin n ‚Üí Sort u}
    (a : (i : Fin 1) ‚Üí Œ± i) (v : (i : Fin n) ‚Üí Œ≤ i) :
    True

theorem seqCompose_soundness
    (lang : (i : Fin (m + 1)) ‚Üí Set (Stmt i))
    (V : (i : Fin m) ‚Üí Verifier oSpec (Stmt i.castSucc) (Stmt i.succ) (pSpec i))
    (soundnessError : Fin m ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (V i).soundness init impl (lang i.castSucc) (lang i.succ) (soundnessError i)) :
      (Verifier.seqCompose Stmt V).soundness init impl (lang 0) (lang (Fin.last m))
        (‚àë i, soundnessError i)

Nat.lt_of_add_right_lt in Init.Data.Nat.Basic

@[simp]
theorem BTField.RingHom_eq_of_dest_eq (k m n : ‚Ñï) (h_eq : m = n) :
  (BTField k ‚Üí+* BTField m) = (BTField k ‚Üí+* BTField n)

@[simp]
theorem OracleVerifier.id_soundness {lang : Set (StmtIn √ó ‚àÄ i, OStmtIn i)} :
    (OracleVerifier.id : OracleVerifier oSpec _ _ _ _ _).soundness
      init impl lang lang 0

theorem liftContext_rbr_knowledgeSoundness [Inhabited InnerStmtOut] [Inhabited InnerWitIn]
    {outerRelIn : Set (OuterStmtIn √ó OuterWitIn)} {outerRelOut : Set (OuterStmtOut √ó OuterWitOut)}
    {innerRelIn : Set (InnerStmtIn √ó InnerWitIn)} {innerRelOut : Set (InnerStmtOut √ó InnerWitOut)}
    {rbrKnowledgeError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    {stmtLens : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut}
    {witLens : Witness.InvLens OuterStmtIn OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    (V : Verifier oSpec InnerStmtIn InnerStmtOut pSpec)
    [lensKS : Extractor.Lens.IsKnowledgeSound outerRelIn innerRelIn outerRelOut innerRelOut
      (V.compatStatement stmtLens) (fun _ _ => True) ‚ü®stmtLens, witLens‚ü©]
    (h : V.rbrKnowledgeSoundness init impl innerRelIn innerRelOut rbrKnowledgeError) :
      (V.liftContext stmtLens).rbrKnowledgeSoundness init impl outerRelIn outerRelOut
        rbrKnowledgeError

omit [DecidableEq L] [DecidableEq ùîΩq] h_Fq_char_prime hF‚ÇÇ hŒ≤_lin_indep h_Œ≤‚ÇÄ_eq_1 in
theorem qMap_eval_ùîΩq_eq_0 (i : Fin r) :
  ‚àÄ c: ùîΩq, (qMap ùîΩq Œ≤ i).eval (algebraMap ùîΩq L c) = 0

@[to_additive (attr := simp)]
theorem prod_insertNth [CommMonoid Œ≤] {n : ‚Ñï} (x : Œ≤) (f : Fin n ‚Üí Œ≤) (p : Fin (n + 1)) :
    ‚àè i, insertNth p x f i = x * ‚àè i, f i

omit [Fintype F] in
private lemma hamming_weight_eq_sum [Zero F] {x : Fin n ‚Üí F}
  :
  ‚Äñx‚Äñ‚ÇÄ = ‚àë i, if x i = 0 then 0 else 1

theorem sum_square_char2 {F : Type*} [Field F] (sumZeroIffEq : ‚àÄ (x y : F), x + y = 0 ‚Üî x = y)
  (s : Finset ‚Ñï) (f : ‚Ñï ‚Üí F) : (‚àë j ‚àà s, f j)^2 = ‚àë j ‚àà s, (f j)^2

theorem getBit_repr {‚Ñì : Nat} : ‚àÄ j, j < 2^‚Ñì ‚Üí
  j = ‚àë k ‚àà Finset.Icc 0 (‚Ñì-1), (getBit k j) * 2^k

@[simp] theorem idxOf'_nil [BEq Œ±] {a : Œ±} : idxOf' a [] = 0

@[simp]
lemma cons_empty_tail_eq_nil {Œ±} (hd : Œ±) (tl : Vector Œ± 0) :
    cons hd tl = ‚ü®#[hd], rfl‚ü©

lemma rank_eq_if_det_ne_zero {U : Matrix (Fin n) (Fin n) F} [IsDomain F] :
  Matrix.det U ‚â† 0 ‚Üí U.rank = n

theorem append_rbrKnowledgeSoundness
    (V‚ÇÅ : Verifier oSpec Stmt‚ÇÅ Stmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : Verifier oSpec Stmt‚ÇÇ Stmt‚ÇÉ pSpec‚ÇÇ)
    {rbrKnowledgeError‚ÇÅ : pSpec‚ÇÅ.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    {rbrKnowledgeError‚ÇÇ : pSpec‚ÇÇ.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    (h‚ÇÅ : V‚ÇÅ.rbrKnowledgeSoundness init impl rel‚ÇÅ rel‚ÇÇ rbrKnowledgeError‚ÇÅ)
    (h‚ÇÇ : V‚ÇÇ.rbrKnowledgeSoundness init impl rel‚ÇÇ rel‚ÇÉ rbrKnowledgeError‚ÇÇ) :
      (V‚ÇÅ.append V‚ÇÇ).rbrKnowledgeSoundness init impl rel‚ÇÅ rel‚ÇÉ
        (Sum.elim rbrKnowledgeError‚ÇÅ rbrKnowledgeError‚ÇÇ ‚àò ChallengeIdx.sumEquiv.symm)

omit [NeZero ‚Ñì] in
lemma fin_‚Ñì_steps_lt_‚Ñì_add_R (i : Fin ‚Ñì) (steps : ‚Ñï) (h : i.val + steps ‚â§ ‚Ñì)
    : i.val + steps < ‚Ñì + ùì°

theorem monomialBasis_getElem {w : Vector R n} (i : Fin (2 ^ n)) :
    (monomialBasis w)[i] = ‚àè j : Fin n, if (BitVec.ofFin i).getLsb j then w[j] else 1

@[simp]
theorem vcons_empty (a : Œ±) : a ::·µõ !v[] = !v[a]

@[simp]
lemma challengeOracleInterface_append_domain_inl (j : pSpec‚ÇÅ.ChallengeIdx) :
    [(pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).Challenge]‚Çí.domain (.inl j) = Unit

lemma zero_is_0 {k : ‚Ñï} : (zero (k:=k)) = (0 : ConcreteBTField k)

@[simp]
theorem FullData.toLeafData_internal {Œ±} {s_left s_right : Skeleton}
    (value : Œ±) (left : FullData Œ± s_left) (right : FullData Œ± s_right) :
    (FullData.internal value left right).toLeafData =
      LeafData.internal (left.toLeafData) (right.toLeafData)

@[simp]
lemma addSalt_dir : (pSpec.addSalt Salt).dir = pSpec.dir

theorem fcons_inj {Œ≤ : Fin n ‚Üí A} (a‚ÇÅ a‚ÇÇ : F Œ±) (b‚ÇÅ b‚ÇÇ : (i : Fin n) ‚Üí F (Œ≤ i)) :
    fcons a‚ÇÅ b‚ÇÅ = fcons a‚ÇÇ b‚ÇÇ ‚Üî a‚ÇÅ = a‚ÇÇ ‚àß b‚ÇÅ = b‚ÇÇ

lemma sqrt_le_J {q Œ¥ : ‚Ñö} (hq : q > 1) (hx0 : 0 ‚â§ Œ¥) (hx1 : Œ¥ ‚â§ 1) (hqx : q / (q - 1) * Œ¥ ‚â§ 1) :
  1 - ((1-Œ¥) : ‚Ñù).sqrt ‚â§ J q Œ¥

@[simp]
lemma eval‚ÇÇ_monomial {S : Type w} [CommSemiring S] (f : R ‚Üí+* S) (x : S) (n : ‚Ñï) (r : R) :
    eval‚ÇÇ (P := P) f x (monomial n r) = f r * x ^ n

theorem BitVec.dcast_bitvec_extractLsb_eq {w hi1 lo1 hi2 lo2 : ‚Ñï}
    (x : BitVec w) (h_lo_eq : lo1 = lo2)
    (h_width_eq : hi1 - lo1 + 1 = hi2 - lo2 + 1) :
    dcast h_width_eq (BitVec.extractLsb (hi:=hi1) (lo:=lo1) x)
      = BitVec.extractLsb (hi:=hi2) (lo:=lo2) (x)

theorem hconcat_init_self {Œ± : Fin n.succ ‚Üí Sort u} (v : (i : Fin (n + 1)) ‚Üí Œ± i) :
    True

@[simp] theorem toNat_ofNat (n : Nat) : toNat (ofNat n) = n

theorem liftContext_run
    {lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    {outerStmtIn : OuterStmtIn} {outerWitIn : OuterWitIn}
    {P : Prover oSpec InnerStmtIn InnerWitIn InnerStmtOut InnerWitOut pSpec} :
      (P.liftContext lens).run outerStmtIn outerWitIn
      = do
        let ‚ü®fullTranscript, innerCtxOut‚ü© ‚Üê
          P.run.uncurry (lens.proj (outerStmtIn, outerWitIn))
        return ‚ü®fullTranscript, lens.lift (outerStmtIn, outerWitIn) innerCtxOut‚ü©

lemma definingPoly_ne_zero {F : Type*} [Field F] [Fintype F] (s : F) [NeZero s] :
  (definingPoly s) ‚â† 0

theorem cast_Type_idx_symm {hn} (hSpec : pSpec‚ÇÅ.cast hn = pSpec‚ÇÇ) {i : Fin n‚ÇÇ} :
    pSpec‚ÇÅ.¬´Type¬ª (Fin.cast hn.symm i) = pSpec‚ÇÇ.¬´Type¬ª i

lemma forwardRange_pred_le_ne_empty (n : ‚Ñï) (r : Fin n) (l : Fin (r.val + 1))
    (h_l_gt_0 : l.val > 0) : forwardRange n r ‚ü®l.val - 1, by omega‚ü© ‚â† []

theorem Fin.sum_univ_odd_even {n : ‚Ñï} {M : Type*} [AddCommMonoid M] (f : ‚Ñï ‚Üí M) :
    (‚àë i : Fin (2 ^ n), f (2 * i)) + (‚àë i : Fin (2 ^ n), f (2 * i + 1))
    = ‚àë i: Fin (2 ^ (n+1)), f i

lemma sum_eq_xor_plus_twice_and (n : Nat) : ‚àÄ m : ‚Ñï, n + m = (n ^^^ m) + 2 * (n &&& m)

theorem eq_zero_or_eq_one {a : ConcreteBTField 0} : a = zero ‚à® a = one

theorem toNat_ofNat (n : ‚Ñï) : toNat (ofNat n) = n

theorem relayOracleVerifier_rbrKnowledgeSoundness (i : Fin ‚Ñì)
    (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
    (relayOracleVerifier ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        i hNCR).rbrKnowledgeSoundness init impl
      (relIn := foldStepRelOut (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i.succ)
      (relayKnowledgeError)

lemma aeval_apply {A : Type w} [CommSemiring A] [Algebra R A] (s : A) :
    aeval (P := P) s = eval‚ÇÇAlgHom (Algebra.ofId R A) s

private lemma solutionToQ_from_Q
  (h_p_deg : p.natDegree < k)
  (h_dist : (Œî‚ÇÄ(f, p.eval ‚àò œâs) : ‚Ñï) ‚â§ e)
  : solutionToQ e k (E_and_Q_to_a_solution e (E œâs f p e) (Q œâs f p e)) = Q œâs f p e

theorem fconcat‚ÇÇ_left_injective {Œ±‚ÇÅ : Fin n ‚Üí A} {Œ±‚ÇÇ : Fin n ‚Üí B} {Œ≤‚ÇÅ : A} {Œ≤‚ÇÇ : B} (a : F‚ÇÇ Œ≤‚ÇÅ Œ≤‚ÇÇ) :
    Function.Injective (fun v : (i : Fin n) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i) => fconcat‚ÇÇ (F := F‚ÇÇ) v a)

theorem toNatInRange {k : ‚Ñï} (b : ConcreteBTField k) :
  BitVec.toNat b ‚â§ 2 ^ (2 ^ k) * 1

@[simp]
theorem dempty_happend {Œ± : Fin 0 ‚Üí Sort u} {Œ≤ : Fin n ‚Üí Sort u} (v : (i : Fin n) ‚Üí Œ≤ i) :
    happend !d‚ü®Œ±‚ü©[] v =
      fun i : Fin (0 + n) => cast (by simp) (v <| i.cast (by omega))

theorem last_nonzero_some_iff [LawfulBEq R] {p : UniPoly R} {k} :
  p.last_nonzero = some k ‚Üî (p[k] ‚â† 0 ‚àß (‚àÄ j, (hj : j < p.size) ‚Üí j > k ‚Üí p[j] = 0))

lemma le_sInf_of_LB {S : Set ‚Ñï} (hne : S.Nonempty) {i : ‚Ñï}
    (hLB : ‚àÄ s ‚àà S, i ‚â§ s) : i ‚â§ sInf S

theorem init_vconcat (v : Fin n ‚Üí Œ±) (a : Œ±) :
    (fun i => vconcat v a (Fin.castSucc i)) = v

@[simp]
theorem bit_finProdFinEquiv_symm_2_pow_succ {n : ‚Ñï} (j : Fin (2 ^ (n + 1))) (i : Fin (n + 1)) :
  let e:=finProdFinEquiv (m:=2^(n)) (n:=2).symm
  Nat.getBit (i) j = if i.val > 0 then Nat.getBit (i.val-1) (e j).1 else (e j).2

@[simp]
private lemma E_ne_zero : (E œâs f p e) ‚â† 0

@[simp]
theorem hflatten_succ {m : ‚Ñï} {n : Fin (m + 1) ‚Üí ‚Ñï}
    {Œ± : (i : Fin (m + 1)) ‚Üí (j : Fin (n i)) ‚Üí Sort*}
    {v : (i : Fin (m + 1)) ‚Üí (j : Fin (n i)) ‚Üí Œ± i j} :
    hflatten v = happend (v 0) (hflatten (fun i => v i.succ))

@[simp]
lemma dfoldr'_zero {Œ± : Fin 1 ‚Üí Type u}
    (f : (i : Fin 0) ‚Üí Œ± i.succ ‚Üí Œ± i.castSucc) (x : Œ± (last 0)) :
    dfoldr' 0 Œ± f x = x

theorem join_eq_join_iff {k : ‚Ñï} (h_pos : k > 0) (hi‚ÇÄ lo‚ÇÄ hi‚ÇÅ lo‚ÇÅ : ConcreteBTField (k - 1)) :
  „Ää hi‚ÇÄ, lo‚ÇÄ „Äã = „Ää hi‚ÇÅ, lo‚ÇÅ „Äã ‚Üî (hi‚ÇÄ = hi‚ÇÅ ‚àß lo‚ÇÄ = lo‚ÇÅ)

lemma concrete_mul_right_distrib0 (a b c : ConcreteBTField 0) :
  concrete_mul (a + b) c = concrete_mul a c + concrete_mul b c

theorem eval_eq_eval_mv_eval_finSuccEquivNth (s : Fin n ‚Üí R) (y : R)
    (f : MvPolynomial (Fin (n + 1)) R) :
      eval (Fin.insertNth p y s : Fin (n + 1) ‚Üí R) f =
        Polynomial.eval y (Polynomial.map (eval s) (finSuccEquivNth R p f))

theorem foldr_split_outer {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤ ‚Üí Œ≤) (init : Œ≤)
    (l : List Œ±) (h : l ‚â† []): foldr (f:=f) (init:=init) (l)
    = f (l.head (by omega)) (foldr (f:=f) (init:=init) (l.tail))

@[simp]
theorem bool_accepts_iff : (bool j).accepts x ‚Üî x j * (x j - 1) = 0

lemma and_one_eq_of_eq {a b : ‚Ñï} : a = b ‚Üí a &&& 1 = b &&& 1

lemma schwartz_zippel_of_fintype {p : MvPolynomial œÉ R} (hp : p ‚â† 0) (S : œÉ ‚Üí Finset R) :
    #{x ‚àà S ^^ œÉ | eval x p = 0} / ‚àè i, (#(S i) : ‚Ñö‚â•0) ‚â§ ‚àë i, (p.degreeOf i / #(S i) : ‚Ñö‚â•0)

@[simp]
theorem monomialBasis_zero {w : Vector R 0} : monomialBasis w = #v[1]

lemma folding
  [Nonempty Œπ] {S : Finset Œπ} [Fintype Œπ]
  (œÜ : Œπ ‚Ü™ F) (f : Œπ ‚Üí F) (k : ‚Ñï)
  [Nonempty (indexPow S œÜ k)]
  {degree : ‚Ñï} (Œ¥ : ‚Ñö) (hŒ¥Pos : Œ¥ > 0)
  (hŒ¥Lt : Œ¥ < foldingDistRange degree œÜ f) :
  let C : Set ((indexPow S œÜ k) ‚Üí F) := code (pow S œÜ k) (degree / k)
  Pr_{ let r ‚Üê $·µñ F }[ Œ¥·µ£((fold œÜ f k r), C) ‚â§ Œ¥]
    ‚â§ ENNReal.ofReal (proximityError F (degree / k) (LinearCode.rate (code œÜ degree)) Œ¥ k)

lemma degree_s_smul_X_add_1 {F : Type*} [Field F] [Fintype F] (s : F) [NeZero s] :
  (C s * (X : (F)[X]) + 1).degree = 1

omit [Fintype L] [DecidableEq L] in
theorem Polynomial.comp_same_inner_eq_if_same_outer (f g : L[X]) (h_f_eq_g : f = g) :
  ‚àÄ x, f.comp x = g.comp x

Nat.add_left_cancel in Init.Data.Nat.Basic

theorem singleEqPolynomial_zeroOne (r : Fin 2) (x : MvPolynomial œÉ R) :
    singleEqPolynomial (r : R) x = if r = 0 then 1 - x else x

@[simp]
lemma bIdx_mul_œë_add_i_cast_lt_‚Ñì_succ (bIdx : Fin (‚Ñì / œë - 1)) (i : Fin (œë - 1 + 1))
    : ‚ÜëbIdx * œë + i < ‚Ñì + 1

lemma natDegree_lt_of_mem_degreeLT [NeZero deg] (h : p ‚àà degreeLT F deg) : p.natDegree < deg

lemma W·µ¢_vanishing (i : Fin r) :
  ‚àÄ u ‚àà U ùîΩq Œ≤ i, (W ùîΩq Œ≤ i).eval u = 0

@[simp]
lemma bIdx_mul_œë_add_i_fin_‚Ñì_pred_lt_‚Ñì (bIdx : Fin (‚Ñì / œë - 1)) (i : Fin (œë - 1))
    : ‚ÜëbIdx * œë + ‚Üëi < ‚Ñì

lemma extract_start_zero_eq_take {n : ‚Ñï} {Œ± : Fin n ‚Üí Sort*} (stop : ‚Ñï) (h : stop ‚â§ n)
    (v : (i : Fin n) ‚Üí Œ± i) : extract 0 stop (Nat.zero_le _) h v = take stop h v

@[simp]
theorem cast_id :
    Prover.cast rfl rfl = (id : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec‚ÇÅ ‚Üí _)

lemma Q'_div_E'_eq_p
  [NeZero n]
  {E' Q' : Polynomial F}
  {œâs f : Fin n ‚Üí F}
  (hp_deg : p.natDegree < k)
  (he : 2 * e < n - k + 1)
  (hk_n : k ‚â§ n)
  (h_ham : (Œî‚ÇÄ(f, p.eval ‚àò œâs) : ‚Ñï) ‚â§ e)
  (h_diff : Function.Injective œâs)
  (h_Q' : Q' ‚â† 0)
  (hp : p ‚â† 0)
  (h_cond : BerlekampWelchCondition e k œâs f E' Q')
  : E' ‚à£ Q' ‚àß Q' / E' = p

@[simp] theorem toNat_add (a b : AssocNat) : toNat (add a b) = toNat a + toNat b

lemma and_by_split_lowBits {n m n1 m1 bn bm : ‚Ñï} (h_bn : bn < 2) (h_bm : bm < 2)
  (h_n : n = n1 * 2 + bn) (h_m : m = m1 * 2 + bm):
  n &&& m = (n1 &&& m1) * 2 + (bn &&& bm)

private lemma johnson_unrefined_by_M' [Zero F]
  (h_n : 0 < n)
  (h_B : 2 ‚â§ B.card)
  (h_card : 2 ‚â§ (Fintype.card F))
  :
  B.card * (Fintype.card F / (Fintype.card F - 1)) *
           ((1 - e B 0 / n) ^ 2  + e B 0 ^ 2 / ((Fintype.card F - 1) * n^2) - 1 + d B/n)
  ‚â§
  (Fintype.card F / (Fintype.card F - 1)) * d B/n

beq_iff_eq in Init.Core

@[grind _=_]
theorem monomialXY_mul_monomialXY {n m p q : ‚Ñï} {a b : F} :
    monomialXY n m a * monomialXY p q b = monomialXY (n + p) (m + q) (a * b)

theorem append_soundness (V‚ÇÅ : OracleVerifier oSpec Stmt‚ÇÅ OStmt‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : OracleVerifier oSpec Stmt‚ÇÇ OStmt‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ pSpec‚ÇÇ)
    {soundnessError‚ÇÅ soundnessError‚ÇÇ : ‚Ñù‚â•0}
    (h‚ÇÅ : V‚ÇÅ.soundness init impl lang‚ÇÅ lang‚ÇÇ soundnessError‚ÇÅ)
    (h‚ÇÇ : V‚ÇÇ.soundness init impl lang‚ÇÇ lang‚ÇÉ soundnessError‚ÇÇ) :
      (V‚ÇÅ.append V‚ÇÇ).soundness init impl lang‚ÇÅ lang‚ÇÉ (soundnessError‚ÇÅ + soundnessError‚ÇÇ)

private lemma coeffs_of_comp_minus_x_pos_degree {f : Polynomial F} {n : ‚Ñï} (h : 0 < f.degree) :
    (f.comp (-X)).coeff n = if Even n then f.coeff n else -f.coeff n

theorem rightpad_eq_self (v : Fin n ‚Üí Œ±) (a : Œ±) : rightpad n a v = v

@[simp]
lemma List.get_nil (i : Fin 0) (a : Œ±) : [].get i = a

theorem computableAdditiveNTT_eq_additiveNTT (a : Fin (2 ^ ‚Ñì) ‚Üí L) :
  computableAdditiveNTT (ùîΩq := ùîΩq) (Œ≤ := Œ≤) (‚Ñì := ‚Ñì) (R_rate := R_rate)
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (a := a) =
  additiveNTT (ùîΩq := ùîΩq) (L := L) (Œ≤ := Œ≤) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (a := a)

theorem pow_zero {a : CNat 50} : a ^ 0 = 1

lemma Oracle.containsCache_of_cache {Œπ : Type} {spec : OracleSpec Œπ}
    [(i : Œπ) ‚Üí Inhabited (OracleSpec.range spec i)]
    (cache : spec.QueryCache) :
    ‚àÉ (f : spec.FunctionType), Oracle.containsCache f cache

lemma bIdx_succ_mul_œë_le_‚Ñì_succ (bIdx : Fin (‚Ñì / œë - 1)) : (‚ÜëbIdx + 1) * œë ‚â§ ‚Ñì + 1

theorem changeOfBasisMatrix_det_ne_zero
  (‚Ñì : Nat) (h_‚Ñì : ‚Ñì ‚â§ r) :
  (changeOfBasisMatrix ùîΩq Œ≤ ‚Ñì h_‚Ñì).det ‚â† 0

lemma eq_degree_of_equiv [LawfulBEq R] {p q : UniPoly R} : equiv p q ‚Üí p.degree = q.degree

lemma vappend_right_of_not_lt {m n : ‚Ñï} {Œ± : Sort u}
    (u : Fin m ‚Üí Œ±) (v : Fin n ‚Üí Œ±) (i : Fin (m + n)) (h : ¬¨ i.val < m) :
      vappend u v i = v ‚ü®i - m, by omega‚ü©

theorem append_completeness (R‚ÇÅ : OracleReduction oSpec Stmt‚ÇÅ OStmt‚ÇÅ Wit‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ Wit‚ÇÇ pSpec‚ÇÅ)
    (R‚ÇÇ : OracleReduction oSpec Stmt‚ÇÇ OStmt‚ÇÇ Wit‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ Wit‚ÇÉ pSpec‚ÇÇ)
    {completenessError‚ÇÅ completenessError‚ÇÇ : ‚Ñù‚â•0}
    (h‚ÇÅ : R‚ÇÅ.completeness init impl rel‚ÇÅ rel‚ÇÇ completenessError‚ÇÅ)
    (h‚ÇÇ : R‚ÇÇ.completeness init impl rel‚ÇÇ rel‚ÇÉ completenessError‚ÇÇ) :
      (R‚ÇÅ.append R‚ÇÇ).completeness init impl
        rel‚ÇÅ rel‚ÇÉ (completenessError‚ÇÅ + completenessError‚ÇÇ)

@[simp]
theorem reduction_perfectCompleteness (hInit : init.neverFails) :
    (reduction oSpec Statement Witness).perfectCompleteness init impl rel rel

lemma nonDoomedFoldingProp_relay_preserved (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i)
    (challenges : Fin i.succ ‚Üí L)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j)
    :
    nonDoomedFoldingProp ùîΩq Œ≤ i.castSucc (Fin.init challenges) oStmt ‚Üî
    nonDoomedFoldingProp ùîΩq Œ≤ i.succ challenges (mapOStmtOutRelayStep ùîΩq Œ≤ i hNCR oStmt)

@[simp]
theorem init_snoc : init (snoc s y) = s

@[simp]
lemma challengeOracleInterface_append_domain_inr (j : pSpec‚ÇÇ.ChallengeIdx) :
    [(pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).Challenge]‚Çí.domain (.inr j) = Unit

private lemma almost_johnson_choose_2_elimed [Zero F]
  (h_n : 0 < n)
  (h_B : 2 ‚â§ B.card)
  (h_card : 2 ‚â§ Fintype.card F)
  :
  (k B * (k B - 1)  +
    (B.card - k B) * ((B.card - k B)/(Fintype.card F-1) - 1))
  ‚â§
  B.card * (B.card - 1) * (n - d B)/n

theorem rightpad_getElem_eq_getD {a b : List Œ±} {unit : Œ±} {i : Nat}
  (h : i < (a.rightpad b.length unit).length) :
    (a.rightpad b.length unit)[i] = a.getD i unit

Nat.succ_le_succ in Init.Prelude

lemma shift_left_def {s : Finset ‚Ñï} :
    shift_left s = s.filterMap
    (fun n => match n with
      | 0 => .none
      | n + 1 => .some n
      )
    (by aesop)

@[simp] lemma my_neg_mod_two (m : ‚Ñ§) : ( - m) % 2 = if m % 2 = 0 then 0 else 1

@[simp]
lemma append_zero_of_succ_left {u : Fin (m + 1) ‚Üí Œ±} {v : Fin n ‚Üí Œ±} :
    (append u v) 0 = u 0

theorem matchSize_comm (l‚ÇÅ : List Œ±) (l‚ÇÇ : List Œ±) (unit : Œ±) :
    matchSize l‚ÇÅ l‚ÇÇ unit = (matchSize l‚ÇÇ l‚ÇÅ unit).swap

@[simp]
lemma ConcreteBTField_add_eq (k n m) :
      ConcreteBTField (k + n + m) = ConcreteBTField (k + (n + m))

lemma concrete_mul_zero0 (a : ConcreteBTField 0) :
  concrete_mul a (zero (k:=0)) = zero (k:=0)

lemma concentration_bounds {deg : ‚Ñï} {domain : Œπ ‚Ü™ F}
  {U : AffineSubspace F (Œπ ‚Üí F)} [Nonempty U]
  (hdiv_pos : 0 < (divergence U (RScodeSet domain deg) : ‚Ñù‚â•0))
  (hdiv_lt : (divergence U (RScodeSet domain deg) : ‚Ñù‚â•0) < 1 - ReedSolomonCode.sqrtRate deg domain)
  : let Œ¥' := divergence U (RScodeSet domain deg)
    Pr_{let u ‚Üê $·µñ U}[Code.relHammingDistToCode u (RScodeSet domain deg) ‚â† Œ¥']
    ‚â§ errorBound Œ¥' deg domain

lemma add_comm {k : ‚Ñï} (a b : ConcreteBTField k) : a + b = b + a

@[simp]
theorem ConcreteBTField.RingHom_cast_dest_apply (k m n : ‚Ñï) (h_eq : m = n)
  (f : ConcreteBTField k ‚Üí+* ConcreteBTField m) (x : ConcreteBTField k) :
    (cast (ConcreteBTField.RingHom_eq_of_dest_eq (k:=k) (m:=m) (n:=n) h_eq) f) x
    = cast (by apply cast_ConcreteBTField_eq (h_eq:=h_eq)) (f x)

@[simp]
theorem FullData.internal_getRootValue {s_left s_right : Skeleton} {Œ± : Type}
    (value : Œ±) (left : FullData Œ± s_left) (right : FullData Œ± s_right) :
    (FullData.internal value left right).getRootValue =
      value

Nat.pred_lt_self in Init.Data.Nat.Basic

lemma powerBasisSucc_dim (k : ‚Ñï) :
  powerBasisSucc (k:=k).dim = 2

lemma algebraMap_succ_eq_zero_x {k : ‚Ñï} (h_pos : k > 0) (x : ConcreteBTField (k - 1)) :
  letI instAlgebra := ConcreteBTFieldAlgebra (l:=k-1) (r:=k) (h_le:=by omega)
  algebraMap (ConcreteBTField (k - 1)) (ConcreteBTField k) x = „Ää 0, x „Äã

Nat.zero_add in Init.Data.Nat.Basic

theorem BitVec.dcast_bitvec_toNat_eq {w w2 : ‚Ñï} (x : BitVec w) (h_width_eq : w = w2) :
    BitVec.toNat x = BitVec.toNat (dcast (h_width_eq) x)

@[simp]
theorem Basis_cast_dest_apply {Œπ : Type*} (Œ± Œ≤ Œ≥ : ‚Ñï)
    (h_le1 : Œ± ‚â§ Œ≤) (h_le2 : Œ± ‚â§ Œ≥)
    (h_eq : Œ≤ = Œ≥) {k : Œπ} (b : @Basis Œπ (ConcreteBTField Œ±) (ConcreteBTField Œ≤) _ _
    (@ConcreteBTFieldAlgebra (l := Œ±) (r := Œ≤) (h_le := h_le1)).toModule) :
    let castBasis : @Basis Œπ (ConcreteBTField Œ±) (ConcreteBTField Œ≥) _ _
      (@ConcreteBTFieldAlgebra (l := Œ±) (r := Œ≥) (h_le := h_le2)).toModule :=
      cast (by
        exact Basis_cast_dest_eq Œ± Œ≥ Œ≤ h_le2 h_le1 h_eq
      ) b
    (castBasis k) = cast (by
      exact cast_ConcreteBTField_eq Œ≤ Œ≥ h_eq) (b k)

protected lemma errors_are_roots_of_elocPoly {i : ‚Ñï}
  (hi : i < n) (h : f i ‚â† p.eval (œâs i)) : (ElocPoly n œâs f p).eval (œâs i) = 0

lemma addSalt_Challenge (i : pSpec.ChallengeIdx) :
    (pSpec.addSalt Salt).Challenge i = pSpec.Challenge i

theorem zipWith_cons {Œ± Œ≤ Œ≥} {n : ‚Ñï} (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥)
    (a : Œ±) (b : Vector Œ± n) (c : Œ≤) (d : Vector Œ≤ n) :
    zipWith f (cons a b) (cons c d) = cons (f a c) (zipWith f b d)

@[simp]
theorem mul_accepts_iff : (mul a b c).accepts x ‚Üî x c = x a * x b

@[simp]
lemma ofPolynomialAlgHom_toPolynomialAlgHom_X :
    ofPolynomialAlgHom (toPolynomialAlgHom (X : P)) = (Polynomial.X : R[X])

lemma natDegree_lt_of_lbounded_zero_coeff {p : F[X]} [NeZero deg]
  (h : ‚àÄ i, deg ‚â§ i ‚Üí p.coeff i = 0) : p.natDegree < deg

private lemma sum_add_one {i : Fin (k + 1)} :
  ‚àë j' ‚àà finRangeTo (i.1 + 1), (s j').1 = (‚àë j' ‚àà finRangeTo i.1, (s j').1) + (s i).1

theorem eqPolynomial_zeroOne (r : œÉ ‚Üí Fin 2) : (eqPolynomial r : MvPolynomial œÉ R) =
    ‚àè i : œÉ, if r i = 0 then 1 - X i else X i

lemma concrete_mul_right_distrib
  {h_k : k > 0} (prevBTFieldProps : ConcreteBTFieldProps (k := k - 1))
  (a b c : ConcreteBTField k) :
    concrete_mul (a + b) c = concrete_mul a c + concrete_mul b c

@[simp]
theorem rdrop_eq_take (m : ‚Ñï) (h : m ‚â§ n) (v : (i : Fin n) ‚Üí Œ± i) :
    rdrop m h v = take (n - m) (by omega) v

theorem add_size {p q : UniPoly Q} : (add_raw p q).size = max p.size q.size

@[simp]
theorem OracleReduction.id_runWithLog (stmt : StmtIn) (oStmt : ‚àÄ i, OStmtIn i) (wit : WitIn) :
    (OracleReduction.id : OracleReduction oSpec StmtIn OStmtIn WitIn _ _ _ _).runWithLog
      stmt oStmt wit = pure ‚ü®‚ü®default, ‚ü®stmt, oStmt‚ü©, wit‚ü©, ‚ü®stmt, oStmt‚ü©, [], []‚ü©

theorem ofFn_drop_eq_drop_ofFn {Œ± : Type*} {m : ‚Ñï} (h : m ‚â§ n) (v : Fin n ‚Üí Œ±) :
    List.ofFn (drop m h v) = (List.ofFn v).drop m

private lemma johnson_denom [Zero F]
  (h_card : 2 ‚â§ (Fintype.card F))
  :
  (Fintype.card F / (Fintype.card F - 1)) *
  ((1 - e B 0 / n) ^ 2  + (e B 0) ^ 2 / ((Fintype.card F - 1) * n^2) - 1 + d B/n)
  =
  (1 - ((Fintype.card F) / (Fintype.card F - 1)) *
  (e B 0 / n)) ^ 2 - (1 - ((Fintype.card F) / (Fintype.card F - 1)) * (d B/n))

lemma num_eq_highBits_add_lowBits {n: ‚Ñï} (numLowBits: ‚Ñï) :
  n = getHighBits numLowBits n + getLowBits numLowBits n

theorem completeness_relIn_mono {Œµ : ‚Ñù‚â•0} {relIn' : Set (StmtIn √ó WitIn)}
    (hrelIn : relIn' ‚äÜ relIn) :
      completeness init impl relIn relOut reduction Œµ ‚Üí
        completeness init impl relIn' relOut reduction Œµ

private lemma K_eq_sum {Œ± : F} : K B i Œ± = ‚àë (x : B), if x.1 i = Œ± then 1 else 0

@[simp]
theorem OracleSpec.append_range_left {Œπ‚ÇÅ Œπ‚ÇÇ : Type} {spec‚ÇÅ : OracleSpec Œπ‚ÇÅ} {spec‚ÇÇ : OracleSpec Œπ‚ÇÇ}
    (i : Œπ‚ÇÅ) : (spec‚ÇÅ ++‚Çí spec‚ÇÇ).range (Sum.inl i) = spec‚ÇÅ.range i

lemma encode_mem_ReedSolomon_code [DecidableEq F] [NeZero deg]
    {msg : Fin deg ‚Üí F} {domain : Fin m ‚Ü™ F} :
  encode msg domain ‚àà ReedSolomon.code domain deg

@[to_additive (attr := simp) vsum_succ]
lemma vprod_succ [CommMonoid Œ±] {a : Fin (n + 1) ‚Üí Œ±} : vprod a = a 0 * vprod (a ‚àò Fin.succ)

theorem vappend_singleton (u : Fin m ‚Üí Œ±) (a : Œ±) :
    vappend u (vcons a !v[]) = vconcat u a

@[simp] theorem rightpadPowerOfTwo_size (unit : Œ±) (a : Array Œ±) :
    (a.rightpadPowerOfTwo unit).size = 2 ^ (Nat.clog 2 a.size)

theorem two_eq_zero_in_char2_field {F : Type*} [Field F]
  (sumZeroIffEq : ‚àÄ (x y : F), x + y = 0 ‚Üî x = y) : (2 : F) = 0

@[simp]
protected lemma elocPoly_one :
  ElocPoly 1 œâs f p = if f 0 ‚â† p.eval (œâs 0) then X - (C (œâs 0)) else 1

@[simp]
theorem cast_perfectCompleteness (hComplete : R.perfectCompleteness init impl relIn relOut) :
    (R.cast hn hSpec hO‚Çò).perfectCompleteness init impl relIn relOut

lemma towerRingHomForwardMap_one {k : ‚Ñï} :
  (towerRingHomForwardMap k) 1 = 1

lemma sum_insertNth' [AddCommMonoid M] [AddCommMonoid N] {n : ‚Ñï} (œÉ : Fin n ‚Üí‚ÇÄ M) (i : M)
    (p : Fin (n + 1)) (f : Fin (n+1) ‚Üí M ‚Üí N) (h : ‚àÄ x, f x 0 = 0) :
    sum (insertNth p i œÉ) f = f p i + sum œÉ (Fin.removeNth p f)

@[simp]
lemma vappend_last_of_succ_right {u : Fin m ‚Üí Œ±} {v : Fin (n + 1) ‚Üí Œ±} :
    (vappend u v) (last (m + n)) = v (last n)

lemma getBit_of_or {n m k: ‚Ñï} : getBit k (n ||| m) = getBit k n ||

@[simp]
theorem simulateQ_map_fst (oa : OracleComp spec Œ±) :
    Prod.fst <$> (simulateQ loggingOracle oa).run = oa

theorem iteratedQuotientMap_k_eq_1_is_qMap (i : Fin ‚Ñì)
    (h_i_add_1 : i.val + 1 ‚â§ ‚Ñì) (x : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®i, by omega‚ü©) :
    iteratedQuotientMap ùîΩq Œ≤ h_‚Ñì_add_R_rate i 1 h_i_add_1 x =
    ‚ü®(qMap ùîΩq Œ≤ ‚ü®i.val, by omega‚ü©).eval (x.val : L),
      qMap_eval_mem_sDomain_succ ùîΩq Œ≤   h_‚Ñì_add_R_rate i h_i_add_1 x‚ü©

lemma listOfCloseCodewordsRel_eq_zero :
  listOfCloseCodewordsRel C y r = 0 ‚Üî
  IsEmpty (relHammingBall C y r) ‚à® Infinite (relHammingBall C y r)

theorem lagrangeBasis_getElem {w : Vector R n} (i : Fin (2 ^ n)) :
    (lagrangeBasis w)[i] = ‚àè j : Fin n, if (BitVec.ofFin i).getLsb j then w[j] else 1 - w[j]

@[csimp, grind =]
theorem findIdx'_eq_findIdx : @findIdx' = @findIdx

theorem mul_zero (n : ChurchNat Œ±) : mul n zero = zero

@[simp]
lemma seqCompose_def {m : ‚Ñï}
    (Stmt : Fin (m + 1) ‚Üí Type) {Œπ‚Çõ : Fin (m + 1) ‚Üí Type} (OStmt : (i : Fin (m + 1)) ‚Üí Œπ‚Çõ i ‚Üí Type)
    (Wit : Fin (m + 1) ‚Üí Type) {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (P : (i : Fin m) ‚Üí
      OracleProver oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Wit i.castSucc)
        (Stmt i.succ) (OStmt i.succ) (Wit i.succ) (pSpec i)) :
    seqCompose Stmt OStmt Wit P = Prover.seqCompose (fun i => Stmt i √ó (‚àÄ j, OStmt i j)) Wit P

theorem oracleReduction_perfectCompleteness (hInit : init.neverFails) :
    (oracleReduction R deg oSpec).perfectCompleteness init impl
      (inputRelation R deg D) (outputRelation R deg)

theorem induction_append_right {m n : ‚Ñï} {motive : Fin (m + n + 1) ‚Üí Sort*} {zero : motive 0}
  {succ : ‚àÄ i : Fin (m + n), motive i.castSucc ‚Üí motive i.succ} {i : Fin (n + 1)} :
    induction zero succ (i.natAdd m) =
      @induction n (fun i => motive (i.natAdd m))
        (@induction m (fun j => motive (Fin.cast (by omega) (j.castAdd n)))
          zero (fun j x => succ (j.castAdd n) x) (last m))
        (fun i x => succ (i.natAdd m) x) i

@[simp]
lemma coeff_polynomialOfCoeffs_eq_coeffs :
  Fin.liftF' (polynomialOfCoeffs coeffs).coeff = coeffs

@[simp]
lemma lastBlockIdx_mul_œë_add_fin_lt_‚Ñì (i : Fin œë) :
    (‚Ñì / œë - 1) * œë + ‚Üëi < ‚Ñì

theorem BitVec.dcast_id {n : Nat} (bv : BitVec n) :
  DCast.dcast (Eq.refl n) bv = bv

@[simp]
theorem LeafData.leftSubtree_internal {Œ±} {s_left s_right : Skeleton}
    (left : LeafData Œ± s_left) (right : LeafData Œ± s_right) :
    (LeafData.internal left right).leftSubtree = left

lemma add_descends [LawfulBEq R] (a‚ÇÅ b‚ÇÅ a‚ÇÇ b‚ÇÇ : UniPoly R) :
  equiv a‚ÇÅ a‚ÇÇ ‚Üí equiv b‚ÇÅ b‚ÇÇ ‚Üí add_descending a‚ÇÅ b‚ÇÅ = add_descending a‚ÇÇ b‚ÇÇ

@[simp]
lemma not_V_to_P_eq_P_to_V {x : Direction} (h : x ‚â† .P_to_V) : x = .V_to_P

lemma IsBerlekampWelchSolution_def
  : IsBerlekampWelchSolution e k œâs f v
  ‚Üî Matrix.mulVec (BerlekampWelchMatrix e k œâs f) v = (Rhs e œâs f)

@[simp]
theorem BTField.PowerBasis.dim_of_eq_rec
    (r1 r : ‚Ñï)
    (h_r : r = r1 + 1)
    (b : PowerBasis (BTField r1) (BTField (r1 + 1))) :
    letI instAlgebra : Algebra (BTField r1) (BTField r) :=
      binaryAlgebraTower (l:=r1) (r:=r) (h_le:=by omega)
    ((Eq.rec (motive:=fun (x : ‚Ñï) (_ : r1 + 1 = x) => by
      letI instAlgebraCur : Algebra (BTField r1) (BTField x) :=
        binaryAlgebraTower (l:=r1) (r:=x) (h_le:=by omega)
      exact PowerBasis (BTField r1) (BTField x)) (refl:=b) (t:=h_r.symm)) :
        PowerBasis (BTField r1) (BTField r)).dim
    = b.dim

Nat.two_pow_pos in Init.Data.Nat.Basic

theorem folding_listdecoding_if_genMutualCorrAgreement
  {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F} [Smooth œÜ] {k m : ‚Ñï}
  {S' : Finset (indexPowT S œÜ 0)} {œÜ' : (indexPowT S œÜ 0) ‚Ü™ F}
  [‚àÄ i : ‚Ñï, Fintype (indexPowT S œÜ i)] [DecidableEq (indexPowT S œÜ 0)] [Smooth œÜ']
  [h : ‚àÄ {f : (indexPowT S œÜ 0) ‚Üí F}, DecidableBlockDisagreement 0 k f S' œÜ']
  [‚àÄ i : ‚Ñï, Neg (indexPowT S œÜ i)]
  {C : Set ((indexPowT S œÜ 0) ‚Üí F)} (hcode : C = smoothCode œÜ' m) (hLe : k ‚â§ m)
  {Œ¥ : ‚Ñù‚â•0}
  {params : GenMutualCorrParams S œÜ k} :

  -- necessary typeclasses of underlying domain (Œπ·µ¢)^2 ≤ regarding finiteness,
  -- non-emptiness and smoothness
    let _ : ‚àÄ j : Fin (k + 1), Fintype (indexPowT S œÜ j) := params.inst1
    let _ : ‚àÄ j : Fin (k + 1), Nonempty (indexPowT S œÜ j) := params.inst2

    Pr_{let Œ±s ‚Üê$·µñ (Fin k ‚Üí F)}[ -- for every function `f : Œπ ‚Üí F` and
                      ‚àÄ (f : (indexPowT S œÜ 0) ‚Üí F),
                      -- `hŒ¥Le` : `Œ¥ ‚àà (0, max_{j ‚àà [0,k]} BStar(C‚±º, par‚Ñì = 2))`
                       (0 < Œ¥ ‚àß Œ¥ < 1 - Finset.univ.sup
                        (fun j => params.BStar j (params.Gen_Œ± j).C (params.Gen_Œ± j).par‚Ñì)) ‚Üí

                      let listBlock : Set ((indexPowT S œÜ 0) ‚Üí F) := Œõ·µ£(0, k, f, S', C, hcode, Œ¥)
                      let fold := fold_k f Œ±s hLe
                      let foldSet := fold_k_set listBlock Œ±s hLe
                      let kFin : Fin (k + 1) := ‚ü®k, Nat.lt_succ_self k‚ü©
                      let C‚Çñ := (params.Gen_Œ± kFin).C
                      let listHamming := relHammingBall C‚Çñ fold Œ¥

                      foldSet ‚â† listHamming
                    ] < (‚àë i : Fin (k + 1),
                          params.errStar i (params.Gen_Œ± i).C (params.Gen_Œ± i).par‚Ñì Œ¥)

lemma min_dist_le_d [Field F] {B : Finset (Fin n ‚Üí F)} (v : Fin n ‚Üí F)
  :
  sInf { d | ‚àÉ u ‚àà B, ‚àÉ v ‚àà B, u ‚â† v ‚àß hammingDist u v = d } ‚â§ d B

@[simp]
theorem cast_dir_idx {hn} (hSpec : pSpec‚ÇÅ.cast hn = pSpec‚ÇÇ) {i : Fin n‚ÇÅ} :
    pSpec‚ÇÇ.dir (Fin.cast hn i) = pSpec‚ÇÅ.dir i

lemma getBit_of_sub_two_pow_of_bit_1 {n i j: ‚Ñï} (h_getBit_eq_1: getBit i n = 1) :
  getBit j (n - 2^i) = (if j = i then 0 else getBit j n)

theorem not_irreducible_of_isRoot_of_degree_gt_one
  (p : R[X]) (h_root : ‚àÉ r : R, IsRoot p r) (h_deg : p.degree > 1) :
  ¬¨ Irreducible p

@[simp]
theorem vcons_of_one (a : Œ±) {i : Fin 1} : !v[a] i = match i with

theorem rtake_eq_take_rev {Œ± : Sort*} (m : ‚Ñï) (h : m ‚â§ n) (v : Fin n ‚Üí Œ±) :
    rtake m h v = (take m h (v ‚àò Fin.rev)) ‚àò Fin.rev

omit [Finite F] in
lemma D_def : D = evalDomain D 0

theorem vext_iff {v w : Fin n ‚Üí Œ±} : v = w ‚Üî ‚àÄ i, v i = w i

omit hF‚ÇÇ in
theorem kernel_normalizedW_eq_U (i : Fin r) :
    LinearMap.ker (polyEvalLinearMap (normalizedW ùîΩq Œ≤ i)
    (normalizedW_is_additive ùîΩq Œ≤ i))
    = U ùîΩq Œ≤ i

theorem join_add_join {k : ‚Ñï} (h_pos : k > 0) (hi‚ÇÄ lo‚ÇÄ hi‚ÇÅ lo‚ÇÅ : ConcreteBTField (k - 1)) :
  „Ää hi‚ÇÄ, lo‚ÇÄ „Äã + „Ää hi‚ÇÅ, lo‚ÇÅ „Äã = „Ää hi‚ÇÄ + hi‚ÇÅ, lo‚ÇÄ + lo‚ÇÅ „Äã

@[simp]
lemma foldl'_zero {Œ± : Type u} (f : (i : Fin 0) ‚Üí Œ± ‚Üí Œ±) (x : Œ±) :
    foldl' 0 f x = x

lemma bIdx_succ_mul_œë_lt_‚Ñì_succ (bIdx : Fin (‚Ñì / œë - 1)) :
    (‚ÜëbIdx + 1) * œë < ‚Ñì + 1

theorem rightpad_getElem_eq_getD {a : Array Œ±} {n : Nat} {unit : Œ±} {i : Nat}
    (h : i < (a.rightpad n unit).size) : (a.rightpad n unit)[i] = a.getD i unit

omit [CharP L 2] [DecidableEq ùîΩq] hF‚ÇÇ h_Œ≤‚ÇÄ_eq_1 [NeZero ‚Ñì] in
theorem card_qMap_total_fiber (i : Fin ‚Ñì) (steps : ‚Ñï) (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
    (y : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i.val + steps, by omega‚ü©)) :
    Fintype.card (Set.image (qMap_total_fiber ùîΩq Œ≤ (i := ‚ü®i, by omega‚ü©) (steps := steps)
      (h_i_add_steps := by simp only; exact fin_‚Ñì_steps_lt_‚Ñì_add_R i steps h_i_add_steps)
      (y := y)) Set.univ) = 2 ^ steps

lemma towerRingHomForwardMap_Z (k : ‚Ñï) :
  towerRingHomForwardMap k (Z k) = BinaryTower.Z k

@[grind]
lemma coeff_ne_zero {f q : F[X][Y]} (hg : q * f ‚â† 0) : q.coeff ‚â† 0

@[simp]
theorem fflatten‚ÇÇ_one {A : Sort u} {B : Sort v} {F : A ‚Üí B ‚Üí Sort w} {n : Fin 1 ‚Üí ‚Ñï}
    {Œ± : (i : Fin 1) ‚Üí (j : Fin (n i)) ‚Üí A}
    {Œ≤ : (i : Fin 1) ‚Üí (j : Fin (n i)) ‚Üí B}
    {v : (i : Fin 1) ‚Üí (j : Fin (n i)) ‚Üí F (Œ± i j) (Œ≤ i j)} :
    fflatten‚ÇÇ v = v 0

theorem liftContext_knowledgeSoundness [Inhabited InnerStmtOut] [Inhabited InnerWitIn]
    {outerRelIn : Set (OuterStmtIn √ó OuterWitIn)} {outerRelOut : Set (OuterStmtOut √ó OuterWitOut)}
    {innerRelIn : Set (InnerStmtIn √ó InnerWitIn)} {innerRelOut : Set (InnerStmtOut √ó InnerWitOut)}
    {knowledgeError : ‚Ñù‚â•0}
    {stmtLens : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut}
    {witLens : Witness.InvLens OuterStmtIn OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    (V : Verifier oSpec InnerStmtIn InnerStmtOut pSpec)
    [lensKS : Extractor.Lens.IsKnowledgeSound outerRelIn innerRelIn outerRelOut innerRelOut
      (V.compatStatement stmtLens) (fun _ _ => True) ‚ü®stmtLens, witLens‚ü©]
    (h : V.knowledgeSoundness init impl innerRelIn innerRelOut knowledgeError) :
      (V.liftContext stmtLens).knowledgeSoundness init impl outerRelIn outerRelOut
        knowledgeError

theorem append_right_injective (a : Fin m ‚Üí Œ±) : Function.Injective (@Fin.append m n Œ± a)

lemma getMiddleBits_eq_mod {n offset len : ‚Ñï} :
  getMiddleBits offset len n = (n >>> offset) % (2 ^ len)

@[simp]
lemma ofPolynomialAlgHom_toPolynomialAlgHom_C {r : R} :
    ofPolynomialAlgHom (toPolynomialAlgHom (C r : P)) = (Polynomial.C r : R[X])

theorem mul_two_eq_add {a : CNat 50} : a * 2 = a + a

theorem vcons_injective2 : Function.Injective2 (@vcons Œ± n)

theorem cast_injective : Function.Injective (MessageIdx.cast hn hSpec)

Nat.le_add_left in Init.Data.Nat.Basic

lemma and_shl_eq_zero_of_lt_two_pow {a n b : ‚Ñï} (hb : b < 2 ^ n) : (a <<< n) &&& b = 0

@[simp]
theorem fflatten‚ÇÇ_two_eq_append {A : Sort u} {B : Sort v} {F : A ‚Üí B ‚Üí Sort w} {n : Fin 2 ‚Üí ‚Ñï}
    {Œ± : (i : Fin 2) ‚Üí (j : Fin (n i)) ‚Üí A}
    {Œ≤ : (i : Fin 2) ‚Üí (j : Fin (n i)) ‚Üí B}
    {v : (i : Fin 2) ‚Üí (j : Fin (n i)) ‚Üí F (Œ± i j) (Œ≤ i j)} :
    fflatten‚ÇÇ v = fappend‚ÇÇ (F := F) (v 0) (v 1)

Nat.lt_of_le_of_lt in Init.Prelude

@[simp]
theorem leftpad_apply_lt (n : ‚Ñï) (a : Œ±) (v : Fin m ‚Üí Œ±) (i : Fin n)
    (h : i.val < n - m) : leftpad n a v i = a

lemma getBit_of_lowBits {n: ‚Ñï} (numLowBits : ‚Ñï) : ‚àÄ k, getBit k (getLowBits numLowBits n) =
    if k < numLowBits then getBit k n else 0

lemma mca_rsc
  [DecidableEq Œπ]
  (Œ± : F) (œÜ : Œπ ‚Ü™ F) (m : ‚Ñï) [Smooth œÜ]
  (par‚Ñì_type : Type) [Fintype par‚Ñì_type] (exp : par‚Ñì_type ‚Ü™ ‚Ñï) :
  let Gen := RSGenerator.genRSC par‚Ñì_type œÜ m exp
  let : Fintype Gen.par‚Ñì := Gen.h‚Ñì
  hasMutualCorrAgreement
    -- Generator
    Gen
    -- BStar
    ((1 + Gen.rate) / 2)
    -- errStar
    (fun Œ¥ => ENNReal.ofReal
        ((Fintype.card par‚Ñì_type - 1) * (2^m / (Gen.rate * (Fintype.card F)))))

@[simp]
theorem induction_one {motive : Fin 2 ‚Üí Sort*} {zero : motive 0}
    {succ : ‚àÄ i : Fin 1, motive i.castSucc ‚Üí motive i.succ} :
      induction (motive := motive) zero succ (last 1) = succ 0 zero

lemma proximity_gap
  {F : Type} [Field F] [Fintype F] [DecidableEq F]
  {Œπ : Type} [Fintype Œπ] [Nonempty Œπ] {œÜ : Œπ ‚Ü™ F}
  {degree m : ‚Ñï} {Œ¥ : ‚Ñù‚â•0} {f : Fin m ‚Üí Œπ ‚Üí F} {GenFun : F ‚Üí Fin m ‚Üí F}
  (h : ‚àÄ (hŒ¥Le : Œ¥ < 1 - Bstar (LinearCode.rate (code œÜ degree))) {f : Fin m ‚Üí Œπ ‚Üí F},
        Pr_{
          let r ‚Üê $·µñ F}[Œ¥·µ£((fun x => ‚àë j : Fin m, (GenFun r j) * f j x), code œÜ degree) ‚â§ (Œ¥ : ‚Ñù)]
            > ENNReal.ofReal (proximityError F degree (LinearCode.rate (code œÜ degree)) Œ¥ m)) :

        ‚àÉ S : Finset Œπ,
          S.card ‚â• (1 - Œ¥) * (Fintype.card Œπ) ‚àß
        ‚àÉ u : (Œπ ‚Üí F),
          u ‚àà (code œÜ degree) ‚àß ‚àÄ i : Fin m, ‚àÄ x ‚àà S, f i x = u x

lemma weight_Œæ_bound (x‚ÇÄ : F) {D : ‚Ñï} (hD : D ‚â• Bivariate.totalDegree H) :
  weight_Œõ_over_ùí™ (Œæ x‚ÇÄ R H) D ‚â§
    WithBot.some ((Bivariate.natDegreeY R - 1) * (D - Bivariate.natDegreeY H + 1))

lemma towerAlgebraMap_id (k : ‚Ñï) : towerAlgebraMap (h_le:=by omega) = RingHom.id (BTField k)

private lemma Fis_cover_B : B = Finset.univ.biUnion (Fi B i)

theorem join_eq_iff_dcast_extractLsb {k : ‚Ñï} (h_pos : k > 0) (x : ConcreteBTField k)
  (hi_btf lo_btf : ConcreteBTField (k - 1)) :
  x = „Ää hi_btf, lo_btf „Äã ‚Üî
  (hi_btf = dcast (h_sub_middle h_pos) (BitVec.extractLsb (hi := 2 ^ k - 1) (lo := 2 ^ (k - 1)) x) ‚àß
  lo_btf = dcast (h_middle_sub) (BitVec.extractLsb (hi := 2 ^ (k - 1) - 1) (lo := 0) x))

theorem oracleVerifier_rbrKnowledgeSoundness [Fintype R] :
    (oracleVerifier R deg D oSpec).rbrKnowledgeSoundness init impl
    (inputRelation R deg D) (outputRelation R deg) (fun _ => (deg : ‚Ñù‚â•0) / (Fintype.card R))

lemma evenPart_even {f : Polynomial F} :
    EvenPoly (evenPart f)

theorem succ'_ne_zero (n : Nat) : succ' n ‚â† 0

lemma towerAlgebraMap_succ (l r : ‚Ñï) (h_le : l ‚â§ r) :
  towerAlgebraMap (l:=l) (r:=r+1) (h_le:=by omega) =
  (towerAlgebraMap (l:=r) (r:=r+1) (h_le:=by omega)).comp
  (towerAlgebraMap (l:=l) (r:=r) (h_le:=by omega))

@[simp]
theorem finSigmaFinEquiv'_apply {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (k : (i : Fin m) √ó Fin (n i)) :
    (finSigmaFinEquiv' k : ‚Ñï) = ‚àë i : Fin k.1, n (Fin.castLE k.1.isLt.le i) + k.2

@[simp]
lemma eval_solutionToQ {x : F} :
  eval x (solutionToQ e k v) =
  ‚àë i ‚àà Finset.range (e + k), liftF v (e + i) * x ^ i

lemma subLeftFull_of_vandermonde_is_vandermonde (h : m ‚â§ n) :
  Matrix.vandermonde Œ± = Matrix.subLeftFull (nonsquare n Œ±) (Fin.castLE h)

theorem mul_add {a b c : AssocNat} : a * (b + c) = a * b + a * c

@[simp]
theorem cast_id : MessageIdx.cast (Eq.refl n‚ÇÅ) rfl = (id : pSpec‚ÇÅ.MessageIdx ‚Üí _)

@[simp] theorem BitVec.dcast_one {n m : ‚Ñï} (h : n = m) : DCast.dcast h (1#n) = 1#m

@[simp]
theorem vconcat_castSucc (v : Fin n ‚Üí Œ±) (a : Œ±) (i : Fin n) :
    vconcat v a (castSucc i) = v i

lemma towerRingHomForwardMap_add_eq (k : ‚Ñï) (x y : ConcreteBTField k) :
    towerRingHomForwardMap (k:=k) (x + y)
    = towerRingHomForwardMap (k:=k) x + towerRingHomForwardMap (k:=k) y

@[simp]
theorem Set.not_mem_language_iff {Œ± Œ≤} (rel : Set (Œ± √ó Œ≤)) (stmt : Œ±) :
    stmt ‚àâ rel.language ‚Üî ‚àÄ wit, (stmt, wit) ‚àâ rel

@[simp]
lemma oddPart_by_2 :
    2 * (oddPart f) = (f - f.comp (-X)) /‚Çò X

theorem fullOracleVerifier_rbrKnowledgeSoundness :
  (fullOracleVerifier ùîΩq Œ≤ Œ≥_repetitions (œë:=œë)
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).rbrKnowledgeSoundness init impl
    (relIn := roundRelation (mp := BBF_SumcheckMultiplierParam) ùîΩq Œ≤ (œë:=œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) 0)
    (relOut := acceptRejectOracleRel)
    (rbrKnowledgeError := fullRbrKnowledgeError ùîΩq Œ≤ Œ≥_repetitions (œë:=œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))

theorem findIdxRev?_eq_some {cond} {as : Array Œ±} (h : ‚àÉ i, ‚àÉ hi : i < as.size, cond as[i]) :
  ‚àÉ k : Fin as.size, findIdxRev? cond as = some k

lemma geometric_sum_units {F : Type*} [Field F] [DecidableEq F] {r : FÀ£} {a : ‚Ñï} :
  ‚àë j ‚àà range (a + 1), (r ^ j : F) =
    if r = 1 then (a + 1 : F)
    else (1 - r ^ (a + 1)) / (1 - r)

theorem support_coeff_finSuccEquivNth {f : MvPolynomial (Fin (n + 1)) R} {i : ‚Ñï} {m : Fin n ‚Üí‚ÇÄ ‚Ñï} :
    m ‚àà (Polynomial.coeff ((finSuccEquivNth R p) f) i).support ‚Üî m.insertNth p i ‚àà f.support

theorem vconcat_inj (v w : Fin n ‚Üí Œ±) (a b : Œ±) :
    vconcat v a = vconcat w b ‚Üî v = w ‚àß a = b

theorem hammingDist_le_of_decoder_eq_some [NeZero n] {œâs f : Fin n ‚Üí F}
  (h : decoder e k œâs f = some p) : Œî‚ÇÄ(f, p.eval ‚àò œâs) ‚â§ e

@[simp]
theorem finSuccEquivNth_X_above {i : Fin n} (h : p < i.succ) :
    finSuccEquivNth R p (X i.succ) = Polynomial.C (X i)

lemma algebraMap_eq_zero_x {i j : ‚Ñï} (h_le : i < j) (x : BTField i) :
    letI instAlgebra := binaryAlgebraTower (l:=i) (r:=j) (h_le:=by omega)
    letI instAlgebraPred := binaryAlgebraTower (l:=i) (r:=j-1) (h_le:=by omega)
    algebraMap (BTField i) (BTField j) x
      = ‚ãò 0, algebraMap (BTField i) (BTField (j-1)) x ‚ãô

theorem mul_assoc (m n p : ChurchNat Œ±) : mul (mul m n) p = mul m (mul n p)

lemma liftF'_liftF_of_lt {k : Fin m} (h : k < n) :
  liftF' (n := m) (liftF (n := n) f') k = f' ‚ü®k, by omega‚ü©

theorem happend_hconcat {Œ± : Fin m ‚Üí Sort u} {Œ≤ : Fin n ‚Üí Sort u} {Œ≥ : Sort u}
    (u : (i : Fin m) ‚Üí Œ± i) (v : (i : Fin n) ‚Üí Œ≤ i) (c : Œ≥) :
    True

theorem leftpad_toList {a : Array Œ±} {n : Nat} {unit : Œ±} :
    a.leftpad n unit = mk (a.toList.leftpad n unit)

theorem hcons_happend_comm {Œ≤ : Fin m ‚Üí Sort u} {Œ≥ : Fin n ‚Üí Sort u}
    (a : Œ±) (u : (i : Fin m) ‚Üí Œ≤ i) (v : (i : Fin n) ‚Üí Œ≥ i) :
    True

private lemma sum_1_over_n_aux_frac_k_i [Zero F]
  (h_n : 0 < n) : ‚àë i, 1/n * aux_frac B (K B i 0) = aux_frac B (k B)

theorem ScalarField_is_prime : Nat.Prime scalarFieldSize

@[simp] theorem join_cons : (l :: ls).join = l ++ ls.join

@[simp]
theorem append_snd (T‚ÇÅ : FullTranscript pSpec‚ÇÅ) (T‚ÇÇ : FullTranscript pSpec‚ÇÇ) :
    (T‚ÇÅ ++‚Çú T‚ÇÇ).snd = T‚ÇÇ

theorem johnson_bound [Field F]
  (h_condition : JohnsonConditionStrong B v)
  :
  let d := d B
  let q : ‚Ñö := Fintype.card F
  let frac := q / (q - 1)
  B.card ‚â§ (frac * d/n) / JohnsonDenominator B v

omit [Finite F] in
lemma pow_2_pow_i_mem_Di_of_mem_D :
  ‚àÄ {x : FÀ£} (i : ‚Ñï),
    x ‚àà D ‚Üí x ^ (2 ^ i) ‚àà evalDomain D i

@[simp]
theorem FullData.ofFun_get {Œ±} {s} (tree : FullData Œ± s) :
    FullData.ofFun s (fun idx => tree.get idx) = tree

@[simp]
lemma dfoldlM'_zero {Œ± : Fin 1 ‚Üí Type u} (f : (i : Fin 0) ‚Üí Œ± i.castSucc ‚Üí m (Œ± i.succ)) (x : Œ± 0) :
    dfoldlM' 0 Œ± f x = pure x

theorem leftpad_eq_self (v : Fin n ‚Üí Œ±) (a : Œ±) : leftpad n a v = v

@[simp]
lemma getTypes_nil : getTypes [] = []

lemma rank_eq_if_subUpFull_eq (h : n ‚â§ m) :
   (subUpFull U (Fin.castLE h)).rank = n  ‚Üí U.rank = n

lemma out_of_dom_smpl_2
  {Œ¥ l : ‚Ñù‚â•0} {s : ‚Ñï} {f : Œπ ‚Üí F} {degree : ‚Ñï} {œÜ : Œπ ‚Ü™ F}
  (C : Set (Œπ ‚Üí F)) (hC : C = code œÜ degree)
  (h_decodable : listDecodable C Œ¥ l)
  (h_nonempty : Nonempty (domainComplement œÜ)) :
  listDecodingCollisionProbability œÜ f Œ¥ s degree h_nonempty ‚â§
    ((l^2 / 2)) * (degree / (Fintype.card F - Fintype.card Œπ))^s

@[grind =] theorem findIdx'_cons {p : Œ± ‚Üí Bool} {x : Œ±} {xs : List Œ±} :
    findIdx' p (x :: xs) = bif p x then 0 else findIdx' p xs + 1

congrArg in Init.Prelude

omit [Finite F] in
private lemma op_der_eq : Monoid.toMulAction FÀ£ = Units.mulAction'

lemma fieldSize_sub_one_factorization : fieldSize - 1 = 2 ^ twoAdicity * 127

protected lemma roots_of_eloc_poly {x : F}
  (h : (ElocPoly n œâs f p).eval x = 0) :
  ‚àÉ i, i < n ‚àß f i ‚â† p.eval (œâs i)

omit [Fintype L] [DecidableEq L] in
theorem Polynomial.foldl_comp (n : ‚Ñï) (f : Fin n ‚Üí L[X]) : ‚àÄ initInner initOuter: L[X],
    Fin.foldl (n:=n) (fun acc j => (f j).comp acc) (initOuter.comp initInner)
    = (Fin.foldl (n:=n) (fun acc j => (f j).comp acc) (initOuter)).comp initInner

omit [NoZeroDivisors ùîΩ] in
lemma foldNth_degree_le {n : ‚Ñï} {f : ùîΩ[X]} {Œ± : ùîΩ} [inst : NeZero n] :
    (foldNth n f Œ±).natDegree ‚â§ f.natDegree / n

lemma zsmul_neg' {k : ‚Ñï} (n : ‚Ñï) (a : ConcreteBTField k) :
  (if ((Int.negSucc n) : ‚Ñ§) % (2 : ‚Ñ§) = (0 : ‚Ñ§) then zero else a) =
    neg (if (‚Üën.succ : ‚Ñ§) % (2 : ‚Ñ§) = (0 : ‚Ñ§) then zero else a)

@[simp] theorem zero_add {a : AssocNat} : 0 + a = a

@[simp]
lemma zero_mem_relHammingDistRange : 0 ‚àà relHammingDistRange Œπ

omit [Finite F] in
lemma neg_mem_dom_of_mem_dom : ‚àÄ {a : FÀ£} (i : Fin n),
    a ‚àà evalDomain D x i ‚Üí - a ‚àà evalDomain D x i

private lemma natDegree_E
  (h : (Œî‚ÇÄ(f, p.eval ‚àò œâs) : ‚Ñï) ‚â§ e) :
  (E (œâs := œâs) f p e).natDegree = e

lemma matching_set_is_a_sub_of_coeffs_of_close_proximity
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  : matching_set k œâs Œ¥ u‚ÇÄ u‚ÇÅ h_gs ‚äÜ coeffs_of_close_proximity k œâs Œ¥ u‚ÇÄ u‚ÇÅ

theorem vappend_right_eq_snoc (u : Fin m ‚Üí Œ±) (a : Fin 1 ‚Üí Œ±) :
    vappend u a = vconcat u (a 0)

theorem foldCommitOracleVerifier_rbrKnowledgeSoundness
    (i : Fin ‚Ñì) (hCR : isCommitmentRound ‚Ñì œë i) :
    (foldCommitOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hCR).rbrKnowledgeSoundness
      init impl
      (relIn := roundRelation (mp := mp) ùîΩq Œ≤ (œë:=œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) i.castSucc)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë:=œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) i.succ)
      (rbrKnowledgeError := fun _ => foldKnowledgeError ùîΩq Œ≤ (œë:=œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i ‚ü®1, by rfl‚ü©
      )

Nat.add_sub_cancel in Init.Data.Nat.Basic

@[simp]
theorem vcons_one (a : Œ±) (v : Fin (n + 1) ‚Üí Œ±) : (a ::·µõ v) 1 = v 0

@[simp] theorem add_zero {a : AssocNat} : a + 0 = a

theorem multilinearBasis_apply (r : ‚Ñï) : ‚àÄ l : ‚Ñï, (h_le : l ‚â§ r) ‚Üí ‚àÄ (j : Fin (2  ^ (r - l))),
  multilinearBasis (l:=l) (r:=r) (h_le:=h_le) j =
    (Finset.univ : Finset (Fin (r - l))).prod (fun i =>
      (binaryAlgebraTower (l:=l + i + 1) (r:=r) (h_le:=by omega)).algebraMap (
        (ùïè (l + i)) ^ (Nat.getBit i j)))

theorem degrees_eval [DecidableEq œÉ] {œÑ : Type*} {f : œÑ ‚Üí R} {p : R[X œÉ][X œÑ]} :
    (eval (C ‚àò f) p).degrees ‚â§ p.support.sup (fun c => (coeff c p).degrees)

@[simp]
theorem dconcat_castSucc {motive : Fin (n + 1) ‚Üí Sort u} (v : (i : Fin n) ‚Üí motive (castSucc i))
    (a : motive (last n)) (i : Fin n) : (v :+·µà‚ü®motive‚ü© a) (castSucc i) = v i

@[simp]
theorem oracleVerifier_rbrKnowledgeSoundness (hRel : ‚àÄ stmtIn oStmtIn witOut,
      ((mapStmt stmtIn, mapOStmt embedIdx hEq oStmtIn), witOut) ‚àà relOut ‚Üí
      ((stmtIn, oStmtIn), mapWitInv (stmtIn, oStmtIn) witOut) ‚àà relIn) :
    (oracleVerifier oSpec mapStmt embedIdx hEq).rbrKnowledgeSoundness init impl relIn relOut 0

@[simp]
theorem simulateQ'_query (q : OracleQuery spec Œ±) :
    simulateQ' so q (by simp) = so.impl q

lemma degree_X‚±º (‚Ñì : ‚Ñï) (h_‚Ñì : ‚Ñì ‚â§ r) (j : Fin (2 ^ ‚Ñì)) :
  (X‚±º ùîΩq Œ≤ ‚Ñì h_‚Ñì j).degree = j

theorem distEq_trans (mx my mz : OracleComp spec Œ±)
    (hxy : distEq mx my) (hyz : distEq my mz) : distEq mx mz

@[simp]
theorem addCases'_right {m n : ‚Ñï} {Œ± : Fin m ‚Üí Sort u} {Œ≤ : Fin n ‚Üí Sort u}
    (left : (i : Fin m) ‚Üí Œ± i) (right : (j : Fin n) ‚Üí Œ≤ j) (i : Fin n) :
      addCases' left right (Fin.natAdd m i) = (Fin.append_right Œ± Œ≤ i) ‚ñ∏ (right i)

theorem generator_on_curve : let (x, y) := generator
  y^2 = x^3 + 3

@[simp]
theorem Fin.cast_val_eq_val {n m : ‚Ñï} [NeZero n] (a : Fin n) (h_eq : n = m):
  (Fin.cast (h_eq) a).val = a.val

@[simp]
theorem embedSum_zero {n : Fin 0 ‚Üí ‚Ñï} {i : Fin 0} (j : Fin (n i)) : embedSum i j = i

theorem buildMerkleTree_neverFails (Œ± : Type) [DecidableEq Œ±] [SelectableType Œ±] {n : ‚Ñï}
    (leaves : List.Vector Œ± (2 ^ n)) (preexisting_cache : (spec Œ±).QueryCache) :
    ((simulateQ randomOracle (buildMerkleTree Œ± n leaves)).run preexisting_cache).neverFails

theorem dcast_symm (ha : a = a') (hb : dcast ha b = b') : dcast (ha.symm) b' = b

lemma getBit_of_two_pow_sub_one {i k: ‚Ñï} : getBit k (2^i - 1) =
    if k < i then 1 else 0

theorem prime_17 : Nat.Prime 17

theorem degreeOf_coeff_finSuccEquivNth (f : MvPolynomial (Fin (n + 1)) R) (j : Fin n) (i : ‚Ñï) :
    degreeOf j (Polynomial.coeff (finSuccEquivNth R p f) i) ‚â§ degreeOf (p.succAbove j) f

@[simp] lemma drop_dir : pSpec‚ü¶m:‚üß.dir = pSpec.dir‚ü¶m:‚üß

@[simp]
theorem cast_id : ChallengeIdx.cast (Eq.refl n‚ÇÅ) rfl = (id : pSpec‚ÇÅ.ChallengeIdx ‚Üí _)

@[coe]
theorem BTField_succ_eq_adjoinRoot (k : ‚Ñï) : AdjoinRoot (poly k) = BTField (k+1)

theorem add_assoc (a b c : AssocNat) : (a + b) + c = a + (b + c)

theorem insertNth_support :
    (insertNth p y s).support ‚äÜ insert p (s.support.map (Fin.succAboveEmb p))

@[simp]
theorem vcons_succ (a : Œ±) (v : Fin n ‚Üí Œ±) (i : Fin n) : (a ::·µõ v) i.succ = v i

lemma minDist_eq_minDist [DecidableEq F] {IC : LawfulInterleavedCode Œ∫ Œπ F} :
  Code.minDist (IC.1.LC : Set (Œπ ‚Üí F)) = minDist IC.1.MF

lemma powerBasisSucc_gen (k : ‚Ñï) :
  (powerBasisSucc k).gen = (Z (k + 1))

@[simp]
theorem oracleReduction_perfectCompleteness (hInit : init.neverFails) :
    (oracleReduction oSpec Statement OStatement Witness).perfectCompleteness init impl rel rel

omit [Fintype ùîΩq] h_Fq_char_prime hŒ≤_lin_indep in
lemma eval_W_eq_zero_iff_in_U (i : Fin r) (a : L) :
  (W ùîΩq Œ≤ i).eval a = 0 ‚Üî a ‚àà U ùîΩq Œ≤ i

@[simp]
theorem hconcat_last {Œ± : Fin n ‚Üí Sort u} {Œ≤ : Sort u} (v : (i : Fin n) ‚Üí Œ± i) (b : Œ≤) :
    hconcat v b (last n) = cast (vconcat_last Œ± Œ≤).symm b

@[simp]
theorem erase_even_mem
  {s : Finset ‚Ñï}
  {n : ‚Ñï}
  : n ‚àà (erase_even s) ‚Üî Odd n ‚àß n ‚àà s

theorem dist'_eq_dist : ‚ÄñC‚Äñ‚ÇÄ'.toNat = ‚ÄñC‚Äñ‚ÇÄ

@[grind _=_]
lemma degreeY_as_weighted_deg (hf : f ‚â† 0) :
  natDegreeY f = natWeightedDegree f 0 1

theorem completeness [SelectableType Œ±] {n : ‚Ñï}
    (leaves : List.Vector Œ± (2 ^ n)) (i : Fin (2 ^ n)) (hash : Œ± √ó Œ± -> Œ±)
    (preexisting_cache : (spec Œ±).QueryCache) :
    (((do
      let cache ‚Üê buildMerkleTree Œ± n leaves
      let proof := generateProof Œ± i cache
      let verif ‚Üê verifyProof Œ± i leaves[i] (getRoot Œ± cache) proof).simulateQ
      (randomOracle)).run preexisting_cache).neverFails

theorem seqCompose_rbrSoundness
    (lang : (i : Fin (m + 1)) ‚Üí Set (Stmt i √ó ‚àÄ j, OStmt i j))
    (V : (i : Fin m) ‚Üí
      OracleVerifier oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Stmt i.succ) (OStmt i.succ)
        (pSpec i))
    (rbrSoundnessError : ‚àÄ i, (pSpec i).ChallengeIdx ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (V i).rbrSoundness init impl (lang i.castSucc) (lang i.succ) (rbrSoundnessError i)) :
      (OracleVerifier.seqCompose Stmt OStmt V).rbrSoundness
        init impl (lang 0) (lang (Fin.last m))
        (fun combinedIdx =>
          letI ij := seqComposeChallengeIdxToSigma combinedIdx
          rbrSoundnessError ij.1 ij.2)

theorem canonical_nonempty_iff [LawfulBEq R] {p : UniPoly R} (hp : p.size > 0) :
  p.trim = p ‚Üî p.last_nonzero = some ‚ü® p.size - 1, Nat.pred_lt_self hp ‚ü©

protected lemma elocPoly_congr {œâs' f' : ‚Ñï ‚Üí F}
  (h‚ÇÅ : ‚àÄ {m}, m < n ‚Üí œâs m = œâs' m) (h‚ÇÇ : ‚àÄ {m}, m < n ‚Üí f m = f' m) :
  ElocPoly n œâs f = ElocPoly n œâs' f'

theorem liftContext_runToRound
    {lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    {outerStmtIn : OuterStmtIn} {outerWitIn : OuterWitIn} {i : Fin (n + 1)}
    (P : Prover oSpec InnerStmtIn InnerWitIn InnerStmtOut InnerWitOut pSpec) :
      (P.liftContext lens).runToRound i outerStmtIn outerWitIn
      = do
        let ‚ü®transcript, prvState‚ü© ‚Üê
          (P.runToRound i).uncurry (lens.proj (outerStmtIn, outerWitIn))
        return ‚ü®transcript, ‚ü®prvState, outerStmtIn, outerWitIn‚ü©‚ü©

theorem dcast‚ÇÉ_dcast‚ÇÇ : dcast‚ÇÉ rfl rfl rfl d = dcast‚ÇÇ dcast_eq.symm dcast‚ÇÇ_dcast.symm d

@[simp]
theorem choose_2_convex : ConvexOn ‚Ñö Set.univ choose_2

@[simp]
lemma liftComp_support {Œπ' : Type w} {superSpec : OracleSpec Œπ'}
    [h : MonadLift (OracleQuery spec) (OracleQuery superSpec)]
    (oa : OracleComp spec Œ±) : (liftComp oa superSpec).support = oa.support

theorem last_nonzero_some [LawfulBEq R] {p : UniPoly R} {i} (hi : i < p.size) (h : p[i] ‚â† 0) :
  ‚àÉ k, p.last_nonzero = some k

@[simp]
theorem insertNth_removeNth : insertNth p y (removeNth p t) = update t p y

@[simp]
theorem dcast‚ÇÇ_eq' (h : a = a) (h' : dcast h b = b) : dcast‚ÇÇ h h' c = c

lemma combine_eq_cases {F Œπ : Type*} [Field F] [DecidableEq F]
  (œÜ : Œπ ‚Ü™ F) (dstar : ‚Ñï) (r : F) (fs : Fin m ‚Üí Œπ ‚Üí F) (degs : Fin m ‚Üí ‚Ñï)
    (hdegs : ‚àÄ i, degs i ‚â§ dstar) (œÜ_neq_0 : ‚àÄ i, œÜ i ‚â† 0) :
  combine œÜ dstar r fs degs =
    fun x =>
      let q := œÜ x * r
      if q ‚â† 1
      then ‚àë i, (ri dstar degs r i) * (fs i x) * (1 - q^(dstar - degs i + 1)) / (1 - q)
      else ‚àë i, (ri dstar degs r i) * (fs i x) *  (dstar - degs i + 1)

omit [DecidableEq ùîΩq] hF‚ÇÇ h_Œ≤‚ÇÄ_eq_1 in
lemma eval_point_œâ_eq_next_twiddleFactor_comp_qmap

  (i : Fin ‚Ñì) (x : Fin (2 ^ (‚Ñì + R_rate - (i + 1)))) :
  -- `j = u||b||v` => x here means u at level i
  evaluationPointœâ ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i.val+1, by omega‚ü© x =
  eval (twiddleFactor ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i, by omega‚ü© ‚ü®x.val, by
    calc x.val < 2 ^ (‚Ñì + R_rate - (i.val + 1)) := by omega
      _ = 2 ^ (‚Ñì + R_rate - i.val - 1) := by rfl
  ‚ü©) (qMap ùîΩq Œ≤ ‚ü®i, by omega‚ü©)

@[simp]
private lemma leadingCoeff_E : (E œâs f p e).leadingCoeff = 1

lemma add_shiftRight_distrib {n m k : ‚Ñï} (h_and_zero : n &&& m = 0):
  (n + m) >>> k = (n >>> k) + (m >>> k)

nonpos_iff_eq_zero in Mathlib.Algebra.Order.Monoid.Canonical.Defs

theorem append_rbrSoundness (V‚ÇÅ : OracleVerifier oSpec Stmt‚ÇÅ OStmt‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : OracleVerifier oSpec Stmt‚ÇÇ OStmt‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ pSpec‚ÇÇ)
    {rbrSoundnessError‚ÇÅ : pSpec‚ÇÅ.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    {rbrSoundnessError‚ÇÇ : pSpec‚ÇÇ.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    (h‚ÇÅ : V‚ÇÅ.rbrSoundness init impl lang‚ÇÅ lang‚ÇÇ rbrSoundnessError‚ÇÅ)
    (h‚ÇÇ : V‚ÇÇ.rbrSoundness init impl lang‚ÇÇ lang‚ÇÉ rbrSoundnessError‚ÇÇ) :
      (V‚ÇÅ.append V‚ÇÇ).rbrSoundness init impl lang‚ÇÅ lang‚ÇÉ
        (Sum.elim rbrSoundnessError‚ÇÅ rbrSoundnessError‚ÇÇ ‚àò ChallengeIdx.sumEquiv.symm)

lemma binaryTowerAlgebra_def (l r : ‚Ñï) (h_le : l ‚â§ r) :
    @binaryAlgebraTower (l:=l) (r:=r) (h_le:=h_le)
    = (towerAlgebraMap l r h_le).toAlgebra

theorem sub_add_eq_sub_sub_rev (a b c : Nat) (h1 : c ‚â§ b) (h2 : b ‚â§ a) :
  a - b + c = a - (b - c)

@[simp]
theorem OracleVerifier.id_knowledgeSoundness {rel : Set ((StmtIn √ó ‚àÄ i, OStmtIn i) √ó WitIn)} :
    (OracleVerifier.id : OracleVerifier oSpec _ _ _ _ _).knowledgeSoundness
      init impl rel rel 0

lemma cast_ConcreteBTField_eq (k m : ‚Ñï) (h_eq : k = m) :
  ConcreteBTField k = ConcreteBTField m

theorem mul_one {a : CNat 50} : a * 1 = a

@[simp]
lemma coeff_truncate : (truncate p n).coeff k = if k < n then p.coeff k else 0

lemma and_two_pow_eq_two_pow_of_getBit_1 {n i : ‚Ñï} (h_getBit: getBit i n = 1) :
    n &&& (2 ^ i) = 2 ^ i

theorem snoc_support :
    (s.snoc y).support ‚äÜ insert (Fin.last n) (s.support.map Fin.castSuccEmb)

theorem append_perfectCompleteness
    (R‚ÇÅ : OracleReduction oSpec Stmt‚ÇÅ OStmt‚ÇÅ Wit‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ Wit‚ÇÇ pSpec‚ÇÅ)
    (R‚ÇÇ : OracleReduction oSpec Stmt‚ÇÇ OStmt‚ÇÇ Wit‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ Wit‚ÇÉ pSpec‚ÇÇ)
    (h‚ÇÅ : R‚ÇÅ.perfectCompleteness init impl rel‚ÇÅ rel‚ÇÇ)
    (h‚ÇÇ : R‚ÇÇ.perfectCompleteness init impl rel‚ÇÇ rel‚ÇÉ) :
      (R‚ÇÅ.append R‚ÇÇ).perfectCompleteness init impl rel‚ÇÅ rel‚ÇÉ

Nat.le_trans in Init.Prelude

@[simp, grind _=_]
theorem smul_monomialXY {n m : ‚Ñï} {a : F} {S} [SMulZeroClass S F] {b : S} :
  monomialXY n m (b ‚Ä¢ a) = b ‚Ä¢ monomialXY n m a

private lemma sum_choose_K' [Zero F]
  (h_card : 2 ‚â§ (Fintype.card F))
  :
  (Fintype.card (Œ± := F) - 1) * choose_2 ((B.card - K B i 0) / (Fintype.card (Œ± := F) - 1)) ‚â§
  ‚àë (Œ± : F) with Œ± ‚â† 0, choose_2 (K B i Œ±)

@[simp]
theorem take_append_left' : (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ)‚ü¶:m‚üß = pSpec‚ÇÅ

theorem fappend‚ÇÇ_ext {Œ±‚ÇÅ : Fin m ‚Üí A} {Œ±‚ÇÇ : Fin m ‚Üí B} {Œ≤‚ÇÅ : Fin n ‚Üí A} {Œ≤‚ÇÇ : Fin n ‚Üí B}
    (u‚ÇÅ u‚ÇÇ : (i : Fin m) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i)) (v‚ÇÅ v‚ÇÇ : (i : Fin n) ‚Üí F‚ÇÇ (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) :
    fappend‚ÇÇ (F := F‚ÇÇ) u‚ÇÅ v‚ÇÅ = fappend‚ÇÇ (F := F‚ÇÇ) u‚ÇÇ v‚ÇÇ ‚Üî u‚ÇÅ = u‚ÇÇ ‚àß v‚ÇÅ = v‚ÇÇ

theorem finalSumcheckOracleReduction_perfectCompleteness {œÉ : Type}
  (init : ProbComp œÉ)
  (impl : QueryImpl []‚Çí (StateT œÉ ProbComp))
  (hInit : init.neverFails) :
  OracleReduction.perfectCompleteness
    (pSpec := pSpecFinalSumcheckStep (L := L))
    (relIn := roundRelation ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (ùìë := ùìë) (mp := BBF_SumcheckMultiplierParam) (Fin.last ‚Ñì))
    (relOut := finalSumcheckRelOut ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (oracleReduction := finalSumcheckOracleReduction ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)) (init := init) (impl := impl)

theorem matchSize_eq_iff_forall_eq (l‚ÇÅ l‚ÇÇ : List Œ±) (unit : Œ±) :
    (fun (x, y) => x = y) (matchSize l‚ÇÅ l‚ÇÇ unit) ‚Üî ‚àÄ i : Nat, l‚ÇÅ.getD i unit = l‚ÇÇ.getD i unit

lemma comm_map_smul_add (s : Right) (x y : Right ‚äó[K] Left)
    (hx : e (s ‚Ä¢ x) = s ‚Ä¢ (e x)) (hy : e (s ‚Ä¢ y) = s ‚Ä¢ (e y)) :
    e (s ‚Ä¢ x) + e (s ‚Ä¢ y) = s ‚Ä¢ e x + s ‚Ä¢ e y

Fin.eta in Init.Data.Fin.Lemmas

lemma zero_add {k : ‚Ñï} (a : ConcreteBTField k) : 0 + a = a

theorem randomOracle_cache_neverFails_iff_runWithOracle_neverFails {Œ≤}
    [DecidableEq Œπ] [spec.DecidableEq] [(i : Œπ) ‚Üí SelectableType (OracleSpec.range spec i)]
    (oa : OracleComp (spec) Œ≤) (preexisting_cache : spec.QueryCache)
    :
    ((oa.simulateQ randomOracle).run preexisting_cache).neverFails
    ‚Üî
    (‚àÄ (f : spec.FunctionType),
      Oracle.containsCache f preexisting_cache ‚Üí
      (runWithOracle f oa).isSome)

omit [CharP L 2] [DecidableEq ùîΩq] h_Œ≤‚ÇÄ_eq_1 [NeZero ùì°] in
lemma firstOracleWitnessConsistencyProp_relay_preserved (i : Fin ‚Ñì)
    (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) (wit : Witness (L := L) ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j) :
    firstOracleWitnessConsistencyProp ùîΩq Œ≤ wit.t (getFirstOracle ùîΩq Œ≤ oStmt) =
    firstOracleWitnessConsistencyProp ùîΩq Œ≤ wit.t
      (getFirstOracle ùîΩq Œ≤ (mapOStmtOutRelayStep ùîΩq Œ≤ i hNCR oStmt))

@[simp]
theorem Iio_zero : Iio (0 : Fin (n + 1)) = ‚àÖ

theorem BitVec.eq_mp_eq_dcast {w w2 : ‚Ñï} (x : BitVec w) (h_width_eq : w = w2)
  (h_bitvec_eq : BitVec w = BitVec w2 := by rw [h_width_eq]) :
  Eq.mp (h:=h_bitvec_eq) (a:=x) = dcast (h_width_eq) (x)

theorem rightpad_eq_rightpad_max (l : List Œ±) (n : Nat) :
    rightpad n unit l = rightpad (max n l.length) unit l

theorem seqCompose_knowledgeSoundness
    (rel : (i : Fin (m + 1)) ‚Üí Set (Stmt i √ó Wit i))
    (V : (i : Fin m) ‚Üí Verifier oSpec (Stmt i.castSucc) (Stmt i.succ) (pSpec i))
    (knowledgeError : Fin m ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (V i).knowledgeSoundness init impl (rel i.castSucc) (rel i.succ) (knowledgeError i)) :
      (Verifier.seqCompose Stmt V).knowledgeSoundness init impl (rel 0) (rel (Fin.last m))
        (‚àë i, knowledgeError i)

@[simp] theorem rightpad_eq_self (l : List Œ±) (n : Nat) (h : n ‚â§ l.length) :
    rightpad n unit l = l

theorem happend_right_eq_hconcat {Œ± : Fin m ‚Üí Sort u} {Œ≤ : Fin 1 ‚Üí Sort u}
    (u : (i : Fin m) ‚Üí Œ± i) (a : (i : Fin 1) ‚Üí Œ≤ i) :
    happend u a = hconcat u (a 0)

lemma getBit_of_lt_two_pow {n: ‚Ñï} (a: Fin (2^n)) (k: ‚Ñï) :
  getBit k a = if k < n then getBit k a else 0

Fin.val_injective in Mathlib.Data.Fin.Basic

theorem singleEqPolynomial_nf (r : R) (x : MvPolynomial œÉ R) :
    singleEqPolynomial r x = (2 * C r - 1) * x + (1 - C r)

@[simp]
lemma liftF'_liftF : Function.LeftInverse liftF' (liftF (Œ± := Œ±) (n := n))

@[simp]
theorem dflatten_embedSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {motive : (k : Fin (vsum n)) ‚Üí Sort*}
    (v : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí motive (embedSum i j)) (i : Fin m) (j : Fin (n i)) :
    dflatten (motive := motive) v (embedSum i j) = v i j

@[simp]
theorem fflatten‚ÇÇ_zero {A : Sort u} {B : Sort v} {F : A ‚Üí B ‚Üí Sort w} {n : Fin 0 ‚Üí ‚Ñï}
    {Œ± : (i : Fin 0) ‚Üí (j : Fin (n i)) ‚Üí A}
    {Œ≤ : (i : Fin 0) ‚Üí (j : Fin (n i)) ‚Üí B}
    {v : (i : Fin 0) ‚Üí (j : Fin (n i)) ‚Üí F (Œ± i j) (Œ≤ i j)} : fflatten‚ÇÇ v = !h[]

omit [Fintype L] [Fintype ùîΩq] h_Fq_char_prime in
lemma finrank_U (i : Fin r) :
  Module.finrank ùîΩq (U ùîΩq Œ≤ i) = i

lemma toPoly_trim [LawfulBEq R] {p : UniPoly R} : p.trim.toPoly = p.toPoly

theorem degreeOf_X_of_ne (i j : œÉ) (h : i ‚â† j) : degreeOf i (X (R := R) j) = 0

theorem SkeletonNodeIndex.rightChild_bind_parent {s : Skeleton}
    (idx : SkeletonNodeIndex s) :
    idx.rightChild >>= parent = idx.rightChild.map (fun _ => idx)

lemma odd_index_intermediate_novel_basis_decomposition
    (i : Fin ‚Ñì) (j : Fin (2 ^ (‚Ñì - i - 1))) :
    intermediateNovelBasisX ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i, by omega‚ü© ‚ü®j * 2 + 1, by
      apply mul_two_add_bit_lt_two_pow j (‚Ñì-i-1) (‚Ñì-i) ‚ü®1, by omega‚ü© (by omega) (by omega)
    ‚ü©  = X * (intermediateNovelBasisX ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i+1, by omega‚ü© ‚ü®j, by
      apply lt_two_pow_of_lt_two_pow_exp_le j (‚Ñì-i-1) (‚Ñì-(i+1)) (by omega) (by omega)
    ‚ü©).comp (qMap ùîΩq Œ≤ ‚ü®i, by omega‚ü©)

theorem basisVectors_linear_independent (‚Ñì : Nat) (h_‚Ñì : ‚Ñì ‚â§ r) :
    LinearIndependent L (basisVectors ùîΩq Œ≤ ‚Ñì h_‚Ñì)

theorem findSum_of_le_sum {l : List ‚Ñï} {j : ‚Ñï} (h : j < l.sum) : ‚àÉ n, findSum l j = some n

theorem hconcat_inj {Œ± : Fin n ‚Üí Sort u} {Œ≤ : Sort u} (v‚ÇÅ v‚ÇÇ : (i : Fin n) ‚Üí Œ± i) (a‚ÇÅ a‚ÇÇ : Œ≤) :
    hconcat v‚ÇÅ a‚ÇÅ = hconcat v‚ÇÇ a‚ÇÇ ‚Üî v‚ÇÅ = v‚ÇÇ ‚àß a‚ÇÅ = a‚ÇÇ

theorem concreteTowerAlgebraMap_succ_last (r : ‚Ñï) : ‚àÄ l : ‚Ñï, (h_le : l ‚â§ r) ‚Üí
  concreteTowerAlgebraMap (l:=l) (r:=r + 1) (h_le:=by
    exact Nat.le_trans (n:=l) (m:=r) (k:=r + 1) (h_le) (by omega)) =
  (concreteTowerAlgebraMap (l:=l + 1) (r:=r + 1) (by omega)).comp (concreteTowerAlgebraMap
    (l:=l) (r:=l + 1) (by omega))

theorem singleEqPolynomial_zeroOne_C (r : Fin 2) (x : Fin 2) :
    (singleEqPolynomial (r : R) (C x) : MvPolynomial œÉ R) = if x = r then 1 else 0

lemma sum_insertNth [AddCommMonoid M] {n : ‚Ñï} (œÉ : Fin n ‚Üí‚ÇÄ M) (i : M) (p : Fin (n + 1)) :
    (insertNth p i œÉ).sum (fun _ e ‚Ü¶ e) = i + œÉ.sum (fun _ e ‚Ü¶ e)

Nat.lt_trans in Init.Prelude

@[simp]
theorem PowerBasis.cast_basis_succ_of_eq_rec_apply
    (r1 r : ‚Ñï) (h_r : r = r1 + 1)
    (k : Fin 2) :
    letI instAlgebra : Algebra (ConcreteBTField r1) (ConcreteBTField r) :=
      ConcreteBTFieldAlgebra (l:=r1) (r:=r) (h_le:=by omega)
    letI instAlgebraSucc : Algebra (ConcreteBTField (r1 + 1)) (ConcreteBTField (r)) :=
      ConcreteBTFieldAlgebra (l:=r1 + 1) (r:=r) (h_le:=by omega)
    let b : PowerBasis (ConcreteBTField r1) (ConcreteBTField (r1 + 1))
      := powerBasisSucc (k:=r1)
    let bCast : PowerBasis (ConcreteBTField r1) (ConcreteBTField r) := Eq.rec (motive:=
      fun (x : ‚Ñï) (_ : r1 + 1 = x) => by
        letI instAlgebraCur : Algebra (ConcreteBTField r1) (ConcreteBTField x) :=
          ConcreteBTFieldAlgebra (l:=r1) (r:=x) (h_le:=by omega)
        exact PowerBasis (ConcreteBTField r1) (ConcreteBTField x)) (refl:=b) (t:=h_r.symm)
    have h_pb_dim : b.dim = 2 := by
      exact powerBasisSucc_dim r1

    have h_pb'_dim : bCast.dim = 2 := by
      dsimp [bCast]
      rw [PowerBasis.dim_of_eq_rec (r1:=r1) (r:=r) (h_r:=h_r) (b:=b)]
      exact h_pb_dim

    have h_pb_type_eq : Basis (Fin bCast.dim) (ConcreteBTField r1) (ConcreteBTField r) =
      Basis (Fin 2) (ConcreteBTField r1) (ConcreteBTField r) := by
      congr

   -- The `cast` needs a proof that `bCast.dim = 2`. We construct it here.
    let left : Basis (Fin 2) (ConcreteBTField r1) (ConcreteBTField r)
      := cast (by exact h_pb_type_eq) bCast.basis
    let right := (algebraMap (ConcreteBTField (r1 + 1)) (ConcreteBTField r))
      (b.basis (Fin.cast h_pb_dim.symm k))
    left k = right

@[simp]
theorem shift_left_mem {s : Finset ‚Ñï} {d : ‚Ñï} : d ‚àà shift_left s ‚Üî (d + 1) ‚àà s

lemma extract_stop_last_eq_drop {n : ‚Ñï} {Œ± : Fin n ‚Üí Sort*} (start : ‚Ñï) (h : start ‚â§ n)
    (v : (i : Fin n) ‚Üí Œ± i) : extract start n h (Nat.le_refl _) v = drop start h v

@[simp, grind] lemma N_pos : 0 < sz.N

@[simp]
lemma lt_add_of_pos_right_of_le (a b c : ‚Ñï) [NeZero c] (h : a ‚â§ b) : a < b + c

@[simp]
theorem FullData.toLeafData_leaf {Œ±} (a : Œ±) :
    (FullData.leaf a).toLeafData = LeafData.leaf a

theorem liftContext_soundness
    {soundnessError : ‚Ñù‚â•0}
    {lens : OracleStatement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                                OuterOStmtIn OuterOStmtOut InnerOStmtIn InnerOStmtOut}
    (V : OracleVerifier oSpec InnerStmtIn InnerOStmtIn InnerStmtOut InnerOStmtOut pSpec)
    [lensSound : lens.IsSound outerLangIn outerLangOut innerLangIn innerLangOut
      (V.toVerifier.compatStatement lens)]
    (h : V.soundness init impl innerLangIn innerLangOut soundnessError) :
      (V.liftContext lens).soundness init impl outerLangIn outerLangOut soundnessError

theorem verifier_rbrKnowledgeSoundness [Fintype R] :
    (verifier R n deg D oSpec i).rbrKnowledgeSoundness init impl
    (relationRound R n deg D i.castSucc) (relationRound R n deg D i.succ)
    (fun _ => (deg : ‚Ñù‚â•0) / Fintype.card R)

lemma testBit_of_sub_two_pow_of_bit_1 {n i : ‚Ñï} (h_testBit_eq_1 : (n).testBit i = true) :
  (n - 2^i).testBit i = false

theorem take_drop_eq_drop_take (m‚ÇÅ m‚ÇÇ : ‚Ñï) (h‚ÇÅ : m‚ÇÅ ‚â§ m‚ÇÇ) (h‚ÇÇ : m‚ÇÇ ‚â§ n) (v : (i : Fin n) ‚Üí Œ± i) :
    take (m‚ÇÇ - m‚ÇÅ) (by omega) (drop m‚ÇÅ (by omega) v) =
      drop m‚ÇÅ (by omega) (take m‚ÇÇ h‚ÇÇ v)

@[simp]
lemma oddPart_coeff {f : Polynomial F} {n : ‚Ñï} :
    (oddPart f).coeff n = if Even n then f.coeff (n + 1) else 0

@[simp]
lemma shift_left_empty :
    shift_left ‚àÖ = ‚àÖ

lemma twoAdicGenerators_order (bits : Fin (twoAdicity + 1)) :
    orderOf (twoAdicGenerators[bits]) = 2 ^ (bits : Nat)

@[simp]
lemma challengeOracleInterface_append_range_inr (j : pSpec‚ÇÇ.ChallengeIdx) :
    [(pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).Challenge]‚Çí.range (.inr j) = pSpec‚ÇÇ.Challenge j

lemma getBit_of_add_distrib {n m k : ‚Ñï}
  (h_n_AND_m : n &&& m = 0) : getBit k (n + m) = getBit k n + getBit k m

omit [DecidableEq L] [DecidableEq ùîΩq] h_Fq_char_prime hF‚ÇÇ hŒ≤_lin_indep h_Œ≤‚ÇÄ_eq_1 in
lemma intermediateNovelBasisX_zero_eq_one (i : Fin (‚Ñì + 1)) :
    intermediateNovelBasisX ùîΩq Œ≤ h_‚Ñì_add_R_rate i ‚ü®0, by
      exact Nat.two_pow_pos (‚Ñì - ‚Üëi)‚ü© = 1

@[simp]
theorem LeafData.get_ofRight {s_left s_right : Skeleton} {Œ± : Type}
    (tree : LeafData Œ± (Skeleton.internal s_left s_right))
    (idxRight : SkeletonLeafIndex s_right) :
    tree.get (SkeletonLeafIndex.ofRight idxRight) =
      tree.rightSubtree.get idxRight

lemma concrete_one_ne_zero {k : ‚Ñï} : (one (k:=k)) ‚â† (zero (k:=k))

theorem support_C_mul_le (p : MvPolynomial œÉ R) (r : R) : (C r * p).support ‚äÜ p.support

@[simp]
theorem Prover.run_of_prover_first [ProverOnly pSpec] (stmt : StmtIn) (wit : WitIn)
    (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      prover.run stmt wit = (do
        let state := prover.input (stmt, wit)
        let ‚ü®msg, state‚ü© ‚Üê liftComp (prover.sendMessage ‚ü®0, by simp‚ü© state) _
        let ctxOut ‚Üê prover.output state
        return ((fun i => match i with | ‚ü®0, _‚ü© => msg), ctxOut))

@[simp]
theorem dcast_trans (h : a = a') (h' : a' = a'') :
    dcast h' (dcast h b) = dcast (h.trans h') b

theorem vconcat_vcons_eq_vcons_vconcat (a : Œ±) (v : Fin n ‚Üí Œ±) (b : Œ±) :
    vconcat (a ::·µõ v) b = a ::·µõ (vconcat v b)

@[simp]
theorem BTField.Basis_cast_dest_apply {Œπ : Type*} (Œ± Œ≤ Œ≥ : ‚Ñï) (h_le1 : Œ± ‚â§ Œ≤) (h_le2 : Œ± ‚â§ Œ≥)
    (h_eq : Œ≤ = Œ≥) {k : Œπ} (b : @Basis Œπ (BTField Œ±) (BTField Œ≤) _ _
    (@binaryAlgebraTower (l := Œ±) (r := Œ≤) (h_le := h_le1)).toModule) :
    let castBasis : @Basis Œπ (BTField Œ±) (BTField Œ≥) _ _
      (@binaryAlgebraTower (l := Œ±) (r := Œ≥) (h_le := h_le2)).toModule :=
      cast (by
        exact Basis_cast_dest_eq Œ± Œ≥ Œ≤ h_le2 h_le1 h_eq
      ) b
    (castBasis k) = cast (by exact BTField.cast_BTField_eq Œ≤ Œ≥ h_eq) (b k)

theorem evalNormalizedWAt_eq_normalizedW (i : Fin r) (x : L) :
  evalNormalizedWAt (Œ≤ := Œ≤) (‚Ñì := ‚Ñì) (R_rate := R_rate) (i := i) x
    = (normalizedW (ùîΩq := ùîΩq) (Œ≤ := Œ≤) (i := i)).eval x

@[simp] theorem BitVec.cast_zero {n m : ‚Ñï} (h : n = m) : BitVec.cast h 0 = 0

theorem fcons‚ÇÇ_inj {Œ±‚ÇÅ : A} {Œ±‚ÇÇ : B} {Œ≤‚ÇÅ : Fin n ‚Üí A} {Œ≤‚ÇÇ : Fin n ‚Üí B}
    (a‚ÇÅ a‚ÇÇ : F‚ÇÇ Œ±‚ÇÅ Œ±‚ÇÇ) (b‚ÇÅ b‚ÇÇ : (i : Fin n) ‚Üí F‚ÇÇ (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) :
    fcons‚ÇÇ (F := F‚ÇÇ) a‚ÇÅ b‚ÇÅ = fcons‚ÇÇ (F := F‚ÇÇ) a‚ÇÇ b‚ÇÇ ‚Üî a‚ÇÅ = a‚ÇÇ ‚àß b‚ÇÅ = b‚ÇÇ

@[simp]
lemma coe_fn_of_coe (f : ‚àÄ a, Œ≤ a) : (f : F) = inst.equiv.invFun f

@[simp]
theorem card_univ_filter_eq {e : Œ±} :
  #{x : Œ± | x ‚â† e} = #(Finset.univ (Œ± := Œ±)) - 1

private lemma Monad.map_of_prod_fst_eq_prod_fst {m : Type u ‚Üí Type v} [Monad m] [LawfulMonad m]
    {Œ± Œ≤ Œ≥ : Type u} (ma : m (Œ± √ó Œ≤)) (c : Œ≥) :
    (fun a => (c, a.1)) <$> ma = Prod.mk c <$> Prod.fst <$> ma

@[simp]
lemma seqCompose_dir {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)} :
    (seqCompose pSpec).dir = Fin.vflatten (fun i => (pSpec i).dir)

@[simp]
lemma seqCompose_zero (Stmt : Fin 1 ‚Üí Type) (Wit : Fin 1 ‚Üí Type)
    {n : Fin 0 ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (R : (i : Fin 0) ‚Üí
      Reduction oSpec (Stmt i.castSucc) (Wit i.castSucc) (Stmt i.succ) (Wit i.succ) (pSpec i)) :
    seqCompose Stmt Wit R = Reduction.id

@[simp]
theorem distFromCode_of_empty (u : n ‚Üí R) : Œî‚ÇÄ(u, (‚àÖ : Set (n ‚Üí R))) = ‚ä§

theorem base_intermediateNormVpoly
  (k : Fin (‚Ñì + 1)) :
  intermediateNormVpoly ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®0, by
    by_contra ht
    simp only [not_lt, nonpos_iff_eq_zero] at ht
    contradiction
  ‚ü© ‚ü®k, by simp only [tsub_zero]; omega‚ü© =
  normalizedW ùîΩq Œ≤ ‚ü®k, by omega‚ü©

theorem linear_sum_repr (R : Type*) [CommRing R] (S : Type*) [CommRing S] [Algebra R S]
    (pb : PowerBasis R S) (h_dim : pb.dim = (2 : ‚Ñï)) (s : S) :
    ‚àÉ a b : R, s = a ‚Ä¢ pb.gen + algebraMap R S b

lemma getBit_eq_succ_getBit_of_mul_two_add_one {n k : ‚Ñï} : getBit (k+1) (2*n + 1) = getBit k n

omit [DecidableEq ùîΩq] hF‚ÇÇ in
lemma initial_tiled_coeffs_correctness (h_‚Ñì : ‚Ñì ‚â§ r) (a : Fin (2 ^ ‚Ñì) ‚Üí L) :
    let b: Fin (2^(‚Ñì + R_rate)) ‚Üí L := tileCoeffs a
    additiveNTTInvariant ùîΩq Œ≤ h_‚Ñì_add_R_rate b a (i := ‚ü®‚Ñì, by omega‚ü©)

theorem cast_run (stmt : StmtIn) (wit : WitIn) :
    R.run stmt wit = cast (sorry) ((R.cast hn hSpec).run stmt wit)

@[simp]
theorem partialSum_nil : [].partialSum = [0]

theorem is_prime : Nat.Prime fieldSize

theorem happend_singleton {Œ± : Fin m ‚Üí Sort u} {Œ≤ : Sort u} (u : (i : Fin m) ‚Üí Œ± i) (a : Œ≤) :
    True

theorem commitOracleReduction_perfectCompleteness (hInit : init.neverFails) (i : Fin ‚Ñì)
    (hCR : isCommitmentRound ‚Ñì œë i) :
    OracleReduction.perfectCompleteness
      (pSpec := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)
      (relIn := foldStepRelOut (mp := mp) ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        (ùìë := ùìë) i)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        (ùìë := ùìë) i.succ)
      (oracleReduction := commitOracleReduction ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hCR)
      (init := init)
      (impl := impl)

@[simp]
theorem verifier_rbrKnowledgeSoundness (hRel : ‚àÄ stmtIn witOut,
      (mapStmt stmtIn, witOut) ‚àà relOut ‚Üí (stmtIn, mapWitInv stmtIn witOut) ‚àà relIn) :
    (verifier oSpec mapStmt).rbrKnowledgeSoundness init impl relIn relOut 0

@[simp]
lemma probFailure_bind_eq_zero_iff [spec.FiniteRange]
    (oa : OracleComp spec Œ±) (ob : Œ± ‚Üí OracleComp spec Œ≤) :
    [‚ä• | oa >>= ob] = 0 ‚Üî [‚ä• | oa] = 0 ‚àß ‚àÄ x ‚àà oa.support, [‚ä• | ob x] = 0

lemma num_eq_highBits_xor_lowBits {n: ‚Ñï} (numLowBits: ‚Ñï) :
  n = getHighBits numLowBits n ^^^ getLowBits numLowBits n

theorem dext_iff {Œ± : Fin n ‚Üí Sort u} {v w : (i : Fin n) ‚Üí Œ± i} :
    v = w ‚Üî ‚àÄ i, v i = w i

theorem runWithOracle_succeeds_iff_simulateQ_randomOracle_neverFails
     {Œ≤}
    [DecidableEq Œπ] [spec.DecidableEq] [(i : Œπ) ‚Üí SelectableType (OracleSpec.range spec i)]
    (oa : OracleComp (spec) Œ≤) (f : spec.FunctionType) :
    (runWithOracle f oa).isSome ‚Üî
    ((oa.simulateQ randomOracle).run (fun i q => some (f i q))).neverFails

lemma normalizedW_eq_qMap_composition (‚Ñì R_rate : ‚Ñï) (i : Fin r) :
    normalizedW ùîΩq Œ≤ i = qCompositionChain ùîΩq Œ≤ (‚Ñì:=‚Ñì) (R_rate:=R_rate) i

@[simp]
theorem dist_subsingleton {C : Set (n ‚Üí R)} [Subsingleton C] : ‚ÄñC‚Äñ‚ÇÄ = 0

@[simp]
theorem generateProof_ofLeft {sleft sright : Skeleton}
    (cache_tree : FullData Œ± (Skeleton.internal sleft sright))
    (idxLeft : SkeletonLeafIndex sleft) :
    generateProof cache_tree (BinaryTree.SkeletonLeafIndex.ofLeft idxLeft) =
      (cache_tree.rightSubtree).getRootValue ::
        (generateProof cache_tree.leftSubtree idxLeft)

@[csimp]
theorem dcons_eq_cons : @dcons = @cons

@[simp]
theorem binaryTowerAlgebra_id {l r : ‚Ñï} (h_eq : l = r) :
    @binaryAlgebraTower l r (h_le:=by omega) =
    (h_eq ‚ñ∏ (Algebra.id (BTField l)) : Algebra (BTField l) (BTField r))

lemma sum_of_and_eq_zero_is_or {n m : ‚Ñï} (h_n_AND_m : n &&& m = 0) : n + m = n ||

@[simp]
lemma OracleReduction.id_toReduction :
    (OracleReduction.id : OracleReduction oSpec Statement OStatement Witness _ _ _ _).toReduction =
      Reduction.id

theorem seqCompose_perfectCompleteness (hInit : init.neverFails)
    (rel : (i : Fin (m + 1)) ‚Üí Set ((Stmt i √ó ‚àÄ j, OStmt i j) √ó Wit i))
    (R : ‚àÄ i, OracleReduction oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Wit i.castSucc)
      (Stmt i.succ) (OStmt i.succ) (Wit i.succ) (pSpec i))
    (h : ‚àÄ i, (R i).perfectCompleteness init impl (rel i.castSucc) (rel i.succ)) :
      (OracleReduction.seqCompose Stmt OStmt Wit R).perfectCompleteness
        init impl (rel 0) (rel (Fin.last m))

@[simp]
theorem dcons_zero {motive : Fin (n + 1) ‚Üí Sort u} (a : motive 0)
    (v : (i : Fin n) ‚Üí motive i.succ) : (a ::·µà‚ü®motive‚ü© v) 0 = a

lemma getBit_of_xor {n m k: ‚Ñï} : getBit k (n ^^^ m) = getBit k n ^^^ getBit k m

theorem rbrKnowledgeSoundness_implies_rbrSoundness
    {relIn : Set (StmtIn √ó WitIn)} {relOut : Set (StmtOut √ó WitOut)}
    {verifier : Verifier oSpec StmtIn StmtOut pSpec}
    {rbrKnowledgeError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    (h : verifier.rbrKnowledgeSoundness init impl relIn relOut rbrKnowledgeError) :
    verifier.rbrSoundness init impl relIn.language relOut.language rbrKnowledgeError

lemma oodSampling_rs_le_bound
    {f : Œπ ‚Üí F} {m s : ‚Ñï} {œÜ : Œπ ‚Ü™ F} [Smooth œÜ]
    (Œ¥ l : ‚Ñù‚â•0) (hŒ¥Le : Œ¥ ‚â§ 1)
    (C : Set (Œπ ‚Üí F)) (hcode : C = smoothCode œÜ m ‚àß listDecodable C Œ¥ l) :
    Pr_{ let rs ‚Üê$·µñ (Fin s ‚Üí F) }[ ‚àÉ u u' : smoothCode œÜ m,
                        u.val ‚â† u'.val ‚àß
                        u.val ‚àà relHammingBall C f Œ¥ ‚àß
                        u'.val ‚àà relHammingBall C f Œ¥ ‚àß
                        ‚àÄ i : Fin s,
                          let ri := rs i
                          let rVec := fun j : Fin m => ri ^ (2^(j : ‚Ñï))
                          (mVdecode u).eval (rVec) = (mVdecode u').eval (rVec)
                      ] ‚â§ ENNReal.ofReal (((l : ‚Ñù)^2 / 2) * (((2^m : ‚Ñù) / Fintype.card F)^s))

@[simp]
theorem sumExceptFirst'_degree_le (n : ‚Ñï) (h : n > 0) (D : Fin (n - 1) ‚Üí Finset R)
    (p : MvPolynomial (Fin n) R) : (sumExceptFirst' n h D p).degree ‚â§ p.degreeOf ‚ü®0, h‚ü©

lemma add_assoc {k : ‚Ñï} : ‚àÄ (a b c : ConcreteBTField k), a + b + c = a + (b + c)

theorem simulateQ'_eq_simulateQ [AlternativeMonad m] [LawfulMonad m]
    {so : QueryImpl spec m} (oa : OracleComp spec Œ±) (h : oa.neverFails) :
      simulateQ' so oa h = simulateQ so oa

@[simp]
theorem hflatten_splitSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {Œ± : (k : Fin (vsum n)) ‚Üí Sort*}
    (v : (k : Fin (vsum n)) ‚Üí Œ± k) (k : Fin (vsum n)) :
    hflatten (fun i j => v (embedSum i j)) k = cast (vflatten_splitSum Œ± k).symm (v k)

theorem simulateQ_bind_fst_comp (oa : OracleComp spec Œ±) (f : Œ± ‚Üí OracleComp spec Œ≤) :
    (do let a ‚Üê (simulateQ loggingOracle oa).run; f a.1) = (do let a ‚Üê oa; f a)

theorem oracleVerifier_toVerifier_run {stmt : Statement} {oStmt : ‚àÄ i, OStatement i}
    {tr : (oraclePSpec Witness).FullTranscript} :
    (oracleVerifier oSpec Statement OStatement Witness).toVerifier.run ‚ü®stmt, oStmt‚ü© tr =
      pure ‚ü®stmt, Sum.rec oStmt (fun i => match i with | 0 => tr 0)‚ü©

lemma split_join_eq_split {k : ‚Ñï} (h_pos : k > 0)
    (hi_btf lo_btf : ConcreteBTField (k - 1)) :
    split h_pos („Ää hi_btf, lo_btf „Äã) = (hi_btf, lo_btf)

Nat.succ_lt_succ_iff in Init.Data.Nat.Basic

lemma coeff_toPoly {p : UniPoly Q} {n : ‚Ñï} : p.toPoly.coeff n = p.coeff n

private lemma Fis_pairwise_disjoint : Set.PairwiseDisjoint Set.univ (Fi B i)

lemma listOfCloseCodewords_eq_zero :
  listOfCloseCodewords C y n = 0 ‚Üî IsEmpty (hammingBall C y n) ‚à® Infinite (hammingBall C y n)

@[simp]
lemma eval‚ÇÇAlgHom_apply {A : Type w} {B : Type*} [CommSemiring A] [CommSemiring B]
    [PolynomialLike A P] [Algebra R A] [IsScalarTower R A P] [Algebra R B]
    (f : A ‚Üí‚Çê[R] B) (b : B) (p : P) :
    (eval‚ÇÇAlgHom f b) p = eval‚ÇÇ f b p

theorem seqCompose_soundness
    (lang : (i : Fin (m + 1)) ‚Üí Set (Stmt i √ó ‚àÄ j, OStmt i j))
    (V : (i : Fin m) ‚Üí
      OracleVerifier oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Stmt i.succ) (OStmt i.succ)
        (pSpec i))
    (soundnessError : Fin m ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (V i).soundness init impl (lang i.castSucc) (lang i.succ) (soundnessError i)) :
      (OracleVerifier.seqCompose Stmt OStmt V).soundness init impl (lang 0) (lang (Fin.last m))
        (‚àë i, soundnessError i)

@[simp]
private lemma evenPart'_coeffs {f : Polynomial F} {n : ‚Ñï} :
    (evenPart' f).coeff n = if Even n then f.coeff n else 0

theorem append_rbrKnowledgeSoundness (V‚ÇÅ : OracleVerifier oSpec Stmt‚ÇÅ OStmt‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : OracleVerifier oSpec Stmt‚ÇÇ OStmt‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ pSpec‚ÇÇ)
    {rbrKnowledgeError‚ÇÅ : pSpec‚ÇÅ.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    {rbrKnowledgeError‚ÇÇ : pSpec‚ÇÇ.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    (h‚ÇÅ : V‚ÇÅ.rbrKnowledgeSoundness init impl rel‚ÇÅ rel‚ÇÇ rbrKnowledgeError‚ÇÅ)
    (h‚ÇÇ : V‚ÇÇ.rbrKnowledgeSoundness init impl rel‚ÇÇ rel‚ÇÉ rbrKnowledgeError‚ÇÇ) :
      (V‚ÇÅ.append V‚ÇÇ).rbrKnowledgeSoundness init impl rel‚ÇÅ rel‚ÇÉ
        (Sum.elim rbrKnowledgeError‚ÇÅ rbrKnowledgeError‚ÇÇ ‚àò ChallengeIdx.sumEquiv.symm)

theorem one_le_two_pow_n (n : ‚Ñï) : 1 ‚â§ 2 ^ n

lemma aeval_eq' {A : Type y} [CommSemiring A] [Algebra R A] {F : Type z} [FunEquiv F œÉ A]
    (f : P ‚Üí‚Çê[R] A) (p : P) : f p = aeval (fun s => f (X s) : F) p

theorem srKnowledgeSoundness_implies_knowledgeSoundness
    (relIn : Set (StmtIn √ó WitIn)) (relOut : Set (StmtOut √ó WitOut))
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    (srInit : ProbComp (srChallengeOracle StmtIn pSpec).FunctionType)
    (srImpl : QueryImpl oSpec (StateT (srChallengeOracle StmtIn pSpec).FunctionType ProbComp))
    (srKnowledgeError : ‚Ñù‚â•0) :
      Verifier.StateRestoration.knowledgeSoundness srInit srImpl relIn relOut
        verifier srKnowledgeError ‚Üí
      knowledgeSoundness init impl relIn relOut verifier srKnowledgeError

lemma probOfBadPts {deg : ‚Ñï} {Œ± : Œπ ‚Ü™ F} {e : ‚Ñï} {U : Matrix Œ∫ Œπ F}
  (he : (e : ‚Ñö) < (Code.minDist (RScodeSet Œ± deg) : ‚Ñö) / 3)
  (hU : e < Œî(U, matrixSubmoduleOfLinearCode Œ∫ (ReedSolomon.code Œ± deg))) :
  (PMF.uniformOfFintype (Matrix.rowSpan U)).toOuterMeasure
    { w | distFromCode (n := Œπ) (R := F) w (ReedSolomon.code Œ± deg) ‚â§ e }
  ‚â§ (Code.minDist (RScodeSet Œ± deg) : ‚Ñù‚â•0) /(Fintype.card F : ‚Ñù‚â•0)

theorem randomOracle_neverFails_iff_runWithOracle_neverFails {Œ≤}
    [DecidableEq Œπ] [spec.DecidableEq] [(i : Œπ) ‚Üí SelectableType (OracleSpec.range spec i)]
    (oa : OracleComp (spec) Œ≤)
    :
    (‚àÄ (preexisting_cache : spec.QueryCache),
      ((oa.simulateQ randomOracle).run preexisting_cache).neverFails)
    ‚Üî
    (‚àÄ (f : spec.FunctionType),
      (runWithOracle f oa).isSome)

lemma folding_steps_pos : (œë : ‚Ñï) > 0

@[simp]
theorem vappend_vcons (a : Œ±) (u : Fin m ‚Üí Œ±) (v : Fin n ‚Üí Œ±) :
    vappend (vcons a u) v = (vcons a (vappend u v)) ‚àò Fin.cast (Nat.succ_add m n)

lemma powContraction_is_right_inverse_to_linearMvExtension
  (p : Polynomial.degreeLT F (2^m)) :
    powContraction.comp linearMvExtension p = p

lemma and_eq_zero_iff_and_each_getBit_eq_zero {n m : ‚Ñï} :
    n &&& m = 0 ‚Üî ‚àÄ k, Nat.getBit k n &&& Nat.getBit k m = 0

theorem FullData.toLeafData_rightSubtree {Œ±} {s_left s_right : Skeleton}
    (tree : FullData Œ± (Skeleton.internal s_left s_right)) :
    tree.toLeafData.rightSubtree =
      tree.rightSubtree.toLeafData

theorem mapM_single (f : Œ± ‚Üí m Œ≤) (a : Œ±) : List.mapM f [a] = return [‚Üê f a]

lemma solution_gamma_is_linear_in_Z
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  :
  ‚àÉ (v‚ÇÄ v‚ÇÅ : F[X]),
    Œ≥' x‚ÇÄ (R k Œ¥ x‚ÇÄ h_gs) (irreducible_H k (x‚ÇÄ := x‚ÇÄ) (Œ¥ := Œ¥) h_gs) =
        AppendixA.polyToPowerSeriesùïÉ _
          (
            (Polynomial.map Polynomial.C v‚ÇÄ) +
            (Polynomial.C Polynomial.X) * (Polynomial.map Polynomial.C v‚ÇÅ)
          )

theorem basis_repr_of_sDomain_lift (i j : Fin r) (h_j : j < ‚Ñì + R_rate) (h_le : i ‚â§ j)
    (y : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := j)) :
    let x‚ÇÄ := sDomain.lift ùîΩq Œ≤ h_‚Ñì_add_R_rate i j (by omega) (by omega) y
    ‚àÄ k: Fin (‚Ñì + R_rate - i),
      (sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := i) (h_i := by omega)).repr x‚ÇÄ k =
        if hk: k < (j.val - i.val) then 0
        else (sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := j)
          (h_i := by omega)).repr y ‚ü®k - (j.val - i.val), by omega‚ü©

@[simp]
theorem cast_id :
    OracleReduction.cast rfl rfl (fun _ => rfl) =
      (id : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec‚ÇÅ ‚Üí _)

@[simp]
theorem poly_form (k : ‚Ñï) : poly k = X^2 + (C (Z k) * X + 1)

@[simp]
theorem removeNth_apply : removeNth p s i = s (p.succAbove i)

@[simp]
theorem LeafData.optionComposeBuild_internal {Œ±} {s_left s_right : Skeleton}
    (left : LeafData Œ± s_left) (right : LeafData Œ± s_right)
    (compose : Œ± ‚Üí Œ± ‚Üí Option Œ±) :
    (LeafData.internal left right).optionComposeBuild compose =
      FullData.internal
        (Option.doubleBind compose
          (left.optionComposeBuild compose).getRootValue
          (right.optionComposeBuild compose).getRootValue)
        (left.optionComposeBuild compose)
        (right.optionComposeBuild compose)

@[simp]
theorem getRoot_trivial (a : Œ±) : getRoot Œ± <$> (buildMerkleTree Œ± 0 ‚ü®[a], rfl‚ü©) = pure a

@[simp]
theorem cast_val {m n : ‚Ñï} (h : m = n) (a : Fin m) : (Fin.cast h a).val = a.val

Nat.sub_mul in Init.Data.Nat.Basic

theorem commit_eq {a : ZMod p} (hpG1 : Nat.card G‚ÇÅ = p)
    (poly : degreeLT (ZMod p) (n + 1)) :
    commit (towerOfExponents g‚ÇÅ a n) (degreeLTEquiv _ _ poly) = g‚ÇÅ ^ (poly.1.eval a).val

@[simp]
theorem init_apply : init s i = s i.castSucc

@[simp]
theorem insertNth_last : insertNth (Fin.last n) y s = snoc s y

lemma eq_evenize_deevenize {f : Polynomial F} (hEven : EvenPoly f) :
    evenize (deevenize f) = f

theorem two_le_two_pow_n_plus_1 (n : ‚Ñï) : 2 ‚â§ 2 ^ (n + 1)

@[simp] lemma ofMvPolynomialAlgHom_X (s : œÉ) :
    ofMvPolynomialAlgHom (MvPolynomial.X s : MvPolynomial œÉ R) = (X s : P)

theorem eval_zeroOne_eq_MLE_toEvalsZeroOne (p : MvPolynomial œÉ R) (x : œÉ ‚Üí Fin 2) :
    eval (x : œÉ ‚Üí R) p = eval (x : œÉ ‚Üí R) (MLE p.toEvalsZeroOne)

@[simp] -- TODO: more general version/class for query impls that never have failures
lemma loggingOracle.probFailure_simulateQ [spec.FiniteRange] (oa : OracleComp spec Œ±) :
    [‚ä• | (simulateQ loggingOracle oa).run] = [‚ä• | oa] := by
  induction oa using OracleComp.induction with

theorem fcons_right_injective {Œ≤ : Fin n ‚Üí A} (a : F Œ±) :
    Function.Injective (fcons a : ((i : Fin n) ‚Üí F (Œ≤ i)) ‚Üí (i : Fin (n + 1)) ‚Üí _)

theorem heq_of_dcast (ha : a = a') (hb : dcast ha b = b') : HEq b b'

lemma toOutCodewordsCount_last ‚Ñì œë : toOutCodewordsCount ‚Ñì œë (Fin.last ‚Ñì) = ‚Ñì / œë

theorem oracleReduction_rbr_knowledge_soundness : True

@[simp]
theorem LeafData.ofFun_get {Œ±} {s} (tree : LeafData Œ± s) :
    LeafData.ofFun s (fun idx => tree.get idx) = tree

@[simp] theorem equiv_trans {p q r : UniPoly Q} : Trim.equiv p q ‚Üí equiv q r ‚Üí equiv p r

lemma xor_eq_sub_iff_submask {n m : ‚Ñï} (h: m ‚â§ n) : n ^^^ m = n - m ‚Üî n &&& m = m

@[simp]
theorem toNat_succ (n : ChurchNat ‚Ñï) : toNat (succ n) = n.toNat.succ

theorem coeff_of_toMvPolynomial_eq_coeff_of_MlPoly (p : MlPoly R n) (m : Fin n ‚Üí‚ÇÄ ‚Ñï) :
  coeff m (toMvPolynomial p) =
    if h_binary: (‚àÄ j: Fin n, m j ‚â§ 1) then
      let i_of_m: ‚Ñï := Nat.binaryFinMapToNat (m:=m) (h_binary:=h_binary)
      p[i_of_m]
    else
      0

lemma toImpl_toPoly_of_canonical [LawfulBEq R] (p : UniPolyC R) : p.toPoly.toImpl = p

theorem append_getLast_dropLast {Œ± : Type u} (l : List Œ±) (h : l ‚â† []) :
  l.dropLast ++ [l.getLast h] = l

lemma wt_eq_hammingNorm [Zero F] {v : Œπ ‚Üí F} :
  wt v = hammingNorm v

Nat.mul_le_mul_right in Init.Data.Nat.Basic

omit [Finite F] in
lemma sqr_mem_D_succ_i_of_mem_D_i : ‚àÄ {x : FÀ£} {i : ‚Ñï},
  x ‚àà evalDomain D i ‚Üí x ^ 2 ‚àà evalDomain D (i + 1)

@[simp]
theorem simulateQ_bind_fst (oa : OracleComp spec Œ±) (f : Œ± ‚Üí OracleComp spec Œ≤) :
    (do let a ‚Üê (simulateQ loggingOracle oa).run; f a.1) = oa >>= f

@[simp, grind =]
theorem monomialXY_eq_zero_iff {n m : ‚Ñï} {a : F} : monomialXY n m a = 0 ‚Üî a = 0

lemma qMap_total_fiber_repr_coeff (i : Fin ‚Ñì) (steps : ‚Ñï) (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
    (y : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i.val + steps, by omega‚ü©))
    (k : Fin (2 ^ steps)) :
    let x := qMap_total_fiber ùîΩq Œ≤ (i := ‚ü®i, by omega‚ü©)
      (steps := steps)
      (h_i_add_steps := by simp only; exact fin_‚Ñì_steps_lt_‚Ñì_add_R i steps h_i_add_steps) (y := y) k
    let basis_y := sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i.val + steps, by omega‚ü©)
      (h_i := by simp only; exact fin_‚Ñì_steps_lt_‚Ñì_add_R i steps h_i_add_steps)
    let y_coeffs := basis_y.repr y
    ‚àÄ j, -- j refers to bit index of the fiber point x
      ((sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i, by omega‚ü©) (by simp only; omega)).repr x) j
      = fiber_coeff (i := i) (steps := steps) (j := j) (elementIdx := k)
        (y_coeffs := y_coeffs)

theorem bitsToU_bijective (i : Fin r) :
  Function.Bijective (bitsToU (ùîΩq := ùîΩq) (Œ≤ := Œ≤) (‚Ñì := ‚Ñì) (R_rate := R_rate) i)

theorem singleton_bound (C : Set (n ‚Üí R)) :
    (ofFinite C).card ‚â§ (ofFinite R).card ^ (card n - (‚ÄñC‚Äñ‚ÇÄ - 1))

theorem dconcat_init_self {motive : Fin (n + 1) ‚Üí Sort u} (v : (i : Fin (n + 1)) ‚Üí motive i) :
    (fun i => v (castSucc i)) :+·µà‚ü®motive‚ü© (v (last n)) = v

@[simp]
theorem reduction_completeness (h : init.neverFails) [Nonempty œÉ] :
    (reduction oSpec Statement pred).perfectCompleteness init impl
    (relIn Statement pred) (relOut Statement)

@[simp]
theorem acceptRejectOracleRel_language :
    acceptRejectOracleRel.language = { (true, isEmptyElim) }

theorem vcons_eq_const (a : Œ±) : a ::·µõ (fun _ : Fin n => a) = fun _ => a

theorem induction_init {n : ‚Ñï} {motive : Fin (n + 2) ‚Üí Sort*} {zero : motive 0}
    {succ : ‚àÄ i : Fin (n + 1), motive i.castSucc ‚Üí motive i.succ} {i : Fin (n + 1)} :
      induction (motive := motive) zero succ i.castSucc =
        induction (motive := Fin.init motive) zero (fun j x => succ j.castSucc x) i

lemma definingPoly_is_monic {F : Type*} [Field F] [Fintype F] (s : F) [NeZero s] :
  (definingPoly s).Monic

@[simp]
theorem OracleReduction.run_eq_run_reduction [‚àÄ i, OracleInterface (pSpec.Message i)]
    {stmt : StmtIn} {oStmt : ‚àÄ i, OStmtIn i} {wit : WitIn}
    {oracleReduction : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec} :
      oracleReduction.run stmt oStmt wit =
        oracleReduction.toReduction.run ‚ü®stmt, oStmt‚ü© wit

theorem neg_add_cancel [LawfulBEq R] (p : UniPoly R) : -p + p = 0

lemma degree_normalizedW (i : Fin r) :
  (normalizedW ùîΩq Œ≤ i).degree = (Fintype.card ùîΩq)^(i.val)

@[simp]
lemma invFun_toFun (f : F) : inst.equiv.invFun (inst.equiv.toFun f) = f

lemma getBit_of_highBits {n: ‚Ñï} (numLowBits : ‚Ñï) : ‚àÄ k, getBit k (getHighBits numLowBits n) =
    if k < numLowBits then 0 else getBit (k) (n)

theorem vappend_ext (u‚ÇÅ u‚ÇÇ : Fin m ‚Üí Œ±) (v‚ÇÅ v‚ÇÇ : Fin n ‚Üí Œ±) :
    vappend u‚ÇÅ v‚ÇÅ = vappend u‚ÇÇ v‚ÇÇ ‚Üî u‚ÇÅ = u‚ÇÇ ‚àß v‚ÇÅ = v‚ÇÇ

@[simp]
lemma domain_def : (spec Œ±).domain () = (Œ± √ó Œ±)

theorem vappend_left_eq_cons (a : Fin 1 ‚Üí Œ±) (v : Fin n ‚Üí Œ±) :
    vappend a v = (vcons (a 0) v) ‚àò Fin.cast (Nat.add_comm 1 n)

@[simp]
theorem dcast‚ÇÇ_trans (ha : a = a') (ha' : a' = a'')
    (hb : dcast ha b = b') (hb' : dcast ha' b' = b'') :
      dcast‚ÇÇ ha' hb' (dcast‚ÇÇ ha hb c) = dcast‚ÇÇ (ha.trans ha') (by simp [‚Üê hb', ‚Üê hb]) c

lemma towerRingHomForwardMap_backwardMap_eq (k : ‚Ñï) (x : BTField k) :
  towerRingHomForwardMap (k:=k) (towerRingHomBackwardMap (k:=k) x) = x

@[simp]
theorem OracleReduction.runWithLog_eq_runWithLog_reduction [‚àÄ i, OracleInterface (pSpec.Message i)]
    {stmt : StmtIn} {oStmt : ‚àÄ i, OStmtIn i} {wit : WitIn}
    {oracleReduction : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec} :
      oracleReduction.run stmt oStmt wit =
        oracleReduction.toReduction.run ‚ü®stmt, oStmt‚ü© wit

theorem Nat.reconstruct_from_hi_and_lo_parts (n hi_len lo_len : ‚Ñï)
    (h_n : n < 2 ^ (hi_len + lo_len)) :
    n = (((n >>> lo_len) % (2 ^ hi_len)) <<< lo_len) + (n % (2 ^ lo_len))

@[simp]
theorem fflatten_zero {A : Sort u} {F : A ‚Üí Sort v} {n : Fin 0 ‚Üí ‚Ñï}
    {Œ± : (i : Fin 0) ‚Üí (j : Fin (n i)) ‚Üí A}
    {v : (i : Fin 0) ‚Üí (j : Fin (n i)) ‚Üí F (Œ± i j)} : fflatten v = !h[]

@[simp]
theorem induction_one' {motive : Fin 2 ‚Üí Sort*} {zero : motive 0}
    {succ : ‚àÄ i : Fin 1, motive i.castSucc ‚Üí motive i.succ} :
      induction (motive := motive) zero succ (1 : Fin 2) = succ 0 zero

@[simp]
theorem lagrangeBasis_zero {w : Vector R 0} : lagrangeBasis w = #v[1]

theorem hcons_eq_hcons_iff {Œ≤ : Fin n ‚Üí Sort u} (a‚ÇÅ a‚ÇÇ : Œ±) (v‚ÇÅ v‚ÇÇ : (i : Fin n) ‚Üí Œ≤ i) :
    hcons a‚ÇÅ v‚ÇÅ = hcons a‚ÇÇ v‚ÇÇ ‚Üî a‚ÇÅ = a‚ÇÇ ‚àß v‚ÇÅ = v‚ÇÇ

lemma getBit_zero_eq_zero {k : Nat} : getBit k 0 = 0

theorem succ'_injective : Function.Injective (succ' : Nat ‚Üí Nat)

@[simp]
theorem fappend_zero {Œ≤ : Fin m ‚Üí A} {Œ± : Fin 0 ‚Üí A}
    (u : (i : Fin m) ‚Üí F (Œ≤ i)) :
    fappend u (!h‚¶ÉF‚¶Ñ‚ü®Œ±‚ü©[] : (i : Fin 0) ‚Üí F (Œ± i)) = u

@[simp]
theorem fcons‚ÇÇ_zero {Œ±‚ÇÅ : A} {Œ±‚ÇÇ : B} {Œ≤‚ÇÅ : Fin n ‚Üí A} {Œ≤‚ÇÇ : Fin n ‚Üí B}
    (a : F‚ÇÇ Œ±‚ÇÅ Œ±‚ÇÇ) (b : (i : Fin n) ‚Üí F‚ÇÇ (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) :
    fcons‚ÇÇ (F := F‚ÇÇ) a b 0 = cast (by simp [Fin.vcons_zero]) a

lemma getBit_of_shiftLeft {n p : ‚Ñï}:
  ‚àÄ k, getBit (k) (n <<< p) = if k < p then 0 else getBit (k - p) n

theorem liftContext_completeness
    (h : R.completeness init impl innerRelIn innerRelOut completenessError) :
      (R.liftContext lens).completeness init impl outerRelIn outerRelOut completenessError

lemma NTTStage_correctness (i : Fin (‚Ñì))
    (input_buffer : Fin (2 ^ (‚Ñì + R_rate)) ‚Üí L) (original_coeffs : Fin (2 ^ ‚Ñì) ‚Üí L) :
    additiveNTTInvariant ùîΩq Œ≤ h_‚Ñì_add_R_rate (evaluation_buffer:=input_buffer)
      (original_coeffs:=original_coeffs) (i := ‚ü®i.val+1, by omega‚ü©) ‚Üí
    additiveNTTInvariant ùîΩq Œ≤ h_‚Ñì_add_R_rate (evaluation_buffer:=NTTStage ùîΩq Œ≤ h_‚Ñì_add_R_rate
      ‚ü®i, by omega‚ü© input_buffer) (original_coeffs:=original_coeffs) ‚ü®i, by omega‚ü©

theorem polynomial_sum_ext.{u, u_1}
  {R : Type u}
  [Semiring R]
  {S : Type u_1}
  [AddCommMonoid S]
  {p : Polynomial R} {f g : ‚Ñï ‚Üí R ‚Üí S}
  (h : ‚àÄ i x, f i x = g i x)
  : p.sum f = p.sum g

lemma rowRank_eq_colRank : rowRank U = colRank U

private lemma fold_max_lemma {Œπ : Type} {s : Finset Œπ} {f : Œπ ‚Üí ‚Ñï} {n : ‚Ñï} :
    (‚àÄ i ‚àà s, f i ‚â§ n) ‚Üí Finset.fold max 0 f s ‚â§ n

@[simp]
protected lemma elocPoly_leading_coeff_one : (ElocPoly n œâs f p).leadingCoeff = 1

private lemma cast_eq_cast_same_type {Œ± Œ≤ : Sort u} (h1 h2 : Œ± = Œ≤) {x y : Œ±}
    (h : cast h1 x = cast h2 y) : x = y

@[simp]
theorem vflatten_zero {n : Fin 0 ‚Üí ‚Ñï} {v : (i : Fin 0) ‚Üí Fin (n i) ‚Üí Œ±} : vflatten v = !v[]

Nat.add_le_of_le_sub in Init.Data.Nat.Basic

theorem seqCompose_completeness (hInit : init.neverFails)
    (rel : (i : Fin (m + 1)) ‚Üí Set ((Stmt i √ó ‚àÄ j, OStmt i j) √ó Wit i))
    (R : ‚àÄ i, OracleReduction oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Wit i.castSucc)
      (Stmt i.succ) (OStmt i.succ) (Wit i.succ) (pSpec i))
    (completenessError : Fin m ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (R i).completeness init impl (rel i.castSucc) (rel i.succ) (completenessError i)) :
      (OracleReduction.seqCompose Stmt OStmt Wit R).completeness
        init impl (rel 0) (rel (Fin.last m)) (‚àë i, completenessError i)

theorem sumcheckFoldOracleVerifier_rbrKnowledgeSoundness :
    (sumcheckFoldOracleVerifier ùîΩq Œ≤).rbrKnowledgeSoundness init impl
      (pSpec := pSpecSumcheckFold ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
      (relIn := roundRelation (mp := mp) ùîΩq Œ≤ (œë:=œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) 0)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë:=œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) (Fin.last ‚Ñì))
      (rbrKnowledgeError := sumcheckFoldKnowledgeError ùîΩq Œ≤ (œë:=œë))

theorem prime_29 : Nat.Prime 29

lemma getBit_eq_succ_getBit_of_mul_two {n k : ‚Ñï} : getBit (k+1) (2*n) = getBit k n

Nat.pow_lt_pow_right in Init.Data.Nat.Lemmas

@[simp]
theorem ConcreteBTField.RingHom_cast_source_apply (k n m : ‚Ñï) (h_eq : k = n)
  (f : ConcreteBTField k ‚Üí+* ConcreteBTField m) (x : ConcreteBTField n) :
    (cast (ConcreteBTField.RingHom_eq_of_source_eq (k:=k) (n:=n) (m:=m) h_eq) f) x
    = f (cast (by apply cast_ConcreteBTField_eq (h_eq:=h_eq.symm)) x)

lemma inv_eq_pow (a : Field) (ha : a ‚â† 0) : a‚Åª¬π = a ^ (fieldSize - 2)

theorem add_assoc : p + q + r = p + (q + r)

@[simp]
theorem splitSum_succ {n : Fin (m + 1) ‚Üí ‚Ñï} {k : Fin (vsum n)} :
    splitSum k = Fin.dappend
      (fun k => ‚ü®0, k‚ü©)
      (fun k => ‚ü®(splitSum k).1.succ, (splitSum k).2‚ü©)
      k

lemma nsmul_succ {k : ‚Ñï} (n : ‚Ñï) (x : ConcreteBTField k) :
  (if ‚Üën.succ % 2 = 0 then zero else x) = (if ‚Üën % 2 = 0 then zero else x) + x

lemma if_self_rfl {Œ± : Type*} [DecidableEq Œ±] (a b : Œ±) :
  (if a = b then b else a) = a

theorem append_left_injective {pSpec : ProtocolSpec n} :
    Function.Injective (@ProtocolSpec.append m n ¬∑ pSpec)

@[simp]
theorem dflatten_splitSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {motive : (k : Fin (vsum n)) ‚Üí Sort*}
    (v : (k : Fin (vsum n)) ‚Üí motive k) (k : Fin (vsum n)) :
    dflatten (motive := motive) (fun i j => v (embedSum i j)) k = v k

@[ext]
theorem ext' {a b : AssocNat} (h : a 0 = b 0) : a = b

lemma concrete_mul_zero
  (prevBTFieldProps : ConcreteBTFieldProps (k := k - 1))
  (a : ConcreteBTField k) : concrete_mul a (zero (k:=k)) = zero (k:=k)

omit [Fintype F] [DecidableEq F] in
private lemma choose_2_card_ne_zero (h : 2 ‚â§ B.card) : choose_2 ‚ÜëB.card ‚â† 0

lemma and_two_pow_eq_two_pow_of_getBit_eq_one {n i : ‚Ñï} (h_getBit: getBit i n = 1)
    : n &&& (2 ^ i) = 2 ^ i

@[simp]
theorem splitSum_zero {n : Fin 0 ‚Üí ‚Ñï} {k : Fin (vsum n)} : splitSum k = Fin.elim0 k

theorem sum_fromNat_eq_from_xor_Nat {k : ‚Ñï} (x y : Nat) :
  fromNat (k:=k) (x ^^^ y) = fromNat (k:=k) x + fromNat (k:=k) y

lemma add_two_pow_of_getBit_eq_zero_lt_two_pow {n m i : ‚Ñï} (h_n: n < 2^m) (h_i: i < m)
  (h_getBit_at_i_eq_zero: getBit i n = 0) :
  n + 2^i < 2^m

lemma qCompositionChain_eq_foldl (i : Fin r) :
  qCompositionChain ùîΩq Œ≤ (‚Ñì:=‚Ñì) (R_rate:=R_rate) i =
  Fin.foldl (n:=i) (fun acc j =>
    (qMap ùîΩq Œ≤ ‚ü®j, by omega‚ü©).comp acc) (X)

lemma liftF_eq_of_lt {i : ‚Ñï} (h : i < n) : liftF f' i = f' ‚ü®i, h‚ü©

Nat.zero_le in Init.Prelude

@[simp]
theorem distFromCode_of_mem (C : Set (n ‚Üí R)) {u : n ‚Üí R} (h : u ‚àà C) : Œî‚ÇÄ(u, C) = 0

theorem SkeletonNodeIndex.leftChild_bind_parent {s : Skeleton}
    (idx : SkeletonNodeIndex s) :
    idx.leftChild >>= parent = idx.leftChild.map (fun _ => idx)

@[simp]
theorem fflatten‚ÇÇ_splitSum {A : Sort u} {B : Sort v} {F : A ‚Üí B ‚Üí Sort w} {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï}
    {Œ± : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí A}
    {Œ≤ : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí B}
    (v : (k : Fin (vsum n)) ‚Üí F (vflatten Œ± k) (vflatten Œ≤ k)) (k : Fin (vsum n)) :
    fflatten‚ÇÇ (fun i j => v (embedSum i j)) k = cast (by simp) (v k)

theorem fconcat_injective2 {Œ± : Fin n ‚Üí A} {Œ≤ : A} :
    Function.Injective2 (@fconcat A F n Œ± Œ≤)

lemma coeff_eq_getElem {p : UniPoly Q} {i} (hp : i < p.size) :
  p.coeff i = p[i]

theorem is_multilinear_eq_iff_eq_evals_zeroOne (p : MvPolynomial œÉ R) (q : MvPolynomial œÉ R)
    (hp : p ‚àà R‚¶É‚â§ 1‚¶Ñ[X œÉ]) (hq : q ‚àà R‚¶É‚â§ 1‚¶Ñ[X œÉ]) :
    p = q ‚Üî p.toEvalsZeroOne = q.toEvalsZeroOne

private lemma sum_of_not_equals :
  ‚àë x ‚àà B √óÀ¢ B with x.1 ‚â† x.2, (if x.1 i ‚â† x.2 i then 1 else 0)
  =
  2 * choose_2 #B - 2 * ‚àë Œ±, choose_2 (K B i Œ±)

@[simp, grind _=_]
lemma degreeX_mul [IsDomain F] (f g : F[X][Y]) (hf : f ‚â† 0) (hg : g ‚â† 0) :
  degreeX (f * g) = degreeX f + degreeX g

Nat.add_le_add_left in Init.Data.Nat.Basic

@[simp] lemma twoAdicGenerators_length : twoAdicGenerators.length = twoAdicity + 1

theorem FullTranscript.mk2_eq_snoc_snoc {pSpec : ProtocolSpec 2} (msg0 : pSpec.¬´Type¬ª 0)
    (msg1 : pSpec.¬´Type¬ª 1) :
      FullTranscript.mk2 msg0 msg1 = ((default : pSpec.Transcript 0).concat msg0).concat msg1

Fin.is_le' in Init.Data.Fin.Lemmas

theorem BTField.PowerBasis_cast_dest_eq (k n m : ‚Ñï) (h_k_le_n : k ‚â§ n)
  (h_k_le_m : k ‚â§ m) (h_eq : m = n) :
  letI instLeftAlgebra := binaryAlgebraTower (l:=k) (r:=m) (h_le:=h_k_le_m)
  letI instRightAlgebra := binaryAlgebraTower (l:=k) (r:=n) (h_le:=h_k_le_n)
  @PowerBasis (BTField k) (BTField m) _ _ instLeftAlgebra =
  @PowerBasis (BTField k) (BTField n) _ _ instRightAlgebra

theorem drop_eq_rtake (m : ‚Ñï) (h : m ‚â§ n) (v : (i : Fin n) ‚Üí Œ± i) :
    drop m h v = fun i => dcast (by simp [Fin.cast]; omega) (rtake (n - m) (by omega) v i)

@[simp]
theorem fappend_left {Œ± : Fin m ‚Üí A} {Œ≤ : Fin n ‚Üí A}
    (u : (i : Fin m) ‚Üí F (Œ± i)) (v : (i : Fin n) ‚Üí F (Œ≤ i)) (i : Fin m) :
    fappend u v (castAdd n i) = cast (by simp [vappend_left]) (u i)

@[simp]
theorem Reduction.runWithLog_discard_logs_eq_run
    {stmt : StmtIn} {wit : WitIn}
    {reduction : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec} :
      Prod.fst <$>
        reduction.runWithLog stmt wit = reduction.run stmt wit

theorem degrees_peval {x : œÉ‚ÇÅ ‚Üí R} {f : œÉ ‚Üí œÉ‚ÇÅ ‚äï œÉ‚ÇÇ} {p : MvPolynomial œÉ R} :
    (peval f x p).degrees ‚â§ (p.degrees.map f).filterMap Sum.getRight?

@[simp]
theorem Basis_cast_index_apply {Œ± Œ≤ i j : ‚Ñï} {k : Fin j}
    (h_le : Œ± ‚â§ Œ≤) (h_eq : i = j)
    {b : @Basis (Fin (i)) (ConcreteBTField Œ±) (ConcreteBTField Œ≤) _ _
      (@ConcreteBTFieldAlgebra (l := Œ±) (r := Œ≤) (h_le := h_le)).toModule} :
  let castBasis : @Basis (Fin j) (ConcreteBTField Œ±) (ConcreteBTField Œ≤) _ _
    (@ConcreteBTFieldAlgebra (l:=Œ±) (r:=Œ≤) (h_le:=h_le)).toModule :=
    cast (by exact Basis_cast_index_eq i j Œ± Œ≤ h_le h_eq) b
  (castBasis k) = b (Fin.cast (h_eq.symm) k)

theorem mca_johnson_bound_CONJECTURE
  [DecidableEq Œπ]
  (Œ± : F) (œÜ : Œπ ‚Ü™ F) (m : ‚Ñï) [Smooth œÜ]
  (par‚Ñì_type : Type) [Fintype par‚Ñì_type] (exp : par‚Ñì_type ‚Ü™ ‚Ñï) :
  let Gen := RSGenerator.genRSC par‚Ñì_type œÜ m exp
  let : Fintype Gen.par‚Ñì := Gen.h‚Ñì
  hasMutualCorrAgreement Gen
    -- Conjectured BStar = ‚àöœÅ
    (Real.sqrt Gen.rate)
    -- Conjectured errStar
    (fun Œ¥ =>
      let min_val := min (1 - Real.sqrt Gen.rate - (Œ¥ : ‚Ñù)) (Real.sqrt Gen.rate / 20)
      ENNReal.ofReal (
        ((Fintype.card par‚Ñì_type - 1) * 2^(2*m)) /
        ((Fintype.card F) * (2 * min_val)^7)
      )
    )

omit [NeZero ‚Ñì] [NeZero r] [NeZero ùì°] in
lemma fin_‚Ñì_add_one_lt_r {h_‚Ñì_add_R_rate : ‚Ñì + ùì° < r} (i : Fin (‚Ñì + 1))
    : i.val < r

theorem completeness [DecidableEq Œ±] [SelectableType Œ±] {s}
    (leaf_data_tree : LeafData Œ± s) (idx : BinaryTree.SkeletonLeafIndex s)
    (preexisting_cache : (spec Œ±).QueryCache) :
    (((do
      let cache ‚Üê buildMerkleTree leaf_data_tree
      let proof := generateProof cache idx
      let _ ‚Üê verifyProof idx (leaf_data_tree.get idx) (cache.getRootValue) proof
      ).simulateQ (randomOracle)).run preexisting_cache).neverFails

lemma mul_by_2_def {s : Finset ‚Ñï} :
    mul_by_2 s = s.map ‚ü®fun n => 2 * n, by {
      intro a b
      simp
    }‚ü©

lemma forwardRange_succ_right_ne_empty (n : ‚Ñï) (r : Fin (n - 1)) (l : Fin (r.val + 1)) :
  forwardRange n ‚ü®r + 1, by omega‚ü© ‚ü®l, by simp only; omega‚ü© ‚â† []

lemma out_of_dom_smpl_1
  {Œ¥ l : ‚Ñù‚â•0} {s : ‚Ñï} {f : Œπ ‚Üí F} {degree : ‚Ñï} {œÜ : Œπ ‚Ü™ F}
  (C : Set (Œπ ‚Üí F)) (hC : C = code œÜ degree)
  (h_decodable : listDecodable C Œ¥ l)
  (h_nonempty : Nonempty (domainComplement œÜ)) :
  listDecodingCollisionProbability œÜ f Œ¥ s degree h_nonempty ‚â§
    ((l * (l-1) / 2)) * ((degree - 1) / (Fintype.card F - Fintype.card Œπ))^s

theorem findIdxRev?_eq_none {cond} {as : Array Œ±} (h : ‚àÄ i, (hi : i < as.size) ‚Üí ¬¨ cond as[i]) :
  findIdxRev? cond as = none

lemma erase_odd_def {s : Finset ‚Ñï} :
    erase_odd s = s.filter Even

@[simp]
theorem add_accepts_iff : (add a b c).accepts x ‚Üî x c = x a + x b

lemma sup_eq_of_le_of_reach {Œ± Œ≤ : Type} [SemilatticeSup Œ≤] [OrderBot Œ≤] {s : Finset Œ±} {f : Œ± ‚Üí Œ≤}
      (x : Œ±) {y : Œ≤} (h : x ‚àà s) :
    f x = y ‚Üí
    (‚àÄ x ‚àà s, f x ‚â§ y) ‚Üí
    s.sup f = y

Nat.cast_pow in Mathlib.Data.Nat.Cast.Basic

lemma eq_iff_eq_all_getBits {n m : ‚Ñï} : n = m ‚Üî ‚àÄ k, getBit k n = getBit k m

lemma folding_preserves_listdecoding_base_ne_subset
  {S : Finset Œπ} {k m : ‚Ñï} (hm : 1 ‚â§ m) {œÜ : Œπ ‚Ü™ F} [Smooth œÜ] {Œ¥ : ‚Ñù‚â•0}
  {S_0 : Finset (indexPowT S œÜ 0)} {S_1 : Finset (indexPowT S œÜ 1)}
  {œÜ_0 : (indexPowT S œÜ 0) ‚Ü™ F} {œÜ_1 : (indexPowT S œÜ 1) ‚Ü™ F}
  [‚àÄ i : ‚Ñï, Fintype (indexPowT S œÜ i)] [‚àÄ i : ‚Ñï, DecidableEq (indexPowT S œÜ i)]
  [Smooth œÜ_0] [Smooth œÜ_1]
  [h : ‚àÄ {f : (indexPowT S œÜ 0) ‚Üí F}, DecidableBlockDisagreement 0 k f S_0 œÜ_0]
  [h : ‚àÄ {f : (indexPowT S œÜ 1) ‚Üí F}, DecidableBlockDisagreement 1 k f S_1 œÜ_1]
  [‚àÄ i : ‚Ñï, Neg (indexPowT S œÜ i)]
  {C : Set ((indexPowT S œÜ 0) ‚Üí F)} (hcode : C = smoothCode œÜ_0 m)
  (C' : Set ((indexPowT S œÜ 1) ‚Üí F)) (hcode' : C' = smoothCode œÜ_1 (m-1))
  {BStar : (Set (indexPowT S œÜ 1 ‚Üí F)) ‚Üí ‚Ñï ‚Üí ‚Ñù‚â•0}
  {errStar : (Set (indexPowT S œÜ 1 ‚Üí F)) ‚Üí ‚Ñï ‚Üí ‚Ñù‚â•0 ‚Üí ‚Ñù‚â•0} :
    Pr_{let Œ± ‚Üê$·µñ F}[ ‚àÄ { f : (indexPowT S œÜ 0) ‚Üí F} (hŒ¥Le: Œ¥ ‚â§ 1 - (BStar C' 2)),
                      let listBlock : Set ((indexPowT S œÜ 0) ‚Üí F) := Œõ·µ£(0, k, f, S_0, C, hcode, Œ¥)
                      let vec_Œ± : Fin 1 ‚Üí F := (fun _ : Fin 1 => Œ±)
                      let foldSet := fold_k_set listBlock vec_Œ± hm
                      let fold := fold_k f vec_Œ± hm
                      let listBlock' : Set ((indexPowT S œÜ 1) ‚Üí F)
                        := Œõ·µ£(1, k, fold, S_1, C', hcode', Œ¥)
                      ¬¨ (listBlock' ‚äÜ foldSet)
                    ] < errStar C' 2 Œ¥

theorem decoder_mem_impl_dist
  {k r D e : ‚Ñï}
  (h_e : e ‚â§ n - Real.sqrt (k * n))
  {œâs : Fin n ‚Ü™ F}
  {f : Fin n ‚Üí F}
  {p : F[X]}
  (h_in : p ‚àà decoder k r D e œâs f)
  :
  Œî‚ÇÄ(f, p.eval ‚àò œâs) ‚â§ e

Fin.append_right in Mathlib.Data.Fin.Tuple.Basic

theorem non_zero_map [LawfulBEq R] (f : R ‚Üí R) (hf : ‚àÄ r, f r = 0 ‚Üí r = 0) (p : UniPoly R) :
  let fp := UniPoly.mk (p.map f);
  p.trim = p ‚Üí fp.trim = fp

theorem ZMod.blub :
    ‚àÄ {n q c : ‚Ñï} (a : ZMod n), (decide (n ‚â• 2) = true) ‚Üí (decide (c < n) = true) ‚Üí
      (decide (c ‚â† 1) = true) ‚Üí IsNat (a ^ ((n - 1) / q)) c ‚Üí a ^ ((n - 1) / q) ‚â† 1

theorem Nat.shiftRight_lo_mod_2_pow_hi_shiftLeft_lo (n hi_len lo_len : ‚Ñï)
  (h_n : n < 2 ^ (hi_len + lo_len)) :
  (((n >>> lo_len) % (2 ^ hi_len)) <<< lo_len) = (n - n % 2 ^ lo_len)
</all_available_lemmas>

<local_ctx>
import ArkLib.Data.FieldTheory.AdditiveNTT.NovelPolynomialBasis

import Mathlib.Tactic

import Mathlib.Data.Finsupp.Defs

import Mathlib.LinearAlgebra.LinearIndependent.Defs

open Polynomial AdditiveNTT Module

namespace AdditiveNTT

variable {r : ‚Ñï} [NeZero r]

variable {L : Type u} [Field L] [Fintype L] [DecidableEq L]

variable (ùîΩq : Type u) [Field ùîΩq] [Fintype ùîΩq] [DecidableEq ùîΩq]
  [h_Fq_char_prime : Fact (Nat.Prime (ringChar ùîΩq))] [hF‚ÇÇ : Fact (Fintype.card ùîΩq = 2)]

variable [Algebra ùîΩq L]

variable (Œ≤ : Fin r ‚Üí L) [hŒ≤_lin_indep : Fact (LinearIndependent ùîΩq Œ≤)]
  [h_Œ≤‚ÇÄ_eq_1 : Fact (Œ≤ 0 = 1)]

variable {‚Ñì R_rate : ‚Ñï} (h_‚Ñì_add_R_rate : ‚Ñì + R_rate < r)-- ‚Ñì ‚àà {1, ..., r-1}

section IntermediateStructures

noncomputable def qMap (i : Fin r) : L[X] :=
  let constMultiplier := ((W ùîΩq Œ≤ i).eval (Œ≤ i))^(Fintype.card ùîΩq)
    / ((W ùîΩq Œ≤ (i + 1)).eval (Œ≤ (i + 1)))
  C constMultiplier * ‚àè c: ùîΩq, (X - C (algebraMap ùîΩq L c))

noncomputable def qCompositionChain (i : Fin r) : L[X] :=
  match i with
  | ‚ü®0, _‚ü© => X
  | ‚ü®k + 1, h_k_add_1‚ü© => (qMap ùîΩq Œ≤ ‚ü®k, by admit /- proof elided -/
  ‚ü©).comp (qCompositionChain ‚ü®k, by admit /- proof elided -/
  ‚ü©)
</local_ctx>

<target_theorem>
lemma normalizedW_eq_qMap_composition (‚Ñì R_rate : ‚Ñï) (i : Fin r) :
    normalizedW ùîΩq Œ≤ i = qCompositionChain ùîΩq Œ≤ (‚Ñì:=‚Ñì) (R_rate:=R_rate) i :=
</target_theorem>

