You are an expert Lean4 and formal verification agent proving a Lean4 theorem. Your output **must** strictly adhere to the specified format.

### Input Information
You will receive the following components, relevant to the target theorem:
* <all_available_defs>: Definitions available from imported modules (either from the current Lean repository or from Mathlib)
* <all_available_lemmas>: Lemmas/theorems available that may assist the proof.
* <local_ctx>...</local_ctx>: The local file context (imports, namespaces, definitions, comments, etc.) from the top of the file up to‚Äîbut not including‚Äîthe target theorem or any previously defined local lemmas/theorems.
* <target_theorem>...</target_theorem>: The target theorem statement, ending with `:=`.

**Notes**
1. Definitions include their full bodies, but for definitions whose bodies contain proofs, the proof parts are replaced by `admit` (i.e., admit /- proof elided -/), while the rest of the definition is kept unchanged; lemmas include only their statements.
2. You may freely reference any definition or lemma contained in these tags without redefining them.
3. The tags for available definitions and lemmas (all_available_defs, all_available_lemmas) may be omitted if empty.

### Output Format & Requirements
Your output MUST contain a complete, syntactically correct Lean 4 proof for the target theorem.

**Strict Output Structure:**
<reasoning> 
...
</reasoning> 

<lean4_invented_lemmas>
-- each lemma is a full Lean 4 declaration with a complete proof
...
</lean4_invented_lemmas>

<lean4_proof>
-- Lean 4 proof body of the target theorem
...
</lean4_proof>

**Requirements:**
1. <reasoning> and <lean4_invented_lemmas> are OPTIONAL. Include them only if they aid proof construction.
2. <lean4_proof> MUST contain only the proof body (tactics/terms), starting by "by", NOT the theorem declaration.
3. <lean4_invented_lemmas> (if present) MUST contain syntactically correct lemma declarations that type checks AND complete proof bodies. Defining a lemma using `axiom` is NOT allowed.
4. <reasoning> contains high-level proof planning.
5. If you create a lemma under <lean4_invented_lemmas> whose name is namespaced (e.g., X.Y.Z), you MUST always refer to it using its fully qualified name. Do NOT rely on shortened names. For example, write rw [X.Y.Z], not rw [Z] for invented lemmas.
6. All Lean 4 code MUST be syntactically correct. No `sorry`, `admit`, or non-Lean text. Comments allowed using `--` or `/- ... -/`.
7. Follow the tags and structure EXACTLY. No extra text before, between, or after the sections.
8. Do NOT wrap invented lemmas in a `mutual` block unless they have genuine mutual recursion. Declare each lemma independently.

### Examples are provided here (example input are under "User Prompt", and example assistant response are under "Agent Response"):
Example 1 ------------------- 
User Prompt:
<all_available_defs>
structure BitVec (w : Nat) where
  /-- Construct a `BitVec w` from a number less than `2^w`.
  O(1), because we use `Fin` as the internal representation of a bitvector. -/
  ofFin ::

  /-- Interpret a bitvector as a number less than `2^w`.
  O(1), because we use `Fin` as the internal representation of a bitvector. -/
  toFin : Fin (hPow 2 w)
</all_available_defs>

<all_available_lemmas>
theorem List.getElem_append_left{Œ± : Type u_1} {l‚ÇÅ l‚ÇÇ : List Œ±} {i : Nat} (hn : i < l‚ÇÅ.length) : (l‚ÇÅ ++ l‚ÇÇ)[i] = l‚ÇÅ[i]
theorem getElem_eq_testBit_toNat (x : BitVec w) (i : Nat) (h : i < w) :
  x[i] = x.toNat.testBit i := rfl
@[simp, grind =] theorem toNat_cons (b : Bool) (x : BitVec w) :
    (cons b x).toNat = (b.toNat <<< w) ||| x.toNat
@[simp, grind =] theorem getLsbD_of_ge (x : BitVec w) (i : Nat) (ge : w ‚â§ i) : getLsbD x i = false
theorem testBit_toNat (x : BitVec w) : x.toNat.testBit i = x.getLsbD i
</all_available_lemmas>

<local_ctx>
import Mathlib.Computability.NFA
import Mathlib.Data.FinEnum
import Mathlib.Data.Rel
import Mathlib.Data.Vector.Basic
import Blase.AutoStructs.ForLean

open Set
open Mathlib
open SetRel

-- this is better because card is defeq to n
instance (Œ± : Type) : Inter (Language Œ±) := ‚ü®Set.inter‚ü©
instance (Œ± : Type) : Union (Language Œ±) := ‚ü®Set.union‚ü©

/--
The set of `n`-tuples of bit vectors of an arbitrary width.
-/
structure BitVecs (n : Nat) where
  w : Nat
  bvs : List.Vector (BitVec w) n

def BitVecs.cast (bvs : BitVecs n) (h : n = n') : BitVecs n' :=
  { w := bvs.w, bvs := h ‚ñ∏ bvs.bvs }

abbrev BitVecs.empty : BitVecs n := ‚ü®0, List.Vector.replicate n .nil‚ü©
abbrev BitVecs.singleton {w : Nat} (bv : BitVec w) : BitVecs 1 := ‚ü®w, bv ::·µ• .nil‚ü©
abbrev BitVecs.pair {w : Nat} (bv1 bv2 : BitVec w) : BitVecs 2 := ‚ü®w, bv1 ::·µ• bv2 ::·µ• .nil‚ü©

/--
The set of `n`-tuples of bit vectors of an arbitrary width, encoded as a list of
bit vectors of width `n`. The width of the encoded bit vectors is the length of
the list.
-/
abbrev BitVecs' (n : Nat) := List (BitVec n)

@[simps]
def dec (bvs' : BitVecs' n) : BitVecs n where
  w := bvs'.length
  bvs := List.Vector.ofFn fun k => BitVec.ofFn fun i => bvs'[i].getLsbD k

@[simp]
</local_ctx>

<target_theorem>
lemma dec_snoc n (bvs' : BitVecs' n) (a : BitVec n) :
  dec (bvs' ++ [a]) =
    { w := bvs'.length + 1
      bvs := List.Vector.ofFn fun k =>
        BitVec.cons (a.getLsbD k) ((dec bvs').bvs.get k) } :=
</target_theorem>

Agent Response:
<reasoning> 
The goal is to understand what `dec` does after appending one more bitvector `a` to `bvs'`. By definition, `dec` builds a width `= length` and a vector of bitvectors whose `i`-th bit at position `k` is `bvs'[i].getLsbD k`. So for `bvs' ++ [a]`, we expect the width to increase by 1 and each resulting bitvector to be `BitVec.cons` of the new bit coming from `a`.

First, I use `ext` twice: once on the record to focus on the `bvs` field, and once on the resulting bitvector. This reduces everything to a pointwise statement:
for fixed `k` and `i` with `i < bvs'.length + 1`,
the bit `(bvs' ++ [a])[i].getLsbD k` should match the bit at index `i` of `BitVec.cons (a.getLsbD k) ((dec bvs').bvs.get k)`.

At this point I need a clean description of indexing into `BitVec.cons`: if we have `x : BitVec n`, then `(cons b x)[i]` should give `b` at the new ‚Äúlast‚Äù index `n` and `x[i]` otherwise. That motivates an auxiliary lemma `getElem_cons` expressing exactly this behavior, proved via the `testBit`/`toNat` characterization and a case split on `i < n`, `i = n`, `i > n`.

Using `getElem_cons`, the RHS becomes an `if` on whether `i = bvs'.length`. So I split into cases:
- If `i = bvs'.length`, then `(bvs' ++ [a])[i]` is the appended `a`, so both sides reduce to `a.getLsbD k`.
- If `i ‚â† bvs'.length`, the bound `i < bvs'.length + 1` forces `i < bvs'.length`. Then `(bvs' ++ [a])[i] = bvs'[i]` by `List.getElem_append_left`, and the RHS takes the ‚Äúelse‚Äù branch and likewise gives the bit from `bvs'[i]`. In both subcases, `simp` (plus the definition of `dec`) finishes.

So the whole proof is: `ext` to bit level, unfold `dec` with `simp_all`, rewrite with `getElem_cons`, split on the boundary index `i = length bvs'`, and in the ‚Äú< length‚Äù branch use `List.getElem_append_left` and bounds to line up both sides.
</reasoning> 

<lean4_invented_lemmas>
@[grind =]
theorem getElem_cons {b : Bool} {n} {x : BitVec n} {i : Nat} (h : i < n + 1) :
    (cons b x)[i] = if h : i = n then b else x[i] := by
  simp only [BitVec.getElem_eq_testBit_toNat, BitVec.toNat_cons, Nat.testBit_or]
  rw [Nat.testBit_shiftLeft]
  rcases Nat.lt_trichotomy i n with i_lt_n | i_eq_n | n_lt_i
  ¬∑ have p1 : ¬¨(n ‚â§ i) := by omega
    have p2 : i ‚â† n := by omega
    simp [p1, p2]
  ¬∑ simp only [i_eq_n, ge_iff_le, Nat.le_refl, decide_true, Nat.sub_self, Nat.testBit_zero,
    Bool.true_and, BitVec.testBit_toNat, BitVec.getLsbD_of_ge, Bool.or_false]
    cases b <;> trivial
  ¬∑ have p1 : i ‚â† n := by omega
    have p2 : i - n ‚â† 0 := by omega
    simp [p1, p2, Nat.testBit_bool_toNat]
</lean4_invented_lemmas>

<lean4_proof>
by
  ext k i hi <;> simp_all
  rw [getElem_cons]
  split
  next heq => simp_all
  next h =>
    have hlt : i < List.length bvs' := by simp at hi; omega
    rw [List.getElem_append_left hlt]
    simp
</lean4_proof>

### Your task:
<all_available_defs>
Field in Mathlib.Algebra.Field.Defs
Finset in Mathlib.Data.Finset.Defs
Finset.range in Mathlib.Data.Finset.Range
Polynomial.C in Mathlib.Algebra.Polynomial.Basic
Polynomial.X in Mathlib.Algebra.Polynomial.Basic
AdjoinRoot.instField in Mathlib.RingTheory.AdjoinRoot
Fintype in Mathlib.Data.Fintype.Defs
Fintype.card in Mathlib.Data.Fintype.Card
Irreducible in Mathlib.Algebra.Group.Irreducible.Defs
List in Init.Prelude
List.Vector in Mathlib.Data.Vector.Defs
NeZero in Init.Data.NeZero
Polynomial in Mathlib.Algebra.Polynomial.Basic
AdjoinRoot in Mathlib.RingTheory.AdjoinRoot
AdjoinRoot.of in Mathlib.RingTheory.AdjoinRoot
AdjoinRoot.root in Mathlib.RingTheory.AdjoinRoot
Eq in Init.Prelude
Eq.mp in Init.Core
CharP in Mathlib.Algebra.CharP.Defs
DivisionRing in Mathlib.Algebra.Field.Defs
DivisionSemiring in Mathlib.Algebra.Field.Defs
Finset.Icc in Mathlib.Order.Interval.Finset.Defs
GroupWithZero in Mathlib.Algebra.GroupWithZero.Defs
Nat in Init.Prelude
Ne in Init.Core
Equiv in Mathlib.Logic.Equiv.Defs
Equiv.ofBijective in Mathlib.Logic.Equiv.Defs
Fact in Mathlib.Logic.Basic
Fintype.ofEquiv in Mathlib.Data.Fintype.OfMap
Function.Bijective in Mathlib.Logic.Function.Defs
Function.Injective in Init.Data.Function
Function.Surjective in Init.Data.Function
Polynomial.Monic in Mathlib.Algebra.Polynomial.Degree.Definitions
Polynomial.eval‚ÇÇ in Mathlib.Algebra.Polynomial.Eval.Defs
Prod in Init.Prelude
Semiring in Mathlib.Algebra.Ring.Defs
Fintype.ofFinite in Mathlib.Data.Fintype.EquivFin
List.Vector.cons in Mathlib.Data.Vector.Defs
List.Vector.nil in Mathlib.Data.Vector.Defs
Algebra in Mathlib.Algebra.Algebra.Defs
algebraMap in Mathlib.Algebra.Algebra.Defs
instAlgebra in Mathlib.LinearAlgebra.TensorAlgebra.Basic
RingHom in Mathlib.Algebra.Ring.Hom.Defs
RingHom.id in Mathlib.Algebra.Ring.Hom.Defs
reduceDIte in Lean.Meta.Tactic.Simp.BuiltinSimprocs.Core
CommRing in Mathlib.Algebra.Ring.Defs
PowerBasis in Mathlib.RingTheory.PowerBasis
Fin in Init.Prelude

notation : 10 "GF(" term : 10 ")" => GaloisField term 1

structure TraceMapProperty (F : Type*) [Field F] (u : F) (k : ‚Ñï) : Prop where
  element_trace : ‚àë i ‚àà Finset.range (2 ^ k), u ^ (2 ^ i) = 1
  inverse_trace : ‚àë i ‚àà Finset.range (2 ^ k), (u‚Åª¬π) ^ (2 ^ i) = 1

noncomputable def definingPoly {F : Type*} [instField : Field F] (s : F)
  := X ^ 2 + C s * X + 1

def AlgebraTowerEquiv.symm (e : AlgebraTowerEquiv A B) : AlgebraTowerEquiv B A where
  toRingEquiv := fun i => (e.toRingEquiv i).symm
  commutesLeft' := fun i j h r => by admit /- proof elided -/

structure AlgebraTowerEquiv (A : Œπ ‚Üí Type*) [‚àÄ i, CommSemiring (A i)] [a : AlgebraTower A]
  (B : Œπ ‚Üí Type*) [‚àÄ i, CommSemiring (B i)] [b : AlgebraTower B]
  where
    toRingEquiv : ‚àÄ i, (A i ‚âÉ+* B i)
    commutesLeft' : ‚àÄ (i j : Œπ) (h : i ‚â§ j) (r : A i),
      (b.algebraMap (i:=i) (j:=j) (h:=h)) ((toRingEquiv i) r) =
      (toRingEquiv j) (a.algebraMap (i:=i) (j:=j) (h:=h) r)

structure SpecialElementRelation {F_prev : Type*} [Field F_prev] (t1 : F_prev)
  {F_cur : Type*} [Field F_cur] (u : F_cur) [Algebra F_prev F_cur] : Prop where
    sum_inv_eq : u + u‚Åª¬π = algebraMap F_prev F_cur t1
    h_u_square : u^2 = u * (algebraMap F_prev F_cur t1) + 1

instance irreducible_quadratic_defining_poly_of_traceMap_eq_1
  {F : Type*} [Field F] [Fintype F] [CharP F 2] (s : F) [NeZero s] (k : ‚Ñï)
  (trace_map_prop : TraceMapProperty F s k)
  (fintypeCard : Fintype.card F = 2 ^ (2 ^ k))
  : Irreducible (definingPoly s) :=

instance charP_eq_2_of_add_self_eq_zero {F : Type*} [Field F]
    (sumZeroIffEq : ‚àÄ (x y : F), x + y = 0 ‚Üî x = y) : CharP F 2 :=
  have h_two : (2 : (F)) = 0 := by admit /- proof elided -/

def coeff.{u} {F : Type u} [Semiring F] (f : F[X][Y]) (i j : ‚Ñï) : F := (f.coeff j).coeff i

instance GF_2_fintype : Fintype (GF(2)) := Fintype.ofFinite (GF(2))

@[simp]
def AlgebraTower.toAlgebra {i j : Œπ} (h : i ‚â§ j) : Algebra (A i) (A j) :=
  (AlgebraTower.algebraMap (i:=i) (j:=j) (h:=h)).toAlgebra

instance {i : Fin (n + 1)} : OfNat (evalDomain D i) 1 where
  ofNat := ‚ü®1, one_in_doms D i‚ü©

instance : ‚àÄ i, SelectableType ((pSpecCoreInteraction ùîΩq Œ≤ (œë:=œë)
  (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).Challenge i) := instSelectableTypeChallengeAppend

def getConst (F : Type) [NonBinaryField F] : OracleComp [(pSpec F).Message]‚Çí F[X] :=
  OracleComp.lift
    (by admit /- proof elided -/
    )

def squeezeUnchecked [Permute C] (sponge : DuplexSponge U C) (arr : Array U) :
    DuplexSponge U C √ó Array U :=
  simulateQ' (m := Id) forwardPermutationOracleImpl (squeezeInto sponge arr) (by admit /- proof elided -/
  )

ZeroMemClass in Mathlib.Algebra.Group.Submonoid.Defs

def RoundByRoundOneShot
    (oSpec : OracleSpec Œπ) (StmtIn WitIn : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n) :=
  (m : Fin (n + 1)) ‚Üí StmtIn ‚Üí Transcript m pSpec ‚Üí QueryLog oSpec ‚Üí WitIn

noncomputable def hasMutualCorrAgreement
  (Gen : ProximityGenerator Œπ F) [Fintype Gen.par‚Ñì]
  (BStar : ‚Ñù) (errStar : ‚Ñù ‚Üí ENNReal) :=
    haveI := Gen.Gen_nonempty
    ‚àÄ (f : Gen.par‚Ñì ‚Üí Œπ ‚Üí F) (Œ¥ : ‚Ñù‚â•0) (_hŒ¥ : 0 < Œ¥ ‚àß Œ¥ < 1 - BStar),
    Pr_{let r ‚Üê$·µñ Gen.Gen}[ proximityCondition f Œ¥ r Gen.C ] ‚â§ errStar Œ¥

noncomputable def fold
  {S : Finset Œπ} (œÜ : Œπ ‚Ü™ F) (f : Œπ ‚Üí F) (k : ‚Ñï) (Œ± : F) : indexPow S œÜ k ‚Üí F :=
    fun x => (xPoly f œÜ k x).eval Œ±

Vector in Init.Data.Vector.Basic

instance [VerifierFirst pSpec] : Unique (pSpec.ChallengeIdx) where
  default := ‚ü®0, by admit /- proof elided -/
  ‚ü©
  uniq := fun ‚ü®i, _‚ü© => by admit /- proof elided -/

def deriveTranscriptDSFS {Œπ : Type} {oSpec : OracleSpec Œπ} {StmtIn : Type}
    (stmtIn : StmtIn) (messages : pSpec.Messages) :
    OracleComp (oSpec ++‚Çí duplexSpongeChallengeOracle StmtIn U)
      (CanonicalDuplexSponge U √ó pSpec.FullTranscript) := do
  let sponge ‚Üê liftM (DuplexSponge.start stmtIn)
  deriveTranscriptDSFSAux sponge messages (Fin.last n)

RingHom in Mathlib.Algebra.Ring.Hom.Defs

instance : ‚àÄ i, SelectableType (‚Üë(sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i)) := fun i => sorry

class DCast‚ÇÇ (Œ± : Sort*) (Œ≤ : Œ± ‚Üí Sort*) (Œ≥ : (a : Œ±) ‚Üí Œ≤ a ‚Üí Sort*) [DCast Œ± Œ≤] where
  dcast‚ÇÇ : ‚àÄ {a a' : Œ±} {b : Œ≤ a} {b' : Œ≤ a'},
    (ha : a = a') ‚Üí (dcast ha b = b') ‚Üí Œ≥ a b ‚Üí Œ≥ a' b'
  dcast‚ÇÇ_id : ‚àÄ {a : Œ±} {b : Œ≤ a}, dcast‚ÇÇ (Eq.refl a) dcast_eq = (id : Œ≥ a b ‚Üí Œ≥ a b)

LinearIndependent in Mathlib.LinearAlgebra.LinearIndependent.Defs

@[inline, specialize]
def reduction : Reduction oSpec Statement Unit Statement Unit !p[] where
  prover := prover oSpec Statement
  verifier := verifier oSpec Statement pred

def powNat [Zero T] [One T] [ToNat T] (a : Cayley T) : Nat ‚Üí Cayley T
  | 0        => one  
  | .succ k  => mul a (powNat a k)  

LinearMap.ker in Mathlib.Algebra.Module.Submodule.Ker

@[simp]
def oCtxLens (i : Fin n) : OracleContext.Lens
    (StatementRound R n i.castSucc) (StatementRound R n i.succ) (Simple.StmtIn R) (Simple.StmtOut R)
    (OracleStatement R n deg) (OracleStatement R n deg)
    (Simple.OStmtIn R deg) (Simple.OStmtOut R deg)
    Unit Unit Unit Unit where
  wit := Witness.Lens.trivial
  stmt := oStmtLens R n deg D i

instance {i : ‚Ñï} : IsCyclicWithGen (evalDomain D i) :=

def monomialXY (n m : ‚Ñï) : F ‚Üí‚Çó[F] F[X][Y] where
  toFun t := ‚ü®Finsupp.single m ‚ü®(Finsupp.single n t)‚ü©‚ü©
  map_add' x y := by admit /- proof elided -/

@[reducible, simp]
def relOut : Set (Statement √ó Unit) := Set.univ

@[inline]
def seqCompose {m : ‚Ñï} (Stmt : Fin (m + 1) ‚Üí Type)
    {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (V : (i : Fin m) ‚Üí Verifier oSpec (Stmt i.castSucc) (Stmt i.succ) (pSpec i)) :
    Verifier oSpec (Stmt 0) (Stmt (Fin.last m)) (seqCompose pSpec) := match m with
  | 0 => Verifier.id
  | _ + 1 => append (V 0) (seqCompose (Stmt ‚àò Fin.succ) (fun i => V (Fin.succ i)))

Subgroup.zpowers in Mathlib.Algebra.Group.Subgroup.ZPowers.Basic

private noncomputable def Q (œâs : Fin n ‚Üí F)
  (f : Fin n ‚Üí F) (p : Polynomial F) (e : ‚Ñï) : Polynomial F :=
  p * (E œâs f p e)

Submodule.module in Mathlib.Algebra.Module.Submodule.Defs

Module.Basis.mk in Mathlib.LinearAlgebra.Basis.Basic

instance : Fact (Nat.Prime scalarFieldSize) := ‚ü®ScalarField_is_prime‚ü©

Fin.pred in Init.Data.Fin.Basic

def rbrKnowledgeSoundness (relIn : Set (StmtIn √ó WitIn)) (relOut : Set (StmtOut √ó WitOut))
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    (rbrKnowledgeError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) : Prop :=
  ‚àÉ WitMid : Fin (n + 1) ‚Üí Type,
  ‚àÉ extractor : Extractor.RoundByRound oSpec StmtIn WitIn WitOut pSpec WitMid,
  ‚àÉ kSF : verifier.KnowledgeStateFunction init impl relIn relOut extractor,
  ‚àÄ stmtIn : StmtIn,
  ‚àÄ witIn : WitIn,
  ‚àÄ prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec,
  ‚àÄ i : pSpec.ChallengeIdx,
    [fun ‚ü®transcript, challenge, _proveQueryLog‚ü© =>
      ‚àÉ witMid,
        ¬¨ kSF i.1.castSucc stmtIn transcript
          (extractor.extractMid i.1 stmtIn (transcript.concat challenge) witMid) ‚àß
          kSF i.1.succ stmtIn (transcript.concat challenge) witMid
    | do
      (simulateQ (impl ++‚Çõ‚Çí challengeQueryImpl : QueryImpl _ (StateT œÉ ProbComp))
        (do
          let ‚ü®‚ü®transcript, _‚ü©, proveQueryLog‚ü© ‚Üê prover.runWithLogToRound i.1.castSucc stmtIn witIn
          let challenge ‚Üê liftComp (pSpec.getChallenge i) _
          return (transcript, challenge, proveQueryLog))).run' (‚Üê init)] ‚â§
      rbrKnowledgeError i

def binding (scheme : Scheme oSpec Data Randomness Commitment pSpec)
    (bindingError : ‚Ñù‚â•0) : Prop :=
  ‚àÄ AuxState : Type,
  ‚àÄ adversary : BindingAdversary oSpec Data Commitment AuxState,
  ‚àÄ prover : Prover oSpec (Commitment √ó O.Query √ó O.Response) AuxState Bool Unit pSpec,
    False

def ValidChurchNat : Type :=
  { f : ChurchNat ‚Ñï // ‚àÉ n, ‚àÄ g x, f g x = Nat.iterate g n x }

def capacitySegmentDupPermInv : Prop :=
  let ‚ü®baseTrace, _‚ü© := removeRedundantEntryDS trace
  ‚àÉ j : Fin baseTrace.length, ‚àÉ capSeg : Vector U SpongeSize.C,
    (‚àÉ stateOut stateIn, baseTrace[j] = ‚ü®.inr .Bwd, stateOut, stateIn‚ü© ‚àß
      stateIn.capacitySegment = capSeg) ‚àß
      (
        (‚àÉ j' < j, ‚àÉ stmt', baseTrace[j'] = ‚ü®.inl (), stmt', capSeg‚ü©) ‚à®
        (‚àÉ j' < j, ‚àÉ stateIn1 stateOut1, baseTrace[j'] = ‚ü®.inr .Fwd, stateIn1, stateOut1‚ü© ‚àß
          stateOut1.capacitySegment = capSeg) ‚à®
        (‚àÉ j' < j, ‚àÉ stateIn2 stateOut2, baseTrace[j'] = ‚ü®.inr .Bwd, stateOut2, stateIn2‚ü© ‚àß
          stateIn2.capacitySegment = capSeg) ‚à®
        (‚àÉ j' ‚â§ j, ‚àÉ stateIn3 stateOut3, baseTrace[j'] = ‚ü®.inr .Fwd, stateIn3, stateOut3‚ü© ‚àß
          stateIn3.capacitySegment = capSeg) ‚à®
        (‚àÉ j' ‚â§ j, ‚àÉ stateIn4 stateOut4, baseTrace[j'] = ‚ü®.inr .Bwd, stateOut4, stateIn4‚ü© ‚àß
          stateOut4.capacitySegment = capSeg)
      )

alias E_pinv := capacitySegmentDupPermInv

instance {i : Fin ‚Ñì} : ‚àÄ j, SelectableType ((pSpecCommit ùîΩq Œ≤
  (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i).Challenge j)
  | ‚ü®0, hj‚ü© => by admit /- proof elided -/

HMul.hMul in Init.Prelude

structure Gate (ùì° : Type*) (numWires : ‚Ñï) extends Selector ùì°, WireIndices numWires
deriving DecidableEq

def Prover.addSalt (P : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec)
    (saltComp : (i : pSpec.MessageIdx) ‚Üí P.PrvState i.1.castSucc ‚Üí OracleComp oSpec (Salt i)) :
  Prover oSpec StmtIn WitIn StmtOut WitOut (pSpec.addSalt Salt) where
  PrvState := P.PrvState
  input := P.input
  sendMessage := fun i st => by admit /- proof elided -/

@[reducible, simp] def StmtOut := Query OStatement

Matrix.col in Mathlib.LinearAlgebra.Matrix.Defs

RatFunc.eval in Mathlib.FieldTheory.RatFunc.AsPolynomial

def StateRestoration.Soundness (oSpec : OracleSpec Œπ) (StmtIn : Type)
    {n : ‚Ñï} (pSpec : ProtocolSpec n) :=
  OracleComp (oSpec ++‚Çí (srChallengeOracle StmtIn pSpec)) (StmtIn √ó pSpec.Messages)

def outputRelation (cond : ‚àë i, (s i).1 ‚â§ n) [DecidableEq F] (Œ¥ : ‚Ñù‚â•0) :
    Set
      (
        (FinalStatement F k √ó ‚àÄ j, FinalOracleStatement D x s j) √ó
        Witness F s d (Fin.last (k + 1))
      )
  := FinalFoldPhase.outputRelation D x s d cond Œ¥

Module.Basis in Mathlib.LinearAlgebra.Basis.Defs

def getHighBits (numLowBits : ‚Ñï) (n : ‚Ñï) : ‚Ñï :=
  (getHighBits_no_shl numLowBits n) <<< numLowBits

def internalLinearLayer (state : Vector KoalaBear.Field params.width) :
    Vector KoalaBear.Field params.width :=
  
  
  let sumAll := state.foldl (fun acc x => acc + x) 0

  
  
  state.zipWith (fun s d => sumAll + d * s) params.internalDiagVectors

def InternalData.EquivIndexFun {Œ± : Type} (s : Skeleton) :
    InternalData Œ± s ‚âÉ (SkeletonInternalIndex s ‚Üí Œ±) where
  toFun := fun tree idx => tree.get idx
  invFun := fun f => InternalData.ofFun s f
  left_inv := by admit /- proof elided -/

def LeafData.map {Œ± Œ≤ : Type} (f : Œ± ‚Üí Œ≤) {s : Skeleton}
    (tree : LeafData Œ± s) : LeafData Œ≤ s :=
  match tree with
  | LeafData.leaf value => LeafData.leaf (f value)
  | LeafData.internal left right =>
    LeafData.internal (left.map f) (right.map f)

EquivLike in Mathlib.Data.FunLike.Equiv

instance {pSpec : ProtocolSpec n} : CoeHead (MessageIdx pSpec) (Fin n) where
  coe := fun i => i.1

instance : SMul R (UniPoly R) := ‚ü®UniPoly.smul‚ü©

def FinalSumcheckWit := fun (m : Fin (1 + 1)) =>
 match m with
 | ‚ü®0, _‚ü© => Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì)
 | ‚ü®1, _‚ü© => Unit

MonomialOrder in Mathlib.Data.Finsupp.MonomialOrder

finSumFinEquiv in Mathlib.Logic.Equiv.Fin.Basic

@[reducible, simp]
def relOut : (StmtOut OStatement √ó ‚àÄ i, OStmtOut OStatement i) ‚Üí WitOut ‚Üí Prop :=
  fun ‚ü®‚ü®q, r‚ü©, oStmt‚ü© () => answer (oStmt 0) q = r

noncomputable def finToSDomain (i : Fin r) (h_i : i < ‚Ñì + R_rate)
  (idx : Fin (2 ^ (‚Ñì + R_rate - i.val))) :
  sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i :=

private def k [Zero F] (B : Finset (Fin n ‚Üí F)) : ‚Ñö :=
  (1 : ‚Ñö) / n * ‚àë i, K B i 0

def Reduction.duplexSpongeFiatShamir (R : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec) :
    NonInteractiveReduction (‚àÄ i, pSpec.Message i) (oSpec ++‚Çí duplexSpongeChallengeOracle StmtIn U)
      StmtIn WitIn StmtOut WitOut where
  prover := R.prover.duplexSpongeFiatShamir
  verifier := R.verifier.duplexSpongeFiatShamir

noncomputable def errorBound (Œ¥ : ‚Ñù‚â•0) (deg : ‚Ñï) (domain : Œπ ‚Ü™ F) : ‚Ñù‚â•0 :=
  letI œÅ : ‚Ñù‚â•0 := œÅ (ReedSolomon.code domain deg)
  if Œ¥ ‚àà Set.Ioc 0 ((1 - œÅ)/2)
  then Fintype.card Œπ / Fintype.card F
  else if Œ¥ ‚àà Set.Ioo ((1 - œÅ)/2) (1 - œÅ.sqrt)
       then letI m := min (1 - œÅ.sqrt - Œ¥) (œÅ.sqrt / 20)
            ‚ü®(deg ^ 2 : ‚Ñù‚â•0) / ((2 * m) ^ 7 * (Fintype.card F : ‚Ñù)), by admit /- proof elided -/
            ‚ü©
       else 0

@[reducible]
def Set.language {Œ± Œ≤} (rel : Set (Œ± √ó Œ≤)) : Set Œ± :=
  Prod.fst '' rel

@[inline] def pred : AssocNat ‚Üí AssocNat :=
  fun a => match a.toNat with
  | 0 => zero
  | Nat.succ k => ofNat k

Option in Init.Prelude

instance instOI‚ÇÇ : ‚àÄ i, OracleInterface
    ((‚ü®!v[.P_to_V], !v[R‚¶É‚â§ deg‚¶Ñ[X]]‚ü© ++‚Çö !p[] ++‚Çö ‚ü®!v[.V_to_P], !v[R]‚ü©).Message i) :=
  instOracleInterfaceMessageAppend

PFunctor in Mathlib.Data.PFunctor.Univariate.Basic

AdjoinRoot.powerBasis' in Mathlib.RingTheory.AdjoinRoot

noncomputable def listDecodingCollisionProbability
  (œÜ : Œπ ‚Ü™ F) (f : Œπ ‚Üí F) (Œ¥ : ‚Ñù) (s degree : ‚Ñï)
  (h_nonempty : Nonempty (domainComplement œÜ)) : ENNReal :=
  Pr_{let r ‚Üê$·µñ (Fin s ‚Üí domainComplement œÜ)}[ ‚àÉ (u u' : code œÜ degree),
                                    u.val ‚â† u'.val ‚àß
                                    u.val ‚àà relHammingBall (code œÜ degree) f Œ¥ ‚àß
                                    u'.val ‚àà relHammingBall (code œÜ degree) f Œ¥ ‚àß
                                    ‚àÄ i : Fin s,
                                    let uPoly := decodeLT u
                                    let uPoly' := decodeLT u'
                                    (uPoly : F[X]).eval (r i).1
                                      = (uPoly' : F[X]).eval (r i).1
                                    ]

instance instDCast‚ÇÇ : DCast‚ÇÇ Nat ProtocolSpec (fun _ pSpec => ChallengeIdx pSpec) where
  dcast‚ÇÇ h := ChallengeIdx.cast h
  dcast‚ÇÇ_id := cast_id

@[simp]
abbrev Statement.AfterFirstSumcheck : Type :=
  FirstSumcheckChallenge R pp √ó Statement.AfterFirstChallenge R pp

def join_via_add_smul {k : ‚Ñï} (h_pos : k > 0) (hi_btf lo_btf : BTField (k - 1)) :
    BTField k :=

OracleSpec.QueryCache in VCVio.OracleComp.QueryTracking.Structures

def snd (T : (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).Transcript k) : pSpec‚ÇÇ.Transcript ‚ü®k - m, by admit /- proof elided -/
‚ü© :=
  if hk : k ‚â§ m then
    fun i => Fin.elim0 (by admit /- proof elided -/
    )
  else
    fun i => sorry

def existPriorSameQuery (log : QueryLog spec) (idx : Fin log.length) : Prop :=
  ‚àÉ j' < idx, log[j'] = log[idx]

@[reducible, simp]
def OracleContext.Lens.IsComplete {OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut : Type}
    {Outer_Œπ‚Çõ·µ¢ : Type} {OuterOStmtIn : Outer_Œπ‚Çõ·µ¢ ‚Üí Type} [‚àÄ i, OracleInterface (OuterOStmtIn i)]
    {Outer_Œπ‚Çõ‚Çí : Type} {OuterOStmtOut : Outer_Œπ‚Çõ‚Çí ‚Üí Type} [‚àÄ i, OracleInterface (OuterOStmtOut i)]
    {Inner_Œπ‚Çõ·µ¢ : Type} {InnerOStmtIn : Inner_Œπ‚Çõ·µ¢ ‚Üí Type} [‚àÄ i, OracleInterface (InnerOStmtIn i)]
    {Inner_Œπ‚Çõ‚Çí : Type} {InnerOStmtOut : Inner_Œπ‚Çõ‚Çí ‚Üí Type} [‚àÄ i, OracleInterface (InnerOStmtOut i)]
    {OuterWitIn OuterWitOut InnerWitIn InnerWitOut : Type}
    (outerRelIn : Set ((OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i)) √ó OuterWitIn))
    (innerRelIn : Set ((InnerStmtIn √ó (‚àÄ i, InnerOStmtIn i)) √ó InnerWitIn))
    (outerRelOut : Set ((OuterStmtOut √ó (‚àÄ i, OuterOStmtOut i)) √ó OuterWitOut))
    (innerRelOut : Set ((InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i)) √ó InnerWitOut))
    (compat : (OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i)) √ó OuterWitIn ‚Üí
              (InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i)) √ó InnerWitOut ‚Üí Prop)
    (lens : OracleContext.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                                    OuterOStmtIn OuterOStmtOut InnerOStmtIn InnerOStmtOut
                                    OuterWitIn OuterWitOut InnerWitIn InnerWitOut) :=
  Context.Lens.IsComplete outerRelIn innerRelIn outerRelOut innerRelOut compat lens.toContext

@[reducible, simp]
def MessageIdx (pSpec : ProtocolSpec n) :=
  {i : Fin n // pSpec.dir i = Direction.P_to_V}

@[ext]
class OracleInterface (Message : Type u) where
  Query : Type v
  Response : Type w
  answer : Message ‚Üí Query ‚Üí Response

@[reducible]
def pSpecFoldRelay : ProtocolSpec (2) :=
  pSpecFold (L:=L) ++‚Çö pSpecRelay

def finSigmaFinEquiv' {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} : (i : Fin m) √ó Fin (n i) ‚âÉ Fin (‚àë i, n i) :=
  .ofRightInverseOfCardLE (le_of_eq <| by admit /- proof elided -/
  )
    (fun ‚ü®i, j‚ü© => ‚ü®‚àë k, n (Fin.castLE i.isLt.le k) + j, by admit /- proof elided -/
          ‚ü©)
    (fun k => ‚ü®k.divSum, k.modSum‚ü©)
    (by admit /- proof elided -/
        )

def take (j : Fin (n + 1)) (challenges : Challenges pSpec) : ChallengesUpTo j pSpec :=

def findFinIdx (p : Œ± ‚Üí Bool) (l : List Œ±) : Fin (l.length + 1) :=
  ‚ü®List.findIdx' p l,
    Nat.lt_succ_of_le (by admit /- proof elided -/
    )‚ü©

@[simps]
def refl (pSpec : ProtocolSpec n) : Equiv pSpec pSpec where
  round_eq := rfl
  dir_eq := fun _ => rfl
  typeEquiv := fun _ => _root_.Equiv.refl _

noncomputable def intermediateNormVpoly
    
    (i: Fin (‚Ñì+1)) (k : Fin (‚Ñì - i + 1)) : L[X] :=
  
  Fin.foldl (n:=k) (fun acc j =>
    (qMap ùîΩq Œ≤ ‚ü®(i : ‚Ñï) + (j : ‚Ñï), by admit /- proof elided -/
    ‚ü©).comp acc) (X)

def Function.extendDomain {Œ± Œ≤ : Type*} [DecidableEq Œ±] [Zero Œ≤] {s : Finset Œ±}
    (f : (x : Œ±) ‚Üí (x ‚àà s) ‚Üí Œ≤) : Œ± ‚Üí Œ≤ :=
  fun x ‚Ü¶ if hx : x ‚àà s then f x hx else 0

instance :
    ‚àÄ i, OracleInterface
          ((pSpecFold D x k s ++‚Çö FinalFoldPhase.pSpec F ++‚Çö QueryRound.pSpec D x l).Message i) :=
  instOracleInterfaceMessageAppend

class VCVCompatible (Œ± : Type*) extends Fintype Œ±, Inhabited Œ± where
  [type_decidableEq' : DecidableEq Œ±]

Set.PairwiseDisjoint in Mathlib.Data.Set.Pairwise.Basic

noncomputable def getFoldProverFinalOutput (i : Fin ‚Ñì)
    (finalPrvState : foldPrvState ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      i 2 (Context := Context)) :
  ((Statement (L := L) Context i.succ √ó ((j : Fin (toOutCodewordsCount ‚Ñì œë i.castSucc)) ‚Üí
    OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j))
      √ó Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ) :=

@[inline, specialize]
def OracleVerifier.run [O‚Çò : ‚àÄ i, OracleInterface (pSpec.Message i)]
    (stmt : StmtIn) (oStmtIn : ‚àÄ i, OStmtIn i) (transcript : FullTranscript pSpec)
    (verifier : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec) :
      OracleComp oSpec (StmtOut √ó (‚àÄ i, OStmtOut i)) := do
  let f := OracleInterface.simOracle2 oSpec oStmtIn transcript.messages
  let stmtOut ‚Üê simulateQ f (verifier.verify stmt transcript.challenges)
  let oStmtOut : ‚àÄ i, OStmtOut i := fun i => match h : verifier.embed i with
  | .inl j => by admit /- proof elided -/
  | .inr j => by admit /- proof elided -/

DFunLike in Mathlib.Data.FunLike.Basic

@[inline, specialize]
def Prover.runToRoundFS [‚àÄ i, VCVCompatible (pSpec.Challenge i)] (i : Fin (n + 1))
    (stmt : StmtIn) (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec)
    (state : prover.PrvState 0) :
        OracleComp (oSpec ++‚Çí fsChallengeOracle StmtIn pSpec)
          (pSpec.MessagesUpTo i √ó StmtIn √ó prover.PrvState i) :=
  Fin.induction
    (pure ‚ü®default, stmt, state‚ü©)
    prover.processRoundFS
    i

Classical.typeDecidableEq in Init.Classical

noncomputable def sDomain_basis (i : Fin r) (h_i : i < ‚Ñì + R_rate) :
    Basis (Fin (‚Ñì + R_rate - i)) ùîΩq (
      sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i) :=

def nonDoomedFoldingProp (i : Fin (‚Ñì + 1)) (challenges : Fin i ‚Üí L)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i j)
    : Prop :=
  let oracleFoldingConsistency := oracleFoldingConsistencyProp ùîΩq Œ≤ i (challenges := challenges)
    (oStmt := oStmt)
  let foldingBadEventExists := badEventExistsProp ùîΩq Œ≤ i (challenges := challenges)
    (oStmt := oStmt)
  oracleFoldingConsistency ‚à® foldingBadEventExists

Array.range in Init.Data.Array.Basic

Vector.take in Init.Data.Vector.Basic

noncomputable def polyFold
  [DecidableEq F] (fPoly : Polynomial F)
  (k : ‚Ñï) (hk0 : 0 < k) (hkfin : k < Fintype.card F)
  (r : F) : Polynomial F :=
    let qPoly : Polynomial F := Polynomial.X ^ k
    let hdeg_q_min : qPoly.natDegree > 0 := sorry
    let hdeg_q_max : qPoly.natDegree < Fintype.card F := sorry
  
    let Q : MvPolynomial (Fin 2) F := polyQ fPoly qPoly
    MvPolynomial.eval‚ÇÇHom
      (Polynomial.C : F ‚Üí+* Polynomial F)
      (fun i : Fin 2 => if i = 0 then Polynomial.X else Polynomial.C r) Q

noncomputable def fold_k
  {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F} {k m : ‚Ñï}
  [‚àÄ j : ‚Ñï, Neg (indexPowT S œÜ j)]
  (f : (indexPowT S œÜ 0) ‚Üí F) (Œ±s : Fin k ‚Üí F) (_hk : k ‚â§ m): indexPowT S œÜ k ‚Üí F :=
  fold_k_core f k Œ±s

noncomputable def genRSC
  [Nonempty F] (par‚Ñì : Type) [h‚Ñì : Fintype par‚Ñì] (œÜ : Œπ ‚Ü™ F) [Smooth œÜ]
  (m : ‚Ñï) (exp : par‚Ñì ‚Ü™ ‚Ñï) : ProximityGenerator Œπ F :=
    let r := LinearCode.rate (smoothCode œÜ m);
    { C := smoothCode œÜ m,
      par‚Ñì := par‚Ñì,
      h‚Ñì := h‚Ñì,
      rate := r,
      Gen := Finset.image (fun r => (fun j => r ^ (exp j))) (Finset.univ : Finset F),
      Gen_nonempty := by admit /- proof elided -/

instance : ‚àÄ j, OracleInterface ((pSpecLastBlock (L:=L) (œë:=œë)).Message j) :=
  instOracleInterfaceMessageSeqCompose

def Verifier.fiatShamir (V : Verifier oSpec StmtIn StmtOut pSpec) :
    NonInteractiveVerifier (‚àÄ i, pSpec.Message i) (oSpec ++‚Çí fsChallengeOracle StmtIn pSpec)
      StmtIn StmtOut where
  verify := fun stmtIn proof => do
    let messages : pSpec.Messages := proof 0
    let transcript ‚Üê messages.deriveTranscriptFS stmtIn
    V.verify stmtIn transcript

def evalBivar
  (Q : MvPolynomial (Fin 2) F) (a b : F) : F := MvPolynomial.eval (Fin.cases a (fun _ ‚Ü¶ b)) Q

@[inline, specialize]
def oracleVerifier : OracleVerifier oSpec
    Statement OStatement Statement (OStatement ‚äï·µ• (fun _ : Fin 1 => Witness))
    (oraclePSpec Witness) where
  verify := fun stmt _ => pure stmt
  embed := .sumMap (.refl _)
    <| Equiv.toEmbedding
    <|.symm (subtypeUnivEquiv (by admit /- proof elided -/
    ))
  hEq := by admit /- proof elided -/

@[reducible]
def MlPoly (R : Type*) (n : ‚Ñï) := Vector R (2 ^ n) 

class Serde (Œ± : Type u) (Œ≤ : Type v) extends Serialize Œ± Œ≤, DeserializeOption Œ± Œ≤

def Cache.leaves (n : ‚Ñï) (cache : Cache Œ± (n + 1)) :
    List.Vector Œ± (2 ^ (n + 1)) := cache (Fin.last _)

instance : ‚àÄ i, OracleInterface ((default : ProtocolSpec 0).Message i) := fun ‚ü®i, _‚ü© => Fin.elim0 i

context in Examples.FrankingProtocol

Iff in Init.Core

Nat.reduceBeqDiff in Lean.Meta.Tactic.Simp.BuiltinSimprocs.Nat

CoeHead in Init.Coe

def domainEmb {i : ‚Ñï} : evalDomain D x i ‚Ü™ F :=
  ‚ü®
    fun x => x.1.1,
    by admit /- proof elided -/
  ‚ü©

def divX (p : UniPoly R) : UniPoly R := p.extract 1 p.size

def lastBlockOracleReduction :=
  let bIdx := ‚Ñì / œë - 1
  let stmt : Fin (œë + 1) ‚Üí Type := fun i => Statement (L := L) (‚Ñì := ‚Ñì) Context
    ‚ü®bIdx * œë + i, by admit /- proof elided -/
    ‚ü©
  let oStmt := fun i: Fin (œë + 1) => OracleStatement ùîΩq Œ≤ œë
    ‚ü®bIdx * œë + i, by admit /- proof elided -/
    ‚ü©
  let wit := fun i: Fin (œë + 1) => Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì)
    ‚ü®bIdx * œë + i, by admit /- proof elided -/
    ‚ü©
  let V:  OracleReduction []‚Çí (StmtIn := Statement (L := L) (‚Ñì := ‚Ñì) Context
    ‚ü®bIdx * œë, by admit /- proof elided -/
    ‚ü©)
    (OStmtIn := OracleStatement ùîΩq Œ≤ œë
      ‚ü®bIdx * œë, by admit /- proof elided -/
      ‚ü©)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì)
      ‚ü®bIdx * œë, by admit /- proof elided -/
      ‚ü©)
    (StmtOut := Statement (L := L) (‚Ñì := ‚Ñì) Context (Fin.last ‚Ñì))
    (OStmtOut := OracleStatement ùîΩq Œ≤ œë (Fin.last ‚Ñì))
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) (Fin.last ‚Ñì))
    (pSpec := pSpecLastBlock (L:=L) (œë:=œë)) := by admit /- proof elided -/

abbrev MatrixSubmodule.{u, v, w} (Œ∫ : Type u) [Fintype Œ∫] (Œπ : Type v) [Fintype Œπ]
                                 (F : Type w) [Semiring F] : Type (max u v w) :=
  Submodule F (Matrix Œ∫ Œπ F)

def relHammingBall (C : Code Œπ F) (y : Œπ ‚Üí F) (r : ‚Ñù) : Code Œπ F :=
  { c | c ‚àà C ‚àß Code.relHammingDist y c ‚â§ r }

def relayKStateProp (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i)
  (stmtIn : Statement (L := L) Context i.succ)
  (witMid : Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
  (oStmtIn : (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j))
  : Prop :=
  masterKStateProp (mp := mp) (œë := œë) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
    (stmtIdx := i.succ) (oracleIdx := i.succ)
    (h_le := le_refl _)
    (stmt := stmtIn) (wit := witMid) (oStmt := mapOStmtOutRelayStep
      ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hNCR oStmtIn)
    (localChecks := True)

OracleComp.inductionOn in VCVio.OracleComp.OracleComp

Set.Ioc in Mathlib.Order.Interval.Set.Defs

instance instHasPred {n : ‚Ñï} : HasPred (CNat n) := match n with
  | 0 => by admit /- proof elided -/
  | .succ n => by admit /- proof elided -/

MonadLiftT in Init.Prelude

noncomputable def queryOracleProof : OracleProof
    (oSpec := []‚Çí)
    (Statement := FinalSumcheckStatementOut (L:=L) (‚Ñì:=‚Ñì))
    (OStatement := OracleStatement ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (
    Fin.last ‚Ñì))
    (Witness := Unit)
    (pSpec := pSpecQuery ùîΩq Œ≤ Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)) :=
  queryOracleReduction ùîΩq Œ≤ (œë:=œë) Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)

def outputRelation :
    Set
      (
        (Fri.Spec.Statement F (0 : Fin (k + 1)) √ó
        (‚àÄ j, Fri.Spec.OracleStatement D x s (0 : Fin (k + 1)) j)) √ó
        Fri.Spec.Witness F s d (0 : Fin (k + 2))
      ) := sorry

instance {Œπ : Type u} (v : Œπ ‚Üí Type v) [O : ‚àÄ i, OracleInterface (v i)]
    [h : ‚àÄ i, DecidableEq (Query (v i))]
    [h' : ‚àÄ i, DecidableEq (Response (v i))] :
    [v]‚Çí.DecidableEq where
  domain_decidableEq' := h
  range_decidableEq' := h'

def divNat [Zero T] [DecidableEq T] [ToNat T]
    (dividend divisor : Cayley T) : Nat ‚Üí Cayley T
  | 0        => zero  
  | .succ fuel =>
    
    if (‚Üëdivisor : Nat) = 0 then
      zero
    else
      
      if (‚Üëdivisor : Nat) ‚â§ (‚Üëdividend : Nat) then
        
        add one (divNat (sub dividend divisor) divisor fuel)
      else
        zero

Matrix.rank in Mathlib.LinearAlgebra.Matrix.Rank

def additiveNTTInvariant (evaluation_buffer : Fin (2 ^ (‚Ñì + R_rate)) ‚Üí L)
    (original_coeffs : Fin (2 ^ ‚Ñì) ‚Üí L) (i : Fin (‚Ñì + 1)) : Prop :=
  ‚àÄ (j : Fin (2^(‚Ñì + R_rate))),
    let u_b_v := j.val
    let v: Fin (2^i.val) := ‚ü®Nat.getLowBits i.val u_b_v, by admit /- proof elided -/
    ‚ü© 
    let u_b := u_b_v / (2^i.val) 
    have h_u_b : u_b = u_b_v / (2^i.val) := by admit /- proof elided -/

def start {Œ± : Type} (a : Œ±) : OracleComp (Œ± ‚Üí‚Çí Vector U SpongeSize.C) (DuplexSponge U C) := do
  let capacitySegment : Vector U SpongeSize.C ‚Üê query (spec := Œ± ‚Üí‚Çí Vector U SpongeSize.C) () a
  let vecSponge := (Vector.replicate SpongeSize.R (0 : U)) ++ capacitySegment
  return {
    state := SpongeState.update (Œ± := C) (0 : C) (vecSponge.cast (by admit /- proof elided -/
    )),
    absorbPos := 0,
    squeezePos := Fin.last SpongeSize.R
  }

noncomputable def intermediateEvaluationPoly (i : Fin (‚Ñì + 1))
    (coeffs : Fin (2 ^ (‚Ñì - i)) ‚Üí L) : L[X] :=
  ‚àë (‚ü®j, hj‚ü©: Fin (2^(‚Ñì-i))), C (coeffs ‚ü®j, by admit /- proof elided -/
  ‚ü©) *
    (intermediateNovelBasisX ùîΩq Œ≤ h_‚Ñì_add_R_rate i ‚ü®j, by admit /- proof elided -/
    ‚ü©)

@[ext]
structure AssocNat where
  toFun : Nat ‚Üí Nat
  presSucc : ‚àÄ n, toFun (n.succ) = (toFun n).succ

def millerRabinBases : List ‚Ñï :=
  [2, 325, 9375, 28178, 450775, 9780504, 1795265022]

noncomputable def monomialBasisOfDegreeLT {n : ‚Ñï} : Basis (Fin n) L (L‚¶É< n‚¶Ñ[X]) :=

guard in Init.Control.Basic

@[inline, reducible]
protected def id :
    OracleContext.Lens OuterStmtIn OuterStmtOut OuterStmtIn OuterStmtOut
                OuterOStmtIn OuterOStmtOut OuterOStmtIn OuterOStmtOut
                OuterWitIn OuterWitOut OuterWitIn OuterWitOut where
  stmt := OracleStatement.Lens.id
  wit := Witness.Lens.id

alias trivial := OracleContext.Lens.id

def soundness (langIn : Set StmtIn) (langOut : Set StmtOut)
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    (soundnessError : ‚Ñù‚â•0) : Prop :=
  ‚àÄ WitIn WitOut : Type,
  ‚àÄ witIn : WitIn,
  ‚àÄ prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec,
  ‚àÄ stmtIn ‚àâ langIn,
    letI reduction := Reduction.mk prover verifier
    [fun ‚ü®_, stmtOut‚ü© => stmtOut ‚àà langOut
    | do (simulateQ (impl ++‚Çõ‚Çí challengeQueryImpl : QueryImpl _ (StateT œÉ ProbComp))
        <| reduction.run stmtIn witIn).run' (‚Üê init)] ‚â§ soundnessError

@[inline, specialize]
def OracleReduction.run [‚àÄ i, OracleInterface (pSpec.Message i)]
    (stmt : StmtIn) (oStmt : ‚àÄ i, OStmtIn i) (wit : WitIn)
    (reduction : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec) :
      OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí)
        ((FullTranscript pSpec √ó (StmtOut √ó ‚àÄ i, OStmtOut i) √ó WitOut) √ó
          (StmtOut √ó ‚àÄ i, OStmtOut i)) := do
  let proverResult ‚Üê reduction.prover.run ‚ü®stmt, oStmt‚ü© wit
  let stmtOut ‚Üê liftM (reduction.verifier.run stmt oStmt proverResult.1)
  return ‚ü®proverResult, stmtOut‚ü©

instance instDCast‚ÇÇ : DCast‚ÇÇ Nat ProtocolSpec (fun _ pSpec => MessageIdx pSpec) where
  dcast‚ÇÇ h := MessageIdx.cast h
  dcast‚ÇÇ_id := cast_id

structure ParamConditions (P : Params Œπ F) where
  m : ‚Ñï 
  h_m : m = P.varCount 0
  h_sumkLt : ‚àë i : Fin (M + 1), P.foldingParam i ‚â§ m
  h_varCount_i : ‚àÄ i : Fin (M + 1),
    P.varCount i = m - ‚àë j : Fin i, P.foldingParam (Fin.castLT j (Nat.lt_trans j.isLt i.isLt))
  h_smooth : ‚àÄ i : Fin (M + 1), Smooth (P.œÜ i)
  h_repeatPLt : ‚àÄ i : Fin (M + 1), P.repeatParam i ‚â§ Fintype.card (Œπ i)

def map (f : R ‚Üí+* S) (p : MlPolyEval R n) : MlPolyEval S n :=
  Vector.map (fun a => f a) p

OracleComp.SelectableType in VCVio.OracleComp.Constructions.UniformSelect

Array.size in Init.Prelude

instance instDCast : DCast Nat ProtocolSpec where
  dcast h := ProtocolSpec.cast h
  dcast_id := cast_id

def Adversary (Œπ : Type) (G : Type) (p : ‚Ñï) (bitLength : ‚Ñï) (Œ± : Type) : Type _ :=
  ReaderT (GroupValTable Œπ G)
    (OracleComp (GroupOpOracle Œπ ++‚Çí GroupExpOracle Œπ p ++‚Çí
      GroupEqOracle Œπ ++‚Çí GroupEncodeOracle Œπ bitLength))
    (List Œπ √ó Œ±)

@[simp]
def evalDomain (i : ‚Ñï) : Set FÀ£ :=
  (x ^ (2 ^ i)) ‚Ä¢ (Domain.evalDomain D i)

instance [Inhabited C] [Permute C] : DuplexSpongeInterface U (DuplexSponge U C) where
  absorbUnchecked := fun (sponge, arr) => absorbUnchecked sponge arr
  squeezeUnchecked := fun (sponge, arr) => squeezeUnchecked sponge arr
  ratchetUnchecked := ratchetUnchecked

def verifier (i : Fin n) : Verifier oSpec
    (StatementRound R n i.castSucc √ó (‚àÄ i, OracleStatement R n deg i))
    (StatementRound R n i.succ √ó (‚àÄ i, OracleStatement R n deg i)) (pSpec R deg) :=
  (Simple.verifier R deg D oSpec).liftContext (oStmtLens R n deg D i)

inferInstanceAs in Init.Prelude

Polynomial.leadingCoeff in Mathlib.Algebra.Polynomial.Degree.Definitions

@[reducible]
def OracleStatement := fun _ : MatrixIdx => Matrix (Fin sz.m) (Fin sz.n) R

def proverRound (i : Fin n) : ProverRound oSpec (pSpec R deg) where
  PrvState := (proverState R n deg i).PrvState

  sendMessage
  | ‚ü®0, _‚ü© => fun state =>
    match n with
    | 0 => sorry
    | n + 1 =>
      let ‚ü®‚ü®_, challenges‚ü©, oStmt‚ü© := state
      let ‚ü®poly, hp‚ü© := oStmt 0
      pure ‚ü® ‚ü®‚àë x ‚àà (univ.map D) ^·∂† (n - i), poly ‚∏®X ‚¶Éi‚¶Ñ, challenges, x‚∏©'(by admit /- proof elided -/
      ),
        sumcheck_roundPoly_degreeLE R n deg D i hp‚ü©,
          state‚ü©
  | ‚ü®1, h‚ü© => nomatch h

  receiveChallenge
  | ‚ü®0, h‚ü© => nomatch h
  | ‚ü®1, _‚ü© => fun ‚ü®‚ü®target, challenges‚ü©, oStmt‚ü© => pure fun chal =>
    let ‚ü®poly, hp‚ü© := oStmt 0
    letI newChallenges : Fin i.succ ‚Üí R := Fin.snoc challenges chal
    letI newTarget := ‚àë x ‚àà (univ.map D) ^·∂† (n - i - 1), poly ‚∏®newChallenges, x‚∏©'(by admit /- proof elided -/
    )
    ‚ü®‚ü®newTarget, newChallenges‚ü©, fun _ => ‚ü®poly, hp‚ü©‚ü©

left_inv in ToMathlib.Control.Monad.Equiv

def BerlekampWelchMatrix
  (e k : ‚Ñï)
  (œâs f : Fin n ‚Üí F) : Matrix (Fin n) (Fin (2 * e + k)) F :=
  Matrix.of fun i j =>
    let Œ±·µ¢ := œâs i
    if ‚Üëj < e then -Rhs j.1 œâs f i else -Œ±·µ¢^(j - e)

def nonLastBlockOracleVerifier (bIdx : Fin (‚Ñì / œë - 1)) :=
  let stmt : Fin (œë - 1 + 1) ‚Üí Type :=
    fun i => Statement (L := L) Context ‚ü®bIdx * œë + i, bIdx_mul_œë_add_i_cast_lt_‚Ñì_succ bIdx i‚ü©
  let oStmt := fun i: Fin (œë - 1 + 1) => OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë
    ‚ü®bIdx * œë + i, bIdx_mul_œë_add_i_cast_lt_‚Ñì_succ bIdx i‚ü©
  let firstFoldRelayRoundsOracleVerifier :=
    OracleVerifier.seqCompose (oSpec := []‚Çí)
      (Stmt := stmt)
      (OStmt := oStmt)
      (pSpec := fun i => pSpecFoldRelay (L:=L))
      (V := fun i => by admit /- proof elided -/
      )
  let h1 : ‚ÜëbIdx * œë + (œë - 1) < ‚Ñì := by admit /- proof elided -/

@[inline, specialize]
def Reduction.runWithLog (stmt : StmtIn) (wit : WitIn)
    (reduction : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí)
        (((FullTranscript pSpec √ó StmtOut √ó WitOut) √ó StmtOut) √ó
          QueryLog (oSpec ++‚Çí [pSpec.Challenge]‚Çí) √ó QueryLog oSpec) := do
  
  let ‚ü®proverResult, proveQueryLog‚ü© ‚Üê reduction.prover.runWithLog stmt wit
  let ‚ü®stmtOut, verifyQueryLog‚ü© ‚Üê
    liftM (simulateQ loggingOracle (reduction.verifier.run stmt proverResult.1)).run
  return ‚ü®‚ü®proverResult, stmtOut‚ü©, proveQueryLog, verifyQueryLog‚ü©

noncomputable instance {H : F[X][Y]} [inst : Fact (Irreducible H)] : Field (ùïÉ H) :=
  IsField.toField (isField_of_irreducible inst.out)

Module.finrank in Mathlib.LinearAlgebra.Dimension.Finrank

structure ConcreteBTFRingProps (k : ‚Ñï) extends (ConcreteBTFAddCommGroupProps k) where
  
  mul_eq : ‚àÄ (a b : ConcreteBTField k) (h_k : k > 0)
    {a‚ÇÅ a‚ÇÄ b‚ÇÅ b‚ÇÄ : ConcreteBTField (k - 1)}
    (_h_a : (a‚ÇÅ, a‚ÇÄ) = split h_k a) (_h_b : (b‚ÇÅ, b‚ÇÄ) = split h_k b),
    concrete_mul a b =
      „Ää concrete_mul a‚ÇÄ b‚ÇÅ + concrete_mul b‚ÇÄ a‚ÇÅ + concrete_mul (concrete_mul a‚ÇÅ b‚ÇÅ) (Z (k - 1)),
      concrete_mul a‚ÇÄ b‚ÇÄ + concrete_mul a‚ÇÅ b‚ÇÅ „Äã

  
  zero_mul : ‚àÄ a : ConcreteBTField k, concrete_mul zero a = zero
  zero_mul' : ‚àÄ a : ConcreteBTField k, concrete_mul 0 a = 0
  mul_zero : ‚àÄ a : ConcreteBTField k, concrete_mul a zero = zero
  mul_zero' : ‚àÄ a : ConcreteBTField k, concrete_mul a 0 = 0
  one_mul : ‚àÄ a : ConcreteBTField k, concrete_mul one a = a
  mul_one : ‚àÄ a : ConcreteBTField k, concrete_mul a one = a

  
  mul_assoc : ‚àÄ a b c : ConcreteBTField k, concrete_mul (concrete_mul a b) c
    = concrete_mul a (concrete_mul b c)
  mul_left_distrib : ‚àÄ a b c : ConcreteBTField k, concrete_mul a (b + c)
    = concrete_mul a b + concrete_mul a c
  mul_right_distrib : ‚àÄ a b c : ConcreteBTField k, concrete_mul (a + b) c
    = concrete_mul a c + concrete_mul b c

instance : SliceGE (FullTranscript pSpec) ‚Ñï
    (fun _ start => start ‚â§ n)
    (fun _ start _ => FullTranscript (pSpec‚ü¶start:‚üß))
    where
  sliceGE := fun v start h => drop start h v

def distanceLE (Message : Type*) [O : OracleInterface Message]
    [Fintype (O.Query)] [DecidableEq (O.Response)] (d : ‚Ñï) : Prop :=
  ‚àÄ a b : Message, a ‚â† b ‚Üí #{q | OracleInterface.answer a q = OracleInterface.answer b q} ‚â§ d

instance {Message : Type u} : Inhabited (OracleInterface Message) :=
  ‚ü®instDefault‚ü©

Fin.castSuccEmb in Mathlib.Data.Fin.Embedding

def composeM {m' : Type u ‚Üí Type v} [Monad m'] (hom : m ‚Üí·µê m') (so : QueryImpl spec m) :
    QueryImpl spec m' where
  impl | query i t => hom (so.impl (query i t))

class LawfulPermute (Œ± : Type*) [Permute Œ±] where
  permuteInv : Œ± ‚Üí Œ±
  left_inv : Function.LeftInverse permuteInv Permute.permute
  right_inv : Function.RightInverse permuteInv Permute.permute

instance {k : ‚Ñï} : NeZero (Z k) := (BinaryTowerAux k).snd.specialElementNeZero

Function.RightInverse in Init.Data.Function

noncomputable def polynomialFromNovelCoeffs (‚Ñì : ‚Ñï) (h_‚Ñì : ‚Ñì ‚â§ r)
  (a : Fin (2 ^ ‚Ñì) ‚Üí L) : L[X] := ‚àë j, C (a j) * (X‚±º ùîΩq Œ≤ ‚Ñì h_‚Ñì j)

def oracleVerifier (i : Fin n) : OracleVerifier oSpec
    (StatementRound R n i.castSucc) (OracleStatement R n deg)
    (StatementRound R n i.succ) (OracleStatement R n deg) (pSpec R deg) where
  
  
  
  
  verify := fun ‚ü®target, challenges‚ü© chal => do
    let evals : List R ‚Üê (List.finRange m).mapM
      (fun i => do
        return ‚Üê query
          (spec := (oSpec ++‚Çí ([OracleStatement R n deg]‚Çí ++‚Çí [(pSpec R deg).Message]‚Çí)))
            (Sum.inr <| Sum.inr default) (D i))
    guard (evals.sum = target)
    let newTarget ‚Üê query
      (spec := (oSpec ++‚Çí ([OracleStatement R n deg]‚Çí ++‚Çí [(pSpec R deg).Message]‚Çí)))
        (Sum.inr <| Sum.inr default) (by admit /- proof elided -/
        )
    letI newTarget : R := by admit /- proof elided -/

def Equiv.precomp {Œ± Œ≤ Œ≥} (e : Œ± ‚âÉ Œ≤) : (Œ≤ ‚Üí Œ≥) ‚âÉ (Œ± ‚Üí Œ≥) :=
{ toFun := fun f a => f (e a)
  , invFun := fun g b => g (e.invFun b)
  , left_inv := by admit /- proof elided -/

def absorb (ds : DomainSeparator U H) (count : Nat) (label : String) : DomainSeparator U H :=
  
  
  
  
  { io := ds.io ++ SEP_BYTE ++ s!"A{count}" ++ label }

Fin.natAdd in Init.Data.Fin.Basic

def toCoeffsVec (‚Ñì : Nat) : L‚¶É<2^‚Ñì‚¶Ñ[X] ‚Üí‚Çó[L] CoeffVecSpace L ‚Ñì where
  toFun := fun p => fun i => p.val.coeff i.val
  map_add' := fun p q => by admit /- proof elided -/

def domain (n : ‚Ñï) (i : ‚Ñï) : Fin (2 ^ (n - i)) ‚Üí evalDomain D i :=
  fun j => ‚ü®(DIsCyclicC.gen ^ (2 ^ i)) ^ j.1, by admit /- proof elided -/
  ‚ü©

Nat.boddDiv2 in Mathlib.Data.Nat.Bits

Finset.add in Mathlib.Algebra.Group.Pointwise.Finset.Basic

instance {s} : Functor (fun Œ± => LeafData Œ± s) where
  map f x := x.map f

instance (priority := 1000) algebra_adjacent_tower (l : ‚Ñï) :
  Algebra (ConcreteBTField l) (ConcreteBTField (l + 1)) :=

def projection (S : Finset n) (w : n ‚Üí R) : S ‚Üí R :=
  fun i => w i.val

def sumAll (n : ‚Ñï) (D : Fin n ‚Üí Finset R) : MvPolynomial (Fin n) R ‚Üí‚Çó[R] R :=

OrderDual in Mathlib.Order.Basic

Polynomial.monomial in Mathlib.Algebra.Polynomial.Basic

def simulateQ' (oa : OracleComp spec Œ±) (h : oa.neverFails) : m Œ± :=

Module in Mathlib.Algebra.Module.Defs

noncomputable def foldOracleProver (i : Fin ‚Ñì) :
  OracleProver (oSpec := []‚Çí)
    
    (StmtIn := Statement (L := L) Context i.castSucc)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) i.castSucc)
    
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) i.succ)
    (pSpec := pSpecFold (L := L)) where

  PrvState := foldPrvState ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i

  input := fun ‚ü®‚ü®stmt, oStmt‚ü©, wit‚ü© => (stmt, oStmt, wit)

  sendMessage 
  | ‚ü®0, _‚ü© => fun ‚ü®stmt, oStmt, wit‚ü© => do
    let curH : ‚Ü•L‚¶É‚â§ 2‚¶Ñ[X Fin (‚Ñì - ‚Üëi.castSucc)] := wit.H
    let h_i : L‚¶É‚â§ 2‚¶Ñ[X] := by admit /- proof elided -/

@[reducible, simp] def OStmtOut := fun _ : Fin 2 => OStatement

def externalLinearLayer (state : Vector KoalaBear.Field params.width) :
    Vector KoalaBear.Field params.width :=
  
  let chunks := Vector.Matrix.ofFlatten (state.cast (params.widthDiv4_mul_4_eq_width).symm)
  let chunksAfterM4 := chunks.map (fun chunk => applyM4 chunk)

  
  

  
  let transposedMatrix := Vector.Matrix.transpose chunksAfterM4

  
  let columnSums := transposedMatrix.map (fun col => col.foldl (¬∑ + ¬∑) 0)

  
  let chunksAfterDiffusion := chunksAfterM4.map (fun row => row.zipWith (¬∑ + ¬∑) columnSums)

  
  (Vector.flatten chunksAfterDiffusion).cast (params.widthDiv4_mul_4_eq_width)

instance {Œ± : Type*} {n : ‚Ñï} [VCVCompatible Œ±] : VCVCompatible (Vector Œ± n) where

@[reducible, simp] def OStmtIn := fun _ : Fin 2 => OStatement

instance [IsSingleRound pSpec] : Unique (pSpec.MessageIdx) where
  default := ‚ü®0, by admit /- proof elided -/
  ‚ü©
  uniq := fun ‚ü®i, hi‚ü© => by admit /- proof elided -/

def hammingBall (C : Code Œπ F) (y : Œπ ‚Üí F) (r : ‚Ñï) : Set (Œπ ‚Üí F) :=
  { c | c ‚àà C ‚àß hammingDist y c ‚â§ r }

@[reducible]
def spec : OracleSpec Unit := fun _ => (Œ± √ó Œ±, Œ±)

def acceptRejectOracleRel : Set ((Bool √ó (‚àÄ _ : Empty, Unit)) √ó Unit) :=
  { ((true, isEmptyElim), ()) }

def OracleMessages (pSpec : ProtocolSpec n) [OracleInterfaces pSpec] : Type :=
  ‚àÄ i, pSpec.OracleMessage i

OrderBot in Mathlib.Order.BoundedOrder.Basic

MvPolynomial.aeval in Mathlib.Algebra.MvPolynomial.Eval

@[reducible, inline]
def OracleProver {Œπ : Type} (oSpec : OracleSpec Œπ)
    (StmtIn : Type) {Œπ‚Çõ·µ¢ : Type} (OStmtIn : Œπ‚Çõ·µ¢ ‚Üí Type) (WitIn : Type)
    (StmtOut : Type) {Œπ‚Çõ‚Çí : Type} (OStmtOut : Œπ‚Çõ‚Çí ‚Üí Type) (WitOut : Type)
    {n : ‚Ñï} (pSpec : ProtocolSpec n) :=
  Prover oSpec (StmtIn √ó (‚àÄ i, OStmtIn i)) WitIn (StmtOut √ó (‚àÄ i, OStmtOut i)) WitOut pSpec

def SumFunEquivProd (Œ± Œ≤ Œ≥ : Type) : ((Œ± ‚äï Œ≤) ‚Üí Œ≥) ‚âÉ (Œ± ‚Üí Œ≥) √ó (Œ≤ ‚Üí Œ≥) :=
{ toFun := fun f => (fun a => f (.inl a), fun b => f (.inr b))
  , invFun := fun p x => match x with | .inl a => p.fst a | .inr b => p.snd b
  , left_inv := by admit /- proof elided -/

@[inline, reducible]
def OracleStatement.Lens (OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut : Type)
    {Outer_Œπ‚Çõ·µ¢ : Type} (OuterOStmtIn : Outer_Œπ‚Çõ·µ¢ ‚Üí Type) [‚àÄ i, OracleInterface (OuterOStmtIn i)]
    {Outer_Œπ‚Çõ‚Çí : Type} (OuterOStmtOut : Outer_Œπ‚Çõ‚Çí ‚Üí Type) [‚àÄ i, OracleInterface (OuterOStmtOut i)]
    {Inner_Œπ‚Çõ·µ¢ : Type} (InnerOStmtIn : Inner_Œπ‚Çõ·µ¢ ‚Üí Type) [‚àÄ i, OracleInterface (InnerOStmtIn i)]
    {Inner_Œπ‚Çõ‚Çí : Type} (InnerOStmtOut : Inner_Œπ‚Çõ‚Çí ‚Üí Type) [‚àÄ i, OracleInterface (InnerOStmtOut i)]
  :=
    Statement.Lens (OuterStmtIn √ó ‚àÄ i, OuterOStmtIn i) (OuterStmtOut √ó ‚àÄ i, OuterOStmtOut i)
                  (InnerStmtIn √ó ‚àÄ i, InnerOStmtIn i) (InnerStmtOut √ó ‚àÄ i, InnerOStmtOut i)

def parametrisedCurve {l : ‚Ñï} [Semiring F] (u : Fin l ‚Üí Œπ ‚Üí F) : Set (Œπ ‚Üí F)
  := {v | ‚àÉ r : F, v = ‚àë i : Fin l, (r ^ (i : ‚Ñï)) ‚Ä¢ u i}

VAdd in Mathlib.Algebra.Notation.Defs

@[inline]
def ofArray [Zero R] (coeffs : Array R) (n : ‚Ñï) : MlPoly R n :=
  .ofFn (fun i => if h : i.1 < coeffs.size then coeffs[i] else 0)

Function.uncurry in Init.Data.Function

ZMod.instField in Mathlib.Algebra.Field.ZMod

instance {Œ± : Type} {s : Skeleton} :
    CoeFun (InternalData Œ± s) fun (_ : InternalData Œ± s) => SkeletonInternalIndex s ‚Üí Œ± where
  coe := fun tree idx => tree.get idx

ZMod.charP in Mathlib.Data.ZMod.Basic

@[inline, specialize]
def mulX (p : UniPoly R) : UniPoly R := p.mulPowX 1

def fromString (io : String) : DomainSeparator U H :=
  { io := io }

def commitKnowledgeError {i : Fin ‚Ñì}
    (m : (pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i).ChallengeIdx) : ‚Ñù‚â•0 :=
  match m with
  | ‚ü®j, hj‚ü© => by admit /- proof elided -/

instance instOI‚ÇÅ : ‚àÄ i, OracleInterface ((‚ü®!v[.P_to_V], !v[R‚¶É‚â§ deg‚¶Ñ[X]]‚ü© ++‚Çö !p[]).Message i) :=
  instOracleInterfaceMessageAppend

@[reducible, inline, specialize]
def OracleMessageIdx := {i : pSpec.MessageIdx // (inst.oracleInterfaces i).isSome }

Setoid in Init.Core

ringChar in Mathlib.Algebra.CharP.Defs

class IsRBRSound (langIn : Set StmtIn) (langOut : Set StmtOut)
    (verifier : Verifier oSpec StmtIn StmtOut pSpec) where
  rbrSoundnessError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0
  is_rbr_sound : rbrSoundness init impl langIn langOut verifier rbrSoundnessError

instance instDCast‚ÇÇSigma {Œ± : Type*} {Œ≤ : Œ± ‚Üí Type*} {Œ≥ : (a : Œ±) ‚Üí Œ≤ a ‚Üí Type*}
    {Œ¥ : (a : Œ±) ‚Üí (b : Œ≤ a) ‚Üí Œ≥ a b ‚Üí Type*}
    [DCast Œ± Œ≤] [DCast‚ÇÇ Œ± Œ≤ Œ≥] [DCast‚ÇÉ Œ± Œ≤ Œ≥ Œ¥] :
    DCast‚ÇÇ ((a : Œ±) √ó Œ≤ a) (fun a => Œ≥ a.1 a.2) (fun a => Œ¥ a.1 a.2) where
  dcast‚ÇÇ ha hb c := dcast‚ÇÉ (by admit /- proof elided -/
  ) (by admit /- proof elided -/
  ) (by admit /- proof elided -/
  ) c
  dcast‚ÇÇ_id := by admit /- proof elided -/

@[inline, reducible]
protected def id :
    Context.Lens OuterStmtIn OuterStmtOut OuterStmtIn OuterStmtOut
                OuterWitIn OuterWitOut OuterWitIn OuterWitOut where
  stmt := Statement.Lens.id
  wit := Witness.Lens.id

alias trivial := Context.Lens.id

@[reducible]
def sumcheckFoldOracleReduction :=
  let stmt : Fin (‚Ñì / œë - 1 + 1) ‚Üí Type :=
    fun i => Statement (L := L) (‚Ñì := ‚Ñì) Context ‚ü®i * œë, blockIdx_mul_œë_lt_‚Ñì_succ i‚ü©
  let oStmt := fun i: Fin (‚Ñì / œë - 1 + 1) =>
    OracleStatement ùîΩq Œ≤ œë ‚ü®i * œë, blockIdx_mul_œë_lt_‚Ñì_succ i‚ü©
  let wit := fun i: Fin (‚Ñì / œë - 1 + 1) =>
    Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì)
      ‚ü®i * œë, blockIdx_mul_œë_lt_‚Ñì_succ i‚ü©
  let nonLastBlocksOracleReduction :=
  OracleReduction.seqCompose (oSpec := []‚Çí)
      (Stmt := stmt)
      (OStmt := oStmt) (Wit := wit)
      (pSpec := fun (bIdx: Fin (‚Ñì / œë - 1)) => pSpecFullNonLastBlock ùîΩq Œ≤ bIdx)
      (R := fun bIdx => nonLastBlockOracleReduction (L:=L) ùîΩq Œ≤ (œë:=œë) (ùìë:=ùìë) (bIdx:=bIdx))

  let lastOracleReduction := lastBlockOracleReduction ùîΩq Œ≤ (œë:=œë) (ùìë:=ùìë)

  let coreInteractionOracleReduction: OracleReduction []‚Çí
    (StmtIn := Statement (L := L) (‚Ñì := ‚Ñì) Context 0)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë 0)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) 0)
    (StmtOut := Statement (L := L) (‚Ñì:=‚Ñì) Context (Fin.last ‚Ñì))
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) (Fin.last ‚Ñì))
    (pSpec := pSpecSumcheckFold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
     := by admit /- proof elided -/

Finsupp.update in Mathlib.Data.Finsupp.Single

@[reducible, simp]
def pSpec : ProtocolSpec 1 := ‚ü®!v[.P_to_V], !v[Witness]‚ü©

Xor' in Mathlib.Logic.Basic

def extend {k : Fin n} (messages : MessagesUpTo k.castSucc pSpec)
    (h : pSpec.dir k = .V_to_P) : MessagesUpTo k.succ pSpec :=
  fun ‚ü®i, h‚ü© => (concat' (pSpec := pSpec) (fun i hi => messages ‚ü®i, hi‚ü©) (fun h' => by admit /- proof elided -/
  )) i h

def getNargString (state : FSProverState U H R) : ByteArray := state.nargString

instance {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    [O‚Çò : ‚àÄ i, ‚àÄ j, OracleInterface.{0, u, v} ((pSpec i).Message j)] :
    ‚àÄ k, OracleInterface.{0, u, v} ((seqCompose pSpec).Message k) :=
  fun ‚ü®k, h‚ü© => Fin.fflatten‚ÇÇ
    (A := Direction) (B := Type) (F := fun dir type => (h : dir = .P_to_V) ‚Üí OracleInterface type)
    (fun i' j' h' => O‚Çò i' ‚ü®j', h'‚ü©) k h

def Reduction.addSalt (R : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec)
    (saltComp : (i : pSpec.MessageIdx) ‚Üí R.prover.PrvState i.1.castSucc ‚Üí
      OracleComp oSpec (Salt i)) :
    Reduction oSpec StmtIn WitIn StmtOut WitOut (pSpec.addSalt Salt) where
  prover := R.prover.addSalt Salt saltComp
  verifier := R.verifier.addSalt Salt

@[simp]
def finRangeTo {k : ‚Ñï} (i : ‚Ñï) : Finset (Fin k) :=
  (List.take i (List.finRange k)).toFinset

def relDistCodewords [DecidableEq F] (U V : Matrix Œ∫ Œπ F) : ‚Ñù :=
  (Matrix.neqCols U V).card / Fintype.card Œπ

inductive PrattPartList : (p : ‚Ñï) ‚Üí (a : ZMod p) ‚Üí ‚Ñï ‚Üí Prop
  | prime : {p : ‚Ñï} ‚Üí {a : ZMod p} ‚Üí (n k nk : ‚Ñï) ‚Üí n.Prime ‚Üí
      a ^ ((p - 1) / n) ‚â† 1 ‚Üí n ^ k = nk ‚Üí PrattPartList p a nk
  | split : {p : ‚Ñï} ‚Üí {a : ZMod p} ‚Üí {n : ‚Ñï} ‚Üí (list : List ‚Ñï) ‚Üí
      (‚àÄ r ‚àà list, PrattPartList p a r) ‚Üí list.prod = n ‚Üí PrattPartList p a n

def Verifier.StateFunction.liftContext
    {œÉ : Type} {init : ProbComp œÉ} {impl : QueryImpl oSpec (StateT œÉ ProbComp)}
    (lens : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut)
    (V : Verifier oSpec InnerStmtIn InnerStmtOut pSpec)
    (outerLangIn : Set OuterStmtIn) (outerLangOut : Set OuterStmtOut)
    (innerLangIn : Set InnerStmtIn) (innerLangOut : Set InnerStmtOut)
    [lensSound : lens.IsSound outerLangIn outerLangOut innerLangIn innerLangOut
      (V.compatStatement lens)]
    (stF : V.StateFunction init impl innerLangIn innerLangOut) :
      (V.liftContext lens).StateFunction init impl outerLangIn outerLangOut
where
  toFun := fun m outerStmtIn transcript =>
    stF m (lens.proj outerStmtIn) transcript
  toFun_empty := fun stmt => by admit /- proof elided -/

@[simp]
abbrev Statement.AfterSecondSumcheck : Type :=
  SecondSumcheckChallenge R pp √ó Statement.AfterLinearCombination R pp

@[reducible, simp]
def StmtIn := R

instance : Slice (ProtocolSpec n) ‚Ñï ‚Ñï
    (fun _ start stop => start ‚â§ stop ‚àß stop ‚â§ n)
    (fun _ start stop _ => ProtocolSpec (stop - start))
    where
  slice := fun v start stop h => extract start stop h.1 h.2 v

instance (k : ‚Ñï) : LT (ConcreteBTField k) where
  lt := fun x y => by admit /- proof elided -/

def FullData.map {Œ± Œ≤ : Type} (f : Œ± ‚Üí Œ≤) {s : Skeleton}
    (tree : FullData Œ± s) : FullData Œ≤ s :=
  match tree with
  | FullData.leaf value => FullData.leaf (f value)
  | FullData.internal value left right =>
    FullData.internal (f value) (left.map f) (right.map f)

def modByMonic [Field R] (p : UniPoly R) (q : UniPoly R) :
    UniPoly R :=
  (divModByMonicAux p q).2

noncomputable def sDomainFinEquiv (i : Fin r) (h_i : i < ‚Ñì + R_rate)
:
  (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i) ‚âÉ
  Fin (2^(‚Ñì + R_rate - i.val)) :=

noncomputable def funcQuotient (f : Œπ ‚Üí F) (S : Finset F) (Ans Fill : S ‚Üí F) : Œπ ‚Üí F :=
  fun x =>
    if hx : x.val ‚àà S then Fill ‚ü®x.val, hx‚ü© 
    else (f x - (ansPoly S Ans).eval x.val) / (vanishingPoly S).eval x.val

noncomputable def ElocPolyF (œâs f : Fin n ‚Üí F) (p : Polynomial F) : Polynomial F :=
  ElocPoly n (liftF œâs) (liftF f) p

class Serialize (Œ± : Type u) (Œ≤ : Type v) where
  serialize : Œ± ‚Üí Œ≤

Algebra.TensorProduct.instAlgebra in Mathlib.RingTheory.TensorProduct.Basic

  partial def computePrattCertificate (n : ‚Ñï) : Option (UnverifiedPrattCertificate n) :=
    
    if n ‚â§ 50 ‚àß deterministicMillerRabin n then
      some (.knownPrime n)
    else do
      let fs ‚Üê factor' (n - 1)
      let a ‚Üê findWitness n fs
      let part ‚Üê computePrattPart fs
      return .of n a part
  where
    findWitness (n : ‚Ñï) (fs : List PrimeWithMultiplicity) : Option ‚Ñï := do
      for a in [2:n] do
        let mut ok := true
        for ‚ü®p, _‚ü© in fs do
          if powMod a ((n - 1) / p) n = 1 then
            ok := false
            break

        if ok then
          return a

      none

def outputRelation [DecidableEq F] (Œ¥ : ‚Ñù‚â•0) :
    Set
      (
        (FinalStatement F k √ó ‚àÄ j, FinalOracleStatement D x s j) √ó
        Witness F s d (Fin.last (k + 1))
      )
  := QueryRound.outputRelation D x s d (round_bound dom_size_cond) Œ¥

def smoothCode
  (domain : Œπ ‚Ü™ F) [Smooth domain]
  (m : ‚Ñï) : Submodule F (Œπ ‚Üí F) := ReedSolomon.code domain (2^m)

def isCommitmentRound (i : Fin ‚Ñì) : Prop :=
  œë ‚à£ i.val + 1 ‚àß i.val + 1 ‚â† ‚Ñì

def eq {Œ± : Type u} (mx my : m Œ±) : Prop :=
  evalDist mx = evalDist my

Nat.binaryRec in Mathlib.Data.Nat.BinaryRec

Option.bind in Init.Data.Option.Basic

@[simp]
abbrev Witness.AfterSecondSumcheck : Type := Unit

def Reduction.append (R‚ÇÅ : Reduction oSpec Stmt‚ÇÅ Wit‚ÇÅ Stmt‚ÇÇ Wit‚ÇÇ pSpec‚ÇÅ)
    (R‚ÇÇ : Reduction oSpec Stmt‚ÇÇ Wit‚ÇÇ Stmt‚ÇÉ Wit‚ÇÉ pSpec‚ÇÇ) :
      Reduction oSpec Stmt‚ÇÅ Wit‚ÇÅ Stmt‚ÇÉ Wit‚ÇÉ (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ) where
  prover := Prover.append R‚ÇÅ.prover R‚ÇÇ.prover
  verifier := Verifier.append R‚ÇÅ.verifier R‚ÇÇ.verifier

instance : Fact (Nat.Prime baseFieldSize) := ‚ü®BaseField_is_prime‚ü©

Vector.tail in Init.Data.Vector.Basic

def numOStmtQueries [DecidableEq Œπ‚Çõ·µ¢] (i : Œπ‚Çõ·µ¢)
    (stmt : StmtIn) (challenges : ‚àÄ i, pSpec.Challenge i)
    (naVerifier : OracleVerifier.NonAdaptive oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec) : ‚Ñï :=
  (naVerifier.queryOStmt stmt challenges).filter (fun q => q.1 = i) |>.length

HPow in Init.Prelude

def quotient (f g : F[X][Y]) : Prop := ‚àÉ q : F[X][Y], g = q * f

Inv in Init.Prelude

def leftDivNat {m n : ‚Ñï} (i : Fin (m * n)) : Fin n := ‚ü®i / m, by admit /- proof elided -/
‚ü©

instance instSetoidUniPoly : Setoid (UniPoly R) where
  r := equiv
  iseqv := instEquivalenceEquiv

Ideal.Quotient.mk in Mathlib.RingTheory.Ideal.Quotient.Defs

instance [Zero T] [ToNat T] : LT (Cayley T) where
  lt := lt

Finset.filter in Mathlib.Data.Finset.Filter

private def Fi (B : Finset (Fin n ‚Üí F)) (i : Fin n) (Œ± : F) : Finset (Fin n ‚Üí F) :=
  { x | x ‚àà B ‚àß x i = Œ± }

@[reducible]
def VectorIOP
    (Statement : Type) {Œπ‚Çõ : Type} (OStatement : Œπ‚Çõ ‚Üí Type) (Witness : Type)
    (vPSpec : ProtocolSpec.VectorSpec n) (A : Type)
    [‚àÄ i, OracleInterface (OStatement i)] :=
  OracleProof []‚Çí Statement OStatement Witness (vPSpec.toProtocolSpec A)

@[inline, specialize]
def add (p q : UniPoly R) : UniPoly R :=
  add_raw p q |> trim

def OracleVerifier.liftContext
    (lens : OracleStatement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                              OuterOStmtIn OuterOStmtOut InnerOStmtIn InnerOStmtOut)
    (V : OracleVerifier oSpec InnerStmtIn InnerOStmtIn InnerStmtOut InnerOStmtOut pSpec) :
      OracleVerifier oSpec OuterStmtIn OuterOStmtIn OuterStmtOut OuterOStmtOut pSpec where
  verify := fun outerStmtIn transcript => sorry
  embed := by admit /- proof elided -/

CommMonoid in Mathlib.Algebra.Group.Defs

def getFoldingChallenges (i : Fin (‚Ñì + 1)) (challenges : Fin i ‚Üí L)
    (k : ‚Ñï) (h : k + œë ‚â§ i) : Fin œë ‚Üí L :=
  fun cId => challenges ‚ü®k + cId, by admit /- proof elided -/
  ‚ü©

@[inline] def one : AssocNat :=
  ‚ü®Nat.succ, by admit /- proof elided -/
  ‚ü©

Fin.snoc in Mathlib.Data.Fin.Tuple.Basic

@[simp]
def Z (k : ‚Ñï) : BTField k := (BinaryTowerAux k).snd.specialElement 

class SpongeUnit (Œ± : Type) extends Zero Œ±, Serde Œ± ByteArray, HasSize Œ± UInt8 where
   
  write (stream : IO.FS.Stream) : Array Œ± ‚Üí IO Unit :=
    Array.foldlM (fun _ a => IO.FS.Stream.write stream (serialize a)) ()
   
  read (stream : IO.FS.Stream) : Array Œ± ‚Üí IO (Array Œ±) :=
    fun arr => do
      let bytes ‚Üê arr.mapM (fun _ => IO.FS.Stream.read stream (USize.ofNat (HasSize.size Œ± UInt8)))
      let units := bytes.mapM deserialize
      if h : units.isSome
        then return units.get h
        else IO.throwServerError "Failed to read units"

def d (B : Finset (Fin n ‚Üí F)) : ‚Ñö :=
  (1 : ‚Ñö)/(2 * choose_2 B.card) * ‚àë x ‚àà (Finset.product B B) with x.1 ‚â† x.2, Œî‚ÇÄ(x.1, x.2)

noncomputable def qMap_total_fiber
    
      (i : Fin r) (steps : ‚Ñï) (h_i_add_steps : i.val + steps < ‚Ñì + ùì°)
        (y : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i.val + steps, by admit /- proof elided -/
        ‚ü©)) :
    Fin (2 ^ steps) ‚Üí sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i :=
  if h_steps : steps = 0 then by
    
    subst h_steps
    simp only [add_zero, Fin.eta] at y
    exact fun _ => y
  else by
    
    let basis_y := sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i+steps,by admit /- proof elided -/
    ‚ü©) (by admit /- proof elided -/
    )
    let y_coeffs : Fin (‚Ñì + ùì° - (‚Üëi + steps)) ‚Üí‚ÇÄ ùîΩq := basis_y.repr y

    let basis_x := sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i, by admit /- proof elided -/
    ‚ü© (by admit /- proof elided -/
    )
    exact fun elementIdx => by admit /- proof elided -/

Array.rightpad in Init.Data.Array.Basic

structure ProverInit (PrvState : Type) where
  init : PrvState

def eval (p : MlPolyEval R n) (x : Vector R n) : R :=
  Vector.dotProduct p (lagrangeBasis x)

instance [VCVCompatible A] : ‚àÄ i, VCVCompatible ((vPSpec.toProtocolSpec A).Challenge i) :=
  fun _ => by admit /- proof elided -/

def leftModNat {m n : ‚Ñï} (h_m : m > 0) (i : Fin (m * n)) : Fin m := ‚ü®i % m, by admit /- proof elided -/
‚ü©

def coreInteractionOracleRbrKnowledgeError (j : (pSpecCoreInteraction ùîΩq Œ≤ (œë := œë)
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).ChallengeIdx) : ‚Ñù‚â•0 :=
    Sum.elim
      (f := fun i => sumcheckFoldKnowledgeError ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)
      (g := fun i => finalSumcheckKnowledgeError (L := L) i)
      (ChallengeIdx.sumEquiv.symm j)

def partialSum {Œ± : Type*} [AddMonoid Œ±] (l : List Œ±) : List Œ± :=
  [0] ++ match l with
  | [] => []
  | a :: l' => (partialSum l').map (a + ¬∑)

Nat.floor in Mathlib.Algebra.Order.Floor.Defs

def towerAlgebraMap (l r : ‚Ñï) (h_le : l ‚â§ r) : BTField l ‚Üí+* BTField r :=

Function.LeftInverse in Init.Data.Function

@[inline]
def add [Add R] (p q : MlPoly R n) : MlPoly R n := Vector.zipWith (¬∑ + ¬∑) p q

structure DomainSeparatorMismatch where
  message : String
deriving Inhabited, DecidableEq, Repr

@[inline] def ge [Zero T] [ToNat T] (a b : Cayley T) : Prop :=
  (a : Nat) ‚â• (b : Nat)

@[inline]
def zsmul [SMul ‚Ñ§ R] (m : ‚Ñ§) (p : MlPolyEval R n) : MlPolyEval R n := p.map (fun a => m ‚Ä¢ a)

private def Bi (B : Finset (Fin n ‚Üí F)) (i : Fin n) : Finset ((Fin n ‚Üí F) √ó (Fin n ‚Üí F)) :=
  { x | x ‚àà B √óÀ¢ B ‚àß x.1 i = x.2 i ‚àß x.1 ‚â† x.2 }

abbrev append (pSpec : ProtocolSpec m) (pSpec' : ProtocolSpec n) : ProtocolSpec (m + n) :=
  ‚ü®Fin.vappend pSpec.dir pSpec'.dir, Fin.vappend pSpec.Type pSpec'.Type‚ü©

@[reducible, simp] def StmtOut : Type := R √ó R

structure SumcheckMultiplierParam (L : Type) [CommRing L] (‚Ñì : ‚Ñï) (Context : Type := Unit) where
  multpoly : (ctx: Context) ‚Üí MultilinearPoly L ‚Ñì

def map (f : R ‚Üí+* S) (p : MlPoly R n) : MlPoly S n :=
  Vector.map (fun a => f a) p

@[reducible]
def GroupOpOracle : OracleSpec Unit := fun _ => (Œπ √ó Œπ √ó Œπ, Unit)

def bool (j : Fin numWires) : Gate ùì° numWires :=
  { qL := -1, qR := 0, qO := 0, qM := 1, qC := 0, a := j, b := j, c := j }

def renameMessage (pSpec : ProtocolSpec n) (NewMessage : pSpec.MessageIdx ‚Üí Type) :
    ProtocolSpec n :=
  ‚ü® pSpec.dir,
    fun i => if h : pSpec.dir i = Direction.P_to_V then NewMessage ‚ü®i, h‚ü© else pSpec.¬´Type¬ª i‚ü©

def Equiv.ofLawfulPermute (Œ± : Type*) [Permute Œ±] [LawfulPermute Œ±] : Equiv Œ± Œ± where
  toFun := Permute.permute
  invFun := LawfulPermute.permuteInv
  left_inv := LawfulPermute.left_inv
  right_inv := LawfulPermute.right_inv

def range (n : ‚Ñï) : Fin n ‚Üí ‚Ñï := fun i => i

LT.lt in Init.Prelude

def DVec {m : Type v} (Œ± : m ‚Üí Type u) : Type (max u v) := ‚àÄ i, Œ± i

DivisionSemiring in Mathlib.Algebra.Field.Defs

MvPolynomial.renameEquiv in Mathlib.Algebra.MvPolynomial.Rename

noncomputable def fullRbrKnowledgeError (i : (fullPSpec ùîΩq Œ≤ Œ≥_repetitions (œë := œë)
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).ChallengeIdx) : ‚Ñù‚â•0 :=
  Sum.elim (f := CoreInteraction.coreInteractionOracleRbrKnowledgeError ùîΩq Œ≤ (œë:=œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (g := QueryPhase.queryRbrKnowledgeError ùîΩq Œ≤ Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (ChallengeIdx.sumEquiv.symm i)

def powContraction :
  MvPolynomial (Fin m) F ‚Üí‚Çó[F] Polynomial F :=
  powAlgHom.toLinearMap

@[inline] def monoToLagrange (n : ‚Ñï) : MlPoly R n ‚Üí MlPolyEval R n :=
  (List.finRange n).foldl (fun acc level => monoToLagrangeLevel level acc)

instance [Zero T] [One T] [ToNat T] : HomogeneousPow (Cayley T) where
  pow := pow

RingEquiv in Mathlib.Algebra.Ring.Equiv

def implGroupDecodeOracle [DeserializeOption G (BitVec bitLength)] :
    QueryImpl (GroupDecodeOracle Œπ bitLength) (StateT (GroupValTable Œπ G) Option) where
  impl | query _ (b, i) => fun table =>
    match DeserializeOption.deserialize b with
    | some g => some ((), table.update i (some g))
    | none => none

Fin.isValue in Lean.Meta.Tactic.Simp.BuiltinSimprocs.Fin

def exData0 {Œ±} (a : Œ±) : ArityTree.Data Œ± exSkel0 :=
  ArityTree.Data.leaf a

def multilinearBasis (l r : ‚Ñï) (h_le : l ‚â§ r) :
    letI instAlgebra := ConcreteBTFieldAlgebra (h_le:=h_le)
    Basis (Fin (2 ^ (r - l))) (ConcreteBTField l) (ConcreteBTField r) :=

instance (k : ‚Ñï) : NeZero (2^k) :=

instance {U : Type} {H : Type*} {R : Type*} [SpongeUnit U] [DuplexSpongeInterface U H] :
    UnitTranscript (FSProverState U H R) U where
  publicUnits state input := do
    
    
    let newState ‚Üê state.addUnits input
    .ok { rng := newState.rng, hashState := newState.hashState,
          nargString := state.nargString } 
  fillChallengeUnits state count :=
    match state.hashState.squeeze count with
    | .ok (newHashState, output) =>
      .ok ({ rng := state.rng, hashState := newHashState, nargString := state.nargString }, output)
    | .error e => .error e

Membership.mem in Init.Prelude

noncomputable def relayOracleVerifier (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
  OracleVerifier
    (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) Context i.succ)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (pSpec := pSpecRelay) where
  verify := fun stmtIn _ => pure stmtIn
  embed := ‚ü®fun j => by admit /- proof elided -/
  ‚ü©
  hEq := fun oracleIdx => by admit /- proof elided -/

noncomputable def toMvPolynomialAlgHom : P ‚Üí‚Çê[R] MvPolynomial œÉ R := aeval MvPolynomial.X

CommMonoidWithZero in Mathlib.Algebra.GroupWithZero.Defs

def interleaveCode [Semiring F] [DecidableEq F] (C : Submodule F (n ‚Üí F)) (Œπ : Type*)
  : Submodule F ((Œπ √ó n) ‚Üí F) :=
  Submodule.span F {v | ‚àÄ i, ‚àÉ c ‚àà C, c = fun j => v (i, j)}

def subNat (c : AssocNat) : Nat ‚Üí AssocNat
| 0            => c 
| Nat.succ k   => pred (subNat c k) 

def aeval {A : Type w} [CommSemiring A] [Algebra R A] (s : A) : P ‚Üí‚Çê[R] A :=
  eval‚ÇÇAlgHom (Algebra.ofId R A) s

@[inline] def div [Zero T] [DecidableEq T] [ToNat T]
    (dividend divisor : Cayley T) : Cayley T :=
  
  letI fuel := (‚Üëdividend : Nat) + 1
  divNat dividend divisor fuel

Nat.mod in Init.Prelude

def powerBasisSucc (k : ‚Ñï) :
    PowerBasis (ConcreteBTField k) (ConcreteBTField (k + 1)) :=

def foldMatrix (i : Fin r) (steps : Fin (‚Ñì + 1)) (h_i_add_steps : i.val + steps < ‚Ñì + ùì°)
    (y : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate)
      ‚ü®‚Üëi + steps, by apply Nat.lt_trans (m := ‚Ñì + ùì°) (h_i_add_steps) h_‚Ñì_add_R_rate‚ü©)
    : Matrix (Fin (2 ^ steps.val)) (Fin (2 ^ steps.val)) L :=

def divSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (k : Fin (‚àë j, n j)) : Fin m :=
  (divSum? n k).get (divSum?_is_some_iff_lt_sum.mpr k.isLt)

@[inline, reducible]
def Witness.Lens (OuterStmtIn InnerStmtOut OuterWitIn OuterWitOut InnerWitIn InnerWitOut : Type)
    := PFunctor.Lens ((OuterStmtIn √ó OuterWitIn) X^ OuterWitOut)
                     (InnerWitIn X^ (InnerStmtOut √ó InnerWitOut))

Sub in Init.Prelude

instance : NonBinaryField Field where
  char_neq_2 := by admit /- proof elided -/

AddGroup in Mathlib.Algebra.Group.Defs

Set.Pairwise in Mathlib.Logic.Pairwise

Polynomial.toFinsupp in Mathlib.Algebra.Polynomial.Basic

def churchNil : ChurchVec Œ± := fun f base => base

RingHom.toAlgebra in Mathlib.Algebra.Algebra.Defs

@[simp]
def testStmtLens :
    Statement.Lens OuterStmtIn_Test OuterStmtOut_Test InnerStmtIn_Test InnerStmtOut_Test :=
  ‚ü®fun ‚ü®p, q, t‚ü© => ‚ü®p * q, t‚ü©, fun ‚ü®p, q, _‚ü© ‚ü®_, t', u‚ü© => (p, q, t', u)‚ü©

noncomputable def finalSumcheckRbrExtractor :
  Extractor.RoundByRound []‚Çí
    (StmtIn := (Statement (L := L) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì)) √ó (‚àÄ j, OracleStatement ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë  (Fin.last ‚Ñì) j))
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì))
    (WitOut := Unit)
    (pSpec := pSpecFinalSumcheckStep (L := L))
    (WitMid := FinalSumcheckWit (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì)) where
  eqIn := rfl
  extractMid := fun m ‚ü®stmtMid, oStmtMid‚ü© trSucc witMidSucc => by admit /- proof elided -/
    | none => 
      exact dummyLastWitness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
    | some tpoly =>
      
      exact {
        t := tpoly,
        H := projectToMidSumcheckPoly (L := L) (‚Ñì := ‚Ñì) (t := tpoly)
          (m := BBF_SumcheckMultiplierParam.multpoly stmtMid.ctx)
          (i := Fin.last ‚Ñì) (challenges := stmtMid.challenges),
        f := getMidCodewords ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) tpoly stmtMid.challenges
      }
  extractOut := fun ‚ü®stmtIn, oStmtIn‚ü© tr witOut => ()

@[reducible, simp] def OStmtAfterSendClaim : Unit ‚äï Unit ‚Üí Type := fun _ => R‚¶É‚â§ deg‚¶Ñ[X]

def finSuccEquivNth : MvPolynomial (Fin (n + 1)) R ‚âÉ‚Çê[R] Polynomial (MvPolynomial (Fin n) R) :=
  (renameEquiv R (_root_.finSuccEquiv' p)).trans (optionEquivLeft R (Fin n))

noncomputable def commitOracleProver (i : Fin ‚Ñì) :
  OracleProver (oSpec := []‚Çí)
    
    (StmtIn := Statement (L := L) Context i.succ)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) i.succ)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) i.succ)
    (pSpec := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) where

  PrvState := commitPrvState ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i

  input := fun ‚ü®‚ü®stmt, oStmt‚ü©, wit‚ü© => (stmt, oStmt, wit)

  sendMessage 
  | ‚ü®0, _‚ü© => fun inputPrvState => by admit /- proof elided -/
  | ‚ü®0, h‚ü© => nomatch h 

  output := fun ‚ü®stmt, oStmt, wit‚ü© => by admit /- proof elided -/

instance [Zero T] [ToNat T] : Sub (Cayley T) where
  sub := sub

def firstOracleWitnessConsistencyProp (t : MultilinearPoly L ‚Ñì)
    (f‚ÇÄ : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate 0 ‚Üí L) : Prop :=
  let P‚ÇÄ: L[X]_(2 ^ ‚Ñì) := polynomialFromNovelCoeffsF‚ÇÇ ùîΩq Œ≤ ‚Ñì (by admit /- proof elided -/
  ) (fun œâ => t.val.eval œâ)
  
  2 * hammingDist (fun x => P‚ÇÄ.val.eval x.val) f‚ÇÄ < BBF_CodeDistance ‚Ñì ùì° ‚ü®0, by admit /- proof elided -/
  ‚ü©

instance [DecidableEq Œπ] : Memory Œπ Œ± (‚àÄ i, Œ± i) where
  read m i := m i
  write m i v := Function.update m i v

class VerifierLast (pSpec : ProtocolSpec n) [NeZero n] where
  verifier_last' : pSpec.dir ‚ü®n - 1, by admit /- proof elided -/
  ‚ü© = .V_to_P

Equivalence in Init.Core

def relationAfterCheckClaim :
    Set (((StmtAfterCheckClaim R) √ó (‚àÄ i, OStmtAfterCheckClaim R deg i)) √ó Unit) :=
  { ‚ü®‚ü®_, oStmt‚ü©, _‚ü© | oStmt (Sum.inr ()) = oStmt (Sum.inl ()) }

def hammingClose (i : Fin (‚Ñì + 1)) (f : OracleFunction ùîΩq Œ≤
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) : Prop :=
  2 * Code.distFromCode (u := f)
    (C := BBF_Code ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) <
    (BBF_CodeDistance ‚Ñì ùì° i : ‚Ñï‚àû)

noncomputable def coeffs_of_close_proximity (œâs : Fin n ‚Ü™ F) (Œ¥ : ‚Ñö) (u‚ÇÄ u‚ÇÅ : Fin n ‚Üí F)
  : Finset F := Set.toFinset { z | ‚àÉ v : ReedSolomon.code œâs (k + 1), Œ¥·µ£(u‚ÇÄ + z ‚Ä¢ u‚ÇÅ, v) ‚â§ Œ¥}

@[inline, reducible]
protected def id :
    OracleStatement.Lens OuterStmtIn OuterStmtOut OuterStmtIn OuterStmtOut
                        OuterOStmtIn OuterOStmtOut OuterOStmtIn OuterOStmtOut :=
  PFunctor.Lens.id _

alias trivial := OracleStatement.Lens.id

def indexPowT (S : Finset Œπ) (œÜ : Œπ ‚Ü™ F) (k : ‚Ñï) := { y : F // ‚àÉ x ‚àà S, y = (œÜ x) ^ (2^k) }

right_inv in ToMathlib.Control.Monad.Equiv

PMF in Mathlib.Probability.ProbabilityMassFunction.Basic

def ConstraintSystem (ùì° : Type) (numWires numGates : ‚Ñï) := Fin numGates ‚Üí Gate ùì° numWires

def toList (xs : ChurchVec Œ±) : List Œ± :=
  churchVecFold xs (fun x acc => x :: acc) []

Or in Init.Prelude

def bitExpo (i : ‚Ñï) : (Fin m) ‚Üí‚ÇÄ ‚Ñï :=
  Finsupp.onFinset Finset.univ
    (fun j => if Nat.testBit i j.1 then 1 else 0)
    (by admit /- proof elided -/
    )

noncomputable def relayOracleProver (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
  OracleProver (oSpec := []‚Çí)
    
    (StmtIn := Statement (L := L) Context i.succ)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) i.succ)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) i.succ)
    (pSpec := pSpecRelay) where
  PrvState := relayPrvState ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i
  input := fun ‚ü®‚ü®stmtIn, oStmtIn‚ü©, witIn‚ü© => (stmtIn, oStmtIn, witIn)
  sendMessage | ‚ü®x, h‚ü© => by admit /- proof elided -/
| ‚ü®x, h‚ü© => by admit /- proof elided -/

instance : Fact (Nat.Prime scalarFieldSize) := ‚ü®ScalarField_is_prime‚ü©

@[reducible, inline, specialize, simp]
def MessageIdx (vPSpec : VectorSpec n) := {i : Fin n // vPSpec.dir i = .P_to_V}

List in Init.Prelude

Nat.gcd in Init.Data.Nat.Gcd

instance : Unique (FullTranscript (default : ProtocolSpec 0)) := inferInstance

def parametrisedCurveFinite [DecidableEq Œπ] [Fintype F] [DecidableEq F] [Semiring F]
  {l : ‚Ñï} (u : Fin l ‚Üí Œπ ‚Üí F) : Finset (Œπ ‚Üí F) :=
  {v | ‚àÉ r : F, v = ‚àë i : Fin l, (r ^ (i : ‚Ñï)) ‚Ä¢ u i}

def oracleReduction : OracleReduction oSpec (StmtIn R) (OStmtIn R deg) Unit
    (StmtOut R) (OStmtOut R deg) Unit (pSpec R deg) :=
  ((oracleReduction.sendClaim R deg oSpec)
  |>.append (oracleReduction.checkClaim R deg oSpec)
  |>.append (oracleReduction.randomQuery R deg oSpec)
  |>.append (oracleReduction.reduceClaim R deg oSpec))

def squeeze (sponge : DuplexSponge U C) (len : Nat) :
    OracleComp (forwardPermutationOracle C) (Vector U len √ó DuplexSponge U C) :=
  match len with
  
  | 0 => pure (#v[], sponge)
  
  | n + 1 => do
    
    let sponge1 : DuplexSponge U C := { sponge with absorbPos := 0 }
    let sponge2 ‚Üê if sponge1.squeezePos = SpongeSize.R then
      let permutedState ‚Üê query (spec := forwardPermutationOracle _) () (sponge1.state)
      let sponge2 : DuplexSponge U C := { sponge1 with state := permutedState, squeezePos := 0 }
      pure sponge2
    else
      pure sponge1
    let squeezedVal := (SpongeState.get sponge2.state)[sponge2.squeezePos]
    let sponge3 := { sponge2 with squeezePos := sponge2.squeezePos + 1 }
    
    let (restVec, sponge4) ‚Üê squeeze sponge3 n
    
    
    return (restVec.insertIdx 0 squeezedVal, sponge4)

HDiv in Init.Prelude

private noncomputable def x_times_oddPart' (f : Polynomial F) : Polynomial F :=
  match f with
  | ‚ü®‚ü®supp, f, pr‚ü©‚ü© => ‚ü®‚ü®erase_even supp, fun n => if Odd n then f n else 0, by admit /- proof elided -/
  ‚ü©‚ü©

@[inline]
def seqCompose {m : ‚Ñï} (Stmt : Fin (m + 1) ‚Üí Type) (Wit : Fin (m + 1) ‚Üí Type)
    {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (R : (i : Fin m) ‚Üí
      Reduction oSpec (Stmt i.castSucc) (Wit i.castSucc) (Stmt i.succ) (Wit i.succ) (pSpec i)) :
    Reduction oSpec (Stmt 0) (Wit 0) (Stmt (Fin.last m)) (Wit (Fin.last m)) (seqCompose pSpec) where
  prover := Prover.seqCompose Stmt Wit (fun i => (R i).prover)
  verifier := Verifier.seqCompose Stmt (fun i => (R i).verifier)

@[reducible]
def foldCommitOracleVerifier (i : Fin ‚Ñì) (hCR : isCommitmentRound ‚Ñì œë i) :
  OracleVerifier []‚Çí
    (StmtIn := Statement (L := L) Context i.castSucc)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.succ)
    (pSpec := pSpecFoldCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) :=
    OracleVerifier.append (oSpec:=[]‚Çí)
      (pSpec‚ÇÅ := pSpecFold (L:=L))
      (pSpec‚ÇÇ := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)
      (V‚ÇÅ := foldOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)
      (V‚ÇÇ := commitOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hCR)

Functor.map in Init.Prelude

noncomputable def foldOracleVerifier (i : Fin ‚Ñì) :
  OracleVerifier
    (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) Context i.castSucc)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (O‚Çò := fun i => by admit /- proof elided -/
    )
    
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (pSpec := pSpecFold (L := L)) where

  
  
  verify := fun stmtIn pSpecChallenges => do
    
    let h_i : L‚¶É‚â§ 2‚¶Ñ[X] ‚Üê query (spec := [(pSpecFold (L := L)).Message]‚Çí)
      ‚ü®0, rfl‚ü© ()

    
    let sumcheck_check := h_i.val.eval 0 + h_i.val.eval 1 = stmtIn.sumcheck_target
    unless sumcheck_check do
      
      let dummyStmt : Statement (L := L) Context i.succ := {
        ctx := stmtIn.ctx,
        sumcheck_target := 0,
        challenges := Fin.snoc stmtIn.challenges 0
      }
      return dummyStmt

    
    let r_i' : L := pSpecChallenges ‚ü®1, rfl‚ü©  

    
    let stmtOut : Statement (L := L) Context i.succ := {
      ctx := stmtIn.ctx,
      sumcheck_target := h_i.val.eval r_i',
      challenges := Fin.snoc stmtIn.challenges r_i'
    }

    pure stmtOut
  embed := ‚ü®fun j => by admit /- proof elided -/
  ‚ü©
  hEq := fun oracleIdx => by admit /- proof elided -/

structure SparseMatrix (m n Œ± : Type*) where
  numEntries : ‚Ñï
  row : Fin numEntries ‚Üí m
  col : Fin numEntries ‚Üí n
  val : Fin numEntries ‚Üí Œ±
deriving Inhabited, DecidableEq

@[simp]
def testLens : Context.Lens OuterStmtIn_Test OuterStmtOut_Test InnerStmtIn_Test InnerStmtOut_Test
                Unit Unit Unit Unit where
  stmt := testStmtLens
  wit := Witness.Lens.id

Finset.range in Mathlib.Data.Finset.Range

instance [Fintype F] [Nonempty F] [Semiring F] [DecidableEq Œπ] [DecidableEq F] {l : ‚Ñï} :
  ‚àÄ u : Fin l ‚Üí Œπ ‚Üí F, Nonempty {x // x ‚àà parametrisedCurveFinite u } :=

@[inline, reducible]
def lift : (OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i)) √ó OuterWitIn ‚Üí
    (InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i)) √ó InnerWitOut ‚Üí
    (OuterStmtOut √ó (‚àÄ i, OuterOStmtOut i)) √ó OuterWitOut :=
  fun ctxIn ctxOut => ‚ü®lens.stmt.lift ctxIn.1 ctxOut.1, lens.wit.lift ctxIn ctxOut‚ü©

instance {Œπ : Type} : OracleInterface (OracleStatement Œπ F ()) := OracleInterface.instFunction

Set.Nontrivial in Mathlib.Data.Set.Subsingleton

@[elab_as_elim] def Fin.predRecOnSameFinType {motive : Fin r ‚Üí Sort _}
    (last : motive (‚ü®r - 1, by
      have h_r_ne_0: r ‚â† 0 := by exact NeZero.ne r
      omega
    ‚ü© : Fin r))
    (succ : ‚àÄ i : Fin r, i.val > 0 ‚Üí motive i ‚Üí motive (‚ü®i.val - 1, by omega‚ü© : Fin r))
    (i : Fin r): motive i :=

def forwardPermutationOracleImpl {Œ± : Type*} [Permute Œ±] :
    QueryImpl (forwardPermutationOracle Œ±) Id where
  impl | query () q => Permute.permute (Œ± := Œ±) q

List.Vector.head in Mathlib.Data.Vector.Defs

@[reducible]
def foldRelayOracleVerifier (i : Fin ‚Ñì)
    (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
  OracleVerifier []‚Çí
    (StmtIn := Statement (L := L) Context i.castSucc)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.succ)
    (pSpec := pSpecFoldRelay (L:=L)) :=
  OracleVerifier.append
        (pSpec‚ÇÅ := pSpecFold (L:=L))
    (pSpec‚ÇÇ := pSpecRelay)
    (foldOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)
    (relayOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hNCR)

def InputStatement := R

def powFiberT (i : ‚Ñï) {k : ‚Ñï} {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F} (S' : Finset (indexPowT S œÜ i))
  (œÜ' : (indexPowT S œÜ i) ‚Ü™ F) (y : indexPowT S œÜ k) :=
  { x : (indexPowT S œÜ i) // x ‚àà S' ‚àß (œÜ' x) ^ (2^(k-i)) = y.val }

def Œæ (x‚ÇÄ : F) (R : F[X][X][Y]) (H : F[X][Y]) [œÜ : Fact (Irreducible H)] : ùí™ H :=
  (Œæ_regular x‚ÇÄ R H).choose

Matrix in Mathlib.LinearAlgebra.Matrix.Defs

@[simp]
abbrev Witness.AfterFirstChallenge : Type := Unit

  partial def computePrattPart (l : List PrimeWithMultiplicity) : Option UnverifiedPrattPart := do
    if let [‚ü®p, k‚ü©] := l then
      let cert ‚Üê computePrattCertificate p
      return .prime p k cert

    let ‚ü®left, right‚ü© := l.splitAt (l.length / 2)
    let lhs ‚Üê computePrattPart left
    let rhs ‚Üê computePrattPart right
    return .split lhs rhs

Finset.fold in Mathlib.Data.Finset.Fold

instance : IsEmpty (MessageIdx ‚ü®!v[.V_to_P], !v[Chal]‚ü©) :=
  ‚ü®fun ‚ü®i, h‚ü© => by admit /- proof elided -/
  ‚ü©

def rowRank : ‚Ñï :=
  Module.finrank F (rowSpan U)

def SkeletonLeafIndex.isLeaf {s : Skeleton} (idx : SkeletonLeafIndex s) : Bool :=
  match idx with
  | SkeletonLeafIndex.ofLeaf => true
  | SkeletonLeafIndex.ofLeft _ => false
  | SkeletonLeafIndex.ofRight _ => false

instance : MvPolynomialLike œÉ R (MvPolynomial œÉ R) where
  X := MvPolynomial.X
  eval‚ÇÇ := fun f g => eval‚ÇÇHom f g
  eval‚ÇÇ_C := fun f g r => by admit /- proof elided -/

def knowledgeStateFunction (hRel : ‚àÄ stmtIn witOut,
      (mapStmt stmtIn, witOut) ‚àà relOut ‚Üí (stmtIn, mapWitInv stmtIn witOut) ‚àà relIn) :
    (verifier oSpec mapStmt).KnowledgeStateFunction
      init impl relIn relOut (extractor mapWitInv) where
  toFun | ‚ü®0, _‚ü© => fun stmtIn _ witIn => ‚ü®stmtIn, witIn‚ü© ‚àà relIn
  toFun_empty := fun stmtIn witIn => by admit /- proof elided -/

Char in Init.Prelude

@[reducible, simp] def OStmtAfterCheckClaim : Unit ‚äï Unit ‚Üí Type := fun _ => R‚¶É‚â§ deg‚¶Ñ[X]

Set.InjOn in Mathlib.Data.Set.Operations

def Œ≥ (x‚ÇÄ : F) (R : F[X][X][Y]) (H : F[X][Y]) [œÜ : Fact (Irreducible H)] : PowerSeries (ùïÉ H) :=
  let subst (t : ‚Ñï) : ùïÉ H :=
    match t with
    | 0 => fieldToùïÉ (-x‚ÇÄ)
    | 1 => 1
    | _ => 0
  PowerSeries.subst (PowerSeries.mk subst) (PowerSeries.mk (Œ± x‚ÇÄ R H))

@[inline, reducible]
def proj : OuterStmtIn √ó OuterWitIn ‚Üí InnerStmtIn √ó InnerWitIn :=
  fun ctxIn => ‚ü®lens.stmt.toFunA ctxIn.1, lens.wit.toFunA ctxIn‚ü©

def SparseMatrix.toMatrix {m n Œ± : Type*} [DecidableEq m] [DecidableEq n] [AddCommMonoid Œ±]
    (A : SparseMatrix m n Œ±) : Matrix m n Œ± :=
  fun i j => ‚àë k : Fin A.numEntries, if A.row k = i ‚àß A.col k = j then A.val k else 0

instance instDCast‚ÇÅ‚ÇÇ : DCast (Œ≤ a) (Œ≥ a) where
  dcast hb c := dcast‚ÇÇ (Eq.refl a) (by admit /- proof elided -/
  ) c
  dcast_id := by admit /- proof elided -/

def concrete_mul {k : ‚Ñï} (a b : ConcreteBTField k) : ConcreteBTField k :=
  if h_k_zero : k = 0 then
    if a = zero then zero
    else if b = zero then zero
    else if a = one then b
    else if b = one then a
    else zero 
  else
    have h_k_gt_0 : k > 0 := by admit /- proof elided -/

class ProverOnly (pSpec : ProtocolSpec 1) extends ProverFirst pSpec

 
alias NonInteractive := ProverOnly

def isBoolean {R : Type _} [Zero R] [One R] (a : Array R) : Prop :=
    ‚àÄ i : Fin a.size, (a[i] = 0) ‚à® (a[i] = 1)

List.getLast in Init.Data.List.Basic

instance instDecidableEqOption {Œ± : Type*} [DecidableEq Œ±] :
    DecidableEq (Option Œ±) := inferInstance

def Cache.cons (n : ‚Ñï) (leaves : List.Vector Œ± (2 ^ (n + 1))) (cache : Cache Œ± n) :
    Cache Œ± (n + 1) :=
  Fin.snoc cache leaves

UInt32.ofFin in Init.Data.UInt.Basic

def localized_fold_eval (i : Fin ‚Ñì) (steps : ‚Ñï) (h_i_add_steps : i + steps ‚â§ ‚Ñì)
    (f : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate)
      ‚ü®i, by exact Nat.lt_of_le_of_lt (n := i) (k := r) (m := ‚Ñì) (h‚ÇÅ := by
        exact Fin.is_le') (by exact lt_of_add_right_lt h_‚Ñì_add_R_rate)‚ü© ‚Üí L)
    (r_challenges : Fin steps ‚Üí L)
    (y : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®‚Üëi + steps, by omega‚ü©) : L :=

@[elab_as_elim]
def dflatten {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {motive : (k : Fin (vsum n)) ‚Üí Sort*}
    (v : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí motive (embedSum i j)) (k : Fin (vsum n)) : motive k :=
  match m with
  | 0 => Fin.elim0 k
  | _ + 1 =>
    dappend
      (fun j => v 0 j)
      (fun j => dflatten (motive := fun j => motive (natAdd _ j)) (fun i => v i.succ) j)
      k

abbrev rdrop (m : ‚Ñï) (h : m ‚â§ n)
    (transcript : FullTranscript pSpec) : FullTranscript (pSpec.rdrop m h) :=
  Fin.rdrop m h transcript

structure BinaryTowerResult (F : Type _) (k : ‚Ñï) where
  vec : (List.Vector F (k + 1))
  instField : (Field F)
  instFintype : Fintype F
  specialElement : F
  specialElementNeZero : NeZero specialElement
  firstElementOfVecIsSpecialElement [Inhabited F] : vec.1.headI = specialElement
  instIrreduciblePoly : (Irreducible (p := (definingPoly specialElement)))
  sumZeroIffEq : ‚àÄ (x y : F), x + y = 0 ‚Üî x = y
  fieldFintypeCard : Fintype.card F = 2^(2^k)
  traceMapEvalAtRootsIs1 : TraceMapProperty F specialElement k

class Context.Lens.IsComplete {OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut : Type}
    {OuterWitIn OuterWitOut InnerWitIn InnerWitOut : Type}
    (outerRelIn : Set (OuterStmtIn √ó OuterWitIn))
    (innerRelIn : Set (InnerStmtIn √ó InnerWitIn))
    (outerRelOut : Set (OuterStmtOut √ó OuterWitOut))
    (innerRelOut : Set (InnerStmtOut √ó InnerWitOut))
    (compat : (OuterStmtIn √ó OuterWitIn) ‚Üí (InnerStmtOut √ó InnerWitOut) ‚Üí Prop)
    (lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut) where

  proj_complete : ‚àÄ stmtIn witIn,
    (stmtIn, witIn) ‚àà outerRelIn ‚Üí
    (lens.stmt.proj stmtIn, lens.wit.proj (stmtIn, witIn)) ‚àà innerRelIn

  lift_complete : ‚àÄ outerStmtIn outerWitIn innerStmtOut innerWitOut,
    compat (outerStmtIn, outerWitIn) (innerStmtOut, innerWitOut) ‚Üí
    (outerStmtIn, outerWitIn) ‚àà outerRelIn ‚Üí
    (innerStmtOut, innerWitOut) ‚àà innerRelOut ‚Üí
    (lens.stmt.lift outerStmtIn innerStmtOut,
    lens.wit.lift (outerStmtIn, outerWitIn) (innerStmtOut, innerWitOut)) ‚àà outerRelOut

instance [h : VerifierFirst pSpec] : IsEmpty (pSpec.MessageIdx) where
  false | ‚ü®0, h'‚ü© => by admit /- proof elided -/

def splitSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (k : Fin (vsum n)) : (i : Fin m) √ó Fin (n i) := match m with
  | 0 => Fin.elim0 k
  | _ + 1 => Fin.dappend
    (fun k => ‚ü®0, k‚ü©)
    (fun k => ‚ü®(splitSum k).1.succ, (splitSum k).2‚ü©)
    k

def take (m : ‚Ñï) (h : m ‚â§ n) (pSpec : ProtocolSpec n) : ProtocolSpec m :=
  {dir := Fin.take m h pSpec.dir, ¬´Type¬ª := Fin.take m h pSpec.¬´Type¬ª}

noncomputable def UniPolyC.toPoly (p : UniPolyC R) : Polynomial R := p.val.toPoly

alias ofPoly := Polynomial.toImpl

@[reducible, simp]
def perfectCompleteness (relation : Set (Statement √ó Witness))
    (proof : Proof oSpec Statement Witness pSpec) : Prop :=
  Reduction.perfectCompleteness init impl relation acceptRejectRel proof

def lagrangeBasis (w : Vector R n) : Vector R (2 ^ n) :=
  Vector.ofFn (fun i => ‚àè j : Fin n, if (BitVec.ofFin i).getLsb j then w[j] else 1 - w[j])

def Rhs (e : ‚Ñï) (œâs f : Fin n ‚Üí F) (i : Fin n) : F :=
  let Œ±·µ¢ := œâs i
  (-(f i) * Œ±·µ¢^e)

@[inline, specialize]
def nsmul (n : ‚Ñï) (p : UniPoly R) : UniPoly R :=
  nsmul_raw n p |> trim

def NestedList (n : ‚Ñï) : Type := dfoldr' n (fun _ => Type) (fun _ T => List T) Nat

example : NestedList 0 = Nat := rfl
example (n : ‚Ñï) : NestedList (n + 1) = List (NestedList n) := rfl

def constrainedCode
  (domain : Œπ ‚Ü™ F) [Smooth domain] (m : ‚Ñï)
  (w : MvPolynomial (Fin (m + 1)) F) (œÉ : F) : Set (Œπ ‚Üí F) :=
    { f | ‚àÉ (h : f ‚àà smoothCode domain m),
      weightConstraint (mVdecode (‚ü®f, h‚ü© : smoothCode domain m)) w œÉ }

noncomputable def liftedFRI [DecidableEq F] :
  OracleReduction []‚Çí
    ((Fin m ‚Üí F) √ó Fri.Spec.Statement F (0 : Fin (k + 1)))
      (OracleStatement D x m) (Fri.Spec.Witness F s d 0)
    (Fri.Spec.FinalStatement F k)
      (Fri.Spec.FinalOracleStatement D x s) (Fri.Spec.Witness F s d (Fin.last (k + 1)))
    (
      Fri.Spec.pSpecFold D x k s ++‚Çö
      Fri.Spec.FinalFoldPhase.pSpec F ++‚Çö
      Fri.Spec.QueryRound.pSpec D x l
    ) :=
    OracleReduction.liftContext
      (liftingLens D x k s d m)
      (Fri.Spec.reduction D x k s d dom_size_cond l)

@[reducible, simp]
def completeness
    (relation : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (oracleProof : OracleProof oSpec Statement OStatement Witness pSpec)
    (completenessError : ‚Ñù‚â•0) : Prop :=
  OracleReduction.completeness init impl
    relation acceptRejectOracleRel oracleProof completenessError

def relHammingBallInterleavedCode [DecidableEq F] (U : Matrix Œ∫ Œπ F)
  (IC : MatrixSubmodule Œ∫ Œπ F) (r : ‚Ñù) :=
    {V | V ‚àà IC ‚àß relDistCodewords U V < r}

Function.update in Mathlib.Logic.Function.Basic

def AlgebraTowerEquiv.toAlgebraOverRight (e : AlgebraTowerEquiv A B) (i j : Œπ)
    (h : i ‚â§ j) : Algebra (B i) (A j) :=

instance {k : Fin 1} : Unique (MessagesUpTo k !p[]) where
  default := fun ‚ü®‚ü®i, h‚ü©, _‚ü© => by admit /- proof elided -/

def Function.interleave‚ÇÇ {Œ± Œ≤ : Type*} (u v : Œ± ‚Üí Œ≤) : (Fin 2) √ó Œ± ‚Üí Œ≤ :=
  Function.uncurry (fun a => if a = 0 then u else v)

@[reducible, simp]
def knowledgeSoundness
    (relation : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (verifier : OracleVerifier oSpec Statement OStatement Bool (fun _ : Empty => Unit) pSpec)
    (knowledgeError : ‚Ñù‚â•0) : Prop :=
  verifier.toVerifier.knowledgeSoundness init impl relation acceptRejectOracleRel knowledgeError

instance instInvConcreteBTF {k : ‚Ñï} : Inv (ConcreteBTField k) where
  inv := concrete_inv

def coeffsOfPolynomial (p : F[X]) : Fin deg ‚Üí F :=
  fun ‚ü®x, _‚ü© ‚Ü¶ p.coeff x

List.ranges in Mathlib.Data.List.Range

noncomputable def queryOracleReduction :
  OracleReduction
    (oSpec := []‚Çí)
    (StmtIn := FinalSumcheckStatementOut (L:=L) (‚Ñì:=‚Ñì))
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (
    Fin.last ‚Ñì))
    (WitIn := Unit)
    (StmtOut := Bool)
    (OStmtOut := fun _ : Empty => Unit)
    (WitOut := Unit)
    (pSpec := pSpecQuery ùîΩq Œ≤ Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)) where
  prover := queryOracleProver ùîΩq Œ≤ (œë:=œë) Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
  verifier := queryOracleVerifier ùîΩq Œ≤ (œë:=œë) Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)

affineSpan in Mathlib.LinearAlgebra.AffineSpace.AffineSubspace.Defs

structure StatementRound (i : Fin (n + 1)) where
  
  target : R
  
  challenges : Fin i ‚Üí R

noncomputable def relayRbrExtractor (i : Fin ‚Ñì) :
  Extractor.RoundByRound []‚Çí
    (StmtIn := (Statement (L := L) Context i.succ) √ó (‚àÄ j, OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc j))
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (pSpec := pSpecRelay)
    (WitMid := fun _messageIdx => Witness (L := L) ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ) where
  eqIn := rfl
  extractMid := fun _ _ _ witMidSucc => witMidSucc
  extractOut := fun _ _ witOut => witOut

@[reducible]
def combineMap : StmtIn √ó WitIn ‚Üí OracleComp oSpec (StmtOut √ó WitOut) :=
  fun ‚ü®stmt, wit‚ü© => do return (‚Üê mapStmt stmt, ‚Üê mapWit stmt wit)

def getRoot {n : ‚Ñï} (cache : Cache Œ± n) : Œ± :=
  (cache 0).get ‚ü®0, by admit /- proof elided -/
  ‚ü©

OracleSpec.FiniteRange in VCVio.OracleComp.OracleSpec

IO in Init.System.IO

instance (priority := low) : DCast Œ± Œ≤ where
  dcast h := cast (congrArg Œ≤ h)
  dcast_id := by admit /- proof elided -/

noncomputable def finalSumcheckOracleReduction :
  OracleReduction
    (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì))
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì))
    (StmtOut := FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì))
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (WitOut := Unit)
    (pSpec := pSpecFinalSumcheckStep (L := L)) where
  prover := finalSumcheckProver ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
  verifier := finalSumcheckVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)

instance {i : ‚Ñï} : SmoothPowerOfTwo (n - i) (evalDomain D i) where
  smooth := by admit /- proof elided -/

instance [reduction.IsPerfectComplete init impl relIn relOut] :
    IsComplete init impl relIn relOut reduction where
  completenessError := 0
  is_complete := IsPerfectComplete.is_perfect_complete

structure Statement (Context : Type) (i : Fin (‚Ñì + 1)) where
  
  sumcheck_target : L              
  challenges : Fin i ‚Üí L           
  ctx : Context 

def lt {Œ± : Type} (m n : ChurchNat Œ±) : ChurchBool Œ± :=
  ChurchBool.churchAnd (leq m n) (ChurchBool.churchNot (leq n m))

def Straightline :=
  StmtIn ‚Üí 
  WitOut ‚Üí 
  FullTranscript pSpec ‚Üí 
  QueryLog oSpec ‚Üí 
  QueryLog oSpec ‚Üí 
  OracleComp oSpec WitIn 

OracleComp.SelectableType.probFailure_selectElem in VCVio.OracleComp.Constructions.UniformSelect

def bivPolyHom {F : Type} [CommRing F] [IsDomain F] :
  Polynomial (F[X]) ‚Üí+* Polynomial (RatFunc F) := Polynomial.mapRingHom (univPolyHom)

toFun in ToMathlib.Control.Monad.Hom

def CEmbedding : R ‚Ü™ MvPolynomial œÉ R := ‚ü®C, C_injective œÉ R‚ü©

Units.val in Mathlib.Algebra.Group.Units.Defs

structure PrattCertificate' (p : ‚Ñï) : Type where
  a : ZMod p
  pow_eq_one : a ^ (p - 1) = 1
  part : PrattPartList p a (p - 1)

structure FinalSumcheckStatementOut extends
  Statement (L := L) (Context := SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì) where
  final_constant : L               

instance : ‚àÄ i, OracleInterface (OracleStatement R pp i) :=
  fun i => {
    Query := (Fin pp.‚Ñì_m ‚Üí R) √ó (Fin pp.‚Ñì_n ‚Üí R)
    Response := R
    answer := fun matrix ‚ü®x, y‚ü© => matrix.toMLE ‚∏®C ‚àò x‚∏© ‚∏®y‚∏©
  }

def equivFin2 : Direction ‚âÉ Fin 2 where
  toFun := fun dir => match dir with | .V_to_P => ‚ü®0, by admit /- proof elided -/
  ‚ü© | .P_to_V => ‚ü®1, by admit /- proof elided -/
  ‚ü©
  invFun := fun n => match n with | ‚ü®0, _‚ü© => .V_to_P | ‚ü®1, _‚ü© => .P_to_V
  left_inv := fun dir => match dir with | .P_to_V => rfl | .V_to_P => rfl
  right_inv := fun n => match n with | ‚ü®0, _‚ü© => rfl | ‚ü®1, _‚ü© => rfl

noncomputable def AffSpanFinsetCollection {t : ‚Ñï} [NeZero k] [NeZero t]
  (C : Fin t ‚Üí (Fin k ‚Üí (Œπ ‚Üí F))) : Set (Finset (Œπ ‚Üí F)) :=
  Set.range (fun i => AffSpanFinset (C i))

noncomputable def Œ∑Star (U : Type) [SpongeUnit U] [Fintype U]
    (t‚Çï t‚Çö t‚Çö·µ¢ : ‚Ñï) (L : ‚Ñï) (Œµcodec : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) : ‚Ñù‚â•0 :=
  let tTotal : ‚Ñï := (t‚Çï + t‚Çö + t‚Çö·µ¢)
  
  
  
  
  let firstTermNumerator : ‚Ñù‚â•0 :=
    7 * tTotal ^2 + (28 * L + 25) * tTotal + (14 * L + 1) * (L + 1)
  let firstTermDenominator : ‚Ñù‚â•0 := 2 * ((Fintype.card U) ^ (SpongeSize.C + 1))
  
  let secondTerm : ‚Ñù‚â•0 := Œ∏Star t‚Çï t‚Çö t‚Çö·µ¢ * (iSup Œµcodec)
  
  let thirdTerm : ‚Ñù‚â•0 := ‚àë i, Œµcodec i
  
  firstTermNumerator / firstTermDenominator + secondTerm + thirdTerm

def domainComplement (œÜ : Œπ ‚Ü™ F) : Finset F :=
  Finset.univ \ Finset.image œÜ.toFun Finset.univ

instance [VerifierFirst pSpec] : ‚àÄ i, OracleInterface (pSpec.Message i) := isEmptyElim

def leadingCoeffY (f : F[X][Y]) : F[X] := f.coeff (natDegree f)

def Prover.duplexSpongeFiatShamir (P : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) :
    NonInteractiveProver (‚àÄ i, pSpec.Message i) (oSpec ++‚Çí duplexSpongeChallengeOracle StmtIn U)
      StmtIn WitIn StmtOut WitOut where
  PrvState := fun i => match i with
    | 0 => StmtIn √ó P.PrvState 0
    | _ => P.PrvState (Fin.last n)
  input := fun ctx => ‚ü®ctx.1, P.input ctx‚ü©
  
  sendMessage | ‚ü®0, _‚ü© => fun ‚ü®stmtIn, state‚ü© => do
    let ‚ü®messages, _, state‚ü© ‚Üê P.runToRoundDSFS (Fin.last n) stmtIn state
    return ‚ü®messages, state‚ü©
  
  receiveChallenge | ‚ü®0, h‚ü© => nomatch h
  output := fun st => (P.output st).liftComp _

def singleHash (left : Œ±) (right : Œ±) : OracleComp (spec Œ±) Œ± := do
  let out ‚Üê query (spec := spec Œ±) () ‚ü®left, right‚ü©
  return out

private noncomputable def oddPart' (f : Polynomial F) : Polynomial F :=
  match f with
  | ‚ü®‚ü®supp, f, pr‚ü©‚ü© => ‚ü®‚ü®
      shift_left (erase_even supp),
      fun n => if Even n then f (n + 1) else 0, by admit /- proof elided -/
      ‚ü©‚ü©

@[inline, specialize]
def oracleVerifier : OracleVerifier oSpec
    Unit (fun _ : Fin 2 => OStatement)
    (Query OStatement) (fun _ : Fin 2 => OStatement) (pSpec OStatement) where

  verify := fun _ chal => do
    let q : Query OStatement := chal ‚ü®0, rfl‚ü©
    pure q

  embed := Function.Embedding.inl

  hEq := by admit /- proof elided -/

class ToNat (Œ± : Type u) where
   
  toNat : Œ± ‚Üí Nat

noncomputable def S_Œ≤ {H : F[X][Y]} (Œ≤ : ùí™ H) : Set F :=
  {z : F | ‚àÉ root : rationalRoot (H_tilde' H) z, (œÄ_z z root) Œ≤ = 0}

def liftLeftNil {Œπ : Type} {œÉ : Type} (oSpec : OracleSpec Œπ) :
    SimOracle.Stateful ([]‚Çí ++‚Çí oSpec) oSpec œÉ where impl
  | query (.inr i) q => fun s ‚Ü¶ do return ‚ü®‚Üê query i q, s‚ü©

@[reducible]
def proverState (i : Fin n) : ProverState 2 where
  PrvState
  | 0 => (StatementRound R n i.castSucc) √ó (‚àÄ i, OracleStatement R n deg i)
  | 1 => (StatementRound R n i.castSucc) √ó (‚àÄ i, OracleStatement R n deg i)
  | 2 => (StatementRound R n i.succ) √ó (‚àÄ i, OracleStatement R n deg i)

def RoundByRound.append
    {WitMid‚ÇÅ : Fin (m + 1) ‚Üí Type} {WitMid‚ÇÇ : Fin (n + 1) ‚Üí Type}
    (E‚ÇÅ : Extractor.RoundByRound oSpec Stmt‚ÇÅ Wit‚ÇÅ Wit‚ÇÇ pSpec‚ÇÅ WitMid‚ÇÅ)
    (E‚ÇÇ : Extractor.RoundByRound oSpec Stmt‚ÇÇ Wit‚ÇÇ Wit‚ÇÉ pSpec‚ÇÇ WitMid‚ÇÇ) :
      Extractor.RoundByRound oSpec Stmt‚ÇÅ Wit‚ÇÅ Wit‚ÇÉ (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ)
        (Fin.append (m := m + 1) WitMid‚ÇÅ (Fin.tail WitMid‚ÇÇ) ‚àò Fin.cast (by admit /- proof elided -/
        )) where
  eqIn := by admit /- proof elided -/

class PolynomialLike.LawfulCoeff (R : Type u) [CommSemiring R] (P : Type v) [CommSemiring P]
    [PolynomialLike R P] (coeff : P ‚Üí ‚Ñï ‚Üí R) where
  coeff_finite (p : P) : Set.Finite {n | coeff p n ‚â† 0}

LawfulMonad in Init.Control.Lawful.Basic

@[simp]
instance CommRing (k : ‚Ñï) : CommRing (BTField k) := Field.toCommRing

abbrev OracleFunction (i : Fin (‚Ñì + 1)) : Type _ := sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i, by admit /- proof elided -/
    ‚ü© ‚Üí L

Coe in Init.Coe

def concat' {k : Fin n}
    (challenges : (i : Fin k) ‚Üí (pSpec.dir (i.castLE (by admit /- proof elided -/
    )) = .V_to_P
      ‚Üí pSpec.¬´Type¬ª (i.castLE (by admit /- proof elided -/
      ))))
    (chal : (h : pSpec.dir k = .V_to_P) ‚Üí pSpec.Challenge ‚ü®k, h‚ü©) :
    (i : Fin (k + 1)) ‚Üí (pSpec.dir (i.castLE (by admit /- proof elided -/
    )) = .V_to_P) ‚Üí
      pSpec.¬´Type¬ª (i.castLE (by admit /- proof elided -/
      )) :=
  Fin.dconcat challenges chal

@[reducible, simp]
def oraclePSpec : ProtocolSpec 1 := ‚ü®!v[.P_to_V], !v[Witness]‚ü©

def testNTTBTF‚ÇÉ : Fin (2 ^ (2 + 2)) ‚Üí BTF‚ÇÉ :=

Neg in Init.Prelude

def InternalData.rightSubtree {Œ± : Type} {s_left s_right : Skeleton}
    (tree : InternalData Œ± (Skeleton.internal s_left s_right)) :
    InternalData Œ± s_right :=
  match tree with
  | InternalData.internal _ _left right =>
    right

def projectToMidSumcheckPoly (t : MultilinearPoly L ‚Ñì)
    (m : MultilinearPoly L ‚Ñì) (i : Fin (‚Ñì + 1))
    (challenges : Fin i ‚Üí L)
    : MultiquadraticPoly L (‚Ñì-i) :=
  let H‚ÇÄ: MultiquadraticPoly L ‚Ñì := computeInitialSumcheckPoly (‚Ñì:=‚Ñì) t m
  let H·µ¢ := fixFirstVariablesOfMQP (‚Ñì := ‚Ñì) (v := ‚ü®i, by admit /- proof elided -/
  ‚ü©)
    (H := H‚ÇÄ) (challenges := challenges)
  ‚ü®H·µ¢, by admit /- proof elided -/
  ‚ü©

Nat.testBit in Init.Data.Nat.Bitwise.Basic

def eval‚ÇÇ (p : MlPoly R n) (f : R ‚Üí+* S) (x : Vector S n) : S := eval (map f p) x

Nat.digits in Mathlib.Data.Nat.Digits.Defs

def SkeletonNodeIndex.parent {s : Skeleton} (idx : SkeletonNodeIndex s) :
    Option (SkeletonNodeIndex s) :=
  match idx with
  | SkeletonNodeIndex.ofLeaf => none
  | SkeletonNodeIndex.ofInternal => none
  | SkeletonNodeIndex.ofLeft (.ofLeaf) => some .ofInternal
  | SkeletonNodeIndex.ofLeft (.ofInternal) => some .ofInternal
  | SkeletonNodeIndex.ofLeft idxLeft =>
    idxLeft.parent.map (SkeletonNodeIndex.ofLeft)
  | SkeletonNodeIndex.ofRight (.ofLeaf) => some .ofInternal
  | SkeletonNodeIndex.ofRight (.ofInternal) => some .ofInternal
  | SkeletonNodeIndex.ofRight idxRight =>
    idxRight.parent.map (SkeletonNodeIndex.ofRight)

Nat.card in Mathlib.SetTheory.Cardinal.Finite

protected def cast (R : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec‚ÇÅ) :
    Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec‚ÇÇ where
  prover := R.prover.cast hn hSpec
  verifier := R.verifier.cast hn hSpec

Algebra.TensorProduct.rightAlgebra in Mathlib.RingTheory.TensorProduct.Basic

def singleHash (left : Œ±) (right : Œ±) : OracleComp (spec Œ±) Œ± := do
  let out ‚Üê query (spec := spec Œ±) () ‚ü®left, right‚ü©
  return out

AdjoinRoot.instAlgebra in Mathlib.RingTheory.AdjoinRoot

def ratchet (state : FSVerifierState U H) :
    Except DomainSeparatorMismatch (FSVerifierState U H) := do
  let newHashState ‚Üê state.hashState.ratchet
  .ok { hashState := newHashState, nargString := state.nargString }

def InternalData.ofFun {Œ± : Type} (s : Skeleton)
    (f : SkeletonInternalIndex s ‚Üí Œ±) : InternalData Œ± s :=
  match s with
  | .leaf => InternalData.leaf
  | .internal l r =>
      InternalData.internal
        (f SkeletonInternalIndex.ofInternal)
        (InternalData.ofFun l (fun idx => f (SkeletonInternalIndex.ofLeft idx)))
        (InternalData.ofFun r (fun idx => f (SkeletonInternalIndex.ofRight idx)))

def FullTranscript.extractSalt (transcript : (pSpec.addSalt Salt).FullTranscript) :
    (i : pSpec.MessageIdx) ‚Üí Salt i :=
  Transcript.extractSalt (pSpec := pSpec) (k := Fin.last n) transcript

instance : IsEmpty (ChallengeIdx ‚ü®!v[.P_to_V], !v[Msg]‚ü©) :=
  ‚ü®fun ‚ü®i, h‚ü© => by admit /- proof elided -/
  ‚ü©

ByteArray.empty in Init.Prelude

def main (args : List String) : IO UInt32 := do lintStyle.validate args

@[inline, specialize]
def runWithLogToRound (i : Fin (n + 1))
    (stmt : StmtIn) (wit : WitIn) (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí)
        ((pSpec.Transcript i √ó prover.PrvState i) √ó QueryLog (oSpec ++‚Çí [pSpec.Challenge]‚Çí)) :=
  (simulateQ loggingOracle (prover.runToRound i stmt wit)).run

def ratchet (state : FSProverState U H R) :
    Except DomainSeparatorMismatch (FSProverState U H R) :=
  match state.hashState.ratchet with
  | .ok newHashState =>
    .ok { rng := state.rng, hashState := newHashState, nargString := state.nargString }
  | .error e => .error e

abbrev vempty {Œ± : Sort*} : Fin 0 ‚Üí Œ± := Fin.elim0

@[inline]
instance [h‚ÇÅ : ‚àÄ i, SelectableType (pSpec‚ÇÅ.Challenge i)]
    [h‚ÇÇ : ‚àÄ i, SelectableType (pSpec‚ÇÇ.Challenge i)] :
    ‚àÄ i, SelectableType ((pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).Challenge i) :=
  fun ‚ü®i, h‚ü© => Fin.fappend‚ÇÇ (A := Direction) (B := Type)
    (F := fun dir type => (h : dir = .V_to_P) ‚Üí SelectableType type)
    (Œ±‚ÇÅ := pSpec‚ÇÅ.dir) (Œ≤‚ÇÅ := pSpec‚ÇÇ.dir)
    (Œ±‚ÇÇ := pSpec‚ÇÅ.Type) (Œ≤‚ÇÇ := pSpec‚ÇÇ.Type) (fun i h => h‚ÇÅ ‚ü®i, h‚ü©) (fun i h => h‚ÇÇ ‚ü®i, h‚ü©) i h

noncomputable def minDist (C : Set (n ‚Üí R)) : ‚Ñï :=
  sInf {d | ‚àÉ u ‚àà C, ‚àÉ v ‚àà C, u ‚â† v ‚àß hammingDist u v = d}

noncomputable def queryOracleVerifier :
  OracleVerifier
    (oSpec := []‚Çí)
    (StmtIn := FinalSumcheckStatementOut (L:=L) (‚Ñì:=‚Ñì))
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (
    Fin.last ‚Ñì))
    (StmtOut := Bool)
    (OStmtOut := fun _ : Empty => Unit)
    (pSpec := pSpecQuery ùîΩq Œ≤ Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)) where
  verify := fun (stmt: FinalSumcheckStatementOut (L:=L) (‚Ñì:=‚Ñì))
    (challenges: (pSpecQuery ùîΩq Œ≤ Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).Challenges) => do
    
    let c := stmt.final_constant
    let fold_challenges : Fin Œ≥_repetitions ‚Üí sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate 0 :=
      challenges ‚ü®0, by admit /- proof elided -/
      ‚ü©

    
    
    for rep in (List.finRange Œ≥_repetitions) do
      let mut c_cur : L := 0 
      let v := fold_challenges rep

      for k_val in List.finRange (‚Ñì / œë) do
        let i := k_val * œë
        have h_k: k_val ‚â§ (‚Ñì/œë - 1) := by admit /- proof elided -/

abbrev contract (m : ‚Ñï) (f : Fin n ‚Üí Œ±) := liftF (liftF' (n := m) (liftF f))

noncomputable def polynomialFromNovelCoeffsF‚ÇÇ
  (‚Ñì : ‚Ñï) (h_‚Ñì : ‚Ñì ‚â§ r) (a : Fin (2 ^ ‚Ñì) ‚Üí L) : L‚¶É<2^‚Ñì‚¶Ñ[X] :=
  ‚ü®polynomialFromNovelCoeffs ùîΩq Œ≤ ‚Ñì h_‚Ñì a, by
    simp only [mem_degreeLT, Nat.cast_pow, Nat.cast_ofNat]
    apply (Polynomial.degree_sum_le Finset.univ (fun j => C (a j) * X‚±º ùîΩq Œ≤ ‚Ñì h_‚Ñì j)).trans_lt
    apply (Finset.sup_lt_iff ?_).mpr ?_
    ¬∑ -- ‚ä¢ ‚ä• < 2 ^ ‚Ñì
      exact compareOfLessAndEq_eq_lt.mp rfl
    ¬∑ -- ‚àÄ b ‚àà univ, (C (a b) * X‚±º ùîΩq Œ≤ ‚Ñì h_‚Ñì b).degree < 2 ^ ‚Ñì
      intro j _
      -- ‚ä¢ (C (a j) * X‚±º ùîΩq Œ≤ ‚Ñì h_‚Ñì j).degree < 2 ^ ‚Ñì
      calc (C (a j) * X‚±º ùîΩq Œ≤ ‚Ñì h_‚Ñì j).degree
        _ ‚â§ (C (a j)).degree + (X‚±º ùîΩq Œ≤ ‚Ñì h_‚Ñì j).degree :=

def partition (cs : ConstraintSystem ùì° numWires numGates) :
    Fin numWires ‚Üí Finset (Fin (3 * numGates)) :=
  
  
  
  
  fun i => Finset.map (Equiv.toEmbedding finProdFinEquiv)
    (Finset.filter (fun j => if j.1 = 0 then (cs j.2).a = i
      else if j.1 = 1 then (cs j.2).b = i else (cs j.2).c = i)
    (Finset.univ : Finset (Fin 3 √ó Fin numGates)))

def relationRound (i : Fin (n + 1)) :
    Set (((StatementRound R n i) √ó (‚àÄ i, OracleStatement R n deg i)) √ó Unit) :=
  { ‚ü®‚ü®‚ü®target, challenges‚ü©, polyOracle‚ü©, _‚ü© |
    ‚àë x ‚àà (univ.map D) ^·∂† (n - i), (polyOracle ()).val ‚∏®challenges, x‚∏© = target }

Cardinal in Mathlib.SetTheory.Cardinal.Defs

GaloisField.equivZmodP in Mathlib.FieldTheory.Finite.GaloisField

def discr_y {F : Type} [CommRing F] (f : F[X][Y]) : F[X] :=
   
  Classical.choose (resultant_is_divisible_by_leadingCoeff f)

@[reducible]
def pSpec : ProtocolSpec 2 :=
  ‚ü®
    !v[.V_to_P, .P_to_V],
    !v[
        F,
        (evalDomain D x (‚àë j' ‚àà (List.take (i.1 + 1) (List.finRange (k + 1))).toFinset, s j')) ‚Üí F
      ]
  ‚ü©

instance : DecidableEq AssocNat :=

instance instDCast : DCast Nat Fin where
  dcast h := Fin.cast h
  dcast_id := by admit /- proof elided -/

OracleSpec.QueryLog.inl in VCVio.OracleComp.QueryTracking.Structures

RingHomCompTriple in Mathlib.Algebra.Ring.CompTypeclasses

Except in Init.Prelude

def split (k : ‚Ñï) (h_k : k > 0) (x : BTField k) : BTField (k-1) √ó BTField (k-1) :=

noncomputable def proximity_gap_degree_bound (rho : ‚Ñö) (m n : ‚Ñï) : ‚Ñï :=
  let b := D_X rho m n
  if h : ‚àÉ n : ‚Ñï, b = n
  then h.choose - 1
  else Nat.floor b

noncomputable def AffSpanFinset [NeZero k] (U : Fin k ‚Üí Œπ ‚Üí F) : Finset (Œπ ‚Üí F) :=
  (AffSpanSet.instFinite U).toFinset

def reduction (i : Fin n) : Reduction oSpec
    ((StatementRound R n i.castSucc) √ó (‚àÄ i, OracleStatement R n deg i)) Unit
    ((StatementRound R n i.succ) √ó (‚àÄ i, OracleStatement R n deg i)) Unit (pSpec R deg) :=
  (Simple.reduction R deg D oSpec).liftContext (oCtxLens R n deg D i).toContext

OracleSpec.QueryLog in VCVio.OracleComp.QueryTracking.Structures

def seqComposeMessageEquiv {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)} :
    (i : Fin m) √ó (pSpec i).MessageIdx ‚âÉ (seqCompose pSpec).MessageIdx where
  toFun := fun ‚ü®i, msgIdx‚ü© => sigmaMessageIdxToSeqCompose i msgIdx
  invFun := seqComposeMessageIdxToSigma
  left_inv := by admit /- proof elided -/

@[simp]
abbrev Statement.AfterFirstChallenge : Type :=
  FirstChallenge R pp √ó Statement.AfterFirstMessage R pp

Polynomial.mapAlgHom in Mathlib.Algebra.Polynomial.AlgebraMap

instance {T} [HasSucc T] : CoeFun (Cayley T) (fun _ => T ‚Üí T) := ‚ü®Cayley.toFun‚ü©

class Deserialize.CloseToUniform (Œ± : Type u) (Œ≤ : Type u)
    [Fintype Œ±] [Fintype Œ≤] [Nonempty Œ±] [Nonempty Œ≤] [Deserialize Œ± Œ≤] where
  Œµ : ‚Ñù‚â•0
  Œµ_close : dist (PMF.uniformOfFintype Œ±) (deserialize <$> PMF.uniformOfFintype Œ≤) ‚â§ Œµ

@[elab_as_elim]
def dcons {n : ‚Ñï} {motive : Fin (n + 1) ‚Üí Sort u} (a : motive 0)
    (b : (i : Fin n) ‚Üí motive i.succ) (i : Fin (n + 1)) : motive i :=
  match n with
  | 0 => match i with | 0 => a
  | _ + 1 => match i with
    | 0 => a
    | ‚ü®k + 1, hk‚ü© => b ‚ü®k, Nat.succ_lt_succ_iff.mp hk‚ü©

abbrev take (m : ‚Ñï) (h : m ‚â§ n)
    (transcript : FullTranscript pSpec) : FullTranscript (pSpec.take m h) :=
  Fin.take m h transcript

Finsupp in Mathlib.Data.Finsupp.Defs

instance {i : Fin ‚Ñì} :
    ‚àÄ j, OracleInterface ((pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i).Message j)
  | ‚ü®0, _‚ü© => by admit /- proof elided -/

instance instHPowConcreteBTF‚Ñ§ {k : ‚Ñï} : HPow (ConcreteBTField k) ‚Ñ§ (ConcreteBTField k) where
  hPow a n :=
    match n with
    | Int.ofNat m => concrete_pow_nat a m
    | Int.negSucc m =>
      
      if a = 0 then 0
      else concrete_pow_nat (concrete_inv a) (m + 1) 

instance : Fact (Nat.Prime fieldSize) := ‚ü®is_prime‚ü©

noncomputable def novelToMonomialCoeffs

  (‚Ñì : ‚Ñï) (h_‚Ñì : ‚Ñì ‚â§ r) (novel_coeffs : Fin (2 ^ ‚Ñì) ‚Üí L) : Fin (2^‚Ñì) ‚Üí L :=
  let A := changeOfBasisMatrix ùîΩq Œ≤ ‚Ñì h_‚Ñì
  Matrix.vecMul novel_coeffs A

noncomputable def novelPolynomialBasis (‚Ñì : Nat) (h_‚Ñì : ‚Ñì ‚â§ r) :
  Basis (Fin (2^‚Ñì)) (R := L) (M := L‚¶É<2^‚Ñì‚¶Ñ[X]) :=

Fin.isEmpty' in Mathlib.Logic.IsEmpty

noncomputable def sDomain (i : Fin r) : Subspace ùîΩq L :=
  let W_i_norm := normalizedW ùîΩq Œ≤ i
  let h_W_i_norm_is_additive : IsLinearMap ùîΩq (fun x : L => W_i_norm.eval x) :=
    AdditiveNTT.normalizedW_is_additive ùîΩq Œ≤ i
  Submodule.map (polyEvalLinearMap W_i_norm h_W_i_norm_is_additive)
    (U ùîΩq Œ≤ ‚ü®‚Ñì + R_rate, h_‚Ñì_add_R_rate‚ü©)

Zero in Init.Prelude

def findIdxRev? (cond : Œ± ‚Üí Bool) (as : Array Œ±) : Option (Fin as.size) :=
  find ‚ü® as.size, Nat.lt_succ_self _ ‚ü©
where
  find : Fin (as.size + 1) ‚Üí Option (Fin as.size)
    | 0 => none
    | ‚ü® i+1, h ‚ü© =>
      if (cond as[i]) then
        some ‚ü® i, Nat.lt_of_succ_lt_succ h ‚ü©
      else
        find ‚ü® i, Nat.lt_of_succ_lt h ‚ü©

@[ext]
structure VectorSpec (n : ‚Ñï) where
  dir : Fin n ‚Üí Direction
  length : Fin n ‚Üí Nat

IsField in Mathlib.Algebra.Field.IsField

Nonempty in Init.Prelude

def solutionToE (e k : ‚Ñï) (v : Fin (2 * e + k) ‚Üí F) : Polynomial F :=
  ‚ü®
    insert e ((Finset.range e).filter (fun x => liftF v x ‚â† 0)),
    fun i => if i = e then 1 else if i < e then liftF v i else 0,
    by admit /- proof elided -/
  ‚ü©

structure ModifiedGuruswami
  (m n k : ‚Ñï)
  (œâs : Fin n ‚Ü™ F)
  (Q : F[Z][X][Y])
  (u‚ÇÄ u‚ÇÅ : Fin n ‚Üí F)
  where
  Q_ne_0 : Q ‚â† 0
   
  Q_deg : natWeightedDegree Q 1 k < D_X ((k + 1) / (n : ‚Ñö)) n m
   
  Q_multiplicity : ‚àÄ i, rootMultiplicity Q
              (Polynomial.C <| œâs i)
              ((Polynomial.C <| u‚ÇÄ i) + Polynomial.X * (Polynomial.C <| u‚ÇÅ i))
            ‚â• m
   
  Q_deg_X :
    degreeX Q < D_X ((k + 1) / (n : ‚Ñö)) n m
   
  Q_D_Y :
    D_Y Q < D_X (k + 1 / (n : ‚Ñö)) n m / k
   
  Q_D_YZ :
    D_YZ Q ‚â§ n * (m + 1/(2 : ‚Ñö))^3 / (6 * Real.sqrt ((k + 1) / n))

instance {n : ‚Ñï} {Œ± : Fin n ‚Üí Type*} : SliceGE ((i : Fin n) ‚Üí Œ± i) ‚Ñï
    (fun _ start => start ‚â§ n)
    (fun _ start h =>
      (i : Fin (n - start)) ‚Üí Œ± (Fin.cast (Nat.sub_add_cancel h) (i.addNat start)))
    where
  sliceGE := fun v start h => drop start h v

instance : Pow (UniPoly R) Nat := ‚ü®UniPoly.pow‚ü©

def verifySmallPrime (n' : Q(‚Ñï)) : MetaM Q(Nat.Prime $n') :=
  match n'.natLit! with
    | 2 => do haveI : $n' =Q 2 := ‚ü®‚ü©; return q(prime_2)
    | 3 => do haveI : $n' =Q 3 := ‚ü®‚ü©; return q(prime_3)
    | 5 => do haveI : $n' =Q 5 := ‚ü®‚ü©; return q(prime_5)
    | 7 => do haveI : $n' =Q 7 := ‚ü®‚ü©; return q(prime_7)
    | 11 => do haveI : $n' =Q 11 := ‚ü®‚ü©; return q(prime_11)
    | 13 => do haveI : $n' =Q 13 := ‚ü®‚ü©; return q(prime_13)
    | 17 => do haveI : $n' =Q 17 := ‚ü®‚ü©; return q(prime_17)
    | 19 => do haveI : $n' =Q 19 := ‚ü®‚ü©; return q(prime_19)
    | 23 => do haveI : $n' =Q 23 := ‚ü®‚ü©; return q(prime_23)
    | 29 => do haveI : $n' =Q 29 := ‚ü®‚ü©; return q(prime_29)
    | 31 => do haveI : $n' =Q 31 := ‚ü®‚ü©; return q(prime_31)
    | 37 => do haveI : $n' =Q 37 := ‚ü®‚ü©; return q(prime_37)
    | 41 => do haveI : $n' =Q 41 := ‚ü®‚ü©; return q(prime_41)
    | 43 => do haveI : $n' =Q 43 := ‚ü®‚ü©; return q(prime_43)
    | 47 => do haveI : $n' =Q 47 := ‚ü®‚ü©; return q(prime_47)
    | _ => failure

def KnowledgeStateFunctionOneShot.toKnowledgeStateFunction
    {relIn : Set (StmtIn √ó WitIn)} {relOut : Set (StmtOut √ó WitOut)}
    {verifier : Verifier oSpec StmtIn StmtOut pSpec}
    (stF : KnowledgeStateFunctionOneShot init impl relIn.language relOut.language verifier)
    (oneShotE : Extractor.RoundByRoundOneShot oSpec StmtIn WitIn pSpec) :
    verifier.KnowledgeStateFunction init impl relIn relOut oneShotE.toRoundByRound where
  toFun := fun m stmtIn tr witIn => if m = 0 then (stmtIn, witIn) ‚àà relIn else
    stF.toFun m stmtIn tr ‚à® (stmtIn, oneShotE m stmtIn tr default) ‚àà relIn
  toFun_empty := fun stmtIn witIn => by admit /- proof elided -/

Equiv.cast in Mathlib.Logic.Equiv.Defs

@[reducible, simp]
def soundness
    (langIn : Set (Statement √ó ‚àÄ i, OStatement i))
    (verifier : OracleVerifier oSpec Statement OStatement Bool (fun _ : Empty => Unit) pSpec)
    (soundnessError : ‚Ñù‚â•0) : Prop :=
  verifier.toVerifier.soundness init impl langIn acceptRejectOracleRel.language soundnessError

noncomputable def decoder (e k : ‚Ñï) [NeZero n] (œâs f : Fin n ‚Üí F) : Option (Polynomial F) :=
  if ‚Äñf‚Äñ‚ÇÄ ‚â§ e
  then some 0
  else
    let x := linsolve (BerlekampWelchMatrix e k œâs f) (Rhs e œâs f)
    match x with
    | none => none
    | some x =>
      let E := solutionToE e k x
      let Q := solutionToQ e k x
      if Q % E = 0 then
        let p := Q / E
        if Œî‚ÇÄ(f, p.eval ‚àò œâs) ‚â§ e then
          some p
        else
          none
      else
        none

instance instDCastPSigma : DCast ((a : Œ±) √ó' Œ≤ a) (fun a => Œ≥ a.1 a.2) where
  dcast hab c := dcast‚ÇÇ (by admit /- proof elided -/
  ) (by admit /- proof elided -/
  ) c
  dcast_id := by admit /- proof elided -/

AddSubmonoidClass in Mathlib.Algebra.Group.Submonoid.Defs

Vector.get in Init.Data.Vector.Basic

def inputRelation : Set ((StmtIn R √ó (‚àÄ i, OStmtIn R deg i)) √ó Unit) :=
  { ‚ü®‚ü®target, oStmt‚ü©, _‚ü© | ‚àë x ‚àà (univ.map D), (oStmt ()).1.eval x = target }

instance : Unique (ChallengesUpTo 0 pSpec) where
  default := fun ‚ü®i, _‚ü© => Fin.elim0 i
  uniq := fun T => by admit /- proof elided -/

def oracleReduction : OracleReduction oSpec
      Statement OStatement Unit
      Unit (OStatement ‚äï·µ• OStatement) Unit (pSpec OStatement) where
  prover := oracleProver oSpec Statement OStatement
  verifier := oracleVerifier oSpec Statement OStatement relComp

def AlgebraTowerEquiv.algebraMapLeftUp (e : AlgebraTowerEquiv A B) (i j : Œπ)
    (h : i ‚â§ j) : (B i) ‚Üí+* (A j) :=

def SkeletonNodeIndex.sibling {s : Skeleton} (idx : SkeletonNodeIndex s) :
    Option (SkeletonNodeIndex s) :=
  match idx with
  
  | SkeletonNodeIndex.ofLeaf => none
  
  | SkeletonNodeIndex.ofInternal => none
  
  | @SkeletonNodeIndex.ofLeft left right idxLeft =>
    match idxLeft with
    
    | SkeletonNodeIndex.ofLeaf => some (getRootIndex right).ofRight
    
    | SkeletonNodeIndex.ofInternal => some (getRootIndex right).ofRight
    
    
    | SkeletonNodeIndex.ofLeft idxLeftLeft =>
      idxLeftLeft.ofLeft.sibling.map (SkeletonNodeIndex.ofLeft)
    | SkeletonNodeIndex.ofRight idxLeftRight =>
      idxLeftRight.ofRight.sibling.map (SkeletonNodeIndex.ofLeft)
  | @SkeletonNodeIndex.ofRight left right idxRight =>
    match idxRight with
    | SkeletonNodeIndex.ofLeaf => some (getRootIndex left).ofLeft
    | SkeletonNodeIndex.ofInternal => some (getRootIndex left).ofLeft
    | SkeletonNodeIndex.ofLeft idxRightLeft =>
      idxRightLeft.ofLeft.sibling.map (SkeletonNodeIndex.ofRight)
    | SkeletonNodeIndex.ofRight idxRightRight =>
      idxRightRight.ofRight.sibling.map (SkeletonNodeIndex.ofRight)

instance instToNat {n : ‚Ñï} : ToNat (CNat n) := match n with
  | 0 => by admit /- proof elided -/
  | .succ n => @Cayley.instToNatOfZero (CNat n) instHasSucc instZero instToNat

@[reducible, simp]
def relIn : Set (Statement √ó Unit) := { ‚ü®stmt, _‚ü© | pred stmt }

@[ext]
structure OracleReduction {Œπ : Type} (oSpec : OracleSpec Œπ)
    (StmtIn : Type) {Œπ‚Çõ·µ¢ : Type} (OStmtIn : Œπ‚Çõ·µ¢ ‚Üí Type) (WitIn : Type)
    (StmtOut : Type) {Œπ‚Çõ‚Çí : Type} (OStmtOut : Œπ‚Çõ‚Çí ‚Üí Type) (WitOut : Type)
    {n : ‚Ñï} (pSpec : ProtocolSpec n)
    [O‚Çõ·µ¢ : ‚àÄ i, OracleInterface (OStmtIn i)] [O‚Çò : ‚àÄ i, OracleInterface (pSpec.Message i)]
    where
  prover : OracleProver oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec
  verifier : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec

def someTypes : List Type := [Nat, String, Nat]

List.Vector in Mathlib.Data.Vector.Defs

@[reducible]
def Witness (F : Type) [Semiring F] {k : ‚Ñï} (s : Fin (k + 1) ‚Üí ‚Ñï+) (d : ‚Ñï+) (m : ‚Ñï) :=
  Fin (m + 1) ‚Üí F‚¶É< 2 ^ (‚àë i, (s i).1) * d‚¶Ñ[X]

inductive VectorOp where | dotProd

def outputRelation (cond : ‚àë i, (s i).1 ‚â§ n) [DecidableEq F] (Œ¥ : ‚Ñù‚â•0) :
    Set
      (
        (Statement F i.succ √ó (‚àÄ j, OracleStatement D x s i.succ j)) √ó
        Witness F s d i.succ.castSucc
      ) := sorry

instance : ‚àÄ j, OracleInterface ((batchSpec F m).Message j)
  | ‚ü®0, h‚ü© => nomatch h

def knowledgeStateFunction :
    (oracleVerifier oSpec OStatement).KnowledgeStateFunction init impl
    (relIn OStatement) (relOut OStatement) (rbrExtractor oSpec OStatement) where
  toFun
  | 0 => fun ‚ü®_, oracles‚ü© _ _ => oracles 0 = oracles 1
  | 1 => fun ‚ü®_, oracles‚ü© chal _ =>
    let q : Query OStatement := by admit /- proof elided -/

noncomputable def foldNth (n : ‚Ñï) (f : ùîΩ[X]) (Œ± : ùîΩ) [inst : NeZero n] : ùîΩ[X] :=
  ‚àë i : Fin n, Polynomial.C Œ± ^ i.1 * splitNth f n i

@[simps!]
def MessageIdx.sumEquiv :
    MessageIdx pSpec‚ÇÅ ‚äï MessageIdx pSpec‚ÇÇ ‚âÉ MessageIdx (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ) where
  toFun := Sum.elim (MessageIdx.inl) (MessageIdx.inr)
  invFun := fun ‚ü®i, h‚ü© => by admit /- proof elided -/

@[reducible, simp] def StmtAfterRandomQuery : Type := R

LinearMap.domRestrict in Mathlib.Algebra.Module.Submodule.LinearMap

instance (k : ‚Ñï) : AddCommGroup (ConcreteBTField k) := mkAddCommGroupInstance

BitVec.extractLsb' in Init.Data.BitVec.Basic

def soundness
    (langIn : Set (StmtIn √ó ‚àÄ i, OStmtIn i))
    (langOut : Set (StmtOut √ó ‚àÄ i, OStmtOut i))
    (verifier : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec)
    (soundnessError : ‚Ñù‚â•0) : Prop :=
  verifier.toVerifier.soundness init impl langIn langOut soundnessError

instance (k : ‚Ñï) : HMul (ConcreteBTField k) (ConcreteBTField k) (ConcreteBTField k)
  where hMul := concrete_mul

Polynomial.derivative in Mathlib.Algebra.Polynomial.Derivative

def MessageIdx.inr (i : MessageIdx pSpec‚ÇÇ) : MessageIdx (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ) :=
  ‚ü®Fin.natAdd m i.1, by admit /- proof elided -/
  ‚ü©

@[simp]
def innerRelOut_Test : Set (InnerStmtOut_Test √ó Unit) :=
  setOf (fun ‚ü®‚ü®f, t, r‚ü©, _‚ü© => f.eval r = t)

structure Simulator (oSpec : OracleSpec Œπ) (StmtIn : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n) where
  SimState : Type
  oracleSim : SimOracle.Stateful oSpec oSpec SimState
  proverSim : StmtIn ‚Üí StateT SimState (OracleComp oSpec) pSpec.FullTranscript

def outputRelation (cond : ‚àë i, (s i).1 ‚â§ n) [DecidableEq F] (Œ¥ : ‚Ñù‚â•0) :
    Set
      (
        (FinalStatement F k √ó ‚àÄ j, FinalOracleStatement D x s j) √ó
        Witness F s d (Fin.last (k + 1))
      ) := sorry

multiplicity in Mathlib.RingTheory.Multiplicity

def totalNumQueries (stmt : StmtIn) (challenges : ‚àÄ i, pSpec.Challenge i)
    (naVerifier : OracleVerifier.NonAdaptive oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec) : ‚Ñï :=
  (naVerifier.queryOStmt stmt challenges).length + (naVerifier.queryMsg stmt challenges).length

def mul (m n : ChurchNat Œ±) : ChurchNat Œ± := fun f => n (m f)

def happend {m n : ‚Ñï} {Œ± : Fin m ‚Üí Sort u} {Œ≤ : Fin n ‚Üí Sort u}
    (u : (i : Fin m) ‚Üí Œ± i) (v : (i : Fin n) ‚Üí Œ≤ i) : (i : Fin (m + n)) ‚Üí Fin.vappend Œ± Œ≤ i :=
  fappend (F := id) u v

class Prover.IsPure (P : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) where
    is_pure : ‚àÉ sendMessage : ‚àÄ _, _ ‚Üí _, ‚àÄ i st,
      P.sendMessage i st = pure (sendMessage i st)

Subtype.eq_iff in Init.Ext

@[reducible, simp]
def toRelInput : Set ((Statement √ó (‚àÄ i, OStatement i)) √ó Unit) :=
  { ‚ü®‚ü®stmt, oStmt‚ü©, _‚ü© | simulateQ' (toOracleImpl OStatement oStmt) (pred stmt) (hPred stmt) }

instance : ‚àÄ j, OracleInterface (OracleStatement D x m j) :=
  fun _ => inferInstance

def dfoldlM' (n : ‚Ñï) (Œ± : Fin (n + 1) ‚Üí Type u)
    (f : (i : Fin n) ‚Üí Œ± i.castSucc ‚Üí m (Œ± i.succ)) (init : Œ± 0) : m (Œ± (last n)) :=
  match n with
  | 0 => pure init
  | n + 1 => do
    let x ‚Üê dfoldlM' n (Œ± ‚àò castSucc) (fun i => f i.castSucc) init
    f (last n) x

def curve : WeierstrassCurve BaseField := {
  a‚ÇÅ := 0,  
  a‚ÇÇ := 0,  
  a‚ÇÉ := 0,  
  a‚ÇÑ := 0,  
  a‚ÇÜ := 3   
}

instance : ‚àÄ i, OracleInterface ((pSpecFinalSumcheckStep (L:=L)).Message i)
  | ‚ü®0, _‚ü© => by admit /- proof elided -/

noncomputable def toPoly (p : UniPoly R) : Polynomial R :=
  p.eval‚ÇÇ Polynomial.C Polynomial.X

def ofMvPolynomialDeg1 (p : R‚¶É‚â§ 1‚¶Ñ[X Fin n]) : MlPoly R n :=
  Vector.ofFn (fun i : Fin (2 ^ n) => p.val.coeff (monomialOfNat i))

def finUInt8Equiv : Fin (2 ^ 8) ‚âÉ UInt8 where
  toFun := fun i => UInt8.ofFin i
  invFun := fun u => u.toFin
  left_inv _ := rfl
  right_inv _ := rfl

def implGroupExpOracle : QueryImpl (GroupExpOracle Œπ p) (StateT (GroupValTable Œπ G) Option) where
  impl | query _ ‚ü®i, a, j‚ü© => fun table =>
    match table i with
    | some g => some ((), table.update j (some (g ^ a.val)))
    | none => none

instance instTestLensComplete : testLens.IsComplete
      outerRelIn_Test innerRelIn_Test outerRelOut_Test innerRelOut_Test
      (fun ‚ü®‚ü®p, q, _‚ü©, _‚ü© ‚ü®‚ü®f, _‚ü©, _‚ü© => p * q = f) where
  proj_complete := fun ‚ü®p, q, t‚ü© () hRelIn => by admit /- proof elided -/

Char.ofNat in Init.Prelude

def leftpad (m‚ÇÇ n‚ÇÇ : ‚Ñï) (a : Œ±) {m‚ÇÅ n‚ÇÅ : ‚Ñï} (M : Matrix (Fin m‚ÇÅ) (Fin n‚ÇÅ) Œ±) :
    Matrix (Fin m‚ÇÇ) (Fin n‚ÇÇ) Œ± :=
  Fin.leftpad m‚ÇÇ (fun _ => a) (Fin.leftpad n‚ÇÇ a ‚àò M)

def numberOfClosePts (u v : Œπ ‚Üí F) (deg : ‚Ñï) (Œ± : Œπ ‚Ü™ F) (e : ‚Ñï) : ‚Ñï :=
  Fintype.card (closePtsOnAffineLine u v deg Œ± e)

instance instDCast‚ÇÉ : DCast‚ÇÉ Nat (fun n => Fin (n + 1)) (fun n _ => ProtocolSpec n)
    (fun _ k pSpec => pSpec.Transcript k) where
  dcast‚ÇÉ h h' h'' T := Transcript.cast h
    (by admit /- proof elided -/
    )
    (by admit /- proof elided -/
    )
    T
  dcast‚ÇÉ_id := cast_id

Fintype.piFinset in Mathlib.Data.Fintype.Pi

@[reducible, simp]
def StmtOut : Type := R √ó R

def params16 : Params where
  width := 16
  numFullRounds := 8
  numPartialRounds := 20
  internalDiagVectors := #v[
       -2,
        1,
        2,
        1 / 2,
        3,
        4,
        -1 / 2,
        -3,
        -4,
        1 / (2 ^ 8),
        1 / 8,
        1 / (2 ^ 24),
        -1 / (2 ^ 8),
        -1 / 8,
        -1 / 16,
        -1 / (2 ^ 24),
    ]
  roundConstants := rawConstants16
  width_dvd_by_4 := by admit /- proof elided -/

Subtype.val in Init.Prelude

def LeafData.leftSubtree {Œ± : Type} {s_left s_right : Skeleton}
    (tree : LeafData Œ± (Skeleton.internal s_left s_right)) :
    LeafData Œ± s_left :=
  match tree with
  | LeafData.internal left _right =>
    left

ringChar.charP in Mathlib.Algebra.CharP.Defs

def generateSrs (n : ‚Ñï) (a : ZMod p) : Vector G‚ÇÅ (n + 1) √ó Vector G‚ÇÇ 2 :=
  (towerOfExponents g‚ÇÅ a n, towerOfExponents g‚ÇÇ a 1)

noncomputable def canonicalRepOfùí™ {H : F[X][Y]} (Œ≤ : ùí™ H) : F[X][Y] :=
  Polynomial.modByMonic Œ≤.out (H_tilde' H)

class OracleInterfaces (pSpec : ProtocolSpec n) where
  oracleInterfaces : ‚àÄ i, Option (OracleInterface (pSpec.Message i))

hammingDist in Mathlib.InformationTheory.Hamming

class Deserialize (Œ± : Type u) (Œ≤ : Type v) where
  deserialize : Œ≤ ‚Üí Œ±

instance : ‚àÄ i, OracleInterface (Message !p[] i) :=
  fun ‚ü®i, h‚ü© =>
    (Fin.elim0 i : (h' : !p[].dir i = .P_to_V) ‚Üí OracleInterface (!p[].Message ‚ü®i, h'‚ü©)) h

Nat in Init.Prelude

String.intercalate in Init.Data.String.Defs

def evalY (a : F) (f : F[X][Y]) : Polynomial F := Polynomial.eval (Polynomial.C a) f

def rbrKnowledgeSoundness
    (relIn : Set ((StmtIn √ó ‚àÄ i, OStmtIn i) √ó WitIn))
    (relOut : Set ((StmtOut √ó ‚àÄ i, OStmtOut i) √ó WitOut))
    (verifier : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec)
    (rbrKnowledgeError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) : Prop :=
  verifier.toVerifier.rbrKnowledgeSoundness init impl relIn relOut rbrKnowledgeError

instance : ToNat AssocNat where
  toNat := toNat

class IsSecureWithGap
    (completeRelation : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (soundRelation : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (Œµ_rbr : vPSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0)
    (vectorIOP : VectorIOP Statement OStatement Witness vPSpec A) where

   
  is_complete : vectorIOP.perfectCompleteness (pure ()) ‚ü®isEmptyElim‚ü© completeRelation

   
  is_rbr_knowledge_sound :
    OracleProof.rbrKnowledgeSoundness (pure ()) ‚ü®isEmptyElim‚ü© soundRelation vectorIOP.verifier Œµ_rbr

MvPolynomial.eval in Mathlib.Algebra.MvPolynomial.Eval

class SpongeSize where
   
  N : Nat
   
  R : Nat
   
  R_lt_N : R < N := by admit /- proof elided -/

@[inline, reducible]
def toContext :
    Context.Lens (OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i)) (OuterStmtOut √ó (‚àÄ i, OuterOStmtOut i))
                (InnerStmtIn √ó (‚àÄ i, InnerOStmtIn i)) (InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i))
                OuterWitIn OuterWitOut InnerWitIn InnerWitOut :=
  ‚ü®lens.stmt, lens.wit‚ü©

HEq in Init.Prelude

noncomputable def verifyOpening (verifySrs : Vector G‚ÇÇ 2) (commitment : G‚ÇÅ) (opening : G‚ÇÅ)
    (z : ZMod p) (v : ZMod p) : Prop :=
  pairing (commitment / g‚ÇÅ ^ v.val) (verifySrs[0]) = pairing opening (verifySrs[1] / g‚ÇÇ ^ z.val)

def finUInt64Equiv : Fin (2 ^ 64) ‚âÉ UInt64 where
  toFun := fun i => UInt64.ofFin i
  invFun := fun u => u.toFin
  left_inv _ := rfl
  right_inv _ := rfl

@[ext]
structure Reduction {Œπ : Type} (oSpec : OracleSpec Œπ)
    (StmtIn WitIn StmtOut WitOut : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n) where
  prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec
  verifier : Verifier oSpec StmtIn StmtOut pSpec

noncomputable def X‚±º (‚Ñì : ‚Ñï) (h_‚Ñì : ‚Ñì ‚â§ r) (j : Fin (2 ^ ‚Ñì)) : L[X] :=
  (Finset.univ : Finset (Fin ‚Ñì)).prod
    (fun i => (normalizedW ùîΩq Œ≤ (Fin.castLE h_‚Ñì i))^(Nat.getBit i j))

instance [h : ProverLast pSpec] : ProverFirst pSpec where
  prover_first' := by admit /- proof elided -/

@[reducible, inline]
instance (priority := low) instTensorForall {Œπ : Type u} (v : Œπ ‚Üí Type v)
    [O : ‚àÄ i, OracleInterface (v i)] : OracleInterface (‚àÄ i, v i) where
  Query := (i : Œπ) ‚Üí (O i).Query
  Response := (i : Œπ) ‚Üí (O i).Response
  answer := fun f q i => (O i).answer (f i) (q i)

noncomputable def finalSumcheckProver :
  OracleProver
    (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì))
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì))
    (StmtOut := FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì))
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (WitOut := Unit)
    (pSpec := pSpecFinalSumcheckStep (L := L)) where
  PrvState := fun
    | 0 => Statement (L := L) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì) √ó (‚àÄ j, OracleStatement ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì) j)
        √ó Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì)
    | _ => Statement (L := L) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì) √ó (‚àÄ j, OracleStatement ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì) j)
        √ó Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì) √ó L
  input := fun ‚ü®‚ü®stmt, oStmt‚ü©, wit‚ü© => (stmt, oStmt, wit)

  sendMessage
  | ‚ü®0, _‚ü© => fun ‚ü®stmtIn, oStmtIn, witIn‚ü© => do
    let f‚Ñì : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := ‚ü®‚Ñì, by admit /- proof elided -/
    ‚ü©)
      := witIn.f
    
    let c : L := f‚Ñì ‚ü®0, by admit /- proof elided -/
    ‚ü© 
    pure ‚ü®c, (stmtIn, oStmtIn, witIn, c)‚ü©

  receiveChallenge
  | ‚ü®0, h‚ü© => nomatch h 

  output := fun ‚ü®stmtIn, oStmtIn, witIn, c‚ü© => do
    let stmtOut : FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì) := {
      ctx := stmtIn.ctx,
      
      sumcheck_target := stmtIn.sumcheck_target,
      challenges := stmtIn.challenges,
      final_constant := c
    }

    pure (‚ü®stmtOut, oStmtIn‚ü©, ())

@[reducible]
def StateRestoration.KnowledgeSoundness (oSpec : OracleSpec Œπ)
    (StmtIn : Type) {Œπ‚Çõ·µ¢ : Type} (OStmtIn : Œπ‚Çõ·µ¢ ‚Üí Type) (WitOut : Type)
    {n : ‚Ñï} {pSpec : ProtocolSpec n} :=
  Prover.StateRestoration.KnowledgeSoundness oSpec (StmtIn √ó (‚àÄ i, OStmtIn i)) WitOut pSpec

Mathlib.Linter.TextBased.ErrorFormat in Mathlib.Tactic.Linter.TextBased

def concat {k : Fin n} (challenges : ChallengesUpTo k.castSucc pSpec)
    (h : pSpec.dir k = .V_to_P) (chal : pSpec.Challenge ‚ü®k, h‚ü©) : ChallengesUpTo k.succ pSpec :=
  fun ‚ü®i, h‚ü© => (concat' (pSpec := pSpec) (fun i hi => challenges ‚ü®i, hi‚ü©) (fun _ => chal)) i h

instance [VerifierFirst pSpec] : VerifierLast pSpec where
  verifier_last' := by admit /- proof elided -/

def Fin2ToF2 (ùîΩq : Type*) [Ring ùîΩq] (k : Fin 2) : ùîΩq :=
  if k = 0 then 0 else 1

instance : HasSize UInt8 UInt8 where
  size := 1
  toFun := ‚ü®fun byte => #v[byte], by admit /- proof elided -/
  ‚ü©

instance {s} : LawfulFunctor (fun Œ± => LeafData Œ± s) :=

StateT.run in Init.Control.State

finFunctionFinEquiv in Mathlib.Algebra.BigOperators.Fin

@[reducible]
def FinalOracleStatement : Fin (k + 2) ‚Üí Type :=
  fun j =>
    if j.1 = k + 1
    then (Unit ‚Üí F[X])
    else (evalDomain D x (‚àë j' ‚àà finRangeTo j.1, s j') ‚Üí F)

def principalIdeal {F : Type} [Semiring F] (f : F) : Ideal F := Ideal.span {f}

def LeafData.get {s} {Œ± : Type}
    (tree : LeafData Œ± s) (idx : SkeletonLeafIndex s) : Œ± :=
  match tree, idx with
  | LeafData.leaf value, SkeletonLeafIndex.ofLeaf => value
  | LeafData.internal left _, SkeletonLeafIndex.ofLeft idxLeft =>
    LeafData.get left idxLeft
  | LeafData.internal _ right, SkeletonLeafIndex.ofRight idxRight =>
    LeafData.get right idxRight

Set.toFinset in Mathlib.Data.Fintype.Sets

def oracleReduction.reduceClaim : OracleReduction oSpec
    (StmtAfterRandomQuery R) (OStmtAfterRandomQuery R deg) Unit
    (StmtOut R) (OStmtOut R deg) Unit !p[] :=

instance : EDist (n ‚Üí R) where
  edist := fun u v => hammingDist u v

def verifyNeOne (n a' q : Q(‚Ñï)) (a : Q(ZMod $n)) (_ : Q(($a' : ZMod $n) = $a)) :
    MetaM Q($a ^ (($n - 1) / $q) ‚â† 1) := do
  
  let p : Q(ZMod $n) := q($a ^ (($n - 1) / $q))
  let .isNat _ c hc ‚Üê Tactic.ReduceModChar.normIntNumeral n p
    q(CommRing.toRing) q(ZMod.charP $n) | failure
  
  
  
  assumeInstancesCommute
  have hn : Q(decide ($n ‚â• 2) = true) := (q(Eq.refl true) : Expr)
  have hc‚ÇÅ : Q(decide ($c < $n) = true) := (q(Eq.refl true) : Expr)
  have hc‚ÇÇ : Q(decide ($c ‚â† 1) = true) := (q(Eq.refl true) : Expr)
  return q(ZMod.blub $a $hn $hc‚ÇÅ $hc‚ÇÇ $hc)

PFunctor.Lens.id in ToMathlib.PFunctor.Lens.Basic

def toOracleImpl {Œπ : Type u} (v : Œπ ‚Üí Type v) [O : ‚àÄ i, OracleInterface (v i)]
    (data : ‚àÄ i, v i) : QueryImpl [v]‚Çí Id where
  impl | query i t => (O i).answer (data i) t

def mkRingInstance {k : ‚Ñï} (props : ConcreteBTFieldProps k) : Ring (ConcreteBTField k) where
  toAddCommGroup := mkAddCommGroupInstance
  toOne := inferInstance
  mul := concrete_mul
  mul_assoc := props.mul_assoc
  one_mul := props.one_mul
  mul_one := props.mul_one
  left_distrib := props.mul_left_distrib
  right_distrib := props.mul_right_distrib
  zero_mul := props.zero_mul
  mul_zero := props.mul_zero

  natCast n := natCast n
  natCast_zero := natCast_zero
  natCast_succ n := natCast_succ n
  intCast n := intCast n
  intCast_ofNat n := intCast_ofNat n
  intCast_negSucc n := intCast_negSucc n

def perm (cs : ConstraintSystem ùì° numWires numGates) : Equiv.Perm (Fin (3 * numGates)) := sorry

inductive SkeletonNodeIndex : Skeleton ‚Üí Type
  | ofLeaf : SkeletonNodeIndex Skeleton.leaf
  | ofInternal {left right} :
      SkeletonNodeIndex (Skeleton.internal left right)
  | ofLeft {left right : Skeleton} (idxLeft : SkeletonNodeIndex left) :
      SkeletonNodeIndex (Skeleton.internal left right)
  | ofRight {left right : Skeleton} (idxRight : SkeletonNodeIndex right) :
      SkeletonNodeIndex (Skeleton.internal left right)

def run (adversary : Adversary Œπ G p bitLength Œ±) (table : GroupValTable Œπ G) : List G √ó Œ± :=
  sorry

Rat.castRec in Mathlib.Algebra.Field.Defs

def C : Nat := sz.N - sz.R

@[inline, specialize]
def oracleProver : OracleProver oSpec
    Statement OStatement (‚àÄ i, Witness i)
    Statement (OStatement ‚äï·µ• Witness) Unit
    (oraclePSpec Witness) where
  PrvState := fun _ => (Statement √ó (‚àÄ i, OStatement i)) √ó (‚àÄ i, Witness i)
  input := id
  sendMessage | ‚ü®0, _‚ü© => fun ‚ü®stmt, wit‚ü© => pure (wit, ‚ü®stmt, wit‚ü©)
  
  receiveChallenge | ‚ü®0, h‚ü© => nomatch h
  output := fun ‚ü®‚ü®stmt, oStmt‚ü©, wit‚ü© => pure (‚ü®stmt, Sum.rec oStmt wit‚ü©, ())

QueryImpl in VCVio.OracleComp.SimSemantics.SimulateQ

class VerifierFirst (pSpec : ProtocolSpec n) [NeZero n] where
  verifier_first' : pSpec.dir 0 = .V_to_P

def FullData.toInternalData {Œ± : Type} {s : Skeleton}
    (tree : FullData Œ± s) : InternalData Œ± s :=
  match tree with
  | FullData.leaf _ => InternalData.leaf
  | FullData.internal value left right =>
    InternalData.internal value (left.toInternalData) (right.toInternalData)

@[reducible, simp]
def relOut : Set ((StmtOut OStatement √ó ‚àÄ i, OStmtOut OStatement i) √ó WitOut) :=
  { ‚ü®‚ü®q, oStmt‚ü©, ()‚ü© | answer (oStmt 0) q = answer (oStmt 1) q }

def halfNumFullRounds : Nat := params.numFullRounds / 2

Array.zipWith in Init.Data.Array.Basic

def degreeX (f : F[X][Y]) : ‚Ñï := f.support.sup (fun n => (f.coeff n).natDegree)

instance instHasSucc {n : ‚Ñï} : HasSucc (CNat n) := (CayleyTower n).2

def Array.toFinVec {Œ± : Type _} (n : ‚Ñï) (arr : Array Œ±) (h : arr.size = n) : Fin n ‚Üí Œ± :=
  fun i => arr[i]

Option.getD in Init.Prelude

@[reducible]
def get {Œ±s : List (Type u)} : HList Œ±s ‚Üí (n : Fin Œ±s.length) ‚Üí Œ±s.get n
  | x ::‚Çï _, ‚ü®0, _‚ü© => x
  | _ ::‚Çï xs, ‚ü®n+1, h‚ü© => xs.get ‚ü®n, Nat.lt_of_succ_lt_succ h‚ü©

@[reducible]
def fieldSize : Nat := 2 ^ 31 - 2 ^ 24 + 1

def distCodewords [DecidableEq F] (U V : Matrix Œ∫ Œπ F) : ‚Ñï :=
  (Matrix.neqCols U V).card

@[inline] def succ (a : Cayley T) : Cayley T := add a one

Ideal in Mathlib.RingTheory.Ideal.Defs

QueryImpl.impl in VCVio.OracleComp.SimSemantics.SimulateQ

@[reducible]
def fieldSize : Nat := 2 ^ 64 - 2 ^ 32 + 1

def binaryFinMapToNat {n : ‚Ñï} (m : Fin n ‚Üí ‚Ñï) (h_binary : ‚àÄ j: Fin n, m j ‚â§ 1) : Fin (2^n) :=

PowerSeries in Mathlib.RingTheory.PowerSeries.Basic

structure Selector (ùì° : Type*) where
   
  qL : ùì°
   
  qR : ùì°
   
  qO : ùì°
   
  qM : ùì°
   
  qC : ùì°
deriving DecidableEq

LinearEquiv.ofBijective in Mathlib.Algebra.Module.Submodule.Equiv

Nat.Coprime in Init.Data.Nat.Coprime

class HasMessageSize {n : ‚Ñï} (pSpec : ProtocolSpec n) where
  messageSize : pSpec.MessageIdx ‚Üí Nat

ByteArray in Init.Prelude

def proximityMeasure (u v : n ‚Üí F) (d : ‚Ñï) : ‚Ñï :=
  Fintype.card {r : F | Œî‚ÇÄ'(r ‚Ä¢ u + (1 - r) ‚Ä¢ v, C) ‚â§ d}

def splitNth (f : ùîΩ[X]) (n : ‚Ñï) [inst : NeZero n] : Fin n ‚Üí ùîΩ[X] :=
  fun i =>
    let sup :=
      Finset.filterMap (fun x => if x % n = i.1 then .some (x / n) else .none)
      f.support
      (
        by admit /- proof elided -/
      )
    Polynomial.ofFinsupp
      ‚ü®
        sup,
        fun e => f.coeff (e * n + i.1),
        by admit /- proof elided -/
      ‚ü©

List.take in Init.Data.List.Basic

instance : HListRepr (HList []) where
  repr := fun _ => ""

Subtype.mk in Init.Prelude

@[reducible, simp] def WitIn := Unit

instance [Zero T] [ToNat T] : HasPred (Cayley T) where
  pred' := pred

instance : Inhabited (UniPolyC R) := ‚ü®#[], Trim.canonical_empty‚ü©

BitVec.toNat in Init.Prelude

structure ProverInteractionWithOutput {Œπ : Type} (oSpec : OracleSpec Œπ) (Output : Type)
    {n : ‚Ñï} (pSpec : ProtocolSpec n) extends
      ProverState n,
      ProverInit (PrvState 0),
      ProverRound oSpec pSpec,
      ProverOutput oSpec Output (PrvState (Fin.last n))

def inputRelation :
    Set
      (
        (Unit √ó (‚àÄ j, OracleStatement D x m j)) √ó
        Witness F s d m
      ) := sorry

def join_via_add_smul (k : ‚Ñï) (h_pos : k > 0) (hi_btf lo_btf : ConcreteBTField (k - 1)) :
    ConcreteBTField k :=

def starSkel (k : ‚Ñï) : ArityTree.Skeleton 1 (ar1 k) :=
  ArityTree.Skeleton.node (fun _ => ArityTree.Skeleton.leaf)

def rbrSoundness (langIn : Set StmtIn) (langOut : Set StmtOut)
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    (rbrSoundnessError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) : Prop :=
  ‚àÉ stateFunction : verifier.StateFunction init impl langIn langOut,
  ‚àÄ stmtIn ‚àâ langIn,
  ‚àÄ WitIn WitOut : Type,
  ‚àÄ witIn : WitIn,
  ‚àÄ prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec,
  ‚àÄ i : pSpec.ChallengeIdx,
    [fun ‚ü®transcript, challenge‚ü© =>
      ¬¨ stateFunction i.1.castSucc stmtIn transcript ‚àß
        stateFunction i.1.succ stmtIn (transcript.concat challenge)
    | do
      (simulateQ (impl ++‚Çõ‚Çí challengeQueryImpl : QueryImpl _ (StateT œÉ ProbComp))
        (do
          let ‚ü®transcript, _‚ü© ‚Üê prover.runToRound i.1.castSucc stmtIn witIn
          let challenge ‚Üê liftComp (pSpec.getChallenge i) _
          return (transcript, challenge))).run' (‚Üê init)] ‚â§
      rbrSoundnessError i

noncomputable def toMvPolynomialAlgEquiv : P ‚âÉ‚Çê[R] MvPolynomial œÉ R where
  toFun := toMvPolynomialAlgHom
  invFun := ofMvPolynomialAlgHom
  left_inv p := by admit /- proof elided -/

ENNReal in Mathlib.Data.ENNReal.Basic

List.rtake in Mathlib.Data.List.DropRight

noncomputable instance finiteDimensionalCoeffVecSpace (‚Ñì : ‚Ñï) :
  FiniteDimensional (K := L) (V := CoeffVecSpace L ‚Ñì) :=

def erase_odd (s : Finset ‚Ñï) : Finset ‚Ñï := s.filter Even

def leftpad {m : ‚Ñï} {Œ± : Sort*} (n : ‚Ñï) (a : Œ±) (v : Fin m ‚Üí Œ±) : Fin n ‚Üí Œ± :=
  fun i => if h : n - m ‚â§ i then v ‚ü®i - (n - m), by admit /- proof elided -/
  ‚ü© else a

def drop (m : ‚Ñï) (h : m ‚â§ n) (pSpec : ProtocolSpec n) : ProtocolSpec (n - m) :=
  {dir := Fin.drop m h pSpec.dir, ¬´Type¬ª := Fin.drop m h pSpec.¬´Type¬ª}

noncomputable def foldProver :
  OracleProver []‚Çí
    (Statement F i.castSucc) (OracleStatement D x s i.castSucc) (Witness F s d i.castSucc.castSucc)
    (Statement F i.succ) (OracleStatement D x s i.succ) (Witness F s d i.castSucc.succ)
    (pSpec D x s i) where
  PrvState
  | 0 =>
    (Statement F i.castSucc √ó ((j : Fin (‚Üëi.castSucc + 1)) ‚Üí OracleStatement D x s i.castSucc j)) √ó
      Witness F s d i.castSucc.castSucc
  | _ =>
    (Statement F i.succ √ó ((j : Fin (‚Üëi.castSucc + 1)) ‚Üí OracleStatement D x s i.castSucc j)) √ó
      Witness F s d i.castSucc.succ

  input := id

  sendMessage
  | ‚ü®0, h‚ü© => nomatch h
  | ‚ü®1, _‚ü© => fun ‚ü®‚ü®chals, o‚ü©, p‚ü© =>
    pure ‚ü®fun x => p.1.eval x.1.1, ‚ü®‚ü®chals, o‚ü©, p‚ü©‚ü©

  receiveChallenge
  | ‚ü®0, _‚ü© => fun ‚ü®‚ü®chals, o‚ü©, p‚ü© => pure <|
    fun (Œ± : F) =>
      ‚ü®
        ‚ü®Fin.append chals (fun (_ : Fin 1) => Œ±), o‚ü©,
        ‚ü®p.1.foldNth (2 ^ (s i.castSucc).1) Œ±, witness_lift p.2‚ü©
      ‚ü©
  | ‚ü®1, h‚ü© => nomatch h

  output := fun ‚ü®‚ü®chals, o‚ü©, p‚ü© => pure <|
    ‚ü®
      ‚ü®
        chals,
        fun j =>
          if h : j.1 < i.1
          then by admit /- proof elided -/
      ‚ü©,
      p
    ‚ü©

def OracleReduction.addSalt
    (R : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec)
    (saltComp : (i : pSpec.MessageIdx) ‚Üí R.prover.PrvState i.1.castSucc ‚Üí
      OracleComp oSpec (Salt i)) :
    OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut (pSpec.addSalt Salt) where
  prover := R.prover.addSalt Salt saltComp
  verifier := R.verifier.addSalt Salt

def minRelHammingDistCode (C : Set (Œπ ‚Üí F)) : ‚Ñö‚â•0 :=
  haveI : Fintype (possibleRelHammingDists C) := @Fintype.ofFinite _ finite_possibleRelHammingDists
  if h : (possibleRelHammingDists C).Nonempty
  then (possibleRelHammingDists C).toFinset.min' (Set.toFinset_nonempty.2 h)
  else 0

@[simp]
instance Nontrivial (k : ‚Ñï) : Nontrivial (BTField k) := inferInstance

@[app_unexpander Slice.slice]
def sliceUnexpander : Lean.PrettyPrinter.Unexpander
  | `($_ $v $start $stop $_) => `($v‚ü¶$start : $stop‚üß)
  | _ => throw ()

Int.ofNat in Init.Data.Int.Basic

@[reducible]
def verifier : Verifier oSpec (StatementRound R n 0 √ó (‚àÄ i, OracleStatement R n deg i))
    (StatementRound R n (.last n) √ó (‚àÄ i, OracleStatement R n deg i)) (pSpec R deg n) :=
  Verifier.seqCompose (oSpec := oSpec)
    (Stmt := fun i => StatementRound R n i √ó (‚àÄ j, OracleStatement R n deg j))
    (pSpec := fun _ => SingleRound.pSpec R deg)
    (SingleRound.verifier R n deg D oSpec)

@[reducible, inline, specialize]
def UniPoly (R : Type*) := Array R

ENat in Mathlib.Data.ENat.Defs

noncomputable def E_and_Q_to_a_solution (e : ‚Ñï) (E Q : Polynomial F) (i : Fin n) : F :=
  if i < e then E.toFinsupp i else Q.toFinsupp (i - e)

Lean.Expr in Lean.Expr

def shift_left (s : Finset ‚Ñï) : Finset ‚Ñï :=
  s.filterMap
    (fun n => match n with
      | 0 => .none
      | n + 1 => .some n
      )
    (by admit /- proof elided -/
    )

Polynomial.modByMonic in Mathlib.Algebra.Polynomial.Div

Div in Init.Prelude

AddMonoid in Mathlib.Algebra.Group.Defs

@[inline]
def nsmul [SMul ‚Ñï R] (m : ‚Ñï) (p : MlPoly R n) : MlPoly R n := p.map (fun a => m ‚Ä¢ a)

@[app_unexpander Fin.dcons]
def dconsUnexpander : Lean.PrettyPrinter.Unexpander
  | `($_ $term !d[$term2, $terms,*]) => `(!d[$term, $term2, $terms,*])
  | `($_ $term !d[$term2]) => `(!d[$term, $term2])
  | `($_ $term !d[]) => `(!d[$term])
  | _ => throw ()

def truncate (p : Polynomial F) (n : ‚Ñï) : Polynomial F
  := ‚ü®‚ü®p.1.1 ‚à© Finset.range n, fun i ‚Ü¶ if i < n then p.1.2 i else 0, by admit /- proof elided -/
  ‚ü©‚ü©

structure WireIndices (numWires : ‚Ñï) where
   
  a : Fin numWires
   
  b : Fin numWires
   
  c : Fin numWires
deriving DecidableEq

structure ParamConditions (P : Params Œπ F) where
  h_deg : ‚àÉ k : ‚Ñï, P.deg = 2^k
  h_foldingParams : ‚àÄ i : Fin (M + 1), ‚àÉ k : ‚Ñï, (P.foldingParam i) = 2^k
  h_deg_ge : P.deg ‚â• ‚àè i : Fin (M + 1), (P.foldingParam i)
  h_smooth : ‚àÄ i : Fin (M + 1), Smooth (P.œÜ i)
  h_smooth_le : ‚àÄ i : Fin (M + 1), Fintype.card (Œπ i) ‚â§ (degree Œπ P i)
  h_repeatP_le : ‚àÄ i : Fin (M + 1), P.repeatParam i + 1 ‚â§ (degree Œπ P i)

@[inline]
def ofInputOnly
    (stmtProj : OuterStmtIn ‚Üí InnerStmtIn)
    (witProj : OuterStmtIn √ó OuterWitIn ‚Üí InnerWitIn) :
    Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn OuterStmtOut
                OuterWitIn OuterWitOut InnerWitIn OuterWitOut where
  stmt := Statement.Lens.ofInputOnly stmtProj
  wit := Witness.Lens.ofInputOnly witProj

@[reducible, inline]
instance instMvPolynomial : OracleInterface (R[X œÉ]) where
  Query := œÉ ‚Üí R
  Response := R
  answer := fun poly point => eval point poly

Set.Nonempty in Mathlib.Data.Set.Defs

def FullData.toLeafData {Œ± : Type} {s : Skeleton}
    (tree : FullData Œ± s) : LeafData Œ± s :=
  match tree with
  | FullData.leaf value => LeafData.leaf value
  | FullData.internal _ left right =>
    LeafData.internal (left.toLeafData) (right.toLeafData)

def getHighBits_no_shl (numLowBits : ‚Ñï) (n : ‚Ñï) : ‚Ñï := n >>> numLowBits

def SkeletonLeafIndex.depth {s : Skeleton} : SkeletonLeafIndex s ‚Üí Nat
  | SkeletonLeafIndex.ofLeaf => 0
  | SkeletonLeafIndex.ofLeft idxLeft => idxLeft.depth + 1
  | SkeletonLeafIndex.ofRight idxRight => idxRight.depth + 1

structure ConcreteBTFieldProps (k : ‚Ñï) extends (ConcreteBTFDivisionRingProps k) where
  
  mul_comm : ‚àÄ a b : ConcreteBTField k, concrete_mul a b = concrete_mul b a

instance : One (Cayley T) where
  one := one

@[reducible]
def scalarFieldSize : Nat :=
  8444461749428370424248824938781546531375899335154063827935233455917409239041

noncomputable def monomialToNovelCoeffs

  (‚Ñì : ‚Ñï) (h_‚Ñì : ‚Ñì ‚â§ r) (monomial_coeffs : Fin (2 ^ ‚Ñì) ‚Üí L) : Fin (2^‚Ñì) ‚Üí L :=
  let A := changeOfBasisMatrix ùîΩq Œ≤ ‚Ñì h_‚Ñì
  
  
  Matrix.vecMul monomial_coeffs A‚Åª¬π

Finset in Mathlib.Data.Finset.Defs

Finset.card in Mathlib.Data.Finset.Card

def BinaryTowerAux (k : ‚Ñï) : (Œ£' (F : Type 0), BinaryTowerResult F k) :=
  match k with
  | 0 => 
    let curBTField := GF(2)
    let newList : List.Vector (GF(2)) 1 := List.Vector.cons (1 : GF(2)) List.Vector.nil
    let specialElement : GF(2) := newList.1.headI
    let firstElementOfVecIsSpecialElement : newList.1.headI = specialElement := rfl
    let specialElementIs1 : specialElement = 1 := by admit /- proof elided -/

class PolynomialLike (R : outParam (Type u)) [CommSemiring R] (P : Type v) [CommSemiring P]
    extends Algebra R P where

   
  X {R} : P

   
  eval‚ÇÇ {S : Type w} [CommSemiring S] (f : R ‚Üí+* S) (x : S) : P ‚Üí+* S

  eval‚ÇÇ_C {r : R} {S : Type w} [CommSemiring S] (f : R ‚Üí+* S) (x : S) :
    (eval‚ÇÇ f x) (_root_.algebraMap R P r) = f r

  eval‚ÇÇ_X {S : Type w} [CommSemiring S] (f : R ‚Üí+* S) (x : S) : eval‚ÇÇ f x X = x

  eval‚ÇÇ_eq {S : Type w} [CommSemiring S] (g : P ‚Üí+* S) :
    g = eval‚ÇÇ (g.comp (Algebra.ofId R P)) (g X)

instance instDCast‚ÇÇVerifier :
    DCast‚ÇÇ Nat ProtocolSpec (fun _ pSpec => Verifier oSpec StmtIn StmtOut pSpec) where
  dcast‚ÇÇ := Verifier.cast
  dcast‚ÇÇ_id := by admit /- proof elided -/

abbrev rdrop {n : ‚Ñï} {Œ± : Fin n ‚Üí Sort*} (m : ‚Ñï) (h : m ‚â§ n) (v : (i : Fin n) ‚Üí Œ± i) :
    (i : Fin (n - m)) ‚Üí Œ± (Fin.cast (Nat.sub_add_cancel h) (i.castAdd m)) :=
  take (n - m) (by admit /- proof elided -/
  ) v

def ar2 (k0 k1 : ‚Ñï) : Fin 2 ‚Üí ‚Ñï
  | ‚ü®0, _‚ü© => k0
  | ‚ü®1, _‚ü© => k1

protected def Reduction.id : Reduction oSpec Statement Witness Statement Witness !p[] where
  prover := Prover.id
  verifier := Verifier.id

class Reduction.IsPure (R : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec) where
    prover_is_pure : R.prover.IsPure
    verifier_is_pure : R.verifier.IsPure

Finset.Iic in Mathlib.Order.Interval.Finset.Defs

structure OracleContext.Lens (OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut : Type)
    {Outer_Œπ‚Çõ·µ¢ : Type} (OuterOStmtIn : Outer_Œπ‚Çõ·µ¢ ‚Üí Type) [‚àÄ i, OracleInterface (OuterOStmtIn i)]
    {Outer_Œπ‚Çõ‚Çí : Type} (OuterOStmtOut : Outer_Œπ‚Çõ‚Çí ‚Üí Type) [‚àÄ i, OracleInterface (OuterOStmtOut i)]
    {Inner_Œπ‚Çõ·µ¢ : Type} (InnerOStmtIn : Inner_Œπ‚Çõ·µ¢ ‚Üí Type) [‚àÄ i, OracleInterface (InnerOStmtIn i)]
    {Inner_Œπ‚Çõ‚Çí : Type} (InnerOStmtOut : Inner_Œπ‚Çõ‚Çí ‚Üí Type) [‚àÄ i, OracleInterface (InnerOStmtOut i)]
    (OuterWitIn OuterWitOut InnerWitIn InnerWitOut : Type) where
  stmt : OracleStatement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                                  OuterOStmtIn OuterOStmtOut InnerOStmtIn InnerOStmtOut
  wit : Witness.Lens (OuterStmtIn √ó ‚àÄ i, OuterOStmtIn i) (InnerStmtOut √ó ‚àÄ i, InnerOStmtOut i)
                          OuterWitIn OuterWitOut InnerWitIn InnerWitOut

instance {k : ‚Ñï} : _root_.Inhabited (BinaryTowerAux k).fst :=

def factor' (n : ‚Ñï) : Option (List PrimeWithMultiplicity) := do
  let facts := List.mergeSort (‚Üê factor n)
  let groups := List.splitBy (¬∑ = ¬∑) facts
  return groups.map (fun g => ‚ü®g[0]!, g.length‚ü©)

def toEvalsZeroOne (p : MvPolynomial œÉ R) : (œÉ ‚Üí Fin 2) ‚Üí R :=
  fun x => eval (x : œÉ ‚Üí R) p

def toSizeR1CS (pp : PublicParams) : R1CS.Size := {
  m := 2 ^ pp.‚Ñì_m
  n := 2 ^ pp.‚Ñì_n
  n_w := 2 ^ pp.‚Ñì_w
  n_w_le_n := Nat.pow_le_pow_of_le (by admit /- proof elided -/
  ) pp.‚Ñì_w_le_‚Ñì_n
}

Polynomial.sum in Mathlib.Algebra.Polynomial.Basic

Ideal.span in Mathlib.RingTheory.Ideal.Span

abbrev SEP_CHAR : Char := Char.ofNat 0

Vector.head in Init.Data.Vector.Basic

absurd in Init.Prelude

instance : ‚àÄ j, OracleInterface ((pSpecSumcheckFold ùîΩq Œ≤ (œë:=œë)
  (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).Message j) := instOracleInterfaceMessageAppend

def LeafData.ofFun {Œ± : Type} (s : Skeleton)
    (f : SkeletonLeafIndex s ‚Üí Œ±) : LeafData Œ± s :=
  match s with
  | .leaf => LeafData.leaf (f SkeletonLeafIndex.ofLeaf)
  | .internal l r =>
      LeafData.internal
        (LeafData.ofFun l (fun idx => f (SkeletonLeafIndex.ofLeft idx)))
        (LeafData.ofFun r (fun idx => f (SkeletonLeafIndex.ofRight idx)))

Matrix.det in Mathlib.LinearAlgebra.Matrix.Determinant.Basic

def PowerType (n : ‚Ñï) : Type := dfoldr' n (fun _ => Type) (fun _ T => T ‚Üí T) Nat


example : PowerType 0 = Nat := rfl
example (n : ‚Ñï) : PowerType (n + 1) = (PowerType n ‚Üí PowerType n) := rfl

Even in Mathlib.Algebra.Group.Even

def queryRbrKnowledgeError := fun _ : (pSpecQuery ùîΩq Œ≤ Œ≥_repetitions
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).ChallengeIdx =>
  ((1/2 : ‚Ñù‚â•0) + (1 : ‚Ñù‚â•0) / (2 * 2^ùì°))^Œ≥_repetitions

@[reducible]
def reduction : Reduction oSpec StmtIn WitIn StmtOut WitOut !p[] where
  prover := prover mapStmt mapWit
  verifier := verifier mapStmt

def foldr' {Œ± : Type u} (n : ‚Ñï) (f : (i : Fin n) ‚Üí Œ± ‚Üí Œ±) (init : Œ±) : Œ± :=
  dfoldr' n (fun _ => Œ±) f init

@[inline]
def zero [Zero R] : MlPoly R n := Vector.replicate (2 ^ n) 0

def factorOutTwos (n : ‚Ñï) : PowTwoRepr := Id.run do
  let mut two_exp := 0
  let mut odd_part := n

  while odd_part % 2 = 0 do
    two_exp := two_exp + 1
    odd_part := odd_part / 2

  return ‚ü®two_exp, odd_part‚ü©

MvPolynomial.sumToIter in Mathlib.Algebra.MvPolynomial.Equiv

CommRing in Mathlib.Algebra.Ring.Defs

inductive SkeletonLeafIndex : Skeleton ‚Üí Type
  | ofLeaf : SkeletonLeafIndex Skeleton.leaf
  | ofLeft {left right : Skeleton} (idxLeft : SkeletonLeafIndex left) :
      SkeletonLeafIndex (Skeleton.internal left right)
  | ofRight {left right : Skeleton} (idxRight : SkeletonLeafIndex right) :
      SkeletonLeafIndex (Skeleton.internal left right)

Fintype.ofEquiv in Mathlib.Data.Fintype.OfMap

def BBF_SumcheckMultiplierParam : SumcheckMultiplierParam L ‚Ñì (SumcheckBaseContext L ‚Ñì) :=
  { multpoly := fun ctx => BBF_eq_multiplier ctx.t_eval_point }

def Option.doubleBind {Œ± Œ≤ Œ≥ : Type} (f : Œ± ‚Üí Œ≤ ‚Üí Option Œ≥)
    (x : Option Œ±) (y : Option Œ≤) : Option Œ≥ :=
  match x, y with
  | none, _ => none
  | _, none => none
  | some a, some b => f a b

@[inline] def toNat (t : AssocNat) : Nat := t 0

def D_YZ (Q : F[Z][X][Y]) : ‚Ñï :=
  Option.getD (dflt := 0) <| Finset.max
    (Finset.image
            (
              fun j =>
                Option.getD (
                  Finset.max (
                    Finset.image
                      (fun k => j + (Bivariate.coeff Q j k).natDegree)
                      (Q.coeff j).support
                  )
                ) 0
            )
            Q.support
    )

structure BinaryTowerInductiveStepResult (k : ‚Ñï) (prevBTField : Type _)
  (prevBTResult : BinaryTowerResult prevBTField k) [instPrevBTFieldIsField : Field prevBTField]
  (prevPoly : Polynomial prevBTField) (F : Type _) where
  binaryTowerResult : BinaryTowerResult F (k+1)
  eq_adjoin : F = AdjoinRoot prevPoly
  u_is_root : Eq.mp (eq_adjoin) binaryTowerResult.specialElement = AdjoinRoot.root prevPoly
  eval_defining_poly_at_root : Eq.mp (eq_adjoin) binaryTowerResult.specialElement^2 +
    Eq.mp (eq_adjoin) binaryTowerResult.specialElement * (of prevPoly) prevBTResult.specialElement
    + 1 = 0

noncomputable def batchProver :
  OracleProver []‚Çí
    Unit (OracleStatement D x m) (Witness F s d m)
    ((Fin m ‚Üí F) √ó Fri.Spec.Statement F (0 : Fin (k + 1)))
      (OracleStatement D x m) (Fri.Spec.Witness F s d (0 : Fin (k + 2)))
    (batchSpec F m) where
  PrvState
  | 0 => (‚àÄj, OracleStatement D x m j) √ó Witness F s d m
  | 1 => (Fin m ‚Üí F) √ó (‚àÄj, OracleStatement D x m j) √ó Fri.Spec.Witness F s d (0 : Fin (k + 2))

  input := fun i => ‚ü®i.1.2, i.2‚ü©

  sendMessage
  | ‚ü®0, h‚ü© => nomatch h

  receiveChallenge
  | ‚ü®0, _‚ü© => fun ‚ü®os, ps‚ü© => pure <|
    fun (cs : Fin m ‚Üí F) =>
      ‚ü®cs, os,
        ‚ü®
          ps 0 + ‚àë i, Polynomial.C (cs i) * (ps i.succ).1,
          by admit /- proof elided -/
        ‚ü©
      ‚ü©

  output := fun ‚ü®cs, os, p‚ü© => pure <|
    ‚ü®‚ü®‚ü®cs, Fin.elim0‚ü©, os‚ü©, p‚ü©

noncomputable def evenPart (f : Polynomial F) : Polynomial F :=
    C (2‚Åª¬π : F) * (f + f.comp (-X))

instance : Initialize (DuplexSponge U C) (Vector UInt8 32) where
  new iv := {
    state := Initialize.new iv,
    absorbPos := 0,
    squeezePos := Fin.last SpongeSize.R
  }

def evalOnPoints [Semiring F] : F[X] ‚Üí‚Çó[F] (Œπ ‚Üí F) where
  toFun := fun p => fun x => p.eval (domain x)
  map_add' := fun x y => by admit /- proof elided -/

def divByMonic [Field R] (p : UniPoly R) (q : UniPoly R) :
    UniPoly R :=
  (divModByMonicAux p q).1

def rootsOfUnity (n s : ‚Ñï) : List (Domain.evalDomain D (n - s)) :=
  List.map
    (fun i =>
      ‚ü®
        (DIsCyclicC.gen.1 ^ (2 ^ (n - s))) ^ i,
        by admit /- proof elided -/
      ‚ü©
    )
    (List.range (2 ^ s))

instance instVector : OracleInterface (Vector Œ± n) where
  Query := Fin n
  Response := Œ±
  answer := fun vec i => vec[i]

instance [LawfulBEq R] : AddCommGroup (UniPolyC R) where
  add_assoc := add_assoc
  zero_add := zero_add
  add_zero := add_zero
  add_comm := add_comm
  neg_add_cancel := neg_add_cancel
  nsmul := nsmul 
  nsmul_zero := nsmul_zero
  nsmul_succ := nsmul_succ
  zsmul := zsmulRec 

def KnowledgeStateFunction.toStateFunction
    {relIn : Set (StmtIn √ó WitIn)} {relOut : Set (StmtOut √ó WitOut)}
    {verifier : Verifier oSpec StmtIn StmtOut pSpec} {WitMid : Fin (n + 1) ‚Üí Type}
    {extractor : Extractor.RoundByRound oSpec StmtIn WitIn WitOut pSpec WitMid}
    (kSF : KnowledgeStateFunction init impl relIn relOut verifier extractor) :
      verifier.StateFunction init impl relIn.language relOut.language where
  toFun := fun m stmtIn tr => ‚àÉ witMid, kSF.toFun m stmtIn tr witMid
  toFun_empty := by admit /- proof elided -/

noncomputable def H
  (Œ¥ : ‚Ñö) (x‚ÇÄ : F)
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  : F[Z][X] := (exists_factors_with_large_common_root_set k Œ¥ x‚ÇÄ h_gs).choose_spec.choose

def accepts (x : Fin numWires ‚Üí ùì°) (g : Gate ùì° numWires) : Prop :=
  g.eval x = 0

OracleSpec.DecidableEq in VCVio.OracleComp.OracleSpec

noncomputable def oddPart_x (f : Polynomial F) : Polynomial F := deevenize (oddPart f)

@[inline, reducible]
def Witness.InvLens (OuterStmtIn OuterWitIn OuterWitOut InnerWitIn InnerWitOut : Type)
    := PFunctor.Lens ((OuterStmtIn √ó OuterWitOut) X^ OuterWitIn)
                     (InnerWitOut X^ InnerWitIn)

@[simp]
abbrev FirstChallenge : Type := Fin pp.‚Ñì_m ‚Üí R

IsUnit in Mathlib.Algebra.Group.Units.Defs

noncomputable def queryVerifier (k_le_n : (‚àë j', (s j').1) ‚â§ n) (l : ‚Ñï) [DecidableEq F] :
  OracleVerifier []‚Çí
    (FinalStatement F k) (FinalOracleStatement D x s)
    (FinalStatement F k) (FinalOracleStatement D x s)
    (pSpec D x l) where
  verify := fun prevChallenges roundChallenge => do
    let (p : F[X]) ‚Üê getConst D x k s
    for m in (List.finRange l) do
      let s‚ÇÄ := roundChallenge ‚ü®1, by admit /- proof elided -/
      ‚ü© m
      discard <|
        (List.finRange (k + 1)).mapM
              (fun i =>
                do
                  let x‚ÇÄ := prevChallenges i
                  let s‚ÇÄ :
                    evalDomain D x
                      (‚àë j' ‚àà finRangeTo i.1, (s j').1) :=
                    ‚ü®_, pow_2_pow_i_mem_Di_of_mem_D _ s‚ÇÄ.2‚ü©
                  let queries :
                    List (
                      evalDomain D x
                        (‚àë j' ‚àà finRangeTo i.1, (s j').1)
                    ) :=
                    List.map
                      (fun r =>
                        ‚ü®
                          _,
                          CosetDomain.mul_root_of_unity D (roots_of_unity_lem k_le_n) s‚ÇÄ.2 r.2
                        ‚ü©
                      )
                      (Domain.rootsOfUnity D n (s i))
                  let (pts : List (F √ó F)) ‚Üê
                    List.mapM
                      (fun q => queryCodeword D x k s q >>= fun v => pure (q.1.1, v))
                      queries
                  let Œ≤ ‚Üê
                    if h : i.1 < k
                    then
                      have := CosetDomain.pow_lift D x (s i).1 s‚ÇÄ.2
                      queryCodeword D x k s (i := ‚ü®i.1.succ, Order.lt_add_one_iff.mpr h‚ü©)
                        ‚ü®_, by admit /- proof elided -/
                        ‚ü©
                    else
                      pure (p.eval (s‚ÇÄ.1.1 ^ (2 ^ (s (Fin.last k)).1)))
                  guard (RoundConsistency.roundConsistencyCheck x‚ÇÄ pts Œ≤)
              )
    pure prevChallenges
  embed :=
    ‚ü®
      fun j => Sum.inl j,
      by admit /- proof elided -/
    ‚ü©
  hEq := by admit /- proof elided -/

noncomputable def restrictLinear [Semiring F] (S : Finset Œπ) :
  (Œπ ‚Üí F) ‚Üí‚Çó[F] (S ‚Üí F) :=
{ toFun := fun f i => f i.1,
  map_add' := by admit /- proof elided -/

def MLEEquivFin {n : ‚Ñï} : R‚¶É‚â§ 1‚¶Ñ[X (Fin n)] ‚âÉ (Fin (2 ^ n) ‚Üí R) :=
  Equiv.trans MLEEquiv (Equiv.piCongr finFunctionFinEquiv (fun _ => Equiv.refl _))

def correlatedAgreement (C : Set (n ‚Üí F)) (Œ¥ : ‚Ñù‚â•0) {k : ‚Ñï} (W : Fin k ‚Üí n ‚Üí F) : Prop :=
  ‚àÉ S : Finset n, #(S) ‚â• (1 - Œ¥) * (Fintype.card n) ‚àß
    ‚àÉ v : Fin k ‚Üí n ‚Üí F, ‚àÄ i, v i ‚àà C ‚àß {j | v i j = W i j} = S

structure HashStateWithInstructions (U : Type) [SpongeUnit U] (H : Type*)
    [DuplexSpongeInterface U H] where
   
  ds : H
   
  stack : Array DomainSeparator.Op
deriving Inhabited, DecidableEq, Repr

def split {k : ‚Ñï} (h : k > 0) (x : ConcreteBTField k) :
    ConcreteBTField (k - 1) √ó ConcreteBTField (k - 1) :=
  let lo_bits : BitVec (2 ^ (k - 1) - 1 - 0 + 1) :=
    BitVec.extractLsb (hi := 2 ^ (k - 1) - 1) (lo := 0) x
  let hi_bits : BitVec (2 ^ k - 1 - 2 ^ (k - 1) + 1) :=
    BitVec.extractLsb (hi := 2 ^ k - 1) (lo := 2 ^ (k - 1)) x
  have h_lo : 2 ^ (k - 1) - 1 - 0 + 1 = 2 ^ (k - 1) := by admit /- proof elided -/

@[reducible, simp]
def perfectCompleteness
    (relation : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (oracleProof : OracleProof oSpec Statement OStatement Witness pSpec) :
      Prop :=
  OracleReduction.perfectCompleteness init impl relation acceptRejectOracleRel oracleProof

CoeFun in Init.Coe

instance : ‚àÄ i, SelectableType ((pSpecNonLastBlocks ùîΩq Œ≤ (œë:=œë)
  (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).Challenge i) := instSelectableTypeChallengeSeqCompose

@[inline, specialize]
def processRound (j : Fin n)
    (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec)
    (currentResult : OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí)
      (pSpec.Transcript j.castSucc √ó prover.PrvState j.castSucc)) :
      OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí)
        (pSpec.Transcript j.succ √ó prover.PrvState j.succ) := do
  let ‚ü®transcript, state‚ü© ‚Üê currentResult
  match hDir : pSpec.dir j with
  | .V_to_P => do
    let challenge ‚Üê pSpec.getChallenge ‚ü®j, hDir‚ü©
    letI newState := (‚Üê prover.receiveChallenge ‚ü®j, hDir‚ü© state) challenge
    return ‚ü®transcript.concat challenge, newState‚ü©
  | .P_to_V => do
    let ‚ü®msg, newState‚ü© ‚Üê prover.sendMessage ‚ü®j, hDir‚ü© state
    return ‚ü®transcript.concat msg, newState‚ü©

Finset.Nonempty in Mathlib.Data.Finset.Empty

@[simp]
instance BTFieldIsField (k : ‚Ñï) : Field (BTField k) := (BinaryTowerAux k).2.instField

NeZero in Init.Data.NeZero

BitVec.xor in Init.Data.BitVec.Basic

instance instDCast‚ÇÇ : DCast‚ÇÇ Nat ProtocolSpec (fun _ pSpec => FullTranscript pSpec) where
  dcast‚ÇÇ h h' T := FullTranscript.cast h h' T
  dcast‚ÇÇ_id := cast_id

def Verifier.liftContext
    (lens : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut)
    (V : Verifier oSpec InnerStmtIn InnerStmtOut pSpec) :
      Verifier oSpec OuterStmtIn OuterStmtOut pSpec where
  verify := fun stmtIn transcript => do
    let innerStmtIn := lens.proj stmtIn
    let innerStmtOut ‚Üê V.verify innerStmtIn transcript
    return lens.lift stmtIn innerStmtOut

liftM in Init.Prelude

CanLift in Mathlib.Tactic.Lift

LawfulFunctor in Init.Control.Lawful.Basic

def churchTrue : ChurchBool Œ± := fun x _ => x

@[inline]
def smul [Mul R] (r : R) (p : MlPolyEval R n) : MlPolyEval R n := p.map (fun a => r * a)

@[reducible, inline, specialize]
def Challenges' (pSpec : ProtocolSpec n) : Type :=
  ‚àÄ i, (hi : pSpec.dir i = .V_to_P) ‚Üí pSpec.¬´Type¬ª i

def instTestLensKnowledgeSound : testLensE.IsKnowledgeSound
      outerRelIn_Test innerRelIn_Test outerRelOut_Test innerRelOut_Test
      (fun ‚ü®p, q, _‚ü© ‚ü®f, _‚ü© => p * q = f) (fun _ _ => True) where
  proj_knowledgeSound := fun ‚ü®p, q, t‚ü© ‚ü®f, t', r‚ü© _ h h' => by admit /- proof elided -/

def leadingCoeff (p : UniPoly R) : R := p.trim.getLastD 0

def line [Ring F] (u v : Œπ ‚Üí F) : AffineSubspace F (Œπ ‚Üí F) :=
  affineSpan _ {u, v}

@[inline, specialize]
def eval (x : R) (p : UniPoly R) : R :=
  p.eval‚ÇÇ (RingHom.id R) x

@[inline, reducible]
def proj : (OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i)) √ó OuterWitIn ‚Üí
    (InnerStmtIn √ó (‚àÄ i, InnerOStmtIn i)) √ó InnerWitIn :=
  fun ctxIn => ‚ü®lens.stmt.proj ctxIn.1, lens.wit.proj ctxIn‚ü©

instance [Semiring R] : Module R (MlPoly R n) where
  smul := smul
  one_smul a := by admit /- proof elided -/

def addCast {n : ‚Ñï} (m : ‚Ñï) (i : Fin n) : Fin (m + n) := ‚ü®i, Nat.lt_add_left m i.2‚ü©

instance {Œ± : Type u} : SliceGE (Array Œ±) Nat (fun _ _ => True) (fun _ _ _ => Array Œ±) where
  sliceGE xs start _ := xs.drop start

def relation : Set (M √ó List (MemoryRead Œπ Œ±)) :=
  { ‚ü®mem, ops‚ü© | ‚àÄ op ‚àà ops, Memory.read mem op.index = op.value }

instance : ToNat Nat where
  toNat := id

instance extractorLens_rbr_knowledge_soundness :
    Extractor.Lens.IsKnowledgeSound
      (relationRound R n deg D i.castSucc) (Simple.inputRelation R deg D)
      (relationRound R n deg D i.succ) (Simple.outputRelation R deg)
      ((Simple.oracleVerifier R deg D oSpec).toVerifier.compatStatement (oStmtLens R n deg D i))
      (fun _ _ => True)
      ‚ü®oStmtLens R n deg D i, Witness.InvLens.trivial‚ü© where
  proj_knowledgeSound := by admit /- proof elided -/

Module.Basis.reindex in Mathlib.LinearAlgebra.Basis.Defs

def relationAfterSendClaim :
    Set (((StmtAfterSendClaim R) √ó (‚àÄ i, OStmtAfterSendClaim R deg i)) √ó Unit) :=
  { ‚ü®‚ü®target, oStmt‚ü©, _‚ü© |
    ‚àë x ‚àà (univ.map D), (oStmt (Sum.inl ())).1.eval x = target
      ‚àß oStmt (Sum.inr ()) = oStmt (Sum.inl ()) }

def concat {k : Fin n} (messages : MessagesUpTo k.castSucc pSpec)
    (h : pSpec.dir k = .P_to_V) (msg : pSpec.Message ‚ü®k, h‚ü©) : MessagesUpTo k.succ pSpec :=
  fun ‚ü®i, h‚ü© => (concat' (pSpec := pSpec) (fun i hi => messages ‚ü®i, hi‚ü©) (fun _ => msg)) i h

def absorbUnchecked [Permute C] (sponge : DuplexSponge U C) (arr : Array U) : DuplexSponge U C :=
  simulateQ' forwardPermutationOracleImpl (absorbFast sponge arr) (by admit /- proof elided -/
  )

def Fin.traverseM {Œ≤ : Fin n ‚Üí Type u}
    (f : (i : Fin n) ‚Üí m (Œ≤ i)) : m ((i : Fin n) ‚Üí Œ≤ i) :=
  let rec aux (k : ‚Ñï) (h : k ‚â§ n) : m ((i : Fin k) ‚Üí Œ≤ (Fin.castLE h i)) :=
    match k with
    | 0 => pure (fun i => i.elim0)
    | k' + 1 => do
      let tail ‚Üê aux k' (Nat.le_of_succ_le h)
      let head ‚Üê f (Fin.castLE h (Fin.last k'))
      return (Fin.snoc tail head)
  aux n (le_refl n)

noncomputable def matching_set
  (œâs : Fin n ‚Ü™ F)
  (Œ¥ : ‚Ñö)
  (u‚ÇÄ u‚ÇÅ : Fin n ‚Üí F)
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  : Finset F := (exists_a_set_and_a_matching_polynomial k h_gs (Œ¥ := Œ¥)).choose

instance : ‚àÄ j, OracleInterface ((pSpec F).Message j)
  | ‚ü®0, h‚ü© => nomatch h
  | ‚ü®1, _‚ü© => by admit /- proof elided -/

noncomputable def polyEvalLinearMap {L ùîΩq : Type*} [Field L] [Field ùîΩq] [Algebra ùîΩq L]
  (p : L[X]) (hp_add : IsLinearMap ùîΩq (fun x : L => p.eval x)) : L ‚Üí‚Çó[ùîΩq] L :=
{
  toFun    := fun x => p.eval x,
  map_add' := hp_add.map_add,
  map_smul' := hp_add.map_smul
}

MvPolynomial.isEmptyAlgEquiv in Mathlib.Algebra.MvPolynomial.Equiv

def computableAdditiveNTT (a : Fin (2 ^ ‚Ñì) ‚Üí L) : Fin (2^(‚Ñì + R_rate)) ‚Üí L :=
  let b: Fin (2^(‚Ñì + R_rate)) ‚Üí L := tileCoeffs a 
  Fin.foldl (n:=‚Ñì) (f:= fun current_b i  =>
    computableNTTStage (ùîΩq := ùîΩq) (Œ≤ := Œ≤) (‚Ñì := ‚Ñì) (R_rate := R_rate)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := ‚ü®‚Ñì - 1 - i, by admit /- proof elided -/
      ‚ü©) (b:=current_b)
  ) (init:=b)

instance : ‚àÄ j, OracleInterface ((pSpecFinalSumcheckStep (L := L)).Message j) := fun j =>
  match j with
  | ‚ü®0, _‚ü© => OracleInterface.instDefault

def oracleVerifier : OracleVerifier oSpec (StmtIn R) (OStmtIn R deg) (StmtOut R) (OStmtOut R deg)
    (pSpec R deg) where
  verify := fun target chal => do
    let evals : Vector R m ‚Üê (Vector.finRange m).mapM
      (fun i => query (spec := [OStmtIn R deg]‚Çí) () (D i))
    guard (evals.sum = target)
    
    pure (sorry, chal default)
  embed := .inl
  hEq := fun i => by admit /- proof elided -/

instance : ‚àÄ i, SelectableType (Challenge !p[] i) :=
  fun ‚ü®i, h‚ü© =>
    (Fin.elim0 i : (h' : !p[].dir i = .V_to_P) ‚Üí SelectableType (!p[].Challenge ‚ü®i, h'‚ü©)) h

abbrev eqPolynomial (r : œÉ ‚Üí R) : R[X œÉ] :=
  ‚àè i : œÉ, singleEqPolynomial (r i) (X i)

class Permute (Œ± : Type*) where
  permute : Œ± ‚Üí Œ±

def hflatten {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {Œ± : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí Sort*}
    (v : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí Œ± i j) : (k : Fin (vsum n)) ‚Üí Fin.vflatten Œ± k :=
  fflatten (F := id) v

instance [ProverFirst pSpec] : Unique (pSpec.MessageIdx) where
  default := ‚ü®0, by admit /- proof elided -/
  ‚ü©
  uniq := fun ‚ü®i, _‚ü© => by admit /- proof elided -/

def X : UniPoly R := #[0, 1]

def Extractor.Straightline.compatWit
    (lens : Extractor.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut)
    (E : Extractor.Straightline oSpec InnerStmtIn InnerWitIn InnerWitOut pSpec) :
      OuterStmtIn √ó OuterWitOut ‚Üí InnerWitIn ‚Üí Prop :=
  fun ‚ü®outerStmtIn, outerWitOut‚ü© innerWitIn =>
    ‚àÉ stmt tr logP logV, innerWitIn ‚àà
      (E stmt (lens.wit.proj (outerStmtIn, outerWitOut)) tr logP logV).support

Fin.init in Mathlib.Data.Fin.Tuple.Basic

def distEq (mx my : OracleComp spec Œ±) : Prop :=
  evalDist mx = evalDist my

orderOf in Mathlib.GroupTheory.OrderOfElement

@[simp]
abbrev OracleStatement.AfterSendEvalClaim : R1CS.MatrixIdx ‚äï R1CS.MatrixIdx ‚äï Fin 1 ‚Üí Type :=
  Sum.elim (EvalClaim R) (OracleStatement.AfterFirstSumcheck R pp)

List.IsSuffix in Init.Data.List.Basic

def dfoldl' (n : ‚Ñï) (Œ± : Fin (n + 1) ‚Üí Type u)
    (f : (i : Fin n) ‚Üí Œ± i.castSucc ‚Üí Œ± i.succ) (init : Œ± 0) : Œ± (last n) :=
  dfoldlM' (m := Id) n Œ± f init

Mathlib.Meta.NormNum.IsNat in Mathlib.Tactic.NormNum.Result

abbrev extract (start stop : ‚Ñï) (h1 : start ‚â§ stop) (h2 : stop ‚â§ n)
    (transcript : FullTranscript pSpec) : FullTranscript (pSpec.extract start stop h1 h2) :=
  Fin.extract start stop h1 h2 transcript

instance (priority := 1000) algebra_adjacent_tower (l : ‚Ñï) :
  Algebra (BTField l) (BTField (l+1)) :=

@[reducible, inline, specialize]
def MessageUpTo (k : Fin (n + 1)) (pSpec : ProtocolSpec n) (i : pSpec.MessageIdxUpTo k) :=
  (pSpec‚ü¶:k.val‚üß).Message i

def possibleDeltas (U V : Set (Œπ ‚Üí F)) : Set ‚Ñö‚â•0 :=
  {d : ‚Ñö‚â•0 | ‚àÉ u ‚àà U, Œ¥·µ£(u,V) = d}

instance : Field ScalarField := ZMod.instField scalarFieldSize

instance : ‚àÄ j, SelectableType ((fullPSpec ùîΩq Œ≤ Œ≥_repetitions (œë:=œë)
  (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).Challenge j) := instSelectableTypeChallengeAppend

def oracleVerifier (i : Fin n) : OracleVerifier oSpec (StatementRound R n i.castSucc)
    (OracleStatement R n deg) (StatementRound R n i.succ) (OracleStatement R n deg) (pSpec R deg) :=
  (Simple.oracleVerifier R deg D oSpec).liftContext (oStmtLens R n deg D i)

def InnerStmtOut_Test := ‚Ñ§[X] √ó ‚Ñ§ √ó ‚Ñ§

def weightedDegree.{u} {F : Type u} [Semiring F] (p : F[X][Y]) (u v : ‚Ñï) : Option ‚Ñï :=
  List.max? <|
    List.map (fun n => u * (p.coeff n).natDegree + v * n) (List.range p.natDegree.succ)

def churchNot (p : ChurchBool Œ±) : ChurchBool Œ± :=
  fun x y => p y x

noncomputable def queryOracleReduction [DecidableEq F] :
  OracleReduction []‚Çí
    (FinalStatement F k) (FinalOracleStatement D x s) (Witness F s d (Fin.last (k + 1)))
    (FinalStatement F k) (FinalOracleStatement D x s) (Witness F s d (Fin.last (k + 1)))
    (pSpec D x l) where
  prover := queryProver D x s d l
  verifier := queryVerifier D x s (round_bound domain_size_cond) l

  inductive UnverifiedPrattPart : Type
    | prime : (p : ‚Ñï) ‚Üí (k : ‚Ñï) ‚Üí (hp : UnverifiedPrattCertificate p) ‚Üí UnverifiedPrattPart
    | split : UnverifiedPrattPart ‚Üí UnverifiedPrattPart ‚Üí UnverifiedPrattPart
  deriving Repr

def relayPrvState (i : Fin ‚Ñì) : Fin (0 + 1) ‚Üí Type := fun
  | ‚ü®0, _‚ü© => Statement (L := L) Context i.succ √ó
    (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j) √ó
    Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ

def vcons {n : ‚Ñï} (a : Œ±) (v : Fin n ‚Üí Œ±) : Fin (n + 1) ‚Üí Œ± :=
  dcons a v

@[app_unexpander Fin.fcons‚ÇÇ]
def fcons‚ÇÇUnexpander : Lean.PrettyPrinter.Unexpander
  | `($_ $a !h‚¶É$F‚¶Ñ‚ü®$Œ±‚ÇÅ‚ü©‚ü®$Œ±‚ÇÇ‚ü©[$b, $bs,*]) => `(!h‚¶É$F‚¶Ñ‚ü®$Œ±‚ÇÅ‚ü©‚ü®$Œ±‚ÇÇ‚ü©[$a, $b, $bs,*])
  | `($_ $a !h‚¶É$F‚¶Ñ‚ü®$Œ±‚ÇÅ‚ü©‚ü®$Œ±‚ÇÇ‚ü©[$b]) => `(!h‚¶É$F‚¶Ñ‚ü®$Œ±‚ÇÅ‚ü©‚ü®$Œ±‚ÇÇ‚ü©[$a, $b])
  | `($_ $a !h‚¶É$F‚¶Ñ‚ü®$Œ±‚ÇÅ‚ü©‚ü®$Œ±‚ÇÇ‚ü©[]) => `(!h‚¶É$F‚¶Ñ‚ü®$Œ±‚ÇÅ‚ü©‚ü®$Œ±‚ÇÇ‚ü©[$a])
  | _ => throw ()

@[app_unexpander Fin.hcons]
def hconsUnexpander : Lean.PrettyPrinter.Unexpander
  | `($_ $term !h[$term2, $terms,*]) => `(!h[$term, $term2, $terms,*])
  | `($_ $term !h[$term2]) => `(!h[$term, $term2])
  | `($_ $term !h[]) => `(!h[$term])
  | _ => throw ()

def allScriptsDocumented : IO Bool := do
  \n  \
      {String.intercalate "," undocumented.toList}"
  return undocumented.size == 0

instance {Œ± : Type*} [Fintype Œ±] : Dist (PMF Œ±) where
  dist := fun a b => ‚àë x, abs ((a x).toReal - (b x).toReal)

List.IsPrefix in Init.Data.List.Basic

def buildMerkleTree (Œ±) (n : ‚Ñï) (leaves : List.Vector Œ± (2 ^ n)) :
    OracleComp (spec Œ±) (Cache Œ± n) := do
  match n with
  | 0 => do
    return fun j => (by admit /- proof elided -/
      )
  | n + 1 => do
    let lastLayer ‚Üê buildLayer Œ± n leaves
    let cache ‚Üê buildMerkleTree Œ± n lastLayer
    return Cache.cons Œ± n leaves cache

NatPow in Init.Prelude

instance : Fintype BTF‚ÇÉ := (inferInstance : Fintype (ConcreteBTField 3))

instance [IsSingleRound pSpec] [h : VCVCompatible (pSpec.Challenge default)] :
    (i : pSpec.ChallengeIdx) ‚Üí VCVCompatible (pSpec.Challenge i) := fun i => by admit /- proof elided -/

def mapOStmtOutRelayStep (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j) :
    ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.succ j := fun j => by admit /- proof elided -/

def backTrack (trace : QueryLog (duplexSpongeChallengeOracle StmtIn U))
    (state : CanonicalSpongeState U) :
    OptionT Option ((StmtIn √ó (i : Fin (n + 1)) √ó (pSpec.MessagesUpTo i))) :=
  sorry

def knowledgeSoundness
    (relIn : Set ((StmtIn √ó ‚àÄ i, OStmtIn i) √ó WitIn))
    (relOut : Set ((StmtOut √ó ‚àÄ i, OStmtOut i) √ó WitOut))
    (verifier : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec)
    (knowledgeError : ‚Ñù‚â•0) : Prop :=
  verifier.toVerifier.knowledgeSoundness init impl relIn relOut knowledgeError

protected def cast (pSpec : ProtocolSpec n‚ÇÅ) : ProtocolSpec n‚ÇÇ :=
  ‚ü®pSpec.dir ‚àò (Fin.cast hn.symm), pSpec.¬´Type¬ª ‚àò (Fin.cast hn.symm)‚ü©

def generateProof {s} (cache_tree : FullData Œ± s) :
    BinaryTree.SkeletonLeafIndex s ‚Üí List Œ±
  | .ofLeaf => []
  | .ofLeft idxLeft =>
    (cache_tree.rightSubtree).getRootValue ::
      (generateProof cache_tree.leftSubtree idxLeft)
  | .ofRight idxRight =>
    (cache_tree.leftSubtree).getRootValue ::
      (generateProof cache_tree.rightSubtree idxRight)

TensorProduct in Mathlib.LinearAlgebra.TensorProduct.Basic

instance instAlgebraTowerConcreteBTF : AlgebraTower (ConcreteBTField) where
  algebraMap := concreteTowerAlgebraMap
  commutes' := by admit /- proof elided -/

instance {s} : Functor (fun Œ± => FullData Œ± s) where
  map f x := x.map f

instance : SliceGE (ProtocolSpec n) ‚Ñï
    (fun _ start => start ‚â§ n)
    (fun _ start _ => ProtocolSpec (n - start))
    where
  sliceGE := fun v start h => drop start h v

List.mergeSort in Init.Data.List.Sort.Basic

Equiv.optionCongr in Mathlib.Logic.Equiv.Option

Algebra.ofId in Mathlib.Algebra.Algebra.Hom

def toFin (f : AssocFin n) : Fin (AssocNat.toNat n) :=
  ‚ü®AssocNat.toNat f.val, f.isLt‚ü©

def basisSucc (k : ‚Ñï) : Basis (Fin 2) (ConcreteBTField k) (ConcreteBTField (k + 1)) :=

@[reducible, simp] def OStmtOut := fun _ : Fin 1 => OStatement

SemilatticeSup in Mathlib.Order.Lattice

instance : ‚àÄ j, OracleInterface ((pSpecFoldRelay (L:=L)).Message j) :=
  instOracleInterfaceMessageAppend

instance instDCastPSigmaPSigma :
    DCast ((a : Œ±) √ó' (b : Œ≤ a) √ó' Œ≥ a b) (fun a => Œ¥ a.1 a.2.1 a.2.2) where
  dcast hc d := dcast‚ÇÉ (by admit /- proof elided -/
  ) (by admit /- proof elided -/
  ) (by admit /- proof elided -/
  ) d
  dcast_id := by admit /- proof elided -/

def width (k : ‚Ñï) : ‚Ñï := 2 ^ k

partial def factor (n : ‚Ñï) : Option (List ‚Ñï) :=
  if deterministicMillerRabin n then
    [n]
  else do
    let f ‚Üê rho n
    let lhs ‚Üê factor f
    let rhs ‚Üê factor (n / f)
    return (lhs ++ rhs)

Monoid in Mathlib.Algebra.Group.Defs

structure LookaheadSequenceFamily
    (trace : QueryLog (forwardPermutationOracle (CanonicalSpongeState U)))
    (state : CanonicalSpongeState U) (i : pSpec.ChallengeIdx) where
   
  seqFamily : Finset (LookaheadSequence trace state)
   
  maximality : ‚àÄ s ‚àà seqFamily, ‚àÄ s' ‚àà seqFamily,
    ¬¨ (s.inputState ‚äÜ s'.inputState) ‚à® ¬¨ (s'.outputState ‚äÜ s.outputState)
   
  length_le_challengeSize : ‚àÄ s ‚àà seqFamily, s.inputState.length ‚â§ challengeSize i

def roundRelationProp (i : Fin (‚Ñì + 1))
    (input : (Statement (L := L) Context i √ó
      (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i j)) √ó
      Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) : Prop :=
  let stmt := input.1.1
  let oStmt := input.1.2
  let wit := input.2
  masterKStateProp (mp := mp) (ùìë := ùìë) ùîΩq Œ≤
    (stmtIdx := i) (oracleIdx := i) (h_le := le_refl i) stmt wit oStmt (localChecks := True)

structure InterleavedCode (Œ∫ Œπ : Type*) [Fintype Œ∫] [Fintype Œπ] (F : Type*) [Semiring F] where
  MF : MatrixSubmodule Œ∫ Œπ F
  LC : LinearCode Œπ F

noncomputable instance {i : Fin r} (x : L) : Decidable (x ‚àà (U ùîΩq Œ≤ i : Set L)) :=

Classical.arbitrary in Mathlib.Logic.Nonempty

def fiberEvaluationMapping (i : Fin r) (steps : ‚Ñï) (h_i_add_steps : i.val + steps < ‚Ñì + ùì°)
    (f : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) i ‚Üí L)
    (y : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate)
      ‚ü®‚Üëi + steps, by admit /- proof elided -/
      ‚ü©)
    : Fin (2 ^ steps) ‚Üí L :=
  
  let fiberMap := qMap_total_fiber ùîΩq Œ≤ (i := i) (steps := steps)
    (h_i_add_steps := h_i_add_steps) (y := y)

  
  fun idx => f (fiberMap idx)

noncomputable def sDomainBasisVectors (i : Fin r) : Fin (‚Ñì + R_rate - i) ‚Üí L :=
  fun k => (normalizedW ùîΩq Œ≤ i).eval (Œ≤ ‚ü®i + k.val, by admit /- proof elided -/
  ‚ü©)

@[inline, specialize, simp]
def oracleProver : OracleProver oSpec
    Statement OStatement Witness Statement OStatement Witness !p[] := OracleProver.id

class IsSingleRound (pSpec : ProtocolSpec 2) extends ProverFirst pSpec, VerifierLast pSpec

alias ProverThenVerifier := IsSingleRound

OptionT in Init.Control.Option

Finite in Mathlib.Data.Finite.Defs

@[reducible, inline, specialize, simp]
def ChallengeIdx (vPSpec : VectorSpec n) := {i : Fin n // vPSpec.dir i = .V_to_P}

def Extractor.RoundByRound.id :
    Extractor.RoundByRound oSpec Statement Witness Witness !p[] (fun _ => Witness) where
  eqIn := rfl
  extractMid := fun i => Fin.elim0 i
  extractOut := fun _ _ => _root_.id

LE in Init.Prelude

@[reducible, inline]
instance instProdForall {Œπ : Type u} (v : Œπ ‚Üí Type v) [O : ‚àÄ i, OracleInterface (v i)] :
    OracleInterface (‚àÄ i, v i) where
  Query := (i : Œπ) √ó (O i).Query
  Response := (i : Œπ) √ó (O i).Response
  answer := fun f ‚ü®i, q‚ü© => ‚ü®i, (O i).answer (f i) q‚ü©

instance {i : Fin r} : DecidableEq (U ùîΩq Œ≤ i) :=

noncomputable def oddPart (f : Polynomial F) : Polynomial F :=
    C (2‚Åª¬π : F) * (f - f.comp (-X)) /‚Çò X

@[reducible]
def Statement := Fin sz.n_x ‚Üí R

instance instOfNat {n : ‚Ñï} : OfNat (CNat n) n := match n with
  | 0 => by admit /- proof elided -/
  | .succ n => by admit /- proof elided -/

private def sum_choose_K_i (B : Finset (Fin n ‚Üí F)) (i : Fin n) : ‚Ñö :=
  ‚àë (Œ± : F), choose_2 (K B i Œ±)

@[inline] def toT [Zero T] (c : Cayley T) : T := c.toFun 0

@[simp]
abbrev EvalClaim : R1CS.MatrixIdx ‚Üí Type := fun _ => R

instance {i : OracleMessageIdx pSpec} : OracleInterface (pSpec.Message i) :=
  (inst.oracleInterfaces i).get i.2

def processMemoryOps (ops : List (MemoryOp Œπ Œ±)) (startMem : M) : Option M :=
  ops.foldlM (fun m op =>
    match op with
    | .read ‚ü®i, v‚ü© => if Memory.read m i = v then some m else none
    | .write ‚ü®i, v‚ü© => some (Memory.write m i v)
  ) startMem

Nat.bodd in Mathlib.Data.Nat.Bits

def commitPrvState (i : Fin ‚Ñì) : Fin (1 + 1) ‚Üí Type := fun
  | ‚ü®0, _‚ü© => Statement (L := L) Context i.succ √ó
    (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j) √ó
    Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ
  | ‚ü®1, _‚ü© => Statement (L := L) Context i.succ √ó
    (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.succ j) √ó
    Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ

noncomputable def ofMvPolynomialAlgHom : MvPolynomial œÉ R ‚Üí‚Çê[R] P := MvPolynomial.aeval X

@[reducible]
def GroupEqOracle : OracleSpec Unit := fun _ => (Œπ √ó Œπ, Bool)

def localized_fold_matrix_form (i : Fin ‚Ñì) (steps : ‚Ñï) (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
  (r_challenges : Fin steps ‚Üí L)
  (y : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®‚Üëi + steps, by omega‚ü©)
  (fiber_eval_mapping : Fin (2 ^ steps) ‚Üí L) :
  L :=

Nat.ceil in Mathlib.Algebra.Order.Floor.Defs

Inhabited in Init.Prelude

instance : Field BTF‚ÇÉ := instFieldConcrete

Algebra.cast in Mathlib.Algebra.Algebra.Defs

structure PrimeWithMultiplicity : Type where
  prime : ‚Ñï
  multiplicity : ‚Ñï
deriving Repr

def MLE (evals : (œÉ ‚Üí Fin 2) ‚Üí R) : MvPolynomial œÉ R :=
    ‚àë x : œÉ ‚Üí Fin 2, (eqPolynomial (x : œÉ ‚Üí R)) * C (evals x)

protected def cast (T : FullTranscript pSpec‚ÇÅ) :
    FullTranscript pSpec‚ÇÇ :=
  Transcript.cast (k := Fin.last n‚ÇÅ) (l := Fin.last n‚ÇÇ) hn hn hSpec T

def lagrangeToMono_segment (n : ‚Ñï) (r : Fin n) (l : Fin (r.val + 1)) :
    Vector R (2 ^ n) ‚Üí Vector R (2 ^ n) :=
  let range := forwardRange n r l
  (range.foldr (fun h acc => lagrangeToMonoLevel h acc))

instance : OracleInterfaces (vPSpec.toProtocolSpec A) where
  oracleInterfaces := fun _ => some OracleInterface.instVector

IO.FS.readFile in Init.System.IO

class IsSecure
    (relation : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (Œµ_rbr : vPSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0)
    (vectorIOP : VectorIOP Statement OStatement Witness vPSpec A) where

   
  is_complete : vectorIOP.perfectCompleteness (pure ()) ‚ü®isEmptyElim‚ü© relation

   
  is_rbr_knowledge_sound :
    OracleProof.rbrKnowledgeSoundness (pure ()) ‚ü®isEmptyElim‚ü© relation vectorIOP.verifier Œµ_rbr

Fintype.ofIsEmpty in Mathlib.Data.Fintype.OfMap

@[ext]
structure ProverInput (StmtIn WitIn PrvState : Type) where
  input : StmtIn √ó WitIn ‚Üí PrvState

instance [Zero T] [ToNat T] : Mul (Cayley T) where
  mul := mul

def Permute.ofEquiv (Œ± : Type*) (e : Equiv Œ± Œ±) : Permute Œ± where
  permute := e.toFun

instance : MonadLift (StateT œÑ m) (StateT (œÉ √ó œÑ) m) where
  monadLift := fun x st => do let y ‚Üê x st.2; return (y.1, st.1, y.2)

noncomputable def towerEquiv_zero : RingEquiv (R:=GF(2)) (S:=ConcreteBTField 0) :=  {
  toFun := fun x => if x = 0 then 0 else 1,
  invFun := fun x => if x = 0 then 0 else 1,
  left_inv := fun x => by admit /- proof elided -/

@[app_unexpander SliceGE.sliceGE]
def sliceGEUnexpander : Lean.PrettyPrinter.Unexpander
  | `($_ $v $start $_) => `($v‚ü¶$start :‚üß)
  | _ => throw ()

@[reducible]
def messageLength (vPSpec : VectorSpec n) (i : MessageIdx vPSpec) : Nat := vPSpec.length i

class NonBinaryField (F : Type*) extends Field F where
  char_neq_2 : (2 : F) ‚â† 0

def getPutativeRoot_with_hash {s} (idx : BinaryTree.SkeletonLeafIndex s)
    (leafValue : Œ±) (proof : List Œ±) (hashFn : Œ± ‚Üí Œ± ‚Üí Œ±) : Œ± :=
  match proof with
  | [] => leafValue 
  | siblingBelowRootHash :: restProof =>
    match idx with
    | BinaryTree.SkeletonLeafIndex.ofLeaf =>
      
      
      
      leafValue
    | BinaryTree.SkeletonLeafIndex.ofLeft idxLeft =>
      
      hashFn (getPutativeRoot_with_hash idxLeft leafValue restProof hashFn) siblingBelowRootHash
    | BinaryTree.SkeletonLeafIndex.ofRight idxRight =>
      
      hashFn siblingBelowRootHash (getPutativeRoot_with_hash idxRight leafValue restProof hashFn)

@[inline]
def ofOutputOnly
    (liftStmt : OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i) ‚Üí InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i) ‚Üí
                OuterStmtOut √ó (‚àÄ i, OuterOStmtOut i)) :
    OracleStatement.Lens OuterStmtIn OuterStmtOut OuterStmtIn InnerStmtOut
                        OuterOStmtIn OuterOStmtOut OuterOStmtIn InnerOStmtOut :=
  ‚ü®id, liftStmt‚ü©

Algebra.TensorProduct.includeLeftRingHom in Mathlib.RingTheory.TensorProduct.Basic

def Option.doubleBind_v3 {Œ± Œ≤ Œ≥ : Type} (f : Œ± ‚Üí Œ≤ ‚Üí Option Œ≥)
    (x : Option Œ±) (y : Option Œ≤) : Option Œ≥ := do f (‚Üê x) (‚Üê y)

@[reducible]
def Statement (F : Type) (i : Fin (k + 1)) : Type := Fin i.val ‚Üí F

def ranges {n : ‚Ñï} (a : Fin n ‚Üí ‚Ñï) : (i : Fin n) ‚Üí Fin (a i) ‚Üí ‚Ñï :=
  match n with
  | 0 => fun i => elim0 i
  | n + 1 => fun i => by admit /- proof elided -/

@[reducible, simp] def StmtOut := Query OStatement √ó Response OStatement

def partialEval {k : ‚Ñï} (f : MvPolynomial (Fin m) F) (Œ± : Fin k ‚Üí F) (h : k ‚â§ m) :
    MvPolynomial (Fin (m - k)) F :=
  let œÜ : Fin m ‚Üí MvPolynomial (Fin (m - k)) F := fun i =>
    if h' : i.val < k then
      C (Œ± ‚ü®i.val, h'‚ü©)
    else
      let j := i.val - k
      let j' : Fin (m - k) := ‚ü®j, sorry‚ü©
      X j'
  eval‚ÇÇ C œÜ f

def foldKnowledgeError (i : Fin ‚Ñì) (_ : (pSpecFold (L := L)).ChallengeIdx) : ‚Ñù‚â•0 :=
  let err_SC := (1 : ‚Ñù‚â•0) / (Fintype.card L)
  
  let err_BE := if hi : œë ‚à£ (i.val + 1) then
    
    œë * (Fintype.card ((sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate)
      ‚ü®i.val + 1, by admit /- proof elided -/
        ‚ü©) : ‚Ñù‚â•0) / (Fintype.card L)
  else 0
  err_SC + err_BE

def relayKnowledgeError (m : pSpecRelay.ChallengeIdx) : ‚Ñù‚â•0 :=
  match m with
  | ‚ü®j, _‚ü© => j.elim0

def relation (cs : ConstraintSystem ùì° numWires numGates) (‚Ñì : ‚Ñï) (h‚Ñì : ‚Ñì ‚â§ numWires) :
    (publicInputs : Fin ‚Ñì ‚Üí ùì°) ‚Üí (privateWitness : Fin (numWires - ‚Ñì) ‚Üí ùì°) ‚Üí Prop :=
  fun (x : Fin ‚Ñì ‚Üí ùì°) (œâ : Fin (numWires - ‚Ñì) ‚Üí ùì°) =>
    let combined := Fin.append x œâ ‚àò Fin.cast (by admit /- proof elided -/
    )
    cs.accepts combined

Polynomial.eval‚ÇÇRingHom in Mathlib.Algebra.Polynomial.Eval.Defs

@[reducible, inline, specialize, simp]
def Challenge' (pSpec : ProtocolSpec n) (i : Fin n) (_ : pSpec.dir i = .V_to_P) := pSpec.¬´Type¬ª i

noncomputable instance {R : Type u} [CommSemiring R] : PolynomialLike R R[X] where
  X := Polynomial.X
  eval‚ÇÇ := Polynomial.eval‚ÇÇRingHom
  eval‚ÇÇ_C := Polynomial.eval‚ÇÇ_C
  eval‚ÇÇ_X := Polynomial.eval‚ÇÇ_X
  eval‚ÇÇ_eq f := by admit /- proof elided -/

def nonsquareTranspose [Field F] (Œπ' : ‚Ñï) (Œ± : Œπ ‚Ü™ F) : Matrix (Fin Œπ') Œπ F :=
  (Vandermonde.nonsquare Œπ' Œ±)·µÄ

Polynomial.eval in Mathlib.Algebra.Polynomial.Eval.Defs

def masterKStateProp (stmtIdx : Fin (‚Ñì + 1))
    (oracleIdx : Fin (‚Ñì + 1))
    (h_le : oracleIdx.val ‚â§ stmtIdx.val) (stmt : Statement (L := L) Context stmtIdx)
    (wit : Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) stmtIdx)
    (oStmt : ‚àÄ j, (OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (i := oracleIdx) j))
    (localChecks : Prop := True) : Prop :=
  let oracleWitnessConsistency: Prop := oracleWitnessConsistency (mp := mp) (ùìë := ùìë) ùîΩq Œ≤
    stmtIdx oracleIdx h_le stmt wit oStmt
  let badEventExists := badEventExistsProp (œë := œë) ùîΩq Œ≤ oracleIdx
    (challenges := Fin.take (m := oracleIdx) (v := stmt.challenges) (h := by admit /- proof elided -/
    ))
    (oStmt := oStmt)
  localChecks ‚àß (badEventExists ‚à® oracleWitnessConsistency)

Algebra.TensorProduct.comm in Mathlib.RingTheory.TensorProduct.Maps

One in Init.Prelude

@[reducible]
def pBits : Nat := 31

def mulNat (a : AssocNat) : Nat ‚Üí AssocNat
| 0            => zero
| Nat.succ k   => add a (mulNat a k)

noncomputable def eval_on_Z‚ÇÄ (p : (RatFunc F)) (z : F) : F :=
  RatFunc.eval (RingHom.id _) z p


notation3:max R "[Z][X]" => Polynomial (Polynomial R)

notation3:max R "[Z][X][Y]" => Polynomial (Polynomial (Polynomial (R)))

notation3:max "Y" => Polynomial.X
notation3:max "X" => Polynomial.C Polynomial.X
notation3:max "Z" => Polynomial.C (Polynomial.C Polynomial.X)

def inputRelation [DecidableEq F] (Œ¥ : ‚Ñù‚â•0) :
    Set
      (
        (Statement (k := k) F 0 √ó (‚àÄ j, OracleStatement (k := k) D x s 0 j)) √ó
        Witness F s d (0 : Fin (k + 2))
      ) :=
  match k with
  | 0 => FinalFoldPhase.inputRelation D x s d (round_bound dom_size_cond) Œ¥
  | .succ _ => FoldPhase.inputRelation D x s d 0 (round_bound dom_size_cond) Œ¥

def Œ≤ (R : F[X][X][Y]) (t : ‚Ñï) : ùí™ H :=
  (Œ≤_regular R H (Nat.le_refl _) t).choose

Pow in Init.Prelude

WithBot.addMonoidWithOne in Mathlib.Algebra.Order.Monoid.Unbundled.WithTop

Submodule.subtype in Mathlib.Algebra.Module.Submodule.LinearMap

def finIdxOf [BEq Œ±] [LawfulBEq Œ±] (a : Œ±) (l : List Œ±) : Fin (l.length + 1) :=
  ‚ü®List.idxOf' a l, Nat.lt_succ_of_le (by admit /- proof elided -/
  )‚ü©

@[inline]
def permute (params : Params) (state : Vector KoalaBear.Field params.width) :
    Vector KoalaBear.Field params.width :=
  letI rcs := params.roundConstants

  
  let st0 := externalLinearLayer params state

  
  let st1 : Vector KoalaBear.Field params.width :=
    Fin.foldl params.halfNumFullRounds (fun st_acc rc_idx =>
      let rc_chunk := (rcs.extract rc_idx (rc_idx + params.width)).cast (by admit /- proof elided -/
      )
      let st_new := fullRound params st_acc rc_chunk
      st_new) st0

  
  let rcs := rcs.drop (params.halfNumFullRounds * params.width)

  
  let st2 := Fin.foldl params.numPartialRounds (fun st_acc rc_idx =>
    let rc_val := rcs[rc_idx]'(sorry)
    let st_new := partialRound params st_acc rc_val
    st_new) st1

  
  let rcs := rcs.drop params.numPartialRounds

  
  let st3 := Fin.foldl params.halfNumFullRounds (fun st_acc rc_idx =>
    let rc_chunk := (rcs.extract rc_idx (rc_idx + params.width)).cast (by admit /- proof elided -/
    )
    let st_new := fullRound params st_acc rc_chunk
    st_new) st2

  st3

def computableTwiddleFactor (i : Fin ‚Ñì) (u : Fin (2 ^ (‚Ñì + R_rate - i - 1))) : L :=
  
  ‚àë (‚ü®k, hk‚ü©: Fin (‚Ñì + R_rate - i - 1)),
  if Nat.getBit k u.val = 1 then
    
      
    (evalNormalizedWAt (Œ≤ := Œ≤) (‚Ñì := ‚Ñì) (R_rate := R_rate)
      (i := ‚ü®i, by admit /- proof elided -/
      ‚ü©) (x := Œ≤ ‚ü®i + 1 + k, by admit /- proof elided -/
      ‚ü©))
  else 0

def StateRestoration (oSpec : OracleSpec Œπ)
    (StmtIn WitIn WitOut : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n) :=
  StmtIn ‚Üí 
  WitOut ‚Üí 
  pSpec.FullTranscript ‚Üí 
  QueryLog (oSpec ++‚Çí (srChallengeOracle StmtIn pSpec)) ‚Üí 
  QueryLog oSpec ‚Üí 
  OracleComp oSpec WitIn 

class DFunEquiv (F : Sort*) (Œ± : outParam (Sort*)) (Œ≤ : outParam <| Œ± ‚Üí Sort*) where
  equiv : F ‚âÉ ‚àÄ a : Œ±, Œ≤ a

noncomputable def foldingBadEventAtBlock
    (stmtIdx : Fin (‚Ñì + 1)) (oracleIdx : Fin (‚Ñì + 1))
    (oStmt : ‚àÄ j, (OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (i := oracleIdx) j))
    (challenges : Fin stmtIdx ‚Üí L)
    (j : Fin (toOutCodewordsCount ‚Ñì œë oracleIdx)) : Prop :=
  have h_œë: œë > 0 := by admit /- proof elided -/

instance : SpongeUnit UInt8 where

CommSemiring in Mathlib.Algebra.Ring.Defs

Neg.neg in Init.Prelude

def OracleSpec.proverOracle (StmtIn : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n) :
    OracleSpec pSpec.MessageIdx :=
  fun i => (StmtIn √ó pSpec.Transcript i.val.castSucc, pSpec.Message i)

def divide_by_2 (s : Finset ‚Ñï) : Finset ‚Ñï :=
  (erase_odd s).image (fun n => n / 2)

def neg_descending (p : UniPoly R) : QuotientUniPoly R :=
  Quotient.mk _ (neg p)

def fnOracle (spec : OracleSpec Œπ) (f : (i : Œπ) ‚Üí spec.domain i ‚Üí spec.range i) :
    SimOracle.Impl spec where
  impl | query i t => pure (f i t)

def sumCases {l : List ‚Ñï} {motive : Fin l.sum ‚Üí Sort*}
    (cases : ‚àÄ (n : ‚Ñï) (h : n ‚àà l) (i : Fin n), motive (castSum l h i))
    (i : Fin l.sum) : motive i := match l with
  | [] => by admit /- proof elided -/
  | n' :: l' => by admit /- proof elided -/

def binaryAlgebraTower {l r : ‚Ñï} (h_le : l ‚â§ r) : Algebra (BTField l) (BTField r) :=

noncomputable instance fintype_U (i : Fin r) : Fintype (U ùîΩq Œ≤ i) :=

@[reducible]
def pSpecFold : ProtocolSpec 2 := ‚ü®![Direction.P_to_V, Direction.V_to_P], ![L‚¶É‚â§ 2‚¶Ñ[X], L]‚ü©

protected def basis : F := sorry

instance (k : ‚Ñï) : Fintype (ConcreteBTField k) := (getBTFResult k).instFintype

@[reducible, inline]
instance instPolynomialDegreeLE : OracleInterface (R‚¶É‚â§ d‚¶Ñ[X]) where
  Query := R
  Response := R
  answer := fun ‚ü®poly, _‚ü© point => poly.eval point

def statelessOracle (baseSpec : OracleSpec Œπ‚Çú) (spec : OracleSpec Œπ)
    (f : (i : Œπ) ‚Üí spec.domain i ‚Üí spec.range i) :
    SimOracle.Stateless (baseSpec ++‚Çí spec) baseSpec where
  impl
  | query (.inl i) t => query i t
  | query (.inr i) t => pure (f i t)

instance (priority := low) : DCast‚ÇÇ Œ± Œ≤ Œ≥ where
  dcast‚ÇÇ ha hb c := by admit /- proof elided -/

def symm (eqv : Equiv pSpec pSpec') : Equiv pSpec' pSpec where
  round_eq := eqv.round_eq.symm
  dir_eq := fun i => by admit /- proof elided -/

@[inline] def max [Zero T] [ToNat T] (a b : Cayley T) : Cayley T :=
  if (a : Nat) ‚â• (b : Nat) then a else b

List.finRange in Init.Data.List.FinRange

AlgHom in Mathlib.Algebra.Algebra.Hom

class GenMutualCorrParams (P : Params Œπ F) (S : ‚àÄ i : Fin (M + 1), Finset (Œπ i)) where

  Œ¥ : Fin (M + 1) ‚Üí ‚Ñù‚â•0
  dist : (i : Fin (M + 1)) ‚Üí Fin ((P.foldingParam i) + 1) ‚Üí ‚Ñù‚â•0


  œÜ : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), (indexPowT (S i) (P.œÜ i) j) ‚Ü™ F

  inst1 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Fintype (indexPowT (S i) (P.œÜ i) j)
  inst2 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    Nonempty (indexPowT (S i) (P.œÜ i) j)
  inst3 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    DecidableEq (indexPowT (S i) (P.œÜ i) j)
  inst4 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Smooth (œÜ i j)

  par‚Ñì_type : ‚àÄ i : Fin (M + 1), ‚àÄ _ : Fin ((P.foldingParam i) + 1), Type
  inst5 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Fintype (par‚Ñì_type i j)

  exp : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), (par‚Ñì_type i j) ‚Ü™ ‚Ñï



  Gen_Œ± : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    ProximityGenerator (indexPowT (S i) (P.œÜ i) j) F :=
      fun i j => RSGenerator.genRSC (par‚Ñì_type i j) (œÜ i j) (P.varCount i - j) (exp i j)

  inst6 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Fintype (Gen_Œ± i j).par‚Ñì

  BStar : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    (Set ((indexPowT (S i) (P.œÜ i) j) ‚Üí F)) ‚Üí Type ‚Üí ‚Ñù‚â•0
  errStar : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    (Set ((indexPowT (S i) (P.œÜ i) j) ‚Üí F)) ‚Üí Type ‚Üí ‚Ñù ‚Üí ENNReal

  C : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Set ((indexPowT (S i) (P.œÜ i) j) ‚Üí F)
  hcode : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), (C i j) = (Gen_Œ± i j).C

  h : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    hasMutualCorrAgreement (Gen_Œ± i j)
      (BStar i j (C i j) (Gen_Œ± i j).par‚Ñì)
      (errStar i j (C i j) (Gen_Œ± i j).par‚Ñì)

  h‚Ñì_bound : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    Fintype.card (Gen_Œ± i j).par‚Ñì = 2
  h‚Ñì_bound' : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    Fintype.card (par‚Ñì_type i j) = 2

  hŒ¥Le : ‚àÄ i : Fin (M + 1),
    (Œ¥ i) ‚â§ 1 - Finset.univ.sup (fun j => BStar i j (C i j) (Gen_Œ± i j).par‚Ñì)

  hlistDecode : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    listDecodable (C i j) (Œ¥ i) (dist i j)

@[reducible]
def reduction : Reduction oSpec
    (StatementRound R n 0 √ó ‚àÄ i, OracleStatement R n deg i) Unit
    (StatementRound R n (.last n) √ó ‚àÄ i, OracleStatement R n deg i) Unit
    (pSpec R deg n) :=
  Reduction.seqCompose (oSpec := oSpec)
    (Stmt := fun i => StatementRound R n i √ó (‚àÄ j, OracleStatement R n deg j))
    (Wit := fun _ => Unit)
    (pSpec := fun _ => SingleRound.pSpec R deg)
    (SingleRound.reduction R n deg D oSpec)

instance {langIn : Set StmtIn} {langOut : Set StmtOut}
    {verifier : Verifier oSpec StmtIn StmtOut pSpec} :
    CoeFun (verifier.StateFunction init impl langIn langOut)
    (fun _ => (m : Fin (n + 1)) ‚Üí StmtIn ‚Üí Transcript m pSpec ‚Üí Prop) := ‚ü®fun f => f.toFun‚ü©

def relayKnowledgeStateFunction (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
    (relayOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        i hNCR).KnowledgeStateFunction init impl
      (relIn := foldStepRelOut (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i.succ)
      (extractor := relayRbrExtractor ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) where
  toFun := fun m ‚ü®stmtIn, oStmtIn‚ü© tr witMid =>
    relayKStateProp (mp:=mp) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (ùìë := ùìë) i hNCR stmtIn witMid oStmtIn
  toFun_empty := fun ‚ü®stmtIn, oStmtIn‚ü© witIn => by admit /- proof elided -/

def hcons {n : ‚Ñï} {Œ± : Sort u} {Œ≤ : Fin n ‚Üí Sort u} (a : Œ±) (b : (i : Fin n) ‚Üí Œ≤ i) :
    (i : Fin (n + 1)) ‚Üí Fin.vcons Œ± Œ≤ i :=
  fcons (F := id) a b

@[inline]
def ofInputOnly
    (projStmt : OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i) ‚Üí InnerStmtIn √ó (‚àÄ i, InnerOStmtIn i)) :
    OracleStatement.Lens OuterStmtIn OuterStmtOut InnerStmtIn OuterStmtOut
                        OuterOStmtIn OuterOStmtOut InnerOStmtIn OuterOStmtOut :=
  ‚ü®projStmt, fun _ => id‚ü©

Lean.parseImports' in Lean.Elab.ParseImportsFast

IsCyclic.commGroup in Mathlib.GroupTheory.SpecificGroups.Cyclic

@[inline]
def lagrangeToMono (n : ‚Ñï) :
    Vector R (2 ^ n) ‚Üí Vector R (2 ^ n) :=
  (List.finRange n).foldr (fun h acc => lagrangeToMonoLevel h acc)

@[inline, specialize]
def prover : Prover oSpec Statement Witness (Statement √ó Witness) Unit (pSpec Witness) where
  PrvState
  | 0 => Statement √ó Witness
  | 1 => Statement √ó Witness
  input := id
  sendMessage | ‚ü®0, _‚ü© => fun ‚ü®stmt, wit‚ü© => pure (wit, ‚ü®stmt, wit‚ü©)
  receiveChallenge | ‚ü®0, h‚ü© => nomatch h
  output := fun ‚ü®stmt, wit‚ü© => pure (‚ü®stmt, wit‚ü©, ())

structure Params where
  
  width : Nat
  numFullRounds : Nat
  numPartialRounds : Nat
  internalDiagVectors : Vector KoalaBear.Field width
  roundConstants : Vector KoalaBear.Field (numFullRounds * width + numPartialRounds)

  

   
  [width_ne_zero : NeZero width]

   
  [numFullRounds_ne_zero : NeZero numFullRounds]

   
  [numPartialRounds_ne_zero : NeZero numPartialRounds]

   
  width_dvd_by_4 : 4 ‚à£ width
   
  numFullRounds_even : Even numFullRounds

Lean.mkRawNatLit in Lean.Expr

noncomputable def codeDistNew (C : Set (n ‚Üí R)) : ‚Ñù := C.infsep

MvPolynomial.support in Mathlib.Algebra.MvPolynomial.Basic

Polynomial.IsRoot in Mathlib.Algebra.Polynomial.Eval.Defs

noncomputable def finalFoldOracleReduction :
  OracleReduction []‚Çí
    (Statement F (Fin.last k)) (OracleStatement D x s (Fin.last k))
      (Witness F s d (Fin.last k).castSucc)
    (FinalStatement F k) (FinalOracleStatement D x s)
      (Witness F s d (Fin.last (k + 1)))
    (pSpec F) where
  prover := finalFoldProver D x s d
  verifier := finalFoldVerifier D x s d

@[app_unexpander Fin.vcons]
def vconsUnexpander : Lean.PrettyPrinter.Unexpander
  | `($_ $term !v[$term2, $terms,*]) => `(!v[$term, $term2, $terms,*])
  | `($_ $term !v[$term2]) => `(!v[$term, $term2])
  | `($_ $term !v[]) => `(!v[$term])
  | _ => throw ()

def multilinearBasis (l r : ‚Ñï) (h_le : l ‚â§ r) :
    letI instAlgebra : Algebra (BTField l) (BTField r) := binaryAlgebraTower (h_le:=h_le)
    Basis (Fin (2 ^ (r - l))) (BTField l) (BTField r) :=

LinearEquiv in Mathlib.Algebra.Module.Equiv.Defs

instance : Dist (n ‚Üí R) where
  dist := fun u v => hammingDist u v

def rawConstants16 : Vector KoalaBear.Field 148 := #v[
    2128964168,
    288780357,
    316938561,
    2126233899,
    426817493,
    1714118888,
    1045008582,
    1738510837,
    889721787,
    8866516,
    681576474,
    419059826,
    1596305521,
    1583176088,
    1584387047,
    1529751136,
    1863858111,
    1072044075,
    517831365,
    1464274176,
    1138001621,
    428001039,
    245709561,
    1641420379,
    1365482496,
    770454828,
    693167409,
    757905735,
    136670447,
    436275702,
    525466355,
    1559174242,
    1030087950,
    869864998,
    322787870,
    267688717,
    948964561,
    740478015,
    679816114,
    113662466,
    2066544572,
    1744924186,
    367094720,
    1380455578,
    1842483872,
    416711434,
    1342291586,
    1692058446,
    1493348999,
    1113949088,
    210900530,
    1071655077,
    610242121,
    1136339326,
    2020858841,
    1019840479,
    678147278,
    1678413261,
    1361743414,
    61132629,
    1209546658,
    64412292,
    1936878279,
    1980661727,
    1423960925,
    2101391318,
    1915532054,
    275400051,
    1168624859,
    1141248885,
    356546469,
    1165250474,
    1320543726,
    932505663,
    1204226364,
    1452576828,
    1774936729,
    926808140,
    1184948056,
    1186493834,
    843181003,
    185193011,
    452207447,
    510054082,
    1139268644,
    630873441,
    669538875,
    462500858,
    876500520,
    1214043330,
    383937013,
    375087302,
    636912601,
    307200505,
    390279673,
    1999916485,
    1518476730,
    1606686591,
    1410677749,
    1581191572,
    1004269969,
    143426723,
    1747283099,
    1016118214,
    1749423722,
    66331533,
    1177761275,
    1581069649,
    1851371119,
    852520128,
    1499632627,
    1820847538,
    150757557,
    884787840,
    619710451,
    1651711087,
    505263814,
    212076987,
    1482432120,
    1458130652,
    382871348,
    417404007,
    2066495280,
    1996518884,
    902934924,
    582892981,
    1337064375,
    1199354861,
    2102596038,
    1533193853,
    1436311464,
    2012303432,
    839997195,
    1225781098,
    2011967775,
    575084315,
    1309329169,
    786393545,
    995788880,
    1702925345,
    1444525226,
    908073383,
    1811535085,
    1531002367,
    1635653662,
    1585100155,
    867006515,
    879151050,
]

CommGroup in Mathlib.Algebra.Group.Defs

def add_descending (p q : UniPoly R) : QuotientUniPoly R :=
  Quotient.mk _ (add p q)

BitVec.append in Init.Data.BitVec.Basic

instance : ‚àÄ i, VCVCompatible ((pSpec Witness).Challenge i) | ‚ü®0, h‚ü© => nomatch h

MulOneClass in Mathlib.Algebra.Group.Defs

@[reducible]
def pSpecFoldCommit (i : Fin ‚Ñì) : ProtocolSpec (3) :=
  pSpecFold (L:=L) ++‚Çö pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i

Nat.pow in Init.Prelude

List.max in Init.Data.List.Basic

def extend {k : Fin n} (challenges : ChallengesUpTo k.castSucc pSpec)
    (h : pSpec.dir k = .P_to_V) : ChallengesUpTo k.succ pSpec :=
  fun ‚ü®i, h‚ü© => (concat' (pSpec := pSpec) (fun i hi => challenges ‚ü®i, hi‚ü©) (fun h' => by admit /- proof elided -/
  )) i h

def oracleVerifier : OracleVerifier oSpec Statement OStatement Unit (OStatement ‚äï·µ• OStatement)
    (pSpec OStatement) where

  verify := fun stmt _ => relComp stmt

  embed := sorry

  hEq := sorry

Irreducible in Mathlib.Algebra.Group.Irreducible.Defs

@[reducible, simp] def WitOut := Unit

WithBot in Mathlib.Order.TypeTags

@[inline] def mul [Zero T] [ToNat T] (a b : Cayley T) : Cayley T :=
  mulNat a ‚Üëb

Finset.Icc in Mathlib.Order.Interval.Finset.Defs

OracleSpec.range in VCVio.OracleComp.OracleSpec

def lawfulInterleavedCodeOfLinearCode (Œ∫ : Type*) [Fintype Œ∫] (LC : LinearCode Œπ F) :
  LawfulInterleavedCode Œ∫ Œπ F := ‚ü®codeOfLinearCode Œ∫ LC, isInterleaved_codeOfLinearCode‚ü©

abbrev Size.n_x : ‚Ñï := sz.n - sz.n_w

noncomputable instance : DecidableEq (GF(2)) :=
  fun x y =>
    
    let œÜ : GF(2) ‚âÉ‚Çê[ZMod 2] ZMod 2 := GaloisField.equivZmodP 2
    
    if h : œÜ x = œÜ y then
      isTrue (by admit /- proof elided -/
        )
    else
      isFalse (by admit /- proof elided -/
        )

@[reducible]
def value (op : MemoryWrite Œπ Œ±) := op.2

Array in Init.Prelude

@[reducible]
def pSpec : ProtocolSpec 1 :=
  ‚ü®!v[.V_to_P], !v[Fin l ‚Üí evalDomain D x 0]‚ü©

Polynomial.support in Mathlib.Algebra.Polynomial.Basic

@[simp]
instance BTFieldNeZero1 (k : ‚Ñï) : NeZero (1 : BTField k) :=

def finalSumcheckRelOut :
    Set ((FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì) √ó
      (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì) j)) √ó
      (Unit)) :=
  { input | finalSumcheckRelOutProp ùîΩq Œ≤ (input := input) }

instance : ‚àÄ i, OracleInterface (EvalClaim R i) :=
  fun _ => default

noncomputable def deevenize (f : Polynomial F) : Polynomial F :=
    match f with
      | ‚ü®‚ü®supp, g, h‚ü©‚ü© => ‚ü®‚ü®divide_by_2 supp, fun n => g (2 * n), by admit /- proof elided -/
      ‚ü©‚ü©

def proverOutput (i : Fin n) : ProverOutput oSpec
    ((StatementRound R n i.succ √ó (‚àÄ i, OracleStatement R n deg i)) √ó Unit)
    ((proverState R n deg i).PrvState (Fin.last 2)) where
  output := fun x => pure (x, ())

@[reducible, simp]
def toRelOut : Set ((Statement √ó Witness) √ó Unit) :=
  Prod.fst ‚Åª¬π' relIn

@[inline, reducible]
def proj : OuterStmtIn √ó OuterWitIn ‚Üí InnerWitIn :=
  lens.toFunA

structure FSVerifierState (U : Type) [SpongeUnit U] (H : Type*) [DuplexSpongeInterface U H] where
   
  hashState : HashStateWithInstructions U H
   
  nargString : ByteArray
deriving Repr

def inputRelation [DecidableEq F] (Œ¥ : ‚Ñù‚â•0) :
    Set
      (
        Unit √ó (‚àÄ j, OracleStatement D x m j) √ó (Witness F s d m)
      ) := sorry

def BTField_succ_alg_equiv_adjoinRoot (k : ‚Ñï) :
  AdjoinRoot (poly k) ‚âÉ‚Çê[BTField k] BTField (k + 1) :=

instance [Zero T] [ToNat T] : DecidableEq (Cayley T) := fun a b =>
  if h : (‚Üëa : Nat) = (‚Üëb : Nat) then
    isTrue (by admit /- proof elided -/
      )
  else
    isFalse (fun heq => h (by admit /- proof elided -/
    ))

def commitKState (i : Fin ‚Ñì) (hCR : isCommitmentRound ‚Ñì œë i) :
    (commitOracleVerifier ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      i hCR).KnowledgeStateFunction init impl
      (relIn := foldStepRelOut (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i.succ)
      (extractor := commitRbrExtractor ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) where
  toFun := fun m ‚ü®stmtIn, oStmtIn‚ü© tr witMid =>
    commitKStateProp ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (i := i) (m := m) (stmtIn := stmtIn) (witMid := witMid) (oStmtIn := oStmtIn) (mp:=mp)
  toFun_empty := fun stmtIn witMid => by admit /- proof elided -/

def deriveTranscriptSR {Œπ : Type} {oSpec : OracleSpec Œπ} {StmtIn : Type}
    (stmt : StmtIn) (messages : pSpec.Messages) :
    OracleComp (oSpec ++‚Çí fsChallengeOracle StmtIn pSpec) pSpec.FullTranscript := do
  MessagesUpTo.deriveTranscriptSR stmt (Fin.last n) messages

alias deriveTranscriptFS := deriveTranscriptSR

def regularElms_set (H : F[X][Y]) : Set (ùïÉ H) :=
  {a : ùïÉ H | ‚àÉ b : ùí™ H, a = embeddingOfùí™IntoùïÉ _ b}

Vector.map in Init.Data.Vector.Basic

def ofMessagesChallenges (messages : MessagesUpTo k pSpec)
    (challenges : ChallengesUpTo k pSpec) : Transcript k pSpec :=
  fun i => match h : pSpec.dir (i.castLE (by admit /- proof elided -/
  )) with
  | Direction.P_to_V => messages ‚ü®i.castLE (by admit /- proof elided -/
  ), h‚ü©
  | Direction.V_to_P => challenges ‚ü®i.castLE (by admit /- proof elided -/
  ), h‚ü©

instance [inst : ‚àÄ i, SelectableType (pSpec.Challenge i)] :
    ‚àÄ i, SelectableType ((pSpec.addSalt Salt).Challenge i) :=
  fun i => by admit /- proof elided -/

instance : Unique (ChallengeIdx ‚ü®!v[.V_to_P], !v[Chal]‚ü©) where
  default := ‚ü®0, by admit /- proof elided -/
  ‚ü©
  uniq := fun i => by admit /- proof elided -/

def chunkPairwise {Œ± : Type} : {n : Nat} ‚Üí Vector Œ± (2 * n) ‚Üí Vector (Œ± √ó Œ±) n
  | 0, Vector.nil => Vector.nil
  | n + 1, xs => by admit /- proof elided -/

BitVec.zero in Init.Data.BitVec.Basic

noncomputable def Œ¥_Œµ_proximityGap {Œ± : Type} [DecidableEq Œ±] [Nonempty Œ±]
  (P : Finset (Œπ ‚Üí Œ±)) (C : Set (Finset (Œπ ‚Üí Œ±))) (Œ¥ Œµ : ‚Ñù‚â•0) : Prop :=
  ‚àÄ S ‚àà C, ‚àÄ [Nonempty S],
  Xor'
  ( Pr_{let x ‚Üê $·µñ S}[Code.relHammingDistToCode x.1 P ‚â§ Œ¥] = 1 )
  ( Pr_{let x ‚Üê $·µñ S}[Code.relHammingDistToCode x.1 P ‚â§ Œ¥] ‚â§ Œµ )

def mul_by_2 (s : Finset ‚Ñï) : Finset ‚Ñï :=
  s.map ‚ü®fun n => 2 * n, by admit /- proof elided -/
  ‚ü©

Set.fintypeMemFinset in Mathlib.Data.Set.Finite.Basic

Module.Basis.smulTower in Mathlib.RingTheory.AlgebraTower

@[inline] def zero : Cayley T :=
  ‚ü®id, by admit /- proof elided -/
  ‚ü©

@[reducible]
def pSpec : ProtocolSpec 2 :=
  ‚ü®!v[.P_to_V], !v[R‚¶É‚â§ deg‚¶Ñ[X]]‚ü© ++‚Çö !p[] ++‚Çö ‚ü®!v[.V_to_P], !v[R]‚ü© ++‚Çö !p[]

@[elab_as_elim] def Fin.succRecOnSameFinType {motive : Fin r ‚Üí Sort _}
    (zero : motive (0 : Fin r))
    (succ : ‚àÄ i : Fin r, i + 1 < r ‚Üí motive i ‚Üí motive (i + 1)) : ‚àÄ (i : Fin r), motive i
  | ‚ü®0, _‚ü© => by admit /- proof elided -/
  | ‚ü®Nat.succ i_val, h‚ü© => by admit /- proof elided -/

@[reducible]
def MemoryWrite (Œπ : Type u) (Œ± : Œπ ‚Üí Type v) := (index : Œπ) √ó (Œ± index)

def rho' (n : ‚Ñï) (start : ‚Ñï) (c : ‚Ñï) : Option ‚Ñï := Id.run do
  if n % 2 = 0 then
    return some 2

  let mut x := start
  let mut y := x
  let mut d := 1

  while d = 1 do
    x := g n c x
    y := g n c (g n c y)
    d := Nat.gcd (Int.natAbs (x - y)) n

  if d = n then
    return none
  else
    return some d

Int in Init.Data.Int.Basic

instance : Add AssocNat where
  add := add

@[inline, specialize]
def add {R : Type*} [Ring R] [BEq R] [LawfulBEq R] (p q : QuotientUniPoly R) : QuotientUniPoly R :=
  Quotient.lift‚ÇÇ add_descending add_descends p q

instance oCtxLens_complete :
    (oCtxLens R n deg D i).toContext.IsComplete
      (relationRound R n deg D i.castSucc) (Simple.inputRelation R deg D)
      (relationRound R n deg D i.succ) (Simple.outputRelation R deg)
      ((Simple.oracleReduction R deg D oSpec).toReduction.compatContext
        (oCtxLens R n deg D i).toContext)
where
  proj_complete := by admit /- proof elided -/

instance instNatPow {n : ‚Ñï} : NatPow (CNat n) := match n with
  | 0 => by admit /- proof elided -/
  | .succ n => by admit /- proof elided -/

@[reducible, inline, specialize, simp]
def srChallengeQueryImpl {Statement : Type} {pSpec : ProtocolSpec n}
    [‚àÄ i, SelectableType (pSpec.Challenge i)] :
    QueryImpl (srChallengeOracle Statement pSpec) ProbComp where
  impl | query i _ => uniformOfFintype (pSpec.Challenge i)

Finset.univ in Mathlib.Data.Fintype.Defs

local instance : Inhabited R := ‚ü®0‚ü©

noncomputable instance : CommSemiring (Left ‚äó[K] Right) := Algebra.TensorProduct.instCommSemiring

structure ConcreteBTFDivisionRingProps (k : ‚Ñï) extends (ConcreteBTFRingProps k) where
  
  mul_inv_cancel : ‚àÄ a : ConcreteBTField k, a ‚â† zero ‚Üí concrete_mul a (concrete_inv a) = one

def getFirstOracle {i : Fin (‚Ñì + 1)}
    (oStmt : (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i j)) :
    sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate 0 ‚Üí L :=

OneMemClass in Mathlib.Algebra.Group.Submonoid.Defs

Submodule in Mathlib.Algebra.Module.Submodule.Defs

Algebra.TensorProduct.leftAlgebra in Mathlib.RingTheory.TensorProduct.Basic

Array.mk in Init.Prelude

inductive MemoryOp (Œπ : Type u) (Œ± : Œπ ‚Üí Type v) where
  | read (op : MemoryRead Œπ Œ±)
  | write (op : MemoryWrite Œπ Œ±)

def implGroupEqOracle [BEq G] :
    QueryImpl (GroupEqOracle Œπ) (StateT (GroupValTable Œπ G) Option) where
  impl | query _ ‚ü®i, j‚ü© => fun table =>
    match table i, table j with
    | some g‚ÇÅ, some g‚ÇÇ => some (g‚ÇÅ == g‚ÇÇ, table)
    | _, _ => none

inductive Program where

BitVec.cast in Init.Data.BitVec.Basic

noncomputable def xPoly
  {S : Finset Œπ} (f : Œπ ‚Üí F) (œÜ : Œπ ‚Ü™ F) (k : ‚Ñï) (x : indexPow S œÜ k) : Polynomial F :=
  let dom := powFiber S œÜ k x
  let emb : { y // y ‚àà dom } ‚Üí F := œÜ ‚àò Subtype.val
  let g : { y // y ‚àà dom } ‚Üí F := f ‚àò Subtype.val
  Lagrange.interpolate univ emb g

instance (s : Finset œÉ) : Fintype { x : œÉ | x ‚àà s } :=

Finset.image in Mathlib.Data.Finset.Image

noncomputable def changeOfBasisMatrix (‚Ñì : Nat) (h_‚Ñì : ‚Ñì ‚â§ r) : Matrix (Fin (2^‚Ñì)) (Fin (2^‚Ñì)) L :=
    fun j i => (toCoeffsVec (L := L) (‚Ñì := ‚Ñì) (
      basisVectors ùîΩq Œ≤ ‚Ñì h_‚Ñì j)) i

Function.onFun in Mathlib.Logic.Function.Defs

instance [ProverFirst pSpec] : ‚àÄ i, VCVCompatible (pSpec.Challenge i) := isEmptyElim

class HListRepr (Œ± : Type _) where
  repr: Œ± ‚Üí Std.Format

def Verifier.append (V‚ÇÅ : Verifier oSpec Stmt‚ÇÅ Stmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : Verifier oSpec Stmt‚ÇÇ Stmt‚ÇÉ pSpec‚ÇÇ) :
      Verifier oSpec Stmt‚ÇÅ Stmt‚ÇÉ (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ) where
  verify := fun stmt transcript => do
    return ‚Üê V‚ÇÇ.verify (‚Üê V‚ÇÅ.verify stmt transcript.fst) transcript.snd

def g (n : ‚Ñï) (c : ‚Ñï) (x : ‚Ñï) := (x * x + c) % n

def aeval {A : Type y} [CommSemiring A] [Algebra R A] {F : Type z} [FunEquiv F œÉ A] (g : F) :
    P ‚Üí‚Çê[R] A :=
  eval‚ÇÇAlgHom (Algebra.ofId R A) g

Or.inl in Init.Prelude

@[inline, reducible]
def proj (lens : Extractor.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
              OuterWitIn OuterWitOut InnerWitIn InnerWitOut) :
    OuterStmtIn √ó OuterWitOut ‚Üí InnerStmtIn √ó InnerWitOut :=
  fun ‚ü®stmtIn, witOut‚ü© => ‚ü®lens.stmt.proj stmtIn, lens.wit.proj (stmtIn, witOut)‚ü©

def ri (dstar : ‚Ñï) (degs : Fin m ‚Üí ‚Ñï) (r : F) (i : Fin m) : F :=
          match i.1 with
          | 0 => 1
          | .succ i' =>
            let exp := i' + ‚àë j < i, (dstar - degs j)
            r ^ exp

instance [Semiring R] : Module R (MlPolyEval R n) where
  smul := smul
  one_smul a := by admit /- proof elided -/

private def f (x : ‚Ñö) : ‚Ñö := x^2 - x

instance : Serde UInt8 ByteArray where

OracleSpec.QueryLog.inr in VCVio.OracleComp.QueryTracking.Structures

inductive Skeleton :
    (n : ‚Ñï) ‚Üí (ar : Fin n ‚Üí ‚Ñï) ‚Üí Type where
  | leaf {ar0 : Fin 0 ‚Üí ‚Ñï} : Skeleton 0 ar0
  | node {n : ‚Ñï} {ar : Fin (n+1) ‚Üí ‚Ñï}
      (children : Fin (ar 0) ‚Üí
        Skeleton n (fun i => ar i.succ)) :
      Skeleton (n+1) ar

RingHom.id in Mathlib.Algebra.Ring.Hom.Defs

OracleComp.construct' in VCVio.OracleComp.OracleComp

Quotient.lift‚ÇÇ in Init.Core

def backwardPermutationOracleImpl {Œ± : Type*} [Permute Œ±] [LawfulPermute Œ±] :
    QueryImpl (backwardPermutationOracle Œ±) Id where
  impl | query () q => LawfulPermute.permuteInv (Œ± := Œ±) q

def fillNextUnits (state : FSVerifierState U H) (count : Nat) :
    Except DomainSeparatorMismatch (FSVerifierState U H √ó Array U) := do
  
  let bytesNeeded := count * HasSize.size U UInt8
  if state.nargString.size < bytesNeeded then
    .error {
      message := s!"Insufficient transcript remaining, need {bytesNeeded} bytes,
        got {state.nargString.size}" }
  else
    
    let readBytes := state.nargString.extract 0 bytesNeeded
    let remaining := state.nargString.extract bytesNeeded state.nargString.size
    
    let units := Array.range count |>.mapM (fun i =>
      let unitBytes := readBytes.extract (i * HasSize.size U UInt8) (HasSize.size U UInt8)
      DeserializeOption.deserialize unitBytes)
    match units with
    | some unitsArray =>
      
      let newHashState ‚Üê state.hashState.absorb unitsArray
      .ok ({ hashState := newHashState, nargString := remaining }, unitsArray)
    | none =>
      .error { message := "Failed to deserialize units from NARG string" }

Polynomial.roots in Mathlib.Algebra.Polynomial.Roots

instance {Œ± : Type*} {s : Finset Œ±} [inst : Nonempty s] : Nonempty (s.toSet) :=

def take (j : Fin (n + 1)) (messages : Messages pSpec) : MessagesUpTo j pSpec :=

instance : AlgebraTower (BTField) where
  algebraMap := towerAlgebraMap
  commutes' := by admit /- proof elided -/

def buildLayer (n : ‚Ñï) (leaves : List.Vector Œ± (2 ^ (n + 1))) :
    OracleComp (spec Œ±) (List.Vector Œ± (2 ^ n)) := do
  let leaves : List.Vector Œ± (2 ^ n * 2) :=

protected def Prover.id : Prover oSpec Statement Witness Statement Witness !p[] where
  PrvState := fun _ => Statement √ó Witness
  input := _root_.id
  sendMessage := fun i => Fin.elim0 i
  receiveChallenge := fun i => Fin.elim0 i
  output := pure

List.foldr in Init.Data.List.Basic

Fin.cast in Init.Data.Fin.Basic

instance {pSpec : ProtocolSpec n} {Statement : Type} [‚àÄ i, VCVCompatible (pSpec.Challenge i)] :
    OracleSpec.FiniteRange (fsChallengeOracle Statement pSpec) :=
  inferInstanceAs (OracleSpec.FiniteRange (srChallengeOracle Statement pSpec))

zsmulRec in Mathlib.Algebra.Group.Defs

def zero : ChurchNat Œ± := fun _ x => x

class VerifierOnly (pSpec : ProtocolSpec 1) extends VerifierFirst pSpec

instance : HListString (HList []) where
  toString
  | HList.nil => ""

def dempty {Œ± : Fin 0 ‚Üí Sort u} : (i : Fin 0) ‚Üí Œ± i := fun i => Fin.elim0 i

def rightpad {m : ‚Ñï} {Œ± : Sort*} (n : ‚Ñï) (a : Œ±) (v : Fin m ‚Üí Œ±) : Fin n ‚Üí Œ± :=
  fun i => if h : i < m then v ‚ü®i, h‚ü© else a

instance {Œ± : Type} [Sampleable Œ±] : DecidableEq Œ± := inferInstance

def NBlockMessages := 2 * (œë - 1) + 3

def FullData.rightSubtree {Œ± : Type} {s_left s_right : Skeleton}
    (tree : FullData Œ± (Skeleton.internal s_left s_right)) :
    FullData Œ± s_right :=
  match tree with
  | FullData.internal _ _left right =>
    right

class HasSucc (T : Type u) where
   
  succ' : T ‚Üí T

instance : DecidableEq BTF‚ÇÉ := (inferInstance : DecidableEq (ConcreteBTField 3))

def FullData.getRootValue {s} {Œ± : Type} (tree : FullData Œ± s) :=
  tree.get (getRootIndex s)

Sum in Init.Core

AddCommMonoid in Mathlib.Algebra.Group.Defs

def AlgebraTowerEquiv.toAlgEquivOverRight (e : AlgebraTowerEquiv A B) (i j : Œπ) (h : i ‚â§ j) :
  letI : Algebra (B i) (B j) :=

def JohnsonConditionStrong (B : Finset (Fin n ‚Üí F)) (v : Fin n ‚Üí F) : Prop :=
  let e := e B v
  let d := d B
  let q : ‚Ñö := Fintype.card F
  let frac := q / (q - 1)
  (1 - frac * d/n) < (1- frac * e/n) ^ 2

@[reducible]
def foldCommitOracleReduction (i : Fin ‚Ñì)
    (hCR : isCommitmentRound ‚Ñì œë i) :
  OracleReduction []‚Çí
    (StmtIn := Statement (L := L) Context i.castSucc)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) i.castSucc)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) i.succ)
    (pSpec := pSpecFoldCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) :=
  OracleReduction.append (oSpec:=[]‚Çí)
    (pSpec‚ÇÅ := pSpecFold (L:=L))
    (pSpec‚ÇÇ := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)
    (R‚ÇÅ := foldOracleReduction ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) i)
    (R‚ÇÇ := commitOracleReduction ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hCR)

@[reducible, inline, specialize]
def PlainMessageIdx := {i : pSpec.MessageIdx // (inst.oracleInterfaces i).isNone }

def getPutativeRoot {s} (idx : BinaryTree.SkeletonLeafIndex s) (leafValue : Œ±)
    (proof : List Œ±) : OracleComp (spec Œ±) Œ± :=
  match proof with
  | [] => return leafValue 
  | siblingBelowRootHash :: restProof => do
    match idx with
    | BinaryTree.SkeletonLeafIndex.ofLeaf =>
      
      
      
      return leafValue
    | BinaryTree.SkeletonLeafIndex.ofLeft idxLeft =>
      
      let ancestorBelowRootHash ‚Üê getPutativeRoot idxLeft leafValue restProof
      singleHash ancestorBelowRootHash siblingBelowRootHash
    | BinaryTree.SkeletonLeafIndex.ofRight idxRight =>
      
      let ancestorBelowRootHash ‚Üê getPutativeRoot idxRight leafValue restProof
      singleHash siblingBelowRootHash ancestorBelowRootHash

class UnitTranscript (Œ± : Type*) (U : Type) where
   
  publicUnits : Œ± ‚Üí Array U ‚Üí Except DomainSeparatorMismatch Œ±
   
  fillChallengeUnits : Œ± ‚Üí Nat ‚Üí Except DomainSeparatorMismatch (Œ± √ó Array U)

def BBF_eq_multiplier (r : Fin ‚Ñì ‚Üí L) : MultilinearPoly L ‚Ñì :=
  ‚ü®MvPolynomial.eqPolynomial r, by admit /- proof elided -/
  ‚ü©

def whirRelation
    {F : Type} [Field F] [Fintype F] [DecidableEq F]
    {Œπ : Type} [Fintype Œπ] [Nonempty Œπ]
    (varCount : ‚Ñï) (œÜ : Œπ ‚Ü™ F) [Smooth œÜ] (err : ‚Ñù)
    : Set ((Unit √ó ‚àÄ i, (OracleStatement Œπ F i)) √ó Unit) :=
  { ‚ü®‚ü®_, oracle‚ü©, _‚ü© | Œ¥·µ£(oracle (), smoothCode œÜ varCount) ‚â§ err }

@[simp]
def BTFieldCard (k : ‚Ñï) : Fintype.card (BTField k) = 2^(2^k)
  := (BinaryTowerAux k).2.fieldFintypeCard

Algebra.TensorProduct.includeRight in Mathlib.RingTheory.TensorProduct.Basic

finSuccEquiv in Mathlib.Logic.Equiv.Fin.Basic

Polynomial.div in Mathlib.Algebra.Polynomial.FieldDivision

def capacitySegmentDupPerm : Prop :=
  let ‚ü®baseTrace, _‚ü© := removeRedundantEntryDS trace
  ‚àÉ j : Fin baseTrace.length, ‚àÉ capSeg : Vector U SpongeSize.C,
    (‚àÉ stateIn stateOut, baseTrace[j] = ‚ü®.inr .Fwd, stateIn, stateOut‚ü© ‚àß
      stateOut.capacitySegment = capSeg) ‚àß
      (
        (‚àÉ j' < j, ‚àÉ stmt', baseTrace[j'] = ‚ü®.inl (), stmt', capSeg‚ü©) ‚à®
        (‚àÉ j' < j, ‚àÉ stateIn1 stateOut1, baseTrace[j'] = ‚ü®.inr .Fwd, stateIn1, stateOut1‚ü© ‚àß
          stateOut1.capacitySegment = capSeg) ‚à®
        (‚àÉ j' ‚â§ j, ‚àÉ stateOut2 stateIn2, baseTrace[j'] = ‚ü®.inr .Bwd, stateOut2, stateIn2‚ü© ‚àß
          stateIn2.capacitySegment = capSeg) ‚à®
        (‚àÉ j' ‚â§ j, ‚àÉ stateIn3 stateOut3, baseTrace[j'] = ‚ü®.inr .Fwd, stateIn3, stateOut3‚ü© ‚àß
          stateIn3.capacitySegment = capSeg) ‚à®
        (‚àÉ j' ‚â§ j, ‚àÉ stateOut4 stateIn4, baseTrace[j'] = ‚ü®.inr .Bwd, stateOut4, stateIn4‚ü© ‚àß
          stateOut4.capacitySegment = capSeg)
      )

alias E_p := capacitySegmentDupPerm

def hiding' (scheme : Scheme oSpec Data Randomness Commitment pSpec) : Prop := sorry

def finIdxOfIfTrue [BEq Œ±] [LawfulBEq Œ±] (a : Œ±) (l : List Œ±) (h : a ‚àà l) : Fin l.length :=
  ‚ü®List.idxOf' a l, by admit /- proof elided -/
  ‚ü©

Polynomial.C in Mathlib.Algebra.Polynomial.Basic

def mulVec [Zero Œ±] [Add Œ±] [Mul Œ±] {numRows numCols : Nat}
    (M : Vector (Vector Œ± numCols) numRows)
    (x : Vector Œ± numCols) : Vector Œ± numRows :=
  M.map (fun row => row *·µ• x)

instance [Repr Œ±] (Œ±s : List Type) [HListRepr (HList Œ±s)] : HListRepr (HList (Œ± :: Œ±s)) where
  repr
  | HList.cons x xs =>
    match xs with
    | HList.nil => reprPrec x 0
    | HList.cons _ _ => reprPrec x 0 ++ ", " ++ HListRepr.repr xs

@[reducible, simp]
def knowledgeSoundness (relation : Set (Statement √ó Bool))
    (verifier : Verifier oSpec Statement Bool pSpec)
    (knowledgeError : ‚Ñù‚â•0) : Prop :=
  verifier.knowledgeSoundness init impl relation acceptRejectRel knowledgeError

def somePairs : HList' (fun x => x √ó x) someTypes :=
  HList'.cons (1, 1) (HList'.cons ("good", "bad") (HList'.cons (5, 3) HList'.nil))

PMF.uniformOfFintype in Mathlib.Probability.Distributions.Uniform

Polynomial.reverse in Mathlib.Algebra.Polynomial.Reverse

@[simp]
abbrev Statement.AfterSendEvalClaim : Type := Statement.AfterFirstSumcheck R pp

Nat.decLe in Init.Prelude

def StraightlineExtractor (oSpec : OracleSpec Œπ) (Data Commitment : Type) :=
  Commitment ‚Üí QueryLog oSpec ‚Üí Data

@[reducible]
def forwardPermutationOracle (Œ± : Type*) : OracleSpec Unit := Œ± ‚Üí‚Çí Œ±

def append' (so‚ÇÅ : SimOracle.Stateful spec‚ÇÅ spec‚Çú‚ÇÅ œÉ) (so‚ÇÇ : SimOracle.Stateful spec‚ÇÇ spec‚Çú‚ÇÇ œÑ) :
    SimOracle.Stateful (spec‚ÇÅ ++‚Çí spec‚ÇÇ) (spec‚Çú‚ÇÅ ++‚Çí spec‚Çú‚ÇÇ) (œÉ √ó œÑ) where
  impl
  | query (.inl i) t => fun (s‚ÇÅ, s‚ÇÇ) ‚Ü¶ do
      let (u, s‚ÇÅ') ‚Üê so‚ÇÅ.impl (query i t) s‚ÇÅ; return (u, s‚ÇÅ', s‚ÇÇ)
  | query (.inr i) t => fun (s‚ÇÅ, s‚ÇÇ) ‚Ü¶ do
      let (u, s‚ÇÇ') ‚Üê so‚ÇÇ.impl (query i t) s‚ÇÇ; return (u, s‚ÇÅ, s‚ÇÇ')

instance instDCast‚ÇÇOracleProver : DCast‚ÇÇ Nat ProtocolSpec
    (fun _ pSpec => OracleProver oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec) where
  dcast‚ÇÇ := OracleProver.cast
  dcast‚ÇÇ_id := OracleProver.cast_id

Vector.zipWith in Init.Data.Vector.Basic

def erase_even (s : Finset ‚Ñï) : Finset ‚Ñï := s.filter Odd

@[inline] def min [Zero T] [ToNat T] (a b : Cayley T) : Cayley T :=
  if (a : Nat) ‚â§ (b : Nat) then a else b

instance {pSpec : ProtocolSpec n} : CoeHead (ChallengeIdx pSpec) (Fin n) where
  coe := fun i => i.1

instance : SMul ‚Ñï (UniPoly R) := ‚ü®nsmul‚ü©

instance : Sub (UniPoly R) := ‚ü®UniPoly.sub‚ü©

def nil {Œ±} : Vector Œ± 0 := ‚ü®#[], rfl‚ü© 

def findImports (path : System.FilePath) : IO (Array Lean.Name) := do
  return (‚Üê Lean.parseImports' (‚Üê IO.FS.readFile path) path.toString)
    |>.map (fun imp ‚Ü¶ imp.module) |>.erase `Init

noncomputable def proximity_gap_johnson (k m : ‚Ñï) : ‚Ñï :=
  let rho := (k + 1 : ‚Ñö) / n
  Nat.floor ((1 : ‚Ñù) - Real.sqrt rho - Real.sqrt rho / (2 * m))

def pSpecLastBlock := pSpecFoldRelaySequence (L:=L) (n:=œë)

@[reducible, inline, specialize]
def OracleMessage (i : pSpec.OracleMessageIdx) := pSpec.Message i.1

noncomputable def fieldToùïÉ {H : F[X][Y]} : F ‚Üí+* ùïÉ H :=
  RingHom.comp liftToFunctionField Polynomial.C

MvPolynomial.eval‚ÇÇ in Mathlib.Algebra.MvPolynomial.Eval

instance instOracleInterfaceMessagePSpec : ‚àÄ i, OracleInterface ((pSpec R deg).Message i) :=
  instOracleInterfaceMessageAppend

@[simp]
def transpose {m n : ‚Ñï} (matrix : Matrix Œ± m n) : Matrix Œ± n m :=
  ofFn (fun j => ofFn (fun i => (matrix.get i).get j))

@[inline, reducible]
def lift : OuterStmtIn √ó OuterWitOut ‚Üí InnerWitIn ‚Üí OuterWitIn :=
  lens.toFunB

MvPolynomial.X in Mathlib.Algebra.MvPolynomial.Basic

@[simp]
def testLensE : Extractor.Lens OuterStmtIn_Test OuterStmtOut_Test InnerStmtIn_Test InnerStmtOut_Test
                Unit Unit Unit Unit where
  stmt := testStmtLens
  wit := Witness.InvLens.id

@[simp]
abbrev Witness.AfterLinearCombination : Type := Unit

def solutionToQ (e k : ‚Ñï) (v : Fin (2 * e + k) ‚Üí F) : Polynomial F :=
  ‚ü®
    (Finset.range (e + k)).filter (fun x => liftF v (e + x) ‚â† 0),
    fun i => if i < e + k then liftF v (e + i) else 0,
    by admit /- proof elided -/
  ‚ü©

UInt64.ofFin in Init.Data.UInt.Basic

def oStmtLens (i : Fin n) : OracleStatement.Lens
    (StatementRound R n i.castSucc) (StatementRound R n i.succ) (Simple.StmtIn R) (Simple.StmtOut R)
    (OracleStatement R n deg) (OracleStatement R n deg)
    (Simple.OStmtIn R deg) (Simple.OStmtOut R deg) where

  toFunA := fun ‚ü®‚ü®target, challenges‚ü©, oStmt‚ü© =>
    ‚ü®target, fun _ =>
      match h : n with
      | 0 => ‚ü®Polynomial.C <| MvPolynomial.isEmptyAlgEquiv R (Fin 0) (oStmt ()), by admit /- proof elided -/
        ‚ü©
      | n + 1 =>
      ‚ü®‚àë x ‚àà (univ.map D) ^·∂† (n - i), (oStmt ()).val ‚∏®X ‚¶Éi‚¶Ñ, challenges, x‚∏©'(by admit /- proof elided -/
      ),
        sumcheck_roundPoly_degreeLE R n deg D i (oStmt ()).property‚ü©‚ü©

  toFunB := fun ‚ü®‚ü®_oldTarget, challenges‚ü©, oStmt‚ü© ‚ü®‚ü®newTarget, chal‚ü©, oStmt'‚ü© =>
    ‚ü®‚ü®newTarget, Fin.snoc challenges chal‚ü©, oStmt‚ü©

instance : LawfulToNat Nat where
  toNat_zero := rfl
  toNat_succ := fun _ => rfl

class MvPolynomialLike (œÉ : outParam (Type u)) (R : outParam (Type v)) [CommSemiring R]
    (P : Type w) [CommSemiring P] extends Algebra R P where
   
  X : œÉ ‚Üí P

   
  eval‚ÇÇ {S : Type y} [CommSemiring S] {F : Type z} [FunEquiv F œÉ S] (f : R ‚Üí+* S) (g : F) : P ‚Üí+* S

   
  eval‚ÇÇ_C {S : Type y} [CommSemiring S] {F : Type z} [FunEquiv F œÉ S]
    (f : R ‚Üí+* S) (g : F) (r : R) : (eval‚ÇÇ f g) (_root_.algebraMap R P r) = f r

   
  eval‚ÇÇ_X {S : Type y} [CommSemiring S] {F : Type z} [FunEquiv F œÉ S]
    (f : R ‚Üí+* S) (g : F) (s : œÉ) : (eval‚ÇÇ f g) (X s) = g s

   
  eval‚ÇÇ_eq {S : Type y} [CommSemiring S] {F : Type z} [FunEquiv F œÉ S] (h : P ‚Üí+* S) :
    h = eval‚ÇÇ (h.comp (Algebra.ofId R P)) (fun s => h (X s) : F)

instance {n : ‚Ñï} {Œ± : Type v} : Memory (Fin n) (fun _ => Œ±) (Vector Œ± n) where
  read m i := m[i]
  write m i v := m.set i v

def canonicalEmbedding (k : ‚Ñï) : BTField k ‚Üí+* BTField (k+1) :=
  AdjoinRoot.of (poly k)

noncomputable def liftToFunctionField {H : F[X][Y]} : F[X] ‚Üí+* ùïÉ H :=
  RingHom.comp (Ideal.Quotient.mk (Ideal.span {H_tilde H})) coeffAsRatFunc

@[reducible]
def mk {R : Type*} (coeffs : Array R) : UniPoly R := coeffs

def dropLastWhile (p : Œ± ‚Üí Bool) (l : List Œ±) : List Œ± :=
  (l.reverse.dropWhile p).reverse

def getNextOracle (i : Fin (‚Ñì + 1))
    (oStmt : ‚àÄ j, (OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i) j)
    (j : Fin (toOutCodewordsCount ‚Ñì œë i)) (hj : j.val + 1 < toOutCodewordsCount ‚Ñì œë i) :
    OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®j.val * œë + œë, by
    apply Nat.lt_succ_of_le;
    let h_k_next_le_i := oracle_block_k_next_le (‚Ñì := ‚Ñì) (œë := œë) (i := i) (j := j) (hj := hj)
    calc _ ‚â§ i.val := h_k_next_le_i
      _ ‚â§ ‚Ñì := Fin.is_le i
  ‚ü© :=

def projectToNextSumcheckPoly (i : Fin (‚Ñì)) (H·µ¢ : MultiquadraticPoly L (‚Ñì - i))
    (r·µ¢ : L) : -- the current challenge
    MultiquadraticPoly L (‚Ñì - i.succ) :=

instance : ‚àÄ j, OracleInterface (FinalOracleStatement D x s j) :=
  fun j =>
    if h : j = k + 1
    then {
           Query := Unit
           Response := F[X]
           answer := cast (by admit /- proof elided -/
           )
                          (id (Œ± := Unit ‚Üí F[X]))
         }
    else {
           Query :=
            ‚Üë(
              evalDomain D x
              (‚àë j' ‚àà finRangeTo j.1, s j')
            )
           Response := F
           answer := cast (by admit /- proof elided -/
           )
                          (id (Œ± := ‚Üë(evalDomain D x (‚àë j' ‚àà finRangeTo j.1, s j')) ‚Üí F))
         }

@[reducible]
def CanonicalSpongeState (U : Type) [SpongeUnit U] [SpongeSize] : Type :=
  Vector U SpongeSize.N

@[inline]
def ofInputOnly (projStmt : OuterStmtIn ‚Üí InnerStmtIn) :
    Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn OuterStmtOut :=
  ‚ü®projStmt, fun _ => id‚ü©

@[reducible, simp]
def KnowledgeStateFunction
    (relIn : Set ((StmtIn √ó ‚àÄ i, OStmtIn i) √ó WitIn))
    (relOut : Set ((StmtOut √ó ‚àÄ i, OStmtOut i) √ó WitOut))
    (verifier : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec)
    {WitMid : Fin (n + 1) ‚Üí Type}
    (extractor : Extractor.RoundByRound oSpec
      (StmtIn √ó (‚àÄ i, OStmtIn i)) WitIn WitOut pSpec WitMid) :=
  verifier.toVerifier.KnowledgeStateFunction init impl relIn relOut extractor

@[reducible]
def MlPolyEval (R : Type*) (n : ‚Ñï) := Vector R (2 ^ n) 

def Z (k : ‚Ñï) : ConcreteBTField k :=
  if h_k : k = 0 then one
  else
    „Ää one (k:=k-1), zero (k:=k-1) „Äã

noncomputable def proximity_gap_degree_bound (k m : ‚Ñï) : ‚Ñï :=
  let rho := (k + 1 : ‚Ñö) / n
  Nat.floor ((((m : ‚Ñö) + (1 : ‚Ñö)/2)*(Real.sqrt rho))*n)

instance Vector.instFintype {Œ± : Type*} {n : ‚Ñï} [VCVCompatible Œ±] : Fintype (Vector Œ± n) :=
  Fintype.ofEquiv _ (Equiv.rootVectorEquivFin).symm

noncomputable def finalFoldVerifier :
  OracleVerifier []‚Çí
    (Statement F (Fin.last k)) (OracleStatement D x s (Fin.last k))
    (FinalStatement F k) (FinalOracleStatement D x s)
    (pSpec F)  where
  verify := fun prevChallenges roundChallenge => do
    let p ‚Üê getConst F
    guard (p.natDegree < d)
    pure (Fin.append prevChallenges (fun _ => roundChallenge ‚ü®0, by admit /- proof elided -/
    ‚ü©))
  embed :=
    ‚ü®
      fun j =>
        if h : j.val = (k + 1)
        then Sum.inr ‚ü®1, by admit /- proof elided -/
        ‚ü©
        else Sum.inl ‚ü®j.val, by admit /- proof elided -/
        ‚ü©,
      by admit /- proof elided -/
    ‚ü©
  hEq := by admit /- proof elided -/

def possibleDistsToCode (w : Œπ ‚Üí F) (C : Set (Œπ ‚Üí F)) (Œ¥f : (Œπ ‚Üí F) ‚Üí (Œπ ‚Üí F) ‚Üí Œ±) : Set Œ± :=
  {d : Œ± | ‚àÉ c ‚àà C, c ‚â† w ‚àß Œ¥f w c = d}

def perfectCorrectness (scheme : Scheme oSpec Data Randomness Commitment pSpec) : Prop :=
  correctness scheme 0

def generator : BaseField √ó BaseField := (1, 2)

def three : ChurchNat Œ± := succ two

def toOutCodewordsCount (i : Fin (‚Ñì + 1)) : ‚Ñï :=

noncomputable def disagreementSet (f : Œπ ‚Üí F) (S : Finset F) (Ans : S ‚Üí F) : Finset F :=
  Set.toFinset ({x : Œπ | x.val ‚àà S ‚àß (ansPoly S Ans).eval x.val ‚â† f x}.image Subtype.val)

def relHammingDistToCode [Nonempty Œπ] [DecidableEq F] (w : Œπ ‚Üí F) (C : Set (Œπ ‚Üí F)) : ‚Ñö‚â•0 :=
  if h : (possibleDistsToCode w C relHammingDist).Nonempty
  then distToCode w C relHammingDist finite_possibleRelHammingDistsToCode |>.get (p h)
  else 0
  where p (h : (possibleDistsToCode w C relHammingDist).Nonempty) := by admit /- proof elided -/

def FullData.leftSubtree {Œ± : Type} {s_left s_right : Skeleton}
    (tree : FullData Œ± (Skeleton.internal s_left s_right)) :
    FullData Œ± s_left :=
  match tree with
  | FullData.internal _ left _right =>
    left

PowerBasis in Mathlib.RingTheory.PowerBasis

instance {s} : LawfulFunctor (fun Œ± => InternalData Œ± s) :=

@[reducible, inline]
instance instPolynomialDegreeLT : OracleInterface (R‚¶É< d‚¶Ñ[X]) where
  Query := R
  Response := R
  answer := fun ‚ü®poly, _‚ü© point => poly.eval point

@[inline, reducible]
def idWit {stmtLens : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut} :
    Extractor.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                OuterWitIn OuterWitOut OuterWitIn OuterWitOut where
  stmt := stmtLens
  wit := Witness.InvLens.id

alias trivialWit := Extractor.Lens.idWit

Fin.succAbove in Mathlib.Data.Fin.SuccPred

def binaryTowerModule {l r : ‚Ñï} (h_le : l ‚â§ r) :
    Module (ConcreteBTField l) (ConcreteBTField r) :=
  (ConcreteBTFieldAlgebra (h_le:=h_le)).toModule

class LawfulHasPred (T : Type u) [HasSucc T] [HasPred T] : Prop where
   
  pred'_succ : ‚àÄ x : T, pred' (succ' x) = x

Field in Mathlib.Algebra.Field.Defs

Set.Ico in Mathlib.Order.Interval.Set.Defs

def computableBasisExplicit (k : ‚Ñï) (i : Fin (2 ^ k)) : ConcreteBTField k :=
  (Finset.univ : Finset (Fin k)).prod fun j =>
    if Nat.getBit (n := i.val) (k := j.val) == 1 then
      concreteTowerAlgebraMap (j.val + 1) k (by admit /- proof elided -/
      ) (Z (j.val + 1))
    else
      1

structure TowerEquivResult (k : ‚Ñï) where
  ringEquiv : ConcreteBTField k ‚âÉ+* BTField k
  ringEquivForwardMapEq : ringEquiv = towerRingHomForwardMap k

instance [Zero T] [One T] [ToNat T] : NatPow (Cayley T) where
  pow := powNat

structure PublicParams where
  ‚Ñì_m : ‚Ñï
  ‚Ñì_n : ‚Ñï
  ‚Ñì_w : ‚Ñï
  ‚Ñì_w_le_‚Ñì_n : ‚Ñì_w ‚â§ ‚Ñì_n := by admit /- proof elided -/

abbrev CNat (n : ‚Ñï) : Type := (CayleyTower n).1

def rdrop (m : ‚Ñï) (h : m ‚â§ n) (pSpec : ProtocolSpec n) : ProtocolSpec (n - m) :=
  {dir := Fin.rdrop m h pSpec.dir, ¬´Type¬ª := Fin.rdrop m h pSpec.¬´Type¬ª}

OfNat in Init.Prelude

instance [AddCommMonoid R] : AddCommMonoid (MlPolyEval R n) where
  add := add
  add_assoc a b c := by admit /- proof elided -/

instance [h : VerifierFirst pSpec] : VerifierFirst pSpec where
  verifier_first' := by admit /- proof elided -/

def neqCols [DecidableEq F] (U V : Matrix Œπ Œπ' F) : Finset Œπ' :=
  {j | ‚àÉ i : Œπ, V i j ‚â† U i j}

def intCast {k : ‚Ñï} (n : ‚Ñ§) : ConcreteBTField k := if n % 2 = 0 then zero else one

noncomputable def relayOracleReduction (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
  OracleReduction (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) Context i.succ)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (pSpec := pSpecRelay) where
  prover := relayOracleProver ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hNCR
  verifier := relayOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hNCR

IsEmpty in Mathlib.Logic.IsEmpty

def eval (x : Fin numWires ‚Üí ùì°) (g : Gate ùì° numWires) : ùì° :=
  g.qL * x g.a + g.qR * x g.b + g.qO * x g.c + g.qM * (x g.a * x g.b) + g.qC

instance : ‚àÄ i, VCVCompatible ((default : ProtocolSpec 0).Challenge i) := fun ‚ü®i, _‚ü© => Fin.elim0 i

noncomputable def coeffAsRatFunc : F[X] ‚Üí+* Polynomial (RatFunc F) :=
  RingHom.comp bivPolyHom Polynomial.C

UInt64 in Init.Prelude

def domain (n : ‚Ñï) (i : ‚Ñï) : Fin (2 ^ (n - i)) ‚Üí evalDomain D x i :=
  fun j =>
    ‚ü®
      x ^ 2 ^ i * (DIsCyclicC.gen ^ (2 ^ i)) ^ j.1,
      by admit /- proof elided -/
    ‚ü©

def deterministicMillerRabin (n : ‚Ñï) : Bool := Id.run do
  if n ‚â§ 2 ‚à® n % 2 = 0 then
    return n = 2

  let ‚ü®s, d‚ü© := factorOutTwos (n - 1)
  for a in millerRabinBases do
    if a % n == 0 then
      continue

    let mut x := powMod a d n
    if x = 1 ‚à® x = n - 1 then
      continue

    for _ in [0:s] do
      x := (x * x) % n
      if x == n - 1 ‚à® x ‚â§ 1 then
        break
    if x ‚â† n - 1 then
      return false

  return true

IO.throwServerError in Lean.Server.Utils

inductive HList' {Œ± : Type v} (Œ≤ : Œ± ‚Üí Type u) : List Œ± ‚Üí Type (max u v)
  | nil  : HList' Œ≤ []
  | cons : Œ≤ i ‚Üí HList' Œ≤ is ‚Üí HList' Œ≤ (i :: is)

Fin.castLT in Init.Data.Fin.Basic

class DCast‚ÇÉ (Œ± : Sort*) (Œ≤ : Œ± ‚Üí Sort*) (Œ≥ : (a : Œ±) ‚Üí Œ≤ a ‚Üí Sort*)
    (Œ¥ : (a : Œ±) ‚Üí (b : Œ≤ a) ‚Üí Œ≥ a b ‚Üí Sort*) [DCast Œ± Œ≤] [DCast‚ÇÇ Œ± Œ≤ Œ≥] where
  dcast‚ÇÉ : ‚àÄ {a a' : Œ±} {b : Œ≤ a} {b' : Œ≤ a'} {c : Œ≥ a b} {c' : Œ≥ a' b'},
    (ha : a = a') ‚Üí (hb : dcast ha b = b') ‚Üí (hc : dcast‚ÇÇ ha hb c = c') ‚Üí Œ¥ a b c ‚Üí Œ¥ a' b' c'
  dcast‚ÇÉ_id : ‚àÄ {a : Œ±} {b : Œ≤ a} {c : Œ≥ a b},
    dcast‚ÇÉ (Eq.refl a) dcast_eq dcast‚ÇÇ_eq = (id : Œ¥ a b c ‚Üí Œ¥ a b c)

def BBF_CodeDistance (‚Ñì ùì° : ‚Ñï) (i : Fin (‚Ñì + 1)) : ‚Ñï :=
  2^(‚Ñì + ùì° - i.val) - 2^(‚Ñì - i.val) + 1

noncomputable def queryRbrExtractor :
  Extractor.RoundByRound []‚Çí
    (StmtIn := (FinalSumcheckStatementOut (L:=L) (‚Ñì:=‚Ñì))
      √ó (‚àÄ j, OracleStatement ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì) j))
    (WitIn := Unit)
    Unit
    (pSpec := pSpecQuery ùîΩq Œ≤ Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (fun _ => Unit) where
  eqIn := rfl
  extractMid := fun _ _ _ witMidSucc => witMidSucc
  extractOut := fun _ _ _ => ()

Nat.reduceMod in Lean.Meta.Tactic.Simp.BuiltinSimprocs.Nat

def liftBTFieldProps (k : ‚Ñï) (prevBTFResult : ConcreteBTFStepResult (k := k)) :
  ConcreteBTFieldProps (k + 1) := {
    zero_mul := concrete_zero_mul (prevBTFResult.toConcreteBTFieldProps),
    zero_mul' := fun a => by admit /- proof elided -/

Prod.fst in Init.Prelude

instAlgebra in Mathlib.LinearAlgebra.TensorAlgebra.Basic

noncomputable instance : Algebra Right (Left ‚äó[K] Right) := Algebra.TensorProduct.rightAlgebra


local notation "e" => Algebra.TensorProduct.comm K Right Left

Matrix.add in Mathlib.LinearAlgebra.Matrix.Defs

instance : Field ScalarField := ZMod.instField scalarFieldSize

def idxOf' [BEq Œ±] (a : Œ±) (l : List Œ±) : ‚Ñï := findIdx' (¬∑ == a) l

MvPolynomial.optionEquivLeft in Mathlib.Algebra.MvPolynomial.Equiv

def neg {k : ‚Ñï} (x : ConcreteBTField k) : ConcreteBTField k := x

def finBitVecEquiv {n : ‚Ñï} : Fin (2 ^ n) ‚âÉ BitVec n where
  toFun := fun i => BitVec.ofFin i
  invFun := fun u => u.toFin
  left_inv _ := rfl
  right_inv _ := rfl

instance : ‚àÄ j, OracleInterface ((pSpecRelay).Message j)
  | ‚ü®x, hj‚ü© => by admit /- proof elided -/

@[reducible, simp] def StmtIn := Unit

@[simp]
instance BTFieldIsDomain (k : ‚Ñï) : IsDomain (BTField k) := inferInstance

def queryCodeword (k : ‚Ñï) (s : Fin (k + 1) ‚Üí ‚Ñï+) {i : Fin (k + 1)}
      (w : evalDomain D x (‚àë j' ‚àà (List.take i.1 (List.finRange (k + 1))).toFinset, (s j').1)) :
    OracleComp [FinalOracleStatement D x s]‚Çí F :=
      OracleComp.lift <| by
        simpa using
          OracleSpec.query
            (spec := [FinalOracleStatement D x s]‚Çí)
            ‚ü®i.1, Nat.lt_succ_of_lt i.2‚ü©
            (by admit /- proof elided -/
            )

def EvenPoly (f : Polynomial F) : Prop := ‚àÄ n, Odd n ‚Üí f.coeff n = 0

MvPolynomial.coeff in Mathlib.Algebra.MvPolynomial.Basic

instance {k : Fin (n + 1)} : Fintype (pSpec.MessageIdxUpTo k) :=
  inferInstanceAs (Fintype <| MessageIdx (pSpec.take k k.is_le))

def AlgebraTowerEquiv.toAlgebraOverLeft (e : AlgebraTowerEquiv A B) (i j : Œπ)
    (h : i ‚â§ j) : Algebra (A i) (B j) :=

Units in Mathlib.Algebra.Group.Units.Defs

@[simp]
def BTField (k : ‚Ñï) := (BinaryTowerAux k).1

UInt8.size in Init.Prelude

def new (sessionIdentifier : String) : Except DomainSeparatorMismatch (DomainSeparator U H) :=
  if sessionIdentifier.contains SEP_CHAR then
    .error ‚ü®"Domain separator cannot contain the separator BYTE."‚ü©
  else
    pure { io := sessionIdentifier }

Quotient in Init.Core

instance {_ : Empty} : OracleInterface (Unit) := OracleInterface.instDefault

def join {k : ‚Ñï} (h_pos : k > 0) (hi lo : ConcreteBTField (k - 1)) : ConcreteBTField k :=

def distFromCode' (C : Set (n ‚Üí R)) [Fintype C] (u : n ‚Üí R) : ‚Ñï‚àû :=
  Finset.min <| (@Finset.univ C _).image (fun v => hammingDist u v.1)

noncomputable def fromColGenMat [CommRing F] (G : Matrix Œπ Œ∫ F) : LinearCode Œπ F :=
  LinearMap.range G.mulVecLin

def toMvPolynomial (p : MlPoly R n) : R[X Fin n] :=
  ‚àë i : Fin (2 ^ n), MvPolynomial.monomial (monomialOfNat i) (a:=p[i])

noncomputable def polynomialAlgEquiv : P ‚âÉ‚Çê[R] R[X] where
  toFun := toPolynomialAlgHom
  invFun := ofPolynomialAlgHom
  left_inv := by admit /- proof elided -/

instance {i : Fin k} : ‚àÄ j, OracleInterface ((pSpec D x s i).Message j)
  | ‚ü®0, h‚ü© => nomatch h
  | ‚ü®1, _‚ü© => by admit /- proof elided -/

def SkeletonNodeIndex.depth {s : Skeleton} : SkeletonNodeIndex s ‚Üí Nat
  | SkeletonNodeIndex.ofLeaf => 0
  | SkeletonNodeIndex.ofInternal => 0
  | SkeletonNodeIndex.ofLeft idxLeft => idxLeft.depth + 1
  | SkeletonNodeIndex.ofRight idxRight => idxRight.depth + 1

def encode [DecidableEq F] (msg : Fin deg ‚Üí F) (domain : Fin m ‚Ü™ F) : Fin m ‚Üí F :=
  (polynomialOfCoeffs msg).eval ‚àò ‚áëdomain

Polynomial.mapAlgEquiv in Mathlib.Algebra.Polynomial.AlgebraMap

def prover (i : Fin n) : OracleProver oSpec
    (StatementRound R n i.castSucc) (OracleStatement R n deg) Unit
    (StatementRound R n i.succ) (OracleStatement R n deg) Unit (pSpec R deg) where
  toProverState := proverState R n deg i
  toProverInput := proverInput R n deg i
  sendMessage := (proverRound R n deg D oSpec i).sendMessage
  receiveChallenge := (proverRound R n deg D oSpec i).receiveChallenge
  toProverOutput := proverOutput R n deg oSpec i

instance : Zero (UniPolyC R) := ‚ü®0, zero_canonical‚ü©
</all_available_defs>

<all_available_lemmas>
Ne.dite_eq_left_iff in Mathlib.Logic.Basic
Nat.add_one_sub_one in Init.Data.Nat.Basic
Nat.left_eq_add in Init.Data.Nat.Lemmas
RingHom.comp_id in Mathlib.Algebra.Ring.Hom.Defs
cast_eq in Init.Core
eq_mp_eq_cast in Init.PropLemmas
one_ne_zero in Mathlib.Algebra.NeZero
Polynomial.natDegree_eq_of_degree_eq_some in Mathlib.Algebra.Polynomial.Degree.Definitions
Algebra.smul_def in Mathlib.Algebra.Algebra.Defs
eqRec_eq_cast in Batteries.Logic

lemma degree_definingPoly {F : Type*} [Field F] [Fintype F] (s : F) [NeZero s] :
  (definingPoly s).degree = 2

lemma degree_s_smul_X_add_1 {F : Type*} [Field F] [Fintype F] (s : F) [NeZero s] :
  (C s * (X : (F)[X]) + 1).degree = 1

lemma degree_s_smul_X {F : Type*} [Field F] [Fintype F] (s : F) [NeZero s] :
  (C s * (X : (F)[X])).degree = 1

theorem unique_linear_form_of_elements_in_adjoined_commring
    {R : Type*} [CommRing R] (f : R[X]) (hf_deg : f.natDegree = 2)
    (hf_monic : Monic f) (c1 : AdjoinRoot f) :
    ‚àÉ! p : R √ó R, c1 = (AdjoinRoot.of f) p.1 * root f + (AdjoinRoot.of f) p.2

theorem unique_linear_sum_repr (R : Type*) [CommRing R] (S : Type*) [CommRing S] [Algebra R S]
    (pb : PowerBasis R S) (h_dim : pb.dim = 2) (s : S) :
    ‚àÉ! p : R √ó R, s = p.fst ‚Ä¢ pb.gen + algebraMap R S p.snd

theorem unique_repr {R : Type*} [CommRing R] {S : Type*} [CommRing S] [Algebra R S]
    (pb : PowerBasis R S) (repr1 repr2 : Fin pb.dim ‚Üí‚ÇÄ R)
    (h : ‚àë i : Fin pb.dim, repr1 i ‚Ä¢ pb.basis i = ‚àë i : Fin pb.dim, repr2 i ‚Ä¢ pb.basis i) :
    repr1 = repr2

theorem toPoly_add {p q : UniPoly Q} : (add_raw p q).toPoly = p.toPoly + q.toPoly

theorem mul_two_eq_add {a : CNat 50} : a * 2 = a + a

@[simp]
theorem take_append_left (T : FullTranscript pSpec‚ÇÅ) (T' : FullTranscript pSpec‚ÇÇ) :
    (T ++‚Çú T').take m (Nat.le_add_right m n) =
      T.cast rfl (by simp [ProtocolSpec.append])

theorem BitVec.extractLsb_eq_and_pow_2_minus_1_ofNat {n num_bits : Nat}
  (h_num_bits : num_bits > 0) (x : BitVec n) :
  BitVec.extractLsb (hi:= num_bits - 1) (lo := 0) x =
    BitVec.ofNat (num_bits - 1 - 0 + 1) (x.toNat &&& (2 ^ num_bits - 1))

theorem cast_idx {i : MessageIdx pSpec‚ÇÅ} :
    pSpec‚ÇÇ.Message (i.cast hn hSpec) = pSpec‚ÇÅ.Message i

lemma getBit_of_lowBits {n: ‚Ñï} (numLowBits : ‚Ñï) : ‚àÄ k, getBit k (getLowBits numLowBits n) =
    if k < numLowBits then getBit k n else 0

lemma rank_nonsquare_eq_deg_of_Œπ_le (inj : Function.Injective Œ±) (h : m ‚â§ n) :
  (Vandermonde.nonsquare (Œπ' := n) Œ±).rank = m

lemma NTTStage_correctness (i : Fin (‚Ñì))
    (input_buffer : Fin (2 ^ (‚Ñì + R_rate)) ‚Üí L) (original_coeffs : Fin (2 ^ ‚Ñì) ‚Üí L) :
    additiveNTTInvariant ùîΩq Œ≤ h_‚Ñì_add_R_rate (evaluation_buffer:=input_buffer)
      (original_coeffs:=original_coeffs) (i := ‚ü®i.val+1, by omega‚ü©) ‚Üí
    additiveNTTInvariant ùîΩq Œ≤ h_‚Ñì_add_R_rate (evaluation_buffer:=NTTStage ùîΩq Œ≤ h_‚Ñì_add_R_rate
      ‚ü®i, by omega‚ü© input_buffer) (original_coeffs:=original_coeffs) ‚ü®i, by omega‚ü©

@[simp] lemma twoAdicGenerators_succ_square_eq (idx : Nat) (h : idx < twoAdicity) :
    haveI : idx + 1 < twoAdicGenerators.length

@[csimp]
theorem vappend_eq_append : @vappend = @append

theorem seqCompose_knowledgeSoundness
    (rel : (i : Fin (m + 1)) ‚Üí Set (Stmt i √ó Wit i))
    (V : (i : Fin m) ‚Üí Verifier oSpec (Stmt i.castSucc) (Stmt i.succ) (pSpec i))
    (knowledgeError : Fin m ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (V i).knowledgeSoundness init impl (rel i.castSucc) (rel i.succ) (knowledgeError i)) :
      (Verifier.seqCompose Stmt V).knowledgeSoundness init impl (rel 0) (rel (Fin.last m))
        (‚àë i, knowledgeError i)

lemma liftF_ne_zero_of_lt {i : ‚Ñï} (h : i < n) : liftF f' i ‚â† 0 ‚Üî f' ‚ü®i, h‚ü© ‚â† 0

@[simp]
theorem fflatten_one {A : Sort u} {F : A ‚Üí Sort v} {n : Fin 1 ‚Üí ‚Ñï}
    {Œ± : (i : Fin 1) ‚Üí (j : Fin (n i)) ‚Üí A}
    {v : (i : Fin 1) ‚Üí (j : Fin (n i)) ‚Üí F (Œ± i j)} :
    fflatten v = v 0

lemma W_splits (i : Fin r) : (W ùîΩq Œ≤ i).Splits (RingHom.id L)

@[simp]
theorem perfectCompleteness_eq_prob_one :
    reduction.perfectCompleteness init impl relIn relOut ‚Üî
      ‚àÄ stmtIn witIn, (stmtIn, witIn) ‚àà relIn ‚Üí
        [fun ‚ü®‚ü®_, (prvStmtOut, witOut)‚ü©, stmtOut‚ü© =>
          (stmtOut, witOut) ‚àà relOut ‚àß prvStmtOut = stmtOut
        | do (simulateQ (impl ++‚Çõ‚Çí challengeQueryImpl : QueryImpl _ (StateT œÉ ProbComp))
            <| reduction.run stmtIn witIn).run' (‚Üê init)] = 1

@[simp]
theorem toNat_succ (n : ChurchNat ‚Ñï) : toNat (succ n) = n.toNat.succ

omit [DecidableEq Œ±] [Inhabited Œ±] [Fintype Œ±] in
@[simp]
lemma Cache.leaves_cons (n : ‚Ñï) (leaves : List.Vector Œ± (2 ^ (n + 1))) (cache : Cache Œ± n) :
    Cache.leaves Œ± n (Cache.cons Œ± n leaves cache) = leaves

@[simp]
theorem LeafData.get_ofLeft {s_left s_right : Skeleton} {Œ± : Type}
    (tree : LeafData Œ± (Skeleton.internal s_left s_right))
    (idxLeft : SkeletonLeafIndex s_left) :
    tree.get (SkeletonLeafIndex.ofLeft idxLeft) =
      tree.leftSubtree.get idxLeft

theorem two_le_two_pow_n_plus_1 (n : ‚Ñï) : 2 ‚â§ 2 ^ (n + 1)

@[simp]
theorem fconcat_last {Œ± : Fin n ‚Üí A} {Œ≤ : A} (v : (i : Fin n) ‚Üí F (Œ± i)) (b : F Œ≤) :
    fconcat v b (last n) = cast (by simp [vconcat_last]) b

omit h_Fq_char_prime in
theorem changeOfBasisMatrix_diag_ne_zero
  (‚Ñì : Nat) (h_‚Ñì : ‚Ñì ‚â§ r) :
  (‚àÄ i, (changeOfBasisMatrix ùîΩq Œ≤ ‚Ñì h_‚Ñì) i i ‚â† 0)

theorem prime_17 : Nat.Prime 17

omit hF‚ÇÇ in
theorem kernel_normalizedW_eq_U (i : Fin r) :
    LinearMap.ker (polyEvalLinearMap (normalizedW ùîΩq Œ≤ i)
    (normalizedW_is_additive ùîΩq Œ≤ i))
    = U ùîΩq Œ≤ i

@[simp]
lemma OracleReduction.id_toReduction :
    (OracleReduction.id : OracleReduction oSpec Statement OStatement Witness _ _ _ _).toReduction =
      Reduction.id

theorem vcons_eq_cons (a : Œ±) (v : Fin n ‚Üí Œ±) : a ::·µõ v = cons a v

lemma and_eq_zero_iff_and_each_getBit_eq_zero {n m : ‚Ñï} :
    n &&& m = 0 ‚Üî ‚àÄ k, Nat.getBit k n &&& Nat.getBit k m = 0

private lemma eval_solutionToQ_aux {i : Fin ((solutionToQ e k v).natDegree + 1)} [NeZero e]
  : e + i < 2 * e + k

lemma sum_of_and_eq_zero_is_or {n m : ‚Ñï} (h_n_AND_m : n &&& m = 0) : n + m = n ||

private lemma errors_are_roots_of_E {i : Fin n}
  (h : f i ‚â† p.eval (œâs i)) : (E œâs f p e).eval (œâs i) = 0

lemma concrete_pow_base_one
  (prevBTFieldProps : ConcreteBTFieldProps (k := k - 1)) (n : ‚Ñï) :
  concrete_pow_nat (k:=k) (x:=1) n = 1

@[simp]
theorem splitSum_succ {n : Fin (m + 1) ‚Üí ‚Ñï} {k : Fin (vsum n)} :
    splitSum k = Fin.dappend
      (fun k => ‚ü®0, k‚ü©)
      (fun k => ‚ü®(splitSum k).1.succ, (splitSum k).2‚ü©)
      k

lemma qMap_total_fiber_one_level_eq (i : Fin ‚Ñì) (h_i_add_1 : i.val + 1 ‚â§ ‚Ñì)
    (y : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i + 1, by omega‚ü©)) (k : Fin 2) :
    let basis_x := sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i, by omega‚ü© (by simp only; omega)
    let x : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i, by omega‚ü© := qMap_total_fiber ùîΩq Œ≤ (i := ‚ü®i, by omega‚ü©)
      (steps := 1) (h_i_add_steps := by apply Nat.lt_add_of_pos_right_of_le; omega) (y := y) k
    let y_lifted : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i, by omega‚ü© := sDomain.lift ùîΩq Œ≤ h_‚Ñì_add_R_rate
      (i := ‚ü®i, by omega‚ü©) (j := ‚ü®i.val + 1, by omega‚ü©)
      (h_j := by apply Nat.lt_add_of_pos_right_of_le; omega)
      (h_le := by apply Fin.mk_le_mk.mpr (by omega)) y
    let free_coeff_term : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i, by omega‚ü© :=
      (Fin2ToF2 ùîΩq k) ‚Ä¢ (basis_x ‚ü®0, by simp only; omega‚ü©)
    x = free_coeff_term + y_lifted

theorem ZMod.blub :
    ‚àÄ {n q c : ‚Ñï} (a : ZMod n), (decide (n ‚â• 2) = true) ‚Üí (decide (c < n) = true) ‚Üí
      (decide (c ‚â† 1) = true) ‚Üí IsNat (a ^ ((n - 1) / q)) c ‚Üí a ^ ((n - 1) / q) ‚â† 1

@[simp]
theorem drop_update_of_ge (m : ‚Ñï) (h : m ‚â§ n) (v : (i : Fin n) ‚Üí Œ± i) (i : Fin n) (hi : i ‚â• m)
    (x : Œ± i) : drop m h (update v i x) =
      update (drop m h v) ‚ü®i - m, by omega‚ü©
        (dcast (by simp; ext; simp; rw [Nat.sub_add_cancel hi]) x)

@[simp]
theorem getRoot_trivial (a : Œ±) : getRoot Œ± <$> (buildMerkleTree Œ± 0 ‚ü®[a], rfl‚ü©) = pure a

lemma concrete_one_mul
  (prevBTFieldProps : ConcreteBTFieldProps (k := k - 1))
  (a : ConcreteBTField k) : concrete_mul (one (k:=k)) a = a

@[simp]
theorem cast_id : ChallengeIdx.cast (Eq.refl n‚ÇÅ) rfl = (id : pSpec‚ÇÅ.ChallengeIdx ‚Üí _)

omit [BEq R] in
lemma neg_coeff : ‚àÄ (p : UniPoly R) (i : ‚Ñï), p.neg.coeff i = - p.coeff i

omit [NoZeroDivisors ùîΩ] in
lemma splitNth_degree_le {n : ‚Ñï} {f : ùîΩ[X]} [inst : NeZero n] :
  ‚àÄ {i}, (splitNth f n i).natDegree ‚â§ f.natDegree / n

theorem rsum_eq_t1_square_aux
  {curBTField : Type*} [Field curBTField] -- curBTField ‚âÉ ùîΩ_{2^{2^k}}
  (u : curBTField) -- here u is already lifted to curBTField
  (k : ‚Ñï)
  (x_pow_card : ‚àÄ (x : curBTField), x ^ (2 ^ (2 ^ (k))) = x)
  (u_ne_zero : u ‚â† 0)
  (trace_map_prop : TraceMapProperty curBTField u k):
   ‚àë j ‚àà Finset.Icc 1 (2 ^ (k)), u ^ (2 ^ 2 ^ (k) - 2 ^ j) = u

lemma add_assoc {k : ‚Ñï} : ‚àÄ (a b c : ConcreteBTField k), a + b + c = a + (b + c)

@[simp]
lemma oddPart_coeff {f : Polynomial F} {n : ‚Ñï} :
    (oddPart f).coeff n = if Even n then f.coeff (n + 1) else 0

lemma cast_join {k n : ‚Ñï} (h_pos : k > 0) (hi lo : ConcreteBTField (k - 1)) (heq : k = n) :
  join (k:=k) h_pos hi lo = cast (by rw [heq])
    (join (k:=n) (by omega) (cast (by subst heq; rfl) hi) (lo:=cast (by subst heq; rfl) lo))

@[to_additive (attr := simp) vsum_succ]
lemma vprod_succ [CommMonoid Œ±] {a : Fin (n + 1) ‚Üí Œ±} : vprod a = a 0 * vprod (a ‚àò Fin.succ)

omit [NeZero r] [Field L] [Fintype L] [DecidableEq L] [Field ùîΩq] [Algebra ùîΩq L] in
lemma sBasis_range_eq (i : Fin r) (h_i : i < ‚Ñì + R_rate) :
    Œ≤ '' Set.Ico i ‚ü®‚Ñì + R_rate, h_‚Ñì_add_R_rate‚ü©
    = Set.range (sBasis Œ≤ h_‚Ñì_add_R_rate i h_i)

lemma concrete_mul_assoc
  {h_k : k > 0} (prevBTFieldProps : ConcreteBTFieldProps (k := k - 1))
  (a b c : ConcreteBTField k) :
  concrete_mul (concrete_mul a b) c = concrete_mul a (concrete_mul b c)

Finset.sup_lt_iff in Mathlib.Data.Finset.Lattice.Fold

theorem size_eq_degree (p : UniPoly R) : p.trim.size = p.degree

theorem vappend_singleton (u : Fin m ‚Üí Œ±) (a : Œ±) :
    vappend u (vcons a !v[]) = vconcat u a

theorem fcons_inj {Œ≤ : Fin n ‚Üí A} (a‚ÇÅ a‚ÇÇ : F Œ±) (b‚ÇÅ b‚ÇÇ : (i : Fin n) ‚Üí F (Œ≤ i)) :
    fcons a‚ÇÅ b‚ÇÅ = fcons a‚ÇÇ b‚ÇÇ ‚Üî a‚ÇÅ = a‚ÇÇ ‚àß b‚ÇÅ = b‚ÇÇ

@[csimp, grind =]
theorem idxOf'_eq_idxOf : @idxOf' = @idxOf

theorem singleton_subset_Icc (n : ‚Ñï) : {1} ‚äÜ Finset.Icc 1 (n + 1)

lemma getBit_zero_eq_zero {k : Nat} : getBit k 0 = 0

private lemma johnson_unrefined_by_M [Zero F]
  (h_n : 0 < n)
  (h_B : 2 ‚â§ B.card)
  (h_card : 2 ‚â§ (Fintype.card F))
  :
  B.card * ((1 - e B 0 / n) ^ 2  + (e B 0) ^ 2 / ((Fintype.card F - 1) * n^2) - 1 + d B/n)
  ‚â§
  d B/n

theorem vappend_vconcat (u : Fin m ‚Üí Œ±) (v : Fin n ‚Üí Œ±) (a : Œ±) :
    vappend u (vconcat v a) = vconcat (vappend u v) a

lemma roots_comp_X_sub_C (p : L[X]) (a : L) :
    (p.comp (X - C a)).roots = p.roots.map (fun r => r + a)

theorem ConcreteBTFieldAlgebra_apply_assoc (l mid r : ‚Ñï)
    (h_l_le_mid : l ‚â§ mid) (h_mid_le_r : mid ‚â§ r) :
    ‚àÄ x : ConcreteBTField l,
    (@ConcreteBTFieldAlgebra (l:=l) (r:=r) (h_le:=by
      exact Nat.le_trans h_l_le_mid h_mid_le_r)).algebraMap x =
    (@ConcreteBTFieldAlgebra (l:=mid) (r:=r) (h_le:=h_mid_le_r)).algebraMap
      ((@ConcreteBTFieldAlgebra (l:=l) (r:=mid) (h_le:=h_l_le_mid)).algebraMap x)

@[simp]
theorem fappend_left {Œ± : Fin m ‚Üí A} {Œ≤ : Fin n ‚Üí A}
    (u : (i : Fin m) ‚Üí F (Œ± i)) (v : (i : Fin n) ‚Üí F (Œ≤ i)) (i : Fin m) :
    fappend u v (castAdd n i) = cast (by simp [vappend_left]) (u i)

@[simp]
lemma foldl'_succ {n : ‚Ñï} {Œ± : Type u} (f : (i : Fin (n + 1)) ‚Üí Œ± ‚Üí Œ±) (x : Œ±) :
    foldl' (n + 1) f x = f (last n) (foldl' n (fun i => f i.castSucc) x)

theorem append_right' {u : Fin m ‚Üí Œ±} {v : Fin n ‚Üí Œ±} {i : Fin n}
    (j : Fin (m + n)) (h : j = natAdd m i) : append u v j = v i

theorem oracleVerifier_rbrKnowledgeSoundness [Fintype R] :
    (oracleVerifier R n deg D oSpec i).rbrKnowledgeSoundness init impl
    (relationRound R n deg D i.castSucc) (relationRound R n deg D i.succ)
    (fun _ => (deg : ‚Ñù‚â•0) / Fintype.card R)

@[simp]
theorem BTField.RingHom_eq_of_dest_AdjoinRoot_eq (k m : ‚Ñï) :
  (BTField k ‚Üí+* BTField (m+1)) = (BTField k ‚Üí+* (AdjoinRoot (poly m)))

@[simp]
lemma getTypes_eq_get_fst (l : HList) (i : Fin l.length) : l.getTypes[i] = l[i].1

lemma rank_nonsquare_eq_deg_of_deg_le (inj : Function.Injective Œ±) (h : n ‚â§ m) :
  (Vandermonde.nonsquare (Œπ' := n) Œ±).rank = n

@[simp]
theorem dflatten_splitSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {motive : (k : Fin (vsum n)) ‚Üí Sort*}
    (v : (k : Fin (vsum n)) ‚Üí motive k) (k : Fin (vsum n)) :
    dflatten (motive := motive) (fun i j => v (embedSum i j)) k = v k

lemma oddPart_even {f : Polynomial F} :
    EvenPoly (oddPart f)

theorem add_succ (m n : ChurchNat Œ±) : add (succ m) n = succ (add m n)

lemma algebraMap_ConcreteBTFieldAlgebra_def (l r : ‚Ñï) (h_le : l ‚â§ r) :
    (@ConcreteBTFieldAlgebra (l:=l) (r:=r) (h_le:=h_le)).algebraMap
    = concreteTowerAlgebraMap l r h_le

theorem sum_zero_iff_eq_of_self_sum_zero {F : Type*} [AddGroup F]
  (h_self_sum_eq_zero : ‚àÄ (x : F), x + x = 0) : ‚àÄ (x y : F), x + y = 0 ‚Üî x = y

lemma toOutCodewordsCount_mul_œë_eq_i_succ (i : Fin ‚Ñì) (hCR : isCommitmentRound ‚Ñì œë i) :
  (toOutCodewordsCount ‚Ñì œë i.castSucc) * œë = i.val + 1

@[simp]
theorem rtake_self (v : (i : Fin n) ‚Üí Œ± i) :
    rtake n (by omega) v = fun i : Fin n => dcast (by simp [Fin.cast]) (v i)

@[simp]
theorem LeafData.get_internal_ofRight {Œ±} {s_left s_right : Skeleton}
    (left : LeafData Œ± s_left) (right : LeafData Œ± s_right)
    (idxRight : SkeletonLeafIndex s_right) :
    (LeafData.internal left right).get (SkeletonLeafIndex.ofRight idxRight) =
      right.get idxRight

@[simp]
theorem hconcat_zero {Œ± : Fin 0 ‚Üí Sort u} {Œ≤ : Sort u} (a : Œ≤) :
    hconcat !h‚ü®Œ±‚ü©[] a = fun i => match i with

lemma rank_eq_if_det_ne_zero {U : Matrix (Fin n) (Fin n) F} [IsDomain F] :
  Matrix.det U ‚â† 0 ‚Üí U.rank = n

@[simp]
lemma polynomialOfCoeffs_mem_degreeLT [NeZero deg] :
  polynomialOfCoeffs coeffs ‚àà degreeLT F deg

theorem linear_form_of_elements_in_adjoined_commring
    {R : Type*} [CommRing R] (f : R[X]) (hf_deg : f.natDegree = 2)
    (hf_monic : Monic f) (c1 : AdjoinRoot f) :
    ‚àÉ a b : R, c1 = (AdjoinRoot.of f) a * root f + (AdjoinRoot.of f) b

lemma concrete_inv_zero {k : ‚Ñï} : concrete_inv (k:=k) 0 = 0

theorem computableTwiddleFactor_eq_twiddleFactor (i : Fin ‚Ñì) :
  computableTwiddleFactor (r := r) (‚Ñì := ‚Ñì) (Œ≤ := Œ≤) (L := L)
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := ‚ü®i, by omega‚ü©) =
  twiddleFactor (ùîΩq := ùîΩq) (L := L) (Œ≤ := Œ≤) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
    (i := ‚ü®i, by omega‚ü©)

lemma concrete_zero_mul
  (prevBTFieldProps : ConcreteBTFieldProps (k := k - 1))
  (a : ConcreteBTField k) : concrete_mul (zero (k:=k)) a = zero (k:=k)

theorem snoc_ne_zero_of_right (h : y ‚â† 0) : snoc s y ‚â† 0

lemma take_eq_take : transcript‚ü¶:m‚üß = transcript.take m h

theorem append_comp {a : Fin m ‚Üí Œ±} {b : Fin n ‚Üí Œ±} (f : Œ± ‚Üí Œ≤) :
    append (f ‚àò a) (f ‚àò b) = f ‚àò append a b

lemma rounds_sub_steps_lt : ‚Ñì - œë < ‚Ñì :=
  Nat.sub_lt (pos_of_neZero ‚Ñì) (folding_steps_pos)

lemma œë_sub_one_le_self : œë - 1 < œë

theorem eq_symm {Œ± : Type u} (mx my : m Œ±) : eq mx my ‚Üí eq my mx

theorem completeness_relOut_mono {Œµ : ‚Ñù‚â•0} {relOut' : Set (StmtOut √ó WitOut)}
    (hrelOut : relOut ‚äÜ relOut') :
      completeness init impl relIn relOut reduction Œµ ‚Üí
        completeness init impl relIn relOut' reduction Œµ

theorem ofFn_rtake_eq_rtake_ofFn {Œ± : Type*} {m : ‚Ñï} (h : m ‚â§ n) (v : Fin n ‚Üí Œ±) :
    List.ofFn (rtake m h v) = (List.ofFn v).rtake m

lemma mem_image_support_coeff_finSuccEquivNth {f : MvPolynomial (Fin (n + 1)) R} {i : ‚Ñï} {x} :
    x ‚àà Finsupp.insertNth p i '' ((finSuccEquivNth R p f).coeff i).support ‚Üî
      x ‚àà f.support ‚àß x p = i

omit O‚Çò in
theorem seqCompose_completeness (hInit : init.neverFails)
    (rel : (i : Fin (m + 1)) ‚Üí Set (Stmt i √ó Wit i))
    (R : ‚àÄ i, Reduction oSpec (Stmt i.castSucc) (Wit i.castSucc) (Stmt i.succ) (Wit i.succ)
      (pSpec i))
    (completenessError : Fin m ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (R i).completeness init impl (rel i.castSucc) (rel i.succ) (completenessError i)) :
      (Reduction.seqCompose Stmt Wit R).completeness init impl (rel 0) (rel (Fin.last m))
        (‚àë i, completenessError i)

lemma sDomainBasisVectors_mem_sDomain (i : Fin r) (k : Fin (‚Ñì + R_rate - i)) :
  sDomainBasisVectors ùîΩq Œ≤ h_‚Ñì_add_R_rate i k
    ‚àà sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i

@[simp]
theorem generateProof_ofLeft {sleft sright : Skeleton}
    (cache_tree : FullData Œ± (Skeleton.internal sleft sright))
    (idxLeft : SkeletonLeafIndex sleft) :
    generateProof cache_tree (BinaryTree.SkeletonLeafIndex.ofLeft idxLeft) =
      (cache_tree.rightSubtree).getRootValue ::
        (generateProof cache_tree.leftSubtree idxLeft)

theorem append_run (stmt : Stmt‚ÇÅ) (wit : Wit‚ÇÅ) :
      (P‚ÇÅ.append P‚ÇÇ).run stmt wit = (do
        let ‚ü®transcript‚ÇÅ, stmt‚ÇÇ, wit‚ÇÇ‚ü© ‚Üê liftM (P‚ÇÅ.run stmt wit)
        let ‚ü®transcript‚ÇÇ, stmt‚ÇÉ, wit‚ÇÉ‚ü© ‚Üê liftM (P‚ÇÇ.run stmt‚ÇÇ wit‚ÇÇ)
        return ‚ü®transcript‚ÇÅ ++‚Çú transcript‚ÇÇ, stmt‚ÇÉ, wit‚ÇÉ‚ü©)

@[simp]
lemma bIdx_mul_œë_add_i_cast_lt_‚Ñì_succ (bIdx : Fin (‚Ñì / œë - 1)) (i : Fin (œë - 1 + 1))
    : ‚ÜëbIdx * œë + i < ‚Ñì + 1

theorem fcons_injective2 {Œ≤ : Fin n ‚Üí A} :
    Function.Injective2 (@fcons A F n Œ± Œ≤)

@[simp]
theorem simulateQ'_query (q : OracleQuery spec Œ±) :
    simulateQ' so q (by simp) = so.impl q

omit [SelectableType R] in
@[simp]
lemma reduction_verifier_eq_verifier {i : Fin n} :
    (reduction R n deg D oSpec i).verifier = verifier R n deg D oSpec i

omit [CommSemiring ùîΩ] in
private lemma poly_eq_of [Field ùîΩ] {p q : ùîΩ[X]} {n : ‚Ñï}
      (hp : p.degree < .some n) (hq : q.degree < .some n) (s : Finset ùîΩ) :
    s.card ‚â• n ‚Üí (‚àÄ x ‚àà s, p.eval x = q.eval x) ‚Üí p = q

theorem image_support_finSuccEquivNth {f : MvPolynomial (Fin (n + 1)) R} {i : ‚Ñï} :
    Finset.image (Finsupp.insertNth p i) (Polynomial.coeff ((finSuccEquivNth R p) f) i).support =
      f.support.filter fun m => m p = i

lemma W_is_additive
  (i : Fin r) :
  IsLinearMap (R := ùîΩq) (M := L) (M‚ÇÇ := L) (f := fun x ‚Ü¶ (W ùîΩq Œ≤ i).eval x)

lemma twoAdicGenerators_pow_twoPow_eq_one (bits : Fin (twoAdicity + 1)) :
    (twoAdicGenerators[bits]) ^ (2 ^ (bits : Nat)) = (1 : Field)

lemma getLowBits_eq_mod_two_pow {numLowBits : ‚Ñï} (n : ‚Ñï) :
  getLowBits numLowBits n = n % (2 ^ numLowBits)

@[simp]
theorem cast_idx_symm {i : MessageIdx pSpec‚ÇÇ} :
    pSpec‚ÇÅ.Message (i.cast hn.symm (cast_symm hSpec)) = pSpec‚ÇÇ.Message i

theorem seqCompose_rbrKnowledgeSoundness
    (rel : ‚àÄ i, Set (Stmt i √ó Wit i))
    (V : ‚àÄ i, Verifier oSpec (Stmt i.castSucc) (Stmt i.succ) (pSpec i))
    (rbrKnowledgeError : ‚àÄ i, (pSpec i).ChallengeIdx ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (V i).rbrKnowledgeSoundness init impl
      (rel i.castSucc) (rel i.succ) (rbrKnowledgeError i)) :
      (Verifier.seqCompose Stmt V).rbrKnowledgeSoundness init impl (rel 0) (rel (Fin.last m))
        (fun combinedIdx =>
          letI ij := seqComposeChallengeIdxToSigma combinedIdx
          rbrKnowledgeError ij.1 ij.2)

@[simp]
theorem LeafData.leftSubtree_internal {Œ±} {s_left s_right : Skeleton}
    (left : LeafData Œ± s_left) (right : LeafData Œ± s_right) :
    (LeafData.internal left right).leftSubtree = left

@[simp]
theorem leftpad_apply_ge (n : ‚Ñï) (a : Œ±) (v : Fin m ‚Üí Œ±) (i : Fin n)
    (h : n - m ‚â§ i.val) : leftpad n a v i = v ‚ü®i.val - (n - m), by omega‚ü©

theorem nsmul_zero [LawfulBEq R] (p : UniPoly R) : nsmul 0 p = 0

theorem succ_eq_one_add (n : ChurchNat Œ±) : succ n = add one n

private lemma johnson_condition_strong_implies_2_le_B_card
  (h_johnson : JohnsonConditionStrong B v)
  :
  2 ‚â§ B.card

@[to_additive vsum_eq_univ_sum]
lemma vprod_eq_univ_prod [CommMonoid Œ±] {a : Fin n ‚Üí Œ±} : vprod a = ‚àè i, a i

theorem append_perfectCompleteness
    (R‚ÇÅ : OracleReduction oSpec Stmt‚ÇÅ OStmt‚ÇÅ Wit‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ Wit‚ÇÇ pSpec‚ÇÅ)
    (R‚ÇÇ : OracleReduction oSpec Stmt‚ÇÇ OStmt‚ÇÇ Wit‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ Wit‚ÇÉ pSpec‚ÇÇ)
    (h‚ÇÅ : R‚ÇÅ.perfectCompleteness init impl rel‚ÇÅ rel‚ÇÇ)
    (h‚ÇÇ : R‚ÇÇ.perfectCompleteness init impl rel‚ÇÇ rel‚ÇÉ) :
      (R‚ÇÅ.append R‚ÇÇ).perfectCompleteness init impl rel‚ÇÅ rel‚ÇÉ

lemma toImpl_toPoly_of_canonical [LawfulBEq R] (p : UniPolyC R) : p.toPoly.toImpl = p

@[simp]
lemma aeval_X {A : Type w} [CommSemiring A] [Algebra R A] (s : A) : aeval s X (P := P) = s

lemma or_by_split_lowBits {n m n1 m1 bn bm : ‚Ñï} (h_bn : bn < 2) (h_bm : bm < 2)
  (h_n : n = n1 * 2 + bn) (h_m : m = m1 * 2 + bm):
  n ||

lemma algebraMap_adjacent_tower_def (l : ‚Ñï) :
    (algebraMap (ConcreteBTField l) (ConcreteBTField (l + 1))) =
    canonicalAlgMap l

@[simp]
theorem fflatten‚ÇÇ_splitSum {A : Sort u} {B : Sort v} {F : A ‚Üí B ‚Üí Sort w} {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï}
    {Œ± : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí A}
    {Œ≤ : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí B}
    (v : (k : Fin (vsum n)) ‚Üí F (vflatten Œ± k) (vflatten Œ≤ k)) (k : Fin (vsum n)) :
    fflatten‚ÇÇ (fun i j => v (embedSum i j)) k = cast (by simp) (v k)

theorem induction_append_right {m n : ‚Ñï} {motive : Fin (m + n + 1) ‚Üí Sort*} {zero : motive 0}
  {succ : ‚àÄ i : Fin (m + n), motive i.castSucc ‚Üí motive i.succ} {i : Fin (n + 1)} :
    induction zero succ (i.natAdd m) =
      @induction n (fun i => motive (i.natAdd m))
        (@induction m (fun j => motive (Fin.cast (by omega) (j.castAdd n)))
          zero (fun j x => succ (j.castAdd n) x) (last m))
        (fun i x => succ (i.natAdd m) x) i

theorem congrArg‚ÇÉ {Œ± Œ≤ Œ≥ Œ¥ : Sort*} {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥ ‚Üí Œ¥} {a a' : Œ±} {b b' : Œ≤} {c c' : Œ≥}
    (h : a = a') (h' : b = b') (h'' : c = c') : f a b c = f a' b' c'

lemma lifted_trace_map_eval_at_roots_prev_BTField
  {curBTField : Type*} [Field curBTField]
  (u : curBTField) (t1 : curBTField) -- here t1 is already lifted to curBTField
  (k : ‚Ñï)
  (sumZeroIffEq : ‚àÄ (x y : curBTField), x + y = 0 ‚Üî x = y)
  (u_plus_inv_eq_t1 : u + u‚Åª¬π = t1)
  (galois_automorphism : u^(2^(2^k)) = u‚Åª¬π ‚àß (u‚Åª¬π)^(2^(2^k)) = u)
  (trace_map_at_prev_root : ‚àë i ‚àà Finset.range (2 ^ k), t1 ^ (2 ^ i) = 1) :
  ‚àë i ‚àà Finset.range (2 ^ (k+1)), u ^ (2 ^ i) = 1

@[simp]
theorem LeafData.get_internal_ofLeft {Œ±} {s_left s_right : Skeleton}
    (left : LeafData Œ± s_left) (right : LeafData Œ± s_right)
    (idxLeft : SkeletonLeafIndex s_left) :
    (LeafData.internal left right).get (SkeletonLeafIndex.ofLeft idxLeft) =
      left.get idxLeft

theorem foldl_split_inner {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤ ‚Üí Œ±) (init : Œ±)
    (l : List Œ≤) (h : l ‚â† []): foldl (f:=f) (init:=init) (l)
    = foldl (f:=f) (init:=f (init) (l.head (by omega))) (l.tail)

theorem prime_23 : Nat.Prime 23

@[simp]
lemma zero_le_relHammingDist : 0 ‚â§ Œ¥·µ£(u, v)

lemma towerAlgebraMap_id (k : ‚Ñï) : towerAlgebraMap (h_le:=by omega) = RingHom.id (BTField k)

lemma natDeg_sum_eq_of_unique {Œ± : Type} {s : Finset Œ±} {f : Œ± ‚Üí F[X]} {deg : ‚Ñï}
  (mx : Œ±) (h : mx ‚àà s) :
    (f mx).natDegree = deg ‚Üí
    (‚àÄ y ‚àà s, y ‚â† mx ‚Üí (f y).natDegree < deg ‚à® f y = 0) ‚Üí
    (‚àë x ‚àà s, f x).natDegree = deg

theorem split_of_join {k : ‚Ñï} (h_pos : k > 0) (x : ConcreteBTField k)
    (hi_btf lo_btf : ConcreteBTField (k - 1))
    (h_join : x = „Äähi_btf, lo_btf„Äã) :
    (hi_btf, lo_btf) = split h_pos x

lemma E_and_Q_unique
  [NeZero n]
  {e k : ‚Ñï}
  {E Q E' Q' : Polynomial F}
  {œâs f : Fin n ‚Üí F}
  (he : 2 * e < n - k + 1)
  (hk_n : k ‚â§ n)
  (h_Q : Q ‚â† 0)
  (h_Q' : Q' ‚â† 0)
  (h_inj : Function.Injective œâs)
  (h_bw‚ÇÅ : BerlekampWelchCondition e k œâs f E Q)
  (h_bw‚ÇÇ : BerlekampWelchCondition e k œâs f E' Q')
: E * Q' = E' * Q

Nat.pos_of_neZero in Init.Data.Nat.Basic

lemma concrete_mul_one
  (prevBTFieldProps : ConcreteBTFieldProps (k := k - 1))
  (a : ConcreteBTField k) : concrete_mul a (one (k:=k)) = a

@[simp]
private lemma E_ne_zero : (E œâs f p e) ‚â† 0

@[simp]
private lemma oddPart'_coeff {f : Polynomial F} {n : ‚Ñï} :
    (oddPart' f).coeff n = if Even n then f.coeff (n + 1) else 0

@[grind =]
theorem monomialXY_eq_monomialXY_iff {n m p q : ‚Ñï} {a b : F} :
  monomialXY n m a = monomialXY p q b ‚Üî n = p ‚àß m = q ‚àß a = b ‚à® a = 0 ‚àß b = 0

theorem singleEqPolynomial_nf (r : R) (x : MvPolynomial œÉ R) :
    singleEqPolynomial r x = (2 * C r - 1) * x + (1 - C r)

omit [Finite F] in
lemma mul_root_of_unity {x : FÀ£} :
  ‚àÄ {a b : FÀ£} {i j : ‚Ñï},
    i ‚â§ j ‚Üí a ‚àà evalDomain D x i ‚Üí b ‚àà Domain.evalDomain D j ‚Üí
      a * b ‚àà evalDomain D x i

List.length_drop in Init.Data.List.TakeDrop

theorem findIdxRev?_emtpy_none {cond} {as : Array Œ±} (h : as = #[]) :
  findIdxRev? cond as = none

theorem mul_two (n : ChurchNat Œ±) : mul n two = add n n

@[simp]
lemma seqCompose_zero
    (Stmt : Fin 1 ‚Üí Type)
    {Œπ‚Çõ : Fin 1 ‚Üí Type} (OStmt : (i : Fin 1) ‚Üí Œπ‚Çõ i ‚Üí Type)
    [O‚Çõ : ‚àÄ i, ‚àÄ j, OracleInterface (OStmt i j)]
    (Wit : Fin 1 ‚Üí Type)
    {n : Fin 0 ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    [O‚Çò : ‚àÄ i, ‚àÄ j, OracleInterface ((pSpec i).Message j)]
    (R : (i : Fin 0) ‚Üí
      OracleReduction oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Wit i.castSucc)
        (Stmt i.succ) (OStmt i.succ) (Wit i.succ) (pSpec i)) :
    seqCompose Stmt OStmt Wit R =
      @OracleReduction.id Œπ oSpec (Stmt 0) (Œπ‚Çõ 0) (OStmt 0) (Wit 0) (O‚Çõ 0)

lemma concrete_div_eq_mul_inv {k : ‚Ñï} (a b : ConcreteBTField k) : a / b = a * (concrete_inv b)

@[simp] theorem one_mul {a : AssocNat} : 1 * a = a

theorem degreeOf_eval_C_finSuccEquiv (p : MvPolynomial (Fin (n + 1)) R) (j : Fin n) (x : R) :
    degreeOf j (Polynomial.eval (C x) (finSuccEquiv R n p)) ‚â§ degreeOf j.succ p

private lemma really_glorious_lemma {f f' : Polynomial F} (h : 2 * f = 2 * f') :
    f = f'

theorem vappend_left_eq_cons (a : Fin 1 ‚Üí Œ±) (v : Fin n ‚Üí Œ±) :
    vappend a v = (vcons (a 0) v) ‚àò Fin.cast (Nat.add_comm 1 n)

theorem append_knowledgeSoundness (V‚ÇÅ : OracleVerifier oSpec Stmt‚ÇÅ OStmt‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : OracleVerifier oSpec Stmt‚ÇÇ OStmt‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ pSpec‚ÇÇ)
    {knowledgeError‚ÇÅ knowledgeError‚ÇÇ : ‚Ñù‚â•0}
    (h‚ÇÅ : V‚ÇÅ.knowledgeSoundness init impl rel‚ÇÅ rel‚ÇÇ knowledgeError‚ÇÅ)
    (h‚ÇÇ : V‚ÇÇ.knowledgeSoundness init impl rel‚ÇÇ rel‚ÇÉ knowledgeError‚ÇÇ) :
      (V‚ÇÅ.append V‚ÇÇ).knowledgeSoundness init impl rel‚ÇÅ rel‚ÇÉ
        (knowledgeError‚ÇÅ + knowledgeError‚ÇÇ)

theorem div_two_pow_lt_two_pow (x i j : ‚Ñï) (h_x_lt_2_pow_i : x < 2 ^ (i + j)): x / 2^j < 2^(i)

@[simp] lemma twoAdicGenerators_length : twoAdicGenerators.length = twoAdicity + 1

@[simp]
theorem hflatten_succ {m : ‚Ñï} {n : Fin (m + 1) ‚Üí ‚Ñï}
    {Œ± : (i : Fin (m + 1)) ‚Üí (j : Fin (n i)) ‚Üí Sort*}
    {v : (i : Fin (m + 1)) ‚Üí (j : Fin (n i)) ‚Üí Œ± i j} :
    hflatten v = happend (v 0) (hflatten (fun i => v i.succ))

theorem range_vcons {Œ± : Type*} (a : Œ±) (v : Fin n ‚Üí Œ±) :
    Set.range (a ::·µõ v) = insert a (Set.range v)

@[csimp]
theorem dcons_eq_cons : @dcons = @cons

theorem happend_eq_addCases {Œ± : Fin m ‚Üí Sort u} {Œ≤ : Fin n ‚Üí Sort u}
    (u : (i : Fin m) ‚Üí Œ± i) (v : (i : Fin n) ‚Üí Œ≤ i) :
    happend u v = addCases (motive := vappend Œ± Œ≤)
      (fun i => cast (vappend_left Œ± Œ≤ i).symm (u i))
      (fun i => cast (vappend_right Œ± Œ≤ i).symm (v i))

@[grind =_]
lemma ne_zero_iff_coeffs_ne_zero (f : F[X][Y]) : f ‚â† 0 ‚Üî f.coeff ‚â† 0

theorem nsmul_succ (n : ‚Ñï) (p : UniPolyC R) : nsmul (n + 1) p = nsmul n p + p

theorem oracleVerifier_rbrKnowledgeSoundness [Fintype R] :
    (oracleReduction R deg oSpec).verifier.rbrKnowledgeSoundness init impl
      (inputRelation R deg D) (outputRelation R deg)
        (fun _ => (deg : ‚Ñù‚â•0) / (Fintype.card R))

theorem take_drop_append {Œ± : Sort*} (m : ‚Ñï) (h : m ‚â§ n) (v : Fin n ‚Üí Œ±) :
    Fin.append (take m h v) (drop m h v) = fun i => v (i.cast (by omega))

lemma rank_eq_colRank : U.rank = colRank U

lemma isInterleaved_codeOfLinearCode : (codeOfLinearCode Œ∫ LC).isInterleaved

theorem eval_eq_eval_mv_eval_finSuccEquivNth (s : Fin n ‚Üí R) (y : R)
    (f : MvPolynomial (Fin (n + 1)) R) :
      eval (Fin.insertNth p y s : Fin (n + 1) ‚Üí R) f =
        Polynomial.eval y (Polynomial.map (eval s) (finSuccEquivNth R p f))

@[simp]
theorem vappend_vcons (a : Œ±) (u : Fin m ‚Üí Œ±) (v : Fin n ‚Üí Œ±) :
    vappend (vcons a u) v = (vcons a (vappend u v)) ‚àò Fin.cast (Nat.succ_add m n)

theorem BitVec.dcast_id {n : Nat} (bv : BitVec n) :
  DCast.dcast (Eq.refl n) bv = bv

@[simp]
theorem fconcat‚ÇÇ_last {Œ±‚ÇÅ : Fin n ‚Üí A} {Œ±‚ÇÇ : Fin n ‚Üí B} {Œ≤‚ÇÅ : A} {Œ≤‚ÇÇ : B}
    (v : (i : Fin n) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i)) (a : F‚ÇÇ Œ≤‚ÇÅ Œ≤‚ÇÇ) :
    fconcat‚ÇÇ (F := F‚ÇÇ) v a (last n) = cast (by simp [vconcat_last]) a

@[simp]
theorem dcast‚ÇÇ_eq : dcast‚ÇÇ (Eq.refl a) dcast_eq c = c

lemma johnson_condition_strong_iff_johnson_denom_pos {B : Finset (Fin n ‚Üí F)} {v : Fin n ‚Üí F} :
  JohnsonConditionStrong B v ‚Üî 0 < JohnsonDenominator B v

@[simp]
lemma eval‚ÇÇAlgHom_apply {A B : Type*} [CommSemiring A] [CommSemiring B] [MvPolynomialLike œÉ A P]
    [Algebra R A] [IsScalarTower R A P] [Algebra R B]
    (f : A ‚Üí‚Çê[R] B) (g : œÉ ‚Üí B) (p : P) :
    (eval‚ÇÇAlgHom f g) p = eval‚ÇÇ f g p

lemma algebraMap_adjacent_tower_succ_eq_Adjoin_of (k : ‚Ñï) :
  (algebraMap (BTField k) (BTField (k + 1))) = of (poly k)

@[simp]
private lemma x_times_oddPart'_coeff {f : Polynomial F} {n : ‚Ñï} :
    (x_times_oddPart' f).coeff n = if Odd n then f.coeff n else 0

omit [SelectableType R] in
@[simp]
lemma oracleReduction_verifier_eq_oracleVerifier :
    (oracleReduction R deg D n oSpec).verifier = oracleVerifier R deg D n oSpec

theorem sum_square_char2 {F : Type*} [Field F] (sumZeroIffEq : ‚àÄ (x y : F), x + y = 0 ‚Üî x = y)
  (s : Finset ‚Ñï) (f : ‚Ñï ‚Üí F) : (‚àë j ‚àà s, f j)^2 = ‚àë j ‚àà s, (f j)^2

@[simp] theorem rightpad_twice_eq_rightpad_max (m n : Nat) (unit : Œ±) (l : List Œ±) :
    rightpad n unit (rightpad m unit l) = rightpad (max m n) unit l

@[simp]
theorem OracleReduction.run_eq_run_reduction [‚àÄ i, OracleInterface (pSpec.Message i)]
    {stmt : StmtIn} {oStmt : ‚àÄ i, OStmtIn i} {wit : WitIn}
    {oracleReduction : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec} :
      oracleReduction.run stmt oStmt wit =
        oracleReduction.toReduction.run ‚ü®stmt, oStmt‚ü© wit

theorem is_multilinear_eq_iff_eq_evals_zeroOne (p : MvPolynomial œÉ R) (q : MvPolynomial œÉ R)
    (hp : p ‚àà R‚¶É‚â§ 1‚¶Ñ[X œÉ]) (hq : q ‚àà R‚¶É‚â§ 1‚¶Ñ[X œÉ]) :
    p = q ‚Üî p.toEvalsZeroOne = q.toEvalsZeroOne

@[simp]
lemma aeval_X {A : Type y} [CommSemiring A] [Algebra R A] {F : Type z} [FunEquiv F œÉ A] (g : F)
    (s : œÉ) : aeval g (X s : P) = g s

lemma and_one_eq_of_eq {a b : ‚Ñï} : a = b ‚Üí a &&& 1 = b &&& 1

theorem simulateQ_bind_fst_comp (oa : OracleComp spec Œ±) (f : Œ± ‚Üí OracleComp spec Œ≤) :
    (do let a ‚Üê (simulateQ loggingOracle oa).run; f a.1) = (do let a ‚Üê oa; f a)

lemma testBit_of_sub_two_pow_of_bit_1 {n i : ‚Ñï} (h_testBit_eq_1 : (n).testBit i = true) :
  (n - 2^i).testBit i = false

lemma geometric_sum_units {F : Type*} [Field F] [DecidableEq F] {r : FÀ£} {a : ‚Ñï} :
  ‚àë j ‚àà range (a + 1), (r ^ j : F) =
    if r = 1 then (a + 1 : F)
    else (1 - r ^ (a + 1)) / (1 - r)

theorem GF_2_value_eq_zero_or_one (x : GF(2)) : x = 0 ‚à® x = 1

lemma pow_2_pow_i_mem_Di_of_mem_D {F : Type} [NonBinaryField F] [Finite F] {D : Subgroup FÀ£}
  [DIsCyclicC : IsCyclicWithGen ‚Ü•D] {x : FÀ£} :
  ‚àÄ {a : FÀ£} (i : ‚Ñï),
    a ‚àà evalDomain D x 0 ‚Üí a ^ (2 ^ i) ‚àà evalDomain D x i

lemma evenPart_even {f : Polynomial F} :
    EvenPoly (evenPart f)

omit [Finite F] in
lemma neg_mem_dom_of_mem_dom : ‚àÄ {a : FÀ£} (i : Fin n),
    a ‚àà evalDomain D x i ‚Üí - a ‚àà evalDomain D x i

lemma if_zero_then_zero_else_self (x : ConcreteBTField 0) :
  (if x = zero then zero else x) = x

theorem coeff_eq_coeff [LawfulBEq R] (p : UniPoly R) (i : ‚Ñï) :
  p.trim.coeff i = p.coeff i

lemma matchSize_size {p q : UniPoly Q} :
    let (p', _) := Array.matchSize p q 0
    p'.size = max p.size q.size

@[simp]
theorem splitSum_embedSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (i : Fin m) (j : Fin (n i)) :
    splitSum (embedSum i j) = ‚ü®i, j‚ü©

lemma zsmul_neg' {k : ‚Ñï} (n : ‚Ñï) (a : ConcreteBTField k) :
  (if ((Int.negSucc n) : ‚Ñ§) % (2 : ‚Ñ§) = (0 : ‚Ñ§) then zero else a) =
    neg (if (‚Üën.succ : ‚Ñ§) % (2 : ‚Ñ§) = (0 : ‚Ñ§) then zero else a)

@[simp]
theorem divide_by_2_mem {s : Finset ‚Ñï} {d : ‚Ñï} :
  d ‚àà divide_by_2 s ‚Üî 2 * d ‚àà s

lemma toImpl_nonzero {p : Q[X]} (hp : p ‚â† 0) : p.toImpl.size > 0

theorem sumcheckFoldOracleVerifier_rbrKnowledgeSoundness :
    (sumcheckFoldOracleVerifier ùîΩq Œ≤).rbrKnowledgeSoundness init impl
      (pSpec := pSpecSumcheckFold ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
      (relIn := roundRelation (mp := mp) ùîΩq Œ≤ (œë:=œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) 0)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë:=œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) (Fin.last ‚Ñì))
      (rbrKnowledgeError := sumcheckFoldKnowledgeError ùîΩq Œ≤ (œë:=œë))

theorem seqCompose_rbrSoundness
    (lang : (i : Fin (m + 1)) ‚Üí Set (Stmt i √ó ‚àÄ j, OStmt i j))
    (V : (i : Fin m) ‚Üí
      OracleVerifier oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Stmt i.succ) (OStmt i.succ)
        (pSpec i))
    (rbrSoundnessError : ‚àÄ i, (pSpec i).ChallengeIdx ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (V i).rbrSoundness init impl (lang i.castSucc) (lang i.succ) (rbrSoundnessError i)) :
      (OracleVerifier.seqCompose Stmt OStmt V).rbrSoundness
        init impl (lang 0) (lang (Fin.last m))
        (fun combinedIdx =>
          letI ij := seqComposeChallengeIdxToSigma combinedIdx
          rbrSoundnessError ij.1 ij.2)

theorem seqCompose_soundness
    (lang : (i : Fin (m + 1)) ‚Üí Set (Stmt i √ó ‚àÄ j, OStmt i j))
    (V : (i : Fin m) ‚Üí
      OracleVerifier oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Stmt i.succ) (OStmt i.succ)
        (pSpec i))
    (soundnessError : Fin m ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (V i).soundness init impl (lang i.castSucc) (lang i.succ) (soundnessError i)) :
      (OracleVerifier.seqCompose Stmt OStmt V).soundness init impl (lang 0) (lang (Fin.last m))
        (‚àë i, soundnessError i)

@[simp]
lemma seqCompose_zero
    (Stmt : Fin 1 ‚Üí Type)
    {Œπ‚Çõ : Fin 1 ‚Üí Type} (OStmt : (i : Fin 1) ‚Üí Œπ‚Çõ i ‚Üí Type)
    [O‚Çõ : ‚àÄ i, ‚àÄ j, OracleInterface (OStmt i j)]
    {n : Fin 0 ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    [O‚Çò : ‚àÄ i, ‚àÄ j, OracleInterface ((pSpec i).Message j)]
    (V : (i : Fin 0) ‚Üí OracleVerifier oSpec
      (Stmt i.castSucc) (OStmt i.castSucc) (Stmt i.succ) (OStmt i.succ) (pSpec i)) :
    seqCompose Stmt OStmt V = OracleVerifier.id

@[simp] theorem toNat_ofNat (n : Nat) : toNat (ofNat n) = n

@[simp]
theorem mul_by_2_mem {s : Finset ‚Ñï} {d : ‚Ñï} :
    d ‚àà mul_by_2 s ‚Üî Even d ‚àß (d / 2) ‚àà s

@[simp]
theorem cast_completeness (Œµ : ‚Ñù‚â•0) (hComplete : R.completeness init impl relIn relOut Œµ) :
    (R.cast hn hSpec).completeness init impl relIn relOut Œµ

theorem monoToLagrangeLevel_lagrangeToMonoLevel_id (v : Vector R (2 ^ n)) (i : Fin n) :
  monoToLagrangeLevel i (lagrangeToMonoLevel i v) = v

@[simp, grind] lemma fin_chunkSize_lt_N (arrSize : Nat) (i : Fin (min arrSize SpongeSize.R)) :
    i < SpongeSize.N

private lemma johnson_bound‚ÇÄ [Zero F]
  (h_n : 0 < n)
  (h_B : 2 ‚â§ B.card)
  (h_card : 2 ‚â§ (Fintype.card F))
  :
  B.card *
    ((1 - ((Fintype.card F : ‚Ñö) / (Fintype.card F - 1)) * (e B 0 / n)) ^ 2
      - (1 - ((Fintype.card F : ‚Ñö) / (Fintype.card F - 1)) * (d B/n)))  ‚â§
  ((Fintype.card F : ‚Ñö) / (Fintype.card F - 1)) * d B/n

@[to_additive]
theorem prod_Iic_succ (i : Fin n) :
    ‚àè j ‚àà Iic i.succ, v j = (‚àè j ‚àà Iic i.castSucc, v j) * v i.succ

Fin.is_le in Init.Data.Fin.Lemmas

lemma Fin.lt_succ' (a : Fin r) (h_a_add_1 : a + 1 < r) : a < a + 1

omit [Fintype F] [DecidableEq F] in
private lemma choose_2_card_ne_zero (h : 2 ‚â§ B.card) : choose_2 ‚ÜëB.card ‚â† 0

@[grind _=_]
lemma degreeY_as_weighted_deg (hf : f ‚â† 0) :
  natDegreeY f = natWeightedDegree f 0 1

@[simp]
theorem coe_basis_apply {R S : Type*} [CommRing R] [Ring S] [Algebra R S]
  (pb : PowerBasis R S) (i : Fin pb.dim) : ‚áëpb.basis i = pb.gen ^ (i : ‚Ñï)

lemma out_of_dom_smpl_2
  {Œ¥ l : ‚Ñù‚â•0} {s : ‚Ñï} {f : Œπ ‚Üí F} {degree : ‚Ñï} {œÜ : Œπ ‚Ü™ F}
  (C : Set (Œπ ‚Üí F)) (hC : C = code œÜ degree)
  (h_decodable : listDecodable C Œ¥ l)
  (h_nonempty : Nonempty (domainComplement œÜ)) :
  listDecodingCollisionProbability œÜ f Œ¥ s degree h_nonempty ‚â§
    ((l^2 / 2)) * (degree / (Fintype.card F - Fintype.card Œπ))^s

theorem rbrSoundness_implies_soundness (langIn : Set StmtIn) (langOut : Set StmtOut)
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    (rbrSoundnessError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) :
      rbrSoundness init impl langIn langOut verifier rbrSoundnessError ‚Üí
        soundness init impl langIn langOut verifier (‚àë i, rbrSoundnessError i)

theorem zero_lt_pow_n (m : ‚Ñï) (n : ‚Ñï) (h_m : m > 0): 0 < m^n

@[simp]
theorem oracleVerifier_rbrKnowledgeSoundness (hRel : ‚àÄ stmtIn oStmtIn witOut,
      ((mapStmt stmtIn, mapOStmt embedIdx hEq oStmtIn), witOut) ‚àà relOut ‚Üí
      ((stmtIn, oStmtIn), mapWitInv (stmtIn, oStmtIn) witOut) ‚àà relIn) :
    (oracleVerifier oSpec mapStmt embedIdx hEq).rbrKnowledgeSoundness init impl relIn relOut 0

lemma listOfCloseCodewordsRel_eq_zero :
  listOfCloseCodewordsRel C y r = 0 ‚Üî
  IsEmpty (relHammingBall C y r) ‚à® Infinite (relHammingBall C y r)

theorem cast_run (stmt : StmtIn) (wit : WitIn) :
    R.run stmt wit = cast (sorry) ((R.cast hn hSpec).run stmt wit)

@[simp]
theorem LeafData.get_ofFun {Œ±} {s} (f : SkeletonLeafIndex s ‚Üí Œ±) :
    (LeafData.ofFun s f).get = f

theorem append_completeness (R‚ÇÅ : OracleReduction oSpec Stmt‚ÇÅ OStmt‚ÇÅ Wit‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ Wit‚ÇÇ pSpec‚ÇÅ)
    (R‚ÇÇ : OracleReduction oSpec Stmt‚ÇÇ OStmt‚ÇÇ Wit‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ Wit‚ÇÉ pSpec‚ÇÇ)
    {completenessError‚ÇÅ completenessError‚ÇÇ : ‚Ñù‚â•0}
    (h‚ÇÅ : R‚ÇÅ.completeness init impl rel‚ÇÅ rel‚ÇÇ completenessError‚ÇÅ)
    (h‚ÇÇ : R‚ÇÇ.completeness init impl rel‚ÇÇ rel‚ÇÉ completenessError‚ÇÇ) :
      (R‚ÇÅ.append R‚ÇÇ).completeness init impl
        rel‚ÇÅ rel‚ÇÉ (completenessError‚ÇÅ + completenessError‚ÇÇ)

theorem addCases_left' {motive : Fin (m + n) ‚Üí Sort*}
    {left : (i : Fin m) ‚Üí motive (castAdd n i)} {right : (j : Fin n) ‚Üí motive (natAdd m j)}
    {i : Fin m} (j : Fin (m + n)) (h : j = castAdd n i) :
      addCases (motive := motive) left right j = h ‚ñ∏ (left i)

theorem eq_zero_or_eq_one {a : ConcreteBTField 0} : a = zero ‚à® a = one

@[simp]
lemma degreeY_monomialXY {n m : ‚Ñï} {a : F} (ha : a ‚â† 0) :
  natDegreeY (monomialXY n m a) = m

theorem seqCompose_perfectCompleteness (hInit : init.neverFails)
    (rel : (i : Fin (m + 1)) ‚Üí Set ((Stmt i √ó ‚àÄ j, OStmt i j) √ó Wit i))
    (R : ‚àÄ i, OracleReduction oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Wit i.castSucc)
      (Stmt i.succ) (OStmt i.succ) (Wit i.succ) (pSpec i))
    (h : ‚àÄ i, (R i).perfectCompleteness init impl (rel i.castSucc) (rel i.succ)) :
      (OracleReduction.seqCompose Stmt OStmt Wit R).perfectCompleteness
        init impl (rel 0) (rel (Fin.last m))

lemma galois_eval_in_BTField
    {curBTField : Type*} [Field curBTField]
    (u : curBTField) (t1 : curBTField) -- here t1 is already lifted to curBTField
    (k : ‚Ñï)
    (sumZeroIffEq : ‚àÄ (x y : curBTField), x + y = 0 ‚Üî x = y)
    (prevSpecialElementNeZero : t1 ‚â† 0)
    (u_plus_inv_eq_t1 : u + u‚Åª¬π = t1)
    (h_u_square : u^2 = u*t1 + 1)
    (h_t1_pow : t1^(2^(2^k)-1) = 1 ‚àß (t1‚Åª¬π)^(2^(2^k)-1) = 1)
    (h_t1_pow_2_pow_2_pow_k :  t1^(2^(2^k)) = t1)
    (h_t1_inv_pow_2_pow_2_pow_k :  (t1‚Åª¬π)^(2^(2^k)) = t1‚Åª¬π)
    (trace_map_at_inv : ‚àë i ‚àà Finset.range (2 ^ k), t1‚Åª¬π ^ (2 ^ i) = 1) :
    u^(2^(2^k)) = u‚Åª¬π

lemma twoAdicity_maximal : ¬¨ (2 ^ (twoAdicity + 1)) ‚à£ (fieldSize - 1)

@[simp]
theorem cast_toVerifier (V : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec‚ÇÅ) :
    (OracleVerifier.cast hn hSpec hO‚Çò V).toVerifier = Verifier.cast hn hSpec V.toVerifier

lemma getBit_eq_succ_getBit_of_mul_two {n k : ‚Ñï} : getBit (k+1) (2*n) = getBit k n

@[simp]
lemma foldl'_zero {Œ± : Type u} (f : (i : Fin 0) ‚Üí Œ± ‚Üí Œ±) (x : Œ±) :
    foldl' 0 f x = x

lemma forwardRange_getElem (n : ‚Ñï) (r : Fin n) (l : Fin (r.val + 1)) (k : Fin (r.val - l.val + 1)) :
    (forwardRange n r l).get ‚ü®k, by
      rw [forwardRange]; simp only [List.length_ofFn]; omega‚ü© = ‚ü®l.val + k, by omega‚ü©

@[simp] lemma extract_dir : pSpec‚ü¶start:stop‚üß.dir = pSpec.dir‚ü¶start:stop‚üß

Polynomial.degree_sum_le in Mathlib.Algebra.Polynomial.Degree.Definitions

omit [Finite F] in
private lemma op_der_eq : Monoid.toMulAction FÀ£ = Units.mulAction'

@[simp]
theorem cast_id :
    OracleVerifier.cast rfl rfl (fun i => rfl) =
      (id : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec‚ÇÅ ‚Üí _)

@[simp]
theorem eval_poly_at_root (k : ‚Ñï) : (Z (k+1))^2 + (Z (k+1)) * Z k + 1 = 0

@[simp]
lemma Rhs_zero_eq_neg : Rhs 0 œâs f i = -f i

lemma h_sub_middle {k : ‚Ñï} (h_pos : k > 0) : 2 ^ k - 1 - 2 ^ (k - 1) + 1 = 2 ^ (k - 1)

lemma Œ≤_regular (R : F[X][X][Y])
                (H : F[X][Y]) [H_irreducible : Fact (Irreducible H)]
                {D : ‚Ñï} (hD : D ‚â• Bivariate.totalDegree H) :
    ‚àÄ t : ‚Ñï, ‚àÉ Œ≤ : ùí™ H, weight_Œõ_over_ùí™ Œ≤ ‚â§ (2 * t + 1) * Bivariate.natDegreeY R * D

theorem eqPolynomial_mem_restrictDegree (r : œÉ ‚Üí R) : (eqPolynomial r) ‚àà R‚¶É‚â§ 1‚¶Ñ[X œÉ]

@[simp]
lemma numPartialRounds_pos : 0 < params.numPartialRounds

lemma towerRingHomForwardMap_mul_eq (k : ‚Ñï) (x y : ConcreteBTField k) :
    towerRingHomForwardMap (k:=k) (x * y)
    = towerRingHomForwardMap (k:=k) x * towerRingHomForwardMap (k:=k) y

@[simp]
theorem fflatten‚ÇÇ_zero {A : Sort u} {B : Sort v} {F : A ‚Üí B ‚Üí Sort w} {n : Fin 0 ‚Üí ‚Ñï}
    {Œ± : (i : Fin 0) ‚Üí (j : Fin (n i)) ‚Üí A}
    {Œ≤ : (i : Fin 0) ‚Üí (j : Fin (n i)) ‚Üí B}
    {v : (i : Fin 0) ‚Üí (j : Fin (n i)) ‚Üí F (Œ± i j) (Œ≤ i j)} : fflatten‚ÇÇ v = !h[]

@[simp]
theorem simulateQ'_pure (x : Œ±) : simulateQ' so (pure x) (by simp) = pure x

theorem ZMod.powNeOfPowMod :
    ‚àÄ {n a' q c : ‚Ñï} (a : ZMod n), (a' : ZMod n) = a ‚Üí decide (n ‚â• 2) = true ‚Üí
      Nat.mod (Nat.pow a' ((n - 1) / q)) n = c ‚Üí decide (c ‚â† 1) = true ‚Üí a ^ ((n - 1) / q) ‚â† 1

lemma oracle_block_k_next_le (i : Fin (‚Ñì + 1)) (j : Fin (toOutCodewordsCount ‚Ñì œë i))
    (hj : j.val + 1 < toOutCodewordsCount ‚Ñì œë i) : j.val * œë + œë ‚â§ i

omit [Fintype ùîΩq] h_Fq_char_prime hŒ≤_lin_indep in
lemma eval_W_eq_zero_iff_in_U (i : Fin r) (a : L) :
  (W ùîΩq Œ≤ i).eval a = 0 ‚Üî a ‚àà U ùîΩq Œ≤ i

theorem liftContext_run
    {lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    {outerStmtIn : OuterStmtIn} {outerWitIn : OuterWitIn}
    {R : Reduction oSpec InnerStmtIn InnerWitIn InnerStmtOut InnerWitOut pSpec} :
      (R.liftContext lens).run outerStmtIn outerWitIn = do
        let ‚ü®‚ü®fullTranscript, innerCtxOut‚ü©, verInnerStmtOut‚ü© ‚Üê
          R.run.uncurry (lens.proj (outerStmtIn, outerWitIn))
        return ‚ü®‚ü®fullTranscript, lens.lift (outerStmtIn, outerWitIn) innerCtxOut‚ü© ,
                lens.stmt.lift outerStmtIn verInnerStmtOut‚ü©

@[simp]
theorem insertNth_apply_succAbove : insertNth p y s (p.succAbove i) = s i

theorem oracleReduction_rbr_knowledge_soundness : True

theorem zipWith_cons {Œ± Œ≤ Œ≥} {n : ‚Ñï} (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥)
    (a : Œ±) (b : Vector Œ± n) (c : Œ≤) (d : Vector Œ≤ n) :
    zipWith f (cons a b) (cons c d) = cons (f a c) (zipWith f b d)

theorem castSum_castAdd {n m : ‚Ñï} (i : Fin n) : castSum [n, m] (by simp) i = castAdd m i

theorem oracleReduction_perfectCompleteness (hInit : init.neverFails) :
    (oracleReduction R deg oSpec).perfectCompleteness init impl
      (inputRelation R deg D) (outputRelation R deg)

theorem srSoundness_implies_soundness
    (langIn : Set StmtIn) (langOut : Set StmtOut)
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    (srInit : ProbComp (srChallengeOracle StmtIn pSpec).FunctionType)
    (srImpl : QueryImpl oSpec (StateT (srChallengeOracle StmtIn pSpec).FunctionType ProbComp))
    (srSoundnessError : ‚Ñù‚â•0) :
      Verifier.StateRestoration.soundness srInit srImpl langIn langOut verifier srSoundnessError ‚Üí
        soundness init impl langIn langOut verifier srSoundnessError

lemma AlgebraTowerEquiv.commutesRight' (e : AlgebraTowerEquiv A B)
    {i j : Œπ} (h : i ‚â§ j) (r : B i) :
  AlgebraTower.algebraMap (AT:=A) (i:=i) (j:=j) (h:=h) ((e.toRingEquiv i).symm r) =
  (e.toRingEquiv j).symm (AlgebraTower.algebraMap (AT:=B) (i:=i) (j:=j) (h:=h) r)

@[simp, grind =]
lemma totalDegree_monomialXY {n m : ‚Ñï} {a : F} (ha : a ‚â† 0) :
  totalDegree (monomialXY n m a) = n + m

@[simp] theorem equiv_trans {p q r : UniPoly Q} : Trim.equiv p q ‚Üí equiv q r ‚Üí equiv p r

lemma algebraMap_binaryTowerAlgebra_def (l r : ‚Ñï) (h_le : l ‚â§ r) :
  (@binaryAlgebraTower (l:=l) (r:=r) (h_le:=h_le)).algebraMap = towerAlgebraMap l r h_le

@[simp]
lemma dfoldrM'_succ {n : ‚Ñï} {Œ± : Fin (n + 1 + 1) ‚Üí Type u}
    (f : (i : Fin (n + 1)) ‚Üí Œ± i.succ ‚Üí m (Œ± i.castSucc)) (x : Œ± (last (n + 1))) :
    dfoldrM' (n + 1) Œ± f x = (do
      let y ‚Üê dfoldrM' n (Œ± ‚àò succ) (fun i => f i.succ) x
      f 0 y)

theorem functional_completeness (Œ± : Type) {s : Skeleton}
  (idx : SkeletonLeafIndex s)
  (leaf_data_tree : LeafData Œ± s)
  (hash : Œ± ‚Üí Œ± ‚Üí Œ±) :
  (getPutativeRoot_with_hash
    idx
    (leaf_data_tree.get idx)
    (generateProof
      (buildMerkleTree_with_hash leaf_data_tree hash) idx)
    (hash)) =
  (buildMerkleTree_with_hash leaf_data_tree hash).getRootValue

@[simp]
theorem fflatten_two_eq_append {A : Sort u} {F : A ‚Üí Sort v} {n : Fin 2 ‚Üí ‚Ñï}
    {Œ± : (i : Fin 2) ‚Üí (j : Fin (n i)) ‚Üí A}
    {v : (i : Fin 2) ‚Üí (j : Fin (n i)) ‚Üí F (Œ± i j)} :
    fflatten v = fappend (F := F) (v 0) (v 1)

theorem init_vconcat (v : Fin n ‚Üí Œ±) (a : Œ±) :
    (fun i => vconcat v a (Fin.castSucc i)) = v

@[simp]
lemma solutionToQ_zero {v : Fin (2 * 0 + 0) ‚Üí F} :
  solutionToQ (F := F) 0 0 v = 0

omit [NoZeroDivisors ùîΩ] in
lemma foldNth_degree_le' {n : ‚Ñï} {f : ùîΩ[X]} {Œ± : ùîΩ} [inst : NeZero n] :
    n * (foldNth n f Œ±).natDegree ‚â§ f.natDegree

@[simp]
lemma deevenize_coeff {f : Polynomial F} {n : ‚Ñï} :
    (deevenize f).coeff n = f.coeff (2 * n)

theorem dconcat_left_injective {motive : Fin (n + 1) ‚Üí Sort u} (a : motive (last n)) :
    Function.Injective (fun v => dconcat (motive := motive) v a)

theorem comp_x_square_coeff {f : Polynomial F} {n : ‚Ñï} :
  (f.comp (X * X)).coeff n = if Even n then f.coeff (n / 2) else 0

lemma coprime_three_fieldSize_sub_one : Nat.Coprime 3 (fieldSize - 1)

@[simp]
lemma eval‚ÇÇAlgHom_apply {A : Type w} {B : Type*} [CommSemiring A] [CommSemiring B]
    [PolynomialLike A P] [Algebra R A] [IsScalarTower R A P] [Algebra R B]
    (f : A ‚Üí‚Çê[R] B) (b : B) (p : P) :
    (eval‚ÇÇAlgHom f b) p = eval‚ÇÇ f b p

theorem hcons_right_injective {Œ≤ : Fin n ‚Üí Sort u} (a : Œ±) :
    Function.Injective (hcons a : ((i : Fin n) ‚Üí Œ≤ i) ‚Üí (i : Fin (n + 1)) ‚Üí vcons Œ± Œ≤ i)

theorem simulateQ'_eq_simulateQ [AlternativeMonad m] [LawfulMonad m]
    {so : QueryImpl spec m} (oa : OracleComp spec Œ±) (h : oa.neverFails) :
      simulateQ' so oa h = simulateQ so oa

@[simp]
theorem choose_2_convex : ConvexOn ‚Ñö Set.univ choose_2

Nat.le_of_succ_le in Init.Data.Nat.Basic

theorem dcast‚ÇÉ_symm (ha : a = a') (hb : dcast ha b = b') (hc : dcast‚ÇÇ ha hb c = c')
    (hd : dcast‚ÇÉ ha hb hc d = d') :
    dcast‚ÇÉ ha.symm (dcast_symm ha hb) (dcast‚ÇÇ_symm ha hb hc) d' = d

@[simp]
theorem LeafData.get_leaf {Œ±} (a : Œ±) :
    (LeafData.leaf a).get SkeletonLeafIndex.ofLeaf = a

theorem Fin.sum_univ_odd_even {n : ‚Ñï} {M : Type*} [AddCommMonoid M] (f : ‚Ñï ‚Üí M) :
    (‚àë i : Fin (2 ^ n), f (2 * i)) + (‚àë i : Fin (2 ^ n), f (2 * i + 1))
    = ‚àë i: Fin (2 ^ (n+1)), f i

theorem snoc_support :
    (s.snoc y).support ‚äÜ insert (Fin.last n) (s.support.map Fin.castSuccEmb)

@[simp]
theorem vconcat_zero (a : Œ±) : vconcat !v[] a = !v[a]

@[simp]
theorem acceptRejectRel_language : acceptRejectRel.language = { true }

Nat.add_zero in Init.Core

lemma fold_f_g_poly
  {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F} {k m : ‚Ñï}
  {œÜ_0 : (indexPowT S œÜ 0) ‚Ü™ F} {œÜ_k : (indexPowT S œÜ k) ‚Ü™ F}
  [Fintype (indexPowT S œÜ 0)] [DecidableEq (indexPowT S œÜ 0)] [Smooth œÜ_0]
  [Fintype (indexPowT S œÜ k)] [DecidableEq (indexPowT S œÜ k)] [Smooth œÜ_k]
  [‚àÄ i : ‚Ñï, Neg (indexPowT S œÜ i)]
  (Œ±s : Fin k ‚Üí F) (hk : k ‚â§ m)
  (f : smoothCode œÜ_0 m) (g : smoothCode œÜ_k (m-k)) :
  let fPoly

theorem vcons_left_injective (v : Fin n ‚Üí Œ±) : Function.Injective (fun a => a ::·µõ v)

lemma rootMultiplicity_some_implies_root {F : Type} [CommSemiring F] [DecidableEq F]
  {x y : F} {f : F[X][Y]} (h : some 0 < (rootMultiplicity (f := f) x y))
  : (f.eval 0).eval 0 = 0

@[simp]
theorem FullData.rightSubtree_internal {Œ±} {s_left s_right : Skeleton}
    (value : Œ±) (left : FullData Œ± s_left) (right : FullData Œ± s_right) :
    (FullData.internal value left right).rightSubtree = right

theorem canonical_empty : (UniPoly.mk (R:=R) #[]).trim = #[]

omit [DecidableEq ùîΩq] hF‚ÇÇ in
lemma initial_tiled_coeffs_correctness (h_‚Ñì : ‚Ñì ‚â§ r) (a : Fin (2 ^ ‚Ñì) ‚Üí L) :
    let b: Fin (2^(‚Ñì + R_rate)) ‚Üí L := tileCoeffs a
    additiveNTTInvariant ùîΩq Œ≤ h_‚Ñì_add_R_rate b a (i := ‚ü®‚Ñì, by omega‚ü©)

@[simp]
protected lemma elocPoly_zero : ElocPoly 0 œâs f p = 1

lemma sDomain_eq_image_of_upper_span (i : Fin r) (h_i : i < ‚Ñì + R_rate) :
    let V_i := Submodule.span ùîΩq (Set.range (sBasis Œ≤ h_‚Ñì_add_R_rate i h_i))
    let W_i_map := polyEvalLinearMap (normalizedW ùîΩq Œ≤ i)
      (normalizedW_is_additive ùîΩq Œ≤ i)
    sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i
    = Submodule.map W_i_map V_i

@[simp] theorem rightpadPowerOfTwo_size (unit : Œ±) (a : Array Œ±) :
    (a.rightpadPowerOfTwo unit).size = 2 ^ (Nat.clog 2 a.size)

lemma dist_eq_minWtCodewords [CommRing F] {LC : LinearCode Œπ F} :
  Code.minDist (LC : Set (Œπ ‚Üí F)) = minWtCodewords LC

Fin.isLt in Init.Prelude

@[simp]
theorem leftpad_apply_lt (n : ‚Ñï) (a : Œ±) (v : Fin m ‚Üí Œ±) (i : Fin n)
    (h : i.val < n - m) : leftpad n a v i = a

lemma rootMultiplicity_W (i : Fin r) (a : L) :
    rootMultiplicity a (W ùîΩq Œ≤ i) = if a ‚àà (U ùîΩq Œ≤ i : Set L) then 1 else 0

theorem mul_two_add_bit_lt_two_pow (a b c : ‚Ñï) (i : Fin 2)
    (h_a : a < 2 ^ b) (h_b : b < c) :
    a * 2 + i.val < 2^c

theorem prime_3 : Nat.Prime 3

lemma one_bitvec_toNat {width : ‚Ñï} (h_width : width > 0) : (1#width).toNat = 1

@[simp]
theorem acceptRejectOracleRel_language :
    acceptRejectOracleRel.language = { (true, isEmptyElim) }

@[simp]
theorem verifier_first (pSpec : ProtocolSpec n) [NeZero n] [h : VerifierFirst pSpec] :
    pSpec.dir 0 = .V_to_P

lemma Fin.val_add_one' (a : Fin r) (h_a_add_1 : a + 1 < r) : (a + 1).val = a.val + 1

omit [NoZeroDivisors ùîΩ] in
lemma splitNth_def (n : ‚Ñï) (f : ùîΩ[X]) [inst : NeZero n] :
    f =
      ‚àë i : Fin n,
        (Polynomial.X ^ i.1) *
          Polynomial.eval‚ÇÇ Polynomial.C (Polynomial.X ^ n) (splitNth f n i)

omit [SelectableType R] in
@[simp]
lemma reduction_verifier_eq_verifier :
    (reduction R deg D n oSpec).verifier = verifier R deg D n oSpec

theorem lagrangeToMonoLevel_monoToLagrangeLevel_id (v : Vector R (2 ^ n)) (i : Fin n) :
  lagrangeToMonoLevel i (monoToLagrangeLevel i v) = v

theorem and_highBits_lowBits_eq_zero {n : ‚Ñï} (numLowBits : ‚Ñï) :
    getHighBits numLowBits n &&& getLowBits numLowBits n = 0

theorem max_eq_add_sub {m n : Nat} : Nat.max m n = m + (n - m)

theorem non_zero_map [LawfulBEq R] (f : R ‚Üí R) (hf : ‚àÄ r, f r = 0 ‚Üí r = 0) (p : UniPoly R) :
  let fp := UniPoly.mk (p.map f);
  p.trim = p ‚Üí fp.trim = fp

theorem relayOracleVerifier_rbrKnowledgeSoundness (i : Fin ‚Ñì)
    (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
    (relayOracleVerifier ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        i hNCR).rbrKnowledgeSoundness init impl
      (relIn := foldStepRelOut (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i.succ)
      (relayKnowledgeError)

@[simp]
theorem append_cast_left {n m : ‚Ñï} {pSpec : ProtocolSpec n} {pSpec' : ProtocolSpec m} (n' : ‚Ñï)
    (h : n + m = n' + m) :
      dcast h (pSpec ++‚Çö pSpec') = (dcast (Nat.add_right_cancel h) pSpec) ++‚Çö pSpec'

theorem dist_eq_dist_from_HammingNorm [CommRing F] [DecidableEq F] (LC : LinearCode Œπ F) :
    Code.dist LC.carrier = disFromHammingNorm LC

@[simp]
lemma eval_solutionToQ {x : F} :
  eval x (solutionToQ e k v) =
  ‚àë i ‚àà Finset.range (e + k), liftF v (e + i) * x ^ i

theorem add_comm : p + q = q + p

@[simp]
theorem finSigmaFinEquiv'_apply {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (k : (i : Fin m) √ó Fin (n i)) :
    (finSigmaFinEquiv' k : ‚Ñï) = ‚àë i : Fin k.1, n (Fin.castLE k.1.isLt.le i) + k.2

lemma folding_preserves_listdecoding_base_ne_subset
  {S : Finset Œπ} {k m : ‚Ñï} (hm : 1 ‚â§ m) {œÜ : Œπ ‚Ü™ F} [Smooth œÜ] {Œ¥ : ‚Ñù‚â•0}
  {S_0 : Finset (indexPowT S œÜ 0)} {S_1 : Finset (indexPowT S œÜ 1)}
  {œÜ_0 : (indexPowT S œÜ 0) ‚Ü™ F} {œÜ_1 : (indexPowT S œÜ 1) ‚Ü™ F}
  [‚àÄ i : ‚Ñï, Fintype (indexPowT S œÜ i)] [‚àÄ i : ‚Ñï, DecidableEq (indexPowT S œÜ i)]
  [Smooth œÜ_0] [Smooth œÜ_1]
  [h : ‚àÄ {f : (indexPowT S œÜ 0) ‚Üí F}, DecidableBlockDisagreement 0 k f S_0 œÜ_0]
  [h : ‚àÄ {f : (indexPowT S œÜ 1) ‚Üí F}, DecidableBlockDisagreement 1 k f S_1 œÜ_1]
  [‚àÄ i : ‚Ñï, Neg (indexPowT S œÜ i)]
  {C : Set ((indexPowT S œÜ 0) ‚Üí F)} (hcode : C = smoothCode œÜ_0 m)
  (C' : Set ((indexPowT S œÜ 1) ‚Üí F)) (hcode' : C' = smoothCode œÜ_1 (m-1))
  {BStar : (Set (indexPowT S œÜ 1 ‚Üí F)) ‚Üí ‚Ñï ‚Üí ‚Ñù‚â•0}
  {errStar : (Set (indexPowT S œÜ 1 ‚Üí F)) ‚Üí ‚Ñï ‚Üí ‚Ñù‚â•0 ‚Üí ‚Ñù‚â•0} :
    Pr_{let Œ± ‚Üê$·µñ F}[ ‚àÄ { f : (indexPowT S œÜ 0) ‚Üí F} (hŒ¥Le: Œ¥ ‚â§ 1 - (BStar C' 2)),
                      let listBlock : Set ((indexPowT S œÜ 0) ‚Üí F) := Œõ·µ£(0, k, f, S_0, C, hcode, Œ¥)
                      let vec_Œ± : Fin 1 ‚Üí F := (fun _ : Fin 1 => Œ±)
                      let foldSet := fold_k_set listBlock vec_Œ± hm
                      let fold := fold_k f vec_Œ± hm
                      let listBlock' : Set ((indexPowT S œÜ 1) ‚Üí F)
                        := Œõ·µ£(1, k, fold, S_1, C', hcode', Œ¥)
                      ¬¨ (listBlock' ‚äÜ foldSet)
                    ] < errStar C' 2 Œ¥

lemma getBit_of_sub_two_pow_of_bit_1 {n i j: ‚Ñï} (h_getBit_eq_1: getBit i n = 1) :
  getBit j (n - 2^i) = (if j = i then 0 else getBit j n)

private lemma k_choose_2 [Zero F] {B : Finset (Fin n ‚Üí F)}
  (h_n : n ‚â† 0)
  (h_B : B.card ‚â† 0)
  :
  n * choose_2 (k B) ‚â§ ‚àë i, choose_2 (K B i 0)

@[simp]
lemma getTypes_nil : getTypes [] = []

theorem degrees_mul_C_le (p : MvPolynomial œÉ R) (c : R) : (p * C c).degrees ‚â§ p.degrees

theorem correlatedAgreement_affine_spaces {k : ‚Ñï} [NeZero k] {u : Fin (k + 1) ‚Üí Œπ ‚Üí F}
  {deg : ‚Ñï} {domain : Œπ ‚Ü™ F} {Œ¥ : ‚Ñù‚â•0} (hŒ¥ : Œ¥ ‚â§ 1 - (ReedSolomonCode.sqrtRate deg domain))
  (hproximity :
    Pr_{let y ‚Üê $·µñ (u 0 +·µ• affineSpan F (Finset.univ.image (Fin.tail u)).toSet)}[
        Code.relHammingDistToCode (Œπ := Œπ) (F := F) y (ReedSolomon.code domain deg) ‚â§ Œ¥
    ] > errorBound Œ¥ deg domain) :
  correlatedAgreement (ReedSolomon.code domain deg) Œ¥ u

theorem Basis_cast_dest_eq {Œπ : Type*} (k n m : ‚Ñï) (h_k_le_n : k ‚â§ n)
  (h_k_le_m : k ‚â§ m) (h_eq : m = n) :
  letI instLeftAlgebra := ConcreteBTFieldAlgebra (l:=k) (r:=m) (h_le:=h_k_le_m)
  letI instRightAlgebra := ConcreteBTFieldAlgebra (l:=k) (r:=n) (h_le:=h_k_le_n)
  @Basis Œπ (ConcreteBTField k) (ConcreteBTField m) _ _ instLeftAlgebra.toModule =
  @Basis Œπ (ConcreteBTField k) (ConcreteBTField n) _ _ instRightAlgebra.toModule

@[simp]
theorem Z_succ_eq_adjointRoot_root (k : ‚Ñï) : Z (k+1) = AdjoinRoot.root (poly k)

@[to_additive]
lemma prod_univ_twos {M : Type*} [CommMonoid M] {n : ‚Ñï} (hn : n = 2) (f : Fin n ‚Üí M) :
    (‚àè i, f i) = f (Fin.cast hn.symm 0) * f (Fin.cast hn.symm 1)

omit [NeZero ‚Ñì] [NeZero r] [NeZero ùì°] in
lemma fin_r_succ_bound {h_‚Ñì_add_R_rate : ‚Ñì + ùì° < r} (i : Fin r) (h_i : i + 1 < ‚Ñì + ùì°)
    : i + 1 < r

theorem split_mul_eq_mul_split {k : ‚Ñï} (h_pos : k > 0) (x‚ÇÄ x‚ÇÅ : ConcreteBTField k)
  (hi‚ÇÄ lo‚ÇÄ hi‚ÇÅ lo‚ÇÅ : ConcreteBTField (k - 1))
  (h_split_x‚ÇÄ : split h_pos x‚ÇÄ = (hi‚ÇÄ, lo‚ÇÄ))
  (h_split_x‚ÇÅ : split h_pos x‚ÇÅ = (hi‚ÇÅ, lo‚ÇÅ)) :
  split h_pos (x‚ÇÄ * x‚ÇÅ) =
    (lo‚ÇÄ * hi‚ÇÅ + lo‚ÇÅ * hi‚ÇÄ + hi‚ÇÄ * hi‚ÇÅ * Z (k - 1), lo‚ÇÄ * lo‚ÇÅ + hi‚ÇÄ * hi‚ÇÅ)

theorem rbrKnowledgeSoundness_implies_rbrSoundness
    {relIn : Set (StmtIn √ó WitIn)} {relOut : Set (StmtOut √ó WitOut)}
    {verifier : Verifier oSpec StmtIn StmtOut pSpec}
    {rbrKnowledgeError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    (h : verifier.rbrKnowledgeSoundness init impl relIn relOut rbrKnowledgeError) :
    verifier.rbrSoundness init impl relIn.language relOut.language rbrKnowledgeError

omit [(i : Œπ‚Çõ) ‚Üí OracleInterface (OStatement i)] [OracleInterface Witness] in
theorem oracleProver_run {stmt : Statement} {oStmt : ‚àÄ i, OStatement i} {wit : Witness} :
    (oracleProver oSpec Statement OStatement Witness).run ‚ü®stmt, oStmt‚ü© wit =
      pure (fun i => by aesop, ‚ü®stmt, Sum.rec oStmt (fun _ => wit)‚ü©, ())

lemma concrete_one_mul0 (a : ConcreteBTField 0) :
  concrete_mul (one (k:=0)) a = a

Nat.lt_trans in Init.Prelude

@[simp]
lemma eval‚ÇÇ_monomial {S : Type w} [CommSemiring S] (f : R ‚Üí+* S) (x : S) (n : ‚Ñï) (r : R) :
    eval‚ÇÇ (P := P) f x (monomial n r) = f r * x ^ n

lemma eq_iff_eq_all_getBits {n m : ‚Ñï} : n = m ‚Üî ‚àÄ k, getBit k n = getBit k m

theorem dconcat_injective2 {motive : Fin (n + 1) ‚Üí Sort u} :
    Function.Injective2 (@dconcat n motive)

theorem ofFn_drop_eq_drop_ofFn {Œ± : Type*} {m : ‚Ñï} (h : m ‚â§ n) (v : Fin n ‚Üí Œ±) :
    List.ofFn (drop m h v) = (List.ofFn v).drop m

@[simp]
theorem seqCompose_zero {n : Fin 0 ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    {T : ‚àÄ i, FullTranscript (pSpec i)} :
    seqCompose T = !h[]

@[simp]
lemma addSalt_dir : (pSpec.addSalt Salt).dir = pSpec.dir

lemma guruswami_sudan_for_proximity_gap_existence {k m : ‚Ñï} {œâs : Fin n ‚Ü™ F} {f : Fin n ‚Üí F} :
  ‚àÉ Q, Condition k m (proximity_gap_degree_bound (n := n) k m) œâs f Q

@[simp, grind =]
lemma leadingCoeffY_ne_zero (f : F[X][Y]) : leadingCoeffY f ‚â† 0 ‚Üî f ‚â† 0

@[simp]
theorem dcast_eq : dcast (Eq.refl a) b = b

@[simp]
theorem lagrangeBasis_zero {w : Vector R 0} : lagrangeBasis w = #v[1]

lemma addSalt_Challenge (i : pSpec.ChallengeIdx) :
    (pSpec.addSalt Salt).Challenge i = pSpec.Challenge i

lemma getBit_eq_succ_getBit_of_mul_two_add_one {n k : ‚Ñï} : getBit (k+1) (2*n + 1) = getBit k n

Nat.zero_le in Init.Prelude

private lemma x_times_oddPart'_eq_x_times_oddPart' {f : Polynomial F} :
    Polynomial.X * (oddPart' f) = x_times_oddPart' f

lemma vappend_right_of_not_lt {m n : ‚Ñï} {Œ± : Sort u}
    (u : Fin m ‚Üí Œ±) (v : Fin n ‚Üí Œ±) (i : Fin (m + n)) (h : ¬¨ i.val < m) :
      vappend u v i = v ‚ü®i - m, by omega‚ü©

lemma towerRingHomForwardMap_Z (k : ‚Ñï) :
  towerRingHomForwardMap k (Z k) = BinaryTower.Z k

@[simp]
theorem vempty_vappend (v : Fin n ‚Üí Œ±) : vappend !v[] v = v ‚àò Fin.cast (Nat.zero_add n)

@[simp]
theorem Fin.cast_val_eq_val {n m : ‚Ñï} [NeZero n] (a : Fin n) (h_eq : n = m):
  (Fin.cast (h_eq) a).val = a.val

theorem dinit_hconcat {Œ± : Fin n ‚Üí Sort u} {Œ≤ : Sort u} (v : (i : Fin n) ‚Üí Œ± i) (b : Œ≤) :
    True

theorem join_eq_join_iff {k : ‚Ñï} (h_pos : k > 0) (hi‚ÇÄ lo‚ÇÄ hi‚ÇÅ lo‚ÇÅ : ConcreteBTField (k - 1)) :
  „Ää hi‚ÇÄ, lo‚ÇÄ „Äã = „Ää hi‚ÇÅ, lo‚ÇÅ „Äã ‚Üî (hi‚ÇÄ = hi‚ÇÅ ‚àß lo‚ÇÄ = lo‚ÇÅ)

lemma exists_Pz_of_coeffs_of_close_proximity
  {k : ‚Ñï}
  {z : F}
  (hS : z ‚àà coeffs_of_close_proximity (k := k) œâs Œ¥ u‚ÇÄ u‚ÇÅ)
  :
  ‚àÉ Pz : F[X], Pz.natDegree ‚â§ k ‚àß Œ¥·µ£(u‚ÇÄ + z ‚Ä¢ u‚ÇÅ, Pz.eval ‚àò œâs) ‚â§ Œ¥

omit [NeZero r] in
theorem hŒ≤_lin_indep_concrete (k : ‚Ñï) :
    letI := ConcreteBTFieldAlgebra (l:=0) (r:=k) (h_le:=by omega)
    LinearIndependent (R := ConcreteBTField 0)
      (v := computableBasisExplicit k)

@[simp] theorem rightpad_prefix (n : Nat) (unit : Œ±) (l : List Œ±) :
    l <+: rightpad n unit l

lemma zero_add {k : ‚Ñï} (a : ConcreteBTField k) : 0 + a = a

theorem hcons_happend_comm {Œ≤ : Fin m ‚Üí Sort u} {Œ≥ : Fin n ‚Üí Sort u}
    (a : Œ±) (u : (i : Fin m) ‚Üí Œ≤ i) (v : (i : Fin n) ‚Üí Œ≥ i) :
    True

@[simp]
theorem Verifier.id_knowledgeSoundness {rel : Set (StmtIn √ó WitIn)} :
    (Verifier.id : Verifier oSpec _ _ _).knowledgeSoundness init impl rel rel 0

@[simp]
private lemma F2i_disjoint :
  Set.PairwiseDisjoint Set.univ (F2i B i)

lemma sum_insertNth' [AddCommMonoid M] [AddCommMonoid N] {n : ‚Ñï} (œÉ : Fin n ‚Üí‚ÇÄ M) (i : M)
    (p : Fin (n + 1)) (f : Fin (n+1) ‚Üí M ‚Üí N) (h : ‚àÄ x, f x 0 = 0) :
    sum (insertNth p i œÉ) f = f p i + sum œÉ (Fin.removeNth p f)

Nat.mul_le_mul_right in Init.Data.Nat.Basic

@[simp]
theorem vappend_right (u : Fin m ‚Üí Œ±) (v : Fin n ‚Üí Œ±) (i : Fin n) :
    vappend u v (natAdd m i) = v i

theorem liftContext_rbr_soundness
    {rbrSoundnessError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    {lens : OracleStatement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                                OuterOStmtIn OuterOStmtOut InnerOStmtIn InnerOStmtOut}
    (V : OracleVerifier oSpec InnerStmtIn InnerOStmtIn InnerStmtOut InnerOStmtOut pSpec)
    [lensSound : lens.IsSound
      outerLangIn outerLangOut innerLangIn innerLangOut
      (V.toVerifier.compatStatement lens)]
    (h : V.rbrSoundness init impl innerLangIn innerLangOut rbrSoundnessError) :
      (V.liftContext lens).rbrSoundness init impl outerLangIn outerLangOut rbrSoundnessError

@[to_additive vsum_castSucc]
lemma vprod_castSucc [CommMonoid Œ±] {a : Fin (n + 1) ‚Üí Œ±} :
    vprod a = vprod (a ‚àò Fin.castSucc) * a (last n)

lemma IsBerlekampWelchSolution_def
  : IsBerlekampWelchSolution e k œâs f v
  ‚Üî Matrix.mulVec (BerlekampWelchMatrix e k œâs f) v = (Rhs e œâs f)

@[simp]
lemma elocPolyF_deg {œâs f : Fin n ‚Üí F} : (ElocPolyF œâs f p).natDegree = Œî‚ÇÄ(f, p.eval ‚àò œâs)

theorem liftContext_soundness [Inhabited InnerStmtOut]
    {outerLangIn : Set OuterStmtIn} {outerLangOut : Set OuterStmtOut}
    {innerLangIn : Set InnerStmtIn} {innerLangOut : Set InnerStmtOut}
    {soundnessError : ‚Ñù‚â•0}
    {lens : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut}
    (V : Verifier oSpec InnerStmtIn InnerStmtOut pSpec)
    -- TODO: figure out the right compatibility relation for the IsSound condition
    [lensSound : lens.IsSound outerLangIn outerLangOut innerLangIn innerLangOut
      (V.compatStatement lens)]
    (h : V.soundness init impl innerLangIn innerLangOut soundnessError) :
      (V.liftContext lens).soundness init impl outerLangIn outerLangOut soundnessError

theorem getBit_repr_univ {‚Ñì : Nat} : ‚àÄ j, j < 2^‚Ñì ‚Üí
  j = ‚àë k ‚àà Finset.univ (Œ±:=Fin ‚Ñì), (getBit k j) * 2^k.val

theorem divSum?_is_some_iff_lt_sum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {k : ‚Ñï} :
    (divSum? n k).isSome ‚Üî k < ‚àë i, n i

@[simp]
lemma Rhs_add_one : Rhs (e + 1) œâs f = fun i ‚Ü¶ Rhs e œâs f i * œâs i

private lemma sum_K_eq_card : ‚àë (Œ± : F), K B i Œ± = B.card

theorem peval_def (f : œÉ ‚Üí œÉ‚ÇÅ ‚äï œÉ‚ÇÇ) (x : œÉ‚ÇÅ ‚Üí R) (p : MvPolynomial œÉ R) :
    peval f x p = eval‚ÇÇ C (Sum.elim (fun i => C (x i)) X ‚àò f) p

@[to_additive /-- A variant of `Finset.add_sum_erase` with the addition swapped.--/]
theorem prod_mul_erase {Œ± Œ≤ : Type*} [CommMonoid Œ≤] [DecidableEq Œ±] (s : Finset Œ±) (f : Œ± ‚Üí Œ≤)
{a : Œ±} (h : a ‚àà s) : f a * (‚àè x ‚àà s.erase a, f x) = ‚àè x ‚àà s, f x

@[simp]
theorem fappend_succ {Œ± : Fin m ‚Üí A} {Œ≤ : Fin (n + 1) ‚Üí A}
    (u : (i : Fin m) ‚Üí F (Œ± i)) (v : (i : Fin (n + 1)) ‚Üí F (Œ≤ i)) :
    fappend u v = fconcat (fappend u (fun i => v (castSucc i))) (v (last n))

theorem reduction_perfectCompleteness (hInit : init.neverFails) :
    (reduction R deg D oSpec).perfectCompleteness init impl
      (inputRelation R deg D) (outputRelation R deg)

@[simp]
lemma erase_odd_empty :
    erase_odd ‚àÖ = ‚àÖ

@[simp]
theorem LeafData.optionComposeBuild_internal {Œ±} {s_left s_right : Skeleton}
    (left : LeafData Œ± s_left) (right : LeafData Œ± s_right)
    (compose : Œ± ‚Üí Œ± ‚Üí Option Œ±) :
    (LeafData.internal left right).optionComposeBuild compose =
      FullData.internal
        (Option.doubleBind compose
          (left.optionComposeBuild compose).getRootValue
          (right.optionComposeBuild compose).getRootValue)
        (left.optionComposeBuild compose)
        (right.optionComposeBuild compose)

omit [DecidableEq ùîΩq] hF‚ÇÇ h_Œ≤‚ÇÄ_eq_1 in
lemma get_sDomain_basis (i : Fin r) (h_i : i < ‚Ñì + R_rate) :
    ‚àÄ (k : Fin (‚Ñì + R_rate - i)),
    (sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate
      i (by omega)) k = eval (Œ≤ ‚ü®i + k.val, by omega‚ü©) (normalizedW ùîΩq Œ≤ i)

theorem last_nonzero_some_iff [LawfulBEq R] {p : UniPoly R} {k} :
  p.last_nonzero = some k ‚Üî (p[k] ‚â† 0 ‚àß (‚àÄ j, (hj : j < p.size) ‚Üí j > k ‚Üí p[j] = 0))

theorem add_comm : p + q = q + p

@[simp]
theorem fconcat_zero {Œ± : Fin 0 ‚Üí A} {Œ≤ : A} (a : F Œ≤) : !h‚¶ÉF‚¶Ñ‚ü®Œ±‚ü©[] :+ ∞ a =
  fun i => match i with

theorem dcast_fun {Œ≥ : (a : Œ±) ‚Üí Œ≤ a ‚Üí Sort*} {f : (b : Œ≤ a) ‚Üí Œ≥ a b} :
    f (dcast rfl b) = dcast (Œ± := Œ≤ a) (Œ≤ := Œ≥ a) dcast_eq.symm (f b)

theorem eqPolynomial_zeroOne (r : œÉ ‚Üí Fin 2) : (eqPolynomial r : MvPolynomial œÉ R) =
    ‚àè i : œÉ, if r i = 0 then 1 - X i else X i

@[simp]
lemma dotProduct_cons [AddCommMonoid R] [Mul R] (a : R) (b : Vector R n) (c : R) (d : Vector R n) :
  dotProduct (cons a b) (cons c d) = a * c + dotProduct b d

lemma coeff_vectors_linear_independent
  (‚Ñì : Nat) (h_‚Ñì : ‚Ñì ‚â§ r) :
    LinearIndependent L (toCoeffsVec (‚Ñì := ‚Ñì) ‚àò (basisVectors ùîΩq Œ≤ ‚Ñì h_‚Ñì))

theorem W_linearity (i : Fin r)
    : IsLinearMap ùîΩq (f := fun inner_p ‚Ü¶ (W ùîΩq Œ≤ i).comp inner_p)

theorem Nat.shiftRight_eq_sub_mod_then_div_two_pow {n lo_len : ‚Ñï} :
  n >>> lo_len = (n - n % 2 ^ lo_len) / 2 ^ lo_len

theorem fiberwise_dist_lt_imp_dist_lt_unique_decoding_radius (i : Fin ‚Ñì) (steps : ‚Ñï)
    [NeZero steps] (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
    (f : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i, by omega‚ü©)
  (h_fw_dist_lt : fiberwiseClose ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
    (i := i) (steps := steps) (h_i_add_steps := h_i_add_steps) (f := f)) :
  hammingClose ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i, by omega‚ü© f

theorem concrete_eq_zero_or_eq_one {k : ‚Ñï} {a : ConcreteBTField k} (h_k_zero : k = 0)
 : a = zero ‚à® a = one

@[simp]
theorem dcast_trans (h : a = a') (h' : a' = a'') :
    dcast h' (dcast h b) = dcast (h.trans h') b

@[simp]
lemma not_P_to_V_eq_V_to_P {x : Direction} (h : x ‚â† .V_to_P) : x = .P_to_V

lemma mul_by_2_def {s : Finset ‚Ñï} :
    mul_by_2 s = s.map ‚ü®fun n => 2 * n, by {
      intro a b
      simp
    }‚ü©

@[simp]
theorem Set.not_mem_language_iff {Œ± Œ≤} (rel : Set (Œ± √ó Œ≤)) (stmt : Œ±) :
    stmt ‚àâ rel.language ‚Üî ‚àÄ wit, (stmt, wit) ‚àâ rel

lemma BTField.cast_BTField_eq (k m : ‚Ñï) (h_eq : k = m) :
  BTField k = BTField m

private lemma f_convex {x‚ÇÅ x‚ÇÇ : ‚Ñö} {Œ±‚ÇÅ Œ±‚ÇÇ : ‚Ñö}
  (h_noneg_1 : 0 ‚â§ Œ±‚ÇÅ)
  (h_noneg_2 : 0 ‚â§ Œ±‚ÇÇ)
  (h_conv : Œ±‚ÇÅ + Œ±‚ÇÇ = 1)
  :
  f (Œ±‚ÇÅ * x‚ÇÅ + Œ±‚ÇÇ * x‚ÇÇ) ‚â§ Œ±‚ÇÅ * f x‚ÇÅ + Œ±‚ÇÇ * f x‚ÇÇ

@[simp]
theorem dflatten_two_eq_append {n : Fin 2 ‚Üí ‚Ñï} {motive : (k : Fin (vsum n)) ‚Üí Sort*}
    {v : (i : Fin 2) ‚Üí (j : Fin (n i)) ‚Üí motive (embedSum i j)} :
    dflatten (motive := motive) v = dappend (v 0) (v 1)

theorem reduction_completeness {Œµ : ‚Ñù‚â•0}
    (hRel : ‚àÄ stmtIn witIn, (stmtIn, witIn) ‚àà relIn ‚Üí
      [fun ‚ü®stmtOut, witOut‚ü© => (stmtOut, witOut) ‚àà relOut|do
        (simulateQ impl <| combineMap mapStmt mapWit ‚ü®stmtIn, witIn‚ü©).run' (‚Üê init)] ‚â• 1 - Œµ) :
    Reduction.completeness init impl relIn relOut (reduction mapStmt mapWit) Œµ

theorem knowledgeSoundness_implies_soundness (relIn : Set (StmtIn √ó WitIn))
    (relOut : Set (StmtOut √ó WitOut))
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    (knowledgeError : ‚Ñù‚â•0) (hLt : knowledgeError < 1) :
      knowledgeSoundness init impl relIn relOut verifier knowledgeError ‚Üí
        soundness init impl relIn.language relOut.language verifier knowledgeError

lemma towerRingHomForwardMap_join {k : ‚Ñï} (h_pos : k > 0) (hi lo : ConcreteBTField (k - 1)) :
  towerRingHomForwardMap (k:=k) („Ää hi, lo „Äã) =
    BinaryTower.join_via_add_smul (k:=k) (h_pos:=by omega)
      (hi_btf := towerRingHomForwardMap (k:=k-1) hi)
      (lo_btf := towerRingHomForwardMap (k:=k-1) lo)

lemma one_bitvec_shiftRight {d : ‚Ñï} (h_d : d > 0) : 1 >>> d = 0

@[simp]
lemma cons_eq_List.cons : x ::‚Çï xs = x :: xs

lemma list_0 : list 0 = List.Vector.cons (1 : GF(2)) List.Vector.nil

lemma concrete_mul_left_distrib
  {h_k : k > 0} (prevBTFieldProps : ConcreteBTFieldProps (k := k - 1))
  (a b c : ConcreteBTField k) :
    concrete_mul a (b + c) = concrete_mul a b + concrete_mul a c

theorem eq_zero_of_degreeOf_lt_card_of_eval_eq_zero {p : R[X œÉ]} (S : œÉ ‚Üí Finset R)
    (hDegree : ‚àÄ i, p.degreeOf i < #(S i))
    (hEval : ‚àÄ x ‚àà piFinset fun i ‚Ü¶ S i, eval x p = 0) : p = 0

@[simp]
lemma bIdx_mul_œë_add_i_fin_‚Ñì_pred_lt_‚Ñì (bIdx : Fin (‚Ñì / œë - 1)) (i : Fin (œë - 1))
    : ‚ÜëbIdx * œë + ‚Üëi < ‚Ñì

@[simp]
lemma natDegree_truncate [œÜ : NeZero n] : (truncate p n).natDegree < n

theorem fixFirstVariablesOfMQP_degreeLE {deg : ‚Ñï} (v : Fin (‚Ñì + 1)) {challenges : Fin v ‚Üí L}
    {poly : L[X Fin ‚Ñì]} (hp : poly ‚àà L‚¶É‚â§ deg‚¶Ñ[X Fin ‚Ñì]) :
    fixFirstVariablesOfMQP ‚Ñì v poly challenges ‚àà L‚¶É‚â§ deg‚¶Ñ[X Fin (‚Ñì - v)]

lemma inv_eq_pow (a : Field) (ha : a ‚â† 0) : a‚Åª¬π = a ^ (fieldSize - 2)

@[simp, grind =]
theorem leadingCoeffY_eq_zero (f : F[X][Y]) : leadingCoeffY f = 0 ‚Üî f = 0

@[simp]
lemma OracleVerifier.append_toVerifier
    (V‚ÇÅ : OracleVerifier oSpec Stmt‚ÇÅ OStmt‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : OracleVerifier oSpec Stmt‚ÇÇ OStmt‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ pSpec‚ÇÇ) :
      (OracleVerifier.append V‚ÇÅ V‚ÇÇ).toVerifier =
        Verifier.append V‚ÇÅ.toVerifier V‚ÇÇ.toVerifier

theorem degree_finSuccEquivNth {f : MvPolynomial (Fin (n + 1)) R} (h : f ‚â† 0) :
    (finSuccEquivNth R p f).degree = degreeOf p f

theorem mobius_apply_zeta_apply_eq_id (n : ‚Ñï) [NeZero n] (r : Fin n) (l : Fin (r.val + 1))
    (v : Vector R (2 ^ n)) : lagrangeToMono_segment n r l (monoToLagrange_segment n r l v) = v

theorem dcast_eq_dcast_iff (h : a = a'') (h' : a' = a'') :
    dcast h b = dcast h' b' ‚Üî b = dcast (h'.trans h.symm) b'

Nat.add_le_of_le_sub in Init.Data.Nat.Basic

theorem concrete_mul_eq
  (prevBTFieldProps : ConcreteBTFieldProps (k := k - 1))
  (a b : ConcreteBTField k) {a‚ÇÅ a‚ÇÄ b‚ÇÅ b‚ÇÄ : ConcreteBTField (k - 1)}
  (h_a : (a‚ÇÅ, a‚ÇÄ) = split h_k a) (h_b : (b‚ÇÅ, b‚ÇÄ) = split h_k b) :
  concrete_mul a b =
    „Ää concrete_mul a‚ÇÄ b‚ÇÅ + concrete_mul b‚ÇÄ a‚ÇÅ + concrete_mul (concrete_mul a‚ÇÅ b‚ÇÅ) (Z (k - 1)),
      concrete_mul a‚ÇÄ b‚ÇÄ + concrete_mul a‚ÇÅ b‚ÇÅ „Äã

theorem sum_join_via_add_smul (k : ‚Ñï) (h_pos : k > 0) (a‚ÇÅ a‚ÇÄ b‚ÇÅ b‚ÇÄ : BTField (k - 1)) :
  ‚ãò a‚ÇÅ, a‚ÇÄ ‚ãô + ‚ãò b‚ÇÅ, b‚ÇÄ ‚ãô = ‚ãò a‚ÇÅ + b‚ÇÅ, a‚ÇÄ + b‚ÇÄ ‚ãô

theorem frobenius_identity_in_algebra [Fact (Nat.Prime (ringChar Fq))]
  (f g : L[X]) : (f + g)^(Fintype.card Fq) = f^(Fintype.card Fq) + g^(Fintype.card Fq)

lemma bIdx_succ_mul_œë_le_‚Ñì_succ (bIdx : Fin (‚Ñì / œë - 1)) : (‚ÜëbIdx + 1) * œë ‚â§ ‚Ñì + 1

@[simp]
theorem dconcat_zero {motive : Fin 1 ‚Üí Sort u} (a : motive (last 0)) :
    !d‚ü®fun _ : Fin 0 => motive (castSucc _)‚ü©[] :+·µà‚ü®motive‚ü© a = !d‚ü®motive‚ü©[a]

theorem liftContext_runWithLogToRound
    {lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    {outerStmtIn : OuterStmtIn} {outerWitIn : OuterWitIn} {i : Fin (n + 1)}
    (P : Prover oSpec InnerStmtIn InnerWitIn InnerStmtOut InnerWitOut pSpec) :
      (P.liftContext lens).runWithLogToRound i outerStmtIn outerWitIn
      = do
        let ‚ü®‚ü®transcript, prvState‚ü©, queryLog‚ü© ‚Üê
          (P.runWithLogToRound i).uncurry (lens.proj (outerStmtIn, outerWitIn))
        return ‚ü®‚ü®transcript, ‚ü®prvState, outerStmtIn, outerWitIn‚ü©‚ü©, queryLog‚ü©

lemma testBit_false_eq_getBit_eq_0 (k n : Nat) :
  (n.testBit k = false) = ((Nat.getBit k n) = 0)

lemma W·µ¢_vanishing (i : Fin r) :
  ‚àÄ u ‚àà U ùîΩq Œ≤ i, (W ùîΩq Œ≤ i).eval u = 0

@[simp]
theorem Prover.runToRound_zero_of_prover_first
    (stmt : StmtIn) (wit : WitIn) (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      prover.runToRound 0 stmt wit = (pure (default, prover.input (stmt, wit)))

@[simp]
theorem vflatten_embedSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (v : (i : Fin m) ‚Üí Fin (n i) ‚Üí Œ±) (i : Fin m)
    (j : Fin (n i)) : vflatten v (embedSum i j) = v i j

theorem last_nonzero_spec [LawfulBEq R] {p : UniPoly R} {k} :
  p.last_nonzero = some k
  ‚Üí p[k] ‚â† 0 ‚àß (‚àÄ j, (hj : j < p.size) ‚Üí j > k ‚Üí p[j] = 0)

@[simp]
theorem eq_accepts (i : Fin numWires) (c : ùì°) (x : Fin numWires ‚Üí ùì°) :
    (eq i c).accepts x ‚Üî x i = c

@[simp]
lemma liftComp_support {Œπ' : Type w} {superSpec : OracleSpec Œπ'}
    [h : MonadLift (OracleQuery spec) (OracleQuery superSpec)]
    (oa : OracleComp spec Œ±) : (liftComp oa superSpec).support = oa.support

lemma mkLastOracleIndex_last : mkLastOracleIndex ‚Ñì œë (Fin.last ‚Ñì) = ‚Ñì / œë - 1

private lemma johnson_unrefined_by_M' [Zero F]
  (h_n : 0 < n)
  (h_B : 2 ‚â§ B.card)
  (h_card : 2 ‚â§ (Fintype.card F))
  :
  B.card * (Fintype.card F / (Fintype.card F - 1)) *
           ((1 - e B 0 / n) ^ 2  + e B 0 ^ 2 / ((Fintype.card F - 1) * n^2) - 1 + d B/n)
  ‚â§
  (Fintype.card F / (Fintype.card F - 1)) * d B/n

omit [DecidableEq L] [DecidableEq ùîΩq] hF‚ÇÇ hŒ≤_lin_indep h_Œ≤‚ÇÄ_eq_1 in
lemma intermediateNormVpoly_eval_is_linear_map (i : Fin (‚Ñì + 1)) (k : Fin (‚Ñì - i + 1)) :
  IsLinearMap ùîΩq (fun x : L =>
    (intermediateNormVpoly ùîΩq Œ≤ h_‚Ñì_add_R_rate i k).eval x)

@[simp]
theorem cast_dir_idx {hn} (hSpec : pSpec‚ÇÅ.cast hn = pSpec‚ÇÇ) {i : Fin n‚ÇÅ} :
    pSpec‚ÇÇ.dir (Fin.cast hn i) = pSpec‚ÇÅ.dir i

@[simp]
lemma length_nil : nil.length = 0

theorem foldOracleVerifier_rbrKnowledgeSoundness (i : Fin ‚Ñì) :
    (foldOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i).rbrKnowledgeSoundness init impl
      (relIn := roundRelation (mp := mp) ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        (ùìë := ùìë) i.castSucc)
      (relOut := foldStepRelOut (mp := mp) ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        (ùìë := ùìë) i)
      (foldKnowledgeError ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)

theorem coeff_eq_getElem_of_lt [LawfulBEq R] {p : UniPoly R} {i} (hi : i < p.size) :
  p.trim.coeff i = p[i]

theorem add_comm (m n : ChurchNat Œ±) : add m n = add n m

@[simp]
lemma coeff_truncate : (truncate p n).coeff k = if k < n then p.coeff k else 0

lemma getBit_of_middleBits {n offset len k : ‚Ñï} :
  getBit k (getMiddleBits offset len n) =
    if k < len then getBit (k + offset) n else 0

theorem fold_advances_evaluation_poly
  (i : Fin (‚Ñì)) (h_i_succ_lt : i + 1 < ‚Ñì + ùì°)
  (coeffs : Fin (2 ^ (‚Ñì - ‚Üëi)) ‚Üí L) (r_chal : L) :
  let P_i : L[X] := intermediateEvaluationPoly ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i, by
    exact Nat.lt_trans (n := i) (k := ‚Ñì+1) (m := ‚Ñì) (h‚ÇÅ := i.isLt) (by exact Nat.lt_add_one ‚Ñì)
  ‚ü©) coeffs
  let f_i

lemma wt_eq_zero_iff [Zero F] {v : Œπ ‚Üí F} :
  wt v = 0 ‚Üî Fintype.card Œπ = 0 ‚à® ‚àÄ i, v i = 0

Nat.zero_add in Init.Data.Nat.Basic

lemma lastBlockIdx_isNeCommitmentRound (i : Fin œë) :
    ¬¨isCommitmentRound ‚Ñì œë ‚ü®(‚Ñì / œë - 1) * œë + ‚Üëi, lastBlockIdx_mul_œë_add_fin_lt_‚Ñì i‚ü©

theorem singleton_bound_linear [CommRing F] [StrongRankCondition F]
    (LC : LinearCode Œπ F) :
    Module.finrank F LC ‚â§ card Œπ - (Code.dist LC.carrier) + 1

@[simp, grind] lemma C_pos : 0 < sz.C

@[simp]
theorem drop_all (v : (i : Fin n) ‚Üí Œ± i) :
    drop n n.le_refl v = fun i => Fin.elim0 (i.cast (Nat.sub_self n))

@[simp]
lemma toFun_invFun (f : ‚àÄ a, Œ≤ a) : inst.equiv.toFun (equiv.invFun f : F) = f

lemma concrete_mul_assoc0 (a b c : ConcreteBTField 0) :
  concrete_mul (concrete_mul a b) c = concrete_mul a (concrete_mul b c)

theorem prime_29 : Nat.Prime 29

@[simp]
theorem BTField.RingHom_comp_cast {Œ± Œ≤ Œ≥ Œ¥ : ‚Ñï} (f : BTField Œ± ‚Üí+* BTField Œ≤)
  (g : BTField Œ≤ ‚Üí+* BTField Œ≥) (h : Œ≥ = Œ¥) :
    ((cast (BTField.RingHom_eq_of_dest_eq (k:=Œ≤) (m:=Œ≥) (n:=Œ¥) h) g).comp f)
    = cast (BTField.RingHom_eq_of_dest_eq (k:=Œ±) (m:=Œ≥) (n:=Œ¥) h) (g.comp f)

@[csimp]
theorem dconcat_eq_snoc : @dconcat = @snoc

theorem hcons_injective2 {Œ± : Sort u} {Œ≤ : Fin n ‚Üí Sort u} :
    Function.Injective2 (@hcons n Œ± Œ≤)

theorem eq_zero_of_degreeOf_lt_card_of_eval_eq_zero_of_fin {n : ‚Ñï} {p : R[X Fin n]}
    (S : Fin n ‚Üí Finset R) (hDegree : ‚àÄ i, p.degreeOf i < (S i).card)
    (hEval : ‚àÄ x ‚àà piFinset fun i ‚Ü¶ S i, eval x p = 0) :
        p = 0

theorem funext‚ÇÇ_iff {Œ± : Sort u} {Œ≤ : Œ± ‚Üí Sort v} {Œ≥ : (a : Œ±) ‚Üí Œ≤ a ‚Üí Sort w}
    {f g : (a : Œ±) ‚Üí (b : Œ≤ a) ‚Üí Œ≥ a b} : f = g ‚Üî ‚àÄ a b, f a b = g a b

theorem vconcat_eq_snoc (v : Fin n ‚Üí Œ±) (a : Œ±) : vconcat v a = snoc v a

theorem append_perfectCompleteness (R‚ÇÅ : Reduction oSpec Stmt‚ÇÅ Wit‚ÇÅ Stmt‚ÇÇ Wit‚ÇÇ pSpec‚ÇÅ)
    (R‚ÇÇ : Reduction oSpec Stmt‚ÇÇ Wit‚ÇÇ Stmt‚ÇÉ Wit‚ÇÉ pSpec‚ÇÇ)
    (h‚ÇÅ : R‚ÇÅ.perfectCompleteness init impl rel‚ÇÅ rel‚ÇÇ)
    (h‚ÇÇ : R‚ÇÇ.perfectCompleteness init impl rel‚ÇÇ rel‚ÇÉ) :
      (R‚ÇÅ.append R‚ÇÇ).perfectCompleteness init impl rel‚ÇÅ rel‚ÇÉ

theorem trim_toImpl [LawfulBEq R] (p : R[X]) : p.toImpl.trim = p.toImpl

theorem hammingDist_le_of_outer_comp_injective {Œπ‚ÇÅ Œπ‚ÇÇ : Type*} [Fintype Œπ‚ÇÅ] [Fintype Œπ‚ÇÇ]
    {Œ≤ : Œπ‚ÇÇ ‚Üí Type*} [‚àÄ i, DecidableEq (Œ≤ i)] [DecidableEq Œπ‚ÇÇ]
    (x y : ‚àÄ i, Œ≤ i) (g : Œπ‚ÇÅ ‚Üí Œπ‚ÇÇ) (hg : Function.Injective g) :
    hammingDist (fun i => x (g i)) (fun i => y (g i)) ‚â§ hammingDist x y

private lemma k_and_e [Zero F]
  (h_n : n ‚â† 0)
  (h_B : B.card ‚â† 0)
  :
  k B = B.card * (n - e B 0) / n

theorem eq_trans {Œ± : Type u} (mx my mz : m Œ±) (hxy : eq mx my) (hyz : eq my mz) : eq mx mz

theorem cast_eq_cast_iff {Œ± Œ≤ Œ≥ : Sort u} {h : Œ± = Œ≥} {h' : Œ≤ = Œ≥} {a : Œ±} {b : Œ≤} :
    cast h a = cast h' b ‚Üî a = cast (h'.trans h.symm) b

lemma crs_equiv_rs_random_point_agreement
  {f : Œπ ‚Üí F} {m s : ‚Ñï} {œÜ : Œπ ‚Ü™ F} [Smooth œÜ] :
  ‚àÄ (r : Fin s ‚Üí Fin m ‚Üí F) (Œ¥ : ‚Ñù‚â•0) (hŒ¥Le : Œ¥ ‚â§ 1),
    (‚àÉ u u' : smoothCode œÜ m,
      u.val ‚â† u'.val ‚àß
      u.val ‚àà relHammingBall (smoothCode œÜ m) f Œ¥ ‚àß
      u'.val ‚àà relHammingBall (smoothCode œÜ m) f Œ¥ ‚àß
      ‚àÄ i : Fin s, (mVdecode u).eval (r i) = (mVdecode u').eval (r i))
    ‚Üî
    (‚àÉ œÉ : Fin s ‚Üí F,
      let w : Fin s ‚Üí MvPolynomial (Fin (m + 1)) F :=
        fun i => MvPolynomial.X (Fin.last m) * rename Fin.castSucc (eqPolynomial (r i))
      let multiCRSCode := multiConstrainedCode œÜ m s w œÉ
      ‚àÉ u u' : Œπ ‚Üí F, u ‚â† u' ‚àß
        u ‚àà relHammingBall multiCRSCode f Œ¥ ‚àß
        u' ‚àà relHammingBall multiCRSCode f Œ¥)

theorem zero_add (n : ChurchNat Œ±) : add zero n = n

theorem unique_linear_decomposition_succ (k : ‚Ñï) :
  ‚àÄ (x : BTField (k+1)), ‚àÉ! (p : BTField k √ó BTField k),
    x = ‚ãò p.1, p.2 ‚ãô

theorem monomialBasis_getElem {w : Vector R n} (i : Fin (2 ^ n)) :
    (monomialBasis w)[i] = ‚àè j : Fin n, if (BitVec.ofFin i).getLsb j then w[j] else 1

protected lemma elocPolyF_ne_zero {œâs f : Fin m ‚Üí F} :
  ElocPolyF œâs f p ‚â† 0

theorem sum_le_of_divSum?_eq_some {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {k : Fin (‚àë j, n j)} {i : Fin m}
    (hi : divSum? n k = some i) : ‚àë j : Fin i, n (castLE i.isLt.le j) ‚â§ k

@[simp]
theorem dflatten_one {n : Fin 1 ‚Üí ‚Ñï} {motive : (k : Fin (vsum n)) ‚Üí Sort*}
    {v : (i : Fin 1) ‚Üí (j : Fin (n i)) ‚Üí motive (embedSum i j)} :
    dflatten (motive := motive) v = v 0

theorem happend_assoc {Œ± : Fin m ‚Üí Sort u} {Œ≤ : Fin n ‚Üí Sort u} {p : ‚Ñï} {Œ≥ : Fin p ‚Üí Sort u}
    (u : (i : Fin m) ‚Üí Œ± i) (v : (i : Fin n) ‚Üí Œ≤ i) (w : (i : Fin p) ‚Üí Œ≥ i) :
    happend (happend u v) w =
      fun i => cast (by simp [vappend_assoc])
        (happend u (happend v w) (i.cast (by omega)))

theorem cast_processRound (j : Fin n‚ÇÅ)
    (P : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec‚ÇÅ)
    (currentResult : OracleComp (oSpec ++‚Çí [pSpec‚ÇÅ.Challenge]‚Çí)
      (Transcript j.castSucc pSpec‚ÇÅ √ó P.PrvState j.castSucc)) :
    P.processRound j currentResult =
      cast (sorry) ((P.cast hn hSpec).processRound (Fin.cast hn j) sorry)

lemma fintype_card_gt_one_of_field (K : Type*) [Field K] [Fintype K] :
  1 < Fintype.card K

theorem seqCompose_soundness
    (lang : (i : Fin (m + 1)) ‚Üí Set (Stmt i))
    (V : (i : Fin m) ‚Üí Verifier oSpec (Stmt i.castSucc) (Stmt i.succ) (pSpec i))
    (soundnessError : Fin m ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (V i).soundness init impl (lang i.castSucc) (lang i.succ) (soundnessError i)) :
      (Verifier.seqCompose Stmt V).soundness init impl (lang 0) (lang (Fin.last m))
        (‚àë i, soundnessError i)

theorem sum_Icc_split {Œ± : Type*} [AddCommMonoid Œ±] (f : ‚Ñï ‚Üí Œ±) (a b c : ‚Ñï)
    (h‚ÇÅ : a ‚â§ b) (h‚ÇÇ : b ‚â§ c):
    ‚àë i ‚àà Finset.Icc a c, f i = ‚àë i ‚àà Finset.Icc a b, f i + ‚àë i ‚àà Finset.Icc (b+1) c, f i

lemma erase_odd_def {s : Finset ‚Ñï} :
    erase_odd s = s.filter Even

@[simp]
theorem cast_idx_symm {i : ChallengeIdx pSpec‚ÇÇ} :
    pSpec‚ÇÅ.Challenge (i.cast hn.symm (cast_symm hSpec)) = pSpec‚ÇÇ.Challenge i

lemma HList.toDVec_eq_getValue (l : HList) (i : Fin l.length) : l.toDVec i = l.getValue i

lemma round_bound {n k : ‚Ñï} {s : Fin (k + 1) ‚Üí ‚Ñï+} {d : ‚Ñï+}
    (domain_size_cond : (2 ^ (‚àë i, (s i).1)) * d ‚â§ 2 ^ n) :
  (‚àë i, (s i).1) ‚â§ n

@[simp]
theorem erase_even_mem
  {s : Finset ‚Ñï}
  {n : ‚Ñï}
  : n ‚àà (erase_even s) ‚Üî Odd n ‚àß n ‚àà s

theorem cast_eq_dcast‚ÇÇ {V : Verifier oSpec StmtIn StmtOut pSpec‚ÇÅ} :
    V.cast hn hSpec = dcast‚ÇÇ hn hSpec V

lemma getBit_eq_pred_getBit_of_div_two {n k : ‚Ñï} (h_k: k > 0) :
    getBit k (n) = getBit (k-1) (n/2)

@[simp]
theorem dcons_zero {motive : Fin (n + 1) ‚Üí Sort u} (a : motive 0)
    (v : (i : Fin n) ‚Üí motive i.succ) : (a ::·µà‚ü®motive‚ü© v) 0 = a

theorem mul_one (n : ChurchNat Œ±) : mul n one = n

theorem johnson_bound_alphabet_free [Field F] [DecidableEq F]
  {B : Finset (Fin n ‚Üí F)}
  {v : Fin n ‚Üí F}
  {e : ‚Ñï}
  :
  let d := sInf { d | ‚àÉ u ‚àà B, ‚àÉ v ‚àà B, u ‚â† v ‚àß hammingDist u v = d }
  let q : ‚Ñö := Fintype.card F
  let frac := q / (q - 1)
  e ‚â§ n - ((n * (n - d)) : ‚Ñù).sqrt
  ‚Üí
  (B ‚à© ({ x | Œî‚ÇÄ(x, v) ‚â§ e } : Finset _)).card ‚â§ q * d * n

@[grind =] theorem findIdx'_cons {p : Œ± ‚Üí Bool} {x : Œ±} {xs : List Œ±} :
    findIdx' p (x :: xs) = bif p x then 0 else findIdx' p xs + 1

protected lemma errors_are_roots_of_elocPoly {i : ‚Ñï}
  (hi : i < n) (h : f i ‚â† p.eval (œâs i)) : (ElocPoly n œâs f p).eval (œâs i) = 0

Fin.eta in Init.Data.Fin.Lemmas

theorem intermediateNormVpoly_comp_qmap (i : Fin (‚Ñì))
    (k : Fin (‚Ñì - i - 1)) : -- corresponds to intermediateNormVpoly_comp

@[simp]
theorem LeafData.rightSubtree_internal {Œ±} {s_left s_right : Skeleton}
    (left : LeafData Œ± s_left) (right : LeafData Œ± s_right) :
    (LeafData.internal left right).rightSubtree = right

lemma eq_poly_deg_one {a b c d : F} {x‚ÇÅ x‚ÇÇ : F}
  (h1 : a + b * x‚ÇÅ = c + d * x‚ÇÅ)
  (h2 : a + b * x‚ÇÇ = c + d * x‚ÇÇ)
  (h1_2 : x‚ÇÅ ‚â† x‚ÇÇ) :
  Polynomial.C a + Polynomial.C b * Polynomial.X
    = Polynomial.C c + Polynomial.C d * Polynomial.X

@[simp] theorem join_cons : (l :: ls).join = l ++ ls.join

@[simp]
theorem Basis_cast_dest_apply {Œπ : Type*} (Œ± Œ≤ Œ≥ : ‚Ñï)
    (h_le1 : Œ± ‚â§ Œ≤) (h_le2 : Œ± ‚â§ Œ≥)
    (h_eq : Œ≤ = Œ≥) {k : Œπ} (b : @Basis Œπ (ConcreteBTField Œ±) (ConcreteBTField Œ≤) _ _
    (@ConcreteBTFieldAlgebra (l := Œ±) (r := Œ≤) (h_le := h_le1)).toModule) :
    let castBasis : @Basis Œπ (ConcreteBTField Œ±) (ConcreteBTField Œ≥) _ _
      (@ConcreteBTFieldAlgebra (l := Œ±) (r := Œ≥) (h_le := h_le2)).toModule :=
      cast (by
        exact Basis_cast_dest_eq Œ± Œ≥ Œ≤ h_le2 h_le1 h_eq
      ) b
    (castBasis k) = cast (by
      exact cast_ConcreteBTField_eq Œ≤ Œ≥ h_eq) (b k)

@[simp]
lemma rank_nonsquare_rows_eq_min (inj : Function.Injective Œ±) :
  (Vandermonde.nonsquare (Œπ' := n) Œ±).rank = min m n

omit [Finite F] in
lemma sqr_mem_D_succ_i_of_mem_D_i : ‚àÄ {a : FÀ£} {i : ‚Ñï},
    a ‚àà evalDomain D x i ‚Üí a ^ 2 ‚àà evalDomain D x (i + 1)

lemma eqRec_fun_eq_eqRec_sort {Œ± : Sort*} {Œ≤ : Œ± ‚Üí Sort u} {a a' : Œ±}
    (h : a = a') (h' : Œ≤ a = Œ≤ a') (b : Œ≤ a) :
  h ‚ñ∏ b = h' ‚ñ∏ b

private lemma K_eq_sum {Œ± : F} : K B i Œ± = ‚àë (x : B), if x.1 i = Œ± then 1 else 0

lemma getLowBits_joinBits {n m : ‚Ñï} (low : Fin (2 ^ n)) (high : Fin (2 ^ m)) :
  getLowBits n (joinBits low high).val = low.val

@[simp]
theorem oracleReduction_perfectCompleteness (hInit : init.neverFails) :
    (oracleReduction oSpec Statement OStatement Witness).perfectCompleteness init impl rel rel

@[simp]
theorem insertNth_removeNth : insertNth p y (removeNth p t) = update t p y

theorem init_dconcat {motive : Fin (n + 1) ‚Üí Sort u} (v : (i : Fin n) ‚Üí motive (castSucc i))
    (a : motive (last n)) : (fun i => (v :+·µà‚ü®motive‚ü© a) (castSucc i)) = v

@[simp]
theorem getRoot_single (a b : Œ±) :
    getRoot Œ± <$> buildMerkleTree Œ± 1 ‚ü®[a, b], rfl‚ü© = (query (spec := spec Œ±) () (a, b))

Nat.add_left_cancel in Init.Data.Nat.Basic

@[simp]
theorem eqPolynomial_eval_zeroOne (r x : œÉ ‚Üí Fin 2) :
    eval (x : œÉ ‚Üí R) (eqPolynomial r) = if x = r then 1 else 0

@[simp]
theorem dcons_succ {motive : Fin (n + 1) ‚Üí Sort u} (a : motive 0)
    (v : (i : Fin n) ‚Üí motive i.succ) (i : Fin n) : (a ::·µà‚ü®motive‚ü© v) i.succ = v i

lemma Oracle.containsCache_of_cache {Œπ : Type} {spec : OracleSpec Œπ}
    [(i : Œπ) ‚Üí Inhabited (OracleSpec.range spec i)]
    (cache : spec.QueryCache) :
    ‚àÉ (f : spec.FunctionType), Oracle.containsCache f cache

omit [Finite F] in
lemma dom_n_eq_triv : evalDomain D n = ‚ä•

lemma bIdx_succ_mul_œë_lt_‚Ñì_succ (bIdx : Fin (‚Ñì / œë - 1)) :
    (‚ÜëbIdx + 1) * œë < ‚Ñì + 1

theorem fconcat_right_injective {Œ± : Fin n ‚Üí A} {Œ≤ : A} (v : (i : Fin n) ‚Üí F (Œ± i)) :
    Function.Injective (fconcat v : F Œ≤ ‚Üí (i : Fin (n + 1)) ‚Üí F (vconcat Œ± Œ≤ i))

private lemma evenPart_eq_evenPart' {f : Polynomial F} : evenPart f = evenPart' f

@[simp]
theorem reduction_completeness (h : init.neverFails) [Nonempty œÉ] :
    (reduction oSpec Statement pred).perfectCompleteness init impl
    (relIn Statement pred) (relOut Statement)

lemma liftF_liftF'_of_lt (h : m < n) : liftF (liftF' (n := n) f) m = f m

@[simp]
lemma challengeOracleInterface_append_range_inr (j : pSpec‚ÇÇ.ChallengeIdx) :
    [(pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).Challenge]‚Çí.range (.inr j) = pSpec‚ÇÇ.Challenge j

@[simp]
lemma possibleDeltas_subset_relHammingDistRange :
  possibleDeltas U C ‚äÜ relHammingDistRange Œπ

theorem matchSize_comm (l‚ÇÅ : List Œ±) (l‚ÇÇ : List Œ±) (unit : Œ±) :
    matchSize l‚ÇÅ l‚ÇÇ unit = (matchSize l‚ÇÇ l‚ÇÅ unit).swap

lemma normalizedW_eq_qMap_composition (‚Ñì R_rate : ‚Ñï) (i : Fin r) :
    normalizedW ùîΩq Œ≤ i = qCompositionChain ùîΩq Œ≤ (‚Ñì:=‚Ñì) (R_rate:=R_rate) i

@[simp]
theorem card_univ_filter_eq {e : Œ±} :
  #{x : Œ± | x ‚â† e} = #(Finset.univ (Œ± := Œ±)) - 1

Fin.append_right in Mathlib.Data.Fin.Tuple.Basic

theorem distanceLE_mvPolynomial_degreeLE {œÉ : Type*} [Fintype œÉ] [DecidableEq œÉ] :
    distanceLE (R‚¶É‚â§ d‚¶Ñ[X œÉ]) (Fintype.card œÉ * d)

@[simp]
theorem shift_left_mem {s : Finset ‚Ñï} {d : ‚Ñï} : d ‚àà shift_left s ‚Üî (d + 1) ‚àà s

Fin.is_le' in Init.Data.Fin.Lemmas

Nat.le_add_left in Init.Data.Nat.Basic

@[simp]
theorem card_prod_self_eq :
  #(((s √óÀ¢ s : Finset _) ‚à© ({x : Œ± √ó Œ± | x.1 = x.2} : Finset _)) : Finset _) = #s

omit [Fintype L] [DecidableEq L] in
theorem Polynomial.foldl_comp (n : ‚Ñï) (f : Fin n ‚Üí L[X]) : ‚àÄ initInner initOuter: L[X],
    Fin.foldl (n:=n) (fun acc j => (f j).comp acc) (initOuter.comp initInner)
    = (Fin.foldl (n:=n) (fun acc j => (f j).comp acc) (initOuter)).comp initInner

lemma erase_even_def {s : Finset ‚Ñï} :
    erase_even s = s.filter Odd

@[simp]
theorem dist_le_card (C : Set (n ‚Üí R)) : dist C ‚â§ Fintype.card n

theorem liftContext_runToRound
    {lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    {outerStmtIn : OuterStmtIn} {outerWitIn : OuterWitIn} {i : Fin (n + 1)}
    (P : Prover oSpec InnerStmtIn InnerWitIn InnerStmtOut InnerWitOut pSpec) :
      (P.liftContext lens).runToRound i outerStmtIn outerWitIn
      = do
        let ‚ü®transcript, prvState‚ü© ‚Üê
          (P.runToRound i).uncurry (lens.proj (outerStmtIn, outerWitIn))
        return ‚ü®transcript, ‚ü®prvState, outerStmtIn, outerWitIn‚ü©‚ü©

protected lemma johnson_bound_lemma [Field F] {v : Fin n ‚Üí F}
  (h_n : 0 < n)
  (h_B : 2 ‚â§ B.card)
  (h_card : 2 ‚â§ (Fintype.card F))
  :
  B.card *
    ((1 - ((Fintype.card F : ‚Ñö) / (Fintype.card F - 1)) * (e B v / n)) ^ 2
      - (1 - ((Fintype.card F : ‚Ñö) / (Fintype.card F - 1)) * (d B/n)))  ‚â§
  ((Fintype.card F : ‚Ñö) / (Fintype.card F - 1)) * d B/n

@[coe]
theorem BTField_succ_eq_adjoinRoot (k : ‚Ñï) : AdjoinRoot (poly k) = BTField (k+1)

@[simp, grind =]
theorem monomialXY_eq_zero_iff {n m : ‚Ñï} {a : F} : monomialXY n m a = 0 ‚Üî a = 0

@[simp]
theorem hflatten_zero {n : Fin 0 ‚Üí ‚Ñï} {Œ± : (i : Fin 0) ‚Üí (j : Fin (n i)) ‚Üí Sort*}
    {v : (i : Fin 0) ‚Üí (j : Fin (n i)) ‚Üí Œ± i j} : hflatten v = !h[]

lemma aeval_eq' {A : Type y} [CommSemiring A] [Algebra R A] {F : Type z} [FunEquiv F œÉ A]
    (f : P ‚Üí‚Çê[R] A) (p : P) : f p = aeval (fun s => f (X s) : F) p

theorem dconcat_right_injective {motive : Fin (n + 1) ‚Üí Sort u}
    (v : (i : Fin n) ‚Üí motive (castSucc i)) :
    Function.Injective (dconcat (motive := motive) v)

theorem cast_injective : Function.Injective (MessageIdx.cast hn hSpec)

theorem succ'_ne_zero (n : Nat) : succ' n ‚â† 0

lemma nsmul_succ {k : ‚Ñï} (n : ‚Ñï) (x : ConcreteBTField k) :
  (if ‚Üën.succ % 2 = 0 then zero else x) = (if ‚Üën % 2 = 0 then zero else x) + x

theorem prime_13 : Nat.Prime 13

@[simp]
theorem vcons_fin_zero (a : Œ±) (v : Fin 0 ‚Üí Œ±) : a ::·µõ v = fun i => match i with

Fin.coe_castSucc in Init.Data.Fin.Lemmas

omit [SelectableType R] in
@[simp]
lemma oracleReduction_verifier_eq_verifier {i : Fin n} :
    (oracleReduction R n deg D oSpec i).verifier = oracleVerifier R n deg D oSpec i

theorem distEq_trans (mx my mz : OracleComp spec Œ±)
    (hxy : distEq mx my) (hyz : distEq my mz) : distEq mx mz

@[simp]
lemma ofPolynomialAlgHom_toPolynomialAlgHom_X :
    ofPolynomialAlgHom (toPolynomialAlgHom (X : P)) = (Polynomial.X : R[X])

theorem foldl_split_outer {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤ ‚Üí Œ±) (init : Œ±)
    (l : List Œ≤) (h : l ‚â† []): foldl (f:=f) (init:=init) (l)
    = f (foldl (f:=f) (init:=init) (l.dropLast)) (l.getLast (by omega))

lemma add_eq_zero_iff_eq {k : ‚Ñï} (a b : ConcreteBTField k) : a + b = 0 ‚Üî a = b

@[simp]
theorem dappend_zero {motive : Fin (m + 0) ‚Üí Sort u} (u : (i : Fin m) ‚Üí motive (castAdd 0 i)) :
    dappend (motive := motive) u !d‚ü®fun _ : Fin 0 => motive (natAdd m _)‚ü©[] = u

@[simp]
lemma dfoldlM'_zero {Œ± : Fin 1 ‚Üí Type u} (f : (i : Fin 0) ‚Üí Œ± i.castSucc ‚Üí m (Œ± i.succ)) (x : Œ± 0) :
    dfoldlM' 0 Œ± f x = pure x

@[grind]
lemma coeff_ne_zero {f q : F[X][Y]} (hg : q * f ‚â† 0) : q.coeff ‚â† 0

theorem PrattCertificate.out {p : ‚Ñï} (c : PrattCertificate p) : p.Prime

@[simp]
lemma OracleVerifier.id_rbrKnowledgeSoundness
    {rel : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness)} :
    (OracleVerifier.id : OracleVerifier oSpec Statement OStatement _ _ _).rbrKnowledgeSoundness
      init impl rel rel 0

theorem induction_init {n : ‚Ñï} {motive : Fin (n + 2) ‚Üí Sort*} {zero : motive 0}
    {succ : ‚àÄ i : Fin (n + 1), motive i.castSucc ‚Üí motive i.succ} {i : Fin (n + 1)} :
      induction (motive := motive) zero succ i.castSucc =
        induction (motive := Fin.init motive) zero (fun j x => succ j.castSucc x) i

theorem vcons_right_injective (a : Œ±) :
    Function.Injective (vcons a : (Fin n ‚Üí Œ±) ‚Üí Fin (n + 1) ‚Üí Œ±)

private lemma sum_choose_K' [Zero F]
  (h_card : 2 ‚â§ (Fintype.card F))
  :
  (Fintype.card (Œ± := F) - 1) * choose_2 ((B.card - K B i 0) / (Fintype.card (Œ± := F) - 1)) ‚â§
  ‚àë (Œ± : F) with Œ± ‚â† 0, choose_2 (K B i Œ±)

theorem completeness_error_mono {Œµ‚ÇÅ Œµ‚ÇÇ : ‚Ñù‚â•0} (hŒµ : Œµ‚ÇÅ ‚â§ Œµ‚ÇÇ) :
      completeness init impl relIn relOut reduction Œµ‚ÇÅ ‚Üí
        completeness init impl relIn relOut reduction Œµ‚ÇÇ

@[simp]
lemma evalDist_cast (h : Œ± = Œ≤) [spec.FiniteRange] :
    evalDist (cast (congrArg (OracleComp spec) h) oa) =
      cast (congrArg (PMF ‚àò Option) h) (evalDist oa)

theorem evenRefinement_eq_novel_poly_of_0_leading_suffix (i : Fin ‚Ñì) (v : Fin (2 ^ i.val))
    (original_coeffs : Fin (2 ^ ‚Ñì) ‚Üí L) :
    have h_v: v.val < 2 ^ (i.val + 1) := by
      calc v.val < 2 ^ i.val := by omega
        _ < 2 ^ (i.val + 1) := by apply Nat.pow_lt_pow_right (by omega) (by omega)
    evenRefinement ùîΩq Œ≤ h_‚Ñì_add_R_rate i (coeffsBySuffix (r:=r)
      (R_rate:=R_rate) (a:=original_coeffs) ‚ü®i, by omega‚ü© v) =
    intermediateEvaluationPoly ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i + 1, by omega‚ü©
      (coeffsBySuffix (r:=r) (R_rate:=R_rate) original_coeffs ‚ü®i + 1, by omega‚ü© ‚ü®v, h_v‚ü©)

theorem srKnowledgeSoundness_addSalt_implies_srKnowledgeSoundness_original
    (relIn : Set (StmtIn √ó WitIn)) (relOut : Set (StmtOut √ó WitOut))
    (Salt : pSpec.MessageIdx ‚Üí Type) [‚àÄ i, Nonempty (Salt i)] [‚àÄ i, Fintype (Salt i)]
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    (srInit : ProbComp (srChallengeOracle StmtIn (pSpec.addSalt Salt)).FunctionType)
    (srImpl : QueryImpl oSpec
      (StateT (srChallengeOracle StmtIn (pSpec.addSalt Salt)).FunctionType ProbComp))
    (srKnowledgeError : ‚Ñù‚â•0) :
      Verifier.StateRestoration.knowledgeSoundness srInit srImpl relIn relOut
        (verifier.addSalt Salt) srKnowledgeError ‚Üí
        Verifier.StateRestoration.knowledgeSoundness sorry sorry relIn relOut
          verifier srKnowledgeError

@[simp]
theorem minPoly_of_powerBasisSucc_generator (k : ‚Ñï) :
  (minpoly (BTField k) (powerBasisSucc k).gen) = X^2 + (Z k) ‚Ä¢ X + 1

theorem evalWAt_eq_W (i : Fin r) (x : L) :
  evalWAt (Œ≤ := Œ≤) (‚Ñì := ‚Ñì) (R_rate := R_rate) (i := i) x =
    (W (ùîΩq := ùîΩq) (Œ≤ := Œ≤) (i := i)).eval x

lemma deevenize_evenize {f : Polynomial F} :
    deevenize (evenize f) = f

lemma coeff_eq_getElem {p : UniPoly Q} {i} (hp : i < p.size) :
  p.coeff i = p[i]

lemma liftF'_liftF_of_lt {k : Fin m} (h : k < n) :
  liftF' (n := m) (liftF (n := n) f') k = f' ‚ü®k, by omega‚ü©

theorem append_rbrKnowledgeSoundness (V‚ÇÅ : OracleVerifier oSpec Stmt‚ÇÅ OStmt‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : OracleVerifier oSpec Stmt‚ÇÇ OStmt‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ pSpec‚ÇÇ)
    {rbrKnowledgeError‚ÇÅ : pSpec‚ÇÅ.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    {rbrKnowledgeError‚ÇÇ : pSpec‚ÇÇ.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    (h‚ÇÅ : V‚ÇÅ.rbrKnowledgeSoundness init impl rel‚ÇÅ rel‚ÇÇ rbrKnowledgeError‚ÇÅ)
    (h‚ÇÇ : V‚ÇÇ.rbrKnowledgeSoundness init impl rel‚ÇÇ rel‚ÇÉ rbrKnowledgeError‚ÇÇ) :
      (V‚ÇÅ.append V‚ÇÇ).rbrKnowledgeSoundness init impl rel‚ÇÅ rel‚ÇÉ
        (Sum.elim rbrKnowledgeError‚ÇÅ rbrKnowledgeError‚ÇÇ ‚àò ChallengeIdx.sumEquiv.symm)

lemma sDomain_card (i : Fin r) (h_i : i < ‚Ñì + R_rate) :
    Fintype.card (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i) = (Fintype.card ùîΩq)^(‚Ñì + R_rate - i)

lemma getBit_eq_zero_or_one {k n : Nat} :
  getBit k n = 0 ‚à® getBit k n = 1

@[simp]
theorem FullData.map_leaf {Œ± Œ≤} (f : Œ± ‚Üí Œ≤) (a : Œ±) :
    (FullData.leaf a).map f = FullData.leaf (f a)

lemma wt_eq_hammingNorm [Zero F] {v : Œπ ‚Üí F} :
  wt v = hammingNorm v

theorem MLE_mem_restrictDegree (evals : (œÉ ‚Üí Fin 2) ‚Üí R) : (MLE evals) ‚àà R‚¶É‚â§ 1‚¶Ñ[X œÉ]

@[simp]
theorem seqCompose_succ_eq_append {m : ‚Ñï} {n : Fin (m + 1) ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    {T : ‚àÄ i, FullTranscript (pSpec i)} :
    seqCompose T = append (T 0) (seqCompose (fun i => T (Fin.succ i)))

lemma getBit_zero_eq_self {n : ‚Ñï} (h_n : n < 2) : getBit 0 n = n

lemma evenize_is_even {f : Polynomial F} :
    EvenPoly (evenize f)

theorem vcons_inj (a b : Œ±) (v w : Fin n ‚Üí Œ±) : a ::·µõ v = b ::·µõ w ‚Üî a = b ‚àß v = w

@[simp]
lemma range_def : (spec Œ±).range () = Œ±

theorem iterated_fold_eq_matrix_form (i : Fin ‚Ñì) (steps : ‚Ñï) (h_i_add_steps : i + steps ‚â§ ‚Ñì)
    (f : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®i, by omega‚ü© ‚Üí L)
    (r_challenges : Fin steps ‚Üí L)
    (y : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®‚Üëi + steps, by omega‚ü©) :
    (iterated_fold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (steps := ‚ü®steps, by apply Nat.lt_succ_of_le; exact Nat.le_of_add_left_le h_i_add_steps‚ü©)
      (i := ‚ü®i, by omega‚ü©)
      (h_i_add_steps := by simp only; exact fin_‚Ñì_steps_lt_‚Ñì_add_R i steps h_i_add_steps) f
      r_challenges ‚ü®y, by exact Submodule.coe_mem y‚ü©) =
    localized_fold_eval ùîΩq Œ≤ i (steps := steps) (h_i_add_steps := h_i_add_steps) f
      r_challenges (y := ‚ü®y, by exact Submodule.coe_mem y‚ü©)

@[simp]
theorem FullData.toLeafData_leaf {Œ±} (a : Œ±) :
    (FullData.leaf a).toLeafData = LeafData.leaf a

lemma poly_natDegree_eq_2 (k : ‚Ñï) : (poly (k:=k)).natDegree = 2

theorem prime_2 : Nat.Prime 2

omit [DecidableEq L] [DecidableEq ùîΩq] h_Fq_char_prime hF‚ÇÇ hŒ≤_lin_indep h_Œ≤‚ÇÄ_eq_1 in
theorem intermediateNormVpoly_comp (i : Fin ‚Ñì) (k : Fin (‚Ñì - i + 1))
  (l : Fin (‚Ñì - (i.val + k.val) + 1)) :
  intermediateNormVpoly ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i, by omega‚ü©) (k:=‚ü®k + l, by
      simp only; omega‚ü©) =
    (intermediateNormVpoly ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i+k, by omega‚ü©) (k:=‚ü®l, by
      simp only; omega‚ü©)).comp (
  intermediateNormVpoly ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i, by omega‚ü©) (k:=‚ü®k, by
      simp only; omega‚ü©)
  )

theorem is_unit_iff_deg_0 {R : Type*} [Field R] {p : R[X]} : p.degree = 0 ‚Üî IsUnit p

@[simp]
theorem splitSum_zero {n : Fin 0 ‚Üí ‚Ñï} {k : Fin (vsum n)} : splitSum k = Fin.elim0 k

theorem oracleVerifier_toVerifier_run {stmt : Statement} {oStmt : ‚àÄ i, OStatement i}
    {tr : (oraclePSpec Witness).FullTranscript} :
    (oracleVerifier oSpec Statement OStatement Witness).toVerifier.run ‚ü®stmt, oStmt‚ü© tr =
      pure ‚ü®stmt, Sum.rec oStmt (fun i => match i with | 0 => tr 0)‚ü©

theorem SkeletonNodeIndex.leftChild_bind_parent {s : Skeleton}
    (idx : SkeletonNodeIndex s) :
    idx.leftChild >>= parent = idx.leftChild.map (fun _ => idx)

theorem cast_injective : Function.Injective (ChallengeIdx.cast hn hSpec)

lemma definingPoly_coeffOf0 {F : Type*} [Field F] [Fintype F] (s : F) [NeZero s] :
    (definingPoly s).coeff 0 = 1

@[simp]
theorem distFromCode_of_empty (u : n ‚Üí R) : Œî‚ÇÄ(u, (‚àÖ : Set (n ‚Üí R))) = ‚ä§

theorem frobenius_identity_in_ground_field
  [Fact (Nat.Prime (ringChar Fq))] (f g : Fq[X]) :
    (f + g)^(Fintype.card Fq) = f^(Fintype.card Fq) + g^(Fintype.card Fq)

lemma qMap_total_fiber_basis_sum_repr (i : Fin ‚Ñì) (steps : ‚Ñï) (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
    (y : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) (i := ‚ü®i + steps, by omega‚ü©))
    (k : Fin (2 ^ steps)) :
    let x : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i, by omega‚ü©) := qMap_total_fiber ùîΩq Œ≤
      (i := ‚ü®i, by omega‚ü©) (steps := steps) (h_i_add_steps := by
        apply Nat.lt_add_of_pos_right_of_le; omega) (y := y) (k)
    let basis_x := sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i, by omega‚ü©
      (by simp only; apply Nat.lt_add_of_pos_right_of_le; omega)
    let basis_y := sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i + steps, by omega‚ü©
      (h_i := by apply Nat.lt_add_of_pos_right_of_le; omega)
    let y_coeffs := basis_y.repr y
    x = ‚àë j : Fin (‚Ñì + ùì° - i), (
      fiber_coeff (i := i) (steps := steps) (j := j) (elementIdx := k) (y_coeffs := y_coeffs)
    ) ‚Ä¢ (basis_x j)

theorem canonical_nonempty_iff [LawfulBEq R] {p : UniPoly R} (hp : p.size > 0) :
  p.trim = p ‚Üî p.last_nonzero = some ‚ü® p.size - 1, Nat.pred_lt_self hp ‚ü©

theorem linear_map_of_comp_to_linear_map_of_eval (f : L[X])
  (h_f_linear : IsLinearMap (R := Fq) (M := L[X]) (M‚ÇÇ := L[X])
    (f := fun inner_p ‚Ü¶ f.comp inner_p)) :
    IsLinearMap (R := Fq) (M := L) (M‚ÇÇ := L) (f := fun x ‚Ü¶ f.eval x)

theorem fcons‚ÇÇ_left_injective {Œ±‚ÇÅ : A} {Œ±‚ÇÇ : B} {Œ≤‚ÇÅ : Fin n ‚Üí A} {Œ≤‚ÇÇ : Fin n ‚Üí B}
    (b : (i : Fin n) ‚Üí F‚ÇÇ (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) :
    Function.Injective (fun a : F‚ÇÇ Œ±‚ÇÅ Œ±‚ÇÇ => fcons‚ÇÇ (F := F‚ÇÇ) a b)

lemma evenize_eval {f : Polynomial F} {s : F} :
    (evenize f).eval s = f.eval (s * s)

Nat.lt_of_le_of_lt in Init.Prelude

lemma rank_eq_if_subUpFull_eq (h : n ‚â§ m) :
   (subUpFull U (Fin.castLE h)).rank = n  ‚Üí U.rank = n

theorem happend_right_eq_hconcat {Œ± : Fin m ‚Üí Sort u} {Œ≤ : Fin 1 ‚Üí Sort u}
    (u : (i : Fin m) ‚Üí Œ± i) (a : (i : Fin 1) ‚Üí Œ≤ i) :
    happend u a = hconcat u (a 0)

@[simp]
theorem BTField.Basis_cast_dest_apply {Œπ : Type*} (Œ± Œ≤ Œ≥ : ‚Ñï) (h_le1 : Œ± ‚â§ Œ≤) (h_le2 : Œ± ‚â§ Œ≥)
    (h_eq : Œ≤ = Œ≥) {k : Œπ} (b : @Basis Œπ (BTField Œ±) (BTField Œ≤) _ _
    (@binaryAlgebraTower (l := Œ±) (r := Œ≤) (h_le := h_le1)).toModule) :
    let castBasis : @Basis Œπ (BTField Œ±) (BTField Œ≥) _ _
      (@binaryAlgebraTower (l := Œ±) (r := Œ≥) (h_le := h_le2)).toModule :=
      cast (by
        exact Basis_cast_dest_eq Œ± Œ≥ Œ≤ h_le2 h_le1 h_eq
      ) b
    (castBasis k) = cast (by exact BTField.cast_BTField_eq Œ≤ Œ≥ h_eq) (b k)

lemma irreducible_factorization_of_gs_solution
  {k : ‚Ñï}
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ) :
  ‚àÉ (C : F[Z][X]) (R : List F[Z][X][Y]) (f : List ‚Ñï) (e : List ‚Ñï),
    R.length = f.length ‚àß
    f.length = e.length ‚àß
    ‚àÄ e·µ¢ ‚àà e, 1 ‚â§ e·µ¢ ‚àß
    ‚àÄ R·µ¢ ‚àà R, R·µ¢.Separable ‚àß
    ‚àÄ R·µ¢ ‚àà R, Irreducible R·µ¢ ‚àß
    Q = (Polynomial.C C) *
        ‚àè (R·µ¢ ‚àà R.toFinset) (f·µ¢ ‚àà f.toFinset) (e·µ¢ ‚àà e.toFinset),
          (R·µ¢.comp ((Y : F[Z][X][Y]) ^ f·µ¢))^e·µ¢

@[simp]
lemma eval‚ÇÇ_C' {r : R} {S : Type w} [CommSemiring S] (f : R ‚Üí+* S) (x : S) :
    eval‚ÇÇ (P := P) f x (C r) = f r

Nat.add_sub_cancel in Init.Data.Nat.Basic

theorem dconcat_dcons_eq_dcons_dconcat {motive : Fin (n + 2) ‚Üí Sort u} (a : motive 0)
    (v : (i : Fin n) ‚Üí motive (succ (castSucc i))) (b : motive (last (n + 1))) :
    (a ::·µà v) :+·µà‚ü®motive‚ü© b = a ::·µà‚ü®motive‚ü© (v :+·µà b)

lemma gamma_eq_P
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  :
  Œ≥' x‚ÇÄ (R k Œ¥ x‚ÇÄ h_gs) (irreducible_H k (x‚ÇÄ := x‚ÇÄ) (Œ¥ := Œ¥) h_gs) =
  AppendixA.polyToPowerSeriesùïÉ _ 
    (P k Œ¥ x‚ÇÄ h_gs)

@[simp]
theorem bool_accepts_iff_of_domain [IsDomain ùì°] :
    (bool j).accepts x ‚Üî x j = 0 ‚à® x j = 1

@[simp]
theorem generator_is_not_lifted_to_succ (k : ‚Ñï) :
  ‚àÄ x : ConcreteBTField k, canonicalAlgMap (k:=k) x ‚â† Z (k + 1)

lemma approximate_solution_is_exact_solution_coeffs'
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  :
    Œ≥' x‚ÇÄ (R k Œ¥ x‚ÇÄ h_gs) (irreducible_H k h_gs) =
        PowerSeries.mk (fun t =>
          if t ‚â• k
          then (0 : AppendixA.ùïÉ (H k Œ¥ x‚ÇÄ h_gs))
          else PowerSeries.coeff _ t
            (Œ≥' 
              x‚ÇÄ
              (R k (x‚ÇÄ := x‚ÇÄ) (Œ¥ := Œ¥) h_gs)
              (irreducible_H k h_gs)))

theorem non_zero_divisors_iff (M‚ÇÄ : Type*) [Mul M‚ÇÄ] [Zero M‚ÇÄ] :
    NoZeroDivisors M‚ÇÄ ‚Üî ‚àÄ {a b : M‚ÇÄ}, a * b = 0 ‚Üí a = 0 ‚à® b = 0

lemma X‚±º_zero_eq_one (‚Ñì : ‚Ñï) (h_‚Ñì : ‚Ñì ‚â§ r) :
  X‚±º ùîΩq Œ≤ ‚Ñì h_‚Ñì ‚ü®0, by exact Nat.two_pow_pos ‚Ñì‚ü© = 1

lemma one_is_1 {k : ‚Ñï} : (one (k:=k)) = 1

lemma getBit_of_highBits_no_shl {n: ‚Ñï} (numLowBits : ‚Ñï) :
    ‚àÄ k, getBit k (getHighBits_no_shl numLowBits n)
  = getBit (k + numLowBits) (n)

@[simp]
private lemma leadingCoeff_E : (E œâs f p e).leadingCoeff = 1

lemma powerBasisSucc_gen (k : ‚Ñï) :
  (powerBasisSucc k).gen = (Z (k+1))

@[simp]
lemma dfoldr'_zero {Œ± : Fin 1 ‚Üí Type u}
    (f : (i : Fin 0) ‚Üí Œ± i.succ ‚Üí Œ± i.castSucc) (x : Œ± (last 0)) :
    dfoldr' 0 Œ± f x = x

lemma full_row_rank_via_rank_subLeftFull (h : m ‚â§ n) :
   (subLeftFull U (Fin.castLE h)).rank = m ‚Üí U.rank = m

theorem iteratedQuotientMap_k_eq_1_is_qMap (i : Fin ‚Ñì)
    (h_i_add_1 : i.val + 1 ‚â§ ‚Ñì) (x : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®i, by omega‚ü©) :
    iteratedQuotientMap ùîΩq Œ≤ h_‚Ñì_add_R_rate i 1 h_i_add_1 x =
    ‚ü®(qMap ùîΩq Œ≤ ‚ü®i.val, by omega‚ü©).eval (x.val : L),
      qMap_eval_mem_sDomain_succ ùîΩq Œ≤   h_‚Ñì_add_R_rate i h_i_add_1 x‚ü©

lemma iterated_fold_transitivity
    (i : Fin r) (steps‚ÇÅ steps‚ÇÇ : Fin (‚Ñì + 1))
    (h_bounds : i.val + steps‚ÇÅ + steps‚ÇÇ ‚â§ ‚Ñì) -- A single, sufficient bounds check
    (f : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := i) ‚Üí L)
    (r_challenges‚ÇÅ : Fin steps‚ÇÅ ‚Üí L) (r_challenges‚ÇÇ : Fin steps‚ÇÇ ‚Üí L) :
    -- LHS : The nested fold (folding twice)
    have hi1 : i.val + steps‚ÇÅ ‚â§ ‚Ñì := by exact le_of_add_right_le h_bounds
    have hi2 : i.val + steps‚ÇÇ ‚â§ ‚Ñì := by
      rw [Nat.add_assoc, Nat.add_comm steps‚ÇÅ steps‚ÇÇ, ‚ÜêNat.add_assoc] at h_bounds
      exact le_of_add_right_le h_bounds
    have hi12 : steps‚ÇÅ + steps‚ÇÇ < ‚Ñì + 1 := by
      apply Nat.lt_succ_of_le; rw [Nat.add_assoc] at h_bounds;
      exact Nat.le_of_add_left_le h_bounds
    let lhs := iterated_fold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (i := ‚ü®i.val + steps‚ÇÅ, by -- ‚ä¢ ‚Üëi + ‚Üësteps‚ÇÅ < r
        apply Nat.lt_of_le_of_lt (m := ‚Ñì) (hi1) (‚Ñì_lt_r (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))‚ü©)
      (steps := steps‚ÇÇ)
      (h_i_add_steps := by simp only; apply Nat.lt_add_of_pos_right_of_le; exact h_bounds)
      (f := by
        exact iterated_fold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := i) (steps := steps‚ÇÅ)
          (h_i_add_steps := by apply Nat.lt_add_of_pos_right_of_le; exact hi1) (f := f)
          (r_challenges := r_challenges‚ÇÅ)
      ) r_challenges‚ÇÇ
    let rhs := iterated_fold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := i)
      (steps := ‚ü®steps‚ÇÅ + steps‚ÇÇ, hi12‚ü©)
      (h_i_add_steps := by
        simp only; rw [‚ÜêNat.add_assoc]; apply Nat.lt_add_of_pos_right_of_le; exact h_bounds)
      (f := f) (r_challenges := Fin.append r_challenges‚ÇÅ r_challenges‚ÇÇ)
    lhs = by
      simp only [‚ÜêNat.add_assoc] at ‚ä¢ rhs
      exact rhs

theorem runWithOracle_succeeds_iff_simulateQ_randomOracle_neverFails
     {Œ≤}
    [DecidableEq Œπ] [spec.DecidableEq] [(i : Œπ) ‚Üí SelectableType (OracleSpec.range spec i)]
    (oa : OracleComp (spec) Œ≤) (f : spec.FunctionType) :
    (runWithOracle f oa).isSome ‚Üî
    ((oa.simulateQ randomOracle).run (fun i q => some (f i q))).neverFails

@[simp]
theorem induction_two' {motive : Fin 3 ‚Üí Sort*} {zero : motive 0}
    {succ : ‚àÄ i : Fin 2, motive i.castSucc ‚Üí motive i.succ} :
      induction (motive := motive) zero succ (2 : Fin 3) = succ 1 (succ 0 zero)

@[simp]
theorem bool_accepts_iff : (bool j).accepts x ‚Üî x j * (x j - 1) = 0

@[simp]
theorem embedSum_succ_succ {n : Fin (m + 1) ‚Üí ‚Ñï} {i : Fin m} (j : Fin (n i.succ)) :
    embedSum (i.succ) j = Fin.natAdd _ (embedSum i j)

@[simp]
lemma List.get_nil (i : Fin 0) (a : Œ±) : [].get i = a

lemma sum_eq_xor_plus_twice_and (n : Nat) : ‚àÄ m : ‚Ñï, n + m = (n ^^^ m) + 2 * (n &&& m)

theorem singleEqPolynomial_zeroOne (r : Fin 2) (x : MvPolynomial œÉ R) :
    singleEqPolynomial (r : R) x = if r = 0 then 1 - x else x

protected lemma errors_are_roots_of_elocPolyF {i : Fin n} {œâs f : Fin n ‚Üí F}
  (h : f i ‚â† p.eval (œâs i)) : (ElocPolyF œâs f p).eval (œâs i) = 0

private lemma roots_of_unity_lem {s : Fin (k + 1) ‚Üí ‚Ñï+} {i : Fin (k + 1)}
    (k_le_n : (‚àë j', (s j').1) ‚â§ n) :
  (‚àë j' ‚àà finRangeTo i.1, (s j').1) ‚â§ n - (s i).1

@[simp]
protected lemma elocPoly_one :
  ElocPoly 1 œâs f p = if f 0 ‚â† p.eval (œâs 0) then X - (C (œâs 0)) else 1

theorem distFromCode_eq_top_iff_empty (u : n ‚Üí R) (C : Set (n ‚Üí R)) : Œî‚ÇÄ(u, C) = ‚ä§ ‚Üî C = ‚àÖ

@[simp]
theorem OracleVerifier.run_eq_run_verifier [O‚Çò : ‚àÄ i, OracleInterface (pSpec.Message i)]
    {stmt : StmtIn} {oStmt : ‚àÄ i, OStmtIn i} {transcript : FullTranscript pSpec}
    {verifier : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec} :
      verifier.run stmt oStmt transcript =
        verifier.toVerifier.run ‚ü®stmt, oStmt‚ü© transcript

@[simp]
theorem bit_revFinProdFinEquiv_symm_2_pow_succ {n : ‚Ñï} (j : Fin (2 ^ (n + 1))) (i : Fin (n + 1)):
  let e : Fin (2 ^ n * 2) ‚âÉ Fin (2 ^ n) √ó Fin 2 :=revFinProdFinEquiv (m:=2^(n)) (n:=2)
    (h_m:=by exact Nat.two_pow_pos n).symm
  let msb : Fin 2 := (e j).2
  let lsbs : Fin (2 ^ n) := (e j).1
  Nat.getBit (i) j = if i.val < n then Nat.getBit (i.val) lsbs else msb

@[simp]
theorem seqCompose_succ_eq_append {m : ‚Ñï} {n : Fin (m + 1) ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)} :
    seqCompose pSpec = append (pSpec 0) (seqCompose (fun i => pSpec (Fin.succ i)))

lemma vappend_left_of_lt {m n : ‚Ñï} {Œ± : Sort u}
    (u : Fin m ‚Üí Œ±) (v : Fin n ‚Üí Œ±) (i : Fin (m + n)) (h : i.val < m) :
      vappend u v i = u ‚ü®i, h‚ü©

@[simp]
theorem reduction_completeness (h : init.neverFails) :
    (reduction oSpec Statement Witness).perfectCompleteness init impl relIn (toRelOut relIn)

@[simp]
theorem init_update_castSucc : init (update s i.castSucc y) = update (init s) i y

@[simp]
theorem drop_apply (m : ‚Ñï) (h : m ‚â§ n) (v : (i : Fin n) ‚Üí Œ± i) (i : Fin (n - m)) :
    (drop m h v) i = v (Fin.cast (Nat.sub_add_cancel h) (addNat i m))

lemma extract_stop_last_eq_drop {n : ‚Ñï} {Œ± : Fin n ‚Üí Sort*} (start : ‚Ñï) (h : start ‚â§ n)
    (v : (i : Fin n) ‚Üí Œ± i) : extract start n h (Nat.le_refl _) v = drop start h v

theorem neg_add_cancel : -p + p = 0

theorem cast_eq_dcast {h : n‚ÇÅ = n‚ÇÇ} {pSpec : ProtocolSpec n‚ÇÅ} :
    pSpec.cast h = dcast h pSpec

theorem novelToMonomial_monomialToNovel_inverse
  (‚Ñì : ‚Ñï) (h_‚Ñì : ‚Ñì ‚â§ r) :
  ‚àÄ coeffs : Fin (2^‚Ñì) ‚Üí L,
    monomialToNovelCoeffs ùîΩq Œ≤ ‚Ñì h_‚Ñì
      (novelToMonomialCoeffs ùîΩq Œ≤ ‚Ñì h_‚Ñì coeffs) = coeffs

@[simp]
lemma E_and_Q_to_a_solution_coeff
  : E_and_Q_to_a_solution e E Q i = if i < e then E.coeff i else Q.coeff (i - e)

@[simp]
lemma challengeOracleInterface_append_domain_inr (j : pSpec‚ÇÇ.ChallengeIdx) :
    [(pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).Challenge]‚Çí.domain (.inr j) = Unit

@[simp]
theorem append_left_cancel_iff {pSpec : ProtocolSpec n} {p1 p2 : ProtocolSpec m} :
    p1 ++‚Çö pSpec = p2 ++‚Çö pSpec ‚Üî p1 = p2

@[simp, grind _=_]
theorem totalDegree_mul {f g : F[X][Y]} (hf : f ‚â† 0) (hg : g ‚â† 0) :
    totalDegree (f * g) = totalDegree f + totalDegree g

@[simp]
lemma widthDiv4_mul_4_eq_width : params.widthDiv4 * 4 = params.width

Nat.sub_mul in Init.Data.Nat.Basic

@[simp]
lemma inv_two_mul_two : 2‚Åª¬π * (2 : F) = 1

lemma Q'_div_E'_eq_p
  [NeZero n]
  {E' Q' : Polynomial F}
  {œâs f : Fin n ‚Üí F}
  (hp_deg : p.natDegree < k)
  (he : 2 * e < n - k + 1)
  (hk_n : k ‚â§ n)
  (h_ham : (Œî‚ÇÄ(f, p.eval ‚àò œâs) : ‚Ñï) ‚â§ e)
  (h_diff : Function.Injective œâs)
  (h_Q' : Q' ‚â† 0)
  (hp : p ‚â† 0)
  (h_cond : BerlekampWelchCondition e k œâs f E' Q')
  : E' ‚à£ Q' ‚àß Q' / E' = p

lemma BTField.coe_one_succ (l : ‚Ñï) :
  (@binaryAlgebraTower (l:=l) (r:=l+1) (h_le:=by omega)).algebraMap (1 : BTField l) =
    (1 : BTField (l+1))

nonpos_iff_eq_zero in Mathlib.Algebra.Order.Monoid.Canonical.Defs

@[simp]
theorem Iic_zero : Iic (0 : Fin (n + 1)) = {0}

lemma isPrimitiveRoot_twoAdicGenerator (bits : Fin (twoAdicity + 1)) :
    IsPrimitiveRoot (twoAdicGenerators[bits]) (2 ^ (bits : Nat))

theorem vconcat_inj (v w : Fin n ‚Üí Œ±) (a b : Œ±) :
    vconcat v a = vconcat w b ‚Üî v = w ‚àß a = b

theorem polynomial_sum_ext.{u, u_1}
  {R : Type u}
  [Semiring R]
  {S : Type u_1}
  [AddCommMonoid S]
  {p : Polynomial R} {f g : ‚Ñï ‚Üí R ‚Üí S}
  (h : ‚àÄ i x, f i x = g i x)
  : p.sum f = p.sum g

lemma towerRingHomBackwardMap_forwardMap_eq (k : ‚Ñï) (x : ConcreteBTField k) :
  towerRingHomBackwardMap (k:=k) (towerRingHomForwardMap (k:=k) x) = x

@[simp]
theorem cast_completeness (Œµ : ‚Ñù‚â•0) (hComplete : R.completeness init impl relIn relOut Œµ) :
    (R.cast hn hSpec hO‚Çò).completeness init impl relIn relOut Œµ

lemma one_le_sub_middle_of_pow2 {k : ‚Ñï} (h_k : 1 ‚â§ k) : 1 ‚â§ 2 ^ k - 2 ^ (k - 1)

theorem prime_19 : Nat.Prime 19

lemma ConcreteBTFieldAlgebra_def (l r : ‚Ñï) (h_le : l ‚â§ r) :
    @ConcreteBTFieldAlgebra (l:=l) (r:=r) (h_le:=h_le)
    = (concreteTowerAlgebraMap l r h_le).toAlgebra

theorem BTField.Basis_cast_dest_eq {Œπ : Type*} (k n m : ‚Ñï) (h_k_le_n : k ‚â§ n)
  (h_k_le_m : k ‚â§ m) (h_eq : m = n) :
  letI instLeftAlgebra := binaryAlgebraTower (l:=k) (r:=m) (h_le:=h_k_le_m)
  letI instRightAlgebra := binaryAlgebraTower (l:=k) (r:=n) (h_le:=h_k_le_n)
  @Basis Œπ (BTField k) (BTField m) _ _ instLeftAlgebra.toModule =
  @Basis Œπ (BTField k) (BTField n) _ _ instRightAlgebra.toModule

lemma eqRec_sort_eqRec_fun_eq_self {Œ± : Sort*} {Œ≤ : Œ± ‚Üí Sort u} {a a' : Œ±}
    (h : a = a') (h' : Œ≤ a = Œ≤ a') (b : Œ≤ a) :
  b = h' ‚ñ∏ h ‚ñ∏ b

@[simp]
lemma eval_solutionToQ_zero {x : F} {v} : eval x (solutionToQ 0 k v) =
                                          ‚àë a ‚àà Finset.range k, liftF v a * x ^ a

theorem liftContext_completeness
    (h : R.completeness init impl innerRelIn innerRelOut completenessError) :
      (R.liftContext lens).completeness init impl outerRelIn outerRelOut completenessError

protected lemma abs_one_sub_div_le_one {v a : Fin n ‚Üí F}
  (h_card : 2 ‚â§ Fintype.card F)
  :
  |1 - (1 + 1 / ((Fintype.card F : ‚Ñö) - 1)) * Œî‚ÇÄ(v, a) / n

omit [Finite F] in
lemma minus_one_in_doms {i : ‚Ñï} (h : i < n) :
    -1 ‚àà evalDomain D i

@[simp]
theorem hcons_succ {Œ≤ : Fin n ‚Üí Sort u} (a : Œ±) (v : (i : Fin n) ‚Üí Œ≤ i) (i : Fin n) :
    hcons a v i.succ = cast (vcons_succ Œ± Œ≤ i).symm (v i)

theorem ScalarField_is_prime : Nat.Prime scalarFieldSize

@[simp]
theorem vflatten_zero {n : Fin 0 ‚Üí ‚Ñï} {v : (i : Fin 0) ‚Üí Fin (n i) ‚Üí Œ±} : vflatten v = !v[]

private lemma johnson_denom [Zero F]
  (h_card : 2 ‚â§ (Fintype.card F))
  :
  (Fintype.card F / (Fintype.card F - 1)) *
  ((1 - e B 0 / n) ^ 2  + (e B 0) ^ 2 / ((Fintype.card F - 1) * n^2) - 1 + d B/n)
  =
  (1 - ((Fintype.card F) / (Fintype.card F - 1)) *
  (e B 0 / n)) ^ 2 - (1 - ((Fintype.card F) / (Fintype.card F - 1)) * (d B/n))

theorem vconcat_left_injective {n : ‚Ñï} (a : Œ±) :
    Function.Injective (fun v : Fin n ‚Üí Œ± => vconcat v a)

@[simp]
theorem rtake_append_right :
    (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).rtake n (Nat.le_add_left n m) = pSpec‚ÇÇ

theorem dcast_fun‚ÇÇ {a‚ÇÅ a‚ÇÇ a‚ÇÅ' a‚ÇÇ' : Œ±} {h‚ÇÅ : a‚ÇÅ = a‚ÇÅ'} {h‚ÇÇ : a‚ÇÇ = a‚ÇÇ'} {f : Œ± ‚Üí Œ± ‚Üí Œ±}
    {g : (a‚ÇÅ : Œ±) ‚Üí (a‚ÇÇ : Œ±) ‚Üí Œ≤ a‚ÇÅ ‚Üí Œ≤ a‚ÇÇ ‚Üí Œ≤ (f a‚ÇÅ a‚ÇÇ)} {b‚ÇÅ : Œ≤ a‚ÇÅ} {b‚ÇÇ : Œ≤ a‚ÇÇ} :
    dcast (by cases h‚ÇÅ; cases h‚ÇÇ; rfl) (g a‚ÇÅ a‚ÇÇ b‚ÇÅ b‚ÇÇ) = g a‚ÇÅ' a‚ÇÇ' (dcast h‚ÇÅ b‚ÇÅ) (dcast h‚ÇÇ b‚ÇÇ)

@[grind _=_]
lemma weightedDegree_eq_natWeightedDegree {u v : ‚Ñï} :
  f ‚â† 0 ‚Üí weightedDegree f u v = natWeightedDegree f u v

private lemma natDegree_Q
  (h : (Œî‚ÇÄ(f, p.eval ‚àò œâs) : ‚Ñï) ‚â§ e) :
  (Q œâs f p e).natDegree ‚â§ e + p.natDegree

theorem GF_2_card : Fintype.card (GF(2)) = 2^(2^0)

@[simp] theorem BitVec.dcast_one {n m : ‚Ñï} (h : n = m) : DCast.dcast h (1#n) = 1#m

private lemma sum_sum_K_i_eq_n_sub_d
  (h_B : 2 ‚â§ B.card)
  :
  ‚àë i, sum_choose_K_i B i = choose_2 B.card * (n - d B)

@[simp]
theorem BTField.Basis_cast_index_apply {Œ± Œ≤ i j : ‚Ñï} {k : Fin j} (h_le : Œ± ‚â§ Œ≤) (h_eq : i = j)
  {b : @Basis (Fin (i)) (BTField Œ±) (BTField Œ≤) _ _
    (@binaryAlgebraTower (l := Œ±) (r := Œ≤) (h_le := h_le)).toModule} :
  let castBasis : @Basis (Fin j) (BTField Œ±) (BTField Œ≤) _ _
    (@binaryAlgebraTower (l:=Œ±) (r:=Œ≤) (h_le:=h_le)).toModule :=
    cast (by exact BTField.Basis_cast_index_eq i j Œ± Œ≤ h_le h_eq) b
  (castBasis k) = b (Fin.cast (h_eq.symm) k)

lemma minDist_eq_minDist [DecidableEq F] {IC : LawfulInterleavedCode Œ∫ Œπ F} :
  Code.minDist (IC.1.LC : Set (Œπ ‚Üí F)) = minDist IC.1.MF

lemma cons_get_eq {Œ±} {n : ‚Ñï} (hd : Œ±) (tl : Vector Œ± n) (i : Fin (n + 1)) :
    (cons hd tl).get i =
      if hi: i.val == 0 then hd else tl.get (‚ü®i.val - 1, by
        simp only [beq_iff_eq, Fin.val_eq_zero_iff] at hi
        apply Nat.sub_lt_left_of_lt_add
        ¬∑ by_contra hi_ne_gt_1
          simp only [not_le, Nat.lt_one_iff, Fin.val_eq_zero_iff] at hi_ne_gt_1
          contradiction
        ¬∑ have hi_lt:= i.isLt; omega
      ‚ü©)

lemma concreteTowerAlgebraMap_succ_1 (k : ‚Ñï) :
  concreteTowerAlgebraMap (l:=k) (r:=k + 1) (h_le:=by omega) = canonicalAlgMap k

@[simp]
theorem hconcat_castSucc {Œ± : Fin n ‚Üí Sort u} {Œ≤ : Sort u}
    (v : (i : Fin n) ‚Üí Œ± i) (b : Œ≤) (i : Fin n) :
    hconcat v b (castSucc i) = cast (vconcat_castSucc Œ± Œ≤ i).symm (v i)

theorem concreteTowerAlgebraMap_assoc :
    ‚àÄ r mid l : ‚Ñï, (h_l_le_mid : l ‚â§ mid) ‚Üí (h_mid_le_r : mid ‚â§ r) ‚Üí
    concreteTowerAlgebraMap (l:=l) (r:=r) (h_le:=by exact Nat.le_trans h_l_le_mid h_mid_le_r) =
    (concreteTowerAlgebraMap (l:=mid) (r:=r) (h_le:=h_mid_le_r)).comp
    (concreteTowerAlgebraMap (l:=l) (r:=mid) (h_le:=h_l_le_mid))

lemma rank_eq_min_row_col_rank : U.rank = min (rowRank U) (colRank U)

Fin.val_injective in Mathlib.Data.Fin.Basic

@[simp] theorem rightpad_eq_self (l : List Œ±) (n : Nat) (h : n ‚â§ l.length) :
    rightpad n unit l = l

private lemma choose_2_eq_half_f :
  choose_2 = (1/2) * f

theorem toFun_eq_const_plus (t : AssocNat) : ‚àÄ m : Nat, t m = t 0 + m

theorem decoder_eq_some {e k : ‚Ñï} [NeZero n] {œâs f : Fin n ‚Üí F} {p : Polynomial F}
  (he : 2 * e < n - k + 1)
  (hn : k ‚â§ n)
  (h_inj : Function.Injective œâs)
  (h_deg : p.natDegree < k)
  (h_dist : Œî‚ÇÄ(f, p.eval ‚àò œâs) ‚â§ e)
  : decoder e k œâs f = some p

theorem vconcat_vcons_eq_vcons_vconcat (a : Œ±) (v : Fin n ‚Üí Œ±) (b : Œ±) :
    vconcat (a ::·µõ v) b = a ::·µõ (vconcat v b)

theorem SkeletonNodeIndex.parent_of_depth_zero {s : Skeleton}
    (idx : SkeletonNodeIndex s) (h : idx.depth = 0) :
    parent idx = none

lemma W_prod_comp_decomposition
    (i : Fin r) (hi : i > 0) :
    (W ùîΩq Œ≤ i) = ‚àè c: ùîΩq, (W ùîΩq Œ≤ (i-1)).comp (X - C (c ‚Ä¢ Œ≤ (i-1)))

theorem append_comp' {a : Fin m ‚Üí Œ±} {b : Fin n ‚Üí Œ±} (f : Œ± ‚Üí Œ≤)
    (i : Fin (m + n)) : append (f ‚àò a) (f ‚àò b) i = f (append a b i)

theorem vappend_succ (u : Fin m ‚Üí Œ±) (v : Fin (n + 1) ‚Üí Œ±) :
    vappend u v = vconcat (vappend u (v ‚àò castSucc)) (v (last n))

@[simp] theorem leftpad_eq_self (l : List Œ±) (n : Nat) (h : l.length ‚â• n) :
    leftpad n unit l = l

@[simp]
lemma lt_add_of_pos_right_of_le (a b c : ‚Ñï) [NeZero c] (h : a ‚â§ b) : a < b + c

omit [DecidableEq L] [Fintype ùîΩq] hŒ≤_lin_indep in
lemma W_ne_zero (i : Fin r) : (W ùîΩq Œ≤ i) ‚â† 0

lemma schwartz_zippel' {p : MvPolynomial œÉ R} (hp : p ‚â† 0) (S : œÉ ‚Üí Finset R) :
    #{x ‚àà Finset.pi p.vars S | eval (extendDomain x) p = 0} / ‚àè i ‚àà p.vars, (#(S i) : ‚Ñö‚â•0)
      ‚â§ ‚àë i ‚àà p.vars, (p.degreeOf i / #(S i) : ‚Ñö‚â•0)

@[simp]
theorem Basis_cast_index_apply {Œ± Œ≤ i j : ‚Ñï} {k : Fin j}
    (h_le : Œ± ‚â§ Œ≤) (h_eq : i = j)
    {b : @Basis (Fin (i)) (ConcreteBTField Œ±) (ConcreteBTField Œ≤) _ _
      (@ConcreteBTFieldAlgebra (l := Œ±) (r := Œ≤) (h_le := h_le)).toModule} :
  let castBasis : @Basis (Fin j) (ConcreteBTField Œ±) (ConcreteBTField Œ≤) _ _
    (@ConcreteBTFieldAlgebra (l:=Œ±) (r:=Œ≤) (h_le:=h_le)).toModule :=
    cast (by exact Basis_cast_index_eq i j Œ± Œ≤ h_le h_eq) b
  (castBasis k) = b (Fin.cast (h_eq.symm) k)

lemma contract_eq_liftF_of_lt {k : ‚Ñï} (h‚ÇÅ : k < m) :
  contract m f' k = liftF f' k

@[simp]
theorem removeNth_update : removeNth p (update s p y) = removeNth p s

private lemma sum_add_one {i : Fin (k + 1)} :
  ‚àë j' ‚àà finRangeTo (i.1 + 1), (s j').1 = (‚àë j' ‚àà finRangeTo i.1, (s j').1) + (s i).1

theorem eval‚ÇÇ_quadratic_prevField_coeff
  {prevBTField : Type*} [CommRing prevBTField]
  {curBTField : Type*} [CommRing curBTField]
  (of_prev : prevBTField ‚Üí+* curBTField)
  (t1 : prevBTField)
  (x : curBTField) :
  eval‚ÇÇ of_prev x (X^2 + (C t1 * X + 1)) = x^2 + of_prev t1 * x + 1

@[simp]
theorem cast_rbrKnowledgeSoundness (Œµ : pSpec‚ÇÅ.ChallengeIdx ‚Üí ‚Ñù‚â•0)
    (hRbrKs : V.rbrKnowledgeSoundness init impl relIn relOut Œµ) :
    (V.cast hn hSpec hO‚Çò).rbrKnowledgeSoundness init impl relIn relOut
      (Œµ ‚àò (ChallengeIdx.cast hn.symm (cast_symm hSpec)))

theorem LeafData.composeBuild_getRootValue {Œ±} {s_left s_right : Skeleton}
    (left : LeafData Œ± s_left) (right : LeafData Œ± s_right)
    (compose : Œ± ‚Üí Œ± ‚Üí Œ±) :
    ((LeafData.internal left right).composeBuild compose).getRootValue =
      compose (left.composeBuild compose).getRootValue (right.composeBuild compose).getRootValue

lemma getBit_of_or {n m k: ‚Ñï} : getBit k (n ||| m) = getBit k n ||

lemma getBit_of_multiple_of_power_of_two {n p : ‚Ñï}: ‚àÄ k,
  getBit (k) (2^p * n) = if k < p then 0 else getBit (k-p) n

@[simp]
lemma solutionToQ_coeff :
  (solutionToQ e k v).coeff n = if n < e + k then liftF v (e + n) else 0

@[simp]
private lemma evenPart'_coeffs {f : Polynomial F} {n : ‚Ñï} :
    (evenPart' f).coeff n = if Even n then f.coeff n else 0

lemma coe_one_succ (l : ‚Ñï) :
    (@ConcreteBTFieldAlgebra (l:=l) (r:=l + 1) (h_le:=by omega)).algebraMap
    (1 : ConcreteBTField l) = (1 : ConcreteBTField (l + 1))

lemma add_two_pow_of_getBit_eq_zero_lt_two_pow {n m i : ‚Ñï} (h_n: n < 2^m) (h_i: i < m)
  (h_getBit_at_i_eq_zero: getBit i n = 0) :
  n + 2^i < 2^m

omit [DecidableEq L] [Fintype ùîΩq] h_Fq_char_prime hŒ≤_lin_indep in
lemma normalizedW‚ÇÄ_eq_1_div_Œ≤‚ÇÄ : normalizedW (ùîΩq := ùîΩq) (Œ≤ := Œ≤) (i :=0) = X * C (1 / (Œ≤ 0))

@[simp]
theorem cast_id :
    Prover.cast rfl rfl = (id : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec‚ÇÅ ‚Üí _)

lemma degree_W (i : Fin r) : (W ùîΩq Œ≤ i).degree = (Fintype.card ùîΩq)^i.val

lemma fieldSize_sub_one_factorization : fieldSize - 1 = 2 ^ twoAdicity * 127

theorem finalSumcheckOracleVerifier_rbrKnowledgeSoundness [Fintype L] {œÉ : Type}
    (init : ProbComp œÉ) (impl : QueryImpl []‚Çí (StateT œÉ ProbComp)) :
    (finalSumcheckVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).rbrKnowledgeSoundness init impl
      (relIn := roundRelation ùîΩq Œ≤ (œë := œë) (ùìë := ùìë)
        (mp := BBF_SumcheckMultiplierParam) (Fin.last ‚Ñì))
      (relOut := finalSumcheckRelOut ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
      (rbrKnowledgeError := finalSumcheckKnowledgeError)

lemma degree_bound_bivariate
  (qPoly : Polynomial F)
  (hdeg_q_min : qPoly.natDegree > 0)
  (hdeg_q_max : qPoly.natDegree < Fintype.card F)
  {t : ‚Ñï} (Q : MvPolynomial (Fin 2) F)
  (hdegX : MvPolynomial.degreeOf 0 Q < t)
  (hdegY : MvPolynomial.degreeOf 1 Q < qPoly.natDegree) :
  (MvPolynomial.eval‚ÇÇHom (Polynomial.C : F ‚Üí+* Polynomial F)
      (fun i : Fin 2 => if i = 0 then qPoly else Polynomial.X) Q).natDegree < t * qPoly.natDegree

theorem embedSum_succ {m : ‚Ñï} {n : Fin (m + 1) ‚Üí ‚Ñï} {i : Fin (m + 1)} (j : Fin (n i)) :
    embedSum i j = (match i with
    | 0 => Fin.castAdd _ j
    | ‚ü®i + 1, h‚ü© => Fin.natAdd _ (embedSum ‚ü®i, Nat.succ_lt_succ_iff.mp h‚ü© j))

@[simp]
lemma bIdx_mul_œë_add_i_lt_‚Ñì_succ {m : ‚Ñï} (bIdx : Fin (‚Ñì / œë - 1)) (i : Fin œë) :
    ‚ÜëbIdx * œë + ‚Üëi < ‚Ñì + m

lemma last_nonzero_unique {p : UniPoly Q} {k k' : Fin p.size} :
  last_nonzero_prop k ‚Üí last_nonzero_prop k' ‚Üí k = k'

omit [Finite F] in
lemma dom_n_eq_triv : evalDomain D x n = {x ^ (2 ^ n)}

theorem randomOracle_neverFails_iff_runWithOracle_neverFails {Œ≤}
    [DecidableEq Œπ] [spec.DecidableEq] [(i : Œπ) ‚Üí SelectableType (OracleSpec.range spec i)]
    (oa : OracleComp (spec) Œ≤)
    :
    (‚àÄ (preexisting_cache : spec.QueryCache),
      ((oa.simulateQ randomOracle).run preexisting_cache).neverFails)
    ‚Üî
    (‚àÄ (f : spec.FunctionType),
      (runWithOracle f oa).isSome)

theorem prod_X_sub_C_eq_X_pow_card_sub_X_in_L :
  (‚àè c ‚àà (Finset.univ : Finset Fq), (Polynomial.X - Polynomial.C (algebraMap Fq L c))) =
    Polynomial.X^(Fintype.card Fq) - Polynomial.X

lemma duplexSpongeToFSGameStatDist
    (maliciousProver : OracleComp (oSpec ++‚Çí duplexSpongeChallengeOracle StmtIn U)
      (StmtIn √ó pSpec.Messages))
    (t‚Çí : Œπ ‚Üí ‚Ñï) (t‚Çï t‚Çö t‚Çö·µ¢ : ‚Ñï)
    -- TODO: state query bound only for subset of the oracles
    (hQuery : IsQueryBound maliciousProver (t‚Çí ‚äï·µ• (t‚Çï ‚äï·µ• (t‚Çö ‚äï·µ• t‚Çö·µ¢)))) : True

lemma h_sum_two_same_pow2 {k : ‚Ñï} (h_pos : k > 0) : 2 ^ (k - 1) + 2 ^ (k - 1) = 2 ^ k

lemma qCompositionChain_eq_foldl (i : Fin r) :
  qCompositionChain ùîΩq Œ≤ (‚Ñì:=‚Ñì) (R_rate:=R_rate) i =
  Fin.foldl (n:=i) (fun acc j =>
    (qMap ùîΩq Œ≤ ‚ü®j, by omega‚ü©).comp acc) (X)

@[simp] lemma toMvPolynomialAlgHom_X (s : œÉ) :
    toMvPolynomialAlgHom (X s : P) = (MvPolynomial.X s : MvPolynomial œÉ R)

lemma Nat.Prime.dvd_mul_list {p : ‚Ñï} {l : List ‚Ñï} (h : p.Prime) :
    p ‚à£ l.prod ‚Üî ‚àÉ r ‚àà l, p ‚à£ r

theorem add_assoc : p + q + r = p + (q + r)

omit [CharP L 2] [DecidableEq ùîΩq] h_Œ≤‚ÇÄ_eq_1 [NeZero ùì°] in
lemma firstOracleWitnessConsistencyProp_relay_preserved (i : Fin ‚Ñì)
    (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) (wit : Witness (L := L) ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j) :
    firstOracleWitnessConsistencyProp ùîΩq Œ≤ wit.t (getFirstOracle ùîΩq Œ≤ oStmt) =
    firstOracleWitnessConsistencyProp ùîΩq Œ≤ wit.t
      (getFirstOracle ùîΩq Œ≤ (mapOStmtOutRelayStep ùîΩq Œ≤ i hNCR oStmt))

lemma forwardRange_eq_of_r_eq (n : ‚Ñï) (r1 r2 : Fin n) (h_r_eq : r1 = r2) (l : Fin (r1.val + 1)) :
  forwardRange n r1 l = forwardRange n r2 ‚ü®l, by omega‚ü©

@[simp] -- main lemma for bIdx: Fin (‚Ñì / œë - 1) bounds
lemma bIdx_mul_œë_add_x_lt_‚Ñì_sub_œë (bIdx : Fin (‚Ñì / œë - 1)) (x : ‚Ñï) {hx : x ‚â§ œë} :
    ‚ÜëbIdx * œë + x ‚â§ ‚Ñì - œë

private lemma fold_max_lemma {Œπ : Type} {s : Finset Œπ} {f : Œπ ‚Üí ‚Ñï} {n : ‚Ñï} :
    (‚àÄ i ‚àà s, f i ‚â§ n) ‚Üí Finset.fold max 0 f s ‚â§ n

lemma relHammingDist_le_blockRelDistance
  (i k : ‚Ñï) {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F} {œÜ' : (indexPowT S œÜ i) ‚Ü™ F}
  [DecidableEq F] [DecidableEq Œπ] [Smooth œÜ]
  (f g : (indexPowT S œÜ i) ‚Üí F) (S' : Finset (indexPowT S œÜ i))
  [h_fintype : ‚àÄ i : ‚Ñï, Fintype (indexPowT S œÜ i)]
  [DecidableEq (indexPowT S œÜ i)] [Smooth œÜ']
  [h_dec : DecidableBlockDisagreement i k f S' œÜ'] :
  Œ¥·µ£(f, g) ‚â§ Œî·µ£(i, k, f, S', œÜ', g)

lemma divide_by_2_def {s : Finset ‚Ñï} :
    divide_by_2 s = (erase_odd s).image (fun n => n / 2)

theorem cast_eq_dcast‚ÇÇ {hn} {hSpec : pSpec‚ÇÅ.cast hn = pSpec‚ÇÇ} {i : MessageIdx pSpec‚ÇÅ}:
    i.cast hn hSpec = dcast‚ÇÇ hn hSpec i

@[simp]
theorem fflatten‚ÇÇ_embedSum {A : Sort u} {B : Sort v} {F : A ‚Üí B ‚Üí Sort w} {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï}
    {Œ± : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí A}
    {Œ≤ : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí B}
    (v : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí F (Œ± i j) (Œ≤ i j)) (i : Fin m) (j : Fin (n i)) :
    fflatten‚ÇÇ v (embedSum i j) = cast (by simp) (v i j)

@[simp]
theorem snoc_last : snoc s y (Fin.last n) = y

theorem fconcat‚ÇÇ_inj {Œ±‚ÇÅ : Fin n ‚Üí A} {Œ±‚ÇÇ : Fin n ‚Üí B} {Œ≤‚ÇÅ : A} {Œ≤‚ÇÇ : B}
    (v‚ÇÅ v‚ÇÇ : (i : Fin n) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i)) (a‚ÇÅ a‚ÇÇ : F‚ÇÇ Œ≤‚ÇÅ Œ≤‚ÇÇ) :
    fconcat‚ÇÇ (F := F‚ÇÇ) v‚ÇÅ a‚ÇÅ = fconcat‚ÇÇ (F := F‚ÇÇ) v‚ÇÇ a‚ÇÇ ‚Üî v‚ÇÅ = v‚ÇÇ ‚àß a‚ÇÅ = a‚ÇÇ

theorem sum_of_pow_exp_of_2 {F : Type*} [Field F]
  (sumZeroIffEq : ‚àÄ (x y : F), x + y = 0 ‚Üî x = y)
  (i : ‚Ñï) : ‚àÄ (a b c : F), a + b = c ‚Üí a^(2^i) + b^(2^i) = c^(2^i)

omit h_Œ≤‚ÇÄ_eq_1 in
lemma finToBinaryCoeffs_sDomainToFin (i : Fin r) (h_i : i < ‚Ñì + R_rate)
    (x : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i) :
    let pointFinIdx := (sDomainToFin ùîΩq Œ≤ h_‚Ñì_add_R_rate i h_i) x
    finToBinaryCoeffs ùîΩq (i := i) (idx :=pointFinIdx) =
    (sDomain_basis ùîΩq Œ≤
    h_‚Ñì_add_R_rate i h_i).repr x

protected lemma elocPoly_congr {œâs' f' : ‚Ñï ‚Üí F}
  (h‚ÇÅ : ‚àÄ {m}, m < n ‚Üí œâs m = œâs' m) (h‚ÇÇ : ‚àÄ {m}, m < n ‚Üí f m = f' m) :
  ElocPoly n œâs f = ElocPoly n œâs' f'

theorem insertNth_ne_zero_of_right (h : s ‚â† 0) : insertNth p y s ‚â† 0

theorem GF_2_pow_card (x : GF(2)) : x ^ Fintype.card (GF(2)) = x

omit [CharP L 2] [DecidableEq ùîΩq] hF‚ÇÇ h_Œ≤‚ÇÄ_eq_1 [NeZero ‚Ñì] in
theorem card_qMap_total_fiber (i : Fin ‚Ñì) (steps : ‚Ñï) (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
    (y : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i.val + steps, by omega‚ü©)) :
    Fintype.card (Set.image (qMap_total_fiber ùîΩq Œ≤ (i := ‚ü®i, by omega‚ü©) (steps := steps)
      (h_i_add_steps := by simp only; exact fin_‚Ñì_steps_lt_‚Ñì_add_R i steps h_i_add_steps)
      (y := y)) Set.univ) = 2 ^ steps

theorem vconcat_injective2 : Function.Injective2 (@vconcat Œ± n)

lemma U_card (i : Fin r) :
    Fintype.card (U ùîΩq Œ≤ i) = (Fintype.card ùîΩq)^i.val

omit [Finite F] in
private lemma gen_def {i : ‚Ñï} :
    (IsCyclicWithGen.gen : evalDomain D i) =
      ‚ü®
        DIsCyclicC.gen ^ (2 ^ i),
        by
          apply pow_2_pow_i_mem_Di_of_mem_D
          exact DIsCyclicC.gen.2
      ‚ü©

theorem FullData.map_getRootValue {Œ± Œ≤ : Type} {s : Skeleton}
    (f : Œ± ‚Üí Œ≤) (tree : FullData Œ± s) :
    (tree.map f).getRootValue = f (tree.getRootValue)

theorem liftContext_runWithLog
    {lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    {outerStmtIn : OuterStmtIn} {outerWitIn : OuterWitIn}
    {R : Reduction oSpec InnerStmtIn InnerWitIn InnerStmtOut InnerWitOut pSpec} :
      (R.liftContext lens).runWithLog outerStmtIn outerWitIn = do
        let ‚ü®‚ü®‚ü®fullTranscript, innerCtxOut‚ü©, verInnerStmtOut‚ü©, queryLog‚ü© ‚Üê
          R.runWithLog.uncurry (lens.proj (outerStmtIn, outerWitIn))
        return ‚ü®‚ü®‚ü®fullTranscript, lens.lift (outerStmtIn, outerWitIn) innerCtxOut‚ü©,
                lens.stmt.lift outerStmtIn verInnerStmtOut‚ü©, queryLog‚ü©

@[simp]
theorem vconcat_castSucc (v : Fin n ‚Üí Œ±) (a : Œ±) (i : Fin n) :
    vconcat v a (castSucc i) = v i

theorem support_C_subset {r : R} : (@C R œÉ _ r).support ‚äÜ { 0 }

theorem succ_succ {T : Type u} [HasSucc T] [Add T] [One T] [LawfulHasSucc T] (x : T) :
    succ' (succ' x) = x + 1 + 1

lemma getMiddleBits_lt_two_pow {n offset len : ‚Ñï} :
  getMiddleBits offset len n < 2 ^ len

lemma cube_map_bijective :
    Function.Bijective (fun x : (Field)À£ => x ^ (3 : Nat))

Nat.lt_of_add_right_lt in Init.Data.Nat.Basic

theorem add_assoc {n : ‚Ñï} (a b c : CNat (n + 1)) : (a + b) + c = a + (b + c)

theorem join_zero_one {k : ‚Ñï} (h_k : k > 0) :
    „Ää zero (k:=k - 1), one (k:=k - 1) „Äã = one (k:=k)

@[simp]
theorem drop_one {Œ± : Fin (n + 1) ‚Üí Sort*} (v : (i : Fin (n + 1)) ‚Üí Œ± i) :
    drop 1 (Nat.le_add_left 1 n) v = tail v

@[simp]
theorem fcons_one {Œ≤ : Fin (n + 1) ‚Üí A} (a : F Œ±) (v : (i : Fin (n + 1)) ‚Üí F (Œ≤ i)) :
    fcons a v 1 = v 0

theorem concreteTowerAlgebraMap_succ_last (r : ‚Ñï) : ‚àÄ l : ‚Ñï, (h_le : l ‚â§ r) ‚Üí
  concreteTowerAlgebraMap (l:=l) (r:=r + 1) (h_le:=by
    exact Nat.le_trans (n:=l) (m:=r) (k:=r + 1) (h_le) (by omega)) =
  (concreteTowerAlgebraMap (l:=l + 1) (r:=r + 1) (by omega)).comp (concreteTowerAlgebraMap
    (l:=l) (r:=l + 1) (by omega))

private lemma solutionToE_from_E
  (h_p_deg : p.natDegree < k)
  (h_dist : (Œî‚ÇÄ(f, p.eval ‚àò œâs) : ‚Ñï) ‚â§ e)
  : solutionToE e k (E_and_Q_to_a_solution e (E œâs f p e) (Q œâs f p e)) = E œâs f p e

@[simp]
theorem removeNth_apply : removeNth p s i = s (p.succAbove i)

@[simp]
theorem fappend‚ÇÇ_right {Œ±‚ÇÅ : Fin m ‚Üí A} {Œ±‚ÇÇ : Fin m ‚Üí B} {Œ≤‚ÇÅ : Fin n ‚Üí A} {Œ≤‚ÇÇ : Fin n ‚Üí B}
    (u : (i : Fin m) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i)) (v : (i : Fin n) ‚Üí F‚ÇÇ (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) (i : Fin n) :
    fappend‚ÇÇ (F := F‚ÇÇ) u v (natAdd m i) =
      cast (by simp [vappend_right]) (v i)

protected lemma elocPoly_leftF_leftF_eq_contract {œâs f : Fin m ‚Üí F} :
  ElocPoly n (liftF œâs) (liftF f) =
  ElocPoly n (contract n œâs) (contract n f)

theorem one_le_sub_consecutive_two_pow (n : ‚Ñï): 1 ‚â§ 2^(n+1) - 2^n

@[simp]
theorem cast_dir_idx_symm {hn} (hSpec : pSpec‚ÇÅ.cast hn = pSpec‚ÇÇ) {i : Fin n‚ÇÇ} :
    pSpec‚ÇÅ.dir (Fin.cast hn.symm i) = pSpec‚ÇÇ.dir i

lemma concrete_zero_mul0 (b : ConcreteBTField 0) :
  concrete_mul (zero (k:=0)) b = zero (k:=0)

Nat.succ_lt_succ_iff in Init.Data.Nat.Basic

theorem insertNth_zero_eq_cases {n : ‚Ñï} {Œ± : Fin (n + 1) ‚Üí Sort u} :
    insertNth 0 = cases (motive := Œ±)

protected lemma a_lemma_im_not_proud_of_OLD {v a : Fin n ‚Üí F}
  (h_card : 2 ‚â§ Fintype.card F)
  :
  |(1 : ‚Ñö) - ((1 : ‚Ñö) + (1 : ‚Ñö) / ((Fintype.card F : ‚Ñö) - 1)) * ‚ÜëŒî‚ÇÄ(v, a) / ‚Üën

@[simp]
theorem hflatten_one {n : Fin 1 ‚Üí ‚Ñï} {Œ± : (i : Fin 1) ‚Üí (j : Fin (n i)) ‚Üí Sort*}
    {v : (i : Fin 1) ‚Üí (j : Fin (n i)) ‚Üí Œ± i j} : hflatten v = v 0

@[simp]
theorem Reduction.id_run (stmt : StmtIn) (wit : WitIn) :
    (Reduction.id : Reduction oSpec StmtIn WitIn _ _ _).run stmt wit =
      pure ‚ü®‚ü®default, stmt, wit‚ü©, stmt‚ü©

List.le_sum_of_mem in Mathlib.Algebra.Order.BigOperators.Group.List

lemma irreducibleHTildeOfIrreducible {H : Polynomial (Polynomial F)} :
    (Irreducible H ‚Üí Irreducible (H_tilde H))

@[simp]
theorem snoc_init_self : snoc (init t) (t (Fin.last n)) = t

theorem fappend‚ÇÇ_ext {Œ±‚ÇÅ : Fin m ‚Üí A} {Œ±‚ÇÇ : Fin m ‚Üí B} {Œ≤‚ÇÅ : Fin n ‚Üí A} {Œ≤‚ÇÇ : Fin n ‚Üí B}
    (u‚ÇÅ u‚ÇÇ : (i : Fin m) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i)) (v‚ÇÅ v‚ÇÇ : (i : Fin n) ‚Üí F‚ÇÇ (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) :
    fappend‚ÇÇ (F := F‚ÇÇ) u‚ÇÅ v‚ÇÅ = fappend‚ÇÇ (F := F‚ÇÇ) u‚ÇÇ v‚ÇÇ ‚Üî u‚ÇÅ = u‚ÇÇ ‚àß v‚ÇÅ = v‚ÇÇ

lemma getBit_of_shiftRight {n p : ‚Ñï}:
  ‚àÄ k, getBit k (n >>> p) = getBit (k+p) n

theorem eq_of_equiv [LawfulBEq R] {p q : UniPoly R} : equiv p q ‚Üí p.trim = q.trim

private lemma Bi_biUnion_F2i :
  Bi B i = Finset.univ.biUnion (F2i B i)

theorem binaryTowerAlgebra_apply_assoc (l mid r : ‚Ñï) (h_l_le_mid : l ‚â§ mid) (h_mid_le_r : mid ‚â§ r) :
    ‚àÄ x : BTField l,
    (@binaryAlgebraTower (l:=l) (r:=r) (h_le:=by
      exact Nat.le_trans h_l_le_mid h_mid_le_r)).algebraMap x =
    (@binaryAlgebraTower (l:=mid) (r:=r) (h_le:=h_mid_le_r)).algebraMap
      ((@binaryAlgebraTower (l:=l) (r:=mid) (h_le:=h_l_le_mid)).algebraMap x)

lemma algebraMap_succ_eq_zero_x {k : ‚Ñï} (h_pos : k > 0) (x : BTField (k - 1)) :
  letI instAlgebra := binaryAlgebraTower (l:=k-1) (r:=k) (h_le:=by omega)
  algebraMap (BTField (k - 1)) (BTField k) x = ‚ãò 0, x ‚ãô

omit [Ring Q] in
@[simp] theorem zero_def : (0 : UniPoly Q) = #[]

@[simp]
lemma solutionToE_ne_zero : (solutionToE e k v) ‚â† 0

@[simp]
theorem cast_rbrKnowledgeSoundness (Œµ : pSpec‚ÇÅ.ChallengeIdx ‚Üí ‚Ñù‚â•0)
    (hRbrKs : V.rbrKnowledgeSoundness init impl relIn relOut Œµ) :
    (V.cast hn hSpec).rbrKnowledgeSoundness init impl relIn relOut
      (Œµ ‚àò (ChallengeIdx.cast hn.symm (cast_symm hSpec)))

lemma C_injective : Function.Injective (C : R ‚Üí P)

theorem unique_linear_decomposition_succ (k : ‚Ñï) :
  letI : Algebra (ConcreteBTField k) (ConcreteBTField (k+1)) :=
    ConcreteBTFieldAlgebra (l:=k) (r:=k+1) (h_le:=by omega)
  ‚àÄ (x : ConcreteBTField (k+1)), ‚àÉ! (p : ConcreteBTField k √ó ConcreteBTField k),
    x = join_via_add_smul (k+1) (by omega) p.1 p.2

@[simp]
lemma erase_even_empty :
    erase_even ‚àÖ = ‚àÖ

theorem findSum_of_le_sum {l : List ‚Ñï} {j : ‚Ñï} (h : j < l.sum) : ‚àÉ n, findSum l j = some n

lemma towerAlgebraMap_succ_1 (k : ‚Ñï) :
  towerAlgebraMap (l:=k) (r:=k+1) (h_le:=by omega) = canonicalEmbedding k

lemma and_eq_zero_iff {n m : ‚Ñï} : n &&& m = 0 ‚Üî ‚àÄ k, (n >>> k) &&& (m >>> k) = 0

theorem dcast_eq_root_cast (h : a = a') : dcast h b = _root_.cast (congrArg Œ≤ h) b

@[simp] lemma ofMvPolynomialAlgHom_X (s : œÉ) :
    ofMvPolynomialAlgHom (MvPolynomial.X s : MvPolynomial œÉ R) = (X s : P)

lemma split_join_eq_split {k : ‚Ñï} (h_pos : k > 0)
    (hi_btf lo_btf : ConcreteBTField (k - 1)) :
    split h_pos („Ää hi_btf, lo_btf „Äã) = (hi_btf, lo_btf)

omit hF‚ÇÇ in
theorem W_linear_comp_decomposition (i : Fin r) (h_i_add_1 : i + 1 < r) :
    ‚àÄ p: L[X], (W ùîΩq Œ≤ (i + 1)).comp p =
      ((W ùîΩq Œ≤ i).comp p) ^ Fintype.card ùîΩq -
        C (eval (Œ≤ i) (W ùîΩq Œ≤ i)) ^ (Fintype.card ùîΩq - 1) * ((W ùîΩq Œ≤ i).comp p)

@[simp]
theorem dempty_happend {Œ± : Fin 0 ‚Üí Sort u} {Œ≤ : Fin n ‚Üí Sort u} (v : (i : Fin n) ‚Üí Œ≤ i) :
    happend !d‚ü®Œ±‚ü©[] v =
      fun i : Fin (0 + n) => cast (by simp) (v <| i.cast (by omega))

@[simp] -- TODO: more general version/class for query impls that never have failures
lemma loggingOracle.probFailure_simulateQ [spec.FiniteRange] (oa : OracleComp spec Œ±) :
    [‚ä• | (simulateQ loggingOracle oa).run] = [‚ä• | oa] := by
  induction oa using OracleComp.induction with

@[simp] theorem BitVec.cast_zero {n m : ‚Ñï} (h : n = m) : BitVec.cast h 0 = 0

@[simp]
theorem sum_degreeLT_monomial_eq_subtype {n : ‚Ñï} (p : L‚¶É< n‚¶Ñ[X]) :
  (‚ü®p.val.sum (fun n a => Polynomial.monomial n a), by
    -- degree of sum is degree of p.val, which is < n
    rw [Polynomial.sum_monomial_eq p.val]
    exact p.property
  ‚ü© : L‚¶É< n‚¶Ñ[X]) = p

theorem last_nonzero_induct [LawfulBEq R] {motive : UniPoly R ‚Üí Prop}
  (case1 : ‚àÄ p, p.last_nonzero = none ‚Üí (‚àÄ i, (hi : i < p.size) ‚Üí p[i] = 0) ‚Üí motive p)
  (case2 : ‚àÄ p : UniPoly R, ‚àÄ k : Fin p.size, p.last_nonzero = some k ‚Üí p[k] ‚â† 0 ‚Üí
    (‚àÄ j : ‚Ñï, (hj : j < p.size) ‚Üí j > k ‚Üí p[j] = 0) ‚Üí motive p)
  (p : UniPoly R) : motive p

@[simp]
lemma range_def : (spec Œ±).range () = Œ±

theorem zero_canonical : (0 : UniPoly R).trim = 0

lemma and_two_pow_eq_two_pow_of_getBit_1 {n i : ‚Ñï} (h_getBit: getBit i n = 1) :
    n &&& (2 ^ i) = 2 ^ i

@[simp] theorem BitVec.dcast_zero {n m : ‚Ñï} (h : n = m) : DCast.dcast h (0#n) = 0#m

theorem decoder_dist_impl_mem
  {k r D e : ‚Ñï}
  (h_e : e ‚â§ n - Real.sqrt (k * n))
  {œâs : Fin n ‚Ü™ F}
  {f : Fin n ‚Üí F}
  {p : F[X]}
  (h_dist : Œî‚ÇÄ(f, p.eval ‚àò œâs) ‚â§ e)
  :
  p ‚àà decoder k r D e œâs f

theorem mul_join_via_add_smul (k : ‚Ñï) (h_pos : k > 0) (a‚ÇÅ a‚ÇÄ b‚ÇÅ b‚ÇÄ : BTField (k - 1)) :
  ‚ãò a‚ÇÅ, a‚ÇÄ ‚ãô * ‚ãò b‚ÇÅ, b‚ÇÄ ‚ãô = ‚ãò a‚ÇÅ * b‚ÇÅ * Z (k - 1) + a‚ÇÅ * b‚ÇÄ + a‚ÇÄ * b‚ÇÅ, a‚ÇÄ * b‚ÇÄ + a‚ÇÅ * b‚ÇÅ ‚ãô

theorem coeff_of_toMvPolynomial_eq_coeff_of_MlPoly (p : MlPoly R n) (m : Fin n ‚Üí‚ÇÄ ‚Ñï) :
  coeff m (toMvPolynomial p) =
    if h_binary: (‚àÄ j: Fin n, m j ‚â§ 1) then
      let i_of_m: ‚Ñï := Nat.binaryFinMapToNat (m:=m) (h_binary:=h_binary)
      p[i_of_m]
    else
      0

theorem append_left_injective (b : Fin n ‚Üí Œ±) : Function.Injective (@Fin.append m n Œ± ¬∑ b)

private lemma k_and_e' [Zero F]
  (h_n : n ‚â† 0)
  (h_B : B.card ‚â† 0)
  :
  k B / B.card = (n - e B 0) / n

@[simp]
theorem init_snoc : init (snoc s y) = s

@[simp]
theorem FullData.ofFun_get {Œ±} {s} (tree : FullData Œ± s) :
    FullData.ofFun s (fun idx => tree.get idx) = tree

@[simp]
theorem oracleVerifier_rbrKnowledgeSoundness [Nonempty (Query OStatement)]
    {d : ‚Ñï} (hDist : distanceLE OStatement d) :
    (oracleVerifier oSpec OStatement).rbrKnowledgeSoundness init impl
      (relIn OStatement)
      (relOut OStatement)
      (fun _ => (d : ‚Ñù‚â•0) / (Fintype.card (Query OStatement) : ‚Ñù‚â•0))

theorem liftContext_perfectCompleteness
    (h : R.perfectCompleteness init impl innerRelIn innerRelOut) :
      (R.liftContext lens).perfectCompleteness init impl outerRelIn outerRelOut

lemma blockRelDistance_eq_relHammingDist_of_k_eq_i -- Renamed for clarity
  (i : ‚Ñï) {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F}
  [DecidableEq F] [DecidableEq Œπ] [Smooth œÜ]
  -- The Fintype instance is now declared before it is needed by `hS'`.
  [h_fintype : ‚àÄ i : ‚Ñï, Fintype (indexPowT S œÜ i)]
  (f g : (indexPowT S œÜ i) ‚Üí F) (S' : Finset (indexPowT S œÜ i))
  (hS' : S' = Finset.univ) -- This now works.
  (œÜ' : (indexPowT S œÜ i) ‚Ü™ F)
  [h_dec : DecidableBlockDisagreement i i f S' œÜ'] [DecidableEq (indexPowT S œÜ i)] :
  Œî·µ£(i, i, f, S', œÜ', g) = Œ¥·µ£(f, g)

theorem foldr_split_inner {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤ ‚Üí Œ≤) (init : Œ≤)
    (l : List Œ±) (h : l ‚â† []): foldr (f:=f) (init:=init) (l)
    = foldr (f:=f) (init:=f (l.getLast (by omega)) (init)) (l.dropLast)

@[simp]
theorem snoc_zero_zero : snoc (0 : Fin n ‚Üí‚ÇÄ M) 0 = 0

theorem pow_one {a : CNat 50} : a ^ 1 = a

theorem cast_symm {hn} (hSpec : pSpec‚ÇÅ.cast hn = pSpec‚ÇÇ) : pSpec‚ÇÇ.cast hn.symm = pSpec‚ÇÅ

lemma neg_add_cancel {k : ‚Ñï} (a : ConcreteBTField k) : neg a + a = 0

@[simp]
protected lemma elocPolyF_eq_elocPoly :
  ElocPolyF (n := n) (liftF' œâs) (liftF' f) = ElocPoly n œâs f

@[simp]
lemma divide_by_2_empty :
    divide_by_2 ‚àÖ = ‚àÖ

@[to_additive (attr := simp) vsum_zero]
lemma vprod_zero [CommMonoid Œ±] {a : Fin 0 ‚Üí Œ±} : vprod a = 1

@[simp] lemma twoAdicGenerators_succ_square_eq' (idx : Fin twoAdicity) :
    twoAdicGenerators[idx.val + 1] ^ 2 = twoAdicGenerators[idx]

@[simp]
theorem append_right_cancel_iff {pSpec : ProtocolSpec m} {p1 p2 : ProtocolSpec n} :
    pSpec ++‚Çö p1 = pSpec ++‚Çö p2 ‚Üî p1 = p2

theorem degrees_peval {x : œÉ‚ÇÅ ‚Üí R} {f : œÉ ‚Üí œÉ‚ÇÅ ‚äï œÉ‚ÇÇ} {p : MvPolynomial œÉ R} :
    (peval f x p).degrees ‚â§ (p.degrees.map f).filterMap Sum.getRight?

theorem eq_of_degreeOf_lt_card_of_eval_eq {p q : R[X œÉ]} (S : œÉ ‚Üí Finset R)
    (hDegree : ‚àÄ i, p.degreeOf i < #(S i))
    (hEval : ‚àÄ x ‚àà piFinset fun i ‚Ü¶ S i, eval x p = eval x q) : p = q

@[simp]
theorem induction_one {motive : Fin 2 ‚Üí Sort*} {zero : motive 0}
    {succ : ‚àÄ i : Fin 1, motive i.castSucc ‚Üí motive i.succ} :
      induction (motive := motive) zero succ (last 1) = succ 0 zero

lemma degree_normalizedW (i : Fin r) :
  (normalizedW ùîΩq Œ≤ i).degree = (Fintype.card ùîΩq)^(i.val)

@[simp]
lemma invFun_toFun (f : F) : inst.equiv.invFun (inst.equiv.toFun f) = f

lemma rowRank_eq_colRank : rowRank U = colRank U

theorem fconcat‚ÇÇ_left_injective {Œ±‚ÇÅ : Fin n ‚Üí A} {Œ±‚ÇÇ : Fin n ‚Üí B} {Œ≤‚ÇÅ : A} {Œ≤‚ÇÇ : B} (a : F‚ÇÇ Œ≤‚ÇÅ Œ≤‚ÇÇ) :
    Function.Injective (fun v : (i : Fin n) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i) => fconcat‚ÇÇ (F := F‚ÇÇ) v a)

@[simp, grind] lemma fin_chunkSize_plus_absorbPos_lt_N (absorbPos arrSize : Nat)
    (i : Fin (min arrSize (SpongeSize.R - absorbPos))) :
    absorbPos + i < SpongeSize.N

@[simp]
theorem fconcat‚ÇÇ_castSucc {Œ±‚ÇÅ : Fin n ‚Üí A} {Œ±‚ÇÇ : Fin n ‚Üí B} {Œ≤‚ÇÅ : A} {Œ≤‚ÇÇ : B}
    (v : (i : Fin n) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i)) (a : F‚ÇÇ Œ≤‚ÇÅ Œ≤‚ÇÇ) (i : Fin n) :
    fconcat‚ÇÇ (F := F‚ÇÇ) v a (castSucc i) =
      cast (by simp [vconcat_castSucc]) (v i)

lemma powerBasisSucc_dim (k : ‚Ñï) :
  powerBasisSucc (k:=k).dim = 2

theorem le_iff_toNat_le (a b : AssocNat) : a ‚â§ b ‚Üî toNat a ‚â§ toNat b

lemma natDegree_definingPoly {F : Type*} [Field F] [Fintype F] (s : F) [NeZero s] :
  (definingPoly s).natDegree = 2

lemma getLowBits_succ {n: ‚Ñï} (numLowBits: ‚Ñï) :
    getLowBits (numLowBits + 1) n = getLowBits numLowBits n
    + (getBit numLowBits n) <<< numLowBits

theorem append_soundness (V‚ÇÅ : OracleVerifier oSpec Stmt‚ÇÅ OStmt‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : OracleVerifier oSpec Stmt‚ÇÇ OStmt‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ pSpec‚ÇÇ)
    {soundnessError‚ÇÅ soundnessError‚ÇÇ : ‚Ñù‚â•0}
    (h‚ÇÅ : V‚ÇÅ.soundness init impl lang‚ÇÅ lang‚ÇÇ soundnessError‚ÇÅ)
    (h‚ÇÇ : V‚ÇÇ.soundness init impl lang‚ÇÇ lang‚ÇÉ soundnessError‚ÇÇ) :
      (V‚ÇÅ.append V‚ÇÇ).soundness init impl lang‚ÇÅ lang‚ÇÉ (soundnessError‚ÇÅ + soundnessError‚ÇÇ)

theorem degreeOf_X_le (i j : œÉ) : degreeOf i (X (R := R) j) ‚â§ 1

lemma exists_a_set_and_a_matching_polynomial
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  :
  ‚àÉ S', ‚àÉ (h_sub : S' ‚äÜ coeffs_of_close_proximity k œâs Œ¥ u‚ÇÄ u‚ÇÅ), ‚àÉ P : F[Z][X],
    #S' > #(coeffs_of_close_proximity k œâs Œ¥ u‚ÇÄ u‚ÇÅ) / (2 * D_Y Q) ‚àß
    ‚àÄ z : S', Pz (h_sub z.2) = P.map (Polynomial.evalRingHom z.1) ‚àß
    P.natDegree ‚â§ k ‚àß
    Bivariate.degreeX P ‚â§ 1

theorem fcons_right_injective {Œ≤ : Fin n ‚Üí A} (a : F Œ±) :
    Function.Injective (fcons a : ((i : Fin n) ‚Üí F (Œ≤ i)) ‚Üí (i : Fin (n + 1)) ‚Üí _)

lemma getBit_of_binaryFinMapToNat {n : ‚Ñï} (m : Fin n ‚Üí ‚Ñï) (h_binary: ‚àÄ j: Fin n, m j ‚â§ 1) :
    ‚àÄ k: ‚Ñï, Nat.getBit k (binaryFinMapToNat m h_binary).val
      = if h_k: k < n then m ‚ü®k, by omega‚ü© else 0

@[simp]
theorem removeNth_last : removeNth (Fin.last n) s = init s

theorem natDegree_finSuccEquivNth (f : MvPolynomial (Fin (n + 1)) R) :
    (finSuccEquivNth R p f).natDegree = degreeOf p f

omit [DecidableEq L] h_Fq_char_prime hF‚ÇÇ hŒ≤_lin_indep in
lemma Prod_W_comp_X_sub_C_ne_zero (i : Fin r) :
    (univ : Finset ùîΩq).prod (fun c => (W ùîΩq Œ≤ i).comp (X - C (c ‚Ä¢ Œ≤ i))) ‚â† 0

@[simp]
lemma OracleVerifier.id_toVerifier :
    (OracleVerifier.id : OracleVerifier oSpec Statement OStatement _ _ _).toVerifier =
      Verifier.id

@[simp]
theorem prover_last_of_two (pSpec : ProtocolSpec 2) [ProverLast pSpec] :
    pSpec.dir 1 = .P_to_V

@[simp, grind] lemma squeezePos_lt_N (sponge : DuplexSponge U C) :
    sponge.squeezePos < SpongeSize.N

theorem eval_zeroOne_eq_MLE_toEvalsZeroOne (p : MvPolynomial œÉ R) (x : œÉ ‚Üí Fin 2) :
    eval (x : œÉ ‚Üí R) p = eval (x : œÉ ‚Üí R) (MLE p.toEvalsZeroOne)

@[simp]
theorem take_append_left :
    (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).take m (Nat.le_add_right m n) = pSpec‚ÇÅ

@[simp]
lemma relHammingDist_le_one : Œ¥·µ£(u, v) ‚â§ 1

@[simp]
theorem OracleReduction.runWithLog_eq_runWithLog_reduction [‚àÄ i, OracleInterface (pSpec.Message i)]
    {stmt : StmtIn} {oStmt : ‚àÄ i, OStmtIn i} {wit : WitIn}
    {oracleReduction : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec} :
      oracleReduction.run stmt oStmt wit =
        oracleReduction.toReduction.run ‚ü®stmt, oStmt‚ü© wit

@[simp]
lemma finite_relHammingDistRange [Nonempty Œπ] : (relHammingDistRange Œπ).Finite

@[simp]
lemma codewordIsZero_makeZero {Œπ : ‚Ñï} {F : Type*} [Zero F] :
  makeZero Œπ F = 0

@[simp]
theorem runWithOracle_freeMonad_pure (f : spec.FunctionType) (a : Option Œ±) :
    runWithOracle f (FreeMonad.pure a) = a

theorem mul_distrib_add (m n p : ChurchNat Œ±) : mul m (add n p) = add (mul m n) (mul m p)

Nat.pow_lt_pow_right in Init.Data.Nat.Lemmas

@[simp]
theorem OracleReduction.id_runWithLog (stmt : StmtIn) (oStmt : ‚àÄ i, OStmtIn i) (wit : WitIn) :
    (OracleReduction.id : OracleReduction oSpec StmtIn OStmtIn WitIn _ _ _ _).runWithLog
      stmt oStmt wit = pure ‚ü®‚ü®default, ‚ü®stmt, oStmt‚ü©, wit‚ü©, ‚ü®stmt, oStmt‚ü©, [], []‚ü©

lemma aeval_definingPoly_at_Z_succ (k : ‚Ñï) :
  (aeval (Z (k + 1))) (definingPoly (s:=Z (k))) = 0

theorem distFromCode_eq_of_lt_half_dist (C : Set (n ‚Üí R)) (u : n ‚Üí R) {v w : n ‚Üí R}
    (hv : v ‚àà C) (hw : w ‚àà C) (huv : Œî‚ÇÄ(u, v) < ‚ÄñC‚Äñ‚ÇÄ / 2) (hvw : Œî‚ÇÄ(u, w) < ‚ÄñC‚Äñ‚ÇÄ / 2) : v = w

theorem pow_exp_of_2_repr_given_x_square_repr {F : Type*} [instField : Field F]
  (sumZeroIffEq : ‚àÄ (x y : F), x + y = 0 ‚Üî x = y) (x z : F) (h_z_non_zero : z ‚â† 0)
  (h_x_square : x ^ 2 = x * z + 1)
  : ‚àÄ i : ‚Ñï, x^(2^i) = x * z^(2^i - 1) + ‚àë j ‚àà Finset.Icc 1 i, z^(2^i - 2^j)

@[simp]
theorem vflatten_succ {m : ‚Ñï} {n : Fin (m + 1) ‚Üí ‚Ñï} {v : (i : Fin (m + 1)) ‚Üí Fin (n i) ‚Üí Œ±} :
    vflatten v = vappend (v 0) (vflatten (fun i => v i.succ))

theorem zero_mul {a : AssocNat} : 0 * a = 0

@[simp]
theorem hcons_fin_zero {Œ± : Sort u} {Œ≤ : Fin 0 ‚Üí Sort u} (a : Œ±) (v : (i : Fin 0) ‚Üí Œ≤ i) :
    hcons a v = fun i => match i with

omit [Fintype L] [Fintype ùîΩq] h_Fq_char_prime in
lemma finrank_U (i : Fin r) :
  Module.finrank ùîΩq (U ùîΩq Œ≤ i) = i

theorem mulVecLin_coeff_vandermondens_eq_eval_matrixOfPolynomials
  {n : ‚Ñï} [NeZero n] {v : Œπ ‚Ü™ F} {p : F[X]} (h_deg : p.natDegree < n) :
  (Vandermonde.nonsquare (Œπ' := n) v).mulVecLin (Fin.liftF' p.coeff) =
  fun i => p.eval (v i)

theorem split_sum_eq_sum_split {k : ‚Ñï} (h_pos : k > 0) (x‚ÇÄ x‚ÇÅ : ConcreteBTField k)
  (hi‚ÇÄ lo‚ÇÄ hi‚ÇÅ lo‚ÇÅ : ConcreteBTField (k - 1))
  (h_split_x‚ÇÄ : split h_pos x‚ÇÄ = (hi‚ÇÄ, lo‚ÇÄ))
  (h_split_x‚ÇÅ : split h_pos x‚ÇÅ = (hi‚ÇÅ, lo‚ÇÅ)) :
  split h_pos (x‚ÇÄ + x‚ÇÅ) = (hi‚ÇÄ + hi‚ÇÅ, lo‚ÇÄ + lo‚ÇÅ)

theorem happend_left_eq_hcons {Œ± : Fin 1 ‚Üí Sort u} {Œ≤ : Fin n ‚Üí Sort u}
    (a : (i : Fin 1) ‚Üí Œ± i) (v : (i : Fin n) ‚Üí Œ≤ i) :
    True

Fin.val_succ in Init.Data.Fin.Lemmas

lemma domain_injective (i : ‚Ñï) : i ‚â§ n ‚Üí Function.Injective (domain D n i)

@[simp] theorem ofNat_succ (n : Nat) : ofNat n.succ = succ (ofNat n)

@[simp, grind _=_]
theorem monomialXY_pow {n m k : ‚Ñï} {a : F} :
  monomialXY n m a ^ k = monomialXY (n * k) (m * k) (a ^ k)

theorem queryOracleVerifier_rbrKnowledgeSoundness [Fintype L] {œÉ : Type} (init : ProbComp œÉ)
    (impl : QueryImpl []‚Çí (StateT œÉ ProbComp)) :
    (queryOracleVerifier ùîΩq Œ≤ (œë:=œë) Œ≥_repetitions).rbrKnowledgeSoundness init impl
    (relIn := finalSumcheckRelOut ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (relOut := acceptRejectOracleRel)
    (rbrKnowledgeError := queryRbrKnowledgeError ùîΩq Œ≤ Œ≥_repetitions
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))

theorem dcast‚ÇÇ_dcast : dcast‚ÇÇ rfl rfl c = dcast dcast_eq.symm c

lemma getBit_of_two_pow_sub_one {i k: ‚Ñï} : getBit k (2^i - 1) =
    if k < i then 1 else 0

@[simp] theorem mul_zero {a : AssocNat} : a * 0 = 0

theorem join_eq_iff_dcast_extractLsb {k : ‚Ñï} (h_pos : k > 0) (x : ConcreteBTField k)
  (hi_btf lo_btf : ConcreteBTField (k - 1)) :
  x = „Ää hi_btf, lo_btf „Äã ‚Üî
  (hi_btf = dcast (h_sub_middle h_pos) (BitVec.extractLsb (hi := 2 ^ k - 1) (lo := 2 ^ (k - 1)) x) ‚àß
  lo_btf = dcast (h_middle_sub) (BitVec.extractLsb (hi := 2 ^ (k - 1) - 1) (lo := 0) x))

@[simp]
theorem Iio_zero : Iio (0 : Fin (n + 1)) = ‚àÖ

lemma getBit_of_xor {n m k: ‚Ñï} : getBit k (n ^^^ m) = getBit k n ^^^ getBit k m

theorem intermediateNormVpoly_comp_qmap_helper (i : Fin (‚Ñì))
    (k : Fin (‚Ñì - (‚Üëi + 1))) :
    (intermediateNormVpoly ùîΩq Œ≤ h_‚Ñì_add_R_rate
      ‚ü®‚Üëi + 1, by omega‚ü© (k:=‚ü®k, by simp only; omega‚ü©)).comp (qMap ùîΩq Œ≤ ‚ü®‚Üëi, by omega‚ü©) =
    intermediateNormVpoly ùîΩq Œ≤ h_‚Ñì_add_R_rate
      ‚ü®‚Üëi, by omega‚ü© ‚ü®k + 1, by simp only; omega‚ü©

theorem induction_heq {n n' : ‚Ñï} {motive : Fin (n + 1) ‚Üí Sort u} {motive' : Fin (n' + 1) ‚Üí Sort u}
    {zero : motive 0} {zero' : motive' 0}
    {succ : ‚àÄ i : Fin n, motive i.castSucc ‚Üí motive i.succ}
    {succ' : ‚àÄ i : Fin n', motive' i.castSucc ‚Üí motive' i.succ}
    {i : Fin (n + 1)} {i' : Fin (n' + 1)}
    (hn : n = n') (hmotive : HEq motive motive') (hzero : HEq zero zero')
    (hsucc : HEq succ succ') (hi : HEq i i') :
      HEq (induction (motive := motive) zero succ i)
        (induction (motive := motive') zero' succ' i')

lemma liftF_eq_of_lt {i : ‚Ñï} (h : i < n) : liftF f' i = f' ‚ü®i, h‚ü©

theorem singleton_bound (C : Set (n ‚Üí R)) :
    (ofFinite C).card ‚â§ (ofFinite R).card ^ (card n - (‚ÄñC‚Äñ‚ÇÄ - 1))

theorem SkeletonNodeIndex.rightChild_bind_parent {s : Skeleton}
    (idx : SkeletonNodeIndex s) :
    idx.rightChild >>= parent = idx.rightChild.map (fun _ => idx)

lemma solutionToE_eq_polynomialOfCoeffs
  (h : n < e) : (solutionToE e k v).coeff n = (polynomialOfCoeffs v).coeff n

lemma join_split_eq_join {k : ‚Ñï} (h_pos : k > 0) (x : ConcreteBTField k) :
  „Ää (split h_pos x).fst, (split h_pos x).snd „Äã = x

theorem ofFn_rtake_get {Œ± : Type*} {m : ‚Ñï} (l : List Œ±) (h : m ‚â§ l.length) :
    List.ofFn (rtake m h l.get) = l.rtake m

theorem liftContext_knowledgeSoundness [Inhabited InnerStmtOut] [Inhabited InnerWitIn]
    {outerRelIn : Set (OuterStmtIn √ó OuterWitIn)} {outerRelOut : Set (OuterStmtOut √ó OuterWitOut)}
    {innerRelIn : Set (InnerStmtIn √ó InnerWitIn)} {innerRelOut : Set (InnerStmtOut √ó InnerWitOut)}
    {knowledgeError : ‚Ñù‚â•0}
    {stmtLens : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut}
    {witLens : Witness.InvLens OuterStmtIn OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    (V : Verifier oSpec InnerStmtIn InnerStmtOut pSpec)
    [lensKS : Extractor.Lens.IsKnowledgeSound outerRelIn innerRelIn outerRelOut innerRelOut
      (V.compatStatement stmtLens) (fun _ _ => True) ‚ü®stmtLens, witLens‚ü©]
    (h : V.knowledgeSoundness init impl innerRelIn innerRelOut knowledgeError) :
      (V.liftContext stmtLens).knowledgeSoundness init impl outerRelIn outerRelOut
        knowledgeError

theorem vcons_eq_const (a : Œ±) : a ::·µõ (fun _ : Fin n => a) = fun _ => a

theorem toMvPolynomial_is_multilinear (p : MlPoly R n) :
  (toMvPolynomial p) ‚àà R‚¶É‚â§ 1‚¶Ñ[X Fin n]

theorem johnson_bound [Field F]
  (h_condition : JohnsonConditionStrong B v)
  :
  let d := d B
  let q : ‚Ñö := Fintype.card F
  let frac := q / (q - 1)
  B.card ‚â§ (frac * d/n) / JohnsonDenominator B v

theorem peval_eq_eval_sumToIter_rename (f : œÉ ‚Üí œÉ‚ÇÅ ‚äï œÉ‚ÇÇ) (x : œÉ‚ÇÅ ‚Üí R) (p : MvPolynomial œÉ R) :
    peval f x p = eval (C ‚àò x) (sumToIter R œÉ‚ÇÅ œÉ‚ÇÇ (rename f p))

theorem BitVec.bitvec_cast_eq_dcast {n m : Nat} (h : n = m) (bv : BitVec n) :
  BitVec.cast h bv = DCast.dcast h bv

theorem vconcat_init_self (v : Fin (n + 1) ‚Üí Œ±) :
    vconcat (fun i => v (Fin.castSucc i)) (v (Fin.last n)) = v

theorem oracleVerifier_eq_verifier :
    (oracleVerifier R deg D oSpec).toVerifier = verifier R deg D oSpec

theorem Nat.shiftRight_lo_mod_2_pow_hi_shiftLeft_lo (n hi_len lo_len : ‚Ñï)
  (h_n : n < 2 ^ (hi_len + lo_len)) :
  (((n >>> lo_len) % (2 ^ hi_len)) <<< lo_len) = (n - n % 2 ^ lo_len)

@[simp]
lemma numFullRounds_pos : 0 < params.numFullRounds

@[simp]
theorem vflatten_splitSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (v : (k : Fin (vsum n)) ‚Üí Œ±) (k : Fin (vsum n)) :
    vflatten (fun i j => v (embedSum i j)) k = v k

lemma e_leq_dist_over_3 [DecidableEq F] {deg : ‚Ñï} {Œ± : Œπ ‚Ü™ F} {e : ‚Ñï} {u v : Œπ ‚Üí F}
  (he : (e : ‚Ñö) < (Code.minDist (RScodeSet Œ± deg) : ‚Ñö) / 3) :
  ‚àÄ x ‚àà Affine.line u v, distFromCode x (ReedSolomon.code Œ± deg) ‚â§ e
  ‚à® (numberOfClosePts u v deg Œ± e) ‚â§ Code.minDist (RScodeSet Œ± deg)

@[simp] theorem rightpad_getD_eq_getD (l : List Œ±) (n : Nat) (unit : Œ±) (i : Nat) :
    (rightpad n unit l).getD i unit = l.getD i unit

theorem hconcat_right_injective {Œ± : Fin n ‚Üí Sort u} {Œ≤ : Sort u} (v : (i : Fin n) ‚Üí Œ± i) :
    Function.Injective (hconcat v : Œ≤ ‚Üí (i : Fin (n + 1)) ‚Üí vconcat Œ± Œ≤ i)

theorem castSum_castLT {l' : List ‚Ñï} {i : ‚Ñï} (j : Fin i) :
    castSum (i :: l') (by simp) j =
      castLT j (Nat.lt_of_lt_of_le j.isLt (List.le_sum_of_mem (by simp)))

omit h_Fq_char_prime hF‚ÇÇ in
lemma inductive_rec_form_W_comp (i : Fin r) (h_i_add_1 : i + 1 < r)
    (h_prev_linear_map : IsLinearMap (R := ùîΩq) (M := L[X]) (M‚ÇÇ := L[X])
      (f := fun inner_p ‚Ü¶ (W ùîΩq Œ≤ i).comp inner_p))
    : ‚àÄ p: L[X], (W ùîΩq Œ≤ (i + 1)).comp p =
      ((W ùîΩq Œ≤ i).comp p) ^ Fintype.card ùîΩq -
        C (eval (Œ≤ i) (W ùîΩq Œ≤ i)) ^ (Fintype.card ùîΩq - 1) * ((W ùîΩq Œ≤ i).comp p)

theorem trim_twice [LawfulBEq R] (p : UniPoly R) : p.trim.trim = p.trim

theorem drop_eq_rtake' {Œ± : Sort*} (m : ‚Ñï) (h : m ‚â§ n) (v : Fin n ‚Üí Œ±) :
    drop m h v = rtake (n - m) (by omega) v

@[simp]
theorem zero_vappend {u : Fin 0 ‚Üí Œ±} (v : Fin n ‚Üí Œ±) :
    vappend u v = v ‚àò Fin.cast (Nat.zero_add n)

@[simp]
theorem fcons_zero {Œ≤ : Fin n ‚Üí A} (a : F Œ±) (b : (i : Fin n) ‚Üí F (Œ≤ i)) :
    fcons a b 0 = cast (by simp [vcons_zero]) a

@[simp]
theorem ranges_nil : List.ranges [] = []

lemma rtake_eq_rtake : transcript‚ü¶m:‚üß = transcript.drop m h

@[simp]
lemma wt_constantCode [DecidableEq F] [NeZero x] :
  wt (constantCode x Œπ) = Fintype.card Œπ

lemma neg_mod_2_eq_0_iff_mod_2_eq_0 {n : ‚Ñ§} : ( - n) % 2 = 0 ‚Üî n % 2 = 0

@[simp]
theorem insertNth_zero : insertNth 0 y s = cons y s

lemma getBit_eq_testBit (k n : Nat) : getBit k n = if n.testBit k then 1 else 0

protected lemma roots_of_eloc_poly {x : F}
  (h : (ElocPoly n œâs f p).eval x = 0) :
  ‚àÉ i, i < n ‚àß f i ‚â† p.eval (œâs i)

@[simp]
theorem Vector.ofFn_get {Œ± : Type*} {n : ‚Ñï} (v : Vector Œ± n) : Vector.ofFn (Vector.get v) = v

lemma nonDoomedFoldingProp_relay_preserved (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i)
    (challenges : Fin i.succ ‚Üí L)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j)
    :
    nonDoomedFoldingProp ùîΩq Œ≤ i.castSucc (Fin.init challenges) oStmt ‚Üî
    nonDoomedFoldingProp ùîΩq Œ≤ i.succ challenges (mapOStmtOutRelayStep ùîΩq Œ≤ i hNCR oStmt)

@[simp]
lemma polynomialOfCoeffs_eq_zero :
  polynomialOfCoeffs coeffs = 0 ‚Üî ‚àÄ (x : ‚Ñï) (h : x < deg), coeffs ‚ü®x, h‚ü© = 0

theorem degreeOf_X_of_ne (i j : œÉ) (h : i ‚â† j) : degreeOf i (X (R := R) j) = 0

@[simp]
lemma weight_constantCode [DecidableEq F] :
  wt (constantCode x Œπ) = 0 ‚Üî IsEmpty Œπ ‚à® x = 0

theorem leftpad_eq_self (v : Fin n ‚Üí Œ±) (a : Œ±) : leftpad n a v = v

lemma poly_eq_zero_of_dist_lt {n k : ‚Ñï} {F : Type*} [DecidableEq F] [CommRing F] [IsDomain F]
  {p : Polynomial F} {œâs : Fin n ‚Üí F}
  (h_deg : p.natDegree < k)
  (hn : k ‚â§ n)
  (h_inj : Function.Injective œâs)
  (h_dist : Œî‚ÇÄ(p.eval ‚àò œâs, 0) < n - k + 1)
  : p = 0

@[simp]
lemma Transcript.def_eq {k : Fin (n + 1)} {pSpec : ProtocolSpec n} :
    (pSpec.take k k.is_le).FullTranscript =
      ((i : Fin k) ‚Üí pSpec.¬´Type¬ª (Fin.castLE (by omega) i))

lemma weight_Œæ_bound (x‚ÇÄ : F) {D : ‚Ñï} (hD : D ‚â• Bivariate.totalDegree H) :
  weight_Œõ_over_ùí™ (Œæ x‚ÇÄ R H) D ‚â§
    WithBot.some ((Bivariate.natDegreeY R - 1) * (D - Bivariate.natDegreeY H + 1))

@[simp]
theorem hflatten_embedSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {Œ± : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí Sort*}
    (v : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí Œ± i j) (i : Fin m) (j : Fin (n i)) :
    hflatten v (embedSum i j) = cast (vflatten_embedSum Œ± i j).symm (v i j)

@[simp]
lemma ofPolynomialAlgHom_toPolynomialAlgHom_C {r : R} :
    ofPolynomialAlgHom (toPolynomialAlgHom (C r : P)) = (Polynomial.C r : R[X])

lemma rank_eq_rowRank : U.rank = rowRank U

theorem oracleReduction_perfectCompleteness (hInit : init.neverFails) :
    (oracleReduction R deg D oSpec).perfectCompleteness init impl
      (inputRelation R deg D) (outputRelation R deg)

Nat.lt_succ_of_lt in Init.Data.Nat.Basic

@[simp]
lemma finite_possibleRelHammingDists : (possibleRelHammingDists C).Finite

omit [NeZero r] [NeZero ùì°] in
lemma isCommitmentRoundOfNonLastBlock (bIdx : Fin (‚Ñì / œë - 1)) :
    isCommitmentRound ‚Ñì œë ‚ü®‚ÜëbIdx * œë + (œë - 1), by
      have hpos: œë > 0 := by exact Nat.pos_of_neZero œë
      conv_rhs => rw [‚ÜêNat.add_zero (n:=‚Ñì)]
      change bIdx.val * œë + (‚ü®œë - 1, by omega‚ü©: Fin œë).val < ‚Ñì + 0
      apply bIdx_mul_œë_add_i_lt_‚Ñì_succ (m:=0)
    ‚ü©

theorem commitOracleVerifier_rbrKnowledgeSoundness (i : Fin ‚Ñì)
    (hCR : isCommitmentRound ‚Ñì œë i) :
    (commitOracleVerifier ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      i hCR).rbrKnowledgeSoundness init impl
      (relIn := foldStepRelOut (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i.succ)
      (commitKnowledgeError ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))

@[simp]
theorem ConcreteBTField.RingHom_eq_of_dest_eq (k m n : ‚Ñï) (h_eq : m = n) :
    (ConcreteBTField k ‚Üí+* ConcreteBTField m)
    = (ConcreteBTField k ‚Üí+* ConcreteBTField n)

theorem succ'_injective : Function.Injective (succ' : Nat ‚Üí Nat)

theorem nsmul_zero : nsmul 0 p = 0
</all_available_lemmas>

<local_ctx>
import ArkLib.Data.FieldTheory.BinaryField.Tower.Prelude

import ArkLib.Data.RingTheory.AlgebraTower

import Mathlib.Tactic.DepRewrite

namespace BinaryTower

noncomputable section

open Polynomial AdjoinRoot Module

section BTFieldDefs

structure BinaryTowerResult (F : Type _) (k : ‚Ñï) where
  vec : (List.Vector F (k + 1))
  instField : (Field F)
  instFintype : Fintype F
  specialElement : F
  specialElementNeZero : NeZero specialElement
  firstElementOfVecIsSpecialElement [Inhabited F] : vec.1.headI = specialElement
  instIrreduciblePoly : (Irreducible (p := (definingPoly specialElement)))
  sumZeroIffEq : ‚àÄ (x y : F), x + y = 0 ‚Üî x = y
  fieldFintypeCard : Fintype.card F = 2^(2^k)
  traceMapEvalAtRootsIs1 : TraceMapProperty F specialElement k

structure BinaryTowerInductiveStepResult (k : ‚Ñï) (prevBTField : Type _)
  (prevBTResult : BinaryTowerResult prevBTField k) [instPrevBTFieldIsField : Field prevBTField]
  (prevPoly : Polynomial prevBTField) (F : Type _) where
  binaryTowerResult : BinaryTowerResult F (k+1)
  eq_adjoin : F = AdjoinRoot prevPoly
  u_is_root : Eq.mp (eq_adjoin) binaryTowerResult.specialElement = AdjoinRoot.root prevPoly
  eval_defining_poly_at_root : Eq.mp (eq_adjoin) binaryTowerResult.specialElement^2 +
    Eq.mp (eq_adjoin) binaryTowerResult.specialElement * (of prevPoly) prevBTResult.specialElement
    + 1 = 0

def binary_tower_inductive_step
  (k : Nat)
  (prevBTField : Type _) [Field prevBTField]
  (prevBTResult : BinaryTowerResult prevBTField k)
: Œ£' (F : Type _), BinaryTowerInductiveStepResult (k:=k) (prevBTField:=prevBTField)
  (prevBTResult:=prevBTResult) (prevPoly:=definingPoly (F:=prevBTField)
    (instField:=prevBTResult.instField) (s:=prevBTResult.specialElement)) (F:=F)
  (instPrevBTFieldIsField:=prevBTResult.instField) :=

def BinaryTowerAux (k : ‚Ñï) : (Œ£' (F : Type 0), BinaryTowerResult F k) :=
  match k with
  | 0 => 
    let curBTField := GF(2)
    let newList : List.Vector (GF(2)) 1 := List.Vector.cons (1 : GF(2)) List.Vector.nil
    let specialElement : GF(2) := newList.1.headI
    let firstElementOfVecIsSpecialElement : newList.1.headI = specialElement := rfl
    let specialElementIs1 : specialElement = 1 := by admit /- proof elided -/

@[simp]
def BTField (k : ‚Ñï) := (BinaryTowerAux k).1

@[simp]
instance Inhabited (k : ‚Ñï) : Inhabited (BTField k) where
  default := (0 : BTField k)

@[simp]
def sumZeroIffEq (k : ‚Ñï) : ‚àÄ (x y : BTField k),
  x + y = 0 ‚Üî x = y := (BinaryTowerAux k).2.sumZeroIffEq

@[simp]
def Z (k : ‚Ñï) : BTField k := (BinaryTowerAux k).snd.specialElement 

@[simp]
def poly (k : ‚Ñï) : Polynomial (BTField k) := definingPoly (s:=(Z k))

instance polyMonic (n : ‚Ñï) : Monic (poly n) := definingPoly_is_monic (Z n)

end BTFieldDefs

section BinaryAlgebraTower

def canonicalEmbedding (k : ‚Ñï) : BTField k ‚Üí+* BTField (k+1) :=
  AdjoinRoot.of (poly k)

def towerAlgebraMap (l r : ‚Ñï) (h_le : l ‚â§ r) : BTField l ‚Üí+* BTField r :=

def binaryAlgebraTower {l r : ‚Ñï} (h_le : l ‚â§ r) : Algebra (BTField l) (BTField r) :=

instance (priority := 1000) algebra_adjacent_tower (l : ‚Ñï) :
  Algebra (BTField l) (BTField (l+1)) :=

end BinaryAlgebraTower

noncomputable section MultilinearBasis

def join_via_add_smul {k : ‚Ñï} (h_pos : k > 0) (hi_btf lo_btf : BTField (k - 1)) :
    BTField k :=

def split (k : ‚Ñï) (h_k : k > 0) (x : BTField k) : BTField (k-1) √ó BTField (k-1) :=
</local_ctx>

<target_theorem>
theorem eq_join_via_add_smul_eq_iff_split (k : ‚Ñï) (h_pos : k > 0)
    (x : BTField k) (hi_btf lo_btf : BTField (k - 1)) :
    x = ‚ãò hi_btf, lo_btf ‚ãô ‚Üî
  split (k:=k) (h_k:=h_pos) x = (hi_btf, lo_btf) :=
</target_theorem>

