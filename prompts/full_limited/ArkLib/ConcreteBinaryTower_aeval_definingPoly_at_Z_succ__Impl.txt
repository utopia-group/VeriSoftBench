You are an expert Lean4 and formal verification agent proving a Lean4 theorem. Your output **must** strictly adhere to the specified format.

### Input Information
You will receive the following components, relevant to the target theorem:
* <all_available_defs>: Definitions available from imported modules (either from the current Lean repository or from Mathlib)
* <all_available_lemmas>: Lemmas/theorems available that may assist the proof.
* <local_ctx>...</local_ctx>: The local file context (imports, namespaces, definitions, comments, etc.) from the top of the file up to‚Äîbut not including‚Äîthe target theorem or any previously defined local lemmas/theorems.
* <target_theorem>...</target_theorem>: The target theorem statement, ending with `:=`.

**Notes**
1. Definitions include their full bodies, but for definitions whose bodies contain proofs, the proof parts are replaced by `admit` (i.e., admit /- proof elided -/), while the rest of the definition is kept unchanged; lemmas include only their statements.
2. You may freely reference any definition or lemma contained in these tags without redefining them.
3. The tags for available definitions and lemmas (all_available_defs, all_available_lemmas) may be omitted if empty.

### Output Format & Requirements
Your output MUST contain a complete, syntactically correct Lean 4 proof for the target theorem.

**Strict Output Structure:**
<reasoning> 
...
</reasoning> 

<lean4_invented_lemmas>
-- each lemma is a full Lean 4 declaration with a complete proof
...
</lean4_invented_lemmas>

<lean4_proof>
-- Lean 4 proof body of the target theorem
...
</lean4_proof>

**Requirements:**
1. <reasoning> and <lean4_invented_lemmas> are OPTIONAL. Include them only if they aid proof construction.
2. <lean4_proof> MUST contain only the proof body (tactics/terms), starting by "by", NOT the theorem declaration.
3. <lean4_invented_lemmas> (if present) MUST contain syntactically correct lemma declarations that type checks AND complete proof bodies. Defining a lemma using `axiom` is NOT allowed.
4. <reasoning> contains high-level proof planning.
5. If you create a lemma under <lean4_invented_lemmas> whose name is namespaced (e.g., X.Y.Z), you MUST always refer to it using its fully qualified name. Do NOT rely on shortened names. For example, write rw [X.Y.Z], not rw [Z] for invented lemmas.
6. All Lean 4 code MUST be syntactically correct. No `sorry`, `admit`, or non-Lean text. Comments allowed using `--` or `/- ... -/`.
7. Follow the tags and structure EXACTLY. No extra text before, between, or after the sections.
8. Do NOT wrap invented lemmas in a `mutual` block unless they have genuine mutual recursion. Declare each lemma independently.

### Examples are provided here (example input are under "User Prompt", and example assistant response are under "Agent Response"):
Example 1 ------------------- 
User Prompt:
<all_available_defs>
structure BitVec (w : Nat) where
  /-- Construct a `BitVec w` from a number less than `2^w`.
  O(1), because we use `Fin` as the internal representation of a bitvector. -/
  ofFin ::

  /-- Interpret a bitvector as a number less than `2^w`.
  O(1), because we use `Fin` as the internal representation of a bitvector. -/
  toFin : Fin (hPow 2 w)
</all_available_defs>

<all_available_lemmas>
theorem List.getElem_append_left{Œ± : Type u_1} {l‚ÇÅ l‚ÇÇ : List Œ±} {i : Nat} (hn : i < l‚ÇÅ.length) : (l‚ÇÅ ++ l‚ÇÇ)[i] = l‚ÇÅ[i]
theorem getElem_eq_testBit_toNat (x : BitVec w) (i : Nat) (h : i < w) :
  x[i] = x.toNat.testBit i := rfl
@[simp, grind =] theorem toNat_cons (b : Bool) (x : BitVec w) :
    (cons b x).toNat = (b.toNat <<< w) ||| x.toNat
@[simp, grind =] theorem getLsbD_of_ge (x : BitVec w) (i : Nat) (ge : w ‚â§ i) : getLsbD x i = false
theorem testBit_toNat (x : BitVec w) : x.toNat.testBit i = x.getLsbD i
</all_available_lemmas>

<local_ctx>
import Mathlib.Computability.NFA
import Mathlib.Data.FinEnum
import Mathlib.Data.Rel
import Mathlib.Data.Vector.Basic
import Blase.AutoStructs.ForLean

open Set
open Mathlib
open SetRel

-- this is better because card is defeq to n
instance (Œ± : Type) : Inter (Language Œ±) := ‚ü®Set.inter‚ü©
instance (Œ± : Type) : Union (Language Œ±) := ‚ü®Set.union‚ü©

/--
The set of `n`-tuples of bit vectors of an arbitrary width.
-/
structure BitVecs (n : Nat) where
  w : Nat
  bvs : List.Vector (BitVec w) n

def BitVecs.cast (bvs : BitVecs n) (h : n = n') : BitVecs n' :=
  { w := bvs.w, bvs := h ‚ñ∏ bvs.bvs }

abbrev BitVecs.empty : BitVecs n := ‚ü®0, List.Vector.replicate n .nil‚ü©
abbrev BitVecs.singleton {w : Nat} (bv : BitVec w) : BitVecs 1 := ‚ü®w, bv ::·µ• .nil‚ü©
abbrev BitVecs.pair {w : Nat} (bv1 bv2 : BitVec w) : BitVecs 2 := ‚ü®w, bv1 ::·µ• bv2 ::·µ• .nil‚ü©

/--
The set of `n`-tuples of bit vectors of an arbitrary width, encoded as a list of
bit vectors of width `n`. The width of the encoded bit vectors is the length of
the list.
-/
abbrev BitVecs' (n : Nat) := List (BitVec n)

@[simps]
def dec (bvs' : BitVecs' n) : BitVecs n where
  w := bvs'.length
  bvs := List.Vector.ofFn fun k => BitVec.ofFn fun i => bvs'[i].getLsbD k

@[simp]
</local_ctx>

<target_theorem>
lemma dec_snoc n (bvs' : BitVecs' n) (a : BitVec n) :
  dec (bvs' ++ [a]) =
    { w := bvs'.length + 1
      bvs := List.Vector.ofFn fun k =>
        BitVec.cons (a.getLsbD k) ((dec bvs').bvs.get k) } :=
</target_theorem>

Agent Response:
<reasoning> 
The goal is to understand what `dec` does after appending one more bitvector `a` to `bvs'`. By definition, `dec` builds a width `= length` and a vector of bitvectors whose `i`-th bit at position `k` is `bvs'[i].getLsbD k`. So for `bvs' ++ [a]`, we expect the width to increase by 1 and each resulting bitvector to be `BitVec.cons` of the new bit coming from `a`.

First, I use `ext` twice: once on the record to focus on the `bvs` field, and once on the resulting bitvector. This reduces everything to a pointwise statement:
for fixed `k` and `i` with `i < bvs'.length + 1`,
the bit `(bvs' ++ [a])[i].getLsbD k` should match the bit at index `i` of `BitVec.cons (a.getLsbD k) ((dec bvs').bvs.get k)`.

At this point I need a clean description of indexing into `BitVec.cons`: if we have `x : BitVec n`, then `(cons b x)[i]` should give `b` at the new ‚Äúlast‚Äù index `n` and `x[i]` otherwise. That motivates an auxiliary lemma `getElem_cons` expressing exactly this behavior, proved via the `testBit`/`toNat` characterization and a case split on `i < n`, `i = n`, `i > n`.

Using `getElem_cons`, the RHS becomes an `if` on whether `i = bvs'.length`. So I split into cases:
- If `i = bvs'.length`, then `(bvs' ++ [a])[i]` is the appended `a`, so both sides reduce to `a.getLsbD k`.
- If `i ‚â† bvs'.length`, the bound `i < bvs'.length + 1` forces `i < bvs'.length`. Then `(bvs' ++ [a])[i] = bvs'[i]` by `List.getElem_append_left`, and the RHS takes the ‚Äúelse‚Äù branch and likewise gives the bit from `bvs'[i]`. In both subcases, `simp` (plus the definition of `dec`) finishes.

So the whole proof is: `ext` to bit level, unfold `dec` with `simp_all`, rewrite with `getElem_cons`, split on the boundary index `i = length bvs'`, and in the ‚Äú< length‚Äù branch use `List.getElem_append_left` and bounds to line up both sides.
</reasoning> 

<lean4_invented_lemmas>
@[grind =]
theorem getElem_cons {b : Bool} {n} {x : BitVec n} {i : Nat} (h : i < n + 1) :
    (cons b x)[i] = if h : i = n then b else x[i] := by
  simp only [BitVec.getElem_eq_testBit_toNat, BitVec.toNat_cons, Nat.testBit_or]
  rw [Nat.testBit_shiftLeft]
  rcases Nat.lt_trichotomy i n with i_lt_n | i_eq_n | n_lt_i
  ¬∑ have p1 : ¬¨(n ‚â§ i) := by omega
    have p2 : i ‚â† n := by omega
    simp [p1, p2]
  ¬∑ simp only [i_eq_n, ge_iff_le, Nat.le_refl, decide_true, Nat.sub_self, Nat.testBit_zero,
    Bool.true_and, BitVec.testBit_toNat, BitVec.getLsbD_of_ge, Bool.or_false]
    cases b <;> trivial
  ¬∑ have p1 : i ‚â† n := by omega
    have p2 : i - n ‚â† 0 := by omega
    simp [p1, p2, Nat.testBit_bool_toNat]
</lean4_invented_lemmas>

<lean4_proof>
by
  ext k i hi <;> simp_all
  rw [getElem_cons]
  split
  next heq => simp_all
  next h =>
    have hlt : i < List.length bvs' := by simp at hi; omega
    rw [List.getElem_append_left hlt]
    simp
</lean4_proof>

### Your task:
<all_available_defs>
Eq in Init.Prelude
id in Init.Prelude
BitVec in Init.Prelude
Nat in Init.Prelude
BitVec.cast in Init.Data.BitVec.Basic
BitVec.append in Init.Data.BitVec.Basic
BitVec.zero in Init.Data.BitVec.Basic
BitVec.extractLsb in Init.Data.BitVec.Basic
BitVec.xor in Init.Data.BitVec.Basic
AddCommGroup in Mathlib.Algebra.Group.Defs
Int in Init.Data.Int.Basic
Int.negSucc in Init.Data.Int.Basic
Ring in Mathlib.Algebra.Ring.Defs
DivisionRing in Mathlib.Algebra.Field.Defs
NNRat in Mathlib.Data.Rat.Init
NNRat.castRec in Mathlib.Algebra.Field.Defs
Rat in Init.Data.Rat.Basic
Rat.castRec in Mathlib.Algebra.Field.Defs
Field in Mathlib.Algebra.Field.Defs
Finset in Mathlib.Data.Finset.Defs
Finset.range in Mathlib.Data.Finset.Range
Polynomial.C in Mathlib.Algebra.Polynomial.Basic
Polynomial.X in Mathlib.Algebra.Polynomial.Basic
AdjoinRoot.instField in Mathlib.RingTheory.AdjoinRoot
Fintype in Mathlib.Data.Fintype.Defs
Fintype.card in Mathlib.Data.Fintype.Card
Irreducible in Mathlib.Algebra.Group.Irreducible.Defs
List in Init.Prelude
List.Vector in Mathlib.Data.Vector.Defs
NeZero in Init.Data.NeZero
Polynomial in Mathlib.Algebra.Polynomial.Basic
AdjoinRoot in Mathlib.RingTheory.AdjoinRoot
AdjoinRoot.of in Mathlib.RingTheory.AdjoinRoot
AdjoinRoot.root in Mathlib.RingTheory.AdjoinRoot
Eq.mp in Init.Core
CharP in Mathlib.Algebra.CharP.Defs
DivisionSemiring in Mathlib.Algebra.Field.Defs
Finset.Icc in Mathlib.Order.Interval.Finset.Defs
GroupWithZero in Mathlib.Algebra.GroupWithZero.Defs
Ne in Init.Core
Equiv in Mathlib.Logic.Equiv.Defs
Equiv.ofBijective in Mathlib.Logic.Equiv.Defs
Fact in Mathlib.Logic.Basic
Fintype.ofEquiv in Mathlib.Data.Fintype.OfMap
Function.Bijective in Mathlib.Logic.Function.Defs
Function.Injective in Init.Data.Function
Function.Surjective in Init.Data.Function
Polynomial.Monic in Mathlib.Algebra.Polynomial.Degree.Definitions
Polynomial.eval‚ÇÇ in Mathlib.Algebra.Polynomial.Eval.Defs
Prod in Init.Prelude
Semiring in Mathlib.Algebra.Ring.Defs
Fintype.ofFinite in Mathlib.Data.Fintype.EquivFin
List.Vector.cons in Mathlib.Data.Vector.Defs
List.Vector.nil in Mathlib.Data.Vector.Defs
toFun in ToMathlib.Control.Monad.Hom
Algebra in Mathlib.Algebra.Algebra.Defs
RingHom in Mathlib.Algebra.Ring.Hom.Defs
RingHom.toAlgebra in Mathlib.Algebra.Algebra.Defs
invFun in ToMathlib.Control.Monad.Equiv
left_inv in ToMathlib.Control.Monad.Equiv
right_inv in ToMathlib.Control.Monad.Equiv
False.elim in Init.Prelude
Finite in Mathlib.Data.Finite.Defs
absurd in Init.Prelude
instAlgebra in Mathlib.LinearAlgebra.TensorAlgebra.Basic
instFintypeProd in Mathlib.Data.Fintype.Prod
reduceDIte in Lean.Meta.Tactic.Simp.BuiltinSimprocs.Core
RingHom.id in Mathlib.Algebra.Ring.Hom.Defs
Polynomial.aeval in Mathlib.Algebra.Polynomial.AlgebraMap
Algebra.algebraMap in Mathlib.Algebra.Algebra.Defs
algebraMap in Mathlib.Algebra.Algebra.Defs
BitVec.ofNat in Init.Prelude
BitVec.extractLsb' in Init.Data.BitVec.Basic
BitVec.setWidth in Init.Data.BitVec.Basic
cast in Init.Prelude
And in Init.Prelude
OfNat in Init.Prelude
pos in ToMathlib.Control.Comonad.Instances
BitVec.toNat in Init.Prelude

notation : 10 "GF(" term : 10 ")" => GaloisField term 1

class DCast (Œ± : Sort*) (Œ≤ : Œ± ‚Üí Sort*) where
  dcast : ‚àÄ {a a' : Œ±}, a = a' ‚Üí Œ≤ a ‚Üí Œ≤ a'
  dcast_id : ‚àÄ {a : Œ±}, dcast (Eq.refl a) = id

@[simp]
def sumZeroIffEq (k : ‚Ñï) : ‚àÄ (x y : BTField k),
  x + y = 0 ‚Üî x = y := (BinaryTowerAux k).2.sumZeroIffEq

@[simp]
def BTField (k : ‚Ñï) := (BinaryTowerAux k).1

def BinaryTowerAux (k : ‚Ñï) : (Œ£' (F : Type 0), BinaryTowerResult F k) :=
  match k with
  | 0 => 
    let curBTField := GF(2)
    let newList : List.Vector (GF(2)) 1 := List.Vector.cons (1 : GF(2)) List.Vector.nil
    let specialElement : GF(2) := newList.1.headI
    let firstElementOfVecIsSpecialElement : newList.1.headI = specialElement := rfl
    let specialElementIs1 : specialElement = 1 := by admit /- proof elided -/

structure BinaryTowerInductiveStepResult (k : ‚Ñï) (prevBTField : Type _)
  (prevBTResult : BinaryTowerResult prevBTField k) [instPrevBTFieldIsField : Field prevBTField]
  (prevPoly : Polynomial prevBTField) (F : Type _) where
  binaryTowerResult : BinaryTowerResult F (k+1)
  eq_adjoin : F = AdjoinRoot prevPoly
  u_is_root : Eq.mp (eq_adjoin) binaryTowerResult.specialElement = AdjoinRoot.root prevPoly
  eval_defining_poly_at_root : Eq.mp (eq_adjoin) binaryTowerResult.specialElement^2 +
    Eq.mp (eq_adjoin) binaryTowerResult.specialElement * (of prevPoly) prevBTResult.specialElement
    + 1 = 0

structure BinaryTowerResult (F : Type _) (k : ‚Ñï) where
  vec : (List.Vector F (k + 1))
  instField : (Field F)
  instFintype : Fintype F
  specialElement : F
  specialElementNeZero : NeZero specialElement
  firstElementOfVecIsSpecialElement [Inhabited F] : vec.1.headI = specialElement
  instIrreduciblePoly : (Irreducible (p := (definingPoly specialElement)))
  sumZeroIffEq : ‚àÄ (x y : F), x + y = 0 ‚Üî x = y
  fieldFintypeCard : Fintype.card F = 2^(2^k)
  traceMapEvalAtRootsIs1 : TraceMapProperty F specialElement k

@[simp]
instance Inhabited (k : ‚Ñï) : Inhabited (BTField k) where
  default := (0 : BTField k)

structure TraceMapProperty (F : Type*) [Field F] (u : F) (k : ‚Ñï) : Prop where
  element_trace : ‚àë i ‚àà Finset.range (2 ^ k), u ^ (2 ^ i) = 1
  inverse_trace : ‚àë i ‚àà Finset.range (2 ^ k), (u‚Åª¬π) ^ (2 ^ i) = 1

noncomputable def definingPoly {F : Type*} [instField : Field F] (s : F)
  := X ^ 2 + C s * X + 1

def binary_tower_inductive_step
  (k : Nat)
  (prevBTField : Type _) [Field prevBTField]
  (prevBTResult : BinaryTowerResult prevBTField k)
: Œ£' (F : Type _), BinaryTowerInductiveStepResult (k:=k) (prevBTField:=prevBTField)
  (prevBTResult:=prevBTResult) (prevPoly:=definingPoly (F:=prevBTField)
    (instField:=prevBTResult.instField) (s:=prevBTResult.specialElement)) (F:=F)
  (instPrevBTFieldIsField:=prevBTResult.instField) :=

def AlgebraTowerEquiv.symm (e : AlgebraTowerEquiv A B) : AlgebraTowerEquiv B A where
  toRingEquiv := fun i => (e.toRingEquiv i).symm
  commutesLeft' := fun i j h r => by admit /- proof elided -/

structure AlgebraTowerEquiv (A : Œπ ‚Üí Type*) [‚àÄ i, CommSemiring (A i)] [a : AlgebraTower A]
  (B : Œπ ‚Üí Type*) [‚àÄ i, CommSemiring (B i)] [b : AlgebraTower B]
  where
    toRingEquiv : ‚àÄ i, (A i ‚âÉ+* B i)
    commutesLeft' : ‚àÄ (i j : Œπ) (h : i ‚â§ j) (r : A i),
      (b.algebraMap (i:=i) (j:=j) (h:=h)) ((toRingEquiv i) r) =
      (toRingEquiv j) (a.algebraMap (i:=i) (j:=j) (h:=h) r)

structure SpecialElementRelation {F_prev : Type*} [Field F_prev] (t1 : F_prev)
  {F_cur : Type*} [Field F_cur] (u : F_cur) [Algebra F_prev F_cur] : Prop where
    sum_inv_eq : u + u‚Åª¬π = algebraMap F_prev F_cur t1
    h_u_square : u^2 = u * (algebraMap F_prev F_cur t1) + 1

instance irreducible_quadratic_defining_poly_of_traceMap_eq_1
  {F : Type*} [Field F] [Fintype F] [CharP F 2] (s : F) [NeZero s] (k : ‚Ñï)
  (trace_map_prop : TraceMapProperty F s k)
  (fintypeCard : Fintype.card F = 2 ^ (2 ^ k))
  : Irreducible (definingPoly s) :=

instance charP_eq_2_of_add_self_eq_zero {F : Type*} [Field F]
    (sumZeroIffEq : ‚àÄ (x y : F), x + y = 0 ‚Üî x = y) : CharP F 2 :=
  have h_two : (2 : (F)) = 0 := by admit /- proof elided -/

def coeff.{u} {F : Type u} [Semiring F] (f : F[X][Y]) (i j : ‚Ñï) : F := (f.coeff j).coeff i

instance GF_2_fintype : Fintype (GF(2)) := Fintype.ofFinite (GF(2))

@[reducible, simp] def StmtOut := Query OStatement

def StraightlineExtractor (oSpec : OracleSpec Œπ) (Data Commitment : Type) :=
  Commitment ‚Üí QueryLog oSpec ‚Üí Data

@[inline]
def seqCompose {m : ‚Ñï} (Stmt : Fin (m + 1) ‚Üí Type) (Wit : Fin (m + 1) ‚Üí Type)
    {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (R : (i : Fin m) ‚Üí
      Reduction oSpec (Stmt i.castSucc) (Wit i.castSucc) (Stmt i.succ) (Wit i.succ) (pSpec i)) :
    Reduction oSpec (Stmt 0) (Wit 0) (Stmt (Fin.last m)) (Wit (Fin.last m)) (seqCompose pSpec) where
  prover := Prover.seqCompose Stmt Wit (fun i => (R i).prover)
  verifier := Verifier.seqCompose Stmt (fun i => (R i).verifier)

MvPolynomial.degrees in Mathlib.Algebra.MvPolynomial.Degrees

Add in Init.Prelude

Matrix.vecMul in Mathlib.Data.Matrix.Mul

Algebra.TensorProduct.comm in Mathlib.RingTheory.TensorProduct.Maps

def Permute.ofEquiv (Œ± : Type*) (e : Equiv Œ± Œ±) : Permute Œ± where
  permute := e.toFun

noncomputable def intermediateNormVpoly
    
    (i: Fin (‚Ñì+1)) (k : Fin (‚Ñì - i + 1)) : L[X] :=
  
  Fin.foldl (n:=k) (fun acc j =>
    (qMap ùîΩq Œ≤ ‚ü®(i : ‚Ñï) + (j : ‚Ñï), by admit /- proof elided -/
    ‚ü©).comp acc) (X)

Matrix.col in Mathlib.LinearAlgebra.Matrix.Defs

def relHammingBall (C : Code Œπ F) (y : Œπ ‚Üí F) (r : ‚Ñù) : Code Œπ F :=
  { c | c ‚àà C ‚àß Code.relHammingDist y c ‚â§ r }

instance domain_neg_inst {F : Type} [NonBinaryField F] [Finite F] {D : Subgroup FÀ£} {n : ‚Ñï}
    [DIsCyclicC : IsCyclicWithGen ‚Ü•D] [DSmooth : SmoothPowerOfTwo n ‚Ü•D]
    {x : FÀ£} (i : Fin n) : Neg (evalDomain D x i) where
  neg := fun a => ‚ü®_, neg_mem_dom_of_mem_dom D x i a.2‚ü©

def toFinMatrix {m n : ‚Ñï} (matrix : Matrix Œ± m n) : _root_.Matrix (Fin m) (Fin n) Œ± :=
  fun i j => (matrix.get i).get j

def verify [BEq Œ≥] (cm : Œ≥) (v : Œ±) (r : Œ≤) : OracleComp (ROspec Œ± Œ≤ Œ≥) Unit := do
  let cm' ‚Üê (query (spec := ROspec Œ± Œ≤ Œ≥) () (v, r) : OracleComp (ROspec Œ± Œ≤ Œ≥) Œ≥)
  guard (cm' == cm)

@[reducible, simp]
def relIn : Set (Statement √ó Unit) := { ‚ü®stmt, _‚ü© | pred stmt }

abbrev ùí™ (H : F[X][Y]) : Type :=
  (Polynomial (Polynomial F)) ‚ß∏ (Ideal.span {H_tilde' H})

noncomputable def hasMutualCorrAgreement
  (Gen : ProximityGenerator Œπ F) [Fintype Gen.par‚Ñì]
  (BStar : ‚Ñù) (errStar : ‚Ñù ‚Üí ENNReal) :=
    haveI := Gen.Gen_nonempty
    ‚àÄ (f : Gen.par‚Ñì ‚Üí Œπ ‚Üí F) (Œ¥ : ‚Ñù‚â•0) (_hŒ¥ : 0 < Œ¥ ‚àß Œ¥ < 1 - BStar),
    Pr_{let r ‚Üê$·µñ Gen.Gen}[ proximityCondition f Œ¥ r Gen.C ] ‚â§ errStar Œ¥

Finset.Iic in Mathlib.Order.Interval.Finset.Defs

def sumcheckConsistencyProp {k : ‚Ñï} (sumcheckTarget : L) (H : L‚¶É‚â§ 2‚¶Ñ[X Fin (k)]) : Prop :=
  sumcheckTarget = ‚àë x ‚àà (univ.map ùìë) ^·∂† (k), H.val.eval x

def add (m n : ChurchNat Œ±) : ChurchNat Œ± := fun f x => m f (n f x)

instance instInvConcreteBTF {k : ‚Ñï} : Inv (ConcreteBTField k) where
  inv := concrete_inv

structure RoundByRound
    (oSpec : OracleSpec Œπ) (StmtIn WitIn WitOut : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n)
    (WitMid : Fin (n + 1) ‚Üí Type) where
   
  eqIn : WitMid 0 = WitIn
   
  extractMid : (m : Fin n) ‚Üí StmtIn ‚Üí Transcript m.succ pSpec ‚Üí WitMid m.succ ‚Üí WitMid m.castSucc
   
  extractOut : StmtIn ‚Üí FullTranscript pSpec ‚Üí WitOut ‚Üí WitMid (.last n)

@[inline, specialize]
def Reduction.run (stmt : StmtIn) (wit : WitIn)
    (reduction : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí)
        ((FullTranscript pSpec √ó StmtOut √ó WitOut) √ó StmtOut) := do
  
  let proverResult ‚Üê reduction.prover.run stmt wit
  let stmtOut ‚Üê liftM (reduction.verifier.run stmt proverResult.1)
  return ‚ü®proverResult, stmtOut‚ü©

@[reducible, simp]
def soundness
    (langIn : Set (Statement √ó ‚àÄ i, OStatement i))
    (verifier : OracleVerifier oSpec Statement OStatement Bool (fun _ : Empty => Unit) pSpec)
    (soundnessError : ‚Ñù‚â•0) : Prop :=
  verifier.toVerifier.soundness init impl langIn acceptRejectOracleRel.language soundnessError

toFun in ToMathlib.Control.Monad.Hom

gen in VCVio.CryptoFoundations.FiatShamir

def SkeletonInternalIndex.toNodeIndex {s : Skeleton} (idx : SkeletonInternalIndex s) :
    SkeletonNodeIndex s :=
  match idx with
  | SkeletonInternalIndex.ofInternal => SkeletonNodeIndex.ofInternal
  | SkeletonInternalIndex.ofLeft idxLeft =>
    SkeletonNodeIndex.ofLeft (SkeletonInternalIndex.toNodeIndex idxLeft)
  | SkeletonInternalIndex.ofRight idxRight =>
    SkeletonNodeIndex.ofRight (SkeletonInternalIndex.toNodeIndex idxRight)

Polynomial.ofFn in Mathlib.Algebra.Polynomial.OfFn

@[reducible] def NonInteractiveVerifier (Message : Type) {Œπ : Type} (oSpec : OracleSpec Œπ)
    (StmtIn StmtOut : Type) :=
  Verifier oSpec StmtIn StmtOut ‚ü®!v[.P_to_V], !v[Message]‚ü©

instance : ‚àÄ i, SelectableType (Challenge ‚ü®!v[.P_to_V], !v[Msg]‚ü© i)
  | ‚ü®0, h‚ü© => nomatch h

noncomputable def Bstar (x : ‚Ñù) : ‚Ñù := x.sqrt

def foldl' {Œ± : Type u} (n : ‚Ñï) (f : (i : Fin n) ‚Üí Œ± ‚Üí Œ±) (init : Œ±) : Œ± :=
  dfoldl' n (fun _ => Œ±) f init

def BerlekampWelchMatrix
  (e k : ‚Ñï)
  (œâs f : Fin n ‚Üí F) : Matrix (Fin n) (Fin (2 * e + k)) F :=
  Matrix.of fun i j =>
    let Œ±·µ¢ := œâs i
    if ‚Üëj < e then -Rhs j.1 œâs f i else -Œ±·µ¢^(j - e)

instance : MonadLift (StateT œÑ m) (StateT (œÉ √ó œÑ) m) where
  monadLift := fun x st => do let y ‚Üê x st.2; return (y.1, st.1, y.2)

List.repr in Init.Data.Repr

BitVec.zero in Init.Data.BitVec.Basic

def monomialY (n : ‚Ñï) : F[X] ‚Üí‚Çó[F[X]] F[X][Y] where
  toFun t := ‚ü®Finsupp.single n t‚ü©
  map_add' x y := by admit /- proof elided -/

def fullRound (params : Params) (state : Vector KoalaBear.Field params.width)
    (roundConstants : Vector KoalaBear.Field params.width) : Vector KoalaBear.Field params.width :=
  
  let stateWithConstants := state.zipWith (¬∑+¬∑) roundConstants
  
  let stateAfterSbox := stateWithConstants.map (fun x => x ^ sBoxDegree)
  
  externalLinearLayer params stateAfterSbox

def FullTranscript.removeSalt (transcript : (pSpec.addSalt Salt).FullTranscript) :
    pSpec.FullTranscript :=
  Transcript.removeSalt (pSpec := pSpec) (k := Fin.last n) transcript

Sum in Init.Core

List.Vector.mmap in Mathlib.Data.Vector.Basic

def ranges {n : ‚Ñï} (a : Fin n ‚Üí ‚Ñï) : (i : Fin n) ‚Üí Fin (a i) ‚Üí ‚Ñï :=
  match n with
  | 0 => fun i => elim0 i
  | n + 1 => fun i => by admit /- proof elided -/

instance : Repr ByteArray where
  reprPrec b n := List.repr b.toList n

Finset.fold in Mathlib.Data.Finset.Fold

@[simp]
def testLensE : Extractor.Lens OuterStmtIn_Test OuterStmtOut_Test InnerStmtIn_Test InnerStmtOut_Test
                Unit Unit Unit Unit where
  stmt := testStmtLens
  wit := Witness.InvLens.id

@[inline] def toT [Zero T] (c : Cayley T) : T := c.toFun 0

noncomputable def basisVectors (‚Ñì : Nat) (h_‚Ñì : ‚Ñì ‚â§ r) :
  Fin (2 ^ ‚Ñì) ‚Üí L‚¶É<2^‚Ñì‚¶Ñ[X] :=
  fun j => ‚ü®X‚±º ùîΩq Œ≤ ‚Ñì h_‚Ñì j, by admit /- proof elided -/
  ‚ü©

def pSpecFullNonLastBlock (bIdx : Fin (‚Ñì / œë - 1)) :=
  (pSpecFoldRelaySequence (L:=L) (n:=œë - 1) ++‚Çö
      pSpecFoldCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        ‚ü®‚ÜëbIdx * œë + (œë - 1), by admit /- proof elided -/
          ‚ü©)

def getRootIndex (s : Skeleton) : SkeletonNodeIndex s := match s with
  | Skeleton.leaf => SkeletonNodeIndex.ofLeaf
  | Skeleton.internal _ _ =>
    SkeletonNodeIndex.ofInternal

def numOMsgQueries (i : pSpec.MessageIdx)
    (stmt : StmtIn) (challenges : ‚àÄ i, pSpec.Challenge i)
    (naVerifier : OracleVerifier.NonAdaptive oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec) : ‚Ñï :=
  (naVerifier.queryMsg stmt challenges).filter (fun q => q.1 = i) |>.length

Finset.map in Mathlib.Data.Finset.Image

noncomputable def oddPart (f : Polynomial F) : Polynomial F :=
    C (2‚Åª¬π : F) * (f - f.comp (-X)) /‚Çò X

def FullData.EquivIndexFun {Œ± : Type} (s : Skeleton) :
    FullData Œ± s ‚âÉ (SkeletonNodeIndex s ‚Üí Œ±) where
  toFun := fun tree idx => tree.get idx
  invFun := fun f => FullData.ofFun s f
  left_inv := by admit /- proof elided -/

@[reducible, simp]
def knowledgeSoundness (relation : Set (Statement √ó Bool))
    (verifier : Verifier oSpec Statement Bool pSpec)
    (knowledgeError : ‚Ñù‚â•0) : Prop :=
  verifier.knowledgeSoundness init impl relation acceptRejectRel knowledgeError

PFunctor.Lens in ToMathlib.PFunctor.Basic

def MlPoly.mk {R : Type*} (n : ‚Ñï) (v : Vector R (2 ^ n)) : MlPoly R n := v

def IterType (n : ‚Ñï) : Type := dfoldl' n (fun _ => Type) (fun _ T => T √ó T) Nat


example : IterType 0 = Nat := rfl
example (n : ‚Ñï) : IterType (n + 1) = (IterType n √ó IterType n) := rfl

def absorb (ds : DomainSeparator U H) (count : Nat) (label : String) : DomainSeparator U H :=
  
  
  
  
  { io := ds.io ++ SEP_BYTE ++ s!"A{count}" ++ label }

def partialSum {Œ± : Type*} [AddMonoid Œ±] (l : List Œ±) : List Œ± :=
  [0] ++ match l with
  | [] => []
  | a :: l' => (partialSum l').map (a + ¬∑)

instance instDCast‚ÇÇ : DCast‚ÇÇ Nat ProtocolSpec (fun _ pSpec => ChallengeIdx pSpec) where
  dcast‚ÇÇ h := ChallengeIdx.cast h
  dcast‚ÇÇ_id := cast_id

CanLift in Mathlib.Tactic.Lift

Fintype.piFinset in Mathlib.Data.Fintype.Pi

GaloisField in Mathlib.FieldTheory.Finite.GaloisField

def finUInt8Equiv : Fin (2 ^ 8) ‚âÉ UInt8 where
  toFun := fun i => UInt8.ofFin i
  invFun := fun u => u.toFin
  left_inv _ := rfl
  right_inv _ := rfl

instance (priority := low) : DCast‚ÇÇ Œ± Œ≤ Œ≥ where
  dcast‚ÇÇ ha hb c := by admit /- proof elided -/

def getBit (k n : Nat) : Nat := (n >>> k) &&& 1

Eq in Init.Prelude

instance [IsSingleRound pSpec] [h : VCVCompatible (pSpec.Challenge default)] :
    (i : pSpec.ChallengeIdx) ‚Üí VCVCompatible (pSpec.Challenge i) := fun i => by admit /- proof elided -/

instance [VerifierFirst pSpec] : Unique (pSpec.ChallengeIdx) where
  default := ‚ü®0, by admit /- proof elided -/
  ‚ü©
  uniq := fun ‚ü®i, _‚ü© => by admit /- proof elided -/

@[simp]
abbrev OracleStatement.AfterFirstMessage : R1CS.MatrixIdx ‚äï Fin 1 ‚Üí Type :=
  Sum.rec (OracleStatement R pp) (fun _ => Witness R pp)

instance : Serde UInt8 ByteArray where

@[reducible]
def duplexSpongeChallengeOracle (StartType : Type) (U : Type) [SpongeUnit U] [SpongeSize] :
    OracleSpec (Unit ‚äï PermuteDir) :=
  (StartType ‚Üí‚Çí Vector U SpongeSize.C) ++‚Çí permutationOracle (CanonicalSpongeState U)

alias ùíü_ùîñ := duplexSpongeChallengeOracle

@[reducible, inline, specialize]
def PlainMessageIdx := {i : pSpec.MessageIdx // (inst.oracleInterfaces i).isNone }

@[reducible, simp]
def relOut : (StmtOut OStatement √ó ‚àÄ i, OStmtOut OStatement i) ‚Üí WitOut ‚Üí Prop :=
  fun ‚ü®‚ü®q, r‚ü©, oStmt‚ü© () => answer (oStmt 0) q = r

structure Gate (ùì° : Type*) (numWires : ‚Ñï) extends Selector ùì°, WireIndices numWires
deriving DecidableEq

Units.mulAction' in Mathlib.Algebra.Group.Action.Units

def removeRedundantEntryDS (log : QueryLog (duplexSpongeChallengeOracle StmtIn U)) :
    {log : QueryLog (duplexSpongeChallengeOracle StmtIn U) | log.NoRedundantEntryDS} :=
  sorry

@[reducible]
def Set.language {Œ± Œ≤} (rel : Set (Œ± √ó Œ≤)) : Set Œ± :=
  Prod.fst '' rel

@[reducible, inline]
instance instPolynomial : OracleInterface R[X] where
  Query := R
  Response := R
  answer := fun poly point => poly.eval point

noncomputable def monomialToNovelCoeffs

  (‚Ñì : ‚Ñï) (h_‚Ñì : ‚Ñì ‚â§ r) (monomial_coeffs : Fin (2 ^ ‚Ñì) ‚Üí L) : Fin (2^‚Ñì) ‚Üí L :=
  let A := changeOfBasisMatrix ùîΩq Œ≤ ‚Ñì h_‚Ñì
  
  
  Matrix.vecMul monomial_coeffs A‚Åª¬π

minpoly in Mathlib.FieldTheory.Minpoly.Basic

Polynomial.evalEvalRingHom in Mathlib.Algebra.Polynomial.Bivariate

class VCVCompatible (Œ± : Type*) extends Fintype Œ±, Inhabited Œ± where
  [type_decidableEq' : DecidableEq Œ±]

def relHammingDistRange (Œπ : Type*) [Fintype Œπ] : Set ‚Ñö‚â•0 :=
  {d : ‚Ñö‚â•0 | ‚àÉ d' : ‚Ñï, d' ‚â§ Fintype.card Œπ ‚àß d = d' / Fintype.card Œπ}

def OracleMessages (pSpec : ProtocolSpec n) [OracleInterfaces pSpec] : Type :=
  ‚àÄ i, pSpec.OracleMessage i

instance instOI‚ÇÇ : ‚àÄ i, OracleInterface
    ((‚ü®!v[.P_to_V], !v[R‚¶É‚â§ deg‚¶Ñ[X]]‚ü© ++‚Çö !p[] ++‚Çö ‚ü®!v[.V_to_P], !v[R]‚ü©).Message i) :=
  instOracleInterfaceMessageAppend

def commit (v : Œ±) : OracleComp (oSpec Œ± Œ≤ Œ≥) Œ≥ := do
  let r : Œ≤ ‚Üê liftComp
    (query (spec := randSpec Œ≤) () () : OracleComp (randSpec Œ≤) Œ≤) _
  let cm : Œ≥ ‚Üê liftComp
    (query (spec := ROspec Œ± Œ≤ Œ≥) () (v, r) : OracleComp (ROspec Œ± Œ≤ Œ≥) Œ≥) _
  return cm

noncomputable def polyQ (P q : Polynomial F) : MvPolynomial (Fin 2) F :=
  
  let Pbi : MvPolynomial (Fin 2) F := uni2bi P
  
  let P' : MvPolynomial (Fin 2) F := (MvPolynomial.X 1) - uni2bi q
  
  have h_unit : IsUnit ((MonomialOrder.lex).leadingCoeff P') := sorry
  modBivar Pbi P' h_unit

noncomputable def evenRefinement (i : Fin (‚Ñì))
    (coeffs : Fin (2 ^ (‚Ñì - i)) ‚Üí L) : L[X] :=
  ‚àë (‚ü®j, hj‚ü©: Fin (2^(‚Ñì-i-1))), C (coeffs ‚ü®j*2, by admit /- proof elided -/
  ‚ü©) * (intermediateNovelBasisX ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i+1, by admit /- proof elided -/
  ‚ü© ‚ü®j, hj‚ü©)

noncomputable def Pz
  {k : ‚Ñï}
  {z : F}
  (hS : z ‚àà coeffs_of_close_proximity k œâs Œ¥ u‚ÇÄ u‚ÇÅ)
  :
  F[X]
  := (exists_Pz_of_coeffs_of_close_proximity (n := n) (k := k) hS).choose

def canonical (p : UniPoly R) := p.trim = p

def commitPrvState (i : Fin ‚Ñì) : Fin (1 + 1) ‚Üí Type := fun
  | ‚ü®0, _‚ü© => Statement (L := L) Context i.succ √ó
    (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j) √ó
    Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ
  | ‚ü®1, _‚ü© => Statement (L := L) Context i.succ √ó
    (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.succ j) √ó
    Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ

@[inline]
def ofOutputOnly (liftStmt : OuterStmtIn ‚Üí InnerStmtOut ‚Üí OuterStmtOut) :
    Statement.Lens OuterStmtIn OuterStmtOut OuterStmtIn InnerStmtOut :=
  ‚ü®id, liftStmt‚ü©

@[inline, specialize]
def oracleVerifier : OracleVerifier oSpec
    Statement OStatement Statement (OStatement ‚äï·µ• (fun _ : Fin 1 => Witness))
    (oraclePSpec Witness) where
  verify := fun stmt _ => pure stmt
  embed := .sumMap (.refl _)
    <| Equiv.toEmbedding
    <|.symm (subtypeUnivEquiv (by admit /- proof elided -/
    ))
  hEq := by admit /- proof elided -/

String in Init.Prelude

ZMod.instField in Mathlib.Algebra.Field.ZMod

@[reducible]
def proverState (i : Fin n) : ProverState 2 where
  PrvState
  | 0 => (StatementRound R n i.castSucc) √ó (‚àÄ i, OracleStatement R n deg i)
  | 1 => (StatementRound R n i.castSucc) √ó (‚àÄ i, OracleStatement R n deg i)
  | 2 => (StatementRound R n i.succ) √ó (‚àÄ i, OracleStatement R n deg i)

@[inline, specialize]
def OracleReduction.runWithLog [‚àÄ i, OracleInterface (pSpec.Message i)]
    (stmt : StmtIn) (oStmt : ‚àÄ i, OStmtIn i) (wit : WitIn)
    (reduction : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec) :
      OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí)
        ((FullTranscript pSpec √ó (StmtOut √ó ‚àÄ i, OStmtOut i) √ó WitOut) √ó
          (StmtOut √ó ‚àÄ i, OStmtOut i) √ó
            QueryLog (oSpec ++‚Çí [pSpec.Challenge]‚Çí) √ó QueryLog oSpec) := do
  let ‚ü®proverResult, proveQueryLog‚ü© ‚Üê
    (simulateQ loggingOracle (reduction.prover.run ‚ü®stmt, oStmt‚ü© wit)).run
  let ‚ü®stmtOut, verifyQueryLog‚ü© ‚Üê
    liftM (simulateQ loggingOracle (reduction.verifier.run stmt oStmt proverResult.1)).run
  return ‚ü®proverResult, stmtOut, proveQueryLog, verifyQueryLog‚ü©

def fiberwiseDistance (i : Fin ‚Ñì) (steps : ‚Ñï) [NeZero steps] (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
  (f : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i.val, by admit /- proof elided -/
  ‚ü©) : ‚Ñï :=
  
  
  let C_i := BBF_Code ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i.val, by admit /- proof elided -/
  ‚ü©
  let disagreement_sizes := (fun (g : C_i) =>
    (fiberwiseDisagreementSet ùîΩq Œ≤ i steps h_i_add_steps f g).ncard) '' Set.univ
  sInf disagreement_sizes

UInt32.ofFin in Init.Data.UInt.Basic

Nat.pow in Init.Prelude

private def f (x : ‚Ñö) : ‚Ñö := x^2 - x

IsDomain in Mathlib.Algebra.Ring.Defs

def OuterStmtIn_Test := ‚Ñ§[X] √ó ‚Ñ§[X] √ó ‚Ñ§

def findFinIdxIfTrue (p : Œ± ‚Üí Bool) (l : List Œ±) (h : ‚àÉ x ‚àà l, p x) : Fin l.length :=
  ‚ü®List.findIdx' p l, by admit /- proof elided -/
  ‚ü©

instance : MonadLift (StateT œÉ m) (StateT (œÉ √ó œÑ) m) where
  monadLift := fun x st => do let y ‚Üê x st.1; return (y.1, y.2, st.2)

@[inline] def add (a b : AssocNat) : AssocNat :=
  ‚ü®a ‚àò b, by admit /- proof elided -/
  ‚ü©

@[inline]
def zero [Zero R] : MlPoly R n := Vector.replicate (2 ^ n) 0

@[inline, specialize]
def OracleReduction.run [‚àÄ i, OracleInterface (pSpec.Message i)]
    (stmt : StmtIn) (oStmt : ‚àÄ i, OStmtIn i) (wit : WitIn)
    (reduction : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec) :
      OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí)
        ((FullTranscript pSpec √ó (StmtOut √ó ‚àÄ i, OStmtOut i) √ó WitOut) √ó
          (StmtOut √ó ‚àÄ i, OStmtOut i)) := do
  let proverResult ‚Üê reduction.prover.run ‚ü®stmt, oStmt‚ü© wit
  let stmtOut ‚Üê liftM (reduction.verifier.run stmt oStmt proverResult.1)
  return ‚ü®proverResult, stmtOut‚ü©

def relayKnowledgeError (m : pSpecRelay.ChallengeIdx) : ‚Ñù‚â•0 :=
  match m with
  | ‚ü®j, _‚ü© => j.elim0

abbrev CNat (n : ‚Ñï) : Type := (CayleyTower n).1

noncomputable def finToSDomain (i : Fin r) (h_i : i < ‚Ñì + R_rate)
  (idx : Fin (2 ^ (‚Ñì + R_rate - i.val))) :
  sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i :=

private noncomputable def evenPart' (f : Polynomial F) : Polynomial F :=
  match f with
  | ‚ü®‚ü®supp, f, pr‚ü©‚ü© => ‚ü®‚ü®erase_odd supp, fun n => if Even n then f n else 0, by admit /- proof elided -/
  ‚ü©‚ü©

instance : SMul ‚Ñï (UniPoly R) := ‚ü®nsmul‚ü©

def toList (xs : ChurchVec Œ±) : List Œ± :=
  churchVecFold xs (fun x acc => x :: acc) []

def rtake (m : ‚Ñï) (h : m ‚â§ n) (pSpec : ProtocolSpec n) : ProtocolSpec m :=
  {dir := Fin.rtake m h pSpec.dir, ¬´Type¬ª := Fin.rtake m h pSpec.¬´Type¬ª}

def fiberwiseDisagreementSet (i : Fin ‚Ñì) (steps : ‚Ñï) [NeZero steps]
    (h_i_add_steps : i.val + steps ‚â§ ‚Ñì) (f g : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate :=
      h_‚Ñì_add_R_rate) ‚ü®i, by admit /- proof elided -/
      ‚ü©) :
  Set ((sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®i.val + steps, by admit /- proof elided -/
  ‚ü©) :=
  
    
  {y | ‚àÉ x, iteratedQuotientMap ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := i)
    (k := steps) (h_bound := by admit /- proof elided -/
    ) x = y ‚àß f x ‚â† g x}

instance : SliceLT (FullTranscript pSpec) ‚Ñï
    (fun _ stop => stop ‚â§ n)
    (fun _ stop _ => FullTranscript (pSpec‚ü¶:stop‚üß))
    where
  sliceLT := fun v stop h => take stop h v

def ConcreteBTField : ‚Ñï ‚Üí Type := fun k => BitVec (2 ^ k)

hammingNorm in Mathlib.InformationTheory.Hamming

@[inline, specialize]
def oracleProver : OracleProver oSpec
    Statement OStatement Unit Statement OStatement Unit !p[] where
  PrvState := fun _ => Statement √ó (‚àÄ i, OStatement i)
  input := Prod.fst
  sendMessage := fun i => nomatch i
  receiveChallenge := fun i => nomatch i
  output := fun stmt => pure (stmt, ())

noncomputable instance changeOfBasisMatrix_invertible
  (‚Ñì : Nat) (h_‚Ñì : ‚Ñì ‚â§ r) :
  Invertible (changeOfBasisMatrix ùîΩq Œ≤ ‚Ñì h_‚Ñì) :=

def toOracleSpec {Œπ : Type u} (v : Œπ ‚Üí Type v) [O : ‚àÄ i, OracleInterface (v i)] :
    OracleSpec Œπ := fun i => ((O i).Query, (O i).Response)

instance instOI‚ÇÅ : ‚àÄ i, OracleInterface ((‚ü®!v[.P_to_V], !v[R‚¶É‚â§ deg‚¶Ñ[X]]‚ü© ++‚Çö !p[]).Message i) :=
  instOracleInterfaceMessageAppend

def append (T‚ÇÅ : FullTranscript pSpec‚ÇÅ) (T‚ÇÇ : FullTranscript pSpec‚ÇÇ) :
    FullTranscript (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ) :=
  Fin.happend T‚ÇÅ T‚ÇÇ

protected def Prover.id : Prover oSpec Statement Witness Statement Witness !p[] where
  PrvState := fun _ => Statement √ó Witness
  input := _root_.id
  sendMessage := fun i => Fin.elim0 i
  receiveChallenge := fun i => Fin.elim0 i
  output := pure

instance finiteDimensional_degreeLT {n : ‚Ñï} (h_n_pos : 0 < n) :
  FiniteDimensional L L‚¶É< n‚¶Ñ[X] :=

def FullData.Equiv {Œ±} (s : Skeleton) :
    FullData Œ± s ‚âÉ InternalData Œ± s √ó LeafData Œ± s :=

def sub (m n : ChurchNat Œ±) : ChurchNat Œ± := sorry 

Vector.drop in Init.Data.Vector.Basic

instance instDCast‚ÇÇ : DCast‚ÇÇ Nat ProtocolSpec (fun _ pSpec => MessageIdx pSpec) where
  dcast‚ÇÇ h := MessageIdx.cast h
  dcast‚ÇÇ_id := cast_id

structure ParamConditions (P : Params Œπ F) where
  m : ‚Ñï 
  h_m : m = P.varCount 0
  h_sumkLt : ‚àë i : Fin (M + 1), P.foldingParam i ‚â§ m
  h_varCount_i : ‚àÄ i : Fin (M + 1),
    P.varCount i = m - ‚àë j : Fin i, P.foldingParam (Fin.castLT j (Nat.lt_trans j.isLt i.isLt))
  h_smooth : ‚àÄ i : Fin (M + 1), Smooth (P.œÜ i)
  h_repeatPLt : ‚àÄ i : Fin (M + 1), P.repeatParam i ‚â§ Fintype.card (Œπ i)

instance : ‚àÄ i, VCVCompatible (Challenge ‚ü®!v[.P_to_V], !v[Msg]‚ü© i)
  | ‚ü®0, h‚ü© => nomatch h

def hli_level_diff_0 (l : ‚Ñï) :
  letI instAlgebra:= ConcreteBTFieldAlgebra (l:=l) (r:=l) (h_le:=by omega)
  @Basis (Fin 1) (ConcreteBTField l) (ConcreteBTField l) _ _ instAlgebra.toModule :=

def implGroupEncodeOracle [Serialize G (BitVec bitLength)] :
    QueryImpl (GroupEncodeOracle Œπ bitLength) (StateT (GroupValTable Œπ G) Option) where
  impl | query _ i => fun table =>
    match table i with
    | some g => some (serialize g, table)
    | none => none

BitVec.extractLsb' in Init.Data.BitVec.Basic

def proverRound (i : Fin n) : ProverRound oSpec (pSpec R deg) where
  PrvState := (proverState R n deg i).PrvState

  sendMessage
  | ‚ü®0, _‚ü© => fun state =>
    match n with
    | 0 => sorry
    | n + 1 =>
      let ‚ü®‚ü®_, challenges‚ü©, oStmt‚ü© := state
      let ‚ü®poly, hp‚ü© := oStmt 0
      pure ‚ü® ‚ü®‚àë x ‚àà (univ.map D) ^·∂† (n - i), poly ‚∏®X ‚¶Éi‚¶Ñ, challenges, x‚∏©'(by admit /- proof elided -/
      ),
        sumcheck_roundPoly_degreeLE R n deg D i hp‚ü©,
          state‚ü©
  | ‚ü®1, h‚ü© => nomatch h

  receiveChallenge
  | ‚ü®0, h‚ü© => nomatch h
  | ‚ü®1, _‚ü© => fun ‚ü®‚ü®target, challenges‚ü©, oStmt‚ü© => pure fun chal =>
    let ‚ü®poly, hp‚ü© := oStmt 0
    letI newChallenges : Fin i.succ ‚Üí R := Fin.snoc challenges chal
    letI newTarget := ‚àë x ‚àà (univ.map D) ^·∂† (n - i - 1), poly ‚∏®newChallenges, x‚∏©'(by admit /- proof elided -/
    )
    ‚ü®‚ü®newTarget, newChallenges‚ü©, fun _ => ‚ü®poly, hp‚ü©‚ü©

noncomputable def codewordToPoly
  [Fintype Œπ] [Field F] [DecidableEq Œπ]
  {deg : ‚Ñï} {domain : Œπ ‚Ü™ F} (f : code domain deg) : F[X] :=
  Lagrange.interpolate Finset.univ domain.toFun f

def ar1 (k : ‚Ñï) : Fin 1 ‚Üí ‚Ñï := fun _ => k

FiniteDimensional in Mathlib.LinearAlgebra.FiniteDimensional.Defs

def duplexSpongeToBasicFSAlgo
    (P : OracleComp (oSpec ++‚Çí duplexSpongeChallengeOracle StmtIn U)
    (StmtIn √ó pSpec.Messages)) :
    OracleComp (oSpec ++‚Çí fsChallengeOracle StmtIn pSpec) (StmtIn √ó pSpec.Messages) :=
  sorry

alias d2SAlgo := duplexSpongeToBasicFSAlgo

inductive MatrixIdx where | A | B | C deriving Inhabited, DecidableEq

@[ext]
structure ProverState (n : ‚Ñï) where
  PrvState : Fin (n + 1) ‚Üí Type

def findSumIdx (l : List Œ±) (j : Œ±) : ‚Ñï := l.partialSum.findIdx (j < ¬∑)

instance instDCast : DCast Nat ProtocolSpec where
  dcast h := ProtocolSpec.cast h
  dcast_id := cast_id

private def k [Zero F] (B : Finset (Fin n ‚Üí F)) : ‚Ñö :=
  (1 : ‚Ñö) / n * ‚àë i, K B i 0

def lastBlockOracleReduction :=
  let bIdx := ‚Ñì / œë - 1
  let stmt : Fin (œë + 1) ‚Üí Type := fun i => Statement (L := L) (‚Ñì := ‚Ñì) Context
    ‚ü®bIdx * œë + i, by admit /- proof elided -/
    ‚ü©
  let oStmt := fun i: Fin (œë + 1) => OracleStatement ùîΩq Œ≤ œë
    ‚ü®bIdx * œë + i, by admit /- proof elided -/
    ‚ü©
  let wit := fun i: Fin (œë + 1) => Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì)
    ‚ü®bIdx * œë + i, by admit /- proof elided -/
    ‚ü©
  let V:  OracleReduction []‚Çí (StmtIn := Statement (L := L) (‚Ñì := ‚Ñì) Context
    ‚ü®bIdx * œë, by admit /- proof elided -/
    ‚ü©)
    (OStmtIn := OracleStatement ùîΩq Œ≤ œë
      ‚ü®bIdx * œë, by admit /- proof elided -/
      ‚ü©)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì)
      ‚ü®bIdx * œë, by admit /- proof elided -/
      ‚ü©)
    (StmtOut := Statement (L := L) (‚Ñì := ‚Ñì) Context (Fin.last ‚Ñì))
    (OStmtOut := OracleStatement ùîΩq Œ≤ œë (Fin.last ‚Ñì))
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) (Fin.last ‚Ñì))
    (pSpec := pSpecLastBlock (L:=L) (œë:=œë)) := by admit /- proof elided -/

@[reducible]
noncomputable def reduction [DecidableEq F] :
  OracleReduction []‚Çí
    (Statement F (0 : Fin (k + 1))) (OracleStatement D x s (0 : Fin (k + 1)))
      (Witness F s d (0 : Fin (k + 2)))
    (FinalStatement F k) (FinalOracleStatement D x s) (Witness F s d (Fin.last (k + 1)))
    (pSpecFold D x k s ++‚Çö FinalFoldPhase.pSpec F ++‚Çö QueryRound.pSpec D x l) :=
  OracleReduction.append (reductionFold D x k s d)
    (QueryRound.queryOracleReduction (k := k) D x s d dom_size_cond l)

@[reducible, simp]
def rbrSoundness
    (langIn : Set (Statement √ó ‚àÄ i, OStatement i))
    (verifier : OracleVerifier oSpec Statement OStatement Bool (fun _ : Empty => Unit) pSpec)
    (rbrSoundnessError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) : Prop :=
  verifier.rbrSoundness init impl langIn acceptRejectOracleRel.language rbrSoundnessError

instance {Œπ : Type u} (v : Œπ ‚Üí Type v) [O : ‚àÄ i, OracleInterface (v i)]
    [h : ‚àÄ i, Fintype (Response (v i))]
    [h' : ‚àÄ i, Inhabited (Response (v i))] :
    [v]‚Çí.FiniteRange where
  range_fintype' := h
  range_inhabited' := h'

Finset.sup in Mathlib.Data.Finset.Lattice.Fold

FreeMonad.roll in ToMathlib.Control.Monad.Free

Fintype.ofIsEmpty in Mathlib.Data.Fintype.OfMap

def eqTilde {L : Type} [CommRing L] {‚Ñì : ‚Ñï} (r r' : Fin ‚Ñì ‚Üí L) : L :=
  MvPolynomial.eval r' (MvPolynomial.eqPolynomial r)

def inputRelation [DecidableEq F] (Œ¥ : ‚Ñù‚â•0) :
    Set
      (
        (Statement (k := k) F 0 √ó (‚àÄ j, OracleStatement (k := k) D x s 0 j)) √ó
        Witness F s d (0 : Fin (k + 2))
      ) :=
  match k with
  | 0 => FinalFoldPhase.inputRelation D x s d (round_bound dom_size_cond) Œ¥
  | .succ _ => FoldPhase.inputRelation D x s d 0 (round_bound dom_size_cond) Œ¥

Matrix.rank in Mathlib.LinearAlgebra.Matrix.Rank

def instDefault {Message : Type u} : OracleInterface Message where
  Query := Unit
  Response := Message
  answer := fun m _ => m

def LeafData.composeBuild {Œ± : Type} {s : Skeleton} (leaf_data_tree : LeafData Œ± s)
    (compose : Œ± ‚Üí Œ± ‚Üí Œ±) :
    FullData Œ± s :=
  match s, leaf_data_tree with
  | Skeleton.leaf, LeafData.leaf value =>
    FullData.leaf value
  | Skeleton.internal _ _, LeafData.internal left right =>
    let left_tree := LeafData.composeBuild left compose
    let right_tree := LeafData.composeBuild right compose
    FullData.internal
      (compose left_tree.getRootValue right_tree.getRootValue)
      left_tree
      right_tree

def mulVec [Zero Œ±] [Add Œ±] [Mul Œ±] {numRows numCols : Nat}
    (M : Vector (Vector Œ± numCols) numRows)
    (x : Vector Œ± numCols) : Vector Œ± numRows :=
  M.map (fun row => row *·µ• x)

Fact in Mathlib.Logic.Basic

Monoid in Mathlib.Algebra.Group.Defs

@[reducible]
def Statement := Fin sz.n_x ‚Üí R

def new (domainSeparator : DomainSeparator U H) : HashStateWithInstructions U H :=
  letI stack := domainSeparator.finalize
  letI tag := generateTag domainSeparator.asBytes
  { ds := Initialize.new tag, stack := stack }

def verifyProof {Œ±} [DecidableEq Œ±] {s}
    (idx : BinaryTree.SkeletonLeafIndex s) (leafValue : Œ±) (rootValue : Œ±)
    (proof : List Œ±) : OracleComp (spec Œ±) Unit := do
  let putative_root ‚Üê getPutativeRoot idx leafValue proof
  guard (putative_root = rootValue)

@[reducible]
def GroupExpOracle : OracleSpec Unit := fun _ => (Œπ √ó ZMod p √ó Œπ, Unit)

Polynomial.compRingHom in Mathlib.Algebra.Polynomial.Eval.Defs

noncomputable def finalSumcheckProver :
  OracleProver
    (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì))
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì))
    (StmtOut := FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì))
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (WitOut := Unit)
    (pSpec := pSpecFinalSumcheckStep (L := L)) where
  PrvState := fun
    | 0 => Statement (L := L) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì) √ó (‚àÄ j, OracleStatement ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì) j)
        √ó Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì)
    | _ => Statement (L := L) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì) √ó (‚àÄ j, OracleStatement ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì) j)
        √ó Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì) √ó L
  input := fun ‚ü®‚ü®stmt, oStmt‚ü©, wit‚ü© => (stmt, oStmt, wit)

  sendMessage
  | ‚ü®0, _‚ü© => fun ‚ü®stmtIn, oStmtIn, witIn‚ü© => do
    let f‚Ñì : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := ‚ü®‚Ñì, by admit /- proof elided -/
    ‚ü©)
      := witIn.f
    
    let c : L := f‚Ñì ‚ü®0, by admit /- proof elided -/
    ‚ü© 
    pure ‚ü®c, (stmtIn, oStmtIn, witIn, c)‚ü©

  receiveChallenge
  | ‚ü®0, h‚ü© => nomatch h 

  output := fun ‚ü®stmtIn, oStmtIn, witIn, c‚ü© => do
    let stmtOut : FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì) := {
      ctx := stmtIn.ctx,
      
      sumcheck_target := stmtIn.sumcheck_target,
      challenges := stmtIn.challenges,
      final_constant := c
    }

    pure (‚ü®stmtOut, oStmtIn‚ü©, ())

def listOfCloseCodewords (C : Code Œπ F) (y : Œπ ‚Üí F) (r : ‚Ñï) : ‚Ñï :=
  Nat.card (hammingBall C y r)

CharP in Mathlib.Algebra.CharP.Defs

def verifier (i : Fin n) : Verifier oSpec
    ((StatementRound R n i.castSucc) √ó (‚àÄ i, OracleStatement R n deg i))
    (StatementRound R n i.succ √ó (‚àÄ i, OracleStatement R n deg i)) (pSpec R deg) where
  verify := fun ‚ü®‚ü®target, challenges‚ü©, oStmt‚ü© transcript => do
    let ‚ü®p_i, _‚ü© : R‚¶É‚â§ deg‚¶Ñ[X] := transcript 0
    let r_i : R := transcript 1
    guard (‚àë x ‚àà (univ.map D), p_i.eval x = target)
    pure ‚ü®‚ü®p_i.eval r_i, Fin.snoc challenges r_i‚ü©, oStmt‚ü©

abbrev ScalarField := ZMod scalarFieldSize

One in Init.Prelude

abbrev Field := ZMod fieldSize

@[inline, reducible]
def lift : OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i) ‚Üí InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i) ‚Üí
    OuterStmtOut √ó (‚àÄ i, OuterOStmtOut i) :=
  lens.toFunB

noncomputable def finalSumcheckRbrExtractor :
  Extractor.RoundByRound []‚Çí
    (StmtIn := (Statement (L := L) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì)) √ó (‚àÄ j, OracleStatement ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë  (Fin.last ‚Ñì) j))
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì))
    (WitOut := Unit)
    (pSpec := pSpecFinalSumcheckStep (L := L))
    (WitMid := FinalSumcheckWit (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì)) where
  eqIn := rfl
  extractMid := fun m ‚ü®stmtMid, oStmtMid‚ü© trSucc witMidSucc => by admit /- proof elided -/
    | none => 
      exact dummyLastWitness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
    | some tpoly =>
      
      exact {
        t := tpoly,
        H := projectToMidSumcheckPoly (L := L) (‚Ñì := ‚Ñì) (t := tpoly)
          (m := BBF_SumcheckMultiplierParam.multpoly stmtMid.ctx)
          (i := Fin.last ‚Ñì) (challenges := stmtMid.challenges),
        f := getMidCodewords ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) tpoly stmtMid.challenges
      }
  extractOut := fun ‚ü®stmtIn, oStmtIn‚ü© tr witOut => ()

instance {s} : Functor (fun Œ± => LeafData Œ± s) where
  map f x := x.map f

RingEquiv in Mathlib.Algebra.Ring.Equiv

def verifyNeOne (n a' q : Q(‚Ñï)) (a : Q(ZMod $n)) (_ : Q(($a' : ZMod $n) = $a)) :
    MetaM Q($a ^ (($n - 1) / $q) ‚â† 1) := do
  
  let p : Q(ZMod $n) := q($a ^ (($n - 1) / $q))
  let .isNat _ c hc ‚Üê Tactic.ReduceModChar.normIntNumeral n p
    q(CommRing.toRing) q(ZMod.charP $n) | failure
  
  
  
  assumeInstancesCommute
  have hn : Q(decide ($n ‚â• 2) = true) := (q(Eq.refl true) : Expr)
  have hc‚ÇÅ : Q(decide ($c < $n) = true) := (q(Eq.refl true) : Expr)
  have hc‚ÇÇ : Q(decide ($c ‚â† 1) = true) := (q(Eq.refl true) : Expr)
  return q(ZMod.blub $a $hn $hc‚ÇÅ $hc‚ÇÇ $hc)

def AlgebraTowerEquiv.toAlgEquivOverLeft (e : AlgebraTowerEquiv A B) (i j : Œπ) (h : i ‚â§ j) :
  letI : Algebra (A i) (A j) :=

cond in Init.Prelude

structure InterleavedCode (Œ∫ Œπ : Type*) [Fintype Œ∫] [Fintype Œπ] (F : Type*) [Semiring F] where
  MF : MatrixSubmodule Œ∫ Œπ F
  LC : LinearCode Œπ F

def SumFunEquivProd (Œ± Œ≤ Œ≥ : Type) : ((Œ± ‚äï Œ≤) ‚Üí Œ≥) ‚âÉ (Œ± ‚Üí Œ≥) √ó (Œ≤ ‚Üí Œ≥) :=
{ toFun := fun f => (fun a => f (.inl a), fun b => f (.inr b))
  , invFun := fun p x => match x with | .inl a => p.fst a | .inr b => p.snd b
  , left_inv := by admit /- proof elided -/

BitVec.toNat in Init.Prelude

Quotient.mk in Init.Core

def canonicalEmbedding (k : ‚Ñï) : BTField k ‚Üí+* BTField (k+1) :=
  AdjoinRoot.of (poly k)

@[reducible, simp] def OStmtOut := fun _ : Fin 2 => OStatement

noncomputable def foldf (S : Finset Œπ) (œÜ : Œπ ‚Ü™ F)
  {k : ‚Ñï} [Neg (indexPowT S œÜ k)] (y : indexPowT S œÜ (k + 1))
  (f : indexPowT S œÜ k ‚Üí F) (Œ± : F) : F :=
  let xPow := extract_x S œÜ k y
  let fx := f xPow
  let f_negx := f (-xPow)
  (fx + f_negx) / 2 + Œ± * ((fx - f_negx) / (2 * (xPow.val : F)))

def internalLinearLayer (state : Vector KoalaBear.Field params.width) :
    Vector KoalaBear.Field params.width :=
  
  
  let sumAll := state.foldl (fun acc x => acc + x) 0

  
  
  state.zipWith (fun s d => sumAll + d * s) params.internalDiagVectors

instance {Œ± : Type*} {n : ‚Ñï} [VCVCompatible Œ±] : VCVCompatible (Vector Œ± n) where

@[reducible, simp] def OStmtIn := fun _ : Fin 2 => OStatement

class Deserialize (Œ± : Type u) (Œ≤ : Type v) where
  deserialize : Œ≤ ‚Üí Œ±

noncomputable def proximityCondition
   (f : par‚Ñì ‚Üí Œπ ‚Üí F) (Œ¥ : ‚Ñù) (r : par‚Ñì ‚Üí F) (C : LinearCode Œπ F) : Prop :=
  Œ¥·µ£( (fun x => ‚àë j : par‚Ñì, (r j) * f j x) , C ) ‚â§ (Œ¥ : ‚Ñù)

def acceptRejectOracleRel : Set ((Bool √ó (‚àÄ _ : Empty, Unit)) √ó Unit) :=
  { ((true, isEmptyElim), ()) }

class Verifier.IsPure (V : Verifier oSpec StmtIn StmtOut pSpec) where
    is_pure : ‚àÉ verify : _ ‚Üí _ ‚Üí _, ‚àÄ stmtIn transcript,
      V.verify stmtIn transcript = pure (verify stmtIn transcript)

noncomputable def queryOracleReduction [DecidableEq F] :
  OracleReduction []‚Çí
    (FinalStatement F k) (FinalOracleStatement D x s) (Witness F s d (Fin.last (k + 1)))
    (FinalStatement F k) (FinalOracleStatement D x s) (Witness F s d (Fin.last (k + 1)))
    (pSpec D x l) where
  prover := queryProver D x s d l
  verifier := queryVerifier D x s (round_bound domain_size_cond) l

Function.Bijective in Mathlib.Logic.Function.Defs

instance : IsEmpty (OracleQuery []‚Çí Œ±) where
  false := by admit /- proof elided -/

Lagrange.basis in Mathlib.LinearAlgebra.Lagrange

@[simp]
def testLens : Context.Lens OuterStmtIn_Test OuterStmtOut_Test InnerStmtIn_Test InnerStmtOut_Test
                Unit Unit Unit Unit where
  stmt := testStmtLens
  wit := Witness.Lens.id

abbrev drop (m : ‚Ñï) (h : m ‚â§ n)
    (transcript : FullTranscript pSpec) : FullTranscript (pSpec.drop m h) :=
  Fin.drop m h transcript

Mathlib.Meta.NormNum.IsNat in Mathlib.Tactic.NormNum.Result

def relHammingBallInterleavedCode [DecidableEq F] (U : Matrix Œ∫ Œπ F)
  (IC : MatrixSubmodule Œ∫ Œπ F) (r : ‚Ñù) :=
    {V | V ‚àà IC ‚àß relDistCodewords U V < r}

def oracleReduction.sendEvalClaim :
    OracleReduction oSpec
      (Statement.AfterFirstSumcheck R pp) (OracleStatement.AfterFirstSumcheck R pp) (Witness R pp)
      (Statement.AfterSendEvalClaim R pp) (OracleStatement.AfterSendEvalClaim R pp) Unit
      ‚ü®!v[.P_to_V], !v[‚àÄ i, EvalClaim R i]‚ü© :=
  sorry

noncomputable def ansPoly (S : Finset F) (Ans : S ‚Üí F) : Polynomial F :=
  Lagrange.interpolate S.attach (fun i => (i : F)) Ans

structure NonAdaptive {Œπ : Type} (oSpec : OracleSpec Œπ)
    (StmtIn : Type) {Œπ‚Çõ·µ¢ : Type} (OStmtIn : Œπ‚Çõ·µ¢ ‚Üí Type)
    (StmtOut : Type) {Œπ‚Çõ‚Çí : Type} (OStmtOut : Œπ‚Çõ‚Çí ‚Üí Type)
    {n : ‚Ñï} (pSpec : ProtocolSpec n)
    [O‚Çõ·µ¢ : ‚àÄ i, OracleInterface (OStmtIn i)]
    [O‚Çò : ‚àÄ i, OracleInterface (pSpec.Message i)]
    where

   
  queryOStmt : StmtIn ‚Üí (‚àÄ i, pSpec.Challenge i) ‚Üí List ((i : Œπ‚Çõ·µ¢) √ó (O‚Çõ·µ¢ i).Query)

   
  queryMsg : StmtIn ‚Üí (‚àÄ i, pSpec.Challenge i) ‚Üí List ((i : pSpec.MessageIdx) √ó (O‚Çò i).Query)

   
  verify : StmtIn ‚Üí (‚àÄ i, pSpec.Challenge i) ‚Üí
    List ((i : Œπ‚Çõ·µ¢) √ó ((O‚Çõ·µ¢ i).Query √ó (O‚Çõ·µ¢ i).Response)) ‚Üí
    List ((i : pSpec.MessageIdx) √ó ((O‚Çò i).Query √ó (O‚Çò i).Response)) ‚Üí OracleComp oSpec StmtOut

  embed : Œπ‚Çõ‚Çí ‚Ü™ Œπ‚Çõ·µ¢ ‚äï pSpec.MessageIdx

  hEq : ‚àÄ i, OStmtOut i = match embed i with
    | Sum.inl j => OStmtIn j
    | Sum.inr j => pSpec.Message j

structure PrimeWithMultiplicity : Type where
  prime : ‚Ñï
  multiplicity : ‚Ñï
deriving Repr

def collisionFwdBwd : Prop :=
  let ‚ü®baseTrace, _‚ü© := removeRedundantEntryDS trace
  ‚àÉ stateIn stateOut stateOut',
    (stateIn, stateOut) ‚àà baseTrace.getQ (.inr .Fwd) ‚àß
    (stateOut', stateIn) ‚àà baseTrace.getQ (.inr .Bwd) ‚àß
    stateOut ‚â† stateOut'

alias E_col_p_pinv := collisionFwdBwd

impl in Mathlib.Deprecated.MLList.BestFirst

@[reducible, simp]
def ChallengeIdx (pSpec : ProtocolSpec n) :=
  {i : Fin n // pSpec.dir i = Direction.V_to_P}

instance instDCast‚ÇÇForall :
    DCast‚ÇÇ Œ± (fun a => ‚àÄ b : Œ≤ a, Œ≥ a b) (fun a f => ‚àÄ b : Œ≤ a, Œ¥ a b (f b)) where
  dcast‚ÇÇ ha hb c := fun b => dcast‚ÇÉ ha (by admit /- proof elided -/
  )
    (by admit /- proof elided -/
    ) (c (dcast ha.symm b))
  dcast‚ÇÇ_id := by admit /- proof elided -/

def redundantQuery (log : QueryLog spec) (i : Œπ) (q : spec.domain i) (r : spec.range i) : Prop :=
  (log.getQ i).count (q, r) > 1

def verifyEqOne (n a' : Q(‚Ñï)) (a : Q(ZMod $n)) (_ : Q(($a' : ZMod $n) = $a)) :
    MetaM Q($a ^ ($n - 1) = 1) := do
  let p : Q(ZMod $n) := q($a ^ ($n - 1))
  let .isNat _ c hc ‚Üê Tactic.ReduceModChar.normIntNumeral n p
    q(CommRing.toRing) q(ZMod.charP $n) | failure
  assumeInstancesCommute
  haveI : $p =Q $a ^ ($n - 1) := ‚ü®‚ü©
  haveI : $c =Q 1 := ‚ü®‚ü©
  return q(ZMod.bla $a (.refl _) $hc)

@[reducible, simp]
def pSpec : ProtocolSpec 1 := ‚ü®!v[.P_to_V], !v[Witness]‚ü©

def OracleVerifier.append (V‚ÇÅ : OracleVerifier oSpec Stmt‚ÇÅ OStmt‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : OracleVerifier oSpec Stmt‚ÇÇ OStmt‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ pSpec‚ÇÇ) :
      OracleVerifier oSpec Stmt‚ÇÅ OStmt‚ÇÅ Stmt‚ÇÉ OStmt‚ÇÉ (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ) where
  verify := fun stmt challenges => by admit /- proof elided -/
|
    
    .trans (.sumMap V‚ÇÅ.embed (.refl _)) <|
    
    .trans (Equiv.sumAssoc _ _ _).toEmbedding <|
    
    .sumMap (.refl _) MessageIdx.sumEquiv.toEmbedding

  hEq := fun i => by admit /- proof elided -/

structure CodeParams (P : Params Œπ F) (Dist : Distances M) where
  C : ‚àÄ i : Fin (M + 1), Set ((Œπ i) ‚Üí F)
  h_code : ‚àÄ i : Fin (M + 1), C i = code (P.œÜ i) (degree Œπ P i)
  h_listDecode : ‚àÄ i : Fin (M + 1), i ‚â† 0 ‚Üí listDecodable (C i) (Dist.Œ¥ i) (Dist.l i)

def buildLayer (n : ‚Ñï) (leaves : List.Vector Œ± (2 ^ (n + 1))) :
    OracleComp (spec Œ±) (List.Vector Œ± (2 ^ n)) := do
  let leaves : List.Vector Œ± (2 ^ n * 2) :=

def sBasis (i : Fin r) (h_i : i < ‚Ñì + R_rate) : Fin (‚Ñì + R_rate - i) ‚Üí L :=
  fun k => Œ≤ ‚ü®i + k.val, by admit /- proof elided -/
  ‚ü©

UInt64.ofFin in Init.Data.UInt.Basic

inductive VectorOp where | dotProd

def Array.toFinVec {Œ± : Type _} (n : ‚Ñï) (arr : Array Œ±) (h : arr.size = n) : Fin n ‚Üí Œ± :=
  fun i => arr[i]

def finOneEquiv : MvPolynomial (Fin 1) R ‚âÉ‚Çê[R] Polynomial R :=
  (finSuccEquiv R 0).trans (Polynomial.mapAlgEquiv (isEmptyAlgEquiv R (Fin 0)))

def domain (n : ‚Ñï) (i : ‚Ñï) : Fin (2 ^ (n - i)) ‚Üí evalDomain D x i :=
  fun j =>
    ‚ü®
      x ^ 2 ^ i * (DIsCyclicC.gen ^ (2 ^ i)) ^ j.1,
      by admit /- proof elided -/
    ‚ü©

IO.FS.Stream.read in Init.System.IO

def fst (T : (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).Transcript k) : pSpec‚ÇÅ.Transcript ‚ü®min k m, by admit /- proof elided -/
‚ü© :=
  if hk : k ‚â§ m then
    fun i => by admit /- proof elided -/

@[reducible]
def foldRelayOracleReduction (i : Fin ‚Ñì)
    (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
  OracleReduction []‚Çí
    (StmtIn := Statement (L := L) Context i.castSucc)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) i.castSucc)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) i.succ)
    (pSpec := pSpecFoldRelay (L:=L)) :=
  OracleReduction.append
    (pSpec‚ÇÅ := pSpecFold (L:=L))
    (pSpec‚ÇÇ := pSpecRelay)
        (foldOracleReduction ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) i)
    (relayOracleReduction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hNCR)

abbrev MultilinearPoly (L : Type) [CommSemiring L] (‚Ñì : ‚Ñï) := L‚¶É‚â§ 1‚¶Ñ[X Fin ‚Ñì]

instance : ‚àÄ i, OracleInterface ((pSpecFinalSumcheckStep (L:=L)).Message i)
  | ‚ü®0, _‚ü© => by admit /- proof elided -/

structure DomainSeparator (U : Type) [SpongeUnit U] (H : Type*) [DuplexSpongeInterface U H] where
   
  io : String
deriving Repr

def div [Field R] (p q : UniPoly R) : UniPoly R :=
  (C (q.leadingCoeff)‚Åª¬π ‚Ä¢ p).divByMonic (C (q.leadingCoeff)‚Åª¬π * q)

Set.toFinset in Mathlib.Data.Fintype.Sets

noncomputable def ElocPolyF (œâs f : Fin n ‚Üí F) (p : Polynomial F) : Polynomial F :=
  ElocPoly n (liftF œâs) (liftF f) p

def hint (ds : DomainSeparator U H) (label : String) : DomainSeparator U H :=
  
  { io := ds.io ++ SEP_BYTE ++ "H" ++ label }

noncomputable def relayOracleProver (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
  OracleProver (oSpec := []‚Çí)
    
    (StmtIn := Statement (L := L) Context i.succ)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) i.succ)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) i.succ)
    (pSpec := pSpecRelay) where
  PrvState := relayPrvState ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i
  input := fun ‚ü®‚ü®stmtIn, oStmtIn‚ü©, witIn‚ü© => (stmtIn, oStmtIn, witIn)
  sendMessage | ‚ü®x, h‚ü© => by admit /- proof elided -/
| ‚ü®x, h‚ü© => by admit /- proof elided -/

@[simp]
instance BTFieldIsField (k : ‚Ñï) : Field (BTField k) := (BinaryTowerAux k).2.instField

Prod.fst in Init.Prelude

def roundRelation (i : Fin (‚Ñì + 1)) :
    Set ((Statement (L := L) Context i √ó
      (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i j)) √ó
      Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) :=
  { input | roundRelationProp (mp := mp) (ùìë := ùìë) ùîΩq Œ≤ i input}

def JohnsonConditionWeak (B : Finset (Fin n ‚Üí F)) (e : ‚Ñï) : Prop :=
  let d := sInf { d | ‚àÉ u ‚àà B, ‚àÉ v ‚àà B, u ‚â† v ‚àß hammingDist u v = d }
  let q : ‚Ñö := Fintype.card F
  (e : ‚Ñö) / n < J q (d / n)

Lean.mkRawNatLit in Lean.Expr

@[ext]
structure Equiv {m n : ‚Ñï} (pSpec : ProtocolSpec m) (pSpec' : ProtocolSpec n) where
  round_eq : m = n
  dir_eq : ‚àÄ i, pSpec.dir i = pSpec'.dir (Fin.cast round_eq i)
  typeEquiv : ‚àÄ i, pSpec.¬´Type¬ª i ‚âÉ pSpec'.¬´Type¬ª (Fin.cast round_eq i)

noncomputable def genRSC
  [Nonempty F] (par‚Ñì : Type) [h‚Ñì : Fintype par‚Ñì] (œÜ : Œπ ‚Ü™ F) [Smooth œÜ]
  (m : ‚Ñï) (exp : par‚Ñì ‚Ü™ ‚Ñï) : ProximityGenerator Œπ F :=
    let r := LinearCode.rate (smoothCode œÜ m);
    { C := smoothCode œÜ m,
      par‚Ñì := par‚Ñì,
      h‚Ñì := h‚Ñì,
      rate := r,
      Gen := Finset.image (fun r => (fun j => r ^ (exp j))) (Finset.univ : Finset F),
      Gen_nonempty := by admit /- proof elided -/

List.length in Init.Prelude

def eval (p : MlPolyEval R n) (x : Vector R n) : R :=
  Vector.dotProduct p (lagrangeBasis x)

class IsSound (langIn : Set StmtIn) (langOut : Set StmtOut)
    (verifier : Verifier oSpec StmtIn StmtOut pSpec) where
  soundnessError : ‚Ñù‚â•0
  is_sound : soundness init impl langIn langOut verifier soundnessError

instance : CoeFun AssocNat (fun _ => Nat ‚Üí Nat) := ‚ü®AssocNat.toFun‚ü©

def findIdxRev?_def {cond} {as : Array Œ±} {k : Fin as.size} :
  findIdxRev? cond as = some k ‚Üí cond as[k] :=

multiplicity in Mathlib.RingTheory.Multiplicity

def leftModNat {m n : ‚Ñï} (h_m : m > 0) (i : Fin (m * n)) : Fin m := ‚ü®i % m, by admit /- proof elided -/
‚ü©

class Serialize (Œ± : Type u) (Œ≤ : Type v) where
  serialize : Œ± ‚Üí Œ≤

def QuotientUniPoly (R : Type*) [Ring R] [BEq R] := Quotient (@instSetoidUniPoly R _)

noncomputable def evenPart_x (f : Polynomial F) : Polynomial F := deevenize (evenPart f)

private def Fi (B : Finset (Fin n ‚Üí F)) (i : Fin n) (Œ± : F) : Finset (Fin n ‚Üí F) :=
  { x | x ‚àà B ‚àß x i = Œ± }

@[reducible]
def VectorIOP
    (Statement : Type) {Œπ‚Çõ : Type} (OStatement : Œπ‚Çõ ‚Üí Type) (Witness : Type)
    (vPSpec : ProtocolSpec.VectorSpec n) (A : Type)
    [‚àÄ i, OracleInterface (OStatement i)] :=
  OracleProof []‚Çí Statement OStatement Witness (vPSpec.toProtocolSpec A)

@[inline, specialize]
def smul (r : R) (p : UniPoly R) : UniPoly R :=
  .mk (Array.map (fun a => r * a) p)

instance : ‚àÄ j, SelectableType ((pSpecFold (L:=L)).Challenge j)
  | ‚ü®j, hj‚ü© => by admit /- proof elided -/

def domainEnum (i : Fin (n + 1)) : Fin (2 ^ (n - i)) ‚Ü™ evalDomain D i :=
  ‚ü®domain D n i.1, domain_injective D i.1 (by admit /- proof elided -/
  )‚ü©

def mulNat [Zero T] (a : Cayley T) : Nat ‚Üí Cayley T
  | 0        => zero
  | .succ k  => add (mulNat a k) a

def weightedDegreeMonomialXY {n m : ‚Ñï} (a b t : ‚Ñï) : ‚Ñï :=
  a * (degreeX (monomialXY n m t)) + b * natDegreeY (monomialXY n m t)

OracleSpec.domain in VCVio.OracleComp.OracleSpec

@[ext]
structure Verifier {Œπ : Type} (oSpec : OracleSpec Œπ)
    (StmtIn StmtOut : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n) where
  verify : StmtIn ‚Üí FullTranscript pSpec ‚Üí OracleComp oSpec StmtOut

local instance : Fintype F := Fintype.ofFinite F

def InternalData.leftSubtree {Œ± : Type} {s_left s_right : Skeleton}
    (tree : InternalData Œ± (Skeleton.internal s_left s_right)) :
    InternalData Œ± s_left :=
  match tree with
  | InternalData.internal _ left _right =>
    left

def genMatrix (deg : ‚Ñï) : Matrix (Fin deg) Œπ F :=
  .of fun i j => domain j ^ (i : ‚Ñï)

def Cache.leaves (n : ‚Ñï) (cache : Cache Œ± (n + 1)) :
    List.Vector Œ± (2 ^ (n + 1)) := cache (Fin.last _)

noncomputable instance instAlgebraTowerEquiv : AlgebraTowerEquiv
  (ConcreteBTField) (BTField) where
  toRingEquiv := fun i => (towerEquiv i).ringEquiv
  commutesLeft' := fun i j h r => by admit /- proof elided -/

def eval‚ÇÇ (p : MlPolyEval R n) (f : R ‚Üí+* S) (x : Vector S n) : S := eval (map f p) x

instance [VCVCompatible A] : ‚àÄ i, VCVCompatible ((vPSpec.toProtocolSpec A).Challenge i) :=
  fun _ => by admit /- proof elided -/

@[simps]
def revFinProdFinEquiv {m n : ‚Ñï} (h_m : m > 0) : Fin m √ó Fin n ‚âÉ Fin (m * n) where
  toFun x :=
    ‚ü®x.1.val + m * x.2.val,
      calc
        x.1.val + m * x.2.val < m + m * x.2.val := Nat.add_lt_add_right x.1.is_lt _
        _ = m * (1 + x.2.val) := by admit /- proof elided -/
        ‚ü©
  invFun := fun x => 
    (leftModNat (m:=m) (n:=n) h_m (i:=x), leftDivNat (m:=m) (n:=n) (i:=x))
  left_inv := fun ‚ü®x, y‚ü© =>
    
    
    Prod.ext
      (Fin.eq_of_val_eq <|
        calc
          (x.val + m * y.val) % m = x.val % m := by admit /- proof elided -/
          )
      (Fin.eq_of_val_eq <|
        calc
          (x.val + m * y.val) / m = x.val / m + y.val := by admit /- proof elided -/
          )
  right_inv x := by admit /- proof elided -/

@[reducible]
def coreInteractionOracleVerifier :=
  OracleVerifier.append (oSpec:=[]‚Çí)
    (Stmt‚ÇÅ := Statement (L := L) (‚Ñì:=‚Ñì) (SumcheckBaseContext L ‚Ñì) 0)
    (Stmt‚ÇÇ := Statement (L := L) (‚Ñì:=‚Ñì) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì))
    (Stmt‚ÇÉ := FinalSumcheckStatementOut (L:=L) (‚Ñì:=‚Ñì))
    (OStmt‚ÇÅ := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë 0)
    (OStmt‚ÇÇ := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (OStmt‚ÇÉ := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (pSpec‚ÇÅ := pSpecSumcheckFold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (pSpec‚ÇÇ := pSpecFinalSumcheckStep (L:=L))
    (V‚ÇÅ := sumcheckFoldOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (V‚ÇÇ := finalSumcheckVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))

Fin.insertNth in Mathlib.Data.Fin.Tuple.Basic

noncomputable def towerEquiv (n : ‚Ñï) : TowerEquivResult n :=

def outputRelation : Set ((StmtOut R √ó (‚àÄ i, OStmtOut R deg i)) √ó Unit) :=
  { ‚ü®‚ü®‚ü®newTarget, chal‚ü©, oStmt‚ü©, _‚ü© | (oStmt ()).1.eval chal = newTarget }

class SpongeState (U : Type) [SpongeUnit U] [SpongeSize] (Œ± : Type*) extends
    Zero Œ±,
    Initialize Œ± (Vector UInt8 32)
    where
  get : Œ± ‚Üí Vector U SpongeSize.N
  update : Œ± ‚Üí Vector U SpongeSize.N ‚Üí Œ±

@[reducible, simp]
def OracleContext.Lens.IsComplete {OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut : Type}
    {Outer_Œπ‚Çõ·µ¢ : Type} {OuterOStmtIn : Outer_Œπ‚Çõ·µ¢ ‚Üí Type} [‚àÄ i, OracleInterface (OuterOStmtIn i)]
    {Outer_Œπ‚Çõ‚Çí : Type} {OuterOStmtOut : Outer_Œπ‚Çõ‚Çí ‚Üí Type} [‚àÄ i, OracleInterface (OuterOStmtOut i)]
    {Inner_Œπ‚Çõ·µ¢ : Type} {InnerOStmtIn : Inner_Œπ‚Çõ·µ¢ ‚Üí Type} [‚àÄ i, OracleInterface (InnerOStmtIn i)]
    {Inner_Œπ‚Çõ‚Çí : Type} {InnerOStmtOut : Inner_Œπ‚Çõ‚Çí ‚Üí Type} [‚àÄ i, OracleInterface (InnerOStmtOut i)]
    {OuterWitIn OuterWitOut InnerWitIn InnerWitOut : Type}
    (outerRelIn : Set ((OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i)) √ó OuterWitIn))
    (innerRelIn : Set ((InnerStmtIn √ó (‚àÄ i, InnerOStmtIn i)) √ó InnerWitIn))
    (outerRelOut : Set ((OuterStmtOut √ó (‚àÄ i, OuterOStmtOut i)) √ó OuterWitOut))
    (innerRelOut : Set ((InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i)) √ó InnerWitOut))
    (compat : (OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i)) √ó OuterWitIn ‚Üí
              (InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i)) √ó InnerWitOut ‚Üí Prop)
    (lens : OracleContext.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                                    OuterOStmtIn OuterOStmtOut InnerOStmtIn InnerOStmtOut
                                    OuterWitIn OuterWitOut InnerWitIn InnerWitOut) :=
  Context.Lens.IsComplete outerRelIn innerRelIn outerRelOut innerRelOut compat lens.toContext

@[inline]
def neg [Neg R] (p : MlPoly R n) : MlPoly R n := p.map (fun a => -a)

@[ext]
structure AssocNat where
  toFun : Nat ‚Üí Nat
  presSucc : ‚àÄ n, toFun (n.succ) = (toFun n).succ

Polynomial.evalEval in Mathlib.Algebra.Polynomial.Bivariate

def evalWAt (i : Fin r) (x : L) : L :=
  ((getUElements (Œ≤ := Œ≤) (‚Ñì := ‚Ñì) (R_rate := R_rate) i).map (fun u => x - u)).prod

instance [AddCommMonoid R] : AddCommMonoid (MlPolyEval R n) where
  add := add
  add_assoc a b c := by admit /- proof elided -/

private def Bi (B : Finset (Fin n ‚Üí F)) (i : Fin n) : Finset ((Fin n ‚Üí F) √ó (Fin n ‚Üí F)) :=
  { x | x ‚àà B √óÀ¢ B ‚àß x.1 i = x.2 i ‚àß x.1 ‚â† x.2 }

def computableNTTStage [Fact (LinearIndependent ùîΩq Œ≤)]
  (i : Fin ‚Ñì) (b : Fin (2 ^ (‚Ñì + R_rate)) ‚Üí L) : Fin (2^(‚Ñì + R_rate)) ‚Üí L :=
  have h_2_pow_i_lt_2_pow_‚Ñì_add_R_rate: 2^i.val < 2^(‚Ñì + R_rate) := by admit /- proof elided -/

inferInstanceAs in Init.Prelude

def mapOStmtOutRelayStep (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j) :
    ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.succ j := fun j => by admit /- proof elided -/

@[simp]
instance CommRing (k : ‚Ñï) : CommRing (BTField k) := Field.toCommRing

def eval (p : MlPoly R n) (x : Vector R n) : R :=
  Vector.dotProduct p (monomialBasis x)

def capacitySegmentDup : Prop :=
  capacitySegmentDupHash trace ‚à® capacitySegmentDupPerm trace ‚à® capacitySegmentDupPermInv trace

alias E_dup := capacitySegmentDup

def bool (j : Fin numWires) : Gate ùì° numWires :=
  { qL := -1, qR := 0, qO := 0, qM := 1, qC := 0, a := j, b := j, c := j }

@[reducible, inline]
def OracleProver {Œπ : Type} (oSpec : OracleSpec Œπ)
    (StmtIn : Type) {Œπ‚Çõ·µ¢ : Type} (OStmtIn : Œπ‚Çõ·µ¢ ‚Üí Type) (WitIn : Type)
    (StmtOut : Type) {Œπ‚Çõ‚Çí : Type} (OStmtOut : Œπ‚Çõ‚Çí ‚Üí Type) (WitOut : Type)
    {n : ‚Ñï} (pSpec : ProtocolSpec n) :=
  Prover oSpec (StmtIn √ó (‚àÄ i, OStmtIn i)) WitIn (StmtOut √ó (‚àÄ i, OStmtOut i)) WitOut pSpec

@[inline, reducible]
protected def id :
    OracleStatement.Lens OuterStmtIn OuterStmtOut OuterStmtIn OuterStmtOut
                        OuterOStmtIn OuterOStmtOut OuterOStmtIn OuterOStmtOut :=
  PFunctor.Lens.id _

alias trivial := OracleStatement.Lens.id

structure InitialStatement where
  
  t_eval_point : Fin ‚Ñì ‚Üí L         
  original_claim : L               

@[reducible, inline]
instance instMvPolynomial : OracleInterface (R[X œÉ]) where
  Query := œÉ ‚Üí R
  Response := R
  answer := fun poly point => eval point poly

@[simp]
abbrev relation := R1CS.relation R pp.toSizeR1CS

def HList.toDVec (l : HList) : DVec (m := Fin l.length) (fun i => l[i].1) := fun i => l[i].2

instance {i : ‚Ñï} : SmoothPowerOfTwo (n - i) (evalDomain D i) where
  smooth := by admit /- proof elided -/

def subNat (c : AssocNat) : Nat ‚Üí AssocNat
| 0            => c 
| Nat.succ k   => pred (subNat c k) 

def soundness
    (langIn : Set (StmtIn √ó ‚àÄ i, OStmtIn i))
    (langOut : Set (StmtOut √ó ‚àÄ i, OStmtOut i))
    (verifier : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec)
    (soundnessError : ‚Ñù‚â•0) : Prop :=
  verifier.toVerifier.soundness init impl langIn langOut soundnessError

@[inline, specialize]
def prover : Prover oSpec Statement Unit Statement Unit !p[] where
  PrvState := fun _ => Statement
  input := Prod.fst
  sendMessage := fun i => nomatch i
  receiveChallenge := fun i => nomatch i
  output := fun stmt => pure (stmt, ())

@[inline] def lagrangeToMonoLevel {n : ‚Ñï} (j : Fin n) : Vector R (2 ^ n) ‚Üí Vector R (2 ^ n) :=
  fun v =>
    let stride : ‚Ñï := 2 ^ j.val  
    Vector.ofFn (fun i : Fin (2 ^ n) =>
      if (BitVec.ofFin i).getLsb j then
        v[i] - v[i - stride]'(Nat.sub_lt_of_lt i.isLt)
      else
        v[i])

Polynomial.derivative in Mathlib.Algebra.Polynomial.Derivative

def getCommitProverFinalOutput (i : Fin ‚Ñì)
    (inputPrvState : commitPrvState (Context := Context) ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i 0) :
  (‚Ü•(sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®‚Üëi + 1, by admit /- proof elided -/
  ‚ü©) ‚Üí L) √ó
  commitPrvState (Context := Context) ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i 1 :=
  let (stmt, oStmtIn, wit) := inputPrvState
  let f·µ¢_succ := wit.f
  let oStmtOut := snoc_oracle ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
    oStmtIn f·µ¢_succ 
  (f·µ¢_succ, (stmt, oStmtOut, wit))

@[inline] def le [Zero T] [ToNat T] (a b : Cayley T) : Prop :=
  (‚Üëa : Nat) ‚â§ (‚Üëb : Nat)

instance : Dist (n ‚Üí R) where
  dist := fun u v => hammingDist u v

AdjoinRoot.powerBasis in Mathlib.RingTheory.AdjoinRoot

OrderBot in Mathlib.Order.BoundedOrder.Basic

noncomputable def towerRingEquiv0 : BTField 0 ‚âÉ+* ConcreteBTField 0 :=

œÜ in ToMathlib.Control.Monad.Relative

instance : Slice (ProtocolSpec n) ‚Ñï ‚Ñï
    (fun _ start stop => start ‚â§ stop ‚àß stop ‚â§ n)
    (fun _ start stop _ => ProtocolSpec (stop - start))
    where
  slice := fun v start stop h => extract start stop h.1 h.2 v

instance {Œ± : Fin 0 ‚Üí Sort u} : Unique ((i : Fin 0) ‚Üí Œ± i) where
  default := fun i => elim0 i
  uniq v := by admit /- proof elided -/

OracleSpec.QueryCache in VCVio.OracleComp.QueryTracking.Structures

LT in Init.Prelude

def FullData.map {Œ± Œ≤ : Type} (f : Œ± ‚Üí Œ≤) {s : Skeleton}
    (tree : FullData Œ± s) : FullData Œ≤ s :=
  match tree with
  | FullData.leaf value => FullData.leaf (f value)
  | FullData.internal value left right =>
    FullData.internal (f value) (left.map f) (right.map f)

def sub (a b : AssocNat) : AssocNat :=
  subNat a b.toNat

def code (deg : ‚Ñï) [Semiring F]: Submodule F (Œπ ‚Üí F) :=
  (Polynomial.degreeLT F deg).map (evalOnPoints domain)

instance instAlgebraLiftConcreteBTField (k : ‚Ñï)
  (prevBTFResult : ConcreteBTFStepResult (k := k)) :
  letI := mkFieldInstance (prevBTFResult.toConcreteBTFieldProps)
  letI := liftConcreteBTField (k:=k) prevBTFResult
  Algebra (ConcreteBTField k) (ConcreteBTField (k + 1)) :=
  letI := mkFieldInstance (prevBTFResult.toConcreteBTFieldProps)
  letI := liftConcreteBTField (k:=k) prevBTFResult
  RingHom.toAlgebra (R:=ConcreteBTField k) (S:=ConcreteBTField (k + 1))
    (i:=(concreteCanonicalEmbedding (k:=k)
      (prevBTFieldProps:=prevBTFResult.toConcreteBTFieldProps)
      (curBTFieldProps:=liftBTFieldProps (k:=k) (prevBTFResult:=prevBTFResult))))

def verifyProof {n : ‚Ñï} (i : Fin (2 ^ n)) (leaf : Œ±) (root : Œ±) (proof : List.Vector Œ± n) :
    OracleComp (spec Œ±) Unit := do
  let putative_root ‚Üê getPutativeRoot Œ± i leaf proof
  guard (putative_root = root)

def modSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (k : Fin (‚àë j, n j)) : Fin (n (divSum k)) :=
  ‚ü®k - ‚àë j, n (Fin.castLE (divSum k).isLt.le j), by admit /- proof elided -/
    ‚ü©

AddMemClass in Mathlib.Algebra.Group.Subsemigroup.Defs

Finset.Nonempty in Mathlib.Data.Finset.Empty

def example1 : ChurchVec ‚Ñï := churchCons 1 (churchCons 2 (churchCons 3 churchNil))

example : toList example1 = [1, 2, 3] := rfl

Eq.mpr in Init.Core

class VerifierLast (pSpec : ProtocolSpec n) [NeZero n] where
  verifier_last' : pSpec.dir ‚ü®n - 1, by admit /- proof elided -/
  ‚ü© = .V_to_P

def e (B : Finset (Fin n ‚Üí F)) (v : Fin n ‚Üí F) : ‚Ñö :=
  (1 : ‚Ñö)/B.card * ‚àë x ‚àà B, Œî‚ÇÄ(v, x)

def FullData.get {s} {Œ± : Type}
    (tree : FullData Œ± s) (idx : SkeletonNodeIndex s) : Œ± :=
  match tree, idx with
  | FullData.leaf value, SkeletonNodeIndex.ofLeaf => value
  | FullData.internal value _ _, SkeletonNodeIndex.ofInternal => value
  | FullData.internal _ left _, SkeletonNodeIndex.ofLeft idxLeft =>
    FullData.get left idxLeft
  | FullData.internal _ _ right, SkeletonNodeIndex.ofRight idxRight =>
    FullData.get right idxRight

def split (k : ‚Ñï) (h_k : k > 0) (x : BTField k) : BTField (k-1) √ó BTField (k-1) :=

instance {Œ± : Type} {s : Skeleton} :
    CoeFun (FullData Œ± s) fun (_ : FullData Œ± s) => SkeletonNodeIndex s ‚Üí Œ± where
  coe := fun tree idx => tree.get idx

noncomputable def polyQuotient (S : Finset F) (fPoly : F[X]) : F[X] :=
    (fPoly - (ansPoly S (fun s => fPoly.eval s))) / (vanishingPoly S)

BitVec.cast in Init.Data.BitVec.Basic

Fintype in Mathlib.Data.Fintype.Defs

def lift {Œπ‚ÇÅ Œπ‚ÇÇ Œπ : Type} {œÉ : Type} (oSpec‚ÇÅ : OracleSpec Œπ‚ÇÅ) (oSpec‚ÇÇ : OracleSpec Œπ‚ÇÇ)
    (oSpec : OracleSpec Œπ) (so : SimOracle.Stateful oSpec‚ÇÅ oSpec‚ÇÇ œÉ) :
      SimOracle.Stateful (oSpec ++‚Çí oSpec‚ÇÅ) (oSpec ++‚Çí oSpec‚ÇÇ) œÉ where
  impl := fun q s => match q with
    | query (.inl i) q => do return ‚ü®‚Üê query i q, s‚ü©
    | query (.inr i) q => so.impl (query (spec := oSpec‚ÇÅ) i q) s

def indexPow (S : Finset Œπ) (œÜ : Œπ ‚Ü™ F) (k : ‚Ñï) : Finset F :=
  S.image (fun x => (œÜ x) ^ k)

List.map in Init.Prelude

def ConstraintSystem (ùì° : Type) (numWires numGates : ‚Ñï) := Fin numGates ‚Üí Gate ùì° numWires

AdjoinRoot.of in Mathlib.RingTheory.AdjoinRoot

def linearMvExtension :
  Polynomial.degreeLT F (2^m) ‚Üí‚Çó[F] MvPolynomial (Fin m) F where
    
    toFun p := (p : Polynomial F).sum fun i a =>
      MvPolynomial.monomial (bitExpo i) a
    map_add' := by admit /- proof elided -/

def backwardPermutationOracleImpl {Œ± : Type*} [Permute Œ±] [LawfulPermute Œ±] :
    QueryImpl (backwardPermutationOracle Œ±) Id where
  impl | query () q => LawfulPermute.permuteInv (Œ± := Œ±) q

@[reducible, inline, specialize, simp]
def MessageIdx (vPSpec : VectorSpec n) := {i : Fin n // vPSpec.dir i = .P_to_V}

abbrev Bwd : PermuteDir := Sum.inr ()

instance : Unique (ChallengeIdx ‚ü®!v[.V_to_P], !v[Chal]‚ü©) where
  default := ‚ü®0, by admit /- proof elided -/
  ‚ü©
  uniq := fun i => by admit /- proof elided -/

@[reducible]
def SimOracle.Stateless (spec : OracleSpec Œπ) (spec‚Çú : OracleSpec Œπ‚Çú) :=
  QueryImpl spec (OracleComp spec‚Çú)

instance : Add (Cayley T) where
  add := add

instance {n : ‚Ñï} {Œ± : Type v} : Memory (Fin n) (fun _ => Œ±) (Vector Œ± n) where
  read m i := m[i]
  write m i v := m.set i v

@[reducible]
def rateSegment (state : CanonicalSpongeState U) : Vector U SpongeSize.R :=
  
  (Vector.take state SpongeSize.R).cast (by admit /- proof elided -/
  )

Nontrivial in Mathlib.Logic.Nontrivial.Defs

algebraMap in Mathlib.Algebra.Algebra.Defs

structure Witness (i : Fin (‚Ñì + 1)) where
  t : L‚¶É‚â§ 1‚¶Ñ[X Fin ‚Ñì]  
  H : L‚¶É‚â§ 2‚¶Ñ[X Fin (‚Ñì - i)] 
  f: (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®i, by admit /- proof elided -/
  ‚ü© ‚Üí L 

@[inline]
def seqCompose {m : ‚Ñï}
    (Stmt : Fin (m + 1) ‚Üí Type) {Œπ‚Çõ : Fin (m + 1) ‚Üí Type} (OStmt : (i : Fin (m + 1)) ‚Üí Œπ‚Çõ i ‚Üí Type)
    (Wit : Fin (m + 1) ‚Üí Type) {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (P : (i : Fin m) ‚Üí
      OracleProver oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Wit i.castSucc)
        (Stmt i.succ) (OStmt i.succ) (Wit i.succ) (pSpec i)) :
    OracleProver oSpec (Stmt 0) (OStmt 0) (Wit 0) (Stmt (Fin.last m)) (OStmt (Fin.last m))
      (Wit (Fin.last m)) (seqCompose pSpec) :=
  Prover.seqCompose (fun i => Stmt i √ó (‚àÄ j, OStmt i j)) Wit P

Algebra.ofId in Mathlib.Algebra.Algebra.Hom

@[reducible]
def foldRelayOracleVerifier (i : Fin ‚Ñì)
    (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
  OracleVerifier []‚Çí
    (StmtIn := Statement (L := L) Context i.castSucc)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.succ)
    (pSpec := pSpecFoldRelay (L:=L)) :=
  OracleVerifier.append
        (pSpec‚ÇÅ := pSpecFold (L:=L))
    (pSpec‚ÇÇ := pSpecRelay)
    (foldOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)
    (relayOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hNCR)

def Prover.liftContext
    (lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut)
    (P : Prover oSpec InnerStmtIn InnerWitIn InnerStmtOut InnerWitOut pSpec) :
      Prover oSpec OuterStmtIn OuterWitIn OuterStmtOut OuterWitOut pSpec where
  PrvState := fun i => P.PrvState i √ó OuterStmtIn √ó OuterWitIn
  input := fun ctxIn => ‚ü®P.input <| lens.proj ctxIn, ctxIn‚ü©
  sendMessage := fun i ‚ü®prvState, stmtIn, witIn‚ü© => do
    let ‚ü®msg, prvState'‚ü© ‚Üê P.sendMessage i prvState
    return ‚ü®msg, ‚ü®prvState', stmtIn, witIn‚ü©‚ü©
  receiveChallenge := fun i ‚ü®prvState, stmtIn, witIn‚ü© => do
    let f ‚Üê P.receiveChallenge i prvState
    return fun chal => ‚ü®f chal, stmtIn, witIn‚ü©
  output := fun ‚ü®prvState, stmtIn, witIn‚ü© => do
    let ‚ü®innerStmtOut, innerWitOut‚ü© ‚Üê P.output prvState
    return lens.lift (stmtIn, witIn) (innerStmtOut, innerWitOut)

Units in Mathlib.Algebra.Group.Units.Defs

noncomputable def codeDistNew (C : Set (n ‚Üí R)) : ‚Ñù := C.infsep

@[reducible]
def pSpecFoldCommit (i : Fin ‚Ñì) : ProtocolSpec (3) :=
  pSpecFold (L:=L) ++‚Çö pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i

Nat.card in Mathlib.SetTheory.Cardinal.Finite

Cardinal in Mathlib.SetTheory.Cardinal.Defs

instance {Œπ : Type} : OracleInterface (OracleStatement Œπ F ()) := OracleInterface.instFunction

def oracleReduction.checkClaim : OracleReduction oSpec
    (StmtAfterSendClaim R) (OStmtAfterSendClaim R deg) Unit
    (StmtAfterCheckClaim R) (OStmtAfterCheckClaim R deg) Unit !p[] :=
  sorry

@[reducible]
def GroupOpOracle : OracleSpec Unit := fun _ => (Œπ √ó Œπ √ó Œπ, Unit)

class Reduction.IsPure (R : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec) where
    prover_is_pure : R.prover.IsPure
    verifier_is_pure : R.verifier.IsPure

instance : LawfulHasSucc Nat where
  succ'_eq_add_one := Nat.succ_eq_add_one

@[reducible, inline, specialize]
def MessageUpTo (k : Fin (n + 1)) (pSpec : ProtocolSpec n) (i : pSpec.MessageIdxUpTo k) :=
  (pSpec‚ü¶:k.val‚üß).Message i

def liftConcreteBTField (k : ‚Ñï) (prevBTFResult : ConcreteBTFStepResult (k := k)) :
  Field (ConcreteBTField (k + 1)) :=

def getRoot {n : ‚Ñï} (cache : Cache Œ± n) : Œ± :=
  (cache 0).get ‚ü®0, by admit /- proof elided -/
  ‚ü©

instance {k : ‚Ñï} : NeZero (1 : ConcreteBTField k) :=

Polynomial.mapAlgHom in Mathlib.Algebra.Polynomial.AlgebraMap

Polynomial.monomial in Mathlib.Algebra.Polynomial.Basic

@[app_unexpander Fin.fcons‚ÇÇ]
def fcons‚ÇÇUnexpander : Lean.PrettyPrinter.Unexpander
  | `($_ $a !h‚¶É$F‚¶Ñ‚ü®$Œ±‚ÇÅ‚ü©‚ü®$Œ±‚ÇÇ‚ü©[$b, $bs,*]) => `(!h‚¶É$F‚¶Ñ‚ü®$Œ±‚ÇÅ‚ü©‚ü®$Œ±‚ÇÇ‚ü©[$a, $b, $bs,*])
  | `($_ $a !h‚¶É$F‚¶Ñ‚ü®$Œ±‚ÇÅ‚ü©‚ü®$Œ±‚ÇÇ‚ü©[$b]) => `(!h‚¶É$F‚¶Ñ‚ü®$Œ±‚ÇÅ‚ü©‚ü®$Œ±‚ÇÇ‚ü©[$a, $b])
  | `($_ $a !h‚¶É$F‚¶Ñ‚ü®$Œ±‚ÇÅ‚ü©‚ü®$Œ±‚ÇÇ‚ü©[]) => `(!h‚¶É$F‚¶Ñ‚ü®$Œ±‚ÇÅ‚ü©‚ü®$Œ±‚ÇÇ‚ü©[$a])
  | _ => throw ()

def bitsToU (i : Fin r) (k : Fin (2 ^ i.val)) :
    AdditiveNTT.U (L := L) (ùîΩq := ùîΩq) (Œ≤ := Œ≤) i :=
  let val := (Finset.univ : Finset (Fin i)).sum fun j =>
    if (Nat.getBit (n := k.val) (k := j.val) == 1) then
      Œ≤ ‚ü®j, by admit /- proof elided -/
      ‚ü©
    else 0

  
  ‚ü®val, by admit /- proof elided -/
  ‚ü©

@[reducible, simp]
def mapOStmt (oStmtIn : ‚àÄ i, OStmtIn i) : ‚àÄ i, OStmtOut i := fun i => (hEq i) ‚ñ∏ oStmtIn (embedIdx i)

noncomputable def queryProver :
  OracleProver []‚Çí
    (FinalStatement F k) (FinalOracleStatement D x s) (Witness F s d (Fin.last (k + 1)))
    (FinalStatement F k) (FinalOracleStatement D x s) (Witness F s d (Fin.last (k + 1)))
    (pSpec D x l) where
  PrvState
  | _ =>
    (FinalStatement F k √ó ((i : Fin (k + 2)) ‚Üí FinalOracleStatement D x s i)) √ó
      Witness F s d (Fin.last (k + 1))

  input := id

  sendMessage
  | ‚ü®0, h‚ü© => nomatch h

  receiveChallenge
  | ‚ü®1, _‚ü© => fun x => pure <| fun _ => x

  output := pure

IO in Init.System.IO

noncomputable def discriminant {F : Type} [Field F] [Inhabited F] (f : F[X]) : F :=
  1/f.leadingCoeff * Polynomial.resultant f (Polynomial.derivative f)

Fintype.ofEquiv in Mathlib.Data.Fintype.OfMap

id in Init.Prelude

instance instDCastPSigma : DCast ((a : Œ±) √ó' Œ≤ a) (fun a => Œ≥ a.1 a.2) where
  dcast hab c := dcast‚ÇÇ (by admit /- proof elided -/
  ) (by admit /- proof elided -/
  ) c
  dcast_id := by admit /- proof elided -/

Setoid in Init.Core

instance : ‚àÄ i, SelectableType (Challenge !p[] i) :=
  fun ‚ü®i, h‚ü© =>
    (Fin.elim0 i : (h' : !p[].dir i = .V_to_P) ‚Üí SelectableType (!p[].Challenge ‚ü®i, h'‚ü©)) h

instance instDecidableEqOption {Œ± : Type*} [DecidableEq Œ±] :
    DecidableEq (Option Œ±) := inferInstance

def NBlockMessages := 2 * (œë - 1) + 3

noncomputable def oddRefinement (i : Fin (‚Ñì))
    (coeffs : Fin (2 ^ (‚Ñì - i)) ‚Üí L) : L[X] :=
  ‚àë (‚ü®j, hj‚ü©: Fin (2^(‚Ñì-i-1))), C (coeffs ‚ü®j*2+1, by admit /- proof elided -/
  ‚ü©) * (intermediateNovelBasisX ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i+1, by admit /- proof elided -/
  ‚ü© ‚ü®j, hj‚ü©)

UInt16 in Init.Prelude

def vflatten {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (v : (i : Fin m) ‚Üí Fin (n i) ‚Üí Œ±) :
    Fin (vsum n) ‚Üí Œ± :=
  dflatten v

Multiset.ofList in Mathlib.Data.Multiset.Defs

Or.inl in Init.Prelude

List.rightpad in Init.Data.List.Basic

def finSum'FinEquiv' {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} : (i : Fin m) √ó Fin (n i) ‚âÉ Fin (vsum n) where
  toFun := fun ij => embedSum ij.1 ij.2
  invFun := splitSum
  left_inv := fun ij => splitSum_embedSum ij.1 ij.2
  right_inv := embedSum_splitSum

@[reducible, inline, specialize]
def Messages' (pSpec : ProtocolSpec n) : Type :=
  ‚àÄ i, (hi : pSpec.dir i = .P_to_V) ‚Üí pSpec.¬´Type¬ª i

def equivProd {k : ‚Ñï} (h_k_pos : k > 0) :
  ConcreteBTField k ‚âÉ ConcreteBTField (k - 1) √ó ConcreteBTField (k - 1) where
  toFun := split h_k_pos
  invFun := fun (hi, lo) => „Ää hi, lo „Äã
  left_inv := fun x => Eq.symm (join_of_split h_k_pos x _ _ rfl)
  right_inv := fun ‚ü®hi, lo‚ü© => Eq.symm (split_of_join h_k_pos _ hi lo rfl)

instance instEquivalenceEquiv : Equivalence (equiv (R := R)) where
  refl := equiv_refl
  symm := equiv_symm
  trans := equiv_trans

Nat.cast in Init.Data.Cast

instance : SpongeUnit UInt8 where

def map (f : R ‚Üí+* S) (p : MlPolyEval R n) : MlPolyEval S n :=
  Vector.map (fun a => f a) p

@[inline, specialize]
def neg (p : UniPoly R) : UniPoly R := p.map (fun a => -a)

Set.Ioo in Mathlib.Order.Interval.Set.Defs

Mathlib.Linter.TextBased.ErrorFormat.humanReadable in Mathlib.Tactic.Linter.TextBased

class IsRBRKnowledgeSound (relIn : Set (StmtIn √ó WitIn)) (relOut : Set (StmtOut √ó WitOut))
    (verifier : Verifier oSpec StmtIn StmtOut pSpec) where
  rbrKnowledgeError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0
  is_rbr_knowledge_sound : rbrKnowledgeSoundness init impl relIn relOut verifier rbrKnowledgeError

noncomputable def proximity_gap_johnson (k m : ‚Ñï) : ‚Ñï :=
  let rho := (k + 1 : ‚Ñö) / n
  Nat.floor ((1 : ‚Ñù) - Real.sqrt rho - Real.sqrt rho / (2 * m))

BEq in Init.Prelude

Fin.succAbove in Mathlib.Data.Fin.SuccPred

instance : HasSucc Nat where
  succ' := Nat.succ

class AlgebraTower {Œπ : Type*} [Preorder Œπ] (AT : Œπ ‚Üí Type*)
  [‚àÄ i, CommSemiring (AT i)] where
   
  protected algebraMap : ‚àÄ i j, (h : i ‚â§ j) ‚Üí (AT i ‚Üí+* AT j)
   
  commutes' : ‚àÄ (i j : Œπ) (h : i ‚â§ j) (r : AT i) (x : AT j),
    (algebraMap i j h r) * x = x * (algebraMap i j h r)
  coherence': ‚àÄ (i j k : Œπ) (h1 : i ‚â§ j) (h2 : j ‚â§ k),
    algebraMap i k (h1.trans h2) =
      (algebraMap j k h2).comp (algebraMap i j h1)

structure ParamConditions (P : Params Œπ F) where
  h_deg : ‚àÉ k : ‚Ñï, P.deg = 2^k
  h_foldingParams : ‚àÄ i : Fin (M + 1), ‚àÉ k : ‚Ñï, (P.foldingParam i) = 2^k
  h_deg_ge : P.deg ‚â• ‚àè i : Fin (M + 1), (P.foldingParam i)
  h_smooth : ‚àÄ i : Fin (M + 1), Smooth (P.œÜ i)
  h_smooth_le : ‚àÄ i : Fin (M + 1), Fintype.card (Œπ i) ‚â§ (degree Œπ P i)
  h_repeatP_le : ‚àÄ i : Fin (M + 1), P.repeatParam i + 1 ‚â§ (degree Œπ P i)

protected def cast (P : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec‚ÇÅ) :
    Prover oSpec StmtIn WitIn StmtOut WitOut pSpec‚ÇÇ where
  PrvState := P.PrvState ‚àò Fin.cast (congrArg (¬∑ + 1) hn.symm)
  input := P.input
  sendMessage := fun i st => do
    let ‚ü®msg, newSt‚ü© ‚Üê P.sendMessage (i.cast hn.symm (cast_symm hSpec)) st
    return ‚ü®(Message.cast_idx_symm hSpec) ‚ñ∏ msg, newSt‚ü©
  receiveChallenge := fun i st => do
    let f ‚Üê P.receiveChallenge (i.cast hn.symm (cast_symm hSpec)) st
    return fun chal => f (Challenge.cast_idx hSpec ‚ñ∏ chal)
  output := P.output ‚àò (fun st => _root_.cast (by admit /- proof elided -/
  ) st)

def queryRbrKnowledgeError := fun _ : (pSpecQuery ùîΩq Œ≤ Œ≥_repetitions
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).ChallengeIdx =>
  ((1/2 : ‚Ñù‚â•0) + (1 : ‚Ñù‚â•0) / (2 * 2^ùì°))^Œ≥_repetitions

def oracleVerifier : OracleVerifier oSpec Statement OStatement Unit (OStatement ‚äï·µ• OStatement)
    (pSpec OStatement) where

  verify := fun stmt _ => relComp stmt

  embed := sorry

  hEq := sorry

noncomputable def commitOracleProver (i : Fin ‚Ñì) :
  OracleProver (oSpec := []‚Çí)
    
    (StmtIn := Statement (L := L) Context i.succ)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) i.succ)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) i.succ)
    (pSpec := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) where

  PrvState := commitPrvState ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i

  input := fun ‚ü®‚ü®stmt, oStmt‚ü©, wit‚ü© => (stmt, oStmt, wit)

  sendMessage 
  | ‚ü®0, _‚ü© => fun inputPrvState => by admit /- proof elided -/
  | ‚ü®0, h‚ü© => nomatch h 

  output := fun ‚ü®stmt, oStmt, wit‚ü© => by admit /- proof elided -/

@[reducible]
def combineMap : StmtIn √ó WitIn ‚Üí OracleComp oSpec (StmtOut √ó WitOut) :=
  fun ‚ü®stmt, wit‚ü© => do return (‚Üê mapStmt stmt, ‚Üê mapWit stmt wit)

noncomputable def getFoldProverFinalOutput (i : Fin ‚Ñì)
    (finalPrvState : foldPrvState ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      i 2 (Context := Context)) :
  ((Statement (L := L) Context i.succ √ó ((j : Fin (toOutCodewordsCount ‚Ñì œë i.castSucc)) ‚Üí
    OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j))
      √ó Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ) :=

def fiberEvaluationMapping (i : Fin r) (steps : ‚Ñï) (h_i_add_steps : i.val + steps < ‚Ñì + ùì°)
    (f : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) i ‚Üí L)
    (y : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate)
      ‚ü®‚Üëi + steps, by admit /- proof elided -/
      ‚ü©)
    : Fin (2 ^ steps) ‚Üí L :=
  
  let fiberMap := qMap_total_fiber ùîΩq Œ≤ (i := i) (steps := steps)
    (h_i_add_steps := h_i_add_steps) (y := y)

  
  fun idx => f (fiberMap idx)

def NestedList (n : ‚Ñï) : Type := dfoldr' n (fun _ => Type) (fun _ T => List T) Nat

example : NestedList 0 = Nat := rfl
example (n : ‚Ñï) : NestedList (n + 1) = List (NestedList n) := rfl

protected def cast (P : OracleProver oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec‚ÇÅ) :
    OracleProver oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec‚ÇÇ :=
  Prover.cast hn hSpec P

@[reducible]
def OracleStatement : Unit ‚Üí Type := fun _ => R‚¶É‚â§ deg‚¶Ñ[X Fin n]

class DCast‚ÇÇ (Œ± : Sort*) (Œ≤ : Œ± ‚Üí Sort*) (Œ≥ : (a : Œ±) ‚Üí Œ≤ a ‚Üí Sort*) [DCast Œ± Œ≤] where
  dcast‚ÇÇ : ‚àÄ {a a' : Œ±} {b : Œ≤ a} {b' : Œ≤ a'},
    (ha : a = a') ‚Üí (dcast ha b = b') ‚Üí Œ≥ a b ‚Üí Œ≥ a' b'
  dcast‚ÇÇ_id : ‚àÄ {a : Œ±} {b : Œ≤ a}, dcast‚ÇÇ (Eq.refl a) dcast_eq = (id : Œ≥ a b ‚Üí Œ≥ a b)

instance {i : Fin (n + 1)} : OfNat (evalDomain D i) 1 where
  ofNat := ‚ü®1, one_in_doms D i‚ü©

Eq.mp in Init.Core

@[reducible]
def spec : OracleSpec Unit := fun _ => (Œ± √ó Œ±, Œ±)

@[inline, reducible]
def lift : (OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i)) √ó OuterWitIn ‚Üí
    (InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i)) √ó InnerWitOut ‚Üí
    (OuterStmtOut √ó (‚àÄ i, OuterOStmtOut i)) √ó OuterWitOut :=
  fun ctxIn ctxOut => ‚ü®lens.stmt.lift ctxIn.1 ctxOut.1, lens.wit.lift ctxIn ctxOut‚ü©

def towerAlgebraMap (l r : ‚Ñï) (h_le : l ‚â§ r) : BTField l ‚Üí+* BTField r :=

@[reducible]
def pBits : Nat := 31

@[reducible, inline, specialize]
def getChallenge (pSpec : ProtocolSpec n) (i : pSpec.ChallengeIdx) :
    OracleComp ([pSpec.Challenge]‚Çí'challengeOracleInterface) (pSpec.Challenge i) :=
  (query i () : OracleQuery ([pSpec.Challenge]‚Çí'challengeOracleInterface) (pSpec.Challenge i))

instance : Fact (Nat.Prime BASE_FIELD_CARD) := ‚ü®BaseField_is_prime‚ü©

def projectToMidSumcheckPoly (t : MultilinearPoly L ‚Ñì)
    (m : MultilinearPoly L ‚Ñì) (i : Fin (‚Ñì + 1))
    (challenges : Fin i ‚Üí L)
    : MultiquadraticPoly L (‚Ñì-i) :=
  let H‚ÇÄ: MultiquadraticPoly L ‚Ñì := computeInitialSumcheckPoly (‚Ñì:=‚Ñì) t m
  let H·µ¢ := fixFirstVariablesOfMQP (‚Ñì := ‚Ñì) (v := ‚ü®i, by admit /- proof elided -/
  ‚ü©)
    (H := H‚ÇÄ) (challenges := challenges)
  ‚ü®H·µ¢, by admit /- proof elided -/
  ‚ü©

def equivFin2 : Direction ‚âÉ Fin 2 where
  toFun := fun dir => match dir with | .V_to_P => ‚ü®0, by admit /- proof elided -/
  ‚ü© | .P_to_V => ‚ü®1, by admit /- proof elided -/
  ‚ü©
  invFun := fun n => match n with | ‚ü®0, _‚ü© => .V_to_P | ‚ü®1, _‚ü© => .P_to_V
  left_inv := fun dir => match dir with | .P_to_V => rfl | .V_to_P => rfl
  right_inv := fun n => match n with | ‚ü®0, _‚ü© => rfl | ‚ü®1, _‚ü© => rfl

noncomputable def queryOracleProver :
  OracleProver
    (oSpec := []‚Çí)
    (StmtIn := FinalSumcheckStatementOut (L:=L) (‚Ñì:=‚Ñì))
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (
    Fin.last ‚Ñì))
    (WitIn := Unit)
    (StmtOut := Bool)
    (OStmtOut := fun _ : Empty => Unit)
    (WitOut := Unit)
    (pSpec := pSpecQuery ùîΩq Œ≤ Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)) where
  PrvState := fun
    | 0 => Unit
    | 1 => Unit
  input := fun _ => ()

  sendMessage
  | ‚ü®0, h‚ü© => nomatch h

  receiveChallenge
  | ‚ü®0, _‚ü© => fun _ => do
    
    pure (fun _challenges => ())

  output := fun _ => do 
    pure (‚ü®true, fun _ => ()‚ü©, ())

def toStatement (stmt : FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì)) :
  Statement (L := L) (Context := SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì)  :=
  {
    sumcheck_target := stmt.sumcheck_target,
    challenges := stmt.challenges,
    ctx := stmt.ctx
  }

@[reducible]
def GroupEncodeOracle : OracleSpec Unit := fun _ => (Œπ, BitVec bitLength)

def StateRestoration.Soundness (oSpec : OracleSpec Œπ) (StmtIn : Type)
    {n : ‚Ñï} (pSpec : ProtocolSpec n) :=
  OracleComp (oSpec ++‚Çí (srChallengeOracle StmtIn pSpec)) (StmtIn √ó pSpec.Messages)

MvPolynomial.aeval in Mathlib.Algebra.MvPolynomial.Eval

def natDegreeY (f : F[X][Y]) : ‚Ñï := Polynomial.natDegree f

def FinalSumcheckWit := fun (m : Fin (1 + 1)) =>
 match m with
 | ‚ü®0, _‚ü© => Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì)
 | ‚ü®1, _‚ü© => Unit

@[inline, specialize]
def oracleVerifier : OracleVerifier oSpec
    Unit (fun _ : Fin 2 => OStatement)
    (Query OStatement) (fun _ : Fin 2 => OStatement) (pSpec OStatement) where

  verify := fun _ chal => do
    let q : Query OStatement := chal ‚ü®0, rfl‚ü©
    pure q

  embed := Function.Embedding.inl

  hEq := by admit /- proof elided -/

NatPow in Init.Prelude

@[reducible]
noncomputable def fullOracleProof :
  OracleProof []‚Çí
    (Statement := Statement (L := L) (‚Ñì:=‚Ñì) (SumcheckBaseContext L ‚Ñì) 0)
    (OStatement := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë 0)
    (Witness := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì) 0)
    (pSpec:=fullPSpec ùîΩq Œ≤ Œ≥_repetitions (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)) :=
  fullOracleReduction ùîΩq Œ≤ Œ≥_repetitions (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë)

instance : ToNat Nat where
  toNat := id

instance : ‚àÄ j, OracleInterface (FinalOracleStatement D x s j) :=
  fun j =>
    if h : j = k + 1
    then {
           Query := Unit
           Response := F[X]
           answer := cast (by admit /- proof elided -/
           )
                          (id (Œ± := Unit ‚Üí F[X]))
         }
    else {
           Query :=
            ‚Üë(
              evalDomain D x
              (‚àë j' ‚àà finRangeTo j.1, s j')
            )
           Response := F
           answer := cast (by admit /- proof elided -/
           )
                          (id (Œ± := ‚Üë(evalDomain D x (‚àë j' ‚àà finRangeTo j.1, s j')) ‚Üí F))
         }

OfNat in Init.Prelude

def toMessagesChallenges (transcript : Transcript k pSpec) :
    MessagesUpTo k pSpec √ó ChallengesUpTo k pSpec :=
  (transcript.toMessagesUpTo, transcript.toChallengesUpTo)

def possibleDistsToCode (w : Œπ ‚Üí F) (C : Set (Œπ ‚Üí F)) (Œ¥f : (Œπ ‚Üí F) ‚Üí (Œπ ‚Üí F) ‚Üí Œ±) : Set Œ± :=
  {d : Œ± | ‚àÉ c ‚àà C, c ‚â† w ‚àß Œ¥f w c = d}

Finsupp.update in Mathlib.Data.Finsupp.Single

def distEq (mx my : OracleComp spec Œ±) : Prop :=
  evalDist mx = evalDist my

instance [h : ProverLast pSpec] : ProverFirst pSpec where
  prover_first' := by admit /- proof elided -/

def stirRelation
    {F : Type} [Field F] [Fintype F] [DecidableEq F]
    {Œπ : Type} [Fintype Œπ] [Nonempty Œπ]
    (degree : ‚Ñï) (œÜ : Œπ ‚Ü™ F) (err : ‚Ñù)
    : Set ((Unit √ó ‚àÄ i, (OracleStatement Œπ F i)) √ó Unit) :=
  fun ‚ü®‚ü®_, oracle‚ü©, _‚ü© => Œ¥·µ£(oracle (), ReedSolomon.code œÜ degree) ‚â§ err

@[simp]
instance BTFieldIsDomain (k : ‚Ñï) : IsDomain (BTField k) := inferInstance

def rationalRoot (H : F[X][Y]) (z : F) : Type :=
  {t_z : F // evalEval z t_z H = 0}

instance [inst : ‚àÄ i, DecidableEq (pSpec.Message i)] {k : Fin (n + 1)} :
    DecidableEq (MessagesUpTo k pSpec) :=
  @Fintype.decidablePiFintype _ _ (fun i => inst ‚ü®i.1.castLE (by admit /- proof elided -/
  ), i.property‚ü©) _

@[reducible, simp]
def oraclePSpec : ProtocolSpec 1 := ‚ü®!v[.P_to_V], !v[Witness]‚ü©

noncomputable def polynomialAlgEquiv : P ‚âÉ‚Çê[R] R[X] where
  toFun := toPolynomialAlgHom
  invFun := ofPolynomialAlgHom
  left_inv := by admit /- proof elided -/

abbrev contract (m : ‚Ñï) (f : Fin n ‚Üí Œ±) := liftF (liftF' (n := m) (liftF f))

def findIdxRev? (cond : Œ± ‚Üí Bool) (as : Array Œ±) : Option (Fin as.size) :=
  find ‚ü® as.size, Nat.lt_succ_self _ ‚ü©
where
  find : Fin (as.size + 1) ‚Üí Option (Fin as.size)
    | 0 => none
    | ‚ü® i+1, h ‚ü© =>
      if (cond as[i]) then
        some ‚ü® i, Nat.lt_of_succ_lt_succ h ‚ü©
      else
        find ‚ü® i, Nat.lt_of_succ_lt h ‚ü©

Mathlib.Linter.TextBased.lintModules in Mathlib.Tactic.Linter.TextBased

noncomputable def proximity_gap_johnson (rho : ‚Ñö) (m : ‚Ñï) : ‚Ñù :=
  (1 : ‚Ñù) - Real.sqrt rho - Real.sqrt rho / (2 * m)

instance inhabited [Inhabited R] : Inhabited (MlPolyEval R n) :=

inductive ScalarVectorOp where | scale

instance {k : Fin (n + 1)} : Fintype (pSpec.ChallengeIdxUpTo k) :=
  inferInstanceAs (Fintype <| ChallengeIdx (pSpec.take k k.is_le))

instance : ‚àÄ j, OracleInterface (OracleStatement D x m j) :=
  fun _ => inferInstance

Polynomial.reverse in Mathlib.Algebra.Polynomial.Reverse

Fin.take in Mathlib.Data.Fin.Tuple.Take

noncomputable def disFromHammingNorm [Semiring F] [DecidableEq F] (LC : LinearCode Œπ F) : ‚Ñï :=
  sInf {d | ‚àÉ u ‚àà LC, u ‚â† 0 ‚àß hammingNorm u ‚â§ d}

def findSumIdxWith (l : List ‚Ñï) (j : Fin l.sum) : (i : Fin l.length) √ó Fin (l.get i) := sorry

Ideal in Mathlib.RingTheory.Ideal.Defs

instance {s} : LawfulFunctor (fun Œ± => InternalData Œ± s) :=

def FullData.ofFun {Œ± : Type} (s : Skeleton)
    (f : SkeletonNodeIndex s ‚Üí Œ±) : FullData Œ± s :=
  match s with
  | .leaf => FullData.leaf (f SkeletonNodeIndex.ofLeaf)
  | .internal l r =>
      FullData.internal
        (f SkeletonNodeIndex.ofInternal)
        (FullData.ofFun l (fun idx => f (SkeletonNodeIndex.ofLeft idx)))
        (FullData.ofFun r (fun idx => f (SkeletonNodeIndex.ofRight idx)))

def OracleReduction.addSalt
    (R : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec)
    (saltComp : (i : pSpec.MessageIdx) ‚Üí R.prover.PrvState i.1.castSucc ‚Üí
      OracleComp oSpec (Salt i)) :
    OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut (pSpec.addSalt Salt) where
  prover := R.prover.addSalt Salt saltComp
  verifier := R.verifier.addSalt Salt

def OracleVerifier.liftContext
    (lens : OracleStatement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                              OuterOStmtIn OuterOStmtOut InnerOStmtIn InnerOStmtOut)
    (V : OracleVerifier oSpec InnerStmtIn InnerOStmtIn InnerStmtOut InnerOStmtOut pSpec) :
      OracleVerifier oSpec OuterStmtIn OuterOStmtIn OuterStmtOut OuterOStmtOut pSpec where
  verify := fun outerStmtIn transcript => sorry
  embed := by admit /- proof elided -/

USize.ofNat in Init.Data.UInt.BasicAux

@[reducible, simp]
def rbrSoundness (langIn : Set Statement)
    (verifier : Verifier oSpec Statement Bool pSpec)
    (rbrSoundnessError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) : Prop :=
  verifier.rbrSoundness init impl langIn acceptRejectRel.language rbrSoundnessError

@[inline, specialize]
def run (stmt : StmtIn) (wit : WitIn)
    (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí) (FullTranscript pSpec √ó StmtOut √ó WitOut) := do
  let ‚ü®transcript, state‚ü© ‚Üê prover.runToRound (Fin.last n) stmt wit
  return ‚ü®transcript, ‚Üê prover.output state‚ü©

def liftBTFieldProps (k : ‚Ñï) (prevBTFResult : ConcreteBTFStepResult (k := k)) :
  ConcreteBTFieldProps (k + 1) := {
    zero_mul := concrete_zero_mul (prevBTFResult.toConcreteBTFieldProps),
    zero_mul' := fun a => by admit /- proof elided -/

StrongRankCondition in Mathlib.LinearAlgebra.InvariantBasisNumber

def vcons {n : ‚Ñï} (a : Œ±) (v : Fin n ‚Üí Œ±) : Fin (n + 1) ‚Üí Œ± :=
  dcons a v

instance [O‚ÇÅ : ‚àÄ i, OracleInterface.{0, u, v} (pSpec‚ÇÅ.Message i)]
    [O‚ÇÇ : ‚àÄ i, OracleInterface.{0, u, v} (pSpec‚ÇÇ.Message i)] :
    ‚àÄ i, OracleInterface.{0, u, v} ((pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).Message i) :=
  fun ‚ü®i, h‚ü© => Fin.fappend‚ÇÇ (A := Direction) (B := Type)
    (F := fun dir type => (h : dir = .P_to_V) ‚Üí OracleInterface type)
    (Œ±‚ÇÅ := pSpec‚ÇÅ.dir) (Œ≤‚ÇÅ := pSpec‚ÇÇ.dir)
    (Œ±‚ÇÇ := pSpec‚ÇÅ.Type) (Œ≤‚ÇÇ := pSpec‚ÇÇ.Type) (fun i h => O‚ÇÅ ‚ü®i, h‚ü©) (fun i h => O‚ÇÇ ‚ü®i, h‚ü©) i h

def ratchet (sponge : DuplexSponge U C) :
    OracleComp (forwardPermutationOracle C) (DuplexSponge U C) := do
  let permutedState : C ‚Üê query (spec := forwardPermutationOracle C) () sponge.state
  
  let vecState : Vector U SpongeSize.N := SpongeState.get permutedState
  
  let zeroed : Vector U SpongeSize.N :=
    Vector.ofFn (fun i => if i < SpongeSize.R then 0 else vecState[i])
  
  let newVecState := SpongeState.update permutedState zeroed
  
  return { sponge with
    state := newVecState,
    squeezePos := Fin.last SpongeSize.R }

Field.toCommRing in Mathlib.Algebra.Field.Defs

def JohnsonConditionStrong (B : Finset (Fin n ‚Üí F)) (v : Fin n ‚Üí F) : Prop :=
  let e := e B v
  let d := d B
  let q : ‚Ñö := Fintype.card F
  let frac := q / (q - 1)
  (1 - frac * d/n) < (1- frac * e/n) ^ 2

instance [Zero T] [DecidableEq T] [ToNat T] : Div (Cayley T) where
  div := div

def proximityChecksSpec (Œ≥_challenges :
    Fin Œ≥_repetitions ‚Üí sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®0, by omega‚ü©)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì) j)
    (fold_challenges : Fin ‚Ñì ‚Üí L) (final_constant : L) : Prop :=
  ‚àÄ rep : Fin Œ≥_repetitions,
    let v := Œ≥_challenges rep
    -- For all folding levels k = 0, ..., ‚Ñì/œë - 1, we track c_cur through the iterations
    ‚àÄ k_val : Fin (‚Ñì / œë),
      let i := k_val.val * œë
      have h_k: k_val ‚â§ (‚Ñì/œë - 1) := by omega
      have h_i_add_œë_le_‚Ñì : i + œë ‚â§ ‚Ñì := by
        calc i + œë = k_val * œë + œë := by omega
          _ ‚â§ (‚Ñì/œë - 1) * œë + œë := by
            apply Nat.add_le_add_right; apply Nat.mul_le_mul_right; omega
          _ = ‚Ñì/œë * œë :=

instance (s : Finset œÉ) : Fintype { x : œÉ | x ‚àà s } :=

def partition (cs : ConstraintSystem ùì° numWires numGates) :
    Fin numWires ‚Üí Finset (Fin (3 * numGates)) :=
  
  
  
  
  fun i => Finset.map (Equiv.toEmbedding finProdFinEquiv)
    (Finset.filter (fun j => if j.1 = 0 then (cs j.2).a = i
      else if j.1 = 1 then (cs j.2).b = i else (cs j.2).c = i)
    (Finset.univ : Finset (Fin 3 √ó Fin numGates)))

def factor' (n : ‚Ñï) : Option (List PrimeWithMultiplicity) := do
  let facts := List.mergeSort (‚Üê factor n)
  let groups := List.splitBy (¬∑ = ¬∑) facts
  return groups.map (fun g => ‚ü®g[0]!, g.length‚ü©)

def disagreementSet (i : Fin ‚Ñì) (steps : ‚Ñï) [NeZero steps] (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
  (f g : OracleFunction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) ‚ü®i.val + steps, by admit /- proof elided -/
    ‚ü©) :
  Set ((sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®i.val + steps, by admit /- proof elided -/
  ‚ü©) :=
  {y | f y ‚â† g y}

noncomputable def D_X (rho : ‚Ñö) (n m : ‚Ñï) : ‚Ñù := (m + 1/2) * (Real.sqrt rho) * n

ByteArray.mk in Init.Prelude

def evalX (a : F) (f : F[X][Y]) : Polynomial F :=
  ‚ü®Finsupp.mapRange (Polynomial.eval a) eval_zero f.toFinsupp‚ü©

def findSumIdx' (l : List ‚Ñï) (j : Fin l.sum) : Fin l.length := ‚ü®findSumIdx l j, sorry‚ü©

instance : ‚àÄ j, OracleInterface ((pSpec F).Message j)
  | ‚ü®0, h‚ü© => nomatch h
  | ‚ü®1, _‚ü© => by admit /- proof elided -/

def add {k : ‚Ñï} (x y : ConcreteBTField k) : ConcreteBTField k := BitVec.xor x y

@[ext]
structure AssocFin (n : AssocNat) where
  val : AssocNat
  isLt : val < n

@[ext]
class OracleInterface (Message : Type u) where
  Query : Type v
  Response : Type w
  answer : Message ‚Üí Query ‚Üí Response

def Reduction.fiatShamir (R : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec) :
    NonInteractiveReduction (‚àÄ i, pSpec.Message i) (oSpec ++‚Çí fsChallengeOracle StmtIn pSpec)
      StmtIn WitIn StmtOut WitOut where
  prover := R.prover.fiatShamir
  verifier := R.verifier.fiatShamir

Algebra.TensorProduct.instCommSemiring in Mathlib.RingTheory.TensorProduct.Basic

IsField in Mathlib.Algebra.Field.IsField

def modNat [Zero T] [DecidableEq T] [ToNat T]
    (dividend divisor : Cayley T) : Nat ‚Üí Cayley T
  | 0        => dividend  
  | .succ fuel =>
    
    if (‚Üëdivisor : Nat) = 0 then
      dividend
    else
      
      if (‚Üëdivisor : Nat) ‚â§ (‚Üëdividend : Nat) then
        
        modNat (sub dividend divisor) divisor fuel
      else
        dividend

def FullTranscript.extractSalt (transcript : (pSpec.addSalt Salt).FullTranscript) :
    (i : pSpec.MessageIdx) ‚Üí Salt i :=
  Transcript.extractSalt (pSpec := pSpec) (k := Fin.last n) transcript

abbrev CoeffVecSpace (L : Type u) (‚Ñì : Nat) := Fin (2^‚Ñì) ‚Üí L

inductive SkeletonNodeIndex : Skeleton ‚Üí Type
  | ofLeaf : SkeletonNodeIndex Skeleton.leaf
  | ofInternal {left right} :
      SkeletonNodeIndex (Skeleton.internal left right)
  | ofLeft {left right : Skeleton} (idxLeft : SkeletonNodeIndex left) :
      SkeletonNodeIndex (Skeleton.internal left right)
  | ofRight {left right : Skeleton} (idxRight : SkeletonNodeIndex right) :
      SkeletonNodeIndex (Skeleton.internal left right)

instance instST‚ÇÇ [SelectableType R] : ‚àÄ i, SelectableType
    ((‚ü®!v[.P_to_V], !v[R‚¶É‚â§ deg‚¶Ñ[X]]‚ü© ++‚Çö !p[] ++‚Çö ‚ü®!v[.V_to_P], !v[R]‚ü©).Challenge i) :=
  instSelectableTypeChallengeAppend

instance {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    [inst : ‚àÄ i, ‚àÄ j, SelectableType ((pSpec i).Challenge j)] :
    ‚àÄ k, SelectableType ((seqCompose pSpec).Challenge k) :=
  fun ‚ü®k, h‚ü© => Fin.fflatten‚ÇÇ
    (A := Direction) (B := Type) (F := fun dir type => (h : dir = .V_to_P) ‚Üí SelectableType type)
    (fun i' j' h' => inst i' ‚ü®j', h'‚ü©) k h

structure BerlekampWelchCondition (e k : ‚Ñï) (œâs f : Fin n ‚Üí F) (E Q : Polynomial F) : Prop where
  cond: ‚àÄ i : Fin n, Q.eval (œâs i) = (f i) * E.eval (œâs i)
  E_natDegree : E.natDegree = e
  E_leadingCoeff : E.coeff e = 1
  Q_natDegree : Q.natDegree ‚â§ e + k - 1

def findImports (path : System.FilePath) : IO (Array Lean.Name) := do
  return (‚Üê Lean.parseImports' (‚Üê IO.FS.readFile path) path.toString)
    |>.map (fun imp ‚Ü¶ imp.module) |>.erase `Init

@[elab_as_elim]
def dconcat {n : ‚Ñï} {motive : Fin (n + 1) ‚Üí Sort u}
    (u : (i : Fin n) ‚Üí motive i.castSucc) (a : motive (last n)) (i : Fin (n + 1)) : motive i :=
  match n with
  | 0 => match i with | 0 => a
  | _ + 1 => dcons (u 0) (dconcat (fun i => u (Fin.succ i)) a) i

setOf in Mathlib.Data.Set.Defs

@[reducible]
def pSpecRelay : ProtocolSpec 0 := ‚ü®![], ![]‚ü© 

def concat {k : Fin n} (messages : MessagesUpTo k.castSucc pSpec)
    (h : pSpec.dir k = .P_to_V) (msg : pSpec.Message ‚ü®k, h‚ü©) : MessagesUpTo k.succ pSpec :=
  fun ‚ü®i, h‚ü© => (concat' (pSpec := pSpec) (fun i hi => messages ‚ü®i, hi‚ü©) (fun _ => msg)) i h

def totalNumPermQueriesMessage : Nat :=
  ‚àë i, pSpec.L‚Çö·µ¢ i

Polynomial.Monic in Mathlib.Algebra.Polynomial.Degree.Definitions

@[ext]
structure VectorSpec (n : ‚Ñï) where
  dir : Fin n ‚Üí Direction
  length : Fin n ‚Üí Nat

Algebra.TensorProduct.rightAlgebra in Mathlib.RingTheory.TensorProduct.Basic

Finset.product in Mathlib.Data.Finset.Prod

instance instNatPow {n : ‚Ñï} : NatPow (CNat n) := match n with
  | 0 => by admit /- proof elided -/
  | .succ n => by admit /- proof elided -/

instance : NatCast (UniPoly R) := ‚ü®fun n => UniPoly.C (n : R)‚ü©

def intCast_ofNat {k : ‚Ñï} (n : ‚Ñï) : intCast (k:=k) (n : ‚Ñ§) = natCast n :=

@[simp]
abbrev Witness.AfterFirstSumcheck : Type := Unit

noncomputable def ofPolynomialAlgHom : R[X] ‚Üí‚Çê[R] P := Polynomial.aeval PolynomialLike.X

protected def cast (R : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec‚ÇÅ) :
    Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec‚ÇÇ where
  prover := R.prover.cast hn hSpec
  verifier := R.verifier.cast hn hSpec

instance : PrimeOrder G where
  p := p
  hCard := PrimeOrderWith.hCard

instance instDCastSigma {Œ± : Type*} {Œ≤ : Œ± ‚Üí Type*} {Œ≥ : (a : Œ±) ‚Üí Œ≤ a ‚Üí Type*}
    [DCast Œ± Œ≤] [DCast‚ÇÇ Œ± Œ≤ Œ≥] : DCast ((a : Œ±) √ó Œ≤ a) (fun a => Œ≥ a.1 a.2) where
  dcast hab c := dcast‚ÇÇ (by admit /- proof elided -/
  ) (by admit /- proof elided -/
  ) c
  dcast_id := by admit /- proof elided -/

Matrix.add in Mathlib.LinearAlgebra.Matrix.Defs

abbrev RScodeSet (domain : Œπ ‚Ü™ F) (deg : ‚Ñï) : Set (Œπ ‚Üí F) := (ReedSolomon.code domain deg).carrier

instance [VerifierFirst pSpec] : ‚àÄ i, OracleInterface (pSpec.Message i) := isEmptyElim

List.idxOf in Init.Data.List.Basic

instance [Zero T] [ToNat T] : DecidableEq (Cayley T) := fun a b =>
  if h : (‚Üëa : Nat) = (‚Üëb : Nat) then
    isTrue (by admit /- proof elided -/
      )
  else
    isFalse (fun heq => h (by admit /- proof elided -/
    ))

@[reducible, simp]
def relOut : Set (Statement √ó Unit) := Set.univ

def pow (S : Finset Œπ) (œÜ : Œπ ‚Ü™ F) (k : ‚Ñï) : indexPow S œÜ k ‚Ü™ F :=
    Function.Embedding.subtype fun y => y ‚àà indexPow S œÜ k

def someValues : HList' (fun x => x) someTypes :=
  HList'.cons 1 (HList'.cons "bad" (HList'.cons 3 HList'.nil))

Sum.isRight in Init.Data.Sum.Basic

DecidableEq in Init.Prelude

def Œæ (x‚ÇÄ : F) (R : F[X][X][Y]) (H : F[X][Y]) [œÜ : Fact (Irreducible H)] : ùí™ H :=
  (Œæ_regular x‚ÇÄ R H).choose

@[simp]
abbrev OracleStatement := R1CS.OracleStatement R pp.toSizeR1CS

@[reducible]
def pSpec (F : Type) [Semiring F] : ProtocolSpec 2 := ‚ü®!v[.V_to_P, .P_to_V], !v[F, Unit ‚Üí F[X]]‚ü©

def knowledgeStateFunction :
    (oracleVerifier oSpec OStatement).KnowledgeStateFunction init impl
    (relIn OStatement) (relOut OStatement) (rbrExtractor oSpec OStatement) where
  toFun
  | 0 => fun ‚ü®_, oracles‚ü© _ _ => oracles 0 = oracles 1
  | 1 => fun ‚ü®_, oracles‚ü© chal _ =>
    let q : Query OStatement := by admit /- proof elided -/

def statelessOracle (baseSpec : OracleSpec Œπ‚Çú) (spec : OracleSpec Œπ)
    (f : (i : Œπ) ‚Üí spec.domain i ‚Üí spec.range i) :
    SimOracle.Stateless (baseSpec ++‚Çí spec) baseSpec where
  impl
  | query (.inl i) t => query i t
  | query (.inr i) t => pure (f i t)

def ChallengeIdx.inl (i : ChallengeIdx pSpec‚ÇÅ) : ChallengeIdx (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ) :=
  ‚ü®Fin.castAdd n i.1, by admit /- proof elided -/
  ‚ü©

def generateSrs (n : ‚Ñï) (a : ZMod p) : Vector G‚ÇÅ (n + 1) √ó Vector G‚ÇÇ 2 :=
  (towerOfExponents g‚ÇÅ a n, towerOfExponents g‚ÇÇ a 1)

HDiv in Init.Prelude

def completeness
    (relIn : Set ((StmtIn √ó ‚àÄ i, OStmtIn i) √ó WitIn))
    (relOut : Set ((StmtOut √ó ‚àÄ i, OStmtOut i) √ó WitOut))
    (oracleReduction : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec)
    (completenessError : ‚Ñù‚â•0) : Prop :=
  Reduction.completeness init impl relIn relOut oracleReduction.toReduction completenessError

instance [Zero T] [One T] [ToNat T] : HomogeneousPow (Cayley T) where
  pow := pow

@[simps!]
def MessageIdx.sumEquiv :
    MessageIdx pSpec‚ÇÅ ‚äï MessageIdx pSpec‚ÇÇ ‚âÉ MessageIdx (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ) where
  toFun := Sum.elim (MessageIdx.inl) (MessageIdx.inr)
  invFun := fun ‚ü®i, h‚ü© => by admit /- proof elided -/

@[simp]
def testStmtLens :
    Statement.Lens OuterStmtIn_Test OuterStmtOut_Test InnerStmtIn_Test InnerStmtOut_Test :=
  ‚ü®fun ‚ü®p, q, t‚ü© => ‚ü®p * q, t‚ü©, fun ‚ü®p, q, _‚ü© ‚ü®_, t', u‚ü© => (p, q, t', u)‚ü©

def outputRelation (cond : ‚àë i, (s i).1 ‚â§ n) [DecidableEq F] (Œ¥ : ‚Ñù‚â•0) :
    Set
      (
        (FinalStatement F k √ó ‚àÄ j, FinalOracleStatement D x s j) √ó
        Witness F s d (Fin.last (k + 1))
      )
  := FinalFoldPhase.outputRelation D x s d cond Œ¥

Or.inr in Init.Prelude

@[inline, reducible]
def lift : OuterStmtIn √ó OuterWitOut ‚Üí InnerWitIn ‚Üí OuterWitIn :=
  lens.toFunB

def ChurchBool (Œ± : Type) : Type := Œ± ‚Üí Œ± ‚Üí Œ±

protected def dcast {n n' : ‚Ñï} {Œ± : Fin n ‚Üí Sort u} {Œ±' : Fin n' ‚Üí Sort u}
    (h : n' = n) (hŒ± : ‚àÄ i, Œ± (Fin.cast h i) = Œ±' i) (v : (i : Fin n) ‚Üí Œ± i) :
      (i : Fin n') ‚Üí Œ±' i :=
  fun i => _root_.cast (hŒ± i) (v (Fin.cast h i))

noncomputable def sDomainBasisVectors (i : Fin r) : Fin (‚Ñì + R_rate - i) ‚Üí L :=
  fun k => (normalizedW ùîΩq Œ≤ i).eval (Œ≤ ‚ü®i + k.val, by admit /- proof elided -/
  ‚ü©)

noncomputable instance {v : Œπ ‚Üí F} {s : AffineSubspace F (Œπ ‚Üí F)} [Fintype s] :
    Fintype (v +·µ• s) := Fintype.ofFinite ‚Ü•(v +·µ• s)

propext in Init.Core

def prover : OracleProver oSpec (StmtIn R) (OStmtIn R deg) Unit (StmtOut R) (OStmtOut R deg) Unit
    (pSpec R deg) where
  PrvState
    | 0 => R‚¶É‚â§ deg‚¶Ñ[X]
    | 1 => R‚¶É‚â§ deg‚¶Ñ[X]
    | 2 => R‚¶É‚â§ deg‚¶Ñ[X] √ó R

  input := fun ‚ü®‚ü®_, oStmt‚ü©, _‚ü© => oStmt ()

  sendMessage
  | ‚ü®0, _‚ü© => fun polyLE => pure ‚ü®polyLE, polyLE‚ü©
  | ‚ü®1, h‚ü© => nomatch h

  receiveChallenge
  | ‚ü®0, h‚ü© => nomatch h
  | ‚ü®1, _‚ü© => fun polyLE => pure fun chal => ‚ü®polyLE, chal‚ü©

  output := fun ‚ü®polyLE, chal‚ü© => pure (((polyLE.val.eval chal, chal), fun _ => polyLE), ())

class HasPred (T : Type u) where
   
  pred' : T ‚Üí T

noncomputable def listBlockRelDistance
  (i k : ‚Ñï) {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F} {œÜ' : (indexPowT S œÜ i) ‚Ü™ F}
  {m : ‚Ñï} [DecidableEq F] [DecidableEq Œπ] [Smooth œÜ]
  (f : (indexPowT S œÜ i) ‚Üí F) (S' : Finset (indexPowT S œÜ i))
  [‚àÄ i : ‚Ñï, Fintype (indexPowT S œÜ i)] [DecidableEq (indexPowT S œÜ i)] [Smooth œÜ']
  (C : Set ((indexPowT S œÜ i) ‚Üí F)) (_hcode : C = smoothCode œÜ' m) (Œ¥ : ‚Ñù‚â•0)
  [h : DecidableBlockDisagreement i k f S' œÜ'] : (Set ((indexPowT S œÜ i) ‚Üí F)) :=
    { u ‚àà C | Œî·µ£(i, k, f, S', œÜ', u) ‚â§ Œ¥ }

@[reducible]
def scalarFieldSize : Nat :=
  52435875175126190479447740508185965837690552500527637822603658699938581184513

def pSpecQuery : ProtocolSpec 1 :=
  ‚ü®![Direction.V_to_P],
    ![Fin Œ≥_repetitions ‚Üí sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate 0]‚ü©

def degCor
  (œÜ : Œπ ‚Ü™ F) (dstar degree : ‚Ñï) (r : F) (f : Œπ ‚Üí F) (x : Œπ) : F :=
    f x * ‚àë l ‚àà range (dstar - degree + 1), ((œÜ x) * r) ^ l

noncomputable def toPoly' (p : UniPoly R) : Polynomial R :=
  Polynomial.ofFinsupp (Finsupp.onFinset (Finset.range p.size) p.coeff (by admit /- proof elided -/
  ))

def truncate (p : Polynomial F) (n : ‚Ñï) : Polynomial F
  := ‚ü®‚ü®p.1.1 ‚à© Finset.range n, fun i ‚Ü¶ if i < n then p.1.2 i else 0, by admit /- proof elided -/
  ‚ü©‚ü©

def Equiv.ofLawfulPermute (Œ± : Type*) [Permute Œ±] [LawfulPermute Œ±] : Equiv Œ± Œ± where
  toFun := Permute.permute
  invFun := LawfulPermute.permuteInv
  left_inv := LawfulPermute.left_inv
  right_inv := LawfulPermute.right_inv

def instTestLensKnowledgeSound : testLensE.IsKnowledgeSound
      outerRelIn_Test innerRelIn_Test outerRelOut_Test innerRelOut_Test
      (fun ‚ü®p, q, _‚ü© ‚ü®f, _‚ü© => p * q = f) (fun _ _ => True) where
  proj_knowledgeSound := fun ‚ü®p, q, t‚ü© ‚ü®f, t', r‚ü© _ h h' => by admit /- proof elided -/

instance : Slice (FullTranscript pSpec) ‚Ñï ‚Ñï
    (fun _ start stop => start ‚â§ stop ‚àß stop ‚â§ n)
    (fun _ start stop _ => FullTranscript (pSpec‚ü¶start:stop‚üß))
    where
  slice := fun v start stop h => extract start stop h.1 h.2 v

noncomputable def toMLE (A : Matrix (Fin (2 ^ m)) (Fin (2 ^ n)) R) : R[X Fin n][X Fin m] :=
  MLE' (MLE' ‚àò A)

@[reducible]
def fieldSize : Nat := 2 ^ 64 - 2 ^ 32 + 1

@[reducible, simp] def OStmtIn : Unit ‚Üí Type := fun _ => R‚¶É‚â§ deg‚¶Ñ[X]

def params24 : Params where
  width := 24
  numFullRounds := 8
  numPartialRounds := 23
  internalDiagVectors := #v[
        -2,
        1,
        2,
        1 / 2,
        3,
        4,
        -1 / 2,
        -3,
        -4,
        1 / (2 ^ 8),
        1 / 4,
        1 / 8,
        1 / 16,
        1 / 32,
        1 / 64,
        1 / (2 ^ 24),
        -1 / (2 ^ 8),
        -1 / 8,
        -1 / 16,
        -1 / 32,
        -1 / 64,
        -1 / (2 ^ 7),
        -1 / (2 ^ 9),
        -1 / (2 ^ 24)
    ]
  roundConstants := RAW_CONSTANTS_24
  width_dvd_by_4 := by admit /- proof elided -/

def trans (eqv : Equiv pSpec pSpec') (eqv' : Equiv pSpec' pSpec'') : Equiv pSpec pSpec'' where
  round_eq := eqv.round_eq.trans eqv'.round_eq
  dir_eq := fun i => by admit /- proof elided -/

noncomputable instance {H : F[X][Y]} [inst : Fact (Irreducible H)] : Field (ùïÉ H) :=
  IsField.toField (isField_of_irreducible inst.out)

instance AffSpanSet.instFinite [NeZero k] (u : Fin k ‚Üí Œπ ‚Üí F) : (AffSpanSet u).Finite :=

def PowerType (n : ‚Ñï) : Type := dfoldr' n (fun _ => Type) (fun _ T => T ‚Üí T) Nat


example : PowerType 0 = Nat := rfl
example (n : ‚Ñï) : PowerType (n + 1) = (PowerType n ‚Üí PowerType n) := rfl

@[to_additive existing]
def partialProd {Œ± : Type*} [Monoid Œ±] (l : List Œ±) : List Œ± :=
  [1] ++ match l with
  | [] => []
  | a :: l' => (partialProd l').map (a * ¬∑)

inductive Program where

System.FilePath.addExtension in Init.System.FilePath

def evalSetY [DecidableEq F] (f : F[X][Y]) (P : Finset F) [Nonempty P] : Finset (Polynomial F) :=
  P.image (fun a => evalY a f)

noncomputable def decoder (e k : ‚Ñï) [NeZero n] (œâs f : Fin n ‚Üí F) : Option (Polynomial F) :=
  if ‚Äñf‚Äñ‚ÇÄ ‚â§ e
  then some 0
  else
    let x := linsolve (BerlekampWelchMatrix e k œâs f) (Rhs e œâs f)
    match x with
    | none => none
    | some x =>
      let E := solutionToE e k x
      let Q := solutionToQ e k x
      if Q % E = 0 then
        let p := Q / E
        if Œî‚ÇÄ(f, p.eval ‚àò œâs) ‚â§ e then
          some p
        else
          none
      else
        none

@[simps] def equivNat : Nat ‚âÉ AssocNat where
  toFun := ofNat
  invFun := toNat
  left_inv := by admit /- proof elided -/

class IsSecureWithGap
    (completeRelation : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (soundRelation : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (Œµ_rbr : vPSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0)
    (vectorIOP : VectorIOP Statement OStatement Witness vPSpec A) where

   
  is_complete : vectorIOP.perfectCompleteness (pure ()) ‚ü®isEmptyElim‚ü© completeRelation

   
  is_rbr_knowledge_sound :
    OracleProof.rbrKnowledgeSoundness (pure ()) ‚ü®isEmptyElim‚ü© soundRelation vectorIOP.verifier Œµ_rbr

AlgEquiv in Mathlib.Algebra.Algebra.Equiv

instance {U : Type} [SpongeUnit U] [SpongeSize] :
    SpongeState U (Vector U SpongeSize.N) where
  
  new := fun _ => 0
  get := id
  update := fun _ v => v

structure SparseMatrix (m n Œ± : Type*) where
  numEntries : ‚Ñï
  row : Fin numEntries ‚Üí m
  col : Fin numEntries ‚Üí n
  val : Fin numEntries ‚Üí Œ±
deriving Inhabited, DecidableEq

instance instDCast‚ÇÉ : DCast‚ÇÉ Nat (fun n => Fin (n + 1)) (fun n _ => ProtocolSpec n)
    (fun _ k pSpec => pSpec.Transcript k) where
  dcast‚ÇÉ h h' h'' T := Transcript.cast h
    (by admit /- proof elided -/
    )
    (by admit /- proof elided -/
    )
    T
  dcast‚ÇÉ_id := cast_id

def StateRestoration.KnowledgeSoundness (oSpec : OracleSpec Œπ) (StmtIn WitOut : Type)
    {n : ‚Ñï} (pSpec : ProtocolSpec n) :=
  OracleComp (oSpec ++‚Çí (srChallengeOracle StmtIn pSpec)) (StmtIn √ó pSpec.Messages √ó WitOut)

Nat.ceil in Mathlib.Algebra.Order.Floor.Defs

def KnowledgeStateFunctionOneShot.toKnowledgeStateFunction
    {relIn : Set (StmtIn √ó WitIn)} {relOut : Set (StmtOut √ó WitOut)}
    {verifier : Verifier oSpec StmtIn StmtOut pSpec}
    (stF : KnowledgeStateFunctionOneShot init impl relIn.language relOut.language verifier)
    (oneShotE : Extractor.RoundByRoundOneShot oSpec StmtIn WitIn pSpec) :
    verifier.KnowledgeStateFunction init impl relIn relOut oneShotE.toRoundByRound where
  toFun := fun m stmtIn tr witIn => if m = 0 then (stmtIn, witIn) ‚àà relIn else
    stF.toFun m stmtIn tr ‚à® (stmtIn, oneShotE m stmtIn tr default) ‚àà relIn
  toFun_empty := fun stmtIn witIn => by admit /- proof elided -/

noncomputable def E_and_Q_to_a_solution (e : ‚Ñï) (E Q : Polynomial F) (i : Fin n) : F :=
  if i < e then E.toFinsupp i else Q.toFinsupp (i - e)

structure PublicParams where
  ‚Ñì_m : ‚Ñï
  ‚Ñì_n : ‚Ñï
  ‚Ñì_w : ‚Ñï
  ‚Ñì_w_le_‚Ñì_n : ‚Ñì_w ‚â§ ‚Ñì_n := by admit /- proof elided -/

def singleHash (left : Œ±) (right : Œ±) : OracleComp (spec Œ±) Œ± := do
  let out ‚Üê query (spec := spec Œ±) () ‚ü®left, right‚ü©
  return out

Nat.floor in Mathlib.Algebra.Order.Floor.Defs

Polynomial.support in Mathlib.Algebra.Polynomial.Basic

DecidableRel in Init.Prelude

@[reducible]
def permutationOracle (Œ± : Type*) : OracleSpec PermuteDir :=
  forwardPermutationOracle Œ± ++‚Çí backwardPermutationOracle Œ±

OracleSpec.append in VCVio.OracleComp.OracleSpec

@[inline, specialize]
def mul (p q : UniPoly R) : UniPoly R :=
  p.zipIdx.foldl (fun acc ‚ü®a, i‚ü© => acc.add <| (smul a q).mulPowX i) (C 0)

noncomputable def finalSumcheckVerifier :
  OracleVerifier
    (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì))
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (StmtOut := FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì))
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (pSpec := pSpecFinalSumcheckStep (L := L)) where
  verify := fun stmtIn _ => do
    
    let c : L ‚Üê query (spec := [(pSpecFinalSumcheckStep (L := L)).Message]‚Çí) ‚ü®0, rfl‚ü© ()

    
    let eq_tilde_eval : L := eqTilde (r := stmtIn.ctx.t_eval_point) (r' := stmtIn.challenges)
    unless stmtIn.sumcheck_target = eq_tilde_eval * c do
      return { 
        ctx := {t_eval_point := 0, original_claim := 0},
        sumcheck_target := 0,
        challenges := 0,
        final_constant := 0
      }

    
    let stmtOut : FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì) := {
      ctx := stmtIn.ctx,
      sumcheck_target := eq_tilde_eval * c, 
      challenges := stmtIn.challenges,
      final_constant := c
    }
    pure stmtOut

  embed := ‚ü®fun j => by admit /- proof elided -/
  ‚ü©
  hEq := fun oracleIdx => by admit /- proof elided -/

def ri (dstar : ‚Ñï) (degs : Fin m ‚Üí ‚Ñï) (r : F) (i : Fin m) : F :=
          match i.1 with
          | 0 => 1
          | .succ i' =>
            let exp := i' + ‚àë j < i, (dstar - degs j)
            r ^ exp

@[inline, reducible]
def srChallengeOracle (Statement : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n) :
    OracleSpec pSpec.ChallengeIdx :=
  [pSpec.Challenge]‚Çí'(challengeOracleInterfaceSR Statement pSpec)

alias fsChallengeOracle := srChallengeOracle

Empty in Init.Prelude

def finalSumcheckRelOut :
    Set ((FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì) √ó
      (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì) j)) √ó
      (Unit)) :=
  { input | finalSumcheckRelOutProp ùîΩq Œ≤ (input := input) }

IO.FS.Stream.write in Init.System.IO

@[reducible]
def C : R ‚Üí+* P := algebraMap R P

@[reducible, inline]
instance instProdForall {Œπ : Type u} (v : Œπ ‚Üí Type v) [O : ‚àÄ i, OracleInterface (v i)] :
    OracleInterface (‚àÄ i, v i) where
  Query := (i : Œπ) √ó (O i).Query
  Response := (i : Œπ) √ó (O i).Response
  answer := fun f ‚ü®i, q‚ü© => ‚ü®i, (O i).answer (f i) q‚ü©

def reduction : Reduction oSpec (StmtIn R √ó (‚àÄ i, OStmtIn R deg i)) Unit
                                (StmtOut R √ó (‚àÄ i, OStmtOut R deg i)) Unit (pSpec R deg) where
  prover := prover R deg oSpec
  verifier := verifier R deg D oSpec

def StateRestoration (oSpec : OracleSpec Œπ)
    (StmtIn WitIn WitOut : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n) :=
  StmtIn ‚Üí 
  WitOut ‚Üí 
  pSpec.FullTranscript ‚Üí 
  QueryLog (oSpec ++‚Çí (srChallengeOracle StmtIn pSpec)) ‚Üí 
  QueryLog oSpec ‚Üí 
  OracleComp oSpec WitIn 

@[simp]
abbrev Statement.AfterSendEvalClaim : Type := Statement.AfterFirstSumcheck R pp

CommSemiring in Mathlib.Algebra.Ring.Defs

@[reducible]
def scalarFieldSize : Nat :=
  21888242871839275222246405745257275088548364400416034343698204186575808495617

Vector.replicate in Init.Data.Vector.Basic

def KnowledgeStateFunction.toStateFunction
    {relIn : Set (StmtIn √ó WitIn)} {relOut : Set (StmtOut √ó WitOut)}
    {verifier : Verifier oSpec StmtIn StmtOut pSpec} {WitMid : Fin (n + 1) ‚Üí Type}
    {extractor : Extractor.RoundByRound oSpec StmtIn WitIn WitOut pSpec WitMid}
    (kSF : KnowledgeStateFunction init impl relIn relOut verifier extractor) :
      verifier.StateFunction init impl relIn.language relOut.language where
  toFun := fun m stmtIn tr => ‚àÉ witMid, kSF.toFun m stmtIn tr witMid
  toFun_empty := by admit /- proof elided -/

finSuccEquiv' in Mathlib.Logic.Equiv.Fin.Basic

inductive Expr where
  | lit (a : Lit F)
  | var (name : String)
  | sOp (op : ScalarOp) (a : Lit F) (b : Lit F)
  | svOp (op : ScalarVectorOp) (a : Lit F) (v : Lit F)
  | vOp (op : VectorOp) (v1 : Lit F) (v2 : Lit F)

ProbComp in VCVio.OracleComp.OracleComp

AffineSubspace in Mathlib.LinearAlgebra.AffineSpace.AffineSubspace.Defs

noncomputable def foldProver :
  OracleProver []‚Çí
    (Statement F i.castSucc) (OracleStatement D x s i.castSucc) (Witness F s d i.castSucc.castSucc)
    (Statement F i.succ) (OracleStatement D x s i.succ) (Witness F s d i.castSucc.succ)
    (pSpec D x s i) where
  PrvState
  | 0 =>
    (Statement F i.castSucc √ó ((j : Fin (‚Üëi.castSucc + 1)) ‚Üí OracleStatement D x s i.castSucc j)) √ó
      Witness F s d i.castSucc.castSucc
  | _ =>
    (Statement F i.succ √ó ((j : Fin (‚Üëi.castSucc + 1)) ‚Üí OracleStatement D x s i.castSucc j)) √ó
      Witness F s d i.castSucc.succ

  input := id

  sendMessage
  | ‚ü®0, h‚ü© => nomatch h
  | ‚ü®1, _‚ü© => fun ‚ü®‚ü®chals, o‚ü©, p‚ü© =>
    pure ‚ü®fun x => p.1.eval x.1.1, ‚ü®‚ü®chals, o‚ü©, p‚ü©‚ü©

  receiveChallenge
  | ‚ü®0, _‚ü© => fun ‚ü®‚ü®chals, o‚ü©, p‚ü© => pure <|
    fun (Œ± : F) =>
      ‚ü®
        ‚ü®Fin.append chals (fun (_ : Fin 1) => Œ±), o‚ü©,
        ‚ü®p.1.foldNth (2 ^ (s i.castSucc).1) Œ±, witness_lift p.2‚ü©
      ‚ü©
  | ‚ü®1, h‚ü© => nomatch h

  output := fun ‚ü®‚ü®chals, o‚ü©, p‚ü© => pure <|
    ‚ü®
      ‚ü®
        chals,
        fun j =>
          if h : j.1 < i.1
          then by admit /- proof elided -/
      ‚ü©,
      p
    ‚ü©

instance : Fact (Nat.Prime fieldSize) := ‚ü®is_prime‚ü©

@[simp]
instance AlgebraTower.toIsScalarTower (a : AlgebraTower C) {i j k : Œπ}
    (h1 : i ‚â§ j) (h2 : j ‚â§ k) :
    letI : Algebra (C i) (C j) :=

def SkeletonInternalIndex.depth {s : Skeleton} : SkeletonInternalIndex s ‚Üí Nat
  | SkeletonInternalIndex.ofInternal => 0
  | SkeletonInternalIndex.ofLeft idxLeft => idxLeft.depth + 1
  | SkeletonInternalIndex.ofRight idxRight => idxRight.depth + 1

instance {i : Fin ‚Ñì} : ‚àÄ j, SelectableType ((pSpecCommit ùîΩq Œ≤
  (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i).Challenge j)
  | ‚ü®0, hj‚ü© => by admit /- proof elided -/

instance (i : Fin 0) : OracleInterface i.elim0 := Fin.elim0 i

def perm (cs : ConstraintSystem ùì° numWires numGates) : Equiv.Perm (Fin (3 * numGates)) := sorry

def SkeletonNodeIndex.isLeaf {s : Skeleton} (idx : SkeletonNodeIndex s) : Bool :=
  match idx with
  | SkeletonNodeIndex.ofLeaf => true
  | SkeletonNodeIndex.ofInternal => false
  | SkeletonNodeIndex.ofLeft _ => false
  | SkeletonNodeIndex.ofRight _ => false

List.min in Init.Data.List.Basic

structure DuplexSponge (U : Type) [SpongeUnit U] [SpongeSize] (C : Type*)
    [SpongeState U C] where
   
  state : C
   
  absorbPos : Fin (SpongeSize.R + 1)
   
  squeezePos : Fin (SpongeSize.R + 1)
deriving Inhabited

@[inline, specialize]
def oracleProver : OracleProver oSpec
    Statement OStatement (‚àÄ i, Witness i)
    Statement (OStatement ‚äï·µ• Witness) Unit
    (oraclePSpec Witness) where
  PrvState := fun _ => (Statement √ó (‚àÄ i, OStatement i)) √ó (‚àÄ i, Witness i)
  input := id
  sendMessage | ‚ü®0, _‚ü© => fun ‚ü®stmt, wit‚ü© => pure (wit, ‚ü®stmt, wit‚ü©)
  
  receiveChallenge | ‚ü®0, h‚ü© => nomatch h
  output := fun ‚ü®‚ü®stmt, oStmt‚ü©, wit‚ü© => pure (‚ü®stmt, Sum.rec oStmt wit‚ü©, ())

@[reducible] def NonInteractiveReduction (Message : Type) {Œπ : Type} (oSpec : OracleSpec Œπ)
    (StmtIn WitIn StmtOut WitOut : Type) :=
  Reduction oSpec StmtIn WitIn StmtOut WitOut ‚ü®!v[.P_to_V], !v[Message]‚ü©

def SkeletonNodeIndex.leftChild {s : Skeleton} (idx : SkeletonNodeIndex s) :
    Option (SkeletonNodeIndex s) :=
  match idx with
  | SkeletonNodeIndex.ofLeaf => none
  | @SkeletonNodeIndex.ofInternal left right =>
    some (SkeletonNodeIndex.ofLeft (getRootIndex left))
  | SkeletonNodeIndex.ofLeft idxLeft =>
    idxLeft.leftChild.map (SkeletonNodeIndex.ofLeft)
  | SkeletonNodeIndex.ofRight idxRight =>
    idxRight.leftChild.map (SkeletonNodeIndex.ofRight)

@[reducible, simp]
def relOut : Set ((StmtOut OStatement √ó ‚àÄ i, OStmtOut OStatement i) √ó WitOut) :=
  { ‚ü®‚ü®q, oStmt‚ü©, ()‚ü© | answer (oStmt 0) q = answer (oStmt 1) q }

def params16 : Params where
  width := 16
  numFullRounds := 8
  numPartialRounds := 20
  internalDiagVectors := #v[
       -2,
        1,
        2,
        1 / 2,
        3,
        4,
        -1 / 2,
        -3,
        -4,
        1 / (2 ^ 8),
        1 / 8,
        1 / (2 ^ 24),
        -1 / (2 ^ 8),
        -1 / 8,
        -1 / 16,
        -1 / (2 ^ 24),
    ]
  roundConstants := rawConstants16
  width_dvd_by_4 := by admit /- proof elided -/

LE.le in Init.Prelude

def binaryTowerModule {l r : ‚Ñï} (h_le : l ‚â§ r) :
    Module (ConcreteBTField l) (ConcreteBTField r) :=
  (ConcreteBTFieldAlgebra (h_le:=h_le)).toModule

def perfectCompleteness
    (relIn : Set ((StmtIn √ó ‚àÄ i, OStmtIn i) √ó WitIn))
    (relOut : Set ((StmtOut √ó ‚àÄ i, OStmtOut i) √ó WitOut))
    (oracleReduction : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec) :
      Prop :=
  Reduction.perfectCompleteness init impl relIn relOut oracleReduction.toReduction

instance (k : ‚Ñï) : NeZero (2^k) :=

instance : Zero (Cayley T) where
  zero := zero

private noncomputable def Q (œâs : Fin n ‚Üí F)
  (f : Fin n ‚Üí F) (p : Polynomial F) (e : ‚Ñï) : Polynomial F :=
  p * (E œâs f p e)

def getTypes {Œ±s : List Type} (_ : HList Œ±s) : List Type := Œ±s

def minDist [DecidableEq F] (IC : MatrixSubmodule Œ∫ Œπ F) : ‚Ñï :=
  sInf { d : ‚Ñï | ‚àÉ U ‚àà IC, ‚àÉ V ‚àà IC, distCodewords U V = d }

Polynomial.sum in Mathlib.Algebra.Polynomial.Basic

@[simp]
abbrev Statement.AfterFirstChallenge : Type :=
  FirstChallenge R pp √ó Statement.AfterFirstMessage R pp

def foldr' {Œ± : Type u} (n : ‚Ñï) (f : (i : Fin n) ‚Üí Œ± ‚Üí Œ±) (init : Œ±) : Œ± :=
  dfoldr' n (fun _ => Œ±) f init

instance : MvPolynomialLike œÉ R (MvPolynomial œÉ R) where
  X := MvPolynomial.X
  eval‚ÇÇ := fun f g => eval‚ÇÇHom f g
  eval‚ÇÇ_C := fun f g r => by admit /- proof elided -/

abbrev Field := ZMod fieldSize

Nat in Init.Prelude

Irreducible in Mathlib.Algebra.Group.Irreducible.Defs

structure Selector (ùì° : Type*) where
   
  qL : ùì°
   
  qR : ùì°
   
  qO : ùì°
   
  qM : ùì°
   
  qC : ùì°
deriving DecidableEq

def lastBlockOracleVerifier :=
  let bIdx := ‚Ñì / œë - 1
  let stmt : Fin (œë + 1) ‚Üí Type := fun i => Statement (L := L) (‚Ñì:=‚Ñì) Context
    ‚ü®bIdx * œë + i, by admit /- proof elided -/
    ‚ü©
  let oStmt := fun i: Fin (œë + 1) => OracleStatement ùîΩq Œ≤ œë
    ‚ü®bIdx * œë + i, by admit /- proof elided -/
    ‚ü©
  let V:  OracleVerifier []‚Çí (StmtIn := Statement (L := L) (‚Ñì := ‚Ñì) Context
      ‚ü®bIdx * œë, by admit /- proof elided -/
      ‚ü©)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë
      ‚ü®bIdx * œë, by admit /- proof elided -/
      ‚ü©)
    (StmtOut := Statement (L := L) (‚Ñì := ‚Ñì) Context (Fin.last ‚Ñì))
    (OStmtOut := OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì))
    (pSpec := pSpecLastBlock (L:=L) (œë:=œë)) := by admit /- proof elided -/

Set.imageFactorization in Mathlib.Data.Set.Operations

def reduction (i : Fin n) : Reduction oSpec
    ((StatementRound R n i.castSucc) √ó (‚àÄ i, OracleStatement R n deg i)) Unit
    ((StatementRound R n i.succ) √ó (‚àÄ i, OracleStatement R n deg i)) Unit (pSpec R deg) :=
  (Simple.reduction R deg D oSpec).liftContext (oCtxLens R n deg D i).toContext

instance {k : ‚Ñï} : NatCast (ConcreteBTField k) where
  natCast n:= natCast n

def fnOracle (spec : OracleSpec Œπ) (f : (i : Œπ) ‚Üí spec.domain i ‚Üí spec.range i) :
    SimOracle.Impl spec where
  impl | query i t => pure (f i t)

@[reducible, inline, specialize]
def Challenges (pSpec : ProtocolSpec n) : Type := ‚àÄ i, pSpec.Challenge i

List.foldr in Init.Data.List.Basic

instance [Repr Œ±] (Œ±s : List Type) [HListRepr (HList Œ±s)] : HListRepr (HList (Œ± :: Œ±s)) where
  repr
  | HList.cons x xs =>
    match xs with
    | HList.nil => reprPrec x 0
    | HList.cons _ _ => reprPrec x 0 ++ ", " ++ HListRepr.repr xs

TensorProduct in Mathlib.LinearAlgebra.TensorProduct.Basic

@[reducible] def OracleProof {Œπ : Type} (oSpec : OracleSpec Œπ)
    (Statement : Type) {Œπ‚Çõ·µ¢ : Type} (OStatement : Œπ‚Çõ·µ¢ ‚Üí Type) (Witness : Type)
    {n : ‚Ñï} (pSpec : ProtocolSpec n)
    [O‚Çõ·µ¢ : ‚àÄ i, OracleInterface (OStatement i)]
    [O‚Çò : ‚àÄ i, OracleInterface (pSpec.Message i)] :=
  OracleReduction oSpec Statement OStatement Witness Bool (fun _ : Empty => Unit) Unit pSpec

@[reducible, simp] def WitIn := Unit

PFunctor.X in ToMathlib.PFunctor.Basic

def eval‚ÇÇ [Semiring S] (f : R ‚Üí+* S) (x : S) (p : UniPoly R) : S :=
  p.zipIdx.foldl (fun acc ‚ü®a, i‚ü© => acc + f a * x ^ i) 0

Algebra.TensorProduct.includeLeftRingHom in Mathlib.RingTheory.TensorProduct.Basic

isEmptyElim in Mathlib.Logic.IsEmpty

OracleSpec in VCVio.OracleComp.OracleSpec

@[reducible, simp] def StmtOut : Type := R √ó R

def starData {Œ±} (k : ‚Ñï) (root : Œ±) (leaves : Fin k ‚Üí Œ±) :
    ArityTree.Data Œ± (starSkel k) :=

def rbrKnowledgeSoundness
    (relIn : Set ((StmtIn √ó ‚àÄ i, OStmtIn i) √ó WitIn))
    (relOut : Set ((StmtOut √ó ‚àÄ i, OStmtOut i) √ó WitOut))
    (verifier : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec)
    (rbrKnowledgeError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) : Prop :=
  verifier.toVerifier.rbrKnowledgeSoundness init impl relIn relOut rbrKnowledgeError

def eval‚ÇÇAlgHom {A B : Type*} [CommSemiring A] [CommSemiring B] [MvPolynomialLike œÉ A P]
    [Algebra R A] [IsScalarTower R A P] [Algebra R B]
    (f : A ‚Üí‚Çê[R] B) (g : œÉ ‚Üí B) : P ‚Üí‚Çê[R] B where
  toRingHom := eval‚ÇÇ f g
  commutes' r := by admit /- proof elided -/

Nat.decEq in Init.Prelude

def erase_even (s : Finset ‚Ñï) : Finset ‚Ñï := s.filter Odd

@[elab_as_elim]
def dcons {n : ‚Ñï} {motive : Fin (n + 1) ‚Üí Sort u} (a : motive 0)
    (b : (i : Fin n) ‚Üí motive i.succ) (i : Fin (n + 1)) : motive i :=
  match n with
  | 0 => match i with | 0 => a
  | _ + 1 => match i with
    | 0 => a
    | ‚ü®k + 1, hk‚ü© => b ‚ü®k, Nat.succ_lt_succ_iff.mp hk‚ü©

class Statement.Lens.IsSound {OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut : Type}
    (outerLangIn : Set OuterStmtIn) (outerLangOut : Set OuterStmtOut)
    (innerLangIn : Set InnerStmtIn) (innerLangOut : Set InnerStmtOut)
    (compatStmt : OuterStmtIn ‚Üí InnerStmtOut ‚Üí Prop)
    (lens : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut) where

  proj_sound : ‚àÄ outerStmtIn,
    outerStmtIn ‚àâ outerLangIn ‚Üí lens.proj outerStmtIn ‚àâ innerLangIn

  lift_sound : ‚àÄ outerStmtIn innerStmtOut,
    compatStmt outerStmtIn innerStmtOut ‚Üí
    innerStmtOut ‚àâ innerLangOut ‚Üí
    lens.lift outerStmtIn innerStmtOut ‚àâ outerLangOut

ZMod.charP in Mathlib.Data.ZMod.Basic

LawfulBEq in Init.Core

def getConst (F : Type) [NonBinaryField F] : OracleComp [(pSpec F).Message]‚Çí F[X] :=
  OracleComp.lift
    (by admit /- proof elided -/
    )

Fin.addNat in Init.Data.Fin.Basic

@[reducible]
def SimOracle.Impl (spec : OracleSpec Œπ) := SimOracle.Stateless spec []‚Çí

@[inline, reducible]
def lift : OuterStmtIn √ó OuterWitIn ‚Üí InnerStmtOut √ó InnerWitOut ‚Üí OuterStmtOut √ó OuterWitOut :=
  fun ctxIn ctxOut =>
    ‚ü®lens.stmt.toFunB ctxIn.1 ctxOut.1, lens.wit.toFunB ctxIn ctxOut‚ü©

@[simp]
instance BTFieldNoZeroDiv (k : ‚Ñï) : NoZeroDivisors (BTField k) :=

AddCommMonoid in Mathlib.Algebra.Group.Defs

instance {Œ± : Type u} : SliceLT (Array Œ±) Nat (fun _ _ => True) (fun _ _ _ => Array Œ±) where
  sliceLT xs stop _ := xs.take stop

Subgroup in Mathlib.Algebra.Group.Subgroup.Defs

IO.println in Init.System.IO

def Polynomial.toImpl {R : Type*} [Semiring R] (p : R[X]) : UniPoly R :=
  match p.degree with
  | ‚ä• => #[]
  | some d  => .ofFn (fun i : Fin (d + 1) => p.coeff i)

DivisionRing in Mathlib.Algebra.Field.Defs

Fin.dfoldl in Batteries.Data.Fin.Basic

noncomputable def modBivar (P P' : MvPolynomial (Fin 2) F)
    (hlg : IsUnit ((MonomialOrder.lex).leadingCoeff P')) : MvPolynomial (Fin 2) F :=
      
      let ord : MonomialOrder (Fin 2) := MonomialOrder.lex
      
      let b : Unit ‚Üí MvPolynomial (Fin 2) F := fun _ => P'
      
      have hb : ‚àÄ i : Unit, IsUnit (ord.leadingCoeff (b i)) := by admit /- proof elided -/

def mul_by_2 (s : Finset ‚Ñï) : Finset ‚Ñï :=
  s.map ‚ü®fun n => 2 * n, by admit /- proof elided -/
  ‚ü©

def oracleReduction : OracleReduction oSpec
      Statement OStatement Unit
      Unit (OStatement ‚äï·µ• OStatement) Unit (pSpec OStatement) where
  prover := oracleProver oSpec Statement OStatement
  verifier := oracleVerifier oSpec Statement OStatement relComp

Fin.succ in Init.Data.Fin.Basic

@[simp]
abbrev EvalClaim : R1CS.MatrixIdx ‚Üí Type := fun _ => R

@[inline]
def zsmul [SMul ‚Ñ§ R] (m : ‚Ñ§) (p : MlPoly R n) : MlPoly R n := p.map (fun a => m ‚Ä¢ a)

Fin.subNat in Init.Data.Fin.Basic

noncomputable def batchOracleReduction :
  OracleReduction []‚Çí
    Unit (OracleStatement D x m) (Witness F s d m)
    ((Fin m ‚Üí F) √ó Fri.Spec.Statement F (0 : Fin (k + 1)))
    (OracleStatement D x m)
    (Fri.Spec.Witness F s d (0 : Fin (k + 2)))
    (batchSpec F m) where
  prover := batchProver D x s d m
  verifier := batchVerifier (k := k) D x m

noncomputable def uni2bi (p : Polynomial F) : MvPolynomial (Fin 2) F :=
  Polynomial.eval‚ÇÇ MvPolynomial.C (MvPolynomial.X 0) p

structure WireIndices (numWires : ‚Ñï) where
   
  a : Fin numWires
   
  b : Fin numWires
   
  c : Fin numWires
deriving DecidableEq

def degree (P : Params Œπ F) : Fin (M + 1) ‚Üí ‚Ñï :=
  fun i => P.deg / ‚àè j < i, (P.foldingParam j)

@[inline]
def ofInputOnly
    (liftWit : OuterStmtIn √ó OuterWitOut ‚Üí InnerWitIn ‚Üí OuterWitIn) :
    Witness.InvLens OuterStmtIn OuterWitIn OuterWitOut InnerWitIn OuterWitOut :=
  ‚ü®Prod.snd, liftWit‚ü©

@[reducible, inline]
instance instMvPolynomialDegreeLE : OracleInterface (R‚¶É‚â§ d‚¶Ñ[X œÉ]) where
  Query := œÉ ‚Üí R
  Response := R
  answer := fun ‚ü®poly, _‚ü© point => eval point poly

def SkeletonNodeIndex.sibling {s : Skeleton} (idx : SkeletonNodeIndex s) :
    Option (SkeletonNodeIndex s) :=
  match idx with
  
  | SkeletonNodeIndex.ofLeaf => none
  
  | SkeletonNodeIndex.ofInternal => none
  
  | @SkeletonNodeIndex.ofLeft left right idxLeft =>
    match idxLeft with
    
    | SkeletonNodeIndex.ofLeaf => some (getRootIndex right).ofRight
    
    | SkeletonNodeIndex.ofInternal => some (getRootIndex right).ofRight
    
    
    | SkeletonNodeIndex.ofLeft idxLeftLeft =>
      idxLeftLeft.ofLeft.sibling.map (SkeletonNodeIndex.ofLeft)
    | SkeletonNodeIndex.ofRight idxLeftRight =>
      idxLeftRight.ofRight.sibling.map (SkeletonNodeIndex.ofLeft)
  | @SkeletonNodeIndex.ofRight left right idxRight =>
    match idxRight with
    | SkeletonNodeIndex.ofLeaf => some (getRootIndex left).ofLeft
    | SkeletonNodeIndex.ofInternal => some (getRootIndex left).ofLeft
    | SkeletonNodeIndex.ofLeft idxRightLeft =>
      idxRightLeft.ofLeft.sibling.map (SkeletonNodeIndex.ofRight)
    | SkeletonNodeIndex.ofRight idxRightRight =>
      idxRightRight.ofRight.sibling.map (SkeletonNodeIndex.ofRight)

Equivalence in Init.Core

def FullData.copath {Œ±} {s} (cache_tree : FullData Œ± s) :
    BinaryTree.SkeletonLeafIndex s ‚Üí List Œ±
  | .ofLeaf => []
  | .ofLeft idxLeft =>
    (cache_tree.rightSubtree).getRootValue ::
      (copath cache_tree.leftSubtree idxLeft)
  | .ofRight idxRight =>
    (cache_tree.leftSubtree).getRootValue ::
      (copath cache_tree.rightSubtree idxRight)

noncomputable def fieldToùïÉ {H : F[X][Y]} : F ‚Üí+* ùïÉ H :=
  RingHom.comp liftToFunctionField Polynomial.C

@[ext]
structure Cayley (T : Type u) [HasSucc T] where
   
  toFun : T ‚Üí T
   
  toFun_succ : ‚àÄ (t : T), toFun (succ' t) = succ' (toFun t)

@[inline] def lt [Zero T] [ToNat T] (a b : Cayley T) : Prop :=
  (‚Üëa : Nat) < (‚Üëb : Nat)

def length [Semiring F] (_ : LinearCode Œπ F) : ‚Ñï := Fintype.card Œπ

@[simps!]
noncomputable def algEquivAevalXSubC {R : Type*} [CommRing R] (t : R) : R[X] ‚âÉ‚Çê[R] R[X] :=

Fin.val in Init.Prelude

Option.bind in Init.Data.Option.Basic

instance : CommGroup G := IsCyclic.commGroup

noncomputable def fromColGenMat [CommRing F] (G : Matrix Œπ Œ∫ F) : LinearCode Œπ F :=
  LinearMap.range G.mulVecLin

@[simp]
instance BTFieldNeZero1 (k : ‚Ñï) : NeZero (1 : BTField k) :=

instance [ProverFirst pSpec] : Unique (pSpec.MessageIdx) where
  default := ‚ü®0, by admit /- proof elided -/
  ‚ü©
  uniq := fun ‚ü®i, _‚ü© => by admit /- proof elided -/

@[inline, reducible]
def OracleStatement.Lens (OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut : Type)
    {Outer_Œπ‚Çõ·µ¢ : Type} (OuterOStmtIn : Outer_Œπ‚Çõ·µ¢ ‚Üí Type) [‚àÄ i, OracleInterface (OuterOStmtIn i)]
    {Outer_Œπ‚Çõ‚Çí : Type} (OuterOStmtOut : Outer_Œπ‚Çõ‚Çí ‚Üí Type) [‚àÄ i, OracleInterface (OuterOStmtOut i)]
    {Inner_Œπ‚Çõ·µ¢ : Type} (InnerOStmtIn : Inner_Œπ‚Çõ·µ¢ ‚Üí Type) [‚àÄ i, OracleInterface (InnerOStmtIn i)]
    {Inner_Œπ‚Çõ‚Çí : Type} (InnerOStmtOut : Inner_Œπ‚Çõ‚Çí ‚Üí Type) [‚àÄ i, OracleInterface (InnerOStmtOut i)]
  :=
    Statement.Lens (OuterStmtIn √ó ‚àÄ i, OuterOStmtIn i) (OuterStmtOut √ó ‚àÄ i, OuterOStmtOut i)
                  (InnerStmtIn √ó ‚àÄ i, InnerOStmtIn i) (InnerStmtOut √ó ‚àÄ i, InnerOStmtOut i)

def extract {n : ‚Ñï} {Œ± : Fin n ‚Üí Sort*} (start stop : ‚Ñï) (h1 : start ‚â§ stop) (h2 : stop ‚â§ n)
    (v : (i : Fin n) ‚Üí Œ± i) : (i : Fin (stop - start)) ‚Üí Œ± ‚ü®i + start, by admit /- proof elided -/
    ‚ü© :=
  fun i ‚Ü¶ v ‚ü®i + start, by admit /- proof elided -/
  ‚ü©

@[reducible, simp] def WitIn := Unit

def twoLevelSkel (k0 k1 : ‚Ñï) :
    ArityTree.Skeleton 2 (ar2 k0 k1) :=
  ArityTree.Skeleton.node (fun _ =>
    ArityTree.Skeleton.node (fun _ => ArityTree.Skeleton.leaf))

def oStmtLens (i : Fin n) : OracleStatement.Lens
    (StatementRound R n i.castSucc) (StatementRound R n i.succ) (Simple.StmtIn R) (Simple.StmtOut R)
    (OracleStatement R n deg) (OracleStatement R n deg)
    (Simple.OStmtIn R deg) (Simple.OStmtOut R deg) where

  toFunA := fun ‚ü®‚ü®target, challenges‚ü©, oStmt‚ü© =>
    ‚ü®target, fun _ =>
      match h : n with
      | 0 => ‚ü®Polynomial.C <| MvPolynomial.isEmptyAlgEquiv R (Fin 0) (oStmt ()), by admit /- proof elided -/
        ‚ü©
      | n + 1 =>
      ‚ü®‚àë x ‚àà (univ.map D) ^·∂† (n - i), (oStmt ()).val ‚∏®X ‚¶Éi‚¶Ñ, challenges, x‚∏©'(by admit /- proof elided -/
      ),
        sumcheck_roundPoly_degreeLE R n deg D i (oStmt ()).property‚ü©‚ü©

  toFunB := fun ‚ü®‚ü®_oldTarget, challenges‚ü©, oStmt‚ü© ‚ü®‚ü®newTarget, chal‚ü©, oStmt'‚ü© =>
    ‚ü®‚ü®newTarget, Fin.snoc challenges chal‚ü©, oStmt‚ü©

instance [VerifierFirst pSpec] [h : VCVCompatible (pSpec.¬´Type¬ª 0)] :
    ‚àÄ i, VCVCompatible (pSpec.Challenge i)
  | ‚ü®0, _‚ü© => inferInstance

Fin.removeNth in Mathlib.Data.Fin.Tuple.Basic

Mathlib.Meta.NormNum.instAddMonoidWithOne in Mathlib.Tactic.NormNum.Result

@[inline, reducible]
def proj (lens : Extractor.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
              OuterWitIn OuterWitOut InnerWitIn InnerWitOut) :
    OuterStmtIn √ó OuterWitOut ‚Üí InnerStmtIn √ó InnerWitOut :=
  fun ‚ü®stmtIn, witOut‚ü© => ‚ü®lens.stmt.proj stmtIn, lens.wit.proj (stmtIn, witOut)‚ü©

@[simp]
def list (k : ‚Ñï) : List.Vector (BTField k) (k + 1) := (BinaryTowerAux k).2.vec

Polynomial.algEquivOfCompEqX in Mathlib.Algebra.Polynomial.AlgebraMap

def millerRabinBases : List ‚Ñï :=
  [2, 325, 9375, 28178, 450775, 9780504, 1795265022]

def toEvalsZeroOne (p : MvPolynomial œÉ R) : (œÉ ‚Üí Fin 2) ‚Üí R :=
  fun x => eval (x : œÉ ‚Üí R) p

noncomputable def errorBound (Œ¥ : ‚Ñù‚â•0) (deg : ‚Ñï) (domain : Œπ ‚Ü™ F) : ‚Ñù‚â•0 :=
  letI œÅ : ‚Ñù‚â•0 := œÅ (ReedSolomon.code domain deg)
  if Œ¥ ‚àà Set.Ioc 0 ((1 - œÅ)/2)
  then Fintype.card Œπ / Fintype.card F
  else if Œ¥ ‚àà Set.Ioo ((1 - œÅ)/2) (1 - œÅ.sqrt)
       then letI m := min (1 - œÅ.sqrt - Œ¥) (œÅ.sqrt / 20)
            ‚ü®(deg ^ 2 : ‚Ñù‚â•0) / ((2 * m) ^ 7 * (Fintype.card F : ‚Ñù)), by admit /- proof elided -/
            ‚ü©
       else 0

HMul in Init.Prelude

def concrete_inv {k : ‚Ñï} (a : ConcreteBTField k) : ConcreteBTField k :=
  if h_k_zero : k = 0 then
    if a = 0 then 0 else 1
  else
    if h_a_zero : a = 0 then 0
    else if h_a_one : a = 1 then 1
    else
      let h_k_gt_0 : k > 0 := Nat.zero_lt_of_ne_zero h_k_zero
      let (a_hi, a_lo) := split (k:=k) (h:=h_k_gt_0) a
      let prevZ := Z (k - 1)
      let a_lo_next := a_lo + concrete_mul a_hi prevZ
      let delta := concrete_mul a_lo a_lo_next + concrete_mul a_hi a_hi
      let delta_inverse := concrete_inv delta
      let out_hi := concrete_mul delta_inverse a_hi
      let out_lo := concrete_mul delta_inverse a_lo_next
      let res := „Ää out_hi, out_lo „Äã
      res

Vector.foldl in Init.Data.Vector.Basic

abbrev SEP_BYTE : String := ‚ü®[SEP_CHAR]‚ü©

instance instSub {n : ‚Ñï} : Sub (CNat n) := match n with
  | 0 => by admit /- proof elided -/
  | .succ n => by admit /- proof elided -/

def pSpecCoreInteraction := (pSpecSumcheckFold ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)) ++‚Çö
  (pSpecFinalSumcheckStep (L:=L))

def InternalData.ofFun {Œ± : Type} (s : Skeleton)
    (f : SkeletonInternalIndex s ‚Üí Œ±) : InternalData Œ± s :=
  match s with
  | .leaf => InternalData.leaf
  | .internal l r =>
      InternalData.internal
        (f SkeletonInternalIndex.ofInternal)
        (InternalData.ofFun l (fun idx => f (SkeletonInternalIndex.ofLeft idx)))
        (InternalData.ofFun r (fun idx => f (SkeletonInternalIndex.ofRight idx)))

Module.Basis.smulTower in Mathlib.RingTheory.AlgebraTower

def soundness (langIn : Set StmtIn) (langOut : Set StmtOut)
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    (soundnessError : ‚Ñù‚â•0) : Prop :=
  ‚àÄ WitIn WitOut : Type,
  ‚àÄ witIn : WitIn,
  ‚àÄ prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec,
  ‚àÄ stmtIn ‚àâ langIn,
    letI reduction := Reduction.mk prover verifier
    [fun ‚ü®_, stmtOut‚ü© => stmtOut ‚àà langOut
    | do (simulateQ (impl ++‚Çõ‚Çí challengeQueryImpl : QueryImpl _ (StateT œÉ ProbComp))
        <| reduction.run stmtIn witIn).run' (‚Üê init)] ‚â§ soundnessError

RingHom.comp in Mathlib.Algebra.Ring.Hom.Defs

@[reducible]
def reduction : Reduction oSpec StmtIn WitIn StmtOut WitOut !p[] where
  prover := prover mapStmt mapWit
  verifier := verifier mapStmt

instance [reduction.IsPerfectComplete init impl relIn relOut] :
    IsComplete init impl relIn relOut reduction where
  completenessError := 0
  is_complete := IsPerfectComplete.is_perfect_complete

@[inline]
def add [Add R] (p q : MlPoly R n) : MlPoly R n := Vector.zipWith (¬∑ + ¬∑) p q

@[reducible]
def oSpec (Œ± Œ≤ Œ≥ : Type) : OracleSpec (Unit ‚äï Unit) := randSpec Œ≤ ++‚Çí ROspec Œ± Œ≤ Œ≥

Set.Ico in Mathlib.Order.Interval.Set.Defs

def SkeletonLeafIndex.isLeaf {s : Skeleton} (idx : SkeletonLeafIndex s) : Bool :=
  match idx with
  | SkeletonLeafIndex.ofLeaf => true
  | SkeletonLeafIndex.ofLeft _ => false
  | SkeletonLeafIndex.ofRight _ => false

run in VCVio.CryptoFoundations.SecExp

class Deserialize.CloseToUniform (Œ± : Type u) (Œ≤ : Type u)
    [Fintype Œ±] [Fintype Œ≤] [Nonempty Œ±] [Nonempty Œ≤] [Deserialize Œ± Œ≤] where
  Œµ : ‚Ñù‚â•0
  Œµ_close : dist (PMF.uniformOfFintype Œ±) (deserialize <$> PMF.uniformOfFintype Œ≤) ‚â§ Œµ

@[inline] def pred : AssocNat ‚Üí AssocNat :=
  fun a => match a.toNat with
  | 0 => zero
  | Nat.succ k => ofNat k

@[reducible, inline, specialize]
instance challengeOracleInterface {pSpec : ProtocolSpec n} :
    ‚àÄ i, OracleInterface (pSpec.Challenge i) := fun i =>
  { Query := Unit
    Response := pSpec.Challenge i
    answer := fun c _ => c }

@[reducible]
def OracleStatement := fun _ : MatrixIdx => Matrix (Fin sz.m) (Fin sz.n) R

def getLast (a : Array Œ±) (h : a.size > 0) : Œ± := a[a.size - 1]

def sumPartial (m : ‚Ñï) (n : ‚Ñï) (D : Fin n ‚Üí Finset R) :
    MvPolynomial (Fin (m + n)) R ‚Üí‚Çó[R] MvPolynomial (Fin m) R where
  toFun := fun p => ‚àë x ‚àà Fintype.piFinset D, peval (Fin.sumCommEquiv m n) x p
  map_add' := fun p q => by admit /- proof elided -/

@[simp]
instance Nontrivial (k : ‚Ñï) : Nontrivial (BTField k) := inferInstance

@[reducible]
def pSpec : ProtocolSpec 1 := ‚ü®!v[.P_to_V], !v[OStatement default]‚ü©

def nonsquare [Semiring F] (Œπ' : ‚Ñï) (Œ± : Œπ ‚Üí F) : Matrix Œπ (Fin Œπ') F :=
  Matrix.of fun i j => (Œ± i) ^ j.1

def ratchetUnchecked [Permute C] (sponge : DuplexSponge U C) : DuplexSponge U C :=
  simulateQ' forwardPermutationOracleImpl (ratchet sponge) (by admit /- proof elided -/
  )

def ConcreteBTField.toBitString {k : ‚Ñï} (bv : ConcreteBTField k) : String :=
  bitVecToString (2 ^ k) (bv)

def modByMonic [Field R] (p : UniPoly R) (q : UniPoly R) :
    UniPoly R :=
  (divModByMonicAux p q).2

@[simp]
def evalDomain (i : ‚Ñï) : Set FÀ£ :=
  (x ^ (2 ^ i)) ‚Ä¢ (Domain.evalDomain D i)

noncomputable def monomialBasisOfDegreeLT {n : ‚Ñï} : Basis (Fin n) L (L‚¶É< n‚¶Ñ[X]) :=

noncomputable def toPoly (p : UniPoly R) : Polynomial R :=
  p.eval‚ÇÇ Polynomial.C Polynomial.X

def rbrKnowledgeSoundnessOneShot (relIn : Set (StmtIn √ó WitIn)) (relOut : Set (StmtOut √ó WitOut))
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    (rbrKnowledgeError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0) : Prop :=
  ‚àÉ stateFunction : verifier.KnowledgeStateFunctionOneShot init impl relIn.language relOut.language,
  ‚àÉ extractor : Extractor.RoundByRoundOneShot oSpec StmtIn WitIn pSpec,
  ‚àÄ stmtIn : StmtIn,
  ‚àÄ witIn : WitIn,
  ‚àÄ prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec,
  ‚àÄ i : pSpec.ChallengeIdx,
    [fun ‚ü®transcript, challenge, proveQueryLog‚ü© =>
      letI extractedWitIn := extractor i.1.castSucc stmtIn transcript proveQueryLog.fst
      (stmtIn, extractedWitIn) ‚àâ relIn ‚àß
        ¬¨ stateFunction i.1.castSucc stmtIn transcript ‚àß
          stateFunction i.1.succ stmtIn (transcript.concat challenge)
    | do
      (simulateQ (impl ++‚Çõ‚Çí challengeQueryImpl : QueryImpl _ (StateT œÉ ProbComp))
        (do
          let ‚ü®‚ü®transcript, _‚ü©, proveQueryLog‚ü© ‚Üê prover.runWithLogToRound i.1.castSucc stmtIn witIn
          let challenge ‚Üê liftComp (pSpec.getChallenge i) _
          return (transcript, challenge, proveQueryLog))).run' (‚Üê init)] ‚â§
      rbrKnowledgeError i

Fin.cons in Mathlib.Data.Fin.Tuple.Basic

def accepts (x : Fin numWires ‚Üí ùì°) (g : Gate ùì° numWires) : Prop :=
  g.eval x = 0

@[reducible, simp]
def OracleStatement.Lens.IsSound {OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut : Type}
    {Outer_Œπ‚Çõ·µ¢ : Type} {OuterOStmtIn : Outer_Œπ‚Çõ·µ¢ ‚Üí Type} [‚àÄ i, OracleInterface (OuterOStmtIn i)]
    {Outer_Œπ‚Çõ‚Çí : Type} {OuterOStmtOut : Outer_Œπ‚Çõ‚Çí ‚Üí Type} [‚àÄ i, OracleInterface (OuterOStmtOut i)]
    {Inner_Œπ‚Çõ·µ¢ : Type} {InnerOStmtIn : Inner_Œπ‚Çõ·µ¢ ‚Üí Type} [‚àÄ i, OracleInterface (InnerOStmtIn i)]
    {Inner_Œπ‚Çõ‚Çí : Type} {InnerOStmtOut : Inner_Œπ‚Çõ‚Çí ‚Üí Type} [‚àÄ i, OracleInterface (InnerOStmtOut i)]
    (outerLangIn : Set (OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i)))
    (outerLangOut : Set (OuterStmtOut √ó (‚àÄ i, OuterOStmtOut i)))
    (innerLangIn : Set (InnerStmtIn √ó (‚àÄ i, InnerOStmtIn i)))
    (innerLangOut : Set (InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i)))
    (compatStmt :
      OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i) ‚Üí InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i) ‚Üí Prop)
    (lens : OracleStatement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                                    OuterOStmtIn OuterOStmtOut InnerOStmtIn InnerOStmtOut) :=
  Statement.Lens.IsSound outerLangIn outerLangOut innerLangIn innerLangOut compatStmt lens

instance [ProverFirst pSpec] : ‚àÄ i, VCVCompatible (pSpec.Challenge i) := isEmptyElim

noncomputable def fullRbrKnowledgeError (i : (fullPSpec ùîΩq Œ≤ Œ≥_repetitions (œë := œë)
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).ChallengeIdx) : ‚Ñù‚â•0 :=
  Sum.elim (f := CoreInteraction.coreInteractionOracleRbrKnowledgeError ùîΩq Œ≤ (œë:=œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (g := QueryPhase.queryRbrKnowledgeError ùîΩq Œ≤ Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (ChallengeIdx.sumEquiv.symm i)

instance : curve.IsElliptic :=

Int.negSucc in Init.Data.Int.Basic

def MLEEquivFin {n : ‚Ñï} : R‚¶É‚â§ 1‚¶Ñ[X (Fin n)] ‚âÉ (Fin (2 ^ n) ‚Üí R) :=
  Equiv.trans MLEEquiv (Equiv.piCongr finFunctionFinEquiv (fun _ => Equiv.refl _))

class IsSingleRound (pSpec : ProtocolSpec 2) extends ProverFirst pSpec, VerifierLast pSpec

alias ProverThenVerifier := IsSingleRound

noncomputable def H
  (Œ¥ : ‚Ñö) (x‚ÇÄ : F)
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  : F[Z][X] := (exists_factors_with_large_common_root_set k Œ¥ x‚ÇÄ h_gs).choose_spec.choose

noncomputable def disagreementSet (f : Œπ ‚Üí F) (S : Finset F) (Ans : S ‚Üí F) : Finset F :=
  Set.toFinset ({x : Œπ | x.val ‚àà S ‚àß (ansPoly S Ans).eval x.val ‚â† f x}.image Subtype.val)

Algebra.algebraMap in Mathlib.Algebra.Algebra.Defs

Vector.zipWith in Init.Data.Vector.Basic

@[inline, specialize]
def runToRound (i : Fin (n + 1))
    (stmt : StmtIn) (wit : WitIn) (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      OracleComp (oSpec ++‚Çí [pSpec.Challenge]‚Çí) (pSpec.Transcript i √ó prover.PrvState i) :=
  Fin.induction
    (pure ‚ü®default, prover.input (stmt, wit)‚ü©)
    (prover.processRound)
    i

protected def basis : F := sorry

def generateProof {n : ‚Ñï} (i : Fin (2 ^ n)) (cache : Cache Œ± n) :
    List.Vector Œ± n :=
  match n with
  | 0 => List.Vector.nil
  | n + 1 => List.Vector.snoc (generateProof ‚ü®i.val / 2, by admit /- proof elided -/
  ‚ü© (cache.upper))
                              ((cache.leaves).get (findNeighbors i (Fin.last _)))

@[simp]
def BTFieldCard (k : ‚Ñï) : Fintype.card (BTField k) = 2^(2^k)
  := (BinaryTowerAux k).2.fieldFintypeCard

Ne in Init.Core

BitVec.ofNat in Init.Prelude

instance instDCast‚ÇÇ : DCast‚ÇÇ Nat ProtocolSpec (fun _ pSpec => FullTranscript pSpec) where
  dcast‚ÇÇ h h' T := FullTranscript.cast h h' T
  dcast‚ÇÇ_id := cast_id

def Reduction.liftContext
    (lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut)
    (R : Reduction oSpec InnerStmtIn InnerWitIn InnerStmtOut InnerWitOut pSpec) :
      Reduction oSpec OuterStmtIn OuterWitIn OuterStmtOut OuterWitOut pSpec where
  prover := R.prover.liftContext lens
  verifier := R.verifier.liftContext lens.stmt

LinearOrder in Mathlib.Order.Defs.LinearOrder

List.rtake in Mathlib.Data.List.DropRight

def ValidChurchNat : Type :=
  { f : ChurchNat ‚Ñï // ‚àÉ n, ‚àÄ g x, f g x = Nat.iterate g n x }

OracleComp.neverFailsWhen in VCVio.OracleComp.Traversal

noncomputable def fold_k
  {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F} {k m : ‚Ñï}
  [‚àÄ j : ‚Ñï, Neg (indexPowT S œÜ j)]
  (f : (indexPowT S œÜ 0) ‚Üí F) (Œ±s : Fin k ‚Üí F) (_hk : k ‚â§ m): indexPowT S œÜ k ‚Üí F :=
  fold_k_core f k Œ±s

@[inline]
def nsmul [SMul ‚Ñï R] (m : ‚Ñï) (p : MlPolyEval R n) : MlPolyEval R n := p.map (fun a => m ‚Ä¢ a)

IsLinearMap in Mathlib.Algebra.Module.LinearMap.Defs

@[reducible, inline, specialize, simp]
def Challenge' (pSpec : ProtocolSpec n) (i : Fin n) (_ : pSpec.dir i = .V_to_P) := pSpec.¬´Type¬ª i

def toMvPolynomial (p : MlPoly R n) : R[X Fin n] :=
  ‚àë i : Fin (2 ^ n), MvPolynomial.monomial (monomialOfNat i) (a:=p[i])

loggingOracle in VCVio.OracleComp.QueryTracking.LoggingOracle

class SliceLT (coll : Type u) (stop : Type v) (valid : outParam (coll ‚Üí stop ‚Üí Prop))
    (subcoll : outParam ((xs : coll) ‚Üí (stop : stop) ‚Üí (h : valid xs stop) ‚Üí Type w)) where
  sliceLT : (xs : coll) ‚Üí (stop : stop) ‚Üí (h : valid xs stop) ‚Üí subcoll xs stop h

def last_nonzero_prop {p : UniPoly R} (k : Fin p.size) : Prop :=
  p[k] ‚â† 0 ‚àß (‚àÄ j, (hj : j < p.size) ‚Üí j > k ‚Üí p[j] = 0)

def neqCols [DecidableEq F] (U V : Matrix Œπ Œπ' F) : Finset Œπ' :=
  {j | ‚àÉ i : Œπ, V i j ‚â† U i j}

class Context.Lens.IsComplete {OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut : Type}
    {OuterWitIn OuterWitOut InnerWitIn InnerWitOut : Type}
    (outerRelIn : Set (OuterStmtIn √ó OuterWitIn))
    (innerRelIn : Set (InnerStmtIn √ó InnerWitIn))
    (outerRelOut : Set (OuterStmtOut √ó OuterWitOut))
    (innerRelOut : Set (InnerStmtOut √ó InnerWitOut))
    (compat : (OuterStmtIn √ó OuterWitIn) ‚Üí (InnerStmtOut √ó InnerWitOut) ‚Üí Prop)
    (lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut) where

  proj_complete : ‚àÄ stmtIn witIn,
    (stmtIn, witIn) ‚àà outerRelIn ‚Üí
    (lens.stmt.proj stmtIn, lens.wit.proj (stmtIn, witIn)) ‚àà innerRelIn

  lift_complete : ‚àÄ outerStmtIn outerWitIn innerStmtOut innerWitOut,
    compat (outerStmtIn, outerWitIn) (innerStmtOut, innerWitOut) ‚Üí
    (outerStmtIn, outerWitIn) ‚àà outerRelIn ‚Üí
    (innerStmtOut, innerWitOut) ‚àà innerRelOut ‚Üí
    (lens.stmt.lift outerStmtIn innerStmtOut,
    lens.wit.lift (outerStmtIn, outerWitIn) (innerStmtOut, innerWitOut)) ‚àà outerRelOut

abbrev Size.n_x : ‚Ñï := sz.n - sz.n_w

def monomialBasis (w : Vector R n) : Vector R (2 ^ n) :=
  Vector.ofFn (fun i => ‚àè j : Fin n, if (BitVec.ofFin i).getLsb j then w[j] else 1)

def vprod [CommMonoid Œ±] {n : ‚Ñï} (a : Fin n ‚Üí Œ±) : Œ± :=
  Fin.dfoldr' n (fun _ => Œ±) (fun i acc => a i * acc) 1

instance {Œ± : Type u} : Slice (Array Œ±) Nat Nat (fun _ _ _ => True) (fun _ _ _ _ => Array Œ±) where
  slice xs start stop _ := xs.extract start stop

def processMemoryOps (ops : List (MemoryOp Œπ Œ±)) (startMem : M) : Option M :=
  ops.foldlM (fun m op =>
    match op with
    | .read ‚ü®i, v‚ü© => if Memory.read m i = v then some m else none
    | .write ‚ü®i, v‚ü© => some (Memory.write m i v)
  ) startMem

instance {Œ± : Type u} [ToNat Œ±] : CoeHead Œ± Nat where
  coe := ToNat.toNat

instance [Zero T] [ToNat T] : LT (Cayley T) where
  lt := lt

Nonempty in Init.Prelude

instance : DeserializeOption UInt8 ByteArray where
  deserialize bytes :=
    if h : bytes.size = 1 then
      some bytes[0]
    else
      none

def OracleSpec.FunctionType (spec : OracleSpec Œπ) := (i : Œπ) ‚Üí spec.domain i ‚Üí spec.range i

instance : ‚àÄ j, OracleInterface ((pSpec D x l).Message j) := fun j =>
  match j with
  | ‚ü®0, h‚ü© => nomatch h

def new (domainSeparator : DomainSeparator U H) (csrng : R) : FSProverState U H R :=
  let hashState := HashStateWithInstructions.new domainSeparator
  
  let rng : ProverPrivateRng R := { ds := (), csrng := csrng }
  { rng := rng, hashState := hashState, nargString := ByteArray.empty }

noncomputable def evaluationPointœâ (i : Fin (‚Ñì + 1))
    (x : Fin (2 ^ (‚Ñì + R_rate - i))) : L := 
    
  ‚àë (‚ü®k, hk‚ü©: Fin (‚Ñì + R_rate - i)),
    if Nat.getBit k x.val = 1 then
      (normalizedW ùîΩq Œ≤ ‚ü®i, by admit /- proof elided -/
      ‚ü©).eval (Œ≤ ‚ü®i + k, by admit /- proof elided -/
      ‚ü©)
    else
      0

def testNTTBTF‚ÇÉ : Fin (2 ^ (2 + 2)) ‚Üí BTF‚ÇÉ :=

noncomputable def finalSumcheckKnowledgeStateFunction {œÉ : Type} (init : ProbComp œÉ)
    (impl : QueryImpl []‚Çí (StateT œÉ ProbComp)) :
    (finalSumcheckVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).KnowledgeStateFunction init impl
    (relIn := roundRelation ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (ùìë := ùìë) (mp := BBF_SumcheckMultiplierParam) (Fin.last ‚Ñì))
    (relOut := finalSumcheckRelOut ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (extractor := finalSumcheckRbrExtractor ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
  where
  toFun := fun m ‚ü®stmt, oStmt‚ü© tr witMid =>
    finalSumcheckKStateProp ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (ùìë := ùìë) (tr := tr) (stmt := stmt) (witMid := witMid) (oStmt := oStmt)
  toFun_empty := fun stmt witMid => by admit /- proof elided -/

Int.natAbs in Init.Data.Int.Basic

def oracleReduction.sendClaim : OracleReduction oSpec (StmtIn R) (OStmtIn R deg) Unit
    (StmtAfterSendClaim R) (OStmtAfterSendClaim R deg) Unit ‚ü®!v[.P_to_V], !v[R‚¶É‚â§ deg‚¶Ñ[X]]‚ü© := sorry

@[reducible, inline, specialize]
def ChallengesUpTo (k : Fin (n + 1)) (pSpec : ProtocolSpec n) : Type :=
  ‚àÄ i, (pSpec.take k k.is_le).Challenge i

def proverInput (i : Fin n) : ProverInput
    ((StatementRound R n i.castSucc) √ó (‚àÄ i, OracleStatement R n deg i))
    Unit ((proverState R n deg i).PrvState 0) where
  input := Prod.fst

abbrev eqPolynomial (r : œÉ ‚Üí R) : R[X œÉ] :=
  ‚àè i : œÉ, singleEqPolynomial (r i) (X i)

instance : ‚àÄ j, SelectableType ((pSpecRelay).Challenge j)
  | ‚ü®x, hj‚ü© => by admit /- proof elided -/

@[reducible]
def backwardPermutationOracle (Œ± : Type*) : OracleSpec Unit := Œ± ‚Üí‚Çí Œ±

def map {Œ± Œ≤ : Fin n ‚Üí Sort*} (f : (i : Fin n) ‚Üí Œ± i ‚Üí Œ≤ i) (a : (i : Fin n) ‚Üí Œ± i) :
    (i : Fin n) ‚Üí Œ≤ i := fun i => f i (a i)

def concreteCanonicalEmbedding (k : ‚Ñï)
    (prevBTFieldProps : ConcreteBTFieldProps (k := (k)))
    (curBTFieldProps : ConcreteBTFieldProps (k := (k + 1))) :
  letI := mkFieldInstance prevBTFieldProps
  letI := mkFieldInstance curBTFieldProps
  ConcreteBTField k ‚Üí+* ConcreteBTField (k + 1) :=

def last_nonzero (p : UniPoly R) : Option (Fin p.size) :=
  p.findIdxRev? (¬∑ != 0)

def Verifier.StateFunction.liftContext
    {œÉ : Type} {init : ProbComp œÉ} {impl : QueryImpl oSpec (StateT œÉ ProbComp)}
    (lens : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut)
    (V : Verifier oSpec InnerStmtIn InnerStmtOut pSpec)
    (outerLangIn : Set OuterStmtIn) (outerLangOut : Set OuterStmtOut)
    (innerLangIn : Set InnerStmtIn) (innerLangOut : Set InnerStmtOut)
    [lensSound : lens.IsSound outerLangIn outerLangOut innerLangIn innerLangOut
      (V.compatStatement lens)]
    (stF : V.StateFunction init impl innerLangIn innerLangOut) :
      (V.liftContext lens).StateFunction init impl outerLangIn outerLangOut
where
  toFun := fun m outerStmtIn transcript =>
    stF m (lens.proj outerStmtIn) transcript
  toFun_empty := fun stmt => by admit /- proof elided -/

List.ranges in Mathlib.Data.List.Range

def D_Y (Q : F[Z][X][Y]) : ‚Ñï := Bivariate.natDegreeY Q

Polynomial.leadingCoeff in Mathlib.Algebra.Polynomial.Degree.Definitions

def generateProof {s} (cache_tree : FullData Œ± s) :
    BinaryTree.SkeletonLeafIndex s ‚Üí List Œ±
  | .ofLeaf => []
  | .ofLeft idxLeft =>
    (cache_tree.rightSubtree).getRootValue ::
      (generateProof cache_tree.leftSubtree idxLeft)
  | .ofRight idxRight =>
    (cache_tree.leftSubtree).getRootValue ::
      (generateProof cache_tree.rightSubtree idxRight)

def secondSumCheckVirtualPolynomial
    (stmt : Statement.AfterLinearCombination R pp)
    (oStmt : ‚àÄ i, OracleStatement.AfterLinearCombination R pp i) :
      MvPolynomial (Fin pp.‚Ñì_n) R := sorry

Set.Nontrivial in Mathlib.Data.Set.Subsingleton

def completeness (relIn : Set (StmtIn √ó WitIn))
    (relOut : Set (StmtOut √ó WitOut))
    (reduction : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec)
    (completenessError : ‚Ñù‚â•0) : Prop :=
  ‚àÄ stmtIn : StmtIn,
  ‚àÄ witIn : WitIn,
  (stmtIn, witIn) ‚àà relIn ‚Üí
    [fun ‚ü®‚ü®_, (prvStmtOut, witOut)‚ü©, stmtOut‚ü© => (stmtOut, witOut) ‚àà relOut ‚àß prvStmtOut = stmtOut
    | do (simulateQ (impl ++‚Çõ‚Çí challengeQueryImpl : QueryImpl _ (StateT œÉ ProbComp))
          <| reduction.run stmtIn witIn).run' (‚Üê init)] ‚â• 1 - completenessError

instance {pSpec : ProtocolSpec n} {Statement : Type} [‚àÄ i, VCVCompatible (pSpec.Challenge i)] :
    OracleSpec.FiniteRange (srChallengeOracle Statement pSpec) where
  range_inhabited' := fun i => by admit /- proof elided -/

Equiv.optionCongr in Mathlib.Logic.Equiv.Option

instance : ‚àÄ i, OracleInterface (Message ‚ü®!v[.V_to_P], !v[Chal]‚ü© i)
  | ‚ü®0, h‚ü© => nomatch h

@[reducible]
def addSalt (pSpec : ProtocolSpec n) (Salt : pSpec.MessageIdx ‚Üí Type) :
    ProtocolSpec n :=
  ‚ü®pSpec.dir, fun i => match hDir : pSpec.dir i with
    | .P_to_V => (pSpec.¬´Type¬ª i) √ó Salt ‚ü®i, hDir‚ü©
    | .V_to_P => pSpec.¬´Type¬ª i‚ü©

instance : SliceGE (FullTranscript pSpec) ‚Ñï
    (fun _ start => start ‚â§ n)
    (fun _ start _ => FullTranscript (pSpec‚ü¶start:‚üß))
    where
  sliceGE := fun v start h => drop start h v

instance : ‚àÄ i, OracleInterface (OracleStatement R pp i) :=
  fun i => {
    Query := (Fin pp.‚Ñì_m ‚Üí R) √ó (Fin pp.‚Ñì_n ‚Üí R)
    Response := R
    answer := fun matrix ‚ü®x, y‚ü© => matrix.toMLE ‚∏®C ‚àò x‚∏© ‚∏®y‚∏©
  }

Mod in Init.Prelude

def mkFieldInstance {k : ‚Ñï} (props : ConcreteBTFieldProps k) : Field (ConcreteBTField k) where
  toDivisionRing := mkDivisionRingInstance (k:=k) props
  mul_comm := props.mul_comm

Finsupp.onFinset in Mathlib.Data.Finsupp.Defs

@[simp]
def outerRelOut_Test : Set (OuterStmtOut_Test √ó Unit) :=
  setOf (fun ‚ü®‚ü®p, q, t, r‚ü©, _‚ü© => (p * q).eval r = t)

def natWeightedDegree.{u} {F : Type u} [Semiring F] (f : F[X][Y]) (u v : ‚Ñï) : ‚Ñï :=
  f.support.sup (fun m => u * (f.coeff m).natDegree + v * m)

def churchNil : ChurchVec Œ± := fun f base => base

def generator : BaseField √ó BaseField := (1, 2)

def deterministicMillerRabin (n : ‚Ñï) : Bool := Id.run do
  if n ‚â§ 2 ‚à® n % 2 = 0 then
    return n = 2

  let ‚ü®s, d‚ü© := factorOutTwos (n - 1)
  for a in millerRabinBases do
    if a % n == 0 then
      continue

    let mut x := powMod a d n
    if x = 1 ‚à® x = n - 1 then
      continue

    for _ in [0:s] do
      x := (x * x) % n
      if x == n - 1 ‚à® x ‚â§ 1 then
        break
    if x ‚â† n - 1 then
      return false

  return true

def vconcat {n : ‚Ñï} (v : Fin n ‚Üí Œ±) (a : Œ±) : Fin (n + 1) ‚Üí Œ± :=
  dconcat v a

Mul in Init.Prelude

AddCommGroup in Mathlib.Algebra.Group.Defs

@[inline] def add (a b : Cayley T) : Cayley T :=
  ‚ü®a.toFun ‚àò b.toFun, by admit /- proof elided -/
  ‚ü©

noncomputable def J (q Œ¥ : ‚Ñö) : ‚Ñù :=
  let frac := q / (q - 1)
  (1 / frac) * (1 - Real.sqrt (1 - frac * Œ¥))

Sub in Init.Prelude

Pi.single in Mathlib.Algebra.Notation.Pi.Basic

List.foldl in Init.Prelude

instance : Field ScalarField := ZMod.instField scalarFieldSize

class LawfulPermute (Œ± : Type*) [Permute Œ±] where
  permuteInv : Œ± ‚Üí Œ±
  left_inv : Function.LeftInverse permuteInv Permute.permute
  right_inv : Function.RightInverse permuteInv Permute.permute

def bitVecToString (width : ‚Ñï) (bv : BitVec width) : String :=
  Fin.foldl width (fun (s : String) (idx : Fin width) =>
    
    
    s.push (if BitVec.getLsb bv (Fin.rev idx) then '1' else '0')
  ) ""

Functor.map in Init.Prelude

StateT.run in Init.Control.State

def computeInitialSumcheckPoly (t : MultilinearPoly L ‚Ñì)
    (m : MultilinearPoly L ‚Ñì) : MultiquadraticPoly L ‚Ñì :=
  ‚ü®m * t, by
    rw [MvPolynomial.mem_restrictDegree_iff_degreeOf_le]
    intro i
    have h_t_deg: degreeOf i t.val ‚â§ 1 :=
      degreeOf_le_iff.mpr fun term a ‚Ü¶ (t.property) a i
    have h_m_deg: degreeOf i m.val ‚â§ 1 :=
      degreeOf_le_iff.mpr fun term a ‚Ü¶ (m.property) a i
    calc
      _ ‚â§ (degreeOf i m.val) + (degreeOf i t.val) :=
        degreeOf_mul_le i m.val t.val
      _ ‚â§ 2 :=

@[reducible, simp]
def knowledgeSoundness
    (relation : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (verifier : OracleVerifier oSpec Statement OStatement Bool (fun _ : Empty => Unit) pSpec)
    (knowledgeError : ‚Ñù‚â•0) : Prop :=
  verifier.toVerifier.knowledgeSoundness init impl relation acceptRejectOracleRel knowledgeError

protected def cast (pSpec : ProtocolSpec n‚ÇÅ) : ProtocolSpec n‚ÇÇ :=
  ‚ü®pSpec.dir ‚àò (Fin.cast hn.symm), pSpec.¬´Type¬ª ‚àò (Fin.cast hn.symm)‚ü©

Finset.biUnion in Mathlib.Data.Finset.Union

instance : ‚àÄ j, OracleInterface ((batchSpec F m).Message j)
  | ‚ü®0, h‚ü© => nomatch h

Algebra.TensorProduct.instAlgebra in Mathlib.RingTheory.TensorProduct.Basic

PowerSeries in Mathlib.RingTheory.PowerSeries.Basic

def outputRelation :
    Set
      (
        (Fri.Spec.Statement F (0 : Fin (k + 1)) √ó
        (‚àÄ j, Fri.Spec.OracleStatement D x s (0 : Fin (k + 1)) j)) √ó
        Fri.Spec.Witness F s d (0 : Fin (k + 2))
      ) := sorry

instance {s} : Functor (fun Œ± => FullData Œ± s) where
  map f x := x.map f

def oracleReduction : OracleReduction oSpec (StmtIn R) (OStmtIn R deg) Unit
    (StmtOut R) (OStmtOut R deg) Unit (pSpec R deg) :=
  ((oracleReduction.sendClaim R deg oSpec)
  |>.append (oracleReduction.checkClaim R deg oSpec)
  |>.append (oracleReduction.randomQuery R deg oSpec)
  |>.append (oracleReduction.reduceClaim R deg oSpec))

Id.run in Init.Control.Id

Set.univ in Mathlib.Data.Set.Defs

EmbeddingLike in Mathlib.Data.FunLike.Embedding

CoeHead in Init.Coe

def ofFin {n : AssocNat} (f : Fin (AssocNat.toNat n)) : AssocFin n :=
  ‚ü®AssocNat.ofNat f.val, by admit /- proof elided -/
  ‚ü©

Array.size in Init.Prelude

AddMonoidAlgebra in Mathlib.Algebra.MonoidAlgebra.Defs

@[reducible, simp] def OStmtOut := fun _ : Fin 1 => OStatement

repr in Init.Data.Repr

instance instDCastSigmaSigma {Œ± : Type*} {Œ≤ : Œ± ‚Üí Type*} {Œ≥ : (a : Œ±) ‚Üí Œ≤ a ‚Üí Type*}
    {Œ¥ : (a : Œ±) ‚Üí (b : Œ≤ a) ‚Üí Œ≥ a b ‚Üí Type*}
    [DCast Œ± Œ≤] [DCast‚ÇÇ Œ± Œ≤ Œ≥] [DCast‚ÇÉ Œ± Œ≤ Œ≥ Œ¥] :
    DCast ((a : Œ±) √ó (b : Œ≤ a) √ó Œ≥ a b) (fun a => Œ¥ a.1 a.2.1 a.2.2) where
  dcast hc d := dcast‚ÇÉ (by admit /- proof elided -/
  ) (by admit /- proof elided -/
  ) (by admit /- proof elided -/
  ) d
  dcast_id := by admit /- proof elided -/

def getNargString (state : FSProverState U H R) : ByteArray := state.nargString

  partial def computePrattCertificate (n : ‚Ñï) : Option (UnverifiedPrattCertificate n) :=
    
    if n ‚â§ 50 ‚àß deterministicMillerRabin n then
      some (.knownPrime n)
    else do
      let fs ‚Üê factor' (n - 1)
      let a ‚Üê findWitness n fs
      let part ‚Üê computePrattPart fs
      return .of n a part
  where
    findWitness (n : ‚Ñï) (fs : List PrimeWithMultiplicity) : Option ‚Ñï := do
      for a in [2:n] do
        let mut ok := true
        for ‚ü®p, _‚ü© in fs do
          if powMod a ((n - 1) / p) n = 1 then
            ok := false
            break

        if ok then
          return a

      none

Vector in Init.Data.Vector.Basic

structure LookaheadSequenceFamily
    (trace : QueryLog (forwardPermutationOracle (CanonicalSpongeState U)))
    (state : CanonicalSpongeState U) (i : pSpec.ChallengeIdx) where
   
  seqFamily : Finset (LookaheadSequence trace state)
   
  maximality : ‚àÄ s ‚àà seqFamily, ‚àÄ s' ‚àà seqFamily,
    ¬¨ (s.inputState ‚äÜ s'.inputState) ‚à® ¬¨ (s'.outputState ‚äÜ s.outputState)
   
  length_le_challengeSize : ‚àÄ s ‚àà seqFamily, s.inputState.length ‚â§ challengeSize i

def badEventExistsProp
    (stmtIdx : Fin (‚Ñì + 1)) (oracleIdx : Fin (‚Ñì + 1))
    (oStmt : ‚àÄ j, (OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (i := oracleIdx) j))
    (challenges : Fin stmtIdx ‚Üí L) : Prop :=
  ‚àÉ j, foldingBadEventAtBlock ùîΩq Œ≤ (stmtIdx := stmtIdx) (oracleIdx := oracleIdx)
    (oStmt := oStmt) (challenges := challenges) j

instance [IsSingleRound pSpec] : Unique (pSpec.ChallengeIdx) where
  default := ‚ü®1, by admit /- proof elided -/
  ‚ü©
  uniq := fun ‚ü®i, hi‚ü© => by admit /- proof elided -/

def isInterleaved (IC : InterleavedCode Œ∫ Œπ F) :=
  ‚àÄ V ‚àà IC.MF, ‚àÄ i, V i ‚àà IC.LC

instance {k : Fin 1} : Unique (ChallengesUpTo k !p[]) where
  default := fun ‚ü®‚ü®i, h‚ü©, _‚ü© => by admit /- proof elided -/

instance extractorLens_rbr_knowledge_soundness :
    Extractor.Lens.IsKnowledgeSound
      (relationRound R n deg D i.castSucc) (Simple.inputRelation R deg D)
      (relationRound R n deg D i.succ) (Simple.outputRelation R deg)
      ((Simple.oracleVerifier R deg D oSpec).toVerifier.compatStatement (oStmtLens R n deg D i))
      (fun _ _ => True)
      ‚ü®oStmtLens R n deg D i, Witness.InvLens.trivial‚ü© where
  proj_knowledgeSound := by admit /- proof elided -/

def nil {Œ±} : Vector Œ± 0 := ‚ü®#[], rfl‚ü© 

noncomputable def fixFirstVariablesOfMQP (v : Fin (‚Ñì + 1))
  (H : MvPolynomial (Fin ‚Ñì) L) (challenges : Fin v ‚Üí L) : MvPolynomial (Fin (‚Ñì - v)) L :=
  have h_l_eq : ‚Ñì = (‚Ñì - v) + v := by rw [Nat.add_comm]; exact (Nat.add_sub_of_le v.is_le).symm
  -- Step 1 : Rename L[X Fin ‚Ñì] to L[X (Fin (‚Ñì - v) ‚äï Fin v)]
  let finEquiv := finSumFinEquiv (m := ‚Ñì - v) (n := v).symm
  let H_sum : L[X (Fin (‚Ñì - v) ‚äï Fin v)] :=

Vector.get in Init.Data.Vector.Basic

@[inline, specialize, simp]
def oracleVerifier : OracleVerifier oSpec Statement OStatement Statement OStatement !p[] :=
  OracleVerifier.id

Nat.reduceAdd in Lean.Meta.Tactic.Simp.BuiltinSimprocs.Nat

Sum.isLeft in Init.Data.Sum.Basic

List.leftpad in Init.Data.List.Basic

MvPolynomial.sumToIter in Mathlib.Algebra.MvPolynomial.Equiv

Finset.range in Mathlib.Data.Finset.Range

@[reducible, inline, specialize, simp]
def ChallengeIdx (vPSpec : VectorSpec n) := {i : Fin n // vPSpec.dir i = .V_to_P}

instance {n : ‚Ñï} {Œ± : Fin n ‚Üí Type*} : SliceGE ((i : Fin n) ‚Üí Œ± i) ‚Ñï
    (fun _ start => start ‚â§ n)
    (fun _ start h =>
      (i : Fin (n - start)) ‚Üí Œ± (Fin.cast (Nat.sub_add_cancel h) (i.addNat start)))
    where
  sliceGE := fun v start h => drop start h v

def zero : ChurchNat Œ± := fun _ x => x

right_inv in ToMathlib.Control.Monad.Equiv

def append {Œπ‚ÇÅ : Type u} {T‚ÇÅ : Œπ‚ÇÅ ‚Üí Type v} [‚àÄ i, OracleInterface (T‚ÇÅ i)]
    {Œπ‚ÇÇ : Type u} {T‚ÇÇ : Œπ‚ÇÇ ‚Üí Type v} [‚àÄ i, OracleInterface (T‚ÇÇ i)] : OracleSpec (Œπ‚ÇÅ ‚äï Œπ‚ÇÇ) :=
  [Sum.rec T‚ÇÅ T‚ÇÇ]‚Çí

Fin.castAdd in Init.Data.Fin.Basic

private noncomputable def x_times_oddPart' (f : Polynomial F) : Polynomial F :=
  match f with
  | ‚ü®‚ü®supp, f, pr‚ü©‚ü© => ‚ü®‚ü®erase_even supp, fun n => if Odd n then f n else 0, by admit /- proof elided -/
  ‚ü©‚ü©

Units.val in Mathlib.Algebra.Group.Units.Defs

instance instPow {n : ‚Ñï} : Pow (CNat n) Nat := match n with
  | 0 => by admit /- proof elided -/
  | .succ n => by admit /- proof elided -/

Finsupp.cons in Mathlib.Data.Finsupp.Fin

private def sum_choose_K_i (B : Finset (Fin n ‚Üí F)) (i : Fin n) : ‚Ñö :=
  ‚àë (Œ± : F), choose_2 (K B i Œ±)

LawfulMonad in Init.Control.Lawful.Basic

def subNat [Zero T] [ToNat T] (a : Cayley T) : Nat ‚Üí Cayley T
  | 0        => a
  | .succ k  => pred (subNat a k)

@[simp]
abbrev OracleStatement.AfterLinearCombination : R1CS.MatrixIdx ‚äï R1CS.MatrixIdx ‚äï Fin 1 ‚Üí Type :=
  Sum.elim (EvalClaim R) (OracleStatement.AfterFirstSumcheck R pp)

def relation : Set (M √ó M √ó List (MemoryOp Œπ Œ±)) :=
  { ‚ü®startMem, finalMem, ops‚ü© | processMemoryOps ops startMem = some finalMem }

def commitKState (i : Fin ‚Ñì) (hCR : isCommitmentRound ‚Ñì œë i) :
    (commitOracleVerifier ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      i hCR).KnowledgeStateFunction init impl
      (relIn := foldStepRelOut (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i.succ)
      (extractor := commitRbrExtractor ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) where
  toFun := fun m ‚ü®stmtIn, oStmtIn‚ü© tr witMid =>
    commitKStateProp ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (i := i) (m := m) (stmtIn := stmtIn) (witMid := witMid) (oStmtIn := oStmtIn) (mp:=mp)
  toFun_empty := fun stmtIn witMid => by admit /- proof elided -/

List.Vector in Mathlib.Data.Vector.Defs

Fin.pred in Init.Data.Fin.Basic

noncomputable def embeddingOfùí™IntoùïÉ (H : F[X][Y]) : ùí™ H ‚Üí+* ùïÉ H :=
  Ideal.quotientMap
        (I := Ideal.span {H_tilde' H}) (Ideal.span {H_tilde H})
        bivPolyHom sorry

def Adversary (Œπ : Type) (G : Type) (p : ‚Ñï) (bitLength : ‚Ñï) (Œ± : Type) : Type _ :=
  ReaderT (GroupValTable Œπ G)
    (OracleComp (GroupOpOracle Œπ ++‚Çí GroupExpOracle Œπ p ++‚Çí
      GroupEqOracle Œπ ++‚Çí GroupEncodeOracle Œπ bitLength))
    (List Œπ √ó Œ±)

def D_YZ (Q : F[Z][X][Y]) : ‚Ñï :=
  Option.getD (dflt := 0) <| Finset.max
    (Finset.image
            (
              fun j =>
                Option.getD (
                  Finset.max (
                    Finset.image
                      (fun k => j + (Bivariate.coeff Q j k).natDegree)
                      (Q.coeff j).support
                  )
                ) 0
            )
            Q.support
    )

def inputRelation : Set (((StmtIn R) √ó (‚àÄ i, OStmtIn R deg i)) √ó Unit) :=
  { ‚ü®‚ü®target, oStmt‚ü©, _‚ü© | ‚àë x ‚àà (univ.map D), (oStmt ()).1.eval x = target }

OracleSpec.DecidableEq in VCVio.OracleComp.OracleSpec

Sum.inl in Init.Core

def finBitVecEquiv {n : ‚Ñï} : Fin (2 ^ n) ‚âÉ BitVec n where
  toFun := fun i => BitVec.ofFin i
  invFun := fun u => u.toFin
  left_inv _ := rfl
  right_inv _ := rfl

def verifySmallPrime (n' : Q(‚Ñï)) : MetaM Q(Nat.Prime $n') :=
  match n'.natLit! with
    | 2 => do haveI : $n' =Q 2 := ‚ü®‚ü©; return q(prime_2)
    | 3 => do haveI : $n' =Q 3 := ‚ü®‚ü©; return q(prime_3)
    | 5 => do haveI : $n' =Q 5 := ‚ü®‚ü©; return q(prime_5)
    | 7 => do haveI : $n' =Q 7 := ‚ü®‚ü©; return q(prime_7)
    | 11 => do haveI : $n' =Q 11 := ‚ü®‚ü©; return q(prime_11)
    | 13 => do haveI : $n' =Q 13 := ‚ü®‚ü©; return q(prime_13)
    | 17 => do haveI : $n' =Q 17 := ‚ü®‚ü©; return q(prime_17)
    | 19 => do haveI : $n' =Q 19 := ‚ü®‚ü©; return q(prime_19)
    | 23 => do haveI : $n' =Q 23 := ‚ü®‚ü©; return q(prime_23)
    | 29 => do haveI : $n' =Q 29 := ‚ü®‚ü©; return q(prime_29)
    | 31 => do haveI : $n' =Q 31 := ‚ü®‚ü©; return q(prime_31)
    | 37 => do haveI : $n' =Q 37 := ‚ü®‚ü©; return q(prime_37)
    | 41 => do haveI : $n' =Q 41 := ‚ü®‚ü©; return q(prime_41)
    | 43 => do haveI : $n' =Q 43 := ‚ü®‚ü©; return q(prime_43)
    | 47 => do haveI : $n' =Q 47 := ‚ü®‚ü©; return q(prime_47)
    | _ => failure

Function.Embedding.inl in Mathlib.Logic.Embedding.Basic

IsCyclic.commGroup in Mathlib.GroupTheory.SpecificGroups.Cyclic

def MLE (evals : (œÉ ‚Üí Fin 2) ‚Üí R) : MvPolynomial œÉ R :=
    ‚àë x : œÉ ‚Üí Fin 2, (eqPolynomial (x : œÉ ‚Üí R)) * C (evals x)

protected def cast (T : FullTranscript pSpec‚ÇÅ) :
    FullTranscript pSpec‚ÇÇ :=
  Transcript.cast (k := Fin.last n‚ÇÅ) (l := Fin.last n‚ÇÇ) hn hn hSpec T

def zeta_apply_mobius_apply_eq_id (n : ‚Ñï) (r : Fin n) (l : Fin (r.val + 1)) (v : Vector R (2 ^ n)) :
  monoToLagrange_segment n r l (lagrangeToMono_segment n r l v) = v :=

instance : OracleInterfaces (vPSpec.toProtocolSpec A) where
  oracleInterfaces := fun _ => some OracleInterface.instVector

Array in Init.Prelude

noncomputable def X‚±º (‚Ñì : ‚Ñï) (h_‚Ñì : ‚Ñì ‚â§ r) (j : Fin (2 ^ ‚Ñì)) : L[X] :=
  (Finset.univ : Finset (Fin ‚Ñì)).prod
    (fun i => (normalizedW ùîΩq Œ≤ (Fin.castLE h_‚Ñì i))^(Nat.getBit i j))

class IsSecure
    (relation : Set ((Statement √ó ‚àÄ i, OStatement i) √ó Witness))
    (Œµ_rbr : vPSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0)
    (vectorIOP : VectorIOP Statement OStatement Witness vPSpec A) where

   
  is_complete : vectorIOP.perfectCompleteness (pure ()) ‚ü®isEmptyElim‚ü© relation

   
  is_rbr_knowledge_sound :
    OracleProof.rbrKnowledgeSoundness (pure ()) ‚ü®isEmptyElim‚ü© relation vectorIOP.verifier Œµ_rbr

noncomputable def P
  (Œ¥ : ‚Ñö) (x‚ÇÄ : F)
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  :
  F[Z][X] :=
  let v‚ÇÄ := Classical.choose (solution_gamma_is_linear_in_Z k (Œ¥ := Œ¥) (x‚ÇÄ := x‚ÇÄ) h_gs)
  let v‚ÇÅ := Classical.choose 
    (Classical.choose_spec <| solution_gamma_is_linear_in_Z k (Œ¥ := Œ¥) (x‚ÇÄ := x‚ÇÄ) h_gs)
  (
    (Polynomial.map Polynomial.C v‚ÇÄ) +
    (Polynomial.C Polynomial.X) * (Polynomial.map Polynomial.C v‚ÇÅ)
  )

instance [Zero T] [One T] [ToNat T] : NatPow (Cayley T) where
  pow := powNat

noncomputable def towerRingEquivFromConcrete0 : ConcreteBTField 0 ‚âÉ+* BTField 0 :=

def forwardPermutationOracleImpl {Œ± : Type*} [Permute Œ±] :
    QueryImpl (forwardPermutationOracle Œ±) Id where
  impl | query () q => Permute.permute (Œ± := Œ±) q

def Oracle.containsCache {Œπ : Type} {spec : OracleSpec Œπ}
    (f : spec.FunctionType) (cache : spec.QueryCache) :
    Prop :=
  ‚àÄ i q r, cache i q = some r ‚Üí f i q = r

def CEmbedding : R ‚Ü™ MvPolynomial œÉ R := ‚ü®C, C_injective œÉ R‚ü©

@[app_unexpander Slice.slice]
def sliceUnexpander : Lean.PrettyPrinter.Unexpander
  | `($_ $v $start $stop $_) => `($v‚ü¶$start : $stop‚üß)
  | _ => throw ()

@[reducible]
def messageLength (vPSpec : VectorSpec n) (i : MessageIdx vPSpec) : Nat := vPSpec.length i

noncomputable def polyFold
  [DecidableEq F] (fPoly : Polynomial F)
  (k : ‚Ñï) (hk0 : 0 < k) (hkfin : k < Fintype.card F)
  (r : F) : Polynomial F :=
    let qPoly : Polynomial F := Polynomial.X ^ k
    let hdeg_q_min : qPoly.natDegree > 0 := sorry
    let hdeg_q_max : qPoly.natDegree < Fintype.card F := sorry
  
    let Q : MvPolynomial (Fin 2) F := polyQ fPoly qPoly
    MvPolynomial.eval‚ÇÇHom
      (Polynomial.C : F ‚Üí+* Polynomial F)
      (fun i : Fin 2 => if i = 0 then Polynomial.X else Polynomial.C r) Q

noncomputable def batchVerifier :
  OracleVerifier []‚Çí
    Unit (OracleStatement D x m)
    ((Fin m ‚Üí F) √ó Fri.Spec.Statement F (0 : Fin (k + 1)))
    (OracleStatement D x m)
    (batchSpec F m) where
  verify := fun _ chals => pure ‚ü®chals ‚ü®0, by admit /- proof elided -/
  ‚ü©, Fin.elim0‚ü©
  embed :=
    ‚ü®
      fun i => Sum.inl i,
      by admit /- proof elided -/
    ‚ü©
  hEq := by admit /- proof elided -/

@[inline]
def ofInputOnly
    (stmtProj : OuterStmtIn ‚Üí InnerStmtIn)
    (witProj : OuterStmtIn √ó OuterWitIn ‚Üí InnerWitIn) :
    Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn OuterStmtOut
                OuterWitIn OuterWitOut InnerWitIn OuterWitOut where
  stmt := Statement.Lens.ofInputOnly stmtProj
  wit := Witness.Lens.ofInputOnly witProj

Pow in Init.Prelude

class Serde (Œ± : Type u) (Œ≤ : Type v) extends Serialize Œ± Œ≤, DeserializeOption Œ± Œ≤

def outputRelation (cond : ‚àë i, (s i).1 ‚â§ n) [DecidableEq F] (Œ¥ : ‚Ñù‚â•0) :
    Set
      (
        (Statement F i.succ √ó (‚àÄ j, OracleStatement D x s i.succ j)) √ó
        Witness F s d i.succ.castSucc
      ) := sorry

def divSum? {m : ‚Ñï} (n : Fin m ‚Üí ‚Ñï) (k : ‚Ñï) : Option (Fin m) :=
  find (fun i => k < ‚àë j, n (castLE i.isLt j))

@[reducible, simp] def StmtOut := Query OStatement √ó Response OStatement

Classical.arbitrary in Mathlib.Logic.Nonempty

def powAlgHom :
  MvPolynomial (Fin m) F ‚Üí‚Çê[F] Polynomial F :=
   aeval fun j => Polynomial.X ^ (2 ^ (j : ‚Ñï))

noncomputable def commitOracleReduction (i : Fin ‚Ñì) (hCR : isCommitmentRound ‚Ñì œë i) :
  OracleReduction (oSpec := []‚Çí)
    (StmtIn := Statement (L := L) Context i.succ)
    (OStmtIn := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.castSucc)
    (WitIn := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (StmtOut := Statement (L := L) Context i.succ)
    (OStmtOut := OracleStatement ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (WitOut := Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (pSpec := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) where
  prover := commitOracleProver ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i
  verifier := commitOracleVerifier ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hCR

def finalSumcheckKnowledgeError (m : pSpecFinalSumcheckStep (L := L).ChallengeIdx) :
  ‚Ñù‚â•0 :=
  match m with
  | ‚ü®0, h0‚ü© => nomatch h0

def queryKStateProp {m : Fin (1 + 1)}
  (tr : ProtocolSpec.Transcript m
    (pSpecQuery ùîΩq Œ≤ Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)))
  (stmt : FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì))
  (witMid : Unit)
  (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤ (œë := œë)
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì) j) : Prop :=
if h0 : m.val = 0 then
  
  Binius.BinaryBasefold.finalSumcheckRelOutProp ùîΩq Œ≤ (input:=‚ü®‚ü®stmt, oStmt‚ü©, witMid‚ü©)
else
    let r := stmt.ctx.t_eval_point
    let s := stmt.ctx.original_claim
    let challenges : Fin ‚Ñì ‚Üí L := stmt.challenges
    let tr_so_far := (pSpecQuery ùîΩq Œ≤ Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).take m m.is_le
    let chalIdx : tr_so_far.ChallengeIdx := ‚ü®‚ü®0,
      Nat.lt_of_succ_le (by admit /- proof elided -/
      )‚ü©, by admit /- proof elided -/
      ‚ü©
    let Œ≥_challenges : Fin Œ≥_repetitions ‚Üí sDomain ùîΩq
      Œ≤ h_‚Ñì_add_R_rate ‚ü®0, by admit /- proof elided -/
      ‚ü© := ((ProtocolSpec.Transcript.equivMessagesChallenges (k:=m)
        (pSpec:=pSpecQuery ùîΩq Œ≤ Œ≥_repetitions (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
        tr).2 chalIdx)
    let fold_challenges := stmt.challenges
    
    let proximityTestsCheck : Prop :=
      proximityChecksSpec ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (œë:=œë) Œ≥_repetitions Œ≥_challenges oStmt fold_challenges stmt.final_constant
    proximityTestsCheck

def relation (cs : ConstraintSystem ùì° numWires numGates) (‚Ñì : ‚Ñï) (h‚Ñì : ‚Ñì ‚â§ numWires) :
    (publicInputs : Fin ‚Ñì ‚Üí ùì°) ‚Üí (privateWitness : Fin (numWires - ‚Ñì) ‚Üí ùì°) ‚Üí Prop :=
  fun (x : Fin ‚Ñì ‚Üí ùì°) (œâ : Fin (numWires - ‚Ñì) ‚Üí ùì°) =>
    let combined := Fin.append x œâ ‚àò Fin.cast (by admit /- proof elided -/
    )
    cs.accepts combined

Multiset.map in Mathlib.Data.Multiset.MapFold

def OracleReduction.append (R‚ÇÅ : OracleReduction oSpec Stmt‚ÇÅ OStmt‚ÇÅ Wit‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ Wit‚ÇÇ pSpec‚ÇÅ)
    (R‚ÇÇ : OracleReduction oSpec Stmt‚ÇÇ OStmt‚ÇÇ Wit‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ Wit‚ÇÉ pSpec‚ÇÇ) :
      OracleReduction oSpec Stmt‚ÇÅ OStmt‚ÇÅ Wit‚ÇÅ Stmt‚ÇÉ OStmt‚ÇÉ Wit‚ÇÉ (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ) where
  prover := Prover.append R‚ÇÅ.prover R‚ÇÇ.prover
  verifier := OracleVerifier.append R‚ÇÅ.verifier R‚ÇÇ.verifier

private noncomputable def interpolate : (Œπ ‚Üí F) ‚Üí‚Çó[F] F[X] :=
  Lagrange.interpolate univ domain

AdjoinRoot.powerBasis' in Mathlib.RingTheory.AdjoinRoot

def univPolyHom {F : Type} [CommRing F] [IsDomain F] : F[X] ‚Üí+* RatFunc F :=
  algebraMap (F[X]) (RatFunc F)

def mul (a b : AssocNat) : AssocNat :=
  mulNat a b.toNat

LE in Init.Prelude

def rightpadPowerOfTwo (unit : Œ±) (a : Array Œ±) : Array Œ± :=
  a.rightpad (2 ^ (Nat.clog 2 a.size)) unit

def Cache.cons (n : ‚Ñï) (leaves : List.Vector Œ± (2 ^ (n + 1))) (cache : Cache Œ± n) :
    Cache Œ± (n + 1) :=
  Fin.snoc cache leaves

Fin.castLE in Init.Data.Fin.Basic

def finIdxOfIfTrue [BEq Œ±] [LawfulBEq Œ±] (a : Œ±) (l : List Œ±) (h : a ‚àà l) : Fin l.length :=
  ‚ü®List.idxOf' a l, by admit /- proof elided -/
  ‚ü©

@[reducible, inline, specialize]
def UniPoly (R : Type*) := Array R

instance : DecidableEq BTF‚ÇÉ := (inferInstance : DecidableEq (ConcreteBTField 3))

def srSoundnessGame (P : Prover.StateRestoration.Soundness oSpec StmtIn pSpec) :
    OracleComp (oSpec ++‚Çí (srChallengeOracle StmtIn pSpec))
      (pSpec.FullTranscript √ó StmtIn) := do
  let ‚ü®stmtIn, messages‚ü© ‚Üê P
  let transcript ‚Üê messages.deriveTranscriptSR stmtIn
  return ‚ü®transcript, stmtIn‚ü©

noncomputable def fold_k_core {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F} (f : (indexPowT S œÜ 0) ‚Üí F)
  [‚àÄ i : ‚Ñï, Neg (indexPowT S œÜ i)] : (i : ‚Ñï) ‚Üí (Œ±s : Fin i ‚Üí F) ‚Üí
    indexPowT S œÜ i ‚Üí F
| 0, _ => fun x‚ÇÄ => f x‚ÇÄ
| k+1, Œ±s => fun y =>
    let Œ± := Œ±s 0
    let Œ±s' : Fin k ‚Üí F := fun i => Œ±s (Fin.succ i)
    let fk := fold_k_core f k Œ±s'
    foldf S œÜ y fk Œ±

Vector.map in Init.Data.Vector.Basic

@[reducible]
noncomputable def reductionFold :
  OracleReduction []‚Çí
    (Statement F (0 : Fin (k + 1))) (OracleStatement D x s (0 : Fin (k + 1)))
      (Witness F s d (0 : Fin (k + 2)))
    (FinalStatement F k) (FinalOracleStatement D x s)
      (Witness F s d (Fin.last (k + 1)))
    (pSpecFold D x k s ++‚Çö FinalFoldPhase.pSpec F)
 := OracleReduction.append
      (OracleReduction.seqCompose _ _ (fun (i : Fin (k + 1)) => Witness F s d i.castSucc)
        (FoldPhase.foldOracleReduction D x s d))
      (FinalFoldPhase.finalFoldOracleReduction D x (k := k) s d)

structure KnowledgeStateFunctionOneShot
    (langIn : Set StmtIn) (langOut : Set StmtOut)
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    where
  toFun : (m : Fin (n + 1)) ‚Üí StmtIn ‚Üí Transcript m pSpec ‚Üí Prop
   
  toFun_empty : ‚àÄ stmtIn, ¬¨ toFun 0 stmtIn default
   
  toFun_next : ‚àÄ m, pSpec.dir m = .P_to_V ‚Üí
    ‚àÄ stmt tr msg, ¬¨ toFun m.castSucc stmt tr ‚Üí ¬¨ toFun m.succ stmt (tr.concat msg)
   
  toFun_full : ‚àÄ stmt tr, ¬¨ toFun (.last n) stmt tr ‚Üí
    [(¬∑ ‚àà langOut) | do (simulateQ impl (verifier.run stmt tr)).run' (‚Üê init)] = 0

class SmoothPowerOfTwo (n : ‚Ñï) (G : Type) [Pow G ‚Ñ§] [Monoid G] [inst : IsCyclicWithGen G] where
  smooth : orderOf inst.gen = 2 ^ n

def foldMatrix (i : Fin r) (steps : Fin (‚Ñì + 1)) (h_i_add_steps : i.val + steps < ‚Ñì + ùì°)
    (y : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate)
      ‚ü®‚Üëi + steps, by apply Nat.lt_trans (m := ‚Ñì + ùì°) (h_i_add_steps) h_‚Ñì_add_R_rate‚ü©)
    : Matrix (Fin (2 ^ steps.val)) (Fin (2 ^ steps.val)) L :=

def coreInteractionOracleRbrKnowledgeError (j : (pSpecCoreInteraction ùîΩq Œ≤ (œë := œë)
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).ChallengeIdx) : ‚Ñù‚â•0 :=
    Sum.elim
      (f := fun i => sumcheckFoldKnowledgeError ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)
      (g := fun i => finalSumcheckKnowledgeError (L := L) i)
      (ChallengeIdx.sumEquiv.symm j)

def OracleSpec.proverOracle (StmtIn : Type) {n : ‚Ñï} (pSpec : ProtocolSpec n) :
    OracleSpec pSpec.MessageIdx :=
  fun i => (StmtIn √ó pSpec.Transcript i.val.castSucc, pSpec.Message i)

@[simp]
def finRangeTo {k : ‚Ñï} (i : ‚Ñï) : Finset (Fin k) :=
  (List.take i (List.finRange k)).toFinset

Polynomial.rootMultiplicity in Mathlib.Algebra.Polynomial.Div

def firstOracleWitnessConsistencyProp (t : MultilinearPoly L ‚Ñì)
    (f‚ÇÄ : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate 0 ‚Üí L) : Prop :=
  let P‚ÇÄ: L[X]_(2 ^ ‚Ñì) := polynomialFromNovelCoeffsF‚ÇÇ ùîΩq Œ≤ ‚Ñì (by admit /- proof elided -/
  ) (fun œâ => t.val.eval œâ)
  
  2 * hammingDist (fun x => P‚ÇÄ.val.eval x.val) f‚ÇÄ < BBF_CodeDistance ‚Ñì ùì° ‚ü®0, by admit /- proof elided -/
  ‚ü©

@[inline, specialize]
def neg {R : Type*} [Ring R] [BEq R] (p : QuotientUniPoly R) : QuotientUniPoly R :=
  Quotient.lift neg_descending neg_descends p

@[reducible]
def FinalStatement (F : Type) (k : ‚Ñï) : Type := Fin (k + 1) ‚Üí F

def finSuccEquivNth' (i : Fin n) : Fin n ‚âÉ Option (Fin (n - 1)) :=

def BTField.isScalarTower_succ_right (l r : ‚Ñï) (h_le : l ‚â§ r) :=
  instAlgebraTowerNatBTField.toIsScalarTower (i:=l) (j:=r) (k:=r+1)
  (h1:=by admit /- proof elided -/
  ) (h2:=by admit /- proof elided -/
  )

def hintBytes (state : FSProverState U H R) (hint : ByteArray) :
    Except DomainSeparatorMismatch (FSProverState U H R) :=
  match state.hashState.hint with
  | .ok newHashState =>
    
    
    .ok { rng := state.rng, hashState := newHashState, nargString := state.nargString }
  | .error e => .error e

def multilinearBasis (l r : ‚Ñï) (h_le : l ‚â§ r) :
    letI instAlgebra := ConcreteBTFieldAlgebra (h_le:=h_le)
    Basis (Fin (2 ^ (r - l))) (ConcreteBTField l) (ConcreteBTField r) :=

def outputRelation :
    Set (((StmtOut R) √ó (‚àÄ i, OStmtOut R deg i)) √ó Unit) :=
  { ‚ü®‚ü®‚ü®newTarget, chal‚ü©, oStmt‚ü©, _‚ü© | (oStmt ()).1.eval chal = newTarget }

@[reducible, inline]
instance instPolynomialDegreeLT : OracleInterface (R‚¶É< d‚¶Ñ[X]) where
  Query := R
  Response := R
  answer := fun ‚ü®poly, _‚ü© point => poly.eval point

@[reducible]
def OracleStatement (i : Fin (k + 1)) : Fin (i.val + 1) ‚Üí Type :=
  fun j =>
    evalDomain D x (‚àë j' ‚àà finRangeTo j.1, s j')
      ‚Üí F

instance instDCast‚ÇÅ‚ÇÇ : DCast (Œ≤ a) (Œ≥ a) where
  dcast hb c := dcast‚ÇÇ (Eq.refl a) (by admit /- proof elided -/
  ) c
  dcast_id := by admit /- proof elided -/

def SkeletonLeafIndex.isRoot {s : Skeleton} (idx : SkeletonLeafIndex s) : Bool :=
  match idx with
  | SkeletonLeafIndex.ofLeaf => true
  | SkeletonLeafIndex.ofLeft _ => false
  | SkeletonLeafIndex.ofRight _ => false

def iterated_fold (i : Fin r) (steps : Fin (‚Ñì + 1)) (h_i_add_steps : i.val + steps < ‚Ñì + ùì°)
  (f : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := i) ‚Üí L) (r_challenges : Fin steps ‚Üí L) :
    sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate
      (‚ü®i + steps.val, Nat.lt_trans (m := ‚Ñì + ùì°) (h_i_add_steps) h_‚Ñì_add_R_rate‚ü©) ‚Üí L :=

instance instZero {n : ‚Ñï} : Zero (CNat n) := match n with
  | 0 => by admit /- proof elided -/
  | .succ n => by admit /- proof elided -/

Polynomial.natDegree in Mathlib.Algebra.Polynomial.Degree.Definitions

class GenMutualCorrParams (P : Params Œπ F) (S : ‚àÄ i : Fin (M + 1), Finset (Œπ i)) where

  Œ¥ : Fin (M + 1) ‚Üí ‚Ñù‚â•0
  dist : (i : Fin (M + 1)) ‚Üí Fin ((P.foldingParam i) + 1) ‚Üí ‚Ñù‚â•0


  œÜ : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), (indexPowT (S i) (P.œÜ i) j) ‚Ü™ F

  inst1 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Fintype (indexPowT (S i) (P.œÜ i) j)
  inst2 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    Nonempty (indexPowT (S i) (P.œÜ i) j)
  inst3 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    DecidableEq (indexPowT (S i) (P.œÜ i) j)
  inst4 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Smooth (œÜ i j)

  par‚Ñì_type : ‚àÄ i : Fin (M + 1), ‚àÄ _ : Fin ((P.foldingParam i) + 1), Type
  inst5 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Fintype (par‚Ñì_type i j)

  exp : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), (par‚Ñì_type i j) ‚Ü™ ‚Ñï



  Gen_Œ± : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    ProximityGenerator (indexPowT (S i) (P.œÜ i) j) F :=
      fun i j => RSGenerator.genRSC (par‚Ñì_type i j) (œÜ i j) (P.varCount i - j) (exp i j)

  inst6 : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Fintype (Gen_Œ± i j).par‚Ñì

  BStar : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    (Set ((indexPowT (S i) (P.œÜ i) j) ‚Üí F)) ‚Üí Type ‚Üí ‚Ñù‚â•0
  errStar : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    (Set ((indexPowT (S i) (P.œÜ i) j) ‚Üí F)) ‚Üí Type ‚Üí ‚Ñù ‚Üí ENNReal

  C : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), Set ((indexPowT (S i) (P.œÜ i) j) ‚Üí F)
  hcode : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1), (C i j) = (Gen_Œ± i j).C

  h : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    hasMutualCorrAgreement (Gen_Œ± i j)
      (BStar i j (C i j) (Gen_Œ± i j).par‚Ñì)
      (errStar i j (C i j) (Gen_Œ± i j).par‚Ñì)

  h‚Ñì_bound : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    Fintype.card (Gen_Œ± i j).par‚Ñì = 2
  h‚Ñì_bound' : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    Fintype.card (par‚Ñì_type i j) = 2

  hŒ¥Le : ‚àÄ i : Fin (M + 1),
    (Œ¥ i) ‚â§ 1 - Finset.univ.sup (fun j => BStar i j (C i j) (Gen_Œ± i j).par‚Ñì)

  hlistDecode : ‚àÄ i : Fin (M + 1), ‚àÄ j : Fin ((P.foldingParam i) + 1),
    listDecodable (C i j) (Œ¥ i) (dist i j)

instance : ‚àÄ j, SelectableType ((fullPSpec ùîΩq Œ≤ Œ≥_repetitions (œë:=œë)
  (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).Challenge j) := instSelectableTypeChallengeAppend

@[reducible, simp]
def StateFunction
    (langIn : Set (StmtIn √ó ‚àÄ i, OStmtIn i))
    (langOut : Set (StmtOut √ó ‚àÄ i, OStmtOut i))
    (verifier : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec) :=
  verifier.toVerifier.StateFunction init impl langIn langOut

def finalSumcheckKStateProp {m : Fin (1 + 1)} (tr : Transcript m (pSpecFinalSumcheckStep (L := L)))
    (stmt : Statement (L := L) (SumcheckBaseContext L ‚Ñì) (Fin.last ‚Ñì))
    (witMid : FinalSumcheckWit (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì := ‚Ñì) m)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì) j) : Prop :=
  match m with
  | ‚ü®0, _‚ü© => 
    masterKStateProp ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë)
      (mp := BBF_SumcheckMultiplierParam)
      (stmtIdx := Fin.last ‚Ñì) (oracleIdx := Fin.last ‚Ñì) (h_le := le_refl _)
      (stmt := stmt) (wit := witMid) (oStmt := oStmt) (localChecks := True)
  | ‚ü®1, _‚ü© => 
    let tr_so_far := (pSpecFinalSumcheckStep (L := L)).take 1 (by admit /- proof elided -/
    )
    let i_msg0 : tr_so_far.MessageIdx := ‚ü®‚ü®0, by admit /- proof elided -/
    ‚ü©, rfl‚ü©
    let c : L := (ProtocolSpec.Transcript.equivMessagesChallenges (k := 1)
      (pSpec := pSpecFinalSumcheckStep (L := L)) tr).1 i_msg0

    let stmtOut : FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì) := {
      ctx := stmt.ctx,
      sumcheck_target := stmt.sumcheck_target,
      challenges := stmt.challenges,
      final_constant := c
    }

    let sumcheckFinalCheck : Prop := stmt.sumcheck_target = eqTilde r stmt.challenges * c
    let finalFoldingProp := finalNonDoomedFoldingProp ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (h_le := by admit /- proof elided -/
        ) (input := ‚ü®stmtOut, oStmt‚ü©)

    sumcheckFinalCheck ‚àß finalFoldingProp 

def fconcat {A : Sort u} {F : A ‚Üí Sort v} {n : ‚Ñï} {Œ± : Fin n ‚Üí A} {Œ≤ : A}
    (u : (i : Fin n) ‚Üí F (Œ± i)) (a : F Œ≤) : (i : Fin (n + 1)) ‚Üí F (Fin.vconcat Œ± Œ≤ i) :=
  match n with
  | 0 => fun i => match i with | 0 => a
  | _ + 1 => fcons (u 0) (fconcat (fun i => u (Fin.succ i)) a)

@[inline, reducible]
protected def id :
    Context.Lens OuterStmtIn OuterStmtOut OuterStmtIn OuterStmtOut
                OuterWitIn OuterWitOut OuterWitIn OuterWitOut where
  stmt := Statement.Lens.id
  wit := Witness.Lens.id

alias trivial := Context.Lens.id

instance ConcreteBTField.instDCast_local : DCast ‚Ñï ConcreteBTField where
  dcast h_k_eq term_k1 := BitVec.cast (congrArg (fun n => 2 ^ n) h_k_eq) term_k1
  dcast_id := by admit /- proof elided -/

List.ofFn in Init.Data.List.OfFn

def lagrangeToMonoSpec (p : MlPolyEval R n) : MlPolyEval R n :=
  
  Vector.ofFn (fun i =>
    
    Finset.sum Finset.univ (fun j =>
      
      if (i.val &&& j.val = j.val) then
        
        
        if (i.val.popCount - j.val.popCount) % 2 = 0 then
          p.get j 
        else
          -p.get j 
      else
        0 
    )
  )

@[inline, specialize]
def prover : Prover oSpec Statement Witness (Statement √ó Witness) Unit (pSpec Witness) where
  PrvState
  | 0 => Statement √ó Witness
  | 1 => Statement √ó Witness
  input := id
  sendMessage | ‚ü®0, _‚ü© => fun ‚ü®stmt, wit‚ü© => pure (wit, ‚ü®stmt, wit‚ü©)
  receiveChallenge | ‚ü®0, h‚ü© => nomatch h
  output := fun ‚ü®stmt, wit‚ü© => pure (‚ü®stmt, wit‚ü©, ())

def widthDiv4 : Nat := params.width / 4

Units.mk0 in Mathlib.Algebra.GroupWithZero.Units.Basic

def distFromCode' (C : Set (n ‚Üí R)) [Fintype C] (u : n ‚Üí R) : ‚Ñï‚àû :=
  Finset.min <| (@Finset.univ C _).image (fun v => hammingDist u v.1)

Function.comp in Init.Prelude

instance {k : Fin (n + 1)} : Fintype (pSpec.MessageIdxUpTo k) :=
  inferInstanceAs (Fintype <| MessageIdx (pSpec.take k k.is_le))

def getConst (k : ‚Ñï) (s : Fin (k + 1) ‚Üí ‚Ñï+) : OracleComp [FinalOracleStatement D x s]‚Çí F[X] :=
  OracleComp.lift
    (by admit /- proof elided -/
    )

Finset.filterMap in Mathlib.Data.Finset.Image

def Prover.addSalt (P : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec)
    (saltComp : (i : pSpec.MessageIdx) ‚Üí P.PrvState i.1.castSucc ‚Üí OracleComp oSpec (Salt i)) :
  Prover oSpec StmtIn WitIn StmtOut WitOut (pSpec.addSalt Salt) where
  PrvState := P.PrvState
  input := P.input
  sendMessage := fun i st => by admit /- proof elided -/

OrderDual in Mathlib.Order.Basic

def possibleDists (C : Set (Œπ ‚Üí F)) (Œ¥f : (Œπ ‚Üí F) ‚Üí (Œπ ‚Üí F) ‚Üí Œ±) : Set Œ± :=
  {d : Œ± | ‚àÉ p ‚àà Set.offDiag C, Œ¥f p.1 p.2 = d}

def RAW_CONSTANTS_24 : Vector KoalaBear.Field 215 := #v[
    487143900,
    1829048205,
    1652578477,
    646002781,
    1044144830,
    53279448,
    1519499836,
    22697702,
    1768655004,
    230479744,
    1484895689,
    705130286,
    1429811285,
    1695785093,
    1417332623,
    1115801016,
    1048199020,
    878062617,
    738518649,
    249004596,
    1601837737,
    24601614,
    245692625,
    364803730,
    1857019234,
    1906668230,
    1916890890,
    835590867,
    557228239,
    352829675,
    515301498,
    973918075,
    954515249,
    1142063750,
    1795549558,
    608869266,
    1850421928,
    2028872854,
    1197543771,
    1027240055,
    1976813168,
    963257461,
    652017844,
    2113212249,
    213459679,
    90747280,
    1540619478,
    324138382,
    1377377119,
    294744504,
    512472871,
    668081958,
    907306515,
    518526882,
    1907091534,
    1152942192,
    1572881424,
    720020214,
    729527057,
    1762035789,
    86171731,
    205890068,
    453077400,
    1201344594,
    986483134,
    125174298,
    2050269685,
    1895332113,
    749706654,
    40566555,
    742540942,
    1735551813,
    162985276,
    1943496073,
    1469312688,
    703013107,
    1979485151,
    1278193166,
    548674995,
    2118718736,
    749596440,
    1476142294,
    1293606474,
    918523452,
    890353212,
    1691895663,
    1932240646,
    1180911992,
    86098300,
    1592168978,
    895077289,
    724819849,
    1697986774,
    1608418116,
    1083269213,
    691256798,
    328586442,
    1572520009,
    1375479591,
    322991001,
    967600467,
    1172861548,
    1973891356,
    1503625929,
    1881993531,
    40601941,
    1155570620,
    571547775,
    1361622243,
    1495024047,
    1733254248,
    964808915,
    763558040,
    1887228519,
    994888261,
    718330940,
    213359415,
    603124968,
    1038411577,
    2099454809,
    949846777,
    630926956,
    1168723439,
    222917504,
    1527025973,
    1009157017,
    2029957881,
    805977836,
    1347511739,
    540019059,
    589807745,
    440771316,
    1530063406,
    761076336,
    87974206,
    1412686751,
    1230318064,
    514464425,
    1469011754,
    1770970737,
    1510972858,
    965357206,
    209398053,
    778802532,
    40567006,
    1984217577,
    1545851069,
    879801839,
    1611910970,
    1215591048,
    330802499,
    1051639108,
    321036,
    511927202,
    591603098,
    1775897642,
    115598532,
    278200718,
    233743176,
    525096211,
    1335507608,
    830017835,
    1380629279,
    560028578,
    598425701,
    302162385,
    567434115,
    1859222575,
    958294793,
    1582225556,
    1781487858,
    1570246000,
    1067748446,
    526608119,
    1666453343,
    1786918381,
    348203640,
    1860035017,
    1489902626,
    1904576699,
    860033965,
    1954077639,
    1685771567,
    971513929,
    1877873770,
    137113380,
    520695829,
    806829080,
    1408699405,
    1613277964,
    793223662,
    648443918,
    893435011,
    403879071,
    1363789863,
    1662900517,
    2043370,
    2109755796,
    931751726,
    2091644718,
    606977583,
    185050397,
    946157136,
    1350065230,
    1625860064,
    122045240,
    880989921,
    145137438,
    1059782436,
    1477755661,
    335465138,
    1640704282,
    1757946479,
    1551204074,
    681266718,
]

Finset.sum in Mathlib.Algebra.BigOperators.Group.Finset.Defs

@[inline, specialize]
def add {R : Type*} [Ring R] [BEq R] [LawfulBEq R] (p q : QuotientUniPoly R) : QuotientUniPoly R :=
  Quotient.lift‚ÇÇ add_descending add_descends p q

ENat in Mathlib.Data.ENat.Defs

instance : ‚àÄ i, VCVCompatible ((pSpec Witness).Challenge i) | ‚ü®0, h‚ü© => nomatch h

instance : SliceLT (ProtocolSpec n) ‚Ñï
    (fun _ stop => stop ‚â§ n)
    (fun _ stop _ => ProtocolSpec stop)
    where
  sliceLT := fun v stop h => take stop h v

noncomputable def towerRingHomForwardMap (k : ‚Ñï) : ConcreteBTField k ‚Üí BTField k :=

List.dropLast in Init.Data.List.Basic

Vector.head in Init.Data.Vector.Basic

@[reducible, simp] def WitOut := Unit

Membership in Init.Prelude

def powNat [Zero T] [One T] [ToNat T] (a : Cayley T) : Nat ‚Üí Cayley T
  | 0        => one  
  | .succ k  => mul a (powNat a k)  

AlternativeMonad in Batteries.Control.AlternativeMonad

Nat.clog in Mathlib.Data.Nat.Log

def distCodewords [DecidableEq F] (U V : Matrix Œ∫ Œπ F) : ‚Ñï :=
  (Matrix.neqCols U V).card

def extractNextSuffixFromChallenge (v : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®0, by omega‚ü©)
    (i : ‚Ñï) (h_i_add_œë_le_‚Ñì : i + œë ‚â§ ‚Ñì) :
    (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®i + œë, by omega‚ü© :=

instance {k : Fin 1} : Unique (MessagesUpTo k !p[]) where
  default := fun ‚ü®‚ü®i, h‚ü©, _‚ü© => by admit /- proof elided -/

inductive MemoryOp (Œπ : Type u) (Œ± : Œπ ‚Üí Type v) where
  | read (op : MemoryRead Œπ Œ±)
  | write (op : MemoryWrite Œπ Œ±)

commit in VCVio.CryptoFoundations.SigmaAlg

def proximityMeasure (u v : n ‚Üí F) (d : ‚Ñï) : ‚Ñï :=
  Fintype.card {r : F | Œî‚ÇÄ'(r ‚Ä¢ u + (1 - r) ‚Ä¢ v, C) ‚â§ d}

@[reducible]
def baseFieldSize : Nat :=
  21888242871839275222246405745257275088696311157297823662689037894645226208583

instance : ‚àÄ j, OracleInterface ((pSpecNonLastBlocks ùîΩq Œ≤ (œë:=œë)
  (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).Message j) := instOracleInterfaceMessageSeqCompose

instFintypeProd in Mathlib.Data.Fintype.Prod

@[simp]
def Z (k : ‚Ñï) : BTField k := (BinaryTowerAux k).snd.specialElement 

def finalNonDoomedFoldingProp {h_le : œë ‚â§ ‚Ñì}
    (input : (FinalSumcheckStatementOut (L := L) (‚Ñì := ‚Ñì) √ó
      (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë (Fin.last ‚Ñì) j))) :
    Prop :=
  let stmt := input.1
  let oStmt := input.2
  let f_‚Ñì: (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®‚Ñì, by admit /- proof elided -/
  ‚ü© ‚Üí L := fun x => stmt.final_constant
  let j := mkLastOracleIndex ‚Ñì œë (Fin.last ‚Ñì) 
  let k := j.val * œë
  have h_k: k = ‚Ñì - œë := by admit /- proof elided -/

@[simp]
abbrev Witness.AfterLinearCombination : Type := Unit

class PrimeOrder (G : Type*) [Group G] where
  p : ‚Ñï
  [hPrime : Fact (Nat.Prime p)]
  hCard : Nat.card G = p

@[reducible, simp]
def toRelOut : Set ((Statement √ó Witness) √ó Unit) :=
  Prod.fst ‚Åª¬π' relIn

@[inline, reducible]
def toContext :
    Context.Lens (OuterStmtIn √ó (‚àÄ i, OuterOStmtIn i)) (OuterStmtOut √ó (‚àÄ i, OuterOStmtOut i))
                (InnerStmtIn √ó (‚àÄ i, InnerOStmtIn i)) (InnerStmtOut √ó (‚àÄ i, InnerOStmtOut i))
                OuterWitIn OuterWitOut InnerWitIn InnerWitOut :=
  ‚ü®lens.stmt, lens.wit‚ü©

def FullData.getRootValue {s} {Œ± : Type} (tree : FullData Œ± s) :=
  tree.get (getRootIndex s)

def mul (m n : ChurchNat Œ±) : ChurchNat Œ± := fun f => n (m f)

def Transcript.removeSalt {k : Fin (n + 1)} (transcript : (pSpec.addSalt Salt).Transcript k) :
    pSpec.Transcript k :=

  fun i => by admit /- proof elided -/

instance instToNat {n : ‚Ñï} : ToNat (CNat n) := match n with
  | 0 => by admit /- proof elided -/
  | .succ n => @Cayley.instToNatOfZero (CNat n) instHasSucc instZero instToNat

def relayKnowledgeStateFunction (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
    (relayOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        i hNCR).KnowledgeStateFunction init impl
      (relIn := foldStepRelOut (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i.succ)
      (extractor := relayRbrExtractor ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i) where
  toFun := fun m ‚ü®stmtIn, oStmtIn‚ü© tr witMid =>
    relayKStateProp (mp:=mp) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (ùìë := ùìë) i hNCR stmtIn witMid oStmtIn
  toFun_empty := fun ‚ü®stmtIn, oStmtIn‚ü© witIn => by admit /- proof elided -/

@[inline]
abbrev concat {m : Fin n} (msg : pSpec.¬´Type¬ª m) (T : Transcript m.castSucc pSpec) :
    Transcript m.succ pSpec :=
  Fin.snoc T msg

noncomputable def foldNth (n : ‚Ñï) (f : ùîΩ[X]) (Œ± : ùîΩ) [inst : NeZero n] : ùîΩ[X] :=
  ‚àë i : Fin n, Polynomial.C Œ± ^ i.1 * splitNth f n i

instance [inst : OracleInterface Msg] : ‚àÄ i, OracleInterface (Message ‚ü®!v[.P_to_V], !v[Msg]‚ü© i)
  | ‚ü®0, _‚ü© => inst

Set.offDiag in Mathlib.Data.Set.Operations

structure DomainSeparatorMismatch where
  message : String
deriving Inhabited, DecidableEq, Repr

def divide_by_2 (s : Finset ‚Ñï) : Finset ‚Ñï :=
  (erase_odd s).image (fun n => n / 2)

@[reducible, simp]
def StmtIn := R

instance : HasSucc (Cayley T) where
  succ' := succ

instance instSelectableTypeChallengePSpec [SelectableType R] :
    ‚àÄ i, SelectableType ((pSpec R deg).Challenge i) :=
  instSelectableTypeChallengeAppend

def collisionBwdFwd : Prop :=
  let ‚ü®baseTrace, _‚ü© := removeRedundantEntryDS trace
  ‚àÉ stateIn stateOut stateOut',
    (stateIn, stateOut) ‚àà baseTrace.getQ (.inr .Bwd) ‚àß
    (stateOut', stateIn) ‚àà baseTrace.getQ (.inr .Fwd) ‚àß
    stateOut ‚â† stateOut'

alias E_col_pinv_p := collisionBwdFwd

@[reducible]
def index (op : MemoryWrite Œπ Œ±) := op.1

instance {n : ‚Ñï} : ToString (UnverifiedPrattCertificate n) where
  toString := fun c => s!"{repr c}"

PowerSeries.mk in Mathlib.RingTheory.PowerSeries.Basic

instance : Sub AssocNat where
  sub := sub

def neg_descending (p : UniPoly R) : QuotientUniPoly R :=
  Quotient.mk _ (neg p)

def prover (i : Fin n) : OracleProver oSpec
    (StatementRound R n i.castSucc) (OracleStatement R n deg) Unit
    (StatementRound R n i.succ) (OracleStatement R n deg) Unit (pSpec R deg) where
  toProverState := proverState R n deg i
  toProverInput := proverInput R n deg i
  sendMessage := (proverRound R n deg D oSpec i).sendMessage
  receiveChallenge := (proverRound R n deg D oSpec i).receiveChallenge
  toProverOutput := proverOutput R n deg oSpec i

abbrev ScalarField := ZMod SCALAR_FIELD_CARD

Finset.Icc in Mathlib.Order.Interval.Finset.Defs

def oracleVerifier (i : Fin n) : OracleVerifier oSpec
    (StatementRound R n i.castSucc) (OracleStatement R n deg)
    (StatementRound R n i.succ) (OracleStatement R n deg) (pSpec R deg) where
  
  
  
  
  verify := fun ‚ü®target, challenges‚ü© chal => do
    let evals : List R ‚Üê (List.finRange m).mapM
      (fun i => do
        return ‚Üê query
          (spec := (oSpec ++‚Çí ([OracleStatement R n deg]‚Çí ++‚Çí [(pSpec R deg).Message]‚Çí)))
            (Sum.inr <| Sum.inr default) (D i))
    guard (evals.sum = target)
    let newTarget ‚Üê query
      (spec := (oSpec ++‚Çí ([OracleStatement R n deg]‚Çí ++‚Çí [(pSpec R deg).Message]‚Çí)))
        (Sum.inr <| Sum.inr default) (by admit /- proof elided -/
        )
    letI newTarget : R := by admit /- proof elided -/

noncomputable instance : Algebra K (Left ‚äó[K] Right) := Algebra.TensorProduct.instAlgebra

instance (k : ‚Ñï) : Preorder (ConcreteBTField k) where
  le_refl := fun x => BitVec.le_refl x
  le_trans := fun x y z hxy hyz => BitVec.le_trans hxy hyz
  lt := fun x y => x < y
  lt_iff_le_not_ge := fun x y => by admit /- proof elided -/
| intro h_le_xy h_not_le_yx =>
      have x_lt_y:= mt bitvec_statement.mp h_not_le_yx
      push_neg at x_lt_y
      exact x_lt_y

def dummyLastWitness :
    Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (Fin.last ‚Ñì) := {
  t := ‚ü®0, by admit /- proof elided -/
  ‚ü©,
  H := ‚ü®0, by admit /- proof elided -/
  ‚ü©,
  f := fun _ => 0
}

Nat.pred in Init.Prelude

def pSpecFinalSumcheckStep : ProtocolSpec 1 := ‚ü®![Direction.P_to_V], ![L]‚ü©

Char in Init.Prelude

def ofFinMatrix {m n : ‚Ñï} (matrix : _root_.Matrix (Fin m) (Fin n) Œ±) : Matrix Œ± m n :=
  Vector.ofFn (fun i => Vector.ofFn (fun j => matrix i j))

def isRead : MemoryOp Œπ Œ± ‚Üí Prop
  | read _ => True
  | _ => False

def toChallengesUpTo (transcript : Transcript k pSpec) : ChallengesUpTo k pSpec :=
  fun ‚ü®i, _‚ü© => transcript i

def dfoldrM' {m : Type u ‚Üí Type v} [Monad m]
    (n : ‚Ñï) (Œ± : Fin (n + 1) ‚Üí Type u)
    (f : (i : Fin n) ‚Üí Œ± i.succ ‚Üí m (Œ± i.castSucc)) (init : Œ± (last n)) : m (Œ± 0) :=
  match n with
  | 0 => pure init
  | n + 1 => do
    let x ‚Üê dfoldrM' n (Œ± ‚àò succ) (fun i => f i.succ) init
    f 0 x

GroupWithZero in Mathlib.Algebra.GroupWithZero.Defs

@[reducible]
def GroupEqOracle : OracleSpec Unit := fun _ => (Œπ √ó Œπ, Bool)

abbrev rtake (m : ‚Ñï) (h : m ‚â§ n)
    (transcript : FullTranscript pSpec) : FullTranscript (pSpec.rtake m h) :=
  Fin.rtake m h transcript

@[reducible]
def batchSpec (F : Type) (m : ‚Ñï) : ProtocolSpec 1 := ‚ü®!v[.V_to_P], !v[Fin m ‚Üí F]‚ü©

Equiv.sumComm in Mathlib.Logic.Equiv.Sum

instance [IsSingleRound pSpec] [h : OracleInterface (pSpec.Message default)] :
    (i : pSpec.MessageIdx) ‚Üí OracleInterface (pSpec.Message i) := fun i => by admit /- proof elided -/

instance : HListRepr (HList []) where
  repr := fun _ => ""

Submodule.map in Mathlib.Algebra.Module.Submodule.Map

noncomputable def proximity_gap_degree_bound (k m : ‚Ñï) : ‚Ñï :=
  let rho := (k + 1 : ‚Ñö) / n
  Nat.floor ((((m : ‚Ñö) + (1 : ‚Ñö)/2)*(Real.sqrt rho))*n)

structure FSVerifierState (U : Type) [SpongeUnit U] (H : Type*) [DuplexSpongeInterface U H] where
   
  hashState : HashStateWithInstructions U H
   
  nargString : ByteArray
deriving Repr

instance : Coe (‚àÄ a : Œ±, Œ≤ a) F where
  coe := DFunEquiv.equiv.invFun

Monoid.toMulAction in Mathlib.Algebra.Group.Action.Defs

@[inline]
def ofInputOnly (projStmt : OuterStmtIn ‚Üí InnerStmtIn) :
    Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn OuterStmtOut :=
  ‚ü®projStmt, fun _ => id‚ü©

def concat {k : Fin n} (challenges : ChallengesUpTo k.castSucc pSpec)
    (h : pSpec.dir k = .V_to_P) (chal : pSpec.Challenge ‚ü®k, h‚ü©) : ChallengesUpTo k.succ pSpec :=
  fun ‚ü®i, h‚ü© => (concat' (pSpec := pSpec) (fun i hi => challenges ‚ü®i, hi‚ü©) (fun _ => chal)) i h

def lagrangeBasis (w : Vector R n) : Vector R (2 ^ n) :=
  Vector.ofFn (fun i => ‚àè j : Fin n, if (BitVec.ofFin i).getLsb j then w[j] else 1 - w[j])

RingHom in Mathlib.Algebra.Ring.Hom.Defs

def getPutativeRoot {s} (idx : BinaryTree.SkeletonLeafIndex s) (leafValue : Œ±)
    (proof : List Œ±) : OracleComp (spec Œ±) Œ± :=
  match proof with
  | [] => return leafValue 
  | siblingBelowRootHash :: restProof => do
    match idx with
    | BinaryTree.SkeletonLeafIndex.ofLeaf =>
      
      
      
      return leafValue
    | BinaryTree.SkeletonLeafIndex.ofLeft idxLeft =>
      
      let ancestorBelowRootHash ‚Üê getPutativeRoot idxLeft leafValue restProof
      singleHash ancestorBelowRootHash siblingBelowRootHash
    | BinaryTree.SkeletonLeafIndex.ofRight idxRight =>
      
      let ancestorBelowRootHash ‚Üê getPutativeRoot idxRight leafValue restProof
      singleHash siblingBelowRootHash ancestorBelowRootHash

Lean.Name in Init.Prelude

structure KnowledgeStateFunction
    (relIn : Set (StmtIn √ó WitIn)) (relOut : Set (StmtOut √ó WitOut))
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    {WitMid : Fin (n + 1) ‚Üí Type}
    (extractor : Extractor.RoundByRound oSpec StmtIn WitIn WitOut pSpec WitMid)
    where
   
  toFun : (m : Fin (n + 1)) ‚Üí StmtIn ‚Üí Transcript m pSpec ‚Üí WitMid m ‚Üí Prop
   
  toFun_empty : ‚àÄ stmtIn witMid,
    ‚ü®stmtIn, cast extractor.eqIn witMid‚ü© ‚àà relIn ‚Üî toFun 0 stmtIn default witMid
   
  toFun_next : ‚àÄ m, pSpec.dir m = .P_to_V ‚Üí
    ‚àÄ stmtIn tr msg witMid, toFun m.succ stmtIn (tr.concat msg) witMid ‚Üí
      toFun m.castSucc stmtIn tr (extractor.extractMid m stmtIn (tr.concat msg) witMid)
   
  toFun_full : ‚àÄ stmtIn tr witOut,
    [fun stmtOut => (stmtOut, witOut) ‚àà relOut
    | do (simulateQ impl (verifier.run stmtIn tr)).run' (‚Üê init)] > 0 ‚Üí
    toFun (.last n) stmtIn tr (extractor.extractOut stmtIn tr witOut)

@[app_unexpander Fin.dempty]
def demptyUnexpander : Lean.PrettyPrinter.Unexpander
  | `($_:ident) => `(!h[])
  | _ => throw ()

inductive Data (Œ± : Type) :
    {n : ‚Ñï} ‚Üí {ar : Fin n ‚Üí ‚Ñï} ‚Üí Skeleton n ar ‚Üí Type where
  | leaf {ar0 : Fin 0 ‚Üí ‚Ñï} (value : Œ±) :
      Data Œ± (Skeleton.leaf (ar0 := ar0))
  | node {n : ‚Ñï} {ar : Fin (n+1) ‚Üí ‚Ñï}
      {children : Fin (ar 0) ‚Üí
        Skeleton n (fun i => ar i.succ)}
      (value : Œ±)
      (childrenData : (i : Fin (ar 0)) ‚Üí
        Data Œ± (children i)) :
      Data Œ± (Skeleton.node children)

noncomputable def additiveNTT (a : Fin (2 ^ ‚Ñì) ‚Üí L) : Fin (2^(‚Ñì + R_rate)) ‚Üí L :=
  let b: Fin (2^(‚Ñì + R_rate)) ‚Üí L := tileCoeffs a 
  Fin.foldl (n:=‚Ñì) (f:= fun current_b i  =>
    NTTStage ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®‚Ñì - 1 - i, by admit /- proof elided -/
    ‚ü©) current_b
  ) (init:=b)

def modify (state : C) (f : Vector U SpongeSize.N ‚Üí Vector U SpongeSize.N) : C :=
  SpongeState.update state (f (SpongeState.get state))

Tactic.ReduceModChar.normIntNumeral in Mathlib.Tactic.ReduceModChar

def foldStepRelOutProp (i : Fin ‚Ñì)
    (input : (Statement (L := L) Context i.succ √ó
      (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j)) √ó
      Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ) : Prop :=
  let stmt := input.1.1
  let oStmt := input.1.2
  let wit := input.2
  masterKStateProp (mp := mp) (ùìë := ùìë) ùîΩq Œ≤
    (stmtIdx := i.succ) (oracleIdx := i.castSucc)
    (h_le := Nat.le_of_lt (Fin.castSucc_lt_succ i)) stmt wit oStmt (localChecks := True)

def findSum (l : List Œ±) (j : Œ±) : Option Œ± := l.partialSum.find? (j < ¬∑)

def hli_level_diff_0 (l : ‚Ñï) :
  letI instAlgebra:= binaryAlgebraTower (l:=l) (r:=l) (h_le:=by omega)
  @Basis (Fin 1) (BTField l) (BTField l) _ _ instAlgebra.toModule :=

def duplexSpongeToBasicFSQueryImpl :
    QueryImpl (duplexSpongeChallengeOracle StmtIn U)
      (OracleComp (fsChallengeOracle StmtIn pSpec)) :=
  sorry

alias d2SQueryImpl := duplexSpongeToBasicFSQueryImpl

ByteArray in Init.Prelude

class VerifierFirst (pSpec : ProtocolSpec n) [NeZero n] where
  verifier_first' : pSpec.dir 0 = .V_to_P

Quotient.lift‚ÇÇ in Init.Core

def splitPointIntoCoeffs (i : Fin r) (h_i : i < ‚Ñì + R_rate)
  (x : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i) :
  Fin (‚Ñì + R_rate - i.val) ‚Üí ‚Ñï := fun j =>
    if ((sDomain_basis ùîΩq Œ≤
    h_‚Ñì_add_R_rate i h_i).repr x j = 0) then
      0 else 1

Infinite in Mathlib.Data.Finite.Defs

Array.map in Init.Data.Array.Basic

def one : ChurchNat Œ± := succ zero

instance [h : ProverFirst pSpec] : IsEmpty (pSpec.ChallengeIdx) where
  false | ‚ü®0, h'‚ü© => by admit /- proof elided -/

instance [ToString Œ±] (Œ±s : List Type) [HListString (HList Œ±s)] :
    HListString (HList (Œ± :: Œ±s)) where
  toString
  | HList.cons x xs =>
    match xs with
    | HList.nil => toString x
    | HList.cons _ _ => toString x ++ ", " ++ HListString.toString xs

def fcons {A : Sort u} {F : A ‚Üí Sort v} {n : ‚Ñï} {Œ± : A} {Œ≤ : Fin n ‚Üí A}
    (a : F Œ±) (b : (i : Fin n) ‚Üí F (Œ≤ i)) : (i : Fin (n + 1)) ‚Üí F (Fin.vcons Œ± Œ≤ i) :=
  match n with
  | 0 => fun i => match i with | 0 => a
  | _ + 1 => fun i => match i with
    | 0 => a
    | ‚ü®k + 1, hk‚ü© => b ‚ü®k, Nat.succ_lt_succ_iff.mp hk‚ü©

BitVec in Init.Prelude

def leftpad {m : ‚Ñï} {Œ± : Sort*} (n : ‚Ñï) (a : Œ±) (v : Fin m ‚Üí Œ±) : Fin n ‚Üí Œ± :=
  fun i => if h : n - m ‚â§ i then v ‚ü®i - (n - m), by admit /- proof elided -/
  ‚ü© else a

instance {Œ± : Type} [Sampleable Œ±] : DecidableEq Œ± := inferInstance

@[inline, specialize]
def Prover.processRoundFS [‚àÄ i, VCVCompatible (pSpec.Challenge i)] (j : Fin n)
    (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec)
    (currentResult : OracleComp (oSpec ++‚Çí fsChallengeOracle StmtIn pSpec)
      (pSpec.MessagesUpTo j.castSucc √ó StmtIn √ó prover.PrvState j.castSucc)) :
      OracleComp (oSpec ++‚Çí fsChallengeOracle StmtIn pSpec)
        (pSpec.MessagesUpTo j.succ √ó StmtIn √ó prover.PrvState j.succ) := do
  let ‚ü®messages, stmtIn, state‚ü© ‚Üê currentResult
  match hDir : pSpec.dir j with
  | .V_to_P => do
    let f ‚Üê prover.receiveChallenge ‚ü®j, hDir‚ü© state
    let challenge ‚Üê query (spec := fsChallengeOracle StmtIn pSpec) ‚ü®j, hDir‚ü© ‚ü®stmtIn, messages‚ü©
    return ‚ü®messages.extend hDir, stmtIn, f challenge‚ü©
  | .P_to_V => do
    let ‚ü®msg, newState‚ü© ‚Üê prover.sendMessage ‚ü®j, hDir‚ü© state
    return ‚ü®messages.concat hDir msg, stmtIn, newState‚ü©

def SkeletonLeafIndex.depth {s : Skeleton} : SkeletonLeafIndex s ‚Üí Nat
  | SkeletonLeafIndex.ofLeaf => 0
  | SkeletonLeafIndex.ofLeft idxLeft => idxLeft.depth + 1
  | SkeletonLeafIndex.ofRight idxRight => idxRight.depth + 1

class Permute (Œ± : Type*) where
  permute : Œ± ‚Üí Œ±

def SkeletonNodeIndex.path {s : Skeleton} (idx : SkeletonNodeIndex s) :
    List (SkeletonNodeIndex s) := sorry

evalDist in VCVio.EvalDist.Basic

Fin.castSuccEmb in Mathlib.Data.Fin.Embedding

noncomputable def minDist (C : Set (n ‚Üí R)) : ‚Ñï :=
  sInf {d | ‚àÉ u ‚àà C, ‚àÉ v ‚àà C, u ‚â† v ‚àß hammingDist u v = d}

def foldKnowledgeError (i : Fin ‚Ñì) (_ : (pSpecFold (L := L)).ChallengeIdx) : ‚Ñù‚â•0 :=
  let err_SC := (1 : ‚Ñù‚â•0) / (Fintype.card L)
  
  let err_BE := if hi : œë ‚à£ (i.val + 1) then
    
    œë * (Fintype.card ((sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate)
      ‚ü®i.val + 1, by admit /- proof elided -/
        ‚ü©) : ‚Ñù‚â•0) / (Fintype.card L)
  else 0
  err_SC + err_BE

def sumcheckFoldKnowledgeError := fun j : (pSpecSumcheckFold ùîΩq Œ≤ (œë:=œë)
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).ChallengeIdx =>
    if hj: (j.val % NBlockMessages (œë:=œë)) % 2 = 1 then
      foldKnowledgeError ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        ‚ü®j / NBlockMessages (œë:=œë) * œë + ((j % NBlockMessages (œë:=œë)) / 2 + 1), by admit /- proof elided -/
        ‚ü© ‚ü®1, rfl‚ü©
    else 0 

@[simps!]
def equivMessagesChallenges : FullTranscript pSpec ‚âÉ (Messages pSpec √ó Challenges pSpec) :=

@[reducible]
def scalarFieldSize : Nat :=
  8444461749428370424248824938781546531375899335154063827935233455917409239041

@[reducible, inline, specialize]
def ChallengeUpTo (k : Fin (n + 1)) (pSpec : ProtocolSpec n) (i : pSpec.ChallengeIdxUpTo k) :=
  (pSpec‚ü¶:k.val‚üß).Challenge i

def getFirstOracle {i : Fin (‚Ñì + 1)}
    (oStmt : (‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i j)) :
    sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate 0 ‚Üí L :=

def whirRelation
    {F : Type} [Field F] [Fintype F] [DecidableEq F]
    {Œπ : Type} [Fintype Œπ] [Nonempty Œπ]
    (varCount : ‚Ñï) (œÜ : Œπ ‚Ü™ F) [Smooth œÜ] (err : ‚Ñù)
    : Set ((Unit √ó ‚àÄ i, (OracleStatement Œπ F i)) √ó Unit) :=
  { ‚ü®‚ü®_, oracle‚ü©, _‚ü© | Œ¥·µ£(oracle (), smoothCode œÜ varCount) ‚â§ err }

@[simp]
def poly (k : ‚Ñï) : Polynomial (BTField k) := definingPoly (s:=(Z k))

DivisionSemiring in Mathlib.Algebra.Field.Defs

Nat.Prime in Mathlib.Data.Nat.Prime.Defs

HAdd in Init.Prelude

def bitExpo (i : ‚Ñï) : (Fin m) ‚Üí‚ÇÄ ‚Ñï :=
  Finsupp.onFinset Finset.univ
    (fun j => if Nat.testBit i j.1 then 1 else 0)
    (by admit /- proof elided -/
    )

def erase_odd (s : Finset ‚Ñï) : Finset ‚Ñï := s.filter Even

orderOf in Mathlib.GroupTheory.OrderOfElement

instance (Œ±s : List Type) [HListRepr (HList Œ±s)] : Repr (HList Œ±s) where
  reprPrec
  | v, _ => "[" ++ HListRepr.repr v ++ "]"

noncomputable def funcQuotient (f : Œπ ‚Üí F) (S : Finset F) (Ans Fill : S ‚Üí F) : Œπ ‚Üí F :=
  fun x =>
    if hx : x.val ‚àà S then Fill ‚ü®x.val, hx‚ü© 
    else (f x - (ansPoly S Ans).eval x.val) / (vanishingPoly S).eval x.val

@[simps]
def subtypeSumComplEquiv {Œ± : Type*} {p : Œ± ‚Üí Prop} [DecidablePred p] :
    {a // p a} ‚äï {a // ¬¨ p a} ‚âÉ Œ± where
  toFun := fun x => match x with
    | Sum.inl a => a.1
    | Sum.inr a => a.1
  invFun := fun x =>
    if h : p x then Sum.inl ‚ü®x, h‚ü© else Sum.inr ‚ü®x, h‚ü©
  left_inv := fun x => match x with
    | Sum.inl a => by admit /- proof elided -/
    | Sum.inr a => by admit /- proof elided -/

Algebra.cast in Mathlib.Algebra.Algebra.Defs

Subsingleton in Init.Core

def oracleReduction.linearCombination :
    OracleReduction oSpec
      (Statement.AfterFirstSumcheck R pp) (OracleStatement.AfterFirstSumcheck R pp) (Witness R pp)
      (Statement.AfterLinearCombination R pp) (OracleStatement.AfterLinearCombination R pp) Unit
      ‚ü®!v[.V_to_P], !v[LinearCombinationChallenge R]‚ü© :=
  sorry

def toMessagesUpTo (transcript : Transcript k pSpec) : MessagesUpTo k pSpec :=
  fun ‚ü®i, _‚ü© => transcript i

def ExtractabilityAdversary (oSpec : OracleSpec Œπ) (Data Commitment AuxState : Type)
    [O : OracleInterface Data] :=
  OracleComp oSpec (Commitment √ó O.Query √ó O.Response √ó AuxState)

class SpongeSize where
   
  N : Nat
   
  R : Nat
   
  R_lt_N : R < N := by admit /- proof elided -/

@[reducible]
def FinalOracleStatement : Fin (k + 2) ‚Üí Type :=
  fun j =>
    if j.1 = k + 1
    then (Unit ‚Üí F[X])
    else (evalDomain D x (‚àë j' ‚àà finRangeTo j.1, s j') ‚Üí F)

@[inline, reducible]
def proj : OuterStmtIn ‚Üí InnerStmtIn :=
  lens.toFunA

def shift_left (s : Finset ‚Ñï) : Finset ‚Ñï :=
  s.filterMap
    (fun n => match n with
      | 0 => .none
      | n + 1 => .some n
      )
    (by admit /- proof elided -/
    )

instance instHasSucc {n : ‚Ñï} : HasSucc (CNat n) := (CayleyTower n).2

def challengeQueryImpl {pSpec : ProtocolSpec n} [‚àÄ i, SelectableType (pSpec.Challenge i)] :
    QueryImpl ([pSpec.Challenge]‚Çí'challengeOracleInterface) ProbComp where
  impl | query i () => uniformOfFintype (pSpec.Challenge i)

instance : Neg (UniPoly R) := ‚ü®UniPoly.neg‚ü©

instance : Mul (UniPoly R) := ‚ü®UniPoly.mul‚ü©

def toCoeffsVec (‚Ñì : Nat) : L‚¶É<2^‚Ñì‚¶Ñ[X] ‚Üí‚Çó[L] CoeffVecSpace L ‚Ñì where
  toFun := fun p => fun i => p.val.coeff i.val
  map_add' := fun p q => by admit /- proof elided -/

instance {T} [HasSucc T] : CoeFun (Cayley T) (fun _ => T ‚Üí T) := ‚ü®Cayley.toFun‚ü©

Subtype in Init.Prelude

def duplexSpongeHybridOracle : OracleSpec pSpec.ChallengeIdx :=
  fun i =>
    ‚ü®StmtIn √ó ((j : pSpec.MessageIdx) ‚Üí (j.1 < i.1) ‚Üí Vector U (pSpec.L‚Çö·µ¢ j)),
    Vector U (pSpec.L·µ•·µ¢ i)‚ü©

alias ¬´ùíü_Œ£¬ª := duplexSpongeHybridOracle

instance : ‚àÄ j, OracleInterface ((pSpecRelay).Message j)
  | ‚ü®x, h‚ü© => by admit /- proof elided -/

Set.Ioc in Mathlib.Order.Interval.Set.Defs

def Œ≥ (x‚ÇÄ : F) (R : F[X][X][Y]) (H : F[X][Y]) [œÜ : Fact (Irreducible H)] : PowerSeries (ùïÉ H) :=
  let subst (t : ‚Ñï) : ùïÉ H :=
    match t with
    | 0 => fieldToùïÉ (-x‚ÇÄ)
    | 1 => 1
    | _ => 0
  PowerSeries.subst (PowerSeries.mk subst) (PowerSeries.mk (Œ± x‚ÇÄ R H))

List.IsSuffix in Init.Data.List.Basic

Fin.natAdd in Init.Data.Fin.Basic

inductive Lit where
  | scalar (val : F)
  
  
  | vector (len : Nat) (v : Fin len ‚Üí F)

@[reducible, simp] def StmtAfterSendClaim : Type := R

AddSubmonoidClass in Mathlib.Algebra.Group.Submonoid.Defs

noncomputable def novelToMonomialCoeffs

  (‚Ñì : ‚Ñï) (h_‚Ñì : ‚Ñì ‚â§ r) (novel_coeffs : Fin (2 ^ ‚Ñì) ‚Üí L) : Fin (2^‚Ñì) ‚Üí L :=
  let A := changeOfBasisMatrix ùîΩq Œ≤ ‚Ñì h_‚Ñì
  Matrix.vecMul novel_coeffs A

instance [Inhabited OuterWitOut]
    [instKS : lens.IsKnowledgeSound
                outerRelIn innerRelIn
                outerRelOut innerRelOut
                compatStmt (fun _ _ => True)] :
    lens.stmt.IsSound
      outerRelIn.language outerRelOut.language
      innerRelIn.language innerRelOut.language
      compatStmt where
  proj_sound := fun outerStmtIn hCompat => by admit /- proof elided -/

LinearIndepOn in Mathlib.LinearAlgebra.LinearIndependent.Defs

MvPolynomial in Mathlib.Algebra.MvPolynomial.Basic

instance instTestLensComplete : testLens.IsComplete
      outerRelIn_Test innerRelIn_Test outerRelOut_Test innerRelOut_Test
      (fun ‚ü®‚ü®p, q, _‚ü©, _‚ü© ‚ü®‚ü®f, _‚ü©, _‚ü© => p * q = f) where
  proj_complete := fun ‚ü®p, q, t‚ü© () hRelIn => by admit /- proof elided -/

abbrev Field := ZMod fieldSize

def evalBivar
  (Q : MvPolynomial (Fin 2) F) (a b : F) : F := MvPolynomial.eval (Fin.cases a (fun _ ‚Ü¶ b)) Q

UInt8.ofFin in Init.Data.UInt.Basic

instance oCtxLens_complete :
    (oCtxLens R n deg D i).toContext.IsComplete
      (relationRound R n deg D i.castSucc) (Simple.inputRelation R deg D)
      (relationRound R n deg D i.succ) (Simple.outputRelation R deg)
      ((Simple.oracleReduction R deg D oSpec).toReduction.compatContext
        (oCtxLens R n deg D i).toContext)
where
  proj_complete := by admit /- proof elided -/

inductive Skeleton :
    (n : ‚Ñï) ‚Üí (ar : Fin n ‚Üí ‚Ñï) ‚Üí Type where
  | leaf {ar0 : Fin 0 ‚Üí ‚Ñï} : Skeleton 0 ar0
  | node {n : ‚Ñï} {ar : Fin (n+1) ‚Üí ‚Ñï}
      (children : Fin (ar 0) ‚Üí
        Skeleton n (fun i => ar i.succ)) :
      Skeleton (n+1) ar

def relation : Set (M √ó List (MemoryRead Œπ Œ±)) :=
  { ‚ü®mem, ops‚ü© | ‚àÄ op ‚àà ops, Memory.read mem op.index = op.value }

def join_via_add_smul {k : ‚Ñï} (h_pos : k > 0) (hi_btf lo_btf : BTField (k - 1)) :
    BTField k :=

def extend {k : Fin n} (challenges : ChallengesUpTo k.castSucc pSpec)
    (h : pSpec.dir k = .P_to_V) : ChallengesUpTo k.succ pSpec :=
  fun ‚ü®i, h‚ü© => (concat' (pSpec := pSpec) (fun i hi => challenges ‚ü®i, hi‚ü©) (fun h' => by admit /- proof elided -/
  )) i h

def Œ± (x‚ÇÄ : F) (R : F[X][X][Y]) (H : F[X][Y]) [œÜ : Fact (Irreducible H)] (t : ‚Ñï) : ùïÉ H :=
  let W : ùïÉ H := liftToFunctionField (H.leadingCoeff)
  embeddingOfùí™IntoùïÉ _ (Œ≤ R t) / (W ^ (t + 1) * (embeddingOfùí™IntoùïÉ _ (Œæ x‚ÇÄ R H)) ^ (2*t - 1))

@[reducible]
def coeffs {R : Type*} (p : UniPoly R) : Array R := p

IntCast in Init.Data.Int.Basic

def dropLastWhile (p : Œ± ‚Üí Bool) (l : List Œ±) : List Œ± :=
  (l.reverse.dropWhile p).reverse

BitVec.setWidth in Init.Data.BitVec.Basic

abbrev MultiquadraticPoly (L : Type) [CommSemiring L] (‚Ñì : ‚Ñï) := L‚¶É‚â§ 2‚¶Ñ[X Fin ‚Ñì]

def inputRelation (cond : ‚àë i, (s i).1 ‚â§ n) [DecidableEq F] (Œ¥ : ‚Ñù‚â•0) :
    Set
      (
        (
          Statement F (Fin.last k) √ó
          (‚àÄ j, OracleStatement D x s (Fin.last k) j)
        ) √ó
        Witness F s d (Fin.last k).castSucc
      ) := sorry

instance : Initialize (DuplexSponge U C) (Vector UInt8 32) where
  new iv := {
    state := Initialize.new iv,
    absorbPos := 0,
    squeezePos := Fin.last SpongeSize.R
  }

@[inline, reducible]
protected def id :
    Witness.InvLens OuterStmtIn OuterWitIn OuterWitOut OuterWitIn OuterWitOut :=
  ‚ü®Prod.snd, fun _ => id‚ü©

alias trivial := Witness.InvLens.id

def Extractor.RoundByRound.id :
    Extractor.RoundByRound oSpec Statement Witness Witness !p[] (fun _ => Witness) where
  eqIn := rfl
  extractMid := fun i => Fin.elim0 i
  extractOut := fun _ _ => _root_.id

def MlPolyEval.mk {R : Type*} (n : ‚Ñï) (v : Vector R (2 ^ n)) : MlPolyEval R n := v

def concrete_pow_nat {k : ‚Ñï} (x : ConcreteBTField k) (n : ‚Ñï) : ConcreteBTField k :=
  if n = 0 then one
  else if n % 2 = 0 then concrete_pow_nat (concrete_mul x x) (n / 2)
  else concrete_mul x (concrete_pow_nat (concrete_mul x x) (n / 2))

def totalNumPermQueries : Nat :=
  pSpec.totalNumPermQueriesMessage + pSpec.totalNumPermQueriesChallenge

instance Vector.instFintype {Œ± : Type*} {n : ‚Ñï} [VCVCompatible Œ±] : Fintype (Vector Œ± n) :=
  Fintype.ofEquiv _ (Equiv.rootVectorEquivFin).symm

def queryCodeword (k : ‚Ñï) (s : Fin (k + 1) ‚Üí ‚Ñï+) {i : Fin (k + 1)}
      (w : evalDomain D x (‚àë j' ‚àà (List.take i.1 (List.finRange (k + 1))).toFinset, (s j').1)) :
    OracleComp [FinalOracleStatement D x s]‚Çí F :=
      OracleComp.lift <| by
        simpa using
          OracleSpec.query
            (spec := [FinalOracleStatement D x s]‚Çí)
            ‚ü®i.1, Nat.lt_succ_of_lt i.2‚ü©
            (by admit /- proof elided -/
            )

def minRelHammingDistCode (C : Set (Œπ ‚Üí F)) : ‚Ñö‚â•0 :=
  haveI : Fintype (possibleRelHammingDists C) := @Fintype.ofFinite _ finite_possibleRelHammingDists
  if h : (possibleRelHammingDists C).Nonempty
  then (possibleRelHammingDists C).toFinset.min' (Set.toFinset_nonempty.2 h)
  else 0

def BindingAdversary (oSpec : OracleSpec Œπ) (Data Commitment AuxState : Type)
    [O : OracleInterface Data] :=
  OracleComp oSpec (Commitment √ó O.Query √ó O.Response √ó O.Response √ó AuxState)

instance : Field ScalarField := ZMod.instField scalarFieldSize

def leq {Œ± : Type} (m n : ChurchNat Œ±) : ChurchBool Œ± :=
  isZero (ChurchNat.sub m n)

def oracleProver : OracleProver oSpec
    Statement OStatement Unit
    Unit (OStatement ‚äï·µ• OStatement) Unit
    (pSpec OStatement) where
  PrvState := fun _ => OStatement default

  input := fun ‚ü®‚ü®_, oStmt‚ü©, _‚ü© => oStmt default

  sendMessage | ‚ü®0, _‚ü© => fun st => pure (st, st)

  receiveChallenge | ‚ü®0, h‚ü© => nomatch h

  output := fun st => pure
    (‚ü®(), fun x => match x with
      | .inl _ => by admit /- proof elided -/
      ‚ü©,
     ())

def nonLastBlockOracleReduction (bIdx : Fin (‚Ñì / œë - 1)) :=
  let stmt : Fin (œë - 1 + 1) ‚Üí Type :=
    fun i => Statement (L := L) (‚Ñì := ‚Ñì) Context ‚ü®bIdx * œë + i, bIdx_mul_œë_add_i_cast_lt_‚Ñì_succ bIdx i‚ü©
  let oStmt := fun i: Fin (œë - 1 + 1) =>
    OracleStatement ùîΩq Œ≤ œë ‚ü®bIdx * œë + i, bIdx_mul_œë_add_i_cast_lt_‚Ñì_succ bIdx i‚ü©
  let wit := fun i: Fin (œë - 1 + 1) =>
    Witness (L := L) ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (‚Ñì:=‚Ñì)
      ‚ü®bIdx * œë + i, bIdx_mul_œë_add_i_cast_lt_‚Ñì_succ bIdx i‚ü©
  let firstFoldRelayRoundsOracleReduction :=
    OracleReduction.seqCompose (oSpec := []‚Çí)
      (Stmt := stmt)
      (OStmt := oStmt)
      (Wit := wit)
      (pSpec := fun i => pSpecFoldRelay (L:=L))
      (R := fun i => by admit /- proof elided -/
      )

  let h1 : ‚ÜëbIdx * œë + (œë - 1) < ‚Ñì := by admit /- proof elided -/

instance domain_neg_inst {i : Fin n} : Neg (evalDomain D i.1) where
  neg := fun x => ‚ü®_, minus_one_in_doms D i.2‚ü© * x

def Mymotive : Fin 3 ‚Üí Type := !v[‚Ñï, Bool, String]

example : !d‚ü®Mymotive‚ü©[(1 : ‚Ñï), (true : Bool), ("hello" : String)] =
  (Fin.dcons (1 : ‚Ñï) (Fin.dcons (true : Bool) (Fin.dcons ("hello" : String) Fin.dempty)) :
   (i : Fin 3) ‚Üí Mymotive i) := rfl


example : !v[1, 2] ++·µõ !v[3, 4] = !v[1, 2, 3, 4] := rfl
example : (0 : ‚Ñï) ::·µõ !v[1, 2] = !v[0, 1, 2] := rfl
example : !v[1, 2] :+·µõ (3 : ‚Ñï) = !v[1, 2, 3] := rfl


example : (1 : ‚Ñï) :: ∞ (Fin.dempty : (i : Fin 0) ‚Üí Fin.vempty i) =
  (!h[(1 : ‚Ñï)] : (i : Fin 1) ‚Üí !v[‚Ñï] i) := rfl


example : !h[(1 : ‚Ñï), (true : Bool), ("hello" : String)] =
  Fin.hcons 1 (Fin.hcons true ("hello" :: ∞‚ü®String ; !v[]‚ü© !h[])) := rfl

instance : ‚àÄ j, OracleInterface ((pSpecFinalSumcheckStep (L := L)).Message j) := fun j =>
  match j with
  | ‚ü®0, _‚ü© => OracleInterface.instDefault

structure ModifiedGuruswami
  (m n k : ‚Ñï)
  (œâs : Fin n ‚Ü™ F)
  (Q : F[Z][X][Y])
  (u‚ÇÄ u‚ÇÅ : Fin n ‚Üí F)
  where
  Q_ne_0 : Q ‚â† 0
   
  Q_deg : natWeightedDegree Q 1 k < D_X ((k + 1) / (n : ‚Ñö)) n m
   
  Q_multiplicity : ‚àÄ i, rootMultiplicity Q
              (Polynomial.C <| œâs i)
              ((Polynomial.C <| u‚ÇÄ i) + Polynomial.X * (Polynomial.C <| u‚ÇÅ i))
            ‚â• m
   
  Q_deg_X :
    degreeX Q < D_X ((k + 1) / (n : ‚Ñö)) n m
   
  Q_D_Y :
    D_Y Q < D_X (k + 1 / (n : ‚Ñö)) n m / k
   
  Q_D_YZ :
    D_YZ Q ‚â§ n * (m + 1/(2 : ‚Ñö))^3 / (6 * Real.sqrt ((k + 1) / n))

instance : ‚àÄ i, SelectableType ((pSpecNonLastBlocks ùîΩq Œ≤ (œë:=œë)
  (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).Challenge i) := instSelectableTypeChallengeSeqCompose

Polynomial.X in Mathlib.Algebra.Polynomial.Basic

@[inline, specialize]
def add_raw (p q : UniPoly R) : UniPoly R :=
  let ‚ü®p', q'‚ü© := Array.matchSize p q 0
  .mk (Array.zipWith (¬∑ + ¬∑) p' q' )

def AlgebraTowerEquiv.toAlgebraOverLeft (e : AlgebraTowerEquiv A B) (i j : Œπ)
    (h : i ‚â§ j) : Algebra (A i) (B j) :=

def polynomialOfCoeffs (coeffs : Fin deg ‚Üí F) : F[X] :=
  ‚ü®
    Finset.map ‚ü®Fin.val, Fin.val_injective‚ü© {i | coeffs i ‚â† 0},
    fun i ‚Ü¶ if h : i < deg then coeffs ‚ü®i, h‚ü© else 0,
    fun a ‚Ü¶ by admit /- proof elided -/
  ‚ü©

def relationAfterRandomQuery :
    Set (((StmtAfterRandomQuery R) √ó (‚àÄ i, OStmtAfterRandomQuery R deg i)) √ó Unit) :=
  { ‚ü®‚ü®chal, oStmt‚ü©, _‚ü© | (oStmt (Sum.inr ())).1.eval chal = (oStmt (Sum.inl ())).1.eval chal }

  inductive UnverifiedPrattCertificate : ‚Ñï ‚Üí Type
    | knownPrime : (n : ‚Ñï) ‚Üí UnverifiedPrattCertificate n
    | of : (n : ‚Ñï) ‚Üí (a : ‚Ñï) ‚Üí (part : UnverifiedPrattPart) ‚Üí UnverifiedPrattCertificate n
  deriving Repr

instance {s} : LawfulFunctor (fun Œ± => LeafData Œ± s) :=

Nat.all in Init.Data.Nat.Fold

UInt16.ofFin in Init.Data.UInt.Basic

noncomputable def towerEquiv_zero : RingEquiv (R:=GF(2)) (S:=ConcreteBTField 0) :=  {
  toFun := fun x => if x = 0 then 0 else 1,
  invFun := fun x => if x = 0 then 0 else 1,
  left_inv := fun x => by admit /- proof elided -/

instance : HasPred Nat where
  pred' := Nat.pred

AddGroup in Mathlib.Algebra.Group.Defs

Polynomial.erase in Mathlib.Algebra.Polynomial.Basic

def finUInt16Equiv : Fin (2 ^ 16) ‚âÉ UInt16 where
  toFun := fun i => UInt16.ofFin i
  invFun := fun u => u.toFin
  left_inv _ := rfl
  right_inv _ := rfl

noncomputable def roundConsistencyCheck [Field ùîΩ] [DecidableEq ùîΩ]
    (Œ≥ : ùîΩ) (pts : List (ùîΩ √ó ùîΩ)) (Œ≤ : ùîΩ) : Bool :=
  let p := Lagrange.interpolate Finset.univ (fun i => (pts.get i).1) (fun i => (pts.get i).2)
  p.eval Œ≥ == Œ≤

@[inline] def mod [Zero T] [DecidableEq T] [ToNat T]
    (dividend divisor : Cayley T) : Cayley T :=
  
  letI fuel := (‚Üëdividend : Nat) + 1
  modNat dividend divisor fuel

@[simp]
abbrev Statement.AfterFirstMessage : Type := Statement R pp
</all_available_defs>

<all_available_lemmas>
Nat.sub_add_cancel in Init.Data.Nat.Basic
Nat.sub_zero in Init.Data.Nat.Basic
BitVec.ofNat_toNat in Init.Data.BitVec.Bootstrap
BitVec.setWidth_eq in Init.Data.BitVec.Lemmas
BitVec.toNat_setWidth in Init.Data.BitVec.Bootstrap
Nat.and_two_pow_sub_one_eq_mod in Init.Data.Nat.Bitwise.Lemmas
Nat.shiftRight_zero in Init.Data.Nat.Bitwise.Basic
Nat.add_sub_self_left in Init.Data.Nat.Basic
Nat.mul_two in Init.Data.Nat.Basic
Nat.pow_succ in Init.Data.Nat.Basic
Nat.succ_eq_add_one in Init.Data.Nat.Basic
Nat.mul_comm in Init.Data.Nat.Basic
Nat.two_pow_pred_mul_two in Init.Data.Nat.Lemmas
id_eq in Init.Prelude
Nat.add_sub_cancel in Init.Data.Nat.Basic
Nat.sub_add_comm in Init.Data.Nat.Lemmas
BitVec.extractLsb'_append_eq_of_le in Init.Data.BitVec.Lemmas
Nat.le_refl in Init.Prelude
congrArg in Init.Prelude
eq_mp_eq_cast in Init.PropLemmas
BitVec.append_eq in Init.Data.BitVec.Basic
BitVec.setWidth_append in Init.Data.BitVec.Lemmas
Nat.add_comm in Init.Data.Nat.Basic
Nat.div_eq_sub_mod_div in Init.Data.Nat.Lemmas
Nat.div_lt_of_lt_mul in Init.Data.Nat.Mod
Nat.div_mul_cancel in Init.Data.Nat.Dvd
Nat.dvd_sub_mod in Init.Data.Nat.Lemmas
Nat.mod_eq_of_lt in Init.Data.Nat.Div.Basic
Nat.pow_add in Init.Data.Nat.Lemmas
Nat.shiftLeft_eq in Init.Data.Nat.Bitwise.Basic
Nat.shiftRight_eq_div_pow in Init.Data.Nat.Bitwise.Basic
Nat.mod_le in Init.Data.Nat.Div.Basic
Nat.mod_lt in Init.Prelude
Nat.shiftLeft_add_eq_or_of_lt in Init.Data.Nat.Bitwise.Lemmas
BitVec.eq_of_toNat_eq in Init.Data.BitVec.Bootstrap
BitVec.isLt in Init.Data.BitVec.BasicAux
BitVec.toNat_append in Init.Data.BitVec.Bootstrap
BitVec.toNat_ofNat in Init.Data.BitVec.Bootstrap
Nat.ofNat_pos in Mathlib.Data.Nat.Cast.Order.Ring
OfNat.ofNat_ne_one in Mathlib.Algebra.CharZero.Defs
ne_eq in Init.SimpLemmas
not_false_eq_true in Init.SimpLemmas
pow_right_inj‚ÇÄ in Mathlib.Algebra.Order.GroupWithZero.Unbundled.Basic
Nat.two_pow_pos in Init.Data.Nat.Basic
Prod.ext_iff in Init.Ext
Nat.ne_zero_of_lt in Init.Data.Nat.Basic
Nat.one_lt_two_pow_iff in Init.Data.Nat.Lemmas
Nat.shiftRight_eq_zero in Init.Data.Nat.Bitwise.Basic
Nat.one_mod_two_pow_eq_one in Init.Data.Nat.Lemmas
BitVec.zero_eq in Init.Data.BitVec.Basic
Nat.one_mod_two_pow in Init.Data.Nat.Lemmas
Nat.zero_lt_two in Init.Data.Nat.Basic
pow_pos in Mathlib.Algebra.Order.GroupWithZero.Unbundled.Basic
BitVec.zero_xor in Init.Data.BitVec.Lemmas
BitVec.xor_zero in Init.Data.BitVec.Lemmas
Nat.add_one_sub_one in Init.Data.Nat.Basic
pow_two in Mathlib.Algebra.Group.Defs
BitVec.ofNat_xor in Init.Data.BitVec.Lemmas
BitVec.xor_eq in Init.Data.BitVec.Basic
BitVec.toNat_xor in Init.Data.BitVec.Lemmas
Nat.and_xor_distrib_right in Init.Data.Nat.Bitwise.Lemmas
Nat.shiftRight_xor_distrib in Init.Data.Nat.Bitwise.Lemmas
mul_one in Mathlib.Algebra.Group.Defs
Ne.dite_eq_left_iff in Mathlib.Logic.Basic
Nat.left_eq_add in Init.Data.Nat.Lemmas
RingHom.comp_id in Mathlib.Algebra.Ring.Hom.Defs
cast_eq in Init.Core
one_ne_zero in Mathlib.Algebra.NeZero
BitVec.xor_assoc in Init.Data.BitVec.Lemmas
BitVec.xor_self in Init.Data.BitVec.Lemmas
Polynomial.C_mul' in Mathlib.Algebra.Polynomial.Coeff
Polynomial.aeval_def in Mathlib.Algebra.Polynomial.AlgebraMap
Polynomial.eval‚ÇÇ_X in Mathlib.Algebra.Polynomial.Eval.Defs
Polynomial.eval‚ÇÇ_X_pow in Mathlib.Algebra.Polynomial.Eval.Defs
Polynomial.eval‚ÇÇ_add in Mathlib.Algebra.Polynomial.Eval.Defs
Polynomial.eval‚ÇÇ_one in Mathlib.Algebra.Polynomial.Eval.Defs
Polynomial.eval‚ÇÇ_smul in Mathlib.Algebra.Polynomial.Eval.SMul
mul_comm in Mathlib.Algebra.Group.Defs

theorem one_le_two_pow_n (n : ‚Ñï) : 1 ‚â§ 2 ^ n

@[simp]
theorem dcast_eq : dcast (Eq.refl a) b = b

theorem one_le_sub_consecutive_two_pow (n : ‚Ñï): 1 ‚â§ 2^(n+1) - 2^n

theorem dcast_eq_root_cast (h : a = a') : dcast h b = _root_.cast (congrArg Œ≤ h) b

theorem dcast_symm (ha : a = a') (hb : dcast ha b = b') : dcast (ha.symm) b' = b

theorem dcast_eq_dcast_iff (h : a = a'') (h' : a' = a'') :
    dcast h b = dcast h' b' ‚Üî b = dcast (h'.trans h.symm) b'

theorem zero_lt_pow_n (m : ‚Ñï) (n : ‚Ñï) (h_m : m > 0): 0 < m^n

lemma and_one_eq_of_eq {a b : ‚Ñï} : a = b ‚Üí a &&& 1 = b &&& 1

theorem cast_eq_cast_iff {Œ± Œ≤ Œ≥ : Sort u} {h : Œ± = Œ≥} {h' : Œ≤ = Œ≥} {a : Œ±} {b : Œ≤} :
    cast h a = cast h' b ‚Üî a = cast (h'.trans h.symm) b

theorem cast_eq_dcast {m n : ‚Ñï} (h : m = n) (a : Fin m) :
    Fin.cast h a = dcast h a

@[simp]
theorem init_snoc : init (snoc s y) = s

lemma getLast_toImpl {p : Q[X]} (hp : p ‚â† 0) : let h : p.toImpl.size > 0 := toImpl_nonzero hp;
    p.toImpl[p.toImpl.size - 1] = p.leadingCoeff

theorem BitVec.extractLsb_concat_hi {hi_size lo_size : ‚Ñï} (hi : BitVec hi_size)
  (lo : BitVec lo_size) (h_hi : hi_size > 0) :
  BitVec.extractLsb (hi:=hi_size + lo_size - 1) (lo:=lo_size)
  (BitVec.append (msbs:=hi) (lsbs:=lo)) = dcast (by
    rw [‚ÜêNat.sub_add_comm (by omega), Nat.sub_add_cancel (by omega), Nat.add_sub_cancel]
  ) hi

omit [DecidableEq Œ±] [Inhabited Œ±] [Fintype Œ±] in
@[simp]
lemma Cache.leaves_cons (n : ‚Ñï) (leaves : List.Vector Œ± (2 ^ (n + 1))) (cache : Cache Œ± n) :
    Cache.leaves Œ± n (Cache.cons Œ± n leaves cache) = leaves

@[simp]
theorem simulateQ'_query (q : OracleQuery spec Œ±) :
    simulateQ' so q (by simp) = so.impl q

@[simp]
lemma append_zero_of_succ_left {u : Fin (m + 1) ‚Üí Œ±} {v : Fin n ‚Üí Œ±} :
    (append u v) 0 = u 0

lemma take_eq_take : transcript‚ü¶:m‚üß = transcript.take m h

lemma and_eq_zero_iff_and_each_getBit_eq_zero {n m : ‚Ñï} :
    n &&& m = 0 ‚Üî ‚àÄ k, Nat.getBit k n &&& Nat.getBit k m = 0

theorem eqPolynomial_symm (x : œÉ ‚Üí R) (y : œÉ ‚Üí R) :
    MvPolynomial.eval y (eqPolynomial x) = MvPolynomial.eval x (eqPolynomial y)

omit [DecidableEq ùîΩq] hF‚ÇÇ h_Œ≤‚ÇÄ_eq_1 in
lemma get_sDomain_basis (i : Fin r) (h_i : i < ‚Ñì + R_rate) :
    ‚àÄ (k : Fin (‚Ñì + R_rate - i)),
    (sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate
      i (by omega)) k = eval (Œ≤ ‚ü®i + k.val, by omega‚ü©) (normalizedW ùîΩq Œ≤ i)

lemma monoToLagrange_eq_monoToLagrange_segment (n : ‚Ñï) [NeZero n] (v : Vector R (2 ^ n)) :
  have h_n_ne_zero: n ‚â† 0

@[simp]
lemma dfoldrM'_succ {n : ‚Ñï} {Œ± : Fin (n + 1 + 1) ‚Üí Type u}
    (f : (i : Fin (n + 1)) ‚Üí Œ± i.succ ‚Üí m (Œ± i.castSucc)) (x : Œ± (last (n + 1))) :
    dfoldrM' (n + 1) Œ± f x = (do
      let y ‚Üê dfoldrM' n (Œ± ‚àò succ) (fun i => f i.succ) x
      f 0 y)

lemma one_bitvec_shiftRight {d : ‚Ñï} (h_d : d > 0) : 1 >>> d = 0

theorem prime_29 : Nat.Prime 29

theorem liftContext_rbr_knowledgeSoundness [Inhabited InnerWitIn]
    {rbrKnowledgeError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    {stmtLens : OracleStatement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                                OuterOStmtIn OuterOStmtOut InnerOStmtIn InnerOStmtOut}
    {witLens : Witness.InvLens (OuterStmtIn √ó ‚àÄ i, OuterOStmtIn i)
                            OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    (V : OracleVerifier oSpec InnerStmtIn InnerOStmtIn InnerStmtOut InnerOStmtOut pSpec)
    [lensKS : Extractor.Lens.IsKnowledgeSound
      outerRelIn innerRelIn outerRelOut innerRelOut
      (V.toVerifier.compatStatement stmtLens) (fun _ _ => True) ‚ü®stmtLens, witLens‚ü©]
    (h : V.rbrKnowledgeSoundness init impl innerRelIn innerRelOut rbrKnowledgeError) :
      (V.liftContext stmtLens).rbrKnowledgeSoundness init impl outerRelIn outerRelOut
        rbrKnowledgeError

theorem prime_41 : Nat.Prime 41

@[simp]
theorem append_left_cancel_iff {pSpec : ProtocolSpec n} {p1 p2 : ProtocolSpec m} :
    p1 ++‚Çö pSpec = p2 ++‚Çö pSpec ‚Üî p1 = p2

theorem neg_add_cancel : -p + p = 0

@[simp]
theorem bool_accepts_iff_of_domain [IsDomain ùì°] :
    (bool j).accepts x ‚Üî x j = 0 ‚à® x j = 1

@[simp]
theorem fflatten_one {A : Sort u} {F : A ‚Üí Sort v} {n : Fin 1 ‚Üí ‚Ñï}
    {Œ± : (i : Fin 1) ‚Üí (j : Fin (n i)) ‚Üí A}
    {v : (i : Fin 1) ‚Üí (j : Fin (n i)) ‚Üí F (Œ± i j)} :
    fflatten v = v 0

theorem last_nonzero_spec [LawfulBEq R] {p : UniPoly R} {k} :
  p.last_nonzero = some k
  ‚Üí p[k] ‚â† 0 ‚àß (‚àÄ j, (hj : j < p.size) ‚Üí j > k ‚Üí p[j] = 0)

theorem unique_repr {R : Type*} [CommRing R] {S : Type*} [CommRing S] [Algebra R S]
    (pb : PowerBasis R S) (repr1 repr2 : Fin pb.dim ‚Üí‚ÇÄ R)
    (h : ‚àë i : Fin pb.dim, repr1 i ‚Ä¢ pb.basis i = ‚àë i : Fin pb.dim, repr2 i ‚Ä¢ pb.basis i) :
    repr1 = repr2

Nat.pos_of_neZero in Init.Data.Nat.Basic

lemma ConcreteBTFieldAlgebra_def (l r : ‚Ñï) (h_le : l ‚â§ r) :
    @ConcreteBTFieldAlgebra (l:=l) (r:=r) (h_le:=h_le)
    = (concreteTowerAlgebraMap l r h_le).toAlgebra

@[simp]
theorem coe_basis_apply {R S : Type*} [CommRing R] [Ring S] [Algebra R S]
  (pb : PowerBasis R S) (i : Fin pb.dim) : ‚áëpb.basis i = pb.gen ^ (i : ‚Ñï)

@[simp]
lemma toFun_invFun (f : ‚àÄ a, Œ≤ a) : inst.equiv.toFun (equiv.invFun f : F) = f

@[simp]
lemma seqCompose_zero
    (Stmt : Fin 1 ‚Üí Type)
    {Œπ‚Çõ : Fin 1 ‚Üí Type} (OStmt : (i : Fin 1) ‚Üí Œπ‚Çõ i ‚Üí Type)
    [O‚Çõ : ‚àÄ i, ‚àÄ j, OracleInterface (OStmt i j)]
    {n : Fin 0 ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    [O‚Çò : ‚àÄ i, ‚àÄ j, OracleInterface ((pSpec i).Message j)]
    (V : (i : Fin 0) ‚Üí OracleVerifier oSpec
      (Stmt i.castSucc) (OStmt i.castSucc) (Stmt i.succ) (OStmt i.succ) (pSpec i)) :
    seqCompose Stmt OStmt V = OracleVerifier.id

theorem MLE_expanded (evals : (œÉ ‚Üí Fin 2) ‚Üí R) : MLE evals =
    ‚àë x : œÉ ‚Üí Fin 2, (‚àè i : œÉ, ((1 - C (x i : R)) * (1 - X i) + C (x i : R) * X i))
      * C (evals x)

theorem induction_append_left {m n : ‚Ñï} {motive : Fin (m + n + 1) ‚Üí Sort*} {zero : motive 0}
    {succ : ‚àÄ i : Fin (m + n), motive i.castSucc ‚Üí motive i.succ} {i : Fin (m + 1)} :
      induction (motive := motive) zero succ ‚ü®i, by omega‚ü© =
        @induction m (fun j => motive ‚ü®j, by omega‚ü©) zero (fun j x => succ ‚ü®j, by omega‚ü© x) i

@[simp]
theorem insertNth_apply_same : insertNth p y s p = y

lemma folding
  [Nonempty Œπ] {S : Finset Œπ} [Fintype Œπ]
  (œÜ : Œπ ‚Ü™ F) (f : Œπ ‚Üí F) (k : ‚Ñï)
  [Nonempty (indexPow S œÜ k)]
  {degree : ‚Ñï} (Œ¥ : ‚Ñö) (hŒ¥Pos : Œ¥ > 0)
  (hŒ¥Lt : Œ¥ < foldingDistRange degree œÜ f) :
  let C : Set ((indexPow S œÜ k) ‚Üí F) := code (pow S œÜ k) (degree / k)
  Pr_{ let r ‚Üê $·µñ F }[ Œ¥·µ£((fold œÜ f k r), C) ‚â§ Œ¥]
    ‚â§ ENNReal.ofReal (proximityError F (degree / k) (LinearCode.rate (code œÜ degree)) Œ¥ k)

theorem findIdxRev?_eq_none {cond} {as : Array Œ±} (h : ‚àÄ i, (hi : i < as.size) ‚Üí ¬¨ cond as[i]) :
  findIdxRev? cond as = none

@[simp]
theorem cast_toVerifier (V : OracleVerifier oSpec StmtIn OStmtIn StmtOut OStmtOut pSpec‚ÇÅ) :
    (OracleVerifier.cast hn hSpec hO‚Çò V).toVerifier = Verifier.cast hn hSpec V.toVerifier

@[simp]
theorem lagrangeBasis_zero {w : Vector R 0} : lagrangeBasis w = #v[1]

@[simp]
theorem oracleVerifier_rbrKnowledgeSoundness (hRel : ‚àÄ stmtIn oStmtIn witOut,
      ((mapStmt stmtIn, mapOStmt embedIdx hEq oStmtIn), witOut) ‚àà relOut ‚Üí
      ((stmtIn, oStmtIn), mapWitInv (stmtIn, oStmtIn) witOut) ‚àà relIn) :
    (oracleVerifier oSpec mapStmt embedIdx hEq).rbrKnowledgeSoundness init impl relIn relOut 0

lemma listOfCloseCodewordsRel_eq_zero :
  listOfCloseCodewordsRel C y r = 0 ‚Üî
  IsEmpty (relHammingBall C y r) ‚à® Infinite (relHammingBall C y r)

lemma or_by_split_lowBits {n m n1 m1 bn bm : ‚Ñï} (h_bn : bn < 2) (h_bm : bm < 2)
  (h_n : n = n1 * 2 + bn) (h_m : m = m1 * 2 + bm):
  n ||

theorem relayOracleReduction_perfectCompleteness (hInit : init.neverFails) (i : Fin ‚Ñì)
    (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
    OracleReduction.perfectCompleteness
      (pSpec := pSpecRelay)
      (relIn := foldStepRelOut (mp := mp) ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        (ùìë := ùìë) i)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        (ùìë := ùìë) i.succ)
      (oracleReduction := relayOracleReduction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        i hNCR)
      (init := init)
      (impl := impl)

@[simp]
lemma seqCompose_toReduction {m : ‚Ñï}
    (Stmt : Fin (m + 1) ‚Üí Type)
    {Œπ‚Çõ : Fin (m + 1) ‚Üí Type} (OStmt : (i : Fin (m + 1)) ‚Üí Œπ‚Çõ i ‚Üí Type)
    [O‚Çõ : ‚àÄ i, ‚àÄ j, OracleInterface (OStmt i j)]
    (Wit : Fin (m + 1) ‚Üí Type)
    {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    [O‚Çò : ‚àÄ i, ‚àÄ j, OracleInterface ((pSpec i).Message j)]
    (R : (i : Fin m) ‚Üí
      OracleReduction oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Wit i.castSucc)
        (Stmt i.succ) (OStmt i.succ) (Wit i.succ) (pSpec i)) :
    (seqCompose Stmt OStmt Wit R).toReduction =
      Reduction.seqCompose (fun i => Stmt i √ó (‚àÄ j, OStmt i j)) Wit
        (fun i => (R i).toReduction)

theorem fcons_inj {Œ≤ : Fin n ‚Üí A} (a‚ÇÅ a‚ÇÇ : F Œ±) (b‚ÇÅ b‚ÇÇ : (i : Fin n) ‚Üí F (Œ≤ i)) :
    fcons a‚ÇÅ b‚ÇÅ = fcons a‚ÇÇ b‚ÇÇ ‚Üî a‚ÇÅ = a‚ÇÇ ‚àß b‚ÇÅ = b‚ÇÇ

@[simp]
theorem vappend_right (u : Fin m ‚Üí Œ±) (v : Fin n ‚Üí Œ±) (i : Fin n) :
    vappend u v (natAdd m i) = v i

lemma concrete_pow_base_one
  (prevBTFieldProps : ConcreteBTFieldProps (k := k - 1)) (n : ‚Ñï) :
  concrete_pow_nat (k:=k) (x:=1) n = 1

theorem congrArg‚ÇÉ {Œ± Œ≤ Œ≥ Œ¥ : Sort*} {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥ ‚Üí Œ¥} {a a' : Œ±} {b b' : Œ≤} {c c' : Œ≥}
    (h : a = a') (h' : b = b') (h'' : c = c') : f a b c = f a' b' c'

theorem append_run (tr : (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).FullTranscript) :
      (V‚ÇÅ.append V‚ÇÇ).run stmt tr =
        (do
          let stmt‚ÇÇ ‚Üê V‚ÇÅ.run stmt tr.fst
          let stmt‚ÇÉ ‚Üê V‚ÇÇ.run stmt‚ÇÇ tr.snd
          return stmt‚ÇÉ)

lemma mulVec_BerlekampWelchMatrix_eq :
  (BerlekampWelchMatrix e k œâs f).mulVec v i =
  ‚àë x : Fin (2 * e + k), v x * if x < e then f i * œâs i ^ x.1 else -œâs i ^ (x - e)

Finset.sup_lt_iff in Mathlib.Data.Finset.Lattice.Fold

lemma getLowBits_succ {n: ‚Ñï} (numLowBits: ‚Ñï) :
    getLowBits (numLowBits + 1) n = getLowBits numLowBits n
    + (getBit numLowBits n) <<< numLowBits

theorem oracleReduction_perfectCompleteness (hInit : init.neverFails) :
    (oracleReduction R deg oSpec).perfectCompleteness init impl
      (inputRelation R deg D) (outputRelation R deg)

lemma list_0 : list 0 = List.Vector.cons (1 : GF(2)) List.Vector.nil

private lemma sum_1_over_n_aux_frac_k_i [Zero F]
  (h_n : 0 < n) : ‚àë i, 1/n * aux_frac B (K B i 0) = aux_frac B (k B)

@[simp]
lemma OracleVerifier.id_toVerifier :
    (OracleVerifier.id : OracleVerifier oSpec Statement OStatement _ _ _).toVerifier =
      Verifier.id

lemma rounds_sub_steps_lt : ‚Ñì - œë < ‚Ñì :=
  Nat.sub_lt (pos_of_neZero ‚Ñì) (folding_steps_pos)

lemma œë_sub_one_le_self : œë - 1 < œë

@[simp, grind] lemma C_pos : 0 < sz.C

lemma getBit_of_highBits {n: ‚Ñï} (numLowBits : ‚Ñï) : ‚àÄ k, getBit k (getHighBits numLowBits n) =
    if k < numLowBits then 0 else getBit (k) (n)

lemma powerBasisSucc_dim (k : ‚Ñï) :
  powerBasisSucc (k:=k).dim = 2

lemma getBit_joinBits {n m k : ‚Ñï} (low : Fin (2 ^ n)) (high : Fin (2 ^ m)) :
  getBit k (joinBits low high).val =
    if k < n then getBit k low.val else getBit (k - n) high.val

@[simp]
theorem generator_is_not_lifted_to_succ (k : ‚Ñï) :
  ‚àÄ x : ConcreteBTField k, canonicalAlgMap (k:=k) x ‚â† Z (k + 1)

theorem functional_completeness (Œ± : Type) {s : Skeleton}
  (idx : SkeletonLeafIndex s)
  (leaf_data_tree : LeafData Œ± s)
  (hash : Œ± ‚Üí Œ± ‚Üí Œ±) :
  (getPutativeRoot_with_hash
    idx
    (leaf_data_tree.get idx)
    (generateProof
      (buildMerkleTree_with_hash leaf_data_tree hash) idx)
    (hash)) =
  (buildMerkleTree_with_hash leaf_data_tree hash).getRootValue

@[simp]
theorem embedSum_succ_succ {n : Fin (m + 1) ‚Üí ‚Ñï} {i : Fin m} (j : Fin (n i.succ)) :
    embedSum (i.succ) j = Fin.natAdd _ (embedSum i j)

@[simp]
theorem fappend_left {Œ± : Fin m ‚Üí A} {Œ≤ : Fin n ‚Üí A}
    (u : (i : Fin m) ‚Üí F (Œ± i)) (v : (i : Fin n) ‚Üí F (Œ≤ i)) (i : Fin m) :
    fappend u v (castAdd n i) = cast (by simp [vappend_left]) (u i)

@[simp]
lemma deevenize_coeff {f : Polynomial F} {n : ‚Ñï} :
    (deevenize f).coeff n = f.coeff (2 * n)

@[simp]
theorem bit_finProdFinEquiv_symm_2_pow_succ {n : ‚Ñï} (j : Fin (2 ^ (n + 1))) (i : Fin (n + 1)) :
  let e:=finProdFinEquiv (m:=2^(n)) (n:=2).symm
  Nat.getBit (i) j = if i.val > 0 then Nat.getBit (i.val-1) (e j).1 else (e j).2

lemma toOutCodewordsCount_last ‚Ñì œë : toOutCodewordsCount ‚Ñì œë (Fin.last ‚Ñì) = ‚Ñì / œë

lemma concrete_inv_zero {k : ‚Ñï} : concrete_inv (k:=k) 0 = 0

@[simp]
theorem BTField.Basis_cast_index_apply {Œ± Œ≤ i j : ‚Ñï} {k : Fin j} (h_le : Œ± ‚â§ Œ≤) (h_eq : i = j)
  {b : @Basis (Fin (i)) (BTField Œ±) (BTField Œ≤) _ _
    (@binaryAlgebraTower (l := Œ±) (r := Œ≤) (h_le := h_le)).toModule} :
  let castBasis : @Basis (Fin j) (BTField Œ±) (BTField Œ≤) _ _
    (@binaryAlgebraTower (l:=Œ±) (r:=Œ≤) (h_le:=h_le)).toModule :=
    cast (by exact BTField.Basis_cast_index_eq i j Œ± Œ≤ h_le h_eq) b
  (castBasis k) = b (Fin.cast (h_eq.symm) k)

lemma Q'_div_E'_eq_p
  [NeZero n]
  {E' Q' : Polynomial F}
  {œâs f : Fin n ‚Üí F}
  (hp_deg : p.natDegree < k)
  (he : 2 * e < n - k + 1)
  (hk_n : k ‚â§ n)
  (h_ham : (Œî‚ÇÄ(f, p.eval ‚àò œâs) : ‚Ñï) ‚â§ e)
  (h_diff : Function.Injective œâs)
  (h_Q' : Q' ‚â† 0)
  (hp : p ‚â† 0)
  (h_cond : BerlekampWelchCondition e k œâs f E' Q')
  : E' ‚à£ Q' ‚àß Q' / E' = p

theorem mul_two_eq_add {a : CNat 50} : a * 2 = a + a

@[simp]
lemma seqCompose_succ {m : ‚Ñï}
    (Stmt : Fin (m + 2) ‚Üí Type)
    {Œπ‚Çõ : Fin (m + 2) ‚Üí Type} (OStmt : (i : Fin (m + 2)) ‚Üí Œπ‚Çõ i ‚Üí Type)
    [O‚Çõ : ‚àÄ i, ‚àÄ j, OracleInterface (OStmt i j)]
    (Wit : Fin (m + 2) ‚Üí Type)
    {n : Fin (m + 1) ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    [O‚Çò : ‚àÄ i, ‚àÄ j, OracleInterface ((pSpec i).Message j)]
    (R : (i : Fin (m + 1)) ‚Üí
      OracleReduction oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Wit i.castSucc)
        (Stmt i.succ) (OStmt i.succ) (Wit i.succ) (pSpec i)) :
    seqCompose Stmt OStmt Wit R =
      append (R 0) (seqCompose (Stmt ‚àò Fin.succ) (fun i => OStmt (Fin.succ i)) (Wit ‚àò Fin.succ)
        (O‚Çõ := fun i => O‚Çõ (Fin.succ i)) (O‚Çò := fun i => O‚Çò (Fin.succ i))
          (fun i => R (Fin.succ i)))

@[simp]
lemma dfoldrM'_zero {Œ± : Fin 1 ‚Üí Type u}
    (f : (i : Fin 0) ‚Üí Œ± i.succ ‚Üí m (Œ± i.castSucc)) (x : Œ± (last 0)) :
    dfoldrM' 0 Œ± f x = pure x

@[simp]
lemma OracleReduction.id_toReduction :
    (OracleReduction.id : OracleReduction oSpec Statement OStatement Witness _ _ _ _).toReduction =
      Reduction.id

@[simp] lemma twoAdicGenerators_succ_square_eq' (idx : Fin twoAdicity) :
    twoAdicGenerators[idx.val + 1] ^ 2 = twoAdicGenerators[idx]

theorem ZMod.blub :
    ‚àÄ {n q c : ‚Ñï} (a : ZMod n), (decide (n ‚â• 2) = true) ‚Üí (decide (c < n) = true) ‚Üí
      (decide (c ‚â† 1) = true) ‚Üí IsNat (a ^ ((n - 1) / q)) c ‚Üí a ^ ((n - 1) / q) ‚â† 1

lemma degree_bound_bivariate
  (qPoly : Polynomial F)
  (hdeg_q_min : qPoly.natDegree > 0)
  (hdeg_q_max : qPoly.natDegree < Fintype.card F)
  {t : ‚Ñï} (Q : MvPolynomial (Fin 2) F)
  (hdegX : MvPolynomial.degreeOf 0 Q < t)
  (hdegY : MvPolynomial.degreeOf 1 Q < qPoly.natDegree) :
  (MvPolynomial.eval‚ÇÇHom (Polynomial.C : F ‚Üí+* Polynomial F)
      (fun i : Fin 2 => if i = 0 then qPoly else Polynomial.X) Q).natDegree < t * qPoly.natDegree

omit [CommSemiring ùîΩ] in
private lemma poly_eq_of [Field ùîΩ] {p q : ùîΩ[X]} {n : ‚Ñï}
      (hp : p.degree < .some n) (hq : q.degree < .some n) (s : Finset ùîΩ) :
    s.card ‚â• n ‚Üí (‚àÄ x ‚àà s, p.eval x = q.eval x) ‚Üí p = q

theorem eq_symm {Œ± : Type u} (mx my : m Œ±) : eq mx my ‚Üí eq my mx

lemma concrete_one_mul
  (prevBTFieldProps : ConcreteBTFieldProps (k := k - 1))
  (a : ConcreteBTField k) : concrete_mul (one (k:=k)) a = a

theorem seqCompose_rbrSoundness
    (lang : (i : Fin (m + 1)) ‚Üí Set (Stmt i))
    (V : (i : Fin m) ‚Üí Verifier oSpec (Stmt i.castSucc) (Stmt i.succ) (pSpec i))
    (rbrSoundnessError : ‚àÄ i, (pSpec i).ChallengeIdx ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (V i).rbrSoundness init impl (lang i.castSucc) (lang i.succ) (rbrSoundnessError i)) :
      (Verifier.seqCompose Stmt V).rbrSoundness init impl (lang 0) (lang (Fin.last m))
        (fun combinedIdx =>
          letI ij := seqComposeChallengeIdxToSigma combinedIdx
          rbrSoundnessError ij.1 ij.2)

lemma discr_of_irred_components_nonzero
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  : ‚àÉ x‚ÇÄ,
      ‚àÄ R ‚àà (irreducible_factorization_of_gs_solution h_gs).choose_spec.choose,
      Bivariate.evalX x‚ÇÄ (Bivariate.discr_y R) ‚â† 0

omit [CharP L 2] [DecidableEq ùîΩq] h_Œ≤‚ÇÄ_eq_1 [NeZero ùì°] in
lemma firstOracleWitnessConsistencyProp_relay_preserved (i : Fin ‚Ñì)
    (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) (wit : Witness (L := L) ùîΩq Œ≤
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i.succ)
    (oStmt : ‚àÄ j, OracleStatement ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) œë i.castSucc j) :
    firstOracleWitnessConsistencyProp ùîΩq Œ≤ wit.t (getFirstOracle ùîΩq Œ≤ oStmt) =
    firstOracleWitnessConsistencyProp ùîΩq Œ≤ wit.t
      (getFirstOracle ùîΩq Œ≤ (mapOStmtOutRelayStep ùîΩq Œ≤ i hNCR oStmt))

@[simp]
theorem MLE_eval_zeroOne (x : œÉ ‚Üí Fin 2) (evals : (œÉ ‚Üí Fin 2) ‚Üí R) :
    MvPolynomial.eval (x : œÉ ‚Üí R) (MLE evals) = evals x

theorem Nat.reconstruct_from_hi_and_lo_parts_or_ver (n hi_len lo_len : ‚Ñï)
  (h_n : n < 2 ^ (hi_len + lo_len)) :
    n = (((n >>> lo_len) % (2 ^ hi_len)) <<< lo_len) ||

theorem cast_Type_idx_symm {hn} (hSpec : pSpec‚ÇÅ.cast hn = pSpec‚ÇÇ) {i : Fin n‚ÇÇ} :
    pSpec‚ÇÅ.¬´Type¬ª (Fin.cast hn.symm i) = pSpec‚ÇÇ.¬´Type¬ª i

@[simp]
lemma domain_def : (spec Œ±).domain () = (Œ± √ó Œ±)

@[grind =] theorem findIdx'_cons {p : Œ± ‚Üí Bool} {x : Œ±} {xs : List Œ±} :
    findIdx' p (x :: xs) = bif p x then 0 else findIdx' p xs + 1

lemma definingPoly_is_not_unit {F : Type*} [Field F] [Fintype F] (s : F) [NeZero s] :
  ¬¨IsUnit (definingPoly s)

theorem liftContext_rbr_knowledgeSoundness [Inhabited InnerStmtOut] [Inhabited InnerWitIn]
    {outerRelIn : Set (OuterStmtIn √ó OuterWitIn)} {outerRelOut : Set (OuterStmtOut √ó OuterWitOut)}
    {innerRelIn : Set (InnerStmtIn √ó InnerWitIn)} {innerRelOut : Set (InnerStmtOut √ó InnerWitOut)}
    {rbrKnowledgeError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    {stmtLens : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut}
    {witLens : Witness.InvLens OuterStmtIn OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    (V : Verifier oSpec InnerStmtIn InnerStmtOut pSpec)
    [lensKS : Extractor.Lens.IsKnowledgeSound outerRelIn innerRelIn outerRelOut innerRelOut
      (V.compatStatement stmtLens) (fun _ _ => True) ‚ü®stmtLens, witLens‚ü©]
    (h : V.rbrKnowledgeSoundness init impl innerRelIn innerRelOut rbrKnowledgeError) :
      (V.liftContext stmtLens).rbrKnowledgeSoundness init impl outerRelIn outerRelOut
        rbrKnowledgeError

theorem fcons‚ÇÇ_left_injective {Œ±‚ÇÅ : A} {Œ±‚ÇÇ : B} {Œ≤‚ÇÅ : Fin n ‚Üí A} {Œ≤‚ÇÇ : Fin n ‚Üí B}
    (b : (i : Fin n) ‚Üí F‚ÇÇ (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) :
    Function.Injective (fun a : F‚ÇÇ Œ±‚ÇÅ Œ±‚ÇÇ => fcons‚ÇÇ (F := F‚ÇÇ) a b)

@[simp]
theorem fflatten‚ÇÇ_embedSum {A : Sort u} {B : Sort v} {F : A ‚Üí B ‚Üí Sort w} {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï}
    {Œ± : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí A}
    {Œ≤ : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí B}
    (v : (i : Fin m) ‚Üí (j : Fin (n i)) ‚Üí F (Œ± i j) (Œ≤ i j)) (i : Fin m) (j : Fin (n i)) :
    fflatten‚ÇÇ v (embedSum i j) = cast (by simp) (v i j)

theorem Basis_cast_dest_eq {Œπ : Type*} (k n m : ‚Ñï) (h_k_le_n : k ‚â§ n)
  (h_k_le_m : k ‚â§ m) (h_eq : m = n) :
  letI instLeftAlgebra := ConcreteBTFieldAlgebra (l:=k) (r:=m) (h_le:=h_k_le_m)
  letI instRightAlgebra := ConcreteBTFieldAlgebra (l:=k) (r:=n) (h_le:=h_k_le_n)
  @Basis Œπ (ConcreteBTField k) (ConcreteBTField m) _ _ instLeftAlgebra.toModule =
  @Basis Œπ (ConcreteBTField k) (ConcreteBTField n) _ _ instRightAlgebra.toModule

lemma inv_eq_pow (a : Field) (ha : a ‚â† 0) : a‚Åª¬π = a ^ (fieldSize - 2)

@[simp]
theorem rtake_self (v : (i : Fin n) ‚Üí Œ± i) :
    rtake n (by omega) v = fun i : Fin n => dcast (by simp [Fin.cast]) (v i)

lemma concrete_mul_assoc
  {h_k : k > 0} (prevBTFieldProps : ConcreteBTFieldProps (k := k - 1))
  (a b c : ConcreteBTField k) :
  concrete_mul (concrete_mul a b) c = concrete_mul a (concrete_mul b c)

theorem pred_succ {T : Type u} [HasSucc T] [Zero T] [ToNat T] (x : Cayley T) :
    pred (succ x) = x

@[simp] theorem rightpadPowerOfTwo_size (unit : Œ±) (a : Array Œ±) :
    (a.rightpadPowerOfTwo unit).size = 2 ^ (Nat.clog 2 a.size)

@[simp] theorem BitVec.dcast_zero {n m : ‚Ñï} (h : n = m) : DCast.dcast h (0#n) = 0#m

theorem split_zero {k : ‚Ñï} (h_pos : k > 0) : split h_pos zero = (zero, zero)

@[simp]
lemma eval‚ÇÇAlgHom_apply {A B : Type*} [CommSemiring A] [CommSemiring B] [MvPolynomialLike œÉ A P]
    [Algebra R A] [IsScalarTower R A P] [Algebra R B]
    (f : A ‚Üí‚Çê[R] B) (g : œÉ ‚Üí B) (p : P) :
    (eval‚ÇÇAlgHom f g) p = eval‚ÇÇ f g p

@[simp]
theorem vflatten_succ {m : ‚Ñï} {n : Fin (m + 1) ‚Üí ‚Ñï} {v : (i : Fin (m + 1)) ‚Üí Fin (n i) ‚Üí Œ±} :
    vflatten v = vappend (v 0) (vflatten (fun i => v i.succ))

lemma algebraMap_eq_zero_x {i j : ‚Ñï} (h_le : i < j) (x : BTField i) :
    letI instAlgebra := binaryAlgebraTower (l:=i) (r:=j) (h_le:=by omega)
    letI instAlgebraPred := binaryAlgebraTower (l:=i) (r:=j-1) (h_le:=by omega)
    algebraMap (BTField i) (BTField j) x
      = ‚ãò 0, algebraMap (BTField i) (BTField (j-1)) x ‚ãô

theorem dcast‚ÇÉ_symm (ha : a = a') (hb : dcast ha b = b') (hc : dcast‚ÇÇ ha hb c = c')
    (hd : dcast‚ÇÉ ha hb hc d = d') :
    dcast‚ÇÉ ha.symm (dcast_symm ha hb) (dcast‚ÇÇ_symm ha hb hc) d' = d

theorem oracleReduction_rbr_knowledge_soundness : True

omit h_Fq_char_prime in
theorem changeOfBasisMatrix_diag_ne_zero
  (‚Ñì : Nat) (h_‚Ñì : ‚Ñì ‚â§ r) :
  (‚àÄ i, (changeOfBasisMatrix ùîΩq Œ≤ ‚Ñì h_‚Ñì) i i ‚â† 0)

@[simp]
theorem fappend‚ÇÇ_succ {Œ±‚ÇÅ : Fin m ‚Üí A} {Œ±‚ÇÇ : Fin m ‚Üí B}
    {Œ≤‚ÇÅ : Fin (n + 1) ‚Üí A} {Œ≤‚ÇÇ : Fin (n + 1) ‚Üí B}
    (u : (i : Fin m) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i)) (v : (i : Fin (n + 1)) ‚Üí F‚ÇÇ (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) :
    fappend‚ÇÇ (F := F‚ÇÇ) u v =
      fconcat‚ÇÇ (F := F‚ÇÇ) (fappend‚ÇÇ (F := F‚ÇÇ) u (fun i => v (castSucc i))) (v (last n))

@[simp]
theorem BTField.Basis_cast_index_eq (i j k n : ‚Ñï) (h_le : k ‚â§ n) (h_eq : i = j) :
    letI instAlgebra : Algebra (BTField k) (BTField n)
      := binaryAlgebraTower (l:=k) (r:=n) (h_le:=h_le)
    letI : Module (BTField k) (BTField n) := instAlgebra.toModule
    (Basis (Fin (i)) (BTField k) (BTField n)) = (Basis (Fin (j)) (BTField k) (BTField n))

@[simp]
lemma finite_offDiag [Finite F] : C.offDiag.Finite

theorem completeness_error_mono {Œµ‚ÇÅ Œµ‚ÇÇ : ‚Ñù‚â•0} (hŒµ : Œµ‚ÇÅ ‚â§ Œµ‚ÇÇ) :
      completeness init impl relIn relOut reduction Œµ‚ÇÅ ‚Üí
        completeness init impl relIn relOut reduction Œµ‚ÇÇ

lemma sum_of_and_eq_zero_is_or {n m : ‚Ñï} (h_n_AND_m : n &&& m = 0) : n + m = n ||

lemma even_eval {f : Polynomial F} {s : F} (hEven : EvenPoly f) :
  f.eval (-s) = f.eval s

@[simp]
theorem acceptRejectRel_language : acceptRejectRel.language = { true }

theorem mulVecLin_coeff_vandermondens_eq_eval_matrixOfPolynomials
  {n : ‚Ñï} [NeZero n] {v : Œπ ‚Ü™ F} {p : F[X]} (h_deg : p.natDegree < n) :
  (Vandermonde.nonsquare (Œπ' := n) v).mulVecLin (Fin.liftF' p.coeff) =
  fun i => p.eval (v i)

@[grind =_]
lemma ne_zero_iff_coeffs_ne_zero (f : F[X][Y]) : f ‚â† 0 ‚Üî f.coeff ‚â† 0

@[simp]
theorem happend_empty {Œ± : Fin m ‚Üí Sort u} {Œ≤ : Fin 0 ‚Üí Sort u} (v : (i : Fin m) ‚Üí Œ± i) :
    happend v !h‚ü®Œ≤‚ü©[] = v

theorem unique_linear_decomposition_succ (k : ‚Ñï) :
  ‚àÄ (x : BTField (k+1)), ‚àÉ! (p : BTField k √ó BTField k),
    x = ‚ãò p.1, p.2 ‚ãô

theorem join_zero_one {k : ‚Ñï} (h_k : k > 0) :
    „Ää zero (k:=k - 1), one (k:=k - 1) „Äã = one (k:=k)

theorem toMvPolynomial_is_multilinear (p : MlPoly R n) :
  (toMvPolynomial p) ‚àà R‚¶É‚â§ 1‚¶Ñ[X Fin n]

@[simp]
theorem take_append_left :
    (pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).take m (Nat.le_add_right m n) = pSpec‚ÇÅ

theorem commitOracleVerifier_rbrKnowledgeSoundness (i : Fin ‚Ñì)
    (hCR : isCommitmentRound ‚Ñì œë i) :
    (commitOracleVerifier ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      i hCR).rbrKnowledgeSoundness init impl
      (relIn := foldStepRelOut (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i.succ)
      (commitKnowledgeError ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))

lemma BTField_is_BTFieldAux (k : ‚Ñï) :
  BTField k = (BinaryTowerAux k).1

lemma roots_comp_X_sub_C (p : L[X]) (a : L) :
    (p.comp (X - C a)).roots = p.roots.map (fun r => r + a)

lemma getBit_eq_succ_getBit_of_mul_two {n k : ‚Ñï} : getBit (k+1) (2*n) = getBit k n

theorem coreInteractionOracleReduction_perfectCompleteness (hInit : init.neverFails) :
    OracleReduction.perfectCompleteness
      (pSpec := pSpecCoreInteraction ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
      (relIn := roundRelation (mp := BBF_SumcheckMultiplierParam) ùîΩq Œ≤ (œë:=œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) 0)
      (relOut := finalSumcheckRelOut ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
      (oracleReduction := coreInteractionOracleReduction ùîΩq Œ≤ (œë:=œë) (ùìë:=ùìë))
      (init := init)
      (impl := impl)

theorem inverse_is_root_of_prevPoly
    {prevBTField : Type*} [Field prevBTField]
    {curBTField : Type*} [Field curBTField]
    (of_prev : prevBTField ‚Üí+* curBTField)
    (u : curBTField) (t1 : prevBTField)
    (specialElementNeZero : u ‚â† 0)
    (eval_prevPoly_at_root : u ^ 2 + of_prev t1 * u + 1 = 0)
    (h_eval : ‚àÄ (x : curBTField),
      eval‚ÇÇ of_prev x (X ^ 2 + (C t1 * X + 1)) = x ^ 2 + of_prev t1 * x + 1) :
    eval‚ÇÇ of_prev u‚Åª¬π (X ^ 2 + (C t1 * X + 1)) = 0

theorem GF_2_one_add_one_eq_zero : (1 + 1 : GF(2)) = 0

omit [Fintype L] [DecidableEq L] in
theorem Polynomial.comp_same_inner_eq_if_same_outer (f g : L[X]) (h_f_eq_g : f = g) :
  ‚àÄ x, f.comp x = g.comp x

theorem vappend_left_eq_cons (a : Fin 1 ‚Üí Œ±) (v : Fin n ‚Üí Œ±) :
    vappend a v = (vcons (a 0) v) ‚àò Fin.cast (Nat.add_comm 1 n)

theorem prime_17 : Nat.Prime 17

lemma num_eq_highBits_xor_lowBits {n: ‚Ñï} (numLowBits: ‚Ñï) :
  n = getHighBits numLowBits n ^^^ getLowBits numLowBits n

theorem vcons_left_injective (v : Fin n ‚Üí Œ±) : Function.Injective (fun a => a ::·µõ v)

@[simp]
lemma List.get_nil (i : Fin 0) (a : Œ±) : [].get i = a

private lemma errors_are_roots_of_E {i : Fin n}
  (h : f i ‚â† p.eval (œâs i)) : (E œâs f p e).eval (œâs i) = 0

@[simp]
theorem fappend‚ÇÇ_left {Œ±‚ÇÅ : Fin m ‚Üí A} {Œ±‚ÇÇ : Fin m ‚Üí B} {Œ≤‚ÇÅ : Fin n ‚Üí A} {Œ≤‚ÇÇ : Fin n ‚Üí B}
    (u : (i : Fin m) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i)) (v : (i : Fin n) ‚Üí F‚ÇÇ (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) (i : Fin m) :
    fappend‚ÇÇ (F := F‚ÇÇ) u v (castAdd n i) =
      cast (by simp [vappend_left]) (u i)

lemma eq_iff_eq_all_getBits {n m : ‚Ñï} : n = m ‚Üî ‚àÄ k, getBit k n = getBit k m

lemma rank_nonsquare_eq_deg_of_deg_le (inj : Function.Injective Œ±) (h : n ‚â§ m) :
  (Vandermonde.nonsquare (Œπ' := n) Œ±).rank = n

@[simp]
lemma range_def : (spec Œ±).range () = Œ±

lemma getMiddleBits_lt_two_pow {n offset len : ‚Ñï} :
  getMiddleBits offset len n < 2 ^ len

theorem happend_eq_addCases {Œ± : Fin m ‚Üí Sort u} {Œ≤ : Fin n ‚Üí Sort u}
    (u : (i : Fin m) ‚Üí Œ± i) (v : (i : Fin n) ‚Üí Œ≤ i) :
    happend u v = addCases (motive := vappend Œ± Œ≤)
      (fun i => cast (vappend_left Œ± Œ≤ i).symm (u i))
      (fun i => cast (vappend_right Œ± Œ≤ i).symm (v i))

theorem induction_tail {n : ‚Ñï} {motive : Fin (n + 2) ‚Üí Sort*} {zero : motive 0}
    {succ : ‚àÄ i : Fin (n + 1), motive i.castSucc ‚Üí motive i.succ} {i : Fin (n + 1)} :
      induction (motive := motive) zero succ i.succ =
        induction (motive := Fin.tail motive) (succ 0 zero) (fun j x => succ j.succ x) i

lemma getHighBits_no_shl_joinBits {n m : ‚Ñï} (low : Fin (2 ^ n)) (high : Fin (2 ^ m)) :
  getHighBits_no_shl n (joinBits low high).val = high.val

theorem eval_eq_eval_mv_eval_finSuccEquivNth (s : Fin n ‚Üí R) (y : R)
    (f : MvPolynomial (Fin (n + 1)) R) :
      eval (Fin.insertNth p y s : Fin (n + 1) ‚Üí R) f =
        Polynomial.eval y (Polynomial.map (eval s) (finSuccEquivNth R p f))

@[simp]
theorem poly_form (k : ‚Ñï) : poly k = X^2 + (C (Z k) * X + 1)

theorem prime_3 : Nat.Prime 3

omit [NeZero r] [Field L] [Fintype L] [DecidableEq L] [DecidableEq ùîΩq] [Field ùîΩq] [Algebra ùîΩq L] in
lemma base_coeffsBySuffix (a : Fin (2 ^ ‚Ñì) ‚Üí L) :
  coeffsBySuffix (r:=r) (R_rate := R_rate) a 0 0 = a

@[simp]
theorem LeafData.get_ofRight {s_left s_right : Skeleton} {Œ± : Type}
    (tree : LeafData Œ± (Skeleton.internal s_left s_right))
    (idxRight : SkeletonLeafIndex s_right) :
    tree.get (SkeletonLeafIndex.ofRight idxRight) =
      tree.rightSubtree.get idxRight

@[simp]
theorem runWithOracle_bind (f : spec.FunctionType)
    (oa : OracleComp spec Œ±) (ob : Œ± ‚Üí OracleComp spec Œ≤) :
    runWithOracle f (oa >>= ob) =
    (runWithOracle f oa) >>=
    (fun x => runWithOracle f (ob x))

private lemma x_times_oddPart'_eq_x_times_oddPart' {f : Polynomial F} :
    Polynomial.X * (oddPart' f) = x_times_oddPart' f

theorem linear_sum_repr (R : Type*) [CommRing R] (S : Type*) [CommRing S] [Algebra R S]
    (pb : PowerBasis R S) (h_dim : pb.dim = (2 : ‚Ñï)) (s : S) :
    ‚àÉ a b : R, s = a ‚Ä¢ pb.gen + algebraMap R S b

@[simp]
theorem ranges_nil : List.ranges [] = []

@[simp]
theorem FullData.internal_getRootValue {s_left s_right : Skeleton} {Œ± : Type}
    (value : Œ±) (left : FullData Œ± s_left) (right : FullData Œ± s_right) :
    (FullData.internal value left right).getRootValue =
      value

@[simp]
theorem dflatten_succ {m : ‚Ñï} {n : Fin (m + 1) ‚Üí ‚Ñï} {motive : (k : Fin (vsum n)) ‚Üí Sort*}
    {v : (i : Fin (m + 1)) ‚Üí (j : Fin (n i)) ‚Üí motive (embedSum i j)} :
    dflatten (motive := motive) v = dappend (v 0) (dflatten (fun i => v i.succ))

theorem ConcreteBTFieldAlgebra_apply_assoc (l mid r : ‚Ñï)
    (h_l_le_mid : l ‚â§ mid) (h_mid_le_r : mid ‚â§ r) :
    ‚àÄ x : ConcreteBTField l,
    (@ConcreteBTFieldAlgebra (l:=l) (r:=r) (h_le:=by
      exact Nat.le_trans h_l_le_mid h_mid_le_r)).algebraMap x =
    (@ConcreteBTFieldAlgebra (l:=mid) (r:=r) (h_le:=h_mid_le_r)).algebraMap
      ((@ConcreteBTFieldAlgebra (l:=l) (r:=mid) (h_le:=h_l_le_mid)).algebraMap x)

@[simp]
theorem removeNth_last : removeNth (Fin.last n) s = init s

lemma division_by_conjugate {a b : ‚Ñù} (hpos : 0 ‚â§ b) (hnonzero : a + b.sqrt ‚â† 0) :
  a - (b).sqrt = (a^2 - b)/(a + b.sqrt)

lemma if_zero_then_zero_else_self (x : ConcreteBTField 0) :
  (if x = zero then zero else x) = x

@[simp] theorem BitVec.dcast_one {n m : ‚Ñï} (h : n = m) : DCast.dcast h (1#n) = 1#m

lemma towerRingHomForwardMap_join {k : ‚Ñï} (h_pos : k > 0) (hi lo : ConcreteBTField (k - 1)) :
  towerRingHomForwardMap (k:=k) („Ää hi, lo „Äã) =
    BinaryTower.join_via_add_smul (k:=k) (h_pos:=by omega)
      (hi_btf := towerRingHomForwardMap (k:=k-1) hi)
      (lo_btf := towerRingHomForwardMap (k:=k-1) lo)

lemma oracle_block_k_next_le (i : Fin (‚Ñì + 1)) (j : Fin (toOutCodewordsCount ‚Ñì œë i))
    (hj : j.val + 1 < toOutCodewordsCount ‚Ñì œë i) : j.val * œë + œë ‚â§ i

@[simp]
theorem Prover.runToRound_one_of_prover_first [ProverOnly pSpec] (stmt : StmtIn) (wit : WitIn)
    (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      prover.runToRound 1 stmt wit = (do
        let state := prover.input (stmt, wit)
        let ‚ü®msg, state‚ü© ‚Üê liftComp (prover.sendMessage ‚ü®0, by simp‚ü© state) _
        return (fun i => match i with | ‚ü®0, _‚ü© => msg, state))

theorem towerEquiv_commutes_left (i j : ‚Ñï) (h : i ‚â§ j) : ‚àÄ r : ConcreteBTField i,
  (AlgebraTower.algebraMap i j h) ((towerEquiv i).ringEquiv r) =
  (towerEquiv j).ringEquiv ((AlgebraTower.algebraMap i j h) r)

theorem liftContext_rbr_soundness
    {rbrSoundnessError : pSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0}
    {lens : OracleStatement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                                OuterOStmtIn OuterOStmtOut InnerOStmtIn InnerOStmtOut}
    (V : OracleVerifier oSpec InnerStmtIn InnerOStmtIn InnerStmtOut InnerOStmtOut pSpec)
    [lensSound : lens.IsSound
      outerLangIn outerLangOut innerLangIn innerLangOut
      (V.toVerifier.compatStatement lens)]
    (h : V.rbrSoundness init impl innerLangIn innerLangOut rbrSoundnessError) :
      (V.liftContext lens).rbrSoundness init impl outerLangIn outerLangOut rbrSoundnessError

@[simp] theorem ofNat_toNat (t : AssocNat) : ofNat (toNat t) = t

theorem vcons_inj (a b : Œ±) (v w : Fin n ‚Üí Œ±) : a ::·µõ v = b ::·µõ w ‚Üî a = b ‚àß v = w

omit [DecidableEq ùîΩq] hF‚ÇÇ h_Œ≤‚ÇÄ_eq_1 in
lemma get_sDomain_first_basis_eq_1 (i : Fin r) (h_i : i < ‚Ñì + R_rate) :
    (sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate
    i (by omega)) ‚ü®0, by omega‚ü© = (1: L)

Nat.mul_le_mul_right in Init.Data.Nat.Basic

omit [Finite F] in
private lemma gen_def {i : ‚Ñï} :
    (IsCyclicWithGen.gen : evalDomain D i) =
      ‚ü®
        DIsCyclicC.gen ^ (2 ^ i),
        by
          apply pow_2_pow_i_mem_Di_of_mem_D
          exact DIsCyclicC.gen.2
      ‚ü©

theorem fconcat‚ÇÇ_inj {Œ±‚ÇÅ : Fin n ‚Üí A} {Œ±‚ÇÇ : Fin n ‚Üí B} {Œ≤‚ÇÅ : A} {Œ≤‚ÇÇ : B}
    (v‚ÇÅ v‚ÇÇ : (i : Fin n) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i)) (a‚ÇÅ a‚ÇÇ : F‚ÇÇ Œ≤‚ÇÅ Œ≤‚ÇÇ) :
    fconcat‚ÇÇ (F := F‚ÇÇ) v‚ÇÅ a‚ÇÅ = fconcat‚ÇÇ (F := F‚ÇÇ) v‚ÇÇ a‚ÇÇ ‚Üî v‚ÇÅ = v‚ÇÇ ‚àß a‚ÇÅ = a‚ÇÇ

theorem commit_eq {a : ZMod p} (hpG1 : Nat.card G‚ÇÅ = p)
    (poly : degreeLT (ZMod p) (n + 1)) :
    commit (towerOfExponents g‚ÇÅ a n) (degreeLTEquiv _ _ poly) = g‚ÇÅ ^ (poly.1.eval a).val

@[simp]
lemma toPolynomialAlgHom_X : toPolynomialAlgHom (X : P) = Polynomial.X

theorem non_zero_map [LawfulBEq R] (f : R ‚Üí R) (hf : ‚àÄ r, f r = 0 ‚Üí r = 0) (p : UniPoly R) :
  let fp := UniPoly.mk (p.map f);
  p.trim = p ‚Üí fp.trim = fp

@[simp]
theorem InternalData.leftSubtree_internal {Œ±} {s_left s_right : Skeleton}
    (value : Œ±) (left : InternalData Œ± s_left) (right : InternalData Œ± s_right) :
    (InternalData.internal value left right).leftSubtree = left

lemma probOfBadPts {deg : ‚Ñï} {Œ± : Œπ ‚Ü™ F} {e : ‚Ñï} {U : Matrix Œ∫ Œπ F}
  (he : (e : ‚Ñö) < (Code.minDist (RScodeSet Œ± deg) : ‚Ñö) / 3)
  (hU : e < Œî(U, matrixSubmoduleOfLinearCode Œ∫ (ReedSolomon.code Œ± deg))) :
  (PMF.uniformOfFintype (Matrix.rowSpan U)).toOuterMeasure
    { w | distFromCode (n := Œπ) (R := F) w (ReedSolomon.code Œ± deg) ‚â§ e }
  ‚â§ (Code.minDist (RScodeSet Œ± deg) : ‚Ñù‚â•0) /(Fintype.card F : ‚Ñù‚â•0)

theorem sum_zero_iff_eq_of_self_sum_zero {F : Type*} [AddGroup F]
  (h_self_sum_eq_zero : ‚àÄ (x : F), x + x = 0) : ‚àÄ (x y : F), x + y = 0 ‚Üî x = y

@[simp]
theorem bit_revFinProdFinEquiv_symm_2_pow_succ {n : ‚Ñï} (j : Fin (2 ^ (n + 1))) (i : Fin (n + 1)):
  let e : Fin (2 ^ n * 2) ‚âÉ Fin (2 ^ n) √ó Fin 2 :=revFinProdFinEquiv (m:=2^(n)) (n:=2)
    (h_m:=by exact Nat.two_pow_pos n).symm
  let msb : Fin 2 := (e j).2
  let lsbs : Fin (2 ^ n) := (e j).1
  Nat.getBit (i) j = if i.val < n then Nat.getBit (i.val) lsbs else msb

lemma sDomainBasisVectors_mem_sDomain (i : Fin r) (k : Fin (‚Ñì + R_rate - i)) :
  sDomainBasisVectors ùîΩq Œ≤ h_‚Ñì_add_R_rate i k
    ‚àà sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i

theorem hconcat_right_injective {Œ± : Fin n ‚Üí Sort u} {Œ≤ : Sort u} (v : (i : Fin n) ‚Üí Œ± i) :
    Function.Injective (hconcat v : Œ≤ ‚Üí (i : Fin (n + 1)) ‚Üí vconcat Œ± Œ≤ i)

theorem degreeOf_X_le (i j : œÉ) : degreeOf i (X (R := R) j) ‚â§ 1

theorem cast_eq_dcast‚ÇÇ {V : Verifier oSpec StmtIn StmtOut pSpec‚ÇÅ} :
    V.cast hn hSpec = dcast‚ÇÇ hn hSpec V

theorem vappend_succ (u : Fin m ‚Üí Œ±) (v : Fin (n + 1) ‚Üí Œ±) :
    vappend u v = vconcat (vappend u (v ‚àò castSucc)) (v (last n))

omit [DecidableEq ùîΩq] hF‚ÇÇ in
lemma initial_tiled_coeffs_correctness (h_‚Ñì : ‚Ñì ‚â§ r) (a : Fin (2 ^ ‚Ñì) ‚Üí L) :
    let b: Fin (2^(‚Ñì + R_rate)) ‚Üí L := tileCoeffs a
    additiveNTTInvariant ùîΩq Œ≤ h_‚Ñì_add_R_rate b a (i := ‚ü®‚Ñì, by omega‚ü©)

@[simp]
theorem runWithOracle_freeMonad_pure_some (f : spec.FunctionType) (a : Œ±) :
    runWithOracle f (FreeMonad.pure (a : Option Œ±)) = a

@[simp]
theorem vcons_one (a : Œ±) (v : Fin (n + 1) ‚Üí Œ±) : (a ::·µõ v) 1 = v 0

theorem srSoundness_implies_soundness
    (langIn : Set StmtIn) (langOut : Set StmtOut)
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    (srInit : ProbComp (srChallengeOracle StmtIn pSpec).FunctionType)
    (srImpl : QueryImpl oSpec (StateT (srChallengeOracle StmtIn pSpec).FunctionType ProbComp))
    (srSoundnessError : ‚Ñù‚â•0) :
      Verifier.StateRestoration.soundness srInit srImpl langIn langOut verifier srSoundnessError ‚Üí
        soundness init impl langIn langOut verifier srSoundnessError

@[simp]
lemma natDegree_truncate [œÜ : NeZero n] : (truncate p n).natDegree < n

@[simp]
theorem dcast‚ÇÇ_eq' (h : a = a) (h' : dcast h b = b) : dcast‚ÇÇ h h' c = c

theorem self_sum_eq_zero
    {prevBTField : Type*} [CommRing prevBTField]
    (sumZeroIffEqPrev : ‚àÄ (x y : prevBTField), x + y = 0 ‚Üî x = y)
    (prevPoly : Polynomial prevBTField)
    (hf_deg : prevPoly.natDegree = 2)
    (hf_monic : Monic prevPoly) :
    ‚àÄ (x : AdjoinRoot prevPoly), x + x = 0

theorem mul_assoc (m n p : ChurchNat Œ±) : mul (mul m n) p = mul m (mul n p)

@[simp] theorem rightpad_length (n : Nat) (unit : Œ±) (l : List Œ±) :
    (rightpad n unit l).length = max n l.length

protected lemma elocPolyF_ne_zero {œâs f : Fin m ‚Üí F} :
  ElocPolyF œâs f p ‚â† 0

@[simp]
theorem divide_by_2_mem {s : Finset ‚Ñï} {d : ‚Ñï} :
  d ‚àà divide_by_2 s ‚Üî 2 * d ‚àà s

theorem mobius_apply_zeta_apply_eq_id (n : ‚Ñï) [NeZero n] (r : Fin n) (l : Fin (r.val + 1))
    (v : Vector R (2 ^ n)) : lagrangeToMono_segment n r l (monoToLagrange_segment n r l v) = v

@[simp]
lemma zero_mem_relHammingDistRange : 0 ‚àà relHammingDistRange Œπ

@[simp]
lemma coeff_polynomialOfCoeffs_eq_coeffs :
  Fin.liftF' (polynomialOfCoeffs coeffs).coeff = coeffs

@[to_additive vsum_castSucc]
lemma vprod_castSucc [CommMonoid Œ±] {a : Fin (n + 1) ‚Üí Œ±} :
    vprod a = vprod (a ‚àò Fin.castSucc) * a (last n)

theorem eqPolynomial_degreeOf (r : œÉ ‚Üí R) (i : œÉ) : degreeOf i (eqPolynomial r) ‚â§ 1

theorem computableAdditiveNTT_eq_additiveNTT (a : Fin (2 ^ ‚Ñì) ‚Üí L) :
  computableAdditiveNTT (ùîΩq := ùîΩq) (Œ≤ := Œ≤) (‚Ñì := ‚Ñì) (R_rate := R_rate)
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (a := a) =
  additiveNTT (ùîΩq := ùîΩq) (L := L) (Œ≤ := Œ≤) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (a := a)

@[simp]
lemma seqCompose_zero (Stmt : Fin 1 ‚Üí Type) (Wit : Fin 1 ‚Üí Type)
    {n : Fin 0 ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (R : (i : Fin 0) ‚Üí
      Reduction oSpec (Stmt i.castSucc) (Wit i.castSucc) (Stmt i.succ) (Wit i.succ) (pSpec i)) :
    seqCompose Stmt Wit R = Reduction.id

@[simp]
theorem insertNth_zero_zero : insertNth p 0 (0 : Fin n ‚Üí‚ÇÄ M) = 0

theorem append_comp {a : Fin m ‚Üí Œ±} {b : Fin n ‚Üí Œ±} (f : Œ± ‚Üí Œ≤) :
    append (f ‚àò a) (f ‚àò b) = f ‚àò append a b

theorem zero_add (n : ChurchNat Œ±) : add zero n = n

@[simp]
private lemma leadingCoeff_E : (E œâs f p e).leadingCoeff = 1

omit [NeZero ‚Ñì] [NeZero r] [NeZero ùì°] in
lemma fin_‚Ñì_lt_r {h_‚Ñì_add_R_rate : ‚Ñì + ùì° < r} (i : Fin ‚Ñì)
    : i.val < r

theorem sumcheckFoldOracleReduction_perfectCompleteness (hInit : init.neverFails) :
    OracleReduction.perfectCompleteness
      (pSpec := pSpecSumcheckFold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
      (relIn := roundRelation (mp := mp) ùîΩq Œ≤ (œë:=œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) 0)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë:=œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) (Fin.last ‚Ñì))
      (oracleReduction := sumcheckFoldOracleReduction ùîΩq Œ≤ (œë:=œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë))
      (init := init)
      (impl := impl)

theorem commitOracleReduction_perfectCompleteness (hInit : init.neverFails) (i : Fin ‚Ñì)
    (hCR : isCommitmentRound ‚Ñì œë i) :
    OracleReduction.perfectCompleteness
      (pSpec := pSpecCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)
      (relIn := foldStepRelOut (mp := mp) ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        (ùìë := ùìë) i)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        (ùìë := ùìë) i.succ)
      (oracleReduction := commitOracleReduction ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hCR)
      (init := init)
      (impl := impl)

theorem singleton_subset_Icc (n : ‚Ñï) : {1} ‚äÜ Finset.Icc 1 (n + 1)

lemma toPoly_trim [LawfulBEq R] {p : UniPoly R} : p.trim.toPoly = p.toPoly

@[simp] lemma extract_dir : pSpec‚ü¶start:stop‚üß.dir = pSpec.dir‚ü¶start:stop‚üß

omit [Fintype L] [DecidableEq L] [Fintype ùîΩq] h_Fq_char_prime hŒ≤_lin_indep in
theorem root_U_lift_up (i : Fin r) (h_i_add_1 : i + 1 < r) (a : L) (x : ùîΩq) :
  a - x ‚Ä¢ Œ≤ i ‚àà (U ùîΩq Œ≤ i) ‚Üí a ‚àà (U ùîΩq Œ≤ (i+1))

omit [Finite F] in
lemma domain_surjective (i : ‚Ñï) : i ‚â§ n ‚Üí Function.Surjective (domain D n i)

lemma pow_inj {i : ‚Ñï} {a b : Fin (2 ^ (n - i))} :
    i ‚â§ n ‚Üí (DIsCyclicC.gen.1 ^ 2 ^ i) ^ a.1 = (DIsCyclicC.gen.1 ^ 2 ^ i) ^ b.1 ‚Üí a = b

@[simp]
theorem seqCompose_succ_dir {m : ‚Ñï} {n : Fin (m + 1) ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)} :
    (seqCompose pSpec).dir = Fin.vflatten (fun i => (pSpec i).dir)

congrArg in Init.Prelude

@[simp]
lemma natDegree_polynomialOfCoeffs_deg_lt_deg
  [NeZero deg] {coeffs : Fin deg ‚Üí F} :
  (polynomialOfCoeffs coeffs).natDegree < deg

lemma and_shl_eq_zero_of_lt_two_pow {a n b : ‚Ñï} (hb : b < 2 ^ n) : (a <<< n) &&& b = 0

@[simp]
theorem snoc_last : snoc s y (Fin.last n) = y

lemma concrete_div_eq_mul_inv {k : ‚Ñï} (a b : ConcreteBTField k) : a / b = a * (concrete_inv b)

lemma coeff_vectors_linear_independent
  (‚Ñì : Nat) (h_‚Ñì : ‚Ñì ‚â§ r) :
    LinearIndependent L (toCoeffsVec (‚Ñì := ‚Ñì) ‚àò (basisVectors ùîΩq Œ≤ ‚Ñì h_‚Ñì))

@[simp]
lemma OracleReduction.append_toReduction
    (R‚ÇÅ : OracleReduction oSpec Stmt‚ÇÅ OStmt‚ÇÅ Wit‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ Wit‚ÇÇ pSpec‚ÇÅ)
    (R‚ÇÇ : OracleReduction oSpec Stmt‚ÇÇ OStmt‚ÇÇ Wit‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ Wit‚ÇÉ pSpec‚ÇÇ) :
      (OracleReduction.append R‚ÇÅ R‚ÇÇ).toReduction =
        Reduction.append R‚ÇÅ.toReduction R‚ÇÇ.toReduction

@[simp]
theorem drop_all (v : (i : Fin n) ‚Üí Œ± i) :
    drop n n.le_refl v = fun i => Fin.elim0 (i.cast (Nat.sub_self n))

lemma IsBerlekampWelchSolution_def
  : IsBerlekampWelchSolution e k œâs f v
  ‚Üî Matrix.mulVec (BerlekampWelchMatrix e k œâs f) v = (Rhs e œâs f)

@[simp]
lemma getTypes_cons (x : Œ£ Œ± : Type u, Œ±) (xs : HList) :
    getTypes (x :: xs) = x.1 :: xs.getTypes

@[simp]
theorem BTField.RingHom_eq_of_dest_AdjoinRoot_eq (k m : ‚Ñï) :
  (BTField k ‚Üí+* BTField (m+1)) = (BTField k ‚Üí+* (AdjoinRoot (poly m)))

@[simp]
theorem cast_idx {i : ChallengeIdx pSpec‚ÇÅ} :
    pSpec‚ÇÇ.Challenge (i.cast hn hSpec) = pSpec‚ÇÅ.Challenge i

theorem vcons_eq_cons (a : Œ±) (v : Fin n ‚Üí Œ±) : a ::·µõ v = cons a v

theorem finrank_degreeLT_n (n : ‚Ñï) : Module.finrank L (L‚¶É< n‚¶Ñ[X]) = n

@[simp] theorem join_cons : (l :: ls).join = l ++ ls.join

lemma algebraMap_ConcreteBTFieldAlgebra_def (l r : ‚Ñï) (h_le : l ‚â§ r) :
    (@ConcreteBTFieldAlgebra (l:=l) (r:=r) (h_le:=h_le)).algebraMap
    = concreteTowerAlgebraMap l r h_le

lemma sum_insertNth' [AddCommMonoid M] [AddCommMonoid N] {n : ‚Ñï} (œÉ : Fin n ‚Üí‚ÇÄ M) (i : M)
    (p : Fin (n + 1)) (f : Fin (n+1) ‚Üí M ‚Üí N) (h : ‚àÄ x, f x 0 = 0) :
    sum (insertNth p i œÉ) f = f p i + sum œÉ (Fin.removeNth p f)

@[simp]
lemma Rhs_add_one : Rhs (e + 1) œâs f = fun i ‚Ü¶ Rhs e œâs f i * œâs i

omit [Finite F] in
lemma minus_one_in_doms {i : ‚Ñï} (h : i < n) :
    -1 ‚àà evalDomain D i

lemma geometric_sum_units {F : Type*} [Field F] [DecidableEq F] {r : FÀ£} {a : ‚Ñï} :
  ‚àë j ‚àà range (a + 1), (r ^ j : F) =
    if r = 1 then (a + 1 : F)
    else (1 - r ^ (a + 1)) / (1 - r)

lemma isField_of_irreducible {H : F[X][Y]} : Irreducible H ‚Üí IsField (ùïÉ H)

theorem add_comm : p + q = q + p

@[simp]
theorem bool_accepts_iff : (bool j).accepts x ‚Üî x j * (x j - 1) = 0

theorem matchSize_eq_iff_forall_eq (l‚ÇÅ l‚ÇÇ : List Œ±) (unit : Œ±) :
    (fun (x, y) => x = y) (matchSize l‚ÇÅ l‚ÇÇ unit) ‚Üî ‚àÄ i : Nat, l‚ÇÅ.getD i unit = l‚ÇÇ.getD i unit

private lemma k_choose_2 [Zero F] {B : Finset (Fin n ‚Üí F)}
  (h_n : n ‚â† 0)
  (h_B : B.card ‚â† 0)
  :
  n * choose_2 (k B) ‚â§ ‚àë i, choose_2 (K B i 0)

@[simp] theorem join_nil : List.join ([] : List (List Œ±)) = []

theorem cast_run (stmt : StmtIn) (wit : WitIn) :
    R.run stmt wit = cast (sorry) ((R.cast hn hSpec).run stmt wit)

Nat.lt_of_le_of_lt in Init.Prelude

@[simp]
theorem dcons_succ {motive : Fin (n + 1) ‚Üí Sort u} (a : motive 0)
    (v : (i : Fin n) ‚Üí motive i.succ) (i : Fin n) : (a ::·µà‚ü®motive‚ü© v) i.succ = v i

private lemma almost_johnson [Zero F]
  (h_n : 0 < n)
  (h_B : 2 ‚â§ B.card)
  (h_card : 2 ‚â§ (Fintype.card F))
  :
  n * (choose_2 (k B) + (Fintype.card F - 1)
    * choose_2 ((B.card - k B) / (Fintype.card F - 1)))
  ‚â§
  choose_2 B.card * (n - d B)

lemma BerlekampWelch_Q_ne_zero {e k : ‚Ñï}
  [NeZero n]
  {œâs f : Fin n ‚Üí F}
  {E Q : Polynomial F}
  (h_bw : BerlekampWelchCondition e k œâs f E Q)
  (h_dist : e < Œî‚ÇÄ(f, 0))
  (h_inj : Function.Injective œâs)
  : Q ‚â† 0

lemma getBit_eq_zero_or_one {k n : Nat} :
  getBit k n = 0 ‚à® getBit k n = 1

lemma W_add_U_invariant
  (i : Fin r) :
  ‚àÄ x : L, ‚àÄ y ‚àà U ùîΩq Œ≤ i, (W ùîΩq Œ≤ i).eval (x + y) = (W ùîΩq Œ≤ i).eval x

theorem fullOracleReduction_perfectCompleteness (hInit : init.neverFails) :
  OracleReduction.perfectCompleteness
    (oracleReduction := fullOracleReduction ùîΩq Œ≤ Œ≥_repetitions (œë:=œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë))
    (relIn := roundRelation (mp := BBF_SumcheckMultiplierParam) ùîΩq Œ≤ (œë:=œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) 0)
    (relOut := acceptRejectOracleRel)
    (init := init)
    (impl := impl)

theorem happend_assoc {Œ± : Fin m ‚Üí Sort u} {Œ≤ : Fin n ‚Üí Sort u} {p : ‚Ñï} {Œ≥ : Fin p ‚Üí Sort u}
    (u : (i : Fin m) ‚Üí Œ± i) (v : (i : Fin n) ‚Üí Œ≤ i) (w : (i : Fin p) ‚Üí Œ≥ i) :
    happend (happend u v) w =
      fun i => cast (by simp [vappend_assoc])
        (happend u (happend v w) (i.cast (by omega)))

@[simp]
lemma Transcript.def_eq {k : Fin (n + 1)} {pSpec : ProtocolSpec n} :
    (pSpec.take k k.is_le).FullTranscript =
      ((i : Fin k) ‚Üí pSpec.¬´Type¬ª (Fin.castLE (by omega) i))

@[simp]
theorem hflatten_one {n : Fin 1 ‚Üí ‚Ñï} {Œ± : (i : Fin 1) ‚Üí (j : Fin (n i)) ‚Üí Sort*}
    {v : (i : Fin 1) ‚Üí (j : Fin (n i)) ‚Üí Œ± i j} : hflatten v = v 0

@[simp]
theorem init_update_castSucc : init (update s i.castSucc y) = update (init s) i y

private lemma eval_solutionToQ_aux {i : Fin ((solutionToQ e k v).natDegree + 1)} [NeZero e]
  : e + i < 2 * e + k

theorem dinit_hconcat {Œ± : Fin n ‚Üí Sort u} {Œ≤ : Sort u} (v : (i : Fin n) ‚Üí Œ± i) (b : Œ≤) :
    True

theorem Fin.sum_univ_odd_even {n : ‚Ñï} {M : Type*} [AddCommMonoid M] (f : ‚Ñï ‚Üí M) :
    (‚àë i : Fin (2 ^ n), f (2 * i)) + (‚àë i : Fin (2 ^ n), f (2 * i + 1))
    = ‚àë i: Fin (2 ^ (n+1)), f i

Fin.coe_castSucc in Init.Data.Fin.Lemmas

theorem dconcat_left_injective {motive : Fin (n + 1) ‚Üí Sort u} (a : motive (last n)) :
    Function.Injective (fun v => dconcat (motive := motive) v a)

theorem decoder_dist_impl_mem
  {k r D e : ‚Ñï}
  (h_e : e ‚â§ n - Real.sqrt (k * n))
  {œâs : Fin n ‚Ü™ F}
  {f : Fin n ‚Üí F}
  {p : F[X]}
  (h_dist : Œî‚ÇÄ(f, p.eval ‚àò œâs) ‚â§ e)
  :
  p ‚àà decoder k r D e œâs f

lemma bwm_of_pos [NeZero n] (h : j.1 < e) :
  BerlekampWelchMatrix e k œâs f i j = -Rhs j.1 œâs f i

@[simp]
lemma Verifier.id_rbrKnowledgeSoundness {rel : Set (Statement √ó Witness)} :
    (Verifier.id : Verifier oSpec Statement _ _).rbrKnowledgeSoundness
      init impl rel rel 0

theorem PrattPartList.out {p : ‚Ñï} {a : ZMod p} {n : ‚Ñï} (h : PrattPartList p a n) :
    ‚àÄ q : ‚Ñï, q.Prime ‚Üí q ‚à£ n ‚Üí a ^ ((p - 1) / q) ‚â† 1

lemma eqRec_sort_eqRec_fun_eq_self {Œ± : Sort*} {Œ≤ : Œ± ‚Üí Sort u} {a a' : Œ±}
    (h : a = a') (h' : Œ≤ a = Œ≤ a') (b : Œ≤ a) :
  b = h' ‚ñ∏ h ‚ñ∏ b

Nat.le_of_succ_le in Init.Data.Nat.Basic

omit O‚Çò in
theorem seqCompose_perfectCompleteness (hInit : init.neverFails)
    (rel : (i : Fin (m + 1)) ‚Üí Set (Stmt i √ó Wit i))
    (R : ‚àÄ i, Reduction oSpec (Stmt i.castSucc) (Wit i.castSucc) (Stmt i.succ) (Wit i.succ)
      (pSpec i))
    (h : ‚àÄ i, (R i).perfectCompleteness init impl (rel i.castSucc) (rel i.succ)) :
      (Reduction.seqCompose Stmt Wit R).perfectCompleteness
        init impl (rel 0) (rel (Fin.last m))

@[simp]
theorem Fin.cast_val_eq_val {n m : ‚Ñï} [NeZero n] (a : Fin n) (h_eq : n = m):
  (Fin.cast (h_eq) a).val = a.val

lemma coe_one_succ (l : ‚Ñï) :
    (@ConcreteBTFieldAlgebra (l:=l) (r:=l + 1) (h_le:=by omega)).algebraMap
    (1 : ConcreteBTField l) = (1 : ConcreteBTField (l + 1))

theorem cast_eq_dcast {h : n‚ÇÅ = n‚ÇÇ} {pSpec : ProtocolSpec n‚ÇÅ} :
    pSpec.cast h = dcast h pSpec

omit [Finite F] in
lemma one_in_doms (i : ‚Ñï) : 1 ‚àà evalDomain D i

lemma getBit_of_shiftLeft {n p : ‚Ñï}:
  ‚àÄ k, getBit (k) (n <<< p) = if k < p then 0 else getBit (k - p) n

lemma cRank_rank_conversion :
  ‚Üë(U.rank) = U.cRank

lemma Fin.val_add_one' (a : Fin r) (h_a_add_1 : a + 1 < r) : (a + 1).val = a.val + 1

lemma runWithOracle_getPutativeRoot {s} (idx : BinaryTree.SkeletonLeafIndex s)
    (leafValue : Œ±) (proof : List Œ±) (f) :
    (runWithOracle f (getPutativeRoot idx leafValue proof))
      =
    getPutativeRoot_with_hash idx leafValue proof fun (left right : Œ±) => (f () ‚ü®left, right‚ü©)

lemma dist_eq_minWtCodewords [CommRing F] {LC : LinearCode Œπ F} :
  Code.minDist (LC : Set (Œπ ‚Üí F)) = minWtCodewords LC

lemma fold_f_g_poly
  {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F} {k m : ‚Ñï}
  {œÜ_0 : (indexPowT S œÜ 0) ‚Ü™ F} {œÜ_k : (indexPowT S œÜ k) ‚Ü™ F}
  [Fintype (indexPowT S œÜ 0)] [DecidableEq (indexPowT S œÜ 0)] [Smooth œÜ_0]
  [Fintype (indexPowT S œÜ k)] [DecidableEq (indexPowT S œÜ k)] [Smooth œÜ_k]
  [‚àÄ i : ‚Ñï, Neg (indexPowT S œÜ i)]
  (Œ±s : Fin k ‚Üí F) (hk : k ‚â§ m)
  (f : smoothCode œÜ_0 m) (g : smoothCode œÜ_k (m-k)) :
  let fPoly

@[simp]
lemma bIdx_mul_œë_add_i_lt_‚Ñì_succ {m : ‚Ñï} (bIdx : Fin (‚Ñì / œë - 1)) (i : Fin œë) :
    ‚ÜëbIdx * œë + ‚Üëi < ‚Ñì + m

@[simp, grind] lemma fin_chunkSize_lt_N (arrSize : Nat) (i : Fin (min arrSize SpongeSize.R)) :
    i < SpongeSize.N

lemma eq_degree_of_equiv [LawfulBEq R] {p q : UniPoly R} : equiv p q ‚Üí p.degree = q.degree

Fin.is_le in Init.Data.Fin.Lemmas

omit h_Œ≤‚ÇÄ_eq_1 in
theorem sDomainFin_bijective (i : Fin r) (h_i : i < ‚Ñì + R_rate)
: Function.Bijective
  (sDomainFinEquiv ùîΩq Œ≤ h_‚Ñì_add_R_rate i h_i)

theorem one_mul (n : ChurchNat Œ±) : mul one n = n

theorem range_vcons {Œ± : Type*} (a : Œ±) (v : Fin n ‚Üí Œ±) :
    Set.range (a ::·µõ v) = insert a (Set.range v)

@[simp]
theorem LeafData.rightSubtree_internal {Œ±} {s_left s_right : Skeleton}
    (left : LeafData Œ± s_left) (right : LeafData Œ± s_right) :
    (LeafData.internal left right).rightSubtree = right

@[simp]
lemma seqCompose_toVerifier {m : ‚Ñï}
    (Stmt : Fin (m + 1) ‚Üí Type)
    {Œπ‚Çõ : Fin (m + 1) ‚Üí Type} (OStmt : (i : Fin (m + 1)) ‚Üí Œπ‚Çõ i ‚Üí Type)
    [O‚Çõ : ‚àÄ i, ‚àÄ j, OracleInterface (OStmt i j)]
    {n : Fin m ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    [O‚Çò : ‚àÄ i, ‚àÄ j, OracleInterface ((pSpec i).Message j)]
    (V : (i : Fin m) ‚Üí
      OracleVerifier oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Stmt i.succ) (OStmt i.succ)
        (pSpec i)) :
    (seqCompose Stmt OStmt V).toVerifier =
      Verifier.seqCompose (fun i => Stmt i √ó (‚àÄ j, OStmt i j)) (fun i => (V i).toVerifier)

omit [CharP L 2] [DecidableEq ùîΩq] hF‚ÇÇ h_Œ≤‚ÇÄ_eq_1 [NeZero ‚Ñì] in
theorem card_qMap_total_fiber (i : Fin ‚Ñì) (steps : ‚Ñï) (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
    (y : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i.val + steps, by omega‚ü©)) :
    Fintype.card (Set.image (qMap_total_fiber ùîΩq Œ≤ (i := ‚ü®i, by omega‚ü©) (steps := steps)
      (h_i_add_steps := by simp only; exact fin_‚Ñì_steps_lt_‚Ñì_add_R i steps h_i_add_steps)
      (y := y)) Set.univ) = 2 ^ steps

lemma qCompositionChain_eq_foldl (i : Fin r) :
  qCompositionChain ùîΩq Œ≤ (‚Ñì:=‚Ñì) (R_rate:=R_rate) i =
  Fin.foldl (n:=i) (fun acc j =>
    (qMap ùîΩq Œ≤ ‚ü®j, by omega‚ü©).comp acc) (X)

@[simp]
theorem leftpad_apply_lt (n : ‚Ñï) (a : Œ±) (v : Fin m ‚Üí Œ±) (i : Fin n)
    (h : i.val < n - m) : leftpad n a v i = a

theorem runWithOracle_succeeds_iff_simulateQ_randomOracle_neverFails
     {Œ≤}
    [DecidableEq Œπ] [spec.DecidableEq] [(i : Œπ) ‚Üí SelectableType (OracleSpec.range spec i)]
    (oa : OracleComp (spec) Œ≤) (f : spec.FunctionType) :
    (runWithOracle f oa).isSome ‚Üî
    ((oa.simulateQ randomOracle).run (fun i q => some (f i q))).neverFails

lemma rootMultiplicity_W (i : Fin r) (a : L) :
    rootMultiplicity a (W ùîΩq Œ≤ i) = if a ‚àà (U ùîΩq Œ≤ i : Set L) then 1 else 0

lemma Œ≤_regular (R : F[X][X][Y])
                (H : F[X][Y]) [H_irreducible : Fact (Irreducible H)]
                {D : ‚Ñï} (hD : D ‚â• Bivariate.totalDegree H) :
    ‚àÄ t : ‚Ñï, ‚àÉ Œ≤ : ùí™ H, weight_Œõ_over_ùí™ Œ≤ ‚â§ (2 * t + 1) * Bivariate.natDegreeY R * D

lemma forwardRange_eq_of_r_eq (n : ‚Ñï) (r1 r2 : Fin n) (h_r_eq : r1 = r2) (l : Fin (r1.val + 1)) :
  forwardRange n r1 l = forwardRange n r2 ‚ü®l, by omega‚ü©

@[simp]
theorem tail_cons {Œ±} {n : ‚Ñï} (hd : Œ±) (tl : Vector Œ± n) : (cons hd tl).tail = tl

theorem cast_eq_dcast‚ÇÇ {hn} {hSpec : pSpec‚ÇÅ.cast hn = pSpec‚ÇÇ} {i : MessageIdx pSpec‚ÇÅ}:
    i.cast hn hSpec = dcast‚ÇÇ hn hSpec i

lemma coeff_eq_zero {p : UniPoly Q} :
    (‚àÄ i, (hi : i < p.size) ‚Üí p[i] = 0) ‚Üî ‚àÄ i, p.coeff i = 0

@[simp]
theorem simulateQ'_bind (oa : OracleComp spec Œ±) (ob : Œ± ‚Üí OracleComp spec Œ≤)
    -- Could potentially be weakened to `‚àÄ x ‚àà oa.support, (ob x).neverFails`
    -- Would require `bindOnSupport` instead of just `bind`
    (ha : oa.neverFails) (hb : ‚àÄ x, (ob x).neverFails) :
      simulateQ' so (oa >>= ob) (by simp; exact ‚ü®ha, fun x _ => hb x‚ü©) =
      simulateQ' so oa ha >>= fun x ‚Ü¶ simulateQ' so (ob x) (hb x)

theorem and_highBits_lowBits_eq_zero {n : ‚Ñï} (numLowBits : ‚Ñï) :
    getHighBits numLowBits n &&& getLowBits numLowBits n = 0

theorem max_eq_add_sub {m n : Nat} : Nat.max m n = m + (n - m)

theorem join_eq_join_iff {k : ‚Ñï} (h_pos : k > 0) (hi‚ÇÄ lo‚ÇÄ hi‚ÇÅ lo‚ÇÅ : ConcreteBTField (k - 1)) :
  „Ää hi‚ÇÄ, lo‚ÇÄ „Äã = „Ää hi‚ÇÅ, lo‚ÇÅ „Äã ‚Üî (hi‚ÇÄ = hi‚ÇÅ ‚àß lo‚ÇÄ = lo‚ÇÅ)

Nat.add_left_cancel in Init.Data.Nat.Basic

theorem computableNTTStage_eq_NTTStage (i : Fin ‚Ñì) :
  computableNTTStage (ùîΩq := ùîΩq) (r := r) (L := L) (‚Ñì := ‚Ñì) (Œ≤ := Œ≤) (R_rate := R_rate)
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := ‚ü®i, by omega‚ü©) =
  NTTStage (ùîΩq := ùîΩq) (L := L) (Œ≤ := Œ≤) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
    (i := ‚ü®i, by omega‚ü©)

private lemma johnson_condition_strong_implies_2_le_F_card
  (h_johnson : JohnsonConditionStrong B v)
  :
  2 ‚â§ Fintype.card F

@[simp]
theorem acceptRejectOracleRel_language :
    acceptRejectOracleRel.language = { (true, isEmptyElim) }

Fin.append_left in Mathlib.Data.Fin.Tuple.Basic

theorem findIdxRev?_emtpy_none {cond} {as : Array Œ±} (h : as = #[]) :
  findIdxRev? cond as = none

lemma listOfCloseCodewords_eq_zero :
  listOfCloseCodewords C y n = 0 ‚Üî IsEmpty (hammingBall C y n) ‚à® Infinite (hammingBall C y n)

lemma wt_eq_hammingNorm [Zero F] {v : Œπ ‚Üí F} :
  wt v = hammingNorm v

@[simp]
lemma bIdx_mul_œë_add_i_cast_lt_‚Ñì_succ (bIdx : Fin (‚Ñì / œë - 1)) (i : Fin (œë - 1 + 1))
    : ‚ÜëbIdx * œë + i < ‚Ñì + 1

lemma lin_shift_d [Field F] [Fintype F]
  (h_B : 2 ‚â§ B.card)
  :
  d B = d ({x - v | x ‚àà B} : Finset _)

@[simp]
private lemma K_le_card {Œ± : F} : K B i Œ± ‚â§ B.card

lemma evenize_is_even {f : Polynomial F} :
    EvenPoly (evenize f)

@[simp]
theorem oracleReduction_completeness (h : init.neverFails)
    (hRel : ‚àÄ stmtIn oStmtIn witIn,
      ((stmtIn, oStmtIn), witIn) ‚àà relIn ‚Üí
      ((mapStmt stmtIn, mapOStmt embedIdx hEq oStmtIn), mapWit stmtIn witIn) ‚àà relOut) :
    (oracleReduction oSpec mapStmt mapWit embedIdx hEq).perfectCompleteness init impl
      relIn relOut

lemma poly_eq_zero_of_dist_lt {n k : ‚Ñï} {F : Type*} [DecidableEq F] [CommRing F] [IsDomain F]
  {p : Polynomial F} {œâs : Fin n ‚Üí F}
  (h_deg : p.natDegree < k)
  (hn : k ‚â§ n)
  (h_inj : Function.Injective œâs)
  (h_dist : Œî‚ÇÄ(p.eval ‚àò œâs, 0) < n - k + 1)
  : p = 0

theorem W_linearity (i : Fin r)
    : IsLinearMap ùîΩq (f := fun inner_p ‚Ü¶ (W ùîΩq Œ≤ i).comp inner_p)

theorem correlatedAgreement_affine_spaces {k : ‚Ñï} [NeZero k] {u : Fin (k + 1) ‚Üí Œπ ‚Üí F}
  {deg : ‚Ñï} {domain : Œπ ‚Ü™ F} {Œ¥ : ‚Ñù‚â•0} (hŒ¥ : Œ¥ ‚â§ 1 - (ReedSolomonCode.sqrtRate deg domain))
  (hproximity :
    Pr_{let y ‚Üê $·µñ (u 0 +·µ• affineSpan F (Finset.univ.image (Fin.tail u)).toSet)}[
        Code.relHammingDistToCode (Œπ := Œπ) (F := F) y (ReedSolomon.code domain deg) ‚â§ Œ¥
    ] > errorBound Œ¥ deg domain) :
  correlatedAgreement (ReedSolomon.code domain deg) Œ¥ u

@[simp]
lemma ofPolynomialAlgHom_toPolynomialAlgHom_C {r : R} :
    ofPolynomialAlgHom (toPolynomialAlgHom (C r : P)) = (Polynomial.C r : R[X])

theorem concrete_mul_eq
  (prevBTFieldProps : ConcreteBTFieldProps (k := k - 1))
  (a b : ConcreteBTField k) {a‚ÇÅ a‚ÇÄ b‚ÇÅ b‚ÇÄ : ConcreteBTField (k - 1)}
  (h_a : (a‚ÇÅ, a‚ÇÄ) = split h_k a) (h_b : (b‚ÇÅ, b‚ÇÄ) = split h_k b) :
  concrete_mul a b =
    „Ää concrete_mul a‚ÇÄ b‚ÇÅ + concrete_mul b‚ÇÄ a‚ÇÅ + concrete_mul (concrete_mul a‚ÇÅ b‚ÇÅ) (Z (k - 1)),
      concrete_mul a‚ÇÄ b‚ÇÄ + concrete_mul a‚ÇÅ b‚ÇÅ „Äã

lemma add_descends [LawfulBEq R] (a‚ÇÅ b‚ÇÅ a‚ÇÇ b‚ÇÇ : UniPoly R) :
  equiv a‚ÇÅ a‚ÇÇ ‚Üí equiv b‚ÇÅ b‚ÇÇ ‚Üí add_descending a‚ÇÅ b‚ÇÅ = add_descending a‚ÇÇ b‚ÇÇ

lemma neg_add_cancel {k : ‚Ñï} (a : ConcreteBTField k) : neg a + a = 0

@[simp]
lemma erase_odd_empty :
    erase_odd ‚àÖ = ‚àÖ

theorem toNat_ofNat (n : ‚Ñï) : toNat (ofNat n) = n

@[simp]
theorem finSigmaFinEquiv'_apply {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (k : (i : Fin m) √ó Fin (n i)) :
    (finSigmaFinEquiv' k : ‚Ñï) = ‚àë i : Fin k.1, n (Fin.castLE k.1.isLt.le i) + k.2

theorem computableTwiddleFactor_eq_twiddleFactor (i : Fin ‚Ñì) :
  computableTwiddleFactor (r := r) (‚Ñì := ‚Ñì) (Œ≤ := Œ≤) (L := L)
    (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := ‚ü®i, by omega‚ü©) =
  twiddleFactor (ùîΩq := ùîΩq) (L := L) (Œ≤ := Œ≤) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
    (i := ‚ü®i, by omega‚ü©)

lemma getBit_of_xor {n m k: ‚Ñï} : getBit k (n ^^^ m) = getBit k n ^^^ getBit k m

lemma algebraMap_succ_eq_zero_x {k : ‚Ñï} (h_pos : k > 0) (x : BTField (k - 1)) :
  letI instAlgebra := binaryAlgebraTower (l:=k-1) (r:=k) (h_le:=by omega)
  algebraMap (BTField (k - 1)) (BTField k) x = ‚ãò 0, x ‚ãô

lemma HList.toDVec_eq_getValue (l : HList) (i : Fin l.length) : l.toDVec i = l.getValue i

@[simp]
theorem dcast‚ÇÉ_trans (ha : a = a') (ha' : a' = a'')
    (hb : dcast ha b = b') (hb' : dcast ha' b' = b'')
    (hc : dcast‚ÇÇ ha hb c = c') (hc' : dcast‚ÇÇ ha' hb' c' = c'') :
    dcast‚ÇÉ ha' hb' hc' (dcast‚ÇÉ ha hb hc d) =
    dcast‚ÇÉ (ha.trans ha') (by simp [‚Üê hb', ‚Üê hb]) (by simp [‚Üê hc', ‚Üê hc]) d

Nat.add_le_of_le_sub in Init.Data.Nat.Basic

lemma full_row_rank_via_rank_subLeftFull (h : m ‚â§ n) :
   (subLeftFull U (Fin.castLE h)).rank = m ‚Üí U.rank = m

theorem eq_join_via_add_smul_eq_iff_split (k : ‚Ñï) (h_pos : k > 0)
    (x : BTField k) (hi_btf lo_btf : BTField (k - 1)) :
    x = ‚ãò hi_btf, lo_btf ‚ãô ‚Üî
  split (k:=k) (h_k:=h_pos) x = (hi_btf, lo_btf)

@[simp, grind =] lemma R_plus_C_eq_N : sz.R + sz.C = sz.N

lemma f_eq_evenPart_plus_x_oddPart {f : Polynomial F} :
  f = evenPart f + Polynomial.X * oddPart f

theorem induction_append_right {m n : ‚Ñï} {motive : Fin (m + n + 1) ‚Üí Sort*} {zero : motive 0}
  {succ : ‚àÄ i : Fin (m + n), motive i.castSucc ‚Üí motive i.succ} {i : Fin (n + 1)} :
    induction zero succ (i.natAdd m) =
      @induction n (fun i => motive (i.natAdd m))
        (@induction m (fun j => motive (Fin.cast (by omega) (j.castAdd n)))
          zero (fun j x => succ (j.castAdd n) x) (last m))
        (fun i x => succ (i.natAdd m) x) i

omit [DecidableEq L] [Fintype ùîΩq] h_Fq_char_prime hŒ≤_lin_indep in
lemma normalizedW‚ÇÄ_eq_1_div_Œ≤‚ÇÄ : normalizedW (ùîΩq := ùîΩq) (Œ≤ := Œ≤) (i :=0) = X * C (1 / (Œ≤ 0))

protected lemma johnson_bound_lemma [Field F] {v : Fin n ‚Üí F}
  (h_n : 0 < n)
  (h_B : 2 ‚â§ B.card)
  (h_card : 2 ‚â§ (Fintype.card F))
  :
  B.card *
    ((1 - ((Fintype.card F : ‚Ñö) / (Fintype.card F - 1)) * (e B v / n)) ^ 2
      - (1 - ((Fintype.card F : ‚Ñö) / (Fintype.card F - 1)) * (d B/n)))  ‚â§
  ((Fintype.card F : ‚Ñö) / (Fintype.card F - 1)) * d B/n

@[simp]
theorem seqCompose_zero {n : Fin 0 ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)} :
    seqCompose pSpec = !p[]

lemma cast_join {k n : ‚Ñï} (h_pos : k > 0) (hi lo : ConcreteBTField (k - 1)) (heq : k = n) :
  join (k:=k) h_pos hi lo = cast (by rw [heq])
    (join (k:=n) (by omega) (cast (by subst heq; rfl) hi) (lo:=cast (by subst heq; rfl) lo))

@[simp]
lemma rank_nonsquare_rows_eq_min (inj : Function.Injective Œ±) :
  (Vandermonde.nonsquare (Œπ' := n) Œ±).rank = min m n

theorem dcast_fun‚ÇÇ {a‚ÇÅ a‚ÇÇ a‚ÇÅ' a‚ÇÇ' : Œ±} {h‚ÇÅ : a‚ÇÅ = a‚ÇÅ'} {h‚ÇÇ : a‚ÇÇ = a‚ÇÇ'} {f : Œ± ‚Üí Œ± ‚Üí Œ±}
    {g : (a‚ÇÅ : Œ±) ‚Üí (a‚ÇÇ : Œ±) ‚Üí Œ≤ a‚ÇÅ ‚Üí Œ≤ a‚ÇÇ ‚Üí Œ≤ (f a‚ÇÅ a‚ÇÇ)} {b‚ÇÅ : Œ≤ a‚ÇÅ} {b‚ÇÇ : Œ≤ a‚ÇÇ} :
    dcast (by cases h‚ÇÅ; cases h‚ÇÇ; rfl) (g a‚ÇÅ a‚ÇÇ b‚ÇÅ b‚ÇÇ) = g a‚ÇÅ' a‚ÇÇ' (dcast h‚ÇÅ b‚ÇÅ) (dcast h‚ÇÇ b‚ÇÇ)

lemma zsmul_neg' {k : ‚Ñï} (n : ‚Ñï) (a : ConcreteBTField k) :
  (if ((Int.negSucc n) : ‚Ñ§) % (2 : ‚Ñ§) = (0 : ‚Ñ§) then zero else a) =
    neg (if (‚Üën.succ : ‚Ñ§) % (2 : ‚Ñ§) = (0 : ‚Ñ§) then zero else a)

Fin.isLt in Init.Prelude

private lemma k_and_e' [Zero F]
  (h_n : n ‚â† 0)
  (h_B : B.card ‚â† 0)
  :
  k B / B.card = (n - e B 0) / n

private lemma fold_max_lemma {Œπ : Type} {s : Finset Œπ} {f : Œπ ‚Üí ‚Ñï} {n : ‚Ñï} :
    (‚àÄ i ‚àà s, f i ‚â§ n) ‚Üí Finset.fold max 0 f s ‚â§ n

lemma split_one {k : ‚Ñï} (h_k : k > 0) :
    split h_k (one (k:=k)) = (zero (k:=k - 1), one (k:=k - 1))

theorem add_zero {n : ‚Ñï} (a : CNat (n + 1)) : a + 0 = a

lemma zero_add {k : ‚Ñï} (a : ConcreteBTField k) : 0 + a = a

theorem hcons_happend_comm {Œ≤ : Fin m ‚Üí Sort u} {Œ≥ : Fin n ‚Üí Sort u}
    (a : Œ±) (u : (i : Fin m) ‚Üí Œ≤ i) (v : (i : Fin n) ‚Üí Œ≥ i) :
    True

private lemma sum_add_one {i : Fin (k + 1)} :
  ‚àë j' ‚àà finRangeTo (i.1 + 1), (s j').1 = (‚àë j' ‚àà finRangeTo i.1, (s j').1) + (s i).1

@[simp]
theorem singleEqPolynomial_zero (x : MvPolynomial œÉ R) : singleEqPolynomial (0 : R) x = 1 - x

lemma e_leq_dist_over_3 [DecidableEq F] {deg : ‚Ñï} {Œ± : Œπ ‚Ü™ F} {e : ‚Ñï} {u v : Œπ ‚Üí F}
  (he : (e : ‚Ñö) < (Code.minDist (RScodeSet Œ± deg) : ‚Ñö) / 3) :
  ‚àÄ x ‚àà Affine.line u v, distFromCode x (ReedSolomon.code Œ± deg) ‚â§ e
  ‚à® (numberOfClosePts u v deg Œ± e) ‚â§ Code.minDist (RScodeSet Œ± deg)

omit [NeZero ‚Ñì] [NeZero r] [NeZero ùì°] in
lemma fin_‚Ñì_steps_lt_r {h_‚Ñì_add_R_rate : ‚Ñì + ùì° < r} (i : Fin ‚Ñì) (steps : ‚Ñï)
    (h : i.val + steps ‚â§ ‚Ñì) : i.val + steps < r

protected lemma elocPoly_congr {œâs' f' : ‚Ñï ‚Üí F}
  (h‚ÇÅ : ‚àÄ {m}, m < n ‚Üí œâs m = œâs' m) (h‚ÇÇ : ‚àÄ {m}, m < n ‚Üí f m = f' m) :
  ElocPoly n œâs f = ElocPoly n œâs' f'

omit [DecidableEq L] [DecidableEq ùîΩq] hF‚ÇÇ hŒ≤_lin_indep h_Œ≤‚ÇÄ_eq_1 in
lemma intermediateNormVpoly_eval_is_linear_map (i : Fin (‚Ñì + 1)) (k : Fin (‚Ñì - i + 1)) :
  IsLinearMap ùîΩq (fun x : L =>
    (intermediateNormVpoly ùîΩq Œ≤ h_‚Ñì_add_R_rate i k).eval x)

theorem queryOracleVerifier_rbrKnowledgeSoundness [Fintype L] {œÉ : Type} (init : ProbComp œÉ)
    (impl : QueryImpl []‚Çí (StateT œÉ ProbComp)) :
    (queryOracleVerifier ùîΩq Œ≤ (œë:=œë) Œ≥_repetitions).rbrKnowledgeSoundness init impl
    (relIn := finalSumcheckRelOut ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (relOut := acceptRejectOracleRel)
    (rbrKnowledgeError := queryRbrKnowledgeError ùîΩq Œ≤ Œ≥_repetitions
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))

theorem getBit_repr_univ {‚Ñì : Nat} : ‚àÄ j, j < 2^‚Ñì ‚Üí
  j = ‚àë k ‚àà Finset.univ (Œ±:=Fin ‚Ñì), (getBit k j) * 2^k.val

@[simp]
theorem fflatten‚ÇÇ_two_eq_append {A : Sort u} {B : Sort v} {F : A ‚Üí B ‚Üí Sort w} {n : Fin 2 ‚Üí ‚Ñï}
    {Œ± : (i : Fin 2) ‚Üí (j : Fin (n i)) ‚Üí A}
    {Œ≤ : (i : Fin 2) ‚Üí (j : Fin (n i)) ‚Üí B}
    {v : (i : Fin 2) ‚Üí (j : Fin (n i)) ‚Üí F (Œ± i j) (Œ≤ i j)} :
    fflatten‚ÇÇ v = fappend‚ÇÇ (F := F) (v 0) (v 1)

lemma powerBasisSucc_dim (k : ‚Ñï) :
  powerBasisSucc (k:=k).dim = 2

theorem unique_linear_sum_repr (R : Type*) [CommRing R] (S : Type*) [CommRing S] [Algebra R S]
    (pb : PowerBasis R S) (h_dim : pb.dim = 2) (s : S) :
    ‚àÉ! p : R √ó R, s = p.fst ‚Ä¢ pb.gen + algebraMap R S p.snd

theorem add_assoc : p + q + r = p + (q + r)

@[simp]
theorem fappend_succ {Œ± : Fin m ‚Üí A} {Œ≤ : Fin (n + 1) ‚Üí A}
    (u : (i : Fin m) ‚Üí F (Œ± i)) (v : (i : Fin (n + 1)) ‚Üí F (Œ≤ i)) :
    fappend u v = fconcat (fappend u (fun i => v (castSucc i))) (v (last n))

@[simp]
lemma solutionToE_and_Q_E_and_Q_to_a_solution :
  E_and_Q_to_a_solution e (solutionToE e k v) (solutionToQ e k v) = v

theorem foldl_split_inner {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤ ‚Üí Œ±) (init : Œ±)
    (l : List Œ≤) (h : l ‚â† []): foldl (f:=f) (init:=init) (l)
    = foldl (f:=f) (init:=f (init) (l.head (by omega))) (l.tail)

@[simp]
theorem ofNat_zero : ofNat 0 = @zero Œ±

lemma add_equiv_raw [LawfulBEq R] (p q : UniPoly R) : Trim.equiv (p.add q) (p.add_raw q)

theorem dcast‚ÇÉ_eq_dcast‚ÇÉ_iff (ha : a = a') (hb : dcast ha b = b') (hc : dcast‚ÇÇ ha hb c = c') :
    dcast‚ÇÉ ha hb hc d = d' ‚Üî d = dcast‚ÇÉ ha.symm (dcast_symm ha hb) (dcast‚ÇÇ_symm ha hb hc) d'

theorem eq_zero_or_eq_one {a : ConcreteBTField 0} : a = zero ‚à® a = one

theorem is_prime : Nat.Prime fieldSize

theorem Nat.shiftRight_lo_mod_2_pow_hi_shiftLeft_lo (n hi_len lo_len : ‚Ñï)
  (h_n : n < 2 ^ (hi_len + lo_len)) :
  (((n >>> lo_len) % (2 ^ hi_len)) <<< lo_len) = (n - n % 2 ^ lo_len)

theorem BitVec.extractLsb_concat_lo {hi_size lo_size : ‚Ñï} (hi : BitVec hi_size)
  (lo : BitVec lo_size) (h_lo : lo_size > 0) : BitVec.extractLsb (hi:=lo_size - 1) (lo:=0)
  (BitVec.append (msbs:=hi) (lsbs:=lo)) = dcast (by
    rw [‚ÜêNat.sub_add_comm (h:=by omega), Nat.sub_add_cancel (h:=by omega), Nat.sub_zero]
  ) lo

lemma lastBlockIdx_isNeCommitmentRound (i : Fin œë) :
    ¬¨isCommitmentRound ‚Ñì œë ‚ü®(‚Ñì / œë - 1) * œë + ‚Üëi, lastBlockIdx_mul_œë_add_fin_lt_‚Ñì i‚ü©

lemma NTTStage_correctness (i : Fin (‚Ñì))
    (input_buffer : Fin (2 ^ (‚Ñì + R_rate)) ‚Üí L) (original_coeffs : Fin (2 ^ ‚Ñì) ‚Üí L) :
    additiveNTTInvariant ùîΩq Œ≤ h_‚Ñì_add_R_rate (evaluation_buffer:=input_buffer)
      (original_coeffs:=original_coeffs) (i := ‚ü®i.val+1, by omega‚ü©) ‚Üí
    additiveNTTInvariant ùîΩq Œ≤ h_‚Ñì_add_R_rate (evaluation_buffer:=NTTStage ùîΩq Œ≤ h_‚Ñì_add_R_rate
      ‚ü®i, by omega‚ü© input_buffer) (original_coeffs:=original_coeffs) ‚ü®i, by omega‚ü©

theorem mca_johnson_bound_CONJECTURE
  [DecidableEq Œπ]
  (Œ± : F) (œÜ : Œπ ‚Ü™ F) (m : ‚Ñï) [Smooth œÜ]
  (par‚Ñì_type : Type) [Fintype par‚Ñì_type] (exp : par‚Ñì_type ‚Ü™ ‚Ñï) :
  let Gen := RSGenerator.genRSC par‚Ñì_type œÜ m exp
  let : Fintype Gen.par‚Ñì := Gen.h‚Ñì
  hasMutualCorrAgreement Gen
    -- Conjectured BStar = ‚àöœÅ
    (Real.sqrt Gen.rate)
    -- Conjectured errStar
    (fun Œ¥ =>
      let min_val := min (1 - Real.sqrt Gen.rate - (Œ¥ : ‚Ñù)) (Real.sqrt Gen.rate / 20)
      ENNReal.ofReal (
        ((Fintype.card par‚Ñì_type - 1) * 2^(2*m)) /
        ((Fintype.card F) * (2 * min_val)^7)
      )
    )

lemma exists_Pz_of_coeffs_of_close_proximity
  {k : ‚Ñï}
  {z : F}
  (hS : z ‚àà coeffs_of_close_proximity (k := k) œâs Œ¥ u‚ÇÄ u‚ÇÅ)
  :
  ‚àÉ Pz : F[X], Pz.natDegree ‚â§ k ‚àß Œ¥·µ£(u‚ÇÄ + z ‚Ä¢ u‚ÇÅ, Pz.eval ‚àò œâs) ‚â§ Œ¥

protected lemma abs_one_sub_div_le_one {v a : Fin n ‚Üí F}
  (h_card : 2 ‚â§ Fintype.card F)
  :
  |1 - (1 + 1 / ((Fintype.card F : ‚Ñö) - 1)) * Œî‚ÇÄ(v, a) / n

theorem vappend_singleton (u : Fin m ‚Üí Œ±) (a : Œ±) :
    vappend u (vcons a !v[]) = vconcat u a

@[simp]
lemma seqCompose_succ {m : ‚Ñï} (Stmt : Fin (m + 2) ‚Üí Type)
    {n : Fin (m + 1) ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (V : (i : Fin (m + 1)) ‚Üí Verifier oSpec (Stmt i.castSucc) (Stmt i.succ) (pSpec i)) :
    seqCompose Stmt V = append (V 0) (seqCompose (Stmt ‚àò Fin.succ) (fun i => V (Fin.succ i)))

@[simp]
protected lemma elocPoly_succ :
  ElocPoly (n + 1) œâs f p =
  ElocPoly n œâs f p *
    if f n = p.eval (œâs n)
    then 1
    else X - C (œâs n)

@[simp]
theorem vcons_succ (a : Œ±) (v : Fin n ‚Üí Œ±) (i : Fin n) : (a ::·µõ v) i.succ = v i

theorem oracleReduction_rbr_knowledge_soundness : True

lemma cube_map_bijective :
    Function.Bijective (fun x : (Field)À£ => x ^ (3 : Nat))

@[simp] theorem toNat_succ (t : AssocNat) : toNat (succ t) = (toNat t).succ

@[simp]
theorem toNat_zero : toNat zero = 0

@[simp]
theorem dcast_trans (h : a = a') (h' : a' = a'') :
    dcast h' (dcast h b) = dcast (h.trans h') b

private lemma f_convex {x‚ÇÅ x‚ÇÇ : ‚Ñö} {Œ±‚ÇÅ Œ±‚ÇÇ : ‚Ñö}
  (h_noneg_1 : 0 ‚â§ Œ±‚ÇÅ)
  (h_noneg_2 : 0 ‚â§ Œ±‚ÇÇ)
  (h_conv : Œ±‚ÇÅ + Œ±‚ÇÇ = 1)
  :
  f (Œ±‚ÇÅ * x‚ÇÅ + Œ±‚ÇÇ * x‚ÇÇ) ‚â§ Œ±‚ÇÅ * f x‚ÇÅ + Œ±‚ÇÇ * f x‚ÇÇ

@[simp]
theorem cast_completeness (Œµ : ‚Ñù‚â•0) (hComplete : R.completeness init impl relIn relOut Œµ) :
    (R.cast hn hSpec hO‚Çò).completeness init impl relIn relOut Œµ

@[simp]
theorem embedSum_succ_zero {n : Fin (m + 1) ‚Üí ‚Ñï} {j : Fin (n 0)} :
    embedSum 0 j = Fin.castAdd _ j

@[simp] theorem rightpad_getD_eq_getD (l : List Œ±) (n : Nat) (unit : Œ±) (i : Nat) :
    (rightpad n unit l).getD i unit = l.getD i unit

@[simp, grind =]
theorem monomialXY_eq_zero_iff {n m : ‚Ñï} {a : F} : monomialXY n m a = 0 ‚Üî a = 0

@[to_additive]
theorem prod_Iic_succ (i : Fin n) :
    ‚àè j ‚àà Iic i.succ, v j = (‚àè j ‚àà Iic i.castSucc, v j) * v i.succ

lemma AlgebraTowerEquiv.commutesRight' (e : AlgebraTowerEquiv A B)
    {i j : Œπ} (h : i ‚â§ j) (r : B i) :
  AlgebraTower.algebraMap (AT:=A) (i:=i) (j:=j) (h:=h) ((e.toRingEquiv i).symm r) =
  (e.toRingEquiv j).symm (AlgebraTower.algebraMap (AT:=B) (i:=i) (j:=j) (h:=h) r)

@[simp]
theorem erase_odd_mem
  {s : Finset ‚Ñï}
  {n : ‚Ñï}
  : n ‚àà (erase_odd s) ‚Üî Even n ‚àß n ‚àà s

theorem append_right_injective {pSpec : ProtocolSpec m} :
    Function.Injective (@ProtocolSpec.append m n pSpec)

theorem concreteTowerAlgebraMap_assoc :
    ‚àÄ r mid l : ‚Ñï, (h_l_le_mid : l ‚â§ mid) ‚Üí (h_mid_le_r : mid ‚â§ r) ‚Üí
    concreteTowerAlgebraMap (l:=l) (r:=r) (h_le:=by exact Nat.le_trans h_l_le_mid h_mid_le_r) =
    (concreteTowerAlgebraMap (l:=mid) (r:=r) (h_le:=h_mid_le_r)).comp
    (concreteTowerAlgebraMap (l:=l) (r:=mid) (h_le:=h_l_le_mid))

lemma mem_image_support_coeff_finSuccEquivNth {f : MvPolynomial (Fin (n + 1)) R} {i : ‚Ñï} {x} :
    x ‚àà Finsupp.insertNth p i '' ((finSuccEquivNth R p f).coeff i).support ‚Üî
      x ‚àà f.support ‚àß x p = i

theorem succ_succ {T : Type u} [HasSucc T] [Add T] [One T] [LawfulHasSucc T] (x : T) :
    succ' (succ' x) = x + 1 + 1

private lemma oddPart_eq_oddPart'_aux' {f : Polynomial F}
  : (f - f.comp (-Polynomial.X)) = (Polynomial.C 2) * x_times_oddPart' f

theorem reduction_perfectCompleteness (hInit : init.neverFails) :
    (reduction R deg D oSpec).perfectCompleteness init impl
      (inputRelation R deg D) (outputRelation R deg)

@[simp]
lemma bIdx_mul_œë_add_i_fin_‚Ñì_pred_lt_‚Ñì (bIdx : Fin (‚Ñì / œë - 1)) (i : Fin (œë - 1))
    : ‚ÜëbIdx * œë + ‚Üëi < ‚Ñì

@[simp]
theorem FullData.get_ofFun {Œ±} {s} (f : SkeletonNodeIndex s ‚Üí Œ±) :
    (FullData.ofFun s f).get = f

@[simp]
theorem ConcreteBTField.RingHom_cast_source_apply (k n m : ‚Ñï) (h_eq : k = n)
  (f : ConcreteBTField k ‚Üí+* ConcreteBTField m) (x : ConcreteBTField n) :
    (cast (ConcreteBTField.RingHom_eq_of_source_eq (k:=k) (n:=n) (m:=m) h_eq) f) x
    = f (cast (by apply cast_ConcreteBTField_eq (h_eq:=h_eq.symm)) x)

theorem mca_capacity_bound_CONJECTURE
  [DecidableEq Œπ]
  (Œ± : F) (œÜ : Œπ ‚Ü™ F) (m : ‚Ñï) [Smooth œÜ]
  (par‚Ñì_type : Type) [Fintype par‚Ñì_type] (exp : par‚Ñì_type ‚Ü™ ‚Ñï) :
  let Gen := RSGenerator.genRSC par‚Ñì_type œÜ m exp
  let : Fintype Gen.par‚Ñì := Gen.h‚Ñì
  haveI := Gen.Gen_nonempty
  ‚àÉ (c‚ÇÅ c‚ÇÇ : ‚Ñï),
    ‚àÄ (f : Gen.par‚Ñì ‚Üí Œπ ‚Üí F) (Œ∑ : ‚Ñù) (_hŒ∑ : 0 < Œ∑) (Œ¥ : ‚Ñù‚â•0)
      (_hŒ¥ : 0 < Œ¥ ‚àß Œ¥ < 1 - Gen.rate - Œ∑),
      Pr_{let r ‚Üê$·µñ Gen.Gen}[ proximityCondition f Œ¥ r Gen.C ] ‚â§
        ENNReal.ofReal (
          (((Fintype.card par‚Ñì_type - 1) : ‚Ñù)^c‚ÇÇ * ((2^m) : ‚Ñù)^c‚ÇÇ) /
          (Œ∑^c‚ÇÅ * Gen.rate^(c‚ÇÅ+c‚ÇÇ) * (Fintype.card F))
        )

lemma aeval_apply {A : Type w} [CommSemiring A] [Algebra R A] (s : A) :
    aeval (P := P) s = eval‚ÇÇAlgHom (Algebra.ofId R A) s

theorem degree_finSuccEquivNth {f : MvPolynomial (Fin (n + 1)) R} (h : f ‚â† 0) :
    (finSuccEquivNth R p f).degree = degreeOf p f

theorem lt_iff_toNat_lt (a b : AssocNat) : a < b ‚Üî toNat a < toNat b

@[simp]
theorem cast_id : FullTranscript.cast rfl rfl = (id : pSpec‚ÇÅ.FullTranscript ‚Üí _)

theorem dcast‚ÇÉ_dcast‚ÇÇ : dcast‚ÇÉ rfl rfl rfl d = dcast‚ÇÇ dcast_eq.symm dcast‚ÇÇ_dcast.symm d

theorem iteratedQuotientMap_k_eq_1_is_qMap (i : Fin ‚Ñì)
    (h_i_add_1 : i.val + 1 ‚â§ ‚Ñì) (x : (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate) ‚ü®i, by omega‚ü©) :
    iteratedQuotientMap ùîΩq Œ≤ h_‚Ñì_add_R_rate i 1 h_i_add_1 x =
    ‚ü®(qMap ùîΩq Œ≤ ‚ü®i.val, by omega‚ü©).eval (x.val : L),
      qMap_eval_mem_sDomain_succ ùîΩq Œ≤   h_‚Ñì_add_R_rate i h_i_add_1 x‚ü©

theorem prod_poly_sub_C_eq_poly_pow_card_sub_poly_in_L
  (p : L[X]) :
  (‚àè c ‚àà (Finset.univ : Finset Fq), (p - Polynomial.C (algebraMap Fq L c))) =
    p^(Fintype.card Fq) - p

theorem SkeletonNodeIndex.rightChild_bind_parent {s : Skeleton}
    (idx : SkeletonNodeIndex s) :
    idx.rightChild >>= parent = idx.rightChild.map (fun _ => idx)

theorem withBot_lt_one_cases (x : WithBot ‚Ñï) (h : x < (1 : ‚Ñï)) : x = ‚ä• ‚à® x = (0 : ‚Ñï)

lemma concrete_exists_pair_ne {k : ‚Ñï} : ‚àÉ x y : ConcreteBTField k, x ‚â† y

@[simp] theorem BitVec.cast_zero {n m : ‚Ñï} (h : n = m) : BitVec.cast h 0 = 0

lemma bIdx_succ_mul_œë_le_‚Ñì_succ (bIdx : Fin (‚Ñì / œë - 1)) : (‚ÜëbIdx + 1) * œë ‚â§ ‚Ñì + 1

theorem relayOracleVerifier_rbrKnowledgeSoundness (i : Fin ‚Ñì)
    (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
    (relayOracleVerifier ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        i hNCR).rbrKnowledgeSoundness init impl
      (relIn := foldStepRelOut (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë := œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë := ùìë) i.succ)
      (relayKnowledgeError)

lemma one_bitvec_toNat {width : ‚Ñï} (h_width : width > 0) : (1#width).toNat = 1

private lemma k_and_e [Zero F]
  (h_n : n ‚â† 0)
  (h_B : B.card ‚â† 0)
  :
  k B = B.card * (n - e B 0) / n

@[simp]
lemma append_last_of_succ_right {u : Fin m ‚Üí Œ±} {v : Fin (n + 1) ‚Üí Œ±} :
    (append u v) (last (m + n)) = v (last n)

theorem induct [LawfulBEq R] {motive : UniPoly R ‚Üí Prop}
  (case1 : ‚àÄ p, p.trim = #[] ‚Üí (‚àÄ i, (hi : i < p.size) ‚Üí p[i] = 0) ‚Üí motive p)
  (case2 : ‚àÄ p : UniPoly R, ‚àÄ k : Fin p.size, p.trim = p.extract 0 (k + 1)
    ‚Üí p[k] ‚â† 0 ‚Üí (‚àÄ j : ‚Ñï, (hj : j < p.size) ‚Üí j > k ‚Üí p[j] = 0) ‚Üí motive p)
  (p : UniPoly R) : motive p

lemma approximate_solution_is_exact_solution_coeffs'
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ)
  :
    Œ≥' x‚ÇÄ (R k Œ¥ x‚ÇÄ h_gs) (irreducible_H k h_gs) =
        PowerSeries.mk (fun t =>
          if t ‚â• k
          then (0 : AppendixA.ùïÉ (H k Œ¥ x‚ÇÄ h_gs))
          else PowerSeries.coeff _ t
            (Œ≥' 
              x‚ÇÄ
              (R k (x‚ÇÄ := x‚ÇÄ) (Œ¥ := Œ¥) h_gs)
              (irreducible_H k h_gs)))

@[simp]
theorem cast_dir_idx_symm {hn} (hSpec : pSpec‚ÇÅ.cast hn = pSpec‚ÇÇ) {i : Fin n‚ÇÇ} :
    pSpec‚ÇÅ.dir (Fin.cast hn.symm i) = pSpec‚ÇÇ.dir i

theorem congrArg‚ÇÑ {Œ± Œ≤ Œ≥ Œ¥ Œµ : Sort*} {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥ ‚Üí Œ¥ ‚Üí Œµ} {a a' : Œ±} {b b' : Œ≤} {c c' : Œ≥}
    {d d' : Œ¥} (h : a = a') (h' : b = b') (h'' : c = c') (h''' : d = d') :
      f a b c d = f a' b' c' d'

@[simp]
theorem dconcat_zero {motive : Fin 1 ‚Üí Sort u} (a : motive (last 0)) :
    !d‚ü®fun _ : Fin 0 => motive (castSucc _)‚ü©[] :+·µà‚ü®motive‚ü© a = !d‚ü®motive‚ü©[a]

@[simp]
theorem verifier_rbrKnowledgeSoundness (hRel : ‚àÄ stmtIn witOut,
      (mapStmt stmtIn, witOut) ‚àà relOut ‚Üí (stmtIn, mapWitInv stmtIn witOut) ‚àà relIn) :
    (verifier oSpec mapStmt).rbrKnowledgeSoundness init impl relIn relOut 0

theorem insertNth_right_injective :
    Injective (Finsupp.insertNth p y : (Fin n ‚Üí‚ÇÄ M) ‚Üí Fin (n + 1) ‚Üí‚ÇÄ M)

lemma folding_preserves_listdecoding_base_ne_subset
  {S : Finset Œπ} {k m : ‚Ñï} (hm : 1 ‚â§ m) {œÜ : Œπ ‚Ü™ F} [Smooth œÜ] {Œ¥ : ‚Ñù‚â•0}
  {S_0 : Finset (indexPowT S œÜ 0)} {S_1 : Finset (indexPowT S œÜ 1)}
  {œÜ_0 : (indexPowT S œÜ 0) ‚Ü™ F} {œÜ_1 : (indexPowT S œÜ 1) ‚Ü™ F}
  [‚àÄ i : ‚Ñï, Fintype (indexPowT S œÜ i)] [‚àÄ i : ‚Ñï, DecidableEq (indexPowT S œÜ i)]
  [Smooth œÜ_0] [Smooth œÜ_1]
  [h : ‚àÄ {f : (indexPowT S œÜ 0) ‚Üí F}, DecidableBlockDisagreement 0 k f S_0 œÜ_0]
  [h : ‚àÄ {f : (indexPowT S œÜ 1) ‚Üí F}, DecidableBlockDisagreement 1 k f S_1 œÜ_1]
  [‚àÄ i : ‚Ñï, Neg (indexPowT S œÜ i)]
  {C : Set ((indexPowT S œÜ 0) ‚Üí F)} (hcode : C = smoothCode œÜ_0 m)
  (C' : Set ((indexPowT S œÜ 1) ‚Üí F)) (hcode' : C' = smoothCode œÜ_1 (m-1))
  {BStar : (Set (indexPowT S œÜ 1 ‚Üí F)) ‚Üí ‚Ñï ‚Üí ‚Ñù‚â•0}
  {errStar : (Set (indexPowT S œÜ 1 ‚Üí F)) ‚Üí ‚Ñï ‚Üí ‚Ñù‚â•0 ‚Üí ‚Ñù‚â•0} :
    Pr_{let Œ± ‚Üê$·µñ F}[ ‚àÄ { f : (indexPowT S œÜ 0) ‚Üí F} (hŒ¥Le: Œ¥ ‚â§ 1 - (BStar C' 2)),
                      let listBlock : Set ((indexPowT S œÜ 0) ‚Üí F) := Œõ·µ£(0, k, f, S_0, C, hcode, Œ¥)
                      let vec_Œ± : Fin 1 ‚Üí F := (fun _ : Fin 1 => Œ±)
                      let foldSet := fold_k_set listBlock vec_Œ± hm
                      let fold := fold_k f vec_Œ± hm
                      let listBlock' : Set ((indexPowT S œÜ 1) ‚Üí F)
                        := Œõ·µ£(1, k, fold, S_1, C', hcode', Œ¥)
                      ¬¨ (listBlock' ‚äÜ foldSet)
                    ] < errStar C' 2 Œ¥

omit [Finite F] in
lemma mul_root_of_unity {x : FÀ£} :
  ‚àÄ {a b : FÀ£} {i j : ‚Ñï},
    i ‚â§ j ‚Üí a ‚àà evalDomain D x i ‚Üí b ‚àà Domain.evalDomain D j ‚Üí
      a * b ‚àà evalDomain D x i

@[simp]
theorem BTField.RingHom_eq_of_dest_eq (k m n : ‚Ñï) (h_eq : m = n) :
  (BTField k ‚Üí+* BTField m) = (BTField k ‚Üí+* BTField n)

theorem vcons_right_injective (a : Œ±) :
    Function.Injective (vcons a : (Fin n ‚Üí Œ±) ‚Üí Fin (n + 1) ‚Üí Œ±)

private lemma johnson_condition_strong_implies_n_pos
  (h_johnson : JohnsonConditionStrong B v)
  :
  0 < n

theorem leftpad_toList {a : Array Œ±} {n : Nat} {unit : Œ±} :
    a.leftpad n unit = mk (a.toList.leftpad n unit)

theorem seqCompose_completeness (hInit : init.neverFails)
    (rel : (i : Fin (m + 1)) ‚Üí Set ((Stmt i √ó ‚àÄ j, OStmt i j) √ó Wit i))
    (R : ‚àÄ i, OracleReduction oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Wit i.castSucc)
      (Stmt i.succ) (OStmt i.succ) (Wit i.succ) (pSpec i))
    (completenessError : Fin m ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (R i).completeness init impl (rel i.castSucc) (rel i.succ) (completenessError i)) :
      (OracleReduction.seqCompose Stmt OStmt Wit R).completeness
        init impl (rel 0) (rel (Fin.last m)) (‚àë i, completenessError i)

@[simp] lemma toMvPolynomialAlgHom_X (s : œÉ) :
    toMvPolynomialAlgHom (X s : P) = (MvPolynomial.X s : MvPolynomial œÉ R)

lemma evenPart_even {f : Polynomial F} :
    EvenPoly (evenPart f)

@[simp]
lemma OracleVerifier.append_toVerifier
    (V‚ÇÅ : OracleVerifier oSpec Stmt‚ÇÅ OStmt‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : OracleVerifier oSpec Stmt‚ÇÇ OStmt‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ pSpec‚ÇÇ) :
      (OracleVerifier.append V‚ÇÅ V‚ÇÇ).toVerifier =
        Verifier.append V‚ÇÅ.toVerifier V‚ÇÇ.toVerifier

theorem rename_ne_zero_of_injective {œÑ : Type*} {f : œÉ ‚Üí œÑ} (hf : Function.Injective f)
    {p : MvPolynomial œÉ R} (h : p ‚â† 0) : rename f p ‚â† 0

lemma W_is_additive
  (i : Fin r) :
  IsLinearMap (R := ùîΩq) (M := L) (M‚ÇÇ := L) (f := fun x ‚Ü¶ (W ùîΩq Œ≤ i).eval x)

theorem finalSumcheckOracleVerifier_rbrKnowledgeSoundness [Fintype L] {œÉ : Type}
    (init : ProbComp œÉ) (impl : QueryImpl []‚Çí (StateT œÉ ProbComp)) :
    (finalSumcheckVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)).rbrKnowledgeSoundness init impl
      (relIn := roundRelation ùîΩq Œ≤ (œë := œë) (ùìë := ùìë)
        (mp := BBF_SumcheckMultiplierParam) (Fin.last ‚Ñì))
      (relOut := finalSumcheckRelOut ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
      (rbrKnowledgeError := finalSumcheckKnowledgeError)

lemma isPrimitiveRoot_twoAdicGenerator (bits : Fin (twoAdicity + 1)) :
    IsPrimitiveRoot (twoAdicGenerators[bits]) (2 ^ (bits : Nat))

Nat.zero_add in Init.Data.Nat.Basic

theorem OracleVerifier.liftContext_toVerifier_comm
    {lens : OracleStatement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                              OuterOStmtIn OuterOStmtOut InnerOStmtIn InnerOStmtOut}
    {V : OracleVerifier oSpec InnerStmtIn InnerOStmtIn InnerStmtOut InnerOStmtOut pSpec} :
      (V.liftContext lens).toVerifier = V.toVerifier.liftContext lens

lemma irreducible_factorization_of_gs_solution
  {k : ‚Ñï}
  (h_gs : ModifiedGuruswami m n k œâs Q u‚ÇÄ u‚ÇÅ) :
  ‚àÉ (C : F[Z][X]) (R : List F[Z][X][Y]) (f : List ‚Ñï) (e : List ‚Ñï),
    R.length = f.length ‚àß
    f.length = e.length ‚àß
    ‚àÄ e·µ¢ ‚àà e, 1 ‚â§ e·µ¢ ‚àß
    ‚àÄ R·µ¢ ‚àà R, R·µ¢.Separable ‚àß
    ‚àÄ R·µ¢ ‚àà R, Irreducible R·µ¢ ‚àß
    Q = (Polynomial.C C) *
        ‚àè (R·µ¢ ‚àà R.toFinset) (f·µ¢ ‚àà f.toFinset) (e·µ¢ ‚àà e.toFinset),
          (R·µ¢.comp ((Y : F[Z][X][Y]) ^ f·µ¢))^e·µ¢

lemma join_split_eq_join {k : ‚Ñï} (h_pos : k > 0) (x : ConcreteBTField k) :
  „Ää (split h_pos x).fst, (split h_pos x).snd „Äã = x

@[simp]
theorem drop_one {Œ± : Fin (n + 1) ‚Üí Sort*} (v : (i : Fin (n + 1)) ‚Üí Œ± i) :
    drop 1 (Nat.le_add_left 1 n) v = tail v

Fin.val_succ in Init.Data.Fin.Lemmas

lemma getBit_zero_eq_self {n : ‚Ñï} (h_n : n < 2) : getBit 0 n = n

lemma List.prod_finRange_eq_finset_prod {M : Type*} [CommMonoid M] {n : ‚Ñï} (f : Fin n ‚Üí M) :
    ((List.finRange n).map f).prod = ‚àè i : Fin n, f i

@[simp]
theorem insertNth_last : insertNth (Fin.last n) y s = snoc s y

lemma add_eq_one_iff (a b : ConcreteBTField 0) :
  a + b = 1 ‚Üî (a = 0 ‚àß b = 1) ‚à® (a = 1 ‚àß b = 0)

theorem lagrangeToMonoLevel_monoToLagrangeLevel_id (v : Vector R (2 ^ n)) (i : Fin n) :
  lagrangeToMonoLevel i (monoToLagrangeLevel i v) = v

lemma extract_start_zero_eq_take {n : ‚Ñï} {Œ± : Fin n ‚Üí Sort*} (stop : ‚Ñï) (h : stop ‚â§ n)
    (v : (i : Fin n) ‚Üí Œ± i) : extract 0 stop (Nat.zero_le _) h v = take stop h v

Fin.ext in Init.Data.Fin.Lemmas

theorem cast_injective : Function.Injective (ChallengeIdx.cast hn hSpec)

lemma normalizedW_eq_qMap_composition (‚Ñì R_rate : ‚Ñï) (i : Fin r) :
    normalizedW ùîΩq Œ≤ i = qCompositionChain ùîΩq Œ≤ (‚Ñì:=‚Ñì) (R_rate:=R_rate) i

@[simp] lemma twoAdicGenerators_length : twoAdicGenerators.length = twoAdicity + 1

lemma concrete_mul_left_distrib
  {h_k : k > 0} (prevBTFieldProps : ConcreteBTFieldProps (k := k - 1))
  (a b c : ConcreteBTField k) :
    concrete_mul a (b + c) = concrete_mul a b + concrete_mul a c

omit [NeZero ‚Ñì] in
lemma fin_‚Ñì_steps_lt_‚Ñì_add_R (i : Fin ‚Ñì) (steps : ‚Ñï) (h : i.val + steps ‚â§ ‚Ñì)
    : i.val + steps < ‚Ñì + ùì°

@[simp]
theorem OracleReduction.run_eq_run_reduction [‚àÄ i, OracleInterface (pSpec.Message i)]
    {stmt : StmtIn} {oStmt : ‚àÄ i, OStmtIn i} {wit : WitIn}
    {oracleReduction : OracleReduction oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec} :
      oracleReduction.run stmt oStmt wit =
        oracleReduction.toReduction.run ‚ü®stmt, oStmt‚ü© wit

theorem size_le_size (p : UniPoly R) : p.trim.size ‚â§ p.size

lemma minDist_eq_minDist [DecidableEq F] {IC : LawfulInterleavedCode Œ∫ Œπ F} :
  Code.minDist (IC.1.LC : Set (Œπ ‚Üí F)) = minDist IC.1.MF

theorem toPoly_add {p q : UniPoly Q} : (add_raw p q).toPoly = p.toPoly + q.toPoly

theorem dcast‚ÇÇ_dcast : dcast‚ÇÇ rfl rfl c = dcast dcast_eq.symm c

theorem hammingDist_le_of_outer_comp_injective {Œπ‚ÇÅ Œπ‚ÇÇ : Type*} [Fintype Œπ‚ÇÅ] [Fintype Œπ‚ÇÇ]
    {Œ≤ : Œπ‚ÇÇ ‚Üí Type*} [‚àÄ i, DecidableEq (Œ≤ i)] [DecidableEq Œπ‚ÇÇ]
    (x y : ‚àÄ i, Œ≤ i) (g : Œπ‚ÇÅ ‚Üí Œπ‚ÇÇ) (hg : Function.Injective g) :
    hammingDist (fun i => x (g i)) (fun i => y (g i)) ‚â§ hammingDist x y

lemma rank_eq_iff_det_ne_zero {U : Matrix (Fin n) (Fin n) F} :
U.rank = n ‚Üî U.det ‚â† 0

private lemma johnson_unrefined_by_M [Zero F]
  (h_n : 0 < n)
  (h_B : 2 ‚â§ B.card)
  (h_card : 2 ‚â§ (Fintype.card F))
  :
  B.card * ((1 - e B 0 / n) ^ 2  + (e B 0) ^ 2 / ((Fintype.card F - 1) * n^2) - 1 + d B/n)
  ‚â§
  d B/n

lemma add_comm {k : ‚Ñï} (a b : ConcreteBTField k) : a + b = b + a

theorem add_assoc {n : ‚Ñï} (a b c : CNat (n + 1)) : (a + b) + c = a + (b + c)

@[grind _=_]
lemma weightedDegree_eq_natWeightedDegree {u v : ‚Ñï} :
  f ‚â† 0 ‚Üí weightedDegree f u v = natWeightedDegree f u v

theorem traceMapProperty_of_quadratic_extension
  (F_prev : Type*) [Field F_prev] [Fintype F_prev] (k : ‚Ñï)
  (fintypeCardPrev : Fintype.card F_prev = 2 ^ (2 ^ k))
  (t1 : F_prev) [instNeZero_t1 : NeZero t1]
  {F_cur : Type*} [Field F_cur] (u : F_cur) [instNeZero_u : NeZero u]
  [Algebra F_prev F_cur]
  (h_rel : SpecialElementRelation (t1 := t1) (u := u))
  (prev_trace_map : TraceMapProperty F_prev t1 (k))
  (sumZeroIffEq : ‚àÄ (x y : F_cur), x + y = 0 ‚Üî x = y)
  : TraceMapProperty F_cur u (k + 1)

lemma getBit_of_middleBits {n offset len k : ‚Ñï} :
  getBit k (getMiddleBits offset len n) =
    if k < len then getBit (k + offset) n else 0

@[simp]
lemma isRoot_polynomialsOfCoeffs {x : F} :
  IsRoot (polynomialOfCoeffs coeffs) x ‚Üî eval x (polynomialOfCoeffs coeffs) = 0

theorem ScalarField_is_prime : Nat.Prime scalarFieldSize

@[simp]
theorem dflatten_two_eq_append {n : Fin 2 ‚Üí ‚Ñï} {motive : (k : Fin (vsum n)) ‚Üí Sort*}
    {v : (i : Fin 2) ‚Üí (j : Fin (n i)) ‚Üí motive (embedSum i j)} :
    dflatten (motive := motive) v = dappend (v 0) (v 1)

theorem eqPolynomial_expanded (r : œÉ ‚Üí R) :
    eqPolynomial r = ‚àè i : œÉ, ((1 - C (r i)) * (1 - X i) + C (r i) * X i)

@[simp]
lemma cons_eq_List.cons : x ::‚Çï xs = x :: xs

lemma concrete_mul_zero
  (prevBTFieldProps : ConcreteBTFieldProps (k := k - 1))
  (a : ConcreteBTField k) : concrete_mul a (zero (k:=k)) = zero (k:=k)

theorem novelToMonomial_monomialToNovel_inverse
  (‚Ñì : ‚Ñï) (h_‚Ñì : ‚Ñì ‚â§ r) :
  ‚àÄ coeffs : Fin (2^‚Ñì) ‚Üí L,
    monomialToNovelCoeffs ùîΩq Œ≤ ‚Ñì h_‚Ñì
      (novelToMonomialCoeffs ùîΩq Œ≤ ‚Ñì h_‚Ñì coeffs) = coeffs

@[simp]
theorem ofNat_succ (n : ‚Ñï) : @ofNat Œ± (n.succ) = succ (ofNat n)

Nat.le_trans in Init.Prelude

theorem addCases_right' {motive : Fin (m + n) ‚Üí Sort*}
    {left : (i : Fin m) ‚Üí motive (castAdd n i)} {right : (j : Fin n) ‚Üí motive (natAdd m j)}
    {i : Fin n} (j : Fin (m + n)) (h : j = natAdd m i) :
      addCases (motive := motive) left right j = h ‚ñ∏ (right i)

@[simp]
lemma getTypes_hcons (x : Œ£ Œ± : Type u, Œ±) (xs : HList) :
    (x ::‚Çï xs).getTypes = x.1 :: xs.getTypes

@[simp]
lemma ofPolynomialAlgHom_toPolynomialAlgHom_X :
    ofPolynomialAlgHom (toPolynomialAlgHom (X : P)) = (Polynomial.X : R[X])

lemma mul_by_2_def {s : Finset ‚Ñï} :
    mul_by_2 s = s.map ‚ü®fun n => 2 * n, by {
      intro a b
      simp
    }‚ü©

@[simp]
theorem dcons_zero {motive : Fin (n + 1) ‚Üí Sort u} (a : motive 0)
    (v : (i : Fin n) ‚Üí motive i.succ) : (a ::·µà‚ü®motive‚ü© v) 0 = a

theorem is_prime : Nat.Prime fieldSize

@[simp]
theorem addCases'_right {m n : ‚Ñï} {Œ± : Fin m ‚Üí Sort u} {Œ≤ : Fin n ‚Üí Sort u}
    (left : (i : Fin m) ‚Üí Œ± i) (right : (j : Fin n) ‚Üí Œ≤ j) (i : Fin n) :
      addCases' left right (Fin.natAdd m i) = (Fin.append_right Œ± Œ≤ i) ‚ñ∏ (right i)

theorem cast_eq_dcast‚ÇÇ {T : FullTranscript pSpec‚ÇÅ} :
    dcast‚ÇÇ hn hSpec T = FullTranscript.cast hn hSpec T

theorem oracleVerifier_toVerifier_run {stmt : Statement} {oStmt : ‚àÄ i, OStatement i}
    {tr : (oraclePSpec Witness).FullTranscript} :
    (oracleVerifier oSpec Statement OStatement Witness).toVerifier.run ‚ü®stmt, oStmt‚ü© tr =
      pure ‚ü®stmt, Sum.rec oStmt (fun i => match i with | 0 => tr 0)‚ü©

Polynomial.degree_sum_le in Mathlib.Algebra.Polynomial.Degree.Definitions

lemma BerlekampWelch_E_ne_zero {e k : ‚Ñï}
  {œâs f : Fin n ‚Üí F}
  {E Q : Polynomial F}
  (h_cond : BerlekampWelchCondition e k œâs f E Q)
  : E ‚â† 0

lemma vappend_left_of_lt {m n : ‚Ñï} {Œ± : Sort u}
    (u : Fin m ‚Üí Œ±) (v : Fin n ‚Üí Œ±) (i : Fin (m + n)) (h : i.val < m) :
      vappend u v i = u ‚ü®i, h‚ü©

@[simp]
theorem runWithOracle_freeMonad_query_roll (f : spec.FunctionType)
    (i : Œπ) (t : spec.domain i)
    (r : (spec.range i) ‚Üí FreeMonad (spec.OracleQuery) (Option Œ±)) :
    runWithOracle f (FreeMonad.roll (query i t) r) = runWithOracle f (r (f i t))

@[simp]
theorem Basis_cast_dest_apply {Œπ : Type*} (Œ± Œ≤ Œ≥ : ‚Ñï)
    (h_le1 : Œ± ‚â§ Œ≤) (h_le2 : Œ± ‚â§ Œ≥)
    (h_eq : Œ≤ = Œ≥) {k : Œπ} (b : @Basis Œπ (ConcreteBTField Œ±) (ConcreteBTField Œ≤) _ _
    (@ConcreteBTFieldAlgebra (l := Œ±) (r := Œ≤) (h_le := h_le1)).toModule) :
    let castBasis : @Basis Œπ (ConcreteBTField Œ±) (ConcreteBTField Œ≥) _ _
      (@ConcreteBTFieldAlgebra (l := Œ±) (r := Œ≥) (h_le := h_le2)).toModule :=
      cast (by
        exact Basis_cast_dest_eq Œ± Œ≥ Œ≤ h_le2 h_le1 h_eq
      ) b
    (castBasis k) = cast (by
      exact cast_ConcreteBTField_eq Œ≤ Œ≥ h_eq) (b k)

theorem hcons_right_injective {Œ≤ : Fin n ‚Üí Sort u} (a : Œ±) :
    Function.Injective (hcons a : ((i : Fin n) ‚Üí Œ≤ i) ‚Üí (i : Fin (n + 1)) ‚Üí vcons Œ± Œ≤ i)

@[simp]
lemma evenPart_by_2 :
  2 * (evenPart f) = f + f.comp (-X)

lemma getLowBits_joinBits {n m : ‚Ñï} (low : Fin (2 ^ n)) (high : Fin (2 ^ m)) :
  getLowBits n (joinBits low high).val = low.val

@[simp]
lemma eval‚ÇÇAlgHom_apply {A : Type w} {B : Type*} [CommSemiring A] [CommSemiring B]
    [PolynomialLike A P] [Algebra R A] [IsScalarTower R A P] [Algebra R B]
    (f : A ‚Üí‚Çê[R] B) (b : B) (p : P) :
    (eval‚ÇÇAlgHom f b) p = eval‚ÇÇ f b p

private lemma sum_K_eq_card : ‚àë (Œ± : F), K B i Œ± = B.card

@[simp]
lemma seqCompose_succ {m : ‚Ñï}
    (Stmt : Fin (m + 2) ‚Üí Type)
    {Œπ‚Çõ : Fin (m + 2) ‚Üí Type} (OStmt : (i : Fin (m + 2)) ‚Üí Œπ‚Çõ i ‚Üí Type)
    [O‚Çõ : ‚àÄ i, ‚àÄ j, OracleInterface (OStmt i j)]
    {n : Fin (m + 1) ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    [O‚Çò : ‚àÄ i, ‚àÄ j, OracleInterface ((pSpec i).Message j)]
    (V : (i : Fin (m + 1)) ‚Üí OracleVerifier oSpec
      (Stmt i.castSucc) (OStmt i.castSucc) (Stmt i.succ) (OStmt i.succ) (pSpec i)) :
    seqCompose Stmt OStmt V =
      append (V 0) (seqCompose (Stmt ‚àò Fin.succ) (fun i => OStmt (Fin.succ i))
        (O‚Çõ := fun i => O‚Çõ (Fin.succ i)) (O‚Çò := fun i => O‚Çò (Fin.succ i))
          (fun i => V (Fin.succ i)))

theorem init_dconcat {motive : Fin (n + 1) ‚Üí Sort u} (v : (i : Fin n) ‚Üí motive (castSucc i))
    (a : motive (last n)) : (fun i => (v :+·µà‚ü®motive‚ü© a) (castSucc i)) = v

lemma eqRec_fun_eqRec_sort_eq_self {Œ± : Sort*} {Œ≤ : Œ± ‚Üí Sort u} {a a' : Œ±}
    (h : a = a') (h' : Œ≤ a = Œ≤ a') (b : Œ≤ a) :
  b = h ‚ñ∏ h' ‚ñ∏ b

omit [NeZero ‚Ñì] [NeZero r] [NeZero ùì°] in
lemma fin_‚Ñì_add_one_lt_r {h_‚Ñì_add_R_rate : ‚Ñì + ùì° < r} (i : Fin (‚Ñì + 1))
    : i.val < r

lemma getBit_of_lowBits {n: ‚Ñï} (numLowBits : ‚Ñï) : ‚àÄ k, getBit k (getLowBits numLowBits n) =
    if k < numLowBits then getBit k n else 0

@[simp]
lemma possibleDeltas_subset_relHammingDistRange :
  possibleDeltas U C ‚äÜ relHammingDistRange Œπ

lemma evenize_eq_comp_x_squared {f : Polynomial F} :
    evenize f = f.comp (Polynomial.X * Polynomial.X)

lemma exists_unique_bivariate
  (qPoly : Polynomial F) (hdeg_q_min : qPoly.natDegree > 0)
  (hdeg_q_max : qPoly.natDegree < Fintype.card F) (fPoly : Polynomial F) :
    -- Q ‚àà ùîΩ[X,Y]
    ‚àÉ! Q : MvPolynomial (Fin 2) F,
      -- deg_x(Q) = Floor ( deg(fPoly) / deg(qPoly) )
      -- This is natural number division towards zero, which is floor
      (MvPolynomial.degreeOf 0 Q = (Polynomial.natDegree fPoly) / (Polynomial.natDegree qPoly)) ‚àß
      -- deg_y(Q) < deg (q)
      (MvPolynomial.degreeOf 1 Q < Polynomial.natDegree qPoly) ‚àß
      -- point‚Äëwise equality on F: f(z) = Q(q(z), z)
      (‚àÄ z : F, Polynomial.eval z fPoly = evalBivar Q (Polynomial.eval z qPoly) z) ‚àß
      (‚àÄ t : ‚Ñï, fPoly.natDegree < t * qPoly.natDegree ‚Üí MvPolynomial.degreeOf 0 Q < t)

lemma bIdx_succ_mul_œë_lt_‚Ñì_succ (bIdx : Fin (‚Ñì / œë - 1)) :
    (‚ÜëbIdx + 1) * œë < ‚Ñì + 1

@[simp]
theorem seqCompose_two_eq_append {n : Fin 2 ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)} :
    seqCompose pSpec = append (pSpec 0) (pSpec 1)

lemma guruswami_sudan_for_proximity_gap_property {k m : ‚Ñï} {œâs : Fin n ‚Ü™ F}
  {f : Fin n ‚Üí F}
  {Q : F[X][X]}
  {p : ReedSolomon.code œâs n}
  (h : Œî‚ÇÄ(f, (ReedSolomon.codewordToPoly p).eval ‚àò f) ‚â§ proximity_gap_johnson (n := n) k m)
  :
  ((X : F[X][X]) - C (ReedSolomon.codewordToPoly p)) ‚à£ Q

@[simp] theorem rightpad_eq_self (l : List Œ±) (n : Nat) (h : n ‚â§ l.length) :
    rightpad n unit l = l

@[simp]
theorem card_univ_filter_eq {e : Œ±} :
  #{x : Œ± | x ‚â† e} = #(Finset.univ (Œ± := Œ±)) - 1

theorem dconcat_right_injective {motive : Fin (n + 1) ‚Üí Sort u}
    (v : (i : Fin n) ‚Üí motive (castSucc i)) :
    Function.Injective (dconcat (motive := motive) v)

Fin.is_le' in Init.Data.Fin.Lemmas

Nat.le_add_left in Init.Data.Nat.Basic

omit [NeZero ‚Ñì] [NeZero r] [NeZero ùì°] in
lemma ‚Ñì_lt_r {h_‚Ñì_add_R_rate : ‚Ñì + ùì° < r}
    : ‚Ñì < r

@[simp]
theorem card_prod_self_eq :
  #(((s √óÀ¢ s : Finset _) ‚à© ({x : Œ± √ó Œ± | x.1 = x.2} : Finset _)) : Finset _) = #s

omit [Fintype L] [DecidableEq L] in
theorem Polynomial.foldl_comp (n : ‚Ñï) (f : Fin n ‚Üí L[X]) : ‚àÄ initInner initOuter: L[X],
    Fin.foldl (n:=n) (fun acc j => (f j).comp acc) (initOuter.comp initInner)
    = (Fin.foldl (n:=n) (fun acc j => (f j).comp acc) (initOuter)).comp initInner

theorem non_trivial_factors_of_non_trivial_poly_have_deg_ge_1 {R : Type*} [Field R]
    {p a b : R[X]}
    (h_prod : p = a * b)
    (h_p_nonzero : p ‚â† 0)
    (h_a_non_unit : ¬¨IsUnit a)
    (h_b_non_unit : ¬¨IsUnit b) :
    1 ‚â§ a.degree ‚àß 1 ‚â§ b.degree

@[csimp, grind =]
theorem idxOf'_eq_idxOf : @idxOf' = @idxOf

@[simp]
theorem dist_le_card (C : Set (n ‚Üí R)) : dist C ‚â§ Fintype.card n

@[grind _=_]
theorem monomialXY_def {n m : ‚Ñï} {a : F} : monomialXY n m a = monomial m (monomial n a)

@[simp]
theorem singleEqPolynomial_one (x : MvPolynomial œÉ R) : singleEqPolynomial (1 : R) x = x

@[simp]
theorem LeafData.leftSubtree_internal {Œ±} {s_left s_right : Skeleton}
    (left : LeafData Œ± s_left) (right : LeafData Œ± s_right) :
    (LeafData.internal left right).leftSubtree = left

theorem fcons‚ÇÇ_right_injective {Œ±‚ÇÅ : A} {Œ±‚ÇÇ : B} {Œ≤‚ÇÅ : Fin n ‚Üí A} {Œ≤‚ÇÇ : Fin n ‚Üí B}
    (a : F‚ÇÇ Œ±‚ÇÅ Œ±‚ÇÇ) :
    Function.Injective
      (fcons‚ÇÇ (F := F‚ÇÇ) a : ((i : Fin n) ‚Üí F‚ÇÇ (Œ≤‚ÇÅ i) (Œ≤‚ÇÇ i)) ‚Üí (i : Fin (n + 1)) ‚Üí _ )

@[simp]
theorem zero_vappend {u : Fin 0 ‚Üí Œ±} (v : Fin n ‚Üí Œ±) :
    vappend u v = v ‚àò Fin.cast (Nat.zero_add n)

@[grind]
lemma quotient_nezero {f q : F[X][Y]} (hg : q * f ‚â† 0) : q ‚â† 0

@[simp] lemma drop_dir : pSpec‚ü¶m:‚üß.dir = pSpec.dir‚ü¶m:‚üß

theorem succ'_ne_zero (n : Nat) : succ' n ‚â† 0

lemma odd_index_intermediate_novel_basis_decomposition
    (i : Fin ‚Ñì) (j : Fin (2 ^ (‚Ñì - i - 1))) :
    intermediateNovelBasisX ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i, by omega‚ü© ‚ü®j * 2 + 1, by
      apply mul_two_add_bit_lt_two_pow j (‚Ñì-i-1) (‚Ñì-i) ‚ü®1, by omega‚ü© (by omega) (by omega)
    ‚ü©  = X * (intermediateNovelBasisX ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®i+1, by omega‚ü© ‚ü®j, by
      apply lt_two_pow_of_lt_two_pow_exp_le j (‚Ñì-i-1) (‚Ñì-(i+1)) (by omega) (by omega)
    ‚ü©).comp (qMap ùîΩq Œ≤ ‚ü®i, by omega‚ü©)

theorem fixFirstVariablesOfMQP_degreeLE {deg : ‚Ñï} (v : Fin (‚Ñì + 1)) {challenges : Fin v ‚Üí L}
    {poly : L[X Fin ‚Ñì]} (hp : poly ‚àà L‚¶É‚â§ deg‚¶Ñ[X Fin ‚Ñì]) :
    fixFirstVariablesOfMQP ‚Ñì v poly challenges ‚àà L‚¶É‚â§ deg‚¶Ñ[X Fin (‚Ñì - v)]

private lemma evenPart_eq_evenPart' {f : Polynomial F} : evenPart f = evenPart' f

lemma join_eq_join_iff (k : ‚Ñï) (h_pos : k > 0) (hi‚ÇÅ hi‚ÇÄ lo‚ÇÅ lo‚ÇÄ : BTField (k - 1)) :
    ‚ãò hi‚ÇÅ, lo‚ÇÅ ‚ãô = ‚ãò hi‚ÇÄ, lo‚ÇÄ ‚ãô ‚Üî
  hi‚ÇÅ = hi‚ÇÄ ‚àß lo‚ÇÅ = lo‚ÇÄ

@[simp, grind _=_]
lemma degreeY_mul [IsDomain F] (f g : F[X][Y]) (hf : f ‚â† 0) (hg : g ‚â† 0)
  : natDegreeY (f * g) = natDegreeY f + natDegreeY g

Nat.sub_mul in Init.Data.Nat.Basic

lemma add_eq_zero_iff_eq {k : ‚Ñï} (a b : ConcreteBTField k) : a + b = 0 ‚Üî a = b

@[simp]
theorem dappend_zero {motive : Fin (m + 0) ‚Üí Sort u} (u : (i : Fin m) ‚Üí motive (castAdd 0 i)) :
    dappend (motive := motive) u !d‚ü®fun _ : Fin 0 => motive (natAdd m _)‚ü©[] = u

@[simp]
lemma range_def : (spec Œ±).range () = Œ±

@[simp]
theorem dcast‚ÇÉ_eq : dcast‚ÇÉ (Eq.refl a) dcast_eq dcast‚ÇÇ_eq d = d

lemma lagrangeToMono_eq_lagrangeToMono_segment (n : ‚Ñï) [NeZero n] (v : Vector R (2 ^ n)) :
  have h_n_ne_zero: n ‚â† 0

@[to_additive]
lemma prod_univ_twos {M : Type*} [CommMonoid M] {n : ‚Ñï} (hn : n = 2) (f : Fin n ‚Üí M) :
    (‚àè i, f i) = f (Fin.cast hn.symm 0) * f (Fin.cast hn.symm 1)

lemma getLowBits_eq_mod_two_pow {numLowBits : ‚Ñï} (n : ‚Ñï) :
  getLowBits numLowBits n = n % (2 ^ numLowBits)

@[simp]
theorem induction_one' {motive : Fin 2 ‚Üí Sort*} {zero : motive 0}
    {succ : ‚àÄ i : Fin 1, motive i.castSucc ‚Üí motive i.succ} :
      induction (motive := motive) zero succ (1 : Fin 2) = succ 0 zero

@[simp]
theorem erase_even_mem
  {s : Finset ‚Ñï}
  {n : ‚Ñï}
  : n ‚àà (erase_even s) ‚Üî Odd n ‚àß n ‚àà s

lemma concreteTowerAlgebraMap_succ_1 (k : ‚Ñï) :
  concreteTowerAlgebraMap (l:=k) (r:=k + 1) (h_le:=by omega) = canonicalAlgMap k

@[simp]
lemma foldl'_succ {n : ‚Ñï} {Œ± : Type u} (f : (i : Fin (n + 1)) ‚Üí Œ± ‚Üí Œ±) (x : Œ±) :
    foldl' (n + 1) f x = f (last n) (foldl' n (fun i => f i.castSucc) x)

lemma cons_get_eq {Œ±} {n : ‚Ñï} (hd : Œ±) (tl : Vector Œ± n) (i : Fin (n + 1)) :
    (cons hd tl).get i =
      if hi: i.val == 0 then hd else tl.get (‚ü®i.val - 1, by
        simp only [beq_iff_eq, Fin.val_eq_zero_iff] at hi
        apply Nat.sub_lt_left_of_lt_add
        ¬∑ by_contra hi_ne_gt_1
          simp only [not_le, Nat.lt_one_iff, Fin.val_eq_zero_iff] at hi_ne_gt_1
          contradiction
        ¬∑ have hi_lt:= i.isLt; omega
      ‚ü©)

@[simp]
theorem vappend_left (u : Fin m ‚Üí Œ±) (v : Fin n ‚Üí Œ±) (i : Fin m) :
    vappend u v (castAdd n i) = u i

lemma mkLastOracleIndex_last : mkLastOracleIndex ‚Ñì œë (Fin.last ‚Ñì) = ‚Ñì / œë - 1

theorem liftContext_perfectCompleteness
    (h : R.perfectCompleteness init impl innerRelIn innerRelOut) :
      (R.liftContext lens).perfectCompleteness init impl outerRelIn outerRelOut

lemma join_via_add_smul_one {k : ‚Ñï} (h_pos : k > 0) :
  ‚ãò 0, 1 ‚ãô = 1

@[simp]
theorem ConcreteBTField.RingHom_cast_dest_apply (k m n : ‚Ñï) (h_eq : m = n)
  (f : ConcreteBTField k ‚Üí+* ConcreteBTField m) (x : ConcreteBTField k) :
    (cast (ConcreteBTField.RingHom_eq_of_dest_eq (k:=k) (m:=m) (n:=n) h_eq) f) x
    = cast (by apply cast_ConcreteBTField_eq (h_eq:=h_eq)) (f x)

lemma getBit_eq_pred_getBit_of_div_two {n k : ‚Ñï} (h_k: k > 0) :
    getBit k (n) = getBit (k-1) (n/2)

lemma liftF'_liftF_of_lt {k : Fin m} (h : k < n) :
  liftF' (n := m) (liftF (n := n) f') k = f' ‚ü®k, by omega‚ü©

lemma rank_eq_if_det_ne_zero {U : Matrix (Fin n) (Fin n) F} [IsDomain F] :
  Matrix.det U ‚â† 0 ‚Üí U.rank = n

lemma sDomain_card (i : Fin r) (h_i : i < ‚Ñì + R_rate) :
    Fintype.card (sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i) = (Fintype.card ùîΩq)^(‚Ñì + R_rate - i)

lemma definingPoly_is_monic {F : Type*} [Field F] [Fintype F] (s : F) [NeZero s] :
  (definingPoly s).Monic

@[simp]
theorem LeafData.get_internal_ofLeft {Œ±} {s_left s_right : Skeleton}
    (left : LeafData Œ± s_left) (right : LeafData Œ± s_right)
    (idxLeft : SkeletonLeafIndex s_left) :
    (LeafData.internal left right).get (SkeletonLeafIndex.ofLeft idxLeft) =
      left.get idxLeft

@[simp]
theorem fflatten‚ÇÇ_one {A : Sort u} {B : Sort v} {F : A ‚Üí B ‚Üí Sort w} {n : Fin 1 ‚Üí ‚Ñï}
    {Œ± : (i : Fin 1) ‚Üí (j : Fin (n i)) ‚Üí A}
    {Œ≤ : (i : Fin 1) ‚Üí (j : Fin (n i)) ‚Üí B}
    {v : (i : Fin 1) ‚Üí (j : Fin (n i)) ‚Üí F (Œ± i j) (Œ≤ i j)} :
    fflatten‚ÇÇ v = v 0

theorem seqCompose_rbrKnowledgeSoundness
    (rel : ‚àÄ i, Set (Stmt i √ó Wit i))
    (V : ‚àÄ i, Verifier oSpec (Stmt i.castSucc) (Stmt i.succ) (pSpec i))
    (rbrKnowledgeError : ‚àÄ i, (pSpec i).ChallengeIdx ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (V i).rbrKnowledgeSoundness init impl
      (rel i.castSucc) (rel i.succ) (rbrKnowledgeError i)) :
      (Verifier.seqCompose Stmt V).rbrKnowledgeSoundness init impl (rel 0) (rel (Fin.last m))
        (fun combinedIdx =>
          letI ij := seqComposeChallengeIdxToSigma combinedIdx
          rbrKnowledgeError ij.1 ij.2)

@[simp]
lemma solutionToE_ne_zero : (solutionToE e k v) ‚â† 0

theorem degreeOf_coeff_finSuccEquivNth (f : MvPolynomial (Fin (n + 1)) R) (j : Fin n) (i : ‚Ñï) :
    degreeOf j (Polynomial.coeff (finSuccEquivNth R p f) i) ‚â§ degreeOf (p.succAbove j) f

List.length_drop in Init.Data.List.TakeDrop

theorem concreteTowerAlgebraMap_succ_last (r : ‚Ñï) : ‚àÄ l : ‚Ñï, (h_le : l ‚â§ r) ‚Üí
  concreteTowerAlgebraMap (l:=l) (r:=r + 1) (h_le:=by
    exact Nat.le_trans (n:=l) (m:=r) (k:=r + 1) (h_le) (by omega)) =
  (concreteTowerAlgebraMap (l:=l + 1) (r:=r + 1) (by omega)).comp (concreteTowerAlgebraMap
    (l:=l) (r:=l + 1) (by omega))

lemma getFoldingChallenges_init_succ_eq (i : Fin ‚Ñì)
    (j : Fin (toOutCodewordsCount ‚Ñì œë i.castSucc)) (challenges : Fin i.succ ‚Üí L)
    (h : ‚Üëj * œë + œë ‚â§ ‚Üëi.castSucc) :
    getFoldingChallenges (r := r) (ùì° := ùì°) (œë := œë) i.castSucc (Fin.init challenges) (‚Üëj * œë)
      (h := by omega) =
    getFoldingChallenges (r := r) (ùì° := ùì°) i.succ challenges (‚Üëj * œë)
      (h := by simp only [Fin.val_succ]; simp only [Fin.coe_castSucc] at h; omega)

omit [DecidableEq L] [DecidableEq ùîΩq] h_Fq_char_prime hF‚ÇÇ hŒ≤_lin_indep h_Œ≤‚ÇÄ_eq_1 in
theorem intermediateNormVpoly_comp (i : Fin ‚Ñì) (k : Fin (‚Ñì - i + 1))
  (l : Fin (‚Ñì - (i.val + k.val) + 1)) :
  intermediateNormVpoly ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i, by omega‚ü©) (k:=‚ü®k + l, by
      simp only; omega‚ü©) =
    (intermediateNormVpoly ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i+k, by omega‚ü©) (k:=‚ü®l, by
      simp only; omega‚ü©)).comp (
  intermediateNormVpoly ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i, by omega‚ü©) (k:=‚ü®k, by
      simp only; omega‚ü©)
  )

theorem foldCommitOracleReduction_perfectCompleteness
    (hInit : init.neverFails) (i : Fin ‚Ñì) (hCR : isCommitmentRound ‚Ñì œë i) :
    OracleReduction.perfectCompleteness
      (pSpec := pSpecFoldCommit ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i)
      (relIn := roundRelation (mp := mp) ùîΩq Œ≤ (œë:=œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) i.castSucc)
      (relOut := roundRelation (mp := mp) ùîΩq Œ≤ (œë:=œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) i.succ)
      (oracleReduction := foldCommitOracleReduction ùîΩq Œ≤ (œë:=œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (ùìë:=ùìë) i hCR) (init := init) (impl := impl)

@[simp]
theorem LeafData.optionComposeBuild_leaf {Œ±} (a : Œ±)
    (compose : Œ± ‚Üí Œ± ‚Üí Option Œ±) :
    (LeafData.leaf a).optionComposeBuild compose = FullData.leaf (.some a)

private lemma Fis_cover_B : B = Finset.univ.biUnion (Fi B i)

lemma matchSize_size {p q : UniPoly Q} :
    let (p', _) := Array.matchSize p q 0
    p'.size = max p.size q.size

@[grind _=_]
lemma degreeX_as_weighted_deg :
  degreeX f = natWeightedDegree f 1 0

theorem foldRelayOracleVerifier_rbrKnowledgeSoundness
    (i : Fin ‚Ñì) (hNCR : ¬¨ isCommitmentRound ‚Ñì œë i) :
    (foldRelayOracleVerifier ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i hNCR).rbrKnowledgeSoundness
      init impl
      (relIn := roundRelation ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        (ùìë:=ùìë) i.castSucc (mp := mp))
      (relOut := roundRelation ùîΩq Œ≤ (œë:=œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
        (ùìë:=ùìë) i.succ (mp := mp))
      (rbrKnowledgeError := fun m => foldKnowledgeError ùîΩq Œ≤ (œë:=œë)
        (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) i ‚ü®m, by
        match m with
        | ‚ü®0, h0‚ü© => nomatch h0
        | ‚ü®1, h1‚ü© => rfl
      ‚ü©)

lemma getBit_eq_succ_getBit_of_mul_two_add_one {n k : ‚Ñï} : getBit (k+1) (2*n + 1) = getBit k n

lemma not_outOfOrder_of_not_combined (h : ¬¨ E trace) : ¬¨ E_time trace state

@[simp]
lemma constantCode_eq_ofNat_zero_iff [Nonempty Œπ] :
  constantCode x Œπ = 0 ‚Üî x = 0

lemma eqRec_fun_eq_eqRec_sort {Œ± : Sort*} {Œ≤ : Œ± ‚Üí Sort u} {a a' : Œ±}
    (h : a = a') (h' : Œ≤ a = Œ≤ a') (b : Œ≤ a) :
  h ‚ñ∏ b = h' ‚ñ∏ b

lemma testBit_false_eq_getBit_eq_0 (k n : Nat) :
  (n.testBit k = false) = ((Nat.getBit k n) = 0)

private lemma solutionToE_from_E
  (h_p_deg : p.natDegree < k)
  (h_dist : (Œî‚ÇÄ(f, p.eval ‚àò œâs) : ‚Ñï) ‚â§ e)
  : solutionToE e k (E_and_Q_to_a_solution e (E œâs f p e) (Q œâs f p e)) = E œâs f p e

@[simp]
lemma finite_possibleDeltas : (possibleDeltas U V).Finite

@[simp]
private lemma E_ne_zero : (E œâs f p e) ‚â† 0

theorem happend_right_eq_hconcat {Œ± : Fin m ‚Üí Sort u} {Œ≤ : Fin 1 ‚Üí Sort u}
    (u : (i : Fin m) ‚Üí Œ± i) (a : (i : Fin 1) ‚Üí Œ≤ i) :
    happend u a = hconcat u (a 0)

omit [Finite F] in
lemma pow_lift : ‚àÄ {a : FÀ£} {i : ‚Ñï} (s : ‚Ñï),
    a ‚àà evalDomain D x i ‚Üí a ^ (2 ^ s) ‚àà evalDomain D x (i + s)

theorem cast_run (stmt : StmtIn) (wit : WitIn)
    (P : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec‚ÇÅ) :
    P.run stmt wit =
      cast (sorry) ((P.cast hn hSpec).run stmt wit)

Nat.add_sub_cancel in Init.Data.Nat.Basic

theorem dconcat_dcons_eq_dcons_dconcat {motive : Fin (n + 2) ‚Üí Sort u} (a : motive 0)
    (v : (i : Fin n) ‚Üí motive (succ (castSucc i))) (b : motive (last (n + 1))) :
    (a ::·µà v) :+·µà‚ü®motive‚ü© b = a ::·µà‚ü®motive‚ü© (v :+·µà b)

lemma blockRelDistance_eq_relHammingDist_of_k_eq_i -- Renamed for clarity
  (i : ‚Ñï) {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F}
  [DecidableEq F] [DecidableEq Œπ] [Smooth œÜ]
  -- The Fintype instance is now declared before it is needed by `hS'`.
  [h_fintype : ‚àÄ i : ‚Ñï, Fintype (indexPowT S œÜ i)]
  (f g : (indexPowT S œÜ i) ‚Üí F) (S' : Finset (indexPowT S œÜ i))
  (hS' : S' = Finset.univ) -- This now works.
  (œÜ' : (indexPowT S œÜ i) ‚Ü™ F)
  [h_dec : DecidableBlockDisagreement i i f S' œÜ'] [DecidableEq (indexPowT S œÜ i)] :
  Œî·µ£(i, i, f, S', œÜ', g) = Œ¥·µ£(f, g)

@[simp]
theorem Iic_zero : Iic (0 : Fin (n + 1)) = {0}

@[simp]
theorem vempty_vappend (v : Fin n ‚Üí Œ±) : vappend !v[] v = v ‚àò Fin.cast (Nat.zero_add n)

@[simp]
theorem OracleReduction.id_runWithLog (stmt : StmtIn) (oStmt : ‚àÄ i, OStmtIn i) (wit : WitIn) :
    (OracleReduction.id : OracleReduction oSpec StmtIn OStmtIn WitIn _ _ _ _).runWithLog
      stmt oStmt wit = pure ‚ü®‚ü®default, ‚ü®stmt, oStmt‚ü©, wit‚ü©, ‚ü®stmt, oStmt‚ü©, [], []‚ü©

lemma X‚±º_zero_eq_one (‚Ñì : ‚Ñï) (h_‚Ñì : ‚Ñì ‚â§ r) :
  X‚±º ùîΩq Œ≤ ‚Ñì h_‚Ñì ‚ü®0, by exact Nat.two_pow_pos ‚Ñì‚ü© = 1

lemma one_is_1 {k : ‚Ñï} : (one (k:=k)) = 1

@[simp]
lemma seqCompose_succ {m : ‚Ñï}
    (Stmt : Fin (m + 2) ‚Üí Type) (Wit : Fin (m + 2) ‚Üí Type)
    {n : Fin (m + 1) ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (R : (i : Fin (m + 1)) ‚Üí
      Reduction oSpec (Stmt i.castSucc) (Wit i.castSucc) (Stmt i.succ) (Wit i.succ) (pSpec i)) :
    seqCompose Stmt Wit R =
      append (R 0) (seqCompose (Stmt ‚àò Fin.succ) (Wit ‚àò Fin.succ) (fun i => R (Fin.succ i)))

@[simp]
lemma eval_polynomialsOfCoeffs [NeZero deg] {Œ± : F} :
  (polynomialOfCoeffs coeffs).eval Œ± = ‚àë x ‚àà {i | coeffs i ‚â† 0}, coeffs x * Œ± ^ x.1

Nat.two_pow_pos in Init.Data.Nat.Basic

@[simp] lemma twoAdicGenerators_succ_square_eq (idx : Nat) (h : idx < twoAdicity) :
    haveI : idx + 1 < twoAdicGenerators.length

omit [NeZero r] [Field L] [Fintype L] [DecidableEq L] [Field ùîΩq] [Algebra ùîΩq L] in
lemma sBasis_range_eq (i : Fin r) (h_i : i < ‚Ñì + R_rate) :
    Œ≤ '' Set.Ico i ‚ü®‚Ñì + R_rate, h_‚Ñì_add_R_rate‚ü©
    = Set.range (sBasis Œ≤ h_‚Ñì_add_R_rate i h_i)

theorem is_prime : Nat.Prime fieldSize

lemma iterated_fold_transitivity
    (i : Fin r) (steps‚ÇÅ steps‚ÇÇ : Fin (‚Ñì + 1))
    (h_bounds : i.val + steps‚ÇÅ + steps‚ÇÇ ‚â§ ‚Ñì) -- A single, sufficient bounds check
    (f : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := i) ‚Üí L)
    (r_challenges‚ÇÅ : Fin steps‚ÇÅ ‚Üí L) (r_challenges‚ÇÇ : Fin steps‚ÇÇ ‚Üí L) :
    -- LHS : The nested fold (folding twice)
    have hi1 : i.val + steps‚ÇÅ ‚â§ ‚Ñì := by exact le_of_add_right_le h_bounds
    have hi2 : i.val + steps‚ÇÇ ‚â§ ‚Ñì := by
      rw [Nat.add_assoc, Nat.add_comm steps‚ÇÅ steps‚ÇÇ, ‚ÜêNat.add_assoc] at h_bounds
      exact le_of_add_right_le h_bounds
    have hi12 : steps‚ÇÅ + steps‚ÇÇ < ‚Ñì + 1 := by
      apply Nat.lt_succ_of_le; rw [Nat.add_assoc] at h_bounds;
      exact Nat.le_of_add_left_le h_bounds
    let lhs := iterated_fold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (i := ‚ü®i.val + steps‚ÇÅ, by -- ‚ä¢ ‚Üëi + ‚Üësteps‚ÇÅ < r
        apply Nat.lt_of_le_of_lt (m := ‚Ñì) (hi1) (‚Ñì_lt_r (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))‚ü©)
      (steps := steps‚ÇÇ)
      (h_i_add_steps := by simp only; apply Nat.lt_add_of_pos_right_of_le; exact h_bounds)
      (f := by
        exact iterated_fold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := i) (steps := steps‚ÇÅ)
          (h_i_add_steps := by apply Nat.lt_add_of_pos_right_of_le; exact hi1) (f := f)
          (r_challenges := r_challenges‚ÇÅ)
      ) r_challenges‚ÇÇ
    let rhs := iterated_fold ùîΩq Œ≤ (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate) (i := i)
      (steps := ‚ü®steps‚ÇÅ + steps‚ÇÇ, hi12‚ü©)
      (h_i_add_steps := by
        simp only; rw [‚ÜêNat.add_assoc]; apply Nat.lt_add_of_pos_right_of_le; exact h_bounds)
      (f := f) (r_challenges := Fin.append r_challenges‚ÇÅ r_challenges‚ÇÇ)
    lhs = by
      simp only [‚ÜêNat.add_assoc] at ‚ä¢ rhs
      exact rhs

lemma forwardRange_getElem (n : ‚Ñï) (r : Fin n) (l : Fin (r.val + 1)) (k : Fin (r.val - l.val + 1)) :
    (forwardRange n r l).get ‚ü®k, by
      rw [forwardRange]; simp only [List.length_ofFn]; omega‚ü© = ‚ü®l.val + k, by omega‚ü©

lemma concrete_mul_one
  (prevBTFieldProps : ConcreteBTFieldProps (k := k - 1))
  (a : ConcreteBTField k) : concrete_mul a (one (k:=k)) = a

@[simp]
lemma elocPolyF_deg {œâs f : Fin n ‚Üí F} : (ElocPolyF œâs f p).natDegree = Œî‚ÇÄ(f, p.eval ‚àò œâs)

lemma last_nonzero_unique {p : UniPoly Q} {k k' : Fin p.size} :
  last_nonzero_prop k ‚Üí last_nonzero_prop k' ‚Üí k = k'

lemma rateOfLinearCode_eq_div [NeZero n] (inj : Function.Injective Œ±) (h : n ‚â§ m) :
  rate (ReedSolomon.code ‚ü®Œ±, inj‚ü© n) = n / m

lemma concrete_mul_assoc0 (a b c : ConcreteBTField 0) :
  concrete_mul (concrete_mul a b) c = concrete_mul a (concrete_mul b c)

theorem append_completeness (R‚ÇÅ : Reduction oSpec Stmt‚ÇÅ Wit‚ÇÅ Stmt‚ÇÇ Wit‚ÇÇ pSpec‚ÇÅ)
    (R‚ÇÇ : Reduction oSpec Stmt‚ÇÇ Wit‚ÇÇ Stmt‚ÇÉ Wit‚ÇÉ pSpec‚ÇÇ)
    {completenessError‚ÇÅ completenessError‚ÇÇ : ‚Ñù‚â•0}
    (h‚ÇÅ : R‚ÇÅ.completeness init impl rel‚ÇÅ rel‚ÇÇ completenessError‚ÇÅ)
    (h‚ÇÇ : R‚ÇÇ.completeness init impl rel‚ÇÇ rel‚ÇÉ completenessError‚ÇÇ) :
      (R‚ÇÅ.append R‚ÇÇ).completeness init impl
        rel‚ÇÅ rel‚ÇÉ (completenessError‚ÇÅ + completenessError‚ÇÇ)

@[grind =]
theorem monomialXY_eq_monomialXY_iff {n m p q : ‚Ñï} {a b : F} :
  monomialXY n m a = monomialXY p q b ‚Üî n = p ‚àß m = q ‚àß a = b ‚à® a = 0 ‚àß b = 0

@[simp]
theorem append_fst (T‚ÇÅ : FullTranscript pSpec‚ÇÅ) (T‚ÇÇ : FullTranscript pSpec‚ÇÇ) :
    (T‚ÇÅ ++‚Çú T‚ÇÇ).fst = T‚ÇÅ

lemma card_le_card_of_count_inj {Œ± Œ≤ : Type*} [DecidableEq Œ±] [DecidableEq Œ≤]
    {s : Multiset Œ±} {s' : Multiset Œ≤}
  {f : Œ± ‚Üí Œ≤} (inj : Function.Injective f) (h : ‚àÄ a : Œ±, s.count a ‚â§ s'.count (f a)) :
  s.card ‚â§ s'.card

theorem insertNth_ne_zero_of_right (h : s ‚â† 0) : insertNth p y s ‚â† 0

@[simp]
theorem InternalData.get_ofFun {Œ±} {s} (f : SkeletonInternalIndex s ‚Üí Œ±) :
    (InternalData.ofFun s f).get = f

theorem generates_quotient_point_if_is_fiber_of_y
    (i : Fin ‚Ñì) (steps : ‚Ñï) (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
    (x : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i, by omega‚ü©))
    (y : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i.val + steps, by omega‚ü©))
    (hx_is_fiber : ‚àÉ (k : Fin (2 ^ steps)), x = qMap_total_fiber ùîΩq Œ≤ (i := ‚ü®i, by omega‚ü©)
      (steps := steps) (h_i_add_steps := by
        simp only; exact fin_‚Ñì_steps_lt_‚Ñì_add_R i steps h_i_add_steps) (y := y) k) :
    y = iteratedQuotientMap ùîΩq Œ≤ h_‚Ñì_add_R_rate i (k := steps) (h_bound := h_i_add_steps) x

protected lemma elocPoly_leftF_leftF_eq_contract {œâs f : Fin m ‚Üí F} :
  ElocPoly n (liftF œâs) (liftF f) =
  ElocPoly n (contract n œâs) (contract n f)

lemma crs_equiv_rs_random_point_agreement
  {f : Œπ ‚Üí F} {m s : ‚Ñï} {œÜ : Œπ ‚Ü™ F} [Smooth œÜ] :
  ‚àÄ (r : Fin s ‚Üí Fin m ‚Üí F) (Œ¥ : ‚Ñù‚â•0) (hŒ¥Le : Œ¥ ‚â§ 1),
    (‚àÉ u u' : smoothCode œÜ m,
      u.val ‚â† u'.val ‚àß
      u.val ‚àà relHammingBall (smoothCode œÜ m) f Œ¥ ‚àß
      u'.val ‚àà relHammingBall (smoothCode œÜ m) f Œ¥ ‚àß
      ‚àÄ i : Fin s, (mVdecode u).eval (r i) = (mVdecode u').eval (r i))
    ‚Üî
    (‚àÉ œÉ : Fin s ‚Üí F,
      let w : Fin s ‚Üí MvPolynomial (Fin (m + 1)) F :=
        fun i => MvPolynomial.X (Fin.last m) * rename Fin.castSucc (eqPolynomial (r i))
      let multiCRSCode := multiConstrainedCode œÜ m s w œÉ
      ‚àÉ u u' : Œπ ‚Üí F, u ‚â† u' ‚àß
        u ‚àà relHammingBall multiCRSCode f Œ¥ ‚àß
        u' ‚àà relHammingBall multiCRSCode f Œ¥)

theorem zero_add : 0 + p = p

@[simp]
lemma not_P_to_V_eq_V_to_P {x : Direction} (h : x ‚â† .V_to_P) : x = .P_to_V

theorem finalSumcheckOracleReduction_perfectCompleteness {œÉ : Type}
  (init : ProbComp œÉ)
  (impl : QueryImpl []‚Çí (StateT œÉ ProbComp))
  (hInit : init.neverFails) :
  OracleReduction.perfectCompleteness
    (pSpec := pSpecFinalSumcheckStep (L := L))
    (relIn := roundRelation ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)
      (ùìë := ùìë) (mp := BBF_SumcheckMultiplierParam) (Fin.last ‚Ñì))
    (relOut := finalSumcheckRelOut ùîΩq Œ≤ (œë := œë) (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate))
    (oracleReduction := finalSumcheckOracleReduction ùîΩq Œ≤ (œë := œë)
      (h_‚Ñì_add_R_rate := h_‚Ñì_add_R_rate)) (init := init) (impl := impl)

@[grind ‚Üê]
lemma mul_ne_zero [IsDomain F] (f g : F[X][Y]) (hf : f ‚â† 0) (hg : g ‚â† 0) :
  f * g ‚â† 0

@[simp]
theorem append_snd (T‚ÇÅ : FullTranscript pSpec‚ÇÅ) (T‚ÇÇ : FullTranscript pSpec‚ÇÇ) :
    (T‚ÇÅ ++‚Çú T‚ÇÇ).snd = T‚ÇÇ

private lemma BerlekampWelchCondition_to_Solution' [NeZero n]
  (h : BerlekampWelchCondition e k œâs f (solutionToE e k v) (solutionToQ e k v))
  : IsBerlekampWelchSolution e k œâs f v

lemma Fin.lt_succ' (a : Fin r) (h_a_add_1 : a + 1 < r) : a < a + 1

nonpos_iff_eq_zero in Mathlib.Algebra.Order.Monoid.Canonical.Defs

@[to_additive]
theorem prod_Iio_succ (i : Fin n) :
    ‚àè j ‚àà Iio i.succ, v j = (‚àè j ‚àà Iio i.castSucc, v j) * v i.castSucc

lemma twoAdicGenerator_unit_mem_rootsOfUnity
    (bits : Fin (twoAdicity + 1)) (h : twoAdicGenerators[bits] ‚â† 0) :
    Units.mk0 (twoAdicGenerators[bits]) h ‚àà rootsOfUnity (2 ^ (bits : Nat)) (Field)

beq_iff_eq in Init.Core

@[simp]
lemma addSalt_dir : (pSpec.addSalt Salt).dir = pSpec.dir

lemma and_two_pow_eq_two_pow_of_getBit_eq_one {n i : ‚Ñï} (h_getBit: getBit i n = 1)
    : n &&& (2 ^ i) = 2 ^ i

@[simp]
theorem cast_id :
    Reduction.cast rfl rfl = (id : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec‚ÇÅ ‚Üí _)

lemma one_le_sub_middle_of_pow2 {k : ‚Ñï} (h_k : 1 ‚â§ k) : 1 ‚â§ 2 ^ k - 2 ^ (k - 1)

theorem prime_19 : Nat.Prime 19

omit [Finite F] in
@[simp]
lemma range_lem‚ÇÅ {i : Fin (k + 1)} :
    [FinalOracleStatement D x s]‚Çí.range ‚ü®i.1, Nat.lt_succ_of_lt i.2‚ü© = F

lemma binaryTowerAlgebra_def (l r : ‚Ñï) (h_le : l ‚â§ r) :
    @binaryAlgebraTower (l:=l) (r:=r) (h_le:=h_le)
    = (towerAlgebraMap l r h_le).toAlgebra

@[simp]
lemma challengeOracleInterface_append_range_inl (j : pSpec‚ÇÅ.ChallengeIdx) :
    [(pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).Challenge]‚Çí.range (.inl j) = pSpec‚ÇÅ.Challenge j

private lemma johnson_unrefined [Zero F]
  (h_n : 0 < n)
  (h_B : 2 ‚â§ B.card)
  (h_card : 2 ‚â§ (Fintype.card F))
  :
  (1 - e B 0 / n) ^ 2 * B.card + B.card * (e B 0) ^ 2 / ((Fintype.card F - 1) * n^2) - 1
  ‚â§
  (B.card - 1) * (1 - d B/n)

lemma not_inv_of_not_combined (h : ¬¨ E trace) : ¬¨ E_inv trace state

theorem zipWith_cons {Œ± Œ≤ Œ≥} {n : ‚Ñï} (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥)
    (a : Œ±) (b : Vector Œ± n) (c : Œ≤) (d : Vector Œ≤ n) :
    zipWith f (cons a b) (cons c d) = cons (f a c) (zipWith f b d)

theorem not_exists_of_decoder_eq_none {e k : ‚Ñï} [NeZero n] {œâs f : Fin n ‚Üí F}
  (he : 2 * e < n - k + 1)
  (hn : k ‚â§ n)
  (h_inj : Function.Injective œâs)
  (h_none : decoder e k œâs f = none)
  : ¬¨‚àÉp : F[X], Œî‚ÇÄ(f, p.eval ‚àò œâs) ‚â§ e ‚àß p.natDegree < k

@[simp]
theorem hcons_succ {Œ≤ : Fin n ‚Üí Sort u} (a : Œ±) (v : (i : Fin n) ‚Üí Œ≤ i) (i : Fin n) :
    hcons a v i.succ = cast (vcons_succ Œ± Œ≤ i).symm (v i)

@[simp]
theorem Prover.run_of_prover_first [ProverOnly pSpec] (stmt : StmtIn) (wit : WitIn)
    (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      prover.run stmt wit = (do
        let state := prover.input (stmt, wit)
        let ‚ü®msg, state‚ü© ‚Üê liftComp (prover.sendMessage ‚ü®0, by simp‚ü© state) _
        let ctxOut ‚Üê prover.output state
        return ((fun i => match i with | ‚ü®0, _‚ü© => msg), ctxOut))

private lemma sum_sum_K_i_eq_n_sub_d
  (h_B : 2 ‚â§ B.card)
  :
  ‚àë i, sum_choose_K_i B i = choose_2 B.card * (n - d B)

@[simp]
lemma degreeY_monomialXY {n m : ‚Ñï} {a : F} (ha : a ‚â† 0) :
  natDegreeY (monomialXY n m a) = m

@[simp]
private lemma oddPart'_coeff {f : Polynomial F} {n : ‚Ñï} :
    (oddPart' f).coeff n = if Even n then f.coeff (n + 1) else 0

@[simp]
theorem BTField.RingHom_cast_dest_AdjoinRoot_apply (k m : ‚Ñï)
  (f : BTField k ‚Üí+* AdjoinRoot (poly m)) (x : BTField k) :
  (cast (BTField.RingHom_eq_of_dest_AdjoinRoot_eq (k:=k) (m:=m)).symm f) x
  = cast (BTField_succ_eq_adjoinRoot m) (f x)

@[simp] theorem rightpad_prefix (n : Nat) (unit : Œ±) (l : List Œ±) :
    l <+: rightpad n unit l

private lemma johnson_denom [Zero F]
  (h_card : 2 ‚â§ (Fintype.card F))
  :
  (Fintype.card F / (Fintype.card F - 1)) *
  ((1 - e B 0 / n) ^ 2  + (e B 0) ^ 2 / ((Fintype.card F - 1) * n^2) - 1 + d B/n)
  =
  (1 - ((Fintype.card F) / (Fintype.card F - 1)) *
  (e B 0 / n)) ^ 2 - (1 - ((Fintype.card F) / (Fintype.card F - 1)) * (d B/n))

Nat.add_zero in Init.Core

@[simp]
theorem binaryTowerAlgebra_id {l r : ‚Ñï} (h_eq : l = r) :
    @binaryAlgebraTower l r (h_le:=by omega) =
    (h_eq ‚ñ∏ (Algebra.id (BTField l)) : Algebra (BTField l) (BTField r))

private lemma le_sum_sum_choose_K [Zero F]
  (h_n : 0 < n)
  (h_B : B.card ‚â† 0)
  (h_card : 2 ‚â§ Fintype.card F)
  :
  n * (choose_2 (k B) + (Fintype.card (Œ± := F) - 1)
    * choose_2 ((B.card - k B) / ((Fintype.card (Œ± := F) - 1))))
  ‚â§ ‚àë i, sum_choose_K_i B i

theorem fiatShamir_completeness (relIn : Set (StmtIn √ó WitIn)) (relOut : Set (StmtOut √ó WitOut))
    (completenessError : ‚Ñù‚â•0) (R : Reduction oSpec StmtIn WitIn StmtOut WitOut pSpec) :
  R.completeness init impl relIn relOut completenessError ‚Üí
    R.fiatShamir.completeness (do return (‚Üê init, by unfold FunctionType; sorry))
      (impl ++‚Çõ‚Çí fsChallengeQueryImpl' :
        QueryImpl (oSpec ++‚Çí srChallengeOracle StmtIn pSpec)
          (StateT (œÉ √ó (srChallengeOracle StmtIn pSpec).FunctionType) ProbComp))
        relIn relOut completenessError

lemma rank_eq_min_row_col_rank : U.rank = min (rowRank U) (colRank U)

Fin.val_injective in Mathlib.Data.Fin.Basic

@[ext]
lemma ext {m n : ChurchNat Œ±} (h : ‚àÄ f x, m f x = n f x) : m = n

private lemma choose_2_eq_half_f :
  choose_2 = (1/2) * f

theorem add_assoc (a b c : AssocNat) : (a + b) + c = a + (b + c)

theorem degreeOf_eval_C_finSuccEquiv (p : MvPolynomial (Fin (n + 1)) R) (j : Fin n) (x : R) :
    degreeOf j (Polynomial.eval (C x) (finSuccEquiv R n p)) ‚â§ degreeOf j.succ p

@[simp] theorem ofNat_add (n m : Nat) : ofNat (n + m) = add (ofNat n) (ofNat m)

lemma W_prod_comp_decomposition
    (i : Fin r) (hi : i > 0) :
    (W ùîΩq Œ≤ i) = ‚àè c: ùîΩq, (W ùîΩq Œ≤ (i-1)).comp (X - C (c ‚Ä¢ Œ≤ (i-1)))

theorem vflatten_eq_vappend_last {m : ‚Ñï} {n : Fin (m + 1) ‚Üí ‚Ñï}
    {v : (i : Fin (m + 1)) ‚Üí Fin (n i) ‚Üí Œ±} :
    vflatten v =
      vappend (vflatten (fun i => v i.castSucc)) (v (last _)) ‚àò Fin.cast vsum_castSucc

@[simp]
theorem rtake_apply (v : (i : Fin n) ‚Üí Œ± i) (m : ‚Ñï) (h : m ‚â§ n)
    (i : Fin m) : rtake m h v i = v (Fin.cast (Nat.sub_add_cancel h) (natAdd (n - m) i))

theorem image_support_finSuccEquivNth {f : MvPolynomial (Fin (n + 1)) R} {i : ‚Ñï} :
    Finset.image (Finsupp.insertNth p i) (Polynomial.coeff ((finSuccEquivNth R p) f) i).support =
      f.support.filter fun m => m p = i

omit [DecidableEq L] [Fintype ùîΩq] hŒ≤_lin_indep in
lemma W_ne_zero (i : Fin r) : (W ùîΩq Œ≤ i) ‚â† 0

lemma schwartz_zippel' {p : MvPolynomial œÉ R} (hp : p ‚â† 0) (S : œÉ ‚Üí Finset R) :
    #{x ‚àà Finset.pi p.vars S | eval (extendDomain x) p = 0} / ‚àè i ‚àà p.vars, (#(S i) : ‚Ñö‚â•0)
      ‚â§ ‚àë i ‚àà p.vars, (p.degreeOf i / #(S i) : ‚Ñö‚â•0)

lemma erase_even_def {s : Finset ‚Ñï} :
    erase_even s = s.filter Odd

private lemma natDegree_Q
  (h : (Œî‚ÇÄ(f, p.eval ‚àò œâs) : ‚Ñï) ‚â§ e) :
  (Q œâs f p e).natDegree ‚â§ e + p.natDegree

@[simp]
theorem Basis_cast_index_apply {Œ± Œ≤ i j : ‚Ñï} {k : Fin j}
    (h_le : Œ± ‚â§ Œ≤) (h_eq : i = j)
    {b : @Basis (Fin (i)) (ConcreteBTField Œ±) (ConcreteBTField Œ≤) _ _
      (@ConcreteBTFieldAlgebra (l := Œ±) (r := Œ≤) (h_le := h_le)).toModule} :
  let castBasis : @Basis (Fin j) (ConcreteBTField Œ±) (ConcreteBTField Œ≤) _ _
    (@ConcreteBTFieldAlgebra (l:=Œ±) (r:=Œ≤) (h_le:=h_le)).toModule :=
    cast (by exact Basis_cast_index_eq i j Œ± Œ≤ h_le h_eq) b
  (castBasis k) = b (Fin.cast (h_eq.symm) k)

theorem degrees_peval {x : œÉ‚ÇÅ ‚Üí R} {f : œÉ ‚Üí œÉ‚ÇÅ ‚äï œÉ‚ÇÇ} {p : MvPolynomial œÉ R} :
    (peval f x p).degrees ‚â§ (p.degrees.map f).filterMap Sum.getRight?

@[simp]
theorem seqCompose_one {n : Fin 1 ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)} :
    seqCompose pSpec = pSpec 0

theorem stir_rbr_soundness
    [SelectableType F] {s : ‚Ñï}
    {P : Params Œπ F} {œÜ : (i : Fin (M + 1)) ‚Üí (Œπ i ‚Ü™ F)}
    [h_nonempty : ‚àÄ i : Fin (M + 1), Nonempty (Œπ i)]
    {hParams : ParamConditions Œπ P} {Dist : Distances M}
    {Codes : CodeParams Œπ P Dist}
    (h_not_code : ‚àÄ f‚ÇÄ : (Œπ 0) ‚Üí F, f‚ÇÄ ‚àâ (Codes.C 0))
    (hŒ¥‚ÇÄLe : ‚àÄ f‚ÇÄ : (Œπ 0) ‚Üí F, Dist.Œ¥ 0 ‚â§ (Œ¥·µ£(f‚ÇÄ, (Codes.C 0)) : ‚Ñù) ‚àß
      Dist.Œ¥ 0 < (1 - Bstar (rate (code (P.œÜ 0) P.deg))))
    (hŒ¥·µ¢ : ‚àÄ {j : Fin (M + 1)}, j ‚â† 0 ‚Üí
        Dist.Œ¥ j < (1 - rate (code (P.œÜ j) (degree Œπ P j))
          - 1 / Fintype.card (Œπ j) : ‚Ñù) ‚àß
        Dist.Œ¥ j < (1 - Bstar (rate (code (P.œÜ j) (degree Œπ P j)))))
    (Œµ_fold : ‚Ñù‚â•0) (Œµ_out : Fin M ‚Üí ‚Ñù‚â•0) (Œµ_shift : Fin M ‚Üí ‚Ñù‚â•0) (Œµ_fin : ‚Ñù‚â•0) :
    ‚àÉ n : ‚Ñï,
    -- There exists an `n`-message vector IOPP,
    ‚àÉ vPSpec : ProtocolSpec.VectorSpec n,
    -- such that there are `2 * M + 2` challenges from the verifier to the prover,
    Fintype.card (vPSpec.ChallengeIdx) = 2 * M + 2 ‚àß
    -- ‚àÉ vector IOPP œÄ with the aforementioned `vPSpec`, and for
    -- `Statement = Unit, Witness = Unit, OracleStatement(Œπ‚ÇÄ, F)` such that
    ‚àÉ œÄ : VectorIOP Unit (OracleStatement (Œπ 0) F) Unit vPSpec F,
    let Œµ_rbr : vPSpec.ChallengeIdx ‚Üí ‚Ñù‚â•0

theorem intermediateNormVpoly_comp_qmap (i : Fin (‚Ñì))
    (k : Fin (‚Ñì - i - 1)) : -- corresponds to intermediateNormVpoly_comp

omit [SelectableType R] in
@[simp]
lemma oracleReduction_verifier_eq_verifier {i : Fin n} :
    (oracleReduction R n deg D oSpec i).verifier = oracleVerifier R n deg D oSpec i

theorem add_comm (m n : ChurchNat Œ±) : add m n = add n m

theorem BitVec.extractLsb_eq_and_pow_2_minus_1_ofNat {n num_bits : Nat}
  (h_num_bits : num_bits > 0) (x : BitVec n) :
  BitVec.extractLsb (hi:= num_bits - 1) (lo := 0) x =
    BitVec.ofNat (num_bits - 1 - 0 + 1) (x.toNat &&& (2 ^ num_bits - 1))

@[simp]
theorem OracleVerifier.id_soundness {lang : Set (StmtIn √ó ‚àÄ i, OStmtIn i)} :
    (OracleVerifier.id : OracleVerifier oSpec _ _ _ _ _).soundness
      init impl lang lang 0

@[simp]
theorem generateProof_ofRight {sleft sright : Skeleton}
    (cache_tree : FullData Œ± (Skeleton.internal sleft sright))
    (idxRight : SkeletonLeafIndex sright) :
    generateProof cache_tree (BinaryTree.SkeletonLeafIndex.ofRight idxRight) =
      (cache_tree.leftSubtree).getRootValue ::
        (generateProof cache_tree.rightSubtree idxRight)

theorem cast_symm {hn} (hSpec : pSpec‚ÇÅ.cast hn = pSpec‚ÇÇ) : pSpec‚ÇÇ.cast hn.symm = pSpec‚ÇÅ

@[simp]
theorem splitSum_zero {n : Fin 0 ‚Üí ‚Ñï} {k : Fin (vsum n)} : splitSum k = Fin.elim0 k

@[simp]
theorem reduction_completeness (h : init.neverFails)
    (hRel : ‚àÄ stmtIn witIn, (stmtIn, witIn) ‚àà relIn ‚Üî
      (mapStmt stmtIn, mapWit stmtIn witIn) ‚àà relOut) :
    (reduction oSpec mapStmt mapWit).perfectCompleteness init impl relIn relOut

theorem vappend_assoc {p : ‚Ñï} (u : Fin m ‚Üí Œ±) (v : Fin n ‚Üí Œ±) (w : Fin p ‚Üí Œ±) :
    (vappend (vappend u v) w) = (vappend u (vappend v w)) ‚àò Fin.cast (add_assoc m n p)

omit [Finite F] in
lemma dom_n_eq_triv : evalDomain D x n = {x ^ (2 ^ n)}

theorem srKnowledgeSoundness_addSalt_implies_srKnowledgeSoundness_original
    (relIn : Set (StmtIn √ó WitIn)) (relOut : Set (StmtOut √ó WitOut))
    (Salt : pSpec.MessageIdx ‚Üí Type) [‚àÄ i, Nonempty (Salt i)] [‚àÄ i, Fintype (Salt i)]
    (verifier : Verifier oSpec StmtIn StmtOut pSpec)
    (srInit : ProbComp (srChallengeOracle StmtIn (pSpec.addSalt Salt)).FunctionType)
    (srImpl : QueryImpl oSpec
      (StateT (srChallengeOracle StmtIn (pSpec.addSalt Salt)).FunctionType ProbComp))
    (srKnowledgeError : ‚Ñù‚â•0) :
      Verifier.StateRestoration.knowledgeSoundness srInit srImpl relIn relOut
        (verifier.addSalt Salt) srKnowledgeError ‚Üí
        Verifier.StateRestoration.knowledgeSoundness sorry sorry relIn relOut
          verifier srKnowledgeError

lemma degree_W (i : Fin r) : (W ùîΩq Œ≤ i).degree = (Fintype.card ùîΩq)^i.val

lemma johnson_condition_strong_iff_johnson_denom_pos {B : Finset (Fin n ‚Üí F)} {v : Fin n ‚Üí F} :
  JohnsonConditionStrong B v ‚Üî 0 < JohnsonDenominator B v

lemma add_self_cancel {k : ‚Ñï} (a : ConcreteBTField k) : a + a = 0

@[simp]
lemma eval_solutionToE {x : F} :
  eval x (solutionToE e k v) = x ^ e + ‚àë y : Fin e, v ‚ü®y, by omega‚ü© * x ^ y.1

theorem toPoly_toImpl {p : Q[X]} : p.toImpl.toPoly = p

@[simp]
lemma evalDist_cast (h : Œ± = Œ≤) [spec.FiniteRange] :
    evalDist (cast (congrArg (OracleComp spec) h) oa) =
      cast (congrArg (PMF ‚àò Option) h) (evalDist oa)

theorem support_mul_C_le (p : MvPolynomial œÉ R) (r : R) : (p * C r).support ‚äÜ p.support

lemma h_sum_two_same_pow2 {k : ‚Ñï} (h_pos : k > 0) : 2 ^ (k - 1) + 2 ^ (k - 1) = 2 ^ k

theorem sum_fromNat_eq_from_xor_Nat {k : ‚Ñï} (x y : Nat) :
  fromNat (k:=k) (x ^^^ y) = fromNat (k:=k) x + fromNat (k:=k) y

lemma oodSampling_rs_le_bound
    {f : Œπ ‚Üí F} {m s : ‚Ñï} {œÜ : Œπ ‚Ü™ F} [Smooth œÜ]
    (Œ¥ l : ‚Ñù‚â•0) (hŒ¥Le : Œ¥ ‚â§ 1)
    (C : Set (Œπ ‚Üí F)) (hcode : C = smoothCode œÜ m ‚àß listDecodable C Œ¥ l) :
    Pr_{ let rs ‚Üê$·µñ (Fin s ‚Üí F) }[ ‚àÉ u u' : smoothCode œÜ m,
                        u.val ‚â† u'.val ‚àß
                        u.val ‚àà relHammingBall C f Œ¥ ‚àß
                        u'.val ‚àà relHammingBall C f Œ¥ ‚àß
                        ‚àÄ i : Fin s,
                          let ri := rs i
                          let rVec := fun j : Fin m => ri ^ (2^(j : ‚Ñï))
                          (mVdecode u).eval (rVec) = (mVdecode u').eval (rVec)
                      ] ‚â§ ENNReal.ofReal (((l : ‚Ñù)^2 / 2) * (((2^m : ‚Ñù) / Fintype.card F)^s))

lemma Nat.Prime.dvd_mul_list {p : ‚Ñï} {l : List ‚Ñï} (h : p.Prime) :
    p ‚à£ l.prod ‚Üî ‚àÉ r ‚àà l, p ‚à£ r

@[csimp]
theorem dappend_eq_addCases : @dappend = @addCases

theorem insertNth_ne_zero_of_left (h : y ‚â† 0) : insertNth p y s ‚â† 0

@[simp]
lemma constantCode_mem_code [NeZero n] :
  constantCode x Œπ ‚àà ReedSolomon.code Œ± n

theorem oddRefinement_eq_novel_poly_of_1_leading_suffix (i : Fin ‚Ñì) (v : Fin (2 ^ i.val))
    (original_coeffs : Fin (2 ^ ‚Ñì) ‚Üí L) :
    have h_v: v.val ||

theorem hconcat_left_injective {Œ± : Fin n ‚Üí Sort u} {Œ≤ : Sort u} (a : Œ≤) :
    Function.Injective (fun v : (i : Fin n) ‚Üí Œ± i => hconcat v a)

lemma relHammingDist_le_blockRelDistance
  (i k : ‚Ñï) {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F} {œÜ' : (indexPowT S œÜ i) ‚Ü™ F}
  [DecidableEq F] [DecidableEq Œπ] [Smooth œÜ]
  (f g : (indexPowT S œÜ i) ‚Üí F) (S' : Finset (indexPowT S œÜ i))
  [h_fintype : ‚àÄ i : ‚Ñï, Fintype (indexPowT S œÜ i)]
  [DecidableEq (indexPowT S œÜ i)] [Smooth œÜ']
  [h_dec : DecidableBlockDisagreement i k f S' œÜ'] :
  Œ¥·µ£(f, g) ‚â§ Œî·µ£(i, k, f, S', œÜ', g)

theorem add_size {p q : UniPoly Q} : (add_raw p q).size = max p.size q.size

@[simp]
theorem cast_dir_idx {hn} (hSpec : pSpec‚ÇÅ.cast hn = pSpec‚ÇÇ) {i : Fin n‚ÇÅ} :
    pSpec‚ÇÇ.dir (Fin.cast hn i) = pSpec‚ÇÅ.dir i

lemma forwardRange_0_eq_finRange (n : ‚Ñï) [NeZero n] : forwardRange n ‚ü®n - 1, by
    have h_ne

@[simp]
lemma relHammingDist_le_one : Œ¥·µ£(u, v) ‚â§ 1

lemma contract_eq_liftF_of_lt {k : ‚Ñï} (h‚ÇÅ : k < m) :
  contract m f' k = liftF f' k

theorem is_unit_iff_deg_0 {R : Type*} [Field R] {p : R[X]} : p.degree = 0 ‚Üî IsUnit p

omit h_Œ≤‚ÇÄ_eq_1 in
lemma finToBinaryCoeffs_sDomainToFin (i : Fin r) (h_i : i < ‚Ñì + R_rate)
    (x : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate i) :
    let pointFinIdx := (sDomainToFin ùîΩq Œ≤ h_‚Ñì_add_R_rate i h_i) x
    finToBinaryCoeffs ùîΩq (i := i) (idx :=pointFinIdx) =
    (sDomain_basis ùîΩq Œ≤
    h_‚Ñì_add_R_rate i h_i).repr x

theorem le_iff_toNat_le (a b : AssocNat) : a ‚â§ b ‚Üî toNat a ‚â§ toNat b

theorem unique_linear_form_of_elements_in_adjoined_commring
    {R : Type*} [CommRing R] (f : R[X]) (hf_deg : f.natDegree = 2)
    (hf_monic : Monic f) (c1 : AdjoinRoot f) :
    ‚àÉ! p : R √ó R, c1 = (AdjoinRoot.of f) p.1 * root f + (AdjoinRoot.of f) p.2

@[simp]
theorem LeafData.ofFun_get {Œ±} {s} (tree : LeafData Œ± s) :
    LeafData.ofFun s (fun idx => tree.get idx) = tree

@[simp]
theorem Reduction.id_runWithLog (stmt : StmtIn) (wit : WitIn) :
    (Reduction.id : Reduction oSpec StmtIn WitIn _ _ _).runWithLog stmt wit =
      pure ‚ü®‚ü®‚ü®default, stmt, wit‚ü©, stmt‚ü©, [], []‚ü©

Fin.eta in Init.Data.Fin.Lemmas

pow_one in Mathlib.Algebra.Group.Defs

lemma BTField.coe_one_succ (l : ‚Ñï) :
  (@binaryAlgebraTower (l:=l) (r:=l+1) (h_le:=by omega)).algebraMap (1 : BTField l) =
    (1 : BTField (l+1))

lemma degree_s_smul_X {F : Type*} [Field F] [Fintype F] (s : F) [NeZero s] :
  (C s * (X : (F)[X])).degree = 1

theorem liftContext_soundness [Inhabited InnerStmtOut]
    {outerLangIn : Set OuterStmtIn} {outerLangOut : Set OuterStmtOut}
    {innerLangIn : Set InnerStmtIn} {innerLangOut : Set InnerStmtOut}
    {soundnessError : ‚Ñù‚â•0}
    {lens : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut}
    (V : Verifier oSpec InnerStmtIn InnerStmtOut pSpec)
    -- TODO: figure out the right compatibility relation for the IsSound condition
    [lensSound : lens.IsSound outerLangIn outerLangOut innerLangIn innerLangOut
      (V.compatStatement lens)]
    (h : V.soundness init impl innerLangIn innerLangOut soundnessError) :
      (V.liftContext lens).soundness init impl outerLangIn outerLangOut soundnessError

@[simp]
theorem snoc_init_self : snoc (init t) (t (Fin.last n)) = t

lemma rank_eq_if_subUpFull_eq (h : n ‚â§ m) :
   (subUpFull U (Fin.castLE h)).rank = n  ‚Üí U.rank = n

@[simp]
theorem vconcat_castSucc (v : Fin n ‚Üí Œ±) (a : Œ±) (i : Fin n) :
    vconcat v a (castSucc i) = v i

@[simp]
theorem fflatten_two_eq_append {A : Sort u} {F : A ‚Üí Sort v} {n : Fin 2 ‚Üí ‚Ñï}
    {Œ± : (i : Fin 2) ‚Üí (j : Fin (n i)) ‚Üí A}
    {v : (i : Fin 2) ‚Üí (j : Fin (n i)) ‚Üí F (Œ± i j)} :
    fflatten v = fappend (F := F) (v 0) (v 1)

theorem support_C_subset {r : R} : (@C R œÉ _ r).support ‚äÜ { 0 }

@[simp]
lemma oddPart_coeff {f : Polynomial F} {n : ‚Ñï} :
    (oddPart f).coeff n = if Even n then f.coeff (n + 1) else 0

@[to_additive (attr := simp)]
theorem prod_Iic_zero : ‚àè j ‚àà Iic 0, v j = v 0

theorem mul_one {a : CNat 50} : a * 1 = a

theorem base_intermediateNovelBasisX (j : Fin (2 ^ ‚Ñì)) :
  intermediateNovelBasisX ùîΩq Œ≤ h_‚Ñì_add_R_rate ‚ü®0, by
    by_contra ht
    simp only [not_lt, nonpos_iff_eq_zero] at ht
    contradiction
  ‚ü© j =
  X‚±º ùîΩq Œ≤ ‚Ñì (by omega) j

@[simp]
theorem LeafData.map_internal {Œ± Œ≤} {s_left s_right : Skeleton}
    (f : Œ± ‚Üí Œ≤) (left : LeafData Œ± s_left) (right : LeafData Œ± s_right) :
    (LeafData.internal left right).map f =
      LeafData.internal (left.map f) (right.map f)

lemma concrete_mul_one0 (a : ConcreteBTField 0) :
  concrete_mul a (one (k:=0)) = a

lemma definingPoly_coeffOf0 {F : Type*} [Field F] [Fintype F] (s : F) [NeZero s] :
    (definingPoly s).coeff 0 = 1

theorem join_of_split {k : ‚Ñï} (h_pos : k > 0) (x : ConcreteBTField k)
    (hi_btf lo_btf : ConcreteBTField (k - 1))
    (h_split_eq : split h_pos x = (hi_btf, lo_btf)) :
    x = „Ää hi_btf, lo_btf „Äã

theorem canonical_ext [LawfulBEq R] {p q : UniPoly R} (hp : p.trim = p) (hq : q.trim = q) :
    equiv p q ‚Üí p = q

protected lemma roots_of_eloc_poly {x : F}
  (h : (ElocPoly n œâs f p).eval x = 0) :
  ‚àÉ i, i < n ‚àß f i ‚â† p.eval (œâs i)

theorem linear_form_of_elements_in_adjoined_commring
    {R : Type*} [CommRing R] (f : R[X]) (hf_deg : f.natDegree = 2)
    (hf_monic : Monic f) (c1 : AdjoinRoot f) :
    ‚àÉ a b : R, c1 = (AdjoinRoot.of f) a * root f + (AdjoinRoot.of f) b

@[simp]
theorem Set.not_mem_language_iff {Œ± Œ≤} (rel : Set (Œ± √ó Œ≤)) (stmt : Œ±) :
    stmt ‚àâ rel.language ‚Üî ‚àÄ wit, (stmt, wit) ‚àâ rel

@[simp]
theorem tail_vcons (a : Œ±) (v : Fin n ‚Üí Œ±) : tail (a ::·µõ v) = v

Nat.succ_lt_succ_iff in Init.Data.Nat.Basic

@[simp]
lemma length_getTypes (l : HList) : l.getTypes.length = l.length

theorem heq_of_dcast (ha : a = a') (hb : dcast ha b = b') : HEq b b'

@[simp]
lemma finite_possibleRelHammingDists : (possibleRelHammingDists C).Finite

omit [SelectableType R] in
@[simp]
lemma oracleReduction_verifier_eq_oracleVerifier :
    (oracleReduction R deg D n oSpec).verifier = oracleVerifier R deg D n oSpec

lemma guruswami_sudan_for_proximity_gap_existence {k m : ‚Ñï} {œâs : Fin n ‚Ü™ F} {f : Fin n ‚Üí F} :
  ‚àÉ Q, Condition k m (proximity_gap_degree_bound (n := n) k m) œâs f Q

theorem append_knowledgeSoundness (V‚ÇÅ : Verifier oSpec Stmt‚ÇÅ Stmt‚ÇÇ pSpec‚ÇÅ)
    (V‚ÇÇ : Verifier oSpec Stmt‚ÇÇ Stmt‚ÇÉ pSpec‚ÇÇ)
    {knowledgeError‚ÇÅ knowledgeError‚ÇÇ : ‚Ñù‚â•0}
    (h‚ÇÅ : V‚ÇÅ.knowledgeSoundness init impl rel‚ÇÅ rel‚ÇÇ knowledgeError‚ÇÅ)
    (h‚ÇÇ : V‚ÇÇ.knowledgeSoundness init impl rel‚ÇÇ rel‚ÇÉ knowledgeError‚ÇÇ) :
      (V‚ÇÅ.append V‚ÇÇ).knowledgeSoundness init impl
        rel‚ÇÅ rel‚ÇÉ (knowledgeError‚ÇÅ + knowledgeError‚ÇÇ)

private lemma Monad.map_of_prod_fst_eq_prod_fst {m : Type u ‚Üí Type v} [Monad m] [LawfulMonad m]
    {Œ± Œ≤ Œ≥ : Type u} (ma : m (Œ± √ó Œ≤)) (c : Œ≥) :
    (fun a => (c, a.1)) <$> ma = Prod.mk c <$> Prod.fst <$> ma

@[simp]
theorem vappend_vcons (a : Œ±) (u : Fin m ‚Üí Œ±) (v : Fin n ‚Üí Œ±) :
    vappend (vcons a u) v = (vcons a (vappend u v)) ‚àò Fin.cast (Nat.succ_add m n)

theorem non_zero_divisors_iff (M‚ÇÄ : Type*) [Mul M‚ÇÄ] [Zero M‚ÇÄ] :
    NoZeroDivisors M‚ÇÄ ‚Üî ‚àÄ {a b : M‚ÇÄ}, a * b = 0 ‚Üí a = 0 ‚à® b = 0

theorem singleEqPolynomial_zeroOne (r : Fin 2) (x : MvPolynomial œÉ R) :
    singleEqPolynomial (r : R) x = if r = 0 then 1 - x else x

theorem append_right' {u : Fin m ‚Üí Œ±} {v : Fin n ‚Üí Œ±} {i : Fin n}
    (j : Fin (m + n)) (h : j = natAdd m i) : append u v j = v i

@[simp]
theorem init_update_last : init (update s (Fin.last n) y) = init s

lemma aeval_eq' {A : Type y} [CommSemiring A] [Algebra R A] {F : Type z} [FunEquiv F œÉ A]
    (f : P ‚Üí‚Çê[R] A) (p : P) : f p = aeval (fun s => f (X s) : F) p

theorem fcons‚ÇÇ_injective2 {Œ±‚ÇÅ : A} {Œ±‚ÇÇ : B} {Œ≤‚ÇÅ : Fin n ‚Üí A} {Œ≤‚ÇÇ : Fin n ‚Üí B} :
    Function.Injective2 (@fcons‚ÇÇ A B F‚ÇÇ n Œ±‚ÇÅ Œ≤‚ÇÅ Œ±‚ÇÇ Œ≤‚ÇÇ)

lemma getBit_of_shiftRight {n p : ‚Ñï}:
  ‚àÄ k, getBit k (n >>> p) = getBit (k+p) n

@[to_additive /-- A variant of `Finset.add_sum_erase` with the addition swapped.--/]
theorem prod_mul_erase {Œ± Œ≤ : Type*} [CommMonoid Œ≤] [DecidableEq Œ±] (s : Finset Œ±) (f : Œ± ‚Üí Œ≤)
{a : Œ±} (h : a ‚àà s) : f a * (‚àè x ‚àà s.erase a, f x) = ‚àè x ‚àà s, f x

private lemma sum_hamming_weight_sum [Zero F]
  :
  ‚àë x ‚àà B, (‚Äñx‚Äñ‚ÇÄ : ‚Ñö) = n * B.card - ‚àë i, K B i 0

Nat.lt_trans in Init.Prelude

lemma getBit_eq_testBit (k n : Nat) : getBit k n = if n.testBit k then 1 else 0

omit [SelectableType R] in
@[simp]
lemma reduction_verifier_eq_verifier :
    (reduction R deg D n oSpec).verifier = verifier R deg D n oSpec

Nat.pred_lt_self in Init.Data.Nat.Basic

@[simp]
lemma coeff_truncate : (truncate p n).coeff k = if k < n then p.coeff k else 0

lemma liftF_ne_zero_of_lt {i : ‚Ñï} (h : i < n) : liftF f' i ‚â† 0 ‚Üî f' ‚ü®i, h‚ü© ‚â† 0

theorem eqPolynomial_mem_restrictDegree (r : œÉ ‚Üí R) : (eqPolynomial r) ‚àà R‚¶É‚â§ 1‚¶Ñ[X œÉ]

@[grind =] theorem idxOf'_cons [BEq Œ±] {a : Œ±} {x : Œ±} {xs : List Œ±} :
    idxOf' a (x :: xs) = bif x == a then 0 else idxOf' a xs + 1

lemma qMap_total_fiber_repr_coeff (i : Fin ‚Ñì) (steps : ‚Ñï) (h_i_add_steps : i.val + steps ‚â§ ‚Ñì)
    (y : sDomain ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i.val + steps, by omega‚ü©))
    (k : Fin (2 ^ steps)) :
    let x := qMap_total_fiber ùîΩq Œ≤ (i := ‚ü®i, by omega‚ü©)
      (steps := steps)
      (h_i_add_steps := by simp only; exact fin_‚Ñì_steps_lt_‚Ñì_add_R i steps h_i_add_steps) (y := y) k
    let basis_y := sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i.val + steps, by omega‚ü©)
      (h_i := by simp only; exact fin_‚Ñì_steps_lt_‚Ñì_add_R i steps h_i_add_steps)
    let y_coeffs := basis_y.repr y
    ‚àÄ j, -- j refers to bit index of the fiber point x
      ((sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®i, by omega‚ü©) (by simp only; omega)).repr x) j
      = fiber_coeff (i := i) (steps := steps) (j := j) (elementIdx := k)
        (y_coeffs := y_coeffs)

lemma getBit_of_multiple_of_power_of_two {n p : ‚Ñï}: ‚àÄ k,
  getBit (k) (2^p * n) = if k < p then 0 else getBit (k-p) n

@[simp]
theorem eval_mapped_poly_at_root (k : ‚Ñï) :
    eval‚ÇÇ (AdjoinRoot.of (poly k)) (Z (k+1)) (poly k) = 0

lemma and_eq_zero_iff {n m : ‚Ñï} : n &&& m = 0 ‚Üî ‚àÄ k, (n >>> k) &&& (m >>> k) = 0

@[simp] lemma ofMvPolynomialAlgHom_X (s : œÉ) :
    ofMvPolynomialAlgHom (MvPolynomial.X s : MvPolynomial œÉ R) = (X s : P)

theorem div_two_pow_lt_two_pow (x i j : ‚Ñï) (h_x_lt_2_pow_i : x < 2 ^ (i + j)): x / 2^j < 2^(i)

lemma twoAdicGenerators_pow_twoPow_eq_one (bits : Fin (twoAdicity + 1)) :
    (twoAdicGenerators[bits]) ^ (2 ^ (bits : Nat)) = (1 : Field)

lemma twoAdicGenerators_pow_twoPow_ne_one_of_lt
    {bits : Fin (twoAdicity + 1)} {m : Nat} (hm : m < bits) :
    (twoAdicGenerators[bits]) ^ (2 ^ m) ‚â† (1 : Field)

@[simp]
private lemma x_times_oddPart'_coeff {f : Polynomial F} {n : ‚Ñï} :
    (x_times_oddPart' f).coeff n = if Odd n then f.coeff n else 0

lemma forwardRange_pred_le_ne_empty (n : ‚Ñï) (r : Fin n) (l : Fin (r.val + 1))
    (h_l_gt_0 : l.val > 0) : forwardRange n r ‚ü®l.val - 1, by omega‚ü© ‚â† []

lemma split_algebraMap_eq_zero_x {k : ‚Ñï} (h_pos : k > 0) (x : BTField (k - 1)) :
  letI instAlgebra := binaryAlgebraTower (l:=k-1) (r:=k) (h_le:=by omega)
  split (k:=k) (h_k:=h_pos) (algebraMap (BTField (k - 1)) (BTField k) x) = (0, x)

omit [Finite F] in
lemma D_def : D = evalDomain D 0

theorem simulateQ'_eq_simulateQ [AlternativeMonad m] [LawfulMonad m]
    {so : QueryImpl spec m} (oa : OracleComp spec Œ±) (h : oa.neverFails) :
      simulateQ' so oa h = simulateQ so oa

@[simp]
lemma zero_le_relHammingDist : 0 ‚â§ Œ¥·µ£(u, v)

@[simp]
theorem addCases'_left {m n : ‚Ñï} {Œ± : Fin m ‚Üí Sort u} {Œ≤ : Fin n ‚Üí Sort u}
    (left : (i : Fin m) ‚Üí Œ± i) (right : (j : Fin n) ‚Üí Œ≤ j) (i : Fin m) :
      addCases' left right (Fin.castAdd n i) = (Fin.append_left Œ± Œ≤ i) ‚ñ∏ (left i)

theorem append_soundness {lang‚ÇÅ : Set Stmt‚ÇÅ} {lang‚ÇÇ : Set Stmt‚ÇÇ} {lang‚ÇÉ : Set Stmt‚ÇÉ}
    (V‚ÇÅ : Verifier oSpec Stmt‚ÇÅ Stmt‚ÇÇ pSpec‚ÇÅ) (V‚ÇÇ : Verifier oSpec Stmt‚ÇÇ Stmt‚ÇÉ pSpec‚ÇÇ)
    {soundnessError‚ÇÅ soundnessError‚ÇÇ : ‚Ñù‚â•0}
    (h‚ÇÅ : V‚ÇÅ.soundness init impl lang‚ÇÅ lang‚ÇÇ soundnessError‚ÇÅ)
    (h‚ÇÇ : V‚ÇÇ.soundness init impl lang‚ÇÇ lang‚ÇÉ soundnessError‚ÇÇ) :
      (V‚ÇÅ.append V‚ÇÇ).soundness init impl lang‚ÇÅ lang‚ÇÉ (soundnessError‚ÇÅ + soundnessError‚ÇÇ)

@[simp]
theorem choose_2_convex : ConvexOn ‚Ñö Set.univ choose_2

theorem coeff_of_toMvPolynomial_eq_coeff_of_MlPoly (p : MlPoly R n) (m : Fin n ‚Üí‚ÇÄ ‚Ñï) :
  coeff m (toMvPolynomial p) =
    if h_binary: (‚àÄ j: Fin n, m j ‚â§ 1) then
      let i_of_m: ‚Ñï := Nat.binaryFinMapToNat (m:=m) (h_binary:=h_binary)
      p[i_of_m]
    else
      0

@[simp]
theorem embedSum_splitSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} (k : Fin (vsum n)) :
    embedSum (splitSum k).1 (splitSum k).2 = k

private lemma K_eq_sum {Œ± : F} : K B i Œ± = ‚àë (x : B), if x.1 i = Œ± then 1 else 0

@[simp] theorem equiv_trans {p q r : UniPoly Q} : Trim.equiv p q ‚Üí equiv q r ‚Üí equiv p r

@[simp, grind _=_]
theorem smul_monomialXY {n m : ‚Ñï} {a : F} {S} [SMulZeroClass S F] {b : S} :
  monomialXY n m (b ‚Ä¢ a) = b ‚Ä¢ monomialXY n m a

@[simp]
lemma dfoldr'_zero {Œ± : Fin 1 ‚Üí Type u}
    (f : (i : Fin 0) ‚Üí Œ± i.succ ‚Üí Œ± i.castSucc) (x : Œ± (last 0)) :
    dfoldr' 0 Œ± f x = x

@[simp]
lemma polynomialOfCoeffs_eq_zero :
  polynomialOfCoeffs coeffs = 0 ‚Üî ‚àÄ (x : ‚Ñï) (h : x < deg), coeffs ‚ü®x, h‚ü© = 0

@[simp]
lemma challengeOracleInterface_append_domain_inr (j : pSpec‚ÇÇ.ChallengeIdx) :
    [(pSpec‚ÇÅ ++‚Çö pSpec‚ÇÇ).Challenge]‚Çí.domain (.inr j) = Unit

@[simp]
lemma eval‚ÇÇ_monomial {S : Type w} [CommSemiring S] (f : R ‚Üí+* S) (x : S) (n : ‚Ñï) (r : R) :
    eval‚ÇÇ (P := P) f x (monomial n r) = f r * x ^ n

private theorem toNat_mulNat (a : AssocNat) (k : Nat) : toNat (mulNat a k) = toNat a * k

lemma and_two_pow_eq_two_pow_of_getBit_1 {n i : ‚Ñï} (h_getBit: getBit i n = 1) :
    n &&& (2 ^ i) = 2 ^ i

@[simp]
lemma coe_fn_of_coe (f : ‚àÄ a, Œ≤ a) : (f : F) = inst.equiv.invFun f

lemma coeff_polynomialOfCoeffs_eq_coeffs' :
  (polynomialOfCoeffs coeffs).coeff = fun x ‚Ü¶ if h : x < deg then coeffs ‚ü®x, h‚ü© else 0

@[to_additive (attr := simp) vsum_succ]
lemma vprod_succ [CommMonoid Œ±] {a : Fin (n + 1) ‚Üí Œ±} : vprod a = a 0 * vprod (a ‚àò Fin.succ)

@[simp]
protected lemma elocPoly_two :
  ElocPoly 2 œâs f p =
  if f 1 = eval (œâs 1) p
  then if f 0 = eval (œâs 0) p then 1
       else X - C (œâs 0)
  else if f 0 = eval (œâs 0) p then X - C (œâs 1)
       else (X - C (œâs 0)) * (X - C (œâs 1))

@[simp]
lemma shift_left_empty :
    shift_left ‚àÖ = ‚àÖ

theorem folding_listdecoding_if_genMutualCorrAgreement
  {S : Finset Œπ} {œÜ : Œπ ‚Ü™ F} [Smooth œÜ] {k m : ‚Ñï}
  {S' : Finset (indexPowT S œÜ 0)} {œÜ' : (indexPowT S œÜ 0) ‚Ü™ F}
  [‚àÄ i : ‚Ñï, Fintype (indexPowT S œÜ i)] [DecidableEq (indexPowT S œÜ 0)] [Smooth œÜ']
  [h : ‚àÄ {f : (indexPowT S œÜ 0) ‚Üí F}, DecidableBlockDisagreement 0 k f S' œÜ']
  [‚àÄ i : ‚Ñï, Neg (indexPowT S œÜ i)]
  {C : Set ((indexPowT S œÜ 0) ‚Üí F)} (hcode : C = smoothCode œÜ' m) (hLe : k ‚â§ m)
  {Œ¥ : ‚Ñù‚â•0}
  {params : GenMutualCorrParams S œÜ k} :

  -- necessary typeclasses of underlying domain (Œπ·µ¢)^2 ≤ regarding finiteness,
  -- non-emptiness and smoothness
    let _ : ‚àÄ j : Fin (k + 1), Fintype (indexPowT S œÜ j) := params.inst1
    let _ : ‚àÄ j : Fin (k + 1), Nonempty (indexPowT S œÜ j) := params.inst2

    Pr_{let Œ±s ‚Üê$·µñ (Fin k ‚Üí F)}[ -- for every function `f : Œπ ‚Üí F` and
                      ‚àÄ (f : (indexPowT S œÜ 0) ‚Üí F),
                      -- `hŒ¥Le` : `Œ¥ ‚àà (0, max_{j ‚àà [0,k]} BStar(C‚±º, par‚Ñì = 2))`
                       (0 < Œ¥ ‚àß Œ¥ < 1 - Finset.univ.sup
                        (fun j => params.BStar j (params.Gen_Œ± j).C (params.Gen_Œ± j).par‚Ñì)) ‚Üí

                      let listBlock : Set ((indexPowT S œÜ 0) ‚Üí F) := Œõ·µ£(0, k, f, S', C, hcode, Œ¥)
                      let fold := fold_k f Œ±s hLe
                      let foldSet := fold_k_set listBlock Œ±s hLe
                      let kFin : Fin (k + 1) := ‚ü®k, Nat.lt_succ_self k‚ü©
                      let C‚Çñ := (params.Gen_Œ± kFin).C
                      let listHamming := relHammingBall C‚Çñ fold Œ¥

                      foldSet ‚â† listHamming
                    ] < (‚àë i : Fin (k + 1),
                          params.errStar i (params.Gen_Œ± i).C (params.Gen_Œ± i).par‚Ñì Œ¥)

lemma getLowBits_le_self {n : ‚Ñï} (numLowBits : ‚Ñï) : getLowBits numLowBits n ‚â§ n

@[simp]
theorem hconcat_castSucc {Œ± : Fin n ‚Üí Sort u} {Œ≤ : Sort u}
    (v : (i : Fin n) ‚Üí Œ± i) (b : Œ≤) (i : Fin n) :
    hconcat v b (castSucc i) = cast (vconcat_castSucc Œ± Œ≤ i).symm (v i)

@[simp]
theorem list_nonempty (k : ‚Ñï) : (list k).1 ‚â† []

theorem funext‚ÇÇ_iff {Œ± : Sort u} {Œ≤ : Œ± ‚Üí Sort v} {Œ≥ : (a : Œ±) ‚Üí Œ≤ a ‚Üí Sort w}
    {f g : (a : Œ±) ‚Üí (b : Œ≤ a) ‚Üí Œ≥ a b} : f = g ‚Üî ‚àÄ a b, f a b = g a b

lemma degree_normalizedW (i : Fin r) :
  (normalizedW ùîΩq Œ≤ i).degree = (Fintype.card ùîΩq)^(i.val)

@[simp]
lemma invFun_toFun (f : F) : inst.equiv.invFun (inst.equiv.toFun f) = f

lemma rowRank_eq_colRank : rowRank U = colRank U

theorem fconcat‚ÇÇ_left_injective {Œ±‚ÇÅ : Fin n ‚Üí A} {Œ±‚ÇÇ : Fin n ‚Üí B} {Œ≤‚ÇÅ : A} {Œ≤‚ÇÇ : B} (a : F‚ÇÇ Œ≤‚ÇÅ Œ≤‚ÇÇ) :
    Function.Injective (fun v : (i : Fin n) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i) => fconcat‚ÇÇ (F := F‚ÇÇ) v a)

@[simp]
theorem fflatten‚ÇÇ_zero {A : Sort u} {B : Sort v} {F : A ‚Üí B ‚Üí Sort w} {n : Fin 0 ‚Üí ‚Ñï}
    {Œ± : (i : Fin 0) ‚Üí (j : Fin (n i)) ‚Üí A}
    {Œ≤ : (i : Fin 0) ‚Üí (j : Fin (n i)) ‚Üí B}
    {v : (i : Fin 0) ‚Üí (j : Fin (n i)) ‚Üí F (Œ± i j) (Œ≤ i j)} : fflatten‚ÇÇ v = !h[]

@[simp]
theorem fconcat‚ÇÇ_castSucc {Œ±‚ÇÅ : Fin n ‚Üí A} {Œ±‚ÇÇ : Fin n ‚Üí B} {Œ≤‚ÇÅ : A} {Œ≤‚ÇÇ : B}
    (v : (i : Fin n) ‚Üí F‚ÇÇ (Œ±‚ÇÅ i) (Œ±‚ÇÇ i)) (a : F‚ÇÇ Œ≤‚ÇÅ Œ≤‚ÇÇ) (i : Fin n) :
    fconcat‚ÇÇ (F := F‚ÇÇ) v a (castSucc i) =
      cast (by simp [vconcat_castSucc]) (v i)

theorem init_vconcat (v : Fin n ‚Üí Œ±) (a : Œ±) :
    (fun i => vconcat v a (Fin.castSucc i)) = v

theorem eq_of_equiv [LawfulBEq R] {p q : UniPoly R} : equiv p q ‚Üí p.trim = q.trim

lemma bwm_of_neg [NeZero n] (h : e ‚â§ j.1) :
  BerlekampWelchMatrix e k œâs f i j = -(œâs i)^(j - e)

lemma evenize_eval {f : Polynomial F} {s : F} :
    (evenize f).eval s = f.eval (s * s)

lemma lifted_trace_map_eval_at_roots_prev_BTField
  {curBTField : Type*} [Field curBTField]
  (u : curBTField) (t1 : curBTField) -- here t1 is already lifted to curBTField
  (k : ‚Ñï)
  (sumZeroIffEq : ‚àÄ (x y : curBTField), x + y = 0 ‚Üî x = y)
  (u_plus_inv_eq_t1 : u + u‚Åª¬π = t1)
  (galois_automorphism : u^(2^(2^k)) = u‚Åª¬π ‚àß (u‚Åª¬π)^(2^(2^k)) = u)
  (trace_map_at_prev_root : ‚àë i ‚àà Finset.range (2 ^ k), t1 ^ (2 ^ i) = 1) :
  ‚àë i ‚àà Finset.range (2 ^ (k+1)), u ^ (2 ^ i) = 1

@[simp]
theorem snoc_zero_zero : snoc (0 : Fin n ‚Üí‚ÇÄ M) 0 = 0

theorem embedSum_succ {m : ‚Ñï} {n : Fin (m + 1) ‚Üí ‚Ñï} {i : Fin (m + 1)} (j : Fin (n i)) :
    embedSum i j = (match i with
    | 0 => Fin.castAdd _ j
    | ‚ü®i + 1, h‚ü© => Fin.natAdd _ (embedSum ‚ü®i, Nat.succ_lt_succ_iff.mp h‚ü© j))

theorem add_coeff? (p q : UniPoly Q) (i : ‚Ñï) :
  (add_raw p q).coeff i = p.coeff i + q.coeff i

lemma mca_linearCode
  (Gen : ProximityGenerator Œπ F) [Fintype Gen.par‚Ñì] [Nonempty Gen.par‚Ñì]
  (C : LinearCode Œπ F) (hC : C = Gen.C) :
    hasMutualCorrAgreement
     -- Gen
      Gen
    -- BStar (using Œ¥·µ£ produced )
      (min (1 - (Œ¥·µ£ (C : Set (Œπ ‚Üí F))) / 2) (Gen.B Gen.C Gen.par‚Ñì))
    -- errStar
      (fun Œ¥ => Gen.err C Gen.par‚Ñì Œ¥)

theorem hconcat_injective2 {Œ± : Fin n ‚Üí Sort u} {Œ≤ : Sort u} :
    Function.Injective2 (@hconcat n Œ± Œ≤)

theorem BTField.Basis_cast_dest_eq {Œπ : Type*} (k n m : ‚Ñï) (h_k_le_n : k ‚â§ n)
  (h_k_le_m : k ‚â§ m) (h_eq : m = n) :
  letI instLeftAlgebra := binaryAlgebraTower (l:=k) (r:=m) (h_le:=h_k_le_m)
  letI instRightAlgebra := binaryAlgebraTower (l:=k) (r:=n) (h_le:=h_k_le_n)
  @Basis Œπ (BTField k) (BTField m) _ _ instLeftAlgebra.toModule =
  @Basis Œπ (BTField k) (BTField n) _ _ instRightAlgebra.toModule

theorem fcons_right_injective {Œ≤ : Fin n ‚Üí A} (a : F Œ±) :
    Function.Injective (fcons a : ((i : Fin n) ‚Üí F (Œ≤ i)) ‚Üí (i : Fin (n + 1)) ‚Üí _)

lemma getBit_of_binaryFinMapToNat {n : ‚Ñï} (m : Fin n ‚Üí ‚Ñï) (h_binary: ‚àÄ j: Fin n, m j ‚â§ 1) :
    ‚àÄ k: ‚Ñï, Nat.getBit k (binaryFinMapToNat m h_binary).val
      = if h_k: k < n then m ‚ü®k, by omega‚ü© else 0

omit [DecidableEq ùîΩq] hF‚ÇÇ in
lemma getSDomainBasisCoeff_of_iteratedQuotientMap
    [NeZero R_rate] (i : Fin ‚Ñì) (k : ‚Ñï)
    (h_bound : i.val + k ‚â§ ‚Ñì) (x : (sDomain ùîΩq Œ≤
    h_‚Ñì_add_R_rate) ‚ü®i, by omega‚ü©) :
    let y := iteratedQuotientMap (i := i) (k:=k) (h_bound:=h_bound) (x:=x)
    ‚àÄ (j: Fin (‚Ñì + R_rate - (i + k))),
    ((sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®‚Üëi + k, by omega‚ü©) (h_i := by
      simp only;
      apply Nat.lt_add_of_pos_right_of_le; omega)).repr y) j =
    ((sDomain_basis ùîΩq Œ≤ h_‚Ñì_add_R_rate (i := ‚ü®‚Üëi, by omega‚ü©)
      (h_i := by simp only; omega)).repr x) ‚ü®j + k, by simp only; omega‚ü©

@[simp]
lemma probFailure_liftComp {Œπ' : Type w} {superSpec : OracleSpec Œπ'}
    [spec.FiniteRange] [superSpec.FiniteRange]
    [h : MonadLift (OracleQuery spec) (OracleQuery superSpec)]
    (oa : OracleComp spec Œ±) : [‚ä• | liftComp oa superSpec] = [‚ä• | oa]

omit [DecidableEq L] h_Fq_char_prime hF‚ÇÇ hŒ≤_lin_indep in
lemma Prod_W_comp_X_sub_C_ne_zero (i : Fin r) :
    (univ : Finset ùîΩq).prod (fun c => (W ùîΩq Œ≤ i).comp (X - C (c ‚Ä¢ Œ≤ i))) ‚â† 0

omit [NeZero r] in
theorem hŒ≤_lin_indep_concrete (k : ‚Ñï) :
    letI := ConcreteBTFieldAlgebra (l:=0) (r:=k) (h_le:=by omega)
    LinearIndependent (R := ConcreteBTField 0)
      (v := computableBasisExplicit k)

@[simp]
theorem prover_last_of_two (pSpec : ProtocolSpec 2) [ProverLast pSpec] :
    pSpec.dir 1 = .P_to_V

theorem evalNormalizedWAt_eq_normalizedW (i : Fin r) (x : L) :
  evalNormalizedWAt (Œ≤ := Œ≤) (‚Ñì := ‚Ñì) (R_rate := R_rate) (i := i) x
    = (normalizedW (ùîΩq := ùîΩq) (Œ≤ := Œ≤) (i := i)).eval x

@[simp]
lemma liftComp_support {Œπ' : Type w} {superSpec : OracleSpec Œπ'}
    [h : MonadLift (OracleQuery spec) (OracleQuery superSpec)]
    (oa : OracleComp spec Œ±) : (liftComp oa superSpec).support = oa.support

@[simp]
lemma runWithLog_discard_log_eq_run (stmt : StmtIn) (wit : WitIn)
    (prover : Prover oSpec StmtIn WitIn StmtOut WitOut pSpec) :
      Prod.fst <$> prover.runWithLog stmt wit = prover.run stmt wit

lemma split_join_eq_split {k : ‚Ñï} (h_pos : k > 0)
    (hi_btf lo_btf : ConcreteBTField (k - 1)) :
    split h_pos („Ää hi_btf, lo_btf „Äã) = (hi_btf, lo_btf)

@[simp]
lemma codewordIsZero_makeZero {Œπ : ‚Ñï} {F : Type*} [Zero F] :
  makeZero Œπ F = 0

Nat.pow_lt_pow_right in Init.Data.Nat.Lemmas

private lemma natDegree_E
  (h : (Œî‚ÇÄ(f, p.eval ‚àò œâs) : ‚Ñï) ‚â§ e) :
  (E (œâs := œâs) f p e).natDegree = e

theorem distFromCode_eq_of_lt_half_dist (C : Set (n ‚Üí R)) (u : n ‚Üí R) {v w : n ‚Üí R}
    (hv : v ‚àà C) (hw : w ‚àà C) (huv : Œî‚ÇÄ(u, v) < ‚ÄñC‚Äñ‚ÇÄ / 2) (hvw : Œî‚ÇÄ(u, w) < ‚ÄñC‚Äñ‚ÇÄ / 2) : v = w

@[simp]
theorem vcons_fin_zero (a : Œ±) (v : Fin 0 ‚Üí Œ±) : a ::·µõ v = fun i => match i with

@[simp]
theorem hflatten_splitSum {m : ‚Ñï} {n : Fin m ‚Üí ‚Ñï} {Œ± : (k : Fin (vsum n)) ‚Üí Sort*}
    (v : (k : Fin (vsum n)) ‚Üí Œ± k) (k : Fin (vsum n)) :
    hflatten (fun i j => v (embedSum i j)) k = cast (vflatten_splitSum Œ± k).symm (v k)

theorem join_add_join {k : ‚Ñï} (h_pos : k > 0) (hi‚ÇÄ lo‚ÇÄ hi‚ÇÅ lo‚ÇÅ : ConcreteBTField (k - 1)) :
  „Ää hi‚ÇÄ, lo‚ÇÄ „Äã + „Ää hi‚ÇÅ, lo‚ÇÅ „Äã = „Ää hi‚ÇÄ + hi‚ÇÅ, lo‚ÇÄ + lo‚ÇÅ „Äã

theorem size_eq_degree (p : UniPoly R) : p.trim.size = p.degree

@[simp]
lemma seqCompose_succ {m : ‚Ñï}
    (Stmt : Fin (m + 2) ‚Üí Type) (Wit : Fin (m + 2) ‚Üí Type)
    {n : Fin (m + 1) ‚Üí ‚Ñï} {pSpec : ‚àÄ i, ProtocolSpec (n i)}
    (P : (i : Fin (m + 1)) ‚Üí
      Prover oSpec (Stmt i.castSucc) (Wit i.castSucc) (Stmt i.succ) (Wit i.succ) (pSpec i)) :
    seqCompose Stmt Wit P =
      append (P 0) (seqCompose (Stmt ‚àò Fin.succ) (Wit ‚àò Fin.succ) (fun i => P (Fin.succ i)))

theorem split_sum_eq_sum_split {k : ‚Ñï} (h_pos : k > 0) (x‚ÇÄ x‚ÇÅ : ConcreteBTField k)
  (hi‚ÇÄ lo‚ÇÄ hi‚ÇÅ lo‚ÇÅ : ConcreteBTField (k - 1))
  (h_split_x‚ÇÄ : split h_pos x‚ÇÄ = (hi‚ÇÄ, lo‚ÇÄ))
  (h_split_x‚ÇÅ : split h_pos x‚ÇÅ = (hi‚ÇÅ, lo‚ÇÅ)) :
  split h_pos (x‚ÇÄ + x‚ÇÅ) = (hi‚ÇÄ + hi‚ÇÅ, lo‚ÇÄ + lo‚ÇÅ)

theorem liftContext_run
    {lens : Context.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut
                        OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    {outerStmtIn : OuterStmtIn} {outerWitIn : OuterWitIn}
    {R : Reduction oSpec InnerStmtIn InnerWitIn InnerStmtOut InnerWitOut pSpec} :
      (R.liftContext lens).run outerStmtIn outerWitIn = do
        let ‚ü®‚ü®fullTranscript, innerCtxOut‚ü©, verInnerStmtOut‚ü© ‚Üê
          R.run.uncurry (lens.proj (outerStmtIn, outerWitIn))
        return ‚ü®‚ü®fullTranscript, lens.lift (outerStmtIn, outerWitIn) innerCtxOut‚ü© ,
                lens.stmt.lift outerStmtIn verInnerStmtOut‚ü©

@[simp] theorem toNat_mul (a b : AssocNat) : toNat (mul a b) = toNat a * toNat b

theorem append_perfectCompleteness
    (R‚ÇÅ : OracleReduction oSpec Stmt‚ÇÅ OStmt‚ÇÅ Wit‚ÇÅ Stmt‚ÇÇ OStmt‚ÇÇ Wit‚ÇÇ pSpec‚ÇÅ)
    (R‚ÇÇ : OracleReduction oSpec Stmt‚ÇÇ OStmt‚ÇÇ Wit‚ÇÇ Stmt‚ÇÉ OStmt‚ÇÉ Wit‚ÇÉ pSpec‚ÇÇ)
    (h‚ÇÅ : R‚ÇÅ.perfectCompleteness init impl rel‚ÇÅ rel‚ÇÇ)
    (h‚ÇÇ : R‚ÇÇ.perfectCompleteness init impl rel‚ÇÇ rel‚ÇÉ) :
      (R‚ÇÅ.append R‚ÇÇ).perfectCompleteness init impl rel‚ÇÅ rel‚ÇÉ

lemma sup_eq_of_le_of_reach {Œ± Œ≤ : Type} [SemilatticeSup Œ≤] [OrderBot Œ≤] {s : Finset Œ±} {f : Œ± ‚Üí Œ≤}
      (x : Œ±) {y : Œ≤} (h : x ‚àà s) :
    f x = y ‚Üí
    (‚àÄ x ‚àà s, f x ‚â§ y) ‚Üí
    s.sup f = y

@[grind]
lemma degreeX_le_degreeX_sub_degreeX [IsDomain F] {f q : F[X][Y]} (hf : f ‚â† 0) (hg : q * f ‚â† 0) :
  degreeX q ‚â§ degreeX (q * f) - degreeX f

theorem seqCompose_soundness
    (lang : (i : Fin (m + 1)) ‚Üí Set (Stmt i √ó ‚àÄ j, OStmt i j))
    (V : (i : Fin m) ‚Üí
      OracleVerifier oSpec (Stmt i.castSucc) (OStmt i.castSucc) (Stmt i.succ) (OStmt i.succ)
        (pSpec i))
    (soundnessError : Fin m ‚Üí ‚Ñù‚â•0)
    (h : ‚àÄ i, (V i).soundness init impl (lang i.castSucc) (lang i.succ) (soundnessError i)) :
      (OracleVerifier.seqCompose Stmt OStmt V).soundness init impl (lang 0) (lang (Fin.last m))
        (‚àë i, soundnessError i)

lemma getBit_of_two_pow_sub_one {i k: ‚Ñï} : getBit k (2^i - 1) =
    if k < i then 1 else 0

theorem liftContext_knowledgeSoundness [Inhabited InnerStmtOut] [Inhabited InnerWitIn]
    {outerRelIn : Set (OuterStmtIn √ó OuterWitIn)} {outerRelOut : Set (OuterStmtOut √ó OuterWitOut)}
    {innerRelIn : Set (InnerStmtIn √ó InnerWitIn)} {innerRelOut : Set (InnerStmtOut √ó InnerWitOut)}
    {knowledgeError : ‚Ñù‚â•0}
    {stmtLens : Statement.Lens OuterStmtIn OuterStmtOut InnerStmtIn InnerStmtOut}
    {witLens : Witness.InvLens OuterStmtIn OuterWitIn OuterWitOut InnerWitIn InnerWitOut}
    (V : Verifier oSpec InnerStmtIn InnerStmtOut pSpec)
    [lensKS : Extractor.Lens.IsKnowledgeSound outerRelIn innerRelIn outerRelOut innerRelOut
      (V.compatStatement stmtLens) (fun _ _ => True) ‚ü®stmtLens, witLens‚ü©]
    (h : V.knowledgeSoundness init impl innerRelIn innerRelOut knowledgeError) :
      (V.liftContext stmtLens).knowledgeSoundness init impl outerRelIn outerRelOut
        knowledgeError

theorem join_eq_iff_dcast_extractLsb {k : ‚Ñï} (h_pos : k > 0) (x : ConcreteBTField k)
  (hi_btf lo_btf : ConcreteBTField (k - 1)) :
  x = „Ää hi_btf, lo_btf „Äã ‚Üî
  (hi_btf = dcast (h_sub_middle h_pos) (BitVec.extractLsb (hi := 2 ^ k - 1) (lo := 2 ^ (k - 1)) x) ‚àß
  lo_btf = dcast (h_middle_sub) (BitVec.extractLsb (hi := 2 ^ (k - 1) - 1) (lo := 0) x))

@[simp]
theorem cast_id :
    OracleProver.cast rfl rfl =
      (id : OracleProver oSpec StmtIn OStmtIn WitIn StmtOut OStmtOut WitOut pSpec‚ÇÅ ‚Üí _)

lemma irreducibleHTildeOfIrreducible {H : Polynomial (Polynomial F)} :
    (Irreducible H ‚Üí Irreducible (H_tilde H))

theorem intermediateNormVpoly_comp_qmap_helper (i : Fin (‚Ñì))
    (k : Fin (‚Ñì - (‚Üëi + 1))) :
    (intermediateNormVpoly ùîΩq Œ≤ h_‚Ñì_add_R_rate
      ‚ü®‚Üëi + 1, by omega‚ü© (k:=‚ü®k, by simp only; omega‚ü©)).comp (qMap ùîΩq Œ≤ ‚ü®‚Üëi, by omega‚ü©) =
    intermediateNormVpoly ùîΩq Œ≤ h_‚Ñì_add_R_rate
      ‚ü®‚Üëi, by omega‚ü© ‚ü®k + 1, by simp only; omega‚ü©

@[grind]
lemma coeff_ne_zero {f q : F[X][Y]} (hg : q * f ‚â† 0) : q.coeff ‚â† 0

Nat.lt_succ_of_lt in Init.Data.Nat.Basic

theorem singleton_bound (C : Set (n ‚Üí R)) :
    (ofFinite C).card ‚â§ (ofFinite R).card ^ (card n - (‚ÄñC‚Äñ‚ÇÄ - 1))

theorem is_multilinear_iff_eq_evals_zeroOne {p : MvPolynomial œÉ R} :
    p ‚àà R‚¶É‚â§ 1‚¶Ñ[X œÉ] ‚Üî MLE p.toEvalsZeroOne = p

theorem funext‚ÇÇ_heq_iff {Œ± Œ±' : Sort u} {Œ≤ : Œ± ‚Üí Sort v} {Œ≤' : Œ±' ‚Üí Sort v}
    {Œ≥ : (a : Œ±) ‚Üí Œ≤ a ‚Üí Sort w} {Œ≥' : (a : Œ±') ‚Üí Œ≤' a ‚Üí Sort w}
    {f : (a : Œ±) ‚Üí (b : Œ≤ a) ‚Üí Œ≥ a b} {g : (a : Œ±') ‚Üí (b : Œ≤' a) ‚Üí Œ≥' a b}
    (ha : Œ± = Œ±') (hb : ‚àÄ a, Œ≤ a = Œ≤' (cast ha a))
    (hc : ‚àÄ a b, Œ≥ a b = Œ≥' (cast ha a) (cast (hb a) b)) :
      HEq f g ‚Üî ‚àÄ a b, HEq (f a b) (g (cast ha a) (cast (hb a) b))

theorem comp_x_square_coeff {f : Polynomial F} {n : ‚Ñï} :
  (f.comp (X * X)).coeff n = if Even n then f.coeff (n / 2) else 0

lemma powerBasisSucc_gen (k : ‚Ñï) :
  (powerBasisSucc k).gen = (Z (k + 1))

private lemma Fis_pairwise_disjoint : Set.PairwiseDisjoint Set.univ (Fi B i)

theorem FullData.toLeafData_rightSubtree {Œ±} {s_left s_right : Skeleton}
    (tree : FullData Œ± (Skeleton.internal s_left s_right)) :
    tree.toLeafData.rightSubtree =
      tree.rightSubtree.toLeafData

lemma nonsquare_mulVecLin [CommSemiring F] {Œπ' : ‚Ñï} {Œ±‚ÇÅ : Œπ ‚Ü™ F} {Œ±‚ÇÇ : Fin Œπ' ‚Üí F} {i : Œπ} :
  (nonsquare Œπ' Œ±‚ÇÅ).mulVecLin Œ±‚ÇÇ i = ‚àë x, Œ±‚ÇÇ x * Œ±‚ÇÅ i ^ x.1

theorem BitVec.dcast_id {n : Nat} (bv : BitVec n) :
  DCast.dcast (Eq.refl n) bv = bv

lemma lt_two_pow_of_lt_two_pow_exp_le (x i j: ‚Ñï)
    (h_x_lt_2_pow_i: x < 2^i) (h_i_le_j: i ‚â§ j): x < 2^j

theorem degrees_mul_C_le (p : MvPolynomial œÉ R) (c : R) : (p * C c).degrees ‚â§ p.degrees

theorem vconcat_vcons_eq_vcons_vconcat (a : Œ±) (v : Fin n ‚Üí Œ±) (b : Œ±) :
    vconcat (a ::·µõ v) b = a ::·µõ (vconcat v b)

@[simp]
theorem LeafData.optionComposeBuild_internal {Œ±} {s_left s_right : Skeleton}
    (left : LeafData Œ± s_left) (right : LeafData Œ± s_right)
    (compose : Œ± ‚Üí Œ± ‚Üí Option Œ±) :
    (LeafData.internal left right).optionComposeBuild compose =
      FullData.internal
        (Option.doubleBind compose
          (left.optionComposeBuild compose).getRootValue
          (right.optionComposeBuild compose).getRootValue)
        (left.optionComposeBuild compose)
        (right.optionComposeBuild compose)

lemma rank_eq_colRank : U.rank = colRank U
</all_available_lemmas>

<local_ctx>
import ArkLib.Data.Classes.DCast

import ArkLib.Data.FieldTheory.BinaryField.Tower.Basic

namespace ConcreteBinaryTower

open Polynomial

def ConcreteBTField : ‚Ñï ‚Üí Type := fun k => BitVec (2 ^ k)

section BitVecDCast

instance BitVec.instDCast : DCast Nat BitVec where
  dcast h := BitVec.cast h
  dcast_id := by admit /- proof elided -/

end BitVecDCast

section ConversionUtils

def fromNat {k : ‚Ñï} (n : Nat) : ConcreteBTField k :=
  BitVec.ofNat (2 ^ k) n

instance ConcreteBTField.instDCast_local : DCast ‚Ñï ConcreteBTField where
  dcast h_k_eq term_k1 := BitVec.cast (congrArg (fun n => 2 ^ n) h_k_eq) term_k1
  dcast_id := by admit /- proof elided -/

end ConversionUtils

section NumericLemmas

end NumericLemmas

section FieldOperationsAndInstances

def zero {k : ‚Ñï} : ConcreteBTField k := BitVec.zero (2 ^ k)

def one {k : ‚Ñï} : ConcreteBTField k := 1#(2 ^ k)

def add {k : ‚Ñï} (x y : ConcreteBTField k) : ConcreteBTField k := BitVec.xor x y

def neg {k : ‚Ñï} (x : ConcreteBTField k) : ConcreteBTField k := x

def split {k : ‚Ñï} (h : k > 0) (x : ConcreteBTField k) :
    ConcreteBTField (k - 1) √ó ConcreteBTField (k - 1) :=
  let lo_bits : BitVec (2 ^ (k - 1) - 1 - 0 + 1) :=
    BitVec.extractLsb (hi := 2 ^ (k - 1) - 1) (lo := 0) x
  let hi_bits : BitVec (2 ^ k - 1 - 2 ^ (k - 1) + 1) :=
    BitVec.extractLsb (hi := 2 ^ k - 1) (lo := 2 ^ (k - 1)) x
  have h_lo : 2 ^ (k - 1) - 1 - 0 + 1 = 2 ^ (k - 1) := by admit /- proof elided -/

def join {k : ‚Ñï} (h_pos : k > 0) (hi lo : ConcreteBTField (k - 1)) : ConcreteBTField k :=

structure ConcreteBTFAddCommGroupProps (k : ‚Ñï) where
  add_assoc : ‚àÄ a b c : ConcreteBTField k, (a + b) + c = a + (b + c) := add_assoc
  add_comm : ‚àÄ a b : ConcreteBTField k, a + b = b + a := add_comm
  add_zero : ‚àÄ a : ConcreteBTField k, a + zero = a := add_zero
  zero_add : ‚àÄ a : ConcreteBTField k, zero + a = a := zero_add
  add_neg : ‚àÄ a : ConcreteBTField k, a + (neg a) = zero := neg_add_cancel

def mkAddCommGroupInstance {k : ‚Ñï} : AddCommGroup (ConcreteBTField k) := {
  zero := zero
  neg := neg
  sub := fun x y => add x y
  add_assoc := add_assoc
  add_comm := add_comm
  zero_add := zero_add
  add_zero := add_zero
  nsmul := fun n x => if n % 2 = (0 : ‚Ñï) then zero else x
  zsmul := fun (n : ‚Ñ§) x => if n % 2 = 0 then zero else x  
  neg_add_cancel := neg_add_cancel
  nsmul_succ := nsmul_succ
  zsmul_succ' := fun n a => zsmul_succ n a
  add := add
  zsmul_neg' := zsmul_neg' (k := k)
}

def Z (k : ‚Ñï) : ConcreteBTField k :=
  if h_k : k = 0 then one
  else
    „Ää one (k:=k-1), zero (k:=k-1) „Äã

def equivProd {k : ‚Ñï} (h_k_pos : k > 0) :
  ConcreteBTField k ‚âÉ ConcreteBTField (k - 1) √ó ConcreteBTField (k - 1) where
  toFun := split h_k_pos
  invFun := fun (hi, lo) => „Ää hi, lo „Äã
  left_inv := fun x => Eq.symm (join_of_split h_k_pos x _ _ rfl)
  right_inv := fun ‚ü®hi, lo‚ü© => Eq.symm (split_of_join h_k_pos _ hi lo rfl)

def concrete_mul {k : ‚Ñï} (a b : ConcreteBTField k) : ConcreteBTField k :=
  if h_k_zero : k = 0 then
    if a = zero then zero
    else if b = zero then zero
    else if a = one then b
    else if b = one then a
    else zero 
  else
    have h_k_gt_0 : k > 0 := by admit /- proof elided -/

def concrete_inv {k : ‚Ñï} (a : ConcreteBTField k) : ConcreteBTField k :=
  if h_k_zero : k = 0 then
    if a = 0 then 0 else 1
  else
    if h_a_zero : a = 0 then 0
    else if h_a_one : a = 1 then 1
    else
      let h_k_gt_0 : k > 0 := Nat.zero_lt_of_ne_zero h_k_zero
      let (a_hi, a_lo) := split (k:=k) (h:=h_k_gt_0) a
      let prevZ := Z (k - 1)
      let a_lo_next := a_lo + concrete_mul a_hi prevZ
      let delta := concrete_mul a_lo a_lo_next + concrete_mul a_hi a_hi
      let delta_inverse := concrete_inv delta
      let out_hi := concrete_mul delta_inverse a_hi
      let out_lo := concrete_mul delta_inverse a_lo_next
      let res := „Ää out_hi, out_lo „Äã
      res

section FieldLemmasOfLevel0

end FieldLemmasOfLevel0

section NumericCasting

def natCast {k : ‚Ñï} (n : ‚Ñï) : ConcreteBTField k := if n % 2 = 0 then zero else one

def natCast_zero {k : ‚Ñï} : natCast (k:=k) 0 = zero :=

def natCast_succ {k : ‚Ñï} (n : ‚Ñï) : natCast (k:=k) (n + 1) = natCast (k:=k) n + 1 :=

def intCast {k : ‚Ñï} (n : ‚Ñ§) : ConcreteBTField k := if n % 2 = 0 then zero else one

def intCast_ofNat {k : ‚Ñï} (n : ‚Ñï) : intCast (k:=k) (n : ‚Ñ§) = natCast n :=

def intCast_negSucc {k : ‚Ñï} (n : ‚Ñï) : intCast (k:=k) (Int.negSucc n)
  = - (‚Üë(n + 1) : ConcreteBTField k) :=

end NumericCasting

structure ConcreteBTFRingProps (k : ‚Ñï) extends (ConcreteBTFAddCommGroupProps k) where
  
  mul_eq : ‚àÄ (a b : ConcreteBTField k) (h_k : k > 0)
    {a‚ÇÅ a‚ÇÄ b‚ÇÅ b‚ÇÄ : ConcreteBTField (k - 1)}
    (_h_a : (a‚ÇÅ, a‚ÇÄ) = split h_k a) (_h_b : (b‚ÇÅ, b‚ÇÄ) = split h_k b),
    concrete_mul a b =
      „Ää concrete_mul a‚ÇÄ b‚ÇÅ + concrete_mul b‚ÇÄ a‚ÇÅ + concrete_mul (concrete_mul a‚ÇÅ b‚ÇÅ) (Z (k - 1)),
      concrete_mul a‚ÇÄ b‚ÇÄ + concrete_mul a‚ÇÅ b‚ÇÅ „Äã

  
  zero_mul : ‚àÄ a : ConcreteBTField k, concrete_mul zero a = zero
  zero_mul' : ‚àÄ a : ConcreteBTField k, concrete_mul 0 a = 0
  mul_zero : ‚àÄ a : ConcreteBTField k, concrete_mul a zero = zero
  mul_zero' : ‚àÄ a : ConcreteBTField k, concrete_mul a 0 = 0
  one_mul : ‚àÄ a : ConcreteBTField k, concrete_mul one a = a
  mul_one : ‚àÄ a : ConcreteBTField k, concrete_mul a one = a

  
  mul_assoc : ‚àÄ a b c : ConcreteBTField k, concrete_mul (concrete_mul a b) c
    = concrete_mul a (concrete_mul b c)
  mul_left_distrib : ‚àÄ a b c : ConcreteBTField k, concrete_mul a (b + c)
    = concrete_mul a b + concrete_mul a c
  mul_right_distrib : ‚àÄ a b c : ConcreteBTField k, concrete_mul (a + b) c
    = concrete_mul a c + concrete_mul b c

structure ConcreteBTFDivisionRingProps (k : ‚Ñï) extends (ConcreteBTFRingProps k) where
  
  mul_inv_cancel : ‚àÄ a : ConcreteBTField k, a ‚â† zero ‚Üí concrete_mul a (concrete_inv a) = one

structure ConcreteBTFieldProps (k : ‚Ñï) extends (ConcreteBTFDivisionRingProps k) where
  
  mul_comm : ‚àÄ a b : ConcreteBTField k, concrete_mul a b = concrete_mul b a

def mkRingInstance {k : ‚Ñï} (props : ConcreteBTFieldProps k) : Ring (ConcreteBTField k) where
  toAddCommGroup := mkAddCommGroupInstance
  toOne := inferInstance
  mul := concrete_mul
  mul_assoc := props.mul_assoc
  one_mul := props.one_mul
  mul_one := props.mul_one
  left_distrib := props.mul_left_distrib
  right_distrib := props.mul_right_distrib
  zero_mul := props.zero_mul
  mul_zero := props.mul_zero

  natCast n := natCast n
  natCast_zero := natCast_zero
  natCast_succ n := natCast_succ n
  intCast n := intCast n
  intCast_ofNat n := intCast_ofNat n
  intCast_negSucc n := intCast_negSucc n

def mkDivisionRingInstance {k : ‚Ñï} (props : ConcreteBTFieldProps k)
    : DivisionRing (ConcreteBTField k) where
  toRing := mkRingInstance (k:=k) props
  inv := concrete_inv
  exists_pair_ne := concrete_exists_pair_ne (k := k)
  mul_inv_cancel := props.mul_inv_cancel
  inv_zero := concrete_inv_zero
  qsmul := (Rat.castRec ¬∑ * ¬∑)
  nnqsmul := (NNRat.castRec ¬∑ * ¬∑)

def mkFieldInstance {k : ‚Ñï} (props : ConcreteBTFieldProps k) : Field (ConcreteBTField k) where
  toDivisionRing := mkDivisionRingInstance (k:=k) props
  mul_comm := props.mul_comm

structure ConcreteBTFStepResult (k : ‚Ñï) extends (ConcreteBTFieldProps k) where
  instFintype : Fintype (ConcreteBTField k)
  fieldFintypeCard : Fintype.card (ConcreteBTField k) = 2^(2^k)
  
  sumZeroIffEq : ‚àÄ (x y : ConcreteBTField k), x + y = 0 ‚Üî x = y
  traceMapEvalAtRootsIs1 :
    letI := mkFieldInstance (k:=k) (props:=toConcreteBTFieldProps)
    TraceMapProperty (ConcreteBTField k) (u:=Z k) k
  instIrreduciblePoly :
    letI := mkFieldInstance (k:=k) (props:=toConcreteBTFieldProps)
    (Irreducible (p := (definingPoly (s:=(Z k)))))

end FieldOperationsAndInstances

section BTFieldPropsOneLevelLiftingLemmas

variable {k : ‚Ñï} {h_k : k > 0}

end BTFieldPropsOneLevelLiftingLemmas

section TowerFieldsConstruction

def liftBTFieldProps (k : ‚Ñï) (prevBTFResult : ConcreteBTFStepResult (k := k)) :
  ConcreteBTFieldProps (k + 1) := {
    zero_mul := concrete_zero_mul (prevBTFResult.toConcreteBTFieldProps),
    zero_mul' := fun a => by admit /- proof elided -/

def liftConcreteBTField (k : ‚Ñï) (prevBTFResult : ConcreteBTFStepResult (k := k)) :
  Field (ConcreteBTField (k + 1)) :=

def concreteCanonicalEmbedding (k : ‚Ñï)
    (prevBTFieldProps : ConcreteBTFieldProps (k := (k)))
    (curBTFieldProps : ConcreteBTFieldProps (k := (k + 1))) :
  letI := mkFieldInstance prevBTFieldProps
  letI := mkFieldInstance curBTFieldProps
  ConcreteBTField k ‚Üí+* ConcreteBTField (k + 1) :=

instance instAlgebraLiftConcreteBTField (k : ‚Ñï)
  (prevBTFResult : ConcreteBTFStepResult (k := k)) :
  letI := mkFieldInstance (prevBTFResult.toConcreteBTFieldProps)
  letI := liftConcreteBTField (k:=k) prevBTFResult
  Algebra (ConcreteBTField k) (ConcreteBTField (k + 1)) :=
  letI := mkFieldInstance (prevBTFResult.toConcreteBTFieldProps)
  letI := liftConcreteBTField (k:=k) prevBTFResult
  RingHom.toAlgebra (R:=ConcreteBTField k) (S:=ConcreteBTField (k + 1))
    (i:=(concreteCanonicalEmbedding (k:=k)
      (prevBTFieldProps:=prevBTFResult.toConcreteBTFieldProps)
      (curBTFieldProps:=liftBTFieldProps (k:=k) (prevBTFResult:=prevBTFResult))))

def getBTFResult (k : ‚Ñï) : ConcreteBTFStepResult k :=
  match k with
  | 0 =>
    let base : ConcreteBTFieldProps 0 := {
      mul_eq := fun a b h_k _ _ _ _ _ _ => by admit /- proof elided -/
| c1_one
        ¬∑ 
          rw [c1_zero] at h_mul
          
          simp at h_mul
        ¬∑ 
          rcases c2_cases with c2_zero | c2_one
          ¬∑ 
            rw [c2_zero] at h_mul
            
            simp at h_mul
          ¬∑ 
            
            exact ‚ü®c1_one, c2_one‚ü©
      
      have specialElement_eq_zero : specialElement = 0 := by admit /- proof elided -/

end TowerFieldsConstruction

section ConcreteBTFieldAlgebraConstruction

def canonicalAlgMap (k : ‚Ñï) := concreteCanonicalEmbedding (k:=k)
  (prevBTFieldProps:= ((getBTFResult k).toConcreteBTFieldProps))
  (curBTFieldProps:= ((getBTFResult (k + 1)).toConcreteBTFieldProps))

def concreteTowerAlgebraMap (l r : ‚Ñï) (h_le : l ‚â§ r) :
    ConcreteBTField l ‚Üí+* ConcreteBTField r :=
</local_ctx>

<target_theorem>
lemma aeval_definingPoly_at_Z_succ (k : ‚Ñï) :
  (aeval (Z (k + 1))) (definingPoly (s:=Z (k))) = 0 :=
</target_theorem>

