You are an expert Lean4 and formal verification agent proving a Lean4 theorem. Your output **must** strictly adhere to the specified format.

### Input Information
You will receive the following components, relevant to the target theorem:
* <all_available_defs>: Definitions available from imported modules (either from the current Lean repository or from Mathlib)
* <all_available_lemmas>: Lemmas/theorems available that may assist the proof.
* <local_ctx>...</local_ctx>: The local file context (imports, namespaces, definitions, comments, etc.) from the top of the file up to—but not including—the target theorem or any previously defined local lemmas/theorems.
* <target_theorem>...</target_theorem>: The target theorem statement, ending with `:=`.

**Notes**
1. Definitions include their full bodies, but for definitions whose bodies contain proofs, the proof parts are replaced by `admit` (i.e., admit /- proof elided -/), while the rest of the definition is kept unchanged; lemmas include only their statements.
2. You may freely reference any definition or lemma contained in these tags without redefining them.
3. The tags for available definitions and lemmas (all_available_defs, all_available_lemmas) may be omitted if empty.

### Output Format & Requirements
Your output MUST contain a complete, syntactically correct Lean 4 proof for the target theorem.

**Strict Output Structure:**
<reasoning> 
...
</reasoning> 

<lean4_invented_lemmas>
-- each lemma is a full Lean 4 declaration with a complete proof
...
</lean4_invented_lemmas>

<lean4_proof>
-- Lean 4 proof body of the target theorem
...
</lean4_proof>

**Requirements:**
1. <reasoning> and <lean4_invented_lemmas> are OPTIONAL. Include them only if they aid proof construction.
2. <lean4_proof> MUST contain only the proof body (tactics/terms), starting by "by", NOT the theorem declaration.
3. <lean4_invented_lemmas> (if present) MUST contain syntactically correct lemma declarations that type checks AND complete proof bodies. Defining a lemma using `axiom` is NOT allowed.
4. <reasoning> contains high-level proof planning.
5. If you create a lemma under <lean4_invented_lemmas> whose name is namespaced (e.g., X.Y.Z), you MUST always refer to it using its fully qualified name. Do NOT rely on shortened names. For example, write rw [X.Y.Z], not rw [Z] for invented lemmas.
6. All Lean 4 code MUST be syntactically correct. No `sorry`, `admit`, or non-Lean text. Comments allowed using `--` or `/- ... -/`.
7. Follow the tags and structure EXACTLY. No extra text before, between, or after the sections.
8. Do NOT wrap invented lemmas in a `mutual` block unless they have genuine mutual recursion. Declare each lemma independently.

### Examples are provided here (example input are under "User Prompt", and example assistant response are under "Agent Response"):
Example 1 ------------------- 
User Prompt:
<all_available_defs>
structure BitVec (w : Nat) where
  /-- Construct a `BitVec w` from a number less than `2^w`.
  O(1), because we use `Fin` as the internal representation of a bitvector. -/
  ofFin ::

  /-- Interpret a bitvector as a number less than `2^w`.
  O(1), because we use `Fin` as the internal representation of a bitvector. -/
  toFin : Fin (hPow 2 w)
</all_available_defs>

<all_available_lemmas>
theorem List.getElem_append_left{α : Type u_1} {l₁ l₂ : List α} {i : Nat} (hn : i < l₁.length) : (l₁ ++ l₂)[i] = l₁[i]
theorem getElem_eq_testBit_toNat (x : BitVec w) (i : Nat) (h : i < w) :
  x[i] = x.toNat.testBit i := rfl
@[simp, grind =] theorem toNat_cons (b : Bool) (x : BitVec w) :
    (cons b x).toNat = (b.toNat <<< w) ||| x.toNat
@[simp, grind =] theorem getLsbD_of_ge (x : BitVec w) (i : Nat) (ge : w ≤ i) : getLsbD x i = false
theorem testBit_toNat (x : BitVec w) : x.toNat.testBit i = x.getLsbD i
</all_available_lemmas>

<local_ctx>
import Mathlib.Computability.NFA
import Mathlib.Data.FinEnum
import Mathlib.Data.Rel
import Mathlib.Data.Vector.Basic
import Blase.AutoStructs.ForLean

open Set
open Mathlib
open SetRel

-- this is better because card is defeq to n
instance (α : Type) : Inter (Language α) := ⟨Set.inter⟩
instance (α : Type) : Union (Language α) := ⟨Set.union⟩

/--
The set of `n`-tuples of bit vectors of an arbitrary width.
-/
structure BitVecs (n : Nat) where
  w : Nat
  bvs : List.Vector (BitVec w) n

def BitVecs.cast (bvs : BitVecs n) (h : n = n') : BitVecs n' :=
  { w := bvs.w, bvs := h ▸ bvs.bvs }

abbrev BitVecs.empty : BitVecs n := ⟨0, List.Vector.replicate n .nil⟩
abbrev BitVecs.singleton {w : Nat} (bv : BitVec w) : BitVecs 1 := ⟨w, bv ::ᵥ .nil⟩
abbrev BitVecs.pair {w : Nat} (bv1 bv2 : BitVec w) : BitVecs 2 := ⟨w, bv1 ::ᵥ bv2 ::ᵥ .nil⟩

/--
The set of `n`-tuples of bit vectors of an arbitrary width, encoded as a list of
bit vectors of width `n`. The width of the encoded bit vectors is the length of
the list.
-/
abbrev BitVecs' (n : Nat) := List (BitVec n)

@[simps]
def dec (bvs' : BitVecs' n) : BitVecs n where
  w := bvs'.length
  bvs := List.Vector.ofFn fun k => BitVec.ofFn fun i => bvs'[i].getLsbD k

@[simp]
</local_ctx>

<target_theorem>
lemma dec_snoc n (bvs' : BitVecs' n) (a : BitVec n) :
  dec (bvs' ++ [a]) =
    { w := bvs'.length + 1
      bvs := List.Vector.ofFn fun k =>
        BitVec.cons (a.getLsbD k) ((dec bvs').bvs.get k) } :=
</target_theorem>

Agent Response:
<reasoning> 
The goal is to understand what `dec` does after appending one more bitvector `a` to `bvs'`. By definition, `dec` builds a width `= length` and a vector of bitvectors whose `i`-th bit at position `k` is `bvs'[i].getLsbD k`. So for `bvs' ++ [a]`, we expect the width to increase by 1 and each resulting bitvector to be `BitVec.cons` of the new bit coming from `a`.

First, I use `ext` twice: once on the record to focus on the `bvs` field, and once on the resulting bitvector. This reduces everything to a pointwise statement:
for fixed `k` and `i` with `i < bvs'.length + 1`,
the bit `(bvs' ++ [a])[i].getLsbD k` should match the bit at index `i` of `BitVec.cons (a.getLsbD k) ((dec bvs').bvs.get k)`.

At this point I need a clean description of indexing into `BitVec.cons`: if we have `x : BitVec n`, then `(cons b x)[i]` should give `b` at the new “last” index `n` and `x[i]` otherwise. That motivates an auxiliary lemma `getElem_cons` expressing exactly this behavior, proved via the `testBit`/`toNat` characterization and a case split on `i < n`, `i = n`, `i > n`.

Using `getElem_cons`, the RHS becomes an `if` on whether `i = bvs'.length`. So I split into cases:
- If `i = bvs'.length`, then `(bvs' ++ [a])[i]` is the appended `a`, so both sides reduce to `a.getLsbD k`.
- If `i ≠ bvs'.length`, the bound `i < bvs'.length + 1` forces `i < bvs'.length`. Then `(bvs' ++ [a])[i] = bvs'[i]` by `List.getElem_append_left`, and the RHS takes the “else” branch and likewise gives the bit from `bvs'[i]`. In both subcases, `simp` (plus the definition of `dec`) finishes.

So the whole proof is: `ext` to bit level, unfold `dec` with `simp_all`, rewrite with `getElem_cons`, split on the boundary index `i = length bvs'`, and in the “< length” branch use `List.getElem_append_left` and bounds to line up both sides.
</reasoning> 

<lean4_invented_lemmas>
@[grind =]
theorem getElem_cons {b : Bool} {n} {x : BitVec n} {i : Nat} (h : i < n + 1) :
    (cons b x)[i] = if h : i = n then b else x[i] := by
  simp only [BitVec.getElem_eq_testBit_toNat, BitVec.toNat_cons, Nat.testBit_or]
  rw [Nat.testBit_shiftLeft]
  rcases Nat.lt_trichotomy i n with i_lt_n | i_eq_n | n_lt_i
  · have p1 : ¬(n ≤ i) := by omega
    have p2 : i ≠ n := by omega
    simp [p1, p2]
  · simp only [i_eq_n, ge_iff_le, Nat.le_refl, decide_true, Nat.sub_self, Nat.testBit_zero,
    Bool.true_and, BitVec.testBit_toNat, BitVec.getLsbD_of_ge, Bool.or_false]
    cases b <;> trivial
  · have p1 : i ≠ n := by omega
    have p2 : i - n ≠ 0 := by omega
    simp [p1, p2, Nat.testBit_bool_toNat]
</lean4_invented_lemmas>

<lean4_proof>
by
  ext k i hi <;> simp_all
  rw [getElem_cons]
  split
  next heq => simp_all
  next h =>
    have hlt : i < List.length bvs' := by simp at hi; omega
    rw [List.getElem_append_left hlt]
    simp
</lean4_proof>

### Your task:
<all_available_defs>
Vector in Init.Data.Vector.Basic
Fin in Init.Prelude
String in Init.Prelude
Unit in Init.Prelude
List in Init.Prelude
Field in Mathlib.Algebra.Field.Defs
Bool in Init.Prelude
DecidableEq in Init.Prelude
FinEnum in Mathlib.Data.FinEnum
Hashable in Init.Prelude
Sum.inl in Init.Core
Sum.inr in Init.Core
Nat in Init.Prelude
Repr in Init.Data.Repr
Sum in Init.Core
Sum.elim in Init.Data.Sum.Basic
id in Init.Prelude
Empty in Init.Prelude
Empty.elim in Init.Core
Nat.max in Init.Data.Nat.Basic
Nat.min in Init.Data.Nat.Basic
Decidable in Init.Prelude

syntax "min" : MLIR.Pretty.uniform_op

syntax "neg" : MLIR.Pretty.uniform_op

macro_rules
  | `(mlir_op| $res:mlir_op_operand = const ($x)
      $[: $outer_type]? ) => do
      let outer_type ← outer_type.getDM `(mlir_type| _)
      `(mlir_op| $res:mlir_op_operand = "const"()
          {val = $x:num : $outer_type} : ($outer_type) -> ($outer_type) )

macro_rules
  | `(mlir_op| $res:mlir_op_operand = li ($x)
     $[: $outer_type]?  ) => do
      let outer_type ← outer_type.getDM `(mlir_type| _ )
      `(mlir_op| $res:mlir_op_operand = "li"()
          {imm = $x:num : $outer_type } : ($outer_type) -> ($outer_type))

macro_rules
| `(mlir_op| $res:mlir_op_operand = $op1:MLIR.Pretty.RV.opWithImmediate $reg1 , $x : $t)  => do
    let some opName := MLIR.EDSL.Pretty.extractOpName op1.raw
      | Macro.throwUnsupported
    `(mlir_op| $res:mlir_op_operand = $opName ($reg1) {imm = $x:num : $t} : ($t) -> ($t) )

macro_rules
| `(mlir_op| $res:mlir_op_operand = $op1:MLIR.Pretty.RV.opWithShamt $reg1 , $x  : $t )  => do
    let some opName := MLIR.EDSL.Pretty.extractOpName op1.raw
      | Macro.throwUnsupported
    `(mlir_op| $res:mlir_op_operand = $opName ($reg1) {shamt = $x:num : $t}  : ($t) -> ($t) )

def ls (b : Bool) : FSM Unit :=
  { α := Unit,
    initCarry := fun _ => b,
    nextStateCirc := fun () => Circuit.var true (inr ()),
    outputCirc := Circuit.var true (inl ())
  }

structure FSM (arity : Type) : Type 1 where
   
  ( α  : Type )
  [ i : FinEnum α ]
  [ h : Hashable α ]
  [ dec_eq : DecidableEq α ]
   
  ( initCarry : α → Bool )
   
  outputCirc : Circuit (α ⊕ arity)
  nextStateCirc : α → Circuit (α ⊕ arity)

inductive Circuit (α : Type u) : Type u
  | tru : Circuit α
  | fals : Circuit α
   
  | var : (positive: Bool) → α → Circuit α
  | and : Circuit α → Circuit α → Circuit α
  | or : Circuit α → Circuit α → Circuit α
  | xor : Circuit α → Circuit α → Circuit α
deriving Repr, DecidableEq

def Var (Γ : Context Ty) (ty : Ty) : Type := { v : VarName // Γ.hasType v ty }

inductive StateSpace (wcard tcard bcard ncard icard pcard : Nat)
| widthVar (v : Fin wcard)
| termVar (v : Fin tcard)
| predVar (v : Fin pcard)
| boolVar (v : Fin bcard)
deriving DecidableEq, Repr, Hashable

inductive Term
| ofNat (w : WidthExpr) (n : Nat) : Term
| var (v : Nat) (w : WidthExpr) : Term
| add (w : WidthExpr) (a b : Term) : Term
| zext (a : Term) (wnew : WidthExpr) : Term
| setWidth (a : Term) (wnew : WidthExpr) : Term
| sext (a : Term) (wnew : WidthExpr) : Term
| bor (w : WidthExpr) (a b : Term) : Term
| band (w : WidthExpr) (a b : Term) : Term
| bxor (w : WidthExpr) (a b : Term) : Term
| bnot (w : WidthExpr)  (a : Term) : Term
| boolVar (v : Nat) : Term
| boolConst (b : Bool) : Term
| shiftl (w : WidthExpr) (a : Term) (k : Nat) : Term
| bvOfBool (b : Term) : Term
| binWidthRel (k : WidthBinaryRelationKind) (wa wb : WidthExpr) : Term
| binRel (k : BinaryRelationKind) (w : WidthExpr)
    (a : Term) (b : Term) : Term
| or (p1 p2 : Term) : Term
| and (p1 p2 : Term) : Term
| pvar (v : Nat) : Term
| boolBinRel (k : BoolBinaryRelationKind)
    (a b : Term) : Term
deriving DecidableEq, Inhabited, Repr, Lean.ToExpr

def composeUnaryAux
    (p : FSM Unit)
    (q : FSM arity) :
    FSM arity :=
  p.compose
    arity
    _
    (λ _ => id)
    (λ _ => q)

def compose [FinEnum arity] [DecidableEq arity] [Hashable arity]
    (new_arity : Type)        
    (q_arity : arity → Type)  
    (vars : ∀ (a : arity), q_arity a → new_arity)
    
    
    (q : ∀ (a : arity), FSM (q_arity a)) : 
    FSM new_arity :=
  { α := p.α ⊕ (Σ a, (q a).α),
    i := by admit /- proof elided -/

structure NatFSM (wcard tcard bcard ncard icard pcard : Nat) (v : Nondep.WidthExpr) where
  toFsm : FSM (StateSpace wcard tcard bcard ncard icard pcard)

inductive WidthExpr where
| const : Nat → WidthExpr
| var : Nat → WidthExpr
| max : WidthExpr → WidthExpr → WidthExpr
| min : WidthExpr → WidthExpr → WidthExpr
| addK : WidthExpr → Nat → WidthExpr
| kadd : Nat → WidthExpr → WidthExpr
deriving Inhabited, Repr, Hashable, DecidableEq, Lean.ToExpr

def scanAnd  : FSM Unit :=
  {
   α := Unit,
   initCarry := fun () => true,
   outputCirc := Circuit.var true (inl ()) &&& Circuit.var true (inr ()),
   nextStateCirc := fun () => (Circuit.var true (inl ())) &&& (Circuit.var true (inr ()))
  }

def scanOr  : FSM Unit :=
  {
   α := Unit,
   initCarry := fun () => false,
   outputCirc := Circuit.var true (inl ()) ||| Circuit.var true (inr ()),
   nextStateCirc := fun () => Circuit.var true (inl ()) ||| Circuit.var true (inr ())
  }

def composeBinaryAux'
    (p : FSM Bool)
    (qtrue : FSM α)
    (qfalse : FSM α) :
    FSM α :=
  p.compose (α)
    (λ _ => α)
    (λ _ i => i)
    (λ b => match b with
      | true => qtrue
      | false => qfalse)

def and : FSM Bool :=
  { α := Empty,
    initCarry := Empty.elim,
    nextStateCirc := fun a => a.elim,
    outputCirc := Circuit.var true (inr true) &&& Circuit.var true (inr false),
  }

abbrev WidthExpr.Env (wcard : Nat) : Type :=
  Fin wcard → Nat

structure HWidthEnv {wcard tcard : Nat}
    (fsmEnv : StateSpace wcard tcard bcard ncard icard pcard → BitStream)
    (wenv : Fin wcard → Nat) : Prop where
    heq_width : ∀ (v : Fin wcard),
      fsmEnv (StateSpace.widthVar v) = BitStream.ofNatUnary (wenv v)

structure HPredicateEnv {wcard tcard bcard ncard icard pcard : Nat}
    (fsmEnv : StateSpace wcard tcard bcard ncard icard pcard → BitStream)
    (penv : Fin pcard → Prop) : Prop where
    heq_width : ∀ (v : Fin pcard),
      fsmEnv (StateSpace.predVar v) = BitStream.ofProp (penv v)

def BitStream : Type := Nat → Bool

abbrev ofNatUnary (n : Nat) : BitStream :=
  fun i => decide (i < n)

structure HNatFSMToBitstream {wcard : Nat} {v : WidthExpr wcard} {tcard : Nat} {bcard : Nat} {pcard : Nat}
   (fsm : NatFSM wcard tcard bcard ncard icard pcard (.ofDep v)) : Prop where
  heq :
    ∀ (wenv : Fin wcard → Nat)
    (fsmEnv : StateSpace wcard tcard bcard ncard icard pcard → BitStream),
    (henv : HWidthEnv fsmEnv wenv) →
      fsm.toFsm.eval fsmEnv =
      BitStream.ofNatUnary (v.toNat wenv)

def WidthExpr.toNat (e : WidthExpr wcard) (env : WidthExpr.Env wcard) : Nat :=
  match e with
  | .const n => n
  | .var v => env v
  | .min v w => Nat.min (v.toNat env) (w.toNat env)
  | .max v w => Nat.max (v.toNat env) (w.toNat env)
  | .addK v k => v.toNat env + k
  | .kadd k v => k + v.toNat env

inductive WidthExpr (wcard : Nat) : Type
| const (n : Nat) :  WidthExpr wcard
| var : (v : Fin wcard) → WidthExpr wcard
| min : (v w : WidthExpr wcard) → WidthExpr wcard
| max : (v w : WidthExpr wcard) → WidthExpr wcard
| addK : (v : WidthExpr wcard) → (k : Nat) → WidthExpr wcard
| kadd : (k : Nat) → (v : WidthExpr wcard) → WidthExpr wcard

structure HPredFSMToBitStream {pcard : Nat}
  {tctx : Term.Ctx wcard tcard}
  {p : Term bcard ncard icard pcard tctx .prop}
  (fsm : TermFSM wcard tcard bcard ncard icard pcard
    (.ofDepTerm p)) : Prop where
  heq :
    ∀ {wenv : WidthExpr.Env wcard}
      (benv : Term.BoolEnv bcard)
      (nenv : Term.NatEnv ncard)
      (ienv : Term.IntEnv icard)
      (penv : Predicate.Env pcard) (tenv : tctx.Env wenv)
      (fsmEnv : StateSpace wcard tcard bcard ncard icard pcard → BitStream),
      (htenv : HTermEnv fsmEnv tenv benv) →
      (hpenv : HPredicateEnv fsmEnv penv) →
        p.toBV benv nenv ienv penv tenv  ↔ (fsm.toFsmZext.eval fsmEnv = .negOne)

def scanOr (s : BitStream) : BitStream := scanl false Bool.or s

abbrev scanl (init : Bool) (f : Bool → Bool → Bool) (s : BitStream) : BitStream :=
  fun n => match n with
    | 0 => f init (s 0)
    | n+1 => f (scanl init f s n) (s (n + 1))

def scanAnd (s : BitStream) : BitStream := scanl true Bool.and s

def rewrite00 : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64), Ty.llvm (.bitvec 64)] where
  lhs:= [LV| {
  ^entry (%arg: i64, %amount: i64):
    %0 = llvm.shl %arg, %amount : i64
    %1 = llvm.lshr %0, %amount : i64
    llvm.return %1 : i64
  }]

  rhs:= [LV| {
  ^entry (%arg: i64, %amount: i64):
    llvm.return %arg : i64
  }]
  correct := by admit /- proof elided -/

def p_commutative4_before := [llvm|
{
^0(%arg22 : i32, %arg23 : i32, %arg24 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.and %arg24, %arg22 : i32
  %2 = llvm.xor %arg24, %0 : i32
  %3 = llvm.and %2, %arg23 : i32
  %4 = llvm.add %3, %1 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

BitVec.xor in Init.Data.BitVec.Basic

def alive_AndOrXor_2188_tgt :=
[sllvm| {
^bb0(%A : i64, %D : i64):
  %v1 = llvm.mlir.constant -1 : i64
  %v2 = llvm.xor %D, %v1 : i64
  %v3 = llvm.mlir.constant -1 : i64
  %v4 = llvm.xor %A, %v3 : i64
  %v5 = llvm.and %A, %v2 : i64
  %v6 = llvm.and %v4, %D : i64
  %v7 = llvm.xor %A, %D : i64
  llvm.return %v7 : i64
}]

def and1_shl1_is_cmp_eq_0_multiuse_before := [llvm|
{
^0(%arg14 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.shl %0, %arg14 : i8
  %2 = llvm.and %1, %0 : i8
  %3 = llvm.add %1, %2 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def test : DCOp.ValueStream Int :=
  joinPackUnpack.denote (Ctxt.Valuation.ofHVector (.cons x <| .cons y <| .nil))

def pr40493_neg3_after := [llvm|
{
^0(%arg15 : i32):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.mlir.constant(4 : i32) : i32
  %2 = llvm.shl %arg15, %0 : i32
  %3 = llvm.and %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def scalar_i8_lshr_and_negC_eq_not_negatedPowerOf2_before := [llvm|
{
^0(%arg0 : i8, %arg1 : i8):
  %0 = llvm.mlir.constant(-3 : i8) : i8
  %1 = llvm.mlir.constant(0 : i8) : i8
  %2 = llvm.lshr %arg0, %arg1 : i8
  %3 = llvm.and %2, %0 : i8
  %4 = llvm.icmp "eq" %3, %1 : i8
  "llvm.return"(%4) : (i1) -> ()
}
]

def test66_after := [llvm|
{
^0(%arg41 : i64):
  %0 = llvm.mlir.constant(4294967296) : i64
  %1 = llvm.mlir.constant(0) : i64
  %2 = llvm.mlir.constant(42 : i32) : i32
  %3 = llvm.mlir.constant(40 : i32) : i32
  %4 = llvm.and %arg41, %0 : i64
  %5 = llvm.icmp "eq" %4, %1 : i64
  %6 = "llvm.select"(%5, %2, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def ashr_ult_0_after := [llvm|
{
^0(%arg98 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def lshrult_02_14_exact_before := [llvm|
{
^0(%arg119 : i4):
  %0 = llvm.mlir.constant(2 : i4) : i4
  %1 = llvm.mlir.constant(-2 : i4) : i4
  %2 = llvm.lshr exact %arg119, %0 : i4
  %3 = llvm.icmp "ult" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def ashr_lshr_shift_wrong_pred2_after := [llvm|
{
^0(%arg79 : i32, %arg80 : i32, %arg81 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.lshr %arg79, %arg80 : i32
  %2 = llvm.ashr %arg79, %arg80 : i32
  %3 = llvm.icmp "slt" %arg81, %0 : i32
  %4 = "llvm.select"(%3, %2, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def foo2_after := [llvm|
{
^0(%arg46 : i32, %arg47 : i32):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.icmp "sgt" %arg46, %0 : i32
  %3 = llvm.sub %1, %arg47 : i32
  %4 = "llvm.select"(%2, %arg47, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %5 = llvm.add %arg46, %4 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def xvar' : MultiWidth.Nondep.Term := MultiWidth.Nondep.Term.var 0 xw'

def main7a_logical_before := [llvm|
{
^0(%arg81 : i32, %arg82 : i32, %arg83 : i32):
  %0 = llvm.mlir.constant(false) : i1
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.and %arg82, %arg81 : i32
  %4 = llvm.icmp "eq" %3, %arg82 : i32
  %5 = llvm.and %arg83, %arg81 : i32
  %6 = llvm.icmp "eq" %5, %arg83 : i32
  %7 = "llvm.select"(%4, %6, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %8 = "llvm.select"(%7, %1, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%8) : (i32) -> ()
}
]

def or_after := [llvm|
{
^0(%arg678 : i64, %arg679 : i64):
  %0 = llvm.or %arg679, %arg678 : i64
  "llvm.return"(%0) : (i64) -> ()
}
]

def test15e_before := [llvm|
{
^0(%arg23 : i32):
  %0 = llvm.mlir.constant(128 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(256 : i32) : i32
  %3 = llvm.and %arg23, %0 : i32
  %4 = llvm.icmp "ne" %3, %1 : i32
  %5 = "llvm.select"(%4, %2, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def alive_InstCombineShift__440_src  (w : Nat)   :=
[llvm( w )| {
^bb0(%Y : _, %X : _, %C : _, %C2 : _):
  %v1 = llvm.lshr %X, %C
  %v2 = llvm.and %v1, %C2
  %v3 = llvm.xor %Y, %v2
  %v4 = llvm.shl %v3, %C
  llvm.return %v4
}]

def or_xor_xor_normal_variant3_after := [llvm|
{
^0(%arg13 : i16, %arg14 : i16):
  %0 = llvm.xor %arg14, %arg13 : i16
  "llvm.return"(%0) : (i16) -> ()
}
]

def zext_sext_add_icmp_sgt_1_after := [llvm|
{
^0(%arg92 : i1, %arg93 : i1):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

instance [ToString w] : ToString (DCOp.ValueStream w) where
  toString s := toString (Stream.toList 10 s)

def icmp_eq_or_z_or_pow2orz_logical_after := [llvm|
{
^0(%arg25 : i8, %arg26 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.sub %0, %arg26 : i8
  %2 = llvm.and %arg26, %1 : i8
  %3 = llvm.and %arg25, %2 : i8
  %4 = llvm.icmp "eq" %3, %arg25 : i8
  "llvm.return"(%4) : (i1) -> ()
}
]

def trunc_ashr_before := [llvm|
{
^0(%arg98 : i32):
  %0 = llvm.mlir.constant(-2147483648 : i36) : i36
  %1 = llvm.mlir.constant(8 : i36) : i36
  %2 = llvm.zext %arg98 : i32 to i36
  %3 = llvm.or %2, %0 : i36
  %4 = llvm.ashr %3, %1 : i36
  %5 = llvm.trunc %4 : i36 to i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def sub_from_variable_of_sub_from_constant_before := [llvm|
{
^0(%arg183 : i8, %arg184 : i8):
  %0 = llvm.mlir.constant(42 : i8) : i8
  %1 = llvm.sub %0, %arg183 : i8
  %2 = llvm.sub %arg184, %1 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def lshrult_02_09_after := [llvm|
{
^0(%arg342 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

instance : ToString (MOp 0) where
   toString  op :=
     match op with
     | .unary _w op => s!"\"{toString op}\""
     | .binary _w op => s!"\"{toString  op}\""
     | .select  _w => "select"
     | .icmp  _pred _w => "icmp"
     | .const w val => s!"\"llvm.mlir.constant\"() \{value = {val} : {w}}"

def test_invert_demorgan_or2_after := [llvm|
{
^0(%arg15 : i64, %arg16 : i64, %arg17 : i64):
  %0 = llvm.mlir.constant(24) : i64
  %1 = llvm.mlir.constant(60) : i64
  %2 = llvm.icmp "ult" %arg15, %0 : i64
  %3 = llvm.icmp "ult" %arg16, %1 : i64
  %4 = llvm.and %2, %3 : i1
  %5 = llvm.icmp "ult" %arg17, %1 : i64
  %6 = llvm.and %4, %5 : i1
  "llvm.return"(%6) : (i1) -> ()
}
]

def src_is_mask_const_slt_after := [llvm|
{
^0(%arg48 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.icmp "slt" %arg48, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def zext_nneg_sext_sle_op0_narrow_before := [llvm|
{
^0(%arg50 : i8, %arg51 : i16):
  %0 = llvm.zext nneg %arg50 : i8 to i32
  %1 = llvm.sext %arg51 : i16 to i32
  %2 = llvm.icmp "sle" %0, %1 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def Predicate.quote (p : Predicate) : Expr :=
  match p with
  | .width .eq n => mkApp2 (mkConst ``Predicate.width) (mkConst ``WidthPredicate.eq) (mkNatLit n)
  | .width .neq n => mkApp2 (mkConst ``Predicate.width) (mkConst ``WidthPredicate.neq) (mkNatLit n)
  | .width .lt n => mkApp2 (mkConst ``Predicate.width) (mkConst ``WidthPredicate.lt) (mkNatLit n)
  | .width .le n => mkApp2 (mkConst ``Predicate.width) (mkConst ``WidthPredicate.le) (mkNatLit n)
  | .width .gt n => mkApp2 (mkConst ``Predicate.width) (mkConst ``WidthPredicate.gt) (mkNatLit n)
  | .width .ge n => mkApp2 (mkConst ``Predicate.width) (mkConst ``WidthPredicate.ge) (mkNatLit n)
  | .binary .eq a b => mkApp2 (mkConstBin ``BinaryPredicate.eq) (Term.quote a) (Term.quote b)
  | .binary .neq a b => mkApp2 (mkConstBin ``BinaryPredicate.neq) (Term.quote a) (Term.quote b)
  | .binary .ult a b => mkApp2 (mkConstBin ``BinaryPredicate.ult) (Term.quote a) (Term.quote b)
  | .binary .ule a b => mkApp2 (mkConstBin ``BinaryPredicate.ule) (Term.quote a) (Term.quote b)
  | .binary .slt a b => mkApp2 (mkConstBin ``BinaryPredicate.slt) (Term.quote a) (Term.quote b)
  | .binary .sle a b => mkApp2 (mkConstBin ``BinaryPredicate.sle) (Term.quote a) (Term.quote b)
  | land p q => mkApp2 (mkConst ``Predicate.land) (Predicate.quote p) (Predicate.quote q)
  | lor p q => mkApp2 (mkConst ``Predicate.lor) (Predicate.quote p) (Predicate.quote q)

def test_or1_before := [llvm|
{
^0(%arg36 : i32, %arg37 : i32):
  %0 = llvm.mlir.constant(2147483647 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.and %arg37, %0 : i32
  %3 = llvm.icmp "slt" %arg36, %1 : i32
  %4 = llvm.icmp "sge" %arg36, %2 : i32
  %5 = llvm.or %3, %4 : i1
  "llvm.return"(%5) : (i1) -> ()
}
]

def icmp_and_ashr_multiuse_logical_after := [llvm|
{
^0(%arg4 : i32):
  %0 = llvm.mlir.constant(240 : i32) : i32
  %1 = llvm.mlir.constant(224 : i32) : i32
  %2 = llvm.mlir.constant(496 : i32) : i32
  %3 = llvm.mlir.constant(432 : i32) : i32
  %4 = llvm.and %arg4, %0 : i32
  %5 = llvm.icmp "ne" %4, %1 : i32
  %6 = llvm.and %arg4, %2 : i32
  %7 = llvm.icmp "ne" %6, %3 : i32
  %8 = llvm.and %5, %7 : i1
  "llvm.return"(%8) : (i1) -> ()
}
]

@[simp]
def envBitstream_set_self_eq_self (x : arity → BitStream) (n : Nat) :
    (envBitstream_set x n (fun a => x a n)) = x :=

def PR42691_6_logical_before := [llvm|
{
^0(%arg332 : i32):
  %0 = llvm.mlir.constant(-2147483647 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.mlir.constant(true) : i1
  %3 = llvm.icmp "ult" %arg332, %0 : i32
  %4 = llvm.icmp "eq" %arg332, %1 : i32
  %5 = "llvm.select"(%3, %2, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%5) : (i1) -> ()
}
]

def ult_and_not_max_commute_before := [llvm|
{
^0(%arg106 : i8, %arg107 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.icmp "ult" %arg106, %arg107 : i8
  %2 = llvm.icmp "ne" %arg106, %0 : i8
  %3 = llvm.and %2, %1 : i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def is_ascii_alphabetic_inverted_before := [llvm|
{
^0(%arg247 : i32):
  %0 = llvm.mlir.constant(-91 : i32) : i32
  %1 = llvm.mlir.constant(-26 : i32) : i32
  %2 = llvm.mlir.constant(-123 : i32) : i32
  %3 = llvm.mlir.constant(false) : i1
  %4 = llvm.add %arg247, %0 overflow<nsw> : i32
  %5 = llvm.icmp "ult" %4, %1 : i32
  %6 = llvm.add %arg247, %2 overflow<nsw> : i32
  %7 = llvm.icmp "ult" %6, %1 : i32
  %8 = "llvm.select"(%5, %7, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%8) : (i1) -> ()
}
]

def and_xor_or4_after := [llvm|
{
^0(%arg664 : i64, %arg665 : i64, %arg666 : i64):
  %0 = llvm.mlir.constant(42) : i64
  %1 = llvm.udiv %0, %arg665 : i64
  %2 = llvm.udiv %0, %arg666 : i64
  %3 = llvm.or %2, %1 : i64
  "llvm.return"(%3) : (i64) -> ()
}
]

@[elab_as_elim, cases_eliminator]
def casesOn'.{u} {α : Type} {motive : PoisonOr α → Sort u}
    (a? : PoisonOr α)
    (poison : motive poison)
    (value : (a : α) → motive (value a))
    : motive a? :=
  match a? with
  | .poison => poison
  | .value a => value a

def is_ascii_alphabetic_after := [llvm|
{
^0(%arg248 : i32):
  %0 = llvm.mlir.constant(-33 : i32) : i32
  %1 = llvm.mlir.constant(-65 : i32) : i32
  %2 = llvm.mlir.constant(26 : i32) : i32
  %3 = llvm.and %arg248, %0 : i32
  %4 = llvm.add %3, %1 : i32
  %5 = llvm.icmp "ult" %4, %2 : i32
  "llvm.return"(%5) : (i1) -> ()
}
]

acNf in Leanwuzla.Basic

def icmp_eq_and_pow2_shl_pow2_negative2_before := [llvm|
{
^0(%arg60 : i32):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.mlir.constant(14 : i32) : i32
  %2 = llvm.mlir.constant(0 : i32) : i32
  %3 = llvm.shl %0, %arg60 : i32
  %4 = llvm.and %3, %1 : i32
  %5 = llvm.icmp "eq" %4, %2 : i32
  %6 = llvm.zext %5 : i1 to i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def nonexact_lshr_ne_noexactlog_before := [llvm|
{
^0(%arg135 : i8):
  %0 = llvm.mlir.constant(90 : i8) : i8
  %1 = llvm.mlir.constant(30 : i8) : i8
  %2 = llvm.lshr %0, %arg135 : i8
  %3 = llvm.icmp "ne" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def masked_icmps_mask_notallzeros_bmask_mixed_negated_5_before := [llvm|
{
^0(%arg60 : i32):
  %0 = llvm.mlir.constant(15 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(8 : i32) : i32
  %3 = llvm.and %arg60, %0 : i32
  %4 = llvm.icmp "eq" %3, %1 : i32
  %5 = llvm.and %arg60, %0 : i32
  %6 = llvm.icmp "ne" %5, %2 : i32
  %7 = llvm.or %4, %6 : i1
  "llvm.return"(%7) : (i1) -> ()
}
]

def lshrugt_03_14_exact_after := [llvm|
{
^0(%arg175 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def invert_both_cmp_operands_add_before := [llvm|
{
^0(%arg38 : i32, %arg39 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.xor %arg38, %0 : i32
  %3 = llvm.add %arg39, %2 : i32
  %4 = llvm.icmp "sgt" %3, %1 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def PR38021_before := [llvm|
{
^0(%arg0 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.mlir.constant(-63 : i8) : i8
  %2 = llvm.lshr %arg0, %0 : i8
  %3 = llvm.add %2, %1 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def udiv_exact_eq_1_after := [llvm|
{
^0(%arg10 : i8, %arg11 : i8):
  %0 = llvm.icmp "ne" %arg10, %arg11 : i8
  "llvm.return"(%0) : (i1) -> ()
}
]

def test_cast_select_before := [llvm|
{
^0(%arg12 : i1):
  %0 = llvm.mlir.constant(3 : i16) : i16
  %1 = llvm.mlir.constant(5 : i16) : i16
  %2 = "llvm.select"(%arg12, %0, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i16, i16) -> i16
  %3 = llvm.zext %2 : i16 to i32
  "llvm.return"(%3) : (i32) -> ()
}
]

noncomputable def TV_sub_lhs_add_const : PeepholeRewrite (ModArith q) [.modLike] .modLike :=
{
  lhs := test_sub_lhs_add_const_LHS,
  rhs := test_sub_lhs_add_const_RHS,
  correct := by admit /- proof elided -/

def lshrugt_02_04_after := [llvm|
{
^0(%arg395 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

RV64.xnor in RISCV.Instructions

def lshr_and_after := [llvm|
{
^0(%arg18 : i8):
  %0 = llvm.mlir.constant(32 : i8) : i8
  %1 = llvm.lshr %0, %arg18 : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

abbrev MatchVar (Δ Γ : Ctxt d.Ty)  := MatchVarM Δ Γ Unit

def negative_not_power_of_two_before := [llvm|
{
^0(%arg7 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.mlir.constant(255 : i32) : i32
  %2 = llvm.mlir.constant(256 : i32) : i32
  %3 = llvm.icmp "sgt" %arg7, %0 : i32
  %4 = llvm.add %arg7, %1 : i32
  %5 = llvm.icmp "ult" %4, %2 : i32
  %6 = llvm.and %3, %5 : i1
  "llvm.return"(%6) : (i1) -> ()
}
]

def or_nand_xor_common_op_commute0_after := [llvm|
{
^0(%arg77 : i4, %arg78 : i4, %arg79 : i4):
  %0 = llvm.mlir.constant(-1 : i4) : i4
  %1 = llvm.and %arg77, %arg79 : i4
  %2 = llvm.and %1, %arg78 : i4
  %3 = llvm.xor %2, %0 : i4
  "llvm.return"(%3) : (i4) -> ()
}
]

def n5_after := [llvm|
{
^0(%arg9 : i8, %arg10 : i8, %arg11 : i8):
  "llvm.return"(%arg11) : (i8) -> ()
}
]

Polynomial.int in Mathlib.Algebra.Ring.Subring.IntPolynomial

instance : CoeOut (Var (Γ.dropUntil v) ty) (Var Γ ty) where
  coe v := dropUntilDiff.toHom v

def ashr_eq_exact_after := [llvm|
{
^0(%arg173 : i8):
  %0 = llvm.mlir.constant(80 : i8) : i8
  %1 = llvm.icmp "eq" %arg173, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

@[simp]
def liftUnop_unchanged' (k : Fin n) : liftUnop n k.castSucc = k.castLE (by simp) :=

def demorgan_nand_before := [llvm|
{
^0(%arg38 : i8, %arg39 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.xor %arg38, %0 : i8
  %2 = llvm.and %1, %arg39 : i8
  %3 = llvm.xor %2, %0 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def mullo_variant3_after := [llvm|
{
^0(%arg4 : i64, %arg5 : i64):
  %0 = llvm.mul %arg4, %arg5 : i64
  "llvm.return"(%0) : (i64) -> ()
}
]

def logical_or_not_before := [llvm|
{
^0(%arg260 : i1, %arg261 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = "llvm.select"(%arg260, %arg261, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%1) : (i1) -> ()
}
]

@[simp_denote]
def sext_llvm_i1_to_i16 := [LV| {
  ^entry (%arg: i1):
    %0 = llvm.sext %arg: i1 to i16
    llvm.return %0: i16
  }]

def mul_splat_fold_no_nuw_before := [llvm|
{
^0(%arg79 : i32):
  %0 = llvm.mlir.constant(65537 : i32) : i32
  %1 = llvm.mlir.constant(16 : i32) : i32
  %2 = llvm.mul %arg79, %0 overflow<nsw> : i32
  %3 = llvm.lshr %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def lshrugt_02_07_exact_before := [llvm|
{
^0(%arg198 : i4):
  %0 = llvm.mlir.constant(2 : i4) : i4
  %1 = llvm.mlir.constant(7 : i4) : i4
  %2 = llvm.lshr exact %arg198, %0 : i4
  %3 = llvm.icmp "ugt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def and_two_ranges_to_mask_and_range_no_add_on_one_range_before := [llvm|
{
^0(%arg249 : i16):
  %0 = llvm.mlir.constant(12 : i16) : i16
  %1 = llvm.mlir.constant(16 : i16) : i16
  %2 = llvm.mlir.constant(28 : i16) : i16
  %3 = llvm.icmp "uge" %arg249, %0 : i16
  %4 = llvm.icmp "ult" %arg249, %1 : i16
  %5 = llvm.icmp "uge" %arg249, %2 : i16
  %6 = llvm.or %4, %5 : i1
  %7 = llvm.and %3, %6 : i1
  "llvm.return"(%7) : (i1) -> ()
}
]

def max_sub_ugt_c32_before := [llvm|
{
^0(%arg3 : i32):
  %0 = llvm.mlir.constant(3 : i32) : i32
  %1 = llvm.mlir.constant(-2 : i32) : i32
  %2 = llvm.mlir.constant(0 : i32) : i32
  %3 = llvm.icmp "ugt" %0, %arg3 : i32
  %4 = llvm.add %arg3, %1 : i32
  %5 = "llvm.select"(%3, %4, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def shrMax (a : BitVec v) (b : BitVec w) : BitVec (max v w) :=
    a.signExtend (max v w) >>> b.signExtend (max v w)

def fold_sext_to_and_wrong4_after := [llvm|
{
^0(%arg6 : i8):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def not_ashr_const_before := [llvm|
{
^0(%arg138 : i8):
  %0 = llvm.mlir.constant(-42 : i8) : i8
  %1 = llvm.mlir.constant(-1 : i8) : i8
  %2 = llvm.ashr %0, %arg138 : i8
  %3 = llvm.xor %2, %1 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def ripple_nsw3_after := [llvm|
{
^0(%arg19 : i16, %arg20 : i16):
  %0 = llvm.mlir.constant(-21845 : i16) : i16
  %1 = llvm.mlir.constant(21843 : i16) : i16
  %2 = llvm.and %arg20, %0 : i16
  %3 = llvm.and %arg19, %1 : i16
  %4 = llvm.add %2, %3 overflow<nsw,nuw> : i16
  "llvm.return"(%4) : (i16) -> ()
}
]

def test_or_eq_different_operands_before := [llvm|
{
^0(%arg24 : i8, %arg25 : i8, %arg26 : i8):
  %0 = llvm.icmp "eq" %arg24, %arg26 : i8
  %1 = llvm.icmp "eq" %arg25, %arg24 : i8
  %2 = llvm.or %0, %1 : i1
  %3 = "llvm.select"(%2, %arg24, %arg25) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def alive_InstCombineShift__476_src  (w : Nat)   :=
[llvm( w )| {
^bb0(%Y : _, %X : _, %C : _, %C2 : _):
  %v1 = llvm.lshr %X, %C
  %v2 = llvm.and %v1, %C2
  %v3 = llvm.or %v2, %Y
  %v4 = llvm.shl %v3, %C
  llvm.return %v4
}]

def sext_xor_sub_2_before := [llvm|
{
^0(%arg24 : i64, %arg25 : i1):
  %0 = llvm.sext %arg25 : i1 to i64
  %1 = llvm.xor %arg24, %0 : i64
  %2 = llvm.sub %0, %1 : i64
  "llvm.return"(%2) : (i64) -> ()
}
]

def bools_logical_commute3_and2_before := [llvm|
{
^0(%arg69 : i1, %arg70 : i1, %arg71 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.mlir.constant(false) : i1
  %2 = llvm.xor %arg71, %0 : i1
  %3 = "llvm.select"(%arg69, %2, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %4 = llvm.and %arg70, %arg71 : i1
  %5 = "llvm.select"(%3, %0, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%5) : (i1) -> ()
}
]

def test19_after := [llvm|
{
^0(%arg278 : i32):
  %0 = llvm.mlir.constant(3 : i32) : i32
  %1 = llvm.shl %arg278, %0 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def add_shl_same_amount_partial_nuw2_after := [llvm|
{
^0(%arg32 : i6, %arg33 : i6, %arg34 : i6):
  %0 = llvm.add %arg32, %arg33 : i6
  %1 = llvm.shl %0, %arg34 : i6
  "llvm.return"(%1) : (i6) -> ()
}
]

def icmp_and_ashr_multiuse_logical_after := [llvm|
{
^0(%arg4 : i32):
  %0 = llvm.mlir.constant(240 : i32) : i32
  %1 = llvm.mlir.constant(224 : i32) : i32
  %2 = llvm.mlir.constant(496 : i32) : i32
  %3 = llvm.mlir.constant(432 : i32) : i32
  %4 = llvm.and %arg4, %0 : i32
  %5 = llvm.icmp "ne" %4, %1 : i32
  %6 = llvm.and %arg4, %2 : i32
  %7 = llvm.icmp "ne" %6, %3 : i32
  %8 = llvm.and %5, %7 : i1
  "llvm.return"(%8) : (i1) -> ()
}
]

def main4f_like_logical_after := [llvm|
{
^0(%arg115 : i32, %arg116 : i32, %arg117 : i32):
  %0 = llvm.mlir.constant(false) : i1
  %1 = llvm.and %arg115, %arg116 : i32
  %2 = llvm.icmp "eq" %1, %arg116 : i32
  %3 = llvm.and %arg115, %arg117 : i32
  %4 = llvm.icmp "eq" %3, %arg117 : i32
  %5 = "llvm.select"(%2, %4, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %6 = llvm.zext %5 : i1 to i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def shl_bad_sub_i8_before := [llvm|
{
^0(%arg8 : i8):
  %0 = llvm.mlir.constant(4 : i8) : i8
  %1 = llvm.mlir.constant(1 : i8) : i8
  %2 = llvm.sub %0, %arg8 : i8
  %3 = llvm.shl %1, %2 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def ashrsgt_02_05_exact_after := [llvm|
{
^0(%arg80 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def ashrslt_02_01_exact_before := [llvm|
{
^0(%arg36 : i4):
  %0 = llvm.mlir.constant(2 : i4) : i4
  %1 = llvm.mlir.constant(1 : i4) : i4
  %2 = llvm.ashr exact %arg36, %0 : i4
  %3 = llvm.icmp "slt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def sub_from_constant_of_sub_from_constant_before := [llvm|
{
^0(%arg186 : i8):
  %0 = llvm.mlir.constant(42 : i8) : i8
  %1 = llvm.mlir.constant(11 : i8) : i8
  %2 = llvm.sub %0, %arg186 : i8
  %3 = llvm.sub %1, %2 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def fold_eq_lhs_fail_eq_nonzero_after := [llvm|
{
^0(%arg21 : i8, %arg22 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.mlir.constant(1 : i8) : i8
  %2 = llvm.shl %0, %arg21 overflow<nsw> : i8
  %3 = llvm.and %2, %arg22 : i8
  %4 = llvm.icmp "eq" %3, %1 : i8
  "llvm.return"(%4) : (i1) -> ()
}
]

def slt_or_not_max_logical_before := [llvm|
{
^0(%arg60 : i8, %arg61 : i8):
  %0 = llvm.mlir.constant(127 : i8) : i8
  %1 = llvm.mlir.constant(true) : i1
  %2 = llvm.icmp "slt" %arg60, %arg61 : i8
  %3 = llvm.icmp "ne" %arg60, %0 : i8
  %4 = "llvm.select"(%2, %1, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def positive_biggerLshr_shlnuw_after := [llvm|
{
^0(%arg27 : i32):
  %0 = llvm.mlir.constant(5 : i32) : i32
  %1 = llvm.lshr %arg27, %0 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def supp {Γ : Ctxt _} (a : Γ.Var (MLIR2DCPlus.Ty.tokenstream)) (c : Γ.Var (MLIR2DCPlus.Ty.valuestream 1)) : Expr (DCPlus) Γ .pure (.tokenstream) :=
  Expr.mk
    (op := .supp)
    (ty_eq := rfl)
    (eff_le := by admit /- proof elided -/
    )
    (args := .cons c <| .cons a <| .nil)
    (regArgs := .nil)

def shlPar (x : BitVec w) (n : Nat) : BitVec w :=
  x <<< n

def or_xor_tree_1010_after := [llvm|
{
^0(%arg15 : i32, %arg16 : i32, %arg17 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mul %arg15, %0 : i32
  %2 = llvm.mul %arg16, %0 : i32
  %3 = llvm.mul %arg17, %0 : i32
  %4 = llvm.xor %1, %2 : i32
  %5 = llvm.or %4, %3 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def test24_before := [llvm|
{
^0(%arg2 : i32):
  %0 = llvm.mlir.constant(4 : i32) : i32
  %1 = llvm.mlir.constant(2 : i32) : i32
  %2 = llvm.mlir.constant(0 : i32) : i32
  %3 = llvm.and %arg2, %0 : i32
  %4 = llvm.lshr %3, %1 : i32
  %5 = llvm.icmp "eq" %4, %2 : i32
  %6 = llvm.zext %5 : i1 to i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def negate_zext_after := [llvm|
{
^0(%arg96 : i8, %arg97 : i1):
  %0 = llvm.sext %arg97 : i1 to i8
  %1 = llvm.add %arg96, %0 : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def test_invert_demorgan_or3_after := [llvm|
{
^0(%arg13 : i32, %arg14 : i32):
  %0 = llvm.mlir.constant(178206 : i32) : i32
  %1 = llvm.mlir.constant(-196608 : i32) : i32
  %2 = llvm.mlir.constant(-1506 : i32) : i32
  %3 = llvm.mlir.constant(-917760 : i32) : i32
  %4 = llvm.mlir.constant(-716213 : i32) : i32
  %5 = llvm.mlir.constant(-1114112 : i32) : i32
  %6 = llvm.mlir.constant(-196112 : i32) : i32
  %7 = llvm.icmp "ne" %arg13, %0 : i32
  %8 = llvm.add %arg14, %1 : i32
  %9 = llvm.icmp "ult" %8, %2 : i32
  %10 = llvm.add %arg14, %3 : i32
  %11 = llvm.icmp "ult" %10, %4 : i32
  %12 = llvm.add %arg14, %5 : i32
  %13 = llvm.icmp "ult" %12, %6 : i32
  %14 = llvm.and %7, %9 : i1
  %15 = llvm.and %14, %11 : i1
  %16 = llvm.and %15, %13 : i1
  "llvm.return"(%16) : (i1) -> ()
}
]

def lshrugt_01_01_exact_before := [llvm|
{
^0(%arg220 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.lshr exact %arg220, %0 : i4
  %2 = llvm.icmp "ugt" %1, %0 : i4
  "llvm.return"(%2) : (i1) -> ()
}
]

def or_wrong_const1_after := [llvm|
{
^0(%arg1 : i16):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def masked_or_allzeroes_logical_after := [llvm|
{
^0(%arg130 : i32):
  %0 = llvm.mlir.constant(7 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.and %arg130, %0 : i32
  %3 = llvm.icmp "eq" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def PR21222_before := [llvm|
{
^0(%arg131 : i32):
  %0 = llvm.mlir.constant(-93 : i32) : i32
  %1 = llvm.mlir.constant(-2 : i32) : i32
  %2 = llvm.ashr %0, %arg131 : i32
  %3 = llvm.icmp "eq" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def ule_umax1_before := [llvm|
{
^0(%arg52 : i32, %arg53 : i32):
  %0 = llvm.icmp "ugt" %arg52, %arg53 : i32
  %1 = "llvm.select"(%0, %arg52, %arg53) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %2 = llvm.icmp "ule" %1, %arg52 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def src_is_mask_p2_m1_after := [llvm|
{
^0(%arg90 : i8, %arg91 : i8):
  %0 = llvm.mlir.constant(2 : i8) : i8
  %1 = llvm.mlir.constant(-1 : i8) : i8
  %2 = llvm.mlir.constant(123 : i8) : i8
  %3 = llvm.shl %0, %arg91 : i8
  %4 = llvm.add %3, %1 : i8
  %5 = llvm.xor %arg90, %2 : i8
  %6 = llvm.icmp "ugt" %5, %4 : i8
  "llvm.return"(%6) : (i1) -> ()
}
]

def icmp_slt_0_and_icmp_sge_neg1_i64_fail_after := [llvm|
{
^0(%arg59 : i64):
  %0 = llvm.mlir.constant(-2) : i64
  %1 = llvm.mlir.constant(62) : i64
  %2 = llvm.mlir.constant(1) : i64
  %3 = llvm.mlir.constant(0) : i64
  %4 = llvm.icmp "sgt" %arg59, %0 : i64
  %5 = llvm.lshr %arg59, %1 : i64
  %6 = llvm.and %5, %2 : i64
  %7 = "llvm.select"(%4, %6, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i64, i64) -> i64
  "llvm.return"(%7) : (i64) -> ()
}
]

def no_shift_xor_multiuse_and_before := [llvm|
{
^0(%arg130 : i32, %arg131 : i32):
  %0 = llvm.mlir.constant(4096 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(-4097 : i32) : i32
  %3 = llvm.and %arg130, %0 : i32
  %4 = llvm.icmp "ne" %1, %3 : i32
  %5 = llvm.and %arg131, %2 : i32
  %6 = "llvm.select"(%4, %arg131, %5) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %7 = llvm.mul %6, %5 : i32
  "llvm.return"(%7) : (i32) -> ()
}
]

def test5_before := [llvm|
{
^0(%arg303 : i32):
  %0 = llvm.and %arg303, %arg303 : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

def neg_test_icmp_non_equality_after := [llvm|
{
^0(%arg2 : i32):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.shl %arg2, %0 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def scalar_i16_shl_ult_const_before := [llvm|
{
^0(%arg16 : i16):
  %0 = llvm.mlir.constant(8 : i16) : i16
  %1 = llvm.mlir.constant(1024 : i16) : i16
  %2 = llvm.shl %arg16, %0 : i16
  %3 = llvm.icmp "ult" %2, %1 : i16
  "llvm.return"(%3) : (i1) -> ()
}
]

private def attrVal11Escape : AttrVal := [mlir_attr_val| $(attrVal10Float) ]

def sgt_positive_multip_rem_zero_after := [llvm|
{
^0(%arg170 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.icmp "sgt" %arg170, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def xvar := @MultiWidth.Term.var (wcard := 1) (bcard := 0) (ncard := 0) (icard := 0) (pcard := 0) (tcard := 2)
  (tctx := tctx) (v := ⟨0, by admit /- proof elided -/
  ⟩)

def add_constant_equal_with_the_top_bit_of_demandedbits_insertpt_after := [llvm|
{
^0(%arg4 : i32, %arg5 : i32):
  %0 = llvm.mlir.constant(16 : i32) : i32
  %1 = llvm.mlir.constant(24 : i32) : i32
  %2 = llvm.xor %arg4, %0 : i32
  %3 = llvm.or %2, %arg5 : i32
  %4 = llvm.and %3, %1 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

@[simp_denote]
def add_llvm_no_flags_16 := [LV| {
  ^entry (%lhs: i16, %rhs: i16):
    %1 = llvm.add %lhs, %rhs : i16
    llvm.return %1 : i16
  }]

def zero_sign_bit2_after := [llvm|
{
^0(%arg29 : i16, %arg30 : i16):
  %0 = llvm.mlir.constant(32767 : i16) : i16
  %1 = llvm.and %arg29, %0 : i16
  %2 = llvm.and %arg30, %0 : i16
  %3 = llvm.add %1, %2 overflow<nuw> : i16
  "llvm.return"(%3) : (i16) -> ()
}
]

def llvm_trunc_riscv_64_to_1_nuw : LLVMPeepholeRewriteRefine 1 [Ty.llvm (.bitvec 64)] :=
  {lhs:= trunc_llvm_64_to_1_nuw, rhs:= trunc_riscv_to_1_nuw }

instance instTransformTy : MLIR.AST.TransformTy DC 0 where
  mkTy := mkTy

def ule_and_min_after := [llvm|
{
^0(%arg206 : i8, %arg207 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.icmp "eq" %arg206, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def t3_exact_before := [llvm|
{
^0(%arg7 : i64):
  %0 = llvm.mlir.constant(63) : i64
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.ashr exact %arg7, %0 : i64
  %3 = llvm.trunc %2 : i64 to i32
  %4 = llvm.sub %1, %3 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def PostLegalizerCombiner_RISCV: List (Σ Γ,RISCVPeepholeRewrite  Γ) :=
    RISCV_identity_combines ++
    commute_int_constant_to_rhs ++
    simplify_neg ++
    mulh_to_lshr

def or_to_nxor2_before := [llvm|
{
^0(%arg91 : i32, %arg92 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.and %arg91, %arg92 : i32
  %2 = llvm.or %arg92, %arg91 : i32
  %3 = llvm.xor %2, %0 : i32
  %4 = llvm.or %1, %3 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def test0_after := [llvm|
{
^0(%arg123 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.icmp "slt" %arg123, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def logical_or_bitwise_or_icmps_comm1_after := [llvm|
{
^0(%arg169 : i8, %arg170 : i8, %arg171 : i8):
  %0 = llvm.mlir.constant(42 : i8) : i8
  %1 = llvm.mlir.constant(1 : i8) : i8
  %2 = llvm.mlir.constant(0 : i8) : i8
  %3 = llvm.mlir.constant(true) : i1
  %4 = llvm.icmp "eq" %arg170, %0 : i8
  %5 = llvm.and %arg169, %1 : i8
  %6 = llvm.shl %1, %arg171 overflow<nuw> : i8
  %7 = llvm.and %arg169, %6 : i8
  %8 = llvm.icmp "eq" %5, %2 : i8
  %9 = llvm.icmp "eq" %7, %2 : i8
  %10 = llvm.or %4, %8 : i1
  %11 = "llvm.select"(%9, %3, %10) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%11) : (i1) -> ()
}
]

@[simp]
def CollectState.wcard (state : CollectState) : Nat :=
  state.wToIx.size

def or_simplify_uge_after := [llvm|
{
^0(%arg15 : i8, %arg16 : i8, %arg17 : i1):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def test_sub_127_Y_eq_127_after := [llvm|
{
^0(%arg46 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.icmp "eq" %arg46, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def ashrslt_01_03_before := [llvm|
{
^0(%arg266 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(3 : i4) : i4
  %2 = llvm.ashr %arg266, %0 : i4
  %3 = llvm.icmp "slt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

structure Item where
 name : String
 tac : Syntax

def Expr.mkTermFsmNondep (wcard tcard bcard ncard icard pcard : Nat) (pNondep : Expr) : SolverM Expr := do
  let out ← mkAppM (``mkTermFsmNondep) #[toExpr wcard, toExpr tcard, toExpr bcard, toExpr ncard, toExpr icard, toExpr pcard, pNondep]
  debugCheck out
  return out

def sub_to_add : List (Σ Γ, LLVMPeepholeRewriteRefine 64 Γ) :=
  [
    ⟨_, sub_to_add_neg5⟩,
    ⟨_, sub_to_add_neg4⟩,
    ⟨_, sub_to_add_neg3⟩,
    ⟨_, sub_to_add_neg2⟩,
    ⟨_, sub_to_add_neg1⟩,
    ⟨_, sub_to_add_0⟩,
    ⟨_, sub_to_add_1⟩,
    ⟨_, sub_to_add_2⟩,
    ⟨_, sub_to_add_3⟩,
    ⟨_, sub_to_add_4⟩,
    ⟨_, sub_to_add_5⟩
  ]

def fold_add_sdiv_srem_before := [llvm|
{
^0(%arg9 : i32):
  %0 = llvm.mlir.constant(10 : i32) : i32
  %1 = llvm.mlir.constant(4 : i32) : i32
  %2 = llvm.sdiv %arg9, %0 : i32
  %3 = llvm.shl %2, %1 : i32
  %4 = llvm.srem %arg9, %0 : i32
  %5 = llvm.add %3, %4 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def langRel (R : BVNRel n) : Set (BitVecs n) :=
  { bvs | R bvs.bvs }

def neg_sgt_n1_before := [llvm|
{
^0(%arg24 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.mlir.constant(-1 : i8) : i8
  %2 = llvm.sub %0, %arg24 : i8
  %3 = llvm.icmp "sgt" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

inductive Ty
| tokenstream : Ty
| tokenstream2 : Ty
| valuestream (w : Nat) : Ty 
| valuestream2 (w : Nat) : Ty 
| valuetokenstream (w : Nat) : Ty 
| variadicvaluetokenstream (w : Nat) : Ty 
deriving Inhabited, DecidableEq, Repr, Lean.ToExpr

def drop_nsw_trunc_before := [llvm|
{
^0(%arg13 : i16, %arg14 : i16):
  %0 = llvm.mlir.constant(255 : i16) : i16
  %1 = llvm.and %arg13, %0 : i16
  %2 = llvm.and %1, %arg14 : i16
  %3 = llvm.trunc %2 overflow<nsw> : i16 to i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def a_false_implies_b_true2_comm_before := [llvm|
{
^0(%arg9 : i8, %arg10 : i1, %arg11 : i1):
  %0 = llvm.mlir.constant(10 : i8) : i8
  %1 = llvm.mlir.constant(20 : i8) : i8
  %2 = llvm.icmp "ugt" %arg9, %0 : i8
  %3 = llvm.icmp "ult" %arg9, %1 : i8
  %4 = "llvm.select"(%3, %arg10, %arg11) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %5 = llvm.or %4, %2 : i1
  "llvm.return"(%5) : (i1) -> ()
}
]

def masked_icmps_mask_notallzeros_bmask_mixed_negated_7_logical_before := [llvm|
{
^0(%arg55 : i32):
  %0 = llvm.mlir.constant(7 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(15 : i32) : i32
  %3 = llvm.mlir.constant(8 : i32) : i32
  %4 = llvm.mlir.constant(true) : i1
  %5 = llvm.and %arg55, %0 : i32
  %6 = llvm.icmp "eq" %5, %1 : i32
  %7 = llvm.and %arg55, %2 : i32
  %8 = llvm.icmp "ne" %7, %3 : i32
  %9 = "llvm.select"(%6, %4, %8) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%9) : (i1) -> ()
}
]

def liftMax2 (n m : Nat) : Fin m → Fin (max n m) :=
  fun k => k.castLE (by admit /- proof elided -/
  )

def lshrugt_03_07_after := [llvm|
{
^0(%arg376 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def or_or_and_pat7_before := [llvm|
{
^0(%arg50 : i8, %arg51 : i8, %arg52 : i8, %arg53 : i8):
  %0 = llvm.and %arg50, %arg51 : i8
  %1 = llvm.and %arg51, %arg53 : i8
  %2 = llvm.or %1, %arg52 : i8
  %3 = llvm.or %2, %0 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def commute_int_constant_to_rhs_and : RISCVPeepholeRewrite [Ty.riscv (.bv)] where
  lhs := [LV| {
    ^entry (%x: !riscv.reg):
      %c = li (1) : !riscv.reg
      %0 = and %c, %x : !riscv.reg
      ret %0 : !riscv.reg
  }]
  rhs := [LV| {
    ^entry (%x: !riscv.reg):
      %c = li (1) : !riscv.reg
      %0 = and %x, %c : !riscv.reg
      ret %0 : !riscv.reg
  }]

def and_ne_with_diff_one_logical_before := [llvm|
{
^0(%arg351 : i32):
  %0 = llvm.mlir.constant(40 : i32) : i32
  %1 = llvm.mlir.constant(39 : i32) : i32
  %2 = llvm.mlir.constant(false) : i1
  %3 = llvm.icmp "ne" %arg351, %0 : i32
  %4 = llvm.icmp "ne" %arg351, %1 : i32
  %5 = "llvm.select"(%3, %4, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%5) : (i1) -> ()
}
]

def or_and_not_not_commute3_after := [llvm|
{
^0(%arg416 : i32, %arg417 : i32, %arg418 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.and %arg418, %arg417 : i32
  %2 = llvm.or %1, %arg416 : i32
  %3 = llvm.xor %2, %0 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def shl_sub_i64_before := [llvm|
{
^0(%arg15 : i64):
  %0 = llvm.mlir.constant(63) : i64
  %1 = llvm.mlir.constant(1) : i64
  %2 = llvm.sub %0, %arg15 : i64
  %3 = llvm.shl %1, %2 : i64
  "llvm.return"(%3) : (i64) -> ()
}
]

def test_before := [llvm|
{
^0(%arg1 : i32):
  %0 = llvm.mlir.constant(17 : i32) : i32
  %1 = llvm.ashr %arg1, %0 : i32
  %2 = llvm.ashr %1, %0 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def ne_nuw_rem_zero_after := [llvm|
{
^0(%arg153 : i8):
  %0 = llvm.mlir.constant(26 : i8) : i8
  %1 = llvm.icmp "ne" %arg153, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def low_bitmask_ugt_before := [llvm|
{
^0(%arg9 : i8):
  %0 = llvm.mlir.constant(127 : i8) : i8
  %1 = llvm.mul %arg9, %arg9 : i8
  %2 = llvm.add %1, %0 : i8
  %3 = llvm.and %2, %0 : i8
  %4 = llvm.icmp "ugt" %1, %3 : i8
  "llvm.return"(%4) : (i1) -> ()
}
]

def PR2539_B_before := [llvm|
{
^0(%arg0 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.icmp "slt" %arg0, %0 : i1
  "llvm.return"(%1) : (i1) -> ()
}
]

def or_not_and_commute1_before := [llvm|
{
^0(%arg534 : i32, %arg535 : i32, %arg536 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.sdiv %0, %arg535 : i32
  %3 = llvm.or %arg534, %2 : i32
  %4 = llvm.xor %3, %1 : i32
  %5 = llvm.and %4, %arg536 : i32
  %6 = llvm.or %arg534, %arg536 : i32
  %7 = llvm.xor %6, %1 : i32
  %8 = llvm.and %2, %7 : i32
  %9 = llvm.or %5, %8 : i32
  "llvm.return"(%9) : (i32) -> ()
}
]

def WidthExpr.Env.empty : WidthExpr.Env 0 :=
  fun v => v.elim0

def xor_of_and_with_same_reg : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64), Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%x: i64, %y: i64):
      %0 = llvm.and %x, %y : i64
      %1 = llvm.xor %0, %y : i64
      llvm.return %1 : i64
  }]
  rhs := [LV| {
    ^entry (%x: i64, %y: i64):
      %0 = llvm.not %x : i64
      %1 = llvm.and %0, %y : i64
      llvm.return %1 : i64
  }]

def scalar_i32_lshr_and_negC_slt_after := [llvm|
{
^0(%arg2 : i32, %arg3 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.lshr %arg2, %arg3 : i32
  %2 = llvm.icmp "slt" %1, %0 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def test6_after := [llvm|
{
^0(%arg1 : i77):
  "llvm.return"(%arg1) : (i77) -> ()
}
]

def elabDefSignatureFor (dialect : Term) (alts : TSyntax ``matchAltsSig) : CommandElabM Unit := do
  let msg := (return m!"{exceptEmoji ·} Defining operation signature for {dialect} dialect")
  withTraceNode `LeanMLIR.Elab msg (collapsed := false) <| do
    let alts := getMatchAlts alts
    let alts ← do
      alts.mapM fun view => do
        trace[LeanMLIR.Elab] m!"Parsing match alternative with\n\
          \tpatterns: {view.patterns}\n\
          \tsignature: {view.rhs}"
        let rhs ← parseSignature view.rhs
        return { view with rhs }

    |

def sub_to_and_or_commuted_before := [llvm|
{
^0(%arg6 : i32, %arg7 : i32):
  %0 = llvm.or %arg7, %arg6 : i32
  %1 = llvm.xor %arg6, %arg7 : i32
  %2 = llvm.sub %1, %0 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def ashrslt_01_11_exact_after := [llvm|
{
^0(%arg42 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

abbrev TypedSSAVal := SSAVal × MLIRType φ

def t7_before := [llvm|
{
^0(%arg6 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.sub %0, %arg6 overflow<nsw> : i8
  %2 = llvm.icmp "ule" %1, %arg6 : i8
  "llvm.return"(%2) : (i1) -> ()
}
]

List.foldlRecOn in Init.Data.List.Lemmas

def shl_add_lshr_before := [llvm|
{
^0(%arg154 : i32, %arg155 : i32, %arg156 : i32):
  %0 = llvm.shl %arg154, %arg155 overflow<nuw> : i32
  %1 = llvm.add %0, %arg156 overflow<nuw> : i32
  %2 = llvm.lshr %1, %arg155 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def udiv_i8_before := [llvm|
{
^0(%arg37 : i8, %arg38 : i8):
  %0 = llvm.zext %arg37 : i8 to i32
  %1 = llvm.zext %arg38 : i8 to i32
  %2 = llvm.udiv %0, %1 : i32
  %3 = llvm.trunc %2 : i32 to i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def Expr.ctxt : Expr d Γ eff [t] → Ctxt d.Ty := fun _ => Γ

def sgt_and_min_commute_after := [llvm|
{
^0(%arg348 : i8, %arg349 : i8):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def canonicalize_logic_first_or0_nswnuw_after := [llvm|
{
^0(%arg38 : i32):
  %0 = llvm.mlir.constant(15 : i32) : i32
  %1 = llvm.mlir.constant(112 : i32) : i32
  %2 = llvm.or %arg38, %0 : i32
  %3 = llvm.add %2, %1 overflow<nsw,nuw> : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def lshrult_03_06_after := [llvm|
{
^0(%arg329 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def fold_sext_to_and_wrong5_after := [llvm|
{
^0(%arg5 : i8):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def not_or_or_and_not_and_and_commute3_after := [llvm|
{
^0(%arg187 : i32, %arg188 : i32, %arg189 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.sdiv %0, %arg188 : i32
  %3 = llvm.xor %arg187, %1 : i32
  %4 = llvm.xor %arg189, %2 : i32
  %5 = llvm.or %4, %3 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def set_bits_before := [llvm|
{
^0(%arg26 : i8, %arg27 : i1):
  %0 = llvm.mlir.constant(-6 : i8) : i8
  %1 = llvm.mlir.constant(5 : i8) : i8
  %2 = llvm.and %arg26, %0 : i8
  %3 = llvm.or %arg26, %1 : i8
  %4 = "llvm.select"(%arg27, %3, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%4) : (i8) -> ()
}
]

def trunc_lshr_exact_mask_before := [llvm|
{
^0(%arg9 : i8):
  %0 = llvm.mlir.constant(2 : i8) : i8
  %1 = llvm.mlir.constant(15 : i6) : i6
  %2 = llvm.lshr %arg9, %0 : i8
  %3 = llvm.trunc %2 : i8 to i6
  %4 = llvm.and %3, %1 : i6
  "llvm.return"(%4) : (i6) -> ()
}
]

def addsub_combine_constants_after := [llvm|
{
^0(%arg14 : i7, %arg15 : i7):
  %0 = llvm.mlir.constant(52 : i7) : i7
  %1 = llvm.sub %arg14, %arg15 : i7
  %2 = llvm.add %1, %0 : i7
  "llvm.return"(%2) : (i7) -> ()
}
]

inductive MedusaSynthGeneralizeConfig.Output
  | thmStmt
  | sexpr

def ashrsgt_01_03_exact_before := [llvm|
{
^0(%arg98 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(3 : i4) : i4
  %2 = llvm.ashr exact %arg98, %0 : i4
  %3 = llvm.icmp "sgt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def add_nsw_poison_constant_fold_after := [llvm|
{
^0(%arg2 : i1, %arg3 : i8):
  %0 = llvm.mlir.constant(64 : i8) : i8
  %1 = llvm.mlir.constant(-127 : i8) : i8
  %2 = llvm.add %arg3, %0 overflow<nsw> : i8
  %3 = "llvm.select"(%arg2, %2, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%3) : (i8) -> ()
}
]

Nat.mod in Init.Prelude

def trunc_lshr_zext_before := [llvm|
{
^0(%arg12 : i8):
  %0 = llvm.mlir.constant(6 : i32) : i32
  %1 = llvm.zext %arg12 : i8 to i32
  %2 = llvm.lshr %1, %0 : i32
  %3 = llvm.trunc %2 : i32 to i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def Lets.outContext (lets : UnTyped.Lets Op VarName) (Γ_in : Context Ty) : Context Ty :=
  lets.inner.foldl (fun Γ e => Γ.push e.varName (signature e.op).returnType) Γ_in

def n2_before := [llvm|
{
^0(%arg19 : i1, %arg20 : i8, %arg21 : i8, %arg22 : i8, %arg23 : i8):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.icmp "eq" %arg20, %arg21 : i8
  %2 = llvm.xor %arg19, %0 : i1
  %3 = llvm.and %2, %1 : i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def RegionList (tys : List (RegionType Ty)) : Type :=
  { regions : List (UnTyped.Region Op VarName) // RegionList.WellTyped regions tys}

@[simp]
def CNFA.inter_language (m₁ m₂ : CNFA n) :
    m₁.recognizes L₁ →
    m₂.recognizes L₂ →
    (m₁.inter m₂).recognizes (L₁ ∩ L₂) :=

def llvm_const_lower_riscv_li40 : LLVMPeepholeRewriteRefine 64 [] :=
  {lhs := constLLVM40, rhs:= liRiscv40,
   correct := by admit /- proof elided -/

def lshrult_01_06_before := [llvm|
{
^0(%arg361 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(6 : i4) : i4
  %2 = llvm.lshr %arg361, %0 : i4
  %3 = llvm.icmp "ult" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def PR2330_before := [llvm|
{
^0(%arg0 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.shl %0, %arg0 : i32
  %3 = llvm.and %2, %0 : i32
  %4 = llvm.icmp "eq" %3, %1 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def RawCNFA.reverse (m : RawCNFA A) : RawCNFA A :=
  let m' := { stateMax := m.stateMax, trans := Std.HashMap.emptyWithCapacity m.trans.size, initials := m.finals, finals := m.initials}
  m.trans.fold (init := m') processState
where
  processState := fun m' (s, a) ss' =>
    ss'.fold (init := m') fun m' s' => m'.addTrans a s' s

def p0_after := [llvm|
{
^0(%arg17 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.icmp "ugt" %arg17, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def llvm_const_lower_riscv_li44 : LLVMPeepholeRewriteRefine 64 [] :=
  {lhs := constLLVM44, rhs:= liRiscv44,
   correct := by admit /- proof elided -/

def or_not_xor_common_op_commute2_before := [llvm|
{
^0(%arg101 : i8, %arg102 : i8, %arg103 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.mlir.constant(-1 : i8) : i8
  %2 = llvm.sub %0, %arg103 : i8
  %3 = llvm.xor %arg101, %1 : i8
  %4 = llvm.xor %arg101, %arg102 : i8
  %5 = llvm.or %2, %3 : i8
  %6 = llvm.or %4, %5 : i8
  "llvm.return"(%6) : (i8) -> ()
}
]

def ashrslt_02_03_exact_before := [llvm|
{
^0(%arg34 : i4):
  %0 = llvm.mlir.constant(2 : i4) : i4
  %1 = llvm.mlir.constant(3 : i4) : i4
  %2 = llvm.ashr exact %arg34, %0 : i4
  %3 = llvm.icmp "slt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def llvm_const_lower_riscv_li34 : LLVMPeepholeRewriteRefine 64 [] :=
  {lhs := constLLVM34, rhs:= liRiscv34,
   correct := by admit /- proof elided -/

def eqToZero (expr: FpExpr w) : FpPredicate :=
  FpPredicate.bin expr FpBinaryPredKind.eq (zero w)

def icmp_ne_zext_ne_one_after := [llvm|
{
^0(%arg37 : i32):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def lshrult_01_09_after := [llvm|
{
^0(%arg358 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def NFA'.autWidth (wp : WidthPredicate) (n : Nat) : NFA' 0 := ⟨_, NFA.autWidth wp n⟩

@[simp_denote] def axpy {Γ : Ctxt _} (a : Var Γ .int) (x : Var Γ .nat) (b: Var Γ .int) :
    Expr ScfArith Γ .pure .int :=
  Expr.mk
    (op := .coe <| .axpy)
    (ty_eq := rfl)
    (eff_le := by admit /- proof elided -/
    )
    (args := .cons a <| .cons x <| .cons b .nil)
    (regArgs := .nil)

@[simp_llvm]
def sshr (a : BitVec n) (s : Nat) := BitVec.sshiftRight a s

def sext_multiuse_before := [llvm|
{
^0(%arg5 : i4):
  %0 = llvm.mlir.constant(-8 : i4) : i4
  %1 = llvm.mlir.constant(-8 : i7) : i7
  %2 = llvm.xor %arg5, %0 : i4
  %3 = llvm.zext %2 : i4 to i7
  %4 = llvm.add %3, %1 overflow<nsw> : i7
  %5 = llvm.sdiv %3, %4 : i7
  %6 = llvm.trunc %5 : i7 to i4
  %7 = llvm.sdiv %6, %2 : i4
  "llvm.return"(%7) : (i4) -> ()
}
]

protected instance Expr.decidableEq [DecidableEq d.Op] [DecidableEq d.Ty] :
    {Γ : Ctxt d.Ty} → {ty : List d.Ty} → DecidableEq (Expr d Γ eff ty)
  | Γ, _, .mk op₁ rfl eff_le₁ arg₁ regArgs₁, .mk op₂ eq eff_le₂ arg₂ regArgs₂ =>
    if ho : op₁ = op₂ then by
      subst ho
      letI := HVector.decidableEq arg₁ arg₂
      letI := HVector.decidableEqReg regArgs₁ regArgs₂
      exact decidable_of_iff (arg₁ = arg₂ ∧ regArgs₁ = regArgs₂) (by admit /- proof elided -/
      )
    else isFalse (by admit /- proof elided -/
    )

def ashrsgt_01_02_exact_after := [llvm|
{
^0(%arg99 : i4):
  %0 = llvm.mlir.constant(4 : i4) : i4
  %1 = llvm.icmp "sgt" %arg99, %0 : i4
  "llvm.return"(%1) : (i1) -> ()
}
]

instance : AndOp (Circuit α) := ⟨Circuit.simplifyAnd⟩

def lshrult_02_01_exact_after := [llvm|
{
^0(%arg132 : i4):
  %0 = llvm.mlir.constant(0 : i4) : i4
  %1 = llvm.icmp "eq" %arg132, %0 : i4
  "llvm.return"(%1) : (i1) -> ()
}
]

def simplify_or_common_op_commute0_before := [llvm|
{
^0(%arg45 : i4, %arg46 : i4, %arg47 : i4):
  %0 = llvm.mlir.constant(-1 : i4) : i4
  %1 = llvm.and %arg45, %arg46 : i4
  %2 = llvm.and %1, %arg47 : i4
  %3 = llvm.xor %2, %0 : i4
  %4 = llvm.or %3, %arg45 : i4
  "llvm.return"(%4) : (i4) -> ()
}
]

def alive_152_tgt  (w : Nat)  :=
[llvm( w )| {
^bb0(%x : _):
  %v1 = llvm.mlir.constant 0
  %v2 = llvm.sub %v1, %x
  llvm.return %v2
}]

def canonicalize_logic_first_or0_nswnuw_before := [llvm|
{
^0(%arg38 : i32):
  %0 = llvm.mlir.constant(112 : i32) : i32
  %1 = llvm.mlir.constant(15 : i32) : i32
  %2 = llvm.add %arg38, %0 overflow<nsw,nuw> : i32
  %3 = llvm.or %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def sext_false_val_must_be_zero_after := [llvm|
{
^0(%arg3 : i1):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = "llvm.select"(%arg3, %0, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def masked_icmps_mask_notallzeros_bmask_mixed_negated_6_logical_before := [llvm|
{
^0(%arg57 : i32):
  %0 = llvm.mlir.constant(12 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(15 : i32) : i32
  %3 = llvm.mlir.constant(8 : i32) : i32
  %4 = llvm.mlir.constant(true) : i1
  %5 = llvm.and %arg57, %0 : i32
  %6 = llvm.icmp "eq" %5, %1 : i32
  %7 = llvm.and %arg57, %2 : i32
  %8 = llvm.icmp "ne" %7, %3 : i32
  %9 = "llvm.select"(%6, %4, %8) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%9) : (i1) -> ()
}
]

Lean.withImportModules in Lean.Environment

def scalar_i16_signbit_lshr_and_eq_before := [llvm|
{
^0(%arg33 : i16, %arg34 : i16):
  %0 = llvm.mlir.constant(-32768 : i16) : i16
  %1 = llvm.mlir.constant(0 : i16) : i16
  %2 = llvm.lshr %0, %arg34 : i16
  %3 = llvm.and %2, %arg33 : i16
  %4 = llvm.icmp "eq" %3, %1 : i16
  "llvm.return"(%4) : (i1) -> ()
}
]

def positive_biggerashr_shlnsw_ashrexact_after := [llvm|
{
^0(%arg35 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.ashr exact %arg35, %0 : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def test_sub_rhs_add_const_RHS := [mod_arith q, hq| {
  ^bb0(%x : !R):
    %res0 = mod_arith.constant 20 : !R
    %res1 = mod_arith.add %x, %res0 : !R
    return %res1 : !R
}]

def ne_smax4_before := [llvm|
{
^0(%arg41 : i32, %arg42 : i32):
  %0 = llvm.mlir.constant(3 : i32) : i32
  %1 = llvm.add %arg41, %0 : i32
  %2 = llvm.icmp "sgt" %arg42, %1 : i32
  %3 = "llvm.select"(%2, %arg42, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %4 = llvm.icmp "ne" %1, %3 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def and_or2_wrong_operand_after := [llvm|
{
^0(%arg172 : i1, %arg173 : i1, %arg174 : i1, %arg175 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.xor %arg174, %0 : i1
  %2 = llvm.and %arg173, %1 : i1
  %3 = "llvm.select"(%2, %arg172, %arg175) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%3) : (i1) -> ()
}
]

List.insert in Init.Data.List.Basic

def t0_basic_before := [llvm|
{
^0(%arg24 : i8, %arg25 : i8):
  %0 = llvm.sub %arg24, %arg25 : i8
  %1 = llvm.icmp "ugt" %0, %arg24 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def lshrult_03_04_before := [llvm|
{
^0(%arg331 : i4):
  %0 = llvm.mlir.constant(3 : i4) : i4
  %1 = llvm.mlir.constant(4 : i4) : i4
  %2 = llvm.lshr %arg331, %0 : i4
  %3 = llvm.icmp "ult" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def ashrsgt_01_00_exact_after := [llvm|
{
^0(%arg101 : i4):
  %0 = llvm.mlir.constant(0 : i4) : i4
  %1 = llvm.icmp "sgt" %arg101, %0 : i4
  "llvm.return"(%1) : (i1) -> ()
}
]

def sext_shl_trunc_smaller_after := [llvm|
{
^0(%arg11 : i16, %arg12 : i32):
  %0 = llvm.zext %arg11 : i16 to i32
  %1 = llvm.shl %0, %arg12 : i32
  %2 = llvm.trunc %1 : i32 to i5
  "llvm.return"(%2) : (i5) -> ()
}
]

def ashrsgt_02_12_before := [llvm|
{
^0(%arg289 : i4):
  %0 = llvm.mlir.constant(2 : i4) : i4
  %1 = llvm.mlir.constant(-4 : i4) : i4
  %2 = llvm.ashr %arg289, %0 : i4
  %3 = llvm.icmp "sgt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def sle_swap_or_not_min_commute_after := [llvm|
{
^0(%arg276 : i8, %arg277 : i8):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def Vector.ofList {α : Type u} (l : List α) : List.Vector α l.length :=
⟨l, rfl⟩

def sge_or_not_max_logical_after := [llvm|
{
^0(%arg318 : i8, %arg319 : i8):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def icmp_sgt4_before := [llvm|
{
^0(%arg21 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.mlir.constant(-2 : i8) : i8
  %2 = llvm.shl %arg21, %0 overflow<nsw> : i8
  %3 = llvm.icmp "sgt" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def test_and2_before := [llvm|
{
^0(%arg48 : i32, %arg49 : i32):
  %0 = llvm.mlir.constant(2147483647 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.and %arg49, %0 : i32
  %3 = llvm.icmp "sgt" %arg48, %1 : i32
  %4 = llvm.icmp "sle" %arg48, %2 : i32
  %5 = llvm.and %3, %4 : i1
  "llvm.return"(%5) : (i1) -> ()
}
]

def test3_after := [llvm|
{
^0(%arg119 : i32):
  %0 = llvm.mlir.constant(32 : i32) : i32
  %1 = llvm.mlir.constant(8 : i32) : i32
  %2 = llvm.and %arg119, %0 : i32
  %3 = llvm.or disjoint %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def select_icmp_ne_0_and_1073741824_and_not_8_before := [llvm|
{
^0(%arg191 : i32, %arg192 : i8):
  %0 = llvm.mlir.constant(1073741824 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(-9 : i8) : i8
  %3 = llvm.and %arg191, %0 : i32
  %4 = llvm.icmp "ne" %1, %3 : i32
  %5 = llvm.and %arg192, %2 : i8
  %6 = "llvm.select"(%4, %arg192, %5) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%6) : (i8) -> ()
}
]

def or_and_not_not_commute7_after := [llvm|
{
^0(%arg404 : i32, %arg405 : i32, %arg406 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.and %arg406, %arg405 : i32
  %2 = llvm.or %1, %arg404 : i32
  %3 = llvm.xor %2, %0 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def positive_samevar_after := [llvm|
{
^0(%arg62 : i8, %arg63 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.shl %0, %arg63 overflow<nsw> : i8
  %2 = llvm.and %1, %arg62 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def test_invert_demorgan_logical_and_after := [llvm|
{
^0(%arg3 : i64, %arg4 : i64):
  %0 = llvm.mlir.constant(27) : i64
  %1 = llvm.mlir.constant(0) : i64
  %2 = llvm.mlir.constant(true) : i1
  %3 = llvm.icmp "ne" %arg3, %0 : i64
  %4 = llvm.icmp "ne" %arg4, %1 : i64
  %5 = "llvm.select"(%3, %2, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %6 = llvm.icmp "ne" %arg3, %1 : i64
  %7 = llvm.and %6, %5 : i1
  "llvm.return"(%7) : (i1) -> ()
}
]

def sel_zext_constants_after := [llvm|
{
^0(%arg96 : i1):
  %0 = llvm.mlir.constant(255 : i16) : i16
  %1 = llvm.mlir.constant(42 : i16) : i16
  %2 = "llvm.select"(%arg96, %0, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i16, i16) -> i16
  "llvm.return"(%2) : (i16) -> ()
}
]

def test2_before := [llvm|
{
^0(%arg196 : i8):
  %0 = llvm.zext %arg196 : i8 to i16
  %1 = llvm.zext %0 : i16 to i32
  %2 = llvm.zext %1 : i32 to i64
  "llvm.return"(%2) : (i64) -> ()
}
]

def test21_after := [llvm|
{
^0(%arg146 : i32, %arg147 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg146, %arg147 : i32
  %2 = llvm.xor %1, %0 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

abbrev BitVecs.empty : BitVecs n := ⟨0, List.Vector.replicate n .nil⟩

def slt_and_not_max_logical_after := [llvm|
{
^0(%arg124 : i8, %arg125 : i8):
  %0 = llvm.icmp "slt" %arg124, %arg125 : i8
  "llvm.return"(%0) : (i1) -> ()
}
]

Nat.div2Induction in Init.Data.Nat.Bitwise.Lemmas

def p_before := [llvm|
{
^0(%arg60 : i32, %arg61 : i32, %arg62 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.and %arg60, %arg62 : i32
  %2 = llvm.xor %arg62, %0 : i32
  %3 = llvm.and %2, %arg61 : i32
  %4 = llvm.xor %1, %3 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

unsafe def elabIntoCore {α : Type} (expectedType : Expr) (stx : Lean.Syntax) : CoreM α :=
  elabIntoMeta (α := α) expectedType stx |>.run'

def foo2_after := [llvm|
{
^0(%arg46 : i32, %arg47 : i32):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.icmp "sgt" %arg46, %0 : i32
  %3 = llvm.sub %1, %arg47 : i32
  %4 = "llvm.select"(%2, %arg47, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %5 = llvm.add %arg46, %4 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def scalar_i64_signbit_lshr_and_eq_before := [llvm|
{
^0(%arg29 : i64, %arg30 : i64):
  %0 = llvm.mlir.constant(-9223372036854775808) : i64
  %1 = llvm.mlir.constant(0) : i64
  %2 = llvm.lshr %0, %arg30 : i64
  %3 = llvm.and %2, %arg29 : i64
  %4 = llvm.icmp "eq" %3, %1 : i64
  "llvm.return"(%4) : (i1) -> ()
}
]

def negative_trunc_not_arg_logical_before := [llvm|
{
^0(%arg20 : i32, %arg21 : i32):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.mlir.constant(128 : i32) : i32
  %2 = llvm.mlir.constant(256 : i32) : i32
  %3 = llvm.mlir.constant(false) : i1
  %4 = llvm.trunc %arg20 : i32 to i8
  %5 = llvm.icmp "sgt" %4, %0 : i8
  %6 = llvm.add %arg21, %1 : i32
  %7 = llvm.icmp "ult" %6, %2 : i32
  %8 = "llvm.select"(%5, %7, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%8) : (i1) -> ()
}
]

def test1_trunc_after := [llvm|
{
^0(%arg53 : i32):
  %0 = llvm.mlir.constant(24 : i32) : i32
  %1 = llvm.mlir.constant(8 : i32) : i32
  %2 = llvm.mlir.constant(65280 : i32) : i32
  %3 = llvm.lshr %arg53, %0 : i32
  %4 = llvm.lshr %arg53, %1 : i32
  %5 = llvm.and %4, %2 : i32
  %6 = llvm.or disjoint %3, %5 : i32
  %7 = llvm.trunc %6 overflow<nuw> : i32 to i16
  "llvm.return"(%7) : (i16) -> ()
}
]

def test19_before := [llvm|
{
^0(%arg192 : i32, %arg193 : i32):
  %0 = llvm.xor %arg192, %arg193 : i32
  %1 = llvm.xor %0, %arg192 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def masked_icmps_mask_notallzeros_bmask_mixed_3b_logical_before := [llvm|
{
^0(%arg85 : i32):
  %0 = llvm.mlir.constant(15 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(3 : i32) : i32
  %3 = llvm.mlir.constant(false) : i1
  %4 = llvm.and %arg85, %0 : i32
  %5 = llvm.icmp "ne" %4, %1 : i32
  %6 = llvm.and %arg85, %2 : i32
  %7 = llvm.icmp "eq" %6, %1 : i32
  %8 = "llvm.select"(%5, %7, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%8) : (i1) -> ()
}
]

def test24_logical_after := [llvm|
{
^0(%arg272 : i32):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.icmp "sgt" %arg272, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def zext_or_masked_bit_test_before := [llvm|
{
^0(%arg54 : i32, %arg55 : i32, %arg56 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.shl %0, %arg55 : i32
  %3 = llvm.and %2, %arg54 : i32
  %4 = llvm.icmp "ne" %3, %1 : i32
  %5 = llvm.icmp "eq" %arg56, %arg55 : i32
  %6 = llvm.or %4, %5 : i1
  %7 = llvm.zext %6 : i1 to i32
  "llvm.return"(%7) : (i32) -> ()
}
]

AndOp in Init.Prelude

def test_after := [llvm|
{
^0(%arg0 : i26):
  "llvm.return"(%arg0) : (i26) -> ()
}
]

def llvm_add_lower_riscv_nuw_flag_32 : LLVMPeepholeRewriteRefine 32 [Ty.llvm (.bitvec 32), Ty.llvm (.bitvec 32)]
where
  lhs:= add_llvm_nuw_flags_32
  rhs:= add_riscv_32

Lean.Parser.Parser in Lean.Parser.Types

def or_not_and_commute5_after := [llvm|
{
^0(%arg522 : i32, %arg523 : i32, %arg524 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.sdiv %0, %arg522 : i32
  %3 = llvm.sdiv %0, %arg524 : i32
  %4 = llvm.xor %arg523, %3 : i32
  %5 = llvm.xor %2, %1 : i32
  %6 = llvm.and %4, %5 : i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def positive_biggerlshr_shlnuwnsw_lshrexact_after := [llvm|
{
^0(%arg25 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.lshr exact %arg25, %0 : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

Nat.min in Init.Data.Nat.Basic

def pb_before := [llvm|
{
^0(%arg13 : i65):
  %0 = llvm.mlir.constant(1 : i65) : i65
  %1 = llvm.shl %arg13, %0 : i65
  %2 = llvm.ashr exact %1, %0 : i65
  %3 = llvm.icmp "ne" %arg13, %2 : i65
  "llvm.return"(%3) : (i1) -> ()
}
]

def match_selects : List (Σ Γ, LLVMPeepholeRewriteRefine 64  Γ) :=
  [⟨_, select_1_0⟩,
  ⟨_, select_neg1_0⟩,
  ⟨_, select_0_1⟩,
  ⟨_, select_0_neg1⟩,
  ⟨_, select_cond_f⟩,
  ⟨_, select_1_f⟩,
  ⟨_, select_t_cond⟩,
  ⟨_, select_t_0⟩,
  ⟨_, select_t_1⟩,
  ⟨_, select_0_f⟩]

def llvm_mul_lower_riscv_nsw_flag_32 : LLVMPeepholeRewriteRefine 32 [Ty.llvm (.bitvec 32), Ty.llvm (.bitvec 32)] where
  lhs := mul_llvm_nsw_32
  rhs := mul_riscv_32

inductive ExOp :  Type
  | add : ExOp
  | beq : ExOp
  | cst : ℕ → ExOp
  deriving DecidableEq

def trunc_equality_nsw_zext_after := [llvm|
{
^0(%arg16 : i32, %arg17 : i8):
  %0 = llvm.zext %arg17 : i8 to i32
  %1 = llvm.icmp "ne" %arg16, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def lshrugt_01_12_exact_before := [llvm|
{
^0(%arg209 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(-4 : i4) : i4
  %2 = llvm.lshr exact %arg209, %0 : i4
  %3 = llvm.icmp "ugt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def n10_wrong_pred2_before := [llvm|
{
^0(%arg10 : i8, %arg11 : i8):
  %0 = llvm.add %arg10, %arg11 : i8
  %1 = llvm.icmp "eq" %0, %arg11 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def udiv_exact_eq_1_before := [llvm|
{
^0(%arg10 : i8, %arg11 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.udiv exact %arg10, %arg11 : i8
  %2 = llvm.icmp "ne" %1, %0 : i8
  "llvm.return"(%2) : (i1) -> ()
}
]

def neg_not_signbit3_before := [llvm|
{
^0(%arg3 : i8):
  %0 = llvm.mlir.constant(7 : i8) : i8
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.ashr %arg3, %0 : i8
  %3 = llvm.zext %2 : i8 to i32
  %4 = llvm.sub %1, %3 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def ashrsgt_01_08_exact_after := [llvm|
{
^0(%arg93 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def scalar_i32_signbit_lshr_and_eq_nonzero_before := [llvm|
{
^0(%arg0 : i32, %arg1 : i32):
  %0 = llvm.mlir.constant(-2147483648 : i32) : i32
  %1 = llvm.mlir.constant(1 : i32) : i32
  %2 = llvm.lshr %0, %arg1 : i32
  %3 = llvm.and %2, %arg0 : i32
  %4 = llvm.icmp "eq" %3, %1 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def or_xor_common_op_commute7_before := [llvm|
{
^0(%arg114 : i8, %arg115 : i8, %arg116 : i8):
  %0 = llvm.or %arg115, %arg114 : i8
  %1 = llvm.xor %arg116, %arg114 : i8
  %2 = llvm.or %1, %0 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def sgt_negative_multip_rem_zero_before := [llvm|
{
^0(%arg169 : i8):
  %0 = llvm.mlir.constant(-7 : i8) : i8
  %1 = llvm.mlir.constant(21 : i8) : i8
  %2 = llvm.mul %arg169, %0 overflow<nsw> : i8
  %3 = llvm.icmp "sgt" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

instance : ToFormat (Width φ) := ⟨repr⟩

def t2_symmetry_after := [llvm|
{
^0(%arg25 : i8, %arg26 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.xor %arg25, %0 : i8
  %2 = llvm.icmp "ugt" %arg26, %1 : i8
  "llvm.return"(%2) : (i1) -> ()
}
]

private def mkExt (name attr : Name) (descr : String) : IO NameExt := do
  let addEntryFn | m, (n3, n4) => m.insert n3 n4
  let ext ← registerSimplePersistentEnvExtension {
    name, addEntryFn
    addImportedFn := mkStateFromImportedEntries addEntryFn {}
  }
  registerBuiltinAttribute {
    name := attr
    descr
    add := fun declName stx attrKind => do
      let s := ext.getState (← getEnv)
      let ns ← stx[1].getArgs.mapM fun stx => do
        let n := stx.getId
        if s.contains n then throwErrorAt stx "test {n} already declared"
        pure n
      modifyEnv $ ns.foldl fun env n =>
        ext.addEntry env (n, declName)
  }
  pure ext

def udiv_mul_shl_nuw_exact_commute1_after := [llvm|
{
^0(%arg163 : i5, %arg164 : i5, %arg165 : i5):
  %0 = llvm.lshr exact %arg164, %arg165 : i5
  "llvm.return"(%0) : (i5) -> ()
}
]

instance [ToString α] [ToString β] [Hashable α] [BEq α] : ToString (Std.HashMap α β) where
  toString map :=
    "{" ++ String.intercalate ", " (map.toList.map (λ (k, v) => toString k ++ " → " ++ toString v)) ++ "}"

structure Signature (Ty : Type) where
  arguments : List Ty
  regions : List (RegionType Ty)
  returnType : Ty

def lshrugt_01_13_exact_after := [llvm|
{
^0(%arg208 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def positive_sameconst_shlnuw_before := [llvm|
{
^0(%arg29 : i32):
  %0 = llvm.mlir.constant(5 : i32) : i32
  %1 = llvm.shl %arg29, %0 overflow<nuw> : i32
  %2 = llvm.lshr %1, %0 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def scalar_i32_shl_and_negC_eq_X_is_constant2_after := [llvm|
{
^0(%arg4 : i32):
  %0 = llvm.mlir.constant(3 : i32) : i32
  %1 = llvm.icmp "ult" %arg4, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def scalar_i32_signbit_shl_and_eq_nonzero_after := [llvm|
{
^0(%arg0 : i32, %arg1 : i32):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def trunc_unsigned_both_after := [llvm|
{
^0(%arg56 : i16, %arg57 : i16):
  %0 = llvm.icmp "ult" %arg56, %arg57 : i16
  "llvm.return"(%0) : (i1) -> ()
}
]

def ashrsgt_03_09_exact_after := [llvm|
{
^0(%arg60 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def trunc_sandwich_after := [llvm|
{
^0(%arg70 : i32):
  %0 = llvm.mlir.constant(30 : i32) : i32
  %1 = llvm.lshr %arg70, %0 : i32
  %2 = llvm.trunc %1 overflow<nsw,nuw> : i32 to i12
  "llvm.return"(%2) : (i12) -> ()
}
]

def sgt_negative_multip_rem_zero_before := [llvm|
{
^0(%arg169 : i8):
  %0 = llvm.mlir.constant(-7 : i8) : i8
  %1 = llvm.mlir.constant(21 : i8) : i8
  %2 = llvm.mul %arg169, %0 overflow<nsw> : i8
  %3 = llvm.icmp "sgt" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def add_const_const_sub_after := [llvm|
{
^0(%arg61 : i32):
  %0 = llvm.mlir.constant(-6 : i32) : i32
  %1 = llvm.sub %0, %arg61 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def substitute_constant_and_eq_ugt_swap_logical_after := [llvm|
{
^0(%arg312 : i8, %arg313 : i8):
  %0 = llvm.mlir.constant(42 : i8) : i8
  %1 = llvm.icmp "eq" %arg312, %0 : i8
  %2 = llvm.icmp "ugt" %arg313, %0 : i8
  %3 = llvm.and %1, %2 : i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def bitwise_and_logical_and_masked_icmp_allones_after := [llvm|
{
^0(%arg139 : i1, %arg140 : i32):
  %0 = llvm.mlir.constant(15 : i32) : i32
  %1 = llvm.mlir.constant(false) : i1
  %2 = llvm.and %arg140, %0 : i32
  %3 = llvm.icmp "eq" %2, %0 : i32
  %4 = "llvm.select"(%3, %arg139, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def llvm_sub_nuw_lower_riscv_64: LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64), Ty.llvm (.bitvec 64)] where
  lhs := llvm_sub_nuw_64
  rhs := sub_riscv_64

def not_true_not_before := [llvm|
{
^0(%arg234 : i1, %arg235 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.xor %arg234, %0 : i1
  %2 = llvm.xor %arg235, %0 : i1
  %3 = "llvm.select"(%1, %0, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def shrink_select_after := [llvm|
{
^0(%arg52 : i1, %arg53 : i32):
  %0 = llvm.mlir.constant(42 : i8) : i8
  %1 = llvm.trunc %arg53 : i32 to i8
  %2 = "llvm.select"(%arg52, %1, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%2) : (i8) -> ()
}
]

abbrev ReducedWidthRes (parsedExpr : Type) (genPred : Type) := (ParsedLogicalExpr parsedExpr genPred) × List (Std.HashMap Nat BVExpr.PackedBitVec)

def canonicalize_icmp_uge_neg5 : LLVMPeepholeRewriteRefine 1 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%x: i64):
      %c = llvm.mlir.constant -5 : i64
      %1 = llvm.icmp.uge %c, %x : i64
      llvm.return %1 : i1
  }]
  rhs := [LV| {
    ^entry (%x: i64):
      %c = llvm.mlir.constant -5 : i64
      %1 = llvm.icmp.ule %x, %c : i64
      llvm.return %1 : i1
  }]

def shl_or_commuted_after := [llvm|
{
^0(%arg13 : i8):
  %0 = llvm.mlir.constant(22 : i8) : i8
  %1 = llvm.shl %0, %arg13 : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def test_sub__nuw_is_safe_after := [llvm|
{
^0(%arg24 : i32):
  %0 = llvm.mlir.constant(2147483647 : i32) : i32
  %1 = llvm.mlir.constant(-2147483648 : i32) : i32
  %2 = llvm.and %arg24, %0 : i32
  %3 = llvm.sub %1, %2 overflow<nuw> : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def test4_after := [llvm|
{
^0(%arg57 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.shl %arg57, %0 overflow<nuw> : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def PR42691_3_logical_after := [llvm|
{
^0(%arg338 : i32):
  %0 = llvm.mlir.constant(-2147483647 : i32) : i32
  %1 = llvm.icmp "ult" %arg338, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def tryFactorization_xor_lshr_lshr_before := [llvm|
{
^0(%arg37 : i32):
  %0 = llvm.mlir.constant(-3 : i32) : i32
  %1 = llvm.mlir.constant(5 : i32) : i32
  %2 = llvm.lshr %0, %arg37 : i32
  %3 = llvm.lshr %1, %arg37 : i32
  %4 = llvm.xor %2, %3 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def shift_trunc_wrong_cmp_after := [llvm|
{
^0(%arg0 : i32):
  %0 = llvm.mlir.constant(24 : i32) : i32
  %1 = llvm.mlir.constant(1 : i8) : i8
  %2 = llvm.lshr %arg0, %0 : i32
  %3 = llvm.trunc %2 overflow<nuw> : i32 to i8
  %4 = llvm.icmp "slt" %3, %1 : i8
  "llvm.return"(%4) : (i1) -> ()
}
]

def irc_constants_C2MinusAPlusC1_1_neg2 : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%a: i64):
      %c1 = llvm.mlir.constant (1) : i64
      %c2 = llvm.mlir.constant (-2) : i64
      %0 = llvm.add %a, %c1 : i64
      %1 = llvm.sub %c2, %0 : i64
      llvm.return %1 : i64
  }]
  rhs := [LV| {
    ^entry (%a: i64):
      %c1 = llvm.mlir.constant (1) : i64
      %c2 = llvm.mlir.constant (-2) : i64
      %0 = llvm.sub %c2, %c1 : i64
      %1 = llvm.sub %0, %a : i64
      llvm.return %1 : i64
  }]

def mul_of_pow2_after := [llvm|
{
^0(%arg83 : i32, %arg84 : i8):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def test15f_after := [llvm|
{
^0(%arg22 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(256 : i32) : i32
  %2 = llvm.shl %arg22, %0 : i32
  %3 = llvm.and %2, %1 : i32
  %4 = llvm.xor %3, %1 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def not_match_inconsistent_signs_after := [llvm|
{
^0(%arg13 : i64):
  %0 = llvm.mlir.constant(299) : i64
  %1 = llvm.mlir.constant(63) : i64
  %2 = llvm.urem %arg13, %0 : i64
  %3 = llvm.sdiv %arg13, %0 : i64
  %4 = llvm.and %3, %1 : i64
  %5 = llvm.mul %4, %0 overflow<nsw,nuw> : i64
  %6 = llvm.add %2, %5 overflow<nsw,nuw> : i64
  "llvm.return"(%6) : (i64) -> ()
}
]

def lshrugt_03_02_after := [llvm|
{
^0(%arg381 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def foo3_before := [llvm|
{
^0(%arg2 : i1, %arg3 : i1):
  %0 = llvm.udiv %arg2, %arg3 : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

RV64.zexth in RISCV.Instructions

def scalar_i16_lshr_and_signbit_eq_after := [llvm|
{
^0(%arg33 : i16, %arg34 : i16):
  %0 = llvm.mlir.constant(-1 : i16) : i16
  %1 = llvm.lshr %arg33, %arg34 : i16
  %2 = llvm.icmp "sgt" %1, %0 : i16
  "llvm.return"(%2) : (i1) -> ()
}
]

def slt_swap_and_not_max_logical_before := [llvm|
{
^0(%arg116 : i8, %arg117 : i8):
  %0 = llvm.mlir.constant(127 : i8) : i8
  %1 = llvm.mlir.constant(false) : i1
  %2 = llvm.icmp "sgt" %arg117, %arg116 : i8
  %3 = llvm.icmp "ne" %arg116, %0 : i8
  %4 = "llvm.select"(%2, %3, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def positive_biggershl_shlnuw_ashrexact_before := [llvm|
{
^0(%arg29 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.mlir.constant(6 : i8) : i8
  %2 = llvm.ashr exact %arg29, %0 : i8
  %3 = llvm.shl %2, %1 overflow<nuw> : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def main6c_before := [llvm|
{
^0(%arg90 : i32):
  %0 = llvm.mlir.constant(7 : i32) : i32
  %1 = llvm.mlir.constant(3 : i32) : i32
  %2 = llvm.mlir.constant(48 : i32) : i32
  %3 = llvm.mlir.constant(16 : i32) : i32
  %4 = llvm.mlir.constant(0 : i32) : i32
  %5 = llvm.mlir.constant(1 : i32) : i32
  %6 = llvm.and %arg90, %0 : i32
  %7 = llvm.icmp "ne" %6, %1 : i32
  %8 = llvm.and %arg90, %2 : i32
  %9 = llvm.icmp "ne" %8, %3 : i32
  %10 = llvm.or %7, %9 : i1
  %11 = "llvm.select"(%10, %4, %5) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%11) : (i32) -> ()
}
]

def test11f_before := [llvm|
{
^0(%arg91 : i32, %arg92 : i32, %arg93 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.mul %arg92, %arg93 : i32
  %2 = llvm.xor %1, %arg91 : i32
  %3 = llvm.xor %arg91, %0 : i32
  %4 = llvm.xor %1, %3 : i32
  %5 = llvm.and %4, %2 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def test5_after := [llvm|
{
^0(%arg104 : i32):
  %0 = llvm.mlir.constant(16 : i32) : i32
  %1 = llvm.lshr %arg104, %0 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def op0Expr := (Expr.app (Expr.const `MLIR.AST.Op []) (Expr.const `Nat.zero []))

def and_slt_to_mask_before := [llvm|
{
^0(%arg5 : i8):
  %0 = llvm.mlir.constant(-124 : i8) : i8
  %1 = llvm.mlir.constant(2 : i8) : i8
  %2 = llvm.mlir.constant(0 : i8) : i8
  %3 = llvm.icmp "slt" %arg5, %0 : i8
  %4 = llvm.and %arg5, %1 : i8
  %5 = llvm.icmp "eq" %4, %2 : i8
  %6 = llvm.and %3, %5 : i1
  "llvm.return"(%6) : (i1) -> ()
}
]

def extract (x : BitVec w) (lb : Nat) : BitVec (w - lb) :=
  BitVec.truncate (w - lb) (BitVec.ushiftRight x lb)

def test_before := [llvm|
{
^0(%arg0 : i31):
  %0 = llvm.mlir.constant(16384 : i32) : i32
  %1 = llvm.mlir.constant(15 : i32) : i32
  %2 = llvm.sext %arg0 : i31 to i32
  %3 = llvm.add %2, %0 : i32
  %4 = llvm.lshr %3, %1 : i32
  %5 = llvm.trunc %4 : i32 to i16
  "llvm.return"(%5) : (i16) -> ()
}
]

def test58_before := [llvm|
{
^0(%arg124 : i64):
  %0 = llvm.mlir.constant(8 : i32) : i32
  %1 = llvm.mlir.constant(128 : i32) : i32
  %2 = llvm.trunc %arg124 : i64 to i32
  %3 = llvm.lshr %2, %0 : i32
  %4 = llvm.or %3, %1 : i32
  %5 = llvm.zext %4 : i32 to i64
  "llvm.return"(%5) : (i64) -> ()
}
]

private def isFile (p: System.FilePath) : IO Bool := do
  return (← p.metadata).type == IO.FS.FileType.file

def lshrult_01_05_before := [llvm|
{
^0(%arg362 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(5 : i4) : i4
  %2 = llvm.lshr %arg362, %0 : i4
  %3 = llvm.icmp "ult" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def positive_biggershl_shlnsw_before := [llvm|
{
^0(%arg49 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.mlir.constant(6 : i8) : i8
  %2 = llvm.ashr %arg49, %0 : i8
  %3 = llvm.shl %2, %1 overflow<nsw> : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def uge_umin3_after := [llvm|
{
^0(%arg48 : i32, %arg49 : i32):
  %0 = llvm.mlir.constant(3 : i32) : i32
  %1 = llvm.add %arg48, %0 : i32
  %2 = llvm.icmp "uge" %arg49, %1 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def rem_euclid_1_after := [llvm|
{
^0(%arg12 : i32):
  %0 = llvm.mlir.constant(7 : i32) : i32
  %1 = llvm.and %arg12, %0 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def lshr_by_const_cmp_sge_value_before := [llvm|
{
^0(%arg7 : i32):
  %0 = llvm.mlir.constant(3 : i32) : i32
  %1 = llvm.lshr %arg7, %0 : i32
  %2 = llvm.icmp "sge" %1, %arg7 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def urem_common_divisor_before := [llvm|
{
^0(%arg61 : i1, %arg62 : i5, %arg63 : i5, %arg64 : i5):
  %0 = llvm.urem %arg63, %arg62 : i5
  %1 = llvm.urem %arg64, %arg62 : i5
  %2 = "llvm.select"(%arg61, %1, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i5, i5) -> i5
  "llvm.return"(%2) : (i5) -> ()
}
]

def eval_sext_multi_use_in_one_inst_after := [llvm|
{
^0(%arg6 : i32):
  %0 = llvm.mlir.constant(14 : i16) : i16
  %1 = llvm.mlir.constant(-32768 : i16) : i16
  %2 = llvm.trunc %arg6 : i32 to i16
  %3 = llvm.and %2, %0 : i16
  %4 = llvm.mul %3, %3 overflow<nsw,nuw> : i16
  %5 = llvm.or disjoint %4, %1 : i16
  %6 = llvm.sext %5 : i16 to i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def ashrsgt_01_08_exact_before := [llvm|
{
^0(%arg93 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(-8 : i4) : i4
  %2 = llvm.ashr exact %arg93, %0 : i4
  %3 = llvm.icmp "sgt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def shl_and_and_fail_after := [llvm|
{
^0(%arg170 : i8, %arg171 : i8):
  %0 = llvm.mlir.constant(4 : i8) : i8
  %1 = llvm.mlir.constant(5 : i8) : i8
  %2 = llvm.mlir.constant(64 : i8) : i8
  %3 = llvm.shl %arg170, %0 : i8
  %4 = llvm.shl %arg171, %1 : i8
  %5 = llvm.and %4, %2 : i8
  %6 = llvm.and %3, %5 : i8
  "llvm.return"(%6) : (i8) -> ()
}
]

def udiv_shl_shl_nuw_nsw2_before := [llvm|
{
^0(%arg55 : i8, %arg56 : i8, %arg57 : i8):
  %0 = llvm.shl %arg55, %arg57 overflow<nsw,nuw> : i8
  %1 = llvm.shl %arg56, %arg57 overflow<nsw> : i8
  %2 = llvm.udiv %0, %1 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def neg_not_signbit2_before := [llvm|
{
^0(%arg4 : i8):
  %0 = llvm.mlir.constant(6 : i8) : i8
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.lshr %arg4, %0 : i8
  %3 = llvm.zext %2 : i8 to i32
  %4 = llvm.sub %1, %3 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def test12_before := [llvm|
{
^0(%arg292 : i32, %arg293 : i32):
  %0 = llvm.icmp "ult" %arg292, %arg293 : i32
  %1 = llvm.icmp "ule" %arg292, %arg293 : i32
  %2 = llvm.and %0, %1 : i1
  "llvm.return"(%2) : (i1) -> ()
}
]

@[simp_denote]
def icmp_neq_riscv_64 := [LV| {
  ^entry (%lhs: i64, %rhs: i64):
    %lhsr = "builtin.unrealized_conversion_cast"(%lhs) : (i64) -> (!i64)
    %rhsr = "builtin.unrealized_conversion_cast"(%rhs) : (i64) -> (!i64)
    %0 = xor    %lhsr, %rhsr : !i64
    %c0 = li (0) : !i64
    %1 = sltu %c0, %0 : !i64
    %2 = "builtin.unrealized_conversion_cast"(%1) : (!i64) -> (i1)
    llvm.return %2 : i1
  }]

instance : Repr (AttrValue φ) where
  reprPrec x _ := docAttrVal x

def trunc? {w: Nat} (w': Nat) (x: BitVec w) : IntW w' := do
  .value <| (BitVec.truncate w' x)

def test9_before := [llvm|
{
^0(%arg111 : i32, %arg112 : i32):
  %0 = llvm.and %arg111, %arg112 : i32
  %1 = llvm.xor %arg111, %arg112 : i32
  %2 = llvm.xor %0, %1 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def t7_ugt_sgt_neg1_before := [llvm|
{
^0(%arg57 : i32, %arg58 : i32, %arg59 : i32):
  %0 = llvm.mlir.constant(-17 : i32) : i32
  %1 = llvm.mlir.constant(16 : i32) : i32
  %2 = llvm.mlir.constant(143 : i32) : i32
  %3 = llvm.icmp "sgt" %arg57, %0 : i32
  %4 = "llvm.select"(%3, %arg59, %arg58) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %5 = llvm.add %arg57, %1 : i32
  %6 = llvm.icmp "ugt" %5, %2 : i32
  %7 = "llvm.select"(%6, %4, %arg57) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%7) : (i32) -> ()
}
]

abbrev FpGeneralizerState := GeneralizerState ParsedFpExpr FpPredicate

def band_land_right1_before := [llvm|
{
^0(%arg34 : i1, %arg35 : i1):
  %0 = llvm.mlir.constant(false) : i1
  %1 = llvm.and %arg34, %arg35 : i1
  %2 = "llvm.select"(%arg34, %1, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%2) : (i1) -> ()
}
]

def samesign_inverted_commute3_before := [llvm|
{
^0(%arg97 : i32, %arg98 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.and %arg97, %arg98 : i32
  %3 = llvm.icmp "sgt" %2, %0 : i32
  %4 = llvm.or %arg98, %arg97 : i32
  %5 = llvm.icmp "slt" %4, %1 : i32
  %6 = llvm.and %5, %3 : i1
  "llvm.return"(%6) : (i1) -> ()
}
]

def negate_lshr_after := [llvm|
{
^0(%arg124 : i8, %arg125 : i8):
  %0 = llvm.mlir.constant(7 : i8) : i8
  %1 = llvm.ashr %arg125, %0 : i8
  %2 = llvm.add %1, %arg124 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def not_logicalOr_not_op1_before := [llvm|
{
^0(%arg50 : i1, %arg51 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.xor %arg51, %0 : i1
  %2 = "llvm.select"(%arg50, %0, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %3 = llvm.xor %2, %0 : i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def liRiscv_38 := [LV| {
  ^entry ():
    %0 = "li"() {imm = -38 : !i64} : (!i64) -> (!i64)
    %1 = "builtin.unrealized_conversion_cast"(%0) : (!i64) -> (i64)
    llvm.return %1 : i64
  }]

IsTrans in Mathlib.Order.Defs.Unbundled

def or : FSM Bool :=
  { α := Empty,
    initCarry := Empty.elim,
    outputCirc := Circuit.var true (inr true) ||| Circuit.var true (inr false),
    nextStateCirc := fun a => a.elim
  }

abbrev FHE (q n : Nat) [Fact (q > 1)] : Dialect where
  Op := Op q n
  Ty := Ty q n

def test_with_5_after := [llvm|
{
^0(%arg315 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.icmp "eq" %arg315, %0 : i32
  %2 = llvm.zext %1 : i1 to i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def right_identity_one : List (Σ Γ, RISCVPeepholeRewrite Γ) :=
  [⟨_, right_identity_one_mul⟩]

def n10_wrong_low_bit_mask_before := [llvm|
{
^0(%arg11 : i8):
  %0 = llvm.mlir.constant(31 : i8) : i8
  %1 = llvm.mlir.constant(0 : i8) : i8
  %2 = llvm.mlir.constant(16 : i8) : i8
  %3 = llvm.mlir.constant(-16 : i8) : i8
  %4 = llvm.and %arg11, %0 : i8
  %5 = llvm.icmp "eq" %4, %1 : i8
  %6 = llvm.add %arg11, %2 : i8
  %7 = llvm.and %6, %3 : i8
  %8 = "llvm.select"(%5, %arg11, %7) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%8) : (i8) -> ()
}
]

instance : HydrablePrettifyAsTheorem GenBVPred where
  prettifyAsTheorem := prettifyAsTheorem

def masked_icmps_mask_notallzeros_bmask_mixed_negated_7b_logical_before := [llvm|
{
^0(%arg53 : i32):
  %0 = llvm.mlir.constant(6 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(15 : i32) : i32
  %3 = llvm.mlir.constant(8 : i32) : i32
  %4 = llvm.mlir.constant(true) : i1
  %5 = llvm.and %arg53, %0 : i32
  %6 = llvm.icmp "eq" %5, %1 : i32
  %7 = llvm.and %arg53, %2 : i32
  %8 = llvm.icmp "ne" %7, %3 : i32
  %9 = "llvm.select"(%6, %4, %8) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%9) : (i1) -> ()
}
]

def lshrult_02_00_exact_after := [llvm|
{
^0(%arg133 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

@[simp_denote]
def freeze_llvm_32 := [LV| {
  ^entry (%x: i32):
    %0 = llvm.freeze %x: i32
    llvm.return %0 : i32
  }]

def positive_trunc_base_logical_before := [llvm|
{
^0(%arg38 : i32):
  %0 = llvm.mlir.constant(-1 : i16) : i16
  %1 = llvm.mlir.constant(128 : i16) : i16
  %2 = llvm.mlir.constant(256 : i16) : i16
  %3 = llvm.mlir.constant(false) : i1
  %4 = llvm.trunc %arg38 : i32 to i16
  %5 = llvm.icmp "sgt" %4, %0 : i16
  %6 = llvm.add %4, %1 : i16
  %7 = llvm.icmp "ult" %6, %2 : i16
  %8 = "llvm.select"(%5, %7, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%8) : (i1) -> ()
}
]

def positive_with_icmp_logical_before := [llvm|
{
^0(%arg57 : i32):
  %0 = llvm.mlir.constant(512 : i32) : i32
  %1 = llvm.mlir.constant(128 : i32) : i32
  %2 = llvm.mlir.constant(256 : i32) : i32
  %3 = llvm.mlir.constant(false) : i1
  %4 = llvm.icmp "ult" %arg57, %0 : i32
  %5 = llvm.add %arg57, %1 : i32
  %6 = llvm.icmp "ult" %5, %2 : i32
  %7 = "llvm.select"(%4, %6, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%7) : (i1) -> ()
}
]

def test23_before := [llvm|
{
^0(%arg185 : i32, %arg186 : i32):
  %0 = llvm.xor %arg186, %arg185 : i32
  %1 = llvm.icmp "eq" %0, %arg185 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def dcAdd := [DCxComb_com| {
  ^entry(%a: !ValueStream_32, %b: !ValueStream_32):
    %unpacka = "DCxComb.unpack" (%a) : (!ValueStream_32) -> (!ValueTokenStream_32)
    
    %output = "DCxComb.fstVal" (%unpacka) : (!ValueTokenStream_32) -> (!ValueStream_32)
    %token = "DCxComb.sndVal" (%unpacka) : (!ValueTokenStream_32) -> (!TokenStream)
    %output1 = "DCxComb.fstVal" (%unpacka) : (!ValueTokenStream_32) -> (!ValueStream_32)
    %token0 = "DCxComb.sndVal" (%unpacka) : (!ValueTokenStream_32) -> (!TokenStream)
    %0 = "DCxComb.join" (%token, %token0) : (!TokenStream, !TokenStream) -> (!TokenStream)
    %1 = "DCxComb.add" (%output, %output1) : (!ValueStream_32, !ValueStream_32) -> (!ValueStream_32)
    
    %2 = "DCxComb.pack" (%1, %0) : (!ValueStream_32, !TokenStream) -> (!ValueStream_32)
    %unpack2 = "DCxComb.unpack" (%2) : (!ValueStream_32) -> (!ValueTokenStream_32)
    %output3 = "DCxComb.fstVal" (%unpack2) : (!ValueTokenStream_32) -> (!ValueStream_32)
    %token2 = "DCxComb.sndVal" (%unpack2) : (!ValueTokenStream_32) -> (!TokenStream)
    %unpackb = "DCxComb.unpack" (%b) : (!ValueStream_32) -> (!ValueTokenStream_32)
    %output5 = "DCxComb.fstVal" (%unpackb) : (!ValueTokenStream_32) -> (!ValueStream_32)
    %token4 = "DCxComb.sndVal" (%unpackb) : (!ValueTokenStream_32) -> (!TokenStream)
    %3 = "DCxComb.join" (%token2, %token4) : (!TokenStream, !TokenStream) -> (!TokenStream)
    %4 = "DCxComb.pack" (%output3, %3) : (!ValueStream_32, !TokenStream) -> (!ValueStream_32)
    %5 = "DCxComb.pack" (%output5, %3) : (!ValueStream_32, !TokenStream) -> (!ValueStream_32)
    %unpack5 = "DCxComb.unpack" (%5) : (!ValueStream_32) -> (!ValueTokenStream_32)
    %output7 = "DCxComb.fstVal" (%unpack5) : (!ValueTokenStream_32) -> (!ValueStream_32)
    %token6 = "DCxComb.sndVal" (%unpack5) : (!ValueTokenStream_32) -> (!TokenStream)
    %unpackabis = "DCxComb.unpack" (%a) : (!ValueStream_32) -> (!ValueTokenStream_32)
    %output9 = "DCxComb.fstVal" (%unpackabis) : (!ValueTokenStream_32) -> (!ValueStream_32)
    %token8 = "DCxComb.sndVal" (%unpackabis) : (!ValueTokenStream_32) -> (!TokenStream)
    %6 = "DCxComb.join" (%token6, %token8) : (!TokenStream, !TokenStream) -> (!TokenStream)
    %7 = "DCxComb.add" (%output7, %output9) : (!ValueStream_32, !ValueStream_32) -> (!ValueStream_32)
    %8 = "DCxComb.pack" (%7, %6) : (!ValueStream_32, !TokenStream) -> (!ValueStream_32)
    "return" (%8) : (!ValueStream_32) -> ()
  }]

def lshr_sub_after := [llvm|
{
^0(%arg77 : i8, %arg78 : i8):
  %0 = llvm.mlir.constant(42 : i8) : i8
  %1 = llvm.mlir.constant(3 : i8) : i8
  %2 = llvm.srem %arg77, %0 : i8
  %3 = llvm.lshr %arg78, %1 : i8
  %4 = llvm.sub %2, %3 overflow<nsw> : i8
  %5 = llvm.shl %4, %1 : i8
  "llvm.return"(%5) : (i8) -> ()
}
]

def mul16_low_after := [llvm|
{
^0(%arg24 : i16, %arg25 : i16):
  %0 = llvm.mul %arg24, %arg25 : i16
  "llvm.return"(%0) : (i16) -> ()
}
]

def shl_add_nsw_after := [llvm|
{
^0(%arg25 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.shl %0, %arg25 overflow<nsw> : i32
  %2 = llvm.xor %1, %0 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def lsb_mask_sign_zext_after := [llvm|
{
^0(%arg11 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.icmp "eq" %arg11, %0 : i32
  %2 = llvm.zext %1 : i1 to i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def RawCNFA.createSink (m : RawCNFA A) : State × RawCNFA A :=
  let (s, m) := m.newState
  let m := m.addInitial s
  let m := FinEnum.toList (α := A).foldl (init := m) fun m a =>
    m.addTrans a s s
  (s, m)

def test_sub_nsw__nsw_is_safe_after := [llvm|
{
^0(%arg21 : i32):
  %0 = llvm.mlir.constant(-2147483648 : i32) : i32
  %1 = llvm.or %arg21, %0 : i32
  %2 = llvm.sub %0, %1 overflow<nsw> : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def select_icmp_sgt_allones_smin_after := [llvm|
{
^0(%arg3 : i8):
  %0 = llvm.mlir.constant(127 : i8) : i8
  %1 = llvm.and %arg3, %0 : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def lshrult_02_05_exact_before := [llvm|
{
^0(%arg128 : i4):
  %0 = llvm.mlir.constant(2 : i4) : i4
  %1 = llvm.mlir.constant(5 : i4) : i4
  %2 = llvm.lshr exact %arg128, %0 : i4
  %3 = llvm.icmp "ult" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

macro "[llvm| " reg:mlir_region "]" : term => `([llvm()| $reg])

def binop_same_val : List (Σ Γ, RISCVPeepholeRewrite  Γ) :=
    [⟨_, binop_same_val_and⟩,
    ⟨_, binop_same_val_or⟩]

def test44_after := [llvm|
{
^0(%arg144 : i8):
  %0 = llvm.mlir.constant(1234 : i16) : i16
  %1 = llvm.zext %arg144 : i8 to i16
  %2 = llvm.or %1, %0 : i16
  %3 = llvm.zext nneg %2 : i16 to i64
  "llvm.return"(%3) : (i64) -> ()
}
]

def lshrult_02_10_exact_after := [llvm|
{
^0(%arg123 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def uge_swap_and_max_logical_before := [llvm|
{
^0(%arg228 : i8, %arg229 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.mlir.constant(false) : i1
  %2 = llvm.icmp "ule" %arg229, %arg228 : i8
  %3 = llvm.icmp "eq" %arg228, %0 : i8
  %4 = "llvm.select"(%2, %3, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def test_with_neg_even_after := [llvm|
{
^0(%arg311 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

def test13_before := [llvm|
{
^0(%arg44 : i32, %arg45 : i32):
  %0 = llvm.mlir.constant(-1431655767 : i32) : i32
  %1 = llvm.mlir.constant(1431655766 : i32) : i32
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.or %arg44, %0 : i32
  %4 = llvm.xor %3, %1 : i32
  %5 = llvm.add %arg45, %2 : i32
  %6 = llvm.add %5, %4 : i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def main3d_after := [llvm|
{
^0(%arg143 : i32):
  %0 = llvm.mlir.constant(23 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.and %arg143, %0 : i32
  %3 = llvm.icmp "eq" %2, %1 : i32
  %4 = llvm.zext %3 : i1 to i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def shl_and_lshr_before := [llvm|
{
^0(%arg94 : i32, %arg95 : i32, %arg96 : i32):
  %0 = llvm.shl %arg94, %arg95 overflow<nuw> : i32
  %1 = llvm.and %0, %arg96 : i32
  %2 = llvm.lshr %1, %arg95 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

instance [SMul M A] : SMul M (Holor A ds) :=

def missed_const_prop_2002h12h05_after := [llvm|
{
^0(%arg0 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

def a_after := [llvm|
{
^0(%arg48 : i1, %arg49 : i1):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.mlir.constant(1 : i32) : i32
  %2 = llvm.sext %arg49 : i1 to i32
  %3 = "llvm.select"(%arg48, %0, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %4 = llvm.add %3, %2 overflow<nsw> : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def or_test2_after := [llvm|
{
^0(%arg0 : i7, %arg1 : i7):
  %0 = llvm.mlir.constant(-64 : i7) : i7
  "llvm.return"(%0) : (i7) -> ()
}
]

def test3_after := [llvm|
{
^0(%arg0 : i599, %arg1 : i1):
  %0 = llvm.mlir.constant(70368744177663 : i599) : i599
  %1 = llvm.mlir.constant(4095 : i599) : i599
  %2 = "llvm.select"(%arg1, %0, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i599, i599) -> i599
  %3 = llvm.and %arg0, %2 : i599
  "llvm.return"(%3) : (i599) -> ()
}
]

def ex2_lhs : Com [.nat] .nat :=
  Com.var (rgn (k := 1) ⟨0, by admit /- proof elided -/
  ⟩ (
      Com.var (add ⟨0, by admit /- proof elided -/
      ⟩ ⟨0, by admit /- proof elided -/
      ⟩) 
      <| Com.ret ⟨0, by admit /- proof elided -/
      ⟩
  )) <|
  Com.ret ⟨0, by admit /- proof elided -/
  ⟩

def icmp_sle11_after := [llvm|
{
^0(%arg2 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.icmp "slt" %arg2, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def lshrugt_01_08_after := [llvm|
{
^0(%arg407 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def land_band_right2_after := [llvm|
{
^0(%arg48 : i1, %arg49 : i1):
  %0 = llvm.mlir.constant(false) : i1
  %1 = "llvm.select"(%arg49, %arg48, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%1) : (i1) -> ()
}
]

def test5_after := [llvm|
{
^0(%arg49 : i32):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def test_shl_nuw_nsw__nuw_is_safe_after := [llvm|
{
^0(%arg82 : i32, %arg83 : i64):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.mlir.constant(-8 : i32) : i32
  %2 = llvm.shl %arg82, %0 : i32
  %3 = llvm.and %2, %1 : i32
  %4 = llvm.zext nneg %3 : i32 to i64
  %5 = llvm.ashr %arg83, %4 : i64
  "llvm.return"(%5) : (i64) -> ()
}
]

def or_or_logic_and_1_before := [llvm|
{
^0(%arg12 : i1, %arg13 : i1, %arg14 : i1):
  %0 = llvm.mlir.constant(false) : i1
  %1 = llvm.or %arg12, %arg13 : i1
  %2 = llvm.or %arg14, %arg12 : i1
  %3 = "llvm.select"(%1, %2, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%3) : (i1) -> ()
}
]

@[simp, simp_denote]
abbrev Op.denote : (o : RV64.Op) → HVector toType o.sig → ⟦o.outTy⟧
  | .li imm, _  => imm
  | .addiw imm, regs => RV64.addiw imm (regs.getN 0)
  | .lui imm, regs  => RV64.lui imm
  | .auipc imm, regs => RV64.auipc imm (regs.getN 0)
  | .slliw shamt, regs => RV64.slliw shamt (regs.getN 0)
  | .srliw shamt, regs => RV64.srliw shamt (regs.getN 0)
  | .sraiw shamt, regs => RV64.sraiw shamt (regs.getN 0)
  | .slli shamt, regs => RV64.slli shamt (regs.getN 0)
  | .srli shamt, regs => RV64.srli shamt (regs.getN 0)
  | .srai shamt, regs => RV64.srai shamt (regs.getN 0)
  | .addw, regs => RV64.addw (regs.getN 1) (regs.getN 0)
  | .subw, regs => RV64.subw (regs.getN 1) (regs.getN 0)
  | .sllw, regs => RV64.sllw (regs.getN 1) (regs.getN 0)
  | .srlw, regs => RV64.srlw (regs.getN 1) (regs.getN 0)
  | .sraw, regs => RV64.sraw (regs.getN 1) (regs.getN 0)
  | .add, regs => RV64.add (regs.getN 1) (regs.getN 0)
  | .slt, regs => RV64.slt (regs.getN 1) (regs.getN 0)
  | .sltu, regs => RV64.sltu (regs.getN 1) (regs.getN 0)
  | .and, regs => RV64.and (regs.getN 1) (regs.getN 0)
  | .or, regs => RV64.or (regs.getN 1) (regs.getN 0)
  | .xor, regs => RV64.xor (regs.getN 1) (regs.getN 0)
  | .sll, regs => RV64.sll (regs.getN 1) (regs.getN 0)
  | .srl, regs => RV64.srl (regs.getN 1) (regs.getN 0)
  | .sub, regs => RV64.sub (regs.getN 1) (regs.getN 0)
  | .sra, regs => RV64.sra (regs.getN 1) (regs.getN 0)
  | .remw, regs => RV64.remw (regs.getN 1) (regs.getN 0)
  | .remuw, regs => RV64.remuw (regs.getN 1) (regs.getN 0)
  | .rem, regs => RV64.rem (regs.getN 1) (regs.getN 0)
  | .remu, regs => RV64.remu (regs.getN 1) (regs.getN 0)
  | .mulhu,regs => RV64.mulhu (regs.getN 1) (regs.getN 0)
  | .mul ,regs => RV64.mul (regs.getN 1) (regs.getN 0)
  | .mulhsu ,regs => RV64.mulhsu (regs.getN 1) (regs.getN 0)
  | .mulh,regs => RV64.mulh (regs.getN 1) (regs.getN 0)
  | .mulw,  regs => RV64.mulw (regs.getN 1) (regs.getN 0)
  | .div, regs => RV64.div (regs.getN 1) (regs.getN 0)
  | .divu, regs => RV64.divu (regs.getN 1) (regs.getN 0)
  | .divw, regs => RV64.divw (regs.getN 1) (regs.getN 0)
  | .divuw, regs => RV64.divuw (regs.getN 1) (regs.getN 0)
  | .addi imm, reg => RV64.addi imm (reg.getN 0)
  | .slti imm, reg => RV64.slti imm (reg.getN 0)
  | .sltiu imm, reg => RV64.sltiu imm (reg.getN 0)
  | .andi imm, reg => RV64.andi imm (reg.getN 0)
  | .ori imm, reg => RV64.ori imm (reg.getN 0)
  | .xori imm, reg => RV64.xori imm (reg.getN 0)
  | .bclr, regs => RV64.bclr (regs.getN 1) (regs.getN 0)
  | .bext, regs => RV64.bext (regs.getN 1) (regs.getN 0)
  | .binv, regs => RV64.binv (regs.getN 1) (regs.getN 0)
  | .bset, regs => RV64.bset (regs.getN 1) (regs.getN 0)
  | .bclri shamt , reg => RV64.bclri shamt (reg.getN 0)
  | .bexti shamt, reg => RV64.bexti shamt (reg.getN 0)
  | .binvi shamt, reg => RV64.binvi shamt (reg.getN 0)
  | .bseti shamt, reg => RV64.bseti shamt (reg.getN 0)
  | .adduw, regs => RV64.adduw (regs.getN 1) (regs.getN 0)
  | .sh1adduw , regs => RV64.sh1adduw (regs.getN 1) (regs.getN 0)
  | .sh2adduw, regs => RV64.sh2adduw (regs.getN 1) (regs.getN 0)
  | .sh3adduw, regs => RV64.sh3adduw (regs.getN 1) (regs.getN 0)
  | .sh1add, regs => RV64.sh1add (regs.getN 1) (regs.getN 0)
  | .sh2add, regs => RV64.sh2add (regs.getN 1) (regs.getN 0)
  | .sh3add, regs => RV64.sh3add (regs.getN 1) (regs.getN 0)
  | .slliuw shamt, regs => RV64.slliuw shamt (regs.getN 0)
  | .andn, regs => RV64.andn (regs.getN 1) (regs.getN 0)
  | .orn, regs => RV64.orn (regs.getN 1) (regs.getN 0)
  | .xnor, regs => RV64.xnor (regs.getN 1) (regs.getN 0)
  | .clz, regs => RV64.clz (regs.getN 1)
  | .clzw, regs => RV64.clzw (regs.getN 1)
  | .ctz, regs => RV64.ctz (regs.getN 1)
  | .ctzw, regs => RV64.ctzw (regs.getN 1)
  | .max, regs => RV64.max (regs.getN 1) (regs.getN 0)
  | .maxu, regs => RV64.maxu (regs.getN 1) (regs.getN 0)
  | .min, regs => RV64.min (regs.getN 1) (regs.getN 0)
  | .minu, regs => RV64.minu (regs.getN 1) (regs.getN 0)
  | .sextb, reg => RV64.sextb (reg.getN 0)
  | .sexth, reg => RV64.sexth (reg.getN 0)
  | .zexth, reg => RV64.zexth (reg.getN 0)
  | .rol, regs => RV64.rol (regs.getN 1) (regs.getN 0)
  | .rolw, regs => RV64.rolw (regs.getN 1) (regs.getN 0)
  | .ror, regs => RV64.ror (regs.getN 1) (regs.getN 0)
  | .rori shamt, regs => RV64.rori shamt (regs.getN 0)
  | .roriw shamt, regs => RV64.roriw shamt (regs.getN 0)
  | .rorw, regs => RV64.rorw (regs.getN 1) (regs.getN 0)
  | .pack, regs => RV64.pack (regs.getN 1) (regs.getN 0)
  | .packh, regs => RV64.packh (regs.getN 1) (regs.getN 0)
  | .packw, regs => RV64.packw (regs.getN 1) (regs.getN 0)
  
  | .mv, regs  => RV64.mv_pseudo (regs.getN 0)
  | .not, regs => RV64.not_pseudo (regs.getN 0)
  | .neg, regs => RV64.neg_pseudo (regs.getN 0)
  | .negw, regs => RV64.negw_pseudo (regs.getN 0)
  | .sextw, regs => RV64.sextw_pseudo (regs.getN 0)
  | .zextb, regs => RV64.zextb_pseudo (regs.getN 0)
  | .zextw, regs => RV64.zextw_pseudo (regs.getN 0)
  | .seqz, regs => RV64.seqz_pseudo (regs.getN 0)
  | .snez, regs => RV64.snez_pseudo (regs.getN 0)
  | .sltz, regs => RV64.sltz_pseudo (regs.getN 0)
  | .sgtz, regs => RV64.sgtz_pseudo (regs.getN 0)

instance : DialectPrint Handshake where
  printOpName := reprStr
  printTy := reprStr
  printAttributes _ := ""
  dialectName := "handshake"
  printReturn _ := "return"

def ashrslt_01_04_after := [llvm|
{
^0(%arg265 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def positive_biggerlshr_after := [llvm|
{
^0(%arg60 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.mlir.constant(24 : i8) : i8
  %2 = llvm.lshr %arg60, %0 : i8
  %3 = llvm.and %2, %1 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def trunc_lshr_before := [llvm|
{
^0(%arg10 : i8):
  %0 = llvm.mlir.constant(2 : i8) : i8
  %1 = llvm.mlir.constant(14 : i6) : i6
  %2 = llvm.lshr %arg10, %0 : i8
  %3 = llvm.trunc %2 : i8 to i6
  %4 = llvm.and %3, %1 : i6
  "llvm.return"(%4) : (i6) -> ()
}
]

def trunc_shl_1_i32_i64_before := [llvm|
{
^0(%arg35 : i64):
  %0 = llvm.mlir.constant(1) : i64
  %1 = llvm.shl %arg35, %0 : i64
  %2 = llvm.trunc %1 : i64 to i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def test2_after := [llvm|
{
^0(%arg24 : i32, %arg25 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.and %arg24, %arg25 : i32
  %2 = llvm.icmp "sgt" %1, %0 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def test24_before := [llvm|
{
^0(%arg2 : i32):
  %0 = llvm.mlir.constant(4 : i32) : i32
  %1 = llvm.mlir.constant(2 : i32) : i32
  %2 = llvm.mlir.constant(0 : i32) : i32
  %3 = llvm.and %arg2, %0 : i32
  %4 = llvm.lshr %3, %1 : i32
  %5 = llvm.icmp "eq" %4, %2 : i32
  %6 = llvm.zext %5 : i1 to i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def sub_ashr_and_i64_after := [llvm|
{
^0(%arg25 : i64, %arg26 : i64):
  %0 = llvm.mlir.constant(0) : i64
  %1 = llvm.icmp "slt" %arg26, %arg25 : i64
  %2 = "llvm.select"(%1, %arg25, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i64, i64) -> i64
  "llvm.return"(%2) : (i64) -> ()
}
]

HOr.hOr in Init.Prelude

def invert_both_cmp_operands_add_after := [llvm|
{
^0(%arg38 : i32, %arg39 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.sub %arg38, %arg39 : i32
  %2 = llvm.icmp "slt" %1, %0 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def xor_or_xor_common_op_commute3_before := [llvm|
{
^0(%arg74 : i32, %arg75 : i32, %arg76 : i32):
  %0 = llvm.xor %arg74, %arg76 : i32
  %1 = llvm.or %arg75, %arg74 : i32
  %2 = llvm.xor %0, %1 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def xor_with_or_disjoint_ab_before := [llvm|
{
^0(%arg26 : i32, %arg27 : i32):
  %0 = llvm.or disjoint %arg26, %arg27 : i32
  %1 = llvm.xor %arg26, %0 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def select_icmp_eq_and_32_0_or_8_before := [llvm|
{
^0(%arg241 : i32, %arg242 : i32):
  %0 = llvm.mlir.constant(32 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(8 : i32) : i32
  %3 = llvm.and %arg241, %0 : i32
  %4 = llvm.icmp "eq" %3, %1 : i32
  %5 = llvm.or %arg242, %2 : i32
  %6 = "llvm.select"(%4, %arg242, %5) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%6) : (i32) -> ()
}
]

RV64.rorw in RISCV.Instructions

def shl_add_nuw_after := [llvm|
{
^0(%arg24 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

def select_icmp_ne_0_and_4096_or_4096_after := [llvm|
{
^0(%arg233 : i32, %arg234 : i32):
  %0 = llvm.mlir.constant(4096 : i32) : i32
  %1 = llvm.and %arg233, %0 : i32
  %2 = llvm.xor %1, %0 : i32
  %3 = llvm.or %arg234, %2 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def udiv_ne_big_after := [llvm|
{
^0(%arg36 : i8, %arg37 : i8):
  %0 = llvm.mlir.constant(-128 : i8) : i8
  %1 = llvm.mlir.constant(1 : i8) : i8
  %2 = llvm.icmp "ne" %arg36, %0 : i8
  %3 = llvm.icmp "ne" %arg37, %1 : i8
  %4 = llvm.or %2, %3 : i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def bor_lor_right1_after := [llvm|
{
^0(%arg6 : i1, %arg7 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = "llvm.select"(%arg6, %0, %arg7) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%1) : (i1) -> ()
}
]

Lean.ReducibilityStatus.reducible in Lean.ReducibilityAttrs

def ashrsgt_02_02_exact_before := [llvm|
{
^0(%arg83 : i4):
  %0 = llvm.mlir.constant(2 : i4) : i4
  %1 = llvm.ashr exact %arg83, %0 : i4
  %2 = llvm.icmp "sgt" %1, %0 : i4
  "llvm.return"(%2) : (i1) -> ()
}
]

IO.FS.Stream in Init.System.IO

def ashr_sgt_overflow_before := [llvm|
{
^0(%arg150 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.mlir.constant(63 : i8) : i8
  %2 = llvm.ashr %arg150, %0 : i8
  %3 = llvm.icmp "sgt" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def not_or_or_and_not_and_and_commute2_and_after := [llvm|
{
^0(%arg202 : i32, %arg203 : i32, %arg204 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg202, %0 : i32
  %2 = llvm.xor %arg204, %arg203 : i32
  %3 = llvm.or %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def test3_before := [llvm|
{
^0(%arg0 : i59, %arg1 : i1):
  %0 = llvm.mlir.constant(1024 : i59) : i59
  %1 = llvm.mlir.constant(4096 : i59) : i59
  %2 = "llvm.select"(%arg1, %0, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i59, i59) -> i59
  %3 = llvm.udiv %arg0, %2 : i59
  "llvm.return"(%3) : (i59) -> ()
}
]

def udiv_shl_mul_nuw_exact_before := [llvm|
{
^0(%arg142 : i5, %arg143 : i5, %arg144 : i5):
  %0 = llvm.shl %arg142, %arg144 overflow<nuw> : i5
  %1 = llvm.mul %arg142, %arg143 overflow<nuw> : i5
  %2 = llvm.udiv exact %0, %1 : i5
  "llvm.return"(%2) : (i5) -> ()
}
]

def test1_before := [llvm|
{
^0(%arg3 : i33):
  %0 = llvm.mlir.constant(4096 : i33) : i33
  %1 = llvm.urem %arg3, %0 : i33
  "llvm.return"(%1) : (i33) -> ()
}
]

def lshrult_03_02_exact_after := [llvm|
{
^0(%arg115 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def not_after := [llvm|
{
^0(%arg7 : i8):
  %0 = llvm.mlir.constant(42 : i8) : i8
  %1 = llvm.mlir.constant(-1 : i8) : i8
  %2 = llvm.udiv %arg7, %0 : i8
  %3 = llvm.xor %arg7, %1 : i8
  %4 = llvm.mul %2, %3 : i8
  "llvm.return"(%4) : (i8) -> ()
}
]

def xor_lshr_multiuse_before := [llvm|
{
^0(%arg596 : i8, %arg597 : i8, %arg598 : i8, %arg599 : i8):
  %0 = llvm.lshr %arg596, %arg599 : i8
  %1 = llvm.lshr %arg597, %arg599 : i8
  %2 = llvm.xor %0, %arg598 : i8
  %3 = llvm.xor %2, %1 : i8
  %4 = llvm.sdiv %2, %3 : i8
  "llvm.return"(%4) : (i8) -> ()
}
]

def t1_after := [llvm|
{
^0(%arg12 : i4):
  %0 = llvm.mlir.constant(3 : i4) : i4
  %1 = llvm.mlir.constant(6 : i4) : i4
  %2 = llvm.and %arg12, %0 : i4
  %3 = llvm.xor %2, %1 : i4
  "llvm.return"(%3) : (i4) -> ()
}
]

def n7_after := [llvm|
{
^0(%arg3 : i8, %arg4 : i8, %arg5 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.mlir.constant(0 : i8) : i8
  %2 = llvm.and %arg3, %0 : i8
  %3 = llvm.icmp "eq" %2, %1 : i8
  %4 = "llvm.select"(%3, %arg4, %arg5) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%4) : (i8) -> ()
}
]

@[match_pattern] abbrev add (w : Nat) (flags: NoWrapFlags := {}) : LLVM.Op := MOp.add (.concrete w) flags

def main4b_logical_before := [llvm|
{
^0(%arg131 : i32):
  %0 = llvm.mlir.constant(7 : i32) : i32
  %1 = llvm.mlir.constant(16 : i32) : i32
  %2 = llvm.mlir.constant(0 : i32) : i32
  %3 = llvm.mlir.constant(false) : i1
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.and %arg131, %0 : i32
  %6 = llvm.icmp "eq" %5, %0 : i32
  %7 = llvm.and %arg131, %1 : i32
  %8 = llvm.icmp "ne" %7, %2 : i32
  %9 = "llvm.select"(%6, %8, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %10 = "llvm.select"(%9, %2, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%10) : (i32) -> ()
}
]

def ashrsgt_01_09_before := [llvm|
{
^0(%arg308 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(-7 : i4) : i4
  %2 = llvm.ashr %arg308, %0 : i4
  %3 = llvm.icmp "sgt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def CombEg6 := [Comb_com| {
    ^entry (%0 : i4, %1 : i4, %2 : i1):
      %3 = "Comb.mux" (%0, %1, %2) : (i4, i4, i1) -> i4
      "return" (%3) : (i4) -> ()
}]

def not_signbit_trunc_before := [llvm|
{
^0(%arg16 : i16):
  %0 = llvm.mlir.constant(-1 : i16) : i16
  %1 = llvm.mlir.constant(15 : i16) : i16
  %2 = llvm.xor %arg16, %0 : i16
  %3 = llvm.lshr %2, %1 : i16
  %4 = llvm.trunc %3 : i16 to i8
  "llvm.return"(%4) : (i8) -> ()
}
]

def pv_after := [llvm|
{
^0(%arg15 : i8, %arg16 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.lshr %0, %arg16 : i8
  %2 = llvm.icmp "ugt" %arg15, %1 : i8
  "llvm.return"(%2) : (i1) -> ()
}
]

def ReflectMap.size (m : ReflectMap) : Nat :=
    m.exprs.size

def test1_after := [llvm|
{
^0(%arg3 : i16):
  %0 = llvm.mlir.constant(8 : i16) : i16
  %1 = llvm.mlir.constant(5 : i16) : i16
  %2 = llvm.lshr %arg3, %0 : i16
  %3 = llvm.mul %arg3, %1 : i16
  %4 = llvm.or %2, %3 : i16
  "llvm.return"(%4) : (i16) -> ()
}
]

def PR28476_logical_after := [llvm|
{
^0(%arg6 : i32, %arg7 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.mlir.constant(true) : i1
  %2 = llvm.icmp "eq" %arg6, %0 : i32
  %3 = llvm.icmp "eq" %arg7, %0 : i32
  %4 = "llvm.select"(%2, %1, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %5 = llvm.zext %4 : i1 to i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def shl_or_disjoint_lshr_comm_after := [llvm|
{
^0(%arg103 : i32, %arg104 : i32, %arg105 : i32):
  %0 = llvm.lshr %arg105, %arg104 : i32
  %1 = llvm.or disjoint %0, %arg103 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def trunc_lshr_sext_exact_after := [llvm|
{
^0(%arg45 : i8):
  %0 = llvm.mlir.constant(6 : i8) : i8
  %1 = llvm.ashr exact %arg45, %0 : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def positive_biggershl_shlnuwnsw_ashrexact_after := [llvm|
{
^0(%arg24 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.shl %arg24, %0 overflow<nsw,nuw> : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def ne_smin1_before := [llvm|
{
^0(%arg71 : i32, %arg72 : i32):
  %0 = llvm.icmp "slt" %arg71, %arg72 : i32
  %1 = "llvm.select"(%0, %arg71, %arg72) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %2 = llvm.icmp "ne" %1, %arg71 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def scalar_i64_shl_ult_const_before := [llvm|
{
^0(%arg14 : i64):
  %0 = llvm.mlir.constant(25) : i64
  %1 = llvm.mlir.constant(8589934592) : i64
  %2 = llvm.shl %arg14, %0 : i64
  %3 = llvm.icmp "ult" %2, %1 : i64
  "llvm.return"(%3) : (i1) -> ()
}
]

def scalar_i32_signbit_lshr_and_eq_before := [llvm|
{
^0(%arg31 : i32, %arg32 : i32):
  %0 = llvm.mlir.constant(-2147483648 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.lshr %0, %arg32 : i32
  %3 = llvm.and %2, %arg31 : i32
  %4 = llvm.icmp "eq" %3, %1 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def src_x_and_nmask_slt_after := [llvm|
{
^0(%arg19 : i8, %arg20 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.shl %0, %arg20 overflow<nsw> : i8
  %2 = llvm.icmp "sgt" %1, %arg19 : i8
  "llvm.return"(%2) : (i1) -> ()
}
]

def lshrugt_02_02_exact_before := [llvm|
{
^0(%arg203 : i4):
  %0 = llvm.mlir.constant(2 : i4) : i4
  %1 = llvm.lshr exact %arg203, %0 : i4
  %2 = llvm.icmp "ugt" %1, %0 : i4
  "llvm.return"(%2) : (i1) -> ()
}
]

def test_implied_true_before := [llvm|
{
^0(%arg9 : i8):
  %0 = llvm.mlir.constant(10 : i8) : i8
  %1 = llvm.mlir.constant(0 : i8) : i8
  %2 = llvm.mlir.constant(5 : i8) : i8
  %3 = llvm.mlir.constant(20 : i8) : i8
  %4 = llvm.icmp "slt" %arg9, %0 : i8
  %5 = llvm.icmp "slt" %arg9, %1 : i8
  %6 = "llvm.select"(%4, %1, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  %7 = "llvm.select"(%5, %6, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%7) : (i8) -> ()
}
]

instance [DecidableEq ι] [Fintype ι] :
    Fintype (Inputs ι n) where
  elems := univ n |>.val
  complete := univ n |>.property

def ugt_swap_or_not_min_logical_after := [llvm|
{
^0(%arg4 : i8, %arg5 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.icmp "ne" %arg4, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def ashr_ult_exact_near_pow2_cmpval_after := [llvm|
{
^0(%arg4 : i8):
  %0 = llvm.mlir.constant(9 : i8) : i8
  %1 = llvm.icmp "ult" %arg4, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def drop_nsw_trunc_after := [llvm|
{
^0(%arg13 : i16, %arg14 : i16):
  %0 = llvm.and %arg13, %arg14 : i16
  %1 = llvm.trunc %0 : i16 to i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def Valuation.eval {Γ : Ctxt Ty} (VAL : Valuation Γ) ⦃t : Ty⦄ (v : Γ.Var t) : toType t :=
    VAL v

def test_add_nuw_nsw__all_are_safe_after := [llvm|
{
^0(%arg47 : i32):
  %0 = llvm.mlir.constant(1073741823 : i32) : i32
  %1 = llvm.mlir.constant(1 : i32) : i32
  %2 = llvm.and %arg47, %0 : i32
  %3 = llvm.add %2, %1 overflow<nsw,nuw> : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def alive_AddSub_1156_src :=
[sllvm| {
^bb0(%b : i64):
  %v1 = llvm.add %b, %b : i64
  llvm.return %v1 : i64
}]

def icmp_power2_and_icmp_shifted_mask_swapped_2147483648_1610612736_before := [llvm|
{
^0(%arg44 : i32):
  %0 = llvm.mlir.constant(-2147483648 : i32) : i32
  %1 = llvm.mlir.constant(1610612736 : i32) : i32
  %2 = llvm.icmp "ult" %arg44, %0 : i32
  %3 = llvm.and %arg44, %1 : i32
  %4 = llvm.icmp "ne" %3, %1 : i32
  %5 = llvm.and %4, %2 : i1
  "llvm.return"(%5) : (i1) -> ()
}
]

def icmp_x_slt_0_xor_icmp_y_sgt_neg1_i32_after := [llvm|
{
^0(%arg55 : i32, %arg56 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg56, %arg55 : i32
  %2 = llvm.icmp "sgt" %1, %0 : i32
  %3 = llvm.zext %2 : i1 to i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def select_or_icmp_bad_before := [llvm|
{
^0(%arg149 : i32, %arg150 : i32, %arg151 : i32):
  %0 = llvm.mlir.constant(3 : i32) : i32
  %1 = llvm.icmp "eq" %arg149, %0 : i32
  %2 = llvm.or %arg149, %arg151 : i32
  %3 = "llvm.select"(%1, %2, %arg150) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def ugt_rem_nz_after := [llvm|
{
^0(%arg165 : i8):
  %0 = llvm.mlir.constant(4 : i8) : i8
  %1 = llvm.icmp "ugt" %arg165, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def xor_notand_to_or_not2_after := [llvm|
{
^0(%arg15 : i3, %arg16 : i3, %arg17 : i3):
  %0 = llvm.mlir.constant(-1 : i3) : i3
  %1 = llvm.or %arg17, %arg16 : i3
  %2 = llvm.and %arg15, %arg17 : i3
  %3 = llvm.xor %1, %0 : i3
  %4 = llvm.or %2, %3 : i3
  "llvm.return"(%4) : (i3) -> ()
}
]

def shiftLeft (n : Nat) : FSM Unit :=
  match n with
  | 0 => FSM.id
  | n + 1 => composeUnaryAux (FSM.ls false) (shiftLeft n)

def slt_swap_or_not_max_commute_logical_after := [llvm|
{
^0(%arg48 : i8, %arg49 : i8):
  %0 = llvm.mlir.constant(127 : i8) : i8
  %1 = llvm.icmp "ne" %arg48, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def not_or_or_and_not_and_and_commute1_and_after := [llvm|
{
^0(%arg205 : i32, %arg206 : i32, %arg207 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg205, %0 : i32
  %2 = llvm.xor %arg207, %arg206 : i32
  %3 = llvm.or %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def test2_before := [llvm|
{
^0(%arg0 : i999, %arg1 : i999):
  %0 = llvm.mlir.constant(65280 : i999) : i999
  %1 = llvm.and %arg0, %0 : i999
  %2 = llvm.and %arg1, %0 : i999
  %3 = llvm.icmp "ne" %1, %2 : i999
  "llvm.return"(%3) : (i1) -> ()
}
]

def trunc_shl_lshr_infloop_before := [llvm|
{
^0(%arg26 : i64):
  %0 = llvm.mlir.constant(1) : i64
  %1 = llvm.mlir.constant(2) : i64
  %2 = llvm.lshr %arg26, %0 : i64
  %3 = llvm.shl %2, %1 : i64
  %4 = llvm.trunc %3 : i64 to i32
  "llvm.return"(%4) : (i32) -> ()
}
]

@[simp_denote]
def constLLVM1_1bit : Com LLVMPlusRiscV ⟨[]⟩ .pure (.llvm (.bitvec 1)) := [LV| {
  ^entry ():
    %1 = llvm.mlir.constant (1) : i1
    llvm.return %1 : i1
  }]

def pr40493_neg1_before := [llvm|
{
^0(%arg17 : i32):
  %0 = llvm.mlir.constant(11 : i32) : i32
  %1 = llvm.mlir.constant(4 : i32) : i32
  %2 = llvm.mlir.constant(0 : i32) : i32
  %3 = llvm.mul %arg17, %0 : i32
  %4 = llvm.and %3, %1 : i32
  %5 = llvm.icmp "eq" %4, %2 : i32
  "llvm.return"(%5) : (i1) -> ()
}
]

def udiv_exact_eq_1_before := [llvm|
{
^0(%arg10 : i8, %arg11 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.udiv exact %arg10, %arg11 : i8
  %2 = llvm.icmp "ne" %1, %0 : i8
  "llvm.return"(%2) : (i1) -> ()
}
]

def add_or_sub_comb_i32_commuted1_nuw_after := [llvm|
{
^0(%arg16 : i32):
  "llvm.return"(%arg16) : (i32) -> ()
}
]

def positive_with_extra_and_after := [llvm|
{
^0(%arg53 : i32, %arg54 : i1):
  %0 = llvm.mlir.constant(128 : i32) : i32
  %1 = llvm.icmp "ult" %arg53, %0 : i32
  %2 = llvm.and %1, %arg54 : i1
  "llvm.return"(%2) : (i1) -> ()
}
]

def ashrsgt_03_00_before := [llvm|
{
^0(%arg285 : i4):
  %0 = llvm.mlir.constant(3 : i4) : i4
  %1 = llvm.mlir.constant(0 : i4) : i4
  %2 = llvm.ashr %arg285, %0 : i4
  %3 = llvm.icmp "sgt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def main8_before := [llvm|
{
^0(%arg28 : i32):
  %0 = llvm.mlir.constant(64 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(0 : i8) : i8
  %3 = llvm.mlir.constant(2 : i32) : i32
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.and %arg28, %0 : i32
  %6 = llvm.icmp "ne" %5, %1 : i32
  %7 = llvm.trunc %arg28 : i32 to i8
  %8 = llvm.icmp "slt" %7, %2 : i8
  %9 = llvm.or %6, %8 : i1
  %10 = "llvm.select"(%9, %3, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%10) : (i32) -> ()
}
]

def n2_badmask_before := [llvm|
{
^0(%arg4 : i32, %arg5 : i32, %arg6 : i32, %arg7 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.and %arg6, %arg4 : i32
  %2 = llvm.xor %arg7, %0 : i32
  %3 = llvm.and %2, %arg5 : i32
  %4 = llvm.or %1, %3 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def lshr_16_to_64_add_zext_basic_after := [llvm|
{
^0(%arg17 : i16, %arg18 : i16):
  %0 = llvm.mlir.constant(-1 : i16) : i16
  %1 = llvm.xor %arg17, %0 : i16
  %2 = llvm.icmp "ugt" %arg18, %1 : i16
  %3 = llvm.zext %2 : i1 to i64
  "llvm.return"(%3) : (i64) -> ()
}
]

def reflectAtomUnchecked (map : ReflectMap) (_w : Expr) (e : Expr) : MetaM (ReflectResult _root_.Term) := do
  let (e, map) := map.findOrInsertExpr e
  return { exprToIx := map, e := Term.var e }

def and_zext_eq_zero_before := [llvm|
{
^0(%arg28 : i32, %arg29 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.icmp "eq" %arg28, %0 : i32
  %3 = llvm.zext %2 : i1 to i32
  %4 = llvm.lshr %arg28, %arg29 : i32
  %5 = llvm.xor %4, %1 : i32
  %6 = llvm.and %3, %5 : i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def EnvFin.getLsb {w : Nat} (env : EnvFin (w + 1) n) : EnvFin 1 n := fun n => BitVec.ofBool <| (env n)[0]

def ashr_ne_both_equal_before := [llvm|
{
^0(%arg171 : i8):
  %0 = llvm.mlir.constant(-128 : i8) : i8
  %1 = llvm.ashr %0, %arg171 : i8
  %2 = llvm.icmp "ne" %1, %0 : i8
  "llvm.return"(%2) : (i1) -> ()
}
]

def debugCheck (check? : Bool) (e : Expr)  : MetaM Unit :=
    if check?
    then check e
    else return ()

def logic_and_logic_or_5_after := [llvm|
{
^0(%arg165 : i1, %arg166 : i1, %arg167 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.mlir.constant(false) : i1
  %2 = "llvm.select"(%arg167, %0, %arg166) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %3 = "llvm.select"(%arg165, %2, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def main7d_before := [llvm|
{
^0(%arg64 : i32, %arg65 : i32, %arg66 : i32, %arg67 : i32, %arg68 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.mlir.constant(1 : i32) : i32
  %2 = llvm.and %arg65, %arg67 : i32
  %3 = llvm.and %arg66, %arg68 : i32
  %4 = llvm.and %arg64, %2 : i32
  %5 = llvm.icmp "eq" %4, %2 : i32
  %6 = llvm.and %arg64, %3 : i32
  %7 = llvm.icmp "eq" %6, %3 : i32
  %8 = llvm.and %5, %7 : i1
  %9 = "llvm.select"(%8, %0, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%9) : (i32) -> ()
}
]

Lean.trace.profiler.threshold in Lean.Util.Trace

def ne_umax3_before := [llvm|
{
^0(%arg40 : i32, %arg41 : i32):
  %0 = llvm.mlir.constant(3 : i32) : i32
  %1 = llvm.add %arg40, %0 : i32
  %2 = llvm.icmp "ugt" %1, %arg41 : i32
  %3 = "llvm.select"(%2, %1, %arg41) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %4 = llvm.icmp "ne" %1, %3 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def alive_AndOrXor_2118___A__B__A___A__B_src :=
[sllvm| {
^bb0(%A : i64, %B : i64):
  %v1 = llvm.mlir.constant -1 : i64
  %v2 = llvm.xor %A, %v1 : i64
  %v3 = llvm.and %A, %B : i64
  %v4 = llvm.or %v3, %v2 : i64
  llvm.return %v4 : i64
}]

def Hom.append {ζ : Ctxt Ty} (f : Γ.Hom Δ) : Hom (ζ ++ Γ) (ζ ++ Δ) :=
  fun _ => Var.appendCases
    (fun v => v.appendInl)
    (fun v => (f v).appendInr)

def udiv_common_dividend_defined_cond_before := [llvm|
{
^0(%arg17 : i1, %arg18 : i5, %arg19 : i5, %arg20 : i5):
  %0 = llvm.udiv %arg18, %arg19 : i5
  %1 = llvm.udiv %arg18, %arg20 : i5
  %2 = "llvm.select"(%arg17, %1, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i5, i5) -> i5
  "llvm.return"(%2) : (i5) -> ()
}
]

def ashr_ne_msb_low_second_zero_after := [llvm|
{
^0(%arg173 : i8):
  %0 = llvm.mlir.constant(7 : i8) : i8
  %1 = llvm.icmp "ult" %arg173, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def shl_and_before := [llvm|
{
^0(%arg71 : i8, %arg72 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.mlir.constant(2 : i8) : i8
  %2 = llvm.shl %arg71, %0 : i8
  %3 = llvm.and %2, %arg72 : i8
  %4 = llvm.shl %3, %1 : i8
  "llvm.return"(%4) : (i8) -> ()
}
]

def band_lor_left2_before := [llvm|
{
^0(%arg80 : i1, %arg81 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.and %arg81, %arg80 : i1
  %2 = "llvm.select"(%1, %0, %arg80) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%2) : (i1) -> ()
}
]

def shl_nuw_add_nuw_before := [llvm|
{
^0(%arg16 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.shl %0, %arg16 overflow<nuw> : i32
  %3 = llvm.add %2, %1 overflow<nuw> : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

@[simp_denote]
def srai_riscv :=
  [LV| {
    ^entry (%arg: i16):
    %a =  "builtin.unrealized_conversion_cast" (%arg) : (i16) -> (!i64)
    %0 =slli %a, 48 : !i64
    %1 =srai %0, 57 : !i64
    %2 = "builtin.unrealized_conversion_cast" (%1) : (!i64) -> (i16)
    llvm.return %2 :i16
  }]

def NFA.autWidth (wp : WidthPredicate) (n : Nat) : NFA (BitVec 0) (Fin (n+2)) where
  start := { 0 }
  accept := { s | wp.final? n s }
  step s₁ _ := { s₂ | if s₁ = Fin.last (n+1) then s₁ = s₂ else s₂ = s₁ + 1 }

Ne in Init.Core

def nonexact_lshr_ne_after := [llvm|
{
^0(%arg153 : i8):
  %0 = llvm.mlir.constant(2 : i8) : i8
  %1 = llvm.icmp "ne" %arg153, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def foo1_and_signbit_lshr_without_shifting_signbit_logical_before := [llvm|
{
^0(%arg115 : i32, %arg116 : i32, %arg117 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(-1 : i32) : i32
  %3 = llvm.mlir.constant(true) : i1
  %4 = llvm.shl %0, %arg116 : i32
  %5 = llvm.and %4, %arg115 : i32
  %6 = llvm.icmp "eq" %5, %1 : i32
  %7 = llvm.shl %arg115, %arg117 : i32
  %8 = llvm.icmp "sgt" %7, %2 : i32
  %9 = "llvm.select"(%6, %3, %8) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%9) : (i1) -> ()
}
]

def testi16i8_ne_before := [llvm|
{
^0(%arg10 : i16):
  %0 = llvm.mlir.constant(8 : i16) : i16
  %1 = llvm.mlir.constant(7 : i8) : i8
  %2 = llvm.lshr %arg10, %0 : i16
  %3 = llvm.trunc %2 : i16 to i8
  %4 = llvm.trunc %arg10 : i16 to i8
  %5 = llvm.ashr %4, %1 : i8
  %6 = llvm.icmp "ne" %5, %3 : i8
  "llvm.return"(%6) : (i1) -> ()
}
]

def PR42691_8_logical_after := [llvm|
{
^0(%arg328 : i32):
  %0 = llvm.mlir.constant(2147483647 : i32) : i32
  %1 = llvm.mlir.constant(-2147483635 : i32) : i32
  %2 = llvm.add %arg328, %0 : i32
  %3 = llvm.icmp "ult" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def t9_ashr_exact_flag_preservation_after := [llvm|
{
^0(%arg25 : i32, %arg26 : i32):
  %0 = llvm.mlir.constant(30 : i32) : i32
  %1 = llvm.ashr exact %arg25, %0 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def visitADD_0 : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%x: i64):
      %c = llvm.mlir.constant (0) : i64
      %0 = llvm.add  %x, %c : i64
      llvm.return %0 : i64
  }]
  rhs := [LV| {
    ^entry (%x: i64):
      llvm.return %x : i64
  }]

def sge_swap_and_max_commute_logical_after := [llvm|
{
^0(%arg240 : i8, %arg241 : i8):
  %0 = llvm.mlir.constant(127 : i8) : i8
  %1 = llvm.icmp "eq" %arg240, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

AList in Mathlib.Data.List.AList

@[simp_denote]
def add_shl_moreOneUse_sh4add_riscv := [LV| {
    ^entry (%a: i64):
    %a0 = "builtin.unrealized_conversion_cast" (%a) : (i64) -> (!i64)
    %0 = ori %a0, 1 : !i64
    %1 = slli %a0, 4 : !i64
    %2 = ori %1, 16 : !i64
    %3 = add %2, %0 : !i64
    %4 = "builtin.unrealized_conversion_cast" (%3) : (!i64) -> (i64)
    llvm.return %4 : i64
  }]

def icmp_slt_0_and_icmp_ne_neg2_i32_fail_before := [llvm|
{
^0(%arg44 : i32):
  %0 = llvm.mlir.constant(-2 : i32) : i32
  %1 = llvm.mlir.constant(31 : i32) : i32
  %2 = llvm.icmp "ne" %arg44, %0 : i32
  %3 = llvm.zext %2 : i1 to i32
  %4 = llvm.lshr %arg44, %1 : i32
  %5 = llvm.and %4, %3 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def PR60818_ne_before := [llvm|
{
^0(%arg5 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.sub %0, %arg5 : i32
  %2 = llvm.icmp "ne" %1, %arg5 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def negate_select_of_op_vs_negated_op_nsw_commuted_after := [llvm|
{
^0(%arg18 : i8, %arg19 : i8, %arg20 : i1):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.sub %0, %arg18 : i8
  %2 = "llvm.select"(%arg20, %1, %arg18) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  %3 = llvm.add %2, %arg19 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

noncomputable def TV_add_fold : PeepholeRewrite (ModArith q) [] .modLike :=
{
  lhs := test_add_fold_LHS,
  rhs := test_add_fold_RHS,
  correct := by admit /- proof elided -/

def prove_exact_with_high_mask_limit_after := [llvm|
{
^0(%arg6 : i8, %arg7 : i8):
  %0 = llvm.mlir.constant(5 : i8) : i8
  %1 = llvm.mlir.constant(0 : i8) : i8
  %2 = llvm.ashr %arg6, %0 : i8
  %3 = llvm.sub %1, %2 overflow<nsw> : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def icmp_mul_nsw_sle_after := [llvm|
{
^0(%arg17 : i8, %arg18 : i8):
  %0 = llvm.icmp "sle" %arg17, %arg18 : i8
  "llvm.return"(%0) : (i1) -> ()
}
]

def bad_add0_after := [llvm|
{
^0(%arg2 : i32, %arg3 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.shl %0, %arg2 overflow<nuw> : i32
  %2 = llvm.add %1, %arg3 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def narrow_zext_ashr_keep_trunc3_before := [llvm|
{
^0(%arg4 : i8, %arg5 : i8):
  %0 = llvm.mlir.constant(1) : i64
  %1 = llvm.sext %arg4 : i8 to i64
  %2 = llvm.sext %arg5 : i8 to i64
  %3 = llvm.add %1, %2 overflow<nsw> : i64
  %4 = llvm.ashr %3, %0 : i64
  %5 = llvm.trunc %4 : i64 to i7
  "llvm.return"(%5) : (i7) -> ()
}
]

instance : Inhabited BVExprWrapper where
  default := {bvExpr := GenBVExpr.const (BitVec.ofNat 0 0), width := 0}

def test9_after := [llvm|
{
^0(%arg111 : i32, %arg112 : i32):
  %0 = llvm.or %arg111, %arg112 : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

def xor_logic_and_or2_after := [llvm|
{
^0(%arg15 : i1, %arg16 : i1, %arg17 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.xor %arg16, %0 : i1
  %2 = "llvm.select"(%arg15, %1, %arg17) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%2) : (i1) -> ()
}
]

def simplify_neg_maxmin : RISCVPeepholeRewrite [Ty.riscv (.bv) ] where
  lhs := [LV| {
    ^entry (%x: !riscv.reg):
      %0 = neg %x : !riscv.reg
      %1 = max %x, %0 : !riscv.reg
      %2 = neg %1 : !riscv.reg
      ret %2 : !riscv.reg
  }]
  rhs := [LV| {
    ^entry (%x: !riscv.reg):
      %0 = neg %x : !riscv.reg
      %1 = min %x, %0 : !riscv.reg
      ret %1 : !riscv.reg
  }]

def ugt_and_not_min_commute_before := [llvm|
{
^0(%arg74 : i8, %arg75 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.icmp "ugt" %arg74, %arg75 : i8
  %2 = llvm.icmp "ne" %arg74, %0 : i8
  %3 = llvm.and %2, %1 : i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def slt_and_not_max_commute_after := [llvm|
{
^0(%arg122 : i8, %arg123 : i8):
  %0 = llvm.icmp "slt" %arg122, %arg123 : i8
  "llvm.return"(%0) : (i1) -> ()
}
]

def test5_before := [llvm|
{
^0(%arg52 : i41):
  %0 = llvm.mlir.constant(32 : i41) : i41
  %1 = llvm.mlir.constant(0 : i41) : i41
  %2 = llvm.and %arg52, %0 : i41
  %3 = llvm.icmp "ne" %2, %1 : i41
  %4 = "llvm.select"(%3, %0, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i41, i41) -> i41
  "llvm.return"(%4) : (i41) -> ()
}
]

def f1_logical_after := [llvm|
{
^0(%arg0 : i32):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.mlir.constant(16711680 : i32) : i32
  %2 = llvm.mlir.constant(0 : i32) : i32
  %3 = llvm.trunc %arg0 : i32 to i8
  %4 = llvm.icmp "ne" %3, %0 : i8
  %5 = llvm.and %arg0, %1 : i32
  %6 = llvm.icmp "ne" %5, %2 : i32
  %7 = llvm.and %4, %6 : i1
  "llvm.return"(%7) : (i1) -> ()
}
]

def lshr_pow2_sgt_before := [llvm|
{
^0(%arg66 : i8):
  %0 = llvm.mlir.constant(-128 : i8) : i8
  %1 = llvm.mlir.constant(3 : i8) : i8
  %2 = llvm.lshr %0, %arg66 : i8
  %3 = llvm.icmp "sgt" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def positive_biggerashr_shlnuw_ashrexact_after := [llvm|
{
^0(%arg30 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.ashr exact %arg30, %0 : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def eq_smax3_after := [llvm|
{
^0(%arg59 : i32, %arg60 : i32):
  %0 = llvm.mlir.constant(3 : i32) : i32
  %1 = llvm.add %arg59, %0 : i32
  %2 = llvm.icmp "sge" %1, %arg60 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

One in Init.Prelude

def positive_with_aggressive_icmp_logical_before := [llvm|
{
^0(%arg55 : i32):
  %0 = llvm.mlir.constant(128 : i32) : i32
  %1 = llvm.mlir.constant(256 : i32) : i32
  %2 = llvm.mlir.constant(512 : i32) : i32
  %3 = llvm.mlir.constant(false) : i1
  %4 = llvm.icmp "ult" %arg55, %0 : i32
  %5 = llvm.add %arg55, %1 : i32
  %6 = llvm.icmp "ult" %5, %2 : i32
  %7 = "llvm.select"(%4, %6, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%7) : (i1) -> ()
}
]

def ashrsgt_02_12_exact_after := [llvm|
{
^0(%arg73 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def rev8_mul_and_lshr_before := [llvm|
{
^0(%arg29 : i8):
  %0 = llvm.mlir.constant(2050) : i64
  %1 = llvm.mlir.constant(139536) : i64
  %2 = llvm.mlir.constant(32800) : i64
  %3 = llvm.mlir.constant(558144) : i64
  %4 = llvm.mlir.constant(65793) : i64
  %5 = llvm.mlir.constant(16) : i64
  %6 = llvm.zext %arg29 : i8 to i64
  %7 = llvm.mul %6, %0 overflow<nsw,nuw> : i64
  %8 = llvm.and %7, %1 : i64
  %9 = llvm.mul %6, %2 overflow<nsw,nuw> : i64
  %10 = llvm.and %9, %3 : i64
  %11 = llvm.or %8, %10 : i64
  %12 = llvm.mul %11, %4 overflow<nsw,nuw> : i64
  %13 = llvm.lshr %12, %5 : i64
  %14 = llvm.trunc %13 : i64 to i8
  "llvm.return"(%14) : (i8) -> ()
}
]

def land_lor_left1_after := [llvm|
{
^0(%arg94 : i1, %arg95 : i1):
  "llvm.return"(%arg94) : (i1) -> ()
}
]

def testtrunclowhigh_before := [llvm|
{
^0(%arg40 : i32, %arg41 : i16, %arg42 : i16):
  %0 = llvm.mlir.constant(128 : i32) : i32
  %1 = llvm.mlir.constant(256 : i32) : i32
  %2 = llvm.mlir.constant(-1 : i32) : i32
  %3 = llvm.add %arg40, %0 : i32
  %4 = llvm.icmp "ult" %3, %1 : i32
  %5 = llvm.trunc %arg40 : i32 to i16
  %6 = llvm.icmp "sgt" %arg40, %2 : i32
  %7 = "llvm.select"(%6, %arg42, %arg41) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i16, i16) -> i16
  %8 = "llvm.select"(%4, %5, %7) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i16, i16) -> i16
  "llvm.return"(%8) : (i16) -> ()
}
]

def or_and3_before := [llvm|
{
^0(%arg104 : i1, %arg105 : i1, %arg106 : i32, %arg107 : i32):
  %0 = llvm.icmp "eq" %arg106, %arg107 : i32
  %1 = llvm.or %arg104, %0 : i1
  %2 = "llvm.select"(%1, %arg104, %arg105) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%2) : (i1) -> ()
}
]

def ashr_ult_12_before := [llvm|
{
^0(%arg84 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(-4 : i4) : i4
  %2 = llvm.ashr %arg84, %0 : i4
  %3 = llvm.icmp "ult" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def not_bool_add_lshr_after := [llvm|
{
^0(%arg12 : i2, %arg13 : i2):
  %0 = llvm.mlir.constant(-1 : i2) : i2
  %1 = llvm.xor %arg12, %0 : i2
  %2 = llvm.icmp "ugt" %arg13, %1 : i2
  %3 = llvm.zext %2 : i1 to i4
  "llvm.return"(%3) : (i4) -> ()
}
]

def c_after := [llvm|
{
^0(%arg0 : i32):
  %0 = llvm.mlir.constant(715827882 : i32) : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

def mkN (fsm : FSM arity) (n : Nat) : KInductionCircuits fsm n :=
  match n with
  | 0 => mkZero
  | n + 1 => mkSucc (mkN fsm n)

def not_true_not_after := [llvm|
{
^0(%arg234 : i1, %arg235 : i1):
  %0 = llvm.mlir.constant(false) : i1
  %1 = llvm.mlir.constant(true) : i1
  %2 = "llvm.select"(%arg234, %arg235, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %3 = llvm.xor %2, %1 : i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def Expr.op : Expr Op T → Op
  | ⟨_, op, _, _⟩ => op

def test_with_5_before := [llvm|
{
^0(%arg315 : i32):
  %0 = llvm.mlir.constant(5 : i32) : i32
  %1 = llvm.mlir.constant(1 : i32) : i32
  %2 = llvm.shl %0, %arg315 : i32
  %3 = llvm.and %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def binop_right_to_zero_mul : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%x: i64):
      %c = llvm.mlir.constant (0) : i64
      %0 = llvm.mul %x, %c: i64
      llvm.return %0 : i64
  }]
  rhs := [LV| {
    ^entry (%x: i64):
      %c = llvm.mlir.constant (0) : i64
      llvm.return %c : i64
  }]

def select_constants_and_icmp_eq0_after := [llvm|
{
^0(%arg46 : i1, %arg47 : i1):
  %0 = llvm.xor %arg46, %arg47 : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

inductive Op (q : Nat) (n : Nat)
  | add : Op q n
  | sub : Op q n
  | mul : Op q n
  | mul_constant : Op q n
    
    
  | leading_term : Op q n
  | monomial : Op q n
  | monomial_mul : Op q n
  | from_tensor : Op q n
  | to_tensor : Op q n
  | const (c : R q n) : Op q n
  | const_int (c : Int) : Op q n
  | const_idx (i : Nat) : Op q n

def sub_const_sub_const_after := [llvm|
{
^0(%arg40 : i32):
  %0 = llvm.mlir.constant(-10 : i32) : i32
  %1 = llvm.add %arg40, %0 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def ashr_ugt_4_before := [llvm|
{
^0(%arg110 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(4 : i4) : i4
  %2 = llvm.ashr %arg110, %0 : i4
  %3 = llvm.icmp "ugt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def fold_mask_cmps_to_false_before := [llvm|
{
^0(%arg111 : i32):
  %0 = llvm.mlir.constant(2147483647 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.and %arg111, %0 : i32
  %3 = llvm.icmp "eq" %2, %1 : i32
  %4 = llvm.icmp "eq" %arg111, %0 : i32
  %5 = llvm.and %4, %3 : i1
  "llvm.return"(%5) : (i1) -> ()
}
]

def select_icmp_sgt_allones_smin_flipped_after := [llvm|
{
^0(%arg2 : i8):
  %0 = llvm.mlir.constant(-128 : i8) : i8
  %1 = llvm.or %arg2, %0 : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def constLLVM23 : Com LLVMPlusRiscV ⟨[]⟩ .pure (.llvm (.bitvec 64)) := [LV| {
  ^entry ():
    %1 = llvm.mlir.constant (23) : i64
    llvm.return %1 : i64
  }]

def trunc_shl_lshr_var_before := [llvm|
{
^0(%arg33 : i64, %arg34 : i64):
  %0 = llvm.mlir.constant(2) : i64
  %1 = llvm.lshr %arg33, %arg34 : i64
  %2 = llvm.shl %1, %0 : i64
  %3 = llvm.trunc %2 : i64 to i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def not_and_and_or_not_or_or_after := [llvm|
{
^0(%arg253 : i32, %arg254 : i32, %arg255 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg255, %arg254 : i32
  %2 = llvm.or %1, %arg253 : i32
  %3 = llvm.xor %2, %0 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def PR38021_before := [llvm|
{
^0(%arg0 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.mlir.constant(-63 : i8) : i8
  %2 = llvm.lshr %arg0, %0 : i8
  %3 = llvm.add %2, %1 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def select_constants_and_icmp_eq0_zero_tval_after := [llvm|
{
^0(%arg34 : i1, %arg35 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = "llvm.select"(%arg34, %0, %arg35) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%1) : (i1) -> ()
}
]

def positive_biggerashr_shlnsw_ashrexact_after := [llvm|
{
^0(%arg35 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.ashr exact %arg35, %0 : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def ashrsgt_02_09_after := [llvm|
{
^0(%arg292 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def or_xor_commute1_before := [llvm|
{
^0(%arg166 : i32, %arg167 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.udiv %0, %arg166 : i32
  %2 = llvm.udiv %0, %arg167 : i32
  %3 = llvm.or %2, %1 : i32
  %4 = llvm.xor %2, %3 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def bools_multi_uses2_logical_after := [llvm|
{
^0(%arg36 : i1, %arg37 : i1, %arg38 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.mlir.constant(false) : i1
  %2 = llvm.xor %arg38, %0 : i1
  %3 = "llvm.select"(%2, %arg36, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %4 = "llvm.select"(%arg38, %arg37, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %5 = "llvm.select"(%arg38, %arg37, %arg36) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %6 = llvm.xor %3, %4 : i1
  %7 = "llvm.select"(%5, %6, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%7) : (i1) -> ()
}
]

def sndVal {Γ} (a : Γ.Var (MLIR2DCPlus.Ty.valuetokenstream r)) : Expr (DCPlus) Γ .pure (.tokenstream) :=
    Expr.mk
    (op := .sndVal r)
    (ty_eq := rfl)
    (eff_le := by admit /- proof elided -/
    )
    (args := .cons a <| .nil)
    (regArgs := .nil)

def slt_zero_eq_ne_0_after := [llvm|
{
^0(%arg6 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.icmp "slt" %arg6, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def test6_before := [llvm|
{
^0(%arg302 : i1):
  %0 = llvm.and %arg302, %arg302 : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def p_constmask_before := [llvm|
{
^0(%arg49 : i32, %arg50 : i32):
  %0 = llvm.mlir.constant(65280 : i32) : i32
  %1 = llvm.mlir.constant(-65281 : i32) : i32
  %2 = llvm.and %arg49, %0 : i32
  %3 = llvm.and %arg50, %1 : i32
  %4 = llvm.add %2, %3 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def t0_before := [llvm|
{
^0(%arg45 : i32, %arg46 : i32, %arg47 : i32, %arg48 : i32):
  %0 = llvm.mlir.constant(false) : i1
  %1 = llvm.mlir.constant(true) : i1
  %2 = llvm.icmp "eq" %arg45, %arg46 : i32
  %3 = llvm.icmp "eq" %arg47, %arg48 : i32
  %4 = "llvm.select"(%3, %2, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %5 = llvm.xor %4, %1 : i1
  "llvm.return"(%5) : (i1) -> ()
}
]

def test8_before := [llvm|
{
^0(%arg21 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.mlir.constant(14 : i32) : i32
  %2 = llvm.icmp "ne" %arg21, %0 : i32
  %3 = llvm.icmp "ult" %arg21, %1 : i32
  %4 = llvm.and %2, %3 : i1
  "llvm.return"(%4) : (i1) -> ()
}
]

List.Subset in Init.Data.List.Basic

def sext_zext_nneg_uge_op0_wide_after := [llvm|
{
^0(%arg26 : i16, %arg27 : i8):
  %0 = llvm.sext %arg27 : i8 to i16
  %1 = llvm.icmp "uge" %arg26, %0 : i16
  "llvm.return"(%1) : (i1) -> ()
}
]

def or_eq_with_one_bit_diff_constants1_logical_before := [llvm|
{
^0(%arg365 : i32):
  %0 = llvm.mlir.constant(50 : i32) : i32
  %1 = llvm.mlir.constant(51 : i32) : i32
  %2 = llvm.mlir.constant(true) : i1
  %3 = llvm.icmp "eq" %arg365, %0 : i32
  %4 = llvm.icmp "eq" %arg365, %1 : i32
  %5 = "llvm.select"(%3, %2, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%5) : (i1) -> ()
}
]

def select_or_disjoint_or_after := [llvm|
{
^0(%arg14 : i32, %arg15 : i1):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.mlir.constant(4 : i32) : i32
  %2 = "llvm.select"(%arg15, %0, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %3 = llvm.shl %arg14, %1 : i32
  %4 = llvm.or disjoint %2, %3 : i32
  %5 = llvm.add %4, %1 overflow<nsw,nuw> : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def not_and_and_or_not_or_or_before := [llvm|
{
^0(%arg253 : i32, %arg254 : i32, %arg255 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.or %arg254, %arg253 : i32
  %2 = llvm.or %1, %arg255 : i32
  %3 = llvm.xor %2, %0 : i32
  %4 = llvm.xor %arg253, %0 : i32
  %5 = llvm.and %4, %arg254 : i32
  %6 = llvm.and %5, %arg255 : i32
  %7 = llvm.or %6, %3 : i32
  "llvm.return"(%7) : (i32) -> ()
}
]

def function : Parser :=
  leading_parser argumentList >> arrow >> termParser

def test9_before := [llvm|
{
^0(%arg91 : i32):
  %0 = llvm.mlir.constant(64 : i32) : i32
  %1 = llvm.mlir.constant(32 : i32) : i32
  %2 = llvm.mul %arg91, %0 : i32
  %3 = llvm.urem %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def basic_preserve_nuw_after := [llvm|
{
^0(%arg13 : i8, %arg14 : i8):
  %0 = llvm.sub %arg13, %arg14 overflow<nuw> : i8
  "llvm.return"(%0) : (i8) -> ()
}
]

def icmp_ne_sext_eq_zero_after := [llvm|
{
^0(%arg25 : i32):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def reassoc_mul_nuw_after := [llvm|
{
^0(%arg24 : i32):
  %0 = llvm.mlir.constant(260 : i32) : i32
  %1 = llvm.mul %arg24, %0 overflow<nuw> : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def or_not_and_commute2_after := [llvm|
{
^0(%arg531 : i32, %arg532 : i32, %arg533 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.sdiv %0, %arg532 : i32
  %3 = llvm.xor %arg533, %2 : i32
  %4 = llvm.xor %arg531, %1 : i32
  %5 = llvm.and %3, %4 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def select_sub_icmp_bad_2_after := [llvm|
{
^0(%arg68 : i32, %arg69 : i32, %arg70 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.icmp "eq" %arg68, %0 : i32
  %3 = llvm.add %arg70, %1 : i32
  %4 = "llvm.select"(%2, %3, %arg69) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def t1_ult_slt_0_after := [llvm|
{
^0(%arg75 : i32, %arg76 : i32, %arg77 : i32):
  %0 = llvm.mlir.constant(-16 : i32) : i32
  %1 = llvm.mlir.constant(127 : i32) : i32
  %2 = llvm.icmp "slt" %arg75, %0 : i32
  %3 = llvm.icmp "sgt" %arg75, %1 : i32
  %4 = "llvm.select"(%2, %arg76, %arg75) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %5 = "llvm.select"(%3, %arg77, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def src_is_mask_const_sle_before := [llvm|
{
^0(%arg46 : i8):
  %0 = llvm.mlir.constant(123 : i8) : i8
  %1 = llvm.mlir.constant(31 : i8) : i8
  %2 = llvm.xor %arg46, %0 : i8
  %3 = llvm.and %2, %1 : i8
  %4 = llvm.icmp "sle" %3, %2 : i8
  "llvm.return"(%4) : (i1) -> ()
}
]

Lean.mkAtom in Init.Prelude

def ashrsgt_02_00_after := [llvm|
{
^0(%arg301 : i4):
  %0 = llvm.mlir.constant(3 : i4) : i4
  %1 = llvm.icmp "sgt" %arg301, %0 : i4
  "llvm.return"(%1) : (i1) -> ()
}
]

@[simp_riscv]
def neg_pseudo (rs1_val : BitVec 64) : BitVec 64 :=
  RV64.sub rs1_val 0

def sle_swap_and_min_logical_after := [llvm|
{
^0(%arg212 : i8, %arg213 : i8):
  %0 = llvm.mlir.constant(-128 : i8) : i8
  %1 = llvm.icmp "eq" %arg212, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def ValueStream := Stream

def ashrsgt_03_02_exact_before := [llvm|
{
^0(%arg67 : i4):
  %0 = llvm.mlir.constant(3 : i4) : i4
  %1 = llvm.mlir.constant(2 : i4) : i4
  %2 = llvm.ashr exact %arg67, %0 : i4
  %3 = llvm.icmp "sgt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def sgt_or_not_min_commute_logical_after := [llvm|
{
^0(%arg24 : i8, %arg25 : i8):
  %0 = llvm.mlir.constant(-128 : i8) : i8
  %1 = llvm.icmp "ne" %arg24, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def scalar_i8_shl_ult_const_3_before := [llvm|
{
^0(%arg17 : i8):
  %0 = llvm.mlir.constant(7 : i8) : i8
  %1 = llvm.mlir.constant(64 : i8) : i8
  %2 = llvm.shl %arg17, %0 : i8
  %3 = llvm.icmp "ult" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def test1_before := [llvm|
{
^0(%arg34 : i32, %arg35 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.udiv %arg34, %arg35 : i32
  %2 = llvm.icmp "eq" %1, %0 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

@[simp_denote]
def zext_riscv_1_to_64 := [LV| {
  ^entry (%arg: i1):
    %0 = "builtin.unrealized_conversion_cast"(%arg) : (i1) -> (!i64)
    %1 = andi %0, 1 : !i64
    %res = "builtin.unrealized_conversion_cast"(%1) : (!i64) -> (i64)
    llvm.return %res : i64
  }]

def lshrult_03_06_exact_after := [llvm|
{
^0(%arg111 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def test21_after := [llvm|
{
^0(%arg146 : i32, %arg147 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg146, %arg147 : i32
  %2 = llvm.xor %1, %0 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def t6_shl_before := [llvm|
{
^0(%arg31 : i32, %arg32 : i32):
  %0 = llvm.mlir.constant(32 : i32) : i32
  %1 = llvm.mlir.constant(-2 : i32) : i32
  %2 = llvm.sub %0, %arg32 : i32
  %3 = llvm.shl %arg31, %2 overflow<nuw> : i32
  %4 = llvm.add %arg32, %1 : i32
  %5 = llvm.shl %3, %4 overflow<nsw> : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def uge_swap_or_max_logical_before := [llvm|
{
^0(%arg164 : i8, %arg165 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.mlir.constant(true) : i1
  %2 = llvm.icmp "ule" %arg165, %arg164 : i8
  %3 = llvm.icmp "eq" %arg164, %0 : i8
  %4 = "llvm.select"(%2, %1, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def sle_swap_or_not_min_after := [llvm|
{
^0(%arg280 : i8, %arg281 : i8):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def ashrslt_02_08_exact_after := [llvm|
{
^0(%arg29 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def ashrsgt_01_13_after := [llvm|
{
^0(%arg304 : i4):
  %0 = llvm.mlir.constant(-5 : i4) : i4
  %1 = llvm.icmp "sgt" %arg304, %0 : i4
  "llvm.return"(%1) : (i1) -> ()
}
]

def select_bittest_to_sub_before := [llvm|
{
^0(%arg4 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(4 : i32) : i32
  %3 = llvm.mlir.constant(3 : i32) : i32
  %4 = llvm.and %arg4, %0 : i32
  %5 = llvm.icmp "eq" %4, %1 : i32
  %6 = "llvm.select"(%5, %2, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%6) : (i32) -> ()
}
]

@[simp_denote]
def slti_llvm := [LV| {
    ^entry (%a: i16):
    %0 = llvm.mlir.constant (2) : i16
    %1 = llvm.icmp.slt %a, %0 : i16
    %2 = llvm.zext %1: i1 to i16
    llvm.return %2 :i16
  }]

def trunc_shl_zext_32_after := [llvm|
{
^0(%arg1 : i32):
  %0 = llvm.mlir.constant(4 : i32) : i32
  %1 = llvm.mlir.constant(65520 : i32) : i32
  %2 = llvm.shl %arg1, %0 : i32
  %3 = llvm.and %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def eq_3210_before := [llvm|
{
^0(%arg126 : i32, %arg127 : i32):
  %0 = llvm.mlir.constant(8 : i32) : i32
  %1 = llvm.mlir.constant(16 : i32) : i32
  %2 = llvm.mlir.constant(24 : i32) : i32
  %3 = llvm.trunc %arg126 : i32 to i8
  %4 = llvm.lshr %arg126, %0 : i32
  %5 = llvm.trunc %4 : i32 to i8
  %6 = llvm.lshr %arg126, %1 : i32
  %7 = llvm.trunc %6 : i32 to i8
  %8 = llvm.lshr %arg126, %2 : i32
  %9 = llvm.trunc %8 : i32 to i8
  %10 = llvm.trunc %arg127 : i32 to i8
  %11 = llvm.lshr %arg127, %0 : i32
  %12 = llvm.trunc %11 : i32 to i8
  %13 = llvm.lshr %arg127, %1 : i32
  %14 = llvm.trunc %13 : i32 to i8
  %15 = llvm.lshr %arg127, %2 : i32
  %16 = llvm.trunc %15 : i32 to i8
  %17 = llvm.icmp "eq" %3, %10 : i8
  %18 = llvm.icmp "eq" %5, %12 : i8
  %19 = llvm.icmp "eq" %7, %14 : i8
  %20 = llvm.icmp "eq" %9, %16 : i8
  %21 = llvm.and %17, %18 : i1
  %22 = llvm.and %19, %21 : i1
  %23 = llvm.and %20, %22 : i1
  "llvm.return"(%23) : (i1) -> ()
}
]

def p_constmask2_before := [llvm|
{
^0(%arg41 : i32, %arg42 : i32):
  %0 = llvm.mlir.constant(61440 : i32) : i32
  %1 = llvm.mlir.constant(-65281 : i32) : i32
  %2 = llvm.and %arg41, %0 : i32
  %3 = llvm.and %arg42, %1 : i32
  %4 = llvm.xor %2, %3 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def pow2_or_zero_is_not_negative_commute_after := [llvm|
{
^0(%arg3 : i8):
  %0 = llvm.mlir.constant(42 : i8) : i8
  %1 = llvm.mlir.constant(-128 : i8) : i8
  %2 = llvm.mul %arg3, %0 : i8
  %3 = llvm.icmp "ne" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

private def neg_constant (w : Nat) :=
  [llvm(w)| {
    %0 = llvm.mlir.constant(-1)
    llvm.return %0
  }]

def liRiscv_31 := [LV| {
  ^entry ():
    %0 = "li"() {imm = -31 : !i64} : (!i64) -> (!i64)
    %1 = "builtin.unrealized_conversion_cast"(%0) : (!i64) -> (i64)
    llvm.return %1 : i64
  }]

def abs_diff_signed_slt_swap_wrong_pred1_before := [llvm|
{
^0(%arg15 : i32, %arg16 : i32):
  %0 = llvm.icmp "eq" %arg15, %arg16 : i32
  %1 = llvm.sub %arg16, %arg15 overflow<nsw> : i32
  %2 = llvm.sub %arg15, %arg16 overflow<nsw> : i32
  %3 = "llvm.select"(%0, %1, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def alive_AddSub_1165_tgt  (w : Nat)  :=
[llvm( w )| {
^bb0(%a : _, %b : _):
  %v1 = llvm.add %a, %b
  %v2 = llvm.mlir.constant 0
  %v3 = llvm.sub %v2, %a
  %v4 = llvm.mlir.constant 0
  %v5 = llvm.sub %v4, %b
  %v6 = llvm.mlir.constant 0
  %v7 = llvm.sub %v6, %v1
  llvm.return %v7
}]

def lt_signed_to_small_unsigned_after := [llvm|
{
^0(%arg50 : i8):
  %0 = llvm.mlir.constant(17 : i8) : i8
  %1 = llvm.icmp "ult" %arg50, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def scalar_i32_lshr_and_negC_eq_nonzero_before := [llvm|
{
^0(%arg0 : i32, %arg1 : i32):
  %0 = llvm.mlir.constant(-2147483648 : i32) : i32
  %1 = llvm.mlir.constant(1 : i32) : i32
  %2 = llvm.lshr %arg0, %arg1 : i32
  %3 = llvm.and %2, %0 : i32
  %4 = llvm.icmp "eq" %3, %1 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def udiv_eq_big_before := [llvm|
{
^0(%arg38 : i8, %arg39 : i8):
  %0 = llvm.mlir.constant(-128 : i8) : i8
  %1 = llvm.udiv %arg38, %arg39 : i8
  %2 = llvm.icmp "eq" %1, %0 : i8
  "llvm.return"(%2) : (i1) -> ()
}
]

def test_add_nsw__nuw_is_safe_after := [llvm|
{
^0(%arg41 : i32):
  %0 = llvm.mlir.constant(2147483647 : i32) : i32
  %1 = llvm.mlir.constant(1 : i32) : i32
  %2 = llvm.and %arg41, %0 : i32
  %3 = llvm.add %2, %1 overflow<nuw> : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def not_logicalOr_not_op1_before := [llvm|
{
^0(%arg50 : i1, %arg51 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.xor %arg51, %0 : i1
  %2 = "llvm.select"(%arg50, %0, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %3 = llvm.xor %2, %0 : i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def visitSUB_XX : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%x: i64):
      %0 = llvm.sub %x, %x : i64
      llvm.return %0 : i64
  }]
  rhs := [LV| {
    ^entry (%x: i64):
      %c = llvm.mlir.constant (0) : i64
      llvm.return %c : i64
  }]

def test_with_even_after := [llvm|
{
^0(%arg313 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

def add_nsw_const_const_sub_nsw_after := [llvm|
{
^0(%arg60 : i8):
  %0 = llvm.mlir.constant(-128 : i8) : i8
  %1 = llvm.sub %0, %arg60 overflow<nsw> : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def getLiveBlockOrUB (p : Pointer) : MemorySSAM LiveBlock := do
  let m ← getThe MemoryState
  let some (.live block) := m[p.id]?
    | throwUB
  return block

def reduce (M : NFA α σ) : NFA α M.Reachable where
  start q :=  M.start q.val
  accept q := M.accept q.val
  step q a q' := M.step q.val a q'.val

def tryFactorization_add_nuw_mul_nuw_mul_var_after := [llvm|
{
^0(%arg3 : i32, %arg4 : i32, %arg5 : i32):
  %0 = llvm.add %arg4, %arg5 : i32
  %1 = llvm.mul %arg3, %0 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def select_icmp_eq_pow2_flipped_before := [llvm|
{
^0(%arg12 : i8):
  %0 = llvm.mlir.constant(4 : i8) : i8
  %1 = llvm.mlir.constant(0 : i8) : i8
  %2 = llvm.and %arg12, %0 : i8
  %3 = llvm.icmp "eq" %2, %1 : i8
  %4 = llvm.xor %arg12, %0 : i8
  %5 = "llvm.select"(%3, %4, %arg12) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%5) : (i8) -> ()
}
]

def scalar_i32_lshr_and_negC_eq_nonzero_after := [llvm|
{
^0(%arg0 : i32, %arg1 : i32):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def add_of_selects_after := [llvm|
{
^0(%arg2 : i1, %arg3 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = "llvm.select"(%arg2, %arg3, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def test1_after := [llvm|
{
^0(%arg34 : i32, %arg35 : i32):
  %0 = llvm.icmp "ugt" %arg35, %arg34 : i32
  "llvm.return"(%0) : (i1) -> ()
}
]

def positive_biggerlshr_shlnsw_before := [llvm|
{
^0(%arg50 : i8):
  %0 = llvm.mlir.constant(6 : i8) : i8
  %1 = llvm.mlir.constant(3 : i8) : i8
  %2 = llvm.lshr %arg50, %0 : i8
  %3 = llvm.shl %2, %1 overflow<nsw> : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def and_nosignbit_select_shl_before := [llvm|
{
^0(%arg44 : i32, %arg45 : i1):
  %0 = llvm.mlir.constant(2147418112 : i32) : i32
  %1 = llvm.mlir.constant(8 : i32) : i32
  %2 = llvm.and %arg44, %0 : i32
  %3 = "llvm.select"(%arg45, %2, %arg44) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %4 = llvm.shl %3, %1 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def xor_icmp_true_unsigned_before := [llvm|
{
^0(%arg7 : i32):
  %0 = llvm.mlir.constant(5 : i32) : i32
  %1 = llvm.mlir.constant(6 : i32) : i32
  %2 = llvm.icmp "ugt" %arg7, %0 : i32
  %3 = llvm.icmp "ult" %arg7, %1 : i32
  %4 = llvm.xor %2, %3 : i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def masked_bit_clear_commute_before := [llvm|
{
^0(%arg77 : i32, %arg78 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(1 : i32) : i32
  %2 = llvm.mlir.constant(0 : i32) : i32
  %3 = llvm.srem %0, %arg77 : i32
  %4 = llvm.shl %1, %arg78 : i32
  %5 = llvm.and %3, %4 : i32
  %6 = llvm.icmp "eq" %5, %2 : i32
  %7 = llvm.zext %6 : i1 to i32
  "llvm.return"(%7) : (i32) -> ()
}
]

BitVec.sub in Init.Data.BitVec.BasicAux

def negative_trunc_not_arg_after := [llvm|
{
^0(%arg22 : i32, %arg23 : i32):
  %0 = llvm.mlir.constant(128 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(256 : i32) : i32
  %3 = llvm.and %arg22, %0 : i32
  %4 = llvm.icmp "eq" %3, %1 : i32
  %5 = llvm.add %arg23, %0 : i32
  %6 = llvm.icmp "ult" %5, %2 : i32
  %7 = llvm.and %4, %6 : i1
  "llvm.return"(%7) : (i1) -> ()
}
]

def lshrugt_02_15_after := [llvm|
{
^0(%arg384 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def urem_constant_dividend_select_of_constants_divisor_0_arm_before := [llvm|
{
^0(%arg23 : i1):
  %0 = llvm.mlir.constant(12 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(42 : i32) : i32
  %3 = "llvm.select"(%arg23, %0, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %4 = llvm.urem %2, %3 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def slt_zero_ult_i1_fail1_after := [llvm|
{
^0(%arg8 : i32, %arg9 : i1):
  %0 = llvm.mlir.constant(30 : i32) : i32
  %1 = llvm.zext %arg9 : i1 to i32
  %2 = llvm.lshr %arg8, %0 : i32
  %3 = llvm.icmp "ugt" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def select_icmp_ne_0_and_4096_or_32_before := [llvm|
{
^0(%arg209 : i32, %arg210 : i32):
  %0 = llvm.mlir.constant(4096 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(32 : i32) : i32
  %3 = llvm.and %arg209, %0 : i32
  %4 = llvm.icmp "ne" %1, %3 : i32
  %5 = llvm.or %arg210, %2 : i32
  %6 = "llvm.select"(%4, %arg210, %5) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def select_icmp_eq_and_4096_0_or_4096_after := [llvm|
{
^0(%arg225 : i32, %arg226 : i32):
  %0 = llvm.mlir.constant(4096 : i32) : i32
  %1 = llvm.and %arg225, %0 : i32
  %2 = llvm.or %arg226, %1 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def and_sel_op0_after := [llvm|
{
^0(%arg17 : i1):
  %0 = llvm.zext %arg17 : i1 to i32
  "llvm.return"(%0) : (i32) -> ()
}
]

def band_land_right1_after := [llvm|
{
^0(%arg34 : i1, %arg35 : i1):
  %0 = llvm.mlir.constant(false) : i1
  %1 = "llvm.select"(%arg34, %arg35, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%1) : (i1) -> ()
}
]

@[simp]
def WidthExpr.ofDep_var {wcard : Nat} {v : Fin wcard} :
    (WidthExpr.ofDep (MultiWidth.WidthExpr.var v)) = (.var v) := rfl

def ult_swap_and_not_max_logical_after := [llvm|
{
^0(%arg100 : i8, %arg101 : i8):
  %0 = llvm.icmp "ugt" %arg101, %arg100 : i8
  "llvm.return"(%0) : (i1) -> ()
}
]

def uge_swap_and_max_commute_before := [llvm|
{
^0(%arg226 : i8, %arg227 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.icmp "ule" %arg227, %arg226 : i8
  %2 = llvm.icmp "eq" %arg226, %0 : i8
  %3 = llvm.and %2, %1 : i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def shl_nsw_add_negative_before := [llvm|
{
^0(%arg45 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.mlir.constant(2 : i32) : i32
  %2 = llvm.add %arg45, %0 : i32
  %3 = llvm.shl %1, %2 overflow<nsw> : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def and_xor_commute3_before := [llvm|
{
^0(%arg151 : i32, %arg152 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.udiv %0, %arg151 : i32
  %2 = llvm.udiv %0, %arg152 : i32
  %3 = llvm.and %2, %1 : i32
  %4 = llvm.xor %3, %2 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def Vars.castLe {n m : Nat} (v : Vars σ ι n) (hnm : n ≤ m) : Vars σ ι m :=
  match v with
  | .state ss => .state (ss.castLe (by admit /- proof elided -/
  ))
  | .inputs is => .inputs (is.castLe hnm)
  | .outputs os =>
    .outputs (os.castLE (by admit /- proof elided -/
    ))

def and_umax_less_after := [llvm|
{
^0(%arg19 : i32):
  %0 = llvm.mlir.constant(-32 : i32) : i32
  %1 = llvm.and %arg19, %0 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def multiuse1_before := [llvm|
{
^0(%arg11 : i32):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.mlir.constant(4 : i32) : i32
  %2 = llvm.mlir.constant(6 : i32) : i32
  %3 = llvm.mlir.constant(1 : i32) : i32
  %4 = llvm.and %arg11, %0 : i32
  %5 = llvm.and %arg11, %1 : i32
  %6 = llvm.shl %4, %2 overflow<nsw,nuw> : i32
  %7 = llvm.lshr exact %4, %3 : i32
  %8 = llvm.shl %5, %2 overflow<nsw,nuw> : i32
  %9 = llvm.lshr exact %5, %3 : i32
  %10 = llvm.or %6, %8 : i32
  %11 = llvm.or %7, %9 : i32
  %12 = llvm.or %11, %10 : i32
  "llvm.return"(%12) : (i32) -> ()
}
]

def or_and_or_pat2_after := [llvm|
{
^0(%arg34 : i8, %arg35 : i8, %arg36 : i8, %arg37 : i8):
  %0 = llvm.mlir.constant(42 : i8) : i8
  %1 = llvm.udiv %0, %arg36 : i8
  %2 = llvm.or %arg37, %arg35 : i8
  %3 = llvm.and %2, %arg34 : i8
  %4 = llvm.or %1, %3 : i8
  "llvm.return"(%4) : (i8) -> ()
}
]

def icmp_sgt10_before := [llvm|
{
^0(%arg15 : i8):
  %0 = llvm.mlir.constant(7 : i8) : i8
  %1 = llvm.mlir.constant(-127 : i8) : i8
  %2 = llvm.shl %arg15, %0 overflow<nsw> : i8
  %3 = llvm.icmp "sgt" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def lshrugt_01_15_exact_before := [llvm|
{
^0(%arg206 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(-1 : i4) : i4
  %2 = llvm.lshr exact %arg206, %0 : i4
  %3 = llvm.icmp "ugt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def nonexact_ashr_eq_before := [llvm|
{
^0(%arg156 : i8):
  %0 = llvm.mlir.constant(-128 : i8) : i8
  %1 = llvm.mlir.constant(-1 : i8) : i8
  %2 = llvm.ashr %0, %arg156 : i8
  %3 = llvm.icmp "eq" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def pr64558_after := [llvm|
{
^0(%arg108 : i1, %arg109 : i1):
  %0 = llvm.or %arg109, %arg108 : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def and_nosignbit_select_ashr_after := [llvm|
{
^0(%arg12 : i32, %arg13 : i1):
  %0 = llvm.mlir.constant(8 : i32) : i32
  %1 = llvm.mlir.constant(8388352 : i32) : i32
  %2 = llvm.ashr %arg12, %0 : i32
  %3 = llvm.and %2, %1 : i32
  %4 = "llvm.select"(%arg13, %3, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%4) : (i32) -> ()
}
]

@[elab_as_elim]
def appendCases
    {motive : (Γ ++ Δ).Var t → Sort u}
    (left : (v : Var Γ t) → motive (appendInl v))
    (right : (v : Var Δ t) → motive (appendInr v)) :
    (v : (Γ ++ Δ).Var t) → motive v
  | ⟨idx, h⟩ =>
    if hv : idx < Γ.length then
      left ⟨idx, by admit /- proof elided -/
      ⟩
    else
      let v' : Var _ _ := ⟨idx - Γ.length, by admit /- proof elided -/
      ⟩
      have eq : v'.appendInr = ⟨idx, h⟩ := by admit /- proof elided -/

@[elab_as_elim, induction_eliminator]
def Valuation.recOn {motive : ∀ {Γ : Ctxt Ty}, Γ.Valuation → Sort*}
    (nil  : motive (Valuation.nil))
    (cons : ∀ {Γ t} (V : Valuation Γ) (v : ⟦t⟧), motive V → motive (v ::ᵥ V)) :
    ∀ {Γ} (V : Valuation Γ), motive V :=

def or_to_nxor3_before := [llvm|
{
^0(%arg89 : i32, %arg90 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.and %arg89, %arg90 : i32
  %2 = llvm.or %arg89, %arg90 : i32
  %3 = llvm.xor %2, %0 : i32
  %4 = llvm.or %3, %1 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def main7e_after := [llvm|
{
^0(%arg54 : i32, %arg55 : i32, %arg56 : i32, %arg57 : i32, %arg58 : i32):
  %0 = llvm.and %arg55, %arg57 : i32
  %1 = llvm.and %arg56, %arg58 : i32
  %2 = llvm.or %0, %1 : i32
  %3 = llvm.and %arg54, %2 : i32
  %4 = llvm.icmp "ne" %3, %2 : i32
  %5 = llvm.zext %4 : i1 to i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def t0_after := [llvm|
{
^0(%arg10 : i64):
  %0 = llvm.mlir.constant(63) : i64
  %1 = llvm.ashr %arg10, %0 : i64
  "llvm.return"(%1) : (i64) -> ()
}
]

def xor_common_op_commute0_before := [llvm|
{
^0(%arg208 : i8, %arg209 : i8):
  %0 = llvm.xor %arg208, %arg209 : i8
  %1 = llvm.or %0, %arg208 : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def autWidth_equiv : (CNFA.autWidth wp n).m.states ≃ (NFA'.autWidth wp n).σ where
  toFun := fun ⟨s, hs⟩ =>
    Fin.mk s (by admit /- proof elided -/
    )
  invFun q := ⟨q.val, by admit /- proof elided -/
  ⟩
  left_inv := by admit /- proof elided -/

def test_add__all_are_safe_after := [llvm|
{
^0(%arg44 : i32):
  %0 = llvm.mlir.constant(1073741823 : i32) : i32
  %1 = llvm.mlir.constant(1 : i32) : i32
  %2 = llvm.and %arg44, %0 : i32
  %3 = llvm.add %2, %1 overflow<nsw,nuw> : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def fold_icmp_shl_nuw_c2_precondition3_before := [llvm|
{
^0(%arg0 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.shl %0, %arg0 overflow<nuw> : i32
  %2 = llvm.icmp "ult" %1, %0 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def ashrslt_01_14_exact_after := [llvm|
{
^0(%arg39 : i4):
  %0 = llvm.mlir.constant(-4 : i4) : i4
  %1 = llvm.icmp "slt" %arg39, %0 : i4
  "llvm.return"(%1) : (i1) -> ()
}
]

def mul_of_pow2_after := [llvm|
{
^0(%arg83 : i32, %arg84 : i8):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def parseIcmpPredicate (n : Int) : AST.ReaderM (MetaLLVM φ) (LLVM.IntPred) := do
  match n with
  | 0 => return .eq
  | 1 => return .ne
  | 8 => return .ugt
  | 9 => return .uge
  | 6 => return .ult
  | 7 => return .ule
  | 4 => return .sgt
  | 5 => return .sge
  | 2 => return .slt
  | 3 => return .sle
  | _ => throw <| .generic s!"The icmp predicate {n} is not supported"

def BoolBinaryRelationKind.toSmtLib : BoolBinaryRelationKind → SexprPBV.BoolBinaryRelationKind
| .eq => .eq

structure Tensor2d' (α : Type) where
  dim₀ : Index
  dim₁ : Index
  mat : Matrix (Fin dim₀) (Fin dim₁) α

def uge_and_max_logical_before := [llvm|
{
^0(%arg236 : i8, %arg237 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.mlir.constant(false) : i1
  %2 = llvm.icmp "uge" %arg236, %arg237 : i8
  %3 = llvm.icmp "eq" %arg236, %0 : i8
  %4 = "llvm.select"(%2, %3, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def main7g_after := [llvm|
{
^0(%arg34 : i32, %arg35 : i32, %arg36 : i32, %arg37 : i32, %arg38 : i32):
  %0 = llvm.and %arg35, %arg37 : i32
  %1 = llvm.and %arg36, %arg38 : i32
  %2 = llvm.or %0, %1 : i32
  %3 = llvm.and %arg34, %2 : i32
  %4 = llvm.icmp "ne" %3, %2 : i32
  %5 = llvm.zext %4 : i1 to i32
  "llvm.return"(%5) : (i32) -> ()
}
]

RV64.ror in RISCV.Instructions

def test13_after := [llvm|
{
^0(%arg0 : i1024):
  %0 = llvm.mlir.constant(1016 : i1024) : i1024
  %1 = llvm.lshr %arg0, %0 : i1024
  "llvm.return"(%1) : (i1024) -> ()
}
]

def masked_icmps_mask_notallzeros_bmask_mixed_6_after := [llvm|
{
^0(%arg80 : i32):
  %0 = llvm.mlir.constant(15 : i32) : i32
  %1 = llvm.mlir.constant(8 : i32) : i32
  %2 = llvm.and %arg80, %0 : i32
  %3 = llvm.icmp "eq" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

@[simp_llvm_option]
def not {w : Nat} (x : IntW w) : IntW w := do
  let x' ← x
  not? x'

def add_nsw_or_and_after := [llvm|
{
^0(%arg11 : i32, %arg12 : i32):
  %0 = llvm.add %arg11, %arg12 overflow<nsw> : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

def or_xor_tree_1111_before := [llvm|
{
^0(%arg0 : i32, %arg1 : i32, %arg2 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mul %arg0, %0 : i32
  %2 = llvm.mul %arg1, %0 : i32
  %3 = llvm.mul %arg2, %0 : i32
  %4 = llvm.xor %2, %1 : i32
  %5 = llvm.xor %3, %2 : i32
  %6 = llvm.xor %1, %5 : i32
  %7 = llvm.or %6, %4 : i32
  "llvm.return"(%7) : (i32) -> ()
}
]

def ashr_slt_exact_before := [llvm|
{
^0(%arg165 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.mlir.constant(10 : i8) : i8
  %2 = llvm.ashr exact %arg165, %0 : i8
  %3 = llvm.icmp "slt" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def masked_or_A_slightly_optimized_logical_after := [llvm|
{
^0(%arg118 : i32):
  %0 = llvm.mlir.constant(-40 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.and %arg118, %0 : i32
  %3 = llvm.icmp "eq" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def add_and_or_after := [llvm|
{
^0(%arg15 : i32, %arg16 : i32):
  %0 = llvm.add %arg15, %arg16 : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

def scalar_i32_lshr_and_negC_slt_before := [llvm|
{
^0(%arg2 : i32, %arg3 : i32):
  %0 = llvm.mlir.constant(-2147483648 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.lshr %arg2, %arg3 : i32
  %3 = llvm.and %2, %0 : i32
  %4 = llvm.icmp "slt" %3, %1 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def only_one_masked_after := [llvm|
{
^0(%arg0 : i64):
  %0 = llvm.mlir.constant(-9223372036854775808) : i64
  %1 = llvm.icmp "eq" %arg0, %0 : i64
  "llvm.return"(%1) : (i1) -> ()
}
]

def test24_before := [llvm|
{
^0(%arg273 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(2 : i32) : i32
  %2 = llvm.icmp "sgt" %arg273, %0 : i32
  %3 = llvm.icmp "ne" %arg273, %1 : i32
  %4 = llvm.and %2, %3 : i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def visitADD_XorNeg1PlusBPlus1 : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64), Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%a: i64, %b: i64):
      %c = llvm.mlir.constant (-1) : i64
      %0 = llvm.xor %a, %c : i64
      %1 = llvm.add %0, %b : i64
      %d = llvm.mlir.constant (1) : i64
      %2 = llvm.add %1, %d : i64
      llvm.return %2 : i64
  }]
  rhs := [LV| {
    ^entry (%a: i64, %b: i64):
      %0 = llvm.sub %b, %a : i64
      llvm.return %0 : i64
  }]

def andi_i64_test : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := andi_llvm_i64
  rhs := andi_riscv_i64

def Substitution.apply (σ : Substitution) (v : VarName) : VarName :=
  match σ.lookup v with
    | some w => w
    | none => v

def const_sub_sub_const_after := [llvm|
{
^0(%arg25 : i32):
  %0 = llvm.mlir.constant(6 : i32) : i32
  %1 = llvm.sub %0, %arg25 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def ult_swap_or_not_max_logical_before := [llvm|
{
^0(%arg36 : i8, %arg37 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.mlir.constant(true) : i1
  %2 = llvm.icmp "ugt" %arg37, %arg36 : i8
  %3 = llvm.icmp "ne" %arg36, %0 : i8
  %4 = "llvm.select"(%2, %1, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def test2_before := [llvm|
{
^0(%arg18 : i8):
  %0 = llvm.mlir.constant(7 : i32) : i32
  %1 = llvm.mlir.constant(3 : i32) : i32
  %2 = llvm.zext %arg18 : i8 to i32
  %3 = llvm.add %2, %0 : i32
  %4 = llvm.ashr %3, %1 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def test_shl__none_are_safe_after := [llvm|
{
^0(%arg64 : i32, %arg65 : i64):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.mlir.constant(-8 : i32) : i32
  %2 = llvm.shl %arg64, %0 : i32
  %3 = llvm.and %2, %1 : i32
  %4 = llvm.zext nneg %3 : i32 to i64
  %5 = llvm.ashr %arg65, %4 : i64
  "llvm.return"(%5) : (i64) -> ()
}
]

def positive_sameconst_shlnuwnsw_lshrexact_before := [llvm|
{
^0(%arg26 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.lshr exact %arg26, %0 : i8
  %2 = llvm.shl %1, %0 overflow<nsw,nuw> : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def and_xor_commute4_after := [llvm|
{
^0(%arg149 : i32, %arg150 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.udiv %0, %arg149 : i32
  %3 = llvm.udiv %0, %arg150 : i32
  %4 = llvm.xor %2, %1 : i32
  %5 = llvm.and %3, %4 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def or_and_shifts2_before := [llvm|
{
^0(%arg13 : i32):
  %0 = llvm.mlir.constant(3 : i32) : i32
  %1 = llvm.mlir.constant(896 : i32) : i32
  %2 = llvm.mlir.constant(4 : i32) : i32
  %3 = llvm.mlir.constant(7 : i32) : i32
  %4 = llvm.shl %arg13, %0 : i32
  %5 = llvm.and %4, %1 : i32
  %6 = llvm.lshr %arg13, %2 : i32
  %7 = llvm.and %6, %3 : i32
  %8 = llvm.or %5, %7 : i32
  "llvm.return"(%8) : (i32) -> ()
}
]

def narrow_zext_or_before := [llvm|
{
^0(%arg50 : i16, %arg51 : i32):
  %0 = llvm.zext %arg50 : i16 to i32
  %1 = llvm.or %0, %arg51 : i32
  %2 = llvm.trunc %1 : i32 to i16
  "llvm.return"(%2) : (i16) -> ()
}
]

def select_icmp_eq_and_1_0_xor_2_after := [llvm|
{
^0(%arg245 : i32, %arg246 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(2 : i32) : i32
  %2 = llvm.shl %arg245, %0 : i32
  %3 = llvm.and %2, %1 : i32
  %4 = llvm.xor %arg246, %3 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def redundant_binop_in_equality_XXorYNeX : LLVMPeepholeRewriteRefine 1 [Ty.llvm (.bitvec 64), Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%x: i64, %y: i64):
      %0 = llvm.xor %x, %y : i64
      %1 = llvm.icmp.ne %0, %x : i64
      llvm.return %1 : i1
  }]
  rhs := [LV| {
    ^entry (%x: i64, %y: i64):
      %0 = llvm.mlir.constant (0) : i64
      %1 = llvm.icmp.ne %y, %0 : i64
      llvm.return %1 : i1
  }]

def n0_after := [llvm|
{
^0(%arg4 : i8):
  %0 = llvm.mlir.constant(-5 : i8) : i8
  %1 = llvm.mlir.constant(0 : i8) : i8
  %2 = llvm.and %arg4, %0 : i8
  %3 = llvm.icmp "eq" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def c_before := [llvm|
{
^0(%arg0 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.mlir.constant(-2147483648 : i32) : i32
  %2 = llvm.mlir.constant(-3 : i32) : i32
  %3 = llvm.sub %0, %1 : i32
  %4 = llvm.sdiv %3, %2 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def or_not_and_commute7_before := [llvm|
{
^0(%arg516 : i32, %arg517 : i32, %arg518 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.or %arg517, %arg516 : i32
  %2 = llvm.xor %1, %0 : i32
  %3 = llvm.and %2, %arg518 : i32
  %4 = llvm.or %arg516, %arg518 : i32
  %5 = llvm.xor %4, %0 : i32
  %6 = llvm.and %5, %arg517 : i32
  %7 = llvm.or %3, %6 : i32
  "llvm.return"(%7) : (i32) -> ()
}
]

def test3_logical_before := [llvm|
{
^0(%arg0 : i32, %arg1 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.mlir.constant(31 : i32) : i32
  %2 = llvm.mlir.constant(true) : i1
  %3 = llvm.sub %arg0, %arg1 overflow<nsw> : i32
  %4 = llvm.icmp "eq" %3, %0 : i32
  %5 = llvm.icmp "eq" %3, %1 : i32
  %6 = "llvm.select"(%4, %2, %5) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%6) : (i1) -> ()
}
]

def ashrsgt_01_05_after := [llvm|
{
^0(%arg312 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def shl1_trunc_sgt4_after := [llvm|
{
^0(%arg15 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(4 : i16) : i16
  %2 = llvm.shl %0, %arg15 overflow<nuw> : i32
  %3 = llvm.trunc %2 : i32 to i16
  %4 = llvm.icmp "sgt" %3, %1 : i16
  "llvm.return"(%4) : (i1) -> ()
}
]

instance : Inhabited (Region φ) where
  default := Region.empty "INHABITANT"

def test_sub_fold_RHS := [mod_arith q, hq| {
  ^bb0():
    %res = mod_arith.constant 6 : !R
    return %res : !R
}]

def test20_before := [llvm|
{
^0(%arg277 : i8):
  %0 = llvm.mlir.constant(7 : i8) : i8
  %1 = llvm.mlir.constant(1 : i8) : i8
  %2 = llvm.lshr %arg277, %0 : i8
  %3 = llvm.and %2, %1 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def test_lshr_exact__exact_is_safe_after := [llvm|
{
^0(%arg62 : i32, %arg63 : i64):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.mlir.constant(15 : i32) : i32
  %2 = llvm.lshr %arg62, %0 : i32
  %3 = llvm.and %2, %1 : i32
  %4 = llvm.zext nneg %3 : i32 to i64
  %5 = llvm.ashr %arg63, %4 : i64
  "llvm.return"(%5) : (i64) -> ()
}
]

def expand_before := [llvm|
{
^0(%arg0 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(2 : i32) : i32
  %2 = llvm.and %arg0, %0 : i32
  %3 = llvm.or %2, %1 : i32
  %4 = llvm.and %3, %0 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

@[simp_denote]
def sll_negative_constant_lhs_llvm_i32 := [LV| {
    ^entry (%a: i32):
    %0 = llvm.mlir.constant (-1) : i32
    %1 = llvm.shl %0, %a : i32
    llvm.return %1 : i32
  }]

def t5_ugt_slt_0_after := [llvm|
{
^0(%arg51 : i32, %arg52 : i32, %arg53 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.mlir.constant(65535 : i32) : i32
  %2 = llvm.icmp "slt" %arg51, %0 : i32
  %3 = llvm.icmp "sgt" %arg51, %1 : i32
  %4 = "llvm.select"(%2, %arg52, %arg51) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %5 = "llvm.select"(%3, %arg53, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def not_or_or_and_not_and_and_commute4_after := [llvm|
{
^0(%arg184 : i32, %arg185 : i32, %arg186 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.sdiv %0, %arg186 : i32
  %3 = llvm.xor %arg184, %1 : i32
  %4 = llvm.xor %2, %arg185 : i32
  %5 = llvm.or %4, %3 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def ult_rem_zero_before := [llvm|
{
^0(%arg174 : i8):
  %0 = llvm.mlir.constant(7 : i8) : i8
  %1 = llvm.mlir.constant(21 : i8) : i8
  %2 = llvm.mul %arg174, %0 overflow<nuw> : i8
  %3 = llvm.icmp "ult" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def ugt_and_not_min_before := [llvm|
{
^0(%arg78 : i8, %arg79 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.icmp "ugt" %arg78, %arg79 : i8
  %2 = llvm.icmp "ne" %arg78, %0 : i8
  %3 = llvm.and %1, %2 : i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def t9_after := [llvm|
{
^0(%arg192 : i8, %arg193 : i8):
  %0 = llvm.sub %arg192, %arg193 : i8
  "llvm.return"(%0) : (i8) -> ()
}
]

def test1_after := [llvm|
{
^0(%arg3 : i33):
  %0 = llvm.mlir.constant(12 : i33) : i33
  %1 = llvm.lshr %arg3, %0 : i33
  "llvm.return"(%1) : (i33) -> ()
}
]

def shl_nuw_add_nuw_before := [llvm|
{
^0(%arg65 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.add %arg65, %0 overflow<nuw> : i32
  %2 = llvm.shl %0, %1 overflow<nuw> : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def lshrult_01_10_exact_before := [llvm|
{
^0(%arg139 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(-6 : i4) : i4
  %2 = llvm.lshr exact %arg139, %0 : i4
  %3 = llvm.icmp "ult" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def negate_lowbitmask_after := [llvm|
{
^0(%arg48 : i8, %arg49 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.mlir.constant(0 : i8) : i8
  %2 = llvm.and %arg48, %0 : i8
  %3 = llvm.icmp "eq" %2, %1 : i8
  %4 = "llvm.select"(%3, %1, %arg49) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%4) : (i8) -> ()
}
]

def lshrugt_03_15_exact_after := [llvm|
{
^0(%arg174 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def urem_common_divisor_before := [llvm|
{
^0(%arg61 : i1, %arg62 : i5, %arg63 : i5, %arg64 : i5):
  %0 = llvm.urem %arg63, %arg62 : i5
  %1 = llvm.urem %arg64, %arg62 : i5
  %2 = "llvm.select"(%arg61, %1, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i5, i5) -> i5
  "llvm.return"(%2) : (i5) -> ()
}
]

private def pretty_test :=
  [llvm()|{
  ^bb0(%arg0: i32):
    %0 = llvm.mlir.constant 8 : i32
    %1 = llvm.add %0, %arg0 : i32
    %2 = llvm.mul %1, %arg0 : i32
    %3 = llvm.not %2 : i32
    llvm.return %3 : i32
  }]

def bitwise_and_bitwise_and_icmps_before := [llvm|
{
^0(%arg244 : i8, %arg245 : i8, %arg246 : i8):
  %0 = llvm.mlir.constant(42 : i8) : i8
  %1 = llvm.mlir.constant(1 : i8) : i8
  %2 = llvm.mlir.constant(0 : i8) : i8
  %3 = llvm.icmp "eq" %arg245, %0 : i8
  %4 = llvm.and %arg244, %1 : i8
  %5 = llvm.shl %1, %arg246 : i8
  %6 = llvm.and %arg244, %5 : i8
  %7 = llvm.icmp "ne" %4, %2 : i8
  %8 = llvm.icmp "ne" %6, %2 : i8
  %9 = llvm.and %3, %7 : i1
  %10 = llvm.and %9, %8 : i1
  "llvm.return"(%10) : (i1) -> ()
}
]

def combined_sdiv_srem := [LV| {
  ^entry (%a: i64, %b: i64):
    %0= llvm.sdiv exact %a, %b : i64
    %1 = llvm.mul %b, %0 : i64
    %2 = llvm.sub %a, %1 : i64
    llvm.return %2 : i64
  }]

def shl_add_nuw_and_nsw_after := [llvm|
{
^0(%arg12 : i8, %arg13 : i8):
  %0 = llvm.mlir.constant(31 : i8) : i8
  %1 = llvm.mlir.constant(2 : i8) : i8
  %2 = llvm.and %arg12, %0 : i8
  %3 = llvm.and %arg13, %1 : i8
  %4 = llvm.shl %2, %3 overflow<nsw,nuw> : i8
  "llvm.return"(%4) : (i8) -> ()
}
]

def test_with_3_before := [llvm|
{
^0(%arg316 : i32):
  %0 = llvm.mlir.constant(3 : i32) : i32
  %1 = llvm.mlir.constant(1 : i32) : i32
  %2 = llvm.shl %0, %arg316 : i32
  %3 = llvm.and %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def select_icmp_ne_pow2_after := [llvm|
{
^0(%arg10 : i8):
  %0 = llvm.mlir.constant(-5 : i8) : i8
  %1 = llvm.and %arg10, %0 : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def not_or_or_and_no_and_commute1_or_after := [llvm|
{
^0(%arg118 : i32, %arg119 : i32, %arg120 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg118, %0 : i32
  %2 = llvm.xor %arg119, %0 : i32
  %3 = llvm.and %arg120, %2 : i32
  %4 = llvm.or %3, %1 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def and_or1_before := [llvm|
{
^0(%arg203 : i1, %arg204 : i1, %arg205 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.xor %arg203, %0 : i1
  %2 = llvm.or %1, %arg205 : i1
  %3 = "llvm.select"(%2, %arg203, %arg204) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%3) : (i1) -> ()
}
]

HShiftLeft.hShiftLeft in Init.Prelude

def t7_after := [llvm|
{
^0(%arg6 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.icmp "slt" %arg6, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def Com.parseFromFile (d : Dialect)
    [DialectSignature d] [TransformTy d 0] [TransformExpr d 0] [TransformReturn d 0]
    (fileName : String) :
    IO (Option (Σ (Γ' : Ctxt d.Ty) (eff : EffectKind) (ty : List d.Ty), Com d Γ' eff ty)) := do
  parseRegionFromFile fileName fun region =>
    let res := mkCom (d:= d) region
    match res with
    | Except.error e => Except.error s!"Error:\n{reprStr e}"
    | Except.ok res => Except.ok res

abbrev falseIffEq (n : Nat) : BitStream := fun i => decide (i != n)

def test13_after := [llvm|
{
^0(%arg7 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.icmp "ugt" %arg7, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def select_1_before := [llvm|
{
^0(%arg87 : i1, %arg88 : i8, %arg89 : i8, %arg90 : i1, %arg91 : i8, %arg92 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.mlir.constant(123 : i8) : i8
  %2 = llvm.mlir.constant(45 : i8) : i8
  %3 = llvm.xor %arg91, %0 : i8
  %4 = llvm.xor %arg92, %1 : i8
  %5 = "llvm.select"(%arg90, %3, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  %6 = llvm.xor %arg88, %2 : i8
  %7 = llvm.xor %arg89, %6 : i8
  %8 = "llvm.select"(%arg87, %7, %5) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  %9 = llvm.xor %8, %0 : i8
  "llvm.return"(%9) : (i8) -> ()
}
]

def p0_after := [llvm|
{
^0(%arg16 : i8):
  %0 = llvm.mlir.constant(4 : i8) : i8
  %1 = llvm.icmp "ult" %arg16, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def nondeterminify2 (f : Stream α → Stream α → Stream α) (x : StreamWithoutNones α × StreamWithoutNones α) : Set (StreamWithoutNones α) :=
  
  
  
  { x1 | ∃ y1 y2, (y1 ∈ StreamWithoutNones.hasStream x.fst)
                  ∧ (y2 ∈ StreamWithoutNones.hasStream x.snd)
                  ∧ Quotient.mk _ (f y1 y2) = x1 }

def lowmask_add_zext_commute_before := [llvm|
{
^0(%arg233 : i16, %arg234 : i32):
  %0 = llvm.mlir.constant(65535 : i32) : i32
  %1 = llvm.mul %arg234, %arg234 : i32
  %2 = llvm.zext %arg233 : i16 to i32
  %3 = llvm.add %1, %2 : i32
  %4 = llvm.and %3, %0 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def test3_after := [llvm|
{
^0(%arg103 : i32):
  %0 = llvm.mlir.constant(7 : i32) : i32
  %1 = llvm.and %arg103, %0 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def trunc_ashr_trunc_exact_after := [llvm|
{
^0(%arg6 : i64):
  %0 = llvm.mlir.constant(8) : i64
  %1 = llvm.lshr exact %arg6, %0 : i64
  %2 = llvm.trunc %1 : i64 to i8
  "llvm.return"(%2) : (i8) -> ()
}
]

Sigma in Init.Core
</all_available_defs>

<all_available_lemmas>
decide_eq_true_iff in Init.PropLemmas
iff_true in Init.SimpLemmas
inf_of_le_left in Mathlib.Order.Lattice
le_refl in Mathlib.Order.Defs.PartialOrder
left_eq_inf in Mathlib.Order.Lattice
not_iff in Mathlib.Logic.Basic
not_le in Mathlib.Order.Defs.LinearOrder
not_lt in Mathlib.Order.Defs.LinearOrder
decide_eq_decide in Init.PropLemmas

theorem scanOr_eq_decide (s : BitStream) (n : Nat) :
    s.scanOr n = decide (∃ (i : Nat), i ≤ n ∧ s i = true)

theorem scanOr_true_iff (s : BitStream) (n : Nat)
    : s.scanOr n = true ↔ ∃ (i : Nat), (i ≤ n) ∧ s i = true

theorem scanOr_false_iff (s : BitStream) (n : Nat) : s.scanOr n = false ↔ ∀ (i : Nat), (hi : i ≤ n) → s i = false

@[simp]
theorem scanOr_succ (s : BitStream) : scanOr s (n+1) = ((s.scanOr n) || s (n + 1))

theorem scanAnd_eq_decide (s : BitStream) (n : Nat) :
    s.scanAnd n = decide (∀ (i : Nat), i ≤ n → s i = true)

theorem scanAnd_true_iff (s : BitStream) (n : Nat) :
    s.scanAnd n = true ↔ ∀ (i : Nat), (hi : i ≤ n) → s i = true

@[simp] theorem scanAnd_succ (s : BitStream) : scanAnd s (n+1) = ((s.scanAnd n) && s (n + 1))

theorem test_logical_or_eq_a_b_thm (e e_1 : IntW 8) (e_2 : IntW 1) :
  select (select e_2 (const? 1 1) (icmp IntPred.eq e_1 e)) e_1 e ⊑ select e_2 e_1 e

theorem not_lshr_thm.extracted_1._1 : ∀ (x : BitVec 8), ¬5#8 ≥ ↑8 → x >>> 5#8 ^^^ 7#8 = (x ^^^ -1#8) >>> 5#8

theorem trunc_shl_ashr_infloop_thm.extracted_1._2 : ∀ (x : BitVec 64),
  ¬(3#64 ≥ ↑64 ∨ 2#64 ≥ ↑64) →
    ¬1#64 ≥ ↑64 → truncate 32 (x.sshiftRight' 3#64 <<< 2#64) = truncate 32 (x >>> 1#64) &&& BitVec.ofInt 32 (-4)

theorem logical_or_logical_or_icmps_comm1_thm.extracted_1._5 : ∀ (x x_1 x_2 : BitVec 8),
  ¬x_1 ≥ ↑8 →
    ¬(ofBool (x_2 &&& 1#8 <<< x_1 == 0#8) = 1#1 ∨ ofBool (x == 42#8) = 1#1) →
      ¬(True ∧ 1#8 <<< x_1 >>> x_1 ≠ 1#8 ∨ x_1 ≥ ↑8) →
        ofBool (x_2 &&& 1#8 <<< x_1 == 0#8) = 1#1 → True → ofBool (x_2 &&& 1#8 == 0#8) = 1#1

theorem and_ne_with_diff_one_logical_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬ofBool (x != 40#32) = 1#1 → 0#1 = ofBool (x + BitVec.ofInt 32 (-41) <ᵤ BitVec.ofInt 32 (-2))

theorem from_poly_zero : R.fromPoly (0 : (ZMod q)[X]) (n := n) = (0 : R q n)

theorem bools2_logical_commute1_and1_thm.extracted_1._2 : ∀ (x x_1 : BitVec 1), x_1 &&& x = 1#1 → ¬x = 1#1 → False

@[simp] theorem HVector.denote_nil
    (T : HVector (fun (t : Ctxt d.Ty × List d.Ty) => Com d t.1 .impure t.2) []) :
    HVector.denote T = HVector.nil

theorem sge_and_max_commute_logical_proof : sge_and_max_commute_logical_before ⊑ sge_and_max_commute_logical_after

theorem ashrsgt_02_04_exact_thm (e : IntW 4) :
  icmp IntPred.sgt (ashr e (const? 4 2) { «exact» := true }) (const? 4 4) ⊑ const? 1 0

theorem main7f_logical_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 32),
  ¬ofBool (x_2 &&& x_1 == x &&& (x_2 &&& x_1)) = 1#1 →
    ofBool (x_2 &&& x_1 != x &&& (x_2 &&& x_1)) = 1#1 → 0#1 = 1#1 → 0#32 = zeroExtend 32 1#1

theorem t6_no_extrause_thm (e e_1 : IntW 8) :
  icmp IntPred.uge (add e_1 e) e ⊑ icmp IntPred.ule e_1 (LLVM.xor e (const? 8 (-1)))

theorem bools2_logical_commute1_and1_and2_proof : bools2_logical_commute1_and1_and2_before ⊑ bools2_logical_commute1_and1_and2_after

theorem icmp_ne_and1_lshr_pow2_proof : icmp_ne_and1_lshr_pow2_before ⊑ icmp_ne_and1_lshr_pow2_after

theorem sgt_positive_multip_rem_nz_thm (e : IntW 8) :
  icmp IntPred.sgt (mul e (const? 8 5) { «nsw» := true, «nuw» := false }) (const? 8 21) ⊑
    icmp IntPred.sgt e (const? 8 4)

theorem lshrult_03_03_proof : lshrult_03_03_before ⊑ lshrult_03_03_after

theorem add_f_eq (a : R q n) : a + (f q n) = a

theorem ashrslt_03_04_exact_thm (e : IntW 4) :
  icmp IntPred.slt (ashr e (const? 4 3) { «exact» := true }) (const? 4 4) ⊑ const? 1 1

theorem select_constants_and_icmp_eq0_common_bit_thm.extracted_1._2 : ∀ (x x_1 : BitVec 1),
  x_1 = 1#1 → ¬x = 1#1 → ofBool (2#8 &&& 3#8 == 0#8) = 0#1

theorem src_is_mask_zext_thm (e : IntW 8) (e_1 : IntW 16) :
  icmp IntPred.eq (LLVM.and (LLVM.xor e_1 (const? 16 123)) (zext 16 (lshr (const? 8 (-1)) e)))
      (LLVM.xor e_1 (const? 16 123)) ⊑
    icmp IntPred.ule (LLVM.xor e_1 (const? 16 123)) (zext 16 (lshr (const? 8 (-1)) e))

theorem shift_xor_multiuse_or_thm (e e_1 : IntW 32) :
  mul (select (icmp IntPred.ne (const? 32 0) (LLVM.and e_1 (const? 32 4096))) e (LLVM.or e (const? 32 2048)))
      (LLVM.or e (const? 32 2048)) ⊑
    mul (select (icmp IntPred.eq (LLVM.and e_1 (const? 32 4096)) (const? 32 0)) (LLVM.or e (const? 32 2048)) e)
      (LLVM.or e (const? 32 2048))

theorem src_x_and_nmask_uge_thm.extracted_1._1 : ∀ (x : BitVec 1) (x_1 : BitVec 8),
  ¬x = 1#1 → x ^^^ 1#1 = 1#1 → ofBool (0#8 ≤ᵤ x_1 &&& 0#8) = 1#1

theorem and_slt_to_mask_proof : and_slt_to_mask_before ⊑ and_slt_to_mask_after

theorem e_599 :
    2 *  ~~~y + 4 * y - 5 *  ~~~(x &&& y) + 2 * (x ^^^ y) + 7 * (x ||| y) + 4 *  ~~~(x &&&  ~~~x) - 2 *  ~~~(x ||| y) - 12 *  ~~~(x |||  ~~~y) - 11 * (x &&&  ~~~y) - 16 * (x &&& y) =  - 1 * (x |||  ~~~y)

theorem sel_sext_thm.extracted_1._1 : ∀ (x : BitVec 1), ¬x = 1#1 → signExtend 64 42#32 = 42#64

theorem and_logic_and_logic_or_8_thm.extracted_1._2 : ∀ (x x_1 : BitVec 1), x_1 = 1#1 → x = 1#1 → 1#1 = x &&& 1#1

theorem narrow_zext_ashr_keep_trunc_proof : narrow_zext_ashr_keep_trunc_before ⊑ narrow_zext_ashr_keep_trunc_after

theorem gt_unsigned_to_large_negative_proof : gt_unsigned_to_large_negative_before ⊑ gt_unsigned_to_large_negative_after

theorem not_zext_thm.extracted_1._1 : ∀ (x : BitVec 1), x = 1#1 → 0#999 = zeroExtend 999 (x ^^^ 1#1)

theorem p_commutative0_proof : p_commutative0_before ⊑ p_commutative0_after

theorem in_constant_mone_vary_invmask_thm (e e_1 : IntW 4) :
  LLVM.xor (LLVM.and (LLVM.xor (const? 4 (-1)) e_1) (LLVM.xor e (const? 4 (-1)))) e_1 ⊑
    LLVM.or e_1 (LLVM.xor e (const? 4 (-1)))

theorem alive_805 : forall (w : Nat) (X : Bitvec 1)
, TSSA.eval
  (Op := Op) (e := e)
  (i := TSSAIndex.STMT (UserType.base (BaseType.bitvec w)))
  [dsl_bb|
  ^bb
  %v0 := unit: ;
  %v1 := op:const (1) %v0;
  %v2 := op:const (X) %v0;
  %v3 := pair:%v1 %v2;
  %v4 := op:sdiv w %v3
  dsl_ret %v4
  ]  ⊑
  TSSA.eval
  (Op := Op) (e := e)
  (i := TSSAIndex.STMT (UserType.base (BaseType.bitvec w)))
  [dsl_bb|
  ^bb
  %v0 := unit: ;
  %v1 := op:const (X) %v0;
  %v2 := op:const (1) %v0;
  %v3 := pair:%v1 %v2;
  %v4 := op:add w %v3;
  %v5 := op:const (Bitvec.ofInt w (3)) %v0;
  %v6 := pair:%v4 %v5;
  %v7 := op:icmp ult  w %v6;
  %v8 := op:const (0) %v0;
  %v9 := triple:%v7 %v1 %v8;
  %v10 := op:select w %v9
  dsl_ret %v10
  ]

theorem e_2269 :
     - 6 * (d ^^^ (e &&& f)) - 1 * ((d &&& f) ^^^ (d ^^^ (e &&& f))) - 1 *  ~~~(e |||  ~~~f) - 1 * ((d |||  ~~~e) &&& (d ^^^ (e ^^^ f))) - 1 * ((d |||  ~~~e) &&&  ~~~(d ^^^ (e ^^^ f))) + 2 * ((d &&& e) ^^^ (e |||  ~~~f)) - 1 * ((d &&& e) |||  ~~~(e ^^^ f)) + 2 * ((d &&& e) |||  ~~~(e ||| f)) - 2 * (f ^^^ ( ~~~d ||| (e ||| f))) - 6 * ((d &&&  ~~~e) |||  ~~~(d ^^^ (e ^^^ f))) - 11 * ((d |||  ~~~e) &&& (e ^^^ f)) + 1 * (e ||| f) - 2 *  ~~~( ~~~d ||| (e &&& f)) - 2 * (e ^^^ (d ||| (e &&& f))) + 5 * (e ||| (d &&&  ~~~f)) + 11 * (e ^^^  ~~~( ~~~d ||| (e &&& f))) - 2 * ( ~~~(d &&&  ~~~e) &&& (e ^^^ f)) + 3 *  ~~~( ~~~d &&& ( ~~~e ||| f)) + 7 * (f ^^^  ~~~(d &&& ( ~~~e ||| f))) + 11 * (e ^^^  ~~~(d ||| (e ^^^ f))) - 3 * (e ||| (d &&& f)) + 1 * (e ^^^ (d &&&  ~~~f)) + 1 * (e ^^^  ~~~(d &&& (e ^^^ f))) + 11 * (e ^^^  ~~~(d ||| (e &&& f))) + 1 *  ~~~(d &&& f) + 11 * (f ^^^  ~~~(d &&&  ~~~e)) + 7 *  ~~~(d ||| (e ^^^ f)) - 1 * (f |||  ~~~(d |||  ~~~e)) + 1 * ( ~~~e &&& (d ^^^ f)) + 3 *  ~~~(d ^^^ e) + 7 * (e &&& f) + 7 * (d &&& e) + 2 * (d &&& (e ||| f)) + 1 * (e ^^^  ~~~(d &&& ( ~~~e &&& f))) - 6 * (e ^^^  ~~~( ~~~d &&& ( ~~~e ||| f))) - 1 * (f ^^^  ~~~(d ||| (e &&& f))) - 6 * ( ~~~d &&& (e ||| f)) + 5 * (f ^^^ (d ||| (e &&& f))) - 5 * (d &&& ( ~~~e ||| f)) + 3 *  ~~~d + 5 * ((d &&& f) ^^^  ~~~(d ^^^ (e &&& f))) - 11 *  ~~~(d &&& (e ||| f)) + 2 * (e ^^^ ( ~~~d ||| (e ||| f))) - 7 * (f ||| (d &&&  ~~~e)) - 2 * ((d ^^^ e) &&&  ~~~(d ^^^ f)) - 5 * ( ~~~d ||| ( ~~~e ||| f)) - 3 * (e ^^^ (d ||| (e ||| f))) + 4 *  ~~~( ~~~d &&& (e ^^^ f)) + 2 *  ~~~(d &&&  ~~~f) + 3 * ( ~~~d ||| (e &&& f)) + 1 * ( ~~~d ||| (e ^^^ f)) - 49 *  ~~~(d ||| (e ||| f)) - 31 *  ~~~(d ||| ( ~~~e ||| f)) + 19 *  ~~~( ~~~d ||| (e ||| f)) - 39 *  ~~~( ~~~d ||| ( ~~~e ||| f)) + 8 * ( ~~~d &&& ( ~~~e &&& f)) - 4 * ( ~~~d &&& (e &&& f)) + 13 * (d &&& ( ~~~e &&& f)) - 54 * (d &&& (e &&& f)) = 1 * (e |||  ~~~(d ||| f))

theorem xor_logic_and_logic_or4_proof : xor_logic_and_logic_or4_before ⊑ xor_logic_and_logic_or4_after

theorem urem_illegal_type_thm.extracted_1._2 : ∀ (x x_1 : BitVec 9),
  ¬zeroExtend 32 x = 0 → ¬x = 0 → zeroExtend 32 x_1 % zeroExtend 32 x = zeroExtend 32 (x_1 % x)

theorem ashr_C1_add_A_C2_i32_proof : ashr_C1_add_A_C2_i32_before ⊑ ashr_C1_add_A_C2_i32_after

theorem test6_thm.extracted_1._1 : ∀ (x : BitVec 64),
  ¬32#128 ≥ ↑128 → 32#64 ≥ ↑64 ∨ True ∧ zeroExtend 64 (truncate 32 (x >>> 32#64)) ≠ x >>> 32#64 → False

theorem test_proof : test_before ⊑ test_after

theorem BitVec.add_getElem_succ (x y : BitVec w) (hw : i + 1 < w) : (x + y)[i + 1] =
    (x[i + 1] ^^ (y[i + 1]) ^^ BitVec.carry (i + 1) x y false)

theorem main3f_like_logical_thm.extracted_1._2 : ∀ (x x_1 : BitVec 32),
  ofBool (x_1 &&& x != 0#32) = 1#1 → ofBool (x_1 &&& x == 0#32) = 1#1 → ¬True → False

theorem fold_icmp_shl_nuw_c3_thm (e : IntW 32) :
  icmp IntPred.uge (shl (const? 32 48) e { «nsw» := false, «nuw» := true }) (const? 32 144) ⊑
    icmp IntPred.ugt e (const? 32 1)

theorem test_thm (e : IntW 32) :
  LLVM.and (icmp IntPred.sgt e (const? 32 (-1))) (icmp IntPred.eq e (const? 32 1)) ⊑
    icmp IntPred.eq e (const? 32 1)

@[simp] theorem nxor_eq : (x.nxor y) i = (x i == y i)

theorem e_1542 :
     - 7 * (a &&& c) - 5 * ((a |||  ~~~b) &&&  ~~~(a ^^^ (b ^^^ c))) + 1 * ( ~~~(a ||| b) ||| (a ^^^ (b ^^^ c))) - 6 * (b ^^^  ~~~(a ||| (b ^^^ c))) - 1 * ((a &&& c) ^^^  ~~~(a ^^^ ( ~~~b &&& c))) + 11 *  ~~~(a ||| (b ||| c)) + 6 *  ~~~(a ||| ( ~~~b ||| c)) - 1 *  ~~~( ~~~a ||| (b ||| c)) + 11 *  ~~~( ~~~a ||| ( ~~~b ||| c)) - 1 * ( ~~~a &&& ( ~~~b &&& c)) + 1 * ( ~~~a &&& (b &&& c)) + 12 * (a &&& ( ~~~b &&& c)) =  - 13 * (a &&& (b &&& c))

theorem icmp_eq_select_thm (e e_1 : IntW 32) (e_2 : IntW 1) :
  icmp IntPred.eq (select e_2 e_1 e) (select e_2 e e_1) ⊑ icmp IntPred.eq e_1 e

theorem mul_sel_op0_thm.extracted_1._1 : ∀ (x : BitVec 32) (x_1 : BitVec 1), x_1 = 1#1 → 0#32 * x = 0#32

theorem shl_shl_constants_div_thm (e e_1 : IntW 32) :
  LLVM.udiv e_1 (shl (shl (const? 32 1) e) (const? 32 2)) ⊑ lshr e_1 (add e (const? 32 2))

theorem foo_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬(-1#32 == 0 || 32 != 1 && x == intMin 32 && -1#32 == -1) = true → ofBool (x.srem (-1#32) == 0#32) = 1#1

theorem e_1598 :
    1 * ( ~~~b &&& (a ^^^ c)) - 11 * ((a ||| b) &&& (b ^^^ c)) - 3 * ( ~~~(a |||  ~~~b) ||| (b ^^^ c)) + 7 * ( ~~~(a &&&  ~~~b) &&&  ~~~(a ^^^ (b ^^^ c))) - 3 * (c ^^^  ~~~(a &&& (b &&& c))) + 4 * ( ~~~b |||  ~~~(a ^^^ c)) + 11 * (b ^^^  ~~~(a &&& (b &&& c))) + 1 * (a &&& ( ~~~b ||| c)) - 11 * ((a &&& b) |||  ~~~(b ||| c)) + 2 * (b ^^^ c) + 1 * (c ^^^ ( ~~~a ||| (b ||| c))) - 10 *  ~~~(a ||| (b ||| c)) - 3 *  ~~~( ~~~a ||| (b ||| c)) + 18 *  ~~~( ~~~a ||| ( ~~~b ||| c)) - 15 * ( ~~~a &&& ( ~~~b &&& c)) - 5 * ( ~~~a &&& (b &&& c)) - 4 * (a &&& ( ~~~b &&& c)) - 2 * (a &&& (b &&& c)) =  - 1 *  ~~~(a ||| (b ^^^ c)) - 10 *  ~~~(a ||| ( ~~~b ||| c))

theorem t2_thm (e : IntW 64) : sub (const? 64 0) (ashr e (const? 64 63)) ⊑ lshr e (const? 64 63)

theorem PR42691_3_thm (e : IntW 32) :
  LLVM.or (icmp IntPred.sge e (const? 32 0)) (icmp IntPred.eq e (const? 32 (-2147483648))) ⊑
    icmp IntPred.ult e (const? 32 (-2147483647))

theorem main12_logical_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ofBool (truncate 16 x <ₛ 0#16) = 1#1 → ofBool (x &&& 32896#32 == 0#32) = 1#1 → ¬True → 2#32 = 1#32

theorem add_five (x : BitVec w) : (x + x) + (x + x) + x = x + x + x + x + x

theorem a_true_implies_b_true2_comm_thm.extracted_1._4 : ∀ (x : BitVec 1) (x_1 : BitVec 8),
  ¬ofBool (10#8 <ᵤ x_1) = 1#1 → ¬ofBool (20#8 <ᵤ x_1) = 1#1 → x &&& ofBool (20#8 <ᵤ x_1) = 0#1

theorem t0_thm.extracted_1._25 : ∀ (x x_1 x_2 x_3 : BitVec 8) (x_4 : BitVec 1),
  x_4 ^^^ 1#1 = 1#1 → x_4 = 1#1 → True → ofBool (x_3 != x_2) = 1#1 → x_1 = x

@[simp]
theorem shiftLeft_and_distrib' {x y : BitVec w} {n m : Nat} :
    x <<< n &&& y <<< (m + n) = (x &&& y <<< m) <<< n

theorem a_false_implies_b_false2_thm (e e_1 : IntW 1) (e_2 : IntW 8) :
  LLVM.or (icmp IntPred.ugt e_2 (const? 8 10)) (select (icmp IntPred.ugt e_2 (const? 8 20)) e_1 e) ⊑
    select (icmp IntPred.ugt e_2 (const? 8 10)) (const? 1 1) e

theorem foo_thm.extracted_1._1 : ∀ (x x_1 : BitVec 64),
  zeroExtend 64 (truncate 32 x_1 &&& truncate 32 x) = x_1 &&& x &&& 4294967295#64

theorem select_icmp_ne_0_and_32_or_4096_thm.extracted_1._3 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (0#32 != x_1 &&& 32#32) = 1#1 → 7#32 ≥ ↑32 → False

theorem positive_trunc_base_logical_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (-1#16 <ₛ truncate 16 x) = 1#1 → ofBool (truncate 16 x + 128#16 <ᵤ 256#16) = ofBool (x &&& 65408#32 == 0#32)

theorem nonexact_ashr_ne_proof : nonexact_ashr_ne_before ⊑ nonexact_ashr_ne_after

theorem sge_and_max_commute_logical_thm.extracted_1._3 : ∀ (x x_1 : BitVec 8),
  ¬ofBool (x_1 == 127#8) = 1#1 → 0#1 = ofBool (x_1 == 127#8)

theorem test4_proof : test4_before ⊑ test4_after

theorem hoist_ashr_ahead_of_sext_1_proof : hoist_ashr_ahead_of_sext_1_before ⊑ hoist_ashr_ahead_of_sext_1_after

theorem positive_trunc_base_logical_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (-1#16 <ₛ truncate 16 x) = 1#1 → ofBool (truncate 16 x + 128#16 <ᵤ 256#16) = ofBool (x &&& 65408#32 == 0#32)

theorem test_proof : test_before ⊑ test_after

theorem src3_proof : src3_before ⊑ src3_after

theorem e_375 :
    3 * y - 7 *  ~~~y + 2 * (x ^^^ y) - 11 *  ~~~x + 3 * x + 7 *  ~~~(x ||| y) - 5 *  ~~~(x |||  ~~~y) - 17 * (x &&& y) =  - 2 * (x &&&  ~~~y) - 11 *  ~~~(x &&&  ~~~y)

theorem neg_sgt_42_proof : neg_sgt_42_before ⊑ neg_sgt_42_after

theorem t0_proof : t0_before ⊑ t0_after

theorem and_not_or_wrong_c_proof : and_not_or_wrong_c_before ⊑ and_not_or_wrong_c_after

theorem alive_AndOrXor_1294_A__B__A__B___A__B  (w : Nat)   : alive_AndOrXor_1294_A__B__A__B___A__B_src w  ⊑ alive_AndOrXor_1294_A__B__A__B___A__B_tgt w

theorem neg_mask_thm.extracted_1._1 : ∀ (x : BitVec 16) (x_1 : BitVec 32),
  ¬(True ∧ x_1.ssubOverflow (signExtend 32 x) = true ∨
        15#16 ≥ ↑16 ∨ True ∧ (0#32).ssubOverflow (zeroExtend 32 (x >>> 15#16)) = true) →
    ofBool (x <ₛ 0#16) = 1#1 → True ∧ x_1.ssubOverflow (signExtend 32 x) = true → False

theorem lshrugt_01_15_proof : lshrugt_01_15_before ⊑ lshrugt_01_15_after

theorem testi32i8_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬(7#8 ≥ ↑8 ∨ 8#32 ≥ ↑32) →
    ¬ofBool ((truncate 8 x).sshiftRight' 7#8 == truncate 8 (x >>> 8#32)) = 1#1 →
      ¬15#32 ≥ ↑32 → truncate 8 (x.sshiftRight' 15#32) ^^^ 127#8 = truncate 8 (x >>> 15#32) ^^^ 127#8

theorem bools2_logical_commute2_proof : bools2_logical_commute2_before ⊑ bools2_logical_commute2_after

theorem sge_swap_or_not_max_commute_logical_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ¬ofBool (x_1 != 127#8) = 1#1 → ofBool (x ≤ₛ x_1) = 1#1

theorem test3_thm.extracted_1._4 : ∀ (x : BitVec 1) (x_1 : BitVec 59),
  ¬x = 1#1 → ¬4096#59 = 0 → ¬12#59 ≥ ↑59 → x_1 / 4096#59 = x_1 >>> 12#59

theorem ashr_bitwidth_mask_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ¬7#8 ≥ ↑8 → ofBool (x_1 <ₛ 0#8) = 1#1 → x_1.sshiftRight' 7#8 &&& x = x

theorem test18_thm (e : IntW 16) (e_1 : IntW 32) :
  urem e_1 (select (icmp IntPred.ne (LLVM.and e (const? 16 4)) (const? 16 0)) (const? 32 32) (const? 32 64)) ⊑
    LLVM.and e_1
      (select (icmp IntPred.eq (LLVM.and e (const? 16 4)) (const? 16 0)) (const? 32 63) (const? 32 31))

theorem band_land_left2_thm.extracted_1._2 : ∀ (x x_1 : BitVec 1), ¬x_1 &&& x = 1#1 → 0#1 = x_1 &&& x

theorem or_logic_or_logic_and_1_proof : or_logic_or_logic_and_1_before ⊑ or_logic_or_logic_and_1_after

theorem main8_proof : main8_before ⊑ main8_after

theorem udiv_i8_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8), ¬zeroExtend 32 x = 0 → x = 0 → False

theorem ashr_ult_14_proof : ashr_ult_14_before ⊑ ashr_ult_14_after

theorem test15f_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ofBool (x &&& 128#32 != 0#32) = 1#1 → ¬1#32 ≥ ↑32 → 0#32 = x <<< 1#32 &&& 256#32 ^^^ 256#32

theorem main5c_like_logical_thm.extracted_1._7 : ∀ (x x_1 : BitVec 32),
  ofBool (x_1 &&& 7#32 != 7#32) = 1#1 → ¬ofBool (x_1 &&& 7#32 == 7#32) = 1#1 → True → 0#32 = zeroExtend 32 0#1

theorem test10_proof : test10_before ⊑ test10_after

theorem ashr_lshr_cst_proof : ashr_lshr_cst_before ⊑ ashr_lshr_cst_after

theorem e_85 :
    1 *  ~~~y + 2 * (x |||  ~~~y) - 4 *  ~~~(x ||| y) - 3 * (x &&&  ~~~y) - 2 * (x &&& y) =  - 1 *  ~~~x + 1 *  ~~~(x |||  ~~~y)

theorem sgt_smax4_proof : sgt_smax4_before ⊑ sgt_smax4_after

theorem uge_swap_or_max_commute_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ofBool (x_1 == -1#8) ||

theorem nomask_rhs_logical_proof : nomask_rhs_logical_before ⊑ nomask_rhs_logical_after

theorem scalar_i8_shl_ult_const_2_proof : scalar_i8_shl_ult_const_2_before ⊑ scalar_i8_shl_ult_const_2_after

theorem test_proof : test_before ⊑ test_after

theorem a_true_implies_b_true2_comm_thm (e e_1 : IntW 1) (e_2 : IntW 8) :
  LLVM.and (select (icmp IntPred.ugt e_2 (const? 8 10)) e_1 e) (icmp IntPred.ugt e_2 (const? 8 20)) ⊑
    select (icmp IntPred.ugt e_2 (const? 8 20)) e_1 (const? 1 0)

theorem foo4_proof : foo4_before ⊑ foo4_after

theorem or_test2_proof : or_test2_before ⊑ or_test2_after

theorem ugt_and_min_commute_proof : ugt_and_min_commute_before ⊑ ugt_and_min_commute_after

theorem select_icmp_slt_zero_smin_flipped_proof : select_icmp_slt_zero_smin_flipped_before ⊑ select_icmp_slt_zero_smin_flipped_after

theorem or_not_and_commute6_thm (e e_1 e_2 : IntW 32) :
  LLVM.or (LLVM.and (LLVM.xor (LLVM.or e_2 e_1) (const? 32 (-1))) e)
      (LLVM.and (LLVM.xor (LLVM.or e e_2) (const? 32 (-1))) e_1) ⊑
    LLVM.and (LLVM.xor e_1 e) (LLVM.xor e_2 (const? 32 (-1)))

theorem and_logic_and_logic_or_2_thm.extracted_1._5 : ∀ (x x_1 x_2 : BitVec 1),
  ¬x_2 &&& x_1 = 1#1 → x = 1#1 → x_2 = 1#1 → x_1 = 1#1 → x_2 = 1#1

theorem nonexact_ashr_eq_noexactlog_proof : nonexact_ashr_eq_noexactlog_before ⊑ nonexact_ashr_eq_noexactlog_after

theorem arbitrary_mask_sub_i8_proof : arbitrary_mask_sub_i8_before ⊑ arbitrary_mask_sub_i8_after

theorem udiv_ne_big_proof : udiv_ne_big_before ⊑ udiv_ne_big_after

theorem test6_proof : test6_before ⊑ test6_after

theorem sub_to_xor_or_commuted_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32), (x_1 ||| x) - (x &&& x_1) = x ^^^ x_1

theorem select_xor_icmp_bad_6_thm.extracted_1._5 : ∀ (x x_1 x_2 : BitVec 32),
  ¬ofBool (x_2 != 1#32) = 1#1 → ofBool (x_2 == 1#32) = 1#1 → x_2 ^^^ x = x ^^^ 1#32

theorem scalar_i32_lshr_and_signbit_ne_proof : scalar_i32_lshr_and_signbit_ne_before ⊑ scalar_i32_lshr_and_signbit_ne_after

theorem sext_zext_nneg_ult_proof : sext_zext_nneg_ult_before ⊑ sext_zext_nneg_ult_after

theorem t10_shift_by_one_proof : t10_shift_by_one_before ⊑ t10_shift_by_one_after

theorem or_xor_tree_1111_thm (e e_1 e_2 : IntW 32) :
  LLVM.or (LLVM.xor (mul e_2 (const? 32 42)) (LLVM.xor (mul e_1 (const? 32 42)) (mul e (const? 32 42))))
      (LLVM.xor (mul e (const? 32 42)) (mul e_2 (const? 32 42))) ⊑
    LLVM.or (LLVM.xor (mul e (const? 32 42)) (mul e_2 (const? 32 42))) (mul e_1 (const? 32 42))

theorem shr_umax_proof : shr_umax_before ⊑ shr_umax_after

theorem n7_wrong_pred2_thm (e e_1 : IntW 8) :
  icmp IntPred.eq (sub e_1 e) e_1 ⊑ icmp IntPred.eq e (const? 8 0)

theorem reused_mul_nuw_xy_z_selectnonzero_ugt_thm.extracted_1._6 : ∀ (x x_1 x_2 : BitVec 8),
  ¬ofBool (x_2 != 0#8) = 1#1 →
    ¬ofBool (x_2 == 0#8) = 1#1 → True ∧ x_1.umulOverflow x_2 = true ∨ True ∧ x.umulOverflow x_2 = true → False

lemma deterministic_stepSet_subsingleton {M : NFA α σ} {S : Set σ} (hd : M.Deterministic) :
    S.Subsingleton → (M.stepSet S a |>.Subsingleton)

theorem t0_sub_of_trueval_thm (e e_1 : IntW 8) (e_2 : IntW 1) :
  sub (select e_2 e_1 e) e_1 ⊑ select e_2 (const? 8 0) (sub e e_1)

theorem fold_mask_cmps_to_true_logical_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬ofBool (x != 2147483647#32) = 1#1 → ofBool (x &&& 2147483647#32 != 0#32) = 1#1

theorem test2_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ofBool (x_1 ^^^ x == 0#32) ^^^ ofBool (x_1 ^^^ x == 32#32) = ofBool (x_1 == x) ^^^ ofBool (x_1 ^^^ x == 32#32)

theorem main7b_logical_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (x_1 == x &&& x_1) = 1#1 → ofBool (x_1 != x &&& x_1) = 1#1 → 0#1 = 1#1 → 0#32 = zeroExtend 32 1#1

theorem foo1_and_thm (e e_1 e_2 : IntW 32) :
  LLVM.or (icmp IntPred.eq (LLVM.and (shl (const? 32 1) e_2) e_1) (const? 32 0))
      (icmp IntPred.eq (LLVM.and (shl (const? 32 1) e) e_1) (const? 32 0)) ⊑
    icmp IntPred.ne
      (LLVM.and e_1
        (LLVM.or (shl (const? 32 1) e_2 { «nsw» := false, «nuw» := true })
          (shl (const? 32 1) e { «nsw» := false, «nuw» := true })))
      (LLVM.or (shl (const? 32 1) e_2 { «nsw» := false, «nuw» := true })
        (shl (const? 32 1) e { «nsw» := false, «nuw» := true }))

theorem basic_proof : basic_before ⊑ basic_after

theorem PR42691_9_logical_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬ofBool (13#32 <ₛ x) = 1#1 → 0#1 = ofBool (x + BitVec.ofInt 32 (-14) <ᵤ 2147483633#32)

theorem test17_proof : test17_before ⊑ test17_after

theorem e_1560 :
     - 2 * (a &&&  ~~~c) + 11 * (b ^^^  ~~~(a &&& c)) + 1 * ((a ^^^ b) ||| (a ^^^ c)) + 1 * ( ~~~a &&& (b ||| c)) + 11 * ( ~~~(a ||| b) |||  ~~~(b ^^^ c)) - 6 * ( ~~~b |||  ~~~(a ^^^ c)) + 2 * (c ^^^ (a ||| (b ||| c))) - 16 *  ~~~(a ||| (b ||| c)) + 2 *  ~~~(a ||| ( ~~~b ||| c)) - 17 *  ~~~( ~~~a ||| (b ||| c)) - 18 * ( ~~~a &&& ( ~~~b &&& c)) - 13 * ( ~~~a &&& (b &&& c)) + 5 * (a &&& ( ~~~b &&& c)) - 16 * (a &&& (b &&& c)) = 1 *  ~~~( ~~~a ||| ( ~~~b ||| c))

theorem udiv_common_dividend_defined_cond_thm (e e_1 e_2 : IntW 5) (e_3 : IntW 1) :
  select e_3 (LLVM.udiv e_2 e_1) (LLVM.udiv e_2 e) ⊑ LLVM.udiv e_2 (select e_3 e_1 e)

theorem ashrslt_03_06_proof : ashrslt_03_06_before ⊑ ashrslt_03_06_after

theorem shift_xor_multiuse_or_proof : shift_xor_multiuse_or_before ⊑ shift_xor_multiuse_or_after

theorem test_zext4_thm.extracted_1._3 : ∀ (x x_1 : BitVec 1),
  x_1 = 1#1 → x_1 ^^^ 1#1 = 1#1 → zeroExtend 32 x = zeroExtend 32 1#1

theorem PR2330_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ofBool (x_1 <ᵤ 8#32) &&& ofBool (x <ᵤ 8#32) = ofBool (x_1 ||| x <ᵤ 8#32)

theorem masked_icmps_bmask_notmixed_or_thm (e : IntW 32) :
  LLVM.or (icmp IntPred.eq (LLVM.and e (const? 32 15)) (const? 32 3))
      (icmp IntPred.eq (LLVM.and e (const? 32 255)) (const? 32 243)) ⊑
    icmp IntPred.eq (LLVM.and e (const? 32 15)) (const? 32 3)

theorem lshrult_02_00_thm.extracted_1._1 : ∀ (x : BitVec 4), ¬2#4 ≥ ↑4 → ofBool (x >>> 2#4 <ᵤ 0#4) = 0#1

theorem or_xor_common_op_commute0_thm (e e_1 e_2 : IntW 8) :
  LLVM.or (LLVM.or e_2 e_1) (LLVM.xor e_2 e) ⊑ LLVM.or (LLVM.or e_2 e_1) e

theorem ashr_mul_times_5_div_4_exact_2_thm (e : IntW 32) :
  ashr (mul e (const? 32 5) { «nsw» := true, «nuw» := false }) (const? 32 2) { «exact» := true } ⊑
    add e (ashr e (const? 32 2) { «exact» := true }) { «nsw» := true, «nuw» := false }

theorem rewrite_n (stream_d : DCOp.TokenStream) :
    DCOp.sink ((DCOp.fork stream_d).fst) = DCOp.sink stream_d

theorem lshr_by_const_cmp_sge_value_proof : lshr_by_const_cmp_sge_value_before ⊑ lshr_by_const_cmp_sge_value_after

theorem test13_proof : test13_before ⊑ test13_after

theorem fold_sext_to_and_wrong6_proof : fold_sext_to_and_wrong6_before ⊑ fold_sext_to_and_wrong6_after

lemma bisimul_eval_one (hsim : Bisimul R M₁ M₂) :
    R.set_eq Q₁ Q₂ → R.set_eq (M₁.stepSet Q₁ a) (M₂.stepSet Q₂ a)

theorem shl_lshr_eq_amt_multi_use_proof : shl_lshr_eq_amt_multi_use_before ⊑ shl_lshr_eq_amt_multi_use_after

theorem trunc_ashr_thm (e : IntW 32) :
  trunc 32 (ashr (LLVM.or (zext 36 e) (const? 36 (-2147483648))) (const? 36 8)) ⊑
    LLVM.or (lshr e (const? 32 8)) (const? 32 (-8388608))

theorem pb_thm (e : IntW 65) :
  icmp IntPred.eq e (ashr (shl e (const? 65 1)) (const? 65 1) { «exact» := true }) ⊑
    icmp IntPred.sgt (add e (const? 65 9223372036854775808)) (const? 65 (-1))

theorem masked_and_notA_logical_proof : masked_and_notA_logical_before ⊑ masked_and_notA_logical_after

theorem lshrugt_01_08_exact_proof : lshrugt_01_08_exact_before ⊑ lshrugt_01_08_exact_after

theorem lshr_eq_opposite_msb_proof : lshr_eq_opposite_msb_before ⊑ lshr_eq_opposite_msb_after

@[grind =, simp] lemma RawCNFA.empty_trans : empty (A := A).trans = ∅

theorem and_umin_thm (e : IntW 32) :
  LLVM.and (select (icmp IntPred.ult (const? 32 15) e) (const? 32 15) e) (const? 32 (-32)) ⊑ const? 32 0

theorem addsub_combine_constants_proof : addsub_combine_constants_before ⊑ addsub_combine_constants_after

theorem lshrult_02_01_proof : lshrult_02_01_before ⊑ lshrult_02_01_after

theorem masked_icmps_mask_notallzeros_bmask_mixed_7_logical_thm (e : IntW 32) :
  select (icmp IntPred.ne (LLVM.and e (const? 32 7)) (const? 32 0))
      (icmp IntPred.eq (LLVM.and e (const? 32 15)) (const? 32 8)) (const? 1 0) ⊑
    const? 1 0

theorem twoway_clamp_lt_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬ofBool (x <ₛ 13768#32) = 1#1 →
    ofBool (13767#32 <ₛ x) = 1#1 → ¬ofBool (13767#32 <ₛ 13768#32) = 1#1 → 13767#32 = 13768#32

theorem no_masks_with_logical_or2_thm.extracted_1._2 : ∀ (x x_1 : BitVec 32),
  ofBool (x_1 != -1#32) = 1#1 → ¬ofBool (x_1 &&& x != -1#32) = 1#1 → False

theorem e_606 :
     - 2 * x + 2 * (x |||  ~~~y) - 1 *  ~~~(x &&& y) - 6 *  ~~~(x &&&  ~~~y) + 5 * (x ||| y) - 2 *  ~~~y - 1 *  ~~~(x &&&  ~~~x) + 3 * (x ^^^ y) + 8 *  ~~~(x ||| y) - 4 * (x &&&  ~~~y) =  - 2 * (x &&& y)

theorem and_xor_common_op_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬(x_1 = 0 ∨ x_1 = 0 ∨ x = 0) → x_1 = 0 ∨ x = 0 → False

theorem land_lor_right2_thm.extracted_1._3 : ∀ (x x_1 : BitVec 1), ¬x_1 = 1#1 → ¬x = 1#1 → 0#1 = x_1

theorem test_invalid_simplify_other_thm (e e_1 : IntW 8) :
  select (icmp IntPred.eq e_1 (const? 8 0)) (const? 8 0) (sub e (const? 8 1)) ⊑
    select (icmp IntPred.eq e_1 (const? 8 0)) (const? 8 0) (add e (const? 8 (-1)))

theorem test_or_eq_different_operands_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 8),
  ofBool (x_2 == x_1) ||

theorem lshrugt_03_11_thm (e : IntW 4) : icmp IntPred.ugt (lshr e (const? 4 3)) (const? 4 (-5)) ⊑ const? 1 0

theorem not_false_not_thm.extracted_1._2 : ∀ (x x_1 : BitVec 1), x_1 ^^^ 1#1 = 1#1 → x_1 = 1#1 → 0#1 = x ^^^ 1#1

theorem abs_must_be_positive_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬ofBool (0#32 ≤ₛ x) = 1#1 → ¬(True ∧ (0#32).ssubOverflow x = true) → ofBool (0#32 ≤ₛ 0#32 - x) = 1#1

theorem XorZextXor_thm.extracted_1._1 : ∀ (x : BitVec 3), zeroExtend 5 (x ^^^ 3#3) ^^^ 12#5 = zeroExtend 5 x ^^^ 15#5

theorem e_1900 :
    2 * (b ^^^ (a &&&  ~~~c)) - 11 * (b ^^^  ~~~(a &&& (b ^^^ c))) - 3 * (b &&&  ~~~(a &&&  ~~~c)) - 1 * (b ^^^ (a |||  ~~~c)) - 2 * (a ||| ( ~~~b &&& c)) + 11 * ( ~~~a ||| (b ||| c)) + 2 * (c ||| (a &&&  ~~~b)) - 1 * (a ||| b) - 5 * (c ^^^ (a &&& b)) + 7 * (b ^^^  ~~~(a &&& ( ~~~b &&& c))) + 4 *  ~~~(b &&&  ~~~c) + 7 * (a ^^^ c) - 1 * ((a &&& b) |||  ~~~(a ^^^ (b ^^^ c))) + 7 * (b ^^^ ( ~~~a &&& ( ~~~b ||| c))) + 11 * (b ^^^ ( ~~~a ||| (b &&& c))) + 1 * (b &&& c) + 1 * ((a ^^^ b) ||| (a ^^^ c)) - 5 * (b ^^^ (a ||| (b ^^^ c))) - 6 * (a &&& (b ||| c)) - 2 * ( ~~~(a |||  ~~~b) ||| (b ^^^ c)) + 7 *  ~~~(a ^^^ (b ||| c)) + 2 *  ~~~(a ||| (b &&& c)) - 7 * ( ~~~b &&&  ~~~(a ^^^ c)) + 3 * ( ~~~(a &&& b) &&& (a ^^^ (b ^^^ c))) - 6 * c - 2 * ((a &&& c) ^^^ (a ^^^ ( ~~~b &&& c))) + 11 *  ~~~(a &&&  ~~~b) - 3 * ( ~~~(a |||  ~~~b) |||  ~~~(a ^^^ (b ^^^ c))) + 7 *  ~~~(a |||  ~~~b) + 2 * (a &&&  ~~~c) - 11 *  ~~~(a &&&  ~~~c) + 11 *  ~~~( ~~~a &&& (b ||| c)) - 2 * (b ^^^ ( ~~~a &&& (b ||| c))) + 4 * ( ~~~(a &&& b) &&&  ~~~(a ^^^ (b ^^^ c))) + 4 * (a ^^^ (b &&& c)) + 1 * (c ^^^  ~~~( ~~~a ||| ( ~~~b &&& c))) - 2 *  ~~~(b |||  ~~~c) + 1 * ( ~~~b |||  ~~~(a ^^^ c)) + 2 *  ~~~(b &&& c) + 11 * (b ^^^  ~~~(a ||| ( ~~~b &&& c))) + 1 * ( ~~~(a ||| b) |||  ~~~(b ^^^ c)) - 56 *  ~~~(a ||| (b ||| c)) - 28 *  ~~~(a ||| ( ~~~b ||| c)) - 27 *  ~~~( ~~~a ||| (b ||| c)) - 52 *  ~~~( ~~~a ||| ( ~~~b ||| c)) - 24 * ( ~~~a &&& ( ~~~b &&& c)) - 18 * ( ~~~a &&& (b &&& c)) + 5 * (a &&& ( ~~~b &&& c)) - 37 * (a &&& (b &&& c)) =  - 1 * ((a &&&  ~~~b) ||| (b ^^^ c))

theorem masked_icmps_mask_notallzeros_bmask_mixed_negated_swapped_1_logical_proof : masked_icmps_mask_notallzeros_bmask_mixed_negated_swapped_1_logical_before ⊑ masked_icmps_mask_notallzeros_bmask_mixed_negated_swapped_1_logical_after

theorem test6a_proof : test6a_before ⊑ test6a_after

theorem e_215 :
     - 6 * (x ||| y) + 5 * (x |||  ~~~y) - 3 *  ~~~y + 2 * x + 13 *  ~~~(x |||  ~~~y) + 9 * (x &&&  ~~~y) + 6 * (x &&& y) = 7 *  ~~~(x &&&  ~~~x) - 5 *  ~~~(x ||| y)

theorem test6_thm.extracted_1._2 : ∀ (x : BitVec 64),
  ¬32#128 ≥ ↑128 →
    ¬(32#64 ≥ ↑64 ∨ True ∧ zeroExtend 64 (truncate 32 (x >>> 32#64)) ≠ x >>> 32#64) →
      truncate 32 (zeroExtend 128 x >>> 32#128) = truncate 32 (x >>> 32#64)

theorem ashr_1_thm (e e_1 e_2 : IntW 8) (e_3 : IntW 1) :
  LLVM.xor (ashr (select e_3 (LLVM.xor e_2 (const? 8 (-1))) (LLVM.xor e_1 (const? 8 123))) e) (const? 8 (-1)) ⊑
    ashr (select e_3 e_2 (LLVM.xor e_1 (const? 8 (-124)))) e

theorem test7_proof : test7_before ⊑ test7_after

theorem icmp_select_var_both_fold_thm.extracted_1._2 : ∀ (x x_1 : BitVec 8),
  ¬ofBool (x_1 == 0#8) = 1#1 → ofBool (2#8 == x ||| 1#8) = ofBool (x_1 == 0#8)

theorem sle_or_not_min_commute_thm (e e_1 : IntW 8) :
  LLVM.or (icmp IntPred.ne e_1 (const? 8 (-128))) (icmp IntPred.sle e_1 e) ⊑ const? 1 1

theorem or_trunc_lshr_more_thm.extracted_1._2 : ∀ (x : BitVec 8),
  ¬4#8 ≥ ↑8 →
    ¬(4#6 ≥ ↑6 ∨ True ∧ (truncate 6 x >>> 4#6 &&& BitVec.ofInt 6 (-4) != 0) = true) →
      truncate 6 (x >>> 4#8) ||

theorem testi64i32_ne_thm.extracted_1._1 : ∀ (x : BitVec 64),
  ¬(31#32 ≥ ↑32 ∨ 32#64 ≥ ↑64) →
    ofBool ((truncate 32 x).sshiftRight' 31#32 != truncate 32 (x >>> 32#64)) =
      ofBool (x + BitVec.ofInt 64 (-2147483648) <ᵤ BitVec.ofInt 64 (-4294967296))

theorem zext_sext_add_icmp_slt_1_proof : zext_sext_add_icmp_slt_1_before ⊑ zext_sext_add_icmp_slt_1_after

theorem not_masked_sub_i8_thm (e : IntW 8) :
  sub (const? 8 11) (LLVM.and e (const? 8 7)) ⊑
    sub (const? 8 11) (LLVM.and e (const? 8 7)) { «nsw» := true, «nuw» := true }

theorem thisdoesnotloop_proof : thisdoesnotloop_before ⊑ thisdoesnotloop_after

theorem sext_xor_sub_1_proof : sext_xor_sub_1_before ⊑ sext_xor_sub_1_after

theorem bv_AndOrXor_2658 :
    ∀ (e e_1 : LLVM.IntW w),
      LLVM.xor (LLVM.and e (LLVM.xor e_1 (LLVM.const? w (-1)))) (LLVM.xor e (LLVM.const? w (-1))) ⊑
        LLVM.xor (LLVM.and e e_1) (LLVM.const? w (-1))

@[simp]
lemma enc_length (bvs : BitVecs n) : (enc bvs).length = bvs.w

theorem test1_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬(1#32 ≥ ↑32 ∨
        True ∧ (x.sshiftRight' 1#32 &&& 1431655765#32 ^^^ -1#32).saddOverflow 1#32 = true ∨
          True ∧ x.saddOverflow ((x.sshiftRight' 1#32 &&& 1431655765#32 ^^^ -1#32) + 1#32) = true) →
    1#32 ≥ ↑32 ∨ True ∧ x.ssubOverflow (x >>> 1#32 &&& 1431655765#32) = true → False

theorem ugt_swap_or_not_min_commute_logical_thm (e e_1 : IntW 823) :
  select (icmp IntPred.ne e_1 (const? 823 0)) (const? 1 1) (icmp IntPred.ult e e_1) ⊑
    icmp IntPred.ne e_1 (const? 823 0)

theorem zext_sext_ugt_known_nonneg_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ofBool (signExtend 32 x <ᵤ zeroExtend 32 (x_1 &&& 127#8)) = ofBool (x <ᵤ x_1 &&& 127#8)

theorem and_nosignbit_select_lshr_proof : and_nosignbit_select_lshr_before ⊑ and_nosignbit_select_lshr_after

theorem main7d_logical_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 32),
  ¬ofBool (x_2 &&& (x_1 &&& x) == x_1 &&& x) = 1#1 →
    ofBool (x_2 &&& (x_1 &&& x) != x_1 &&& x) = 1#1 → 0#1 = 1#1 → 0#32 = zeroExtend 32 1#1

theorem bools_logical_proof : bools_logical_before ⊑ bools_logical_after

theorem main13_logical_thm (e : IntW 32) :
  select
      (select (icmp IntPred.slt (trunc 16 e) (const? 16 0)) (icmp IntPred.slt (trunc 8 e) (const? 8 0))
        (const? 1 0))
      (const? 32 2) (const? 32 1) ⊑
    select (icmp IntPred.eq (LLVM.and e (const? 32 32896)) (const? 32 32896)) (const? 32 2) (const? 32 1)

theorem bools_logical_commute0_thm.extracted_1._15 : ∀ (x x_1 x_2 : BitVec 1),
  x_2 ^^^ 1#1 = 1#1 → ¬x_2 = 1#1 → ¬x_1 = 1#1 → 0#1 = x_1

theorem neg_thm (e : IntW 8) :
  LLVM.xor (sub (const? 8 0) e) (LLVM.udiv e (const? 8 42)) ⊑
    LLVM.xor (LLVM.udiv e (const? 8 42)) (sub (const? 8 0) e)

theorem Predicate.eval_eq_denote (w : Nat) (p : Predicate) (vars : List (BitVec w)) :
    (p.eval (vars.map .ofBitVecSext) w = false) ↔ p.denote w vars

theorem ashrslt_01_02_proof : ashrslt_01_02_before ⊑ ashrslt_01_02_after

theorem Predicate.evalEq_denote_false_iff {w : Nat} (a b : Term) (vars : List (BitVec w)) :
    evalEq (a.eval (List.map .ofBitVecSext vars)) (b.eval (List.map .ofBitVecSext vars)) w = false ↔
    Term.denote w a vars = Term.denote w b vars

theorem e_459 :
     - 3 *  ~~~(x &&&  ~~~y) - 1 *  ~~~(x &&&  ~~~x) - 1 * (x ||| y) + 4 * (x ^^^ y) - 3 * x + 2 *  ~~~x - 2 *  ~~~(x ||| y) - 1 *  ~~~(x |||  ~~~y) - 3 * (x &&&  ~~~y) =  - 8 * (x &&& y) - 4 *  ~~~y

theorem and_not_or_or_not_or_xor_commute2_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 32),
  ¬((x_2 == 0 || 32 != 1 && 42#32 == intMin 32 && x_2 == -1) = true ∨
        (x_2 == 0 || 32 != 1 && 42#32 == intMin 32 && x_2 == -1) = true) →
    (x_2 == 0 || 32 != 1 && 42#32 == intMin 32 && x_2 == -1) = true → False

theorem test13_thm (e : IntW 18) :
  shl (ashr (mul e (const? 18 3)) (const? 18 8)) (const? 18 9) ⊑
    LLVM.and (mul e (const? 18 6)) (const? 18 (-512))

theorem exactly_one_set_signbit_wrong_pred_thm (e e_1 : IntW 8) :
  icmp IntPred.sgt (lshr e_1 (const? 8 7)) (zext 8 (icmp IntPred.sgt e (const? 8 (-1)))) ⊑
    icmp IntPred.slt (LLVM.and e e_1) (const? 8 0)

theorem nonexact_lshr_ne_noexactlog_proof : nonexact_lshr_ne_noexactlog_before ⊑ nonexact_lshr_ne_noexactlog_after

theorem e_1128 :
    7 * (z ^^^ t) + 1 *  ~~~(z ^^^ t) - 7 *  ~~~z - 3 *  ~~~(z &&& t) + 11 * t + 9 *  ~~~(z ||| t) - 8 *  ~~~(z |||  ~~~t) - 4 * (z &&&  ~~~t) = 12 * (z &&& t)

theorem exact_lshr_ne_proof : exact_lshr_ne_before ⊑ exact_lshr_ne_after

theorem test_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬(17#32 ≥ ↑32 ∨ 17#32 ≥ ↑32) → ¬31#32 ≥ ↑32 → (x.sshiftRight' 17#32).sshiftRight' 17#32 = x.sshiftRight' 31#32

theorem Tensor2d'.map_functorial (g : β → γ) (f : α → β) (t : Tensor2d' α) :
  t.map (g ∘ f) = (t.map f).map g

theorem e_1266 :
    3 *  ~~~z + 1 * z + 11 *  ~~~(z &&&  ~~~z) - 6 * t - 1 *  ~~~(z &&& t) - 13 *  ~~~(z ||| t) - 9 *  ~~~(z |||  ~~~t) - 13 * (z &&&  ~~~t) - 6 * (z &&& t) =  - 2 * (z ^^^ t)

theorem test5_thm (e e_1 : IntW 32) :
  LLVM.xor (LLVM.or (LLVM.xor e_1 (const? 32 (-1))) (LLVM.xor e (const? 32 (-1)))) (const? 32 (-1)) ⊑
    LLVM.and e_1 e

theorem icmp_ule_thm (e e_1 : IntW 32) : icmp IntPred.ule (lshr e_1 e) e_1 ⊑ const? 1 1

theorem logic_or_logic_and_2_proof : logic_or_logic_and_2_before ⊑ logic_or_logic_and_2_after

theorem scalar_i32_signbit_lshr_and_eq_nonzero_proof : scalar_i32_signbit_lshr_and_eq_nonzero_before ⊑ scalar_i32_signbit_lshr_and_eq_nonzero_after

theorem or_nand_xor_common_op_commute0_thm (e e_1 e_2 : IntW 4) :
  LLVM.or (LLVM.xor (LLVM.and e_2 e_1) (const? 4 (-1))) (LLVM.xor e_2 e) ⊑
    LLVM.xor (LLVM.and (LLVM.and e_2 e_1) e) (const? 4 (-1))

@[simp] theorem bv_isRefinedBy_iff (x y : BitVec w) : x ⊑ y ↔ x = y

theorem bv_AndOrXor_2647 :
    ∀ (e e_1 : LLVM.IntW w), LLVM.xor (LLVM.and e e_1) (LLVM.xor e e_1) ⊑ LLVM.or e e_1

theorem t3_exact_thm.extracted_1._2 : ∀ (x : BitVec 64),
  ¬(True ∧ x >>> 63#64 <<< 63#64 ≠ x ∨ 63#64 ≥ ↑64) →
    ¬(True ∧ x >>> 63#64 <<< 63#64 ≠ x ∨
          63#64 ≥ ↑64 ∨
            True ∧ signExtend 64 (truncate 32 (x >>> 63#64)) ≠ x >>> 63#64 ∨
              True ∧ zeroExtend 64 (truncate 32 (x >>> 63#64)) ≠ x >>> 63#64) →
      0#32 - truncate 32 (x.sshiftRight' 63#64) = truncate 32 (x >>> 63#64)

theorem test1_proof : test1_before ⊑ test1_after

theorem R.representative'_zero_ideal : R.representative' q n 0 ∈ Ideal.span {f q n}

theorem bv_AndOrXor_1230__A__B___A__B :
    ∀ (e e_1 : LLVM.IntW w),
      LLVM.and (LLVM.xor e (LLVM.const? w (-1))) (LLVM.xor e_1 (LLVM.const? w (-1))) ⊑
        LLVM.xor (LLVM.or e e_1) (LLVM.const? w (-1))

theorem rawspeed_signbit_thm.extracted_1._1 : ∀ (x : BitVec 64) (x_1 : BitVec 32),
  ¬(True ∧ x_1.saddOverflow (-1#32) = true ∨
        x_1 + -1#32 ≥ ↑32 ∨ True ∧ (64#32).ssubOverflow x_1 = true ∨ zeroExtend 64 (64#32 - x_1) ≥ ↑64) →
    ofBool (1#32 <<< (x_1 + -1#32) &&& truncate 32 (x >>> zeroExtend 64 (64#32 - x_1)) == 0#32) = ofBool (-1#64 <ₛ x)

theorem sub_ashr_and_i32_commute_thm (e e_1 : IntW 32) :
  LLVM.and e_1 (ashr (sub e e_1 { «nsw» := true, «nuw» := false }) (const? 32 31)) ⊑
    select (icmp IntPred.slt e e_1) e_1 (const? 32 0)

theorem bitwise_and_bitwise_and_icmps_comm1_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 8),
  ¬x_1 ≥ ↑8 → True ∧ 1#8 <<< x_1 >>> x_1 ≠ 1#8 ∨ x_1 ≥ ↑8 ∨ True ∧ 1#8 <<< x_1 >>> x_1 ≠ 1#8 ∨ x_1 ≥ ↑8 → False

theorem icmp_select_const_proof : icmp_select_const_before ⊑ icmp_select_const_after

theorem bools_multi_uses2_logical_thm.extracted_1._7 : ∀ (x x_1 : BitVec 1),
  ¬x_1 ^^^ 1#1 = 1#1 → ¬x_1 = 1#1 → 0#1 = 1#1 → x = 1#1 → True → 0#1 + 0#1 = 0#1 ^^^ 0#1

theorem n0_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 8),
  ¬x_2 ≥ ↑8 → True ∧ ((-1#8) <<< x_2).sshiftRight' x_2 ≠ -1#8 ∨ x_2 ≥ ↑8 → False

theorem lshr_x_by_const_cmp_x_proof : lshr_x_by_const_cmp_x_before ⊑ lshr_x_by_const_cmp_x_after

theorem test25_proof : test25_before ⊑ test25_after

theorem trunc_shl_lshr_infloop_thm.extracted_1._2 : ∀ (x : BitVec 64),
  ¬(1#64 ≥ ↑64 ∨ 2#64 ≥ ↑64) →
    ¬1#32 ≥ ↑32 → truncate 32 (x >>> 1#64 <<< 2#64) = truncate 32 x <<< 1#32 &&& BitVec.ofInt 32 (-4)

theorem bv_AndOrXor_1247_AB__AB__AB :
    ∀ (e e_1 : LLVM.IntW w), LLVM.and (LLVM.xor (LLVM.and e e_1) (LLVM.const? w (-1))) (LLVM.or e e_1) ⊑ LLVM.xor e e_1

theorem trunc_equality_nuw_thm.extracted_1._1 : ∀ (x x_1 : BitVec 16),
  ¬(True ∧ zeroExtend 16 (truncate 8 x_1) ≠ x_1 ∨ True ∧ zeroExtend 16 (truncate 8 x) ≠ x) →
    ofBool (truncate 8 x_1 == truncate 8 x) = ofBool (x_1 == x)

theorem PR30273_three_bools_thm.extracted_1._8 : ∀ (x x_1 x_2 : BitVec 1),
  ¬x_2 = 1#1 →
    x_1 = 1#1 →
      ¬(True ∧ (zeroExtend 32 x).saddOverflow 1#32 = true) →
        x = 1#1 →
          ¬(True ∧ (2#32).saddOverflow (zeroExtend 32 x_2) = true ∨
                True ∧ (2#32).uaddOverflow (zeroExtend 32 x_2) = true) →
            zeroExtend 32 x + 1#32 = 2#32 + zeroExtend 32 x_2

theorem select_icmp_eq_and_1_0_or_2_proof : select_icmp_eq_and_1_0_or_2_before ⊑ select_icmp_eq_and_1_0_or_2_after

@[simp] theorem Valuation.append_appendInr {v : Var Δ t} :
    (V ++ W) v.appendInr = W v

theorem pow2_or_zero_is_not_negative_commute_thm (e : IntW 8) :
  icmp IntPred.sgt (LLVM.and (sub (const? 8 0) (mul (const? 8 42) e)) (mul (const? 8 42) e)) (const? 8 (-1)) ⊑
    icmp IntPred.ne (mul e (const? 8 42)) (const? 8 (-128))

theorem select_xor_icmp_bad_3_proof : select_xor_icmp_bad_3_before ⊑ select_xor_icmp_bad_3_after

theorem test_nuw_and_unsigned_pred_thm (e : IntW 64) :
  icmp IntPred.ult (sub (const? 64 10) e { «nsw» := false, «nuw» := true }) (const? 64 3) ⊑
    icmp IntPred.ugt e (const? 64 7)

theorem test_sub_4_Y_ne_4_proof : test_sub_4_Y_ne_4_before ⊑ test_sub_4_Y_ne_4_after

theorem alive_InstCombineShift__239 : alive_InstCombineShift__239_src ⊑ alive_InstCombineShift__239_tgt

theorem neg_test_icmp_non_equality_proof : neg_test_icmp_non_equality_before ⊑ neg_test_icmp_non_equality_after

theorem lshr_mul_proof : lshr_mul_before ⊑ lshr_mul_after

theorem select_2_thm.extracted_1._14 : ∀ (x x_1 x_2 : BitVec 8) (x_3 x_4 : BitVec 1),
  x_4 = 1#1 → x_3 = 1#1 → x_2 ^^^ -1#8 ^^^ -1#8 = x_2

theorem sext_multiuse_proof : sext_multiuse_before ⊑ sext_multiuse_after

theorem select_bittest_to_shl_negative_test_proof : select_bittest_to_shl_negative_test_before ⊑ select_bittest_to_shl_negative_test_after

theorem slt_swap_or_not_max_commute_proof : slt_swap_or_not_max_commute_before ⊑ slt_swap_or_not_max_commute_after

@[simp] theorem pure_le (e : EffectKind) : pure ≤ e

theorem test2_proof : test2_before ⊑ test2_after

@[simp]
theorem Valuation.ofPair_fst {t₁ t₂ : Ty} (v₁: ⟦t₁⟧) (v₂ : ⟦t₂⟧) :
  (Ctxt.Valuation.ofPair v₁ v₂) ⟨0, by rfl⟩ = v₁

theorem not_or_or_and_not_and_and_commute1_and_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 32),
  (x_2 ^^^ -1#32 ||| x_1 ||| x) &&& (x &&& x_2 &&& x_1 ^^^ -1#32) = x ^^^ x_1 ||

theorem p0_thm (e e_1 : IntW 8) :
  icmp IntPred.ult (LLVM.xor (shl (const? 8 (-1)) e_1) (const? 8 (-1))) e ⊑
    icmp IntPred.ne (lshr e e_1) (const? 8 0)

theorem add_nosignbit_shl_thm (e : IntW 32) :
  shl (add e (const? 32 2147418112)) (const? 32 8) ⊑ add (shl e (const? 32 8)) (const? 32 (-16777216))

theorem shl_xor_thm (e : IntW 8) :
  LLVM.xor (shl (const? 8 16) e) (shl (const? 8 3) (add e (const? 8 1))) ⊑ shl (const? 8 22) e

theorem icmp_sle_x_negy_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ofBool ((x_1 ||| BitVec.ofInt 8 (-128)) &&& x ≤ₛ x) = 1#1

@[simp]
lemma evalRelation_coe (rel : Relation) (bv1 bv2 : BitVec w1) (heq : w1 = w2) :
    evalRelation rel (heq ▸ bv1) (heq ▸ bv2) = evalRelation rel bv1 bv2

theorem sext_ule_sext_thm.extracted_1._1 : ∀ (x : BitVec 1) (x_1 : BitVec 8),
  ofBool (signExtend 16 (x_1 * x_1) ≤ᵤ signExtend 16 x) = ofBool (x_1 * x_1 == 0#8) ||

theorem t2_proof : t2_before ⊑ t2_after

theorem n10_proof : n10_before ⊑ n10_after

theorem shl_lshr_demand3_thm (e : IntW 8) :
  LLVM.or (lshr (shl (const? 8 40) e) (const? 8 3)) (const? 8 (-64)) ⊑
    LLVM.or (lshr (shl (const? 8 40) e) (const? 8 3) { «exact» := true }) (const? 8 (-64))
      { «disjoint» := true }

theorem select_non_const_sides_thm.extracted_1._3 : ∀ (x x_1 : BitVec 64) (x_2 : BitVec 1),
  x_2 = 1#1 → x_1 - zeroExtend 64 x_2 = x_1 + -1#64

private theorem not_decide_eq_decide_lnot {P : Prop}
  [Decidable P] :
    (!(decide P)) = (decide (¬ P))

theorem src_x_and_nmask_uge_thm.extracted_1._7 : ∀ (x : BitVec 8) (x_1 : BitVec 1) (x_2 : BitVec 8),
  ¬x_1 = 1#1 → ¬x_1 ^^^ 1#1 = 1#1 → True ∧ ((-1#8) <<< x).sshiftRight' x ≠ -1#8 ∨ x ≥ ↑8 → False

theorem ashrslt_03_12_exact_proof : ashrslt_03_12_exact_before ⊑ ashrslt_03_12_exact_after

theorem t0_proof : t0_before ⊑ t0_after

theorem slt_proof : slt_before ⊑ slt_after

theorem test83_thm.extracted_1._2 : ∀ (x : BitVec 64) (x_1 : BitVec 16),
  ¬(True ∧ x.saddOverflow (-1#64) = true ∨ truncate 32 (x + -1#64) ≥ ↑32) →
    ¬truncate 32 x + -1#32 ≥ ↑32 →
      zeroExtend 64 (signExtend 32 x_1 <<< truncate 32 (x + -1#64)) =
        zeroExtend 64 (signExtend 32 x_1 <<< (truncate 32 x + -1#32))

theorem lshrult_01_13_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬1#4 ≥ ↑4 → ofBool (x >>> 1#4 <ᵤ BitVec.ofInt 4 (-3)) = 1#1

theorem bitwise_and_logical_and_icmps_comm3_thm.extracted_1._5 : ∀ (x x_1 x_2 : BitVec 8),
  ¬x_1 ≥ ↑8 →
    ofBool (x_2 &&& 1#8 != 0#8) = 1#1 →
      ¬(True ∧ 1#8 <<< x_1 >>> x_1 ≠ 1#8 ∨ x_1 ≥ ↑8 ∨ True ∧ 1#8 <<< x_1 >>> x_1 ≠ 1#8 ∨ x_1 ≥ ↑8) →
        ¬ofBool (x_2 &&& (1#8 <<< x_1 ||| 1#8) == 1#8 <<< x_1 ||| 1#8) = 1#1 →
          ofBool (x_2 &&& 1#8 <<< x_1 != 0#8) &&& ofBool (x == 42#8) = 0#1

theorem PR2844_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x == 0#32) ||

theorem udiv_i80_proof : udiv_i80_before ⊑ udiv_i80_after

theorem negate_select_of_op_vs_negated_op_nsw_commuted_thm (e : IntW 8) (e_1 : IntW 1) (e_2 : IntW 8) :
  sub e_2 (select e_1 e (sub (const? 8 0) e { «nsw» := true, «nuw» := false })) ⊑
    add (select e_1 (sub (const? 8 0) e) e) e_2

theorem n3_constmask_samemask_proof : n3_constmask_samemask_before ⊑ n3_constmask_samemask_after

theorem test11d_proof : test11d_before ⊑ test11d_after

theorem n3_constmask_samemask_thm (e e_1 : IntW 32) :
  LLVM.or (LLVM.and e_1 (const? 32 65280)) (LLVM.and e (const? 32 65280)) ⊑
    LLVM.and (LLVM.or e_1 e) (const? 32 65280)

theorem src_fv_ne_proof : src_fv_ne_before ⊑ src_fv_ne_after

theorem main12_logical_proof : main12_logical_before ⊑ main12_logical_after

theorem ne_smin1_thm (e e_1 : IntW 32) :
  icmp IntPred.ne (select (icmp IntPred.slt e_1 e) e_1 e) e_1 ⊑ icmp IntPred.sgt e_1 e

theorem main4f_like_logical_thm.extracted_1._5 : ∀ (x x_1 x_2 : BitVec 32),
  ofBool (x_2 &&& x_1 != x_1) = 1#1 →
    ofBool (x_2 &&& x_1 == x_1) = 1#1 → True → 0#32 = zeroExtend 32 (ofBool (x_2 &&& x == x))

theorem or_xor_tree_1000_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 32),
  x_2 * 42#32 ^^^ x_1 * 42#32 ^^^ x * 42#32 ||

theorem icmp_slt_0_and_icmp_sgt_neg1_i64_thm.extracted_1._1 : ∀ (x : BitVec 64),
  ¬63#64 ≥ ↑64 → x >>> 63#64 &&& zeroExtend 64 (ofBool (-1#64 <ₛ x)) = 0#64

theorem nonexact_lshr_ne_noexactdiv_proof : nonexact_lshr_ne_noexactdiv_before ⊑ nonexact_lshr_ne_noexactdiv_after

@[bv_automata_preprocess] theorem BitVec.mul_nat_eq_ofNat_mul (x : BitVec w) (n : Nat) :
  x * n = BitVec.ofNat w n * x

theorem icmp_power2_and_icmp_shifted_mask_swapped_2147483648_805306368_proof : icmp_power2_and_icmp_shifted_mask_swapped_2147483648_805306368_before ⊑ icmp_power2_and_icmp_shifted_mask_swapped_2147483648_805306368_after

theorem band_lor_left1_proof : band_lor_left1_before ⊑ band_lor_left1_after

theorem xor_ashr_not_fail_invalid_xor_constant_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 8),
  ¬(x_1 ≥ ↑8 ∨ x_1 ≥ ↑8) → x_1 ≥ ↑8 → False

theorem positive_biggerLshr_lshrexact_proof : positive_biggerLshr_lshrexact_before ⊑ positive_biggerLshr_lshrexact_after

theorem test_lshr_exact__exact_is_unsafe_proof : test_lshr_exact__exact_is_unsafe_before ⊑ test_lshr_exact__exact_is_unsafe_after

theorem test4_proof : test4_before ⊑ test4_after

theorem add_constant_equal_with_the_top_bit_of_demandedbits_pass_proof : add_constant_equal_with_the_top_bit_of_demandedbits_pass_before ⊑ add_constant_equal_with_the_top_bit_of_demandedbits_pass_after

theorem scalar_i32_lshr_and_negC_slt_thm (e e_1 : IntW 32) :
  icmp IntPred.slt (LLVM.and (lshr e_1 e) (const? 32 (-8))) (const? 32 0) ⊑
    icmp IntPred.slt (lshr e_1 e) (const? 32 0)

theorem ult_2_proof : ult_2_before ⊑ ult_2_after

theorem n8_wrong_pred3_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8), ofBool (x_1 - x != x_1) = ofBool (x != 0#8)

theorem fold_mask_cmps_to_false_logical_proof : fold_mask_cmps_to_false_logical_before ⊑ fold_mask_cmps_to_false_logical_after

theorem or_test2_thm.extracted_1._1 : ∀ (x : BitVec 7),
  ¬6#7 ≥ ↑7 → x <<< 6#7 ||

theorem sdiv_icmp6_thm.extracted_1._1 : ∀ (x : BitVec 64),
  ¬(True ∧ x.smod (BitVec.ofInt 64 (-5)) ≠ 0 ∨
        (BitVec.ofInt 64 (-5) == 0 || 64 != 1 && x == intMin 64 && BitVec.ofInt 64 (-5) == -1) = true) →
    ofBool (x.sdiv (BitVec.ofInt 64 (-5)) == -1#64) = ofBool (x == 5#64)

theorem icmp_sgt6_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬(True ∧ (x <<< 1#8).sshiftRight' 1#8 ≠ x ∨ 1#8 ≥ ↑8) → ofBool (16#8 <ₛ x <<< 1#8) = ofBool (8#8 <ₛ x)

theorem test_logical_or_eq_a_b_proof : test_logical_or_eq_a_b_before ⊑ test_logical_or_eq_a_b_after

@[simp]
lemma RawCNFA.autSignedCmp_m_wf : autSignedCmp.m.1 |>.WF

theorem main5e_like_logical_thm (e e_1 e_2 : IntW 32) :
  select (select (icmp IntPred.eq (LLVM.and e_2 e_1) e_2) (icmp IntPred.eq (LLVM.and e_2 e) e_2) (const? 1 0))
      (const? 32 0) (const? 32 1) ⊑
    zext 32
      (select (icmp IntPred.ne (LLVM.and e_2 e_1) e_2) (const? 1 1)
        (icmp IntPred.ne (LLVM.and e_2 e) e_2))

omit [LawfulBEq A] [Fintype S] [DecidableEq S] in
lemma processOneElem_visited (st : worklist.St A S) :
    let st' := processOneElem _ _  final s st (a, sa')
    st'.visited = st.visited

theorem bv_AddSub_1539 :
    ∀ (e e_1 : LLVM.IntW w), LLVM.sub e_1 (LLVM.sub (LLVM.const? w 0) e) ⊑ LLVM.add e_1 e

theorem max_of_min_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (0#32 <ₛ x) = 1#1 → ofBool (-1#32 <ₛ x ^^^ -1#32) = 1#1 ∧ ofBool (0#32 <ₛ x) = 1#1 → x ^^^ -1#32 = -1#32

theorem bools2_logical_commute0_thm.extracted_1._18 : ∀ (x x_1 x_2 : BitVec 1),
  ¬x_2 = 1#1 → ¬x_2 ^^^ 1#1 = 1#1 → 0#1 = 1#1 → 1#1 = x

theorem testtrunclowhigh_thm.extracted_1._2 : ∀ (x : BitVec 16) (x_1 : BitVec 32),
  ¬ofBool (x_1 + 128#32 <ᵤ 256#32) = 1#1 → ¬ofBool (-1#32 <ₛ x_1) = 1#1 → ¬ofBool (x_1 <ₛ 0#32) = 1#1 → False

theorem eq_nsw_rem_nz_thm (e : IntW 8) :
  icmp IntPred.eq (mul e (const? 8 5) { «nsw» := true, «nuw» := false }) (const? 8 (-11)) ⊑ const? 1 0

theorem test22_proof : test22_before ⊑ test22_after

theorem n2_badmask_proof : n2_badmask_before ⊑ n2_badmask_after

@[simp]
theorem BitVec.zero_concat (b : Bool) : (0#0).concat b = BitVec.ofBool b

theorem fold_inverted_icmp_preds_reverse_thm.extracted_1._5 : ∀ (x x_1 x_2 x_3 : BitVec 32),
  ¬ofBool (x_3 <ₛ x_2) = 1#1 → ¬ofBool (x_2 ≤ₛ x_3) = 1#1 → x_1 ||

theorem test92_thm.extracted_1._1 : ∀ (x : BitVec 64), ¬32#96 ≥ ↑96 → 32#64 ≥ ↑64 → False

theorem t3_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬(32#32 - x ≥ ↑32 ∨ zeroExtend 64 (x + BitVec.ofInt 32 (-16)) ≥ ↑64) →
    ofBool (x_1 <<< (32#32 - x) &&& truncate 32 (131071#64 >>> zeroExtend 64 (x + BitVec.ofInt 32 (-16))) != 0#32) =
      ofBool (x_1 &&& 1#32 != 0#32)

theorem or_nontrivial_mask1_thm.extracted_1._1 : ∀ (x : BitVec 16),
  ofBool (truncate 8 x != 127#8) ||

theorem scalar_i64_lshr_and_negC_eq_thm.extracted_1._1 : ∀ (x x_1 : BitVec 64),
  ¬x ≥ ↑64 → ofBool (x_1 >>> x &&& BitVec.ofInt 64 (-8589934592) == 0#64) = ofBool (x_1 >>> x <ᵤ 8589934592#64)

@[simp] theorem cons_getElem_toCons (x : A a) (v : Var Γ u)
    (h : as = Γ.toList := by rfl) (h' : a :: as = (Γ.cons a).toList := by rfl) :
    (HVector.cons x xs)[v.toCons (t' := a)]'h' = xs[v]'h

theorem zext_proof : zext_before ⊑ zext_after

theorem and_sext_sext_proof : and_sext_sext_before ⊑ and_sext_sext_after

theorem udiv_i8_thm (e e_1 : IntW 8) : trunc 8 (LLVM.udiv (zext 32 e_1) (zext 32 e)) ⊑ LLVM.udiv e_1 e

theorem or_simplify_ult_proof : or_simplify_ult_before ⊑ or_simplify_ult_after

theorem lshr_shl_pow2_const_case2_proof : lshr_shl_pow2_const_case2_before ⊑ lshr_shl_pow2_const_case2_after

theorem urem_constant_dividend_select_of_constants_divisor_0_arm_thm (e : IntW 1) : urem (const? 32 42) (select e (const? 32 12) (const? 32 0)) ⊑ const? 32 6

theorem neg_not_signbit2_thm (e : IntW 8) :
  sub (const? 32 0) (zext 32 (lshr e (const? 8 6))) ⊑
    sub (const? 32 0) (zext 32 (lshr e (const? 8 6)) { «nneg» := true }) { «nsw» := true, «nuw» := false }

theorem sge_to_ugt_proof : sge_to_ugt_before ⊑ sge_to_ugt_after

theorem invert_both_cmp_operands_sub_thm (e e_1 : IntW 32) :
  icmp IntPred.ult (sub (LLVM.xor e_1 (const? 32 (-1))) e) (const? 32 42) ⊑
    icmp IntPred.ugt (add e_1 e) (const? 32 (-43))

theorem lshrugt_01_14_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬1#4 ≥ ↑4 → ofBool (BitVec.ofInt 4 (-2) <ᵤ x >>> 1#4) = 0#1

theorem basic_preserve_nuw_nsw_thm (e e_1 : IntW 8) :
  LLVM.xor (add (LLVM.xor e_1 (const? 8 (-1))) e { «nsw» := true, «nuw» := true }) (const? 8 (-1)) ⊑
    sub e_1 e { «nsw» := true, «nuw» := true }

theorem ult_rem_zero_nsw_thm (e : IntW 8) :
  icmp IntPred.ult (mul e (const? 8 7) { «nsw» := true, «nuw» := true }) (const? 8 21) ⊑
    icmp IntPred.ult e (const? 8 3)

theorem slt_swap_and_max_logical_proof : slt_swap_and_max_logical_before ⊑ slt_swap_and_max_logical_after

theorem test_lshr__exact_is_unsafe_thm.extracted_1._2 : ∀ (x : BitVec 64) (x_1 : BitVec 32),
  ofBool (x_1 &&& 63#32 == 0#32) = 1#1 →
    ¬(2#32 ≥ ↑32 ∨ True ∧ (x_1 >>> 2#32 &&& 15#32).msb = true ∨ zeroExtend 64 (x_1 >>> 2#32 &&& 15#32) ≥ ↑64) →
      x = x.sshiftRight' (zeroExtend 64 (x_1 >>> 2#32 &&& 15#32))

theorem ashr_exact_poison_constant_fold_thm.extracted_1._2 : ∀ (x : BitVec 8) (x_1 : BitVec 1),
  x_1 = 1#1 → 3#8 ≥ ↑8 → ¬(True ∧ x >>> 3#8 <<< 3#8 ≠ x ∨ 3#8 ≥ ↑8) → False

theorem ashrsgt_02_12_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬2#4 ≥ ↑4 → ofBool (BitVec.ofInt 4 (-4) <ₛ x.sshiftRight' 2#4) = 1#1

theorem c0_thm (e : IntW 8) : icmp IntPred.ule (LLVM.and e (const? 8 3)) e ⊑ const? 1 1

theorem foo_proof : foo_before ⊑ foo_after

theorem lowmask_or_zext_commute_proof : lowmask_or_zext_commute_before ⊑ lowmask_or_zext_commute_after

theorem modulo32_proof : modulo32_before ⊑ modulo32_after

@[deprecated "liftEffect_eq_pure_cast_of" (since := "")]
theorem liftEffect_pure [Pure m] {e} (hle : e ≤ pure) :
    liftEffect hle (α := α) (m := m) = cast (by rw [eq_of_le_pure hle])

theorem test10_thm (e : IntW 123) : LLVM.and (LLVM.and e (const? 123 127)) (const? 123 128) ⊑ const? 123 0

@[simp]
theorem denote_splitProgramAt [LawfulMonad d.m] {pos : ℕ} {prog : Com d Γ eff t}
    {res : _} (hres : res ∈ splitProgramAt pos prog) :
    res.denote = prog.denote

theorem select_icmp_ne_0_and_1073741824_and_not_8_proof : select_icmp_ne_0_and_1073741824_and_not_8_before ⊑ select_icmp_ne_0_and_1073741824_and_not_8_after

theorem test_add__nuw_is_safe_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x &&& 2147483647#32 == 2147483647#32) = 1#1 → True ∧ (x &&& 2147483647#32).uaddOverflow 1#32 = true → False

theorem scalar_i16_lshr_and_negC_eq_thm.extracted_1._1 : ∀ (x x_1 : BitVec 16),
  ¬x ≥ ↑16 → ofBool (x_1 >>> x &&& BitVec.ofInt 16 (-128) == 0#16) = ofBool (x_1 >>> x <ᵤ 128#16)

theorem zext_nneg_sext_ule_op0_wide_thm (e : IntW 8) (e_1 : IntW 9) :
  icmp IntPred.ule (zext 32 e_1 { «nneg» := true }) (sext 32 e) ⊑ icmp IntPred.ule e_1 (sext 9 e)

theorem bor_land_right2_thm.extracted_1._2 : ∀ (x x_1 : BitVec 1), x_1 = 1#1 → x ||

theorem scalar_i64_signbit_lshr_and_eq_proof : scalar_i64_signbit_lshr_and_eq_before ⊑ scalar_i64_signbit_lshr_and_eq_after

@[simp] lemma composeBinary_eval
    (p : FSM Bool)
    {t₁ t₂ : Term}
    (q₁ : FSMTermSolution t₁)
    (q₂ : FSMTermSolution t₂)
    (x : Fin (max t₁.arity t₂.arity) → BitStream) :
    (composeBinary p q₁ q₂).eval x = p.eval
      (λ b => cond b (t₁.evalFin (fun i => x (Fin.castLE (by simp) i)))
                  (t₂.evalFin (fun i => x (Fin.castLE (by simp) i))))

theorem test2_proof : test2_before ⊑ test2_after

theorem test_ashr_exact__exact_is_safe_thm.extracted_1._1 : ∀ (x : BitVec 64) (x_1 : BitVec 32),
  ofBool (x_1 &&& BitVec.ofInt 32 (-2147483588) == 0#32) = 1#1 →
    2#32 ≥ ↑32 ∨
        True ∧ (x_1.sshiftRight' 2#32 &&& BitVec.ofInt 32 (-536870897)).msb = true ∨
          zeroExtend 64 (x_1.sshiftRight' 2#32 &&& BitVec.ofInt 32 (-536870897)) ≥ ↑64 →
      False

theorem test5_proof : test5_before ⊑ test5_after

theorem e_2168 :
     - 2 * ((d ||| e) &&&  ~~~(e ^^^ f)) - 1 * (f ^^^  ~~~(d &&& ( ~~~e &&& f))) + 7 * (f ^^^ ( ~~~d ||| ( ~~~e ||| f))) - 11 * ( ~~~f &&& (d ^^^ e)) + 4 *  ~~~(e ^^^ f) + 2 * (f ^^^ (d &&& (e ||| f))) - 2 * (e ^^^ ( ~~~d ||| (e &&& f))) - 7 * ( ~~~d ||| (e ^^^ f)) + 3 * ((d &&& e) |||  ~~~(d ^^^ (e ^^^ f))) + 1 * ((d &&& f) ^^^ (d ^^^ ( ~~~e &&& f))) + 5 *  ~~~(d ^^^ f) + 11 * (e &&&  ~~~(d ^^^ f)) + 11 * (f ^^^ ( ~~~d ||| (e ||| f))) + 3 * ( ~~~e ||| (d ^^^ f)) + 1 * (e ^^^ (d &&& ( ~~~e ||| f))) + 2 * (f ^^^ (d ||| ( ~~~e &&& f))) + 7 * (f ^^^  ~~~(d ||| e)) - 1 * ( ~~~(d ^^^ e) &&& (d ^^^ f)) - 7 * (e ^^^  ~~~(d ||| (e &&& f))) - 1 * (e ||| (d &&&  ~~~f)) + 1 * (e ^^^ ( ~~~d ||| (e ^^^ f))) - 1 * (e ||| f) + 1 * ((d &&& f) |||  ~~~(e ||| f)) - 1 * (d ^^^ (e &&& f)) - 3 * ((d &&& e) |||  ~~~(e |||  ~~~f)) + 1 *  ~~~( ~~~d &&& ( ~~~e &&& f)) + 1 * (e ^^^ ( ~~~d &&& ( ~~~e ||| f))) + 5 * (e ^^^  ~~~(d &&& ( ~~~e ||| f))) + 3 * (f ^^^ ( ~~~d ||| (e &&& f))) - 6 * (e ^^^  ~~~(d &&& f)) + 4 * (f ^^^  ~~~(d ||| ( ~~~e &&& f))) + 1 * ( ~~~d &&& (e ^^^ f)) + 1 *  ~~~(d &&& e) + 4 *  ~~~f + 1 * ( ~~~f &&&  ~~~(d ^^^ e)) - 11 * (e ^^^  ~~~( ~~~d &&& ( ~~~e ||| f))) + 1 * (e ^^^  ~~~( ~~~d &&& ( ~~~e &&& f))) - 5 * ((d |||  ~~~e) &&& (e ^^^ f)) - 3 * ( ~~~(d &&& e) &&& (d ^^^ (e ^^^ f))) + 1 *  ~~~( ~~~d ||| (e &&& f)) + 7 * (f &&& (d ^^^ e)) - 43 *  ~~~(d ||| (e ||| f)) - 28 *  ~~~(d ||| ( ~~~e ||| f)) + 7 *  ~~~( ~~~d ||| (e ||| f)) - 2 *  ~~~( ~~~d ||| ( ~~~e ||| f)) + 17 * ( ~~~d &&& ( ~~~e &&& f)) - 4 * ( ~~~d &&& (e &&& f)) - 10 * (d &&& ( ~~~e &&& f)) - 25 * (d &&& (e &&& f)) = 1 * ((d &&&  ~~~e) ||| (d ^^^ (e ^^^ f))) - 3 * ( ~~~(d |||  ~~~e) |||  ~~~(e ^^^ f))

theorem xor_sge_proof : xor_sge_before ⊑ xor_sge_after

theorem test11_proof : test11_before ⊑ test11_after

theorem test_invert_demorgan_and2_proof : test_invert_demorgan_and2_before ⊑ test_invert_demorgan_and2_after

theorem lshrugt_03_15_thm.extracted_1._1 : ∀ (x : BitVec 4), ¬3#4 ≥ ↑4 → ofBool (-1#4 <ᵤ x >>> 3#4) = 0#1

theorem e_511 :
    11 *  ~~~(x ^^^ y) + 2 * (x ||| y) - 7 *  ~~~x - 1 * (x |||  ~~~y) - 3 * y - 1 *  ~~~y + 8 *  ~~~(x |||  ~~~y) + 2 * (x &&&  ~~~y) - 7 * (x &&& y) = 2 * x + 2 *  ~~~(x ||| y)

theorem masked_icmps_mask_notallzeros_bmask_mixed_swapped_3b_logical_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬ofBool (x &&& 3#32 == 0#32) = 1#1 → 0#1 = ofBool (x &&& 3#32 == 0#32) &&& ofBool (x &&& 15#32 != 0#32)

theorem select_mul_icmp_thm (e e_1 e_2 : IntW 32) :
  select (icmp IntPred.eq e_2 (const? 32 1)) (mul e_2 e_1) e ⊑
    select (icmp IntPred.eq e_2 (const? 32 1)) e_1 e

theorem sdiv_x_by_const_cmp_x_proof : sdiv_x_by_const_cmp_x_before ⊑ sdiv_x_by_const_cmp_x_after

theorem e_1669 :
    1 *  ~~~( ~~~a ||| (b ^^^ c)) - 1 * (c ||| (a &&&  ~~~b)) + 5 * ( ~~~(a |||  ~~~b) |||  ~~~(b ^^^ c)) - 5 * ( ~~~a ||| ( ~~~b &&& c)) + 2 *  ~~~(a |||  ~~~b) - 7 *  ~~~a - 2 * ( ~~~c &&&  ~~~(a ^^^ b)) - 3 *  ~~~(a &&& (b ^^^ c)) - 1 * ( ~~~(a |||  ~~~b) ||| (b ^^^ c)) - 2 *  ~~~(a ^^^ (b &&& c)) + 11 * (a |||  ~~~c) - 11 * (b ^^^  ~~~( ~~~a &&& ( ~~~b ||| c))) - 11 * (b ^^^ (a ||| (b &&& c))) + 5 * ((a ^^^ b) &&&  ~~~(a ^^^ c)) + 2 *  ~~~(a ||| b) + 2 *  ~~~( ~~~a ||| (b &&& c)) - 2 * (c ^^^  ~~~(a ||| ( ~~~b &&& c))) + 2 * (b ^^^ (a &&& ( ~~~b ||| c))) + 13 *  ~~~(a ||| ( ~~~b ||| c)) + 12 *  ~~~( ~~~a ||| (b ||| c)) - 5 *  ~~~( ~~~a ||| ( ~~~b ||| c)) + 26 * ( ~~~a &&& ( ~~~b &&& c)) + 19 * ( ~~~a &&& (b &&& c)) + 18 * (a &&& ( ~~~b &&& c)) - 9 * (a &&& (b &&& c)) = 7 * ((a &&&  ~~~b) ||| (b ^^^ c)) - 3 *  ~~~(a ||| (b ||| c))

theorem lshrult_01_08_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬1#4 ≥ ↑4 → ofBool (x >>> 1#4 <ᵤ BitVec.ofInt 4 (-8)) = 1#1

theorem t0_thm (e : IntW 8) :
  sub (LLVM.and e (const? 8 42)) e ⊑ sub (const? 8 0) (LLVM.and e (const? 8 (-43)))

theorem p14_commutativity1_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x <ᵤ 65536#32) = 1#1 → ofBool (65535#32 <ᵤ x) = 1#1 → 65535#32 = 42#32

theorem shl_add_proof : shl_add_before ⊑ shl_add_after

theorem sub_eq_xor_sub_mul_not_and :
    x - y = (x ^^^ y) - 2 * (~~~ x &&& y)

theorem shl_nsw_add_nsw_nuw_proof : shl_nsw_add_nsw_nuw_before ⊑ shl_nsw_add_nsw_nuw_after

theorem test2_proof : test2_before ⊑ test2_after

theorem lshrult_03_08_exact_proof : lshrult_03_08_exact_before ⊑ lshrult_03_08_exact_after

theorem not_and_and_or_not_or_or_commute4_proof : not_and_and_or_not_or_or_commute4_before ⊑ not_and_and_or_not_or_or_commute4_after

theorem logic_and_logic_or_4_proof : logic_and_logic_or_4_before ⊑ logic_and_logic_or_4_after

theorem sdiv?_denom_zero_eq_poison {w : Nat} (x : BitVec w) :
  LLVM.sdiv? x 0 = .poison

theorem pr64558_thm.extracted_1._2 : ∀ (x x_1 : BitVec 1), ¬(x_1 ^^^ 1#1) &&& x = 1#1 → x_1 = x_1 ||

theorem icmp_select_implied_cond_relational_proof : icmp_select_implied_cond_relational_before ⊑ icmp_select_implied_cond_relational_after

theorem n13_proof : n13_before ⊑ n13_after

theorem ashr_ugt_3_proof : ashr_ugt_3_before ⊑ ashr_ugt_3_after

theorem negate_zext_thm.extracted_1._1 : ∀ (x : BitVec 1) (x_1 : BitVec 8),
  x_1 - zeroExtend 8 x = x_1 + signExtend 8 x

theorem e_1735 :
    4 * ( ~~~(a &&&  ~~~b) &&&  ~~~(b ^^^ c)) - 1 *  ~~~(b &&&  ~~~c) - 5 * (b ^^^  ~~~(a &&& ( ~~~b ||| c))) - 1 * (b ^^^ ( ~~~a &&& ( ~~~b ||| c))) - 11 * (b ^^^  ~~~( ~~~a &&& (b ^^^ c))) - 7 * (c ^^^  ~~~(a |||  ~~~b)) - 6 * (b ^^^ (a ||| c)) + 1 * ( ~~~b ||| (a ^^^ c)) - 2 * ((a &&& b) ||| (a ^^^ (b ^^^ c))) - 1 * ((a &&& b) ^^^  ~~~(a ^^^ (b &&& c))) - 2 * (b &&& c) - 6 * (b |||  ~~~(a |||  ~~~c)) + 1 * (a ||| b) - 1 *  ~~~(a &&& (b &&& c)) + 11 * ((b &&&  ~~~c) |||  ~~~(a ||| ( ~~~b &&& c))) + 4 * ( ~~~(a &&&  ~~~b) &&&  ~~~(a ^^^ (b ^^^ c))) + 4 * (c ^^^ (a ||| (b ||| c))) + 2 * (b ^^^ (a ||| ( ~~~b ||| c))) - 7 * ( ~~~c &&&  ~~~(a ^^^ b)) + 4 *  ~~~( ~~~a ||| (b ^^^ c)) - 3 * (c ^^^ ( ~~~a ||| ( ~~~b ||| c))) + 1 * (c ^^^ (a ||| ( ~~~b ||| c))) + 3 * (c ^^^  ~~~(a ||| (b &&& c))) + 4 * (c ^^^  ~~~(a &&&  ~~~b)) - 5 *  ~~~(a ||| (b ||| c)) + 13 *  ~~~(a ||| ( ~~~b ||| c)) + 11 *  ~~~( ~~~a ||| (b ||| c)) - 13 *  ~~~( ~~~a ||| ( ~~~b ||| c)) + 27 * ( ~~~a &&& ( ~~~b &&& c)) - 19 * ( ~~~a &&& (b &&& c)) + 15 * (a &&& ( ~~~b &&& c)) + 7 * (a &&& (b &&& c)) =  - 5 * (b ^^^  ~~~(a ||| c))

theorem ashrsgt_03_15_thm (e : IntW 4) :
  icmp IntPred.sgt (ashr e (const? 4 3)) (const? 4 (-1)) ⊑ icmp IntPred.sgt e (const? 4 (-1))

theorem neg_or_lshr_i32_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬31#32 ≥ ↑32 → (0#32 - x ||| x) >>> 31#32 = zeroExtend 32 (ofBool (x != 0#32))

theorem test9_proof : test9_before ⊑ test9_after

theorem shl_and_lshr_comm_thm (e e_1 e_2 : IntW 32) :
  lshr (LLVM.and e_2 (shl e_1 e { «nsw» := false, «nuw» := true })) e ⊑ LLVM.and (lshr e_2 e) e_1

theorem ashr_can_be_lshr_thm (e : IntW 32) :
  trunc 16 (ashr e (const? 32 16) { «exact» := true }) { «nsw» := true, «nuw» := false } ⊑
    trunc 16 (lshr e (const? 32 16) { «exact» := true }) { «nsw» := false, «nuw» := true }

theorem no_shift_no_xor_multiuse_cmp_xor_thm (e e_1 e_2 e_3 : IntW 32) :
  mul
      (mul
        (select (icmp IntPred.eq (LLVM.and e_3 (const? 32 4096)) (const? 32 0)) e_2
          (LLVM.xor e_2 (const? 32 4096)))
        (select (icmp IntPred.eq (LLVM.and e_3 (const? 32 4096)) (const? 32 0)) e_1 e))
      (LLVM.xor e_2 (const? 32 4096)) ⊑
    mul
      (mul (LLVM.xor e_2 (LLVM.and e_3 (const? 32 4096)))
        (select (icmp IntPred.eq (LLVM.and e_3 (const? 32 4096)) (const? 32 0)) e_1 e))
      (LLVM.xor e_2 (const? 32 4096))

theorem foo1_and_signbit_lshr_without_shifting_signbit_both_sides_proof : foo1_and_signbit_lshr_without_shifting_signbit_both_sides_before ⊑ foo1_and_signbit_lshr_without_shifting_signbit_both_sides_after

theorem test22_thm (e : IntW 14) :
  icmp IntPred.eq (shl e (const? 14 7)) (const? 14 0) ⊑
    icmp IntPred.eq (LLVM.and e (const? 14 127)) (const? 14 0)

theorem neg_not_signbit2_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬6#8 ≥ ↑8 →
    6#8 ≥ ↑8 ∨ True ∧ (x >>> 6#8).msb = true ∨ True ∧ (0#32).ssubOverflow (zeroExtend 32 (x >>> 6#8)) = true → False

theorem neg_nsw_slt_n1_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬(True ∧ (0#8).ssubOverflow x = true) → ofBool (0#8 - x <ₛ -1#8) = ofBool (1#8 <ₛ x)

theorem add_nsw_const_const_sub_proof : add_nsw_const_const_sub_before ⊑ add_nsw_const_const_sub_after

theorem main5f_like_logical_proof : main5f_like_logical_before ⊑ main5f_like_logical_after

theorem e_1826 :
    5 * (b ^^^  ~~~( ~~~a &&& (b ||| c))) + 4 * (b ^^^  ~~~( ~~~a &&& (b &&& c))) - 6 *  ~~~(a &&& (b ||| c)) + 5 * (c ^^^  ~~~( ~~~a &&& (b ||| c))) + 1 * (b ^^^ ( ~~~a &&& (b ^^^ c))) - 1 * (a ||| c) + 2 * ((a ^^^ b) &&& (a ^^^ c)) - 2 * (c ^^^  ~~~( ~~~a ||| (b &&& c))) - 5 * c + 2 * (b ^^^ (a ||| (b &&& c))) + 1 *  ~~~( ~~~a ||| (b ^^^ c)) + 11 *  ~~~(b |||  ~~~c) - 7 * ((b &&&  ~~~c) ^^^ ( ~~~a ||| (b ^^^ c))) + 3 * (c ^^^  ~~~(a |||  ~~~b)) + 11 * ( ~~~b |||  ~~~(a ^^^ c)) + 1 * (b ^^^ (a ||| (b ||| c))) + 11 * (a &&& (b ||| c)) - 7 * ( ~~~(a &&&  ~~~b) &&&  ~~~(a ^^^ (b ^^^ c))) - 3 *  ~~~b + 1 * (a ||| (b ||| c)) + 1 * ( ~~~(a &&& b) &&& (a ^^^ (b ^^^ c))) - 2 * (b ^^^ ( ~~~a ||| ( ~~~b &&& c))) - 1 * (c ^^^ ( ~~~a ||| ( ~~~b ||| c))) - 1 * (c ^^^ (a &&& b)) - 2 *  ~~~( ~~~a &&& (b &&& c)) + 1 * (c |||  ~~~(a ^^^ b)) + 1 *  ~~~(a ^^^ (b ||| c)) + 11 *  ~~~(a ||| c) + 3 * (c ^^^  ~~~( ~~~a ||| ( ~~~b &&& c))) - 11 * (b ^^^ (a ||| c)) + 1 * (c ^^^  ~~~(a ||| ( ~~~b &&& c))) + 1 *  ~~~(b &&&  ~~~c) - 2 * (b &&&  ~~~(a &&&  ~~~c)) + 4 * ((a ^^^ b) &&&  ~~~(a ^^^ c)) - 12 *  ~~~(a ||| (b ||| c)) - 17 *  ~~~(a ||| ( ~~~b ||| c)) - 15 *  ~~~( ~~~a ||| (b ||| c)) - 8 *  ~~~( ~~~a ||| ( ~~~b ||| c)) - 8 * ( ~~~a &&& ( ~~~b &&& c)) + 4 * ( ~~~a &&& (b &&& c)) - 32 * (a &&& ( ~~~b &&& c)) - 22 * (a &&& (b &&& c)) =  - 4 * (c ||| (a &&&  ~~~b))

theorem sge_swap_or_max_proof : sge_swap_or_max_before ⊑ sge_swap_or_max_after

theorem xor_of_icmps_to_ne_commute_thm (e : IntW 64) :
  LLVM.xor (icmp IntPred.slt e (const? 64 6)) (icmp IntPred.sgt e (const? 64 4)) ⊑
    icmp IntPred.ne e (const? 64 5)

theorem lshr_or_proof : lshr_or_before ⊑ lshr_or_after

theorem ugt_swap_and_min_logical_thm (e e_1 : IntW 8) :
  select (icmp IntPred.ult e_1 e) (icmp IntPred.eq e (const? 8 0)) (const? 1 0) ⊑ const? 1 0

theorem PR56294_thm (e : IntW 8) :
  icmp IntPred.ne (LLVM.and (zext 32 (icmp IntPred.eq e (const? 8 2))) (zext 32 (LLVM.and e (const? 8 1))))
      (const? 32 0) ⊑
    const? 1 0

theorem or_not_and_and_not_and_xor_commute2_thm (e e_1 e_2 : IntW 32) :
  LLVM.and (LLVM.or (LLVM.sdiv (const? 32 42) e_2) (LLVM.xor (LLVM.and e_1 e) (const? 32 (-1))))
      (LLVM.xor (LLVM.and (LLVM.xor e_1 e) (LLVM.sdiv (const? 32 42) e_2)) (const? 32 (-1))) ⊑
    LLVM.xor (LLVM.and (LLVM.xor e_1 e) (LLVM.sdiv (const? 32 42) e_2))
      (LLVM.or (LLVM.sdiv (const? 32 42) e_2) (LLVM.xor (LLVM.and e_1 e) (const? 32 (-1))))

theorem masked_icmps_mask_notallzeros_bmask_mixed_swapped_4_logical_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬ofBool (x &&& 15#32 == 8#32) = 1#1 → 0#1 = ofBool (x &&& 15#32 == 8#32)

theorem e_279 :
     - 6 * y - 2 *  ~~~(x &&&  ~~~y) + 11 *  ~~~x - 1 *  ~~~(x &&& y) - 8 *  ~~~(x ||| y) + 1 *  ~~~(x |||  ~~~y) + 8 * (x &&& y) = 3 * (x ^^^ y) - 4 * (x &&&  ~~~y)

theorem main5f_like_logical_thm.extracted_1._7 : ∀ (x x_1 x_2 : BitVec 32),
  ofBool (x_2 &&& x_1 != x_2) = 1#1 → ¬ofBool (x_2 &&& x_1 == x_2) = 1#1 → True → 0#32 = zeroExtend 32 0#1

theorem samesign_inverted_commute3_proof : samesign_inverted_commute3_before ⊑ samesign_inverted_commute3_after

theorem and_ashr_not_thm (e e_1 e_2 : IntW 8) :
  LLVM.and (ashr e_2 e_1) (LLVM.xor (ashr e e_1) (const? 8 (-1))) ⊑
    ashr (LLVM.and e_2 (LLVM.xor e (const? 8 (-1)))) e_1

theorem t2_symmetry_proof : t2_symmetry_before ⊑ t2_symmetry_after

theorem ne_umax2_proof : ne_umax2_before ⊑ ne_umax2_after

theorem test20_thm (e : IntW 8) : LLVM.and (lshr e (const? 8 7)) (const? 8 1) ⊑ lshr e (const? 8 7)

theorem test_proof : test_before ⊑ test_after

theorem test_symbolic_abstraction (f : BitVec w → BitVec w) (x y : BitVec w) : f x ≠ f y

theorem lowmask_add_zext_thm (e : IntW 32) (e_1 : IntW 8) :
  LLVM.and (add (zext 32 e_1) e) (const? 32 255) ⊑ zext 32 (add e_1 (trunc 8 e))

theorem test92_proof : test92_before ⊑ test92_after

theorem select_icmp_ne_0_and_4096_xor_4096_proof : select_icmp_ne_0_and_4096_xor_4096_before ⊑ select_icmp_ne_0_and_4096_xor_4096_after

theorem trunc_lshr_thm.extracted_1._2 : ∀ (x : BitVec 8),
  ¬2#8 ≥ ↑8 → ¬2#6 ≥ ↑6 → truncate 6 (x >>> 2#8) &&& 14#6 = truncate 6 x >>> 2#6 &&& 14#6

theorem e_157 :
     - 2 * (x |||  ~~~y) - 3 *  ~~~(x ^^^ y) + 5 *  ~~~(x ||| y) + 18 *  ~~~(x |||  ~~~y) + 20 * (x &&&  ~~~y) + 12 * (x &&& y) = 7 * (x ||| y) + 11 * (x ^^^ y)

theorem n2_proof : n2_before ⊑ n2_after

theorem shl_add_and_proof : shl_add_and_before ⊑ shl_add_and_after

theorem test16_thm (e : IntW 8) : LLVM.and (shl e (const? 8 2)) (const? 8 3) ⊑ const? 8 0

theorem shl_xor_lshr_thm (e e_1 e_2 : IntW 32) :
  lshr (LLVM.xor (shl e_2 e_1 { «nsw» := false, «nuw» := true }) e) e_1 ⊑ LLVM.xor (lshr e e_1) e_2

theorem ule_or_not_min_commute_logical_proof : ule_or_not_min_commute_logical_before ⊑ ule_or_not_min_commute_logical_after

theorem add_shl_same_amount_constants_proof : add_shl_same_amount_constants_before ⊑ add_shl_same_amount_constants_after

theorem signExtend_eq (x : BitVec w) : x.signExtend w = x  := sorry

--

theorem lshrugt_03_08_exact_thm (e : IntW 4) :
  icmp IntPred.ugt (lshr e (const? 4 3) { «exact» := true }) (const? 4 (-8)) ⊑ const? 1 0

theorem PR2844_logical_proof : PR2844_logical_before ⊑ PR2844_logical_after

theorem e_1473 :
    1 *  ~~~(z &&&  ~~~z) + 1 * z + 1 *  ~~~t + 1 *  ~~~(z &&& t) - 7 * (z ||| t) + 7 * (z ^^^ t) - 2 * t - 5 *  ~~~(z ||| t) - 2 *  ~~~(z |||  ~~~t) - 4 * (z &&&  ~~~t) + 5 * (z &&& t) =  - 2 *  ~~~(z &&&  ~~~t)

theorem sub_from_constant_of_sub_from_constant_thm.extracted_1._1 : ∀ (x : BitVec 8),
  11#8 - (42#8 - x) = x + BitVec.ofInt 8 (-31)

theorem ashrslt_01_07_exact_proof : ashrslt_01_07_exact_before ⊑ ashrslt_01_07_exact_after

theorem udiv1_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32), ¬(True ∧ x_1.umod x ≠ 0 ∨ x = 0) → x_1 / x * x = x_1

theorem e_136 :
     - 1 * y + 3 * (x ^^^ y) - 2 * (x |||  ~~~y) + 2 *  ~~~(x ||| y) - 2 *  ~~~(x |||  ~~~y) + 3 * (x &&& y) = 1 * (x &&&  ~~~y)

theorem different_size_zext_zext_slt_thm.extracted_1._1 : ∀ (x : BitVec 4) (x_1 : BitVec 7),
  ofBool (zeroExtend 25 x_1 <ₛ zeroExtend 25 x) = ofBool (x_1 <ᵤ zeroExtend 7 x)

theorem test_shl__nuw_is_safe_proof : test_shl__nuw_is_safe_before ⊑ test_shl__nuw_is_safe_after

theorem e_604 :
     - 1 *  ~~~y - 1 * y + 3 * (x ^^^ y) - 7 *  ~~~(x &&& y) - 2 * x - 1 *  ~~~(x ^^^ y) + 1 * (x ||| y) - 1 * (x |||  ~~~y) + 6 *  ~~~(x ||| y) + 3 * (x &&&  ~~~y) =  - 4 *  ~~~(x &&&  ~~~x)

theorem icmp_sgt8_proof : icmp_sgt8_before ⊑ icmp_sgt8_after

theorem e_256 :
     - 11 * (x |||  ~~~y) - 5 * y + 2 *  ~~~x - 5 * (x ||| y) + 1 * (x ^^^ y) + 7 *  ~~~(x |||  ~~~y) + 15 * (x &&&  ~~~y) =  - 21 * (x &&& y) - 9 *  ~~~(x ||| y)

theorem not_and_and_or_not_or_or_commute1_or_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 32),
  (x_2 ^^^ -1#32) &&& x_1 &&& x ||

theorem sext_zext_slt_known_nonneg_proof : sext_zext_slt_known_nonneg_before ⊑ sext_zext_slt_known_nonneg_after

theorem nomask_rhs_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x &&& 1#32 == 0#32) ||

theorem or_consts_logical_proof : or_consts_logical_before ⊑ or_consts_logical_after

theorem icmp_equality_test_swift_optional_pointers_thm.extracted_1._2 : ∀ (x x_1 : BitVec 64),
  ofBool (x_1 == 0#64) = 1#1 → ¬True → ofBool (x == 0#64) = ofBool (x_1 == x)

theorem subAux_inductive_lemma (i : Nat) :
    a.subAux b i = ⟨(a.addAux b.neg i).1, subCarries? a b i⟩

theorem t11_no_shift_proof : t11_no_shift_before ⊑ t11_no_shift_after

theorem lshrult_03_04_exact_proof : lshrult_03_04_exact_before ⊑ lshrult_03_04_exact_after

theorem no_shift_no_xor_multiuse_cmp_or_thm.extracted_1._4 : ∀ (x x_1 x_2 x_3 : BitVec 32),
  ¬ofBool (x_3 &&& 4096#32 == 0#32) = 1#1 →
    (x_2 ||| 4096#32) * x * (x_2 ||| 4096#32) = (x_2 ||| x_3 &&& 4096#32) * x * (x_2 ||| 4096#32)

theorem main4c_thm (e : IntW 32) :
  select
      (LLVM.or (icmp IntPred.ne (LLVM.and e (const? 32 7)) (const? 32 7))
        (icmp IntPred.ne (LLVM.and e (const? 32 48)) (const? 32 48)))
      (const? 32 0) (const? 32 1) ⊑
    zext 32 (icmp IntPred.eq (LLVM.and e (const? 32 55)) (const? 32 55))

theorem main7c_logical_thm.extracted_1._12 : ∀ (x x_1 x_2 : BitVec 32),
  ¬ofBool (x_2 == x_2 &&& x_1) = 1#1 →
    ¬ofBool (x_2 != x_2 &&& x_1) = 1#1 → ¬0#1 = 1#1 → 1#32 = zeroExtend 32 (ofBool (x != x &&& x_1))

theorem scalar0_proof : scalar0_before ⊑ scalar0_after

theorem test_add_nsw__all_are_safe_proof : test_add_nsw__all_are_safe_before ⊑ test_add_nsw__all_are_safe_after

theorem not_or_neg_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  (0#8 - x_1 ||| x) ^^^ -1#8 = x_1 + -1#8 &&& (x ^^^ -1#8)

theorem t5_ugt_slt_0_thm.extracted_1._10 : ∀ (x x_1 x_2 : BitVec 32),
  ¬ofBool (65535#32 <ᵤ x_2) = 1#1 → ofBool (65535#32 <ₛ x_2) = 1#1 → x_2 = x

theorem test_or2_logical_thm (e e_1 : IntW 32) :
  select (icmp IntPred.sle e_1 (const? 32 (-1))) (const? 1 1)
      (icmp IntPred.sgt e_1 (LLVM.and e (const? 32 2147483647))) ⊑
    select (icmp IntPred.slt e_1 (const? 32 0)) (const? 1 1)
      (icmp IntPred.sgt e_1 (LLVM.and e (const? 32 2147483647)))

theorem mul_setnzV_unkV_nuw_eq_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ¬(True ∧ (x_1 ||| 2#8).umulOverflow x = true) → ofBool ((x_1 ||| 2#8) * x == 0#8) = ofBool (x == 0#8)

theorem icmp_ne_sext_sgt_zero_nofold_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (signExtend 32 (ofBool (0#32 <ₛ x)) != x) = ofBool (x != signExtend 32 (ofBool (0#32 <ₛ x)))

theorem test28_thm (e : IntW 32) :
  LLVM.xor (add e (const? 32 (-2147483647))) (const? 32 (-2147483648)) ⊑ add e (const? 32 1)

theorem main10_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x &&& 64#32 == 0#32) &&& ofBool (0#8 ≤ₛ truncate 8 x) = 1#1 →
    ¬ofBool (x &&& 192#32 == 0#32) = 1#1 → 2#32 = 1#32

theorem thisdoesnotloop_thm.extracted_1._2 : ∀ (x x_1 : BitVec 32),
  ofBool (x_1 <ₛ BitVec.ofInt 32 (-128)) = 1#1 → truncate 8 128#32 = BitVec.ofInt 8 (-128)

theorem sgt_swap_and_not_min_logical_proof : sgt_swap_and_not_min_logical_before ⊑ sgt_swap_and_not_min_logical_after

theorem test35_with_trunc_thm (e : IntW 64) :
  select (icmp IntPred.sge (trunc 32 e) (const? 32 0)) (const? 32 60) (const? 32 100) ⊑
    select (icmp IntPred.eq (LLVM.and e (const? 64 2147483648)) (const? 64 0)) (const? 32 60)
      (const? 32 100)

theorem test2_proof : test2_before ⊑ test2_after

theorem positive_biggershl_shlnuw_lshrexact_thm.extracted_1._2 : ∀ (x : BitVec 8),
  ¬(True ∧ x >>> 3#8 <<< 3#8 ≠ x ∨ 3#8 ≥ ↑8 ∨ True ∧ x >>> 3#8 <<< 6#8 >>> 6#8 ≠ x >>> 3#8 ∨ 6#8 ≥ ↑8) →
    ¬(True ∧ x <<< 3#8 >>> 3#8 ≠ x ∨ 3#8 ≥ ↑8) → x >>> 3#8 <<< 6#8 = x <<< 3#8

theorem e_801 :
     - 11 * t - 1 *  ~~~(z &&&  ~~~t) + 18 *  ~~~(z |||  ~~~t) + 6 * (z &&&  ~~~t) + 18 * (z &&& t) = 6 * (z ||| t) - 1 *  ~~~(z ||| t)

theorem lshr_xor_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ¬(3#8 ≥ ↑8 ∨ (42#8 == 0 || 8 != 1 && x == intMin 8 && 42#8 == -1) = true ∨ 3#8 ≥ ↑8) →
    (42#8 == 0 || 8 != 1 && x == intMin 8 && 42#8 == -1) = true ∨ 3#8 ≥ ↑8 → False

theorem or_nosignbit_select_shl_thm.extracted_1._1 : ∀ (x : BitVec 32) (x_1 : BitVec 1),
  x_1 = 1#1 → ¬8#32 ≥ ↑32 → (x ||| 2147418112#32) <<< 8#32 = x <<< 8#32 ||

theorem exact_lshr_ne_opposite_msb_proof : exact_lshr_ne_opposite_msb_before ⊑ exact_lshr_ne_opposite_msb_after

theorem e_2430 :
    1 * e + 1 * ( ~~~(d |||  ~~~e) |||  ~~~(d ^^^ (e ^^^ f))) - 5 * ((d ^^^ e) |||  ~~~(d ^^^ f)) - 6 * (d ||| (e ^^^ f)) + 1 * (e |||  ~~~(d |||  ~~~f)) - 6 * ((e &&& f) ||| ( ~~~d &&& (e ||| f))) - 2 * (e ||| (d &&&  ~~~f)) + 4 * (f ^^^ (d &&& ( ~~~e ||| f))) - 2 * ((d &&& e) ||| (d ^^^ (e ^^^ f))) + 2 * ( ~~~(d &&&  ~~~e) &&&  ~~~(d ^^^ (e ^^^ f))) + 4 * ((d |||  ~~~e) &&&  ~~~(e ^^^ f)) + 4 * (e ^^^ ( ~~~d &&& (e ||| f))) + 2 * ((d &&& e) ^^^  ~~~(d ^^^ (e &&& f))) + 1 * ( ~~~d ||| ( ~~~e ||| f)) + 2 * (f ^^^ ( ~~~d ||| (e &&& f))) - 11 *  ~~~(d &&& (e &&& f)) + 1 * ((d &&& e) |||  ~~~(e ^^^ f)) + 7 * (d ^^^ f) + 11 *  ~~~( ~~~d &&& ( ~~~e ||| f)) + 4 * ((e &&&  ~~~f) ^^^ (d ||| (e ^^^ f))) - 3 * (f ^^^ (d ||| ( ~~~e &&& f))) - 6 * (f ^^^  ~~~(d &&& (e &&& f))) + 5 * ((d &&& f) ^^^ (d ^^^ ( ~~~e &&& f))) - 5 * (e ^^^  ~~~( ~~~d ||| (e &&& f))) + 5 * (f &&&  ~~~(d &&& e)) + 1 * ((d &&& f) ^^^  ~~~(e &&&  ~~~f)) - 7 *  ~~~d + 3 * (d ^^^ (e ^^^ f)) + 2 *  ~~~( ~~~d &&& ( ~~~e &&& f)) - 5 * (f ^^^ (d &&& (e ||| f))) + 5 *  ~~~(d &&& f) + 2 * (f ^^^  ~~~(d &&& (e ||| f))) - 2 * (f ^^^  ~~~(d ||| (e &&& f))) + 3 * (e ^^^ f) - 2 * (e ^^^  ~~~( ~~~d ||| (e ^^^ f))) - 2 *  ~~~( ~~~d &&& (e ||| f)) - 1 *  ~~~( ~~~d &&& (e &&& f)) + 11 * (e ||| f) - 3 * (e &&& (d ||| f)) - 2 * ((e &&&  ~~~f) |||  ~~~(d ||| ( ~~~e &&& f))) - 1 * (e |||  ~~~(d ||| f)) - 3 *  ~~~(d ||| f) - 3 * (f ^^^  ~~~(d ||| e)) + 1 * ( ~~~d ||| ( ~~~e &&& f)) - 1 * (e &&&  ~~~(d &&& f)) - 11 * (e ^^^  ~~~( ~~~d &&& (e ||| f))) + 5 * ( ~~~d ||| (e ^^^ f)) + 11 * ((d &&& e) ^^^  ~~~(d ^^^ ( ~~~e ||| f))) - 2 *  ~~~e + 11 * (d ^^^ e) + 2 * ( ~~~(d &&& e) &&&  ~~~(d ^^^ (e ^^^ f))) + 1 * (e &&& (d ^^^ f)) - 7 * ( ~~~(d ^^^ e) ||| (d ^^^ f)) - 3 *  ~~~(d ^^^ ( ~~~e ||| f)) + 7 * ((d &&& e) ^^^ (d ^^^ (e &&& f))) + 11 * ( ~~~(d &&&  ~~~e) &&&  ~~~(e ^^^ f)) - 2 *  ~~~( ~~~d ||| ( ~~~e &&& f)) + 1 * ( ~~~(d |||  ~~~e) ||| (e ^^^ f)) - 1 *  ~~~(d ^^^ (e ^^^ f)) + 1 *  ~~~(e &&& f) + 2 *  ~~~(d ||| e) + 5 * ( ~~~(d ^^^ e) &&&  ~~~(d ^^^ f)) + 1 * (f ^^^  ~~~( ~~~d &&& (e &&& f))) - 1 * (f |||  ~~~(d |||  ~~~e)) - 1 * ((d &&& f) |||  ~~~(e ||| f)) + 4 * (d |||  ~~~f) - 6 * (d ||| (e ||| f)) + 10 *  ~~~(d ||| (e ||| f)) + 3 *  ~~~(d ||| ( ~~~e ||| f)) - 8 *  ~~~( ~~~d ||| (e ||| f)) - 10 *  ~~~( ~~~d ||| ( ~~~e ||| f)) - 5 * ( ~~~d &&& ( ~~~e &&& f)) + 9 * ( ~~~d &&& (e &&& f)) - 30 * (d &&& ( ~~~e &&& f)) - 1 * (d &&& (e &&& f)) = 7 * (e ^^^ ( ~~~d &&& (e ^^^ f)))

theorem and_logic_and_logic_or_3_proof : and_logic_and_logic_or_3_before ⊑ and_logic_and_logic_or_3_after

theorem demorgan_or_apint2_proof : demorgan_or_apint2_before ⊑ demorgan_or_apint2_after

theorem xor_logic_and_logic_or2_thm.extracted_1._1 : ∀ (x x_1 : BitVec 1), ¬x_1 = 1#1 → x = 1#1 → 0#1 ^^^ 1#1 = x

@[simp]
lemma CNFA.SignedCmp_stateMax cmp : (autSignedCmp cmp).m.stateMax = 5

theorem com_Γ : com.1 = (Γn 1)

theorem lshr_sub_proof : lshr_sub_before ⊑ lshr_sub_after

theorem shl_bad_sub_i8_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬4#8 - x ≥ ↑8 → True ∧ 1#8 <<< (4#8 - x) >>> (4#8 - x) ≠ 1#8 ∨ 4#8 - x ≥ ↑8 → False

theorem e_2322 :
    5 *  ~~~( ~~~d &&& (e ^^^ f)) + 4 *  ~~~(d &&& ( ~~~e &&& f)) - 1 * ( ~~~(d ^^^ e) |||  ~~~(d ^^^ f)) + 7 * (e ^^^ (d ||| f)) - 1 * ( ~~~(d ||| e) ||| (d ^^^ (e ^^^ f))) + 1 * ((d ||| e) &&&  ~~~(d ^^^ (e ^^^ f))) - 2 * ( ~~~(d ^^^ e) &&& (d ^^^ f)) + 11 * ( ~~~(d &&&  ~~~e) &&&  ~~~(d ^^^ (e ^^^ f))) - 2 * ( ~~~e &&& (d ^^^ f)) + 5 * ( ~~~(d |||  ~~~e) ||| (e ^^^ f)) + 1 * (f ^^^ (d ||| (e ||| f))) - 2 *  ~~~(d &&& f) + 1 * (e ^^^  ~~~(d &&& ( ~~~e &&& f))) - 5 * ((d &&& e) ^^^  ~~~(d ^^^ (e &&& f))) - 5 * (f ^^^  ~~~( ~~~d ||| ( ~~~e &&& f))) - 5 *  ~~~e - 1 * ((d &&& f) ^^^ (d ^^^ ( ~~~e &&& f))) + 1 * (e ^^^  ~~~( ~~~d &&& (e ||| f))) - 11 * (e ^^^  ~~~(d &&& (e ||| f))) + 3 * ((d &&& f) ^^^  ~~~(d ^^^ (e &&& f))) + 4 * (f ^^^ (d &&& ( ~~~e ||| f))) + 2 * (e &&& f) - 6 * ( ~~~d ||| (e ^^^ f)) + 5 * (e ^^^ (d |||  ~~~f)) + 11 * (e ^^^ (d &&& (e ^^^ f))) + 7 * ((e &&&  ~~~f) ^^^ (d ||| (e ^^^ f))) + 1 *  ~~~(d ||| e) - 6 *  ~~~(d &&& (e &&& f)) + 1 * ((d &&& f) ^^^  ~~~(e &&&  ~~~f)) + 7 * (e ^^^ (d &&& (e ||| f))) + 4 * (e ^^^ ( ~~~d &&& ( ~~~e ||| f))) - 3 *  ~~~(e &&&  ~~~f) + 1 * (f &&&  ~~~(d ^^^ e)) + 2 * (f ^^^  ~~~(d ||| e)) - 1 * (e ^^^  ~~~(d &&&  ~~~f)) - 11 * (e ^^^  ~~~( ~~~d ||| ( ~~~e &&& f))) + 1 *  ~~~(d ||| (e ^^^ f)) - 1 * (f ^^^  ~~~(d &&& ( ~~~e ||| f))) + 2 * d - 6 * (f ^^^ (d ||| (e &&& f))) - 2 *  ~~~(d ^^^ (e ^^^ f)) + 1 * (e &&& (d ^^^ f)) + 7 * (e ^^^ (d &&& f)) - 1 * ( ~~~(d ^^^ e) ||| (d ^^^ f)) + 1 * ( ~~~d &&& (e ^^^ f)) - 2 * ((d &&&  ~~~e) ||| (d ^^^ (e ^^^ f))) - 7 * (e ^^^  ~~~(d ||| f)) + 7 * (f ^^^  ~~~( ~~~d ||| (e &&& f))) + 2 *  ~~~(d &&& (e ^^^ f)) - 1 * (d &&& (e ||| f)) + 3 *  ~~~( ~~~d &&& ( ~~~e &&& f)) + 3 *  ~~~( ~~~d ||| ( ~~~e &&& f)) + 4 * ((d &&& f) |||  ~~~(e ||| f)) + 2 * ((d &&& f) ||| (e &&&  ~~~f)) - 11 * (e ^^^  ~~~( ~~~d ||| (e ^^^ f))) + 1 * ((e &&&  ~~~f) |||  ~~~( ~~~d ||| ( ~~~e &&& f))) + 5 * ( ~~~d ||| (e &&& f)) - 1 *  ~~~(d ||| (e ||| f)) - 18 *  ~~~(d ||| ( ~~~e ||| f)) + 9 *  ~~~( ~~~d ||| (e ||| f)) + 12 *  ~~~( ~~~d ||| ( ~~~e ||| f)) + 7 * ( ~~~d &&& ( ~~~e &&& f)) - 31 * ( ~~~d &&& (e &&& f)) - 37 * (d &&& (e &&& f)) = 38 * (d &&& ( ~~~e &&& f))

theorem masked_icmps_mask_notallzeros_bmask_mixed_negated_swapped_5_logical_proof : masked_icmps_mask_notallzeros_bmask_mixed_negated_swapped_5_logical_before ⊑ masked_icmps_mask_notallzeros_bmask_mixed_negated_swapped_5_logical_after

theorem eq_commuted_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ¬(x == 0 || 8 != 1 && 43#8 == intMin 8 && x == -1) = true →
    ofBool (x_1 == 0#8) ||

@[simp]
theorem Array.take_ge_size {a : Array α} {n} (h : n ≥ a.size) : a.take n = a

theorem lshr_shl_pow2_const_overflow_proof : lshr_shl_pow2_const_overflow_before ⊑ lshr_shl_pow2_const_overflow_after

theorem t10_proof : t10_before ⊑ t10_after

theorem sub_sext_mask1_trunc_lshr_proof : sub_sext_mask1_trunc_lshr_before ⊑ sub_sext_mask1_trunc_lshr_after

theorem e_2389 :
     - 1 * (f ^^^  ~~~( ~~~d ||| (e &&& f))) + 11 * (e ^^^ ( ~~~d ||| (e &&& f))) + 2 * (f ^^^  ~~~(d &&& e)) + 4 * (f ^^^  ~~~( ~~~d &&& ( ~~~e &&& f))) - 2 * ((d &&& e) ^^^ (e ||| f)) + 1 * ((d &&& e) |||  ~~~(e ^^^ f)) + 2 * ( ~~~(d ^^^ e) &&& (d ^^^ f)) + 2 * (e ^^^ (d &&& f)) + 1 * (f &&&  ~~~(d ^^^ e)) - 5 * (f &&& (d ^^^ e)) - 1 * ( ~~~d ||| (e ||| f)) - 1 * (e ^^^ (d &&& (e ^^^ f))) - 2 * (e ^^^ ( ~~~d &&& ( ~~~e ||| f))) + 5 * (e ^^^ (d ||| (e ^^^ f))) + 1 * (f ^^^  ~~~(d &&& (e &&& f))) + 11 * (e ^^^  ~~~(d ||| ( ~~~e &&& f))) + 7 *  ~~~(d ^^^ (e ^^^ f)) - 1 * (f ^^^ ( ~~~d &&& ( ~~~e ||| f))) + 2 * (d &&& ( ~~~e ||| f)) - 1 * ((d &&&  ~~~e) |||  ~~~(e ^^^ f)) - 1 * ( ~~~(d &&& e) &&& (d ^^^ (e ^^^ f))) - 3 *  ~~~(e ^^^ f) + 1 * ( ~~~d &&& ( ~~~e ||| f)) - 5 * ( ~~~(d ||| e) |||  ~~~(d ^^^ (e ^^^ f))) + 3 * (e ^^^ (d ||| (e ||| f))) + 1 *  ~~~(d &&& (e ^^^ f)) + 1 * ((d &&& f) |||  ~~~(e ||| f)) - 7 * (f &&& (d ||| e)) + 2 * ( ~~~d ||| (e &&& f)) + 3 * (e ^^^  ~~~( ~~~d ||| (e ^^^ f))) - 7 * ((d |||  ~~~e) &&&  ~~~(d ^^^ (e ^^^ f))) - 2 * ((d ||| e) &&& (d ^^^ (e ^^^ f))) + 1 *  ~~~( ~~~d ||| ( ~~~e &&& f)) + 2 * ( ~~~f |||  ~~~(d ^^^ e)) - 2 * ((d ||| e) &&& (e ^^^ f)) + 2 * (f ^^^ ( ~~~d ||| ( ~~~e ||| f))) - 1 * ((d &&& e) |||  ~~~(e ||| f)) - 5 * ((e &&&  ~~~f) |||  ~~~( ~~~d ||| ( ~~~e &&& f))) - 6 * (d ^^^ ( ~~~e ||| f)) + 3 *  ~~~(e &&&  ~~~f) + 1 * (d &&& (e ||| f)) - 1 * (f ^^^ (d ||| (e &&& f))) - 6 * (d |||  ~~~e) - 11 * ((d ^^^ e) ||| (d ^^^ f)) - 1 *  ~~~(d &&& f) - 2 * (f ^^^  ~~~(d |||  ~~~e)) - 3 *  ~~~( ~~~d &&& (e &&& f)) + 11 *  ~~~(d ||| f) - 2 *  ~~~(d &&&  ~~~f) - 1 * ((d &&& e) ^^^ (e |||  ~~~f)) + 1 * (f ^^^ (d ||| ( ~~~e ||| f))) + 11 * (f |||  ~~~(d |||  ~~~e)) - 1 * ((e &&& f) ^^^  ~~~( ~~~d &&& (e ^^^ f))) - 7 * ( ~~~d ||| ( ~~~e &&& f)) - 2 * ((d &&& f) ^^^ (e ||| f)) + 1 * (f ^^^  ~~~(d ||| (e &&& f))) + 2 * (f ^^^ (d ||| e)) + 4 * (d ||| ( ~~~e ||| f)) - 11 * (f ^^^ (d &&&  ~~~e)) + 1 * (f ^^^ ( ~~~d &&& (e ||| f))) - 5 * (d ||| ( ~~~e &&& f)) - 7 * ((d &&& e) |||  ~~~(d ^^^ (e ^^^ f))) + 7 * (e ^^^ (d &&&  ~~~f)) - 11 *  ~~~(d ||| (e ||| f)) + 4 *  ~~~(d ||| ( ~~~e ||| f)) + 20 *  ~~~( ~~~d ||| (e ||| f)) + 25 *  ~~~( ~~~d ||| ( ~~~e ||| f)) + 17 * ( ~~~d &&& ( ~~~e &&& f)) + 26 * ( ~~~d &&& (e &&& f)) + 46 * (d &&& ( ~~~e &&& f)) + 8 * (d &&& (e &&& f)) = 11 * ((d &&& e) ^^^  ~~~(d ^^^ ( ~~~e ||| f)))

theorem test_and_ne_a_b_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8) (x_2 : BitVec 1),
  x_2 &&& ofBool (x_1 != x) = 1#1 → ¬x_2 = 1#1 → x_1 = x

theorem trunc_lshr_sext_exact_thm (e : IntW 8) :
  trunc 8 (lshr (sext 32 e) (const? 32 6) { «exact» := true }) ⊑ ashr e (const? 8 6) { «exact» := true }

theorem or_consts_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (4#32 &&& x != 0#32) &&& ofBool (8#32 &&& x != 0#32) = ofBool (x &&& 12#32 == 12#32)

theorem ashrsgt_01_09_proof : ashrsgt_01_09_before ⊑ ashrsgt_01_09_after

theorem lt_signed_to_small_unsigned_proof : lt_signed_to_small_unsigned_before ⊑ lt_signed_to_small_unsigned_after

theorem test9_proof : test9_before ⊑ test9_after

theorem main3d_logical_thm.extracted_1._3 : ∀ (x : BitVec 32),
  ¬ofBool (x &&& 7#32 != 0#32) = 1#1 →
    ofBool (x &&& 16#32 == 16#32) = 1#1 → 0#32 = zeroExtend 32 (ofBool (x &&& 23#32 == 0#32))

theorem test13_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32), ¬(8#32 ≥ ↑32 ∨ 8#32 ≥ ↑32) → 8#32 ≥ ↑32 → False

theorem ashrsgt_01_09_thm (e : IntW 4) : icmp IntPred.sgt (ashr e (const? 4 1)) (const? 4 (-7)) ⊑ const? 1 1

theorem lshrult_01_06_exact_thm (e : IntW 4) :
  icmp IntPred.ult (lshr e (const? 4 1) { «exact» := true }) (const? 4 6) ⊑
    icmp IntPred.ult e (const? 4 (-4))

theorem sub_ashr_and_i32_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬(True ∧ x_1.ssubOverflow x = true ∨ 31#32 ≥ ↑32) →
    ofBool (x_1 <ₛ x) = 1#1 → (x_1 - x).sshiftRight' 31#32 &&& x = x

theorem negate_xor_proof : negate_xor_before ⊑ negate_xor_after

theorem and_logic_and_logic_or_5_thm.extracted_1._2 : ∀ (x x_1 : BitVec 1), ¬x_1 = 1#1 → 0#1 = 1#1 → 1#1 = 0#1

theorem scalar_i32_lshr_and_negC_ne_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬x ≥ ↑32 → ofBool (x_1 >>> x &&& BitVec.ofInt 32 (-262144) != 0#32) = ofBool (262143#32 <ᵤ x_1 >>> x)

@[simp]
theorem Expr.regArgs_mk {Γ : Ctxt d.Ty} {ty eff op}
    (ty_eq : ty = DialectSignature.returnTypes op)
    (eff_le : DialectSignature.effectKind op ≤ eff)
    (args : HVector (Var Γ) (DialectSignature.sig op)) (regArgs) :
    (Expr.mk op ty_eq eff_le args regArgs).regArgs = regArgs

theorem scalar_i32_shl_and_signbit_ne_proof : scalar_i32_shl_and_signbit_ne_before ⊑ scalar_i32_shl_and_signbit_ne_after

theorem ashrslt_02_07_proof : ashrslt_02_07_before ⊑ ashrslt_02_07_after

theorem add_constant_equal_with_the_top_bit_of_demandedbits_insertpt_proof : add_constant_equal_with_the_top_bit_of_demandedbits_insertpt_before ⊑ add_constant_equal_with_the_top_bit_of_demandedbits_insertpt_after

theorem or_eq_with_one_bit_diff_constants2_logical_proof : or_eq_with_one_bit_diff_constants2_logical_before ⊑ or_eq_with_one_bit_diff_constants2_logical_after

theorem or_xor_or_proof : or_xor_or_before ⊑ or_xor_or_after

@[simp]
theorem Factor.numVars_term : (Factor.var n).numVars = n + 1

theorem pow2_or_zero_is_negative_commute_thm (e : IntW 8) :
  icmp IntPred.slt (LLVM.and (sub (const? 8 0) (mul (const? 8 42) e)) (mul (const? 8 42) e)) (const? 8 0) ⊑
    icmp IntPred.eq (mul e (const? 8 42)) (const? 8 (-128))

theorem logical_or_bitwise_or_icmps_comm1_thm.extracted_1._2 : ∀ (x x_1 x_2 : BitVec 8),
  ¬x_1 ≥ ↑8 → ofBool (x_2 &&& 1#8 <<< x_1 == 0#8) = 1#1 → True ∧ 1#8 <<< x_1 >>> x_1 ≠ 1#8 ∨ x_1 ≥ ↑8 → False

theorem xor_notand_to_or_not4_proof : xor_notand_to_or_not4_before ⊑ xor_notand_to_or_not4_after

theorem ripple_nsw3_thm (e e_1 : IntW 16) :
  add (LLVM.and e_1 (const? 16 (-21845))) (LLVM.and e (const? 16 21843)) ⊑
    add (LLVM.and e_1 (const? 16 (-21845))) (LLVM.and e (const? 16 21843)) { «nsw» := true, «nuw» := true }

theorem e_1485 :
     - 2 *  ~~~(z &&&  ~~~t) + 2 *  ~~~(z &&& t) + 5 * z + 1 * (z |||  ~~~t) - 2 *  ~~~z + 3 *  ~~~(z ^^^ t) + 1 * (z ^^^ t) - 3 *  ~~~(z &&&  ~~~z) + 1 *  ~~~(z ||| t) + 12 *  ~~~(z |||  ~~~t) + 4 * (z &&& t) = 2 * t + 6 * (z ||| t)

theorem intMin_eq_one {w : Nat} (hw : w ≤ 1): BitVec.intMin w = 1

theorem test14_thm (e : IntW 32) (e_1 : IntW 64) :
  urem e_1 (zext 64 (shl (const? 32 1) e)) ⊑
    LLVM.and e_1
      (add (zext 64 (shl (const? 32 1) e { «nsw» := false, «nuw» := true })) (const? 64 (-1))
        { «nsw» := true, «nuw» := false })

theorem sdiv_icmp6_proof : sdiv_icmp6_before ⊑ sdiv_icmp6_after

theorem e_1369 :
    2 * (z |||  ~~~t) + 3 *  ~~~t - 1 * (z ||| t) - 6 *  ~~~(z &&&  ~~~z) - 2 * t - 5 * (z ^^^ t) + 2 *  ~~~(z &&& t) + 12 *  ~~~(z |||  ~~~t) + 5 * (z &&&  ~~~t) + 8 * (z &&& t) = 1 *  ~~~(z ^^^ t)

theorem a_true_implies_b_false2_comm_thm.extracted_1._8 : ∀ (x x_1 : BitVec 1) (x_2 : BitVec 8),
  ¬ofBool (x_2 == 10#8) = 1#1 → ¬ofBool (20#8 <ᵤ x_2) = 1#1 → x &&& ofBool (20#8 <ᵤ x_2) = 0#1

theorem test15e_proof : test15e_before ⊑ test15e_after

theorem add_const_const_sub_nsw_proof : add_const_const_sub_nsw_before ⊑ add_const_const_sub_nsw_after

theorem t0_thm.extracted_1._2 : ∀ (x : BitVec 16) (x_1 : BitVec 32),
  ¬(zeroExtend 32 (32#16 - x) ≥ ↑32 ∨ x + -1#16 ≥ ↑16) →
    ¬(31#32 ≥ ↑32 ∨ True ∧ signExtend 32 (truncate 16 (x_1.sshiftRight' 31#32)) ≠ x_1.sshiftRight' 31#32) →
      (truncate 16 (x_1.sshiftRight' (zeroExtend 32 (32#16 - x)))).sshiftRight' (x + -1#16) =
        truncate 16 (x_1.sshiftRight' 31#32)

theorem sdiv_i1_is_op0_thm (e e_1 : IntW 1) : LLVM.sdiv e_1 e ⊑ e_1

theorem exact_ashr_ne_both_equal_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬(True ∧ BitVec.ofInt 8 (-128) >>> x <<< x ≠ BitVec.ofInt 8 (-128) ∨ x ≥ ↑8) →
    ofBool ((BitVec.ofInt 8 (-128)).sshiftRight' x != BitVec.ofInt 8 (-128)) = ofBool (x != 0#8)

theorem test7_logical_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬ofBool (x <ₛ 1#32) = 1#1 → ofBool (x == 0#32) = 1#1 → ¬0#1 = 1#1 → False

theorem testi16i8_ne_com_thm.extracted_1._1 : ∀ (x : BitVec 16),
  ¬(8#16 ≥ ↑16 ∨ 7#8 ≥ ↑8) →
    ofBool (truncate 8 (x >>> 8#16) != (truncate 8 x).sshiftRight' 7#8) =
      ofBool (x + BitVec.ofInt 16 (-128) <ᵤ BitVec.ofInt 16 (-256))

theorem and_signbit_select_ashr_proof : and_signbit_select_ashr_before ⊑ and_signbit_select_ashr_after

theorem e_1498 :
     - 1 * z + 4 *  ~~~t + 3 *  ~~~(z ^^^ t) + 2 *  ~~~(z &&&  ~~~z) + 5 * (z |||  ~~~t) + 1 *  ~~~z + 1 *  ~~~(z &&& t) - 16 *  ~~~(z ||| t) - 15 *  ~~~(z |||  ~~~t) - 11 * (z &&&  ~~~t) - 20 * (z &&& t) =  - 11 * t

theorem main11_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x &&& 64#32 == 0#32) ||

theorem positive_biggerlshr_shlnsw_lshrexact_thm (e : IntW 8) :
  shl (lshr e (const? 8 6) { «exact» := true }) (const? 8 3) { «nsw» := true, «nuw» := false } ⊑
    lshr e (const? 8 3) { «exact» := true }

theorem p0_proof : p0_before ⊑ p0_after

theorem e_1045 :
     - 1 *  ~~~(z &&&  ~~~t) + 1 *  ~~~(z &&&  ~~~z) + 1 * (z ||| t) - 5 * (z |||  ~~~t) + 1 *  ~~~(z |||  ~~~t) + 5 * (z &&&  ~~~t) + 4 * (z &&& t) = 2 *  ~~~(z &&& t) - 7 *  ~~~(z ||| t)

theorem slt_negative_multip_rem_zero_thm (e : IntW 8) :
  icmp IntPred.slt (mul e (const? 8 (-7)) { «nsw» := true, «nuw» := false }) (const? 8 21) ⊑
    icmp IntPred.sgt e (const? 8 (-3))

@[simp]
lemma Fin.clamp_eq_bound : Fin.clamp m n = Fin.last n ↔ n ≤ m

theorem or2_thm (e e_1 : IntW 64) : LLVM.or (LLVM.and e_1 e) (LLVM.xor e_1 e) ⊑ LLVM.or e_1 e

theorem no_shift_no_xor_multiuse_cmp_or_thm.extracted_1._2 : ∀ (x x_1 x_2 : BitVec 32),
  ¬ofBool (x_2 &&& 4096#32 == 0#32) = 1#1 →
    (x_1 ||| 4096#32) * x * (x_1 ||| 4096#32) = (x_1 ||| x_2 &&& 4096#32) * x * (x_1 ||| 4096#32)

theorem e_140 :
     - 11 *  ~~~x + 5 * (x ||| y) + 4 *  ~~~(x ^^^ y) + 7 *  ~~~(x ||| y) + 6 *  ~~~(x |||  ~~~y) - 9 * (x &&& y) = 5 * (x &&&  ~~~y)

theorem lshrult_03_07_thm.extracted_1._1 : ∀ (x : BitVec 4), ¬3#4 ≥ ↑4 → ofBool (x >>> 3#4 <ᵤ 7#4) = 1#1

@[bv_multi_width_normalize]
theorem BitVec.lt_ult {x y : BitVec w} : (x < y) = (x.ult y)

theorem test19_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32), x_1 ^^^ x ^^^ x_1 = x

theorem AvoidCollision_setWidth_shiftLeft_of_le {x : BitVec w} {y : Nat} (hi : i ≤ w)  :
    (x <<< y).setWidth i = x.setWidth i <<< y

theorem add_select_not_zext_thm (e : IntW 1) :
  add (select e (const? 64 64) (const? 64 1)) (zext 64 (LLVM.xor e (const? 1 1))) ⊑
    select e (const? 64 64) (const? 64 2)

theorem test8_thm (e : IntW 32) :
  icmp IntPred.ugt (LLVM.udiv (const? 32 4) e) (const? 32 3) ⊑ icmp IntPred.ult e (const? 32 2)

theorem c0_proof : c0_before ⊑ c0_after

theorem positive_with_extra_and_proof : positive_with_extra_and_before ⊑ positive_with_extra_and_after

theorem t7_thm.extracted_1._4 : ∀ (x : BitVec 8) (x_1 : BitVec 1) (x_2 : BitVec 8),
  ¬x_1 = 1#1 →
    ¬x ≥ ↑8 → ¬(True ∧ ((-1#8) <<< x).sshiftRight' x ≠ -1#8 ∨ x ≥ ↑8) → x_2 - 1#8 <<< x = (-1#8) <<< x + x_2

theorem or_and1_commuted_thm.extracted_1._6 : ∀ (x x_1 x_2 : BitVec 1),
  ¬x_2 &&& (x_1 ^^^ 1#1) = 1#1 → x_1 = 1#1 → x_1 = 1#1

theorem icmp_ne_sext_sgt_zero_nofold_proof : icmp_ne_sext_sgt_zero_nofold_before ⊑ icmp_ne_sext_sgt_zero_nofold_after

theorem _root_.AList.mem_of_mem_entries {α : Type _} {β : α → Type _} {s : AList β}
    {k : α} {v : β k} :
    ⟨k, v⟩ ∈ s.entries → k ∈ s

theorem icmp_select_implied_cond_swapped_select_thm.extracted_1._2 : ∀ (x x_1 : BitVec 8),
  ofBool (x_1 == 0#8) = 1#1 → ofBool (x == x_1) = ofBool (x == 0#8)

theorem clear_to_clear_decomposebittest_thm.extracted_1._2 : ∀ (x : BitVec 8),
  ofBool (-1#8 <ₛ x) = 1#1 →
    ¬(True ∧ (x &&& BitVec.ofInt 8 (-128) &&& 3#8 != 0) = true) → 3#8 = x &&& BitVec.ofInt 8 (-128) ||

theorem e_632 :
    2 *  ~~~(x &&&  ~~~x) + 7 *  ~~~x + 2 * (x |||  ~~~y) + 2 * (x ||| y) - 7 * x + 2 *  ~~~(x &&&  ~~~y) - 15 *  ~~~(x ||| y) - 13 *  ~~~(x |||  ~~~y) - 1 * (x &&&  ~~~y) - 1 * (x &&& y) =  - 2 *  ~~~y

theorem e_1084 :
     - 6 * t + 1 *  ~~~(z &&& t) + 1 * z - 6 *  ~~~(z ^^^ t) - 1 * (z ||| t) + 5 *  ~~~(z ||| t) + 6 *  ~~~(z |||  ~~~t) - 1 * (z &&&  ~~~t) =  - 12 * (z &&& t)

theorem bools2_logical_commute1_and1_thm.extracted_1._7 : ∀ (x x_1 x_2 : BitVec 1),
  ¬x_2 &&& x_1 = 1#1 → x_1 ^^^ 1#1 = 1#1 → x_1 = 1#1 → x = x_2

theorem e_2059 :
    2 * (f ^^^  ~~~(d |||  ~~~e)) - 1 * (e ||| (d &&& f)) + 3 * ((e &&& f) ||| (d &&& (e ||| f))) + 11 * (e ^^^ ( ~~~d ||| (e ^^^ f))) + 1 * (d &&& e) - 1 * (e ^^^  ~~~( ~~~d ||| (e ^^^ f))) + 1 * (f ^^^  ~~~( ~~~d ||| ( ~~~e &&& f))) - 6 * (e ^^^ (d ||| ( ~~~e &&& f))) - 1 * (e ^^^ ( ~~~d ||| ( ~~~e ||| f))) + 7 * (e ^^^  ~~~( ~~~d ||| ( ~~~e &&& f))) + 3 * (e ^^^ ( ~~~d ||| (e ||| f))) + 7 * (f &&& (d ^^^ e)) - 1 * (f &&&  ~~~(d ^^^ e)) - 11 * (f ^^^  ~~~(d ||| (e &&& f))) - 2 * (f ^^^  ~~~(d &&& ( ~~~e &&& f))) - 2 * ( ~~~(d ^^^ e) &&& (d ^^^ f)) - 1 *  ~~~(d &&&  ~~~f) + 1 *  ~~~(d ||| ( ~~~e &&& f)) - 3 * (f &&&  ~~~(d &&&  ~~~e)) + 1 *  ~~~(d &&& ( ~~~e ||| f)) + 5 * (e ^^^ (d ||| (e &&& f))) - 3 *  ~~~( ~~~d &&& ( ~~~e &&& f)) + 7 * (e &&&  ~~~(d &&& f)) - 1 *  ~~~(d ||| (e &&& f)) - 3 * ( ~~~e &&& (d ^^^ f)) - 7 * (e ^^^ ( ~~~d &&& (e ^^^ f))) - 1 * (f ^^^  ~~~(d &&&  ~~~e)) - 5 * ( ~~~d &&& (e ||| f)) + 1 * ((d ||| e) &&& (d ^^^ (e ^^^ f))) - 11 *  ~~~(d ||| e) + 12 *  ~~~(d ||| (e ||| f)) + 5 *  ~~~(d ||| ( ~~~e ||| f)) - 1 *  ~~~( ~~~d ||| (e ||| f)) + 4 *  ~~~( ~~~d ||| ( ~~~e ||| f)) + 23 * ( ~~~d &&& ( ~~~e &&& f)) + 9 * ( ~~~d &&& (e &&& f)) - 9 * (d &&& ( ~~~e &&& f)) + 8 * (d &&& (e &&& f)) =  - 1 * (d |||  ~~~f) - 2 * (e ^^^  ~~~( ~~~d &&& (e ||| f)))

theorem main14_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (0#16 ≤ₛ truncate 16 x) &&& ofBool (0#8 ≤ₛ truncate 8 x) = 1#1 →
    ¬ofBool (x &&& 32896#32 == 0#32) = 1#1 → 2#32 = 1#32

theorem ule_swap_or_min_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ofBool (x ≤ᵤ x_1) ||

theorem icmp_ne_and_pow2_shl_pow2_proof : icmp_ne_and_pow2_shl_pow2_before ⊑ icmp_ne_and_pow2_shl_pow2_after

theorem narrow_sext_mul_proof : narrow_sext_mul_before ⊑ narrow_sext_mul_after

theorem masked_icmps_mask_notallzeros_bmask_mixed_negated_4_logical_thm (e : IntW 32) :
  select (icmp IntPred.eq (LLVM.and e (const? 32 255)) (const? 32 0)) (const? 1 1)
      (icmp IntPred.ne (LLVM.and e (const? 32 15)) (const? 32 8)) ⊑
    icmp IntPred.ne (LLVM.and e (const? 32 15)) (const? 32 8)

theorem test69_xor_thm.extracted_1._2 : ∀ (x x_1 : BitVec 32),
  ofBool (x_1 &&& 128#32 != 0#32) = 1#1 → ¬6#32 ≥ ↑32 → x = x_1 >>> 6#32 &&& 2#32 ^^^ x ^^^ 2#32

theorem e_721 :
    3 *  ~~~x - 1 * (x |||  ~~~y) + 3 *  ~~~(x &&&  ~~~y) - 2 *  ~~~y + 7 *  ~~~(x &&& y) - 3 * x - 6 * (x ^^^ y) - 1 * (x ||| y) - 10 *  ~~~(x ||| y) + 6 * (x &&&  ~~~y) + 2 * (x &&& y) = 6 *  ~~~(x |||  ~~~y)

theorem shift_xor_multiuse_cmp_xor_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 32),
  ofBool (0#32 != x_2 &&& 4096#32) = 1#1 → ofBool (x_2 &&& 4096#32 == 0#32) = 1#1 → False

theorem demorgan_and_apint2_proof : demorgan_and_apint2_before ⊑ demorgan_and_apint2_after

theorem lshr_add_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ¬(5#8 ≥ ↑8 ∨ (42#8 == 0 || 8 != 1 && x == intMin 8 && 42#8 == -1) = true ∨ 5#8 ≥ ↑8) →
    (42#8 == 0 || 8 != 1 && x == intMin 8 && 42#8 == -1) = true ∨ 5#8 ≥ ↑8 → False

theorem e_444 :
    1 *  ~~~(x &&&  ~~~x) - 5 *  ~~~y - 5 * (x ^^^ y) + 3 *  ~~~(x &&& y) + 1 *  ~~~(x ||| y) - 3 *  ~~~(x |||  ~~~y) + 5 * (x &&&  ~~~y) - 6 * (x &&& y) =  - 4 * y - 1 * x

theorem select_1_thm.extracted_1._19 : ∀ (x x_1 : BitVec 8) (x_2 : BitVec 1) (x_3 x_4 : BitVec 8) (x_5 : BitVec 1),
  ¬x_5 = 1#1 → x_2 = 1#1 → x_1 ^^^ -1#8 ^^^ -1#8 = x_1

theorem main7a_logical_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (x_1 &&& x == x_1) = 1#1 → ofBool (x_1 &&& x != x_1) = 1#1 → 0#1 = 1#1 → 0#32 = zeroExtend 32 1#1

theorem test4_thm.extracted_1._1 : ∀ (x : BitVec 49), (x &&& BitVec.ofInt 49 (-2)) + 1#49 = x ||

theorem e_2434 :
    1 * (d ||| f) - 2 *  ~~~(d ||| f) - 7 * (f &&&  ~~~(d &&&  ~~~e)) + 5 * (f ^^^  ~~~( ~~~d &&& (e &&& f))) + 1 * ((d &&& e) ^^^  ~~~(d ^^^ ( ~~~e ||| f))) - 7 * ( ~~~(d ^^^ e) &&& (d ^^^ f)) + 7 * (f ^^^  ~~~(d ||| (e &&& f))) - 7 * ( ~~~(d &&&  ~~~e) &&& (e ^^^ f)) - 2 * (e ^^^  ~~~( ~~~d ||| (e &&& f))) - 11 *  ~~~(d &&&  ~~~e) - 3 * (d &&&  ~~~e) + 1 * (e ^^^  ~~~(d &&& ( ~~~e ||| f))) - 5 * (e ^^^  ~~~(d ||| (e &&& f))) + 1 * ((e &&& f) ^^^  ~~~( ~~~d &&& (e ^^^ f))) + 2 * (f &&&  ~~~(d ^^^ e)) - 1 * ((e &&&  ~~~f) ^^^ (d ||| (e ^^^ f))) + 4 *  ~~~(d ^^^ (e &&& f)) - 3 * (e ^^^ (d ||| f)) + 11 * (d |||  ~~~e) + 1 * ((d &&& e) ^^^  ~~~(d ^^^ (e &&& f))) - 7 * ( ~~~(d &&& e) &&& (d ^^^ (e ^^^ f))) - 1 * ( ~~~(d ||| e) ||| (d ^^^ (e ^^^ f))) - 2 * (f ^^^  ~~~(d &&& (e &&& f))) - 5 * (e ^^^ (d ||| ( ~~~e ||| f))) + 3 * (d ||| ( ~~~e &&& f)) + 4 *  ~~~( ~~~d &&& (e ^^^ f)) + 5 * (f ^^^  ~~~(d &&& (e ||| f))) - 6 *  ~~~(d ^^^ (e ^^^ f)) + 11 * (d &&& ( ~~~e ||| f)) + 1 * ( ~~~(d |||  ~~~e) ||| (d ^^^ (e ^^^ f))) + 7 * ((d &&& e) |||  ~~~(e ^^^ f)) + 3 * (e &&& f) - 2 * ((d ||| e) &&&  ~~~(d ^^^ (e ^^^ f))) + 1 * ((d &&& f) |||  ~~~(e ||| f)) - 11 *  ~~~(d ^^^ ( ~~~e ||| f)) - 3 * (d ^^^ e) + 7 * (f ^^^  ~~~(d &&& e)) + 5 *  ~~~( ~~~d ||| ( ~~~e &&& f)) - 1 * (e ^^^  ~~~( ~~~d ||| (e ^^^ f))) + 2 *  ~~~( ~~~d &&& ( ~~~e &&& f)) - 1 * (f ^^^ ( ~~~d ||| (e ||| f))) + 2 * (d &&& (e ^^^ f)) - 1 * ( ~~~(d ^^^ e) |||  ~~~(d ^^^ f)) - 5 * ( ~~~f &&&  ~~~(d ^^^ e)) - 7 * (f ^^^  ~~~(d |||  ~~~e)) - 1 * (e ^^^  ~~~(d &&& (e ^^^ f))) + 11 * ((d |||  ~~~e) &&&  ~~~(d ^^^ (e ^^^ f))) + 4 * (e ^^^  ~~~(d |||  ~~~f)) + 3 * (d ||| ( ~~~e ||| f)) + 1 * ( ~~~(d ||| e) ||| (e ^^^ f)) + 11 *  ~~~(e |||  ~~~f) + 7 * (e ^^^  ~~~(d &&& ( ~~~e &&& f))) + 2 *  ~~~(d &&&  ~~~d) - 2 * (e ^^^  ~~~(d ||| f)) - 1 * e + 2 *  ~~~(d &&& f) - 5 * ( ~~~(d &&& e) &&& (e ^^^ f)) - 6 * ((e &&& f) ||| (d &&& (e ||| f))) + 1 *  ~~~(e &&& f) + 2 * (e &&&  ~~~(d &&& f)) - 2 * (e ^^^ (d ||| ( ~~~e &&& f))) - 11 * (e |||  ~~~f) + 5 *  ~~~(d &&& (e ^^^ f)) - 1 * d + 1 * (f ^^^  ~~~( ~~~d &&& ( ~~~e ||| f))) + 7 * ((d &&& f) ||| (e &&&  ~~~f)) + 1 * ((d &&& f) ^^^ (d ^^^ ( ~~~e &&& f))) + 1 * (d ||| (e &&& f)) - 29 *  ~~~(d ||| (e ||| f)) + 25 *  ~~~(d ||| ( ~~~e ||| f)) - 33 *  ~~~( ~~~d ||| (e ||| f)) - 8 *  ~~~( ~~~d ||| ( ~~~e ||| f)) + 15 * ( ~~~d &&& ( ~~~e &&& f)) + 13 * ( ~~~d &&& (e &&& f)) - 23 * (d &&& ( ~~~e &&& f)) - 27 * (d &&& (e &&& f)) = 1 * (d ^^^ ( ~~~e &&& f)) + 6 * (e ^^^ ( ~~~d ||| (e ||| f)))

theorem main5f_like_logical_thm.extracted_1._9 : ∀ (x x_1 x_2 : BitVec 32),
  ¬ofBool (x_2 &&& x_1 != x_2) = 1#1 →
    ofBool (x_2 &&& x_1 == x_2) = 1#1 →
      ofBool (x_2 &&& x != x_2) = 1#1 → 0#32 = zeroExtend 32 (ofBool (x_2 &&& x == x_2))

theorem test3_thm.extracted_1._1 : ∀ (x : BitVec 32), ofBool (x <ₛ x) = 0#1

theorem uge_swap_and_max_commute_logical_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬ofBool (x == -1#8) = 1#1 → 0#1 = ofBool (x == -1#8)

theorem foo2_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (2#32 <ₛ x_1) = 1#1 → ¬(True ∧ x_1.ssubOverflow x = true) → x_1 - x = x_1 + (0#32 - x)

theorem uge_zext_proof : uge_zext_before ⊑ uge_zext_after

theorem ult_rem_zero_thm (e : IntW 8) :
  icmp IntPred.ult (mul e (const? 8 7) { «nsw» := false, «nuw» := true }) (const? 8 21) ⊑
    icmp IntPred.ult e (const? 8 3)

theorem mul_sel_op0_thm.extracted_1._2 : ∀ (x : BitVec 32) (x_1 : BitVec 1),
  ¬x_1 = 1#1 → ¬(True ∧ (42#32).umod x ≠ 0 ∨ x = 0) → 42#32 / x * x = 42#32

theorem udiv_lshr_mul_nuw_proof : udiv_lshr_mul_nuw_before ⊑ udiv_lshr_mul_nuw_after

theorem or_thm (e e_1 : IntW 64) : add (LLVM.and e_1 e) (LLVM.xor e_1 e) ⊑ LLVM.or e_1 e

theorem p_commutative4_proof : p_commutative4_before ⊑ p_commutative4_after

theorem and_logic_and_logic_or_1_thm.extracted_1._3 : ∀ (x x_1 x_2 : BitVec 1),
  x_2 &&& x_1 = 1#1 → x_2 = 1#1 → ¬x_1 = 1#1 → 1#1 = x

theorem positive_samevar_shlnsw_ashrexact_proof : positive_samevar_shlnsw_ashrexact_before ⊑ positive_samevar_shlnsw_ashrexact_after

theorem trunc_ashr_trunc_exact_thm.extracted_1._1 : ∀ (x : BitVec 64),
  ¬(True ∧ truncate 32 x >>> 8#32 <<< 8#32 ≠ truncate 32 x ∨ 8#32 ≥ ↑32) →
    True ∧ x >>> 8#64 <<< 8#64 ≠ x ∨ 8#64 ≥ ↑64 → False

theorem e_2321 :
     - 11 *  ~~~(e ^^^ f) + 2 * (e ^^^ (d &&& (e ^^^ f))) + 2 * ( ~~~f |||  ~~~(d ^^^ e)) - 11 * ( ~~~d ||| (e ||| f)) + 3 * (e ^^^  ~~~(d &&& ( ~~~e &&& f))) + 7 * ((d &&&  ~~~e) |||  ~~~(d ^^^ (e ^^^ f))) - 3 * (f &&&  ~~~(d &&& e)) - 7 * ((d &&&  ~~~e) ||| (d ^^^ (e ^^^ f))) + 1 * (d &&& ( ~~~e ||| f)) + 1 *  ~~~(d &&& ( ~~~e ||| f)) - 1 * (d &&&  ~~~f) + 1 * (e ^^^  ~~~(d ||| (e ^^^ f))) - 11 * ( ~~~(d &&& e) &&& (e ^^^ f)) - 2 * ((d &&& f) ^^^  ~~~(d ^^^ ( ~~~e &&& f))) + 2 *  ~~~(d &&& (e ^^^ f)) - 2 * (e |||  ~~~(d ||| f)) + 1 * (f ^^^ ( ~~~d ||| ( ~~~e &&& f))) - 11 * ((d &&& f) ^^^  ~~~(d ^^^ (e &&& f))) + 11 * (d ^^^ (e ^^^ f)) - 1 * ( ~~~d ||| (e &&& f)) - 1 * ((d ||| e) &&&  ~~~(e ^^^ f)) + 2 * ( ~~~f &&&  ~~~(d ^^^ e)) - 1 * (e ^^^  ~~~(d &&& (e ^^^ f))) - 1 * (e ^^^ ( ~~~d &&& ( ~~~e ||| f))) - 1 * (e ^^^ (d &&& f)) + 1 *  ~~~(d ^^^ (e &&& f)) - 2 * ((d ^^^ e) &&&  ~~~(d ^^^ f)) + 4 * (d |||  ~~~e) + 11 * ( ~~~d &&& (e ||| f)) - 3 * (d &&& e) + 7 * (e ^^^  ~~~(d ||| f)) + 3 * (e &&&  ~~~(d &&&  ~~~f)) + 7 * (f ^^^ (d ||| ( ~~~e ||| f))) - 1 * (f ^^^  ~~~( ~~~d &&& (e ||| f))) + 3 * ( ~~~d &&& (e ^^^ f)) - 6 * ((d ||| e) &&& (e ^^^ f)) - 5 * ((d |||  ~~~e) &&& (d ^^^ (e ^^^ f))) + 3 * (f &&& (d ||| e)) + 1 * ((d &&&  ~~~e) ||| (e ^^^ f)) - 3 * (f ^^^ ( ~~~d ||| ( ~~~e ||| f))) - 11 * (e ^^^ (d ||| f)) - 11 * ((d &&& e) ^^^  ~~~(d ^^^ (e &&& f))) + 1 * ( ~~~(d &&&  ~~~e) &&& (d ^^^ (e ^^^ f))) + 11 * (f &&&  ~~~(d &&&  ~~~e)) + 1 * (f ^^^ ( ~~~d ||| (e &&& f))) + 5 * ((d ^^^ e) &&& (d ^^^ f)) - 5 * (e ^^^ (d &&& (e ||| f))) - 1 * (d ||| (e &&& f)) + 2 * (e ^^^ (d |||  ~~~f)) + 1 * (d |||  ~~~f) - 7 * (f |||  ~~~(d ^^^ e)) - 5 *  ~~~( ~~~d ||| (e &&& f)) + 1 *  ~~~d + 3 * ( ~~~(d &&& e) &&&  ~~~(e ^^^ f)) + 11 * ( ~~~(d |||  ~~~e) ||| (d ^^^ (e ^^^ f))) - 7 * ( ~~~(d |||  ~~~e) ||| (e ^^^ f)) + 14 *  ~~~(d ||| (e ||| f)) + 38 *  ~~~(d ||| ( ~~~e ||| f)) - 13 *  ~~~( ~~~d ||| (e ||| f)) + 23 *  ~~~( ~~~d ||| ( ~~~e ||| f)) + 23 * ( ~~~d &&& ( ~~~e &&& f)) - 18 * ( ~~~d &&& (e &&& f)) + 66 * (d &&& ( ~~~e &&& f)) - 12 * (d &&& (e &&& f)) =  - 2 * (e ^^^  ~~~(d ||| (e &&& f)))

theorem positive_biggerashr_shlnuwnsw_ashrexact_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬(True ∧ x >>> 6#8 <<< 6#8 ≠ x ∨
        6#8 ≥ ↑8 ∨
          True ∧ (x.sshiftRight' 6#8 <<< 3#8).sshiftRight' 3#8 ≠ x.sshiftRight' 6#8 ∨
            True ∧ x.sshiftRight' 6#8 <<< 3#8 >>> 3#8 ≠ x.sshiftRight' 6#8 ∨ 3#8 ≥ ↑8) →
    True ∧ x >>> 3#8 <<< 3#8 ≠ x ∨ 3#8 ≥ ↑8 → False

theorem uge_or_max_proof : uge_or_max_before ⊑ uge_or_max_after

theorem masked_and_notA_logical_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x &&& 14#32 != x) = 1#1 → ofBool (x &&& 78#32 != x) = ofBool (x &&& BitVec.ofInt 32 (-79) != 0#32)

theorem xor_or_xor_common_op_commute5_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 32),
  (x_2 ||| x_1) ^^^ (x_2 ^^^ x) = x_1 &&& (x_2 ^^^ -1#32) ^^^ x

theorem e_897 :
     - 1 *  ~~~z + 2 *  ~~~(z &&& t) + 1 *  ~~~(z &&&  ~~~t) + 7 * t - 2 * (z &&&  ~~~t) - 8 * (z &&& t) = 2 *  ~~~(z ||| t) + 9 *  ~~~(z |||  ~~~t)

theorem p0_scalar_proof : p0_scalar_before ⊑ p0_scalar_after

theorem e_369 :
     - 5 * (x ^^^ y) - 3 * (x |||  ~~~y) - 11 * y + 2 * (x ||| y) + 5 *  ~~~(x ^^^ y) + 1 * x - 2 *  ~~~(x ||| y) + 5 * (x &&&  ~~~y) =  - 6 * (x &&& y) - 14 *  ~~~(x |||  ~~~y)

@[simp]
lemma CNFA.autUnsignedCmp_stateMax cmp : (autUnsignedCmp cmp).m.stateMax = 3

theorem test5_thm (e : IntW 32) :
  add (sext 64 (ashr e (const? 32 1))) (const? 64 1073741823) ⊑
    sext 64 (add (ashr e (const? 32 1)) (const? 32 1073741823) { «nsw» := true, «nuw» := false })

theorem e_751 :
     - 7 * (z ||| t) + 2 *  ~~~z + 7 * z =  - 5 *  ~~~(z |||  ~~~t) + 2 *  ~~~(z ||| t)

theorem substitute_constant_and_eq_ugt_swap_logical_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ofBool (x <ᵤ x_1) = 1#1 → ofBool (x == 42#8) = ofBool (x == 42#8) &&& ofBool (42#8 <ᵤ x_1)

theorem sdiv_icmp2_thm (e : IntW 64) :
  icmp IntPred.eq (LLVM.sdiv e (const? 64 5) { «exact» := true }) (const? 64 1) ⊑
    icmp IntPred.eq e (const? 64 5)

theorem t2_ult_sgt_128_thm.extracted_1._8 : ∀ (x x_1 x_2 : BitVec 32),
  ofBool (x_2 + 16#32 <ᵤ 144#32) = 1#1 →
    ¬ofBool (127#32 <ₛ x_2) = 1#1 → ofBool (x_2 <ₛ BitVec.ofInt 32 (-16)) = 1#1 → x_2 = x

theorem not_logicalOr_not_op1_thm.extracted_1._2 : ∀ (x : BitVec 1), x = 1#1 → ¬x ^^^ 1#1 = 1#1 → 1#1 ^^^ 1#1 = 0#1

theorem n2_thm (e : IntW 8) :
  LLVM.sdiv e (const? 8 (-128)) ⊑ zext 8 (icmp IntPred.eq e (const? 8 (-128)))

theorem for_return {t : Arith.Ty} (istart istep: Var Γ Arith.Ty.int)
    (niters : Var Γ .nat) (v : Var Γ t) :
    Expr.denoteOp (for_ (t := t) istart istep niters v (RegionRet t ⟨1, by simp⟩)) Γv = [Γv v]ₕ

theorem masked_icmps_mask_notallzeros_bmask_mixed_swapped_3_thm (e : IntW 32) :
  LLVM.and (icmp IntPred.eq (LLVM.and e (const? 32 7)) (const? 32 0))
      (icmp IntPred.ne (LLVM.and e (const? 32 15)) (const? 32 0)) ⊑
    icmp IntPred.eq (LLVM.and e (const? 32 15)) (const? 32 8)

theorem positive_different_trunc_both_logical_proof : positive_different_trunc_both_logical_before ⊑ positive_different_trunc_both_logical_after

theorem test19_proof : test19_before ⊑ test19_after

theorem e_1798 :
     - 1 *  ~~~(a ^^^ ( ~~~b &&& c)) + 11 * (b &&&  ~~~(a ^^^ c)) - 1 * ((a &&&  ~~~b) |||  ~~~(a ^^^ (b ^^^ c))) + 3 * ( ~~~b &&&  ~~~(a ^^^ c)) + 11 * (b &&&  ~~~(a &&&  ~~~c)) - 5 *  ~~~( ~~~a &&& (b ||| c)) - 2 * (a ||| (b ||| c)) - 11 * (a ||| ( ~~~b ||| c)) + 3 * ( ~~~(a &&&  ~~~b) &&&  ~~~(b ^^^ c)) + 5 * ((a ||| b) &&& (a ^^^ (b ^^^ c))) + 7 * ((a ||| b) &&&  ~~~(b ^^^ c)) + 1 * a - 2 * (b &&& c) + 1 *  ~~~(b |||  ~~~c) - 1 * ( ~~~(a &&&  ~~~b) &&& (a ^^^ (b ^^^ c))) - 7 * ((a |||  ~~~b) &&&  ~~~(b ^^^ c)) + 3 * (b |||  ~~~c) - 1 * (c ^^^  ~~~(a &&& (b &&& c))) - 1 * ( ~~~(a ^^^ b) ||| (a ^^^ c)) - 1 *  ~~~(a ^^^ (b &&& c)) + 1 * ((b &&&  ~~~c) |||  ~~~(a ||| ( ~~~b &&& c))) + 4 * (c ^^^  ~~~( ~~~a &&& (b ||| c))) - 11 *  ~~~b - 1 * (c ^^^  ~~~(a ||| ( ~~~b &&& c))) + 2 * (a ^^^ (b ||| c)) + 5 * (c ^^^  ~~~( ~~~a &&& ( ~~~b ||| c))) + 4 *  ~~~(a ^^^ (b ||| c)) + 5 *  ~~~(a ||| c) - 7 * ( ~~~(a |||  ~~~b) |||  ~~~(b ^^^ c)) - 3 * ((a ^^^ b) |||  ~~~(a ^^^ c)) + 11 * (b ^^^  ~~~(a |||  ~~~c)) - 7 * (b ^^^  ~~~(a ||| c)) + 34 *  ~~~(a ||| (b ||| c)) - 37 *  ~~~(a ||| ( ~~~b ||| c)) + 22 *  ~~~( ~~~a ||| (b ||| c)) - 1 *  ~~~( ~~~a ||| ( ~~~b ||| c)) + 5 * ( ~~~a &&& ( ~~~b &&& c)) - 1 * ( ~~~a &&& (b &&& c)) - 7 * (a &&& (b &&& c)) =  - 26 * (a &&& ( ~~~b &&& c))

theorem fold_select_trunc_nsw_false_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬(True ∧ signExtend 8 (truncate 1 x) ≠ x ∨ truncate 1 x = 1#1) → x = 0#8

theorem t7_thm.extracted_1._4 : ∀ (x : BitVec 8) (x_1 : BitVec 1) (x_2 : BitVec 8),
  ¬x_1 = 1#1 →
    ¬x ≥ ↑8 → ¬(True ∧ ((-1#8) <<< x).sshiftRight' x ≠ -1#8 ∨ x ≥ ↑8) → x_2 - 1#8 <<< x = (-1#8) <<< x + x_2

theorem test6_thm.extracted_1._1 : ∀ (x : BitVec 8), x ^^^ 17#8 ^^^ 17#8 = x

theorem gt_unsigned_to_large_signed_proof : gt_unsigned_to_large_signed_before ⊑ gt_unsigned_to_large_signed_after

theorem no_shift_xor_multiuse_cmp_proof : no_shift_xor_multiuse_cmp_before ⊑ no_shift_xor_multiuse_cmp_after

@[simp] theorem Com.denote_castPureToEff {com : Com d Γ .pure ty} :
    denote (com.castPureToEff eff) = fun V => pure (com.denote V)

theorem uadd_sat_via_add_swapped_cmp_nonstrict_proof : uadd_sat_via_add_swapped_cmp_nonstrict_before ⊑ uadd_sat_via_add_swapped_cmp_nonstrict_after

theorem e_709 :
    7 *  ~~~(x &&&  ~~~y) - 1 *  ~~~(x &&&  ~~~x) + 2 * (x |||  ~~~y) - 11 * x + 5 *  ~~~x + 11 * (x ||| y) - 13 *  ~~~(x ||| y) - 20 *  ~~~(x |||  ~~~y) + 1 * (x &&&  ~~~y) - 8 * (x &&& y) = 2 * (x ^^^ y)

theorem ashrsgt_03_01_exact_proof : ashrsgt_03_01_exact_before ⊑ ashrsgt_03_01_exact_after

theorem positive_sameconst_shlnuw_thm (e : IntW 8) :
  shl (lshr e (const? 8 3)) (const? 8 3) { «nsw» := false, «nuw» := true } ⊑ LLVM.and e (const? 8 (-8))

theorem test54_thm.extracted_1._2 : ∀ (x : BitVec 64),
  ¬(True ∧ (truncate 16 x &&& 7224#16 &&& BitVec.ofInt 16 (-32574) != 0) = true) →
    signExtend 32 ((truncate 16 x ||| BitVec.ofInt 16 (-32574)) &&& BitVec.ofInt 16 (-25350)) =
      signExtend 32 (truncate 16 x &&& 7224#16 ||| BitVec.ofInt 16 (-32574))

theorem logical_and_bitwise_and_icmps_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 8),
  ofBool (x_2 == 42#8) &&& ofBool (x_1 &&& 1#8 != 0#8) = 1#1 →
    ¬x ≥ ↑8 → True ∧ 1#8 <<< x >>> x ≠ 1#8 ∨ x ≥ ↑8 → False

theorem corec_eq_corec_of
    (R : β₁ → β₂→ Prop)
    (f₁ : β₁ → (Option α × β₁) )
    (f₂ : β₂ → (Option α × β₂))
    (h : ∀ b₁ b₂, R b₁ b₂ →
      (f₁ b₁).fst = (f₂ b₂).fst
      ∧ R (f₁ b₁).snd (f₂ b₂).snd)
    {b₁ : β₁} {b₂ : β₂} (hR : R b₁ b₂):
    corec b₁ f₁ = corec b₂ f₂

theorem or_not_and_and_not_and_xor_commute2_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 32),
  ¬((x_2 == 0 || 32 != 1 && 42#32 == intMin 32 && x_2 == -1) = true ∨
        (x_2 == 0 || 32 != 1 && 42#32 == intMin 32 && x_2 == -1) = true) →
    ((42#32).sdiv x_2 ||| x_1 &&& x ^^^ -1#32) &&& ((x_1 ^^^ x) &&& (42#32).sdiv x_2 ^^^ -1#32) =
      (x_1 ^^^ x) &&& (42#32).sdiv x_2 ^^^ ((42#32).sdiv x_2 ||| x_1 &&& x ^^^ -1#32)

theorem ashrslt_02_15_exact_thm (e : IntW 4) :
  icmp IntPred.slt (ashr e (const? 4 2) { «exact» := true }) (const? 4 (-1)) ⊑
    icmp IntPred.slt e (const? 4 (-4))

theorem e_1477 :
    7 *  ~~~(z &&&  ~~~z) - 7 *  ~~~z - 6 *  ~~~(z &&&  ~~~t) + 5 *  ~~~(z &&& t) + 2 * (z |||  ~~~t) + 5 * (z ^^^ t) + 2 *  ~~~t - 3 *  ~~~(z ||| t) + 1 *  ~~~(z |||  ~~~t) - 21 * (z &&&  ~~~t) + 2 * (z &&& t) = 5 * t

theorem narrow_sext_and_thm (e : IntW 32) (e_1 : IntW 16) :
  trunc 16 (LLVM.and (sext 32 e_1) e) ⊑ LLVM.and e_1 (trunc 16 e)

theorem icmp_slt_0_and_icmp_ne_neg2_i32_fail_proof : icmp_slt_0_and_icmp_ne_neg2_i32_fail_before ⊑ icmp_slt_0_and_icmp_ne_neg2_i32_fail_after

theorem add_shl_same_amount_proof : add_shl_same_amount_before ⊑ add_shl_same_amount_after

theorem foo1_or_commuted_thm.extracted_1._2 : ∀ (x x_1 x_2 : BitVec 32),
  ¬(x_1 ≥ ↑32 ∨ x ≥ ↑32) →
    ¬(True ∧ 1#32 <<< x_1 >>> x_1 ≠ 1#32 ∨
          x_1 ≥ ↑32 ∨
            True ∧ 1#32 <<< x >>> x ≠ 1#32 ∨
              x ≥ ↑32 ∨ True ∧ 1#32 <<< x_1 >>> x_1 ≠ 1#32 ∨ x_1 ≥ ↑32 ∨ True ∧ 1#32 <<< x >>> x ≠ 1#32 ∨ x ≥ ↑32) →
      ofBool (x_2 * x_2 &&& 1#32 <<< x_1 != 0#32) &&& ofBool (1#32 <<< x &&& x_2 * x_2 != 0#32) =
        ofBool (x_2 * x_2 &&& (1#32 <<< x_1 ||| 1#32 <<< x) == 1#32 <<< x_1 ||| 1#32 <<< x)

theorem foo_proof : foo_before ⊑ foo_after

theorem tryFactorization_xor_ashr_ashr_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬(x ≥ ↑32 ∨ x ≥ ↑32) →
    ¬x ≥ ↑32 → (BitVec.ofInt 32 (-3)).sshiftRight' x ^^^ (BitVec.ofInt 32 (-5)).sshiftRight' x = 6#32 >>> x

theorem uge_swap_and_max_commute_thm (e e_1 : IntW 8) :
  LLVM.and (icmp IntPred.eq e_1 (const? 8 (-1))) (icmp IntPred.ule e e_1) ⊑
    icmp IntPred.eq e_1 (const? 8 (-1))

theorem bools2_logical_commute2_and1_thm.extracted_1._2 : ∀ (x x_1 : BitVec 1), x_1 &&& x = 1#1 → ¬x_1 = 1#1 → False

theorem logical_or_logical_or_icmps_comm3_thm.extracted_1._6 : ∀ (x x_1 x_2 : BitVec 8),
  ¬x_1 ≥ ↑8 →
    ¬(ofBool (x_2 &&& 1#8 <<< x_1 == 0#8) = 1#1 ∨ ofBool (x_2 &&& 1#8 == 0#8) = 1#1) →
      ¬(True ∧ 1#8 <<< x_1 >>> x_1 ≠ 1#8 ∨ x_1 ≥ ↑8 ∨ True ∧ 1#8 <<< x_1 >>> x_1 ≠ 1#8 ∨ x_1 ≥ ↑8) →
        ofBool (x_2 &&& (1#8 <<< x_1 ||| 1#8) != 1#8 <<< x_1 ||| 1#8) = 1#1 → ofBool (x == 42#8) = 1#1

theorem eq_nsw_rem_zero_thm (e : IntW 8) :
  icmp IntPred.eq (mul e (const? 8 (-5)) { «nsw» := true, «nuw» := false }) (const? 8 20) ⊑
    icmp IntPred.eq e (const? 8 (-4))

theorem uaddo_commute4_proof : uaddo_commute4_before ⊑ uaddo_commute4_after

theorem e_2100 :
    2 *  ~~~(d &&& ( ~~~e &&& f)) + 1 * (e ^^^ ( ~~~d ||| (e ^^^ f))) - 2 * (e ^^^  ~~~(d &&& (e ||| f))) - 1 *  ~~~(d |||  ~~~e) - 1 * (d &&& ( ~~~e ||| f)) - 5 *  ~~~(e |||  ~~~f) + 5 * ( ~~~d &&& (e ^^^ f)) + 3 * ((d &&&  ~~~e) ||| (d ^^^ (e ^^^ f))) - 2 * ( ~~~(d |||  ~~~e) |||  ~~~(e ^^^ f)) - 11 * ( ~~~(d |||  ~~~e) ||| (e ^^^ f)) + 7 * (e ||| (d &&& f)) - 2 *  ~~~(d ||| (e ^^^ f)) + 11 * (f ^^^  ~~~(d &&& ( ~~~e &&& f))) + 11 *  ~~~(d &&& ( ~~~e ||| f)) + 7 * (f ^^^  ~~~( ~~~d ||| ( ~~~e &&& f))) - 2 * ( ~~~(d &&&  ~~~e) &&& (e ^^^ f)) - 1 * (e &&&  ~~~f) + 1 * (d ||| (e ||| f)) - 3 * (d ^^^ (e ||| f)) - 6 * (e ^^^ (d &&& (e ||| f))) - 6 * (f ^^^  ~~~(d ||| (e &&& f))) - 1 * (f ^^^ (d &&&  ~~~e)) - 1 *  ~~~( ~~~d ||| (e &&& f)) + 1 *  ~~~( ~~~d &&& (e ||| f)) + 1 * ( ~~~d ||| (e ^^^ f)) + 2 * (d |||  ~~~f) + 5 * d - 3 * (f ^^^  ~~~(d &&& ( ~~~e ||| f))) - 3 *  ~~~(d ^^^ f) - 1 * (f &&& (d |||  ~~~e)) + 5 * ( ~~~f &&&  ~~~(d ^^^ e)) - 11 * ( ~~~d ||| ( ~~~e ||| f)) + 2 * (e |||  ~~~(d ||| f)) + 1 * (e &&&  ~~~(d &&& f)) + 11 * ((d |||  ~~~e) &&&  ~~~(d ^^^ (e ^^^ f))) + 4 * ((d &&& e) ^^^ (e ||| f)) + 5 *  ~~~( ~~~d &&& ( ~~~e ||| f)) - 18 *  ~~~(d ||| (e ||| f)) - 7 *  ~~~(d ||| ( ~~~e ||| f)) - 17 *  ~~~( ~~~d ||| (e ||| f)) - 54 *  ~~~( ~~~d ||| ( ~~~e ||| f)) + 6 * ( ~~~d &&& (e &&& f)) - 13 * (d &&& ( ~~~e &&& f)) =  - 1 * (d ||| (e ^^^ f)) - 1 * ((d ||| e) &&&  ~~~(d ^^^ (e ^^^ f)))

theorem and_logic_and_logic_or_8_proof : and_logic_and_logic_or_8_before ⊑ and_logic_and_logic_or_8_after

theorem scalar_i32_shl_and_negC_slt_proof : scalar_i32_shl_and_negC_slt_before ⊑ scalar_i32_shl_and_negC_slt_after

theorem logical_and_cond_reuse_proof : logical_and_cond_reuse_before ⊑ logical_and_cond_reuse_after

theorem ashr_ult_2_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬1#4 ≥ ↑4 → ofBool (x.sshiftRight' 1#4 <ᵤ 2#4) = ofBool (x <ᵤ 4#4)

theorem e_202 :
    3 *  ~~~(x &&& y) - 7 *  ~~~(x &&&  ~~~x) - 1 * (x |||  ~~~y) + 5 *  ~~~(x ||| y) + 1 * (x &&&  ~~~y) + 8 * (x &&& y) =  - 4 * (x ^^^ y)

theorem positive_sameconst_shlnuwnsw_ashrexact_thm (e : IntW 8) :
  shl (ashr e (const? 8 3) { «exact» := true }) (const? 8 3) { «nsw» := true, «nuw» := true } ⊑ e

theorem bitwise_and_logical_and_masked_icmp_allones_thm.extracted_1._4 : ∀ (x : BitVec 1) (x_1 : BitVec 32),
  ofBool (x_1 &&& 8#32 == 8#32) = 1#1 →
    ¬ofBool (x_1 &&& 15#32 == 15#32) = 1#1 → x &&& ofBool (x_1 &&& 7#32 == 7#32) = 0#1

theorem test9_thm.extracted_1._2 : ∀ (x : BitVec 77),
  ¬(True ∧ (x &&& 562949953421310#77 &&& 1#77 != 0) = true) →
    (x &&& 562949953421310#77) + 1#77 = x &&& 562949953421310#77 ||

theorem ult_rem_nz_proof : ult_rem_nz_before ⊑ ult_rem_nz_after

theorem e_649 :
     - 7 *  ~~~x + 1 * (x ^^^ y) + 1 *  ~~~(x &&&  ~~~y) + 3 *  ~~~(x ^^^ y) + 5 *  ~~~y + 7 * (x |||  ~~~y) - 8 *  ~~~(x ||| y) + 6 *  ~~~(x |||  ~~~y) - 12 * (x &&&  ~~~y) - 10 * (x &&& y) = 1 *  ~~~(x &&&  ~~~x)

theorem or_xor_commute3_proof : or_xor_commute3_before ⊑ or_xor_commute3_after

theorem ashrsgt_01_08_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬1#4 ≥ ↑4 → ofBool (BitVec.ofInt 4 (-8) <ₛ x.sshiftRight' 1#4) = 1#1

theorem lshrult_01_13_exact_proof : lshrult_01_13_exact_before ⊑ lshrult_01_13_exact_after

theorem t1_proof : t1_before ⊑ t1_after

theorem add_mask_sign_commute_i32_proof : add_mask_sign_commute_i32_before ⊑ add_mask_sign_commute_i32_after

theorem test15c_thm (e : IntW 32) :
  select (icmp IntPred.eq (LLVM.and e (const? 32 16)) (const? 32 16)) (const? 32 16) (const? 32 0) ⊑
    LLVM.and e (const? 32 16)

theorem test13_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬(x == 0 || 32 != 1 && x == intMin 32 && x == -1) = true → x.srem x = 0#32

theorem nonexact_lshr_eq_noexactlog_proof : nonexact_lshr_eq_noexactlog_before ⊑ nonexact_lshr_eq_noexactlog_after

theorem fold_and_zext_icmp_thm (e e_1 e_2 : IntW 64) :
  LLVM.and (zext 8 (icmp IntPred.sgt e_2 e_1)) (zext 8 (icmp IntPred.slt e_2 e)) ⊑
    zext 8 (LLVM.and (icmp IntPred.sgt e_2 e_1) (icmp IntPred.slt e_2 e))

theorem srem_common_dividend_defined_cond_proof : srem_common_dividend_defined_cond_before ⊑ srem_common_dividend_defined_cond_after

theorem fold_sext_to_and_wrong3_proof : fold_sext_to_and_wrong3_before ⊑ fold_sext_to_and_wrong3_after

theorem lshr_pow2_sgt_proof : lshr_pow2_sgt_before ⊑ lshr_pow2_sgt_after

theorem icmp_ne_sext_ne_zero_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (signExtend 32 (ofBool (x != 0#32)) != x) = ofBool (x + -1#32 <ᵤ BitVec.ofInt 32 (-2))

theorem bv_820 :
    ∀ (e e_1 : LLVM.IntW 9), LLVM.sdiv (LLVM.sub e (LLVM.srem e e_1)) e_1 ⊑ LLVM.sdiv e e_1

theorem t4_commutative_proof : t4_commutative_before ⊑ t4_commutative_after

theorem t3_singlebit_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬(32#32 - x ≥ ↑32 ∨ zeroExtend 64 (x + BitVec.ofInt 32 (-16)) ≥ ↑64) →
    ofBool (x_1 <<< (32#32 - x) &&& truncate 32 (65536#64 >>> zeroExtend 64 (x + BitVec.ofInt 32 (-16))) != 0#32) =
      ofBool (x_1 &&& 1#32 != 0#32)

theorem main5c_like_logical_thm.extracted_1._10 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (x_1 &&& 7#32 != 7#32) = 1#1 →
    ofBool (x_1 &&& 7#32 == 7#32) = 1#1 →
      ¬ofBool (x &&& 7#32 != 7#32) = 1#1 → 1#32 = zeroExtend 32 (ofBool (x &&& 7#32 == 7#32))

theorem t0_thm.extracted_1._1 : ∀ (x : BitVec 16),
  ¬16#32 ≥ ↑32 →
    zeroExtend 32 x <<< 16#32 &&& BitVec.ofInt 32 (-2147483648) = signExtend 32 x &&& BitVec.ofInt 32 (-2147483648)

theorem select_constants_and_icmp_ne0_zero_tval_thm.extracted_1._2 : ∀ (x x_1 : BitVec 1),
  x_1 = 1#1 → ¬x = 1#1 → ofBool (0#8 &&& 12#8 != 0#8) = 1#1 ^^^ 1#1

theorem logical_and_implies_thm (e : IntW 32) :
  select (icmp IntPred.ne e (const? 32 0)) (icmp IntPred.ne e (const? 32 42)) (const? 1 0) ⊑
    LLVM.and (icmp IntPred.ne e (const? 32 0)) (icmp IntPred.ne e (const? 32 42))

theorem logical_and_not_thm (e e_1 : IntW 1) :
  select e_1 (const? 1 0) e ⊑ select (LLVM.xor e_1 (const? 1 1)) e (const? 1 0)

theorem bool2 (x y : Bool) (h : x = y) : y = x

theorem e_1225 :
     - 11 *  ~~~(z ^^^ t) + 11 *  ~~~(z &&& t) + 5 * (z |||  ~~~t) + 7 *  ~~~(z &&&  ~~~z) + 5 *  ~~~t - 18 *  ~~~(z ||| t) - 19 *  ~~~(z |||  ~~~t) - 26 * (z &&&  ~~~t) + 1 * (z &&& t) = 2 * z - 1 *  ~~~z

theorem ashr_ult_6_proof : ashr_ult_6_before ⊑ ashr_ult_6_after

theorem test_lshr_exact__exact_is_unsafe_thm.extracted_1._4 : ∀ (x : BitVec 64) (x_1 : BitVec 32),
  ¬ofBool (x_1 &&& 63#32 == 0#32) = 1#1 →
    ¬(True ∧ (x_1 &&& 63#32) >>> 2#32 <<< 2#32 ≠ x_1 &&& 63#32 ∨
          2#32 ≥ ↑32 ∨ zeroExtend 64 ((x_1 &&& 63#32) >>> 2#32) ≥ ↑64) →
      ¬(2#32 ≥ ↑32 ∨ True ∧ (x_1 >>> 2#32 &&& 15#32).msb = true ∨ zeroExtend 64 (x_1 >>> 2#32 &&& 15#32) ≥ ↑64) →
        x.sshiftRight' (zeroExtend 64 ((x_1 &&& 63#32) >>> 2#32)) =
          x.sshiftRight' (zeroExtend 64 (x_1 >>> 2#32 &&& 15#32))

theorem test92_thm.extracted_1._2 : ∀ (x : BitVec 64),
  ¬32#96 ≥ ↑96 → ¬32#64 ≥ ↑64 → truncate 64 (signExtend 96 x >>> 32#96) = x.sshiftRight' 32#64

theorem or_to_nxor4_thm (e e_1 : IntW 32) :
  LLVM.or (LLVM.xor (LLVM.or e_1 e) (const? 32 (-1))) (LLVM.and e e_1) ⊑
    LLVM.xor (LLVM.xor e e_1) (const? 32 (-1))

theorem PR38139_proof : PR38139_before ⊑ PR38139_after

theorem sgt_and_min_commute_logical_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ofBool (x_1 == BitVec.ofInt 8 (-128)) = 1#1 → ofBool (x <ₛ x_1) = 0#1

theorem test4_proof : test4_before ⊑ test4_after

theorem ashr_known_pos_exact_proof : ashr_known_pos_exact_before ⊑ ashr_known_pos_exact_after

theorem add_select_zext_thm.extracted_1._1 : ∀ (x : BitVec 1), x = 1#1 → 64#64 + zeroExtend 64 x = 65#64

theorem pv_proof : pv_before ⊑ pv_after

theorem exact_ashr_eq_noexactdiv_proof : exact_ashr_eq_noexactdiv_before ⊑ exact_ashr_eq_noexactdiv_after

theorem or_ne_notY_eq_1s_fail_bad_not_proof : or_ne_notY_eq_1s_fail_bad_not_before ⊑ or_ne_notY_eq_1s_fail_bad_not_after

theorem test_or3_logical_thm.extracted_1._2 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (x_1 &&& 2147483647#32 ≤ₛ x) = 1#1 → ofBool (x <ₛ 0#32) = ofBool (x_1 &&& 2147483647#32 ≤ᵤ x)

theorem PR38139_thm (e : IntW 8) :
  icmp IntPred.ne (LLVM.or e (const? 8 (-64))) e ⊑ icmp IntPred.ult e (const? 8 (-64))

theorem test6_thm (e e_1 : IntW 57) : sub e_1 (LLVM.and e_1 e) ⊑ LLVM.and e_1 (LLVM.xor e (const? 57 (-1)))

theorem ashr_mul_times_3_div_2_exact_2_thm (e : IntW 32) :
  ashr (mul e (const? 32 3) { «nsw» := true, «nuw» := false }) (const? 32 1) { «exact» := true } ⊑
    add e (ashr e (const? 32 1) { «exact» := true }) { «nsw» := true, «nuw» := false }

theorem e_1275 :
     - 3 *  ~~~(z &&&  ~~~z) + 2 * (z ^^^ t) - 7 *  ~~~t + 3 * z + 2 *  ~~~(z &&& t) + 7 *  ~~~(z &&&  ~~~t) + 1 *  ~~~(z ||| t) + 3 * (z &&&  ~~~t) - 5 * (z &&& t) = 2 * t + 6 *  ~~~(z |||  ~~~t)

theorem sub_from_constant_commute_proof : sub_from_constant_commute_before ⊑ sub_from_constant_commute_after

theorem zext_sext_add_icmp_slt_1_rhs_not_const_thm (e : IntW 8) (e_1 e_2 : IntW 1) :
  icmp IntPred.slt (add (zext 8 e_2) (sext 8 e_1)) e ⊑
    icmp IntPred.slt (add (zext 8 e_2) (sext 8 e_1) { «nsw» := true, «nuw» := false }) e

theorem t0_thm.extracted_1._8 : ∀ (x x_1 x_2 : BitVec 8) (x_3 : BitVec 1),
  ¬x_3 ^^^ 1#1 = 1#1 → ¬x_3 = 1#1 → 0#1 = 1#1 → ofBool (x_2 != x_1) = 1#1 → False

theorem lshrult_02_13_exact_proof : lshrult_02_13_exact_before ⊑ lshrult_02_13_exact_after

theorem test_add_nsw__nuw_is_safe_thm.extracted_1._3 : ∀ (x : BitVec 32),
  ¬ofBool (x &&& 2147483647#32 == 2147483647#32) = 1#1 →
    ¬(True ∧ (x &&& 2147483647#32).saddOverflow 1#32 = true) →
      True ∧ (x &&& 2147483647#32).uaddOverflow 1#32 = true → False

theorem sub_eq (a b : BitStream) : a.sub b = a - b

theorem e_515 :
     - 6 *  ~~~(x ^^^ y) + 2 * y + 2 * (x |||  ~~~y) + 3 * (x ^^^ y) + 2 *  ~~~y + 3 *  ~~~(x ||| y) - 4 *  ~~~(x |||  ~~~y) - 4 * (x &&&  ~~~y) + 5 * (x &&& y) = 2 * x + 1 *  ~~~(x &&&  ~~~x)

theorem rem_euclid_i128_thm (e : IntW 128) :
  select (icmp IntPred.slt (LLVM.srem e (const? 128 8)) (const? 128 0))
      (add (LLVM.srem e (const? 128 8)) (const? 128 8)) (LLVM.srem e (const? 128 8)) ⊑
    LLVM.and e (const? 128 7)

theorem mul_select_zext_thm.extracted_1._1 : ∀ (x : BitVec 1), ¬x = 1#1 → 1#64 * zeroExtend 64 x = 0#64

theorem test35_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (0#32 ≤ₛ x) = 1#1 → ¬ofBool (-1#32 <ₛ x) = 1#1 → 60#32 = 100#32

theorem n0_proof : n0_before ⊑ n0_after

theorem eq_21_comm_eq2_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬(16#32 ≥ ↑32 ∨ 16#32 ≥ ↑32 ∨ 8#32 ≥ ↑32 ∨ 8#32 ≥ ↑32) → 8#32 ≥ ↑32 ∨ 8#32 ≥ ↑32 → False

theorem narrow_sext_sub_thm.extracted_1._1 : ∀ (x : BitVec 32) (x_1 : BitVec 16),
  truncate 16 (signExtend 32 x_1 - x) = x_1 - truncate 16 x

theorem test1_proof : test1_before ⊑ test1_after

theorem t0_scalar_proof : t0_scalar_before ⊑ t0_scalar_after

theorem uge_umin1_proof : uge_umin1_before ⊑ uge_umin1_after

theorem select_or_disjoint_or_proof : select_or_disjoint_or_before ⊑ select_or_disjoint_or_after

theorem test91_thm (e : IntW 64) :
  trunc 64 (lshr (sext 96 e) (const? 96 48)) ⊑
    trunc 64 (lshr (sext 96 e) (const? 96 48)) { «nsw» := true, «nuw» := true }

theorem sgt_or_not_min_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ofBool (x <ₛ x_1) ||

theorem or_ranges_single_elem_right_proof : or_ranges_single_elem_right_before ⊑ or_ranges_single_elem_right_after

theorem select_ashr_thm.extracted_1._3 : ∀ (x x_1 : BitVec 128) (x_2 : BitVec 1), ¬x_2 = 1#1 → 0#128 ≥ ↑128 → False

theorem ashrsgt_02_05_exact_proof : ashrsgt_02_05_exact_before ⊑ ashrsgt_02_05_exact_after

theorem srem_common_divisor_defined_cond_proof : srem_common_divisor_defined_cond_before ⊑ srem_common_divisor_defined_cond_after

theorem lshr_sub_thm (e e_1 : IntW 8) :
  shl (sub (LLVM.srem e_1 (const? 8 42)) (lshr e (const? 8 3))) (const? 8 3) ⊑
    shl (sub (LLVM.srem e_1 (const? 8 42)) (lshr e (const? 8 3)) { «nsw» := true, «nuw» := false })
      (const? 8 3)

theorem lshr_C1_add_A_C2_i32_thm (e : IntW 32) :
  shl (const? 32 6) (add (LLVM.and e (const? 32 65535)) (const? 32 5)) ⊑
    shl (const? 32 192) (LLVM.and e (const? 32 65535))

theorem nomask_rhs_proof : nomask_rhs_before ⊑ nomask_rhs_after

theorem lshrult_03_06_proof : lshrult_03_06_before ⊑ lshrult_03_06_after

theorem e_480 :
     - 1 *  ~~~(x &&&  ~~~x) + 1 *  ~~~(x &&& y) + 3 *  ~~~y + 1 * (x ^^^ y) + 1 * (x |||  ~~~y) - 2 *  ~~~(x &&&  ~~~y) - 2 *  ~~~(x ||| y) + 1 *  ~~~(x |||  ~~~y) - 5 * (x &&&  ~~~y) =  - 2 * (x &&& y)

theorem main4f_like_logical_thm.extracted_1._10 : ∀ (x x_1 x_2 : BitVec 32),
  ¬ofBool (x_2 &&& x_1 != x_1) = 1#1 →
    ofBool (x_2 &&& x_1 == x_1) = 1#1 →
      ¬ofBool (x_2 &&& x != x) = 1#1 → 1#32 = zeroExtend 32 (ofBool (x_2 &&& x == x))

theorem neg_signbit_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬7#8 ≥ ↑8 → 0#32 - zeroExtend 32 (x >>> 7#8) = signExtend 32 (x.sshiftRight' 7#8)

theorem ashr_ne_both_equal_thm (e : IntW 8) :
  icmp IntPred.ne (ashr (const? 8 (-128)) e) (const? 8 (-128)) ⊑ icmp IntPred.ne e (const? 8 0)

theorem ashrslt_01_14_proof : ashrslt_01_14_before ⊑ ashrslt_01_14_after

theorem l_thm (e e_1 e_2 : IntW 32) :
  add (add (sub (const? 32 0) e_2) (sub (const? 32 0) e_1)) e ⊑ sub e (add e_2 e_1)

theorem t4_proof : t4_before ⊑ t4_after

theorem lshrugt_03_02_exact_proof : lshrugt_03_02_exact_before ⊑ lshrugt_03_02_exact_after

theorem demorgan_and_apint5_thm (e e_1 : IntW 47) :
  LLVM.and (LLVM.xor e_1 (const? 47 (-1))) (LLVM.xor e (const? 47 (-1))) ⊑
    LLVM.xor (LLVM.or e_1 e) (const? 47 (-1))

theorem select_icmp_eq_and_1_0_lshr_tv_thm.extracted_1._2 : ∀ (x x_1 : BitVec 8),
  ofBool (x_1 &&& 1#8 != 0#8) = 1#1 →
    ¬2#8 ≥ ↑8 → ¬(1#8 ≥ ↑8 ∨ x_1 <<< 1#8 &&& 2#8 ≥ ↑8) → x >>> 2#8 = x >>> (x_1 <<< 1#8 &&& 2#8)

theorem mul_of_sdiv_thm.extracted_1._2 : ∀ (x : BitVec 8),
  ¬(True ∧ x.smod 12#8 ≠ 0 ∨ (12#8 == 0 || 8 != 1 && x == intMin 8 && 12#8 == -1) = true) →
    ¬(True ∧ x >>> 1#8 <<< 1#8 ≠ x ∨ 1#8 ≥ ↑8 ∨ True ∧ (0#8).ssubOverflow (x.sshiftRight' 1#8) = true) →
      x.sdiv 12#8 * BitVec.ofInt 8 (-6) = 0#8 - x.sshiftRight' 1#8

theorem bv_AndOrXor_1288_A__B__B__C__A___A__B__C :
    ∀ (e e_1 e_2 : LLVM.IntW w),
      LLVM.and (LLVM.xor e e_2) (LLVM.xor (LLVM.xor e_2 e_1) e) ⊑
        LLVM.and (LLVM.xor e e_2) (LLVM.xor e_1 (LLVM.const? w (-1)))

theorem ashrslt_03_10_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬3#4 ≥ ↑4 → ofBool (x.sshiftRight' 3#4 <ₛ BitVec.ofInt 4 (-6)) = 0#1

theorem shl_or_thm.extracted_1._2 : ∀ (x x_1 : BitVec 16),
  ¬((42#16 == 0 || 16 != 1 && x_1 == intMin 16 && 42#16 == -1) = true ∨ 5#16 ≥ ↑16 ∨ 7#16 ≥ ↑16) →
    ¬(12#16 ≥ ↑16 ∨
          (42#16 == 0 || 16 != 1 && x_1 == intMin 16 && 42#16 == -1) = true ∨
            True ∧ (x_1.srem 42#16 <<< 7#16).sshiftRight' 7#16 ≠ x_1.srem 42#16 ∨ 7#16 ≥ ↑16) →
      (x_1.srem 42#16 ||| x <<< 5#16) <<< 7#16 = x <<< 12#16 ||

theorem lshrult_01_01_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬1#4 ≥ ↑4 → ofBool (x >>> 1#4 <ᵤ 1#4) = ofBool (x <ᵤ 2#4)

theorem trunc_nuw_xor_thm (e e_1 : IntW 8) :
  trunc 1 (LLVM.xor e_1 e) { «nsw» := false, «nuw» := true } ⊑ icmp IntPred.ne e_1 e

theorem n6_thm.extracted_1._3 : ∀ (x : BitVec 32),
  ¬ofBool (x &&& 1#32 != 0#32) = 1#1 → ¬ofBool (x &&& 1#32 == 0#32) = 1#1 → ¬2#32 ≥ ↑32 → 1#32 = x >>> 2#32 &&& 1#32

theorem test3_apint_thm (e e_1 : IntW 47) :
  LLVM.xor (LLVM.and (LLVM.xor e_1 (const? 47 (-1))) (LLVM.xor e (const? 47 (-1)))) (const? 47 (-1)) ⊑
    LLVM.or e_1 e

theorem e_33 :
     - 1 * (x ||| y) - 1 *  ~~~(x &&& y) + 1 *  ~~~(x ||| y) + 1 * (x &&&  ~~~y) + 1 * (x &&& y) =  - 1 * (x ^^^ y) - 1 *  ~~~(x |||  ~~~y)

theorem positive_biggerlshr_thm.extracted_1._2 : ∀ (x : BitVec 8),
  ¬(6#8 ≥ ↑8 ∨ 3#8 ≥ ↑8) → ¬3#8 ≥ ↑8 → x >>> 6#8 <<< 3#8 = x >>> 3#8 &&& 24#8

theorem test46_thm (e e_1 : IntW 32) :
  LLVM.and e_1 (LLVM.or (LLVM.xor e_1 (const? 32 (-1))) e) ⊑ LLVM.and e_1 e

theorem select_bittest_to_shl_negative_test_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x &&& 1#32 == 0#32) = 1#1 →
    ¬(True ∧ (2#32).saddOverflow 2#32 = true ∨ True ∧ (2#32).uaddOverflow 2#32 = true) → 2#32 + 2#32 = 4#32

theorem lshrult_02_12_exact_thm (e : IntW 4) :
  icmp IntPred.ult (lshr e (const? 4 2) { «exact» := true }) (const? 4 (-4)) ⊑ const? 1 1

theorem ashrslt_03_11_exact_thm (e : IntW 4) :
  icmp IntPred.slt (ashr e (const? 4 3) { «exact» := true }) (const? 4 (-5)) ⊑ const? 1 0

theorem lshr_shl_demand3_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬(x ≥ ↑8 ∨ 3#8 ≥ ↑8) →
    x ≥ ↑8 ∨
        True ∧ 28#8 >>> x <<< 3#8 >>> 3#8 ≠ 28#8 >>> x ∨ 3#8 ≥ ↑8 ∨ True ∧ (28#8 >>> x <<< 3#8 &&& 3#8 != 0) = true →
      False

theorem PR60818_ne_proof : PR60818_ne_before ⊑ PR60818_ne_after

theorem ashrsgt_02_01_exact_thm (e : IntW 4) :
  icmp IntPred.sgt (ashr e (const? 4 2) { «exact» := true }) (const? 4 1) ⊑ const? 1 0

theorem neg_nsw_sgt_n1_proof : neg_nsw_sgt_n1_before ⊑ neg_nsw_sgt_n1_after

theorem sle_smax4_proof : sle_smax4_before ⊑ sle_smax4_after

theorem ne_nsw_rem_nz_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬(True ∧ x.smulOverflow 5#8 = true) → ofBool (x * 5#8 != BitVec.ofInt 8 (-126)) = 1#1

theorem main7d_logical_thm.extracted_1._6 : ∀ (x x_1 x_2 x_3 : BitVec 32),
  ¬ofBool (x_3 &&& (x_2 &&& x_1) == x_2 &&& x_1) = 1#1 →
    ofBool (x_3 &&& (x_2 &&& x_1) != x_2 &&& x_1) = 1#1 → ¬0#1 = 1#1 → 1#32 = zeroExtend 32 1#1

theorem masked_icmps_mask_notallzeros_bmask_mixed_6_proof : masked_icmps_mask_notallzeros_bmask_mixed_6_before ⊑ masked_icmps_mask_notallzeros_bmask_mixed_6_after

theorem eq_smax2_proof : eq_smax2_before ⊑ eq_smax2_after

theorem test19_commutative0_proof : test19_commutative0_before ⊑ test19_commutative0_after

theorem lor_bor_right1_proof : lor_bor_right1_before ⊑ lor_bor_right1_after

theorem test18 (x y : BitVec w) : (x &&&  (~~~ y)) = ((x ||| y) - y)

theorem eq_umax4_proof : eq_umax4_before ⊑ eq_umax4_after

omit [Fintype S] [DecidableEq S] [LawfulBEq A] in
theorem processOneElem_grow (st : worklist.St A S) (final : S → Bool) (a : A) (sa' : S) (s : State) :
      let st' := processOneElem _ _ final s st (a, sa')
      ∃ sas, List.Perm st'.map.keys (sas ++ st.map.keys) ∧ st'.worklist.toList = st.worklist.toList ++ sas

theorem not_or_or_and_not_and_and_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 32),
  (x_2 ^^^ -1#32 ||| x_1 ||| x) &&& (x_1 &&& x_2 &&& x ^^^ -1#32) = x ^^^ x_1 ||

theorem bor_lor_right2_thm (e e_1 : IntW 1) : select e_1 (const? 1 1) (LLVM.or e e_1) ⊑ select e_1 (const? 1 1) e

theorem sle_swap_or_not_min_commute_logical_proof : sle_swap_or_not_min_commute_logical_before ⊑ sle_swap_or_not_min_commute_logical_after

theorem trunc_shl_nsw_31_i32_i64_thm (e : IntW 64) :
  trunc 32 (shl e (const? 64 31) { «nsw» := true, «nuw» := false }) ⊑ shl (trunc 32 e) (const? 32 31)

theorem trunc_equality_both_thm.extracted_1._1 : ∀ (x x_1 : BitVec 16),
  ¬(True ∧ signExtend 16 (truncate 8 x_1) ≠ x_1 ∨
        True ∧ zeroExtend 16 (truncate 8 x_1) ≠ x_1 ∨
          True ∧ signExtend 16 (truncate 8 x) ≠ x ∨ True ∧ zeroExtend 16 (truncate 8 x) ≠ x) →
    ofBool (truncate 8 x_1 == truncate 8 x) = ofBool (x_1 == x)

theorem srem_common_dividend_defined_cond_thm.extracted_1._1 : ∀ (x x_1 : BitVec 5) (x_2 : BitVec 1),
  ¬(x_2 = 1#1 ∨ (x == 0 || 5 != 1 && x_1 == intMin 5 && x == -1) = true) → x_2 = 1#1 → False

theorem test_mul_nuw_nsw__nuw_is_safe_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ofBool (x &&& 268435457#32 == 268435456#32) = 1#1 →
    ¬(True ∧ (x &&& 268435457#32).umulOverflow 9#32 = true) →
      BitVec.ofInt 32 (-1879048192) = (x &&& 268435457#32) * 9#32

theorem e_624 :
    7 *  ~~~(x ^^^ y) + 2 * (x ||| y) - 2 * (x |||  ~~~y) - 11 * (x ^^^ y) - 11 *  ~~~x + 2 *  ~~~(x &&&  ~~~y) + 5 *  ~~~(x ||| y) + 25 *  ~~~(x |||  ~~~y) + 12 * (x &&&  ~~~y) - 2 * (x &&& y) = 1 *  ~~~(x &&&  ~~~x) + 6 * y

theorem masked_icmps_mask_notallzeros_bmask_mixed_negated_swapped_1b_logical_thm (e : IntW 32) :
  select (icmp IntPred.ne (LLVM.and e (const? 32 3)) (const? 32 1)) (const? 1 1)
      (icmp IntPred.eq (LLVM.and e (const? 32 14)) (const? 32 0)) ⊑
    LLVM.or (icmp IntPred.ne (LLVM.and e (const? 32 3)) (const? 32 1))
      (icmp IntPred.eq (LLVM.and e (const? 32 14)) (const? 32 0))

theorem e_2361 :
     - 7 * (d ||| ( ~~~e &&& f)) + 1 * ((e &&&  ~~~f) ^^^ ( ~~~d ||| (e ^^^ f))) - 1 * ( ~~~d &&& (e ||| f)) - 2 * ((d |||  ~~~e) &&& (d ^^^ (e ^^^ f))) + 7 * (f ^^^ ( ~~~d ||| ( ~~~e &&& f))) + 2 * ((d &&& e) ^^^ (e ||| f)) - 3 * (e |||  ~~~f) + 11 * (f ^^^  ~~~(d &&& ( ~~~e &&& f))) - 2 * (f &&&  ~~~(d &&&  ~~~e)) + 5 * ( ~~~d &&& (e ^^^ f)) - 2 * ((d &&& f) ^^^ (d ^^^ ( ~~~e &&& f))) + 1 *  ~~~( ~~~d ||| (e &&& f)) - 3 * (e &&& f) + 7 * (e ^^^  ~~~(d ||| ( ~~~e &&& f))) + 4 * (e ||| (d &&& f)) - 7 * ( ~~~(d &&& e) &&& (d ^^^ (e ^^^ f))) + 11 * (f &&& (d ||| e)) + 3 *  ~~~e - 6 * ((d &&& e) ||| (e ^^^ f)) - 6 *  ~~~( ~~~d &&& ( ~~~e ||| f)) + 2 * (e ^^^ ( ~~~d &&& (e ^^^ f))) + 2 * (f &&&  ~~~(d &&& e)) - 11 * ((d &&& e) ^^^  ~~~(d ^^^ (e &&& f))) - 1 *  ~~~(e &&& f) - 1 * (f ^^^  ~~~( ~~~d &&& ( ~~~e ||| f))) + 2 * (e ^^^  ~~~( ~~~d &&& (e &&& f))) + 1 * (e ^^^  ~~~(d &&& f)) - 5 * (e ^^^ (d ||| (e ^^^ f))) + 1 * (f ^^^  ~~~( ~~~d &&& (e &&& f))) + 1 * ( ~~~d ||| (e &&& f)) + 11 * ( ~~~d &&& ( ~~~e ||| f)) + 4 * ( ~~~(d |||  ~~~e) ||| (e ^^^ f)) + 4 * (f ^^^ (d ||| (e &&& f))) - 6 *  ~~~(d &&& e) + 3 * (e ^^^ (d &&& (e ^^^ f))) - 2 *  ~~~(d ^^^ (e &&& f)) + 11 * ((d &&& f) |||  ~~~(e ||| f)) - 7 * (d |||  ~~~f) - 2 * ( ~~~(d ||| e) ||| (d ^^^ (e ^^^ f))) - 6 * ( ~~~f &&& (d ^^^ e)) - 2 * (f ^^^ (d &&& (e ||| f))) + 1 * (e &&&  ~~~(d ^^^ f)) + 1 * (e &&&  ~~~(d &&& f)) - 3 * ((d &&& f) ^^^  ~~~(d ^^^ (e &&& f))) - 2 * (e ||| (d ^^^ f)) + 11 * ( ~~~e &&& (d ^^^ f)) - 2 * ( ~~~e ||| (d ^^^ f)) - 1 * ((d &&& f) ^^^ (d ^^^ (e &&& f))) - 11 * (e ||| f) - 1 * (e ^^^  ~~~( ~~~d ||| ( ~~~e &&& f))) + 1 *  ~~~( ~~~d &&& ( ~~~e &&& f)) + 1 * ((d &&& f) ||| (e &&&  ~~~f)) - 1 * ((e &&& f) ^^^  ~~~( ~~~d &&& (e ^^^ f))) + 2 * ((d ||| e) &&& (d ^^^ (e ^^^ f))) - 1 * (f &&& (d |||  ~~~e)) - 1 * (e ^^^  ~~~(d ||| (e &&& f))) + 1 * ( ~~~(d ^^^ e) &&&  ~~~(d ^^^ f)) + 11 *  ~~~(e ||| f) - 6 * (e ^^^  ~~~( ~~~d &&& (e ^^^ f))) - 7 *  ~~~(e ^^^ f) - 17 *  ~~~(d ||| (e ||| f)) + 38 *  ~~~(d ||| ( ~~~e ||| f)) + 16 *  ~~~( ~~~d ||| (e ||| f)) + 27 *  ~~~( ~~~d ||| ( ~~~e ||| f)) + 28 * ( ~~~d &&& ( ~~~e &&& f)) - 3 * ( ~~~d &&& (e &&& f)) + 2 * (d &&& ( ~~~e &&& f)) + 10 * (d &&& (e &&& f)) =  - 5 * (f &&& (d ^^^ e))

theorem e_443 :
    7 * y - 11 * (x |||  ~~~y) + 2 *  ~~~(x ^^^ y) - 7 *  ~~~y + 2 * (x ||| y) + 11 *  ~~~x + 5 *  ~~~(x ||| y) - 20 *  ~~~(x |||  ~~~y) =  - 16 * (x &&&  ~~~y)

theorem lshr_pow2_sgt_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬x ≥ ↑8 → True ∧ BitVec.ofInt 8 (-128) >>> x <<< x ≠ BitVec.ofInt 8 (-128) ∨ x ≥ ↑8 → False

theorem or_xor_tree_1111_proof : or_xor_tree_1111_before ⊑ or_xor_tree_1111_after

theorem shift_mul:
    [llvm(w)| {
  ^bb0(%X : _, %Y : _):
    %c1 = llvm.mlir.constant(1)
    %poty = llvm.shl %c1, %Y
    %r = llvm.mul %poty, %X
    llvm.return %r
  }] ⊑  [llvm(w)| {
  ^bb0(%X : _, %Y : _):
    %r = llvm.shl %X, %Y
    llvm.return %r
  }]

theorem test_sext2_proof : test_sext2_before ⊑ test_sext2_after

@[simp]
theorem castLe_mk_eq_mk {α : Type _} {n m : Nat} (i : Fin n) (h : n ≤ m) (x : α) :
    (Inputs.mk i x).castLe h = Inputs.mk (i.castLE (by omega)) x

theorem add_nuw_or_and_proof : add_nuw_or_and_before ⊑ add_nuw_or_and_after

theorem lshrugt_01_12_exact_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬(True ∧ x >>> 1#4 <<< 1#4 ≠ x ∨ 1#4 ≥ ↑4) → ofBool (BitVec.ofInt 4 (-4) <ᵤ x >>> 1#4) = 0#1

theorem or_not_and_and_not_and_xor_commute3_proof : or_not_and_and_not_and_xor_commute3_before ⊑ or_not_and_and_not_and_xor_commute3_after

@[simp] lemma swapLastTwoBlock_SSn {n : Nat} : swapLastTwoBlock (Fin.last (n+2)) = n

theorem shl_trunc_smaller_lshr_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬(3#32 ≥ ↑32 ∨ 5#8 ≥ ↑8) →
    ¬2#8 ≥ ↑8 → truncate 8 (x >>> 3#32) <<< 5#8 = truncate 8 x <<< 2#8 &&& BitVec.ofInt 8 (-32)

@[simp]
theorem mkUnsatImpliesCircuit_eq_false_iff
    (env : α → Bool)
    (lhs rhs : Circuit α) :
    (mkUnsatImpliesCircuit lhs rhs).eval env = false ↔
    (Circuit.eval lhs env = false → Circuit.eval rhs env = false)

theorem n4_thm (e : IntW 16) :
  LLVM.and (shl (zext 32 e) (const? 32 16)) (const? 32 (-1073741824)) ⊑
    LLVM.and (shl (zext 32 e) (const? 32 16) { «nsw» := false, «nuw» := true }) (const? 32 (-1073741824))

@[simp]
theorem Term.toBV_bor {wenv : WidthExpr.Env wcard}
    {tctx : Term.Ctx wcard tcard}
    (benv : Term.BoolEnv bcard)
    (tenv : tctx.Env wenv) (a b : Term bcard ncard icard pcard tctx (.bv w)) :
  Term.toBV benv nenv ienv penv tenv (.bor a b) = a.toBV benv nenv ienv penv tenv ||

theorem test17_proof : test17_before ⊑ test17_after

theorem and_or_hoist_mask_proof : and_or_hoist_mask_before ⊑ and_or_hoist_mask_after

theorem zext_sext_ugt_known_nonneg_thm (e e_1 : IntW 8) :
  icmp IntPred.ugt (zext 32 (LLVM.and e_1 (const? 8 127))) (sext 32 e) ⊑
    icmp IntPred.ugt (LLVM.and e_1 (const? 8 127)) e

@[grind =, simp, aesop 50% unsafe]
lemma states_addFinal (m : RawCNFA A) (s' : State) :
    (m.addFinal s').states = m.states

theorem slt_and_shl_one_proof : slt_and_shl_one_before ⊑ slt_and_shl_one_after
</all_available_lemmas>

<local_ctx>
import Blase.Fast.FiniteStateMachine

import Blase.Vars

import Blase.MultiWidth.Defs

import Blase.KInduction.KInduction

import Lean

namespace MultiWidth

def NatFSM.fsmUnaryIndexUle (a : NatFSM wcard tcard bcard ncard icard pcard v) :
    FSM (StateSpace wcard tcard bcard ncard icard pcard) :=
  composeUnaryAux (FSM.ls true) a.toFsm

def fsmUnaryUle (a : NatFSM wcard tcard bcard ncard icard pcard (.ofDep v))
    (b : NatFSM wcard tcard bcard ncard icard pcard (.ofDep w)) : FSM (StateSpace wcard tcard bcard ncard icard pcard) :=
 composeUnaryAux FSM.scanAnd (b.fsmUnaryIndexUle ||| ~~~ a.fsmUnaryIndexUle)

def fsmUnaryNeqUpto (a : NatFSM wcard tcard bcard ncard icard pcard (.ofDep v))
    (b : NatFSM wcard tcard bcard ncard icard pcard (.ofDep w)) : FSM (StateSpace wcard tcard bcard ncard icard pcard) :=
  composeUnaryAux FSM.scanOr (a.fsmUnaryIndexUle ^^^ b.fsmUnaryIndexUle)

def fsmUltUnary
    (a : NatFSM wcard tcard bcard ncard icard pcard (.ofDep v))
    (b : NatFSM wcard tcard bcard ncard icard pcard (.ofDep w)) : FSM (StateSpace wcard tcard bcard ncard icard pcard) :=
  composeBinaryAux' FSM.and (fsmUnaryUle a b) (fsmUnaryNeqUpto a b)
</local_ctx>

<target_theorem>
theorem eval_fsmUltUnary_eq_decide
    (a : NatFSM wcard tcard bcard ncard icard pcard (.ofDep v))
    (b : NatFSM wcard tcard bcard ncard icard pcard (.ofDep w))
    {wenv : WidthExpr.Env wcard}
    {fsmEnv : StateSpace wcard tcard bcard ncard icard pcard → BitStream}
    (henv : HWidthEnv fsmEnv wenv)
    (ha : HNatFSMToBitstream a) (hb : HNatFSMToBitstream b) :
    ((fsmUltUnary a b).eval fsmEnv) i =
   (decide (min i (v.toNat wenv) < min i (w.toNat wenv))) :=
</target_theorem>

