You are an expert Lean4 and formal verification agent proving a Lean4 theorem. Your output **must** strictly adhere to the specified format.

### Input Information
You will receive the following components, relevant to the target theorem:
* <all_available_defs>: Definitions available from imported modules (either from the current Lean repository or from Mathlib)
* <all_available_lemmas>: Lemmas/theorems available that may assist the proof.
* <local_ctx>...</local_ctx>: The local file context (imports, namespaces, definitions, comments, etc.) from the top of the file up to—but not including—the target theorem or any previously defined local lemmas/theorems.
* <target_theorem>...</target_theorem>: The target theorem statement, ending with `:=`.

**Notes**
1. Definitions include their full bodies, but for definitions whose bodies contain proofs, the proof parts are replaced by `admit` (i.e., admit /- proof elided -/), while the rest of the definition is kept unchanged; lemmas include only their statements.
2. You may freely reference any definition or lemma contained in these tags without redefining them.
3. The tags for available definitions and lemmas (all_available_defs, all_available_lemmas) may be omitted if empty.

### Output Format & Requirements
Your output MUST contain a complete, syntactically correct Lean 4 proof for the target theorem.

**Strict Output Structure:**
<reasoning> 
...
</reasoning> 

<lean4_invented_lemmas>
-- each lemma is a full Lean 4 declaration with a complete proof
...
</lean4_invented_lemmas>

<lean4_proof>
-- Lean 4 proof body of the target theorem
...
</lean4_proof>

**Requirements:**
1. <reasoning> and <lean4_invented_lemmas> are OPTIONAL. Include them only if they aid proof construction.
2. <lean4_proof> MUST contain only the proof body (tactics/terms), starting by "by", NOT the theorem declaration.
3. <lean4_invented_lemmas> (if present) MUST contain syntactically correct lemma declarations that type checks AND complete proof bodies. Defining a lemma using `axiom` is NOT allowed.
4. <reasoning> contains high-level proof planning.
5. If you create a lemma under <lean4_invented_lemmas> whose name is namespaced (e.g., X.Y.Z), you MUST always refer to it using its fully qualified name. Do NOT rely on shortened names. For example, write rw [X.Y.Z], not rw [Z] for invented lemmas.
6. All Lean 4 code MUST be syntactically correct. No `sorry`, `admit`, or non-Lean text. Comments allowed using `--` or `/- ... -/`.
7. Follow the tags and structure EXACTLY. No extra text before, between, or after the sections.
8. Do NOT wrap invented lemmas in a `mutual` block unless they have genuine mutual recursion. Declare each lemma independently.

### Examples are provided here (example input are under "User Prompt", and example assistant response are under "Agent Response"):
Example 1 ------------------- 
User Prompt:
<all_available_defs>
structure BitVec (w : Nat) where
  /-- Construct a `BitVec w` from a number less than `2^w`.
  O(1), because we use `Fin` as the internal representation of a bitvector. -/
  ofFin ::

  /-- Interpret a bitvector as a number less than `2^w`.
  O(1), because we use `Fin` as the internal representation of a bitvector. -/
  toFin : Fin (hPow 2 w)
</all_available_defs>

<all_available_lemmas>
theorem List.getElem_append_left{α : Type u_1} {l₁ l₂ : List α} {i : Nat} (hn : i < l₁.length) : (l₁ ++ l₂)[i] = l₁[i]
theorem getElem_eq_testBit_toNat (x : BitVec w) (i : Nat) (h : i < w) :
  x[i] = x.toNat.testBit i := rfl
@[simp, grind =] theorem toNat_cons (b : Bool) (x : BitVec w) :
    (cons b x).toNat = (b.toNat <<< w) ||| x.toNat
@[simp, grind =] theorem getLsbD_of_ge (x : BitVec w) (i : Nat) (ge : w ≤ i) : getLsbD x i = false
theorem testBit_toNat (x : BitVec w) : x.toNat.testBit i = x.getLsbD i
</all_available_lemmas>

<local_ctx>
import Mathlib.Computability.NFA
import Mathlib.Data.FinEnum
import Mathlib.Data.Rel
import Mathlib.Data.Vector.Basic
import Blase.AutoStructs.ForLean

open Set
open Mathlib
open SetRel

-- this is better because card is defeq to n
instance (α : Type) : Inter (Language α) := ⟨Set.inter⟩
instance (α : Type) : Union (Language α) := ⟨Set.union⟩

/--
The set of `n`-tuples of bit vectors of an arbitrary width.
-/
structure BitVecs (n : Nat) where
  w : Nat
  bvs : List.Vector (BitVec w) n

def BitVecs.cast (bvs : BitVecs n) (h : n = n') : BitVecs n' :=
  { w := bvs.w, bvs := h ▸ bvs.bvs }

abbrev BitVecs.empty : BitVecs n := ⟨0, List.Vector.replicate n .nil⟩
abbrev BitVecs.singleton {w : Nat} (bv : BitVec w) : BitVecs 1 := ⟨w, bv ::ᵥ .nil⟩
abbrev BitVecs.pair {w : Nat} (bv1 bv2 : BitVec w) : BitVecs 2 := ⟨w, bv1 ::ᵥ bv2 ::ᵥ .nil⟩

/--
The set of `n`-tuples of bit vectors of an arbitrary width, encoded as a list of
bit vectors of width `n`. The width of the encoded bit vectors is the length of
the list.
-/
abbrev BitVecs' (n : Nat) := List (BitVec n)

@[simps]
def dec (bvs' : BitVecs' n) : BitVecs n where
  w := bvs'.length
  bvs := List.Vector.ofFn fun k => BitVec.ofFn fun i => bvs'[i].getLsbD k

@[simp]
</local_ctx>

<target_theorem>
lemma dec_snoc n (bvs' : BitVecs' n) (a : BitVec n) :
  dec (bvs' ++ [a]) =
    { w := bvs'.length + 1
      bvs := List.Vector.ofFn fun k =>
        BitVec.cons (a.getLsbD k) ((dec bvs').bvs.get k) } :=
</target_theorem>

Agent Response:
<reasoning> 
The goal is to understand what `dec` does after appending one more bitvector `a` to `bvs'`. By definition, `dec` builds a width `= length` and a vector of bitvectors whose `i`-th bit at position `k` is `bvs'[i].getLsbD k`. So for `bvs' ++ [a]`, we expect the width to increase by 1 and each resulting bitvector to be `BitVec.cons` of the new bit coming from `a`.

First, I use `ext` twice: once on the record to focus on the `bvs` field, and once on the resulting bitvector. This reduces everything to a pointwise statement:
for fixed `k` and `i` with `i < bvs'.length + 1`,
the bit `(bvs' ++ [a])[i].getLsbD k` should match the bit at index `i` of `BitVec.cons (a.getLsbD k) ((dec bvs').bvs.get k)`.

At this point I need a clean description of indexing into `BitVec.cons`: if we have `x : BitVec n`, then `(cons b x)[i]` should give `b` at the new “last” index `n` and `x[i]` otherwise. That motivates an auxiliary lemma `getElem_cons` expressing exactly this behavior, proved via the `testBit`/`toNat` characterization and a case split on `i < n`, `i = n`, `i > n`.

Using `getElem_cons`, the RHS becomes an `if` on whether `i = bvs'.length`. So I split into cases:
- If `i = bvs'.length`, then `(bvs' ++ [a])[i]` is the appended `a`, so both sides reduce to `a.getLsbD k`.
- If `i ≠ bvs'.length`, the bound `i < bvs'.length + 1` forces `i < bvs'.length`. Then `(bvs' ++ [a])[i] = bvs'[i]` by `List.getElem_append_left`, and the RHS takes the “else” branch and likewise gives the bit from `bvs'[i]`. In both subcases, `simp` (plus the definition of `dec`) finishes.

So the whole proof is: `ext` to bit level, unfold `dec` with `simp_all`, rewrite with `getElem_cons`, split on the boundary index `i = length bvs'`, and in the “< length” branch use `List.getElem_append_left` and bounds to line up both sides.
</reasoning> 

<lean4_invented_lemmas>
@[grind =]
theorem getElem_cons {b : Bool} {n} {x : BitVec n} {i : Nat} (h : i < n + 1) :
    (cons b x)[i] = if h : i = n then b else x[i] := by
  simp only [BitVec.getElem_eq_testBit_toNat, BitVec.toNat_cons, Nat.testBit_or]
  rw [Nat.testBit_shiftLeft]
  rcases Nat.lt_trichotomy i n with i_lt_n | i_eq_n | n_lt_i
  · have p1 : ¬(n ≤ i) := by omega
    have p2 : i ≠ n := by omega
    simp [p1, p2]
  · simp only [i_eq_n, ge_iff_le, Nat.le_refl, decide_true, Nat.sub_self, Nat.testBit_zero,
    Bool.true_and, BitVec.testBit_toNat, BitVec.getLsbD_of_ge, Bool.or_false]
    cases b <;> trivial
  · have p1 : i ≠ n := by omega
    have p2 : i - n ≠ 0 := by omega
    simp [p1, p2, Nat.testBit_bool_toNat]
</lean4_invented_lemmas>

<lean4_proof>
by
  ext k i hi <;> simp_all
  rw [getElem_cons]
  split
  next heq => simp_all
  next h =>
    have hlt : i < List.length bvs' := by simp at hi; omega
    rw [List.getElem_append_left hlt]
    simp
</lean4_proof>

### Your task:
<all_available_defs>
DecidableEq in Init.Prelude
Lean.ToExpr in Lean.ToExpr
List in Init.Prelude
Repr in Init.Data.Repr
Nat in Init.Prelude
String in Init.Prelude
Fin in Init.Prelude
List.ofFn in Init.Data.List.OfFn
Option in Init.Prelude
List.length in Init.Prelude

structure Ctxt (Ty : Type) : Type where
  ofList :: toList : List Ty
  
  deriving Repr, Lean.ToExpr, DecidableEq

@[grind=]
def length (Γ : Ctxt Ty) : Nat := Γ.toList.length

inductive Ty (q : Nat) (n : Nat)
  | index : Ty q n
  | integer : Ty q n
  | tensor : Ty q n
  | polynomialLike : Ty q n
  deriving DecidableEq, Repr

def appendInl (v : Γ.Var t) : (Γ ++ Δ).Var t :=
  ⟨v.val, by admit /- proof elided -/
  ⟩

def Var (Γ : Ctxt Ty) (t : Ty) : Type :=
  { i : Nat // Γ[i]? = some t }

def icmp_equality_test_swift_optional_pointers_before := [llvm|
{
^0(%arg28 : i64, %arg29 : i64):
  %0 = llvm.mlir.constant(0) : i64
  %1 = llvm.mlir.constant(true) : i1
  %2 = llvm.mlir.constant(false) : i1
  %3 = llvm.icmp "eq" %arg28, %0 : i64
  %4 = llvm.icmp "eq" %arg29, %0 : i64
  %5 = "llvm.select"(%3, %1, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %6 = "llvm.select"(%3, %4, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %7 = llvm.icmp "eq" %arg28, %arg29 : i64
  %8 = "llvm.select"(%5, %6, %7) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%8) : (i1) -> ()
}
]

Function.LeftInverse in Init.Data.Function

def alive_InstCombineShift__279_src :=
[sllvm| {
^bb0(%X : i64, %C : i64):
  %v1 = llvm.lshr %X, %C : i64
  %v2 = llvm.shl %v1, %C : i64
  llvm.return %v2 : i64
}]

def and_zext_eq_zero_after := [llvm|
{
^0(%arg28 : i32, %arg29 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.icmp "eq" %arg28, %0 : i32
  %2 = llvm.zext %1 : i1 to i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def masked_icmps_mask_notallzeros_bmask_mixed_negated_4_after := [llvm|
{
^0(%arg62 : i32):
  %0 = llvm.mlir.constant(15 : i32) : i32
  %1 = llvm.mlir.constant(8 : i32) : i32
  %2 = llvm.and %arg62, %0 : i32
  %3 = llvm.icmp "ne" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def slt_or_not_max_logical_before := [llvm|
{
^0(%arg60 : i8, %arg61 : i8):
  %0 = llvm.mlir.constant(127 : i8) : i8
  %1 = llvm.mlir.constant(true) : i1
  %2 = llvm.icmp "slt" %arg60, %arg61 : i8
  %3 = llvm.icmp "ne" %arg60, %0 : i8
  %4 = "llvm.select"(%2, %1, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def bools2_logical_commute0_after := [llvm|
{
^0(%arg64 : i1, %arg65 : i1, %arg66 : i1):
  %0 = "llvm.select"(%arg66, %arg64, %arg65) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def ex3 : Com ∅ .nat :=
  .var (cst 1) <|
  .var (cst 0) <|
  .var (cst 2) <|
  .var (add ⟨1, by admit /- proof elided -/
  ⟩ ⟨0, by admit /- proof elided -/
  ⟩) <|
  .var (add ⟨3, by admit /- proof elided -/
  ⟩ ⟨1, by admit /- proof elided -/
  ⟩) <|
  .var (add ⟨1, by admit /- proof elided -/
  ⟩ ⟨0, by admit /- proof elided -/
  ⟩) <| 
  .var (add ⟨0, by admit /- proof elided -/
  ⟩ ⟨0, by admit /- proof elided -/
  ⟩) <|
  .ret ⟨0, by admit /- proof elided -/
  ⟩

def foo2_after := [llvm|
{
^0(%arg46 : i32, %arg47 : i32):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.icmp "sgt" %arg46, %0 : i32
  %3 = llvm.sub %1, %arg47 : i32
  %4 = "llvm.select"(%2, %arg47, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %5 = llvm.add %arg46, %4 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

instance : Lean.ToExpr TestDialect.Ty :=

instance : Lean.ToExpr (LLVM.Op) :=

def test4_before := [llvm|
{
^0(%arg3 : i37):
  %0 = llvm.mlir.constant(-1 : i37) : i37
  %1 = llvm.xor %0, %arg3 : i37
  %2 = llvm.xor %arg3, %1 : i37
  "llvm.return"(%2) : (i37) -> ()
}
]

def add_nuw_nsw_or_and_before := [llvm|
{
^0(%arg7 : i32, %arg8 : i32):
  %0 = llvm.or %arg7, %arg8 : i32
  %1 = llvm.and %arg7, %arg8 : i32
  %2 = llvm.add %0, %1 overflow<nsw,nuw> : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def not {Γ : Ctxt _} (a : Var Γ (.stream (.bitvec 1))) : Expr (Handshake) Γ .pure (.stream (.bitvec 1))  :=
  Expr.mk
    (op := .not)
    (ty_eq := rfl)
    (eff_le := by admit /- proof elided -/
    )
    (args := .cons a <| .nil)
    (regArgs := .nil)

def xor_or_xor_common_op_commute5_after := [llvm|
{
^0(%arg68 : i32, %arg69 : i32, %arg70 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg68, %0 : i32
  %2 = llvm.and %arg69, %1 : i32
  %3 = llvm.xor %2, %arg70 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def ExprRemapVar [DecidableEq d.Ty] [DecidableEq d.Op]
    {Γstart Γ Γ' : Ctxt d.Ty} {α}
    (lets : Lets d Γstart .pure Γ)
    (hom : Ctxt.Hom Γ' Γ)
    (vold : HVector Γ.Var α)
    (vnew : HVector Γ'.Var α)
    (VNEW: ∀ (Vstart : Ctxt.Valuation Γstart), vold.map (lets.denote Vstart) =
      vnew.map ((lets.denote Vstart).comap hom))
    (e' : Expr d Γ' .pure β) :
    {e : Expr d Γ .pure β // ∀ (V : Ctxt.Valuation Γstart),
          e.denoteOp (lets.denote V)
          = e'.denoteOp ((lets.denote V).comap hom) } :=
  match e' with
  | ⟨op, ty_eq, eff_le, args, regArgs⟩ =>
    let ⟨args', hargs'⟩ := VarRemapVar lets hom vold vnew VNEW args
    ⟨.mk op ty_eq eff_le args' regArgs, by admit /- proof elided -/
    ⟩

def or {Γ : Ctxt _} (e₁ e₂: Ctxt.Var Γ .bv) : Expr RV64 Γ .pure [.bv]  :=
  Expr.mk
    (op := Op.or)
    (eff_le := by admit /- proof elided -/
    )
    (ty_eq := by admit /- proof elided -/
    )
    (args := .cons e₁ <| .cons e₂ .nil)
    (regArgs := HVector.nil)

def constLLVM_2 : Com LLVMPlusRiscV ⟨[]⟩ .pure (.llvm (.bitvec 64)) := [LV| {
  ^entry ():
    %1 = llvm.mlir.constant (-2) : i64
    llvm.return %1 : i64
  }]

def udiv_exact_eq_1_before := [llvm|
{
^0(%arg10 : i8, %arg11 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.udiv exact %arg10, %arg11 : i8
  %2 = llvm.icmp "ne" %1, %0 : i8
  "llvm.return"(%2) : (i1) -> ()
}
]

def or_test2_after := [llvm|
{
^0(%arg0 : i7, %arg1 : i7):
  %0 = llvm.mlir.constant(-64 : i7) : i7
  "llvm.return"(%0) : (i7) -> ()
}
]

def n3_after := [llvm|
{
^0(%arg1 : i8, %arg2 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.shl %0, %arg2 overflow<nsw> : i8
  %2 = llvm.xor %1, %0 : i8
  %3 = llvm.icmp "uge" %arg1, %2 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def sge_smin1_before := [llvm|
{
^0(%arg79 : i32, %arg80 : i32):
  %0 = llvm.icmp "slt" %arg79, %arg80 : i32
  %1 = "llvm.select"(%0, %arg79, %arg80) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %2 = llvm.icmp "sge" %1, %arg79 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def masked_and_notallones_logical_before := [llvm|
{
^0(%arg128 : i32):
  %0 = llvm.mlir.constant(7 : i32) : i32
  %1 = llvm.mlir.constant(39 : i32) : i32
  %2 = llvm.mlir.constant(false) : i1
  %3 = llvm.and %arg128, %0 : i32
  %4 = llvm.icmp "ne" %3, %0 : i32
  %5 = llvm.and %arg128, %1 : i32
  %6 = llvm.icmp "ne" %5, %1 : i32
  %7 = "llvm.select"(%4, %6, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%7) : (i1) -> ()
}
]

def PR42691_6_after := [llvm|
{
^0(%arg333 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(-2147483646 : i32) : i32
  %2 = llvm.add %arg333, %0 : i32
  %3 = llvm.icmp "ult" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def test_before := [llvm|
{
^0(%arg1 : i32):
  %0 = llvm.mlir.constant(13 : i32) : i32
  %1 = llvm.mlir.constant(15 : i32) : i32
  %2 = llvm.icmp "ugt" %arg1, %0 : i32
  %3 = llvm.icmp "eq" %arg1, %1 : i32
  %4 = llvm.and %2, %3 : i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def xor_ashr_not_after := [llvm|
{
^0(%arg27 : i8, %arg28 : i8, %arg29 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.xor %arg28, %arg27 : i8
  %2 = llvm.ashr %1, %arg29 : i8
  %3 = llvm.xor %2, %0 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def slt_swap_and_not_max_logical_before := [llvm|
{
^0(%arg116 : i8, %arg117 : i8):
  %0 = llvm.mlir.constant(127 : i8) : i8
  %1 = llvm.mlir.constant(false) : i1
  %2 = llvm.icmp "sgt" %arg117, %arg116 : i8
  %3 = llvm.icmp "ne" %arg116, %0 : i8
  %4 = "llvm.select"(%2, %3, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def test6a_after := [llvm|
{
^0(%arg47 : i55):
  %0 = llvm.mlir.constant(6 : i55) : i55
  %1 = llvm.mul %arg47, %0 : i55
  "llvm.return"(%1) : (i55) -> ()
}
]

def ashr_pow2_ult_before := [llvm|
{
^0(%arg59 : i8):
  %0 = llvm.mlir.constant(-128 : i8) : i8
  %1 = llvm.mlir.constant(-96 : i8) : i8
  %2 = llvm.ashr %0, %arg59 : i8
  %3 = llvm.icmp "ult" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def icmp_eq_zext_eq_zero_after := [llvm|
{
^0(%arg40 : i32):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def trunc_lshr_after := [llvm|
{
^0(%arg10 : i8):
  %0 = llvm.mlir.constant(2 : i6) : i6
  %1 = llvm.mlir.constant(14 : i6) : i6
  %2 = llvm.trunc %arg10 : i8 to i6
  %3 = llvm.lshr %2, %0 : i6
  %4 = llvm.and %3, %1 : i6
  "llvm.return"(%4) : (i6) -> ()
}
]

def xor_ugt_2_before := [llvm|
{
^0(%arg13 : i8, %arg14 : i8, %arg15 : i8):
  %0 = llvm.mlir.constant(63 : i8) : i8
  %1 = llvm.mlir.constant(64 : i8) : i8
  %2 = llvm.add %arg13, %arg15 : i8
  %3 = llvm.and %arg14, %0 : i8
  %4 = llvm.or %3, %1 : i8
  %5 = llvm.xor %2, %4 : i8
  %6 = llvm.icmp "ugt" %2, %5 : i8
  "llvm.return"(%6) : (i1) -> ()
}
]

def and_slt_to_mask_before := [llvm|
{
^0(%arg5 : i8):
  %0 = llvm.mlir.constant(-124 : i8) : i8
  %1 = llvm.mlir.constant(2 : i8) : i8
  %2 = llvm.mlir.constant(0 : i8) : i8
  %3 = llvm.icmp "slt" %arg5, %0 : i8
  %4 = llvm.and %arg5, %1 : i8
  %5 = llvm.icmp "eq" %4, %2 : i8
  %6 = llvm.and %3, %5 : i1
  "llvm.return"(%6) : (i1) -> ()
}
]

def test9_before := [llvm|
{
^0(%arg111 : i32, %arg112 : i32):
  %0 = llvm.and %arg111, %arg112 : i32
  %1 = llvm.xor %arg111, %arg112 : i32
  %2 = llvm.xor %0, %1 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

instance : DialectPrint Handshake where
  printOpName := reprStr
  printTy := reprStr
  printAttributes _ := ""
  dialectName := "handshake"
  printReturn _ := "return"

private def tensor1dTest : MLIRTy := [mlir_type| tensor1d]

def bitwise_and_logical_and_masked_icmp_allzeros_before := [llvm|
{
^0(%arg147 : i1, %arg148 : i32):
  %0 = llvm.mlir.constant(8 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(false) : i1
  %3 = llvm.mlir.constant(7 : i32) : i32
  %4 = llvm.and %arg148, %0 : i32
  %5 = llvm.icmp "eq" %4, %1 : i32
  %6 = "llvm.select"(%5, %arg147, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %7 = llvm.and %arg148, %3 : i32
  %8 = llvm.icmp "eq" %7, %1 : i32
  %9 = llvm.and %6, %8 : i1
  "llvm.return"(%9) : (i1) -> ()
}
]

def p_before := [llvm|
{
^0(%arg60 : i32, %arg61 : i32, %arg62 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.and %arg60, %arg62 : i32
  %2 = llvm.xor %arg62, %0 : i32
  %3 = llvm.and %2, %arg61 : i32
  %4 = llvm.or %1, %3 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def lshr_exact_ne_0_after := [llvm|
{
^0(%arg121 : i32, %arg122 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.icmp "ne" %arg121, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def ashrslt_03_07_before := [llvm|
{
^0(%arg230 : i4):
  %0 = llvm.mlir.constant(3 : i4) : i4
  %1 = llvm.mlir.constant(7 : i4) : i4
  %2 = llvm.ashr %arg230, %0 : i4
  %3 = llvm.icmp "slt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def xor_logic_and_or2_after := [llvm|
{
^0(%arg15 : i1, %arg16 : i1, %arg17 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.xor %arg16, %0 : i1
  %2 = "llvm.select"(%arg15, %1, %arg17) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%2) : (i1) -> ()
}
]

def select_t_cond : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64), Ty.llvm (.bitvec 1)] where
  lhs := [LV| {
    ^entry (%c: i1, %t: i64):
      %0 = llvm.sext %c: i1 to i64
      %1 = llvm.select %c, %t, %0 : i64
      llvm.return %1 : i64
  }]
  rhs := [LV| {
    ^entry (%c: i1, %t: i64):
      %0 = llvm.sext %c: i1 to i64
      %1 = llvm.freeze %t : i64
      %2 = llvm.and %0, %1 : i64
      llvm.return %2 : i64
  }]

def zext_sext_sgt_known_nonneg_before := [llvm|
{
^0(%arg24 : i8, %arg25 : i8):
  %0 = llvm.mlir.constant(127 : i8) : i8
  %1 = llvm.udiv %0, %arg24 : i8
  %2 = llvm.zext %1 : i8 to i32
  %3 = llvm.sext %arg25 : i8 to i32
  %4 = llvm.icmp "sgt" %2, %3 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def f_var1_commutative_and_before := [llvm|
{
^0(%arg40 : i32, %arg41 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.mlir.constant(1 : i32) : i32
  %2 = llvm.and %arg41, %arg40 : i32
  %3 = llvm.icmp "eq" %2, %0 : i32
  %4 = llvm.and %arg40, %1 : i32
  %5 = "llvm.select"(%3, %4, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def sle_swap_or_min_before := [llvm|
{
^0(%arg150 : i8, %arg151 : i8):
  %0 = llvm.mlir.constant(-128 : i8) : i8
  %1 = llvm.icmp "sge" %arg151, %arg150 : i8
  %2 = llvm.icmp "eq" %arg150, %0 : i8
  %3 = llvm.or %1, %2 : i1
  "llvm.return"(%3) : (i1) -> ()
}
]

Max in Init.Prelude

def getSimpData (simpsetName : Name) : MetaM (SimpTheorems × Simprocs) := do
  let some ext ← (getSimpExtension? simpsetName)
    | throwError m!"'{simpsetName}' simp attribute not found!"
  let theorems ← ext.getTheorems
  let some ext ← (Simp.getSimprocExtension? simpsetName)
    | throwError m!"'{simpsetName}' simp attribute not found!"
  let simprocs ← ext.getSimprocs
  return (theorems, simprocs)

@[reducible]
instance : TyDenote ExTy where
  toType
    | .nat => Nat
    | .bool => Bool

abbrev worklist.St.sim {st : worklist.St A S} (T : Set (S × A × S)) :=
  st.m.Simul (nfa inits final f) st.rel st.D T

@[simp_denote]
def shl_riscv_64 := [LV| {
  ^entry (%reg1: i64, %reg2: i64 ):
    %0 = "builtin.unrealized_conversion_cast"(%reg1) : (i64) -> (!i64)
    %1 = "builtin.unrealized_conversion_cast"(%reg2) : (i64) -> (!i64)
    %2 = sll %0, %1 : !i64
    %3 = "builtin.unrealized_conversion_cast"(%2) : (!i64) -> (i64)
    llvm.return %3 : i64
  }]

def test11f_before := [llvm|
{
^0(%arg91 : i32, %arg92 : i32, %arg93 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.mul %arg92, %arg93 : i32
  %2 = llvm.xor %1, %arg91 : i32
  %3 = llvm.xor %arg91, %0 : i32
  %4 = llvm.xor %1, %3 : i32
  %5 = llvm.and %4, %2 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def foo_before := [llvm|
{
^0(%arg0 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.mlir.constant(7 : i32) : i32
  %2 = llvm.or %0, %1 : i32
  %3 = llvm.and %arg0, %2 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def or_not_and_commute2_before := [llvm|
{
^0(%arg531 : i32, %arg532 : i32, %arg533 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.sdiv %0, %arg532 : i32
  %3 = llvm.or %arg531, %2 : i32
  %4 = llvm.xor %3, %1 : i32
  %5 = llvm.and %4, %arg533 : i32
  %6 = llvm.or %arg531, %arg533 : i32
  %7 = llvm.xor %6, %1 : i32
  %8 = llvm.and %2, %7 : i32
  %9 = llvm.or %8, %5 : i32
  "llvm.return"(%9) : (i32) -> ()
}
]

def test7_after := [llvm|
{
^0(%arg7 : i47):
  %0 = llvm.mlir.constant(39 : i47) : i47
  %1 = llvm.lshr %arg7, %0 : i47
  "llvm.return"(%1) : (i47) -> ()
}
]

def lshrult_02_09_exact_before := [llvm|
{
^0(%arg124 : i4):
  %0 = llvm.mlir.constant(2 : i4) : i4
  %1 = llvm.mlir.constant(-7 : i4) : i4
  %2 = llvm.lshr exact %arg124, %0 : i4
  %3 = llvm.icmp "ult" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def ashr_exact_eq_0_before := [llvm|
{
^0(%arg127 : i32, %arg128 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.ashr exact %arg127, %arg128 : i32
  %2 = llvm.icmp "eq" %1, %0 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def mul_select_zext_before := [llvm|
{
^0(%arg18 : i1, %arg19 : i64):
  %0 = llvm.mlir.constant(1) : i64
  %1 = "llvm.select"(%arg18, %arg19, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i64, i64) -> i64
  %2 = llvm.zext %arg18 : i1 to i64
  %3 = llvm.mul %1, %2 : i64
  "llvm.return"(%3) : (i64) -> ()
}
]

def urem_common_dividend_defined_cond_before := [llvm|
{
^0(%arg13 : i1, %arg14 : i5, %arg15 : i5, %arg16 : i5):
  %0 = llvm.urem %arg14, %arg15 : i5
  %1 = llvm.urem %arg14, %arg16 : i5
  %2 = "llvm.select"(%arg13, %1, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i5, i5) -> i5
  "llvm.return"(%2) : (i5) -> ()
}
]

def masked_icmps_mask_notallzeros_bmask_mixed_negated_7_after := [llvm|
{
^0(%arg56 : i32):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def samesign_inverted_commute3_before := [llvm|
{
^0(%arg97 : i32, %arg98 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.and %arg97, %arg98 : i32
  %3 = llvm.icmp "sgt" %2, %0 : i32
  %4 = llvm.or %arg98, %arg97 : i32
  %5 = llvm.icmp "slt" %4, %1 : i32
  %6 = llvm.and %5, %3 : i1
  "llvm.return"(%6) : (i1) -> ()
}
]

def binop_right_to_zero_mul : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%x: i64):
      %c = llvm.mlir.constant (0) : i64
      %0 = llvm.mul %x, %c: i64
      llvm.return %0 : i64
  }]
  rhs := [LV| {
    ^entry (%x: i64):
      %c = llvm.mlir.constant (0) : i64
      llvm.return %c : i64
  }]

def Region.WellTyped : UnTyped.Region Op VarName → RegionType Ty → Prop
  | ⟨entry, _⟩ => BasicBlock.WellTyped entry

instance : Lean.ToExpr RegIndex := inherit

def test_before := [llvm|
{
^0(%arg0 : i8):
  %0 = llvm.mlir.constant(8 : i32) : i32
  %1 = llvm.sext %arg0 : i8 to i32
  %2 = llvm.ashr %1, %0 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def elim0 {α : Sort u} (i : Inputs ι 0) : α :=
  i.ix.elim0

def bools_logical_commute0_after := [llvm|
{
^0(%arg108 : i1, %arg109 : i1, %arg110 : i1):
  %0 = "llvm.select"(%arg110, %arg109, %arg108) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def sgt_swap_and_min_commute_logical_after := [llvm|
{
^0(%arg338 : i8, %arg339 : i8):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def invert_icmp_after := [llvm|
{
^0(%arg151 : i32, %arg152 : i32):
  %0 = llvm.icmp "sgt" %arg151, %arg152 : i32
  "llvm.return"(%0) : (i1) -> ()
}
]

def lowbitmask_casted_shift_after := [llvm|
{
^0(%arg157 : i8):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.sext %arg157 : i8 to i32
  %2 = llvm.lshr %1, %0 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def select_sub_icmp_bad_2_before := [llvm|
{
^0(%arg68 : i32, %arg69 : i32, %arg70 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.icmp "eq" %arg68, %0 : i32
  %2 = llvm.sub %arg70, %arg68 : i32
  %3 = "llvm.select"(%1, %2, %arg69) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def test_mul__nsw_is_safe_before := [llvm|
{
^0(%arg4 : i32):
  %0 = llvm.mlir.constant(-83886080 : i32) : i32
  %1 = llvm.mlir.constant(-83886079 : i32) : i32
  %2 = llvm.mlir.constant(9 : i32) : i32
  %3 = llvm.mlir.constant(-754974711 : i32) : i32
  %4 = llvm.or %arg4, %0 : i32
  %5 = llvm.icmp "eq" %4, %1 : i32
  %6 = llvm.mul %4, %2 : i32
  %7 = "llvm.select"(%5, %3, %6) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%7) : (i32) -> ()
}
]

def test18_after := [llvm|
{
^0(%arg34 : i32, %arg35 : i32):
  %0 = llvm.mlir.constant(1431655765 : i32) : i32
  %1 = llvm.or %arg34, %0 : i32
  %2 = llvm.sub %arg35, %1 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def constLLVM_42 : Com LLVMPlusRiscV ⟨[]⟩ .pure (.llvm (.bitvec 64)) := [LV| {
  ^entry ():
    %1 = llvm.mlir.constant (-42) : i64
    llvm.return %1 : i64
  }]

def xor_signbit_select_shl_before := [llvm|
{
^0(%arg38 : i32, %arg39 : i1):
  %0 = llvm.mlir.constant(-65536 : i32) : i32
  %1 = llvm.mlir.constant(8 : i32) : i32
  %2 = llvm.xor %arg38, %0 : i32
  %3 = "llvm.select"(%arg39, %2, %arg38) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %4 = llvm.shl %3, %1 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def ashrsgt_01_02_before := [llvm|
{
^0(%arg315 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(2 : i4) : i4
  %2 = llvm.ashr %arg315, %0 : i4
  %3 = llvm.icmp "sgt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def test17_after := [llvm|
{
^0(%arg18 : i106):
  %0 = llvm.mlir.constant(-8 : i106) : i106
  %1 = llvm.mlir.constant(9872 : i106) : i106
  %2 = llvm.and %arg18, %0 : i106
  %3 = llvm.icmp "eq" %2, %1 : i106
  "llvm.return"(%3) : (i1) -> ()
}
]

def main6c_before := [llvm|
{
^0(%arg90 : i32):
  %0 = llvm.mlir.constant(7 : i32) : i32
  %1 = llvm.mlir.constant(3 : i32) : i32
  %2 = llvm.mlir.constant(48 : i32) : i32
  %3 = llvm.mlir.constant(16 : i32) : i32
  %4 = llvm.mlir.constant(0 : i32) : i32
  %5 = llvm.mlir.constant(1 : i32) : i32
  %6 = llvm.and %arg90, %0 : i32
  %7 = llvm.icmp "ne" %6, %1 : i32
  %8 = llvm.and %arg90, %2 : i32
  %9 = llvm.icmp "ne" %8, %3 : i32
  %10 = llvm.or %7, %9 : i1
  %11 = "llvm.select"(%10, %4, %5) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%11) : (i32) -> ()
}
]

def t9_after := [llvm|
{
^0(%arg176 : i8, %arg177 : i8):
  %0 = llvm.sub %arg176, %arg177 : i8
  "llvm.return"(%0) : (i8) -> ()
}
]

def p_before := [llvm|
{
^0(%arg73 : i32, %arg74 : i32, %arg75 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg75, %0 : i32
  %2 = llvm.or %1, %arg73 : i32
  %3 = llvm.or %arg74, %arg75 : i32
  %4 = llvm.and %2, %3 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def zext_nneg_before := [llvm|
{
^0(%arg0 : i16):
  %0 = llvm.mlir.constant(32767 : i16) : i16
  %1 = llvm.mlir.constant(8388607 : i24) : i24
  %2 = llvm.and %arg0, %0 : i16
  %3 = llvm.zext nneg %2 : i16 to i24
  %4 = llvm.and %3, %1 : i24
  "llvm.return"(%4) : (i24) -> ()
}
]

def select_icmp_ne_0_and_4096_or_4096_after := [llvm|
{
^0(%arg233 : i32, %arg234 : i32):
  %0 = llvm.mlir.constant(4096 : i32) : i32
  %1 = llvm.and %arg233, %0 : i32
  %2 = llvm.xor %1, %0 : i32
  %3 = llvm.or %arg234, %2 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def ashr_exact_add_negative_shift_negative_before := [llvm|
{
^0(%arg49 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.mlir.constant(-2 : i32) : i32
  %2 = llvm.add %arg49, %0 : i32
  %3 = llvm.ashr exact %1, %2 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def test21_before := [llvm|
{
^0(%arg10 : i12):
  %0 = llvm.mlir.constant(6 : i12) : i12
  %1 = llvm.mlir.constant(-128 : i12) : i12
  %2 = llvm.shl %arg10, %0 : i12
  %3 = llvm.icmp "eq" %2, %1 : i12
  "llvm.return"(%3) : (i1) -> ()
}
]

def fork {Γ : Ctxt _}  (a : Γ.Var (MLIR2DCPlus.Ty.tokenstream)) : Expr (DCPlus) Γ .pure (.tokenstream2) :=
  Expr.mk
    (op := .fork)
    (ty_eq := rfl)
    (eff_le := by admit /- proof elided -/
    )
    (args := .cons a <| .nil)
    (regArgs := .nil)

def t1_after := [llvm|
{
^0(%arg28 : i8, %arg29 : i1):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.sub %0, %arg28 : i8
  %2 = "llvm.select"(%arg29, %1, %arg28) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def ult_to_slt_before := [llvm|
{
^0(%arg32 : i8, %arg33 : i8):
  %0 = llvm.mlir.constant(-128 : i8) : i8
  %1 = llvm.xor %arg32, %0 : i8
  %2 = llvm.xor %arg33, %0 : i8
  %3 = llvm.icmp "ult" %1, %2 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def and_or_not_not_commute1_after := [llvm|
{
^0(%arg372 : i32, %arg373 : i32, %arg374 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.sdiv %0, %arg373 : i32
  %3 = llvm.or %arg374, %2 : i32
  %4 = llvm.and %3, %arg372 : i32
  %5 = llvm.xor %4, %1 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def scalar_i32_lshr_and_negC_eq_X_is_constant2_before := [llvm|
{
^0(%arg8 : i32):
  %0 = llvm.mlir.constant(268435456 : i32) : i32
  %1 = llvm.mlir.constant(-8 : i32) : i32
  %2 = llvm.mlir.constant(0 : i32) : i32
  %3 = llvm.lshr %0, %arg8 : i32
  %4 = llvm.and %3, %1 : i32
  %5 = llvm.icmp "eq" %4, %2 : i32
  "llvm.return"(%5) : (i1) -> ()
}
]

def narrow_sext_and_after := [llvm|
{
^0(%arg56 : i16, %arg57 : i32):
  %0 = llvm.trunc %arg57 : i32 to i16
  %1 = llvm.and %arg56, %0 : i16
  "llvm.return"(%1) : (i16) -> ()
}
]

def icmp_slt_0_and_icmp_sge_neg1_i64_fail_before := [llvm|
{
^0(%arg59 : i64):
  %0 = llvm.mlir.constant(-1) : i64
  %1 = llvm.mlir.constant(62) : i64
  %2 = llvm.icmp "sge" %arg59, %0 : i64
  %3 = llvm.zext %2 : i1 to i64
  %4 = llvm.lshr %arg59, %1 : i64
  %5 = llvm.and %4, %3 : i64
  "llvm.return"(%5) : (i64) -> ()
}
]

def neg (x : BitStream) : BitStream :=
  fun n => (negAux x n).1

def sub_zext_trunc_lshr_after := [llvm|
{
^0(%arg15 : i64):
  %0 = llvm.mlir.constant(16 : i32) : i32
  %1 = llvm.mlir.constant(31 : i32) : i32
  %2 = llvm.mlir.constant(10 : i32) : i32
  %3 = llvm.trunc %arg15 : i64 to i32
  %4 = llvm.shl %3, %0 : i32
  %5 = llvm.ashr %4, %1 : i32
  %6 = llvm.add %5, %2 overflow<nsw> : i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def CNFA.inter_bv_language (m₁ m₂ : CNFA n) :
    m₁.bv_recognizes L₁ →
    m₂.bv_recognizes L₂ →
    (m₁.inter m₂).bv_recognizes (L₁ ∩ L₂) :=

def sext_sub_after := [llvm|
{
^0(%arg20 : i8, %arg21 : i1):
  %0 = llvm.zext %arg21 : i1 to i8
  %1 = llvm.add %arg20, %0 : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def uge_zext_after := [llvm|
{
^0(%arg170 : i1, %arg171 : i8):
  %0 = llvm.zext %arg170 : i1 to i8
  %1 = llvm.icmp "ule" %arg171, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def original_sdiv_srem := [LV| {
  ^entry (%a: i64, %b: i64):
    %0= llvm.sdiv exact %a, %b : i64
    %1 = llvm.srem %a, %b : i64
    llvm.return %1 : i64
  }]

def test_sext_zext_after := [llvm|
{
^0(%arg105 : i16):
  %0 = llvm.zext %arg105 : i16 to i64
  "llvm.return"(%0) : (i64) -> ()
}
]

def different_size_sext_sext_sle_after := [llvm|
{
^0(%arg12 : i7, %arg13 : i4):
  %0 = llvm.sext %arg13 : i4 to i7
  %1 = llvm.icmp "sle" %arg12, %0 : i7
  "llvm.return"(%1) : (i1) -> ()
}
]

def pr40493_neg3_after := [llvm|
{
^0(%arg15 : i32):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.mlir.constant(4 : i32) : i32
  %2 = llvm.shl %arg15, %0 : i32
  %3 = llvm.and %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def add_nsw_poison_constant_fold_after := [llvm|
{
^0(%arg2 : i1, %arg3 : i8):
  %0 = llvm.mlir.constant(64 : i8) : i8
  %1 = llvm.mlir.constant(-127 : i8) : i8
  %2 = llvm.add %arg3, %0 overflow<nsw> : i8
  %3 = "llvm.select"(%arg2, %2, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def different_size_zext_zext_slt_before := [llvm|
{
^0(%arg18 : i7, %arg19 : i4):
  %0 = llvm.zext %arg18 : i7 to i25
  %1 = llvm.zext %arg19 : i4 to i25
  %2 = llvm.icmp "slt" %0, %1 : i25
  "llvm.return"(%2) : (i1) -> ()
}
]

def bar_before := [llvm|
{
^0(%arg109 : i32, %arg110 : i32, %arg111 : i32, %arg112 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.icmp "slt" %arg109, %arg110 : i32
  %2 = llvm.sext %1 : i1 to i32
  %3 = llvm.and %arg111, %2 : i32
  %4 = llvm.xor %2, %0 : i32
  %5 = llvm.and %arg112, %4 : i32
  %6 = llvm.or %5, %3 : i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def test_shr_and_1_ne_0_samesign_after := [llvm|
{
^0(%arg9 : i32, %arg10 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.shl %0, %arg10 overflow<nuw> : i32
  %3 = llvm.and %arg9, %2 : i32
  %4 = llvm.icmp "ne" %3, %1 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

RV64.xor in RISCV.Instructions

def trunc_equality_both_after := [llvm|
{
^0(%arg40 : i16, %arg41 : i16):
  %0 = llvm.icmp "eq" %arg40, %arg41 : i16
  "llvm.return"(%0) : (i1) -> ()
}
]

def alive_AddSub_1043_tgt  (w : Nat)  :=
[llvm( w )| {
^bb0(%C1 : _, %Z : _, %RHS : _):
  %v1 = llvm.not %C1
  %v2 = llvm.or %Z, %v1
  %v3 = llvm.and %Z, %C1
  %v4 = llvm.xor %v3, %C1
  %v5 = llvm.mlir.constant 1
  %v6 = llvm.add %v4, %v5
  %v7 = llvm.sub %RHS, %v2
  llvm.return %v7
}]

def or_xor_tree_0110_after := [llvm|
{
^0(%arg27 : i32, %arg28 : i32, %arg29 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mul %arg27, %0 : i32
  %2 = llvm.mul %arg28, %0 : i32
  %3 = llvm.mul %arg29, %0 : i32
  %4 = llvm.xor %1, %2 : i32
  %5 = llvm.or %4, %3 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def src_x_and_nmask_sge_fail_maybe_z_before := [llvm|
{
^0(%arg11 : i8, %arg12 : i8, %arg13 : i1):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.mlir.constant(0 : i8) : i8
  %2 = llvm.shl %0, %arg12 : i8
  %3 = "llvm.select"(%arg13, %2, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  %4 = llvm.and %arg11, %3 : i8
  %5 = llvm.icmp "sge" %4, %3 : i8
  "llvm.return"(%5) : (i1) -> ()
}
]

def main7e_after := [llvm|
{
^0(%arg54 : i32, %arg55 : i32, %arg56 : i32, %arg57 : i32, %arg58 : i32):
  %0 = llvm.and %arg55, %arg57 : i32
  %1 = llvm.and %arg56, %arg58 : i32
  %2 = llvm.or %0, %1 : i32
  %3 = llvm.and %arg54, %2 : i32
  %4 = llvm.icmp "ne" %3, %2 : i32
  %5 = llvm.zext %4 : i1 to i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def no_shift_no_xor_multiuse_or_after := [llvm|
{
^0(%arg140 : i32, %arg141 : i32):
  %0 = llvm.mlir.constant(4096 : i32) : i32
  %1 = llvm.and %arg140, %0 : i32
  %2 = llvm.or %arg141, %0 : i32
  %3 = llvm.or %arg141, %1 : i32
  %4 = llvm.mul %3, %2 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def eq_umin1_before := [llvm|
{
^0(%arg60 : i32, %arg61 : i32):
  %0 = llvm.icmp "ult" %arg60, %arg61 : i32
  %1 = "llvm.select"(%0, %arg60, %arg61) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %2 = llvm.icmp "eq" %1, %arg60 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def udiv {w : Nat} (x y : IntW w) (flag : ExactFlag := {exact := false}) : IntW w := do
  let x' ← x
  let y' ← y
  if flag.exact ∧ x'.umod y' ≠ 0 then
    .poison
  else
    udiv? x' y'

structure Item where
 name : String
 tac : Syntax

Repr in Init.Data.Repr

@[match_pattern] abbrev zext (w w': Nat) (flag : NonNegFlag := {nneg := false}) : LLVM.Op :=
  MOp.zext (.concrete w) (.concrete w') flag

def slt_zero_eq_ne_0_fail2_before := [llvm|
{
^0(%arg0 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.mlir.constant(30 : i32) : i32
  %2 = llvm.icmp "ne" %arg0, %0 : i32
  %3 = llvm.zext %2 : i1 to i32
  %4 = llvm.lshr %arg0, %1 : i32
  %5 = llvm.icmp "eq" %3, %4 : i32
  "llvm.return"(%5) : (i1) -> ()
}
]

def or_umin_after := [llvm|
{
^0(%arg4 : i32):
  %0 = llvm.mlir.constant(31 : i32) : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

structure CliTest where
  name : Name
  mvars : Nat
  context : MContext mvars
  ty : MTy mvars
  eff : EffectKind
  code : MCom mvars context eff [ty]

def positive_biggershl_shlnuw_ashrexact_after := [llvm|
{
^0(%arg29 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.shl %arg29, %0 overflow<nuw> : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def t1_sub_from_falseval_before := [llvm|
{
^0(%arg10 : i1, %arg11 : i8, %arg12 : i8):
  %0 = "llvm.select"(%arg10, %arg11, %arg12) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  %1 = llvm.sub %arg12, %0 : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def lift (f : Fin n → Fin m) (M : NFA' n) : NFA' m where
  σ := _
  M := M.M.lift f

def and_or3_commuted_after := [llvm|
{
^0(%arg164 : i1, %arg165 : i1, %arg166 : i32, %arg167 : i32):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.mlir.constant(false) : i1
  %2 = llvm.icmp "ne" %arg166, %arg167 : i32
  %3 = "llvm.select"(%2, %0, %arg164) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %4 = "llvm.select"(%arg165, %3, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def test3_before := [llvm|
{
^0(%arg51 : i32):
  %0 = llvm.icmp "slt" %arg51, %arg51 : i32
  "llvm.return"(%0) : (i1) -> ()
}
]

def positive_biggershl_shlnsw_before := [llvm|
{
^0(%arg49 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.mlir.constant(6 : i8) : i8
  %2 = llvm.lshr %arg49, %0 : i8
  %3 = llvm.shl %2, %1 overflow<nsw> : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

@[simp_denote]
def icmp_ule_llvm_32 : Com LLVMPlusRiscV ⟨[.llvm (.bitvec 32), .llvm (.bitvec 32)]⟩
  .pure (.llvm (.bitvec 1)) := [LV| {
  ^entry (%lhs: i32, %rhs: i32):
    %1 = llvm.icmp.ule %lhs, %rhs : i32
    llvm.return %1 : i1
  }]

def and_orn_cmp_3_logical_before := [llvm|
{
^0(%arg182 : i72, %arg183 : i72, %arg184 : i72):
  %0 = llvm.mlir.constant(42 : i72) : i72
  %1 = llvm.mlir.constant(true) : i1
  %2 = llvm.mlir.constant(false) : i1
  %3 = llvm.icmp "ugt" %arg182, %arg183 : i72
  %4 = llvm.icmp "ule" %arg182, %arg183 : i72
  %5 = llvm.icmp "ugt" %arg184, %0 : i72
  %6 = "llvm.select"(%4, %1, %5) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %7 = "llvm.select"(%3, %6, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%7) : (i1) -> ()
}
]

instance [ToString w] : ToString (Option w) where
  toString
    | some x => s!"(some {toString x})"
    | none   => "(none)"

def lshrugt_02_03_before := [llvm|
{
^0(%arg396 : i4):
  %0 = llvm.mlir.constant(2 : i4) : i4
  %1 = llvm.mlir.constant(3 : i4) : i4
  %2 = llvm.lshr %arg396, %0 : i4
  %3 = llvm.icmp "ugt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def negtest_near_pow2_cmpval_ashr_slt_noexact_before := [llvm|
{
^0(%arg3 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.mlir.constant(5 : i8) : i8
  %2 = llvm.ashr %arg3, %0 : i8
  %3 = llvm.icmp "slt" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

instance : BEq BVExprWrapper where
  beq := fun a b => if h : a.width = b.width then
                      a.bvExpr == h ▸ b.bvExpr
                    else false

def and_xor_commute2_after := [llvm|
{
^0(%arg153 : i32, %arg154 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.udiv %0, %arg153 : i32
  %3 = llvm.udiv %0, %arg154 : i32
  %4 = llvm.xor %2, %1 : i32
  %5 = llvm.and %3, %4 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def select_ashr_before := [llvm|
{
^0(%arg6 : i1, %arg7 : i128, %arg8 : i128):
  %0 = llvm.ashr %arg7, %arg8 : i128
  %1 = "llvm.select"(%arg6, %0, %arg7) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i128, i128) -> i128
  "llvm.return"(%1) : (i128) -> ()
}
]

@[simp_denote]
def add_llvm_nsw_nuw_flags_8 := [LV| {
   ^entry (%lhs: i8, %rhs: i8):
    %1 = llvm.add %lhs, %rhs overflow<nsw,nuw> : i8
    llvm.return %1 : i8
  }]

def scalar_i8_shl_and_negC_eq_after := [llvm|
{
^0(%arg35 : i8, %arg36 : i8):
  %0 = llvm.mlir.constant(4 : i8) : i8
  %1 = llvm.shl %arg35, %arg36 : i8
  %2 = llvm.icmp "ult" %1, %0 : i8
  "llvm.return"(%2) : (i1) -> ()
}
]

def lor_lor_left2_after := [llvm|
{
^0(%arg68 : i1, %arg69 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = "llvm.select"(%arg69, %0, %arg68) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%1) : (i1) -> ()
}
]

def test5_after := [llvm|
{
^0(%arg52 : i41):
  %0 = llvm.mlir.constant(32 : i41) : i41
  %1 = llvm.and %arg52, %0 : i41
  "llvm.return"(%1) : (i41) -> ()
}
]

def ule_or_min_logical_after := [llvm|
{
^0(%arg140 : i8, %arg141 : i8):
  %0 = llvm.icmp "ule" %arg140, %arg141 : i8
  "llvm.return"(%0) : (i1) -> ()
}
]

def test_and1_logical_after := [llvm|
{
^0(%arg50 : i32, %arg51 : i32):
  %0 = llvm.mlir.constant(2147483647 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.mlir.constant(false) : i1
  %3 = llvm.and %arg51, %0 : i32
  %4 = llvm.icmp "sgt" %arg50, %1 : i32
  %5 = llvm.icmp "slt" %arg50, %3 : i32
  %6 = "llvm.select"(%4, %5, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%6) : (i1) -> ()
}
]

def not_zext_before := [llvm|
{
^0(%arg8 : i1):
  %0 = llvm.mlir.constant(0 : i999) : i999
  %1 = llvm.mlir.constant(1 : i999) : i999
  %2 = "llvm.select"(%arg8, %0, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i999, i999) -> i999
  "llvm.return"(%2) : (i999) -> ()
}
]

def select_icmp_ne_pow2_flipped_before := [llvm|
{
^0(%arg9 : i8):
  %0 = llvm.mlir.constant(4 : i8) : i8
  %1 = llvm.mlir.constant(0 : i8) : i8
  %2 = llvm.and %arg9, %0 : i8
  %3 = llvm.icmp "ne" %2, %1 : i8
  %4 = llvm.xor %arg9, %0 : i8
  %5 = "llvm.select"(%3, %arg9, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%5) : (i8) -> ()
}
]

def test_before := [llvm|
{
^0(%arg0 : i16, %arg1 : i16):
  %0 = llvm.sext %arg0 : i16 to i32
  %1 = llvm.sext %arg1 : i16 to i32
  %2 = llvm.add %0, %1 : i32
  %3 = llvm.sext %2 : i32 to i64
  "llvm.return"(%3) : (i64) -> ()
}
]

def gt_unsigned_to_small_negative_before := [llvm|
{
^0(%arg30 : i8):
  %0 = llvm.mlir.constant(-17 : i32) : i32
  %1 = llvm.zext %arg30 : i8 to i32
  %2 = llvm.icmp "sgt" %1, %0 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def select_and_icmp_zero_after := [llvm|
{
^0(%arg152 : i32, %arg153 : i32, %arg154 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.icmp "eq" %arg152, %0 : i32
  %2 = "llvm.select"(%1, %0, %arg153) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def test52_before := [llvm|
{
^0(%arg132 : i64):
  %0 = llvm.mlir.constant(-32574 : i16) : i16
  %1 = llvm.mlir.constant(-25350 : i16) : i16
  %2 = llvm.trunc %arg132 : i64 to i16
  %3 = llvm.or %2, %0 : i16
  %4 = llvm.and %3, %1 : i16
  %5 = llvm.zext %4 : i16 to i32
  "llvm.return"(%5) : (i32) -> ()
}
]

@[simp]
abbrev RV64 : Dialect where
  Op := Op
  Ty := Ty

def or_simplify_uge_after := [llvm|
{
^0(%arg15 : i8, %arg16 : i8, %arg17 : i1):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def test_nuw_nsw_and_unsigned_pred_before := [llvm|
{
^0(%arg55 : i64):
  %0 = llvm.mlir.constant(10) : i64
  %1 = llvm.mlir.constant(3) : i64
  %2 = llvm.sub %0, %arg55 overflow<nsw,nuw> : i64
  %3 = llvm.icmp "ule" %2, %1 : i64
  "llvm.return"(%3) : (i1) -> ()
}
]

def main5e_like_after := [llvm|
{
^0(%arg108 : i32, %arg109 : i32, %arg110 : i32):
  %0 = llvm.and %arg109, %arg110 : i32
  %1 = llvm.and %arg108, %0 : i32
  %2 = llvm.icmp "ne" %1, %arg108 : i32
  %3 = llvm.zext %2 : i1 to i32
  "llvm.return"(%3) : (i32) -> ()
}
]

RV64.slti in RISCV.Instructions

def main6_after := [llvm|
{
^0(%arg94 : i32):
  %0 = llvm.mlir.constant(55 : i32) : i32
  %1 = llvm.mlir.constant(19 : i32) : i32
  %2 = llvm.and %arg94, %0 : i32
  %3 = llvm.icmp "ne" %2, %1 : i32
  %4 = llvm.zext %3 : i1 to i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def test_after := [llvm|
{
^0(%arg0 : i26):
  "llvm.return"(%arg0) : (i26) -> ()
}
]

def n1_before := [llvm|
{
^0(%arg2 : i8, %arg3 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.mlir.constant(-1 : i8) : i8
  %2 = llvm.shl %0, %arg3 : i8
  %3 = llvm.xor %2, %1 : i8
  %4 = llvm.and %3, %arg2 : i8
  %5 = llvm.icmp "ne" %4, %arg2 : i8
  "llvm.return"(%5) : (i1) -> ()
}
]

def llvm_const_lower_riscv_li_19 : LLVMPeepholeRewriteRefine 64 [] :=
  {lhs := constLLVM_19, rhs:= liRiscv_19,
   correct := by admit /- proof elided -/

def eq_smax3_after := [llvm|
{
^0(%arg59 : i32, %arg60 : i32):
  %0 = llvm.mlir.constant(3 : i32) : i32
  %1 = llvm.add %arg59, %0 : i32
  %2 = llvm.icmp "sge" %1, %arg60 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def icmp_eq_mul_nsw_nonequal_commuted_before := [llvm|
{
^0(%arg30 : i8, %arg31 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.add %arg30, %0 : i8
  %2 = llvm.mul %arg30, %arg31 overflow<nsw> : i8
  %3 = llvm.mul %arg31, %1 overflow<nsw> : i8
  %4 = llvm.icmp "eq" %2, %3 : i8
  "llvm.return"(%4) : (i1) -> ()
}
]

def test19_after := [llvm|
{
^0(%arg7 : i10):
  %0 = llvm.mlir.constant(1 : i3) : i3
  %1 = llvm.mlir.constant(0 : i3) : i3
  %2 = llvm.trunc %arg7 : i10 to i3
  %3 = llvm.and %2, %0 : i3
  %4 = llvm.sub %1, %3 overflow<nsw> : i3
  %5 = llvm.sext %4 : i3 to i10
  "llvm.return"(%5) : (i10) -> ()
}
]

def ugt_sext_before := [llvm|
{
^0(%arg130 : i1, %arg131 : i8):
  %0 = llvm.sext %arg130 : i1 to i8
  %1 = llvm.icmp "ugt" %0, %arg131 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

Int in Init.Data.Int.Basic

def test7_before := [llvm|
{
^0(%arg7 : i47):
  %0 = llvm.mlir.constant(39 : i47) : i47
  %1 = llvm.mlir.constant(255 : i47) : i47
  %2 = llvm.ashr %arg7, %0 : i47
  %3 = llvm.and %2, %1 : i47
  "llvm.return"(%3) : (i47) -> ()
}
]

def Lets.repr (prec : Nat) : Lets d eff Γ t → Format
    | .nil => .align false ++ f!";"
    | .var body e => body.repr prec ++ (.align false ++ f!"{e.print}")

def main4b_logical_after := [llvm|
{
^0(%arg131 : i32):
  %0 = llvm.mlir.constant(23 : i32) : i32
  %1 = llvm.and %arg131, %0 : i32
  %2 = llvm.icmp "ne" %1, %0 : i32
  %3 = llvm.zext %2 : i1 to i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def toAIG {α : Type}
    [DecidableEq α] [Fintype α] [Hashable α]
    (c : Circuit α) : { entry : Entrypoint α // ∀ (env : α → Bool), AIG.denote env entry = c.eval env } :=
  let aig : AIG α := AIG.empty
  let val := c.toAIGAux aig
  let aig := val.out
  let ref := val.ref
  let outVal := ⟨aig, ref⟩
  ⟨outVal, by admit /- proof elided -/
  ⟩

def slt_and_not_max_commute_after := [llvm|
{
^0(%arg122 : i8, %arg123 : i8):
  %0 = llvm.icmp "slt" %arg122, %arg123 : i8
  "llvm.return"(%0) : (i1) -> ()
}
]

def negate_lowbitmask_after := [llvm|
{
^0(%arg48 : i8, %arg49 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.mlir.constant(0 : i8) : i8
  %2 = llvm.and %arg48, %0 : i8
  %3 = llvm.icmp "eq" %2, %1 : i8
  %4 = "llvm.select"(%3, %1, %arg49) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%4) : (i8) -> ()
}
]

def not_ashr_bitwidth_mask_before := [llvm|
{
^0(%arg105 : i8, %arg106 : i8):
  %0 = llvm.mlir.constant(7 : i8) : i8
  %1 = llvm.mlir.constant(-1 : i8) : i8
  %2 = llvm.ashr %arg105, %0 : i8
  %3 = llvm.xor %2, %1 : i8
  %4 = llvm.and %3, %arg106 : i8
  "llvm.return"(%4) : (i8) -> ()
}
]

def p_before := [llvm|
{
^0(%arg60 : i32, %arg61 : i32, %arg62 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.and %arg60, %arg62 : i32
  %2 = llvm.xor %arg62, %0 : i32
  %3 = llvm.and %2, %arg61 : i32
  %4 = llvm.add %1, %3 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def or_basic_before := [llvm|
{
^0(%arg15 : i16):
  %0 = llvm.mlir.constant(127 : i8) : i8
  %1 = llvm.mlir.constant(-256 : i16) : i16
  %2 = llvm.mlir.constant(17664 : i16) : i16
  %3 = llvm.trunc %arg15 : i16 to i8
  %4 = llvm.icmp "ne" %3, %0 : i8
  %5 = llvm.and %arg15, %1 : i16
  %6 = llvm.icmp "ne" %5, %2 : i16
  %7 = llvm.or %4, %6 : i1
  "llvm.return"(%7) : (i1) -> ()
}
]

def lshr_and_after := [llvm|
{
^0(%arg73 : i8, %arg74 : i8):
  %0 = llvm.mlir.constant(42 : i8) : i8
  %1 = llvm.mlir.constant(6 : i8) : i8
  %2 = llvm.srem %arg73, %0 : i8
  %3 = llvm.shl %2, %1 : i8
  %4 = llvm.and %arg74, %3 : i8
  "llvm.return"(%4) : (i8) -> ()
}
]

def or_xor_not_before := [llvm|
{
^0(%arg56 : i32, %arg57 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg57, %0 : i32
  %2 = llvm.xor %arg56, %1 : i32
  %3 = llvm.or %2, %arg57 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def regionParser : @ParseFun (MLIR.AST.Region 0) :=
  fun env : Lean.Environment => mkNonTerminalParser `mlir_region (elabRegion env) env

def ashr_slt_noexact_before := [llvm|
{
^0(%arg155 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.mlir.constant(10 : i8) : i8
  %2 = llvm.ashr %arg155, %0 : i8
  %3 = llvm.icmp "slt" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

@[simp_denote]
def add_hi_one_lo_negone_riscv_i64 :=
  [LV| {
    ^entry (%arg0: i64):
    %a = "builtin.unrealized_conversion_cast" (%arg0) : (i64) -> (!riscv.reg)
    %0 = li (0) : !riscv.reg
    %1= li (1) : !riscv.reg
    %2 = sub %0, %1 : !riscv.reg  
    %3 = srli %2, 31 : !riscv.reg
    %4 = add %3, %a : !riscv.reg
    %5 = "builtin.unrealized_conversion_cast" (%4) : (!riscv.reg) -> (i64)
    llvm.return %5 : i64
  }]

def trunc_ashr_trunc_outofrange_before := [llvm|
{
^0(%arg2 : i64):
  %0 = llvm.mlir.constant(25 : i32) : i32
  %1 = llvm.trunc %arg2 : i64 to i32
  %2 = llvm.ashr %1, %0 : i32
  %3 = llvm.trunc %2 : i32 to i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def alive_AndOrXor_1280_ABA___AB_src :=
[sllvm| {
^bb0(%A : i64, %B : i64):
  %v1 = llvm.mlir.constant -1 : i64
  %v2 = llvm.xor %A, %v1 : i64
  %v3 = llvm.or %v2, %B : i64
  %v4 = llvm.and %v3, %A : i64
  llvm.return %v4 : i64
}]

def positive_with_icmp_before := [llvm|
{
^0(%arg58 : i32):
  %0 = llvm.mlir.constant(512 : i32) : i32
  %1 = llvm.mlir.constant(128 : i32) : i32
  %2 = llvm.mlir.constant(256 : i32) : i32
  %3 = llvm.icmp "ult" %arg58, %0 : i32
  %4 = llvm.add %arg58, %1 : i32
  %5 = llvm.icmp "ult" %4, %2 : i32
  %6 = llvm.and %3, %5 : i1
  "llvm.return"(%6) : (i1) -> ()
}
]

instance h41 : (41 : ZMod q) = -1 := rfl

instance [SIG : DialectSignature d] [DENOTE : DialectDenote d] {Γ : Ctxt d.Ty} {t}
    (com : Com d Γ .pure t) : Inhabited (DCEType com) where
  default :=
    ⟨Γ, Hom.id, com, by admit /- proof elided -/
    ⟩

def size : FpPredicate → Nat
| .bin lhs _ rhs => 1 + lhs.size + rhs.size

def ashrslt_02_15_exact_after := [llvm|
{
^0(%arg22 : i4):
  %0 = llvm.mlir.constant(-4 : i4) : i4
  %1 = llvm.icmp "slt" %arg22, %0 : i4
  "llvm.return"(%1) : (i1) -> ()
}
]

def icmp_sge_riscv_eq_icmp_sge_llvm_32 : LLVMPeepholeRewriteRefine 1 [Ty.llvm (.bitvec 32), Ty.llvm (.bitvec 32)] :=
  {lhs:= icmp_sge_llvm_32, rhs:= icmp_sge_riscv_32}

def verbose_flag (fileName : String ) : IO UInt32 := do
      let icom? ← parseComFromFile fileName
      match icom? with
      | none => return 1
      | some (Sigma.mk _Γ icom) => do
      IO.println "Flag `
      IO.println s!"{repr icom}" 
      return 0

def udiv_i32_before := [llvm|
{
^0(%arg29 : i8, %arg30 : i8):
  %0 = llvm.zext %arg29 : i8 to i32
  %1 = llvm.zext %arg30 : i8 to i32
  %2 = llvm.udiv %0, %1 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def llvm_const_lower_riscv_li44 : LLVMPeepholeRewriteRefine 64 [] :=
  {lhs := constLLVM44, rhs:= liRiscv44,
   correct := by admit /- proof elided -/

def not_and_and_or_not_or_or_commute1_and_after := [llvm|
{
^0(%arg244 : i32, %arg245 : i32, %arg246 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg245, %arg246 : i32
  %2 = llvm.or %1, %arg244 : i32
  %3 = llvm.xor %2, %0 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def or_or_logic_and_1_after := [llvm|
{
^0(%arg12 : i1, %arg13 : i1, %arg14 : i1):
  %0 = llvm.mlir.constant(false) : i1
  %1 = "llvm.select"(%arg13, %arg14, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %2 = llvm.or %arg12, %1 : i1
  "llvm.return"(%2) : (i1) -> ()
}
]

def t0_before := [llvm|
{
^0(%arg206 : i8):
  %0 = llvm.mlir.constant(-42 : i8) : i8
  %1 = llvm.sub %arg206, %0 : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def icmp_mul_nsw_sgt_after := [llvm|
{
^0(%arg15 : i8, %arg16 : i8):
  %0 = llvm.icmp "sgt" %arg15, %arg16 : i8
  "llvm.return"(%0) : (i1) -> ()
}
]

def trunc_shl_7_i8_i64_after := [llvm|
{
^0(%arg37 : i64):
  %0 = llvm.mlir.constant(7 : i8) : i8
  %1 = llvm.trunc %arg37 : i64 to i8
  %2 = llvm.shl %1, %0 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def trunc_shl_7_i8_i64_before := [llvm|
{
^0(%arg52 : i64):
  %0 = llvm.mlir.constant(7) : i64
  %1 = llvm.shl %arg52, %0 : i64
  %2 = llvm.trunc %1 : i64 to i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def lshrult_03_05_exact_after := [llvm|
{
^0(%arg112 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def rewrite_patterns : List (Σ Γ, Σ ty, PeepholeRewrite DCPlus Γ ty) :=[
  mkRewrite rewrite_a_T,
  mkRewrite rewrite_a_F,
  mkRewrite rewrite_c_A,
  mkRewrite rewrite_c_B,
  mkRewrite rewrite_h_A,
  mkRewrite rewrite_h_B,
  mkRewrite rewrite_g,
  mkRewrite rewrite_e,
]

def shrink_or_after := [llvm|
{
^0(%arg11 : i6):
  %0 = llvm.mlir.constant(1 : i3) : i3
  %1 = llvm.trunc %arg11 : i6 to i3
  %2 = llvm.or %1, %0 : i3
  "llvm.return"(%2) : (i3) -> ()
}
]

def ne_irregular_bit_widths_before := [llvm|
{
^0(%arg62 : i31, %arg63 : i31):
  %0 = llvm.mlir.constant(7 : i31) : i31
  %1 = llvm.mlir.constant(13 : i31) : i31
  %2 = llvm.lshr %arg62, %0 : i31
  %3 = llvm.trunc %2 : i31 to i6
  %4 = llvm.lshr %arg62, %1 : i31
  %5 = llvm.trunc %4 : i31 to i5
  %6 = llvm.lshr %arg63, %0 : i31
  %7 = llvm.trunc %6 : i31 to i6
  %8 = llvm.lshr %arg63, %1 : i31
  %9 = llvm.trunc %8 : i31 to i5
  %10 = llvm.icmp "ne" %3, %7 : i6
  %11 = llvm.icmp "ne" %5, %9 : i5
  %12 = llvm.or %11, %10 : i1
  "llvm.return"(%12) : (i1) -> ()
}
]

def select_icmp_x_and_8_eq_0_y_xor_8_before := [llvm|
{
^0(%arg179 : i32, %arg180 : i64):
  %0 = llvm.mlir.constant(8 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(8) : i64
  %3 = llvm.and %arg179, %0 : i32
  %4 = llvm.icmp "eq" %3, %1 : i32
  %5 = llvm.xor %arg180, %2 : i64
  %6 = "llvm.select"(%4, %arg180, %5) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i64, i64) -> i64
  "llvm.return"(%6) : (i64) -> ()
}
]

Nonempty in Init.Prelude

Lean.findSysroot in Lean.Util.Path

def or_xor_xor_normal_binops_before := [llvm|
{
^0(%arg8 : i32, %arg9 : i32, %arg10 : i32):
  %0 = llvm.xor %arg8, %arg10 : i32
  %1 = llvm.xor %arg9, %arg10 : i32
  %2 = llvm.and %1, %0 : i32
  %3 = llvm.xor %1, %2 : i32
  %4 = llvm.xor %0, %2 : i32
  %5 = llvm.or %3, %4 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def PR42691_3_logical_after := [llvm|
{
^0(%arg338 : i32):
  %0 = llvm.mlir.constant(-2147483647 : i32) : i32
  %1 = llvm.icmp "ult" %arg338, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

Lean.Core.State in Lean.CoreM

def select2_after := [llvm|
{
^0(%arg9 : i1, %arg10 : i8, %arg11 : i8, %arg12 : i8):
  %0 = llvm.add %arg10, %arg11 : i8
  %1 = "llvm.select"(%arg9, %arg12, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%1) : (i8) -> ()
}
]

private def test_li := [RV64_com| {
 ^bb0(%e1 : !i64):
 %1 = li (42) : !i64
 %2 = li (42) : !i64
      ret %1 : !i64
}]

def and_or2_wrong_operand_after := [llvm|
{
^0(%arg172 : i1, %arg173 : i1, %arg174 : i1, %arg175 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.xor %arg174, %0 : i1
  %2 = llvm.and %arg173, %1 : i1
  %3 = "llvm.select"(%2, %arg172, %arg175) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def test86_after := [llvm|
{
^0(%arg59 : i16):
  %0 = llvm.mlir.constant(4 : i16) : i16
  %1 = llvm.ashr %arg59, %0 : i16
  "llvm.return"(%1) : (i16) -> ()
}
]

def fold_sext_to_and_wrong7_before := [llvm|
{
^0(%arg3 : i8):
  %0 = llvm.mlir.constant(-2147483647 : i32) : i32
  %1 = llvm.mlir.constant(128 : i32) : i32
  %2 = llvm.sext %arg3 : i8 to i32
  %3 = llvm.and %2, %0 : i32
  %4 = llvm.icmp "ne" %3, %1 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def test1_before := [llvm|
{
^0(%arg26 : i23):
  %0 = llvm.sub %arg26, %arg26 : i23
  "llvm.return"(%0) : (i23) -> ()
}
]

def or_simplify_ult_before := [llvm|
{
^0(%arg9 : i8, %arg10 : i8):
  %0 = llvm.mlir.constant(36 : i8) : i8
  %1 = llvm.mlir.constant(-5 : i8) : i8
  %2 = llvm.or %arg9, %0 : i8
  %3 = llvm.and %arg10, %1 : i8
  %4 = llvm.or %2, %3 : i8
  %5 = llvm.icmp "ult" %3, %4 : i8
  "llvm.return"(%5) : (i1) -> ()
}
]

def main12_after := [llvm|
{
^0(%arg20 : i32):
  %0 = llvm.mlir.constant(32896 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.mlir.constant(2 : i32) : i32
  %4 = llvm.and %arg20, %0 : i32
  %5 = llvm.icmp "eq" %4, %1 : i32
  %6 = "llvm.select"(%5, %2, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def or_xor_commute4_before := [llvm|
{
^0(%arg160 : i32, %arg161 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.udiv %0, %arg160 : i32
  %2 = llvm.udiv %0, %arg161 : i32
  %3 = llvm.or %1, %2 : i32
  %4 = llvm.xor %2, %3 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def ne_irregular_bit_widths_after := [llvm|
{
^0(%arg62 : i31, %arg63 : i31):
  %0 = llvm.mlir.constant(7 : i31) : i31
  %1 = llvm.lshr %arg62, %0 : i31
  %2 = llvm.trunc %1 : i31 to i11
  %3 = llvm.lshr %arg63, %0 : i31
  %4 = llvm.trunc %3 : i31 to i11
  %5 = llvm.icmp "ne" %2, %4 : i11
  "llvm.return"(%5) : (i1) -> ()
}
]

def XorAndAnd : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64), Ty.llvm (.bitvec 64), Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%x: i64, %y: i64, %z: i64):
      %0 = llvm.and %x, %z : i64
      %1 = llvm.and %y, %z : i64
      %2 = llvm.xor %0, %1 : i64
      llvm.return %2 : i64
  }]
  rhs := [LV| {
    ^entry (%x: i64, %y: i64, %z: i64):
      %0 = llvm.xor %x, %y : i64
      %1 = llvm.and %0, %z : i64
      llvm.return %1 : i64
  }]

def select_riscv_select_llvm_32 : LLVMPeepholeRewriteRefine 32
  [Ty.llvm (.bitvec 32), Ty.llvm (.bitvec 32), Ty.llvm (.bitvec 1)] where
  lhs := select_llvm_32
  rhs := select_riscv_32

def test_before := [llvm|
{
^0(%arg0 : i1):
  %0 = llvm.mlir.constant(false) : i1
  %1 = llvm.icmp "ult" %arg0, %0 : i1
  "llvm.return"(%1) : (i1) -> ()
}
]

def or_xor_tree_0001_after := [llvm|
{
^0(%arg42 : i32, %arg43 : i32, %arg44 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mul %arg42, %0 : i32
  %2 = llvm.mul %arg43, %0 : i32
  %3 = llvm.mul %arg44, %0 : i32
  %4 = llvm.xor %2, %1 : i32
  %5 = llvm.or %4, %3 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def src_is_mask_xor_after := [llvm|
{
^0(%arg115 : i8, %arg116 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.mlir.constant(123 : i8) : i8
  %2 = llvm.add %arg116, %0 : i8
  %3 = llvm.xor %arg116, %2 : i8
  %4 = llvm.xor %arg115, %1 : i8
  %5 = llvm.icmp "ugt" %4, %3 : i8
  "llvm.return"(%5) : (i1) -> ()
}
]

def test_after := [llvm|
{
  %0 = llvm.mlir.constant(0 : i32) : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

def ashrsgt_01_11_exact_before := [llvm|
{
^0(%arg90 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(-5 : i4) : i4
  %2 = llvm.ashr exact %arg90, %0 : i4
  %3 = llvm.icmp "sgt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def n0_before := [llvm|
{
^0(%arg9 : i8, %arg10 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.mlir.constant(-1 : i8) : i8
  %2 = llvm.shl %0, %arg10 : i8
  %3 = llvm.xor %2, %1 : i8
  %4 = llvm.icmp "uge" %3, %arg9 : i8
  "llvm.return"(%4) : (i1) -> ()
}
]

def land_lor_right1_before := [llvm|
{
^0(%arg46 : i1, %arg47 : i1):
  %0 = llvm.mlir.constant(false) : i1
  %1 = llvm.mlir.constant(true) : i1
  %2 = "llvm.select"(%arg46, %arg47, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %3 = "llvm.select"(%arg46, %1, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def sdiv_mul_shl_nsw_exact_commute1_before := [llvm|
{
^0(%arg190 : i5, %arg191 : i5, %arg192 : i5):
  %0 = llvm.mul %arg191, %arg190 overflow<nsw> : i5
  %1 = llvm.shl %arg190, %arg192 overflow<nsw> : i5
  %2 = llvm.sdiv exact %0, %1 : i5
  "llvm.return"(%2) : (i5) -> ()
}
]

def mul_add_to_mul_8_before := [llvm|
{
^0(%arg24 : i16):
  %0 = llvm.mlir.constant(16383 : i16) : i16
  %1 = llvm.mlir.constant(16384 : i16) : i16
  %2 = llvm.mul %arg24, %0 overflow<nsw> : i16
  %3 = llvm.mul %arg24, %1 overflow<nsw> : i16
  %4 = llvm.add %2, %3 overflow<nsw> : i16
  "llvm.return"(%4) : (i16) -> ()
}
]

def test3_after := [llvm|
{
^0(%arg207 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

Polynomial.natDegree in Mathlib.Algebra.Polynomial.Degree.Definitions

def test_or_ne_a_b_before := [llvm|
{
^0(%arg15 : i1, %arg16 : i8, %arg17 : i8):
  %0 = llvm.icmp "ne" %arg16, %arg17 : i8
  %1 = llvm.or %arg15, %0 : i1
  %2 = "llvm.select"(%1, %arg16, %arg17) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def pr33078_1_before := [llvm|
{
^0(%arg5 : i8):
  %0 = llvm.mlir.constant(8 : i16) : i16
  %1 = llvm.sext %arg5 : i8 to i16
  %2 = llvm.lshr %1, %0 : i16
  %3 = llvm.trunc %2 : i16 to i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def src_srem_shl_demand_min_signbit_mask_hit_last_demand_after := [llvm|
{
^0(%arg20 : i32):
  %0 = llvm.mlir.constant(536870912 : i32) : i32
  %1 = llvm.mlir.constant(1 : i32) : i32
  %2 = llvm.mlir.constant(-1073741822 : i32) : i32
  %3 = llvm.srem %arg20, %0 : i32
  %4 = llvm.shl %3, %1 overflow<nsw> : i32
  %5 = llvm.and %4, %2 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def test1_before := [llvm|
{
^0(%arg104 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.srem %arg104, %0 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def demorgan_nand_before := [llvm|
{
^0(%arg38 : i8, %arg39 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.xor %arg38, %0 : i8
  %2 = llvm.and %1, %arg39 : i8
  %3 = llvm.xor %2, %0 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

Lean.Name.mkSimple in Init.Prelude

def test15a_after := [llvm|
{
^0(%arg27 : i32):
  %0 = llvm.mlir.constant(16 : i32) : i32
  %1 = llvm.and %arg27, %0 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def demorgan_plus_and_to_xor_after := [llvm|
{
^0(%arg4 : i32, %arg5 : i32):
  %0 = llvm.xor %arg5, %arg4 : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

def xor_or_xor_common_op_commute8_before := [llvm|
{
^0(%arg59 : i32, %arg60 : i32, %arg61 : i32):
  %0 = llvm.xor %arg61, %arg59 : i32
  %1 = llvm.or %arg60, %arg59 : i32
  %2 = llvm.xor %1, %0 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def test15_after := [llvm|
{
^0(%arg6 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(8 : i32) : i32
  %2 = llvm.ashr %arg6, %0 : i32
  %3 = llvm.sub %1, %2 overflow<nsw> : i32
  %4 = llvm.sext %3 : i32 to i64
  "llvm.return"(%4) : (i64) -> ()
}
]

def n6_after := [llvm|
{
^0(%arg6 : i8, %arg7 : i8, %arg8 : i8):
  "llvm.return"(%arg8) : (i8) -> ()
}
]

def xor_logic_and_logic_or2_before := [llvm|
{
^0(%arg51 : i1, %arg52 : i1, %arg53 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.mlir.constant(false) : i1
  %2 = "llvm.select"(%arg53, %0, %arg51) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %3 = "llvm.select"(%arg51, %arg52, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %4 = llvm.xor %3, %2 : i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def ashr_ule_exact_before := [llvm|
{
^0(%arg168 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.mlir.constant(10 : i8) : i8
  %2 = llvm.ashr exact %arg168, %0 : i8
  %3 = llvm.icmp "ule" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def xor_or_xor_common_op_commute6_before := [llvm|
{
^0(%arg65 : i32, %arg66 : i32, %arg67 : i32):
  %0 = llvm.xor %arg67, %arg65 : i32
  %1 = llvm.or %arg65, %arg66 : i32
  %2 = llvm.xor %1, %0 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def masked_icmps_mask_notallzeros_bmask_mixed_negated_6_after := [llvm|
{
^0(%arg58 : i32):
  %0 = llvm.mlir.constant(15 : i32) : i32
  %1 = llvm.mlir.constant(8 : i32) : i32
  %2 = llvm.and %arg58, %0 : i32
  %3 = llvm.icmp "ne" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def uge_and_max_commute_before := [llvm|
{
^0(%arg234 : i8, %arg235 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.icmp "uge" %arg234, %arg235 : i8
  %2 = llvm.icmp "eq" %arg234, %0 : i8
  %3 = llvm.and %2, %1 : i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def llvm_mul_lower_riscv_nsw_flag_32 : LLVMPeepholeRewriteRefine 32 [Ty.llvm (.bitvec 32), Ty.llvm (.bitvec 32)] where
  lhs := mul_llvm_nsw_32
  rhs := mul_riscv_32

def negate_add_with_single_negatible_operand_depth2_after := [llvm|
{
^0(%arg21 : i8, %arg22 : i8):
  %0 = llvm.mlir.constant(-21 : i8) : i8
  %1 = llvm.sub %0, %arg21 : i8
  %2 = llvm.mul %1, %arg22 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def test_ne_before := [llvm|
{
^0(%arg9 : i32):
  %0 = llvm.mlir.constant(1073741823 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(2 : i32) : i32
  %3 = llvm.and %arg9, %0 : i32
  %4 = llvm.icmp "ne" %3, %1 : i32
  %5 = llvm.shl %arg9, %2 : i32
  %6 = "llvm.select"(%4, %5, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%6) : (i32) -> ()
}
]

Id.run in Init.Control.Id

def ashr_ult_7_after := [llvm|
{
^0(%arg89 : i4):
  %0 = llvm.mlir.constant(-1 : i4) : i4
  %1 = llvm.icmp "sgt" %arg89, %0 : i4
  "llvm.return"(%1) : (i1) -> ()
}
]

One in Init.Prelude

def t0_before := [llvm|
{
^0(%arg32 : i8, %arg33 : i1):
  %0 = llvm.sext %arg33 : i1 to i8
  %1 = llvm.add %0, %arg32 : i8
  %2 = llvm.xor %1, %0 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def zext_nneg_sext_sle_op0_narrow_before := [llvm|
{
^0(%arg50 : i8, %arg51 : i16):
  %0 = llvm.zext nneg %arg50 : i8 to i32
  %1 = llvm.sext %arg51 : i16 to i32
  %2 = llvm.icmp "sle" %0, %1 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def scalar_i32_shl_ult_const_before := [llvm|
{
^0(%arg15 : i32):
  %0 = llvm.mlir.constant(11 : i32) : i32
  %1 = llvm.mlir.constant(131072 : i32) : i32
  %2 = llvm.shl %arg15, %0 : i32
  %3 = llvm.icmp "ult" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def sub_not_after := [llvm|
{
^0(%arg22 : i8, %arg23 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.xor %arg22, %0 : i8
  %2 = llvm.add %arg23, %1 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def test2_before := [llvm|
{
^0(%arg0 : i23, %arg1 : i23, %arg2 : i23):
  %0 = llvm.and %arg1, %arg0 : i23
  %1 = llvm.or %arg1, %arg0 : i23
  %2 = llvm.xor %0, %1 : i23
  "llvm.return"(%2) : (i23) -> ()
}
]

elab "[Comb_com| " reg:mlir_region "]" : term => do
  SSA.elabIntoCom' reg Comb

def n1_after := [llvm|
{
^0(%arg2 : i8, %arg3 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.mlir.constant(0 : i8) : i8
  %2 = llvm.shl %0, %arg3 overflow<nuw> : i8
  %3 = llvm.and %arg2, %2 : i8
  %4 = llvm.icmp "eq" %3, %1 : i8
  "llvm.return"(%4) : (i1) -> ()
}
]

def add_and_or_after := [llvm|
{
^0(%arg15 : i32, %arg16 : i32):
  %0 = llvm.add %arg15, %arg16 : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

def test_mul_nuw__nsw_is_safe_before := [llvm|
{
^0(%arg6 : i32):
  %0 = llvm.mlir.constant(-83886080 : i32) : i32
  %1 = llvm.mlir.constant(-83886079 : i32) : i32
  %2 = llvm.mlir.constant(9 : i32) : i32
  %3 = llvm.mlir.constant(-754974711 : i32) : i32
  %4 = llvm.or %arg6, %0 : i32
  %5 = llvm.icmp "eq" %4, %1 : i32
  %6 = llvm.mul %4, %2 overflow<nuw> : i32
  %7 = "llvm.select"(%5, %3, %6) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%7) : (i32) -> ()
}
]

def test9_after := [llvm|
{
^0(%arg72 : i32):
  %0 = llvm.mlir.constant(42 : i8) : i8
  %1 = llvm.trunc %arg72 : i32 to i8
  %2 = llvm.and %1, %0 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def negative4_before := [llvm|
{
^0(%arg6 : i32, %arg7 : i32):
  %0 = llvm.mlir.constant(2147483647 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.and %arg7, %0 : i32
  %3 = llvm.icmp "ne" %arg6, %2 : i32
  %4 = llvm.icmp "sge" %arg6, %1 : i32
  %5 = llvm.and %3, %4 : i1
  "llvm.return"(%5) : (i1) -> ()
}
]

def elabDefSignatureFor (dialect : Term) (alts : TSyntax ``matchAltsSig) : CommandElabM Unit := do
  let msg := (return m!"{exceptEmoji ·} Defining operation signature for {dialect} dialect")
  withTraceNode `LeanMLIR.Elab msg (collapsed := false) <| do
    let alts := getMatchAlts alts
    let alts ← do
      alts.mapM fun view => do
        trace[LeanMLIR.Elab] m!"Parsing match alternative with\n\
          \tpatterns: {view.patterns}\n\
          \tsignature: {view.rhs}"
        let rhs ← parseSignature view.rhs
        return { view with rhs }

    |

def mul_select_zext_after := [llvm|
{
^0(%arg18 : i1, %arg19 : i64):
  %0 = llvm.mlir.constant(0) : i64
  %1 = "llvm.select"(%arg18, %arg19, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i64, i64) -> i64
  "llvm.return"(%1) : (i64) -> ()
}
]

def subMax' (a : BitVec o) (wmask : BitVec o) (b : BitVec o) (vmask : BitVec o) : BitVec o :=
    (a - b)  

def sgt_and_min_after := [llvm|
{
^0(%arg352 : i9, %arg353 : i9):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def pv_before := [llvm|
{
^0(%arg14 : i8, %arg15 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.lshr %0, %arg15 : i8
  %2 = llvm.and %1, %arg14 : i8
  %3 = llvm.icmp "uge" %2, %arg14 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def invert_both_cmp_operands_complex_before := [llvm|
{
^0(%arg32 : i1, %arg33 : i32, %arg34 : i32, %arg35 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg33, %0 : i32
  %2 = llvm.xor %arg34, %0 : i32
  %3 = llvm.xor %arg35, %0 : i32
  %4 = llvm.add %arg35, %1 : i32
  %5 = "llvm.select"(%arg32, %4, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %6 = llvm.icmp "sle" %5, %3 : i32
  "llvm.return"(%6) : (i1) -> ()
}
]

def icmp' {w : Nat} (c : IntPred) (x y : BitVec w) : Bool :=
  match c with
    | .eq => (x == y)
    | .ne => (x != y)
    | .sgt => (x >ₛ y)
    | .sge => (x ≥ₛ y)
    | .slt => (x <ₛ y)
    | .sle => (x ≤ₛ y)
    | .ugt => (x >ᵤ y)
    | .uge => (x ≥ᵤ y)
    | .ult => (x <ᵤ y)
    | .ule => (x ≤ᵤ y)

def test35_before := [llvm|
{
^0(%arg50 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.mlir.constant(60 : i32) : i32
  %2 = llvm.mlir.constant(100 : i32) : i32
  %3 = llvm.icmp "sge" %arg50, %0 : i32
  %4 = "llvm.select"(%3, %1, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def ashrsgt_02_09_exact_after := [llvm|
{
^0(%arg76 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def test_shift_and_cmp_changed4_after := [llvm|
{
^0(%arg0 : i8):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def add {w : Nat} (x y : IntW w) (flags : NoWrapFlags := {nsw := false , nuw := false}) : IntW w := do
  let x' ← x
  let y' ← y
  if flags.nsw ∧ BitVec.saddOverflow x' y' then
    .poison
  else if flags.nuw ∧ BitVec.uaddOverflow x' y' then
    .poison
  else
    add? x' y'

def PR42691_8_logical_after := [llvm|
{
^0(%arg328 : i32):
  %0 = llvm.mlir.constant(2147483647 : i32) : i32
  %1 = llvm.mlir.constant(-2147483635 : i32) : i32
  %2 = llvm.add %arg328, %0 : i32
  %3 = llvm.icmp "ult" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

private def attrVal5bint: AttrVal := [mlir_attr_val| -42 ]

def shift_trunc_wrong_cmp_after := [llvm|
{
^0(%arg0 : i32):
  %0 = llvm.mlir.constant(24 : i32) : i32
  %1 = llvm.mlir.constant(1 : i8) : i8
  %2 = llvm.lshr %arg0, %0 : i32
  %3 = llvm.trunc %2 overflow<nuw> : i32 to i8
  %4 = llvm.icmp "slt" %3, %1 : i8
  "llvm.return"(%4) : (i1) -> ()
}
]

def scalar_i8_shl_ult_const_2_before := [llvm|
{
^0(%arg18 : i8):
  %0 = llvm.mlir.constant(6 : i8) : i8
  %1 = llvm.mlir.constant(64 : i8) : i8
  %2 = llvm.shl %arg18, %0 : i8
  %3 = llvm.icmp "ult" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def positive_sameconst_before := [llvm|
{
^0(%arg35 : i32):
  %0 = llvm.mlir.constant(5 : i32) : i32
  %1 = llvm.shl %arg35, %0 : i32
  %2 = llvm.lshr %1, %0 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def sdiv_exact_eq_9_no_of_before := [llvm|
{
^0(%arg8 : i8, %arg9 : i8):
  %0 = llvm.mlir.constant(7 : i8) : i8
  %1 = llvm.mlir.constant(9 : i8) : i8
  %2 = llvm.and %arg9, %0 : i8
  %3 = llvm.sdiv exact %arg8, %2 : i8
  %4 = llvm.icmp "eq" %3, %1 : i8
  "llvm.return"(%4) : (i1) -> ()
}
]

def sgt_swap_and_min_commute_after := [llvm|
{
^0(%arg340 : i8, %arg341 : i8):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def t9_c0_c2_before := [llvm|
{
^0(%arg13 : i8, %arg14 : i8):
  %0 = llvm.mlir.constant(42 : i8) : i8
  %1 = llvm.mlir.constant(24 : i8) : i8
  %2 = llvm.sub %0, %arg13 : i8
  %3 = llvm.sub %2, %1 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def test11_before := [llvm|
{
^0(%arg48 : i32, %arg49 : i32):
  %0 = llvm.mlir.constant(-1431655766 : i32) : i32
  %1 = llvm.mlir.constant(1431655765 : i32) : i32
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.or %arg48, %0 : i32
  %4 = llvm.xor %3, %1 : i32
  %5 = llvm.add %arg49, %2 : i32
  %6 = llvm.add %5, %4 : i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def lshrult_03_12_before := [llvm|
{
^0(%arg323 : i4):
  %0 = llvm.mlir.constant(3 : i4) : i4
  %1 = llvm.mlir.constant(-4 : i4) : i4
  %2 = llvm.lshr %arg323, %0 : i4
  %3 = llvm.icmp "ult" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def negate_lshr_after := [llvm|
{
^0(%arg108 : i8, %arg109 : i8):
  %0 = llvm.mlir.constant(7 : i8) : i8
  %1 = llvm.ashr %arg109, %0 : i8
  %2 = llvm.add %1, %arg108 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def not_and_and_or_no_or_commute2_and_before := [llvm|
{
^0(%arg157 : i32, %arg158 : i32, %arg159 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.or %arg158, %arg157 : i32
  %2 = llvm.xor %1, %0 : i32
  %3 = llvm.xor %arg157, %0 : i32
  %4 = llvm.and %3, %arg159 : i32
  %5 = llvm.and %4, %arg158 : i32
  %6 = llvm.or %5, %2 : i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def t2_after := [llvm|
{
^0(%arg15 : i7):
  %0 = llvm.mlir.constant(3 : i7) : i7
  %1 = llvm.ashr %arg15, %0 : i7
  %2 = llvm.sext %1 : i7 to i16
  "llvm.return"(%2) : (i16) -> ()
}
]

def test34_after := [llvm|
{
^0(%arg248 : i32, %arg249 : i32):
  "llvm.return"(%arg249) : (i32) -> ()
}
]

def slt_swap_and_not_max_logical_before := [llvm|
{
^0(%arg116 : i8, %arg117 : i8):
  %0 = llvm.mlir.constant(127 : i8) : i8
  %1 = llvm.mlir.constant(false) : i1
  %2 = llvm.icmp "sgt" %arg117, %arg116 : i8
  %3 = llvm.icmp "ne" %arg116, %0 : i8
  %4 = "llvm.select"(%2, %3, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def is_ascii_alphabetic_after := [llvm|
{
^0(%arg248 : i32):
  %0 = llvm.mlir.constant(-33 : i32) : i32
  %1 = llvm.mlir.constant(-65 : i32) : i32
  %2 = llvm.mlir.constant(26 : i32) : i32
  %3 = llvm.and %arg248, %0 : i32
  %4 = llvm.add %3, %1 : i32
  %5 = llvm.icmp "ult" %4, %2 : i32
  "llvm.return"(%5) : (i1) -> ()
}
]

def ashrsgt_03_07_after := [llvm|
{
^0(%arg278 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def BinaryRelationKind.toSmtLib : BinaryRelationKind → SexprPBV.BinaryRelationKind
| .eq => .eq
| .ne => .ne
| .ule => .ule
| .slt => .slt
| .sle => .sle
| .ult => .ult

def reduce_xor_common_op_commute0_before := [llvm|
{
^0(%arg10 : i4, %arg11 : i4, %arg12 : i4):
  %0 = llvm.xor %arg10, %arg11 : i4
  %1 = llvm.xor %0, %arg12 : i4
  %2 = llvm.or %1, %arg10 : i4
  "llvm.return"(%2) : (i4) -> ()
}
]

def n2_after := [llvm|
{
^0(%arg0 : i8, %arg1 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.mlir.constant(-2 : i8) : i8
  %2 = llvm.mlir.constant(0 : i8) : i8
  %3 = llvm.shl %0, %arg1 overflow<nsw> : i8
  %4 = llvm.xor %3, %1 : i8
  %5 = llvm.and %arg0, %4 : i8
  %6 = llvm.icmp "ne" %5, %2 : i8
  "llvm.return"(%6) : (i1) -> ()
}
]

def cast (h_eq : ty₁ = ty₂) : Γ.Var ty₁ → Γ.Var ty₂
  | ⟨i, h⟩ => ⟨i, h_eq ▸ h⟩

@[combinator_parenthesizer MLIR.EDSL.balancedBrackets]
def MLIR.EDSL.balancedBracketsParenthesizer : Parenthesizer := pure ()

def ashrsgt_01_15_before := [llvm|
{
^0(%arg302 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(-1 : i4) : i4
  %2 = llvm.ashr %arg302, %0 : i4
  %3 = llvm.icmp "sgt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def not_and_and_or_not_or_or_commute2_or_before := [llvm|
{
^0(%arg247 : i32, %arg248 : i32, %arg249 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.or %arg248, %arg249 : i32
  %2 = llvm.or %1, %arg247 : i32
  %3 = llvm.xor %2, %0 : i32
  %4 = llvm.xor %arg247, %0 : i32
  %5 = llvm.and %4, %arg248 : i32
  %6 = llvm.and %5, %arg249 : i32
  %7 = llvm.or %6, %3 : i32
  "llvm.return"(%7) : (i32) -> ()
}
]

def test59_before := [llvm|
{
^0(%arg122 : i8, %arg123 : i8):
  %0 = llvm.mlir.constant(4 : i32) : i32
  %1 = llvm.mlir.constant(48 : i32) : i32
  %2 = llvm.zext %arg122 : i8 to i32
  %3 = llvm.shl %2, %0 : i32
  %4 = llvm.and %3, %1 : i32
  %5 = llvm.zext %arg123 : i8 to i32
  %6 = llvm.lshr %5, %0 : i32
  %7 = llvm.or %6, %4 : i32
  %8 = llvm.zext %7 : i32 to i64
  "llvm.return"(%8) : (i64) -> ()
}
]

def test15_after := [llvm|
{
^0(%arg44 : i8, %arg45 : i8):
  %0 = llvm.mlir.constant(33 : i8) : i8
  %1 = llvm.xor %arg45, %arg44 : i8
  %2 = llvm.xor %arg44, %arg45 : i8
  %3 = llvm.xor %2, %0 : i8
  %4 = llvm.and %1, %3 : i8
  %5 = llvm.mul %4, %3 : i8
  "llvm.return"(%5) : (i8) -> ()
}
]

def lshrugt_01_13_exact_after := [llvm|
{
^0(%arg208 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def or_xor_not_after := [llvm|
{
^0(%arg56 : i32, %arg57 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg56, %0 : i32
  %2 = llvm.or %arg57, %1 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def not_mul_of_pow2_before := [llvm|
{
^0(%arg77 : i32, %arg78 : i8):
  %0 = llvm.mlir.constant(6 : i32) : i32
  %1 = llvm.mlir.constant(1530 : i32) : i32
  %2 = llvm.and %arg77, %0 : i32
  %3 = llvm.zext %arg78 : i8 to i32
  %4 = llvm.mul %2, %3 : i32
  %5 = llvm.icmp "ugt" %4, %1 : i32
  "llvm.return"(%5) : (i1) -> ()
}
]

def masked_or_allzeroes_notoptimised_logical_before := [llvm|
{
^0(%arg116 : i32):
  %0 = llvm.mlir.constant(15 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(39 : i32) : i32
  %3 = llvm.mlir.constant(true) : i1
  %4 = llvm.and %arg116, %0 : i32
  %5 = llvm.icmp "eq" %4, %1 : i32
  %6 = llvm.and %arg116, %2 : i32
  %7 = llvm.icmp "eq" %6, %1 : i32
  %8 = "llvm.select"(%5, %3, %7) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%8) : (i1) -> ()
}
]

def TermBinop.termGadget (t : TermBinop) : CNFA 3 :=
  match t with
  | .and => FSM.ofTerm (.and (.var 0) (.var 1)) |> CNFA.ofFSM
  | .or => FSM.ofTerm (.or (.var 0) (.var 1)) |> CNFA.ofFSM
  | .xor => FSM.ofTerm (.xor (.var 0) (.var 1)) |> CNFA.ofFSM
  | .add => FSM.ofTerm (.add (.var 0) (.var 1)) |> CNFA.ofFSM
  | .sub => FSM.ofTerm (.sub (.var 0) (.var 1)) |> CNFA.ofFSM

@[simp_denote]
def sdiv_riscv_32 := [LV| {
  ^entry (%reg1: i32, %reg2: i32):
    %0 = "builtin.unrealized_conversion_cast"(%reg1) : (i32) -> (!i64)
    %1 = "builtin.unrealized_conversion_cast"(%reg2) : (i32) -> (!i64)
    %2 = div %0, %1 : !i64
    %3 = "builtin.unrealized_conversion_cast"(%2) : (!i64) -> (i32)
    llvm.return %3 : i32
  }]

structure GlobalState where
  alloc : AllocState
  mem : MemoryState

def sdiv_exact_ne_1_after := [llvm|
{
^0(%arg12 : i8, %arg13 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.icmp "eq" %arg12, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

instance : Hashable (FpExpr e) where
  hash expr := expr.hashCode

def t2_symmetry_before := [llvm|
{
^0(%arg25 : i8, %arg26 : i8):
  %0 = llvm.add %arg25, %arg26 : i8
  %1 = llvm.icmp "ult" %0, %arg25 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def RawCNFA.addFinal (m : RawCNFA A) (s : State) : RawCNFA A :=
  { m with finals := m.finals.insert s }

def rem_euclid_pow2_false_arm_folded_before := [llvm|
{
^0(%arg2 : i32):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.srem %arg2, %0 : i32
  %4 = llvm.icmp "sge" %3, %1 : i32
  %5 = "llvm.select"(%4, %3, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def ConcreteCliTest.printSignature (test : ConcreteCliTest) : String :=
  s!"{test.context.toList.reverse} → {test.ty}"

def test18_before := [llvm|
{
^0(%arg152 : i8, %arg153 : i8):
  %0 = llvm.mlir.constant(33 : i8) : i8
  %1 = llvm.xor %arg153, %arg152 : i8
  %2 = llvm.xor %arg152, %0 : i8
  %3 = llvm.xor %2, %arg153 : i8
  %4 = llvm.or %3, %1 : i8
  %5 = llvm.mul %4, %3 : i8
  "llvm.return"(%5) : (i8) -> ()
}
]

def positive_biggerlshr_shlnuwnsw_lshrexact_before := [llvm|
{
^0(%arg25 : i8):
  %0 = llvm.mlir.constant(6 : i8) : i8
  %1 = llvm.mlir.constant(3 : i8) : i8
  %2 = llvm.lshr exact %arg25, %0 : i8
  %3 = llvm.shl %2, %1 overflow<nsw,nuw> : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def bool_eq0_logical_before := [llvm|
{
^0(%arg32 : i64):
  %0 = llvm.mlir.constant(0) : i64
  %1 = llvm.mlir.constant(1) : i64
  %2 = llvm.mlir.constant(false) : i1
  %3 = llvm.icmp "sgt" %arg32, %0 : i64
  %4 = llvm.icmp "eq" %arg32, %1 : i64
  %5 = llvm.icmp "eq" %4, %2 : i1
  %6 = "llvm.select"(%3, %5, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%6) : (i1) -> ()
}
]

def shl_nsw_nuw_ult_Csle0_after := [llvm|
{
^0(%arg14 : i8, %arg15 : i8):
  %0 = llvm.mlir.constant(-19 : i8) : i8
  %1 = llvm.icmp "ult" %arg14, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def mkReturn (Γ : Ctxt _) (opStx : MLIR.AST.Op 0) : MLIR.AST.ReaderM LLVMPlusRiscV
  (Σ eff ty, Com LLVMPlusRiscV Γ eff ty) := do
  let llvmParseReturn := InstcombineTransformDialect.mkReturn (ctxtTransformToLLVM  Γ) opStx (← read)
  match llvmParseReturn with
  | .ok ⟨eff, ty, Com.rets vs⟩ =>
    let vs : HVector Γ.Var (.llvm <$> ty) ←
      vs.mapM' (fun _ => transformVarLLVM)
    return ⟨eff, .llvm <$> ty, Com.rets vs⟩
  | .error e =>
    match e with
    | .unsupportedOp _s=>
      let ⟨eff, ty , com⟩ ← RiscvMkExpr.mkReturn (ctxtTransformToRiscV Γ) opStx (← read)
      match com with
      | Com.rets vs =>
        let vs : HVector Γ.Var (.riscv <$> ty) ←
          vs.mapM' (fun _ => transformVarRISCV)
        return ⟨eff, .riscv <$> ty, Com.rets vs⟩
      | _ => throw <| .unsupportedOp s!"Unable to parse return as either LLVM type or RISCV type."
    | e => throw e
  | _ => throw <| .generic s!"Unable to parse return as the program is impure and therefore not supported."

@[simp_denote]
def select_riscv_64 := [LV| {
  ^entry (%cond : i1, %arg0: i64, %arg1: i64):
    %0 = "builtin.unrealized_conversion_cast" (%arg0) : (i64) -> (!i64)
    %1 = "builtin.unrealized_conversion_cast" (%arg1) : (i64) -> (!i64)
    %2 = "builtin.unrealized_conversion_cast" (%cond) : (i1) -> (!i64)
    %3 = snez %2 : !i64
    %4 = sub %0, %1 : !i64
    %5 = mul %4, %3 : !i64
    %6 = add %5, %1 : !i64
    %7 = "builtin.unrealized_conversion_cast" (%6) : (!i64) -> (i64)
    llvm.return %7 : i64
  }]

def test5_before := [llvm|
{
^0(%arg95 : i32, %arg96 : i8):
  %0 = llvm.mlir.constant(32 : i32) : i32
  %1 = llvm.zext %arg96 : i8 to i32
  %2 = llvm.shl %0, %1 : i32
  %3 = llvm.urem %arg95, %2 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

@[match_pattern] def mul (w : Width φ)
  (NoWrapFlags: NoWrapFlags := {nsw := false , nuw := false}) : MOp φ
    := .binary w (.mul NoWrapFlags )

def xor_of_icmps_to_ne_commute_after := [llvm|
{
^0(%arg28 : i64):
  %0 = llvm.mlir.constant(5) : i64
  %1 = llvm.icmp "ne" %arg28, %0 : i64
  "llvm.return"(%1) : (i1) -> ()
}
]

def logical_or_implies_folds_after := [llvm|
{
^0(%arg250 : i32):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def icmp_and_ashr_multiuse_logical_after := [llvm|
{
^0(%arg4 : i32):
  %0 = llvm.mlir.constant(240 : i32) : i32
  %1 = llvm.mlir.constant(224 : i32) : i32
  %2 = llvm.mlir.constant(496 : i32) : i32
  %3 = llvm.mlir.constant(432 : i32) : i32
  %4 = llvm.and %arg4, %0 : i32
  %5 = llvm.icmp "ne" %4, %1 : i32
  %6 = llvm.and %arg4, %2 : i32
  %7 = llvm.icmp "ne" %6, %3 : i32
  %8 = llvm.and %5, %7 : i1
  "llvm.return"(%8) : (i1) -> ()
}
]

def test65_after := [llvm|
{
^0(%arg43 : i64):
  %0 = llvm.mlir.constant(16) : i64
  %1 = llvm.mlir.constant(0) : i64
  %2 = llvm.mlir.constant(42 : i32) : i32
  %3 = llvm.mlir.constant(40 : i32) : i32
  %4 = llvm.and %arg43, %0 : i64
  %5 = llvm.icmp "eq" %4, %1 : i64
  %6 = "llvm.select"(%5, %2, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def unpack2 (x : ValueStream (BitVec w)) (y : ValueStream (BitVec w)) : VariadicValueStream w × TokenStream :=
  Stream.corec₂ (β := CIRCTStream.Stream (BitVec w) × CIRCTStream.Stream (BitVec w)) (x, y)
    fun (x, y) => Id.run <| do
      match x 0, y 0 with
      | some x', some y' => return (some [x', y'], some .unit, (x.tail, y.tail))
      | some _, none => return (none, none, (x, y.tail))
      | none, some _ => return (none, none, (x.tail, y)) 
      | none, none => return (none, none, (x.tail, y.tail))

def ult_umin3_after := [llvm|
{
^0(%arg32 : i32, %arg33 : i32):
  %0 = llvm.mlir.constant(3 : i32) : i32
  %1 = llvm.add %arg32, %0 : i32
  %2 = llvm.icmp "ult" %arg33, %1 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

instance : DecidableEq (NFA'.autMsbSet).σ :=

def llvm_or_lower_riscv_noflag_64 : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64), Ty.llvm (.bitvec 64)] where
  lhs := or_llvm_noflag_64
  rhs := or_riscv_64

def or_eq_with_one_bit_diff_constants2_before := [llvm|
{
^0(%arg362 : i32):
  %0 = llvm.mlir.constant(97 : i32) : i32
  %1 = llvm.mlir.constant(65 : i32) : i32
  %2 = llvm.icmp "eq" %arg362, %0 : i32
  %3 = llvm.icmp "eq" %arg362, %1 : i32
  %4 = llvm.or %2, %3 : i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def positive_with_aggressive_icmp_before := [llvm|
{
^0(%arg56 : i32):
  %0 = llvm.mlir.constant(128 : i32) : i32
  %1 = llvm.mlir.constant(256 : i32) : i32
  %2 = llvm.mlir.constant(512 : i32) : i32
  %3 = llvm.icmp "ult" %arg56, %0 : i32
  %4 = llvm.add %arg56, %1 : i32
  %5 = llvm.icmp "ult" %4, %2 : i32
  %6 = llvm.and %3, %5 : i1
  "llvm.return"(%6) : (i1) -> ()
}
]

def rewritePeepholeRecursivelyRegArgs (fuel : ℕ)
    (pr : PeepholeRewrite d Γ t) {ts :  List (Ctxt d.Ty × List d.Ty)}
    (args : HVector (fun t => Com d t.1 EffectKind.impure t.2) ts)
    : { out : HVector (fun t => Com d t.1 EffectKind.impure t.2) ts // out.denote = args.denote} :=
  match ts with
  | .nil =>
    match args with
    | .nil => ⟨HVector.nil, rfl⟩
  | .cons .. =>
    match args with
    | .cons (a := a) (as := as) com coms =>
      let ⟨com', hcom'⟩ := rewritePeepholeRecursively fuel pr com
      let ⟨coms', hcoms'⟩ := (rewritePeepholeRecursivelyRegArgs fuel pr coms)
      ⟨.cons com' coms', by admit /- proof elided -/
      ⟩
termination_by (fuel, ts.length + 2)

def ult_and_max_commute_logical_after := [llvm|
{
^0(%arg362 : i8, %arg363 : i8):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

instance : MLIR.AST.TransformExpr (FHE q n) 0 where
  mkExpr := mkExpr

def testi16i8_after := [llvm|
{
^0(%arg9 : i16):
  %0 = llvm.mlir.constant(-1 : i16) : i16
  %1 = llvm.mlir.constant(27 : i8) : i8
  %2 = llvm.mlir.constant(-28 : i8) : i8
  %3 = llvm.icmp "sgt" %arg9, %0 : i16
  %4 = "llvm.select"(%3, %1, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%4) : (i8) -> ()
}
]

def test1_before := [llvm|
{
^0(%arg153 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg153, %0 : i32
  %2 = llvm.xor %1, %0 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def test_after := [llvm|
{
^0(%arg1 : i32):
  %0 = llvm.mlir.constant(255 : i32) : i32
  %1 = llvm.icmp "ugt" %arg1, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def shl_add_nsw_before := [llvm|
{
^0(%arg25 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.shl %0, %arg25 : i32
  %3 = llvm.add %2, %1 overflow<nsw> : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def and_xor_or3_before := [llvm|
{
^0(%arg667 : i64, %arg668 : i64, %arg669 : i64):
  %0 = llvm.mlir.constant(42) : i64
  %1 = llvm.udiv %0, %arg667 : i64
  %2 = llvm.udiv %0, %arg668 : i64
  %3 = llvm.udiv %0, %arg669 : i64
  %4 = llvm.and %1, %2 : i64
  %5 = llvm.xor %3, %4 : i64
  %6 = llvm.or %5, %2 : i64
  "llvm.return"(%6) : (i64) -> ()
}
]

def lshrult_01_00_before := [llvm|
{
^0(%arg367 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(0 : i4) : i4
  %2 = llvm.lshr %arg367, %0 : i4
  %3 = llvm.icmp "ult" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def ashr_uge_exact_after := [llvm|
{
^0(%arg170 : i8):
  %0 = llvm.mlir.constant(72 : i8) : i8
  %1 = llvm.icmp "ugt" %arg170, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

@[simp_denote]
def sub_riscv_16 := [LV| {
  ^entry (%x: i16, %y: i16):
    %0 = "builtin.unrealized_conversion_cast"(%x) : (i16) -> (!i64)
    %1 = "builtin.unrealized_conversion_cast"(%y) : (i16) -> (!i64)
    %2 = sub %0, %1 : !i64
    %3 = "builtin.unrealized_conversion_cast"(%2) : (!i64) -> (i16)
    llvm.return %3 : i16
  }]

def sra_i64_test : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64), Ty.llvm (.bitvec 64)] where
  lhs := sra_llvm_i64
  rhs := sra_riscv_i64

def and_logic_and_logic_or_5_before := [llvm|
{
^0(%arg126 : i1, %arg127 : i1, %arg128 : i1):
  %0 = llvm.mlir.constant(false) : i1
  %1 = llvm.mlir.constant(true) : i1
  %2 = llvm.and %arg126, %arg127 : i1
  %3 = "llvm.select"(%arg126, %arg128, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %4 = "llvm.select"(%3, %1, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def pr51551_neg1_before := [llvm|
{
^0(%arg4 : i32, %arg5 : i32):
  %0 = llvm.mlir.constant(-3 : i32) : i32
  %1 = llvm.mlir.constant(1 : i32) : i32
  %2 = llvm.mlir.constant(7 : i32) : i32
  %3 = llvm.mlir.constant(0 : i32) : i32
  %4 = llvm.and %arg5, %0 : i32
  %5 = llvm.or %4, %1 : i32
  %6 = llvm.mul %5, %arg4 overflow<nsw> : i32
  %7 = llvm.and %6, %2 : i32
  %8 = llvm.icmp "eq" %7, %3 : i32
  "llvm.return"(%8) : (i1) -> ()
}
]

def parseAndGeneralize
  [H : HydrableParseAndGeneralize parsedExpr genPred genExpr]
  (cfg : MedusaSynthGeneralizeConfig)
  (hExpr : Expr) (context: GeneralizeContext): TermElabM MessageData := do
    let targetWidth := 8
    let timeoutMs := 300000

    match_expr hExpr with
    | Eq w lhsExpr rhsExpr =>

          let some width ← H.getWidth w  | throwError m! "Could not determine the rewrite width from {w}"
          let startTime ← Core.liftIOCore IO.monoMsNow

          \n Input expression: {hExpr} has generalization: {pretty}"
                          | GeneralizeContext.Tactic _name =>
                            match cfg.output with
                            | .thmStmt =>
                              let name := Name.mkSimple "foo"
                              pure m! "{H.prettifyAsTheorem name res allVariables widthVals}"
                            | .sexpr =>
                              throwError (H.prettifyAsSexpr res allVariables) widthVals|> format
            | none => throwError m! "Could not generalize {bvLogicalExpr}"
    | _ => throwError m!"The top level constructor is not an equality predicate in {hExpr}"

def uge_swap_and_max_logical_before := [llvm|
{
^0(%arg228 : i8, %arg229 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.mlir.constant(false) : i1
  %2 = llvm.icmp "ule" %arg229, %arg228 : i8
  %3 = llvm.icmp "eq" %arg228, %0 : i8
  %4 = "llvm.select"(%2, %3, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def test_shl_nsw__none_are_safe_after := [llvm|
{
^0(%arg66 : i32, %arg67 : i64):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.mlir.constant(-8 : i32) : i32
  %2 = llvm.shl %arg66, %0 : i32
  %3 = llvm.and %2, %1 : i32
  %4 = llvm.zext nneg %3 : i32 to i64
  %5 = llvm.ashr %arg67, %4 : i64
  "llvm.return"(%5) : (i64) -> ()
}
]

def evalBV {w} (x : ar → BitVec w) : BitVec w :=
  BitVec.ofFn fun k => p.eval (fun ar => .ofBitVecSext (x ar)) k

def test_add_mul_neg_one_rhs_LHS := [mod_arith q, hq| {
  ^bb0(%x : !R, %y : !R):
    %neg_one = mod_arith.constant 41 : !R
    %mul = mod_arith.mul %y, %neg_one : !R
    %add = mod_arith.add %x, %mul : !R
    return %add : !R
}]

def toHom (d : Diff Γ₁ Γ₂) : Hom Γ₁ Γ₂ :=
  fun _ v => ⟨v.val + d.val, d.property v.property⟩

MonadLift in Init.Prelude

def udiv_pow2_16 : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%x: i64):
      %c = llvm.mlir.constant (16) : i64
      %0 = llvm.udiv %x, %c : i64
      llvm.return %0 : i64
  }]
  rhs := [LV| {
    ^entry (%x: i64):
      %c = llvm.mlir.constant (4) : i64
      %0 = llvm.lshr %x, %c : i64
      llvm.return %0 : i64
  }]

def or_not_and_wrong_b_after := [llvm|
{
^0(%arg484 : i32, %arg485 : i32, %arg486 : i32, %arg487 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.or %arg484, %arg485 : i32
  %2 = llvm.xor %1, %0 : i32
  %3 = llvm.and %arg486, %2 : i32
  %4 = llvm.or %arg484, %arg486 : i32
  %5 = llvm.xor %4, %0 : i32
  %6 = llvm.and %arg487, %5 : i32
  %7 = llvm.or %3, %6 : i32
  "llvm.return"(%7) : (i32) -> ()
}
]

def ashrsgt_02_12_exact_after := [llvm|
{
^0(%arg73 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def icmp_eq_and1_lshr_pow2_minus_one_after := [llvm|
{
^0(%arg38 : i32):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.icmp "ugt" %arg38, %0 : i32
  %2 = llvm.zext %1 : i1 to i32
  "llvm.return"(%2) : (i32) -> ()
}
]

Lean.Declaration.defnDecl in Lean.Declaration

instance : DecidableEq VarName :=

def lshrult_01_09_after := [llvm|
{
^0(%arg358 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def and_two_ranges_to_mask_and_range_no_add_on_one_range_before := [llvm|
{
^0(%arg249 : i16):
  %0 = llvm.mlir.constant(12 : i16) : i16
  %1 = llvm.mlir.constant(16 : i16) : i16
  %2 = llvm.mlir.constant(28 : i16) : i16
  %3 = llvm.icmp "uge" %arg249, %0 : i16
  %4 = llvm.icmp "ult" %arg249, %1 : i16
  %5 = llvm.icmp "uge" %arg249, %2 : i16
  %6 = llvm.or %4, %5 : i1
  %7 = llvm.and %3, %6 : i1
  "llvm.return"(%7) : (i1) -> ()
}
]

inductive BasicBlock
  | mk (label : BlockLabel) (args : List VarName) (body : Body)

def main4f_like_logical_before := [llvm|
{
^0(%arg115 : i32, %arg116 : i32, %arg117 : i32):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.and %arg115, %arg116 : i32
  %4 = llvm.icmp "ne" %3, %arg116 : i32
  %5 = llvm.and %arg115, %arg117 : i32
  %6 = llvm.icmp "ne" %5, %arg117 : i32
  %7 = "llvm.select"(%4, %0, %6) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %8 = "llvm.select"(%7, %1, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%8) : (i32) -> ()
}
]

def shl_nsw_add_nsw_before := [llvm|
{
^0(%arg21 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.shl %0, %arg21 overflow<nsw> : i32
  %3 = llvm.add %2, %1 overflow<nsw> : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def lshrult_01_04_exact_after := [llvm|
{
^0(%arg145 : i4):
  %0 = llvm.mlir.constant(-1 : i4) : i4
  %1 = llvm.icmp "sgt" %arg145, %0 : i4
  "llvm.return"(%1) : (i1) -> ()
}
]

def constLLVM_18 : Com LLVMPlusRiscV ⟨[]⟩ .pure (.llvm (.bitvec 64)) := [LV| {
  ^entry ():
    %1 = llvm.mlir.constant (-18) : i64
    llvm.return %1 : i64
  }]

def urem_illegal_type_c_before := [llvm|
{
^0(%arg7 : i9):
  %0 = llvm.mlir.constant(10 : i32) : i32
  %1 = llvm.zext %arg7 : i9 to i32
  %2 = llvm.urem %1, %0 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def select_icmp_ne_0_and_4096_and_not_32_after := [llvm|
{
^0(%arg205 : i32, %arg206 : i32):
  %0 = llvm.mlir.constant(4096 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(-33 : i32) : i32
  %3 = llvm.and %arg205, %0 : i32
  %4 = llvm.icmp "eq" %3, %1 : i32
  %5 = llvm.and %arg206, %2 : i32
  %6 = "llvm.select"(%4, %5, %arg206) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%6) : (i32) -> ()
}
]

inductive ISLOp
  | regConst (r : RegIndex)
  | regRead
  | regWrite
  | bitsConst {w : Nat} (x : BitVec w)
  | bitsAdd (w : Nat)
  deriving DecidableEq, ToExpr, Repr

def logic_or_logic_and_5_after := [llvm|
{
^0(%arg75 : i1, %arg76 : i1, %arg77 : i1):
  %0 = llvm.mlir.constant(false) : i1
  %1 = llvm.mlir.constant(true) : i1
  %2 = "llvm.select"(%arg77, %arg76, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %3 = "llvm.select"(%arg75, %1, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def fsmWidthEq (a b : FSM α) : FSM α :=
  composeUnaryAux FSM.scanAnd (composeBinaryAux' FSM.nxor a b)

@[inline]
def CNFA.proj (m: CNFA n2) (f : Fin n1 → Fin n2) : CNFA n1 :=
  ⟨m.m.proj f, m.m.proj_wf m.wf⟩

def lshr_x_by_const_cmp_x_after := [llvm|
{
^0(%arg11 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.icmp "eq" %arg11, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def negative_trunc_not_arg_logical_after := [llvm|
{
^0(%arg20 : i32, %arg21 : i32):
  %0 = llvm.mlir.constant(128 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(256 : i32) : i32
  %3 = llvm.mlir.constant(false) : i1
  %4 = llvm.and %arg20, %0 : i32
  %5 = llvm.icmp "eq" %4, %1 : i32
  %6 = llvm.add %arg21, %0 : i32
  %7 = llvm.icmp "ult" %6, %2 : i32
  %8 = "llvm.select"(%5, %7, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%8) : (i1) -> ()
}
]

def Lets.castPureToEff (eff : EffectKind) : Lets d Γ_in .pure Γ_out → Lets d Γ_in eff Γ_out
  | .nil => .nil
  | .var body e => .var (body.castPureToEff eff) (e.castPureToEff eff)

def p13_commutativity0_before := [llvm|
{
^0(%arg28 : i32, %arg29 : i32):
  %0 = llvm.mlir.constant(65536 : i32) : i32
  %1 = llvm.mlir.constant(65535 : i32) : i32
  %2 = llvm.icmp "ult" %arg28, %0 : i32
  %3 = "llvm.select"(%2, %1, %arg29) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def f_before := [llvm|
{
^0(%arg0 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.or %arg0, %0 : i32
  %3 = llvm.srem %2, %0 : i32
  %4 = llvm.icmp "ne" %3, %1 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def sub_ashr_or_i64_after := [llvm|
{
^0(%arg33 : i64, %arg34 : i64):
  %0 = llvm.mlir.constant(-1) : i64
  %1 = llvm.icmp "slt" %arg34, %arg33 : i64
  %2 = "llvm.select"(%1, %0, %arg33) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i64, i64) -> i64
  "llvm.return"(%2) : (i64) -> ()
}
]

def wrapReadyValue (value : α) (_ : Unit) := value

def pr9998_after := [llvm|
{
^0(%arg24 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.and %arg24, %0 : i32
  %3 = llvm.icmp "ne" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def liRiscv_3 := [LV| {
  ^entry ():
    %0 = "li"() {imm = -3 : !i64} : (!i64) -> (!i64)
    %1 = "builtin.unrealized_conversion_cast"(%0) : (!i64) -> (i64)
    llvm.return %1 : i64
  }]

def irc_constants_AMinusC1MinusC2_neg2_0 : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%a: i64):
      %c1 = llvm.mlir.constant (-2) : i64
      %c2 = llvm.mlir.constant (0) : i64
      %0 = llvm.sub %a, %c1 : i64
      %1 = llvm.sub %0, %c2 : i64
      llvm.return %1 : i64
  }]
  rhs := [LV| {
    ^entry (%a: i64):
      %c1 = llvm.mlir.constant (-2) : i64
      %c2 = llvm.mlir.constant (0) : i64
      %0 = llvm.add %c1, %c2 : i64
      %1 = llvm.sub %a, %0 : i64
      llvm.return %1 : i64
  }]

def ashrsgt_02_05_before := [llvm|
{
^0(%arg296 : i4):
  %0 = llvm.mlir.constant(2 : i4) : i4
  %1 = llvm.mlir.constant(5 : i4) : i4
  %2 = llvm.ashr %arg296, %0 : i4
  %3 = llvm.icmp "sgt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def or_not_and_commute8_after := [llvm|
{
^0(%arg513 : i32, %arg514 : i32, %arg515 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.sdiv %0, %arg513 : i32
  %3 = llvm.sdiv %0, %arg514 : i32
  %4 = llvm.xor %3, %arg515 : i32
  %5 = llvm.xor %2, %1 : i32
  %6 = llvm.and %4, %5 : i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def ashrsgt_02_14_exact_before := [llvm|
{
^0(%arg71 : i4):
  %0 = llvm.mlir.constant(2 : i4) : i4
  %1 = llvm.mlir.constant(-2 : i4) : i4
  %2 = llvm.ashr exact %arg71, %0 : i4
  %3 = llvm.icmp "sgt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def ashrslt_01_05_before := [llvm|
{
^0(%arg264 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(5 : i4) : i4
  %2 = llvm.ashr %arg264, %0 : i4
  %3 = llvm.icmp "slt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

@[combinator_formatter MLIR.EDSL.balancedBrackets]
def MLIR.EDSL.balancedBrackets.formatter : Formatter := pure ()

def lshrugt_03_05_exact_after := [llvm|
{
^0(%arg184 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def udiv_common_divisor_before := [llvm|
{
^0(%arg65 : i1, %arg66 : i5, %arg67 : i5, %arg68 : i5):
  %0 = llvm.udiv %arg67, %arg66 : i5
  %1 = llvm.udiv %arg68, %arg66 : i5
  %2 = "llvm.select"(%arg65, %1, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i5, i5) -> i5
  "llvm.return"(%2) : (i5) -> ()
}
]

def test_sub__none_are_safe_after := [llvm|
{
^0(%arg16 : i32):
  %0 = llvm.mlir.constant(-2147483648 : i32) : i32
  %1 = llvm.sub %0, %arg16 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def in_constant_mone_vary_before := [llvm|
{
^0(%arg24 : i4, %arg25 : i4):
  %0 = llvm.mlir.constant(-1 : i4) : i4
  %1 = llvm.mlir.constant(1 : i4) : i4
  %2 = llvm.xor %arg24, %0 : i4
  %3 = llvm.and %2, %1 : i4
  %4 = llvm.xor %3, %arg24 : i4
  "llvm.return"(%4) : (i4) -> ()
}
]

@[simp_denote]
def udiv_riscv_32: Com  LLVMPlusRiscV ⟨[.llvm (.bitvec 32), .llvm (.bitvec 32)]⟩
  .pure (.llvm (.bitvec 32)) := [LV| {
  ^entry (%reg1: i32, %reg2: i32):
    %0 = "builtin.unrealized_conversion_cast"(%reg1) : (i32) -> (!i64)
    %1 = "builtin.unrealized_conversion_cast"(%reg2) : (i32) -> (!i64)
    %2 = divu %0, %1 : !i64
    %3 = "builtin.unrealized_conversion_cast"(%2) : (!i64) -> (i32)
    llvm.return %3 : i32
  }]

def t1_before := [llvm|
{
^0(%arg17 : i16):
  %0 = llvm.mlir.constant(1 : i16) : i16
  %1 = llvm.mlir.constant(-1 : i16) : i16
  %2 = llvm.shl %0, %arg17 : i16
  %3 = llvm.add %2, %1 : i16
  %4 = llvm.or %3, %2 : i16
  "llvm.return"(%4) : (i16) -> ()
}
]

def masked_icmps_mask_notallzeros_bmask_mixed_negated_swapped_3_logical_after := [llvm|
{
^0(%arg21 : i32):
  %0 = llvm.mlir.constant(15 : i32) : i32
  %1 = llvm.mlir.constant(8 : i32) : i32
  %2 = llvm.and %arg21, %0 : i32
  %3 = llvm.icmp "ne" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def TestDialect : Dialect where
  Ty := Ty
  Op := Op

def and_lshr_and_after := [llvm|
{
^0(%arg63 : i32):
  %0 = llvm.mlir.constant(3 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.and %arg63, %0 : i32
  %3 = llvm.icmp "ne" %2, %1 : i32
  %4 = llvm.zext %3 : i1 to i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def AndZextAnd_after := [llvm|
{
^0(%arg2 : i3):
  %0 = llvm.mlir.constant(2 : i3) : i3
  %1 = llvm.and %arg2, %0 : i3
  %2 = llvm.zext nneg %1 : i3 to i5
  "llvm.return"(%2) : (i5) -> ()
}
]

def ashrsgt_02_01_exact_after := [llvm|
{
^0(%arg84 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def one_inst_concrete_com :
    Com InstCombine.LLVM [LLVM.Ty.bitvec 1] .pure [LLVM.Ty.bitvec 1] :=
  Com.var (not 1 0) <|
  Com.ret ⟨0, rfl⟩

def or_logic_or_logic_and_7_after := [llvm|
{
^0(%arg30 : i1, %arg31 : i1, %arg32 : i1):
  %0 = llvm.mlir.constant(false) : i1
  %1 = llvm.mlir.constant(true) : i1
  %2 = "llvm.select"(%arg32, %arg31, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %3 = "llvm.select"(%arg30, %1, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def ashr_ugt_11_before := [llvm|
{
^0(%arg103 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(-5 : i4) : i4
  %2 = llvm.ashr %arg103, %0 : i4
  %3 = llvm.icmp "ugt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def n2_before := [llvm|
{
^0(%arg19 : i1, %arg20 : i8, %arg21 : i8, %arg22 : i8, %arg23 : i8):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.icmp "eq" %arg20, %arg21 : i8
  %2 = llvm.xor %arg19, %0 : i1
  %3 = llvm.or %2, %1 : i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def ashrsgt_02_14_after := [llvm|
{
^0(%arg287 : i4):
  %0 = llvm.mlir.constant(-5 : i4) : i4
  %1 = llvm.icmp "sgt" %arg287, %0 : i4
  "llvm.return"(%1) : (i1) -> ()
}
]

def lshrugt_01_06_exact_before := [llvm|
{
^0(%arg215 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(6 : i4) : i4
  %2 = llvm.lshr exact %arg215, %0 : i4
  %3 = llvm.icmp "ugt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def p13_commutativity0_after := [llvm|
{
^0(%arg28 : i32, %arg29 : i32):
  %0 = llvm.mlir.constant(65535 : i32) : i32
  %1 = llvm.icmp "ugt" %arg28, %0 : i32
  %2 = "llvm.select"(%1, %arg29, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%2) : (i32) -> ()
}
]

@[simp] abbrev FlatCom.denote [DialectDenote d]
    (flatCom : FlatCom d Γ eff Γ_out ts)
    (V : Γ.Valuation) : eff.toMonad d.m (HVector toType ts) :=
  flatCom.lets.denote V >>= (return flatCom.rets.map ·)

def no_reassoc_add_nuw_none_after := [llvm|
{
^0(%arg23 : i32):
  %0 = llvm.mlir.constant(68 : i32) : i32
  %1 = llvm.add %arg23, %0 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def neg_nsw_slt_n1_after := [llvm|
{
^0(%arg21 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.icmp "sgt" %arg21, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def not_and_and_or_no_or_commute1_and_before := [llvm|
{
^0(%arg160 : i32, %arg161 : i32, %arg162 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.or %arg161, %arg160 : i32
  %2 = llvm.xor %1, %0 : i32
  %3 = llvm.xor %arg160, %0 : i32
  %4 = llvm.and %arg162, %arg161 : i32
  %5 = llvm.and %4, %3 : i32
  %6 = llvm.or %5, %2 : i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def logical_or_not_before := [llvm|
{
^0(%arg260 : i1, %arg261 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = "llvm.select"(%arg260, %arg261, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%1) : (i1) -> ()
}
]

def test_with_even_after := [llvm|
{
^0(%arg313 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

def ult_swap_and_max_before := [llvm|
{
^0(%arg360 : i8, %arg361 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.icmp "ugt" %arg361, %arg360 : i8
  %2 = llvm.icmp "eq" %arg360, %0 : i8
  %3 = llvm.and %1, %2 : i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def srem2_ashr_mask_after := [llvm|
{
^0(%arg6 : i32):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.srem %arg6, %0 : i32
  %2 = llvm.and %1, %0 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def ugt_swap_or_not_min_logical_after := [llvm|
{
^0(%arg4 : i8, %arg5 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.icmp "ne" %arg4, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def irc_constants_APlusC1MinusC2_neg2_neg2 : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%a: i64):
      %c1 = llvm.mlir.constant (-2) : i64
      %c2 = llvm.mlir.constant (-2) : i64
      %0 = llvm.add %a, %c1 : i64
      %1 = llvm.sub %0, %c2 : i64
      llvm.return %1 : i64
  }]
  rhs := [LV| {
    ^entry (%a: i64):
      %c1 = llvm.mlir.constant (-2) : i64
      %c2 = llvm.mlir.constant (-2) : i64
      %0 = llvm.sub %c1, %c2 : i64
      %1 = llvm.add %a, %0 : i64
      llvm.return %1 : i64
  }]

def trunc_shl_nsw_nuw_31_i32_i64_before := [llvm|
{
^0(%arg40 : i64):
  %0 = llvm.mlir.constant(31) : i64
  %1 = llvm.shl %arg40, %0 overflow<nsw,nuw> : i64
  %2 = llvm.trunc %1 : i64 to i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def sub_ashr_and_i32_before := [llvm|
{
^0(%arg27 : i32, %arg28 : i32):
  %0 = llvm.mlir.constant(31 : i32) : i32
  %1 = llvm.sub %arg28, %arg27 overflow<nsw> : i32
  %2 = llvm.ashr %1, %0 : i32
  %3 = llvm.and %2, %arg27 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def test_nuw_nsw_and_unsigned_pred_after := [llvm|
{
^0(%arg55 : i64):
  %0 = llvm.mlir.constant(6) : i64
  %1 = llvm.icmp "ugt" %arg55, %0 : i64
  "llvm.return"(%1) : (i1) -> ()
}
]

def a_true_implies_b_true2_after := [llvm|
{
^0(%arg30 : i8, %arg31 : i1, %arg32 : i1):
  %0 = llvm.mlir.constant(20 : i8) : i8
  %1 = llvm.mlir.constant(false) : i1
  %2 = llvm.icmp "ugt" %arg30, %0 : i8
  %3 = "llvm.select"(%2, %arg31, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def icmp_slt_0_and_icmp_sge_neg1_i64_fail_after := [llvm|
{
^0(%arg59 : i64):
  %0 = llvm.mlir.constant(-2) : i64
  %1 = llvm.mlir.constant(62) : i64
  %2 = llvm.mlir.constant(1) : i64
  %3 = llvm.mlir.constant(0) : i64
  %4 = llvm.icmp "sgt" %arg59, %0 : i64
  %5 = llvm.lshr %arg59, %1 : i64
  %6 = llvm.and %5, %2 : i64
  %7 = "llvm.select"(%4, %6, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i64, i64) -> i64
  "llvm.return"(%7) : (i64) -> ()
}
]

def lshrult_03_04_exact_before := [llvm|
{
^0(%arg113 : i4):
  %0 = llvm.mlir.constant(3 : i4) : i4
  %1 = llvm.mlir.constant(4 : i4) : i4
  %2 = llvm.lshr exact %arg113, %0 : i4
  %3 = llvm.icmp "ult" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def invert_both_cmp_operands_add_before := [llvm|
{
^0(%arg38 : i32, %arg39 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.xor %arg38, %0 : i32
  %3 = llvm.add %arg39, %2 : i32
  %4 = llvm.icmp "sgt" %3, %1 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def slt_swap_or_not_max_commute_logical_after := [llvm|
{
^0(%arg48 : i8, %arg49 : i8):
  %0 = llvm.mlir.constant(127 : i8) : i8
  %1 = llvm.icmp "ne" %arg48, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def icmp_slt_0_and_icmp_ne_neg2_i32_fail_before := [llvm|
{
^0(%arg44 : i32):
  %0 = llvm.mlir.constant(-2 : i32) : i32
  %1 = llvm.mlir.constant(31 : i32) : i32
  %2 = llvm.icmp "ne" %arg44, %0 : i32
  %3 = llvm.zext %2 : i1 to i32
  %4 = llvm.lshr %arg44, %1 : i32
  %5 = llvm.and %4, %3 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def size (α : Type u) : Circuit α → Nat
| tru | fals | var .. => 1
| and l r | or l r | xor l r => 1 + l.size  + r.size

def select_icmp_ne_0_and_1073741824_and_not_8_before := [llvm|
{
^0(%arg191 : i32, %arg192 : i8):
  %0 = llvm.mlir.constant(1073741824 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(-9 : i8) : i8
  %3 = llvm.and %arg191, %0 : i32
  %4 = llvm.icmp "ne" %1, %3 : i32
  %5 = llvm.and %arg192, %2 : i8
  %6 = "llvm.select"(%4, %arg192, %5) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%6) : (i8) -> ()
}
]

def trunc_lshr_zext_before := [llvm|
{
^0(%arg12 : i8):
  %0 = llvm.mlir.constant(6 : i32) : i32
  %1 = llvm.zext %arg12 : i8 to i32
  %2 = llvm.lshr %1, %0 : i32
  %3 = llvm.trunc %2 : i32 to i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def test2_before := [llvm|
{
^0(%arg0 : i999, %arg1 : i999):
  %0 = llvm.mlir.constant(65280 : i999) : i999
  %1 = llvm.and %arg0, %0 : i999
  %2 = llvm.and %arg1, %0 : i999
  %3 = llvm.icmp "ne" %1, %2 : i999
  "llvm.return"(%3) : (i1) -> ()
}
]

def Body.return : (body : Body Op Γ ty) → Var body.returnContext ty
  | ⟨⟨_, ret⟩, h⟩ => ⟨ret, by admit /- proof elided -/
  ⟩

def sub_i64_test : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64), Ty.llvm (.bitvec 64)] where
  lhs := sub_llvm_i64
  rhs := sub_riscv_i64

def pr40493_neg1_before := [llvm|
{
^0(%arg17 : i32):
  %0 = llvm.mlir.constant(11 : i32) : i32
  %1 = llvm.mlir.constant(4 : i32) : i32
  %2 = llvm.mlir.constant(0 : i32) : i32
  %3 = llvm.mul %arg17, %0 : i32
  %4 = llvm.and %3, %1 : i32
  %5 = llvm.icmp "eq" %4, %2 : i32
  "llvm.return"(%5) : (i1) -> ()
}
]

def bad_shl2_sub_i32_after := [llvm|
{
^0(%arg9 : i32):
  %0 = llvm.mlir.constant(-31 : i32) : i32
  %1 = llvm.mlir.constant(1 : i32) : i32
  %2 = llvm.add %arg9, %0 : i32
  %3 = llvm.shl %1, %2 overflow<nuw> : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def main13_logical_after := [llvm|
{
^0(%arg17 : i32):
  %0 = llvm.mlir.constant(32896 : i32) : i32
  %1 = llvm.mlir.constant(2 : i32) : i32
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.and %arg17, %0 : i32
  %4 = llvm.icmp "eq" %3, %0 : i32
  %5 = "llvm.select"(%4, %1, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def test_shl_nuw__nuw_is_safe_after := [llvm|
{
^0(%arg80 : i32, %arg81 : i64):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.mlir.constant(-8 : i32) : i32
  %2 = llvm.shl %arg80, %0 : i32
  %3 = llvm.and %2, %1 : i32
  %4 = llvm.zext nneg %3 : i32 to i64
  %5 = llvm.ashr %arg81, %4 : i64
  "llvm.return"(%5) : (i64) -> ()
}
]

def ashrslt_01_15_exact_after := [llvm|
{
^0(%arg38 : i4):
  %0 = llvm.mlir.constant(-2 : i4) : i4
  %1 = llvm.icmp "slt" %arg38, %0 : i4
  "llvm.return"(%1) : (i1) -> ()
}
]

def test1_before := [llvm|
{
^0(%arg14 : i32, %arg15 : i32):
  %0 = llvm.icmp "slt" %arg14, %arg15 : i32
  %1 = llvm.zext %0 : i1 to i32
  %2 = llvm.icmp "sgt" %arg14, %arg15 : i32
  %3 = llvm.zext %2 : i1 to i32
  %4 = llvm.and %1, %3 : i32
  %5 = llvm.trunc %4 : i32 to i1
  "llvm.return"(%5) : (i1) -> ()
}
]

def n1_before := [llvm|
{
^0(%arg2 : i8, %arg3 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.mlir.constant(-1 : i8) : i8
  %2 = llvm.shl %0, %arg3 : i8
  %3 = llvm.xor %2, %1 : i8
  %4 = llvm.and %3, %arg2 : i8
  %5 = llvm.icmp "eq" %4, %arg2 : i8
  "llvm.return"(%5) : (i1) -> ()
}
]

def llvm_trunc_riscv_32_to_8_nuw_nsw : LLVMPeepholeRewriteRefine 8 [Ty.llvm (.bitvec 32)] :=
  {lhs:= trunc_llvm_32_to_8_nsw_nuw, rhs:= trunc_riscv_32_to_8_nsw_nuw}

instance : Fintype (NFA'.autMsbSet).σ :=

def src_x_and_nmask_sge_after := [llvm|
{
^0(%arg17 : i8, %arg18 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.shl %0, %arg18 overflow<nsw> : i8
  %2 = llvm.icmp "sle" %1, %arg17 : i8
  "llvm.return"(%2) : (i1) -> ()
}
]

def select_icmp_eq_and_4096_0_or_4096_after := [llvm|
{
^0(%arg225 : i32, %arg226 : i32):
  %0 = llvm.mlir.constant(4096 : i32) : i32
  %1 = llvm.and %arg225, %0 : i32
  %2 = llvm.or %arg226, %1 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def compose [FinEnum arity] [DecidableEq arity] [Hashable arity]
    (new_arity : Type)        
    (q_arity : arity → Type)  
    (vars : ∀ (a : arity), q_arity a → new_arity)
    
    
    (q : ∀ (a : arity), FSM (q_arity a)) : 
    FSM new_arity :=
  { α := p.α ⊕ (Σ a, (q a).α),
    i := by admit /- proof elided -/

def bools_logical_commute1_after := [llvm|
{
^0(%arg96 : i1, %arg97 : i1, %arg98 : i1):
  %0 = "llvm.select"(%arg98, %arg97, %arg96) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def revertBvHyps (g : MVarId) : MetaM MVarId := do
  let (_, g) ← g.revert (← g.getNondepPropHyps)
  return g

def scalar_i16_shl_ult_const_before := [llvm|
{
^0(%arg16 : i16):
  %0 = llvm.mlir.constant(8 : i16) : i16
  %1 = llvm.mlir.constant(1024 : i16) : i16
  %2 = llvm.shl %arg16, %0 : i16
  %3 = llvm.icmp "ult" %2, %1 : i16
  "llvm.return"(%3) : (i1) -> ()
}
]

def ashrsgt_01_08_exact_after := [llvm|
{
^0(%arg93 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def eq_umin3_before := [llvm|
{
^0(%arg56 : i32, %arg57 : i32):
  %0 = llvm.mlir.constant(3 : i32) : i32
  %1 = llvm.add %arg56, %0 : i32
  %2 = llvm.icmp "ult" %1, %arg57 : i32
  %3 = "llvm.select"(%2, %1, %arg57) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %4 = llvm.icmp "eq" %1, %3 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def cst {Γ : Ctxt _} (n : ℕ) : Expr Ex Γ .pure [.nat]  :=
  Expr.mk
    (op := .cst n)
    (ty_eq := rfl)
    (eff_le := by admit /- proof elided -/
    )
    (args := .nil)
    (regArgs := .nil)

def icmp_x_slt_0_and_icmp_y_sgt_neg1_i32_fail_after := [llvm|
{
^0(%arg40 : i32, %arg41 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.icmp "sgt" %arg40, %0 : i32
  %3 = llvm.icmp "slt" %arg41, %1 : i32
  %4 = llvm.and %3, %2 : i1
  %5 = llvm.zext %4 : i1 to i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def Expr.mkToFSM (self : Expr) : MetaM Expr :=
  mkAppM ``FSMPredicateSolution.toFSM #[self]

def test_shl_nuw__nsw_is_safe_after := [llvm|
{
^0(%arg74 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

def neg_not_signbit2_before := [llvm|
{
^0(%arg4 : i8):
  %0 = llvm.mlir.constant(6 : i8) : i8
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.lshr %arg4, %0 : i8
  %3 = llvm.zext %2 : i8 to i32
  %4 = llvm.sub %1, %3 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def uaddo_commute4_before := [llvm|
{
^0(%arg22 : i32, %arg23 : i32, %arg24 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg23, %0 : i32
  %2 = llvm.add %arg23, %arg22 : i32
  %3 = llvm.icmp "ult" %1, %arg22 : i32
  %4 = "llvm.select"(%3, %arg24, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def extractOpName : Syntax → Option (TSyntax `str)
  | .node _ _ ⟨.atom _ name :: _⟩ => some <| Syntax.mkStrLit name
  | _ => none

 
syntax (mlir_op_operand " = ")? MLIR.Pretty.uniform_op mlir_op_operand,*
  (" : " mlir_type)? : mlir_op

def sup : EffectKind → EffectKind → EffectKind
  | .pure, .pure => .pure
  | _, _ => .impure

def logic_or_logic_and_6_after := [llvm|
{
^0(%arg72 : i1, %arg73 : i1, %arg74 : i1):
  %0 = llvm.mlir.constant(false) : i1
  %1 = llvm.mlir.constant(true) : i1
  %2 = "llvm.select"(%arg74, %arg73, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %3 = "llvm.select"(%arg72, %1, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def test_sub_nuw_nsw__all_are_safe_after := [llvm|
{
^0(%arg31 : i32):
  %0 = llvm.mlir.constant(255 : i32) : i32
  %1 = llvm.mlir.constant(-254 : i32) : i32
  %2 = llvm.and %arg31, %0 : i32
  %3 = llvm.sub %1, %2 overflow<nsw,nuw> : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def icmp_eq_x_invertable_y2_todo_before := [llvm|
{
^0(%arg4 : i8, %arg5 : i1):
  %0 = llvm.mlir.constant(7 : i8) : i8
  %1 = llvm.mlir.constant(24 : i8) : i8
  %2 = "llvm.select"(%arg5, %0, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  %3 = llvm.and %arg4, %2 : i8
  %4 = llvm.icmp "eq" %2, %3 : i8
  "llvm.return"(%4) : (i1) -> ()
}
]

def Eqn.denoteFin {w : Nat} (e : Eqn) (envFin : EnvFin w e.numVars) : Int :=
  match e with
  | [] => 0
  | t :: ts =>
    t.denoteFin (envFin.castLe (by admit /- proof elided -/
    )) +
    Eqn.denoteFin ts (envFin.castLe (by admit /- proof elided -/
    ))

def lsb_mask_sign_sext_commuted_before := [llvm|
{
^0(%arg4 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.mlir.constant(31 : i32) : i32
  %2 = llvm.add %arg4, %0 : i32
  %3 = llvm.xor %arg4, %0 : i32
  %4 = llvm.and %3, %2 : i32
  %5 = llvm.ashr %4, %1 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def fold_sext_to_and1_before := [llvm|
{
^0(%arg16 : i8):
  %0 = llvm.mlir.constant(-2147483647 : i32) : i32
  %1 = llvm.mlir.constant(1 : i32) : i32
  %2 = llvm.sext %arg16 : i8 to i32
  %3 = llvm.and %2, %0 : i32
  %4 = llvm.icmp "ne" %3, %1 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def lshrult_01_09_before := [llvm|
{
^0(%arg358 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(-7 : i4) : i4
  %2 = llvm.lshr %arg358, %0 : i4
  %3 = llvm.icmp "ult" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def ashrsgt_03_12_exact_before := [llvm|
{
^0(%arg57 : i4):
  %0 = llvm.mlir.constant(3 : i4) : i4
  %1 = llvm.mlir.constant(-4 : i4) : i4
  %2 = llvm.ashr exact %arg57, %0 : i4
  %3 = llvm.icmp "sgt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def and_two_ranges_to_mask_and_range_no_add_on_one_range_before := [llvm|
{
^0(%arg249 : i16):
  %0 = llvm.mlir.constant(12 : i16) : i16
  %1 = llvm.mlir.constant(16 : i16) : i16
  %2 = llvm.mlir.constant(28 : i16) : i16
  %3 = llvm.icmp "uge" %arg249, %0 : i16
  %4 = llvm.icmp "ult" %arg249, %1 : i16
  %5 = llvm.icmp "uge" %arg249, %2 : i16
  %6 = llvm.or %4, %5 : i1
  %7 = llvm.and %3, %6 : i1
  "llvm.return"(%7) : (i1) -> ()
}
]

def masked_icmps_mask_notallzeros_bmask_mixed_swapped_1_after := [llvm|
{
^0(%arg50 : i32):
  %0 = llvm.mlir.constant(15 : i32) : i32
  %1 = llvm.mlir.constant(9 : i32) : i32
  %2 = llvm.and %arg50, %0 : i32
  %3 = llvm.icmp "eq" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

structure State where
  
  e2ix : Std.HashMap Expr Ix := {}

def Expr.mkVerifyCircuit (c cert : Expr) : MetaM Expr :=
  mkAppM ``Circuit.verifyCircuit #[c, cert]

def no_shift_xor_multiuse_cmp_and_before := [llvm|
{
^0(%arg40 : i32, %arg41 : i32, %arg42 : i32, %arg43 : i32):
  %0 = llvm.mlir.constant(4096 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(-4097 : i32) : i32
  %3 = llvm.and %arg40, %0 : i32
  %4 = llvm.icmp "ne" %1, %3 : i32
  %5 = llvm.and %arg41, %2 : i32
  %6 = "llvm.select"(%4, %arg41, %5) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %7 = "llvm.select"(%4, %arg42, %arg43) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %8 = llvm.mul %6, %7 : i32
  %9 = llvm.mul %8, %5 : i32
  "llvm.return"(%9) : (i32) -> ()
}
]

def add_smin_simplify_after := [llvm|
{
^0(%arg34 : i32):
  %0 = llvm.mlir.constant(-3 : i32) : i32
  %1 = llvm.add %arg34, %0 overflow<nsw> : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def sge_and_max_commute_before := [llvm|
{
^0(%arg250 : i8, %arg251 : i8):
  %0 = llvm.mlir.constant(127 : i8) : i8
  %1 = llvm.icmp "sge" %arg250, %arg251 : i8
  %2 = llvm.icmp "eq" %arg250, %0 : i8
  %3 = llvm.and %2, %1 : i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def and_xor_common_op_after := [llvm|
{
^0(%arg695 : i32, %arg696 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(43 : i32) : i32
  %2 = llvm.mlir.constant(-1 : i32) : i32
  %3 = llvm.udiv %0, %arg695 : i32
  %4 = llvm.udiv %1, %arg696 : i32
  %5 = llvm.xor %4, %2 : i32
  %6 = llvm.and %3, %5 : i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def foo_before := [llvm|
{
^0(%arg0 : i32):
  %0 = llvm.mlir.constant(223 : i32) : i32
  %1 = llvm.mlir.constant(29 : i32) : i32
  %2 = llvm.mlir.constant(-784568073 : i32) : i32
  %3 = llvm.mlir.constant(1874836915 : i32) : i32
  %4 = llvm.mlir.constant(221 : i32) : i32
  %5 = llvm.mlir.constant(1 : i32) : i32
  %6 = llvm.mlir.constant(1533579450 : i32) : i32
  %7 = llvm.mlir.constant(-2147483648 : i32) : i32
  %8 = llvm.mlir.constant(749011377 : i32) : i32
  %9 = llvm.and %arg0, %0 : i32
  %10 = llvm.xor %9, %1 : i32
  %11 = llvm.add %10, %2 overflow<nuw> : i32
  %12 = llvm.or %10, %3 : i32
  %13 = llvm.and %10, %4 : i32
  %14 = llvm.xor %13, %3 : i32
  %15 = llvm.xor %12, %14 : i32
  %16 = llvm.shl %15, %5 overflow<nsw,nuw> : i32
  %17 = llvm.sub %11, %16 : i32
  %18 = llvm.add %17, %6 overflow<nsw> : i32
  %19 = llvm.or %18, %7 : i32
  %20 = llvm.xor %19, %8 : i32
  "llvm.return"(%20) : (i32) -> ()
}
]

def xor_signbit_select_shl_after := [llvm|
{
^0(%arg38 : i32, %arg39 : i1):
  %0 = llvm.mlir.constant(8 : i32) : i32
  %1 = llvm.mlir.constant(-16777216 : i32) : i32
  %2 = llvm.shl %arg38, %0 : i32
  %3 = llvm.xor %2, %1 : i32
  %4 = "llvm.select"(%arg39, %3, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def test7_after := [llvm|
{
^0(%arg96 : i64):
  %0 = llvm.mlir.constant(32) : i64
  %1 = llvm.lshr %arg96, %0 : i64
  %2 = llvm.zext nneg %1 : i64 to i92
  "llvm.return"(%2) : (i92) -> ()
}
]

def t0_after := [llvm|
{
^0(%arg14 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.icmp "slt" %arg14, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def same_signbit_wrong_type_before := [llvm|
{
^0(%arg34 : i8, %arg35 : i32):
  %0 = llvm.mlir.constant(7 : i8) : i8
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.lshr %arg34, %0 : i8
  %3 = llvm.icmp "sgt" %arg35, %1 : i32
  %4 = llvm.zext %3 : i1 to i8
  %5 = llvm.icmp "ne" %2, %4 : i8
  "llvm.return"(%5) : (i1) -> ()
}
]

def lshrult_03_01_exact_before := [llvm|
{
^0(%arg116 : i4):
  %0 = llvm.mlir.constant(3 : i4) : i4
  %1 = llvm.mlir.constant(1 : i4) : i4
  %2 = llvm.lshr exact %arg116, %0 : i4
  %3 = llvm.icmp "ult" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def scalar_i64_lshr_and_negC_eq_after := [llvm|
{
^0(%arg33 : i64, %arg34 : i64):
  %0 = llvm.mlir.constant(8589934592) : i64
  %1 = llvm.lshr %arg33, %arg34 : i64
  %2 = llvm.icmp "ult" %1, %0 : i64
  "llvm.return"(%2) : (i1) -> ()
}
]

def llvm_sext_lower_riscv_i8_to_64 : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 8)] :=
  {lhs:=sext_llvm_i8_to_64, rhs:= sext_riscv_i8_to_64}

def test5_before := [llvm|
{
^0(%arg2 : i7):
  %0 = llvm.mlir.constant(23 : i7) : i7
  %1 = llvm.or %arg2, %0 : i7
  %2 = llvm.xor %1, %0 : i7
  "llvm.return"(%2) : (i7) -> ()
}
]

def shl_add_log_may_cause_poison_pr62175_with_nsw_after := [llvm|
{
^0(%arg0 : i8, %arg1 : i8):
  %0 = llvm.mlir.constant(2 : i8) : i8
  %1 = llvm.add %arg0, %0 : i8
  %2 = llvm.shl %arg1, %1 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def masked_icmps_mask_notallzeros_bmask_mixed_negated_7_before := [llvm|
{
^0(%arg56 : i32):
  %0 = llvm.mlir.constant(7 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(15 : i32) : i32
  %3 = llvm.mlir.constant(8 : i32) : i32
  %4 = llvm.and %arg56, %0 : i32
  %5 = llvm.icmp "eq" %4, %1 : i32
  %6 = llvm.and %arg56, %2 : i32
  %7 = llvm.icmp "ne" %6, %3 : i32
  %8 = llvm.or %5, %7 : i1
  "llvm.return"(%8) : (i1) -> ()
}
]

def negative_not_next_power_of_two_before := [llvm|
{
^0(%arg5 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.mlir.constant(64 : i32) : i32
  %2 = llvm.mlir.constant(256 : i32) : i32
  %3 = llvm.icmp "sgt" %arg5, %0 : i32
  %4 = llvm.add %arg5, %1 : i32
  %5 = llvm.icmp "ult" %4, %2 : i32
  %6 = llvm.and %3, %5 : i1
  "llvm.return"(%6) : (i1) -> ()
}
]

def uge_swap_or_not_max_after := [llvm|
{
^0(%arg296 : i8, %arg297 : i8):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def mul_add_to_mul_2_before := [llvm|
{
^0(%arg31 : i16):
  %0 = llvm.mlir.constant(8 : i16) : i16
  %1 = llvm.mul %arg31, %0 overflow<nsw> : i16
  %2 = llvm.add %1, %arg31 overflow<nsw> : i16
  "llvm.return"(%2) : (i16) -> ()
}
]

def ne_smax4_before := [llvm|
{
^0(%arg41 : i32, %arg42 : i32):
  %0 = llvm.mlir.constant(3 : i32) : i32
  %1 = llvm.add %arg41, %0 : i32
  %2 = llvm.icmp "sgt" %arg42, %1 : i32
  %3 = "llvm.select"(%2, %arg42, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %4 = llvm.icmp "ne" %1, %3 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def IndexInvariant (f : LoopBody t) : Prop :=
  ∀ (i j : Int) (v : t), f i v = f j v

def xor_icmp_to_ne_before := [llvm|
{
^0(%arg6 : i32):
  %0 = llvm.mlir.constant(4 : i32) : i32
  %1 = llvm.mlir.constant(6 : i32) : i32
  %2 = llvm.icmp "sgt" %arg6, %0 : i32
  %3 = llvm.icmp "slt" %arg6, %1 : i32
  %4 = llvm.xor %2, %3 : i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def icmp_ne_zext_ne_non_boolean_after := [llvm|
{
^0(%arg33 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.icmp "ne" %arg33, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def multiuse_lshr_lshr_before := [llvm|
{
^0(%arg39 : i9):
  %0 = llvm.mlir.constant(2 : i9) : i9
  %1 = llvm.mlir.constant(3 : i9) : i9
  %2 = llvm.lshr %arg39, %0 : i9
  %3 = llvm.lshr %2, %1 : i9
  %4 = llvm.mul %2, %3 : i9
  "llvm.return"(%4) : (i9) -> ()
}
]

def test12_after := [llvm|
{
^0(%arg292 : i32, %arg293 : i32):
  %0 = llvm.icmp "ult" %arg292, %arg293 : i32
  "llvm.return"(%0) : (i1) -> ()
}
]

@[simp_denote]
def add_shl_moreOneUse_sh4add_riscv := [LV| {
    ^entry (%a: i64):
    %a0 = "builtin.unrealized_conversion_cast" (%a) : (i64) -> (!i64)
    %0 = ori %a0, 1 : !i64
    %1 = slli %a0, 4 : !i64
    %2 = ori %1, 16 : !i64
    %3 = add %2, %0 : !i64
    %4 = "builtin.unrealized_conversion_cast" (%3) : (!i64) -> (i64)
    llvm.return %4 : i64
  }]

def positive_samevar_shlnsw_before := [llvm|
{
^0(%arg52 : i8, %arg53 : i8):
  %0 = llvm.ashr %arg52, %arg53 : i8
  %1 = llvm.shl %0, %arg53 overflow<nsw> : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

@[match_pattern] abbrev add (w : Nat) (flags: NoWrapFlags := {}) : LLVM.Op := MOp.add (.concrete w) flags

def ashr_sge_exact_before := [llvm|
{
^0(%arg166 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.mlir.constant(10 : i8) : i8
  %2 = llvm.ashr exact %arg166, %0 : i8
  %3 = llvm.icmp "sge" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def lshr_2_add_zext_basic_after := [llvm|
{
^0(%arg37 : i1, %arg38 : i1):
  %0 = llvm.and %arg37, %arg38 : i1
  %1 = llvm.zext %0 : i1 to i2
  "llvm.return"(%1) : (i2) -> ()
}
]

def positive_sameconst_shlnsw_ashrexact_before := [llvm|
{
^0(%arg36 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.ashr exact %arg36, %0 : i8
  %2 = llvm.shl %1, %0 overflow<nsw> : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def select_or_icmp_after := [llvm|
{
^0(%arg278 : i32, %arg279 : i32, %arg280 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.icmp "eq" %arg278, %0 : i32
  %2 = "llvm.select"(%1, %arg280, %arg279) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def n9_before := [llvm|
{
^0(%arg1 : i64):
  %0 = llvm.mlir.constant(62) : i64
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.lshr %arg1, %0 : i64
  %3 = llvm.trunc %2 : i64 to i32
  %4 = llvm.sub %1, %3 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def transpose' {A : α → Type} {as : List α}
    (xs : HVector (fun a => Stream (A a)) as) :
    Stream (HVector A as) :=
  corec xs fun xs =>
    let xs := xs.map fun _ x => x.dropFirstNone
    let out := xs.mapM fun _ x => x.head
    
    let xs :=
      if out.isSome
        then xs.map fun _ x => x.tail
        else xs

    (out, xs)

def lshrult_03_05_after := [llvm|
{
^0(%arg330 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def annihilate_xor_common_op_commute2_after := [llvm|
{
^0(%arg3 : i4, %arg4 : i4, %arg5 : i4, %arg6 : i4):
  %0 = llvm.mul %arg5, %arg5 : i4
  %1 = llvm.xor %arg4, %0 : i4
  %2 = llvm.xor %1, %arg6 : i4
  "llvm.return"(%2) : (i4) -> ()
}
]

def xor_i8_to_i64_shl_save_and_ne_before := [llvm|
{
^0(%arg8 : i8, %arg9 : i64):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.mlir.constant(0 : i8) : i8
  %2 = llvm.mlir.constant(-9223372036854775808) : i64
  %3 = llvm.and %arg8, %0 : i8
  %4 = llvm.icmp "ne" %3, %1 : i8
  %5 = llvm.xor %arg9, %2 : i64
  %6 = "llvm.select"(%4, %5, %arg9) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i64, i64) -> i64
  "llvm.return"(%6) : (i64) -> ()
}
]

@[simp_denote]
def trunc_llvm_64_to_32_nuw := [LV| {
  ^entry (%lhs: i64):
    %0 = llvm.trunc %lhs overflow<nuw> : i64 to i32
    llvm.return %0 : i32
  }]

def n10_lshr_ashr_after := [llvm|
{
^0(%arg0 : i32, %arg1 : i16):
  %0 = llvm.mlir.constant(32 : i16) : i16
  %1 = llvm.mlir.constant(-1 : i16) : i16
  %2 = llvm.sub %0, %arg1 : i16
  %3 = llvm.zext nneg %2 : i16 to i32
  %4 = llvm.lshr %arg0, %3 : i32
  %5 = llvm.trunc %4 : i32 to i16
  %6 = llvm.add %arg1, %1 : i16
  %7 = llvm.ashr %5, %6 : i16
  "llvm.return"(%7) : (i16) -> ()
}
]

def no_masks_with_logical_or2_after := [llvm|
{
^0(%arg7 : i32, %arg8 : i32, %arg9 : i32):
  %0 = llvm.mlir.constant(63 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.mlir.constant(true) : i1
  %3 = llvm.icmp "ne" %arg8, %0 : i32
  %4 = llvm.and %arg7, %arg9 : i32
  %5 = llvm.icmp "ne" %4, %1 : i32
  %6 = "llvm.select"(%5, %2, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%6) : (i1) -> ()
}
]

def both_sides_fold_eq_before := [llvm|
{
^0(%arg37 : i32, %arg38 : i1):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(9 : i32) : i32
  %2 = "llvm.select"(%arg38, %0, %arg37) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %3 = "llvm.select"(%arg38, %1, %arg37) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %4 = llvm.icmp "eq" %3, %2 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def negative3_before := [llvm|
{
^0(%arg11 : i32, %arg12 : i32, %arg13 : i32):
  %0 = llvm.mlir.constant(2147483647 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.and %arg13, %0 : i32
  %3 = llvm.icmp "slt" %arg11, %2 : i32
  %4 = llvm.icmp "sge" %arg12, %1 : i32
  %5 = llvm.and %3, %4 : i1
  "llvm.return"(%5) : (i1) -> ()
}
]

def main4e_like_before := [llvm|
{
^0(%arg128 : i32, %arg129 : i32, %arg130 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.mlir.constant(1 : i32) : i32
  %2 = llvm.and %arg128, %arg129 : i32
  %3 = llvm.icmp "eq" %2, %arg129 : i32
  %4 = llvm.and %arg128, %arg130 : i32
  %5 = llvm.icmp "eq" %4, %arg130 : i32
  %6 = llvm.and %3, %5 : i1
  %7 = "llvm.select"(%6, %0, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%7) : (i32) -> ()
}
]

def or_eq_with_one_bit_diff_constants1_logical_before := [llvm|
{
^0(%arg365 : i32):
  %0 = llvm.mlir.constant(50 : i32) : i32
  %1 = llvm.mlir.constant(51 : i32) : i32
  %2 = llvm.mlir.constant(true) : i1
  %3 = llvm.icmp "eq" %arg365, %0 : i32
  %4 = llvm.icmp "eq" %arg365, %1 : i32
  %5 = "llvm.select"(%3, %2, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%5) : (i1) -> ()
}
]

@[simp_denote]
def or_llvm_i16:= [LV| {
    ^entry (%a: i16,%b: i16 ):
    %0 = llvm.or %a, %b : i16
    llvm.return %0 :i16
  }]

def shl_or_with_or_disjoint_instead_of_add_before := [llvm|
{
^0(%arg1 : i8):
  %0 = llvm.mlir.constant(16 : i8) : i8
  %1 = llvm.mlir.constant(1 : i8) : i8
  %2 = llvm.mlir.constant(3 : i8) : i8
  %3 = llvm.shl %0, %arg1 : i8
  %4 = llvm.or disjoint %arg1, %1 : i8
  %5 = llvm.shl %2, %4 : i8
  %6 = llvm.or %3, %5 : i8
  "llvm.return"(%6) : (i8) -> ()
}
]

instance : Functor Signature where
  map := fun f ⟨sig, regSig, returnTypes, effKind⟩ =>
    ⟨f <$> sig, f <$> regSig, f <$> returnTypes, effKind⟩

def select_icmp_eq_and_32_0_xor_8_before := [llvm|
{
^0(%arg237 : i32, %arg238 : i32):
  %0 = llvm.mlir.constant(32 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(8 : i32) : i32
  %3 = llvm.and %arg237, %0 : i32
  %4 = llvm.icmp "eq" %3, %1 : i32
  %5 = llvm.xor %arg238, %2 : i32
  %6 = "llvm.select"(%4, %arg238, %5) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def t2_symmetry_after := [llvm|
{
^0(%arg37 : i8, %arg38 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.xor %arg37, %0 : i8
  %2 = llvm.icmp "ule" %arg38, %1 : i8
  "llvm.return"(%2) : (i1) -> ()
}
]

def test6a_before := [llvm|
{
^0(%arg1 : i1):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.zext %arg1 : i1 to i32
  %2 = llvm.icmp "ne" %1, %0 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def function : Parser :=
  leading_parser argumentList >> arrow >> termParser

def Reachable (M : NFA α σ) : Set σ := λ q ↦ ∃ w, q ∈ M.eval w

def positive_biggerashr_shlnuw_after := [llvm|
{
^0(%arg55 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.mlir.constant(-8 : i8) : i8
  %2 = llvm.ashr %arg55, %0 : i8
  %3 = llvm.and %2, %1 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def lshrult_03_15_exact_after := [llvm|
{
^0(%arg102 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def negate_ashr_after := [llvm|
{
^0(%arg110 : i8, %arg111 : i8):
  %0 = llvm.mlir.constant(7 : i8) : i8
  %1 = llvm.lshr %arg111, %0 : i8
  %2 = llvm.add %1, %arg110 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def test_logical_before := [llvm|
{
^0(%arg0 : i32, %arg1 : i32):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.icmp "slt" %arg0, %arg1 : i32
  %2 = llvm.icmp "eq" %arg0, %arg1 : i32
  %3 = "llvm.select"(%1, %0, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def t7_twoshifts2_before := [llvm|
{
^0(%arg28 : i32, %arg29 : i32, %arg30 : i32, %arg31 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.shl %0, %arg29 : i32
  %3 = llvm.shl %arg30, %arg31 : i32
  %4 = llvm.and %3, %2 : i32
  %5 = llvm.icmp "eq" %4, %1 : i32
  "llvm.return"(%5) : (i1) -> ()
}
]

def sle_swap_and_min_logical_after := [llvm|
{
^0(%arg212 : i8, %arg213 : i8):
  %0 = llvm.mlir.constant(-128 : i8) : i8
  %1 = llvm.icmp "eq" %arg212, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def icmp_eq_x_invertable_y_todo_after := [llvm|
{
^0(%arg10 : i8, %arg11 : i1):
  %0 = llvm.mlir.constant(-8 : i8) : i8
  %1 = llvm.mlir.constant(-25 : i8) : i8
  %2 = llvm.mlir.constant(0 : i8) : i8
  %3 = "llvm.select"(%arg11, %0, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  %4 = llvm.and %arg10, %3 : i8
  %5 = llvm.icmp "eq" %4, %2 : i8
  "llvm.return"(%5) : (i1) -> ()
}
]

def test22_before := [llvm|
{
^0(%arg189 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.mlir.constant(1 : i32) : i32
  %2 = llvm.xor %arg189, %0 : i1
  %3 = llvm.zext %2 : i1 to i32
  %4 = llvm.xor %3, %1 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def uaddo_commute3_before := [llvm|
{
^0(%arg25 : i32, %arg26 : i32, %arg27 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg26, %0 : i32
  %2 = llvm.add %arg25, %arg26 : i32
  %3 = llvm.icmp "ult" %1, %arg25 : i32
  %4 = "llvm.select"(%3, %arg27, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def ule_umax2_after := [llvm|
{
^0(%arg50 : i32, %arg51 : i32):
  %0 = llvm.icmp "ule" %arg51, %arg50 : i32
  "llvm.return"(%0) : (i1) -> ()
}
]

def t7_ashr_before := [llvm|
{
^0(%arg29 : i32, %arg30 : i32):
  %0 = llvm.mlir.constant(32 : i32) : i32
  %1 = llvm.mlir.constant(-2 : i32) : i32
  %2 = llvm.sub %0, %arg30 : i32
  %3 = llvm.ashr exact %arg29, %2 : i32
  %4 = llvm.add %arg30, %1 : i32
  %5 = llvm.ashr %3, %4 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def shl_nuw_add_nsw_nuw_after := [llvm|
{
^0(%arg15 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

def sle_swap_or_not_min_after := [llvm|
{
^0(%arg280 : i8, %arg281 : i8):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def test5_after := [llvm|
{
^0(%arg19 : i19, %arg20 : i19, %arg21 : i19):
  %0 = llvm.sub %arg21, %arg20 : i19
  %1 = llvm.add %0, %arg19 : i19
  "llvm.return"(%1) : (i19) -> ()
}
]

def and_logic_and_logic_or_8_after := [llvm|
{
^0(%arg117 : i1, %arg118 : i1, %arg119 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = "llvm.select"(%arg119, %0, %arg118) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %2 = llvm.and %arg117, %1 : i1
  "llvm.return"(%2) : (i1) -> ()
}
]

def foo_after := [llvm|
{
^0(%arg2 : i32, %arg3 : i32):
  %0 = llvm.mul %arg2, %arg3 : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

def lshrult_03_15_exact_after := [llvm|
{
^0(%arg102 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def positive_samevar_shlnuwnsw_lshrexact_before := [llvm|
{
^0(%arg27 : i8, %arg28 : i8):
  %0 = llvm.lshr exact %arg27, %arg28 : i8
  %1 = llvm.shl %0, %arg28 overflow<nsw,nuw> : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def p_after := [llvm|
{
^0(%arg73 : i32, %arg74 : i32, %arg75 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg75, %0 : i32
  %2 = llvm.or %arg73, %1 : i32
  %3 = llvm.or %arg74, %arg75 : i32
  %4 = llvm.and %2, %3 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def or_nosignbit_select_lshr_before := [llvm|
{
^0(%arg24 : i32, %arg25 : i1):
  %0 = llvm.mlir.constant(2147418112 : i32) : i32
  %1 = llvm.mlir.constant(8 : i32) : i32
  %2 = llvm.or %arg24, %0 : i32
  %3 = "llvm.select"(%arg25, %2, %arg24) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %4 = llvm.lshr %3, %1 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def llvm_freeze_lower_riscv_32 : LLVMPeepholeRewriteRefine 32 [Ty.llvm (.bitvec 32)] where
  lhs := freeze_llvm_32
  rhs := freeze_riscv_32

def masked_icmps_mask_notallzeros_bmask_mixed_7b_after := [llvm|
{
^0(%arg76 : i32):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def lshr_exact_add_nuw_after := [llvm|
{
^0(%arg63 : i32):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.lshr exact %0, %arg63 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

RV64.sh2add in RISCV.Instructions

def a_or_b_before := [llvm|
{
^0(%arg15 : i32, %arg16 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.icmp "eq" %arg15, %0 : i32
  %2 = llvm.icmp "ne" %arg16, %0 : i32
  %3 = llvm.and %1, %2 : i1
  %4 = llvm.icmp "ne" %arg15, %0 : i32
  %5 = llvm.icmp "eq" %arg16, %0 : i32
  %6 = llvm.and %4, %5 : i1
  %7 = llvm.or %3, %6 : i1
  "llvm.return"(%7) : (i1) -> ()
}
]

@[simp, reducible]
def Op.sig : Op → List Ty
  | .li _ => []
  | .mulh  => [Ty.bv, Ty.bv]
  | .mulhu  => [Ty.bv, Ty.bv]
  | .mulhsu  => [Ty.bv, Ty.bv]
  | .divu =>  [Ty.bv, Ty.bv]
  | .remuw  => [Ty.bv, Ty.bv]
  | .remu  =>  [Ty.bv, Ty.bv]
  | .addiw (_imm : BitVec 12) => [Ty.bv]
  | .lui (_imm : BitVec 20) => [Ty.bv]
  | .auipc (_imm : BitVec 20)  => [Ty.bv]
  | .slliw (_shamt : BitVec 5)  => [Ty.bv]
  | .srliw (_shamt : BitVec 5) => [Ty.bv]
  | .sraiw (_shamt : BitVec 5) => [Ty.bv]
  | .slli (_shamt : BitVec 6) => [Ty.bv]
  | .srli (_shamt : BitVec 6) => [Ty.bv]
  | .srai (_shamt : BitVec 6) => [Ty.bv]
  | .addw => [Ty.bv, Ty.bv]
  | .subw => [Ty.bv, Ty.bv]
  | .sllw => [Ty.bv, Ty.bv]
  | .srlw => [Ty.bv, Ty.bv]
  | .sraw => [Ty.bv, Ty.bv]
  | .add => [Ty.bv, Ty.bv]
  | .slt => [Ty.bv, Ty.bv]
  | .sltu => [Ty.bv, Ty.bv]
  | .and => [Ty.bv, Ty.bv]
  | .or => [Ty.bv, Ty.bv]
  | .xor => [Ty.bv, Ty.bv]
  | .sll => [Ty.bv, Ty.bv]
  | .srl => [Ty.bv, Ty.bv]
  | .sub => [Ty.bv, Ty.bv]
  | .sra => [Ty.bv, Ty.bv]
  | .remw  => [Ty.bv, Ty.bv]
  | .rem  =>  [Ty.bv, Ty.bv]
  | .mul => [Ty.bv, Ty.bv]
  | .mulw => [Ty.bv, Ty.bv]
  | .div  =>  [Ty.bv, Ty.bv]
  | .divw  =>  [Ty.bv, Ty.bv]
  | .divuw  =>  [Ty.bv, Ty.bv]
  | .addi (_imm : BitVec 12) => [Ty.bv]
  | .slti (_imm : BitVec 12) => [Ty.bv]
  | .sltiu (_imm : BitVec 12) => [Ty.bv]
  | .andi (_imm : BitVec 12) => [Ty.bv]
  | .ori (_imm : BitVec 12) => [Ty.bv]
  | .xori (_imm : BitVec 12) => [Ty.bv]
  | .bclr => [Ty.bv, Ty.bv]
  | .bext => [Ty.bv, Ty.bv]
  | .binv => [Ty.bv, Ty.bv]
  | .bset  => [Ty.bv, Ty.bv]
  | .bclri (_shamt : BitVec 6) => [Ty.bv]
  | .bexti (_shamt : BitVec 6) => [Ty.bv]
  | .binvi (_shamt : BitVec 6) => [Ty.bv]
  | .bseti (_shamt : BitVec 6) => [Ty.bv]
  | .adduw => [Ty.bv, Ty.bv]
  | .sh1adduw => [Ty.bv, Ty.bv]
  | .sh2adduw => [Ty.bv, Ty.bv]
  | .sh3adduw => [Ty.bv, Ty.bv]
  | .sh1add => [Ty.bv, Ty.bv]
  | .sh2add => [Ty.bv, Ty.bv]
  | .sh3add => [Ty.bv, Ty.bv]
  | .slliuw (_shamt : BitVec 6) => [Ty.bv]
  | .andn => [Ty.bv, Ty.bv]
  | .orn => [Ty.bv, Ty.bv]
  | .xnor => [Ty.bv, Ty.bv]
  | .clz
  | .clzw
  | .ctz
  | .ctzw
  | .max => [Ty.bv, Ty.bv]
  | .maxu => [Ty.bv, Ty.bv]
  | .min  => [Ty.bv, Ty.bv]
  | .minu  => [Ty.bv, Ty.bv]
  | .sextb => [Ty.bv]
  | .sexth => [Ty.bv]
  | .zexth => [Ty.bv]
  | .rol => [Ty.bv, Ty.bv]
  | .rolw => [Ty.bv, Ty.bv]
  | .ror => [Ty.bv, Ty.bv]
  | .rori (_shamt : BitVec 6) =>[Ty.bv]
  | .roriw (_shamt : BitVec 5) =>[Ty.bv]
  | .rorw => [Ty.bv, Ty.bv]
  | .pack => [Ty.bv, Ty.bv]
  | .packh => [Ty.bv, Ty.bv]
  | .packw => [Ty.bv, Ty.bv]
  | .mv => [Ty.bv]
  | .not => [Ty.bv]
  | .neg => [Ty.bv]
  | .negw => [Ty.bv]
  | .sextw => [Ty.bv]
  | .zextb => [Ty.bv]
  | .zextw => [Ty.bv]
  | .seqz => [Ty.bv]
  | .snez => [Ty.bv]
  | .sltz => [Ty.bv]
  | .sgtz => [Ty.bv]

def t4_ugt_slt_65536_after := [llvm|
{
^0(%arg54 : i32, %arg55 : i32, %arg56 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.mlir.constant(65535 : i32) : i32
  %2 = llvm.icmp "slt" %arg54, %0 : i32
  %3 = llvm.icmp "sgt" %arg54, %1 : i32
  %4 = "llvm.select"(%2, %arg55, %arg54) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %5 = "llvm.select"(%3, %arg56, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def or_not_and_commute9_after := [llvm|
{
^0(%arg510 : i32, %arg511 : i32, %arg512 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.sdiv %0, %arg510 : i32
  %3 = llvm.sdiv %0, %arg511 : i32
  %4 = llvm.sdiv %0, %arg512 : i32
  %5 = llvm.xor %3, %4 : i32
  %6 = llvm.xor %2, %1 : i32
  %7 = llvm.and %5, %6 : i32
  "llvm.return"(%7) : (i32) -> ()
}
]

def land_land_left2_before := [llvm|
{
^0(%arg100 : i1, %arg101 : i1):
  %0 = llvm.mlir.constant(false) : i1
  %1 = "llvm.select"(%arg101, %arg100, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %2 = "llvm.select"(%1, %arg100, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%2) : (i1) -> ()
}
]

def factorize4_before := [llvm|
{
^0(%arg3 : i32, %arg4 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.shl %arg4, %0 : i32
  %2 = llvm.mul %1, %arg3 : i32
  %3 = llvm.mul %arg3, %arg4 : i32
  %4 = llvm.sub %2, %3 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def test3_before := [llvm|
{
^0(%arg307 : i1):
  %0 = llvm.mlir.constant(false) : i1
  %1 = llvm.and %arg307, %0 : i1
  "llvm.return"(%1) : (i1) -> ()
}
]

def ashrsgt_02_07_before := [llvm|
{
^0(%arg294 : i4):
  %0 = llvm.mlir.constant(2 : i4) : i4
  %1 = llvm.mlir.constant(7 : i4) : i4
  %2 = llvm.ashr %arg294, %0 : i4
  %3 = llvm.icmp "sgt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def neg_of_add_with_constant_after := [llvm|
{
^0(%arg171 : i8):
  %0 = llvm.mlir.constant(-42 : i8) : i8
  %1 = llvm.sub %0, %arg171 : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def lshr_shl_pow2_const_case1_after := [llvm|
{
^0(%arg60 : i16):
  %0 = llvm.mlir.constant(7 : i16) : i16
  %1 = llvm.mlir.constant(8 : i16) : i16
  %2 = llvm.mlir.constant(0 : i16) : i16
  %3 = llvm.icmp "eq" %arg60, %0 : i16
  %4 = "llvm.select"(%3, %1, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i16, i16) -> i16
  "llvm.return"(%4) : (i16) -> ()
}
]

def test19_commutative0_before := [llvm|
{
^0(%arg74 : i32, %arg75 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.shl %0, %arg74 : i32
  %2 = llvm.shl %0, %arg75 : i32
  %3 = llvm.and %2, %1 : i32
  %4 = llvm.add %3, %1 : i32
  %5 = llvm.urem %arg75, %4 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def not_signbit_zext_before := [llvm|
{
^0(%arg17 : i16):
  %0 = llvm.mlir.constant(-1 : i16) : i16
  %1 = llvm.mlir.constant(15 : i16) : i16
  %2 = llvm.xor %arg17, %0 : i16
  %3 = llvm.lshr %2, %1 : i16
  %4 = llvm.zext %3 : i16 to i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def no_shift_no_xor_multiuse_or_after := [llvm|
{
^0(%arg140 : i32, %arg141 : i32):
  %0 = llvm.mlir.constant(4096 : i32) : i32
  %1 = llvm.and %arg140, %0 : i32
  %2 = llvm.or %arg141, %0 : i32
  %3 = llvm.or %arg141, %1 : i32
  %4 = llvm.mul %3, %2 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def commutativity_constant_6_vary_invmask_before := [llvm|
{
^0(%arg16 : i4, %arg17 : i4):
  %0 = llvm.mlir.constant(-1 : i4) : i4
  %1 = llvm.mlir.constant(6 : i4) : i4
  %2 = llvm.xor %arg17, %0 : i4
  %3 = llvm.xor %arg16, %1 : i4
  %4 = llvm.and %2, %3 : i4
  %5 = llvm.xor %4, %arg16 : i4
  "llvm.return"(%5) : (i4) -> ()
}
]

def lshrult_03_07_exact_before := [llvm|
{
^0(%arg110 : i4):
  %0 = llvm.mlir.constant(3 : i4) : i4
  %1 = llvm.mlir.constant(7 : i4) : i4
  %2 = llvm.lshr exact %arg110, %0 : i4
  %3 = llvm.icmp "ult" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

instance : MLIR.AST.TransformExpr (HSxComb) 0 where
  mkExpr := mkExpr

def scalar_i32_lshr_and_negC_eq_X_is_constant1_before := [llvm|
{
^0(%arg9 : i32):
  %0 = llvm.mlir.constant(12345 : i32) : i32
  %1 = llvm.mlir.constant(-8 : i32) : i32
  %2 = llvm.mlir.constant(0 : i32) : i32
  %3 = llvm.lshr %0, %arg9 : i32
  %4 = llvm.and %3, %1 : i32
  %5 = llvm.icmp "eq" %4, %2 : i32
  "llvm.return"(%5) : (i1) -> ()
}
]

def slt_zero_sgt_minus1_after := [llvm|
{
^0(%arg22 : i4, %arg23 : i4):
  %0 = llvm.mlir.constant(-1 : i4) : i4
  %1 = llvm.xor %arg22, %arg23 : i4
  %2 = llvm.icmp "sgt" %1, %0 : i4
  "llvm.return"(%2) : (i1) -> ()
}
]

def mulo_by_2_unsigned_signed : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%x: i64):
      %c = llvm.mlir.constant (2) : i64
      %0 = llvm.mul %x, %c overflow<nsw, nuw> : i64
      llvm.return %0 : i64
  }]
  rhs := [LV| {
    ^entry (%x: i64):
      %0 = llvm.add %x, %x overflow<nsw, nuw> : i64
      llvm.return %0 : i64
  }]

def test4_before := [llvm|
{
^0(%arg305 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.and %arg305, %0 : i1
  "llvm.return"(%1) : (i1) -> ()
}
]

def shl_trunc_bigger_ashr_after := [llvm|
{
^0(%arg42 : i32):
  %0 = llvm.mlir.constant(9 : i32) : i32
  %1 = llvm.mlir.constant(-8 : i24) : i24
  %2 = llvm.ashr %arg42, %0 : i32
  %3 = llvm.trunc %2 overflow<nsw> : i32 to i24
  %4 = llvm.and %3, %1 : i24
  "llvm.return"(%4) : (i24) -> ()
}
]

def sub_to_add_5 : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%x: i64):
      %c = llvm.mlir.constant 5 : i64
      %1 = llvm.sub %x, %c : i64
      llvm.return %1 : i64
  }]
  rhs := [LV| {
    ^entry (%x: i64):
      %c = llvm.mlir.constant -5 : i64
      %1 = llvm.add %x, %c : i64
      llvm.return %1 : i64
  }]

def alive_Select_1105_src  (w : Nat)   :=
[llvm( w )| {
^bb0(%Y : _, %X : _):
  %v1 = llvm.mlir.constant 0 :  i1
  %v2 = llvm.select %v1,%X, %Y
  llvm.return %v2
}]

@[simp_denote]
def sltu_riscv_i32 :=
  [LV| {
    ^entry (%arg0: i32, %arg1: i32):
    %a = "builtin.unrealized_conversion_cast" (%arg0) : (i32) -> (!i64)
    %b = "builtin.unrealized_conversion_cast" (%arg1) : (i32) -> (!i64)
    %0 = "sext.w" (%a) : (!i64) -> (!i64)
    %1 = "sext.w" (%b) : (!i64) -> (!i64)
    %2 = sltu %0, %1 : !i64
    %3 = "builtin.unrealized_conversion_cast" (%2) : (!i64) -> (i32)
    llvm.return %3 : i32
  }]

def t0_after := [llvm|
{
^0(%arg30 : i1, %arg31 : i8, %arg32 : i8, %arg33 : i8, %arg34 : i8):
  %0 = llvm.icmp "ne" %arg31, %arg32 : i8
  %1 = llvm.and %0, %arg30 : i1
  %2 = "llvm.select"(%1, %arg34, %arg33) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def ashrsgt_03_09_after := [llvm|
{
^0(%arg276 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def or_xor_tree_0111_after := [llvm|
{
^0(%arg24 : i32, %arg25 : i32, %arg26 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mul %arg24, %0 : i32
  %2 = llvm.mul %arg25, %0 : i32
  %3 = llvm.mul %arg26, %0 : i32
  %4 = llvm.xor %2, %1 : i32
  %5 = llvm.or %4, %3 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def prettifyBVBinPred (op : BVBinPred) : String :=
  match op with
  | .eq => "="
  | _ => op.toString

def lshr_pow2_ugt_after := [llvm|
{
^0(%arg72 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.icmp "eq" %arg72, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def and_or_not_not_commute6_before := [llvm|
{
^0(%arg357 : i32, %arg358 : i32, %arg359 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.sdiv %0, %arg358 : i32
  %3 = llvm.and %2, %arg357 : i32
  %4 = llvm.xor %3, %1 : i32
  %5 = llvm.and %arg359, %arg357 : i32
  %6 = llvm.xor %5, %1 : i32
  %7 = llvm.or %2, %6 : i32
  %8 = llvm.and %7, %4 : i32
  "llvm.return"(%8) : (i32) -> ()
}
]

def n11_before := [llvm|
{
^0(%arg5 : i32, %arg6 : i16):
  %0 = llvm.mlir.constant(30 : i16) : i16
  %1 = llvm.mlir.constant(-31 : i16) : i16
  %2 = llvm.sub %0, %arg6 : i16
  %3 = llvm.zext %2 : i16 to i32
  %4 = llvm.shl %arg5, %3 : i32
  %5 = llvm.trunc %4 : i32 to i16
  %6 = llvm.add %arg6, %1 : i16
  %7 = llvm.shl %5, %6 : i16
  "llvm.return"(%7) : (i16) -> ()
}
]

def test5_before := [llvm|
{
^0(%arg205 : i32):
  %0 = llvm.mlir.constant(123 : i32) : i32
  %1 = llvm.or %arg205, %0 : i32
  %2 = llvm.xor %1, %0 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def fold_icmp_shl_nuw_c2_precondition1_after := [llvm|
{
^0(%arg2 : i32):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def ashrslt_03_01_exact_after := [llvm|
{
^0(%arg20 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

@[simp_denote]
def lshr_llvm_exact_64 := [LV| {
  ^entry (%x: i64, %amount: i64):
    %1 = llvm.lshr exact %x, %amount : i64
    llvm.return %1 : i64
  }]

def sext_xor_sub_3_after := [llvm|
{
^0(%arg22 : i64, %arg23 : i1):
  %0 = llvm.mlir.constant(0) : i64
  %1 = llvm.sub %0, %arg22 : i64
  %2 = "llvm.select"(%arg23, %arg22, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i64, i64) -> i64
  "llvm.return"(%2) : (i64) -> ()
}
]

def test12_after := [llvm|
{
^0(%arg42 : i1):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def or_xor_common_op_commute5_after := [llvm|
{
^0(%arg120 : i8, %arg121 : i8, %arg122 : i8):
  %0 = llvm.or %arg121, %arg120 : i8
  %1 = llvm.or %0, %arg122 : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def and_zext_eq_odd_commuted_after := [llvm|
{
^0(%arg30 : i32):
  %0 = llvm.mlir.constant(3 : i32) : i32
  %1 = llvm.icmp "eq" %arg30, %0 : i32
  %2 = llvm.zext %1 : i1 to i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def not_invert_signbit_splat_mask2_before := [llvm|
{
^0(%arg81 : i8, %arg82 : i16):
  %0 = llvm.mlir.constant(6 : i8) : i8
  %1 = llvm.mlir.constant(-1 : i8) : i8
  %2 = llvm.ashr %arg81, %0 : i8
  %3 = llvm.xor %2, %1 : i8
  %4 = llvm.sext %3 : i8 to i16
  %5 = llvm.and %4, %arg82 : i16
  "llvm.return"(%5) : (i16) -> ()
}
]

def liftEffect_compose {e1 e2 e3 : EffectKind} {α : Type} [Pure m]
    (h12 : e1 ≤ e2)
    (h23 : e2 ≤ e3)
    (h13 : e1 ≤ e3 := le_trans h12 h23) :
    ((liftEffect (α := α) h23) ∘ (liftEffect h12)) = liftEffect (m := m) h13 :=

def exactly_one_set_signbit_wrong_pred_after := [llvm|
{
^0(%arg28 : i8, %arg29 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.and %arg29, %arg28 : i8
  %2 = llvm.icmp "slt" %1, %0 : i8
  "llvm.return"(%2) : (i1) -> ()
}
]

def uge_swap_and_max_commute_before := [llvm|
{
^0(%arg226 : i8, %arg227 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.icmp "ule" %arg227, %arg226 : i8
  %2 = llvm.icmp "eq" %arg226, %0 : i8
  %3 = llvm.and %2, %1 : i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def logic_and_logic_or_7_before := [llvm|
{
^0(%arg159 : i1, %arg160 : i1, %arg161 : i1):
  %0 = llvm.mlir.constant(false) : i1
  %1 = llvm.mlir.constant(true) : i1
  %2 = "llvm.select"(%arg160, %arg159, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %3 = "llvm.select"(%arg161, %arg159, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %4 = "llvm.select"(%3, %1, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def not_or_or_and_no_and_before := [llvm|
{
^0(%arg121 : i32, %arg122 : i32, %arg123 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.and %arg122, %arg121 : i32
  %2 = llvm.xor %1, %0 : i32
  %3 = llvm.xor %arg121, %0 : i32
  %4 = llvm.or %3, %arg122 : i32
  %5 = llvm.or %4, %arg123 : i32
  %6 = llvm.and %5, %2 : i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def shl_nsw_add_negative_before := [llvm|
{
^0(%arg45 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.mlir.constant(2 : i32) : i32
  %2 = llvm.add %arg45, %0 : i32
  %3 = llvm.shl %1, %2 overflow<nsw> : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def lshrult_03_07_after := [llvm|
{
^0(%arg328 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def bools2_logical_commute0_before := [llvm|
{
^0(%arg64 : i1, %arg65 : i1, %arg66 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.mlir.constant(false) : i1
  %2 = llvm.xor %arg66, %0 : i1
  %3 = "llvm.select"(%arg66, %arg64, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %4 = "llvm.select"(%2, %arg65, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %5 = "llvm.select"(%3, %0, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%5) : (i1) -> ()
}
]

def t0_before := [llvm|
{
^0(%arg224 : i8):
  %0 = llvm.mlir.constant(-42 : i8) : i8
  %1 = llvm.sub %arg224, %0 : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def add_nosignbit_select_shl_before := [llvm|
{
^0(%arg32 : i32, %arg33 : i1):
  %0 = llvm.mlir.constant(2147418112 : i32) : i32
  %1 = llvm.mlir.constant(8 : i32) : i32
  %2 = llvm.add %arg32, %0 : i32
  %3 = "llvm.select"(%arg33, %2, %arg32) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %4 = llvm.shl %3, %1 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def consLeft : MatchVarResult lets v matchLets w mapIn :=
  ⟨mapOut.val, by
    rcases mapOut with ⟨mapOut, ⟨mapIn', mapOut', h_entries_in, h_entries_out, h⟩⟩
    change StateT.run _ _ = _ at h
    obtain ⟨⟨⟩, mapOut'', h₁, h₂⟩ :=

def test47_before := [llvm|
{
^0(%arg139 : i8):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.sext %arg139 : i8 to i32
  %2 = llvm.or %1, %0 : i32
  %3 = llvm.zext %2 : i32 to i64
  "llvm.return"(%3) : (i64) -> ()
}
]

Array.emptyWithCapacity in Init.Prelude

def select_sub_icmp_after := [llvm|
{
^0(%arg214 : i32, %arg215 : i32, %arg216 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.icmp "eq" %arg214, %0 : i32
  %2 = "llvm.select"(%1, %arg216, %arg215) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def xor_andn_commute4_after := [llvm|
{
^0(%arg66 : i32, %arg67 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.udiv %0, %arg66 : i32
  %2 = llvm.udiv %0, %arg67 : i32
  %3 = llvm.or %1, %2 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def test67_before := [llvm|
{
^0(%arg113 : i1, %arg114 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(24 : i32) : i32
  %2 = llvm.mlir.constant(-16777216 : i32) : i32
  %3 = llvm.mlir.constant(0 : i8) : i8
  %4 = llvm.zext %arg113 : i1 to i32
  %5 = llvm.xor %4, %0 : i32
  %6 = llvm.and %arg114, %5 : i32
  %7 = llvm.shl %6, %1 overflow<nsw,nuw> : i32
  %8 = llvm.xor %7, %2 : i32
  %9 = llvm.ashr exact %8, %1 : i32
  %10 = llvm.trunc %9 : i32 to i8
  %11 = llvm.icmp "eq" %10, %3 : i8
  "llvm.return"(%11) : (i1) -> ()
}
]

def neg_not_signbit2_before := [llvm|
{
^0(%arg4 : i8):
  %0 = llvm.mlir.constant(6 : i8) : i8
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.lshr %arg4, %0 : i8
  %3 = llvm.zext %2 : i8 to i32
  %4 = llvm.sub %1, %3 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def src_srem_shl_demand_min_signbit_mask_hit_last_demand_after := [llvm|
{
^0(%arg20 : i32):
  %0 = llvm.mlir.constant(536870912 : i32) : i32
  %1 = llvm.mlir.constant(1 : i32) : i32
  %2 = llvm.mlir.constant(-1073741822 : i32) : i32
  %3 = llvm.srem %arg20, %0 : i32
  %4 = llvm.shl %3, %1 overflow<nsw> : i32
  %5 = llvm.and %4, %2 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def trunc_equality_nsw_zext_after := [llvm|
{
^0(%arg16 : i32, %arg17 : i8):
  %0 = llvm.zext %arg17 : i8 to i32
  %1 = llvm.icmp "ne" %arg16, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def irc_constants_C2MinusAPlusC1_2_neg1 : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%a: i64):
      %c1 = llvm.mlir.constant (2) : i64
      %c2 = llvm.mlir.constant (-1) : i64
      %0 = llvm.add %a, %c1 : i64
      %1 = llvm.sub %c2, %0 : i64
      llvm.return %1 : i64
  }]
  rhs := [LV| {
    ^entry (%a: i64):
      %c1 = llvm.mlir.constant (2) : i64
      %c2 = llvm.mlir.constant (-1) : i64
      %0 = llvm.sub %c2, %c1 : i64
      %1 = llvm.sub %0, %a : i64
      llvm.return %1 : i64
  }]

def bitwise_or_logical_or_icmps_after := [llvm|
{
^0(%arg184 : i8, %arg185 : i8, %arg186 : i8):
  %0 = llvm.mlir.constant(42 : i8) : i8
  %1 = llvm.mlir.constant(1 : i8) : i8
  %2 = llvm.mlir.constant(true) : i1
  %3 = llvm.icmp "eq" %arg185, %0 : i8
  %4 = llvm.shl %1, %arg186 overflow<nuw> : i8
  %5 = llvm.or %4, %1 : i8
  %6 = llvm.and %arg184, %5 : i8
  %7 = llvm.icmp "ne" %6, %5 : i8
  %8 = "llvm.select"(%3, %2, %7) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%8) : (i1) -> ()
}
]

def liRiscv37 := [LV| {
  ^entry ():
    %0 = "li"() {imm = 37 : !i64} : (!i64) -> (!i64)
    %1 = "builtin.unrealized_conversion_cast"(%0) : (!i64) -> (i64)
    llvm.return %1 : i64
  }]

def PR42691_7_logical_before := [llvm|
{
^0(%arg330 : i32):
  %0 = llvm.mlir.constant(-2147483647 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(true) : i1
  %3 = llvm.icmp "uge" %arg330, %0 : i32
  %4 = llvm.icmp "eq" %arg330, %1 : i32
  %5 = "llvm.select"(%3, %2, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%5) : (i1) -> ()
}
]

def test_with_1_after := [llvm|
{
^0(%arg317 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.icmp "eq" %arg317, %0 : i32
  %2 = llvm.zext %1 : i1 to i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def ashrsgt_03_00_before := [llvm|
{
^0(%arg285 : i4):
  %0 = llvm.mlir.constant(3 : i4) : i4
  %1 = llvm.mlir.constant(0 : i4) : i4
  %2 = llvm.ashr %arg285, %0 : i4
  %3 = llvm.icmp "sgt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def udiv_shl_mul_nuw_before := [llvm|
{
^0(%arg148 : i5, %arg149 : i5, %arg150 : i5):
  %0 = llvm.shl %arg148, %arg150 overflow<nuw> : i5
  %1 = llvm.mul %arg148, %arg149 overflow<nuw> : i5
  %2 = llvm.udiv %0, %1 : i5
  "llvm.return"(%2) : (i5) -> ()
}
]

def lshrult_03_09_before := [llvm|
{
^0(%arg326 : i4):
  %0 = llvm.mlir.constant(3 : i4) : i4
  %1 = llvm.mlir.constant(-7 : i4) : i4
  %2 = llvm.lshr %arg326, %0 : i4
  %3 = llvm.icmp "ult" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def ult_rem_zero_after := [llvm|
{
^0(%arg174 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.icmp "ult" %arg174, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def masked_or_allzeroes_notoptimised_logical_after := [llvm|
{
^0(%arg116 : i32):
  %0 = llvm.mlir.constant(15 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(39 : i32) : i32
  %3 = llvm.and %arg116, %0 : i32
  %4 = llvm.icmp "eq" %3, %1 : i32
  %5 = llvm.and %arg116, %2 : i32
  %6 = llvm.icmp "eq" %5, %1 : i32
  %7 = llvm.or %4, %6 : i1
  "llvm.return"(%7) : (i1) -> ()
}
]

def mul_add_to_mul_6_before := [llvm|
{
^0(%arg26 : i32, %arg27 : i32):
  %0 = llvm.mlir.constant(5 : i32) : i32
  %1 = llvm.mul %arg26, %arg27 overflow<nsw> : i32
  %2 = llvm.mul %1, %0 overflow<nsw> : i32
  %3 = llvm.add %1, %2 overflow<nsw> : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def land_land_right1_before := [llvm|
{
^0(%arg54 : i1, %arg55 : i1):
  %0 = llvm.mlir.constant(false) : i1
  %1 = "llvm.select"(%arg54, %arg55, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %2 = "llvm.select"(%arg54, %1, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%2) : (i1) -> ()
}
]

def neg_mask_before := [llvm|
{
^0(%arg1 : i32, %arg2 : i16):
  %0 = llvm.mlir.constant(15 : i16) : i16
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.sext %arg2 : i16 to i32
  %3 = llvm.sub %arg1, %2 overflow<nsw> : i32
  %4 = llvm.lshr %arg2, %0 : i16
  %5 = llvm.zext %4 : i16 to i32
  %6 = llvm.sub %1, %5 overflow<nsw> : i32
  %7 = llvm.and %3, %6 : i32
  "llvm.return"(%7) : (i32) -> ()
}
]

def trunc_shl_lshr_infloop_before := [llvm|
{
^0(%arg26 : i64):
  %0 = llvm.mlir.constant(1) : i64
  %1 = llvm.mlir.constant(2) : i64
  %2 = llvm.lshr %arg26, %0 : i64
  %3 = llvm.shl %2, %1 : i64
  %4 = llvm.trunc %3 : i64 to i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def irc_constants_AMinusC1MinusC2_0_neg1 : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%a: i64):
      %c1 = llvm.mlir.constant (0) : i64
      %c2 = llvm.mlir.constant (-1) : i64
      %0 = llvm.sub %a, %c1 : i64
      %1 = llvm.sub %0, %c2 : i64
      llvm.return %1 : i64
  }]
  rhs := [LV| {
    ^entry (%a: i64):
      %c1 = llvm.mlir.constant (0) : i64
      %c2 = llvm.mlir.constant (-1) : i64
      %0 = llvm.add %c1, %c2 : i64
      %1 = llvm.sub %a, %0 : i64
      llvm.return %1 : i64
  }]

def not_or_or_and_not_and_and_commute4_before := [llvm|
{
^0(%arg184 : i32, %arg185 : i32, %arg186 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.sdiv %0, %arg186 : i32
  %3 = llvm.and %arg185, %arg184 : i32
  %4 = llvm.and %3, %2 : i32
  %5 = llvm.xor %4, %1 : i32
  %6 = llvm.xor %arg184, %1 : i32
  %7 = llvm.or %6, %arg185 : i32
  %8 = llvm.or %2, %7 : i32
  %9 = llvm.and %8, %5 : i32
  "llvm.return"(%9) : (i32) -> ()
}
]

def test6a_after := [llvm|
{
^0(%arg1 : i1):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def t1_after := [llvm|
{
^0(%arg16 : i8):
  %0 = llvm.mlir.constant(5 : i8) : i8
  %1 = llvm.ashr %arg16, %0 : i8
  %2 = llvm.sext %1 : i8 to i16
  "llvm.return"(%2) : (i16) -> ()
}
]

def add {Γ : Ctxt _} (e₁ e₂ : Var Γ .nat) : Expr Γ .nat :=
  Expr.mk
    (op := .add)
    (ty_eq := rfl)
    (eff_le := EffectKind.le_refl _)
    (args := .cons e₁ <| .cons e₂ .nil)
    (regArgs := .nil)

def main4f_like_logical_after := [llvm|
{
^0(%arg115 : i32, %arg116 : i32, %arg117 : i32):
  %0 = llvm.mlir.constant(false) : i1
  %1 = llvm.and %arg115, %arg116 : i32
  %2 = llvm.icmp "eq" %1, %arg116 : i32
  %3 = llvm.and %arg115, %arg117 : i32
  %4 = llvm.icmp "eq" %3, %arg117 : i32
  %5 = "llvm.select"(%2, %4, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %6 = llvm.zext %5 : i1 to i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def n2_before := [llvm|
{
^0(%arg0 : i8, %arg1 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.mlir.constant(1 : i8) : i8
  %2 = llvm.shl %0, %arg1 : i8
  %3 = llvm.xor %2, %1 : i8
  %4 = llvm.and %3, %arg0 : i8
  %5 = llvm.icmp "eq" %4, %arg0 : i8
  "llvm.return"(%5) : (i1) -> ()
}
]

def llvm_add_lower_riscv_nuw_nsw_flag_1 : LLVMPeepholeRewriteRefine 1 [Ty.llvm (.bitvec 1), Ty.llvm (.bitvec 1)] where
  lhs:= add_llvm_nsw_nuw_flags_1
  rhs:= add_riscv_1

Sum.inr in Init.Core

def masked_icmps_mask_notallzeros_bmask_mixed_swapped_1_before := [llvm|
{
^0(%arg50 : i32):
  %0 = llvm.mlir.constant(12 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(7 : i32) : i32
  %3 = llvm.mlir.constant(1 : i32) : i32
  %4 = llvm.and %arg50, %0 : i32
  %5 = llvm.icmp "ne" %4, %1 : i32
  %6 = llvm.and %arg50, %2 : i32
  %7 = llvm.icmp "eq" %6, %3 : i32
  %8 = llvm.and %7, %5 : i1
  "llvm.return"(%8) : (i1) -> ()
}
]

def a_before := [llvm|
{
^0(%arg48 : i1, %arg49 : i1):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.mlir.constant(1 : i32) : i32
  %2 = llvm.zext %arg48 : i1 to i32
  %3 = llvm.zext %arg49 : i1 to i32
  %4 = llvm.sub %0, %3 : i32
  %5 = llvm.add %2, %1 : i32
  %6 = llvm.add %5, %4 : i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def add_nsw_const_const_sub_before := [llvm|
{
^0(%arg59 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.mlir.constant(-127 : i8) : i8
  %2 = llvm.add %arg59, %0 overflow<nsw> : i8
  %3 = llvm.sub %1, %2 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def t0_ult_slt_65536_before := [llvm|
{
^0(%arg66 : i32, %arg67 : i32, %arg68 : i32):
  %0 = llvm.mlir.constant(65536 : i32) : i32
  %1 = llvm.icmp "slt" %arg66, %0 : i32
  %2 = "llvm.select"(%1, %arg67, %arg68) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %3 = llvm.icmp "ult" %arg66, %0 : i32
  %4 = "llvm.select"(%3, %arg66, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%4) : (i32) -> ()
}
]

@[simp_denote]
def ori_llvm := [LV| {
    ^entry (%a: i16):
    %0 = llvm.mlir.constant (5) : i16
    %1 = llvm.or %a, %0 : i16
    llvm.return %1 :i16
  }]

def positive_biggerShl_before := [llvm|
{
^0(%arg34 : i32):
  %0 = llvm.mlir.constant(10 : i32) : i32
  %1 = llvm.mlir.constant(5 : i32) : i32
  %2 = llvm.shl %arg34, %0 : i32
  %3 = llvm.lshr %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def src_x_and_nmask_ult_before := [llvm|
{
^0(%arg24 : i8, %arg25 : i8, %arg26 : i1):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.mlir.constant(0 : i8) : i8
  %2 = llvm.shl %0, %arg25 : i8
  %3 = "llvm.select"(%arg26, %2, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  %4 = llvm.and %arg24, %3 : i8
  %5 = llvm.icmp "ult" %4, %3 : i8
  "llvm.return"(%5) : (i1) -> ()
}
]

def andcond.010.inv.inner.cond.in.inner.sel_before := [llvm|
{
^0(%arg65 : i1, %arg66 : i1, %arg67 : i1, %arg68 : i1, %arg69 : i1):
  %0 = llvm.mlir.constant(false) : i1
  %1 = llvm.mlir.constant(true) : i1
  %2 = "llvm.select"(%arg65, %arg66, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %3 = llvm.xor %arg65, %1 : i1
  %4 = "llvm.select"(%3, %arg68, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %5 = "llvm.select"(%2, %arg69, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%5) : (i1) -> ()
}
]

def ashrsgt_02_06_before := [llvm|
{
^0(%arg295 : i4):
  %0 = llvm.mlir.constant(2 : i4) : i4
  %1 = llvm.mlir.constant(6 : i4) : i4
  %2 = llvm.ashr %arg295, %0 : i4
  %3 = llvm.icmp "sgt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def canonicalize_logic_first_or0_nswnuw_before := [llvm|
{
^0(%arg38 : i32):
  %0 = llvm.mlir.constant(112 : i32) : i32
  %1 = llvm.mlir.constant(15 : i32) : i32
  %2 = llvm.add %arg38, %0 overflow<nsw,nuw> : i32
  %3 = llvm.or %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def or_ugt_before := [llvm|
{
^0(%arg58 : i8, %arg59 : i8):
  %0 = llvm.or %arg58, %arg59 : i8
  %1 = llvm.icmp "ugt" %0, %arg58 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def ult_swap_or_not_max_logical_before := [llvm|
{
^0(%arg36 : i8, %arg37 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.mlir.constant(true) : i1
  %2 = llvm.icmp "ugt" %arg37, %arg36 : i8
  %3 = llvm.icmp "ne" %arg36, %0 : i8
  %4 = "llvm.select"(%2, %1, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def simplify_and_common_op_commute1_before := [llvm|
{
^0(%arg29 : i4, %arg30 : i4, %arg31 : i4):
  %0 = llvm.mlir.constant(-1 : i4) : i4
  %1 = llvm.or %arg30, %arg29 : i4
  %2 = llvm.or %1, %arg31 : i4
  %3 = llvm.xor %2, %0 : i4
  %4 = llvm.and %3, %arg29 : i4
  "llvm.return"(%4) : (i4) -> ()
}
]

def t9_ashr_exact_flag_preservation_after := [llvm|
{
^0(%arg25 : i32, %arg26 : i32):
  %0 = llvm.mlir.constant(30 : i32) : i32
  %1 = llvm.ashr exact %arg25, %0 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

Language.instMembershipList in Mathlib.Computability.Language
</all_available_defs>

<all_available_lemmas>
Fin.coe_cast in Init.Data.Fin.Lemmas
List.getElem?_append in Init.Data.List.Lemmas
List.getElem?_ofFn in Init.Data.List.OfFn
List.getElem_append_right in Init.Data.List.BasicAux
List.length_append in Init.Data.List.Basic
Nat.ge_of_not_lt in Init.Data.Nat.Basic
Option.dite_none_right_eq_some in Init.Data.Option.Lemmas
Valuation.ext in Mathlib.RingTheory.Valuation.Basic
dite_eq_ite in Init.ByCases

@[simp] theorem ofList_append {ts us : List Ty} :
    Ctxt.ofList ts ++ Ctxt.ofList us = Ctxt.ofList (ts ++ us)

@[simp, grind=] theorem length_ofList : (ofList ts).length = ts.length

@[simp, grind=] theorem getElem?_ofList (i : Nat) : (ofList ts)[i]? = ts[i]?

@[simp, grind=] theorem getElem_ofList (i : Nat) (h : _) : (ofList ts)[i]'h = ts[i]'h

theorem positive_sameconst_ashrexact_proof : positive_sameconst_ashrexact_before ⊑ positive_sameconst_ashrexact_after

theorem test_with_3_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬x ≥ ↑32 → 3#32 <<< x &&& 1#32 = zeroExtend 32 (ofBool (x == 0#32))

theorem unsigned_sign_bit_extract_with_trunc_thm.extracted_1._1 : ∀ (x : BitVec 64),
  ¬63#64 ≥ ↑64 → ofBool (truncate 32 (x >>> 63#64) != 0#32) = ofBool (x <ₛ 0#64)

theorem sext_thm.extracted_1._1 : ∀ (x : BitVec 1), x = 1#1 → -1#41 = signExtend 41 x

theorem add_or_sub_comb_i8_commuted2_nsw_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬(True ∧ (x * x).saddOverflow (0#8 - x * x ||| x * x) = true) → True ∧ (x * x).saddOverflow (-1#8) = true → False

theorem ashrsgt_02_02_proof : ashrsgt_02_02_before ⊑ ashrsgt_02_02_after

theorem tryFactorization_xor_lshr_ashr_thm (e : IntW 32) :
  LLVM.xor (lshr (const? 32 5) e) (ashr (const? 32 (-3)) e) ⊑ ashr (const? 32 (-8)) e

theorem both_thm (e e_1 : IntW 8) :
  icmp IntPred.ugt (shl (const? 8 1) e_1) (shl (const? 8 1) e) ⊑
    icmp IntPred.eq (lshr (shl (const? 8 1) e { «nsw» := false, «nuw» := true }) e_1) (const? 8 0)

theorem or_xor_tree_1010_thm (e e_1 e_2 : IntW 32) :
  LLVM.or (LLVM.xor (LLVM.xor (mul e_2 (const? 32 42)) (mul e_1 (const? 32 42))) (mul e (const? 32 42)))
      (LLVM.xor (mul e (const? 32 42)) (mul e_1 (const? 32 42))) ⊑
    LLVM.or (LLVM.xor (mul e (const? 32 42)) (mul e_1 (const? 32 42))) (mul e_2 (const? 32 42))

theorem e_320 :
     - 7 *  ~~~x + 1 * x + 7 *  ~~~(x &&&  ~~~x) + 1 *  ~~~(x ||| y) + 1 *  ~~~(x |||  ~~~y) - 7 * (x &&&  ~~~y) - 8 * (x &&& y) = 1 *  ~~~(x &&& y)

theorem lshrugt_01_01_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬1#4 ≥ ↑4 → ofBool (1#4 <ᵤ x >>> 1#4) = ofBool (3#4 <ᵤ x)

theorem or_to_nxor1_proof : or_to_nxor1_before ⊑ or_to_nxor1_after

theorem add_of_selects_thm.extracted_1._3 : ∀ (x : BitVec 32) (x_1 : BitVec 1),
  ¬x_1 = 1#1 → BitVec.ofInt 32 (-2) + 2#32 = 0#32

theorem mul_constant_eq_nsw_proof : mul_constant_eq_nsw_before ⊑ mul_constant_eq_nsw_after

theorem main3e_like_logical_thm.extracted_1._4 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (x_1 &&& x == 0#32) = 1#1 → ¬ofBool (x_1 &&& x != 0#32) = 1#1 → ¬0#1 = 1#1 → False

theorem shl_and_thm (e e_1 : IntW 8) :
  shl (LLVM.and (shl e_1 (const? 8 3)) e) (const? 8 2) ⊑ LLVM.and (shl e_1 (const? 8 5)) (shl e (const? 8 2))

theorem test19_proof : test19_before ⊑ test19_after

@[simp] theorem Com.denoteLets_returnVars (c : Com d Γ .pure tys) (V : Valuation Γ) :
    c.returnVars.map (c.denoteLets V) = c.denote V

@[simp] theorem mapValuation_nil (mapOut : MatchVarResult lets v .nil w mapIn) (V) :
    mapOut.val.mapValuation V w = V v

theorem ult_swap_and_not_max_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ofBool (x <ᵤ x_1) &&& ofBool (x != -1#8) = ofBool (x <ᵤ x_1)

theorem xor_notand_to_or_not1_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 3),
  x_2 &&& x_1 ^^^ -1#3 ^^^ (x ||| x_1) = x_2 &&& x_1 ||

theorem zext_zext_eq_proof : zext_zext_eq_before ⊑ zext_zext_eq_after

@[simp] theorem nil_append : nil (f:=A) ++ ys = ys

theorem e_1876 :
     - 2 *  ~~~(a &&& b) + 2 * (c ||| (a &&&  ~~~b)) - 6 * ( ~~~a &&& (b ||| c)) - 1 * ( ~~~a ||| (b &&& c)) - 5 * (b ^^^ (a &&& c)) - 5 * ((a &&& c) ^^^  ~~~(a ^^^ (b &&& c))) + 2 *  ~~~c + 1 * ((a &&& b) ^^^ (b ||| c)) + 7 * (a ||| (b ||| c)) + 4 * (a ^^^ c) - 3 * (c ^^^  ~~~(a &&& ( ~~~b &&& c))) - 7 *  ~~~(a &&&  ~~~c) - 1 * ( ~~~(a ||| b) |||  ~~~(a ^^^ (b ^^^ c))) - 3 *  ~~~(a ||| (b ^^^ c)) - 1 * (c ^^^ ( ~~~a ||| ( ~~~b &&& c))) - 1 *  ~~~(a ^^^ ( ~~~b ||| c)) + 1 * (b ^^^ (a ||| (b ^^^ c))) + 1 *  ~~~(a ||| ( ~~~b &&& c)) + 1 *  ~~~( ~~~a &&& ( ~~~b &&& c)) - 7 * (b ^^^  ~~~(a ||| c)) - 1 * (c ||| (a ^^^ b)) - 2 * ( ~~~c ||| (a ^^^ b)) + 1 * (c ^^^ (a ||| ( ~~~b &&& c))) + 1 * ((a &&& b) ||| (a ^^^ (b ^^^ c))) + 4 * (b ^^^ (a &&& ( ~~~b ||| c))) - 7 * ((a &&&  ~~~b) ||| (b ^^^ c)) + 1 * ((b &&&  ~~~c) ^^^ ( ~~~a ||| (b ^^^ c))) + 11 * ( ~~~(a &&&  ~~~b) &&&  ~~~(a ^^^ (b ^^^ c))) - 6 * ((a ^^^ b) ||| (a ^^^ c)) - 6 * ((a ^^^ b) |||  ~~~(a ^^^ c)) - 7 *  ~~~(a |||  ~~~b) - 1 * (b ^^^  ~~~(a &&& (b &&& c))) - 3 * ( ~~~(a |||  ~~~b) |||  ~~~(b ^^^ c)) + 5 *  ~~~(a ^^^ c) - 1 * (c &&& (a ||| b)) + 2 * ((a ^^^ b) &&& (a ^^^ c)) + 2 *  ~~~( ~~~a &&& (b ^^^ c)) + 1 * ((a ^^^ b) &&&  ~~~(a ^^^ c)) - 1 * (c ^^^ (a ||| b)) + 15 *  ~~~(a ||| (b ||| c)) + 40 *  ~~~(a ||| ( ~~~b ||| c)) + 1 *  ~~~( ~~~a ||| (b ||| c)) - 5 *  ~~~( ~~~a ||| ( ~~~b ||| c)) + 16 * ( ~~~a &&& ( ~~~b &&& c)) + 20 * ( ~~~a &&& (b &&& c)) + 22 * (a &&& ( ~~~b &&& c)) + 6 * (a &&& (b &&& c)) =  - 1 * ((a &&&  ~~~b) ||| (a ^^^ (b ^^^ c))) - 4 * (b ^^^  ~~~(a &&& (b ||| c)))

theorem absdiff1_thm.extracted_1._1 : ∀ (x x_1 : BitVec 64),
  ofBool (x_1 <ᵤ x) = 1#1 →
    (x_1 - x ^^^ signExtend 64 (ofBool (x_1 <ᵤ x))) - signExtend 64 (ofBool (x_1 <ᵤ x)) = 0#64 - (x_1 - x)

theorem test43_thm.extracted_1._1 : ∀ (x : BitVec 8), True ∧ (zeroExtend 32 x).saddOverflow (-1#32) = true → False

theorem ne_umin3_proof : ne_umin3_before ⊑ ne_umin3_after

theorem test7_thm (e : IntW 32) : LLVM.srem (mul e (const? 32 8)) (const? 32 4) ⊑ const? 32 0

@[simp_llvm_option]
theorem const?_eq : LLVM.const? w i = .value (BitVec.ofInt w i)

theorem ashrsgt_03_05_proof : ashrsgt_03_05_before ⊑ ashrsgt_03_05_after

theorem trunc_lshr_exact_mask_thm.extracted_1._2 : ∀ (x : BitVec 8),
  ¬2#8 ≥ ↑8 → ¬2#6 ≥ ↑6 → truncate 6 (x >>> 2#8) &&& 15#6 = truncate 6 x >>> 2#6

theorem test1_proof : test1_before ⊑ test1_after

theorem and_min_7_8_proof : and_min_7_8_before ⊑ and_min_7_8_after

theorem test1_thm.extracted_1._1 : ∀ (x x_1 : BitVec 33),
  ofBool (x_1 &&& 65280#33 != x &&& 65280#33) = ofBool ((x_1 ^^^ x) &&& 65280#33 != 0#33)

theorem or_ranges_single_elem_left_proof : or_ranges_single_elem_left_before ⊑ or_ranges_single_elem_left_after

theorem test_thm (e : IntW 64) :
  ashr (shl e (const? 64 16)) (const? 64 16) ⊑ ashr (shl e (const? 64 16)) (const? 64 16) { «exact» := true }

theorem add_or_sub_comb_i8_negative_y_or_thm (e e_1 : IntW 8) :
  add (LLVM.or (sub (const? 8 0) e_1) e) e_1 ⊑ add (LLVM.or e (sub (const? 8 0) e_1)) e_1

theorem shift_xor_multiuse_xor_thm.extracted_1._2 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (0#32 != x_1 &&& 4096#32) = 1#1 →
    ¬ofBool (x_1 &&& 4096#32 == 0#32) = 1#1 → (x ^^^ 2048#32) * (x ^^^ 2048#32) = x * (x ^^^ 2048#32)

theorem lshrult_03_10_proof : lshrult_03_10_before ⊑ lshrult_03_10_after

theorem lshrugt_01_11_exact_thm (e : IntW 4) :
  icmp IntPred.ugt (lshr e (const? 4 1) { «exact» := true }) (const? 4 (-5)) ⊑ const? 1 0

theorem e_1144 :
    2 * z - 3 * (z ||| t) + 1 *  ~~~(z &&&  ~~~z) - 1 * t - 1 *  ~~~(z ||| t) + 6 *  ~~~(z |||  ~~~t) + 3 * (z &&&  ~~~t) + 1 * (z &&& t) = 3 * (z ^^^ t)

theorem t0_sub_of_trueval_thm (e e_1 : IntW 8) (e_2 : IntW 1) :
  sub (select e_2 e_1 e) e_1 ⊑ select e_2 (const? 8 0) (sub e e_1)

theorem sel_false_val_is_a_masked_shl_of_true_val2_thm.extracted_1._1 : ∀ (x : BitVec 64) (x_1 : BitVec 32),
  ¬(True ∧ ((x_1 &&& 15#32) <<< 2#32).sshiftRight' 2#32 ≠ x_1 &&& 15#32 ∨
        True ∧ (x_1 &&& 15#32) <<< 2#32 >>> 2#32 ≠ x_1 &&& 15#32 ∨ 2#32 ≥ ↑32) →
    ofBool ((x_1 &&& 15#32) <<< 2#32 == 0#32) = 1#1 →
      2#32 ≥ ↑32 ∨ True ∧ (x_1 <<< 2#32 &&& 60#32).msb = true ∨ zeroExtend 64 (x_1 <<< 2#32 &&& 60#32) ≥ ↑64 → False

theorem nonexact_ashr_eq_exactdiv_thm (e : IntW 8) :
  icmp IntPred.eq (ashr (const? 8 (-80)) e) (const? 8 (-5)) ⊑ icmp IntPred.eq e (const? 8 4)

theorem R.fromTensor_eq_fromTensor'_fromPoly {q n} [Fact (q > 1)] {coeffs : List Int} :
    R.fromTensor (q := q) (n := n) coeffs =
  R.fromPoly (q := q) (n := n) (R.fromTensor' coeffs)

theorem icmp_sle9_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬(True ∧ (x <<< 7#8).sshiftRight' 7#8 ≠ x ∨ 7#8 ≥ ↑8) →
    ofBool (x <<< 7#8 ≤ₛ BitVec.ofInt 8 (-128)) = ofBool (x != 0#8)

theorem test_shift_nonnegative_thm (e : IntW 32) :
  icmp IntPred.sge (shl (lshr e (const? 32 2)) (const? 32 3) { «nsw» := true, «nuw» := false }) (const? 32 0) ⊑
    const? 1 1

theorem fold_icmp_shl_nuw_c2_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬(True ∧ 16#32 <<< x >>> x ≠ 16#32 ∨ x ≥ ↑32) → ofBool (16#32 <<< x <ᵤ 64#32) = ofBool (x <ᵤ 2#32)

private theorem decide_or_decide_eq_decide {P Q : Prop}
  [Decidable P] [Decidable Q] :
  (decide P || decide Q) = decide (P ∨ Q)

theorem add_or_and_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32), (x_1 ||| x) + (x_1 &&& x) = x_1 + x

theorem udiv_common_dividend_defined_cond_thm (e e_1 e_2 : IntW 5) (e_3 : IntW 1) :
  select e_3 (LLVM.udiv e_2 e_1) (LLVM.udiv e_2 e) ⊑ LLVM.udiv e_2 (select e_3 e_1 e)

theorem masked_bit_set_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬x_1 ≥ ↑32 → zeroExtend 32 (ofBool (1#32 <<< x_1 &&& x != 0#32)) = x >>> x_1 &&& 1#32

theorem logic_or_logic_and_3_thm.extracted_1._6 : ∀ (x x_1 x_2 : BitVec 1),
  ¬x_2 = 1#1 → ¬x = 1#1 → x_1 = 1#1 → 0#1 = 1#1 → x_1 = 1#1

theorem demorgan_or_apint2_thm.extracted_1._1 : ∀ (x x_1 : BitVec 129),
  x_1 ^^^ -1#129 ||

theorem PR30273_three_bools_thm.extracted_1._5 : ∀ (x x_1 x_2 : BitVec 1),
  x_2 = 1#1 →
    ¬x_1 = 1#1 →
      ¬(True ∧ (zeroExtend 32 x).saddOverflow 1#32 = true) →
        True ∧ (zeroExtend 32 x).saddOverflow (zeroExtend 32 x_2) = true ∨
            True ∧ (zeroExtend 32 x).uaddOverflow (zeroExtend 32 x_2) = true →
          False

theorem demorgan_and_apint4_thm.extracted_1._1 : ∀ (x x_1 : BitVec 66),
  (x_1 ^^^ -1#66) &&& (x ^^^ -1#66) = (x_1 ||| x) ^^^ -1#66

theorem ashrsgt_02_14_proof : ashrsgt_02_14_before ⊑ ashrsgt_02_14_after

theorem bv_AndOrXor_2118___A__B__A___A__B :
    ∀ (e e_1 : LLVM.IntW w),
      LLVM.or (LLVM.and e e_1) (LLVM.xor e (LLVM.const? w (-1))) ⊑ LLVM.or (LLVM.xor e (LLVM.const? w (-1))) e_1

theorem ashrslt_03_07_exact_proof : ashrslt_03_07_exact_before ⊑ ashrslt_03_07_exact_after

@[simp]
lemma dec_spec (bvs' : BitVecs' n) (k : Fin n) (i : Fin bvs'.length) :
    ((dec bvs').bvs.get k).getLsbD i = bvs'[i].getLsbD k

theorem ofDep_prop_eq : (MultiWidth.Nondep.Term.ofDepTerm prop_xw_eq_xw) =
  (MultiWidth.Nondep.Term.binRel .eq xw' xvar' xvar')

theorem e_799 :
     - 1 *  ~~~(z &&&  ~~~t) + 11 * z + 3 *  ~~~t - 12 * (z &&&  ~~~t) - 9 * (z &&& t) = 2 * (z |||  ~~~t) - 1 * t

theorem bv_AndOrXor_709 :
    ∀ (e e_1 e_2 : LLVM.IntW w),
      LLVM.and (LLVM.icmp LLVM.IntPred.eq (LLVM.and e e_1) e_1) (LLVM.icmp LLVM.IntPred.eq (LLVM.and e e_2) e_2) ⊑
        LLVM.icmp LLVM.IntPred.eq (LLVM.and e (LLVM.or e_1 e_2)) (LLVM.or e_1 e_2)

theorem ashrsgt_01_01_exact_proof : ashrsgt_01_01_exact_before ⊑ ashrsgt_01_01_exact_after

theorem test15_proof : test15_before ⊑ test15_after

theorem in_constant_mone_vary_invmask_proof : in_constant_mone_vary_invmask_before ⊑ in_constant_mone_vary_invmask_after

@[simp] theorem Valuation.append_inj_right {V : Γ.Valuation} {W W' : Δ.Valuation} :
    (V ++ W) = (V ++ W') ↔ W = W'

theorem sel_false_val_is_a_masked_shl_of_true_val2_thm.extracted_1._4 : ∀ (x : BitVec 64) (x_1 : BitVec 32),
  ¬(True ∧ ((x_1 &&& 15#32) <<< 2#32).sshiftRight' 2#32 ≠ x_1 &&& 15#32 ∨
        True ∧ (x_1 &&& 15#32) <<< 2#32 >>> 2#32 ≠ x_1 &&& 15#32 ∨ 2#32 ≥ ↑32) →
    ¬ofBool ((x_1 &&& 15#32) <<< 2#32 == 0#32) = 1#1 →
      ¬(True ∧ ((x_1 &&& 15#32) <<< 2#32).sshiftRight' 2#32 ≠ x_1 &&& 15#32 ∨
            True ∧ (x_1 &&& 15#32) <<< 2#32 >>> 2#32 ≠ x_1 &&& 15#32 ∨
              2#32 ≥ ↑32 ∨ zeroExtend 64 ((x_1 &&& 15#32) <<< 2#32) ≥ ↑64) →
        ¬(2#32 ≥ ↑32 ∨ True ∧ (x_1 <<< 2#32 &&& 60#32).msb = true ∨ zeroExtend 64 (x_1 <<< 2#32 &&& 60#32) ≥ ↑64) →
          x.sshiftRight' (zeroExtend 64 ((x_1 &&& 15#32) <<< 2#32)) =
            x.sshiftRight' (zeroExtend 64 (x_1 <<< 2#32 &&& 60#32))

theorem or_xor_tree_0000_thm (e e_1 e_2 : IntW 32) :
  LLVM.or (LLVM.xor (mul e_2 (const? 32 42)) (mul e_1 (const? 32 42)))
      (LLVM.xor (LLVM.xor (mul e_1 (const? 32 42)) (mul e (const? 32 42))) (mul e_2 (const? 32 42))) ⊑
    LLVM.or (LLVM.xor (mul e_2 (const? 32 42)) (mul e_1 (const? 32 42))) (mul e (const? 32 42))

theorem e_1625 :
     - 11 * (b ^^^  ~~~(a |||  ~~~c)) - 2 * (c &&& (a |||  ~~~b)) + 11 * (b ^^^  ~~~(a &&& (b &&& c))) + 5 * ((a &&& b) ^^^ (a ^^^ (b &&& c))) + 5 * ( ~~~c |||  ~~~(a ^^^ b)) - 1 * (a ||| (b ^^^ c)) - 3 * (c ^^^  ~~~(a ||| (b &&& c))) + 2 * ((a &&& b) |||  ~~~(b ||| c)) + 11 * (b ^^^ (a |||  ~~~c)) + 7 *  ~~~(a ||| c) - 2 *  ~~~(a ^^^ (b ||| c)) + 2 * ((a &&& b) ^^^  ~~~(a ^^^ (b &&& c))) - 7 * ((a &&& b) ||| (b ^^^ c)) - 2 * (c |||  ~~~(a ||| b)) - 28 *  ~~~(a ||| (b ||| c)) + 8 *  ~~~(a ||| ( ~~~b ||| c)) - 33 *  ~~~( ~~~a ||| (b ||| c)) + 8 * ( ~~~a &&& ( ~~~b &&& c)) - 8 * ( ~~~a &&& (b &&& c)) - 7 * (a &&& ( ~~~b &&& c)) + 5 * (a &&& (b &&& c)) =  - 12 *  ~~~( ~~~a ||| ( ~~~b ||| c)) + 3 * ((b &&&  ~~~c) ^^^ ( ~~~a ||| (b ^^^ c)))

theorem ashrslt_03_00_thm (e : IntW 4) :
  icmp IntPred.slt (ashr e (const? 4 3)) (const? 4 0) ⊑ icmp IntPred.slt e (const? 4 0)

theorem add_select_not_zext_thm.extracted_1._2 : ∀ (x : BitVec 1), ¬x = 1#1 → 1#64 + zeroExtend 64 (x ^^^ 1#1) = 2#64

theorem icmp_select_var_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8), ofBool (x_1 == 0#8) = 1#1 → ofBool (x == x) = 1#1

theorem lshrult_01_14_exact_proof : lshrult_01_14_exact_before ⊑ lshrult_01_14_exact_after

theorem trunc_shl_lshr_infloop_thm (e : IntW 64) :
  trunc 32 (shl (lshr e (const? 64 1)) (const? 64 2)) ⊑
    LLVM.and (shl (trunc 32 e) (const? 32 1)) (const? 32 (-4))

theorem shift_trunc_signbit_test_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬24#32 ≥ ↑32 → ofBool (truncate 8 (x >>> 24#32) <ₛ 0#8) = ofBool (x <ₛ 0#32)

theorem sle_swap_and_min_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ofBool (x ≤ₛ x_1) &&& ofBool (x == BitVec.ofInt 8 (-128)) = ofBool (x == BitVec.ofInt 8 (-128))

theorem lor_bor_right2_thm.extracted_1._2 : ∀ (x x_1 : BitVec 1), ¬x = 1#1 → x_1 ||

theorem e_2332 :
     - 2 * (e ^^^  ~~~( ~~~d &&& (e &&& f))) + 1 * ( ~~~(d ||| e) |||  ~~~(d ^^^ (e ^^^ f))) - 5 * (e ^^^  ~~~(d &&&  ~~~f)) + 5 * (d ^^^ (e &&& f)) - 1 * (e ^^^  ~~~(d ||| f)) + 7 * (d ||| (e ||| f)) + 1 * (e &&&  ~~~f) - 3 * (e ^^^ ( ~~~d ||| (e ||| f))) - 1 * (e ^^^ (d ||| ( ~~~e &&& f))) + 7 *  ~~~(d &&& ( ~~~e &&& f)) - 2 * (e ^^^  ~~~(d &&& (e ||| f))) - 1 * (d ^^^ f) - 1 * (f ^^^  ~~~( ~~~d &&& ( ~~~e &&& f))) - 2 * (f ^^^ (d ||| e)) - 1 * ((d &&& e) ^^^ (d ^^^ ( ~~~e ||| f))) - 3 * (f &&& (d ||| e)) - 1 * ((d &&& e) |||  ~~~(e ||| f)) - 3 * (f ||| (d &&&  ~~~e)) + 4 *  ~~~(e &&& f) + 1 * ( ~~~(d |||  ~~~e) |||  ~~~(e ^^^ f)) + 1 * (f ^^^ (d &&& ( ~~~e ||| f))) - 6 * (e ^^^ (d ||| f)) - 5 *  ~~~(d |||  ~~~f) - 6 * (f ^^^  ~~~(d &&& (e ||| f))) - 7 * ((d &&& f) ^^^ (d ^^^ (e &&& f))) + 2 * (f ||| (d &&& e)) - 6 * ((d &&& e) |||  ~~~(e |||  ~~~f)) + 5 *  ~~~(d &&& (e ||| f)) + 4 * (e ^^^ ( ~~~d ||| ( ~~~e &&& f))) + 1 * ( ~~~(d &&&  ~~~e) &&&  ~~~(e ^^^ f)) - 1 * (f ^^^ (d &&& e)) + 5 * (e ^^^  ~~~( ~~~d ||| (e &&& f))) + 1 * (f ^^^  ~~~( ~~~d ||| ( ~~~e &&& f))) + 7 * (f ^^^ ( ~~~d &&& (e ||| f))) - 7 * ((d &&&  ~~~e) ||| (d ^^^ (e ^^^ f))) + 2 *  ~~~(e ||| f) - 11 *  ~~~(d ||| f) - 1 * ((d ||| e) &&& (e ^^^ f)) - 5 *  ~~~( ~~~d ||| ( ~~~e &&& f)) + 3 * (e ^^^ (d ||| (e &&& f))) + 2 *  ~~~(d &&&  ~~~f) + 7 * ((d ^^^ e) |||  ~~~(d ^^^ f)) - 2 * ((d &&& f) ^^^  ~~~(d ^^^ ( ~~~e &&& f))) - 6 *  ~~~(d ^^^ (e &&& f)) - 11 * ( ~~~e &&&  ~~~(d ^^^ f)) + 4 * ((d &&&  ~~~e) |||  ~~~(d ^^^ (e ^^^ f))) + 2 * ( ~~~f &&& (d ^^^ e)) - 11 * ((d |||  ~~~e) &&&  ~~~(e ^^^ f)) - 1 * (d |||  ~~~f) + 1 * ( ~~~e &&& (d ^^^ f)) - 2 * (e &&& (d ||| f)) + 2 * (e ||| f) + 1 * (d &&&  ~~~f) - 7 * ( ~~~d ||| (e ^^^ f)) - 1 *  ~~~(d ||| (e ^^^ f)) - 1 * (e ^^^ ( ~~~d ||| (e ^^^ f))) + 1 * (e ||| (d &&&  ~~~f)) + 36 *  ~~~(d ||| (e ||| f)) - 4 *  ~~~(d ||| ( ~~~e ||| f)) - 1 *  ~~~( ~~~d ||| (e ||| f)) + 3 *  ~~~( ~~~d ||| ( ~~~e ||| f)) + 21 * ( ~~~d &&& ( ~~~e &&& f)) - 15 * ( ~~~d &&& (e &&& f)) + 10 * (d &&& ( ~~~e &&& f)) + 18 * (d &&& (e &&& f)) = 1 * (f ^^^ ( ~~~d ||| ( ~~~e &&& f))) - 2 * ( ~~~(d &&&  ~~~e) &&& (d ^^^ (e ^^^ f)))

theorem demorgan_nand_apint2_proof : demorgan_nand_apint2_before ⊑ demorgan_nand_apint2_after

theorem eval_fsmUltUnary_eq_decide
    (a : NatFSM wcard tcard bcard ncard icard pcard (.ofDep v))
    (b : NatFSM wcard tcard bcard ncard icard pcard (.ofDep w))
    {wenv : WidthExpr.Env wcard}
    {fsmEnv : StateSpace wcard tcard bcard ncard icard pcard → BitStream}
    (henv : HWidthEnv fsmEnv wenv)
    (ha : HNatFSMToBitstream a) (hb : HNatFSMToBitstream b) :
    ((fsmUltUnary a b).eval fsmEnv) i =
   (decide (min i (v.toNat wenv) < min i (w.toNat wenv)))

theorem demorgan_nor_use2c_proof : demorgan_nor_use2c_before ⊑ demorgan_nor_use2c_after

theorem ashrsgt_01_09_proof : ashrsgt_01_09_before ⊑ ashrsgt_01_09_after

theorem ult_umin3_proof : ult_umin3_before ⊑ ult_umin3_after

theorem test1_thm.extracted_1._1 : ∀ (x : BitVec 64) (x_1 : BitVec 32),
  ¬32#64 ≥ ↑64 → zeroExtend 64 x_1 <<< 32#64 + x &&& 123#64 = x &&& 123#64

theorem ule_umax2_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (x <ᵤ x_1) = 1#1 → ofBool (x ≤ᵤ x) = ofBool (x_1 ≤ᵤ x)

theorem test1_thm.extracted_1._1 : ∀ (x x_1 : BitVec 47),
  True ∧ (x_1 &&& BitVec.ofInt 47 (-70368744177664) &&& (x &&& 70368744177661#47) != 0) = true → False

theorem test_shift_and_cmp_changed1_thm.extracted_1._2 : ∀ (x x_1 : BitVec 8),
  ¬(5#8 ≥ ↑8 ∨ 5#8 ≥ ↑8) →
    ¬5#8 ≥ ↑8 →
      ofBool (((x_1 &&& 8#8 ||| x &&& 6#8) <<< 5#8).sshiftRight' 5#8 <ₛ 1#8) =
        ofBool (x <<< 5#8 &&& BitVec.ofInt 8 (-64) <ₛ 32#8)

theorem lsb_mask_sign_zext_wrong_cst2_proof : lsb_mask_sign_zext_wrong_cst2_before ⊑ lsb_mask_sign_zext_wrong_cst2_after

private theorem not_not_xor_not (a b : Bool) : ! ((!a).xor (!b)) = (a == b)

theorem test1_thm (e e_1 : IntW 32) :
  LLVM.or e_1 (LLVM.xor (LLVM.or e_1 e) (const? 32 (-1))) ⊑ LLVM.or e_1 (LLVM.xor e (const? 32 (-1)))

theorem test_eq_0_and_15_add_1_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ofBool (x + 1#8 &&& 15#8 == 0#8) = ofBool (x &&& 15#8 == 15#8)

theorem and_or2_wrong_operand_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 1),
  (x_2 ^^^ 1#1) &&& x_1 = 1#1 → ¬x_1 &&& (x_2 ^^^ 1#1) = 1#1 → False

theorem and_not_or_or_not_or_xor_commute5_proof : and_not_or_or_not_or_xor_commute5_before ⊑ and_not_or_or_not_or_xor_commute5_after

theorem lshr_neg_slt_zero_proof : lshr_neg_slt_zero_before ⊑ lshr_neg_slt_zero_after

theorem le_proof : le_before ⊑ le_after

theorem shl_nsw_nuw_ult_Csle0_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ¬(True ∧ (x_1 <<< x).sshiftRight' x ≠ x_1 ∨ True ∧ x_1 <<< x >>> x ≠ x_1 ∨ x ≥ ↑8) →
    ofBool (x_1 <<< x <ᵤ BitVec.ofInt 8 (-19)) = ofBool (x_1 <ᵤ BitVec.ofInt 8 (-19))

theorem test_nsw_and_signed_pred_proof : test_nsw_and_signed_pred_before ⊑ test_nsw_and_signed_pred_after

theorem lt_signed_to_small_unsigned_proof : lt_signed_to_small_unsigned_before ⊑ lt_signed_to_small_unsigned_after

theorem e_1516 :
    5 * ( ~~~(a &&&  ~~~b) &&&  ~~~(a ^^^ (b ^^^ c))) - 1 *  ~~~c + 7 * (b ^^^ (a |||  ~~~c)) + 4 * ((a ^^^ b) |||  ~~~(a ^^^ c)) - 2 *  ~~~( ~~~a ||| (b &&& c)) - 15 *  ~~~(a ||| (b ||| c)) - 3 *  ~~~(a ||| ( ~~~b ||| c)) - 8 *  ~~~( ~~~a ||| (b ||| c)) - 16 * ( ~~~a &&& (b &&& c)) - 4 * (a &&& (b &&& c)) = 9 * (a &&& ( ~~~b &&& c)) + 2 *  ~~~( ~~~a ||| ( ~~~b ||| c))

theorem or_or_logic_and_2_thm.extracted_1._2 : ∀ (x x_1 : BitVec 1), ¬x_1 ||

theorem sel_zext_constants_thm.extracted_1._2 : ∀ (x : BitVec 1), ¬x = 1#1 → zeroExtend 16 42#8 = 42#16

theorem test11_thm.extracted_1._2 : ∀ (x : BitVec 8),
  ¬(True ∧ (x &&& BitVec.ofInt 8 (-13) &&& 8#8 != 0) = true) →
    (x ||| 12#8) ^^^ 4#8 = x &&& BitVec.ofInt 8 (-13) ||

theorem test_mul_nuw__all_are_safe_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ofBool (x &&& 255#32 == 17#32) = 1#1 →
    ¬(True ∧ (x &&& 255#32).smulOverflow 9#32 = true ∨ True ∧ (x &&& 255#32).umulOverflow 9#32 = true) →
      153#32 = (x &&& 255#32) * 9#32

theorem n13_thm (e e_1 e_2 : IntW 32) :
  lshr (LLVM.and (shl (const? 32 (-1)) e_2) e_1) e ⊑
    lshr (LLVM.and (shl (const? 32 (-1)) e_2 { «nsw» := true, «nuw» := false }) e_1) e

theorem e_1277 :
    1 * z + 1 * (z ||| t) - 1 * (z ^^^ t) - 5 * (z |||  ~~~t) - 1 *  ~~~(z ^^^ t) + 8 *  ~~~(z ||| t) + 2 *  ~~~(z |||  ~~~t) + 6 * (z &&&  ~~~t) + 4 * (z &&& t) = 2 *  ~~~(z &&& t)

theorem sle_smax2_proof : sle_smax2_before ⊑ sle_smax2_after

theorem shl_fold_or_disjoint_cnt_proof : shl_fold_or_disjoint_cnt_before ⊑ shl_fold_or_disjoint_cnt_after

theorem add_nuw_const_const_sub_nuw_thm.extracted_1._2 : ∀ (x : BitVec 8),
  ¬(True ∧ x.uaddOverflow 1#8 = true ∨ True ∧ (BitVec.ofInt 8 (-127)).usubOverflow (x + 1#8) = true) →
    ¬(True ∧ (BitVec.ofInt 8 (-128)).usubOverflow x = true) →
      BitVec.ofInt 8 (-127) - (x + 1#8) = BitVec.ofInt 8 (-128) - x

theorem logic_or_logic_and_3_thm.extracted_1._7 : ∀ (x x_1 x_2 : BitVec 1),
  ¬x_2 = 1#1 → ¬x = 1#1 → ¬x_1 = 1#1 → 0#1 = 1#1 → 0#1 = 1#1

theorem main10_logical_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x &&& 64#32 == 0#32) = 1#1 →
    ofBool (x &&& 192#32 == 0#32) = 1#1 → ¬ofBool (0#8 ≤ₛ truncate 8 x) = 1#1 → 1#32 = 2#32

theorem foo3_thm.extracted_1._1 : ∀ (x x_1 : BitVec 1), ¬x = 0 → x_1 / x = x_1

theorem src_srem_shl_demand_max_signbit_proof : src_srem_shl_demand_max_signbit_before ⊑ src_srem_shl_demand_max_signbit_after

theorem negate_lowbitmask_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ofBool (x_1 &&& 1#8 == 0#8) = 1#1 → 0#8 - (x_1 &&& 1#8) &&& x = 0#8

theorem lshr_32_add_not_known_32_leading_zeroes_thm (e e_1 : IntW 64) :
  lshr (add (LLVM.and e_1 (const? 64 8589934591)) (LLVM.and e (const? 64 4294967295))) (const? 64 32) ⊑
    lshr
      (add (LLVM.and e_1 (const? 64 8589934591)) (LLVM.and e (const? 64 4294967295)) { «nsw» := true, «nuw» := true })
      (const? 64 32)

theorem ashr_sge_exact_thm (e : IntW 8) :
  icmp IntPred.sge (ashr e (const? 8 3) { «exact» := true }) (const? 8 10) ⊑
    icmp IntPred.sgt e (const? 8 72)

theorem AndZextAnd_proof : AndZextAnd_before ⊑ AndZextAnd_after

theorem trunc_shl_nsw_31_i32_i64_proof : trunc_shl_nsw_31_i32_i64_before ⊑ trunc_shl_nsw_31_i32_i64_after

theorem PR75692_1_proof : PR75692_1_before ⊑ PR75692_1_after

theorem mul_selectp2_x_non_const_thm.extracted_1._4 : ∀ (x x_1 : BitVec 8) (x_2 : BitVec 1),
  x_2 = 1#1 → ¬1#8 ≥ ↑8 → 2#8 * x = x <<< 1#8

theorem bitwise_and_logical_and_masked_icmp_allones_poison1_thm.extracted_1._2 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (x_1 &&& x == x) = 1#1 →
    ¬ofBool (x_1 &&& (x ||| 7#32) == x ||| 7#32) = 1#1 → 0#1 &&& ofBool (x_1 &&& 7#32 == 7#32) = 0#1

theorem e_364 :
    7 * (x |||  ~~~y) - 1 * y + 2 *  ~~~(x &&&  ~~~y) - 2 *  ~~~(x ^^^ y) + 1 * (x ^^^ y) - 8 *  ~~~(x ||| y) - 9 * (x &&&  ~~~y) - 7 * (x &&& y) = 3 *  ~~~(x |||  ~~~y) - 1 *  ~~~(x &&&  ~~~x)

theorem differentconsts_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x + 16#32 <ᵤ 144#32) = 1#1 → ofBool (127#32 <ₛ x) = 1#1 → truncate 16 x = -1#16

theorem e_2028 :
     - 5 * (e ^^^ ( ~~~d ||| ( ~~~e ||| f))) + 4 * ((d &&& f) ^^^  ~~~(d ^^^ (e &&& f))) - 5 * (f ^^^  ~~~( ~~~d &&& ( ~~~e ||| f))) + 2 * ( ~~~(d &&&  ~~~e) &&& (e ^^^ f)) - 1 * (e ^^^ (d ||| f)) + 11 * ( ~~~(d &&& e) &&&  ~~~(d ^^^ (e ^^^ f))) + 4 * (f |||  ~~~(d ^^^ e)) + 1 * (f ^^^ (d &&&  ~~~e)) - 1 * ( ~~~d ||| ( ~~~e ||| f)) + 2 * (f ^^^  ~~~( ~~~d &&& (e ||| f))) - 6 * (f ^^^  ~~~(d &&& e)) + 1 * (e ^^^ (d |||  ~~~f)) + 4 * (f &&&  ~~~(d &&& e)) + 1 * (e &&&  ~~~(d &&& f)) - 3 * ((d &&& f) ^^^  ~~~(d ^^^ ( ~~~e &&& f))) + 7 * ((d &&& f) |||  ~~~(e ||| f)) + 2 * (d |||  ~~~e) + 3 * ( ~~~f &&&  ~~~(d ^^^ e)) - 5 * (d &&& (e ||| f)) + 2 * (d &&&  ~~~f) + 3 * (f ^^^ ( ~~~d ||| (e &&& f))) - 11 * (f ^^^  ~~~(d &&& (e ||| f))) - 1 * (e |||  ~~~(d ^^^ f)) + 11 * ( ~~~(d |||  ~~~e) |||  ~~~(e ^^^ f)) - 5 * (e &&& (d ^^^ f)) + 1 * ( ~~~d &&& ( ~~~e ||| f)) - 2 * (f ||| (d &&&  ~~~e)) - 22 *  ~~~(d ||| (e ||| f)) + 8 *  ~~~(d ||| ( ~~~e ||| f)) + 6 *  ~~~( ~~~d ||| (e ||| f)) + 12 *  ~~~( ~~~d ||| ( ~~~e ||| f)) - 5 * ( ~~~d &&& ( ~~~e &&& f)) - 18 * ( ~~~d &&& (e &&& f)) - 2 * (d &&& ( ~~~e &&& f)) + 5 * (d &&& (e &&& f)) = 1 * (f ||| (d ^^^ e)) + 7 * (d &&& (e ^^^ f))

theorem mul128_low_proof : mul128_low_before ⊑ mul128_low_after

theorem main6d_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬ofBool (x &&& 7#32 != 3#32) ||

theorem ne_basic_equal_5_proof : ne_basic_equal_5_before ⊑ ne_basic_equal_5_after

theorem test_with_neg_5_proof : test_with_neg_5_before ⊑ test_with_neg_5_after

theorem e_2292 :
    2 *  ~~~(d ||| f) - 11 * (e &&& f) + 11 *  ~~~(e &&&  ~~~f) + 7 * (f ^^^ ( ~~~d &&& (e ||| f))) + 4 * ((d ^^^ e) |||  ~~~(d ^^^ f)) - 7 * (d ||| ( ~~~e &&& f)) + 1 *  ~~~( ~~~d ||| (e &&& f)) - 2 * (d |||  ~~~e) - 2 * (e ^^^  ~~~(d &&& f)) + 1 *  ~~~(d &&& e) + 2 * ( ~~~(d |||  ~~~e) ||| (d ^^^ (e ^^^ f))) - 6 * ((d &&& e) ^^^  ~~~(d ^^^ ( ~~~e ||| f))) + 1 * (d &&& e) + 2 * (e &&& (d |||  ~~~f)) + 7 * ( ~~~(d ^^^ e) ||| (d ^^^ f)) + 7 * (f ^^^ (d &&& (e ||| f))) - 3 * ( ~~~(d ||| e) ||| (d ^^^ (e ^^^ f))) + 1 * (e ^^^ (d &&& ( ~~~e ||| f))) - 7 * (d ^^^ ( ~~~e &&& f)) - 1 *  ~~~(d ^^^ ( ~~~e ||| f)) - 7 * ((d ||| e) &&&  ~~~(e ^^^ f)) + 5 *  ~~~(d ^^^ ( ~~~e &&& f)) + 2 *  ~~~(d ||| e) + 1 * (f ^^^ (d &&& e)) - 1 * ( ~~~(d &&& e) &&& (d ^^^ (e ^^^ f))) + 11 * ( ~~~d ||| ( ~~~e ||| f)) + 7 * (e ^^^  ~~~(d |||  ~~~f)) + 2 * ((d &&& f) |||  ~~~(e ||| f)) + 1 * (e &&&  ~~~(d &&&  ~~~f)) + 11 * ( ~~~f |||  ~~~(d ^^^ e)) - 5 *  ~~~(d ||| (e ^^^ f)) - 1 * (d ||| (e &&& f)) + 2 * (e ^^^ ( ~~~d ||| ( ~~~e &&& f))) + 3 * ( ~~~d ||| (e ^^^ f)) + 2 * (e ^^^  ~~~(d ||| (e ^^^ f))) + 2 * (f ^^^ ( ~~~d &&& ( ~~~e ||| f))) + 11 * (e ^^^ ( ~~~d ||| (e ||| f))) - 11 * (e ^^^ ( ~~~d &&& (e ^^^ f))) - 2 * (e ^^^  ~~~( ~~~d &&& (e ||| f))) - 5 *  ~~~(e &&& f) + 4 * (d ||| e) - 1 * ((d &&& f) ^^^  ~~~(e &&&  ~~~f)) - 3 * ((e &&& f) ||| (d &&& (e ||| f))) + 4 * ( ~~~d &&& (e ^^^ f)) - 11 *  ~~~(d ||| (e &&& f)) - 1 * d - 2 * ( ~~~(d |||  ~~~e) |||  ~~~(e ^^^ f)) + 2 *  ~~~(d &&& f) - 3 * ( ~~~(d ^^^ e) |||  ~~~(d ^^^ f)) - 2 * (e |||  ~~~(d ||| f)) + 1 *  ~~~( ~~~d &&& (e ||| f)) + 11 *  ~~~(d &&&  ~~~f) + 2 * (f ^^^ (d ||| (e &&& f))) - 51 *  ~~~(d ||| (e ||| f)) - 43 *  ~~~(d ||| ( ~~~e ||| f)) - 11 *  ~~~( ~~~d ||| (e ||| f)) - 5 *  ~~~( ~~~d ||| ( ~~~e ||| f)) - 41 * ( ~~~d &&& ( ~~~e &&& f)) - 32 * ( ~~~d &&& (e &&& f)) - 53 * (d &&& ( ~~~e &&& f)) - 25 * (d &&& (e &&& f)) =  - 7 * (f &&& (d ^^^ e)) + 1 *  ~~~(d &&& (e &&& f))

theorem scalar_i32_signbit_lshr_and_eq_X_is_constant1_proof : scalar_i32_signbit_lshr_and_eq_X_is_constant1_before ⊑ scalar_i32_signbit_lshr_and_eq_X_is_constant1_after

theorem demorganize_constant2_proof : demorganize_constant2_before ⊑ demorganize_constant2_after

theorem reused_mul_nuw_xy_z_selectnonzero_ugt_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬ofBool (x != 0#8) = 1#1 → ¬ofBool (x == 0#8) = 1#1 → False

theorem lor_land_left2_thm.extracted_1._1 : ∀ (x x_1 : BitVec 1), ¬x_1 = 1#1 → ¬x = 1#1 → 0#1 = x

theorem test12_proof : test12_before ⊑ test12_after

theorem zext_nneg_i1_proof : zext_nneg_i1_before ⊑ zext_nneg_i1_after

theorem test_thm.extracted_1._1 : zeroExtend 32 (ofBool (1#32 == 2#32)) = 0#32

theorem xor_or_xor_common_op_commute7_thm (e e_1 e_2 : IntW 32) :
  LLVM.xor (LLVM.or e_2 e_1) (LLVM.xor e_1 e) ⊑ LLVM.xor (LLVM.and e_2 (LLVM.xor e_1 (const? 32 (-1)))) e

theorem ashrsgt_03_00_exact_proof : ashrsgt_03_00_exact_before ⊑ ashrsgt_03_00_exact_after

theorem main4e_like_logical_thm.extracted_1._9 : ∀ (x x_1 x_2 : BitVec 32),
  ¬ofBool (x_2 &&& x_1 == x_1) = 1#1 → ofBool (x_2 &&& x_1 != x_1) = 1#1 → 0#1 = 1#1 → 0#32 = zeroExtend 32 1#1

theorem shl_nuw_eq_0_thm (e e_1 : IntW 8) :
  icmp IntPred.eq (shl e_1 e { «nsw» := false, «nuw» := true }) (const? 8 0) ⊑
    icmp IntPred.eq e_1 (const? 8 0)

theorem positive_samevar_thm.extracted_1._2 : ∀ (x x_1 : BitVec 8),
  ¬(x ≥ ↑8 ∨ x ≥ ↑8) →
    ¬(True ∧ ((-1#8) <<< x).sshiftRight' x ≠ -1#8 ∨ x ≥ ↑8) → x_1.sshiftRight' x <<< x = (-1#8) <<< x &&& x_1

theorem lshrult_01_07_proof : lshrult_01_07_before ⊑ lshrult_01_07_after

theorem sgt_3_impliesT_sgt_2_thm.extracted_1._3 : ∀ (x x_1 : BitVec 8),
  ofBool (3#8 <ₛ x_1) = 1#1 → ofBool (x_1 <ₛ 4#8) = 1#1 → ofBool (x_1 <ₛ 2#8) = ofBool (x_1 <ₛ x)

@[simp] theorem Com.outContext_rets (vs : HVector Γ.Var t) : (rets vs : Com d Γ eff t).outContext = Γ

theorem ashr_ugt_9_proof : ashr_ugt_9_before ⊑ ashr_ugt_9_after

theorem test_proof : test_before ⊑ test_after

theorem test_add__nsw_is_safe_thm.extracted_1._3 : ∀ (x : BitVec 32),
  ¬ofBool (x ||| BitVec.ofInt 32 (-2147483648) == -1#32) = 1#1 →
    True ∧ (x ||| BitVec.ofInt 32 (-2147483648)).saddOverflow 1#32 = true → False

theorem t3_ult_sgt_neg1_thm.extracted_1._6 : ∀ (x x_1 : BitVec 32),
  ofBool (x_1 <ᵤ 65536#32) = 1#1 → ofBool (65535#32 <ₛ x_1) = 1#1 → False

theorem ashrslt_03_15_exact_proof : ashrslt_03_15_exact_before ⊑ ashrslt_03_15_exact_after

@[simp] theorem carry_succ (initCarry : Bool) (x y : BitStream) :
    (carry initCarry x y (i + 1)) =
  let out

theorem test11_logical_proof : test11_logical_before ⊑ test11_logical_after

theorem R.monomial_zero_c_eq_zero : R.monomial (q := q) (n := n) 0 c = 0

theorem sext_sext_slt_proof : sext_sext_slt_before ⊑ sext_sext_slt_after

theorem zext_sub_thm.extracted_1._1 : ∀ (x : BitVec 8),
  BitVec.ofInt 16 (-5) - zeroExtend 16 x &&& zeroExtend 16 x = zeroExtend 16 (BitVec.ofInt 8 (-5) - x &&& x)

theorem test15c_thm.extracted_1._2 : ∀ (x : BitVec 32), ¬ofBool (x &&& 16#32 == 16#32) = 1#1 → 0#32 = x &&& 16#32

theorem and_and_logic_or_1_thm.extracted_1._5 : ∀ (x x_1 x_2 : BitVec 1),
  ¬x_2 &&& x_1 = 1#1 → x_1 = 1#1 → x_2 &&& x = x_2 &&& 1#1

theorem lshr_ne_opposite_msb_proof : lshr_ne_opposite_msb_before ⊑ lshr_ne_opposite_msb_after

theorem e_140 :
     - 11 *  ~~~x + 5 * (x ||| y) + 4 *  ~~~(x ^^^ y) + 7 *  ~~~(x ||| y) + 6 *  ~~~(x |||  ~~~y) - 9 * (x &&& y) = 5 * (x &&&  ~~~y)

@[bv_automata_nnf]
theorem ule_iff_ult_eq_false {a b : BitVec w} : a.ult b = false ↔ b.ule a

theorem or_and_not_constant_commute2_proof : or_and_not_constant_commute2_before ⊑ or_and_not_constant_commute2_after

theorem testtrunclowhigh_proof : testtrunclowhigh_before ⊑ testtrunclowhigh_after

theorem neg_sgt_n1_proof : neg_sgt_n1_before ⊑ neg_sgt_n1_after

theorem t0_proof : t0_before ⊑ t0_after

theorem main5f_like_logical_thm.extracted_1._8 : ∀ (x x_1 x_2 : BitVec 32),
  ofBool (x_2 &&& x_1 != x_2) = 1#1 → ¬ofBool (x_2 &&& x_1 == x_2) = 1#1 → ¬True → 0#32 = zeroExtend 32 0#1

theorem e_2359 :
     - 2 * (e ^^^ ( ~~~d ||| (e ^^^ f))) + 3 * (f ^^^ (d &&& ( ~~~e ||| f))) + 5 * ( ~~~(d ^^^ e) ||| (d ^^^ f)) + 11 * (e ^^^ ( ~~~d ||| ( ~~~e ||| f))) - 1 *  ~~~(d &&& ( ~~~e &&& f)) + 3 * (e ^^^  ~~~(d &&& f)) - 1 *  ~~~(d &&& ( ~~~e ||| f)) - 1 * ( ~~~(d ||| e) |||  ~~~(d ^^^ (e ^^^ f))) - 11 * (e &&&  ~~~f) - 5 * ( ~~~(d &&&  ~~~e) &&&  ~~~(e ^^^ f)) + 1 * (d ^^^ (e ||| f)) + 4 * (f ^^^  ~~~(d &&& ( ~~~e &&& f))) - 11 * ( ~~~e ||| (d ^^^ f)) + 1 * (f ^^^ (d ||| (e ||| f))) + 2 *  ~~~(d ||| e) + 1 * (e ^^^ ( ~~~d &&& (e ^^^ f))) + 1 * ( ~~~(d ^^^ e) &&&  ~~~(d ^^^ f)) - 2 * (e ^^^ ( ~~~d &&& (e ||| f))) - 6 * ((d |||  ~~~e) &&&  ~~~(d ^^^ (e ^^^ f))) + 1 *  ~~~(d &&& (e ||| f)) + 1 * (f ^^^ ( ~~~d ||| (e &&& f))) - 6 * (f &&& (d ^^^ e)) - 5 * (e ||| (d &&&  ~~~f)) - 11 *  ~~~(d ^^^ (e ||| f)) - 6 * (e ^^^ ( ~~~d &&& ( ~~~e ||| f))) - 1 * ((e &&& f) ||| (d &&& (e ||| f))) + 4 * ((e &&&  ~~~f) ^^^ (d ||| (e ^^^ f))) - 5 *  ~~~(d &&& e) + 3 * (e ^^^  ~~~(d |||  ~~~f)) - 1 * (d ^^^ ( ~~~e ||| f)) + 2 * ( ~~~(d &&&  ~~~e) &&& (e ^^^ f)) - 3 * (f ^^^  ~~~(d &&& ( ~~~e ||| f))) + 2 * ((d &&& f) |||  ~~~(e ||| f)) - 7 * (e &&&  ~~~(d ^^^ f)) - 11 * ((d &&& e) |||  ~~~(e |||  ~~~f)) + 3 * (e ^^^ (d ||| (e ||| f))) - 1 * ((d &&& e) ^^^ (d ^^^ (e &&& f))) + 4 * (e ^^^ ( ~~~d ||| ( ~~~e &&& f))) - 7 * (f ^^^ (d ||| ( ~~~e &&& f))) - 7 * (f ^^^  ~~~( ~~~d &&& (e ||| f))) + 1 * ( ~~~d &&& ( ~~~e ||| f)) - 1 * (f ^^^ (d ||| e)) + 5 * (e ^^^  ~~~(d ||| f)) + 1 *  ~~~(e ^^^ f) - 1 * ( ~~~f &&& (d ^^^ e)) + 3 * (d ||| (e ||| f)) + 5 * (f ^^^ (d |||  ~~~e)) - 7 * ((d &&& e) ^^^  ~~~(d ^^^ (e &&& f))) - 7 * (f ||| (d &&& e)) + 7 * (d ||| ( ~~~e ||| f)) - 3 * ((d &&& f) ^^^ (d ^^^ (e &&& f))) + 1 * ((d &&& f) ^^^ (e ||| f)) - 6 * (f ||| (d ^^^ e)) + 1 * ((d &&& e) ^^^ (e |||  ~~~f)) + 2 * f - 5 *  ~~~( ~~~d &&& (e ^^^ f)) + 2 * (f ^^^ (d ||| ( ~~~e ||| f))) - 1 * (e &&&  ~~~(d &&& f)) + 1 * ( ~~~d ||| ( ~~~e ||| f)) - 11 * ((d ^^^ e) &&& (d ^^^ f)) + 15 *  ~~~(d ||| (e ||| f)) + 36 *  ~~~(d ||| ( ~~~e ||| f)) + 7 *  ~~~( ~~~d ||| (e ||| f)) + 56 *  ~~~( ~~~d ||| ( ~~~e ||| f)) + 11 * ( ~~~d &&& ( ~~~e &&& f)) + 48 * ( ~~~d &&& (e &&& f)) + 35 * (d &&& ( ~~~e &&& f)) + 34 * (d &&& (e &&& f)) = 1 * (d ^^^ (e &&& f))

theorem uge_to_sgt_thm (e : IntW 8) :
  icmp IntPred.uge (LLVM.xor e (const? 8 (-128))) (const? 8 15) ⊑
    icmp IntPred.sgt e (const? 8 (-114))

theorem test3_thm.extracted_1._1 : ∀ (x : BitVec 1) (x_1 : BitVec 599),
  x = 1#1 → ¬70368744177664#599 = 0 → 46#599 ≥ ↑599 → False

theorem scalar_i8_lshr_and_negC_eq_not_negatedPowerOf2_proof : scalar_i8_lshr_and_negC_eq_not_negatedPowerOf2_before ⊑ scalar_i8_lshr_and_negC_eq_not_negatedPowerOf2_after

theorem foo1_and_commuted_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 32),
  ¬(x_1 ≥ ↑32 ∨ x ≥ ↑32) →
    True ∧ 1#32 <<< x_1 >>> x_1 ≠ 1#32 ∨
        x_1 ≥ ↑32 ∨
          True ∧ 1#32 <<< x >>> x ≠ 1#32 ∨
            x ≥ ↑32 ∨ True ∧ 1#32 <<< x_1 >>> x_1 ≠ 1#32 ∨ x_1 ≥ ↑32 ∨ True ∧ 1#32 <<< x >>> x ≠ 1#32 ∨ x ≥ ↑32 →
      False

theorem icmp_mul_nsw_sle_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ¬(True ∧ x_1.smulOverflow 7#8 = true ∨ True ∧ x.smulOverflow 7#8 = true) →
    ofBool (x_1 * 7#8 ≤ₛ x * 7#8) = ofBool (x_1 ≤ₛ x)

theorem udiv_mul_shl_nuw_exact_commute1_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 5),
  ¬(True ∧ x_2.umulOverflow x_1 = true ∨
        True ∧ x_1 <<< x >>> x ≠ x_1 ∨ x ≥ ↑5 ∨ True ∧ (x_2 * x_1).umod (x_1 <<< x) ≠ 0 ∨ x_1 <<< x = 0) →
    True ∧ x_2 >>> x <<< x ≠ x_2 ∨ x ≥ ↑5 → False

theorem src_fv_ne_proof : src_fv_ne_before ⊑ src_fv_ne_after

theorem positive_samevar_proof : positive_samevar_before ⊑ positive_samevar_after

theorem foo3_proof : foo3_before ⊑ foo3_after

theorem pr40493_neg3_thm.extracted_1._1 : ∀ (x : BitVec 32), 2#32 ≥ ↑32 → False

theorem test_proof : test_before ⊑ test_after

theorem add_const_const_sub_proof : add_const_const_sub_before ⊑ add_const_const_sub_after

theorem xor_signbit_select_lshr_proof : xor_signbit_select_lshr_before ⊑ xor_signbit_select_lshr_after

theorem trunc_shl_shl_var_thm.extracted_1._2 : ∀ (x x_1 : BitVec 64),
  ¬(x ≥ ↑64 ∨ 2#64 ≥ ↑64) →
    ¬(x ≥ ↑64 ∨ 2#32 ≥ ↑32) → truncate 32 (x_1 <<< x <<< 2#64) = truncate 32 (x_1 <<< x) <<< 2#32

theorem uadd_sat_flipped_wrong_bounds7_thm (e : IntW 32) :
  select (icmp IntPred.ule e (const? 32 (-12))) (add e (const? 32 9)) (const? 32 (-1)) ⊑
    select (icmp IntPred.ult e (const? 32 (-11))) (add e (const? 32 9)) (const? 32 (-1))

theorem neg_eq_not_add_one :
    -x = ~~~ x + 1

theorem logic_and_logic_or_3_thm.extracted_1._10 : ∀ (x x_1 x_2 : BitVec 1),
  ¬x_2 = 1#1 → ¬x = 1#1 → 0#1 = 1#1 → 1#1 = 0#1

theorem negate_add_with_single_negatible_operand_thm (e : IntW 8) : sub (const? 8 0) (add e (const? 8 42)) ⊑ sub (const? 8 (-42)) e

theorem p14_commutativity1_thm (e : IntW 32) :
  select (icmp IntPred.ult e (const? 32 65536)) (const? 32 65535) (const? 32 42) ⊑
    select (icmp IntPred.ugt e (const? 32 65535)) (const? 32 42) (const? 32 65535)

theorem e_329 :
     - 3 *  ~~~y - 1 *  ~~~x + 5 * (x ||| y) + 5 * y - 11 * (x ^^^ y) - 7 *  ~~~(x ||| y) - 9 *  ~~~(x |||  ~~~y) - 19 * (x &&& y) = 2 * x - 11 *  ~~~(x &&&  ~~~x)

theorem icmp_power2_and_icmp_shifted_mask_swapped_2147483648_2147483647_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x &&& 2147483647#32 != 2147483647#32) &&& ofBool (x <ᵤ BitVec.ofInt 32 (-2147483648)) =
    ofBool (x <ᵤ 2147483647#32)

@[simp]
lemma BitVec.cons_ugt_iff {w} {bv1 bv2 : BitVec w} :
    ((BitVec.cons b2 bv2).ult (BitVec.cons b1 bv1)) ↔ (if b1 = b2 then bv2.ult bv1 else b1)

theorem bools2_logical_commute0_and1_thm.extracted_1._1 : ∀ (x x_1 : BitVec 1), x_1 &&& x = 1#1 → x_1 = 1#1 → 1#1 = x

theorem same_signbit_wrong_type_signed_thm.extracted_1._1 : ∀ (x : BitVec 32) (x_1 : BitVec 8),
  ¬7#8 ≥ ↑8 →
    ofBool (x_1.sshiftRight' 7#8 != signExtend 8 (ofBool (-1#32 <ₛ x))) = ofBool (x_1 <ₛ 0#8) ^^^ ofBool (-1#32 <ₛ x)

theorem or_basic_commuted_thm.extracted_1._1 : ∀ (x : BitVec 16),
  ofBool (x &&& BitVec.ofInt 16 (-256) != 32512#16) ||

theorem e_1912 :
    1 * (c ^^^ (a ||| (b &&& c))) + 11 * (c ^^^ ( ~~~a &&& ( ~~~b ||| c))) - 2 * (a ||| ( ~~~b &&& c)) - 1 * (b ^^^ (a &&&  ~~~c)) + 2 * (b &&& (a ^^^ c)) - 1 * (b ^^^ ( ~~~a &&& (b ^^^ c))) + 1 * ((a &&& b) ||| (b ^^^ c)) + 2 * (c &&&  ~~~(a &&&  ~~~b)) - 6 * ( ~~~(a ^^^ b) &&&  ~~~(a ^^^ c)) - 2 * (a ||| ( ~~~b ||| c)) - 5 * (c &&& (a ^^^ b)) - 1 * ( ~~~a ||| (b ^^^ c)) + 5 * (c ||| (a &&&  ~~~b)) - 2 * (b ^^^  ~~~(a &&& ( ~~~b &&& c))) - 7 *  ~~~(a ^^^ (b &&& c)) - 2 * (b ||| (a &&& c)) + 1 * ((a &&& b) ||| (a ^^^ (b ^^^ c))) - 6 * ( ~~~(a &&& b) &&&  ~~~(b ^^^ c)) - 1 * (b ^^^ (a &&& (b ^^^ c))) + 3 * (c ^^^  ~~~( ~~~a &&& ( ~~~b ||| c))) + 2 * (c ^^^  ~~~(a &&& ( ~~~b &&& c))) - 6 * (c |||  ~~~(a |||  ~~~b)) - 2 * ((a |||  ~~~b) &&&  ~~~(b ^^^ c)) - 6 * (c ^^^  ~~~(a &&& ( ~~~b ||| c))) - 1 * (b ||| c) + 2 * ((a ||| b) &&& (a ^^^ (b ^^^ c))) - 11 * (c ^^^  ~~~( ~~~a ||| (b &&& c))) + 2 * ((a &&&  ~~~b) ||| (a ^^^ (b ^^^ c))) + 4 * (b |||  ~~~(a ^^^ c)) + 2 *  ~~~(b ^^^ c) - 3 * ((a &&&  ~~~b) |||  ~~~(a ^^^ (b ^^^ c))) - 6 * (c ^^^  ~~~( ~~~a ||| ( ~~~b &&& c))) + 1 * (c &&&  ~~~(a &&& b)) - 2 * ((a &&& b) |||  ~~~(a ^^^ (b ^^^ c))) - 3 *  ~~~( ~~~a &&& ( ~~~b &&& c)) + 5 * ((b &&& c) ^^^  ~~~(a &&& (b ^^^ c))) + 2 * ((b &&&  ~~~c) |||  ~~~( ~~~a ||| ( ~~~b &&& c))) - 1 * (b ^^^ c) + 1 * (c ^^^ ( ~~~a ||| ( ~~~b &&& c))) - 5 * ((a &&& c) ^^^  ~~~(a ^^^ (b &&& c))) + 1 * ( ~~~(a |||  ~~~b) |||  ~~~(a ^^^ (b ^^^ c))) + 2 *  ~~~(b &&& c) + 24 *  ~~~(a ||| (b ||| c)) + 8 *  ~~~(a ||| ( ~~~b ||| c)) + 14 *  ~~~( ~~~a ||| (b ||| c)) + 29 *  ~~~( ~~~a ||| ( ~~~b ||| c)) + 22 * ( ~~~a &&& ( ~~~b &&& c)) + 34 * ( ~~~a &&& (b &&& c)) + 17 * (a &&& ( ~~~b &&& c)) + 20 * (a &&& (b &&& c)) = 7 * ( ~~~c &&&  ~~~(a ^^^ b)) + 3 * ((a ^^^ b) &&& (a ^^^ c))

theorem main4c_logical_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x &&& 7#32 != 7#32) = 1#1 → True → 0#32 = zeroExtend 32 (ofBool (x &&& 55#32 == 55#32))

theorem e_2285 :
    1 * ( ~~~d ||| (e ^^^ f)) - 1 * ( ~~~(d |||  ~~~e) ||| (e ^^^ f)) + 4 * (d ^^^ (e &&& f)) - 1 * (d &&& e) - 1 * ( ~~~(d &&&  ~~~e) &&& (e ^^^ f)) + 5 *  ~~~(d &&& ( ~~~e ||| f)) - 5 * (d ||| ( ~~~e ||| f)) + 3 *  ~~~(e ||| f) + 2 *  ~~~(d &&& (e ||| f)) + 5 * (e ^^^ ( ~~~d ||| (e ||| f))) + 1 * ((d &&& e) ||| (e ^^^ f)) - 3 *  ~~~( ~~~d &&& (e &&& f)) - 7 * (e ^^^ (d &&& f)) + 1 * (d |||  ~~~f) - 1 * (e ^^^  ~~~(d ||| f)) + 7 *  ~~~(e ^^^ f) - 5 * ((d &&& e) ^^^ (d ^^^ (e &&& f))) - 2 * ( ~~~(d |||  ~~~e) |||  ~~~(e ^^^ f)) - 7 * (e ||| f) - 1 * (e ||| (d &&& f)) - 6 *  ~~~(d &&& (e &&& f)) + 1 * d - 3 * (e ^^^ (d ||| ( ~~~e &&& f))) + 1 * ( ~~~(d ^^^ e) &&&  ~~~(d ^^^ f)) - 1 * f - 5 * (f ^^^  ~~~(d ||| ( ~~~e &&& f))) + 5 * (e ^^^  ~~~( ~~~d ||| ( ~~~e &&& f))) - 2 * ((d &&& f) ||| (e &&&  ~~~f)) + 2 * ((d &&& e) ^^^  ~~~(d ^^^ ( ~~~e ||| f))) - 1 *  ~~~(d ||| e) + 1 * ((d &&& e) ^^^  ~~~(d ^^^ (e &&& f))) + 11 * (f ^^^  ~~~(d &&&  ~~~e)) + 1 * (f ^^^ (d ||| e)) + 2 * ( ~~~(d ||| e) |||  ~~~(d ^^^ (e ^^^ f))) + 1 *  ~~~(d &&&  ~~~d) - 5 *  ~~~(d ||| (e ^^^ f)) - 1 * (d ^^^ ( ~~~e ||| f)) + 1 *  ~~~(d ^^^ e) + 1 * ( ~~~e ||| (d ^^^ f)) - 2 * (e ^^^ (d ||| (e ^^^ f))) + 3 * (f ^^^ (d ||| ( ~~~e ||| f))) + 2 * (f ^^^ ( ~~~d ||| ( ~~~e &&& f))) - 2 * ( ~~~d &&& (e ^^^ f)) - 1 * ((d ^^^ e) &&& (d ^^^ f)) + 3 * (f ||| (d &&&  ~~~e)) - 11 * (e ^^^  ~~~(d ||| ( ~~~e &&& f))) - 1 * (e ^^^  ~~~(d ||| (e ^^^ f))) + 11 *  ~~~(e &&& f) + 2 * (f ^^^ ( ~~~d &&& ( ~~~e ||| f))) - 11 * (d ^^^ e) - 1 * ( ~~~f &&& (d ^^^ e)) - 3 * ( ~~~(d ^^^ e) ||| (d ^^^ f)) + 2 * ((d &&& f) ^^^ (d ^^^ ( ~~~e &&& f))) - 16 *  ~~~(d ||| (e ||| f)) + 9 *  ~~~(d ||| ( ~~~e ||| f)) - 9 *  ~~~( ~~~d ||| (e ||| f)) - 2 *  ~~~( ~~~d ||| ( ~~~e ||| f)) + 4 * ( ~~~d &&& ( ~~~e &&& f)) + 27 * ( ~~~d &&& (e &&& f)) + 11 * (d &&& ( ~~~e &&& f)) + 24 * (d &&& (e &&& f)) =  - 4 * ((d &&& f) ^^^ (d ^^^ (e &&& f)))

theorem shl_nuw_add_nuw_thm (e : IntW 32) :
  shl (const? 32 1) (add e (const? 32 1) { «nsw» := false, «nuw» := true }) { «nsw» := false, «nuw» := true } ⊑
    shl (const? 32 2) e { «nsw» := false, «nuw» := true }

theorem scalar_i64_shl_and_negC_eq_thm.extracted_1._1 : ∀ (x x_1 : BitVec 64),
  ¬x ≥ ↑64 → ofBool (x_1 <<< x &&& BitVec.ofInt 64 (-8589934592) == 0#64) = ofBool (x_1 <<< x <ᵤ 8589934592#64)

theorem alive_290__292 : alive_290__292_src ⊑ alive_290__292_tgt

theorem lshr_lshr_pow2_const_proof : lshr_lshr_pow2_const_before ⊑ lshr_lshr_pow2_const_after

theorem multiuse_select_thm.extracted_1._1 : ∀ (x : BitVec 1), x = 1#1 → 64#64 * (64#64 - zeroExtend 64 x) = 4032#64

theorem test14a_thm.extracted_1._1 : ∀ (x : BitVec 79),
  ¬(4#79 ≥ ↑79 ∨ 4#79 ≥ ↑79) → (x <<< 4#79 &&& 1234#79) >>> 4#79 = x &&& 77#79

theorem e_161 :
     - 11 *  ~~~(x &&&  ~~~y) - 7 * y + 11 *  ~~~(x ||| y) + 19 *  ~~~(x |||  ~~~y) + 1 * (x &&&  ~~~y) + 19 * (x &&& y) = 1 * (x ||| y)

theorem udiv_shl_mul_nuw_swap_thm (e e_1 e_2 : IntW 5) :
  LLVM.udiv (shl e_2 e_1 { «nsw» := false, «nuw» := true }) (mul e e_2 { «nsw» := false, «nuw» := true }) ⊑
    LLVM.udiv (shl (const? 5 1) e_1 { «nsw» := false, «nuw» := true }) e

theorem set_to_set_decomposebittest_proof : set_to_set_decomposebittest_before ⊑ set_to_set_decomposebittest_after

theorem select_icmp_eq_0_and_1_xor_1_proof : select_icmp_eq_0_and_1_xor_1_before ⊑ select_icmp_eq_0_and_1_xor_1_after

theorem and_xor_or7_thm (e e_1 e_2 : IntW 64) :
  LLVM.or (LLVM.udiv (const? 64 42) e_2)
      (LLVM.xor (LLVM.udiv (const? 64 42) e_1) (LLVM.and (LLVM.udiv (const? 64 42) e) (LLVM.udiv (const? 64 42) e_2))) ⊑
    LLVM.or (LLVM.udiv (const? 64 42) e_2) (LLVM.udiv (const? 64 42) e_1)

theorem bv_AndOrXor_1683_1 :
    ∀ (e e_1 : LLVM.IntW w),
      LLVM.or (LLVM.icmp LLVM.IntPred.ugt e e_1) (LLVM.icmp LLVM.IntPred.eq e e_1) ⊑ LLVM.icmp LLVM.IntPred.uge e e_1

theorem test1_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32), (x_1 &&& 7#32 ||| x &&& 8#32) &&& 7#32 = x_1 &&& 7#32

theorem tryFactorization_xor_lshr_ashr_proof : tryFactorization_xor_lshr_ashr_before ⊑ tryFactorization_xor_lshr_ashr_after

theorem t8_lshr_exact_flag_preservation_thm (e e_1 : IntW 32) :
  lshr (lshr e_1 (sub (const? 32 32) e) { «exact» := true }) (add e (const? 32 (-2))) { «exact» := true } ⊑
    lshr e_1 (const? 32 30) { «exact» := true }

theorem icmp_shl_ne_2_proof : icmp_shl_ne_2_before ⊑ icmp_shl_ne_2_after

theorem test_shl_nuw__nuw_is_safe_thm.extracted_1._4 : ∀ (x : BitVec 64) (x_1 : BitVec 32),
  ¬ofBool (x_1 &&& 1073741822#32 == 0#32) = 1#1 →
    ¬(True ∧ (x_1 &&& 1073741822#32) <<< 2#32 >>> 2#32 ≠ x_1 &&& 1073741822#32 ∨
          2#32 ≥ ↑32 ∨ zeroExtend 64 ((x_1 &&& 1073741822#32) <<< 2#32) ≥ ↑64) →
      ¬(2#32 ≥ ↑32 ∨
            True ∧ (x_1 <<< 2#32 &&& BitVec.ofInt 32 (-8)).msb = true ∨
              zeroExtend 64 (x_1 <<< 2#32 &&& BitVec.ofInt 32 (-8)) ≥ ↑64) →
        x.sshiftRight' (zeroExtend 64 ((x_1 &&& 1073741822#32) <<< 2#32)) =
          x.sshiftRight' (zeroExtend 64 (x_1 <<< 2#32 &&& BitVec.ofInt 32 (-8)))

theorem test2_proof : test2_before ⊑ test2_after

theorem lshrult_02_13_proof : lshrult_02_13_before ⊑ lshrult_02_13_after

@[bv_mba_preprocess]
theorem BitVec.add_ofInt_zero (x : BitVec w) : x + BitVec.ofInt w 0 = x

theorem ashrslt_03_06_exact_proof : ashrslt_03_06_exact_before ⊑ ashrslt_03_06_exact_after

theorem lshrult_01_01_exact_proof : lshrult_01_01_exact_before ⊑ lshrult_01_01_exact_after

theorem icmp_sle1_thm (e : IntW 8) :
  icmp IntPred.sle (shl e (const? 8 1) { «nsw» := true, «nuw» := false }) (const? 8 (-128)) ⊑
    icmp IntPred.eq e (const? 8 (-64))

theorem bools_logical_commute0_and1_thm.extracted_1._2 : ∀ (x x_1 : BitVec 1),
  (x_1 ^^^ 1#1) &&& x = 1#1 → ¬x_1 = 1#1 → 1#1 = x

theorem ashrsgt_02_00_thm (e : IntW 4) :
  icmp IntPred.sgt (ashr e (const? 4 2)) (const? 4 0) ⊑ icmp IntPred.sgt e (const? 4 3)

theorem p_commutative4_proof : p_commutative4_before ⊑ p_commutative4_after

theorem e_1356 :
    2 * t + 7 * z + 3 * (z ^^^ t) + 7 *  ~~~(z &&&  ~~~t) + 1 *  ~~~(z &&&  ~~~z) - 6 *  ~~~(z ^^^ t) - 7 *  ~~~(z ||| t) - 13 *  ~~~(z |||  ~~~t) - 6 * (z &&&  ~~~t) - 6 * (z &&& t) = 5 * (z ||| t) - 5 *  ~~~z

theorem main4e_like_logical_thm (e e_1 e_2 : IntW 32) :
  select (select (icmp IntPred.eq (LLVM.and e_2 e_1) e_1) (icmp IntPred.eq (LLVM.and e_2 e) e) (const? 1 0))
      (const? 32 0) (const? 32 1) ⊑
    zext 32
      (select (icmp IntPred.ne (LLVM.and e_2 e_1) e_1) (const? 1 1)
        (icmp IntPred.ne (LLVM.and e_2 e) e))

theorem pb_proof : pb_before ⊑ pb_after

theorem and1_shl1_is_cmp_eq_0_proof : and1_shl1_is_cmp_eq_0_before ⊑ and1_shl1_is_cmp_eq_0_after

theorem e_1361 :
    4 *  ~~~z + 2 * t + 1 *  ~~~(z &&&  ~~~z) - 3 *  ~~~(z ^^^ t) + 2 *  ~~~(z &&&  ~~~t) + 7 *  ~~~(z &&& t) + 4 *  ~~~t + 5 * (z ^^^ t) - 21 *  ~~~(z |||  ~~~t) - 17 * (z &&&  ~~~t) = 2 * (z &&& t) + 15 *  ~~~(z ||| t)

theorem trunc_shl_zext_64_thm.extracted_1._2 : ∀ (x : BitVec 64),
  ¬7#8 ≥ ↑8 → ¬7#64 ≥ ↑64 → zeroExtend 64 (truncate 8 x <<< 7#8) = x <<< 7#64 &&& 128#64

@[simp]
lemma RawCNFA.lift_processTrans_spec {m : CNFA n₁} {f : Fin n₁ → Fin n₂} :
    s' ∈ (lift.processTrans m.m f trs s₀ a).getD (s, b) ∅ ↔
      s' ∈ trs.getD (s, b) ∅ ∨ s = s₀ ∧ a = b ∧ s' ∈ m.m.tr s (b.transport f)

theorem masked_icmps_mask_notallzeros_bmask_mixed_negated_swapped_6_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x &&& 15#32 != 8#32) ||

@[simp]
theorem Array.not_elem_back_pop (a : Array X) (x : X) : a.toList.Nodup → a.back? = some x → x ∉ a.pop

theorem test6_thm (e : IntW 64) :
  trunc 32 (lshr (zext 128 e) (const? 128 32)) ⊑
    trunc 32 (lshr e (const? 64 32)) { «nsw» := false, «nuw» := true }

theorem icmp_equality_test_proof : icmp_equality_test_before ⊑ icmp_equality_test_after

theorem e_1949 :
     - 1 * (b |||  ~~~(a ^^^ c)) + 5 * ((b &&& c) ||| (a &&& (b ||| c))) + 11 *  ~~~(a &&& ( ~~~b ||| c)) - 2 * (c ^^^  ~~~(a &&& (b ||| c))) - 5 * ((a &&&  ~~~b) |||  ~~~(b ^^^ c)) - 7 * (c ^^^ ( ~~~a ||| (b &&& c))) - 7 * ( ~~~a &&& (b ^^^ c)) - 6 * ( ~~~a &&& (b ||| c)) - 5 * (b ^^^ ( ~~~a ||| (b ^^^ c))) + 1 * (b |||  ~~~(a |||  ~~~c)) - 2 * (c ^^^  ~~~( ~~~a ||| (b &&& c))) + 2 * ((b &&&  ~~~c) ^^^ ( ~~~a ||| (b ^^^ c))) + 11 *  ~~~(a ^^^ ( ~~~b &&& c)) + 3 *  ~~~(a ^^^ c) + 2 * (b ^^^  ~~~(a &&& (b ||| c))) - 5 * (c ^^^  ~~~(a ||| ( ~~~b &&& c))) - 3 * ((a ||| b) &&&  ~~~(b ^^^ c)) + 2 * ((a |||  ~~~b) &&& (b ^^^ c)) + 11 * ( ~~~(a &&& b) &&&  ~~~(a ^^^ (b ^^^ c))) + 7 *  ~~~b + 7 * ((a &&& c) ^^^  ~~~(a ^^^ (b &&& c))) - 6 * (b ^^^ (a ||| (b &&& c))) + 2 * ((a ^^^ b) &&&  ~~~(a ^^^ c)) - 1 * ((a ^^^ b) ||| (a ^^^ c)) - 11 *  ~~~(a ||| ( ~~~b &&& c)) - 3 *  ~~~(a ^^^ (b ^^^ c)) + 1 * (b ^^^ ( ~~~a &&& (b ||| c))) - 2 *  ~~~(a &&& (b ^^^ c)) + 1 * (c ^^^  ~~~(a ||| b)) + 1 * (a ||| ( ~~~b &&& c)) - 1 * ( ~~~a ||| (b ^^^ c)) - 11 *  ~~~( ~~~a ||| ( ~~~b &&& c)) + 1 * (b ^^^  ~~~(a |||  ~~~c)) - 6 *  ~~~( ~~~a ||| (b ^^^ c)) - 3 * (b &&&  ~~~(a &&&  ~~~c)) + 1 * (a &&& ( ~~~b ||| c)) + 5 * (b ^^^ ( ~~~a &&& ( ~~~b ||| c))) + 3 * (c ^^^ (a &&& b)) + 2 *  ~~~(a &&& (b ||| c)) - 3 * (c &&& (a |||  ~~~b)) + 4 * ( ~~~c &&&  ~~~(a ^^^ b)) - 1 * ( ~~~b &&& (a ^^^ c)) - 5 * (c ^^^ ( ~~~a ||| (b ||| c))) + 2 * ((a ||| b) &&& (a ^^^ (b ^^^ c))) + 3 * (b ^^^  ~~~(a ||| (b ^^^ c))) - 26 *  ~~~(a ||| (b ||| c)) + 5 *  ~~~(a ||| ( ~~~b ||| c)) + 20 *  ~~~( ~~~a ||| (b ||| c)) - 19 *  ~~~( ~~~a ||| ( ~~~b ||| c)) - 16 * ( ~~~a &&& ( ~~~b &&& c)) - 13 * ( ~~~a &&& (b &&& c)) - 17 * (a &&& ( ~~~b &&& c)) + 18 * (a &&& (b &&& c)) =  - 4 *  ~~~(a &&& ( ~~~b &&& c))

theorem ashr_and_thm.extracted_1._2 : ∀ (x : BitVec 8),
  ¬(x ≥ ↑8 ∨ x + 1#8 ≥ ↑8) →
    ¬x ≥ ↑8 →
      (BitVec.ofInt 8 (-64)).sshiftRight' x &&& (BitVec.ofInt 8 (-128)).sshiftRight' (x + 1#8) =
        (BitVec.ofInt 8 (-64)).sshiftRight' x

theorem shl_lshr_demand3_proof : shl_lshr_demand3_before ⊑ shl_lshr_demand3_after

@[symm] theorem Bisim.symm {a b : Stream α} : a ~ b → b ~ a

theorem neg_thm.extracted_1._1 : ∀ (x : BitVec 8), ¬42#8 = 0 → 0#8 - x ^^^ x / 42#8 = x / 42#8 ^^^ 0#8 - x

theorem and_xor_or8_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 64),
  ¬(x_2 = 0 ∨ x_1 = 0 ∨ x_2 = 0 ∨ x = 0) → x_2 = 0 ∨ x_1 = 0 → False

theorem alive_Select_1100  (w : Nat)   : alive_Select_1100_src w  ⊑ alive_Select_1100_tgt w

theorem eq_umax1_thm.extracted_1._2 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (x <ᵤ x_1) = 1#1 → ofBool (x == x_1) = ofBool (x ≤ᵤ x_1)

@[simp]
lemma complete_stepSet {M : NFA α σ} (q : σ) :
    (∀ q, (Sum.inl q ∈ S1) ↔ S2 q) →
    ((.inl q ∈ M.complete.stepSet S1 a) ↔ q ∈ M.stepSet S2 a)

theorem t6_no_extrause_proof : t6_no_extrause_before ⊑ t6_no_extrause_after

theorem sel_zext_thm.extracted_1._1 : ∀ (x : BitVec 1), ¬x = 1#1 → zeroExtend 64 42#32 = 42#64

theorem width5 (w : Nat) (a b : BitVec w) : (a + b = a - a) → a = - b

theorem sle_swap_and_min_commute_logical_thm.extracted_1._3 : ∀ (x x_1 : BitVec 8),
  ¬ofBool (x_1 == BitVec.ofInt 8 (-128)) = 1#1 → 0#1 = ofBool (x_1 == BitVec.ofInt 8 (-128))

theorem t2_proof : t2_before ⊑ t2_after

theorem e_1018 :
     - 1 * t + 7 *  ~~~(z &&& t) + 1 * (z |||  ~~~t) - 2 * (z ||| t) - 8 *  ~~~(z ||| t) - 6 * (z &&&  ~~~t) + 2 * (z &&& t) = 4 *  ~~~(z |||  ~~~t)

theorem alive_AndOrXor_2663  (w : Nat)   : alive_AndOrXor_2663_src w  ⊑ alive_AndOrXor_2663_tgt w

theorem zext_lshr_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬4#16 ≥ ↑16 → 4#8 ≥ ↑8 ∨ True ∧ (x >>> 4#8 &&& x).msb = true → False

theorem xor_ashr_not_fail_invalid_xor_constant_thm (e e_1 e_2 : IntW 8) :
  LLVM.xor (ashr e_2 e_1) (LLVM.xor (ashr e e_1) (const? 8 (-2))) ⊑
    LLVM.xor (ashr (LLVM.xor e e_2) e_1) (const? 8 (-2))

theorem and_ne_with_one_bit_diff_constants1_proof : and_ne_with_one_bit_diff_constants1_before ⊑ and_ne_with_one_bit_diff_constants1_after

theorem bools2_logical_commute1_and1_thm (e e_1 e_2 : IntW 1) :
  select (LLVM.and e_2 e_1) (const? 1 1) (select (LLVM.xor e_1 (const? 1 1)) e (const? 1 0)) ⊑ select e_1 e_2 e

theorem shl_mul_mask_proof : shl_mul_mask_before ⊑ shl_mul_mask_after

theorem in_constant_6_vary_invmask_proof : in_constant_6_vary_invmask_before ⊑ in_constant_6_vary_invmask_after

theorem negative3_thm (e e_1 e_2 : IntW 32) :
  LLVM.and (icmp IntPred.slt e_2 (LLVM.and e_1 (const? 32 2147483647))) (icmp IntPred.sge e (const? 32 0)) ⊑
    LLVM.and (icmp IntPred.slt e_2 (LLVM.and e_1 (const? 32 2147483647)))
      (icmp IntPred.sgt e (const? 32 (-1)))

theorem e_1800 :
     - 1 * (b ^^^ (a |||  ~~~c)) - 6 * (c ||| (a &&& b)) + 3 * ((a |||  ~~~b) &&&  ~~~(a ^^^ (b ^^^ c))) - 7 *  ~~~(b |||  ~~~c) - 1 *  ~~~(b &&&  ~~~c) + 5 *  ~~~(a ||| b) + 1 * (b ^^^  ~~~(a &&& (b &&& c))) - 5 * (c ^^^ (a &&& b)) - 11 * (c ^^^ (a &&&  ~~~b)) - 2 * (c ^^^ (a ||| (b &&& c))) - 11 * ((b &&& c) ||| (a &&& (b ||| c))) + 4 * (b ^^^ (a &&&  ~~~c)) - 5 * ((a &&& c) ^^^ (a ^^^ ( ~~~b &&& c))) - 2 * ((b &&&  ~~~c) |||  ~~~( ~~~a ||| ( ~~~b &&& c))) - 1 * (b &&& (a ||| c)) - 1 * (b &&&  ~~~c) + 2 * (c ^^^  ~~~( ~~~a &&& ( ~~~b &&& c))) - 2 * ( ~~~a ||| (b ||| c)) - 5 * ((b &&&  ~~~c) ^^^ ( ~~~a ||| (b ^^^ c))) - 2 *  ~~~b + 5 *  ~~~(a |||  ~~~c) + 4 * (b ^^^  ~~~(a |||  ~~~c)) - 2 * (b ^^^ (a ||| c)) + 4 * (a &&& ( ~~~b ||| c)) - 3 * ((a &&& b) |||  ~~~(b ||| c)) + 3 * ( ~~~(a |||  ~~~b) |||  ~~~(a ^^^ (b ^^^ c))) + 5 * (a &&&  ~~~b) - 1 * (c &&&  ~~~(a ^^^ b)) + 5 * ((a ||| b) &&& (b ^^^ c)) + 2 *  ~~~(a &&& ( ~~~b ||| c)) + 3 * ((b &&&  ~~~c) ^^^ (a ||| (b ^^^ c))) - 7 * (a ||| (b &&& c)) + 1 * ( ~~~(a &&&  ~~~b) &&&  ~~~(a ^^^ (b ^^^ c))) - 3 *  ~~~(a ||| (b ||| c)) - 13 *  ~~~(a ||| ( ~~~b ||| c)) + 17 *  ~~~( ~~~a ||| (b ||| c)) + 25 *  ~~~( ~~~a ||| ( ~~~b ||| c)) + 35 * ( ~~~a &&& (b &&& c)) + 30 * (a &&& ( ~~~b &&& c)) + 29 * (a &&& (b &&& c)) =  - 27 * ( ~~~a &&& ( ~~~b &&& c))

theorem udiv1_thm (e e_1 : IntW 32) : mul (LLVM.udiv e_1 e { «exact» := true }) e ⊑ e_1

theorem icmp_ugt_proof : icmp_ugt_before ⊑ icmp_ugt_after

theorem bv_AndOrXor_1253_A__AB___A__B :
    ∀ (e e_1 : LLVM.IntW w), LLVM.and (LLVM.xor e e_1) e ⊑ LLVM.and e (LLVM.xor e_1 (LLVM.const? w (-1)))

theorem lshrugt_02_12_exact_thm (e : IntW 4) :
  icmp IntPred.ugt (lshr e (const? 4 2) { «exact» := true }) (const? 4 (-4)) ⊑ const? 1 0

theorem sub_shl_same_amount_proof : sub_shl_same_amount_before ⊑ sub_shl_same_amount_after

@[bv_multi_width_normalize] theorem iff_eq (p q : Prop) : (p ↔ q) = (p = q)

@[simp] theorem cons_getElem_toCons (x : A a) (v : Var Γ u)
    (h : as = Γ.toList := by rfl) (h' : a :: as = (Γ.cons a).toList := by rfl) :
    (HVector.cons x xs)[v.toCons (t' := a)]'h' = xs[v]'h

theorem lshrugt_02_13_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬2#4 ≥ ↑4 → ofBool (BitVec.ofInt 4 (-3) <ᵤ x >>> 2#4) = 0#1

theorem test5_proof : test5_before ⊑ test5_after

theorem shl_xor_xor_bad_mask_distribute_proof : shl_xor_xor_bad_mask_distribute_before ⊑ shl_xor_xor_bad_mask_distribute_after

theorem t4_thm (e : IntW 1) (e_1 : IntW 8) :
  sub e_1 (select e (const? 8 (-42)) (const? 8 44)) ⊑ add (select e (const? 8 42) (const? 8 (-44))) e_1

theorem main4_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬ofBool (x &&& 7#32 == 7#32) &&& ofBool (x &&& 48#32 == 48#32) = 1#1 →
    1#32 = zeroExtend 32 (ofBool (x &&& 55#32 != 55#32))

theorem test10_thm.extracted_1._1 : ∀ (x : BitVec 8), True ∧ (x &&& 3#8 &&& 4#8 != 0) = true → False

theorem scalar_i32_shl_and_negC_eq_proof : scalar_i32_shl_and_negC_eq_before ⊑ scalar_i32_shl_and_negC_eq_after

theorem test_invert_demorgan_logical_or_proof : test_invert_demorgan_logical_or_before ⊑ test_invert_demorgan_logical_or_after

theorem or_shl_proof : or_shl_before ⊑ or_shl_after

theorem t2_thm (e : IntW 64) :
  sub (const? 32 0) (trunc 32 (ashr e (const? 64 63))) ⊑
    trunc 32 (lshr e (const? 64 63)) { «nsw» := true, «nuw» := true }

omit [LawfulBEq A] [Fintype S] in
lemma processOneElem_rel_preserve_olds :
    s₂ ~[(processOneElem A S final s₁ st (a, sa)).rel] sa' →
    s₂ ∈ st.m.states → s₂ ~[st.rel] sa'

theorem sdiv_shl_pair_const_thm (e : IntW 32) :
  LLVM.sdiv (shl e (const? 32 2) { «nsw» := true, «nuw» := false })
      (shl e (const? 32 1) { «nsw» := true, «nuw» := false }) ⊑
    const? 32 2

theorem ashrsgt_01_13_proof : ashrsgt_01_13_before ⊑ ashrsgt_01_13_after

theorem test22_logical_proof : test22_logical_before ⊑ test22_logical_after

theorem icmp_ult_8_proof : icmp_ult_8_before ⊑ icmp_ult_8_after

theorem test7_proof : test7_before ⊑ test7_after

theorem a_false_implies_b_false2_comm_thm.extracted_1._6 : ∀ (x x_1 : BitVec 1) (x_2 : BitVec 8),
  ofBool (20#8 <ᵤ x_2) = 1#1 → ¬ofBool (10#8 <ᵤ x_2) = 1#1 → x_1 ||

theorem bools_logical_commute0_and2_thm.extracted_1._18 : ∀ (x x_1 x_2 : BitVec 1),
  ¬x_2 ^^^ 1#1 = 1#1 → ¬x_2 = 1#1 → ¬0#1 = 1#1 → x_2 &&& x = x_1

theorem lshr_or_thm (e : IntW 8) :
  LLVM.or (lshr (const? 8 16) e) (lshr (const? 8 3) (add e (const? 8 1))) ⊑ lshr (const? 8 17) e

theorem urem_common_dividend_defined_cond_thm (e e_1 e_2 : IntW 5) (e_3 : IntW 1) :
  select e_3 (urem e_2 e_1) (urem e_2 e) ⊑ urem e_2 (select e_3 e_1 e)

theorem ashr_overshift_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬(15#32 ≥ ↑32 ∨ 17#32 ≥ ↑32) → ¬31#32 ≥ ↑32 → (x.sshiftRight' 15#32).sshiftRight' 17#32 = x.sshiftRight' 31#32

theorem nonexact_lshr_ne_noexactlog_proof : nonexact_lshr_ne_noexactlog_before ⊑ nonexact_lshr_ne_noexactlog_after

theorem shift_xor_multiuse_cmp_with_xor_thm.extracted_1._3 : ∀ (x x_1 x_2 x_3 : BitVec 32),
  ofBool (0#32 != x_3 &&& 4096#32) = 1#1 → ofBool (x_3 &&& 4096#32 == 0#32) = 1#1 → x_2 * x_1 = (x_2 ^^^ 2048#32) * x

theorem test47_thm (e : IntW 8) :
  zext 64 (LLVM.or (sext 32 e) (const? 32 42)) ⊑ zext 64 (sext 32 (LLVM.or e (const? 8 42)))

theorem e_2360 :
     - 1 * ( ~~~d ||| (e ||| f)) - 3 * (e ^^^ ( ~~~d &&& (e ^^^ f))) - 1 *  ~~~(d |||  ~~~e) + 7 * (e ^^^  ~~~( ~~~d &&& (e ^^^ f))) + 1 * (f ||| (d &&& e)) + 1 * (e ^^^ ( ~~~d ||| ( ~~~e ||| f))) - 7 *  ~~~(d ^^^ e) - 11 * ((d &&& e) ||| (e ^^^ f)) - 1 * (d ||| e) - 2 * (e ^^^ (d ||| (e &&& f))) + 2 * ( ~~~(d &&&  ~~~e) &&&  ~~~(d ^^^ (e ^^^ f))) + 11 * ((d &&& f) ^^^  ~~~(d ^^^ (e &&& f))) - 3 * ( ~~~d ||| ( ~~~e ||| f)) + 1 * (e ^^^ ( ~~~d ||| (e ||| f))) + 5 * (f ^^^  ~~~( ~~~d &&& ( ~~~e ||| f))) - 5 * ((d &&&  ~~~e) ||| (e ^^^ f)) - 5 *  ~~~(d ||| (e ^^^ f)) - 5 * ((d &&& e) ^^^ (d ^^^ ( ~~~e ||| f))) + 11 * ( ~~~d &&& (e ^^^ f)) - 6 *  ~~~(d &&&  ~~~f) + 2 * (e &&&  ~~~f) - 7 *  ~~~(d &&& (e &&& f)) - 11 *  ~~~(d &&& e) - 5 * (e ^^^ f) + 5 * ( ~~~f &&& (d ^^^ e)) + 1 * ((d |||  ~~~e) &&& (d ^^^ (e ^^^ f))) + 4 * (e ^^^  ~~~(d ||| (e &&& f))) + 3 * (e ^^^  ~~~( ~~~d &&& (e ||| f))) + 1 *  ~~~e - 1 * (e ^^^ (d |||  ~~~f)) + 7 * ( ~~~f &&&  ~~~(d ^^^ e)) - 11 *  ~~~d - 1 * (e ^^^ ( ~~~d &&& (e ||| f))) - 1 * ((d ||| e) &&&  ~~~(d ^^^ (e ^^^ f))) + 4 * (f ^^^ (d &&& ( ~~~e ||| f))) + 1 * (d ^^^ ( ~~~e ||| f)) - 6 * ((d |||  ~~~e) &&&  ~~~(d ^^^ (e ^^^ f))) + 1 * (f ^^^  ~~~(d &&& (e ||| f))) + 2 * ((d &&& e) ^^^ (d ^^^ (e &&& f))) - 1 * (e ||| (d &&&  ~~~f)) + 4 *  ~~~(d &&&  ~~~d) - 2 * (d ^^^ (e ^^^ f)) + 1 * ((d |||  ~~~e) &&& (e ^^^ f)) + 2 * ( ~~~(d |||  ~~~e) |||  ~~~(d ^^^ (e ^^^ f))) - 1 * (f |||  ~~~(d ||| e)) + 4 * (e ^^^  ~~~( ~~~d ||| ( ~~~e &&& f))) + 1 * (d &&&  ~~~e) + 5 * ((e &&& f) ||| ( ~~~d &&& (e ||| f))) + 4 * ( ~~~(d ^^^ e) &&& (d ^^^ f)) - 7 * (d ||| ( ~~~e ||| f)) + 3 * ((d ^^^ e) |||  ~~~(d ^^^ f)) - 1 * (d &&& e) - 2 *  ~~~(e |||  ~~~f) - 5 *  ~~~(e ^^^ f) + 2 * ((d ^^^ e) &&&  ~~~(d ^^^ f)) + 5 * (f &&&  ~~~(d &&&  ~~~e)) + 11 *  ~~~(e &&& f) + 2 * (e ^^^  ~~~(d ||| ( ~~~e &&& f))) - 6 * (d &&& (e ^^^ f)) - 3 * ( ~~~e &&& (d ^^^ f)) + 17 *  ~~~(d ||| (e ||| f)) - 7 *  ~~~(d ||| ( ~~~e ||| f)) - 3 *  ~~~( ~~~d ||| (e ||| f)) + 16 *  ~~~( ~~~d ||| ( ~~~e ||| f)) + 22 * ( ~~~d &&& ( ~~~e &&& f)) + 25 * ( ~~~d &&& (e &&& f)) + 24 * (d &&& ( ~~~e &&& f)) + 29 * (d &&& (e &&& f)) = 2 * ( ~~~(d ||| e) ||| (d ^^^ (e ^^^ f)))

theorem a_false_implies_b_false_proof : a_false_implies_b_false_before ⊑ a_false_implies_b_false_after

theorem lshrugt_03_00_thm (e : IntW 4) :
  icmp IntPred.ugt (lshr e (const? 4 3)) (const? 4 0) ⊑ icmp IntPred.slt e (const? 4 0)

theorem n11_wrong_pred3_thm (e e_1 : IntW 8) :
  icmp IntPred.ne (add e_1 e) e ⊑ icmp IntPred.ne e_1 (const? 8 0)

theorem positive_with_signbit_proof : positive_with_signbit_before ⊑ positive_with_signbit_after

theorem ugt_or_not_min_commute_logical_thm.extracted_1._3 : ∀ (x x_1 : BitVec 8),
  ¬ofBool (x_1 != 0#8) = 1#1 → ofBool (x <ᵤ x_1) = ofBool (x_1 != 0#8)

theorem simplify_or_common_op_commute1_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 4),
  x_2 &&& x_1 &&& x ^^^ -1#4 ||

theorem and_sel_op0_thm.extracted_1._2 : ∀ (x : BitVec 1), ¬x = 1#1 → 0#32 &&& 1#32 = zeroExtend 32 x

theorem xor_signbit_select_ashr_thm (e : IntW 32) (e_1 : IntW 1) :
  ashr (select e_1 (LLVM.xor e (const? 32 (-65536))) e) (const? 32 8) ⊑
    select e_1 (LLVM.xor (ashr e (const? 32 8)) (const? 32 (-256))) (ashr e (const? 32 8))

theorem samesign_inverted_different_sign_bittest1_proof : samesign_inverted_different_sign_bittest1_before ⊑ samesign_inverted_different_sign_bittest1_after

@[simp]
theorem Term.denoteFin_width_zero  (t : Term) (env : EnvFin 0 t.numVars) :
    t.denoteFin env = 0

theorem main5_like_logical_thm.extracted_1._11 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (x_1 &&& 7#32 == 7#32) = 1#1 →
    ¬ofBool (x_1 &&& 7#32 != 7#32) = 1#1 → 0#1 = 1#1 → 0#32 = zeroExtend 32 (ofBool (x &&& 7#32 != 7#32))

theorem add_select_zext_thm.extracted_1._2 : ∀ (x : BitVec 1), ¬x = 1#1 → 1#64 + zeroExtend 64 x = 1#64

theorem mul_add_to_mul_7_thm.extracted_1._1 : ∀ (x : BitVec 16),
  ¬(True ∧ x.smulOverflow 32767#16 = true ∨ True ∧ x.saddOverflow (x * 32767#16) = true) → 15#16 ≥ ↑16 → False

theorem e_74 :
     - 6 * (x ||| y) + 4 * (x ^^^ y) + 2 *  ~~~(x ||| y) + 4 *  ~~~(x |||  ~~~y) + 2 * (x &&&  ~~~y) = 2 *  ~~~x - 6 * (x &&& y)

theorem PR42691_7_logical_proof : PR42691_7_logical_before ⊑ PR42691_7_logical_after

theorem sel_false_val_is_a_masked_ashr_of_true_val1_thm.extracted_1._3 : ∀ (x : BitVec 64) (x_1 : BitVec 32),
  ¬ofBool (x_1 &&& BitVec.ofInt 32 (-2147483588) == 0#32) = 1#1 →
    ¬(2#32 ≥ ↑32 ∨ zeroExtend 64 ((x_1 &&& BitVec.ofInt 32 (-2147483588)).sshiftRight' 2#32) ≥ ↑64) →
      2#32 ≥ ↑32 ∨
          True ∧ (x_1.sshiftRight' 2#32 &&& BitVec.ofInt 32 (-536870897)).msb = true ∨
            zeroExtend 64 (x_1.sshiftRight' 2#32 &&& BitVec.ofInt 32 (-536870897)) ≥ ↑64 →
        False

theorem not_or_or_and_not_and_and_commute2_thm (e e_1 e_2 : IntW 32) :
  LLVM.and (LLVM.or (LLVM.or (LLVM.xor e_2 (const? 32 (-1))) e_1) (LLVM.sdiv (const? 32 42) e))
      (LLVM.xor (LLVM.and (LLVM.sdiv (const? 32 42) e) (LLVM.and e_1 e_2)) (const? 32 (-1))) ⊑
    LLVM.or (LLVM.xor (LLVM.sdiv (const? 32 42) e) e_1) (LLVM.xor e_2 (const? 32 (-1)))

@[simp]
theorem ofBitVecSextMsb_eq_concat_ofBitVec (x : BitVec w) :
    ofBitVecSextMsb x = (ofBitVecSext x).concat false

theorem fold_mask_cmps_to_true_proof : fold_mask_cmps_to_true_before ⊑ fold_mask_cmps_to_true_after

theorem test_invert_demorgan_logical_and_thm.extracted_1._4 : ∀ (x x_1 : BitVec 64),
  ofBool (x_1 == 27#64) = 1#1 →
    ¬ofBool (x_1 != 27#64) = 1#1 →
      (ofBool (x_1 == 0#64) ||| ofBool (x == 0#64)) ^^^ 1#1 = ofBool (x_1 != 0#64) &&& ofBool (x != 0#64)

theorem logic_and_logic_or_3_thm.extracted_1._2 : ∀ (x x_1 : BitVec 1), x_1 = 1#1 → x = 1#1 → 1#1 = x

theorem exact_lshr_ne_opposite_msb_thm (e : IntW 8) :
  icmp IntPred.ne (lshr (const? 8 (-128)) e { «exact» := true }) (const? 8 1) ⊑
    icmp IntPred.ne e (const? 8 7)

theorem test6a_thm.extracted_1._1 : ∀ (x : BitVec 1), ofBool (zeroExtend 32 x != -1#32) = 1#1

theorem test1_thm (e : IntW 17) :
  trunc 17 (LLVM.or (lshr (zext 37 e) (const? 37 8)) (shl (zext 37 e) (const? 37 8))) ⊑
    LLVM.or (lshr e (const? 17 8)) (shl e (const? 17 8))

theorem cmpeq_bitwise_proof : cmpeq_bitwise_before ⊑ cmpeq_bitwise_after

theorem splat_mul_known_lz_proof : splat_mul_known_lz_before ⊑ splat_mul_known_lz_after

theorem test3_thm.extracted_1._1 : ∀ (x : BitVec 41), ofBool (x <ₛ 0#41) = 1#1 → 40#41 ≥ ↑41 → False

theorem t0_thm.extracted_1._24 : ∀ (x x_1 x_2 : BitVec 8) (x_3 : BitVec 1),
  x_3 ^^^ 1#1 = 1#1 → ¬x_3 = 1#1 → ¬True → 0#1 = 1#1 → x_1 = x

theorem test19_thm (e : IntW 32) : LLVM.and (shl e (const? 32 3)) (const? 32 (-2)) ⊑ shl e (const? 32 3)

@[simp low]
theorem eval_latchImmediate_zero_eq (initVal : Bool)
    (x : Bool → BitStream) :
    (latchImmediate initVal).eval x 0 =
      if (x true 0) then (x false 0) else initVal

theorem bad_shl2_sub_i32_proof : bad_shl2_sub_i32_before ⊑ bad_shl2_sub_i32_after

theorem ashr_eq_msb_low_second_zero_proof : ashr_eq_msb_low_second_zero_before ⊑ ashr_eq_msb_low_second_zero_after

theorem t1_ult_slt_0_thm (e e_1 e_2 : IntW 32) :
  select (icmp IntPred.ult e_2 (const? 32 65536)) e_2 (select (icmp IntPred.slt e_2 (const? 32 0)) e_1 e) ⊑
    select (icmp IntPred.sgt e_2 (const? 32 65535)) e
      (select (icmp IntPred.slt e_2 (const? 32 0)) e_1 e_2)

theorem lor_land_right2_proof : lor_land_right2_before ⊑ lor_land_right2_after

theorem ugt_swap_and_min_commute_thm (e e_1 : IntW 8) :
  LLVM.and (icmp IntPred.eq e_1 (const? 8 0)) (icmp IntPred.ult e e_1) ⊑ const? 1 0

theorem icmp_eq_x_invertable_y2_todo_thm (e : IntW 8) (e_1 : IntW 1) :
  icmp IntPred.eq (select e_1 (const? 8 7) (const? 8 24)) (LLVM.and e (select e_1 (const? 8 7) (const? 8 24))) ⊑
    icmp IntPred.eq (LLVM.or e (select e_1 (const? 8 (-8)) (const? 8 (-25)))) (const? 8 (-1))

theorem e_1196 :
     - 6 * t + 4 * (z ||| t) - 5 *  ~~~t + 7 *  ~~~(z ^^^ t) + 4 *  ~~~z - 3 *  ~~~(z ||| t) - 2 *  ~~~(z |||  ~~~t) + 4 * (z &&&  ~~~t) = 2 * (z &&& t) + 3 * (z |||  ~~~t)

theorem shl_or_disjoint_lshr_comm_proof : shl_or_disjoint_lshr_comm_before ⊑ shl_or_disjoint_lshr_comm_after

theorem PR96857_xor_without_noundef_proof : PR96857_xor_without_noundef_before ⊑ PR96857_xor_without_noundef_after

theorem test3_logical_thm (e e_1 : IntW 32) :
  select (icmp IntPred.eq (sub e_1 e { «nsw» := true, «nuw» := false }) (const? 32 0)) (const? 1 1)
      (icmp IntPred.eq (sub e_1 e { «nsw» := true, «nuw» := false }) (const? 32 31)) ⊑
    select (icmp IntPred.eq e_1 e) (const? 1 1)
      (icmp IntPred.eq (sub e_1 e { «nsw» := true, «nuw» := false }) (const? 32 31))

theorem trunc_lshr_trunc_thm (e : IntW 64) : trunc 8 (lshr (trunc 32 e) (const? 32 8)) ⊑ trunc 8 (lshr e (const? 64 8))

theorem toTensor_length_eq_rep_length [Fact (q > 1)] (a : R q n) :
  a.toTensor.length = a.repLength

theorem main10_thm (e : IntW 32) :
  select
      (LLVM.and (icmp IntPred.eq (LLVM.and e (const? 32 64)) (const? 32 0))
        (icmp IntPred.sge (trunc 8 e) (const? 8 0)))
      (const? 32 2) (const? 32 1) ⊑
    select (icmp IntPred.eq (LLVM.and e (const? 32 192)) (const? 32 0)) (const? 32 2) (const? 32 1)

theorem t3_singlebit_thm (e e_1 : IntW 32) :
  icmp IntPred.ne
      (LLVM.and (shl e_1 (sub (const? 32 32) e))
        (trunc 32 (lshr (const? 64 65536) (zext 64 (add e (const? 32 (-16)))))))
      (const? 32 0) ⊑
    icmp IntPred.ne (LLVM.and e_1 (const? 32 1)) (const? 32 0)

theorem eq_21_comm_eq2_proof : eq_21_comm_eq2_before ⊑ eq_21_comm_eq2_after

theorem test15_thm (e : IntW 32) :
  sext 32 (icmp IntPred.ne (LLVM.and e (const? 32 16)) (const? 32 0)) ⊑
    ashr (shl e (const? 32 27)) (const? 32 31)

theorem scalar_i64_lshr_and_negC_eq_proof : scalar_i64_lshr_and_negC_eq_before ⊑ scalar_i64_lshr_and_negC_eq_after

theorem ripple_nsw6_proof : ripple_nsw6_before ⊑ ripple_nsw6_after

theorem c_0_1_0_proof : c_0_1_0_before ⊑ c_0_1_0_after

theorem or_trunc_lshr_more_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬4#8 ≥ ↑8 → 4#6 ≥ ↑6 ∨ True ∧ (truncate 6 x >>> 4#6 &&& BitVec.ofInt 6 (-4) != 0) = true → False

theorem e_1641 :
     - 2 * (b ^^^ (a |||  ~~~c)) - 3 * ((a &&& b) |||  ~~~(a ^^^ (b ^^^ c))) - 1 * (b ^^^  ~~~(a ||| ( ~~~b &&& c))) + 7 * ((a &&&  ~~~b) ||| (a ^^^ (b ^^^ c))) - 2 * ( ~~~(a ^^^ b) |||  ~~~(a ^^^ c)) + 7 * (c &&& (a |||  ~~~b)) - 5 * (b ^^^  ~~~( ~~~a &&& ( ~~~b &&& c))) + 3 * (b ^^^ (a ||| ( ~~~b ||| c))) + 3 * (c ^^^  ~~~( ~~~a &&& ( ~~~b &&& c))) - 11 *  ~~~(b |||  ~~~c) + 4 * ((a &&&  ~~~b) |||  ~~~(b ^^^ c)) + 11 * (c ^^^ (a &&& (b ||| c))) - 1 *  ~~~(a ||| (b ^^^ c)) - 2 *  ~~~(a &&& (b ^^^ c)) + 5 *  ~~~(a ||| (b ||| c)) - 10 *  ~~~(a ||| ( ~~~b ||| c)) - 8 *  ~~~( ~~~a ||| (b ||| c)) - 8 *  ~~~( ~~~a ||| ( ~~~b ||| c)) - 16 * ( ~~~a &&& ( ~~~b &&& c)) - 7 * ( ~~~a &&& (b &&& c)) + 1 * (a &&& ( ~~~b &&& c)) - 11 * (a &&& (b &&& c)) =  - 1 *  ~~~(a ^^^ c)

theorem icmp_slt_0_and_icmp_ne_neg2_i32_fail_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬31#32 ≥ ↑32 →
    x >>> 31#32 &&& zeroExtend 32 (ofBool (x != BitVec.ofInt 32 (-2))) =
      zeroExtend 32 (ofBool (x <ₛ 0#32) &&& ofBool (x != BitVec.ofInt 32 (-2)))

theorem exact_ashr_eq_proof : exact_ashr_eq_before ⊑ exact_ashr_eq_after

theorem shift_xor_multiuse_cmp_and_thm.extracted_1._2 : ∀ (x x_1 x_2 : BitVec 32),
  ¬ofBool (0#32 != x_2 &&& 4096#32) = 1#1 → ¬ofBool (x_2 &&& 4096#32 == 0#32) = 1#1 → False

theorem PR42691_3_logical_proof : PR42691_3_logical_before ⊑ PR42691_3_logical_after

theorem lshrugt_03_04_proof : lshrugt_03_04_before ⊑ lshrugt_03_04_after

theorem test_implied_true_proof : test_implied_true_before ⊑ test_implied_true_after

@[simp]
theorem isRefinedBy_iff [HRefinement α γ] [HRefinement β δ]
    (a : α) (b : β) (c : γ) (d : δ) :
    (a, b) ⊑ (c, d) ↔ a ⊑ c ∧ b ⊑ d

theorem trunc_shl_7_i8_i64_thm.extracted_1._2 : ∀ (x : BitVec 64),
  ¬7#64 ≥ ↑64 → ¬7#8 ≥ ↑8 → truncate 8 (x <<< 7#64) = truncate 8 x <<< 7#8

theorem lshrugt_03_00_exact_thm (e : IntW 4) :
  icmp IntPred.ugt (lshr e (const? 4 3) { «exact» := true }) (const? 4 0) ⊑
    icmp IntPred.ne e (const? 4 0)

theorem main7a_logical_thm.extracted_1._12 : ∀ (x x_1 x_2 : BitVec 32),
  ¬ofBool (x_2 &&& x_1 == x_2) = 1#1 →
    ¬ofBool (x_2 &&& x_1 != x_2) = 1#1 → ¬0#1 = 1#1 → 1#32 = zeroExtend 32 (ofBool (x &&& x_1 != x))

theorem not_and_and_not_proof : not_and_and_not_before ⊑ not_and_and_not_after

theorem p_commutative2_thm (e e_1 e_2 : IntW 32) :
  LLVM.xor (LLVM.and (LLVM.xor e_2 (const? 32 (-1))) e_1) (LLVM.and e e_2) ⊑
    LLVM.or (LLVM.and e_1 (LLVM.xor e_2 (const? 32 (-1)))) (LLVM.and e e_2) { «disjoint» := true }

@[aesop 50% unsafe]
theorem Std.HashMap.mem_of_getElem? [BEq K] [LawfulBEq K] [Hashable K] [LawfulHashable K] {m : Std.HashMap K V} {k : K} :
    m[k]? = some v → k ∈ m

theorem e_1828 :
    4 * (c &&& (a |||  ~~~b)) + 7 * ( ~~~(a &&& b) &&& (a ^^^ (b ^^^ c))) - 1 * ((a &&& b) |||  ~~~(b ^^^ c)) + 11 *  ~~~(a ^^^ ( ~~~b &&& c)) - 6 * (b &&&  ~~~(a &&&  ~~~c)) - 1 * ((a ||| b) &&&  ~~~(b ^^^ c)) + 4 * (b ^^^  ~~~( ~~~a &&& (b ^^^ c))) + 1 * (b ^^^ (a &&& (b ^^^ c))) + 3 * ((b &&&  ~~~c) |||  ~~~(a ||| ( ~~~b &&& c))) + 1 * (b ^^^  ~~~(a &&& ( ~~~b ||| c))) + 2 * ( ~~~(a &&& b) &&&  ~~~(b ^^^ c)) + 2 * ( ~~~a ||| (b ^^^ c)) - 11 * ( ~~~(a |||  ~~~b) ||| (a ^^^ (b ^^^ c))) - 1 * (a ||| ( ~~~b &&& c)) + 2 *  ~~~(b |||  ~~~c) - 1 * (b ^^^  ~~~(a ||| ( ~~~b &&& c))) + 4 * (c ^^^ (a &&& ( ~~~b ||| c))) - 7 * (b ^^^ ( ~~~a ||| (b ||| c))) - 2 * ( ~~~(a ^^^ b) &&& (a ^^^ c)) + 2 * (c ||| (a ^^^ b)) + 7 * (c ||| (a &&& b)) - 1 * ( ~~~a ||| ( ~~~b &&& c)) + 4 * (b ^^^ ( ~~~a ||| (b &&& c))) - 1 * (b ^^^ c) - 2 * (c &&&  ~~~(a &&&  ~~~b)) + 5 * ( ~~~(a ^^^ b) |||  ~~~(a ^^^ c)) + 1 * c - 11 * (a ||| (b ||| c)) + 11 * ((a |||  ~~~b) &&& (b ^^^ c)) + 3 * ((a &&& c) |||  ~~~(b ||| c)) + 2 * (b ^^^ (a &&& (b ||| c))) + 1 * (a ^^^ ( ~~~b &&& c)) - 1 * (a ^^^ (b ||| c)) + 1 * ((a &&& c) ||| (b &&&  ~~~c)) - 2 * (c ^^^ (a ||| (b ||| c))) + 5 * (c ^^^ (a &&& (b ||| c))) - 30 *  ~~~(a ||| (b ||| c)) - 5 *  ~~~(a ||| ( ~~~b ||| c)) - 25 *  ~~~( ~~~a ||| ( ~~~b ||| c)) - 24 * ( ~~~a &&& ( ~~~b &&& c)) - 6 * ( ~~~a &&& (b &&& c)) - 40 * (a &&& ( ~~~b &&& c)) + 8 * (a &&& (b &&& c)) =  - 5 * (b ^^^ ( ~~~a ||| ( ~~~b ||| c)))

theorem positive_sameconst_shlnuw_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬(3#8 ≥ ↑8 ∨ True ∧ x.sshiftRight' 3#8 <<< 3#8 >>> 3#8 ≠ x.sshiftRight' 3#8 ∨ 3#8 ≥ ↑8) →
    x.sshiftRight' 3#8 <<< 3#8 = x &&& BitVec.ofInt 8 (-8)

theorem ashrsgt_03_05_thm (e : IntW 4) : icmp IntPred.sgt (ashr e (const? 4 3)) (const? 4 5) ⊑ const? 1 0

theorem test_shl_nuw_nsw__nuw_is_safe_proof : test_shl_nuw_nsw__nuw_is_safe_before ⊑ test_shl_nuw_nsw__nuw_is_safe_after

theorem sdiv_exact_ne_1_thm (e e_1 : IntW 8) :
  icmp IntPred.eq (LLVM.sdiv e_1 e { «exact» := true }) (const? 8 0) ⊑
    icmp IntPred.eq e_1 (const? 8 0)

theorem logic_or_logic_and_7_thm.extracted_1._6 : ∀ (x x_1 x_2 : BitVec 1),
  ¬x_2 = 1#1 → ¬x = 1#1 → x_1 = 1#1 → 0#1 = 1#1 → x_1 = 1#1

theorem main3c_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬ofBool (x &&& 7#32 != 0#32) ||

theorem positive_biggershl_shlnsw_lshrexact_thm.extracted_1._2 : ∀ (x : BitVec 8),
  ¬(True ∧ x >>> 3#8 <<< 3#8 ≠ x ∨ 3#8 ≥ ↑8 ∨ True ∧ (x >>> 3#8 <<< 6#8).sshiftRight' 6#8 ≠ x >>> 3#8 ∨ 6#8 ≥ ↑8) →
    ¬(True ∧ (x <<< 3#8).sshiftRight' 3#8 ≠ x ∨ True ∧ x <<< 3#8 >>> 3#8 ≠ x ∨ 3#8 ≥ ↑8) →
      x >>> 3#8 <<< 6#8 = x <<< 3#8

theorem lshrult_03_09_proof : lshrult_03_09_before ⊑ lshrult_03_09_after

theorem e_959 :
     - 6 * t - 1 *  ~~~t + 1 *  ~~~(z ||| t) + 6 *  ~~~(z |||  ~~~t) + 2 * (z &&&  ~~~t) + 7 * (z &&& t) = 1 * z

theorem lshrult_01_05_exact_proof : lshrult_01_05_exact_before ⊑ lshrult_01_05_exact_after

theorem eval_sext_multi_use_in_one_inst_proof : eval_sext_multi_use_in_one_inst_before ⊑ eval_sext_multi_use_in_one_inst_after

theorem t1_const_shl_lshr_ne_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬(1#32 ≥ ↑32 ∨ 1#32 ≥ ↑32) → 2#32 ≥ ↑32 → False

theorem BitVec.even_mul_eq_shiftLeft_mul_of_eq_mul_two
    (w : Nat) (x : BitVec w) (n e : Nat) (he : e = n * 2) :
    (BitVec.ofNat w e) * x = (BitVec.ofNat w n) * (x <<< (1 : Nat))

theorem slt_zero_ne_ne_0_proof : slt_zero_ne_ne_0_before ⊑ slt_zero_ne_ne_0_after

@[simp] theorem eval_trueUptoExcluding (n : Nat) {env : Fin 0 → BitStream} :
    (trueUptoExcluding n).eval env = fun i => decide (i < n)

theorem e_693 :
     - 11 * x + 1 *  ~~~(x &&& y) + 2 *  ~~~(x &&&  ~~~x) + 1 *  ~~~x + 1 * (x |||  ~~~y) + 1 * y + 1 *  ~~~(x ^^^ y) - 6 *  ~~~y + 13 * (x &&&  ~~~y) + 6 * (x &&& y) = 5 *  ~~~(x |||  ~~~y)

theorem band_lor_right1_proof : band_lor_right1_before ⊑ band_lor_right1_after

theorem and1_shl1_is_cmp_eq_0_multiuse_proof : and1_shl1_is_cmp_eq_0_multiuse_before ⊑ and1_shl1_is_cmp_eq_0_multiuse_after

theorem test_invalid_simplify_eq2_thm (e : IntW 8) :
  select (icmp IntPred.eq e (const? 8 2)) (const? 8 0) (sub e (const? 8 1)) ⊑
    select (icmp IntPred.eq e (const? 8 2)) (const? 8 0) (add e (const? 8 (-1)))

theorem test_mul_nuw__nsw_is_safe_thm.extracted_1._3 : ∀ (x : BitVec 32),
  ¬ofBool (x ||| BitVec.ofInt 32 (-83886080) == BitVec.ofInt 32 (-83886079)) = 1#1 →
    ¬(True ∧ (x ||| BitVec.ofInt 32 (-83886080)).umulOverflow 9#32 = true) →
      True ∧ (x ||| BitVec.ofInt 32 (-83886080)).smulOverflow 9#32 = true → False

theorem narrow_zext_xor_proof : narrow_zext_xor_before ⊑ narrow_zext_xor_after

theorem test_negative_combined_sub_unsigned_overflow_thm (e : IntW 64) :
  icmp IntPred.ult (sub (const? 64 10) e { «nsw» := false, «nuw» := true }) (const? 64 11) ⊑ const? 1 1

theorem f_thm (e : IntW 32) :
  select (icmp IntPred.slt e (const? 32 0)) (const? 1 1) (icmp IntPred.sgt e (ashr (const? 32 7) e)) ⊑
    select (icmp IntPred.slt e (const? 32 0)) (const? 1 1)
      (icmp IntPred.sgt e (lshr (const? 32 7) e))

theorem slt_to_ugt_proof : slt_to_ugt_before ⊑ slt_to_ugt_after

theorem e_1987 :
     - 3 * (b |||  ~~~(a |||  ~~~c)) + 3 * (a &&& ( ~~~b ||| c)) - 11 * ( ~~~a ||| ( ~~~b ||| c)) - 7 * b - 3 *  ~~~( ~~~a ||| (b &&& c)) + 1 * (c ^^^  ~~~(a &&& ( ~~~b &&& c))) - 2 *  ~~~(a &&& (b ^^^ c)) - 7 * (c ^^^ (a ||| (b ||| c))) + 1 * ( ~~~b &&& (a ^^^ c)) + 1 * (b ^^^ ( ~~~a ||| (b &&& c))) - 2 * (b ^^^ (a ||| ( ~~~b &&& c))) - 6 * ( ~~~(a &&& b) &&& (b ^^^ c)) - 1 *  ~~~(a ||| b) + 3 * (c &&&  ~~~(a &&&  ~~~b)) - 3 * (c ^^^ (a ||| (b &&& c))) - 2 * (b ^^^ (a &&& (b ^^^ c))) - 2 * ((b &&&  ~~~c) |||  ~~~( ~~~a ||| ( ~~~b &&& c))) - 11 *  ~~~(b |||  ~~~c) + 7 * (b ^^^  ~~~(a &&& c)) + 2 * (b ^^^ (a ||| c)) - 1 *  ~~~(b &&& c) + 3 *  ~~~(a &&&  ~~~b) - 1 * (a &&&  ~~~c) + 1 * ( ~~~(a ^^^ b) |||  ~~~(a ^^^ c)) + 4 * (c ^^^ (a ||| b)) + 11 * (b ^^^  ~~~( ~~~a &&& ( ~~~b &&& c))) - 1 *  ~~~(a |||  ~~~b) - 11 * (c ^^^  ~~~(a &&&  ~~~b)) - 1 * ( ~~~a ||| (b &&& c)) - 5 * (b ^^^  ~~~(a |||  ~~~c)) - 1 * ((a ^^^ b) &&& (a ^^^ c)) + 4 * (a ||| (b ^^^ c)) + 1 * ( ~~~(a &&&  ~~~b) &&&  ~~~(a ^^^ (b ^^^ c))) + 2 * (b ^^^ c) + 11 * (b |||  ~~~(a ||| c)) + 1 * (b ||| c) - 3 * (c ||| (a ^^^ b)) + 5 * (c ^^^ (a &&& b)) - 6 *  ~~~(a ||| (b ^^^ c)) - 1 * ((a &&& b) |||  ~~~(b |||  ~~~c)) - 3 * (a &&& (b ^^^ c)) + 7 *  ~~~(a |||  ~~~c) + 4 * ((a ^^^ b) ||| (a ^^^ c)) - 1 *  ~~~(a &&& b) - 2 * ((a &&& b) ||| (a ^^^ (b ^^^ c))) - 5 * (b ^^^  ~~~(a ||| c)) - 2 * (b ^^^ (a &&& (b ||| c))) - 1 * (a &&& (b ||| c)) - 1 * ( ~~~(a |||  ~~~b) |||  ~~~(b ^^^ c)) + 3 * (b ^^^  ~~~(a &&& ( ~~~b ||| c))) - 4 *  ~~~(a ||| (b ||| c)) + 29 *  ~~~(a ||| ( ~~~b ||| c)) - 5 *  ~~~( ~~~a ||| (b ||| c)) + 9 *  ~~~( ~~~a ||| ( ~~~b ||| c)) + 5 * ( ~~~a &&& ( ~~~b &&& c)) + 8 * ( ~~~a &&& (b &&& c)) + 21 * (a &&& ( ~~~b &&& c)) + 10 * (a &&& (b &&& c)) =  - 5 * (c ^^^  ~~~( ~~~a &&& (b &&& c))) - 3 * ((a &&& b) ^^^  ~~~(a ^^^ ( ~~~b ||| c)))

theorem test20_thm.extracted_1._1 : ∀ (x : BitVec 13), ¬12#13 ≥ ↑13 → ofBool (x.sshiftRight' 12#13 == 123#13) = 0#1

theorem sext_multiuse_thm.extracted_1._2 : ∀ (x : BitVec 4),
  ¬(True ∧ (zeroExtend 7 (x ^^^ BitVec.ofInt 4 (-8))).saddOverflow (BitVec.ofInt 7 (-8)) = true ∨
        (zeroExtend 7 (x ^^^ BitVec.ofInt 4 (-8)) + BitVec.ofInt 7 (-8) == 0 ||
              7 != 1 && zeroExtend 7 (x ^^^ BitVec.ofInt 4 (-8)) == intMin 7 &&
                zeroExtend 7 (x ^^^ BitVec.ofInt 4 (-8)) + BitVec.ofInt 7 (-8) == -1) =
            true ∨
          (x ^^^ BitVec.ofInt 4 (-8) == 0 ||
              4 != 1 &&
                  truncate 4
                      ((zeroExtend 7 (x ^^^ BitVec.ofInt 4 (-8))).sdiv
                        (zeroExtend 7 (x ^^^ BitVec.ofInt 4 (-8)) + BitVec.ofInt 7 (-8))) ==
                    intMin 4 &&
                x ^^^ BitVec.ofInt 4 (-8) == -1) =
            true) →
    ¬((signExtend 7 x == 0 || 7 != 1 && zeroExtend 7 (x ^^^ BitVec.ofInt 4 (-8)) == intMin 7 && signExtend 7 x == -1) =
            true ∨
          (x ^^^ BitVec.ofInt 4 (-8) == 0 ||
              4 != 1 && truncate 4 ((zeroExtend 7 (x ^^^ BitVec.ofInt 4 (-8))).sdiv (signExtend 7 x)) == intMin 4 &&
                x ^^^ BitVec.ofInt 4 (-8) == -1) =
            true) →
      (truncate 4
              ((zeroExtend 7 (x ^^^ BitVec.ofInt 4 (-8))).sdiv
                (zeroExtend 7 (x ^^^ BitVec.ofInt 4 (-8)) + BitVec.ofInt 7 (-8)))).sdiv
          (x ^^^ BitVec.ofInt 4 (-8)) =
        (truncate 4 ((zeroExtend 7 (x ^^^ BitVec.ofInt 4 (-8))).sdiv (signExtend 7 x))).sdiv
          (x ^^^ BitVec.ofInt 4 (-8))

theorem test_shl_nuw_nsw__nsw_is_safe_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬ofBool (x ||| BitVec.ofInt 32 (-83886080) == BitVec.ofInt 32 (-83886079)) = 1#1 →
    ¬(True ∧ ((x ||| BitVec.ofInt 32 (-83886080)) <<< 2#32).sshiftRight' 2#32 ≠ x ||| BitVec.ofInt 32 (-83886080) ∨
          True ∧ (x ||| BitVec.ofInt 32 (-83886080)) <<< 2#32 >>> 2#32 ≠ x ||| BitVec.ofInt 32 (-83886080) ∨
            2#32 ≥ ↑32) →
      (x ||| BitVec.ofInt 32 (-83886080)) <<< 2#32 * (x ||| BitVec.ofInt 32 (-83886080)) *
          (x ||| BitVec.ofInt 32 (-83886080)) <<< 2#32 =
        0#32

theorem sle_smax4_proof : sle_smax4_before ⊑ sle_smax4_after

theorem e_1829 :
    3 * (b &&& (a ||| c)) + 11 * (b ^^^ ( ~~~a ||| ( ~~~b ||| c))) - 2 * (c ^^^ ( ~~~a &&& ( ~~~b ||| c))) - 7 * ((a &&& c) ^^^  ~~~(a ^^^ (b &&& c))) + 1 * (b |||  ~~~c) - 1 * a + 1 * ((a &&& b) ||| (b ^^^ c)) - 3 * ( ~~~b &&&  ~~~(a ^^^ c)) + 11 * ((a &&& b) |||  ~~~(b |||  ~~~c)) - 7 * ((b &&& c) ^^^  ~~~( ~~~a &&& (b ^^^ c))) - 2 * ( ~~~c |||  ~~~(a ^^^ b)) + 1 * ( ~~~(a ^^^ b) |||  ~~~(a ^^^ c)) - 2 * (c ^^^ (a ||| (b &&& c))) + 5 * ( ~~~a ||| ( ~~~b &&& c)) - 2 * (b ^^^  ~~~(a &&& (b ||| c))) + 4 * (a ^^^ ( ~~~b &&& c)) + 7 * ( ~~~(a &&& b) &&&  ~~~(a ^^^ (b ^^^ c))) + 1 * ((a &&& b) |||  ~~~(b ^^^ c)) - 2 *  ~~~a - 1 * (a ||| c) + 7 * ( ~~~c &&& (a ^^^ b)) - 1 *  ~~~(a &&& ( ~~~b ||| c)) - 1 * (c &&&  ~~~(a &&& b)) + 2 *  ~~~(a &&&  ~~~a) - 6 * ( ~~~c &&&  ~~~(a ^^^ b)) + 3 * (c ^^^  ~~~( ~~~a &&& (b &&& c))) + 1 * (a ^^^ (b ||| c)) - 6 * ((b &&& c) ||| (a &&& (b ||| c))) + 11 * (b ^^^  ~~~( ~~~a ||| (b &&& c))) + 2 * ( ~~~b |||  ~~~(a ^^^ c)) + 7 * ((a &&& c) ^^^ (a ^^^ ( ~~~b &&& c))) + 11 * (b ^^^ (a &&& (b ^^^ c))) + 4 * b + 7 * (a ^^^ c) - 1 * (c &&& (a |||  ~~~b)) - 1 *  ~~~(a ||| (b ||| c)) - 44 *  ~~~(a ||| ( ~~~b ||| c)) - 49 *  ~~~( ~~~a ||| (b ||| c)) - 35 *  ~~~( ~~~a ||| ( ~~~b ||| c)) - 33 * ( ~~~a &&& ( ~~~b &&& c)) - 45 * ( ~~~a &&& (b &&& c)) - 40 * (a &&& ( ~~~b &&& c)) - 44 * (a &&& (b &&& c)) =  - 7 * ((b &&&  ~~~c) |||  ~~~( ~~~a ||| ( ~~~b &&& c)))

theorem test9_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x &&& 1073741824#32 != 0#32) &&& ofBool (-1#32 <ₛ x) =
    ofBool (x &&& BitVec.ofInt 32 (-1073741824) == 1073741824#32)

theorem select_1_thm.extracted_1._14 : ∀ (x x_1 : BitVec 8) (x_2 x_3 : BitVec 1),
  ¬x_3 = 1#1 → x_2 = 1#1 → x_1 ^^^ -1#8 ^^^ -1#8 = x_1

theorem lshrult_03_08_proof : lshrult_03_08_before ⊑ lshrult_03_08_after

theorem sdiv400_yes_thm (e : IntW 32) :
  LLVM.sdiv (lshr e (const? 32 2)) (const? 32 100) ⊑ LLVM.udiv e (const? 32 400)

@[simp] theorem Com.toLets_castPureToEff {com : Com d Γ .pure ty} :
    (com.castPureToEff eff).toLets = cast (by simp) (com.toLets.castPureToEff eff)

@[simp]
theorem eval_mkOutputAssignCircuitNAux_eq {arity : Type _}
  [DecidableEq arity]
  [Fintype arity]
  [Hashable arity]
  (p : FSM arity) (n : Nat) (env : Vars p.α arity (n + 1) → Bool) :
  (mkOutputAssignCircuitNAux p n).eval env =
    (p.outputCirc).eval
      (fun x => match x with
        | .inl s => env (Vars.stateN s n)
        | .inr i => env (Vars.inputN i n))

theorem select_icmp_eq_0_and_1_xor_1_thm.extracted_1._1 : ∀ (x : BitVec 32) (x_1 : BitVec 64),
  ofBool (x_1 &&& 1#64 == 0#64) = 1#1 → x = x ^^^ truncate 32 x_1 &&& 1#32

theorem sel_false_val_is_a_masked_ashr_of_true_val1_thm.extracted_1._3 : ∀ (x : BitVec 64) (x_1 : BitVec 32),
  ¬ofBool (x_1 &&& BitVec.ofInt 32 (-2147483588) == 0#32) = 1#1 →
    ¬(2#32 ≥ ↑32 ∨ zeroExtend 64 ((x_1 &&& BitVec.ofInt 32 (-2147483588)).sshiftRight' 2#32) ≥ ↑64) →
      2#32 ≥ ↑32 ∨
          True ∧ (x_1.sshiftRight' 2#32 &&& BitVec.ofInt 32 (-536870897)).msb = true ∨
            zeroExtend 64 (x_1.sshiftRight' 2#32 &&& BitVec.ofInt 32 (-536870897)) ≥ ↑64 →
        False

theorem n7_wrong_pred2_thm (e e_1 : IntW 8) :
  icmp IntPred.eq (sub e_1 e) e_1 ⊑ icmp IntPred.eq e (const? 8 0)

theorem test1_thm (e e_1 : IntW 32) :
  icmp IntPred.eq (LLVM.udiv e_1 e) (const? 32 0) ⊑ icmp IntPred.ugt e e_1

theorem select_of_symmetric_selects_commuted_thm.extracted_1._4 : ∀ (x : BitVec 32) (x_1 x_2 : BitVec 1),
  ¬x_2 = 1#1 → x_1 = 1#1 → ¬x_1 ^^^ x_2 = 1#1 → False

theorem nonexact_lshr_eq_noexactdiv_thm (e : IntW 8) : icmp IntPred.eq (lshr (const? 8 80) e) (const? 8 31) ⊑ const? 1 0

theorem PR21222_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬x ≥ ↑32 → ofBool ((BitVec.ofInt 32 (-93)).sshiftRight' x == BitVec.ofInt 32 (-2)) = ofBool (x == 6#32)

theorem alive_Select_705 : forall (w : Nat) (A B : Bitvec 1)
, TSSA.eval
  (Op := Op) (e := e)
  (i := TSSAIndex.STMT (UserType.base (BaseType.bitvec 1)))
  [dsl_bb|
  ^bb
  %v0 := unit: ;
  %v1 := op:const (A) %v0;
  %v2 := op:const (B) %v0;
  %v3 := pair:%v1 %v2;
  %v4 := op:icmp sge  w %v3;
  %v5 := triple:%v4 %v1 %v2;
  %v6 := op:select 1 %v5;
  %v7 := pair:%v6 %v1;
  %v8 := op:icmp slt  w %v7;
  %v9 := triple:%v8 %v6 %v1;
  %v10 := op:select 1 %v9
  dsl_ret %v10
  ]  ⊑
  TSSA.eval
  (Op := Op) (e := e)
  (i := TSSAIndex.STMT (UserType.base (BaseType.bitvec 1)))
  [dsl_bb|
  ^bb
  %v0 := unit: ;
  %v1 := op:const (A) %v0;
  %v2 := op:const (B) %v0;
  %v3 := pair:%v1 %v2;
  %v4 := op:icmp sge  1 %v3;
  %v5 := triple:%v4 %v1 %v2;
  %v6 := op:select 1 %v5;
  %v7 := pair:%v6 %v1;
  %v8 := op:icmp slt  1 %v7;
  %v9 := op:copy 1 %v1
  dsl_ret %v9
  ]

theorem icmp_sle4_thm (e : IntW 8) :
  icmp IntPred.sle (shl e (const? 8 1) { «nsw» := true, «nuw» := false }) (const? 8 (-2)) ⊑
    icmp IntPred.slt e (const? 8 0)

theorem signed_sign_bit_extract_trunc_thm.extracted_1._1 : ∀ (x : BitVec 64),
  ¬63#64 ≥ ↑64 → ofBool (truncate 32 (x.sshiftRight' 63#64) != 0#32) = ofBool (x <ₛ 0#64)

theorem zext_zext_ule_op0_wide_proof : zext_zext_ule_op0_wide_before ⊑ zext_zext_ule_op0_wide_after

theorem uge_swap_or_not_max_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8), ofBool (x_1 ≤ᵤ x) ||

theorem lshr_sext_i1_to_i128_thm (e : IntW 1) :
  lshr (sext 128 e) (const? 128 42) ⊑ select e (const? 128 77371252455336267181195263) (const? 128 0)

theorem ult_1_impliesF_eq_1_thm.extracted_1._3 : ∀ (x x_1 : BitVec 8),
  ofBool (x_1 <ᵤ 1#8) = 1#1 → ofBool (x_1 != 0#8) = 1#1 → ofBool (x_1 == 1#8) = ofBool (x == x_1)

theorem ashr_16_to_64_add_zext_basic_thm.extracted_1._1 : ∀ (x x_1 : BitVec 16),
  ¬16#64 ≥ ↑64 →
    (zeroExtend 64 x_1 + zeroExtend 64 x).sshiftRight' 16#64 = zeroExtend 64 (ofBool (x_1 ^^^ -1#16 <ᵤ x))

theorem icmp_eq_and1_lshr_pow2_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬x ≥ ↑32 → zeroExtend 32 (ofBool (8#32 >>> x &&& 1#32 == 0#32)) = zeroExtend 32 (ofBool (x != 3#32))

theorem test_shift_and_cmp_changed1_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ¬(5#8 ≥ ↑8 ∨ 5#8 ≥ ↑8) → 5#8 ≥ ↑8 → False

theorem e_1094 :
    2 * (z ||| t) - 1 *  ~~~(z &&& t) - 5 * (z |||  ~~~t) - 11 * t - 3 *  ~~~t + 16 *  ~~~(z ||| t) + 14 * (z &&&  ~~~t) + 21 * (z &&& t) = 7 *  ~~~(z &&&  ~~~z) - 17 *  ~~~(z |||  ~~~t)

theorem icmp_ne_sext_ne_otherwise_i128_thm.extracted_1._1 : ∀ (x : BitVec 128),
  ofBool (signExtend 128 (ofBool (x != 2#128)) != x) = ofBool (x != -1#128)

theorem ashr_sgt_exact_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬(True ∧ x >>> 3#8 <<< 3#8 ≠ x ∨ 3#8 ≥ ↑8) → ofBool (10#8 <ₛ x.sshiftRight' 3#8) = ofBool (80#8 <ₛ x)

theorem main3_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x &&& 7#32 == 0#32) &&& ofBool (x &&& 48#32 == 0#32) = 1#1 →
    0#32 = zeroExtend 32 (ofBool (x &&& 55#32 != 0#32))

theorem scalar_i32_lshr_and_negC_eq_X_is_constant2_proof : scalar_i32_lshr_and_negC_eq_X_is_constant2_before ⊑ scalar_i32_lshr_and_negC_eq_X_is_constant2_after

theorem and_add_bool_to_select_multi_use_proof : and_add_bool_to_select_multi_use_before ⊑ and_add_bool_to_select_multi_use_after

theorem e_855 :
    7 * (z ||| t) - 2 * z + 4 * (z ^^^ t) - 1 *  ~~~(z ||| t) - 11 *  ~~~(z |||  ~~~t) - 10 * (z &&&  ~~~t) = 6 * (z &&& t) - 1 * (z |||  ~~~t)

theorem test3_thm (e : IntW 1) (e_1 : IntW 59) :
  LLVM.udiv e_1 (select e (const? 59 1024) (const? 59 4096)) ⊑
    lshr e_1 (select e (const? 59 10) (const? 59 12))

theorem e_1280 :
    11 * z - 2 *  ~~~z - 2 * (z ^^^ t) - 5 *  ~~~(z &&& t) + 3 *  ~~~(z &&&  ~~~t) - 3 * (z ||| t) + 4 *  ~~~(z ||| t) + 9 *  ~~~(z |||  ~~~t) - 11 * (z &&& t) = 1 * (z &&&  ~~~t)

theorem AvoidCollision_cast_setWidth (h : v = v') (x : BitVec w) :
    (x.setWidth v).cast h = x.setWidth v'

theorem bools2_logical_commute0_and2_thm.extracted_1._8 : ∀ (x x_1 x_2 : BitVec 1), ¬x_2 = 1#1 → 0#1 = 1#1 → 1#1 = x

theorem shl_shl_proof : shl_shl_before ⊑ shl_shl_after

theorem src_is_mask_shl_lshr_fail_not_allones_proof : src_is_mask_shl_lshr_fail_not_allones_before ⊑ src_is_mask_shl_lshr_fail_not_allones_after

theorem bitwise_or_bitwise_or_icmps_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 8),
  ¬x ≥ ↑8 → True ∧ 1#8 <<< x >>> x ≠ 1#8 ∨ x ≥ ↑8 ∨ True ∧ 1#8 <<< x >>> x ≠ 1#8 ∨ x ≥ ↑8 → False

theorem eq_nsw_rem_nz_proof : eq_nsw_rem_nz_before ⊑ eq_nsw_rem_nz_after

theorem e_1029 :
     - 1 *  ~~~t - 7 * z - 7 *  ~~~(z &&& t) + 8 *  ~~~(z ||| t) + 10 *  ~~~(z |||  ~~~t) + 18 * (z &&&  ~~~t) + 7 * (z &&& t) = 3 * (z ^^^ t)

theorem main3_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬ofBool (x &&& 7#32 == 0#32) &&& ofBool (x &&& 48#32 == 0#32) = 1#1 →
    1#32 = zeroExtend 32 (ofBool (x &&& 55#32 != 0#32))

theorem scalar_i32_shl_and_signbit_slt_proof : scalar_i32_shl_and_signbit_slt_before ⊑ scalar_i32_shl_and_signbit_slt_after

theorem t4_commutative_proof : t4_commutative_before ⊑ t4_commutative_after

theorem e_2312 :
    5 * (d &&&  ~~~e) + 1 * (d &&& e) + 1 *  ~~~(d &&& f) - 2 * (e &&&  ~~~(d ^^^ f)) + 3 * (d ||| ( ~~~e &&& f)) - 2 * (d ^^^ (e &&& f)) + 11 * ( ~~~d ||| (e ||| f)) + 3 * (d &&&  ~~~f) - 5 *  ~~~(d ||| ( ~~~e &&& f)) - 3 * ((d &&& f) ^^^  ~~~(e &&&  ~~~f)) - 1 * (f ^^^  ~~~(d &&& (e &&& f))) - 1 * (d ^^^ f) + 7 * (f ^^^ (d |||  ~~~e)) + 3 * (e ^^^  ~~~(d ||| (e ^^^ f))) + 1 * (e ^^^ f) - 11 *  ~~~(d &&& (e &&& f)) - 1 * (f ^^^  ~~~( ~~~d ||| (e &&& f))) + 11 * (e ^^^  ~~~(d |||  ~~~f)) - 7 * e - 3 * ( ~~~(d |||  ~~~e) |||  ~~~(d ^^^ (e ^^^ f))) + 11 * f + 1 * (d ^^^ (e ^^^ f)) - 5 * (f ^^^  ~~~( ~~~d ||| ( ~~~e &&& f))) + 2 * ( ~~~d ||| (e ^^^ f)) - 2 * ( ~~~(d ||| e) |||  ~~~(e ^^^ f)) - 7 * ( ~~~f |||  ~~~(d ^^^ e)) - 1 *  ~~~(d |||  ~~~f) - 2 * (e &&&  ~~~(d &&&  ~~~f)) + 1 * ( ~~~(d &&&  ~~~e) &&& (e ^^^ f)) - 7 * (f ^^^ (d ||| (e ||| f))) + 1 * ((d &&& e) ^^^ (d ^^^ (e &&& f))) + 11 * (d &&& ( ~~~e ||| f)) + 2 *  ~~~( ~~~d &&& ( ~~~e ||| f)) + 5 * (e ^^^  ~~~( ~~~d &&& ( ~~~e &&& f))) + 1 * ( ~~~(d ||| e) |||  ~~~(d ^^^ (e ^^^ f))) - 2 * (f ^^^  ~~~( ~~~d &&& ( ~~~e ||| f))) + 1 * ( ~~~e |||  ~~~(d ^^^ f)) + 11 * (d ||| ( ~~~e ||| f)) - 5 * (f ^^^ (d &&& ( ~~~e ||| f))) - 11 * ( ~~~(d &&&  ~~~e) &&&  ~~~(d ^^^ (e ^^^ f))) - 2 * (e &&&  ~~~f) + 2 * ((d ||| e) &&&  ~~~(d ^^^ (e ^^^ f))) + 7 *  ~~~( ~~~d ||| ( ~~~e &&& f)) - 6 *  ~~~( ~~~d ||| (e &&& f)) - 11 * ((d &&& e) |||  ~~~(d ^^^ (e ^^^ f))) + 2 * ( ~~~d &&& (e ^^^ f)) + 5 *  ~~~d - 3 * ((d &&&  ~~~e) |||  ~~~(e ^^^ f)) - 11 * (f ^^^ ( ~~~d &&& (e ||| f))) - 1 * (d ||| f) - 1 *  ~~~f + 4 * (e ||| (d &&& f)) - 1 * (f ^^^ (d &&& (e ||| f))) - 3 * (f ^^^  ~~~( ~~~d &&& (e ||| f))) + 2 * (e ^^^  ~~~(d ||| (e &&& f))) + 13 *  ~~~(d ||| (e ||| f)) + 27 *  ~~~(d ||| ( ~~~e ||| f)) + 14 *  ~~~( ~~~d ||| (e ||| f)) + 10 *  ~~~( ~~~d ||| ( ~~~e ||| f)) - 20 * ( ~~~d &&& ( ~~~e &&& f)) + 33 * ( ~~~d &&& (e &&& f)) - 7 * (d &&& ( ~~~e &&& f)) - 20 * (d &&& (e &&& f)) = 1 * (e ^^^  ~~~(d &&& ( ~~~e ||| f))) + 11 * (e ^^^  ~~~( ~~~d ||| (e &&& f)))

theorem or_trunc_lshr_thm (e : IntW 8) :
  LLVM.or (trunc 6 (lshr e (const? 8 1))) (const? 6 (-32)) ⊑
    LLVM.or (lshr (trunc 6 e) (const? 6 1)) (const? 6 (-32)) { «disjoint» := true }

theorem t3_no_extrause_proof : t3_no_extrause_before ⊑ t3_no_extrause_after

theorem bv_AndOrXor_1253_A__AB___A__B :
    ∀ (e e_1 : LLVM.IntW w), LLVM.and (LLVM.xor e e_1) e ⊑ LLVM.and e (LLVM.xor e_1 (LLVM.const? w (-1)))

theorem icmp_shl_nsw_sge0_proof : icmp_shl_nsw_sge0_before ⊑ icmp_shl_nsw_sge0_after

theorem p_proof : p_before ⊑ p_after

theorem and_logic_and_logic_or_8_thm.extracted_1._1 : ∀ (x : BitVec 1), ¬x = 1#1 → 0#1 = 1#1 → False

theorem src_tv_eq_thm.extracted_1._1 : ∀ (x : BitVec 8) (x_1 : BitVec 1),
  x_1 = 1#1 → ofBool (0#8 ||| x == 0#8) = ofBool (x == 0#8) &&& x_1

theorem test_shr_and_1_ne_0_samesign_thm.extracted_1._2 : ∀ (x x_1 : BitVec 32),
  ¬x ≥ ↑32 →
    ¬(True ∧ 1#32 <<< x >>> x ≠ 1#32 ∨ x ≥ ↑32) →
      ofBool (x_1 >>> x &&& 1#32 != 0#32) = ofBool (x_1 &&& 1#32 <<< x != 0#32)

theorem samesign_commute2_proof : samesign_commute2_before ⊑ samesign_commute2_after

theorem sext_multi_uses_proof : sext_multi_uses_before ⊑ sext_multi_uses_after

theorem test_invert_demorgan_and2_proof : test_invert_demorgan_and2_before ⊑ test_invert_demorgan_and2_after

theorem main4e_like_logical_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (x_1 &&& x == x) = 1#1 → ofBool (x_1 &&& x != x) = 1#1 → 0#1 = 1#1 → 0#32 = zeroExtend 32 1#1

theorem sdiv_icmp1_proof : sdiv_icmp1_before ⊑ sdiv_icmp1_after

theorem and_logic_and_logic_or_7_thm.extracted_1._1 : ∀ (x : BitVec 1), ¬x = 1#1 → 0#1 = 1#1 → 1#1 = 0#1

theorem lor_bor_left1_thm.extracted_1._3 : ∀ (x x_1 : BitVec 1), ¬x_1 = 1#1 → x ||

theorem test51_thm.extracted_1._1 : ∀ (x : BitVec 64) (x_1 : BitVec 1),
  x_1 = 1#1 → True ∧ (truncate 32 x &&& BitVec.ofInt 32 (-2) &&& zeroExtend 32 (x_1 ^^^ 1#1) != 0) = true → False

theorem add_shl_same_amount_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 6), ¬(x_1 ≥ ↑6 ∨ x_1 ≥ ↑6) → x_1 ≥ ↑6 → False

theorem and_or3_commuted_thm.extracted_1._6 : ∀ (x x_1 : BitVec 1) (x_2 x_3 : BitVec 32),
  ¬ofBool (x_3 == x_2) &&& x_1 = 1#1 → x_1 = 1#1 → ofBool (x_3 != x_2) = 1#1 → x_1 = 1#1

theorem positive_with_icmp_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x <ᵤ 512#32) &&& ofBool (x + 128#32 <ᵤ 256#32) = ofBool (x <ᵤ 128#32)

theorem test9b_proof : test9b_before ⊑ test9b_after

theorem e_613 :
     - 6 * x + 1 *  ~~~(x ^^^ y) - 11 * (x |||  ~~~y) + 5 *  ~~~(x &&&  ~~~x) + 4 * y - 2 * (x ^^^ y) + 8 *  ~~~(x ||| y) - 4 *  ~~~(x |||  ~~~y) + 14 * (x &&&  ~~~y) + 10 * (x &&& y) = 3 *  ~~~(x &&&  ~~~y)

theorem select_replace_nested_proof : select_replace_nested_before ⊑ select_replace_nested_after

theorem udiv_shl_pair_const_proof : udiv_shl_pair_const_before ⊑ udiv_shl_pair_const_after

lemma Predicate.evalFin_eq_eval (p : Predicate)
   (varsList : List BitStream) (varsFin : Fin p.arity → BitStream)
   (hvars : ∀ (i : Fin p.arity), varsList.getD i default = (varsFin i)) :
    Predicate.evalFin p varsFin  = Predicate.eval p varsList

theorem test_uge_xor_proof : test_uge_xor_before ⊑ test_uge_xor_after

theorem test24_proof : test24_before ⊑ test24_after

theorem mullo_proof : mullo_before ⊑ mullo_after

theorem negate_sdiv_proof : negate_sdiv_before ⊑ negate_sdiv_after

theorem PR42691_8_proof : PR42691_8_before ⊑ PR42691_8_after

@[symm]
theorem equal_up_to_symm (e : a ≈ʷ b) : b ≈ʷ a

theorem ashr_can_be_lshr_2_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬(34#64 ≥ ↑64 ∨
        True ∧
            (zeroExtend 64 x ||| 4278190080#64) <<< 34#64 >>> 32#64 <<< 32#64 ≠
              (zeroExtend 64 x ||| 4278190080#64) <<< 34#64 ∨
          32#64 ≥ ↑64 ∨
            True ∧
              signExtend 64 (truncate 32 (((zeroExtend 64 x ||| 4278190080#64) <<< 34#64).sshiftRight' 32#64)) ≠
                ((zeroExtend 64 x ||| 4278190080#64) <<< 34#64).sshiftRight' 32#64) →
    2#32 ≥ ↑32 → False

theorem test1_proof : test1_before ⊑ test1_after

@[grind =, simp]
lemma createSink_finals [LawfulBEq A] {m : RawCNFA A} : m.createSink.2.finals = m.finals

theorem basic_com_add_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8), x_1 + (x ^^^ -1#8) ^^^ -1#8 = x - x_1

theorem test_shl_nuw__nsw_is_safe_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬ofBool (x ||| BitVec.ofInt 32 (-83886080) == BitVec.ofInt 32 (-83886079)) = 1#1 →
    ¬(True ∧ (x ||| BitVec.ofInt 32 (-83886080)) <<< 2#32 >>> 2#32 ≠ x ||| BitVec.ofInt 32 (-83886080) ∨ 2#32 ≥ ↑32) →
      (x ||| BitVec.ofInt 32 (-83886080)) <<< 2#32 * (x ||| BitVec.ofInt 32 (-83886080)) *
          (x ||| BitVec.ofInt 32 (-83886080)) <<< 2#32 =
        0#32

theorem xor_of_icmps_commute_proof : xor_of_icmps_commute_before ⊑ xor_of_icmps_commute_after

theorem src_is_mask_shl_lshr_fail_not_allones_proof : src_is_mask_shl_lshr_fail_not_allones_before ⊑ src_is_mask_shl_lshr_fail_not_allones_after

theorem select_constants_and_icmp_ne0_zero_tval_thm.extracted_1._4 : ∀ (x x_1 : BitVec 1),
  ¬x_1 = 1#1 → ¬x = 1#1 → ofBool (12#8 &&& 12#8 != 0#8) = x ^^^ 1#1

theorem icmp_select_var_select_thm.extracted_1._17 : ∀ (x x_1 : BitVec 8) (x_2 : BitVec 1),
  ¬x_2 = 1#1 → ¬(ofBool (x_1 == 0#8) = 1#1 ∧ x_2 = 1#1) → ofBool (x_1 == 0#8) = 1#1 → ¬True → ofBool (x == x) = 1#1

theorem masked_icmps_mask_notallzeros_bmask_mixed_4_logical_proof : masked_icmps_mask_notallzeros_bmask_mixed_4_logical_before ⊑ masked_icmps_mask_notallzeros_bmask_mixed_4_logical_after

theorem test_add__nsw_is_safe_proof : test_add__nsw_is_safe_before ⊑ test_add__nsw_is_safe_after

theorem shl_nsw_nuw_poison_constant_fold_thm.extracted_1._2 : ∀ (x : BitVec 8) (x_1 : BitVec 1),
  x_1 = 1#1 →
    ¬(True ∧ (16#8 <<< 3#8).sshiftRight' 3#8 ≠ 16#8 ∨ True ∧ 16#8 <<< 3#8 >>> 3#8 ≠ 16#8 ∨ 3#8 ≥ ↑8) →
      16#8 <<< 3#8 = BitVec.ofInt 8 (-128)

theorem test48_proof : test48_before ⊑ test48_after

theorem lshr_eq_both_equal_proof : lshr_eq_both_equal_before ⊑ lshr_eq_both_equal_after

theorem main5_like_logical_thm.extracted_1._4 : ∀ (x : BitVec 32),
  ¬ofBool (x &&& 7#32 == 7#32) = 1#1 → ¬ofBool (x &&& 7#32 != 7#32) = 1#1 → ¬0#1 = 1#1 → False

theorem or_not_and_and_not_and_xor_commute2_proof : or_not_and_and_not_and_xor_commute2_before ⊑ or_not_and_and_not_and_xor_commute2_after

theorem ashrsgt_03_10_exact_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬(True ∧ x >>> 3#4 <<< 3#4 ≠ x ∨ 3#4 ≥ ↑4) → ofBool (BitVec.ofInt 4 (-6) <ₛ x.sshiftRight' 3#4) = 1#1

theorem gt_signed_to_small_signed_thm (e : IntW 8) :
  icmp IntPred.sgt (sext 32 e) (const? 32 17) ⊑ icmp IntPred.sgt e (const? 8 17)

theorem zext_zext_sgt_proof : zext_zext_sgt_before ⊑ zext_zext_sgt_after

theorem mul_constant_mismatch_wrap_eq_thm (e e_1 : IntW 32) :
  icmp IntPred.eq (mul e_1 (const? 32 54) { «nsw» := true, «nuw» := false })
      (mul e (const? 32 54) { «nsw» := false, «nuw» := true }) ⊑
    icmp IntPred.eq (LLVM.and (LLVM.xor e_1 e) (const? 32 2147483647)) (const? 32 0)

theorem sext_thm (e : IntW 16) :
  add (LLVM.xor (zext 32 e) (const? 32 32768)) (const? 32 (-32768)) ⊑ sext 32 e

theorem ugt_rem_nz_thm (e : IntW 8) :
  icmp IntPred.ugt (mul e (const? 8 5) { «nsw» := false, «nuw» := true }) (const? 8 21) ⊑
    icmp IntPred.ugt e (const? 8 4)

theorem test3_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32), ¬x = 0 → ofBool (x_1 / x != 0#32) = ofBool (x ≤ᵤ x_1)

theorem ashrslt_01_15_exact_thm (e : IntW 4) :
  icmp IntPred.slt (ashr e (const? 4 1) { «exact» := true }) (const? 4 (-1)) ⊑
    icmp IntPred.slt e (const? 4 (-2))

theorem and_sel_op0_thm.extracted_1._1 : ∀ (x : BitVec 1), x = 1#1 → 25#32 &&& 1#32 = zeroExtend 32 x

theorem main3e_like_logical_proof : main3e_like_logical_before ⊑ main3e_like_logical_after

theorem test_thm.extracted_1._1 : zeroExtend 32 (ofBool (1#32 == 2#32)) = 0#32

theorem ashrslt_03_11_thm (e : IntW 4) : icmp IntPred.slt (ashr e (const? 4 3)) (const? 4 (-5)) ⊑ const? 1 0

theorem test_add_nuw__nuw_is_safe_proof : test_add_nuw__nuw_is_safe_before ⊑ test_add_nuw__nuw_is_safe_after

theorem main7g_logical_thm.extracted_1._15 : ∀ (x x_1 x_2 x_3 x_4 : BitVec 32),
  ¬ofBool (x_4 &&& x_3 == x_4 &&& x_3 &&& x_2) = 1#1 →
    ¬ofBool (x_4 &&& x_3 != x_4 &&& x_3 &&& x_2) = 1#1 →
      0#1 = 1#1 → 0#32 = zeroExtend 32 (ofBool (x_1 &&& x != x_1 &&& x &&& x_2))

theorem sub_to_xor_proof : sub_to_xor_before ⊑ sub_to_xor_after

theorem exact_lshr_eq_exactdiv_proof : exact_lshr_eq_exactdiv_before ⊑ exact_lshr_eq_exactdiv_after

theorem test11_proof : test11_before ⊑ test11_after

theorem main7b_logical_thm.extracted_1._8 : ∀ (x x_1 x_2 : BitVec 32),
  ofBool (x_2 == x_1 &&& x_2) = 1#1 →
    ¬ofBool (x_2 != x_1 &&& x_2) = 1#1 →
      ¬ofBool (x == x_1 &&& x) = 1#1 → 1#32 = zeroExtend 32 (ofBool (x != x_1 &&& x))

theorem zext_sext_add_icmp_sgt_minus2_proof : zext_sext_add_icmp_sgt_minus2_before ⊑ zext_sext_add_icmp_sgt_minus2_after

theorem test_with_5_proof : test_with_5_before ⊑ test_with_5_after

theorem test_mul_nuw__none_are_safe_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x == 805306368#32) = 1#1 → BitVec.ofInt 32 (-1342177280) = x * 9#32

theorem icmp_eq_and1_lshr_pow2_minus_one_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬x ≥ ↑32 → zeroExtend 32 (ofBool (7#32 >>> x &&& 1#32 == 0#32)) = zeroExtend 32 (ofBool (2#32 <ᵤ x))

theorem test6a_thm (e : IntW 1) : icmp IntPred.ne (zext 32 e) (const? 32 (-1)) ⊑ const? 1 1

theorem test_shl_nuw__nuw_is_safe_thm.extracted_1._1 : ∀ (x : BitVec 64) (x_1 : BitVec 32),
  ofBool (x_1 &&& 1073741822#32 == 0#32) = 1#1 →
    2#32 ≥ ↑32 ∨
        True ∧ (x_1 <<< 2#32 &&& BitVec.ofInt 32 (-8)).msb = true ∨
          zeroExtend 64 (x_1 <<< 2#32 &&& BitVec.ofInt 32 (-8)) ≥ ↑64 →
      False

theorem masked_icmps_mask_notallzeros_bmask_mixed_negated_swapped_3_logical_proof : masked_icmps_mask_notallzeros_bmask_mixed_negated_swapped_3_logical_before ⊑ masked_icmps_mask_notallzeros_bmask_mixed_negated_swapped_3_logical_after

theorem test6_thm.extracted_1._1 : ∀ (x : BitVec 64),
  ¬32#128 ≥ ↑128 → 32#64 ≥ ↑64 ∨ True ∧ zeroExtend 64 (truncate 32 (x >>> 32#64)) ≠ x >>> 32#64 → False

theorem ashrslt_03_14_exact_thm (e : IntW 4) :
  icmp IntPred.slt (ashr e (const? 4 3) { «exact» := true }) (const? 4 (-2)) ⊑ const? 1 0

theorem select_2_thm.extracted_1._6 : ∀ (x : BitVec 8) (x_1 x_2 : BitVec 1),
  ¬x_2 = 1#1 → x ^^^ 45#8 ^^^ -1#8 = x ^^^ BitVec.ofInt 8 (-46)

theorem negative5_thm (e e_1 : IntW 32) :
  LLVM.or (icmp IntPred.slt e_1 (LLVM.and e (const? 32 2147483647))) (icmp IntPred.sge e_1 (const? 32 0)) ⊑
    const? 1 1

theorem not_signbit_zext_thm.extracted_1._1 : ∀ (x : BitVec 16),
  ¬15#16 ≥ ↑16 → zeroExtend 32 ((x ^^^ -1#16) >>> 15#16) = zeroExtend 32 (ofBool (-1#16 <ₛ x))

theorem icmp_select_implied_cond_ne_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ofBool (x == 0#8) = 1#1 → ofBool (x != 0#8) = 1#1 → False

theorem e_1615 :
     - 5 * (b ^^^ ( ~~~a ||| (b ||| c))) - 11 * ((a |||  ~~~b) &&&  ~~~(b ^^^ c)) + 2 *  ~~~(a ^^^ ( ~~~b ||| c)) + 1 * (c ^^^  ~~~( ~~~a &&& ( ~~~b &&& c))) + 1 * ( ~~~(a &&&  ~~~b) &&&  ~~~(b ^^^ c)) - 1 * (b |||  ~~~(a ||| c)) + 1 * (a ||| ( ~~~b ||| c)) - 2 * (c ^^^  ~~~(a &&& (b ||| c))) - 11 * ( ~~~a ||| (b ||| c)) + 4 *  ~~~(a &&& (b ^^^ c)) - 7 * ((a &&& c) |||  ~~~(b ||| c)) - 1 * (b ^^^ c) + 30 *  ~~~(a ||| (b ||| c)) + 18 *  ~~~(a ||| ( ~~~b ||| c)) + 12 *  ~~~( ~~~a ||| (b ||| c)) + 10 *  ~~~( ~~~a ||| ( ~~~b ||| c)) + 21 * ( ~~~a &&& ( ~~~b &&& c)) + 5 * ( ~~~a &&& (b &&& c)) + 33 * (a &&& ( ~~~b &&& c)) + 35 * (a &&& (b &&& c)) =  - 1 * ( ~~~(a |||  ~~~b) ||| (b ^^^ c)) + 11 * (c ^^^  ~~~(a |||  ~~~b))

theorem band_land_right1_thm (e e_1 : IntW 1) : select e_1 (LLVM.and e_1 e) (const? 1 0) ⊑ select e_1 e (const? 1 0)

theorem udiv_shl_pair3_proof : udiv_shl_pair3_before ⊑ udiv_shl_pair3_after

theorem slt_zero_eq_ne_0_fail2_thm (e : IntW 32) :
  icmp IntPred.eq (zext 32 (icmp IntPred.ne e (const? 32 0))) (lshr e (const? 32 30)) ⊑
    icmp IntPred.eq (lshr e (const? 32 30)) (zext 32 (icmp IntPred.ne e (const? 32 0)))

theorem e_490 :
     - 1 * (x ||| y) + 4 *  ~~~(x ^^^ y) + 2 * y - 5 *  ~~~y - 1 *  ~~~(x &&&  ~~~x) - 1 *  ~~~(x &&& y) + 10 *  ~~~(x ||| y) + 8 *  ~~~(x |||  ~~~y) + 8 * (x &&&  ~~~y) =  - 3 * (x &&& y) + 7 *  ~~~(x &&&  ~~~y)

theorem test19_thm (e : IntW 32) :
  icmp IntPred.slt (sext 64 e) (const? 64 12345) ⊑ icmp IntPred.slt e (const? 32 12345)

theorem ashr_can_be_lshr_thm (e : IntW 32) :
  trunc 16 (ashr e (const? 32 16) { «exact» := true }) { «nsw» := true, «nuw» := false } ⊑
    trunc 16 (lshr e (const? 32 16) { «exact» := true }) { «nsw» := false, «nuw» := true }

theorem n2_proof : n2_before ⊑ n2_after

theorem ugt_and_not_min_commute_thm (e e_1 : IntW 8) :
  LLVM.and (icmp IntPred.ne e_1 (const? 8 0)) (icmp IntPred.ugt e_1 e) ⊑ icmp IntPred.ugt e_1 e

theorem or_xor_tree_1111_proof : or_xor_tree_1111_before ⊑ or_xor_tree_1111_after

theorem no_shift_xor_multiuse_cmp_and_thm.extracted_1._4 : ∀ (x x_1 x_2 x_3 : BitVec 32),
  ¬ofBool (0#32 != x_3 &&& 4096#32) = 1#1 →
    ¬ofBool (x_3 &&& 4096#32 == 0#32) = 1#1 →
      (x_2 &&& BitVec.ofInt 32 (-4097)) * x * (x_2 &&& BitVec.ofInt 32 (-4097)) =
        x_2 * x_1 * (x_2 &&& BitVec.ofInt 32 (-4097))

theorem test_sext4_proof : test_sext4_before ⊑ test_sext4_after

theorem e_421 :
    1 *  ~~~x - 11 * (x ^^^ y) - 7 *  ~~~(x &&&  ~~~y) - 7 *  ~~~(x &&& y) + 2 *  ~~~(x ^^^ y) + 25 *  ~~~(x |||  ~~~y) + 8 * (x &&&  ~~~y) - 5 * (x &&& y) = 1 * (x ||| y) - 11 * (x |||  ~~~y)

theorem e_1726 :
     - 5 * ((a |||  ~~~b) &&& (a ^^^ (b ^^^ c))) - 6 * c - 1 *  ~~~(a |||  ~~~c) - 1 * ((a &&& b) ^^^ (b |||  ~~~c)) - 5 * (b ^^^  ~~~( ~~~a &&& (b &&& c))) + 4 * (c ^^^ (a ||| (b &&& c))) - 1 *  ~~~(a &&&  ~~~a) + 1 * (b ^^^ (a ||| c)) - 1 * ( ~~~(a ||| b) |||  ~~~(a ^^^ (b ^^^ c))) - 3 * ( ~~~(a ^^^ b) &&&  ~~~(a ^^^ c)) + 5 * (b ^^^ (a &&&  ~~~c)) - 1 * ((a ^^^ b) &&& (a ^^^ c)) + 11 * (c ^^^ ( ~~~a ||| ( ~~~b ||| c))) + 2 * (a ^^^ ( ~~~b &&& c)) - 11 * ((a ||| b) &&&  ~~~(b ^^^ c)) + 1 *  ~~~(a ^^^ ( ~~~b ||| c)) - 1 *  ~~~(a ^^^ (b ||| c)) + 1 * (b ^^^  ~~~( ~~~a &&& (b ||| c))) + 1 *  ~~~( ~~~a ||| (b ^^^ c)) - 11 * (b ^^^  ~~~(a &&& (b ||| c))) + 11 * (c ^^^  ~~~(a &&&  ~~~b)) + 3 * (c ^^^  ~~~( ~~~a &&& (b &&& c))) - 11 * (a &&&  ~~~b) + 8 *  ~~~(a ||| (b ||| c)) - 20 *  ~~~(a ||| ( ~~~b ||| c)) + 17 *  ~~~( ~~~a ||| (b ||| c)) - 6 *  ~~~( ~~~a ||| ( ~~~b ||| c)) + 34 * ( ~~~a &&& ( ~~~b &&& c)) + 18 * ( ~~~a &&& (b &&& c)) + 11 * (a &&& ( ~~~b &&& c)) + 29 * (a &&& (b &&& c)) = 11 *  ~~~(a ||| (b &&& c))

theorem shl_add_log_may_cause_poison_pr62175_with_nsw_proof : shl_add_log_may_cause_poison_pr62175_with_nsw_before ⊑ shl_add_log_may_cause_poison_pr62175_with_nsw_after

theorem lshrult_03_10_exact_proof : lshrult_03_10_exact_before ⊑ lshrult_03_10_exact_after

theorem ashrsgt_02_13_exact_thm (e : IntW 4) :
  icmp IntPred.sgt (ashr e (const? 4 2) { «exact» := true }) (const? 4 (-3)) ⊑ const? 1 1

theorem src_srem_shl_demand_max_signbit_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬((2#32 == 0 || 32 != 1 && x == intMin 32 && 2#32 == -1) = true ∨ 30#32 ≥ ↑32) →
    ¬(2#32 == 0 || 32 != 1 && x == intMin 32 && 2#32 == -1) = true →
      x.srem 2#32 <<< 30#32 &&& BitVec.ofInt 32 (-2147483648) = x.srem 2#32 &&& BitVec.ofInt 32 (-2147483648)

theorem test_thm.extracted_1._1 : ∀ (x : BitVec 64), ¬1#64 ≥ ↑64 → ofBool (0#64 <ᵤ x >>> 1#64) = ofBool (1#64 <ᵤ x)

theorem and_ne_with_one_bit_diff_constants2_thm.extracted_1._1 : ∀ (x : BitVec 19),
  ofBool (x != 65#19) &&& ofBool (x != 193#19) = ofBool (x &&& BitVec.ofInt 19 (-129) != 65#19)

theorem reused_mul_nuw_xy_z_selectnonzero_ugt_thm.extracted_1._5 : ∀ (x x_1 x_2 : BitVec 8),
  ofBool (x_2 != 0#8) = 1#1 →
    ¬(True ∧ x_1.umulOverflow x_2 = true ∨ True ∧ x.umulOverflow x_2 = true) →
      ofBool (x_2 == 0#8) = 1#1 → ofBool (x * x_2 <ᵤ x_1 * x_2) = 1#1

theorem negative_not_next_power_of_two_proof : negative_not_next_power_of_two_before ⊑ negative_not_next_power_of_two_after

theorem icmp_ult_x_y_proof : icmp_ult_x_y_before ⊑ icmp_ult_x_y_after

theorem select_xor_icmp2_thm.extracted_1._4 : ∀ (x x_1 x_2 : BitVec 32),
  ofBool (x_2 != 0#32) = 1#1 → ofBool (x_2 == 0#32) = 1#1 → x_1 = x

theorem bv_AddSub_1152 :
    ∀ (e e_1 : LLVM.IntW 1), LLVM.add e_1 e ⊑ LLVM.xor e_1 e

theorem main3e_like_logical_thm.extracted_1._11 : ∀ (x x_1 x_2 : BitVec 32),
  ¬ofBool (x_2 &&& x_1 == 0#32) = 1#1 →
    ¬ofBool (x_2 &&& x_1 != 0#32) = 1#1 → 0#1 = 1#1 → 0#32 = zeroExtend 32 (ofBool (x_2 &&& x != 0#32))

theorem n7_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x &&& 2#32 != 0#32) = 1#1 → ofBool (x &&& 2#32 == 0#32) = 1#1 → x &&& 1#32 = 1#32

theorem lshrult_01_11_thm (e : IntW 4) : icmp IntPred.ult (lshr e (const? 4 1)) (const? 4 (-5)) ⊑ const? 1 1

theorem t1_flags_nuw_first_proof : t1_flags_nuw_first_before ⊑ t1_flags_nuw_first_after

theorem icmp_eq_mul_nsw_nonequal_commuted_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ¬(True ∧ x_1.smulOverflow x = true ∨ True ∧ x.smulOverflow (x_1 + 1#8) = true) →
    ofBool (x_1 * x == x * (x_1 + 1#8)) = ofBool (x == 0#8)

theorem test_zext4_thm (e e_1 : IntW 1) :
  select e_1 (zext 32 e) (const? 32 1) ⊑ zext 32 (select (LLVM.xor e_1 (const? 1 1)) (const? 1 1) e)

theorem e_563 :
    2 * (x ^^^ y) + 2 *  ~~~y + 7 * y - 1 *  ~~~x - 7 *  ~~~(x &&& y) + 1 * (x |||  ~~~y) - 1 *  ~~~(x &&&  ~~~y) + 6 *  ~~~(x ||| y) + 2 * (x &&&  ~~~y) = 7 * (x &&& y)

theorem t6_thm (e : IntW 8) :
  icmp IntPred.ult (sub (const? 8 0) e { «nsw» := true, «nuw» := false }) e ⊑
    icmp IntPred.slt e (const? 8 0)

theorem lshr_neg_sgt_minus_1_proof : lshr_neg_sgt_minus_1_before ⊑ lshr_neg_sgt_minus_1_after

theorem udiv_illegal_type_thm.extracted_1._1 : ∀ (x x_1 : BitVec 9), ¬zeroExtend 32 x = 0 → x = 0 → False

theorem scalar_i16_shl_and_signbit_eq_thm (e e_1 : IntW 16) :
  icmp IntPred.eq (LLVM.and (shl e_1 e) (const? 16 (-32768))) (const? 16 0) ⊑
    icmp IntPred.sgt (shl e_1 e) (const? 16 (-1))

theorem negative_trunc_not_arg_logical_thm.extracted_1._2 : ∀ (x x_1 : BitVec 32),
  ofBool (-1#8 <ₛ truncate 8 x_1) = 1#1 →
    ¬ofBool (x_1 &&& 128#32 == 0#32) = 1#1 → ofBool (x + 128#32 <ᵤ 256#32) = 0#1

theorem ashr_mul_sign_bits_thm (e e_1 : IntW 8) :
  trunc 16 (ashr (mul (sext 32 e_1) (sext 32 e)) (const? 32 3)) ⊑
    ashr (mul (sext 16 e_1) (sext 16 e) { «nsw» := true, «nuw» := false }) (const? 16 3)

theorem lshrugt_02_03_thm.extracted_1._1 : ∀ (x : BitVec 4), ¬2#4 ≥ ↑4 → ofBool (3#4 <ᵤ x >>> 2#4) = 0#1

theorem e_109 :
    1 *  ~~~(x ^^^ y) - 3 * x - 1 *  ~~~(x ||| y) + 6 *  ~~~(x |||  ~~~y) + 10 * (x &&&  ~~~y) + 8 * (x &&& y) = 7 * (x ||| y) - 1 * y

theorem bools_logical_commute0_thm.extracted_1._3 : ∀ (x : BitVec 1),
  ¬x ^^^ 1#1 = 1#1 → ¬x = 1#1 → ¬0#1 = 1#1 → False

theorem src_srem_shl_demand_max_mask_hit_demand_proof : src_srem_shl_demand_max_mask_hit_demand_before ⊑ src_srem_shl_demand_max_mask_hit_demand_after

@[simp]
theorem envBitstream_set_eq_self_of_ne {x : arity → BitStream}
    {n k : Nat} {v : arity → Bool} {a : arity} (hneq : k ≠ n) :
  (envBitstream_set x n v) a k = x a k

theorem logic_and_logic_or_1_thm.extracted_1._2 : ∀ (x x_1 : BitVec 1), ¬x_1 = 1#1 → 0#1 = 1#1 → 1#1 = 0#1

theorem main7c_logical_thm.extracted_1._10 : ∀ (x x_1 x_2 : BitVec 32),
  ¬ofBool (x_2 == x_2 &&& x_1) = 1#1 → ofBool (x_2 != x_2 &&& x_1) = 1#1 → ¬0#1 = 1#1 → 1#32 = zeroExtend 32 1#1

theorem C0zero_thm.extracted_1._4 : ∀ (x x_1 : BitVec 8),
  ofBool (x_1 + 10#8 <ᵤ 0#8) = 1#1 → ¬ofBool (x_1 <ₛ BitVec.ofInt 8 (-10)) = 1#1 → False

theorem const_sub_add_const_proof : const_sub_add_const_before ⊑ const_sub_add_const_after

theorem main13_proof : main13_before ⊑ main13_after

theorem bools2_logical_commute2_thm.extracted_1._12 : ∀ (x x_1 x_2 : BitVec 1),
  ¬x_2 = 1#1 → x = 1#1 → 0#1 = 1#1 → 1#1 = x

theorem test_invert_demorgan_and2_thm.extracted_1._1 : ∀ (x : BitVec 64),
  x + 9223372036854775807#64 &&& 9223372036854775807#64 ^^^ -1#64 =
    0#64 - x ||

theorem ashrslt_03_01_exact_proof : ashrslt_03_01_exact_before ⊑ ashrslt_03_01_exact_after

theorem t7_proof : t7_before ⊑ t7_after

theorem and_signbit_shl_proof : and_signbit_shl_before ⊑ and_signbit_shl_after

theorem n1_thm (e e_1 : IntW 8) :
  icmp IntPred.eq (LLVM.and (LLVM.xor (shl (const? 8 1) e_1) (const? 8 (-1))) e) e ⊑
    icmp IntPred.eq (LLVM.and e (shl (const? 8 1) e_1 { «nsw» := false, «nuw» := true })) (const? 8 0)

theorem zext_false_val_must_be_zero_proof : zext_false_val_must_be_zero_before ⊑ zext_false_val_must_be_zero_after

theorem positive_biggerlshr_shlnuwnsw_lshrexact_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬(True ∧ x >>> 6#8 <<< 6#8 ≠ x ∨
        6#8 ≥ ↑8 ∨
          True ∧ (x >>> 6#8 <<< 3#8).sshiftRight' 3#8 ≠ x >>> 6#8 ∨
            True ∧ x >>> 6#8 <<< 3#8 >>> 3#8 ≠ x >>> 6#8 ∨ 3#8 ≥ ↑8) →
    True ∧ x >>> 3#8 <<< 3#8 ≠ x ∨ 3#8 ≥ ↑8 → False

theorem icmp_eq_zext_ne_one_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (zeroExtend 32 (ofBool (x != 1#32)) == x) = 0#1

theorem icmp_eq_and_pow2_shl1_thm (e : IntW 32) :
  zext 32 (icmp IntPred.eq (LLVM.and (shl (const? 32 1) e) (const? 32 16)) (const? 32 0)) ⊑
    zext 32 (icmp IntPred.ne e (const? 32 4))

theorem positive_samevar_shlnuw_ashrexact_thm (e e_1 : IntW 8) :
  shl (ashr e_1 e { «exact» := true }) e { «nsw» := false, «nuw» := true } ⊑ e_1

theorem e_2197 :
     - 3 * ((d &&& e) ^^^ (e |||  ~~~f)) + 1 * ((d &&&  ~~~e) |||  ~~~(d ^^^ (e ^^^ f))) + 1 * (f &&&  ~~~(d ^^^ e)) - 1 * ((e &&&  ~~~f) ^^^ ( ~~~d ||| (e ^^^ f))) + 1 * (e &&& (d ||| f)) + 1 * ( ~~~d ||| (e ^^^ f)) - 1 * (d ||| f) - 1 * (f ^^^  ~~~(d ||| (e &&& f))) + 2 * (e ^^^  ~~~(d &&& f)) + 4 * (e ^^^  ~~~(d &&& (e ||| f))) - 6 * ( ~~~f |||  ~~~(d ^^^ e)) - 2 * (e ^^^  ~~~( ~~~d &&& (e ||| f))) - 2 * (e ^^^  ~~~(d &&& (e &&& f))) + 1 * (e ^^^  ~~~(d |||  ~~~f)) - 11 * (e ^^^ (d &&&  ~~~f)) - 1 *  ~~~( ~~~d &&& ( ~~~e ||| f)) + 1 * (f ^^^  ~~~( ~~~d &&& ( ~~~e &&& f))) + 3 * ((d ||| e) &&&  ~~~(e ^^^ f)) + 5 * (f &&&  ~~~(d &&& e)) - 7 *  ~~~(d |||  ~~~e) - 2 * (e ^^^ ( ~~~d ||| (e ^^^ f))) + 1 * ( ~~~(d ^^^ e) &&&  ~~~(d ^^^ f)) - 2 * (f &&& (d ^^^ e)) + 11 * (e ||| f) + 1 * ((d ^^^ e) ||| (d ^^^ f)) - 1 * (f ||| (d &&&  ~~~e)) + 11 * (e ^^^ ( ~~~d ||| ( ~~~e ||| f))) - 2 * ( ~~~(d |||  ~~~e) ||| (d ^^^ (e ^^^ f))) + 2 * ((d &&& e) ^^^  ~~~(d ^^^ (e &&& f))) + 2 * (f ^^^  ~~~(d &&& e)) + 5 * (e |||  ~~~(d |||  ~~~f)) - 11 * ((d ^^^ e) |||  ~~~(d ^^^ f)) - 11 * ( ~~~d &&& ( ~~~e ||| f)) - 3 * ((d |||  ~~~e) &&& (e ^^^ f)) - 7 * ((d &&&  ~~~e) ||| (d ^^^ (e ^^^ f))) + 2 * (e ^^^ (d ||| (e ^^^ f))) - 3 * (e ^^^  ~~~(d &&&  ~~~f)) + 1 * (e ^^^  ~~~(d ||| ( ~~~e &&& f))) + 1 * (f ^^^ ( ~~~d ||| (e &&& f))) - 1 *  ~~~(d &&& (e &&& f)) - 1 * ((e &&& f) ||| (d &&& (e ||| f))) + 4 * (d ^^^ (e ||| f)) + 1 * (e ||| (d &&& f)) + 22 *  ~~~(d ||| (e ||| f)) + 28 *  ~~~(d ||| ( ~~~e ||| f)) + 17 *  ~~~( ~~~d ||| (e ||| f)) - 25 *  ~~~( ~~~d ||| ( ~~~e ||| f)) - 5 * ( ~~~d &&& ( ~~~e &&& f)) + 26 * ( ~~~d &&& (e &&& f)) + 11 * (d &&& ( ~~~e &&& f)) + 19 * (d &&& (e &&& f)) = 6 *  ~~~(d &&&  ~~~f)

theorem trunc_shl_1_i32_i64_thm.extracted_1._2 : ∀ (x : BitVec 64),
  ¬1#64 ≥ ↑64 → ¬1#32 ≥ ↑32 → truncate 32 (x <<< 1#64) = truncate 32 x <<< 1#32

theorem test_shl_nuw__nsw_is_safe_proof : test_shl_nuw__nsw_is_safe_before ⊑ test_shl_nuw__nsw_is_safe_after

theorem test3_proof : test3_before ⊑ test3_after

theorem n8_wrong_pred3_proof : n8_wrong_pred3_before ⊑ n8_wrong_pred3_after

theorem xor_and_logic_or1_proof : xor_and_logic_or1_before ⊑ xor_and_logic_or1_after

theorem test17_proof : test17_before ⊑ test17_after

theorem e_1074 :
    5 *  ~~~z - 11 *  ~~~(z ^^^ t) - 2 * t - 2 * (z ^^^ t) + 3 *  ~~~t - 4 *  ~~~(z |||  ~~~t) - 1 * (z &&&  ~~~t) =  - 10 * (z &&& t) - 3 *  ~~~(z &&&  ~~~t)

theorem e_1522 :
     - 6 * (c ^^^  ~~~(a &&& (b &&& c))) + 2 * (c ^^^ (a ||| ( ~~~b &&& c))) - 2 *  ~~~( ~~~a &&& (b ^^^ c)) + 7 *  ~~~(a ||| (b ||| c)) + 5 *  ~~~(a ||| ( ~~~b ||| c)) + 6 *  ~~~( ~~~a ||| (b ||| c)) + 6 *  ~~~( ~~~a ||| ( ~~~b ||| c)) - 1 * ( ~~~a &&& ( ~~~b &&& c)) + 1 * (a &&& ( ~~~b &&& c)) + 8 * (a &&& (b &&& c)) =  - 1 * ((a &&& c) ^^^  ~~~(a ^^^ (b &&& c)))

theorem not_signbit_splat_mask1_thm (e : IntW 16) (e_1 : IntW 8) :
  LLVM.and (zext 16 (ashr e_1 (const? 8 7))) e ⊑ LLVM.and e (zext 16 (ashr e_1 (const? 8 7)))

theorem and_and_proof : and_and_before ⊑ and_and_after

theorem or_not_and_and_not_and_xor_commute4_proof : or_not_and_and_not_and_xor_commute4_before ⊑ or_not_and_and_not_and_xor_commute4_after

theorem e_1543 :
     - 1 *  ~~~(b &&& c) - 2 *  ~~~(a &&& ( ~~~b ||| c)) + 7 * (b ^^^  ~~~( ~~~a ||| ( ~~~b &&& c))) + 2 * ((a |||  ~~~b) &&& (b ^^^ c)) + 2 *  ~~~b + 7 * ( ~~~(a |||  ~~~b) |||  ~~~(a ^^^ (b ^^^ c))) - 2 *  ~~~(b ||| c) - 4 *  ~~~(a ||| (b ||| c)) - 11 *  ~~~(a ||| ( ~~~b ||| c)) - 6 *  ~~~( ~~~a ||| (b ||| c)) - 6 *  ~~~( ~~~a ||| ( ~~~b ||| c)) - 1 * ( ~~~a &&& ( ~~~b &&& c)) - 10 * (a &&& ( ~~~b &&& c)) = 12 * ( ~~~a &&& (b &&& c))

theorem test_nuw_nsw_and_unsigned_pred_thm.extracted_1._1 : ∀ (x : BitVec 64),
  ¬(True ∧ (10#64).ssubOverflow x = true ∨ True ∧ (10#64).usubOverflow x = true) →
    ofBool (10#64 - x ≤ᵤ 3#64) = ofBool (6#64 <ᵤ x)

theorem exact_lshr_eq_opposite_msb_thm (e : IntW 8) :
  icmp IntPred.eq (lshr (const? 8 (-128)) e { «exact» := true }) (const? 8 1) ⊑
    icmp IntPred.eq e (const? 8 7)

theorem logical_or_logical_or_icmps_comm1_thm.extracted_1._5 : ∀ (x x_1 x_2 : BitVec 8),
  ¬x_1 ≥ ↑8 →
    ¬(ofBool (x_2 &&& 1#8 <<< x_1 == 0#8) = 1#1 ∨ ofBool (x == 42#8) = 1#1) →
      ¬(True ∧ 1#8 <<< x_1 >>> x_1 ≠ 1#8 ∨ x_1 ≥ ↑8) →
        ofBool (x_2 &&& 1#8 <<< x_1 == 0#8) = 1#1 → True → ofBool (x_2 &&& 1#8 == 0#8) = 1#1

theorem t0_ult_slt_128_thm.extracted_1._5 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (x_1 + 16#32 <ᵤ 144#32) = 1#1 →
    ofBool (x_1 <ₛ 128#32) = 1#1 →
      ¬ofBool (127#32 <ₛ x_1) = 1#1 → ¬ofBool (x_1 <ₛ BitVec.ofInt 32 (-16)) = 1#1 → x = x_1

theorem bools_logical_commute3_and2_thm.extracted_1._13 : ∀ (x x_1 x_2 : BitVec 1),
  ¬x_2 = 1#1 → ¬x_1 = 1#1 → 0#1 = 1#1 → 1#1 = x_2

theorem e_1583 :
     - 2 *  ~~~( ~~~a ||| ( ~~~b &&& c)) + 2 * (a &&& ( ~~~b ||| c)) - 1 * a - 3 * (b ^^^ ( ~~~a ||| ( ~~~b ||| c))) + 1 * ( ~~~a ||| (b &&& c)) + 11 * ((b &&& c) ^^^  ~~~(a &&& (b ^^^ c))) + 1 * (c ^^^ (a |||  ~~~b)) - 1 * ((a &&& c) ^^^ (a ^^^ (b &&& c))) + 11 * (b ^^^ ( ~~~a ||| (b ||| c))) - 16 *  ~~~(a ||| (b ||| c)) - 7 *  ~~~(a ||| ( ~~~b ||| c)) - 7 *  ~~~( ~~~a ||| (b ||| c)) + 6 *  ~~~( ~~~a ||| ( ~~~b ||| c)) - 20 * ( ~~~a &&& ( ~~~b &&& c)) - 1 * ( ~~~a &&& (b &&& c)) - 4 * (a &&& ( ~~~b &&& c)) + 1 * (a &&& (b &&& c)) = 5 * (c ^^^ ( ~~~a ||| (b &&& c)))

theorem shl_bad_sub2_i32_thm (e : IntW 32) :
  shl (const? 32 1) (sub e (const? 32 31)) ⊑
    shl (const? 32 1) (add e (const? 32 (-31))) { «nsw» := false, «nuw» := true }

lemma product.f_spec {m₁ m₂ : CNFA n} {s₁ : m₁.m.states} {s₂ : m₂.m.states} :
    ∀ a s₁' s₂',
      (a, (s₁', s₂')) ∈ f m₁ m₂ (s₁, s₂) ↔ s₁'.val ∈ m₁.m.tr s₁ a ∧ s₂'.val ∈ m₂.m.tr s₂ a

theorem select_icmp_ne_0_and_32_or_4096_thm.extracted_1._4 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (0#32 != x_1 &&& 32#32) = 1#1 → ¬7#32 ≥ ↑32 → x ||

theorem test_nuw_nsw_and_signed_pred_thm.extracted_1._1 : ∀ (x : BitVec 64),
  ¬(True ∧ (10#64).ssubOverflow x = true ∨ True ∧ (10#64).usubOverflow x = true) →
    ofBool (10#64 - x <ₛ 3#64) = ofBool (7#64 <ᵤ x)

theorem and_or1_commuted_thm.extracted_1._1 : ∀ (x x_1 : BitVec 1),
  x_1 ||

theorem mul_constant_eq_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ofBool (x_1 * 5#32 == x * 5#32) = ofBool (x_1 == x)

theorem logical_or_logical_or_icmps_comm3_thm.extracted_1._5 : ∀ (x x_1 x_2 : BitVec 8),
  ¬x_1 ≥ ↑8 →
    ¬(ofBool (x_2 &&& 1#8 <<< x_1 == 0#8) = 1#1 ∨ ofBool (x_2 &&& 1#8 == 0#8) = 1#1) →
      True ∧ 1#8 <<< x_1 >>> x_1 ≠ 1#8 ∨ x_1 ≥ ↑8 ∨ True ∧ 1#8 <<< x_1 >>> x_1 ≠ 1#8 ∨ x_1 ≥ ↑8 → False

theorem lshrult_02_01_proof : lshrult_02_01_before ⊑ lshrult_02_01_after

theorem test_sub_nsw__nuw_is_safe_thm (e : IntW 32) :
  select (icmp IntPred.eq (LLVM.and e (const? 32 2147483647)) (const? 32 1073741824)) (const? 32 1073741824)
      (sub (const? 32 (-2147483648)) (LLVM.and e (const? 32 2147483647)) { «nsw» := true, «nuw» := false }) ⊑
    sub (const? 32 (-2147483648)) (LLVM.and e (const? 32 2147483647)) { «nsw» := false, «nuw» := true }

theorem slt3 (w : Nat) (a b : BitVec w) : ((a.sle b) ∧ (b.sle a)) → a = b

theorem not_sext_proof : not_sext_before ⊑ not_sext_after

theorem twoway_clamp_lt_thm.extracted_1._3 : ∀ (x : BitVec 32),
  ¬ofBool (x <ₛ 13768#32) = 1#1 →
    ¬ofBool (13767#32 <ₛ x) = 1#1 → ofBool (13767#32 <ₛ 13768#32) = 1#1 → 13768#32 = 13767#32

theorem e_1394 :
     - 6 *  ~~~t - 3 * (z ^^^ t) - 2 *  ~~~(z &&&  ~~~z) + 3 *  ~~~(z &&& t) - 1 * (z ||| t) + 1 * z - 2 *  ~~~(z ||| t) + 3 *  ~~~(z |||  ~~~t) + 8 * (z &&&  ~~~t) - 5 * (z &&& t) =  - 7 *  ~~~(z ^^^ t)

theorem src_thm (e e_1 : IntW 32) :
  add (LLVM.and e_1 e) (LLVM.xor (LLVM.or e_1 e) (const? 32 (-1))) ⊑ LLVM.xor (LLVM.xor e_1 e) (const? 32 (-1))

theorem e_302 :
     - 1 * x - 7 * (x |||  ~~~y) - 1 *  ~~~(x &&&  ~~~x) - 7 * (x ||| y) + 10 *  ~~~(x |||  ~~~y) + 16 * (x &&&  ~~~y) + 18 * (x &&& y) =  - 10 *  ~~~(x ||| y) + 2 *  ~~~(x &&&  ~~~y)

@[simp] theorem Valuation.cons_append {V : Γ.Valuation} {W : Δ.Valuation} {x : ⟦t⟧} :
    HAppend.hAppend (α := Valuation no_index _) (γ := Valuation no_index _)
      (x ::ᵥ V) W -- x::ᵥV ++ W
    = x ::ᵥ (V ++ W)

theorem logical_and_not_proof : logical_and_not_before ⊑ logical_and_not_after

theorem test1_thm (e : IntW 32) :
  add e
      (add (LLVM.xor (LLVM.and (ashr e (const? 32 1)) (const? 32 1431655765)) (const? 32 (-1))) (const? 32 1)
        { «nsw» := true, «nuw» := false })
      { «nsw» := true, «nuw» := false } ⊑
    sub e (LLVM.and (lshr e (const? 32 1)) (const? 32 1431655765)) { «nsw» := true, «nuw» := false }

theorem logical_and_implies_proof : logical_and_implies_before ⊑ logical_and_implies_after

theorem sge_or_max_proof : sge_or_max_before ⊑ sge_or_max_after

theorem fold_sext_to_and_wrong6_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ofBool (signExtend 32 x &&& BitVec.ofInt 32 (-2147483647) != -1#32) = 1#1

theorem logic_and_logic_or_7_thm.extracted_1._2 : ∀ (x x_1 : BitVec 1), x_1 = 1#1 → x = 1#1 → 1#1 = x

theorem test19_thm.extracted_1._2 : ∀ (x : BitVec 10),
  ¬(2#3 ≥ ↑3 ∨ 2#3 ≥ ↑3) →
    ¬(True ∧ (0#3).ssubOverflow (truncate 3 x &&& 1#3) = true) →
      signExtend 10 ((truncate 3 x <<< 2#3).sshiftRight' 2#3) = signExtend 10 (0#3 - (truncate 3 x &&& 1#3))

theorem test3_thm.extracted_1._1 : ∀ (x : BitVec 32), ¬8#32 = 0 → x % 8#32 = x &&& 7#32

theorem ashr_slt_exact_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬(True ∧ x >>> 3#8 <<< 3#8 ≠ x ∨ 3#8 ≥ ↑8) → ofBool (x.sshiftRight' 3#8 <ₛ 10#8) = ofBool (x <ₛ 80#8)

theorem test_add__none_are_safe_proof : test_add__none_are_safe_before ⊑ test_add__none_are_safe_after

@[simp]
theorem ite_value_value {c : Prop} [Decidable c] {a b : α} :
    (if c then value a else value b : no_index _) = value (if c then a else b)

theorem eq_basic_equal_minus_1_proof : eq_basic_equal_minus_1_before ⊑ eq_basic_equal_minus_1_after

theorem ne_umax3_thm.extracted_1._2 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (x <ᵤ x_1 + 3#32) = 1#1 → ofBool (x_1 + 3#32 != x) = ofBool (x_1 + 3#32 <ᵤ x)

theorem shift_xor_multiuse_cmp_with_xor_thm.extracted_1._4 : ∀ (x x_1 x_2 x_3 : BitVec 32),
  ¬ofBool (0#32 != x_3 &&& 4096#32) = 1#1 →
    ¬ofBool (x_3 &&& 4096#32 == 0#32) = 1#1 → (x_2 ^^^ 2048#32) * x = x_2 * x_1

theorem slt_zero_eq_i1_thm (e : IntW 32) (e_1 : IntW 1) :
  icmp IntPred.eq (zext 32 e_1) (lshr e (const? 32 31)) ⊑
    LLVM.xor (icmp IntPred.sgt e (const? 32 (-1))) e_1

theorem test42_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 32),
  (x_2 ^^^ -1#32 ^^^ x_1 * x) &&& (x_2 ||| x_1 * x) = x_1 * x &&& x_2

theorem sle_smax2_proof : sle_smax2_before ⊑ sle_smax2_after

theorem test38_proof : test38_before ⊑ test38_after

theorem and_ugt_to_mask_proof : and_ugt_to_mask_before ⊑ and_ugt_to_mask_after

theorem ashrslt_01_14_proof : ashrslt_01_14_before ⊑ ashrslt_01_14_after

@[simp]
lemma CNFA.SignedCmp_states cmp : s ∈ (autSignedCmp cmp).m.states ↔  s < 5

theorem pr40493_neg3_proof : pr40493_neg3_before ⊑ pr40493_neg3_after

theorem lshrult_02_10_exact_proof : lshrult_02_10_exact_before ⊑ lshrult_02_10_exact_after

theorem main7b_logical_proof : main7b_logical_before ⊑ main7b_logical_after

@[simp]
theorem Eqn.numVars_nil : Eqn.numVars [] = 0

theorem slt_swap_or_not_max_commute_proof : slt_swap_or_not_max_commute_before ⊑ slt_swap_or_not_max_commute_after

theorem sdiv_shl_shl_nsw2_nuw_thm.extracted_1._2 : ∀ (x x_1 x_2 : BitVec 8),
  ¬(True ∧ (x_2 <<< x_1).sshiftRight' x_1 ≠ x_2 ∨
        x_1 ≥ ↑8 ∨
          True ∧ (x <<< x_1).sshiftRight' x_1 ≠ x ∨
            True ∧ x <<< x_1 >>> x_1 ≠ x ∨
              x_1 ≥ ↑8 ∨ (x <<< x_1 == 0 || 8 != 1 && x_2 <<< x_1 == intMin 8 && x <<< x_1 == -1) = true) →
    ¬(x == 0 || 8 != 1 && x_2 == intMin 8 && x == -1) = true → (x_2 <<< x_1).sdiv (x <<< x_1) = x_2.sdiv x

@[simp]
theorem instantiate_mvar_zero {hφ : List.length (w :: ws) = φ} {h0 : 0 < φ} :
    ConcreteOrMVar.instantiate (Subtype.mk (w :: ws) hφ)  (ConcreteOrMVar.mvar ⟨0, h0⟩) = w

theorem or_nosignbit_select_shl_proof : or_nosignbit_select_shl_before ⊑ or_nosignbit_select_shl_after

theorem test_shl_nuw__none_are_safe_thm.extracted_1._2 : ∀ (x : BitVec 64) (x_1 : BitVec 32),
  ofBool (x_1 &&& BitVec.ofInt 32 (-2) == 0#32) = 1#1 →
    ¬(2#32 ≥ ↑32 ∨
          True ∧ (x_1 <<< 2#32 &&& BitVec.ofInt 32 (-8)).msb = true ∨
            zeroExtend 64 (x_1 <<< 2#32 &&& BitVec.ofInt 32 (-8)) ≥ ↑64) →
      x = x.sshiftRight' (zeroExtend 64 (x_1 <<< 2#32 &&& BitVec.ofInt 32 (-8)))

theorem ult_umin1_proof : ult_umin1_before ⊑ ult_umin1_after

theorem bools2_logical_commute3_and1_thm.extracted_1._6 : ∀ (x x_1 x_2 : BitVec 1),
  ¬x_2 &&& x_1 = 1#1 → x = 1#1 → ¬x_1 = 1#1 → x_1 ^^^ 1#1 = x

theorem in_constant_14_vary_proof : in_constant_14_vary_before ⊑ in_constant_14_vary_after

theorem e_2190 :
     - 7 * (e ^^^ ( ~~~d ||| (e &&& f))) - 5 * (e &&& (d ^^^ f)) - 2 *  ~~~(d ||| ( ~~~e &&& f)) + 5 * (f ^^^  ~~~( ~~~d &&& (e ||| f))) + 1 * ( ~~~(d &&& e) &&& (e ^^^ f)) - 1 * (f ^^^  ~~~( ~~~d &&& ( ~~~e ||| f))) - 1 * (f ^^^  ~~~(d &&& (e &&& f))) - 2 * (e ^^^  ~~~( ~~~d &&& (e ||| f))) - 1 * (e ^^^ (d ||| ( ~~~e ||| f))) + 11 * (f ^^^ (d &&&  ~~~e)) - 11 * ( ~~~(d &&& e) &&&  ~~~(d ^^^ (e ^^^ f))) - 2 * (d ^^^ ( ~~~e ||| f)) + 1 * (d &&&  ~~~f) - 6 * ((d &&& f) ^^^  ~~~(e &&&  ~~~f)) - 5 * (f ^^^  ~~~(d &&& ( ~~~e ||| f))) + 2 * (f ||| (d &&&  ~~~e)) + 3 * (e ^^^  ~~~(d &&& (e ^^^ f))) - 6 * ((e &&&  ~~~f) |||  ~~~( ~~~d ||| ( ~~~e &&& f))) - 1 * ((d |||  ~~~e) &&& (d ^^^ (e ^^^ f))) - 11 * ((d &&& e) ^^^ (d ^^^ ( ~~~e ||| f))) + 2 * (f &&&  ~~~(d ^^^ e)) - 1 * ( ~~~(d ^^^ e) &&&  ~~~(d ^^^ f)) - 1 * ( ~~~d &&& ( ~~~e ||| f)) + 1 * (e ^^^ (d &&& (e ||| f))) - 2 * ((d &&& f) ^^^  ~~~(d ^^^ (e &&& f))) - 3 * (e &&& (d ||| f)) - 1 * ( ~~~f &&&  ~~~(d ^^^ e)) - 2 * (e |||  ~~~(d ^^^ f)) - 6 * (e ^^^  ~~~(d &&& (e ||| f))) + 2 * ((d &&& f) ^^^  ~~~(d ^^^ ( ~~~e &&& f))) + 1 *  ~~~( ~~~d &&& (e ||| f)) + 1 * (f ^^^  ~~~( ~~~d ||| (e &&& f))) - 6 * (e |||  ~~~(d ||| f)) + 11 * ((e &&&  ~~~f) ^^^ ( ~~~d ||| (e ^^^ f))) + 3 *  ~~~(e ^^^ f) - 1 * (f ^^^  ~~~(d &&& (e ||| f))) - 2 * ((d &&& e) ^^^ (e ||| f)) - 1 *  ~~~(d &&& f) - 7 *  ~~~(e &&& f) + 2 * ( ~~~e &&& (d ^^^ f)) + 5 * (f ^^^ ( ~~~d ||| (e &&& f))) + 5 * (e ^^^ ( ~~~d &&& (e ^^^ f))) + 2 * (f ^^^  ~~~(d &&&  ~~~e)) - 11 * (d ^^^ e) + 39 *  ~~~(d ||| (e ||| f)) + 32 *  ~~~(d ||| ( ~~~e ||| f)) + 10 *  ~~~( ~~~d ||| (e ||| f)) + 35 *  ~~~( ~~~d ||| ( ~~~e ||| f)) + 25 * ( ~~~d &&& (e &&& f)) + 21 * (d &&& ( ~~~e &&& f)) + 9 * (d &&& (e &&& f)) =  - 2 * (e &&&  ~~~(d ^^^ f)) - 5 * ( ~~~(d ||| e) ||| (d ^^^ (e ^^^ f)))

theorem AvoidCollision_toFin_setWidth {x : BitVec w} :
    (x.setWidth v).toFin = Fin.ofNat (2^v) x.toNat

theorem p0_ult_65536_proof : p0_ult_65536_before ⊑ p0_ult_65536_after

theorem ofBitVec_sub : ofBitVecSext (x - y) ≈ʷ (ofBitVecSext x) - (ofBitVecSext y)

theorem no_masks_with_logical_or2_thm.extracted_1._3 : ∀ (x x_1 x_2 : BitVec 32),
  ofBool (x_2 != -1#32) = 1#1 → ofBool (x_2 &&& x != -1#32) = 1#1 → 1#1 ||

theorem thisdoesnotloop_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x <ₛ BitVec.ofInt 32 (-128)) = 1#1 → truncate 8 128#32 = BitVec.ofInt 8 (-128)

theorem exact_lshr_ne_opposite_msb_proof : exact_lshr_ne_opposite_msb_before ⊑ exact_lshr_ne_opposite_msb_after

theorem test2_proof : test2_before ⊑ test2_after

theorem mul_of_udiv_thm.extracted_1._2 : ∀ (x : BitVec 8),
  ¬(True ∧ x.umod 12#8 ≠ 0 ∨ 12#8 = 0) → ¬(True ∧ x >>> 1#8 <<< 1#8 ≠ x ∨ 1#8 ≥ ↑8) → x / 12#8 * 6#8 = x >>> 1#8

theorem uge_or_not_max_commute_thm (e e_1 : IntW 8) :
  LLVM.or (icmp IntPred.ne e_1 (const? 8 (-1))) (icmp IntPred.uge e_1 e) ⊑ const? 1 1

theorem bv_select_1100 :
    ∀ (e e_1 : LLVM.IntW w), LLVM.select (LLVM.const? 1 1) e_1 e ⊑ e_1

theorem t20_thm (e : IntW 16) (e_1 : IntW 8) :
  sub e_1 (trunc 8 (shl (const? 16 (-42)) e)) ⊑ add e_1 (trunc 8 (shl (const? 16 42) e))

theorem select_icmp_x_and_8_eq_0_y_xor_8_thm.extracted_1._2 : ∀ (x : BitVec 64) (x_1 : BitVec 32),
  ofBool (x_1 &&& 8#32 == 0#32) = 1#1 → ¬(True ∧ (x_1 &&& 8#32).msb = true) → x = x ^^^ zeroExtend 64 (x_1 &&& 8#32)

theorem ashr_lowmask_thm (e : IntW 32) : LLVM.and (ashr e (const? 32 24)) (const? 32 255) ⊑ lshr e (const? 32 24)

theorem e_2434 :
    1 * (d ||| f) - 2 *  ~~~(d ||| f) - 7 * (f &&&  ~~~(d &&&  ~~~e)) + 5 * (f ^^^  ~~~( ~~~d &&& (e &&& f))) + 1 * ((d &&& e) ^^^  ~~~(d ^^^ ( ~~~e ||| f))) - 7 * ( ~~~(d ^^^ e) &&& (d ^^^ f)) + 7 * (f ^^^  ~~~(d ||| (e &&& f))) - 7 * ( ~~~(d &&&  ~~~e) &&& (e ^^^ f)) - 2 * (e ^^^  ~~~( ~~~d ||| (e &&& f))) - 11 *  ~~~(d &&&  ~~~e) - 3 * (d &&&  ~~~e) + 1 * (e ^^^  ~~~(d &&& ( ~~~e ||| f))) - 5 * (e ^^^  ~~~(d ||| (e &&& f))) + 1 * ((e &&& f) ^^^  ~~~( ~~~d &&& (e ^^^ f))) + 2 * (f &&&  ~~~(d ^^^ e)) - 1 * ((e &&&  ~~~f) ^^^ (d ||| (e ^^^ f))) + 4 *  ~~~(d ^^^ (e &&& f)) - 3 * (e ^^^ (d ||| f)) + 11 * (d |||  ~~~e) + 1 * ((d &&& e) ^^^  ~~~(d ^^^ (e &&& f))) - 7 * ( ~~~(d &&& e) &&& (d ^^^ (e ^^^ f))) - 1 * ( ~~~(d ||| e) ||| (d ^^^ (e ^^^ f))) - 2 * (f ^^^  ~~~(d &&& (e &&& f))) - 5 * (e ^^^ (d ||| ( ~~~e ||| f))) + 3 * (d ||| ( ~~~e &&& f)) + 4 *  ~~~( ~~~d &&& (e ^^^ f)) + 5 * (f ^^^  ~~~(d &&& (e ||| f))) - 6 *  ~~~(d ^^^ (e ^^^ f)) + 11 * (d &&& ( ~~~e ||| f)) + 1 * ( ~~~(d |||  ~~~e) ||| (d ^^^ (e ^^^ f))) + 7 * ((d &&& e) |||  ~~~(e ^^^ f)) + 3 * (e &&& f) - 2 * ((d ||| e) &&&  ~~~(d ^^^ (e ^^^ f))) + 1 * ((d &&& f) |||  ~~~(e ||| f)) - 11 *  ~~~(d ^^^ ( ~~~e ||| f)) - 3 * (d ^^^ e) + 7 * (f ^^^  ~~~(d &&& e)) + 5 *  ~~~( ~~~d ||| ( ~~~e &&& f)) - 1 * (e ^^^  ~~~( ~~~d ||| (e ^^^ f))) + 2 *  ~~~( ~~~d &&& ( ~~~e &&& f)) - 1 * (f ^^^ ( ~~~d ||| (e ||| f))) + 2 * (d &&& (e ^^^ f)) - 1 * ( ~~~(d ^^^ e) |||  ~~~(d ^^^ f)) - 5 * ( ~~~f &&&  ~~~(d ^^^ e)) - 7 * (f ^^^  ~~~(d |||  ~~~e)) - 1 * (e ^^^  ~~~(d &&& (e ^^^ f))) + 11 * ((d |||  ~~~e) &&&  ~~~(d ^^^ (e ^^^ f))) + 4 * (e ^^^  ~~~(d |||  ~~~f)) + 3 * (d ||| ( ~~~e ||| f)) + 1 * ( ~~~(d ||| e) ||| (e ^^^ f)) + 11 *  ~~~(e |||  ~~~f) + 7 * (e ^^^  ~~~(d &&& ( ~~~e &&& f))) + 2 *  ~~~(d &&&  ~~~d) - 2 * (e ^^^  ~~~(d ||| f)) - 1 * e + 2 *  ~~~(d &&& f) - 5 * ( ~~~(d &&& e) &&& (e ^^^ f)) - 6 * ((e &&& f) ||| (d &&& (e ||| f))) + 1 *  ~~~(e &&& f) + 2 * (e &&&  ~~~(d &&& f)) - 2 * (e ^^^ (d ||| ( ~~~e &&& f))) - 11 * (e |||  ~~~f) + 5 *  ~~~(d &&& (e ^^^ f)) - 1 * d + 1 * (f ^^^  ~~~( ~~~d &&& ( ~~~e ||| f))) + 7 * ((d &&& f) ||| (e &&&  ~~~f)) + 1 * ((d &&& f) ^^^ (d ^^^ ( ~~~e &&& f))) + 1 * (d ||| (e &&& f)) - 29 *  ~~~(d ||| (e ||| f)) + 25 *  ~~~(d ||| ( ~~~e ||| f)) - 33 *  ~~~( ~~~d ||| (e ||| f)) - 8 *  ~~~( ~~~d ||| ( ~~~e ||| f)) + 15 * ( ~~~d &&& ( ~~~e &&& f)) + 13 * ( ~~~d &&& (e &&& f)) - 23 * (d &&& ( ~~~e &&& f)) - 27 * (d &&& (e &&& f)) = 1 * (d ^^^ ( ~~~e &&& f)) + 6 * (e ^^^ ( ~~~d ||| (e ||| f)))

theorem lshrult_03_10_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬3#4 ≥ ↑4 → ofBool (x >>> 3#4 <ᵤ BitVec.ofInt 4 (-6)) = 1#1

theorem mul_constant_partial_nuw_eq_thm (e e_1 : IntW 32) :
  icmp IntPred.eq (mul e_1 (const? 32 44)) (mul e (const? 32 44) { «nsw» := false, «nuw» := true }) ⊑
    icmp IntPred.eq (LLVM.and (LLVM.xor e_1 e) (const? 32 1073741823)) (const? 32 0)

theorem e_1799 :
    5 * (b ^^^ ( ~~~a ||| (b ^^^ c))) - 6 * (b ^^^  ~~~(a &&& ( ~~~b ||| c))) + 1 * (c ^^^  ~~~( ~~~a &&& (b &&& c))) + 1 * ((a ||| b) &&& (a ^^^ (b ^^^ c))) - 1 * (b ^^^  ~~~(a ||| (b &&& c))) - 7 * ((b &&& c) ||| ( ~~~a &&& (b ||| c))) - 11 * (b ^^^ (a ||| ( ~~~b &&& c))) + 3 * (a &&& ( ~~~b ||| c)) - 1 * ( ~~~(a ^^^ b) &&&  ~~~(a ^^^ c)) - 6 *  ~~~(a &&&  ~~~b) + 2 * (b |||  ~~~(a |||  ~~~c)) + 1 * (b ^^^  ~~~(a &&&  ~~~c)) - 2 * (c ||| (a &&& b)) - 3 * (b ^^^ (a &&& ( ~~~b ||| c))) - 5 * ( ~~~(a &&&  ~~~b) &&&  ~~~(a ^^^ (b ^^^ c))) - 7 * (a ^^^ ( ~~~b &&& c)) + 3 * (b ^^^  ~~~( ~~~a &&& ( ~~~b ||| c))) + 1 *  ~~~(a ^^^ c) - 11 *  ~~~(a &&& b) + 7 *  ~~~( ~~~a ||| (b &&& c)) - 2 * (b ^^^  ~~~( ~~~a ||| (b &&& c))) - 1 * ((b &&&  ~~~c) ^^^ (a ||| (b ^^^ c))) + 4 * (a ^^^ (b ||| c)) + 2 * (b ^^^  ~~~( ~~~a &&& (b ^^^ c))) + 1 * ((a &&& b) ^^^ (a ^^^ ( ~~~b ||| c))) - 2 * (a &&& c) - 7 * (b ^^^ (a &&&  ~~~c)) - 5 *  ~~~( ~~~a &&& ( ~~~b ||| c)) - 2 * (b ^^^  ~~~( ~~~a &&& (b ||| c))) - 3 * ( ~~~b |||  ~~~(a ^^^ c)) - 2 * ((a &&& c) ^^^  ~~~(a ^^^ ( ~~~b &&& c))) - 5 * (c ^^^ ( ~~~a ||| (b ||| c))) + 24 *  ~~~(a ||| (b ||| c)) + 53 *  ~~~(a ||| ( ~~~b ||| c)) + 26 *  ~~~( ~~~a ||| (b ||| c)) + 21 *  ~~~( ~~~a ||| ( ~~~b ||| c)) + 40 * ( ~~~a &&& ( ~~~b &&& c)) + 46 * ( ~~~a &&& (b &&& c)) + 18 * (a &&& ( ~~~b &&& c)) + 39 * (a &&& (b &&& c)) =  - 5 *  ~~~(b ||| c) - 2 * ( ~~~(a ||| b) |||  ~~~(a ^^^ (b ^^^ c)))

theorem t5_thm.extracted_1._6 : ∀ (x x_1 : BitVec 1) (x_2 : BitVec 32),
  x_1 = 1#1 → ¬x = 1#1 → ¬64#32 = 0 → 6#32 ≥ ↑32 → False

theorem slt_zero_ult_i1_thm.extracted_1._1 : ∀ (x : BitVec 32) (x_1 : BitVec 1),
  ¬31#32 ≥ ↑32 → ofBool (zeroExtend 32 x_1 <ᵤ x >>> 31#32) = ofBool (x <ₛ 0#32) &&& (x_1 ^^^ 1#1)

theorem ashr_ugt_13_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬1#4 ≥ ↑4 → ofBool (BitVec.ofInt 4 (-3) <ᵤ x.sshiftRight' 1#4) = ofBool (BitVec.ofInt 4 (-5) <ᵤ x)

theorem ashr_ult_9_proof : ashr_ult_9_before ⊑ ashr_ult_9_after

theorem mul_of_udiv_fail_bad_remainder_proof : mul_of_udiv_fail_bad_remainder_before ⊑ mul_of_udiv_fail_bad_remainder_after

theorem main7g_logical_proof : main7g_logical_before ⊑ main7g_logical_after

theorem or_or_and_pat3_proof : or_or_and_pat3_before ⊑ or_or_and_pat3_after

theorem n10_wrong_pred2_thm (e e_1 : IntW 8) :
  icmp IntPred.eq (add e_1 e) e ⊑ icmp IntPred.eq e_1 (const? 8 0)

theorem udiv_eq_big_proof : udiv_eq_big_before ⊑ udiv_eq_big_after

theorem positive_with_mask_logical_proof : positive_with_mask_logical_before ⊑ positive_with_mask_logical_after

theorem sel_zext_thm.extracted_1._1 : ∀ (x : BitVec 1), ¬x = 1#1 → zeroExtend 64 42#32 = 42#64

theorem or_not_xor_common_op_commute2_proof : or_not_xor_common_op_commute2_before ⊑ or_not_xor_common_op_commute2_after

theorem src_x_and_nmask_sge_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ¬(x ≥ ↑8 ∨ x ≥ ↑8) → True ∧ ((-1#8) <<< x).sshiftRight' x ≠ -1#8 ∨ x ≥ ↑8 → False

theorem t0_ult_slt_128_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x + 16#32 <ᵤ 144#32) = 1#1 → ofBool (127#32 <ₛ x) = 1#1 ∨ ofBool (x <ₛ BitVec.ofInt 32 (-16)) = 1#1 → False

theorem shl_nsw_sgt_n1_thm (e e_1 : IntW 8) :
  icmp IntPred.sgt (shl e_1 e { «nsw» := true, «nuw» := false }) (const? 8 (-1)) ⊑
    icmp IntPred.sgt e_1 (const? 8 (-1))

theorem or_and2_thm (e e_1 e_2 : IntW 1) :
  select (LLVM.or (LLVM.xor e_2 (const? 1 1)) e_1) e_1 e ⊑ select e_1 (const? 1 1) (select e_2 e (const? 1 0))

theorem zext_lshr_thm.extracted_1._2 : ∀ (x : BitVec 8),
  ¬4#16 ≥ ↑16 →
    ¬(4#8 ≥ ↑8 ∨ True ∧ (x >>> 4#8 &&& x).msb = true) →
      zeroExtend 16 x >>> 4#16 &&& zeroExtend 16 x = zeroExtend 16 (x >>> 4#8 &&& x)

theorem trans {α : Type u} : ∀ x y z : Option α, Refinement x y → Refinement y z → Refinement x z

lemma NFA'.autEq_correct : autEq.correct2 (fun _ => eqRel) eqRel

theorem main7c_logical_thm.extracted_1._7 : ∀ (x x_1 x_2 : BitVec 32),
  ofBool (x_2 == x_2 &&& x_1) = 1#1 →
    ¬ofBool (x_2 != x_2 &&& x_1) = 1#1 →
      ofBool (x == x &&& x_1) = 1#1 → 0#32 = zeroExtend 32 (ofBool (x != x &&& x_1))

theorem e_7 :
    11 *  ~~~(x &&&  ~~~y) - 11 * x + 11 * (x &&&  ~~~y) + 11 * (x &&& y) = 11 *  ~~~(x ||| y) + 11 * y

theorem mul_add_to_mul_1_thm.extracted_1._1 : ∀ (x : BitVec 16),
  ¬(True ∧ x.smulOverflow 8#16 = true ∨ True ∧ x.saddOverflow (x * 8#16) = true) →
    True ∧ x.smulOverflow 9#16 = true → False

theorem min_of_max_swap_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬ofBool (0#32 <ₛ x) = 1#1 → ofBool (x ^^^ -1#32 <ₛ -1#32) = 1#1 → x ^^^ -1#32 = -1#32

theorem mul_of_bool_no_lz_other_op_thm.extracted_1._1 : ∀ (x : BitVec 8) (x_1 : BitVec 32),
  ¬(True ∧ (x_1 &&& 1#32).smulOverflow (signExtend 32 x) = true ∨
        True ∧ (x_1 &&& 1#32).umulOverflow (signExtend 32 x) = true) →
    ofBool (127#32 <ₛ (x_1 &&& 1#32) * signExtend 32 x) = 0#1

theorem lshr_xor_thm (e : IntW 8) :
  LLVM.xor (lshr (const? 8 16) e) (lshr (const? 8 3) (add e (const? 8 1))) ⊑ lshr (const? 8 17) e

theorem and_two_ranges_to_mask_and_range_no_add_on_one_range_thm (e : IntW 16) :
  LLVM.and (icmp IntPred.uge e (const? 16 12))
      (LLVM.or (icmp IntPred.ult e (const? 16 16)) (icmp IntPred.uge e (const? 16 28))) ⊑
    icmp IntPred.ugt (LLVM.and e (const? 16 (-20))) (const? 16 11)

theorem t15_and_with_const1_proof : t15_and_with_const1_before ⊑ t15_and_with_const1_after

theorem negation_of_increment_via_or_with_no_common_bits_set_thm (e e_1 : IntW 8) :
  sub e_1 (LLVM.or (shl e (const? 8 1)) (const? 8 1)) ⊑ add e_1 (LLVM.xor (shl e (const? 8 1)) (const? 8 (-1)))

theorem max_of_min_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬ofBool (0#32 <ₛ x) = 1#1 → ofBool (-1#32 <ₛ -1#32) = 1#1 ∧ ofBool (0#32 <ₛ x) = 1#1 → x ^^^ -1#32 = -1#32

theorem t9_nocse_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬(x ≥ ↑8 ∨ x ≥ ↑8) →
    True ∧ 1#8 <<< x >>> x ≠ 1#8 ∨ x ≥ ↑8 ∨ True ∧ ((-1#8) <<< x).sshiftRight' x ≠ -1#8 ∨ x ≥ ↑8 → False

@[simp, simp_denote, simp_sllvm]
lemma run_ub : StateT.run (throwUB : EffectM α) s = .poison

@[simp] theorem get_map (xs : HVector A as) (f : (a : α) → A a → B a) :
    (xs.map f).get i = f _ (xs.get i)

theorem e_744 :
    1 * (x ^^^ y) - 11 *  ~~~(x &&&  ~~~x) + 11 * x + 3 *  ~~~(x &&& y) - 3 *  ~~~(x &&&  ~~~y) - 1 *  ~~~y + 1 * y + 14 *  ~~~(x ||| y) + 15 *  ~~~(x |||  ~~~y) - 3 * (x &&&  ~~~y) - 2 * (x &&& y) =  - 4 *  ~~~(x ^^^ y) + 6 *  ~~~x

theorem test3_thm.extracted_1._1 : ∀ (x : BitVec 23), x &&& 127#23 &&& 128#23 = 0#23

theorem lshr_shl_pow2_const_case2_thm.extracted_1._2 : ∀ (x : BitVec 16),
  ¬(x ≥ ↑16 ∨ 4#16 ≥ ↑16) → ¬ofBool (x == 12#16) = 1#1 → 8192#16 >>> x <<< 4#16 &&& 32#16 = 0#16

theorem nonexact_lshr_ne_exactdiv_proof : nonexact_lshr_ne_exactdiv_before ⊑ nonexact_lshr_ne_exactdiv_after

theorem eval_sext_multi_use_in_one_inst_thm (e : IntW 32) :
  sext 32
      (LLVM.or
        (mul (LLVM.and (trunc 16 e) (const? 16 14)) (LLVM.and (trunc 16 e) (const? 16 14))
          { «nsw» := true, «nuw» := true })
        (const? 16 (-32768))) ⊑
    sext 32
      (LLVM.or
        (mul (LLVM.and (trunc 16 e) (const? 16 14)) (LLVM.and (trunc 16 e) (const? 16 14))
          { «nsw» := true, «nuw» := true })
        (const? 16 (-32768)) { «disjoint» := true })

theorem sub_mask1_lshr_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬1#8 ≥ ↑8 → 6#8 ≥ ↑8 ∨ 7#8 ≥ ↑8 ∨ True ∧ ((x <<< 6#8).sshiftRight' 7#8).saddOverflow 10#8 = true → False

theorem a_true_implies_b_true2_comm_thm.extracted_1._1 : ∀ (x : BitVec 1) (x_1 : BitVec 8),
  ofBool (10#8 <ᵤ x_1) = 1#1 → ofBool (20#8 <ᵤ x_1) = 1#1 → x &&& ofBool (20#8 <ᵤ x_1) = x

theorem e_2323 :
     - 5 * (e ^^^ ( ~~~d ||| (e ||| f))) - 11 * (f ^^^  ~~~(d ||| ( ~~~e &&& f))) - 11 * (f &&&  ~~~(d &&&  ~~~e)) + 5 * ((e &&&  ~~~f) |||  ~~~(d ||| ( ~~~e &&& f))) + 1 * (f ^^^ ( ~~~d ||| ( ~~~e &&& f))) - 3 * ( ~~~(d ^^^ e) ||| (d ^^^ f)) - 7 * (f ^^^ (d ||| ( ~~~e ||| f))) + 5 * ( ~~~d &&& (e ||| f)) + 2 * ((e &&&  ~~~f) |||  ~~~( ~~~d ||| ( ~~~e &&& f))) + 3 * (e ^^^ ( ~~~d ||| ( ~~~e ||| f))) - 7 * (e ^^^ (d &&& (e ^^^ f))) - 2 * (e ^^^  ~~~( ~~~d &&& (e ||| f))) + 5 * ( ~~~e |||  ~~~(d ^^^ f)) + 1 * ( ~~~e &&&  ~~~(d ^^^ f)) + 5 * (d ^^^ e) + 1 *  ~~~(d &&&  ~~~f) + 2 * (f ^^^  ~~~( ~~~d &&& ( ~~~e ||| f))) + 5 * ( ~~~(d ||| e) ||| (e ^^^ f)) + 3 * (e |||  ~~~(d ^^^ f)) + 2 * ((d ^^^ e) &&& (d ^^^ f)) - 2 * ( ~~~(d &&& e) &&&  ~~~(e ^^^ f)) + 11 * (f &&&  ~~~(d ^^^ e)) + 2 * (e ^^^ ( ~~~d &&& ( ~~~e ||| f))) + 7 * (f ^^^ (d |||  ~~~e)) - 5 * ( ~~~e ||| (d ^^^ f)) + 7 * (e ^^^ (d &&&  ~~~f)) - 1 *  ~~~(e |||  ~~~f) - 2 * (e ^^^  ~~~(d &&& ( ~~~e &&& f))) - 7 * ((d &&&  ~~~e) |||  ~~~(e ^^^ f)) - 3 * (f ^^^ ( ~~~d &&& ( ~~~e ||| f))) + 11 * (e ^^^ (d ||| ( ~~~e ||| f))) + 5 * (e ^^^  ~~~( ~~~d &&& ( ~~~e &&& f))) - 6 * (e ^^^  ~~~(d &&& (e ||| f))) - 5 * (f ^^^ (d &&& ( ~~~e ||| f))) - 1 *  ~~~(e &&& f) + 1 *  ~~~(d ^^^ (e ||| f)) + 4 * (f |||  ~~~(d ^^^ e)) + 11 * (f ^^^ (d &&& (e ||| f))) - 5 *  ~~~( ~~~d ||| ( ~~~e &&& f)) - 1 * (e ^^^ ( ~~~d ||| (e &&& f))) + 11 * (e ^^^ (d &&& ( ~~~e ||| f))) - 2 * (f &&& (d ^^^ e)) - 1 * ( ~~~(d &&&  ~~~e) &&&  ~~~(d ^^^ (e ^^^ f))) - 2 * ( ~~~(d ||| e) ||| (d ^^^ (e ^^^ f))) - 1 * (e ^^^  ~~~(d &&& ( ~~~e ||| f))) + 1 * f - 6 * ( ~~~d ||| ( ~~~e ||| f)) + 2 * ( ~~~(d ^^^ e) &&& (d ^^^ f)) - 11 * ((d &&&  ~~~e) ||| (e ^^^ f)) + 1 * ( ~~~f &&& (d ^^^ e)) + 7 * ((e &&&  ~~~f) ^^^ (d ||| (e ^^^ f))) + 2 * ((d |||  ~~~e) &&& (d ^^^ (e ^^^ f))) - 1 * (f &&&  ~~~(d &&& e)) + 1 * (e ||| (d &&&  ~~~f)) - 3 * ((d &&& e) ^^^ (d ^^^ ( ~~~e ||| f))) - 7 * (d &&& e) + 15 *  ~~~(d ||| (e ||| f)) - 26 *  ~~~(d ||| ( ~~~e ||| f)) - 7 *  ~~~( ~~~d ||| (e ||| f)) - 12 *  ~~~( ~~~d ||| ( ~~~e ||| f)) + 4 * ( ~~~d &&& ( ~~~e &&& f)) - 10 * ( ~~~d &&& (e &&& f)) - 1 * (d &&& ( ~~~e &&& f)) + 25 * (d &&& (e &&& f)) = 1 *  ~~~(d ^^^ (e &&& f))

theorem R.trimTensor_trimTensor (tensor : List Int) :
  trimTensor (trimTensor tensor) = trimTensor tensor

theorem srem_common_divisor_defined_cond_proof : srem_common_divisor_defined_cond_before ⊑ srem_common_divisor_defined_cond_after

theorem test_eq_0_and_15_add_3_thm (e : IntW 8) :
  icmp IntPred.eq (LLVM.and (add e (const? 8 3)) (const? 8 15)) (const? 8 0) ⊑
    icmp IntPred.eq (LLVM.and e (const? 8 15)) (const? 8 13)

theorem bv_AddSub_1043 :
    ∀ (e e_1 e_2 : LLVM.IntW w),
      LLVM.add (LLVM.add (LLVM.xor (LLVM.and e_1 e) e) (LLVM.const? w 1)) e_2 ⊑ LLVM.sub e_2 (LLVM.or e_1 (LLVM.not e))

theorem t_1_10_thm (e : IntW 8) :
  LLVM.and (select (icmp IntPred.ugt e (const? 8 1)) e (const? 8 1)) (const? 8 10) ⊑
    LLVM.and e (const? 8 10)

theorem positive_with_signbit_thm (e : IntW 32) :
  LLVM.and (icmp IntPred.sgt e (const? 32 (-1))) (icmp IntPred.ult (add e (const? 32 128)) (const? 32 256)) ⊑
    icmp IntPred.ult e (const? 32 128)

theorem substitute_constant_and_ne_ugt_swap_logical_thm.extracted_1._2 : ∀ (x x_1 : BitVec 8),
  ¬ofBool (x <ᵤ x_1) = 1#1 → 0#1 = ofBool (x <ᵤ x_1) &&& ofBool (x != 42#8)

theorem urem_common_divisor_defined_cond_thm.extracted_1._1 : ∀ (x x_1 : BitVec 5) (x_2 : BitVec 1),
  ¬(x_2 = 1#1 ∨ x_1 = 0) → x_2 = 1#1 → x_1 = 0 → False

theorem PR56294_thm (e : IntW 8) :
  icmp IntPred.ne (LLVM.and (zext 32 (icmp IntPred.eq e (const? 8 2))) (zext 32 (LLVM.and e (const? 8 1))))
      (const? 32 0) ⊑
    const? 1 0

theorem select_non_const_sides_proof : select_non_const_sides_before ⊑ select_non_const_sides_after

theorem src_is_notmask_x_xor_neg_x_proof : src_is_notmask_x_xor_neg_x_before ⊑ src_is_notmask_x_xor_neg_x_after

theorem p2_slt_65536_thm (e e_1 : IntW 32) :
  select (icmp IntPred.slt e_1 (const? 32 65536)) e (const? 32 65535) ⊑
    select (icmp IntPred.sgt e_1 (const? 32 65535)) (const? 32 65535) e

theorem addhshlhsdivhnegative1_thm (e : IntW 32) :
  add (shl (LLVM.sdiv e (const? 32 (-1))) (const? 32 1)) e ⊑ sub (const? 32 0) e

theorem demorgan_or_zext_thm (e e_1 : IntW 1) :
  LLVM.or (LLVM.xor (zext 32 e_1) (const? 32 1)) (LLVM.xor (zext 32 e) (const? 32 1)) ⊑
    zext 32 (LLVM.xor (LLVM.and e_1 e) (const? 1 1))

theorem lshrult_01_14_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬1#4 ≥ ↑4 → ofBool (x >>> 1#4 <ᵤ BitVec.ofInt 4 (-2)) = 1#1

theorem test_and2_thm (e e_1 : IntW 32) :
  LLVM.and (icmp IntPred.sgt e_1 (const? 32 (-1)))
      (icmp IntPred.sle e_1 (LLVM.and e (const? 32 2147483647))) ⊑
    icmp IntPred.ule e_1 (LLVM.and e (const? 32 2147483647))

theorem e_1661 :
    7 * ((a ||| b) &&& (b ^^^ c)) + 5 * ( ~~~(a |||  ~~~b) ||| (a ^^^ (b ^^^ c))) + 2 * (c ||| (a &&&  ~~~b)) + 4 * ((a &&&  ~~~b) |||  ~~~(a ^^^ (b ^^^ c))) - 3 * (b ^^^ ( ~~~a ||| (b &&& c))) - 7 *  ~~~(a &&& (b ||| c)) - 1 * ((a &&& b) ^^^  ~~~(a ^^^ ( ~~~b ||| c))) + 1 *  ~~~(a &&&  ~~~a) - 5 *  ~~~(a ^^^ b) + 3 * ( ~~~(a ^^^ b) &&& (a ^^^ c)) - 6 * (c ||| (a ^^^ b)) + 5 * ( ~~~(a &&& b) &&&  ~~~(a ^^^ (b ^^^ c))) - 5 * ((a &&& b) ||| (b ^^^ c)) - 11 * (c &&& (a |||  ~~~b)) - 2 * (b ^^^ (a ||| ( ~~~b &&& c))) + 11 * ((b &&& c) ^^^  ~~~(a &&& (b ^^^ c))) + 11 * (b |||  ~~~(a ||| c)) - 1 * (b ^^^  ~~~( ~~~a ||| ( ~~~b &&& c))) - 17 *  ~~~(a ||| (b ||| c)) - 6 *  ~~~( ~~~a ||| (b ||| c)) - 12 *  ~~~( ~~~a ||| ( ~~~b ||| c)) + 17 * ( ~~~a &&& ( ~~~b &&& c)) - 12 * ( ~~~a &&& (b &&& c)) + 8 * (a &&& (b &&& c)) =  - 6 * (a &&& ( ~~~b &&& c)) + 13 *  ~~~(a ||| ( ~~~b ||| c))

theorem e_1358 :
     - 7 * (z ||| t) + 1 * z + 5 *  ~~~(z &&& t) + 3 *  ~~~z - 1 *  ~~~(z &&&  ~~~t) - 2 * (z |||  ~~~t) - 1 * t - 2 *  ~~~(z ||| t) + 1 *  ~~~(z |||  ~~~t) + 13 * (z &&& t) = 3 *  ~~~(z ^^^ t) - 3 * (z &&&  ~~~t)

theorem eq_umax1_proof : eq_umax1_before ⊑ eq_umax1_after

theorem incr_congr (h : a ≈ʷ b) : a.incr ≈ʷ b.incr

theorem test6_thm (e : IntW 1023) :
  select (icmp IntPred.ne (LLVM.and e (const? 1023 64)) (const? 1023 0)) (const? 1023 64) (const? 1023 0) ⊑
    LLVM.and e (const? 1023 64)

theorem eq_commuted_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ¬(x == 0 || 8 != 1 && 43#8 == intMin 8 && x == -1) = true →
    ofBool (x_1 == 0#8) ||

theorem t0_thm (e e_1 e_2 e_3 : IntW 32) :
  LLVM.xor (select (icmp IntPred.eq e_3 e_2) (const? 1 1) (icmp IntPred.eq e_1 e)) (const? 1 1) ⊑
    select (icmp IntPred.ne e_3 e_2) (icmp IntPred.ne e_1 e) (const? 1 0)

theorem PR42691_8_logical_proof : PR42691_8_logical_before ⊑ PR42691_8_logical_after

theorem neg_test_icmp_non_equality_proof : neg_test_icmp_non_equality_before ⊑ neg_test_icmp_non_equality_after

theorem clear_to_set_decomposebittest_proof : clear_to_set_decomposebittest_before ⊑ clear_to_set_decomposebittest_after

theorem n2_thm (e : IntW 8) :
  LLVM.sdiv e (const? 8 (-128)) ⊑ zext 8 (icmp IntPred.eq e (const? 8 (-128)))

theorem ashrsgt_01_02_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬1#4 ≥ ↑4 → ofBool (2#4 <ₛ x.sshiftRight' 1#4) = ofBool (5#4 <ₛ x)

theorem PR52261_thm.extracted_1._2 : ∀ (x : BitVec 1),
  ¬x = 1#1 →
    ¬(True ∧ (0#32).ssubOverflow (BitVec.ofInt 32 (-2)) = true) →
      BitVec.ofInt 32 (-2) &&& 0#32 - BitVec.ofInt 32 (-2) = 2#32

theorem badimm4_thm.extracted_1._1 : ∀ (x : BitVec 16),
  ¬(7#8 ≥ ↑8 ∨ 8#16 ≥ ↑16) →
    ofBool ((truncate 8 x).sshiftRight' 7#8 == truncate 8 (x >>> 8#16)) = 1#1 →
      ofBool (127#16 <ₛ x) = 1#1 → truncate 8 x = 126#8

theorem lshrugt_03_09_exact_proof : lshrugt_03_09_exact_before ⊑ lshrugt_03_09_exact_after

theorem main7c_logical_thm.extracted_1._10 : ∀ (x x_1 x_2 : BitVec 32),
  ¬ofBool (x_2 == x_2 &&& x_1) = 1#1 → ofBool (x_2 != x_2 &&& x_1) = 1#1 → ¬0#1 = 1#1 → 1#32 = zeroExtend 32 1#1

theorem ashr_exact_poison_constant_fold_thm.extracted_1._1 : ∀ (x : BitVec 1),
  ¬x = 1#1 → ¬(True ∧ 42#8 >>> 3#8 <<< 3#8 ≠ 42#8 ∨ 3#8 ≥ ↑8) → (42#8).sshiftRight' 3#8 = 5#8

theorem slt_0_proof : slt_0_before ⊑ slt_0_after

theorem e_646 :
    3 * (x |||  ~~~y) + 3 *  ~~~(x &&&  ~~~y) - 2 * y - 11 *  ~~~x + 1 * (x ||| y) + 2 *  ~~~(x &&& y) - 2 * x - 4 *  ~~~(x |||  ~~~y) - 15 * (x &&&  ~~~y) - 3 * (x &&& y) =  - 11 * (x ^^^ y) - 3 *  ~~~(x ||| y)

theorem test5_proof : test5_before ⊑ test5_after

theorem ult_and_not_max_commute_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ofBool (x_1 != -1#8) &&& ofBool (x_1 <ᵤ x) = ofBool (x_1 <ᵤ x)

theorem main7d_logical_thm.extracted_1._10 : ∀ (x x_1 x_2 x_3 x_4 : BitVec 32),
  ofBool (x_4 &&& (x_3 &&& x_2) == x_3 &&& x_2) = 1#1 →
    ofBool (x_4 &&& (x_3 &&& x_2) != x_3 &&& x_2) = 1#1 →
      ¬ofBool (x_4 &&& (x_1 &&& x) == x_1 &&& x) = 1#1 → 1#32 = zeroExtend 32 1#1

theorem carry_sub (x : Bool → BitStream) : ∀ (n : ℕ), sub.carry x (n+1) =
    fun _ => (BitStream.subAux (x true) (x false) n).2

theorem e_1879 :
    5 * (c &&&  ~~~(a &&&  ~~~b)) + 1 * ((b &&&  ~~~c) |||  ~~~(a ||| ( ~~~b &&& c))) - 6 *  ~~~a - 6 * (c &&& (a |||  ~~~b)) + 11 * ((b &&& c) ||| ( ~~~a &&& (b ||| c))) - 11 * ( ~~~c &&& (a ^^^ b)) + 5 * (c |||  ~~~(a |||  ~~~b)) - 11 * (b |||  ~~~(a ||| c)) + 2 *  ~~~(a &&& c) + 2 * ( ~~~a ||| (b ^^^ c)) + 11 * (a &&& b) - 1 * (c ^^^ (a ||| (b ||| c))) - 6 * ( ~~~(a ^^^ b) &&&  ~~~(a ^^^ c)) - 6 * (b ^^^ ( ~~~a ||| ( ~~~b ||| c))) - 1 * (b &&& c) - 3 * ((a |||  ~~~b) &&&  ~~~(b ^^^ c)) - 3 * (b ^^^  ~~~( ~~~a ||| ( ~~~b &&& c))) + 7 * (b ^^^  ~~~( ~~~a &&& (b ||| c))) + 3 * (c ^^^  ~~~( ~~~a &&& (b ||| c))) - 7 *  ~~~(a &&& ( ~~~b ||| c)) - 2 * ( ~~~(a &&&  ~~~b) &&& (b ^^^ c)) + 1 * (c ||| (a &&& b)) - 5 * (b ^^^ (a &&&  ~~~c)) + 1 * (a |||  ~~~c) + 1 * ((a &&& b) |||  ~~~(a ^^^ (b ^^^ c))) - 6 * (b ^^^ (a ||| (b ^^^ c))) + 1 * ( ~~~a ||| (b &&& c)) - 1 * ( ~~~(a ^^^ b) |||  ~~~(a ^^^ c)) + 5 * (b ^^^  ~~~(a &&&  ~~~c)) + 11 * (a ^^^ c) + 1 * ( ~~~c |||  ~~~(a ^^^ b)) - 1 * (b ^^^  ~~~(a &&& ( ~~~b &&& c))) - 3 *  ~~~(a ^^^ c) - 1 * ( ~~~(a ^^^ b) ||| (a ^^^ c)) - 2 * (b &&& (a ^^^ c)) + 1 * ((a &&& c) ^^^  ~~~(a ^^^ ( ~~~b &&& c))) + 1 * (c ^^^ (a ||| b)) - 5 *  ~~~(a ^^^ (b ||| c)) + 4 * (a &&&  ~~~b) + 2 * (a &&&  ~~~c) + 25 *  ~~~(a ||| (b ||| c)) + 5 *  ~~~( ~~~a ||| (b ||| c)) - 6 *  ~~~( ~~~a ||| ( ~~~b ||| c)) - 12 * ( ~~~a &&& ( ~~~b &&& c)) - 9 * ( ~~~a &&& (b &&& c)) + 1 * (a &&& ( ~~~b &&& c)) + 4 * (a &&& (b &&& c)) =  - 17 *  ~~~(a ||| ( ~~~b ||| c))

theorem eq_10_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬(8#32 ≥ ↑32 ∨ 8#32 ≥ ↑32) →
    ofBool (truncate 8 x_1 == truncate 8 x) &&& ofBool (truncate 8 (x_1 >>> 8#32) == truncate 8 (x >>> 8#32)) =
      ofBool (truncate 16 x_1 == truncate 16 x)

theorem icmp_eq_sext_ne_otherwise_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (signExtend 32 (ofBool (x != 2#32)) == x) = ofBool (x == -1#32)

theorem negative_not_power_of_two_proof : negative_not_power_of_two_before ⊑ negative_not_power_of_two_after

theorem icmp_shl_uge_2_thm (e : IntW 5) :
  icmp IntPred.uge (add (const? 5 10) e) (shl (add (const? 5 10) e) (const? 5 1)) ⊑
    icmp IntPred.slt (add e (const? 5 10)) (const? 5 1)

@[simp]
lemma neg_accepts (M : NFA' n) :
    M.neg.accepts = M.acceptsᶜ

theorem dec_mask_commute_neg_i32_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬((x == 0 || 32 != 1 && 42#32 == intMin 32 && x == -1) = true ∨
        (x == 0 || 32 != 1 && 42#32 == intMin 32 && x == -1) = true) →
    (x == 0 || 32 != 1 && 42#32 == intMin 32 && x == -1) = true ∨
        True ∧ ((42#32).sdiv x).saddOverflow (-1#32) = true ∨
          (x == 0 || 32 != 1 && 42#32 == intMin 32 && x == -1) = true →
      False

theorem in_constant_6_vary_invmask_thm (e e_1 : IntW 4) :
  LLVM.xor (LLVM.and (LLVM.xor e_1 (const? 4 6)) (LLVM.xor e (const? 4 (-1)))) e_1 ⊑
    LLVM.xor (LLVM.and (LLVM.xor e_1 (const? 4 6)) e) (const? 4 6)

theorem e_1416 :
    7 *  ~~~(z &&&  ~~~z) - 5 *  ~~~z - 5 * z - 2 * (z ||| t) + 1 *  ~~~(z &&&  ~~~t) + 2 * (z ^^^ t) - 3 *  ~~~(z ||| t) - 4 *  ~~~(z |||  ~~~t) - 2 * (z &&&  ~~~t) - 2 * (z &&& t) =  - 1 * t

theorem e_581 :
     - 3 * (x ||| y) - 6 * y + 11 *  ~~~(x &&&  ~~~x) - 1 * (x ^^^ y) + 4 *  ~~~x - 1 *  ~~~(x &&& y) + 1 * (x |||  ~~~y) - 4 *  ~~~(x |||  ~~~y) - 3 * (x &&& y) = 8 *  ~~~(x ||| y) + 7 *  ~~~y

theorem t0_thm.extracted_1._13 : ∀ (x x_1 : BitVec 8) (x_2 : BitVec 1),
  ¬x_2 ^^^ 1#1 = 1#1 → x_2 = 1#1 → 0#1 = 1#1 → x_1 = x

theorem e_1431 :
    2 *  ~~~(z ^^^ t) + 4 * z - 3 *  ~~~(z &&& t) + 4 *  ~~~z + 2 * (z ^^^ t) - 6 *  ~~~t + 6 *  ~~~(z ||| t) - 3 *  ~~~(z |||  ~~~t) + 6 * (z &&&  ~~~t) - 3 * (z &&& t) = 3 * (z |||  ~~~t)

theorem main4d_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x &&& 7#32 != 7#32) ||

theorem test_shl__nuw_is_safe_thm (e : IntW 64) (e_1 : IntW 32) :
  select (icmp IntPred.eq (LLVM.and e_1 (const? 32 1073741822)) (const? 32 0)) e
      (ashr e (zext 64 (shl (LLVM.and e_1 (const? 32 1073741822)) (const? 32 2)))) ⊑
    ashr e (zext 64 (LLVM.and (shl e_1 (const? 32 2)) (const? 32 (-8))) { «nneg» := true })

theorem n9_wrong_x1_proof : n9_wrong_x1_before ⊑ n9_wrong_x1_after

theorem test14_thm.extracted_1._2 : ∀ (x : BitVec 32) (x_1 : BitVec 64),
  ¬(x ≥ ↑32 ∨ zeroExtend 64 (1#32 <<< x) = 0) →
    ¬(True ∧ 1#32 <<< x >>> x ≠ 1#32 ∨ x ≥ ↑32 ∨ True ∧ (zeroExtend 64 (1#32 <<< x)).saddOverflow (-1#64) = true) →
      x_1 % zeroExtend 64 (1#32 <<< x) = x_1 &&& zeroExtend 64 (1#32 <<< x) + -1#64

theorem eq_smax3_proof : eq_smax3_before ⊑ eq_smax3_after
</all_available_lemmas>

<local_ctx>
import LeanMLIR.Framework

import Mathlib.Tactic.Linarith

import Mathlib.Tactic.DepRewrite

open Ctxt (Var Valuation Hom)

namespace DCE

structure DeleteRange (Γ : Ctxt Ty) where
   
  start : Fin (Γ.length + 1)
   
  num : Fin (Γ.length + 1 - start.val)

open DCE (DeleteRange)

namespace DeleteRange

def appendInl {Γ : Ctxt Ty} {ts : List Ty}
    (r : DeleteRange Γ) : DeleteRange (⟨ts⟩ ++ Γ) where
  start := ⟨r.start + ts.length, by admit /- proof elided -/
  ⟩
  num := ⟨r.num, by admit /- proof elided -/
  ⟩

section Lemmas

end Lemmas

end DeleteRange

end DCE

open DCE (DeleteRange)

def Ctxt.delete (Γ : Ctxt Ty) (vs : DeleteRange Γ) : Ctxt Ty :=
  Ctxt.ofList <| List.ofFn (n := Γ.length - vs.num.val) fun i =>
    have := vs.start.prop
    if hi : i.val < vs.start then
      Γ[i.val]
    else
      Γ[i.val + vs.num]
</local_ctx>

<target_theorem>
@[simp] theorem Ctxt.delete_append_appendInl {Γ : Ctxt Ty} {us : List Ty}
    {r : DeleteRange Γ} :
    (⟨us⟩ ++ Γ).delete r.appendInl = ⟨us⟩ ++ (Γ.delete r) :=
</target_theorem>

