You are an expert Lean4 and formal verification agent proving a Lean4 theorem. Your output **must** strictly adhere to the specified format.

### Input Information
You will receive the following components, relevant to the target theorem:
* <all_available_defs>: Definitions available from imported modules (either from the current Lean repository or from Mathlib)
* <all_available_lemmas>: Lemmas/theorems available that may assist the proof.
* <local_ctx>...</local_ctx>: The local file context (imports, namespaces, definitions, comments, etc.) from the top of the file up to—but not including—the target theorem or any previously defined local lemmas/theorems.
* <target_theorem>...</target_theorem>: The target theorem statement, ending with `:=`.

**Notes**
1. Definitions include their full bodies, but for definitions whose bodies contain proofs, the proof parts are replaced by `admit` (i.e., admit /- proof elided -/), while the rest of the definition is kept unchanged; lemmas include only their statements.
2. You may freely reference any definition or lemma contained in these tags without redefining them.
3. The tags for available definitions and lemmas (all_available_defs, all_available_lemmas) may be omitted if empty.

### Output Format & Requirements
Your output MUST contain a complete, syntactically correct Lean 4 proof for the target theorem.

**Strict Output Structure:**
<reasoning> 
...
</reasoning> 

<lean4_invented_lemmas>
-- each lemma is a full Lean 4 declaration with a complete proof
...
</lean4_invented_lemmas>

<lean4_proof>
-- Lean 4 proof body of the target theorem
...
</lean4_proof>

**Requirements:**
1. <reasoning> and <lean4_invented_lemmas> are OPTIONAL. Include them only if they aid proof construction.
2. <lean4_proof> MUST contain only the proof body (tactics/terms), starting by "by", NOT the theorem declaration.
3. <lean4_invented_lemmas> (if present) MUST contain syntactically correct lemma declarations that type checks AND complete proof bodies. Defining a lemma using `axiom` is NOT allowed.
4. <reasoning> contains high-level proof planning.
5. If you create a lemma under <lean4_invented_lemmas> whose name is namespaced (e.g., X.Y.Z), you MUST always refer to it using its fully qualified name. Do NOT rely on shortened names. For example, write rw [X.Y.Z], not rw [Z] for invented lemmas.
6. All Lean 4 code MUST be syntactically correct. No `sorry`, `admit`, or non-Lean text. Comments allowed using `--` or `/- ... -/`.
7. Follow the tags and structure EXACTLY. No extra text before, between, or after the sections.
8. Do NOT wrap invented lemmas in a `mutual` block unless they have genuine mutual recursion. Declare each lemma independently.

### Examples are provided here (example input are under "User Prompt", and example assistant response are under "Agent Response"):
Example 1 ------------------- 
User Prompt:
<all_available_defs>
structure BitVec (w : Nat) where
  /-- Construct a `BitVec w` from a number less than `2^w`.
  O(1), because we use `Fin` as the internal representation of a bitvector. -/
  ofFin ::

  /-- Interpret a bitvector as a number less than `2^w`.
  O(1), because we use `Fin` as the internal representation of a bitvector. -/
  toFin : Fin (hPow 2 w)
</all_available_defs>

<all_available_lemmas>
theorem List.getElem_append_left{α : Type u_1} {l₁ l₂ : List α} {i : Nat} (hn : i < l₁.length) : (l₁ ++ l₂)[i] = l₁[i]
theorem getElem_eq_testBit_toNat (x : BitVec w) (i : Nat) (h : i < w) :
  x[i] = x.toNat.testBit i := rfl
@[simp, grind =] theorem toNat_cons (b : Bool) (x : BitVec w) :
    (cons b x).toNat = (b.toNat <<< w) ||| x.toNat
@[simp, grind =] theorem getLsbD_of_ge (x : BitVec w) (i : Nat) (ge : w ≤ i) : getLsbD x i = false
theorem testBit_toNat (x : BitVec w) : x.toNat.testBit i = x.getLsbD i
</all_available_lemmas>

<local_ctx>
import Mathlib.Computability.NFA
import Mathlib.Data.FinEnum
import Mathlib.Data.Rel
import Mathlib.Data.Vector.Basic
import Blase.AutoStructs.ForLean

open Set
open Mathlib
open SetRel

-- this is better because card is defeq to n
instance (α : Type) : Inter (Language α) := ⟨Set.inter⟩
instance (α : Type) : Union (Language α) := ⟨Set.union⟩

/--
The set of `n`-tuples of bit vectors of an arbitrary width.
-/
structure BitVecs (n : Nat) where
  w : Nat
  bvs : List.Vector (BitVec w) n

def BitVecs.cast (bvs : BitVecs n) (h : n = n') : BitVecs n' :=
  { w := bvs.w, bvs := h ▸ bvs.bvs }

abbrev BitVecs.empty : BitVecs n := ⟨0, List.Vector.replicate n .nil⟩
abbrev BitVecs.singleton {w : Nat} (bv : BitVec w) : BitVecs 1 := ⟨w, bv ::ᵥ .nil⟩
abbrev BitVecs.pair {w : Nat} (bv1 bv2 : BitVec w) : BitVecs 2 := ⟨w, bv1 ::ᵥ bv2 ::ᵥ .nil⟩

/--
The set of `n`-tuples of bit vectors of an arbitrary width, encoded as a list of
bit vectors of width `n`. The width of the encoded bit vectors is the length of
the list.
-/
abbrev BitVecs' (n : Nat) := List (BitVec n)

@[simps]
def dec (bvs' : BitVecs' n) : BitVecs n where
  w := bvs'.length
  bvs := List.Vector.ofFn fun k => BitVec.ofFn fun i => bvs'[i].getLsbD k

@[simp]
</local_ctx>

<target_theorem>
lemma dec_snoc n (bvs' : BitVecs' n) (a : BitVec n) :
  dec (bvs' ++ [a]) =
    { w := bvs'.length + 1
      bvs := List.Vector.ofFn fun k =>
        BitVec.cons (a.getLsbD k) ((dec bvs').bvs.get k) } :=
</target_theorem>

Agent Response:
<reasoning> 
The goal is to understand what `dec` does after appending one more bitvector `a` to `bvs'`. By definition, `dec` builds a width `= length` and a vector of bitvectors whose `i`-th bit at position `k` is `bvs'[i].getLsbD k`. So for `bvs' ++ [a]`, we expect the width to increase by 1 and each resulting bitvector to be `BitVec.cons` of the new bit coming from `a`.

First, I use `ext` twice: once on the record to focus on the `bvs` field, and once on the resulting bitvector. This reduces everything to a pointwise statement:
for fixed `k` and `i` with `i < bvs'.length + 1`,
the bit `(bvs' ++ [a])[i].getLsbD k` should match the bit at index `i` of `BitVec.cons (a.getLsbD k) ((dec bvs').bvs.get k)`.

At this point I need a clean description of indexing into `BitVec.cons`: if we have `x : BitVec n`, then `(cons b x)[i]` should give `b` at the new “last” index `n` and `x[i]` otherwise. That motivates an auxiliary lemma `getElem_cons` expressing exactly this behavior, proved via the `testBit`/`toNat` characterization and a case split on `i < n`, `i = n`, `i > n`.

Using `getElem_cons`, the RHS becomes an `if` on whether `i = bvs'.length`. So I split into cases:
- If `i = bvs'.length`, then `(bvs' ++ [a])[i]` is the appended `a`, so both sides reduce to `a.getLsbD k`.
- If `i ≠ bvs'.length`, the bound `i < bvs'.length + 1` forces `i < bvs'.length`. Then `(bvs' ++ [a])[i] = bvs'[i]` by `List.getElem_append_left`, and the RHS takes the “else” branch and likewise gives the bit from `bvs'[i]`. In both subcases, `simp` (plus the definition of `dec`) finishes.

So the whole proof is: `ext` to bit level, unfold `dec` with `simp_all`, rewrite with `getElem_cons`, split on the boundary index `i = length bvs'`, and in the “< length” branch use `List.getElem_append_left` and bounds to line up both sides.
</reasoning> 

<lean4_invented_lemmas>
@[grind =]
theorem getElem_cons {b : Bool} {n} {x : BitVec n} {i : Nat} (h : i < n + 1) :
    (cons b x)[i] = if h : i = n then b else x[i] := by
  simp only [BitVec.getElem_eq_testBit_toNat, BitVec.toNat_cons, Nat.testBit_or]
  rw [Nat.testBit_shiftLeft]
  rcases Nat.lt_trichotomy i n with i_lt_n | i_eq_n | n_lt_i
  · have p1 : ¬(n ≤ i) := by omega
    have p2 : i ≠ n := by omega
    simp [p1, p2]
  · simp only [i_eq_n, ge_iff_le, Nat.le_refl, decide_true, Nat.sub_self, Nat.testBit_zero,
    Bool.true_and, BitVec.testBit_toNat, BitVec.getLsbD_of_ge, Bool.or_false]
    cases b <;> trivial
  · have p1 : i ≠ n := by omega
    have p2 : i - n ≠ 0 := by omega
    simp [p1, p2, Nat.testBit_bool_toNat]
</lean4_invented_lemmas>

<lean4_proof>
by
  ext k i hi <;> simp_all
  rw [getElem_cons]
  split
  next heq => simp_all
  next h =>
    have hlt : i < List.length bvs' := by simp at hi; omega
    rw [List.getElem_append_left hlt]
    simp
</lean4_proof>

### Your task:
<all_available_defs>
Nat in Init.Prelude
BitVec in Init.Prelude
Set in Mathlib.Data.Set.Defs
Finset in Mathlib.Data.Finset.Defs
Finset.range in Mathlib.Data.Finset.Range
BEq in Init.Prelude
DecidableEq in Init.Prelude
FinEnum in Mathlib.Data.FinEnum
Hashable in Init.Prelude
Repr in Init.Data.Repr
Std.HashMap in Std.Data.HashMap.Basic
Std.HashSet in Std.Data.HashSet.Basic
LawfulBEq in Init.Core

abbrev State := Nat

def RawCNFA.states (m : RawCNFA A) : Finset State := Finset.range m.stateMax

instance RawCNFA.statesFinset (m : RawCNFA A) : Fintype m.states := (Finset.range m.stateMax).fintypeCoeSort

structure CNFA (n : Nat) where
  m : RawCNFA (BitVec n)
  wf : m.WF

def Std.HashSet.toSet [BEq α] [Hashable α] (m : HashSet α) : Set α := { x | x ∈ m }

BitVec.instHShiftLeft in Init.Data.BitVec.Basic

def cmp_x_and_negp2_with_eq_before := [llvm|
{
^0(%arg4 : i8):
  %0 = llvm.mlir.constant(-2 : i8) : i8
  %1 = llvm.mlir.constant(-128 : i8) : i8
  %2 = llvm.and %arg4, %0 : i8
  %3 = llvm.icmp "eq" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def alive_InstCombineShift__279_src :=
[sllvm| {
^bb0(%X : i64, %C : i64):
  %v1 = llvm.lshr %X, %C : i64
  %v2 = llvm.shl %v1, %C : i64
  llvm.return %v2 : i64
}]

def trunc_equality_nuw_after := [llvm|
{
^0(%arg44 : i16, %arg45 : i16):
  %0 = llvm.icmp "eq" %arg44, %arg45 : i16
  "llvm.return"(%0) : (i1) -> ()
}
]

IO.monoNanosNow in Init.System.IO

def p0_before := [llvm|
{
^0(%arg16 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.and %arg16, %0 : i8
  %2 = llvm.icmp "eq" %1, %arg16 : i8
  "llvm.return"(%2) : (i1) -> ()
}
]

def masked_icmps_mask_notallzeros_bmask_mixed_negated_4_after := [llvm|
{
^0(%arg62 : i32):
  %0 = llvm.mlir.constant(15 : i32) : i32
  %1 = llvm.mlir.constant(8 : i32) : i32
  %2 = llvm.and %arg62, %0 : i32
  %3 = llvm.icmp "ne" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def slt_or_not_max_logical_before := [llvm|
{
^0(%arg60 : i8, %arg61 : i8):
  %0 = llvm.mlir.constant(127 : i8) : i8
  %1 = llvm.mlir.constant(true) : i1
  %2 = llvm.icmp "slt" %arg60, %arg61 : i8
  %3 = llvm.icmp "ne" %arg60, %0 : i8
  %4 = "llvm.select"(%2, %1, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

@[reducible]
instance : DialectDenote ExOp ExTy where
  denote
    | .add, .cons (a : Nat) (.cons b .nil), _ => a + b
    | .runK (k : Nat), (.cons (v : Nat) .nil), (.cons rgn _nil) =>
      k.iterate (fun val => rgn (fun _ty _var => val)) v

def lshr_pow2_ugt_before := [llvm|
{
^0(%arg72 : i8):
  %0 = llvm.mlir.constant(2 : i8) : i8
  %1 = llvm.mlir.constant(1 : i8) : i8
  %2 = llvm.lshr %0, %arg72 : i8
  %3 = llvm.icmp "ugt" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def test6_before := [llvm|
{
^0(%arg1 : i7):
  %0 = llvm.mlir.constant(23 : i7) : i7
  %1 = llvm.xor %arg1, %0 : i7
  %2 = llvm.xor %1, %0 : i7
  "llvm.return"(%2) : (i7) -> ()
}
]

def llvm_udiv_lower_riscv_flag_32: LLVMPeepholeRewriteRefine 32 [Ty.llvm (.bitvec 32), Ty.llvm (.bitvec 32)] :=
  {lhs := udiv_llvm_exact_32, rhs := udiv_riscv_32, correct := sorry }

def Term.denote {w : Nat} (t : Term) (xs : Env w) : Int :=
  t.c * t.f.denote xs

def xor_or_xor_common_op_commute5_after := [llvm|
{
^0(%arg68 : i32, %arg69 : i32, %arg70 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg68, %0 : i32
  %2 = llvm.and %arg69, %1 : i32
  %3 = llvm.xor %2, %arg70 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

elab "#generalize" expr:term : command =>

def State.cseRegionArgList
  {Γstart Γ : Ctxt d.Ty}
  {lets : Lets d Γstart .pure Γ}
  (_ : State d lets)
  {ts : RegionSignature d.Ty}
  (rs : HVector ((fun t => Com d t.1 .impure t.2)) <| ts) :
  {rs' : HVector ((fun t => Com d t.1 .impure t.2)) <| ts //
    HVector.denote rs = HVector.denote rs' } :=
  let _ := HVector.map (fun _Γα com => Com.denote com) rs
  match ts, rs with
  | _, .nil => ⟨.nil, by admit /- proof elided -/
    ⟩
  | ⟨Γ, t⟩::ts, .cons region rs =>
    
    
    
    
    ⟨.cons region rs, by admit /- proof elided -/
    ⟩

def constLLVM0 : Com LLVMPlusRiscV ⟨[]⟩ .pure (.llvm (.bitvec 64)) := [LV| {
  ^entry ():
    %1 = llvm.mlir.constant (0) : i64
    llvm.return %1 : i64
  }]

def udiv_exact_eq_1_before := [llvm|
{
^0(%arg10 : i8, %arg11 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.udiv exact %arg10, %arg11 : i8
  %2 = llvm.icmp "ne" %1, %0 : i8
  "llvm.return"(%2) : (i1) -> ()
}
]

def sge_smin1_before := [llvm|
{
^0(%arg79 : i32, %arg80 : i32):
  %0 = llvm.icmp "slt" %arg79, %arg80 : i32
  %1 = "llvm.select"(%0, %arg79, %arg80) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %2 = llvm.icmp "sge" %1, %arg79 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def masked_or_allones_logical_before := [llvm|
{
^0(%arg126 : i32):
  %0 = llvm.mlir.constant(7 : i32) : i32
  %1 = llvm.mlir.constant(39 : i32) : i32
  %2 = llvm.mlir.constant(true) : i1
  %3 = llvm.and %arg126, %0 : i32
  %4 = llvm.icmp "eq" %3, %0 : i32
  %5 = llvm.and %arg126, %1 : i32
  %6 = llvm.icmp "eq" %5, %1 : i32
  %7 = "llvm.select"(%4, %2, %6) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%7) : (i1) -> ()
}
]

def mul8_low_before := [llvm|
{
^0(%arg26 : i8, %arg27 : i8):
  %0 = llvm.mlir.constant(15 : i8) : i8
  %1 = llvm.mlir.constant(4 : i8) : i8
  %2 = llvm.and %arg26, %0 : i8
  %3 = llvm.lshr %arg26, %1 : i8
  %4 = llvm.and %arg27, %0 : i8
  %5 = llvm.lshr %arg27, %1 : i8
  %6 = llvm.mul %5, %2 : i8
  %7 = llvm.mul %4, %3 : i8
  %8 = llvm.mul %4, %2 : i8
  %9 = llvm.add %6, %7 : i8
  %10 = llvm.shl %9, %1 : i8
  %11 = llvm.add %10, %8 : i8
  "llvm.return"(%11) : (i8) -> ()
}
]

def PR42691_7_logical_before := [llvm|
{
^0(%arg330 : i32):
  %0 = llvm.mlir.constant(-2147483647 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(true) : i1
  %3 = llvm.icmp "uge" %arg330, %0 : i32
  %4 = llvm.icmp "eq" %arg330, %1 : i32
  %5 = "llvm.select"(%3, %2, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%5) : (i1) -> ()
}
]

def size : GenBVExpr w → Nat
  | .var idx => 1
  | .const val => 1
  | .extract _ len expr => 1 + expr.size
  | .bin lhs _ rhs => 1 + lhs.size + rhs.size
  | .un _ operand => 1 + operand.size
  | .append lhs rhs _ => 1 + lhs.size + rhs.size
  | .replicate _ expr _ => 1 + expr.size
  | .shiftLeft lhs rhs => 1 + lhs.size + rhs.size
  | .shiftRight lhs rhs => 1 + lhs.size + rhs.size
  | .arithShiftRight lhs rhs => 1 + lhs.size + rhs.size
  | .signExtend v expr => 1 + expr.size
  | .zeroExtend v expr => 1 + expr.size
  | .truncate v expr => 1 + expr.size

def bool_eq0_after := [llvm|
{
^0(%arg33 : i64):
  %0 = llvm.mlir.constant(1) : i64
  %1 = llvm.icmp "sgt" %arg33, %0 : i64
  "llvm.return"(%1) : (i1) -> ()
}
]

def eval_zext_multi_use_in_one_inst_after := [llvm|
{
^0(%arg7 : i32):
  %0 = llvm.mlir.constant(5 : i16) : i16
  %1 = llvm.trunc %arg7 : i32 to i16
  %2 = llvm.and %1, %0 : i16
  %3 = llvm.mul %2, %2 overflow<nsw,nuw> : i16
  %4 = llvm.zext nneg %3 : i16 to i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def slt_swap_and_not_max_commute_before := [llvm|
{
^0(%arg114 : i8, %arg115 : i8):
  %0 = llvm.mlir.constant(127 : i8) : i8
  %1 = llvm.icmp "sgt" %arg115, %arg114 : i8
  %2 = llvm.icmp "ne" %arg114, %0 : i8
  %3 = llvm.and %2, %1 : i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def test9_before := [llvm|
{
^0(%arg42 : i17):
  %0 = llvm.mlir.constant(16 : i17) : i17
  %1 = llvm.shl %arg42, %0 : i17
  %2 = llvm.lshr %1, %0 : i17
  "llvm.return"(%2) : (i17) -> ()
}
]

def ashr_pow2_ult_before := [llvm|
{
^0(%arg59 : i8):
  %0 = llvm.mlir.constant(-128 : i8) : i8
  %1 = llvm.mlir.constant(-96 : i8) : i8
  %2 = llvm.ashr %0, %arg59 : i8
  %3 = llvm.icmp "ult" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def icmp_eq_zext_eq_zero_after := [llvm|
{
^0(%arg40 : i32):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def test_xor_eq_after := [llvm|
{
^0(%arg61 : i8, %arg62 : i8, %arg63 : i8):
  %0 = llvm.xor %arg62, %arg61 : i8
  %1 = llvm.icmp "eq" %arg63, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def or_ugt_after := [llvm|
{
^0(%arg58 : i8, %arg59 : i8):
  %0 = llvm.or %arg58, %arg59 : i8
  %1 = llvm.icmp "ne" %0, %arg58 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def and_slt_to_mask_before := [llvm|
{
^0(%arg5 : i8):
  %0 = llvm.mlir.constant(-124 : i8) : i8
  %1 = llvm.mlir.constant(2 : i8) : i8
  %2 = llvm.mlir.constant(0 : i8) : i8
  %3 = llvm.icmp "slt" %arg5, %0 : i8
  %4 = llvm.and %arg5, %1 : i8
  %5 = llvm.icmp "eq" %4, %2 : i8
  %6 = llvm.and %3, %5 : i1
  "llvm.return"(%6) : (i1) -> ()
}
]

def test10_before := [llvm|
{
^0(%arg107 : i32, %arg108 : i32):
  %0 = llvm.xor %arg107, %arg108 : i32
  %1 = llvm.and %arg107, %arg108 : i32
  %2 = llvm.xor %0, %1 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

private def attrVal0Str : AttrVal := [mlir_attr_val| "foo"]

Nat.reduceAdd in Lean.Meta.Tactic.Simp.BuiltinSimprocs.Nat

def Expr.args {Γ ts} (e : Expr d Γ eff ts) :
    HVector (Var Γ) (DialectSignature.sig e.op) :=
  Expr.casesOn e (fun _ _ _ args _ => args)

abbrev MLIRType.i32: MLIRType φ := MLIRType.int .Signless 32

def icmp_eq_sext_eq_otherwise_after := [llvm|
{
^0(%arg15 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.icmp "eq" %arg15, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

instance {n} : ShiftLeft (BitVec n) := ⟨fun x y => x <<< y.toNat⟩

@[simp_llvm]
def urem? {w : Nat} (x y : BitVec w) : IntW w :=
  if y = 0 then
    .poison
  else
    .value <| x % y

def shl_trunc_bigger_ashr_before := [llvm|
{
^0(%arg42 : i32):
  %0 = llvm.mlir.constant(12 : i32) : i32
  %1 = llvm.mlir.constant(3 : i24) : i24
  %2 = llvm.ashr %arg42, %0 : i32
  %3 = llvm.trunc %2 : i32 to i24
  %4 = llvm.shl %3, %1 : i24
  "llvm.return"(%4) : (i24) -> ()
}
]

def lshr_exact_ne_0_after := [llvm|
{
^0(%arg121 : i32, %arg122 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.icmp "ne" %arg121, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def ashrslt_03_09_before := [llvm|
{
^0(%arg228 : i4):
  %0 = llvm.mlir.constant(3 : i4) : i4
  %1 = llvm.mlir.constant(-7 : i4) : i4
  %2 = llvm.ashr %arg228, %0 : i4
  %3 = llvm.icmp "slt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def withArity : Σ n, ParsedArgs Γ (some n) :=
  ⟨args.toList.length, ⟨args.toList, rfl⟩⟩

def xor_logic_and_or2_after := [llvm|
{
^0(%arg15 : i1, %arg16 : i1, %arg17 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.xor %arg16, %0 : i1
  %2 = "llvm.select"(%arg15, %1, %arg17) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%2) : (i1) -> ()
}
]

def match_selects : List (Σ Γ, LLVMPeepholeRewriteRefine 64  Γ) :=
  [⟨_, select_1_0⟩,
  ⟨_, select_neg1_0⟩,
  ⟨_, select_0_1⟩,
  ⟨_, select_0_neg1⟩,
  ⟨_, select_cond_f⟩,
  ⟨_, select_1_f⟩,
  ⟨_, select_t_cond⟩,
  ⟨_, select_t_0⟩,
  ⟨_, select_t_1⟩,
  ⟨_, select_0_f⟩]

def test36_after := [llvm|
{
^0(%arg244 : i32):
  %0 = llvm.mlir.constant(7 : i32) : i32
  %1 = llvm.mlir.constant(240 : i32) : i32
  %2 = llvm.add %arg244, %0 : i32
  %3 = llvm.and %2, %1 : i32
  %4 = llvm.zext nneg %3 : i32 to i64
  "llvm.return"(%4) : (i64) -> ()
}
]

def src_is_mask_zext_fail_not_mask_before := [llvm|
{
^0(%arg129 : i16, %arg130 : i8):
  %0 = llvm.mlir.constant(123 : i16) : i16
  %1 = llvm.mlir.constant(-2 : i8) : i8
  %2 = llvm.xor %arg129, %0 : i16
  %3 = llvm.lshr %1, %arg130 : i8
  %4 = llvm.zext %3 : i8 to i16
  %5 = llvm.and %2, %4 : i16
  %6 = llvm.icmp "eq" %5, %2 : i16
  "llvm.return"(%6) : (i1) -> ()
}
]

BitVec.sdiv in Init.Data.BitVec.Basic

def test7_after := [llvm|
{
^0(%arg7 : i47):
  %0 = llvm.mlir.constant(39 : i47) : i47
  %1 = llvm.lshr %arg7, %0 : i47
  "llvm.return"(%1) : (i47) -> ()
}
]

def test_after := [llvm|
{
^0(%arg0 : i8, %arg1 : i8):
  %0 = llvm.icmp "ugt" %arg0, %arg1 : i8
  "llvm.return"(%0) : (i1) -> ()
}
]

def positive_biggershl_shlnuw_ashrexact_after := [llvm|
{
^0(%arg29 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.shl %arg29, %0 overflow<nuw> : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def bitwise_and_bitwise_and_icmps_after := [llvm|
{
^0(%arg244 : i8, %arg245 : i8, %arg246 : i8):
  %0 = llvm.mlir.constant(42 : i8) : i8
  %1 = llvm.mlir.constant(1 : i8) : i8
  %2 = llvm.icmp "eq" %arg245, %0 : i8
  %3 = llvm.shl %1, %arg246 overflow<nuw> : i8
  %4 = llvm.or %3, %1 : i8
  %5 = llvm.and %arg244, %4 : i8
  %6 = llvm.icmp "eq" %5, %4 : i8
  %7 = llvm.and %2, %6 : i1
  "llvm.return"(%7) : (i1) -> ()
}
]

def and_logic_and_logic_or_5_after := [llvm|
{
^0(%arg126 : i1, %arg127 : i1, %arg128 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.mlir.constant(false) : i1
  %2 = "llvm.select"(%arg128, %0, %arg127) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %3 = "llvm.select"(%arg126, %2, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def sle_swap_or_min_logical_before := [llvm|
{
^0(%arg148 : i8, %arg149 : i8):
  %0 = llvm.mlir.constant(-128 : i8) : i8
  %1 = llvm.mlir.constant(true) : i1
  %2 = llvm.icmp "sge" %arg149, %arg148 : i8
  %3 = llvm.icmp "eq" %arg148, %0 : i8
  %4 = "llvm.select"(%2, %1, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

Lattice in Mathlib.Order.Lattice

def getSimpData (simpsetName : Name) : MetaM (SimpTheorems × Simprocs) := do
  let some ext ← (getSimpExtension? simpsetName)
    | throwError m!"'{simpsetName}' simp attribute not found!"
  let theorems ← ext.getTheorems
  let some ext ← (Simp.getSimprocExtension? simpsetName)
    | throwError m!"'{simpsetName}' simp attribute not found!"
  let simprocs ← ext.getSimprocs
  return (theorems, simprocs)

def worklistRun'_spec :
    (worklistRun' A S final inits hinits f |>.Sim $ nfa inits final f) :=

def test12commuted_before := [llvm|
{
^0(%arg87 : i32, %arg88 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg88, %0 : i32
  %2 = llvm.and %1, %arg87 : i32
  %3 = llvm.xor %arg87, %0 : i32
  %4 = llvm.xor %2, %3 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def foo_before := [llvm|
{
^0(%arg0 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.mlir.constant(7 : i32) : i32
  %2 = llvm.or %0, %1 : i32
  %3 = llvm.and %arg0, %2 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def eq_umax2_before := [llvm|
{
^0(%arg58 : i32, %arg59 : i32):
  %0 = llvm.icmp "ugt" %arg59, %arg58 : i32
  %1 = "llvm.select"(%0, %arg59, %arg58) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %2 = llvm.icmp "eq" %1, %arg58 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def test10_before := [llvm|
{
^0(%arg4 : i123):
  %0 = llvm.mlir.constant(127 : i123) : i123
  %1 = llvm.mlir.constant(128 : i123) : i123
  %2 = llvm.and %arg4, %0 : i123
  %3 = llvm.and %2, %1 : i123
  "llvm.return"(%3) : (i123) -> ()
}
]

def lshrult_02_11_exact_before := [llvm|
{
^0(%arg122 : i4):
  %0 = llvm.mlir.constant(2 : i4) : i4
  %1 = llvm.mlir.constant(-5 : i4) : i4
  %2 = llvm.lshr exact %arg122, %0 : i4
  %3 = llvm.icmp "ult" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def hasType (Γ : Context Ty) (v : VarName) (ty : Ty) : Prop :=
  Γ.lookup v = some ty

def n0_before := [llvm|
{
^0(%arg9 : i8, %arg10 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.mlir.constant(-1 : i8) : i8
  %2 = llvm.shl %0, %arg10 : i8
  %3 = llvm.xor %2, %1 : i8
  %4 = llvm.icmp "ult" %3, %arg9 : i8
  "llvm.return"(%4) : (i1) -> ()
}
]

def select_zext_different_condition_after := [llvm|
{
^0(%arg15 : i1, %arg16 : i1):
  %0 = llvm.mlir.constant(64) : i64
  %1 = llvm.mlir.constant(1) : i64
  %2 = "llvm.select"(%arg15, %0, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i64, i64) -> i64
  %3 = llvm.zext %arg16 : i1 to i64
  %4 = llvm.add %2, %3 overflow<nsw,nuw> : i64
  "llvm.return"(%4) : (i64) -> ()
}
]

def samesign_inverted_commute3_before := [llvm|
{
^0(%arg97 : i32, %arg98 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.and %arg97, %arg98 : i32
  %3 = llvm.icmp "sgt" %2, %0 : i32
  %4 = llvm.or %arg98, %arg97 : i32
  %5 = llvm.icmp "slt" %4, %1 : i32
  %6 = llvm.and %5, %3 : i1
  "llvm.return"(%6) : (i1) -> ()
}
]

def anyext_trunc_fold: List (Σ Γ, LLVMPeepholeRewriteRefine 32 Γ) :=
  [⟨_, anyext_trunc_fold_sext_32⟩,
  ⟨_, anyext_trunc_fold_zext_32⟩]

def max_of_min_before := [llvm|
{
^0(%arg22 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.xor %arg22, %0 : i32
  %3 = llvm.icmp "sgt" %arg22, %1 : i32
  %4 = "llvm.select"(%3, %2, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %5 = llvm.icmp "sgt" %4, %0 : i32
  %6 = "llvm.select"(%5, %4, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%6) : (i32) -> ()
}
]

instance : Lean.ToExpr RegIndex := inherit

acNf in Leanwuzla.Basic

def test14_before := [llvm|
{
^0(%arg36 : i1, %arg37 : i1):
  %0 = llvm.icmp "eq" %arg36, %arg37 : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def t0_before := [llvm|
{
^0(%arg18 : i32, %arg19 : i16):
  %0 = llvm.mlir.constant(32 : i16) : i16
  %1 = llvm.mlir.constant(-1 : i16) : i16
  %2 = llvm.sub %0, %arg19 : i16
  %3 = llvm.zext %2 : i16 to i32
  %4 = llvm.ashr %arg18, %3 : i32
  %5 = llvm.trunc %4 : i32 to i16
  %6 = llvm.add %arg19, %1 : i16
  %7 = llvm.ashr %5, %6 : i16
  "llvm.return"(%7) : (i16) -> ()
}
]

def or_or_logic_and_1_before := [llvm|
{
^0(%arg12 : i1, %arg13 : i1, %arg14 : i1):
  %0 = llvm.mlir.constant(false) : i1
  %1 = llvm.or %arg12, %arg13 : i1
  %2 = llvm.or %arg14, %arg12 : i1
  %3 = "llvm.select"(%1, %2, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def demorgan_nor_use2c_after := [llvm|
{
^0(%arg26 : i8, %arg27 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.mlir.constant(23 : i8) : i8
  %2 = llvm.xor %arg26, %0 : i8
  %3 = llvm.or %arg27, %2 : i8
  %4 = llvm.mul %3, %1 : i8
  %5 = llvm.xor %3, %0 : i8
  %6 = llvm.sdiv %5, %4 : i8
  "llvm.return"(%6) : (i8) -> ()
}
]

def select_sub_icmp_bad_2_before := [llvm|
{
^0(%arg68 : i32, %arg69 : i32, %arg70 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.icmp "eq" %arg68, %0 : i32
  %2 = llvm.sub %arg70, %arg68 : i32
  %3 = "llvm.select"(%1, %2, %arg69) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def test_before := [llvm|
{
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(2 : i32) : i32
  %2 = llvm.icmp "eq" %0, %1 : i32
  %3 = llvm.zext %2 : i1 to i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def ashr_not_after := [llvm|
{
^0(%arg78 : i8):
  %0 = llvm.mlir.constant(5 : i8) : i8
  %1 = llvm.mlir.constant(-1 : i8) : i8
  %2 = llvm.ashr %arg78, %0 : i8
  %3 = llvm.xor %2, %1 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def ashrsgt_01_04_before := [llvm|
{
^0(%arg313 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(4 : i4) : i4
  %2 = llvm.ashr %arg313, %0 : i4
  %3 = llvm.icmp "sgt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def test35_after := [llvm|
{
^0(%arg50 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.mlir.constant(60 : i32) : i32
  %2 = llvm.mlir.constant(100 : i32) : i32
  %3 = llvm.icmp "sgt" %arg50, %0 : i32
  %4 = "llvm.select"(%3, %1, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def sge_swap_or_max_commute_before := [llvm|
{
^0(%arg178 : i8, %arg179 : i8):
  %0 = llvm.mlir.constant(127 : i8) : i8
  %1 = llvm.icmp "sle" %arg179, %arg178 : i8
  %2 = llvm.icmp "eq" %arg178, %0 : i8
  %3 = llvm.or %2, %1 : i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def main6d_before := [llvm|
{
^0(%arg88 : i32):
  %0 = llvm.mlir.constant(7 : i32) : i32
  %1 = llvm.mlir.constant(3 : i32) : i32
  %2 = llvm.mlir.constant(16 : i32) : i32
  %3 = llvm.mlir.constant(0 : i32) : i32
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.and %arg88, %0 : i32
  %6 = llvm.icmp "ne" %5, %1 : i32
  %7 = llvm.and %arg88, %2 : i32
  %8 = llvm.icmp "eq" %7, %3 : i32
  %9 = llvm.or %6, %8 : i1
  %10 = "llvm.select"(%9, %3, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%10) : (i32) -> ()
}
]

def sub_from_constant_of_sub_from_constant_after := [llvm|
{
^0(%arg170 : i8):
  %0 = llvm.mlir.constant(-31 : i8) : i8
  %1 = llvm.add %arg170, %0 : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

@[simp]
def dec_bij {n : Nat} : Function.Bijective (dec (n := n)) :=

def DCE.DeleteRange.pred (vs : DeleteRange (Γ.cons t)) (h : vs.start ≠ 0) :
    DeleteRange Γ where
  start := vs.start.pred (fun h' => by admit /- proof elided -/
  )
  num := ⟨vs.num, by admit /- proof elided -/
  ⟩

instance [ToString w] : ToString (Option w) where
  toString
    | some x => s!"(some {toString x})"
    | none   => "(none)"

def bools2_logical_commute0_and1_after := [llvm|
{
^0(%arg61 : i1, %arg62 : i1, %arg63 : i1):
  %0 = "llvm.select"(%arg63, %arg61, %arg62) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def test23_before := [llvm|
{
^0(%arg8 : i44):
  %0 = llvm.mlir.constant(33 : i44) : i44
  %1 = llvm.shl %arg8, %0 : i44
  %2 = llvm.ashr %1, %0 : i44
  %3 = llvm.trunc %2 : i44 to i11
  "llvm.return"(%3) : (i11) -> ()
}
]

def test5_before := [llvm|
{
^0(%arg23 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.udiv %0, %arg23 : i32
  %3 = llvm.icmp "ne" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def shl_lshr_demand3_before := [llvm|
{
^0(%arg18 : i8):
  %0 = llvm.mlir.constant(40 : i8) : i8
  %1 = llvm.mlir.constant(3 : i8) : i8
  %2 = llvm.mlir.constant(-64 : i8) : i8
  %3 = llvm.shl %0, %arg18 : i8
  %4 = llvm.lshr %3, %1 : i8
  %5 = llvm.or %4, %2 : i8
  "llvm.return"(%5) : (i8) -> ()
}
]

def mux {Γ : Ctxt _}  (a b : Γ.Var (MLIR2DCPlus.Ty.tokenstream)) (c : Γ.Var (MLIR2DCPlus.Ty.valuestream 1)) : Expr (DCPlus) Γ .pure (.tokenstream) :=
  Expr.mk
    (op := .mux)
    (ty_eq := rfl)
    (eff_le := by admit /- proof elided -/
    )
    (args := .cons a <| .cons b <| .cons c <| .nil)
    (regArgs := .nil)

def t3_after := [llvm|
{
^0(%arg23 : i8, %arg24 : i2):
  %0 = llvm.sext %arg24 : i2 to i8
  %1 = llvm.add %arg23, %0 : i8
  %2 = llvm.xor %1, %0 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def icmp_slt_sext_ne_otherwise_nofold_after := [llvm|
{
^0(%arg1 : i32):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.icmp "ne" %arg1, %0 : i32
  %2 = llvm.sext %1 : i1 to i32
  %3 = llvm.icmp "sgt" %arg1, %2 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def and_or_not_not_commute3_after := [llvm|
{
^0(%arg366 : i32, %arg367 : i32, %arg368 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.or %arg368, %arg367 : i32
  %2 = llvm.and %1, %arg366 : i32
  %3 = llvm.xor %2, %0 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def scalar_i32_lshr_and_negC_slt_before := [llvm|
{
^0(%arg4 : i32, %arg5 : i32):
  %0 = llvm.mlir.constant(-8 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.lshr %arg4, %arg5 : i32
  %3 = llvm.and %2, %0 : i32
  %4 = llvm.icmp "slt" %3, %1 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def narrow_sext_or_after := [llvm|
{
^0(%arg52 : i16, %arg53 : i32):
  %0 = llvm.trunc %arg53 : i32 to i16
  %1 = llvm.or %arg52, %0 : i16
  "llvm.return"(%1) : (i16) -> ()
}
]

def icmp_slt_0_xor_icmp_sgt_neg2_i32_after := [llvm|
{
^0(%arg54 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.icmp "ne" %arg54, %0 : i32
  %2 = llvm.zext %1 : i1 to i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def decr (x : BitStream) : BitStream :=
  fun n => (decrAux x n).1

def sub_zext_trunc_lshr_after := [llvm|
{
^0(%arg15 : i64):
  %0 = llvm.mlir.constant(16 : i32) : i32
  %1 = llvm.mlir.constant(31 : i32) : i32
  %2 = llvm.mlir.constant(10 : i32) : i32
  %3 = llvm.trunc %arg15 : i64 to i32
  %4 = llvm.shl %3, %0 : i32
  %5 = llvm.ashr %4, %1 : i32
  %6 = llvm.add %5, %2 overflow<nsw> : i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def test7_before := [llvm|
{
^0(%arg44 : i8):
  %0 = llvm.mlir.constant(-1 : i29) : i29
  %1 = llvm.zext %arg44 : i8 to i29
  %2 = llvm.ashr %0, %1 : i29
  "llvm.return"(%2) : (i29) -> ()
}
]

def test14_after := [llvm|
{
^0(%arg14 : i8, %arg15 : i8):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def CNFA.inter_bv_language (m₁ m₂ : CNFA n) :
    m₁.bv_recognizes L₁ →
    m₂.bv_recognizes L₂ →
    (m₁.inter m₂).bv_recognizes (L₁ ∩ L₂) :=

@[simp, deprecated "Use `getElem?`" (since := "")]
def get? : Ctxt Ty → Nat → Option Ty := (·[·]?)

def combined_sdiv_srem_correct := [LV| {
  ^entry (%a: i64, %b: i64):
    %0= llvm.sdiv %a, %b : i64
    %1 = llvm.mul %b, %0 : i64
    %2 = llvm.sub %a, %1 : i64
    llvm.return %2 : i64
  }]

def union (M N : NFA' n) : NFA' n := ⟨_, M.M.union N.M⟩

def fold_and_zext_icmp_after := [llvm|
{
^0(%arg97 : i64, %arg98 : i64, %arg99 : i64):
  %0 = llvm.icmp "sgt" %arg97, %arg98 : i64
  %1 = llvm.icmp "slt" %arg97, %arg99 : i64
  %2 = llvm.and %0, %1 : i1
  %3 = llvm.zext %2 : i1 to i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def test2_after := [llvm|
{
^0(%arg59 : i32):
  %0 = llvm.mlir.constant(39 : i32) : i32
  %1 = llvm.and %arg59, %0 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def n2_badmask_before := [llvm|
{
^0(%arg4 : i32, %arg5 : i32, %arg6 : i32, %arg7 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.and %arg6, %arg4 : i32
  %2 = llvm.xor %arg7, %0 : i32
  %3 = llvm.and %2, %arg5 : i32
  %4 = llvm.add %1, %3 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def test38_before := [llvm|
{
^0(%arg238 : i32):
  %0 = llvm.mlir.constant(7) : i64
  %1 = llvm.mlir.constant(240) : i64
  %2 = llvm.zext %arg238 : i32 to i64
  %3 = llvm.xor %2, %0 : i64
  %4 = llvm.and %3, %1 : i64
  "llvm.return"(%4) : (i64) -> ()
}
]

def testi128i128_after := [llvm|
{
^0(%arg7 : i128):
  %0 = llvm.mlir.constant(-1 : i128) : i128
  %1 = llvm.mlir.constant(27 : i128) : i128
  %2 = llvm.mlir.constant(-28 : i128) : i128
  %3 = llvm.icmp "sgt" %arg7, %0 : i128
  %4 = "llvm.select"(%3, %1, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i128, i128) -> i128
  "llvm.return"(%4) : (i128) -> ()
}
]

def pr40493_neg3_after := [llvm|
{
^0(%arg15 : i32):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.mlir.constant(4 : i32) : i32
  %2 = llvm.shl %arg15, %0 : i32
  %3 = llvm.and %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def add_nsw_poison_constant_fold_after := [llvm|
{
^0(%arg2 : i1, %arg3 : i8):
  %0 = llvm.mlir.constant(64 : i8) : i8
  %1 = llvm.mlir.constant(-127 : i8) : i8
  %2 = llvm.add %arg3, %0 overflow<nsw> : i8
  %3 = "llvm.select"(%arg2, %2, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def icmp_ne_sext_ne_otherwise_before := [llvm|
{
^0(%arg16 : i32):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.icmp "ne" %arg16, %0 : i32
  %2 = llvm.sext %1 : i1 to i32
  %3 = llvm.icmp "ne" %2, %arg16 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def goo_before := [llvm|
{
^0(%arg105 : i32, %arg106 : i32, %arg107 : i32, %arg108 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.icmp "slt" %arg105, %arg106 : i32
  %3 = "llvm.select"(%2, %0, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %4 = llvm.and %3, %arg107 : i32
  %5 = llvm.xor %3, %0 : i32
  %6 = llvm.and %5, %arg108 : i32
  %7 = llvm.or %4, %6 : i32
  "llvm.return"(%7) : (i32) -> ()
}
]

def test12_after := [llvm|
{
^0(%arg88 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

def main7b_before := [llvm|
{
^0(%arg78 : i32, %arg79 : i32, %arg80 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.mul %arg80, %0 : i32
  %4 = llvm.and %arg78, %arg79 : i32
  %5 = llvm.icmp "eq" %arg79, %4 : i32
  %6 = llvm.and %arg78, %3 : i32
  %7 = llvm.icmp "eq" %3, %6 : i32
  %8 = llvm.and %5, %7 : i1
  %9 = "llvm.select"(%8, %1, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%9) : (i32) -> ()
}
]

@[simp_denote]
def shl_llvm_nsw_nuw_32 := [LV| {
  ^entry (%x: i32, %y: i32):
    %1 = llvm.shl    %x, %y overflow<nsw,nuw> : i32
    llvm.return %1 : i32
  }]

def shl1_trunc_sgt4_before := [llvm|
{
^0(%arg15 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(4 : i16) : i16
  %2 = llvm.shl %0, %arg15 : i32
  %3 = llvm.trunc %2 : i32 to i16
  %4 = llvm.icmp "sgt" %3, %1 : i16
  "llvm.return"(%4) : (i1) -> ()
}
]

def alive_AddSub_1043_tgt  (w : Nat)  :=
[llvm( w )| {
^bb0(%C1 : _, %Z : _, %RHS : _):
  %v1 = llvm.not %C1
  %v2 = llvm.or %Z, %v1
  %v3 = llvm.and %Z, %C1
  %v4 = llvm.xor %v3, %C1
  %v5 = llvm.mlir.constant 1
  %v6 = llvm.add %v4, %v5
  %v7 = llvm.sub %RHS, %v2
  llvm.return %v7
}]

def or_xor_tree_1001_after := [llvm|
{
^0(%arg18 : i32, %arg19 : i32, %arg20 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mul %arg18, %0 : i32
  %2 = llvm.mul %arg19, %0 : i32
  %3 = llvm.mul %arg20, %0 : i32
  %4 = llvm.xor %2, %1 : i32
  %5 = llvm.or %4, %3 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def icmp_ne_sext_ne_allones_before := [llvm|
{
^0(%arg20 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.icmp "ne" %arg20, %0 : i32
  %2 = llvm.sext %1 : i1 to i32
  %3 = llvm.icmp "ne" %2, %arg20 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def p1_ugt_after := [llvm|
{
^0(%arg52 : i32, %arg53 : i32):
  %0 = llvm.mlir.constant(65535 : i32) : i32
  %1 = llvm.icmp "ult" %arg52, %0 : i32
  %2 = "llvm.select"(%1, %0, %arg53) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def sgt_smax3_after := [llvm|
{
^0(%arg35 : i32, %arg36 : i32):
  %0 = llvm.mlir.constant(3 : i32) : i32
  %1 = llvm.add %arg35, %0 : i32
  %2 = llvm.icmp "sgt" %arg36, %1 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

private def pretty_test_overflow :=
  [llvm()|{
  ^bb0(%arg0: i32):
    %0 = llvm.mlir.constant 8 : i32
    %1 = llvm.add %0, %arg0 overflow<nsw> : i32
    %2 = llvm.mul %1, %arg0 : i32
    %3 = llvm.not %2 : i32
    llvm.return %3 : i32
  }]

def eq_umin1_before := [llvm|
{
^0(%arg60 : i32, %arg61 : i32):
  %0 = llvm.icmp "ult" %arg60, %arg61 : i32
  %1 = "llvm.select"(%0, %arg60, %arg61) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %2 = llvm.icmp "eq" %1, %arg60 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def urem {w : Nat} (x y : IntW w) : IntW w := do
  let x' ← x
  let y' ← y
  urem? x' y'

structure Item where
 name : String
 tac : Syntax

def slt_zero_ne_ne_0_after := [llvm|
{
^0(%arg5 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.icmp "sgt" %arg5, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def canonicalize_icmp_slt_neg2 : LLVMPeepholeRewriteRefine 1 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%x: i64):
      %c = llvm.mlir.constant -2 : i64
      %1 = llvm.icmp.slt %c, %x : i64
      llvm.return %1 : i1
  }]
  rhs := [LV| {
    ^entry (%x: i64):
      %c = llvm.mlir.constant -2 : i64
      %1 = llvm.icmp.sgt %x, %c : i64
      llvm.return %1 : i1
  }]

def or_umin_after := [llvm|
{
^0(%arg4 : i32):
  %0 = llvm.mlir.constant(31 : i32) : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

Monad in Init.Prelude

instance {n : Nat} : Cli.ParseableType (BitVec n) where
  name := s!"BitVec {n}"
  parse? str := do
   let intVal ← Cli.instParseableTypeInt.parse? str
   return BitVec.ofInt n intVal

def positive_biggerashr_shlnuwnsw_ashrexact_after := [llvm|
{
^0(%arg25 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.ashr exact %arg25, %0 : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def shl_and_and_fail_after := [llvm|
{
^0(%arg170 : i8, %arg171 : i8):
  %0 = llvm.mlir.constant(4 : i8) : i8
  %1 = llvm.mlir.constant(5 : i8) : i8
  %2 = llvm.mlir.constant(64 : i8) : i8
  %3 = llvm.shl %arg170, %0 : i8
  %4 = llvm.shl %arg171, %1 : i8
  %5 = llvm.and %4, %2 : i8
  %6 = llvm.and %3, %5 : i8
  "llvm.return"(%6) : (i8) -> ()
}
]

def a_false_implies_b_true2_comm_before := [llvm|
{
^0(%arg9 : i8, %arg10 : i1, %arg11 : i1):
  %0 = llvm.mlir.constant(10 : i8) : i8
  %1 = llvm.mlir.constant(20 : i8) : i8
  %2 = llvm.icmp "ugt" %arg9, %0 : i8
  %3 = llvm.icmp "ult" %arg9, %1 : i8
  %4 = "llvm.select"(%3, %arg10, %arg11) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %5 = llvm.or %4, %2 : i1
  "llvm.return"(%5) : (i1) -> ()
}
]

instance : ToString FpBinaryPredKind := ⟨FpBinaryPredKind.toString⟩

@[simp_denote]
def icmp_ule_llvm_32 : Com LLVMPlusRiscV ⟨[.llvm (.bitvec 32), .llvm (.bitvec 32)]⟩
  .pure (.llvm (.bitvec 1)) := [LV| {
  ^entry (%lhs: i32, %rhs: i32):
    %1 = llvm.icmp.ule %lhs, %rhs : i32
    llvm.return %1 : i1
  }]

def foo_after := [llvm|
{
^0(%arg113 : i32, %arg114 : i32, %arg115 : i32, %arg116 : i32):
  %0 = llvm.icmp "slt" %arg113, %arg114 : i32
  %1 = "llvm.select"(%0, %arg115, %arg116) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def lshr_16_add_zext_basic_after := [llvm|
{
^0(%arg33 : i16, %arg34 : i16):
  %0 = llvm.mlir.constant(-1 : i16) : i16
  %1 = llvm.xor %arg33, %0 : i16
  %2 = llvm.icmp "ugt" %arg34, %1 : i16
  %3 = llvm.zext %2 : i1 to i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def lshrugt_02_05_before := [llvm|
{
^0(%arg394 : i4):
  %0 = llvm.mlir.constant(2 : i4) : i4
  %1 = llvm.mlir.constant(5 : i4) : i4
  %2 = llvm.lshr %arg394, %0 : i4
  %3 = llvm.icmp "ugt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def fast_div_201_before := [llvm|
{
^0(%arg0 : i8):
  %0 = llvm.mlir.constant(71 : i16) : i16
  %1 = llvm.mlir.constant(8 : i16) : i16
  %2 = llvm.mlir.constant(1 : i8) : i8
  %3 = llvm.mlir.constant(7 : i8) : i8
  %4 = llvm.zext %arg0 : i8 to i16
  %5 = llvm.mul %4, %0 : i16
  %6 = llvm.lshr %5, %1 : i16
  %7 = llvm.trunc %6 : i16 to i8
  %8 = llvm.sub %arg0, %7 : i8
  %9 = llvm.lshr %8, %2 : i8
  %10 = llvm.add %7, %9 : i8
  %11 = llvm.lshr %10, %3 : i8
  "llvm.return"(%11) : (i8) -> ()
}
]

def negtest_near_pow2_cmpval_isnt_close_to_pow2_before := [llvm|
{
^0(%arg1 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.mlir.constant(6 : i8) : i8
  %2 = llvm.ashr exact %arg1, %0 : i8
  %3 = llvm.icmp "slt" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def shl_xor_lshr_comm_before := [llvm|
{
^0(%arg97 : i32, %arg98 : i32, %arg99 : i32):
  %0 = llvm.shl %arg97, %arg98 overflow<nuw> : i32
  %1 = llvm.xor %arg99, %0 : i32
  %2 = llvm.lshr %1, %arg98 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def ne_3210_after := [llvm|
{
^0(%arg74 : i32, %arg75 : i32):
  %0 = llvm.icmp "ne" %arg74, %arg75 : i32
  "llvm.return"(%0) : (i1) -> ()
}
]

Lean.Meta.getSimpCongrTheorems in Lean.Meta.Tactic.Simp.SimpCongrTheorems

def negate_sdiv_before := [llvm|
{
^0(%arg132 : i8, %arg133 : i8):
  %0 = llvm.mlir.constant(42 : i8) : i8
  %1 = llvm.sdiv %arg133, %0 : i8
  %2 = llvm.sub %arg132, %1 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def ule_umax2_after := [llvm|
{
^0(%arg50 : i32, %arg51 : i32):
  %0 = llvm.icmp "ule" %arg51, %arg50 : i32
  "llvm.return"(%0) : (i1) -> ()
}
]

def llvm_add_lower_riscv_nuw_nsw_flag_8 : LLVMPeepholeRewriteRefine 8 [Ty.llvm (.bitvec 8), Ty.llvm (.bitvec 8)] where
  lhs:= add_llvm_nsw_nuw_flags_8
  rhs:= add_riscv_8

def scalar_i32_shl_and_negC_eq_after := [llvm|
{
^0(%arg31 : i32, %arg32 : i32):
  %0 = llvm.mlir.constant(262144 : i32) : i32
  %1 = llvm.shl %arg31, %arg32 : i32
  %2 = llvm.icmp "ult" %1, %0 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def lor_lor_left2_after := [llvm|
{
^0(%arg68 : i1, %arg69 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = "llvm.select"(%arg69, %0, %arg68) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%1) : (i1) -> ()
}
]

@[simp_denote]
def add_positive_low_bound_accept_llvm := [LV| {
    ^entry (%a: i32):
    %0 = llvm.mlir.constant (2048) : i32
    %1 = llvm.add %0, %a : i32
    llvm.return %1 :i32
  }]

def trunc_shl_ashr_var_before := [llvm|
{
^0(%arg16 : i64, %arg17 : i64):
  %0 = llvm.mlir.constant(2) : i64
  %1 = llvm.ashr %arg16, %arg17 : i64
  %2 = llvm.shl %1, %0 : i64
  %3 = llvm.trunc %2 : i64 to i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def test_and3_after := [llvm|
{
^0(%arg44 : i32, %arg45 : i32):
  %0 = llvm.mlir.constant(2147483647 : i32) : i32
  %1 = llvm.and %arg45, %0 : i32
  %2 = llvm.icmp "ult" %arg44, %1 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def negative3_logical_after := [llvm|
{
^0(%arg8 : i32, %arg9 : i32, %arg10 : i32):
  %0 = llvm.mlir.constant(2147483647 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.mlir.constant(false) : i1
  %3 = llvm.and %arg10, %0 : i32
  %4 = llvm.icmp "slt" %arg8, %3 : i32
  %5 = llvm.icmp "sgt" %arg9, %1 : i32
  %6 = "llvm.select"(%4, %5, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%6) : (i1) -> ()
}
]

def test1_before := [llvm|
{
^0(%arg153 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg153, %0 : i32
  %2 = llvm.xor %1, %0 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def masked_icmps_bmask_notmixed_and_after := [llvm|
{
^0(%arg3 : i32):
  %0 = llvm.mlir.constant(15 : i32) : i32
  %1 = llvm.mlir.constant(3 : i32) : i32
  %2 = llvm.and %arg3, %0 : i32
  %3 = llvm.icmp "ne" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def select_icmp_slt_zero_smin_before := [llvm|
{
^0(%arg7 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.mlir.constant(-128 : i8) : i8
  %2 = llvm.icmp "slt" %arg7, %0 : i8
  %3 = llvm.xor %arg7, %1 : i8
  %4 = "llvm.select"(%2, %arg7, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%4) : (i8) -> ()
}
]

def differentconsts_before := [llvm|
{
^0(%arg29 : i32, %arg30 : i16, %arg31 : i16):
  %0 = llvm.mlir.constant(128 : i32) : i32
  %1 = llvm.mlir.constant(256 : i16) : i16
  %2 = llvm.mlir.constant(-1 : i16) : i16
  %3 = llvm.mlir.constant(16 : i32) : i32
  %4 = llvm.mlir.constant(144 : i32) : i32
  %5 = llvm.icmp "slt" %arg29, %0 : i32
  %6 = "llvm.select"(%5, %1, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i16, i16) -> i16
  %7 = llvm.add %arg29, %3 : i32
  %8 = llvm.icmp "ult" %7, %4 : i32
  %9 = llvm.trunc %arg29 : i32 to i16
  %10 = "llvm.select"(%8, %9, %6) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i16, i16) -> i16
  "llvm.return"(%10) : (i16) -> ()
}
]

def different_size_zext_zext_eq_before := [llvm|
{
^0(%arg22 : i4, %arg23 : i7):
  %0 = llvm.zext %arg22 : i4 to i25
  %1 = llvm.zext %arg23 : i7 to i25
  %2 = llvm.icmp "eq" %0, %1 : i25
  "llvm.return"(%2) : (i1) -> ()
}
]

def select_and_icmp_zero_after := [llvm|
{
^0(%arg152 : i32, %arg153 : i32, %arg154 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.icmp "eq" %arg152, %0 : i32
  %2 = "llvm.select"(%1, %0, %arg153) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def test54_before := [llvm|
{
^0(%arg130 : i64):
  %0 = llvm.mlir.constant(-32574 : i16) : i16
  %1 = llvm.mlir.constant(-25350 : i16) : i16
  %2 = llvm.trunc %arg130 : i64 to i16
  %3 = llvm.or %2, %0 : i16
  %4 = llvm.and %3, %1 : i16
  %5 = llvm.sext %4 : i16 to i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def or_xor_common_op_commute0_after := [llvm|
{
^0(%arg135 : i8, %arg136 : i8, %arg137 : i8):
  %0 = llvm.or %arg135, %arg136 : i8
  %1 = llvm.or %0, %arg137 : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def p15_commutativity2_before := [llvm|
{
^0(%arg24 : i32, %arg25 : i32):
  %0 = llvm.mlir.constant(65536 : i32) : i32
  %1 = llvm.mlir.constant(42 : i32) : i32
  %2 = llvm.mlir.constant(65535 : i32) : i32
  %3 = llvm.icmp "ult" %arg24, %0 : i32
  %4 = "llvm.select"(%3, %1, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def modulo2_after := [llvm|
{
^0(%arg10 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.and %arg10, %0 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def test_negative_nuw_and_signed_pred_before := [llvm|
{
^0(%arg53 : i64):
  %0 = llvm.mlir.constant(10) : i64
  %1 = llvm.mlir.constant(3) : i64
  %2 = llvm.sub %0, %arg53 overflow<nuw> : i64
  %3 = llvm.icmp "slt" %2, %1 : i64
  "llvm.return"(%3) : (i1) -> ()
}
]

def ult_swap_and_max_commute_logical_before := [llvm|
{
^0(%arg354 : i8, %arg355 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.mlir.constant(false) : i1
  %2 = llvm.icmp "ugt" %arg355, %arg354 : i8
  %3 = llvm.icmp "eq" %arg354, %0 : i8
  %4 = "llvm.select"(%3, %2, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def shiftLeft (op1 : GenBVExpr w) (op2: GenBVExpr w) : GenBVExpr w :=
  GenBVExpr.shiftLeft op1 op2

def main6b_after := [llvm|
{
^0(%arg92 : i32):
  %0 = llvm.mlir.constant(23 : i32) : i32
  %1 = llvm.mlir.constant(19 : i32) : i32
  %2 = llvm.and %arg92, %0 : i32
  %3 = llvm.icmp "ne" %2, %1 : i32
  %4 = llvm.zext %3 : i1 to i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def test_after := [llvm|
{
^0(%arg0 : i26):
  "llvm.return"(%arg0) : (i26) -> ()
}
]

def select_of_symmetric_selects_before := [llvm|
{
^0(%arg33 : i32, %arg34 : i32, %arg35 : i1, %arg36 : i1):
  %0 = "llvm.select"(%arg35, %arg33, %arg34) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %1 = "llvm.select"(%arg35, %arg34, %arg33) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %2 = "llvm.select"(%arg36, %0, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def llvm_const_lower_riscv_li_17 : LLVMPeepholeRewriteRefine 64 [] :=
  {lhs := constLLVM_17, rhs:= liRiscv_17,
   correct := by admit /- proof elided -/

def eq_smax3_after := [llvm|
{
^0(%arg59 : i32, %arg60 : i32):
  %0 = llvm.mlir.constant(3 : i32) : i32
  %1 = llvm.add %arg59, %0 : i32
  %2 = llvm.icmp "sge" %1, %arg60 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def icmp_eq_mul_nsw_nonequal_commuted_before := [llvm|
{
^0(%arg30 : i8, %arg31 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.add %arg30, %0 : i8
  %2 = llvm.mul %arg30, %arg31 overflow<nsw> : i8
  %3 = llvm.mul %arg31, %1 overflow<nsw> : i8
  %4 = llvm.icmp "eq" %2, %3 : i8
  "llvm.return"(%4) : (i1) -> ()
}
]

def test19_after := [llvm|
{
^0(%arg7 : i10):
  %0 = llvm.mlir.constant(1 : i3) : i3
  %1 = llvm.mlir.constant(0 : i3) : i3
  %2 = llvm.trunc %arg7 : i10 to i3
  %3 = llvm.and %2, %0 : i3
  %4 = llvm.sub %1, %3 overflow<nsw> : i3
  %5 = llvm.sext %4 : i3 to i10
  "llvm.return"(%5) : (i10) -> ()
}
]

def ne_umax3_before := [llvm|
{
^0(%arg40 : i32, %arg41 : i32):
  %0 = llvm.mlir.constant(3 : i32) : i32
  %1 = llvm.add %arg40, %0 : i32
  %2 = llvm.icmp "ugt" %1, %arg41 : i32
  %3 = "llvm.select"(%2, %1, %arg41) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %4 = llvm.icmp "ne" %1, %3 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def ugt_sext_before := [llvm|
{
^0(%arg130 : i1, %arg131 : i8):
  %0 = llvm.sext %arg130 : i1 to i8
  %1 = llvm.icmp "ugt" %0, %arg131 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

inductive Ty
|   int : Ty
|   ix : Ty
|   tensor1d  : Ty
deriving DecidableEq, Inhabited

def add_const_const_sub_before := [llvm|
{
^0(%arg61 : i32):
  %0 = llvm.mlir.constant(8 : i32) : i32
  %1 = llvm.mlir.constant(2 : i32) : i32
  %2 = llvm.add %arg61, %0 : i32
  %3 = llvm.sub %1, %2 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def main4c_before := [llvm|
{
^0(%arg124 : i32):
  %0 = llvm.mlir.constant(7 : i32) : i32
  %1 = llvm.mlir.constant(48 : i32) : i32
  %2 = llvm.mlir.constant(0 : i32) : i32
  %3 = llvm.mlir.constant(1 : i32) : i32
  %4 = llvm.and %arg124, %0 : i32
  %5 = llvm.icmp "ne" %4, %0 : i32
  %6 = llvm.and %arg124, %1 : i32
  %7 = llvm.icmp "ne" %6, %1 : i32
  %8 = llvm.or %5, %7 : i1
  %9 = "llvm.select"(%8, %2, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%9) : (i32) -> ()
}
]

def checkCircuitUnsatAux {α : Type} [DecidableEq α] [Hashable α] [Fintype α]
    (c : Circuit α) : TermElabM (Option LratCert) := do
  let cfg : BVDecideConfig := { timeout := cadicalTimeoutSec }
  IO.FS.withTempFile fun _ lratFile => do
    let cfg ← BVDecide.Frontend.TacticContext.new lratFile cfg
    let entrypoint:= c.toAIG.val
    let ⟨entrypoint, _labelling⟩ := entrypoint.relabelNat'
    let cnf := toCNF entrypoint
    let out ← runExternal cnf cfg.solver cfg.lratPath
      (trimProofs := true)
      (timeout := cadicalTimeoutSec)
      (binaryProofs := true)
    match out with
    | .error _model => return .none
    | .ok cert => return .some cert

def sext_shl_mask_after := [llvm|
{
^0(%arg7 : i16, %arg8 : i32):
  %0 = llvm.mlir.constant(65535 : i32) : i32
  %1 = llvm.zext %arg7 : i16 to i32
  %2 = llvm.shl %1, %arg8 : i32
  %3 = llvm.and %2, %0 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def or_basic_before := [llvm|
{
^0(%arg15 : i16):
  %0 = llvm.mlir.constant(127 : i8) : i8
  %1 = llvm.mlir.constant(-256 : i16) : i16
  %2 = llvm.mlir.constant(17664 : i16) : i16
  %3 = llvm.trunc %arg15 : i16 to i8
  %4 = llvm.icmp "ne" %3, %0 : i8
  %5 = llvm.and %arg15, %1 : i16
  %6 = llvm.icmp "ne" %5, %2 : i16
  %7 = llvm.or %4, %6 : i1
  "llvm.return"(%7) : (i1) -> ()
}
]

@[match_pattern] abbrev shl (w : Nat) (flags: NoWrapFlags := {}) : LLVM.Op := MOp.shl (.concrete w) flags

def slt_swap_and_max_commute_before := [llvm|
{
^0(%arg372 : i8, %arg373 : i8):
  %0 = llvm.mlir.constant(127 : i8) : i8
  %1 = llvm.icmp "sgt" %arg373, %arg372 : i8
  %2 = llvm.icmp "eq" %arg372, %0 : i8
  %3 = llvm.and %2, %1 : i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def or_xor_and_commuted2_before := [llvm|
{
^0(%arg48 : i32, %arg49 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.mul %arg49, %arg49 : i32
  %2 = llvm.mul %arg48, %arg48 : i32
  %3 = llvm.xor %1, %0 : i32
  %4 = llvm.xor %2, %3 : i32
  %5 = llvm.or %4, %1 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def ashr_sgt_overflow_before := [llvm|
{
^0(%arg150 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.mlir.constant(63 : i8) : i8
  %2 = llvm.ashr %arg150, %0 : i8
  %3 = llvm.icmp "sgt" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def f2_after := [llvm|
{
^0(%arg0 : i32, %arg1 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.mlir.constant(7 : i32) : i32
  %2 = llvm.mlir.constant(true) : i1
  %3 = llvm.icmp "slt" %arg0, %0 : i32
  %4 = llvm.lshr %1, %arg1 : i32
  %5 = llvm.icmp "sgt" %arg0, %4 : i32
  %6 = "llvm.select"(%3, %2, %5) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %7 = llvm.zext %6 : i1 to i32
  "llvm.return"(%7) : (i32) -> ()
}
]

def alive_AndOrXor_1280_ABA___AB_src :=
[sllvm| {
^bb0(%A : i64, %B : i64):
  %v1 = llvm.mlir.constant -1 : i64
  %v2 = llvm.xor %A, %v1 : i64
  %v3 = llvm.or %v2, %B : i64
  %v4 = llvm.and %v3, %A : i64
  llvm.return %v4 : i64
}]

def positive_with_aggressive_icmp_before := [llvm|
{
^0(%arg56 : i32):
  %0 = llvm.mlir.constant(128 : i32) : i32
  %1 = llvm.mlir.constant(256 : i32) : i32
  %2 = llvm.mlir.constant(512 : i32) : i32
  %3 = llvm.icmp "ult" %arg56, %0 : i32
  %4 = llvm.add %arg56, %1 : i32
  %5 = llvm.icmp "ult" %4, %2 : i32
  %6 = llvm.and %3, %5 : i1
  "llvm.return"(%6) : (i1) -> ()
}
]

def main4b_logical_after := [llvm|
{
^0(%arg131 : i32):
  %0 = llvm.mlir.constant(23 : i32) : i32
  %1 = llvm.and %arg131, %0 : i32
  %2 = llvm.icmp "ne" %1, %0 : i32
  %3 = llvm.zext %2 : i1 to i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def ashrslt_03_01_exact_after := [llvm|
{
^0(%arg20 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def icmp_sge_riscv_eq_icmp_sge_llvm_32 : LLVMPeepholeRewriteRefine 1 [Ty.llvm (.bitvec 32), Ty.llvm (.bitvec 32)] :=
  {lhs:= icmp_sge_llvm_32, rhs:= icmp_sge_riscv_32}

def constLLVM_34 : Com LLVMPlusRiscV ⟨[]⟩ .pure (.llvm (.bitvec 64)) := [LV| {
  ^entry ():
    %1 = llvm.mlir.constant (-34) : i64
    llvm.return %1 : i64
  }]

class SubstituteableTerminator (T : Type u) where
  substituteTerminator (σ : VarName → VarName) : T → T

Array.foldl in Init.Data.Array.Basic

def ashr_32_add_zext_basic_after := [llvm|
{
^0(%arg9 : i32, %arg10 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg9, %0 : i32
  %2 = llvm.icmp "ugt" %arg10, %1 : i32
  %3 = llvm.zext %2 : i1 to i64
  "llvm.return"(%3) : (i64) -> ()
}
]

def or_xor_tree_0110_after := [llvm|
{
^0(%arg27 : i32, %arg28 : i32, %arg29 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mul %arg27, %0 : i32
  %2 = llvm.mul %arg28, %0 : i32
  %3 = llvm.mul %arg29, %0 : i32
  %4 = llvm.xor %1, %2 : i32
  %5 = llvm.or %4, %3 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def or_not_and_commute6_before := [llvm|
{
^0(%arg519 : i32, %arg520 : i32, %arg521 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.or %arg519, %arg520 : i32
  %2 = llvm.xor %1, %0 : i32
  %3 = llvm.and %2, %arg521 : i32
  %4 = llvm.or %arg521, %arg519 : i32
  %5 = llvm.xor %4, %0 : i32
  %6 = llvm.and %5, %arg520 : i32
  %7 = llvm.or %3, %6 : i32
  "llvm.return"(%7) : (i32) -> ()
}
]

def t4_before := [llvm|
{
^0(%arg192 : i8, %arg193 : i1):
  %0 = llvm.mlir.constant(-42 : i8) : i8
  %1 = llvm.mlir.constant(44 : i8) : i8
  %2 = "llvm.select"(%arg193, %0, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  %3 = llvm.sub %arg192, %2 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def icmp_mul_nsw_sgt_after := [llvm|
{
^0(%arg15 : i8, %arg16 : i8):
  %0 = llvm.icmp "sgt" %arg15, %arg16 : i8
  "llvm.return"(%0) : (i1) -> ()
}
]

def trunc_shl_7_i8_i64_after := [llvm|
{
^0(%arg37 : i64):
  %0 = llvm.mlir.constant(7 : i8) : i8
  %1 = llvm.trunc %arg37 : i64 to i8
  %2 = llvm.shl %1, %0 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def test9_after := [llvm|
{
^0(%arg5 : i1005):
  "llvm.return"(%arg5) : (i1005) -> ()
}
]

def constLLVM27 : Com LLVMPlusRiscV ⟨[]⟩ .pure (.llvm (.bitvec 64)) := [LV| {
  ^entry ():
    %1 = llvm.mlir.constant (27) : i64
    llvm.return %1 : i64
  }]

def lshrult_03_07_exact_after := [llvm|
{
^0(%arg110 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def t0_basic_after := [llvm|
{
^0(%arg24 : i8, %arg25 : i8):
  %0 = llvm.icmp "ule" %arg25, %arg24 : i8
  "llvm.return"(%0) : (i1) -> ()
}
]

def shrink_or_after := [llvm|
{
^0(%arg11 : i6):
  %0 = llvm.mlir.constant(1 : i3) : i3
  %1 = llvm.trunc %arg11 : i6 to i3
  %2 = llvm.or %1, %0 : i3
  "llvm.return"(%2) : (i3) -> ()
}
]

def select {Γ : Ctxt _} (a b : Γ.Var (.tokenstream)) (c : Γ.Var (.valuestream 1)) : Expr (DC) Γ .pure (.tokenstream) :=
  Expr.mk
    (op := .select)
    (ty_eq := rfl)
    (eff_le := by admit /- proof elided -/
    )
    (args := .cons a <| .cons b <| .cons c <| .nil)
    (regArgs := .nil)

def ne_shift_in_zeros_before := [llvm|
{
^0(%arg32 : i32, %arg33 : i32):
  %0 = llvm.mlir.constant(8 : i32) : i32
  %1 = llvm.mlir.constant(16 : i32) : i32
  %2 = llvm.lshr %arg32, %0 : i32
  %3 = llvm.trunc %2 : i32 to i8
  %4 = llvm.lshr %arg32, %1 : i32
  %5 = llvm.trunc %4 : i32 to i24
  %6 = llvm.lshr %arg33, %0 : i32
  %7 = llvm.trunc %6 : i32 to i8
  %8 = llvm.lshr %arg33, %1 : i32
  %9 = llvm.trunc %8 : i32 to i24
  %10 = llvm.icmp "ne" %3, %7 : i8
  %11 = llvm.icmp "ne" %5, %9 : i24
  %12 = llvm.or %11, %10 : i1
  "llvm.return"(%12) : (i1) -> ()
}
]

Lean.withImportModules in Lean.Environment

def sub_to_and_after := [llvm|
{
^0(%arg14 : i32, %arg15 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.and %arg14, %arg15 : i32
  %2 = llvm.sub %0, %1 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def PR42691_3_logical_after := [llvm|
{
^0(%arg338 : i32):
  %0 = llvm.mlir.constant(-2147483647 : i32) : i32
  %1 = llvm.icmp "ult" %arg338, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def nonexact_ashr_eq_exactdiv_before := [llvm|
{
^0(%arg146 : i8):
  %0 = llvm.mlir.constant(-80 : i8) : i8
  %1 = llvm.mlir.constant(-5 : i8) : i8
  %2 = llvm.ashr %0, %arg146 : i8
  %3 = llvm.icmp "eq" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def scalar_i32_shl_and_signbit_eq_X_is_constant2_after := [llvm|
{
^0(%arg4 : i32):
  %0 = llvm.mlir.constant(31 : i32) : i32
  %1 = llvm.icmp "ne" %arg4, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def test88_after := [llvm|
{
^0(%arg57 : i16):
  %0 = llvm.mlir.constant(15 : i16) : i16
  %1 = llvm.ashr %arg57, %0 : i16
  "llvm.return"(%1) : (i16) -> ()
}
]

def fold_sext_to_and_wrong9_before := [llvm|
{
^0(%arg1 : i8):
  %0 = llvm.mlir.constant(128 : i32) : i32
  %1 = llvm.mlir.constant(1 : i32) : i32
  %2 = llvm.sext %arg1 : i8 to i32
  %3 = llvm.and %2, %0 : i32
  %4 = llvm.icmp "ne" %3, %1 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def src_before := [llvm|
{
^0(%arg0 : i1):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.zext %arg0 : i1 to i32
  %2 = llvm.shl %0, %1 : i32
  %3 = llvm.xor %2, %0 : i32
  %4 = llvm.and %3, %1 : i32
  %5 = llvm.shl %4, %1 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def ugt_and_not_min_after := [llvm|
{
^0(%arg78 : i8, %arg79 : i8):
  %0 = llvm.icmp "ugt" %arg78, %arg79 : i8
  "llvm.return"(%0) : (i1) -> ()
}
]

def main13_after := [llvm|
{
^0(%arg18 : i32):
  %0 = llvm.mlir.constant(32896 : i32) : i32
  %1 = llvm.mlir.constant(2 : i32) : i32
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.and %arg18, %0 : i32
  %4 = llvm.icmp "eq" %3, %0 : i32
  %5 = "llvm.select"(%4, %1, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def positive_sameconst_shlnsw_ashrexact_before := [llvm|
{
^0(%arg36 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.ashr exact %arg36, %0 : i8
  %2 = llvm.shl %1, %0 overflow<nsw> : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def binop_same_val_or : RISCVPeepholeRewrite [Ty.riscv (.bv)] where
  lhs := [LV| {
    ^entry (%x: !riscv.reg):
      %0 = or %x, %x : !riscv.reg
      ret %0 : !riscv.reg
  }]
  rhs := [LV| {
    ^entry (%x: !riscv.reg):
      ret %x : !riscv.reg
  }]

def trunc_sel_larger_zext_before := [llvm|
{
^0(%arg73 : i32, %arg74 : i1):
  %0 = llvm.mlir.constant(42 : i16) : i16
  %1 = llvm.trunc %arg73 : i32 to i16
  %2 = "llvm.select"(%arg74, %1, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i16, i16) -> i16
  %3 = llvm.zext %2 : i16 to i64
  "llvm.return"(%3) : (i64) -> ()
}
]

def test1_after := [llvm|
{
^0(%arg27 : i32, %arg28 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg28, %arg27 : i32
  %2 = llvm.icmp "sgt" %1, %0 : i32
  %3 = llvm.zext %2 : i1 to i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def select_match : List (Σ Γ, Σ ty, PeepholeRewrite LLVMPlusRiscV Γ ty) :=
  [⟨[Ty.llvm (.bitvec 64), Ty.llvm (.bitvec 64),Ty.llvm (.bitvec 1)],
   [Ty.llvm (.bitvec 64)],(LLVMToRiscvPeepholeRewriteRefine.toPeepholeUNSOUND select_riscv_select_llvm_64)⟩,
  ⟨[Ty.llvm (.bitvec 32), Ty.llvm (.bitvec 32),Ty.llvm (.bitvec 1)],
   [Ty.llvm (.bitvec 32)],(LLVMToRiscvPeepholeRewriteRefine.toPeepholeUNSOUND select_riscv_select_llvm_32)⟩,
   ⟨[Ty.llvm (.bitvec 8), Ty.llvm (.bitvec 8),Ty.llvm (.bitvec 1)],
   [Ty.llvm (.bitvec 8)],(LLVMToRiscvPeepholeRewriteRefine.toPeepholeUNSOUND select_riscv_select_llvm_8)⟩]

def or_xor_tree_0011_after := [llvm|
{
^0(%arg36 : i32, %arg37 : i32, %arg38 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mul %arg36, %0 : i32
  %2 = llvm.mul %arg37, %0 : i32
  %3 = llvm.mul %arg38, %0 : i32
  %4 = llvm.xor %2, %1 : i32
  %5 = llvm.or %4, %3 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def irc_constants_AMinusC1PlusC2_1_0 : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%a: i64):
      %c1 = llvm.mlir.constant (1) : i64
      %c2 = llvm.mlir.constant (0) : i64
      %0 = llvm.sub %a, %c1 : i64
      %1 = llvm.add %0, %c2 : i64
      llvm.return %1 : i64
  }]
  rhs := [LV| {
    ^entry (%a: i64):
      %c1 = llvm.mlir.constant (1) : i64
      %c2 = llvm.mlir.constant (0) : i64
      %0 = llvm.sub %c2, %c1 : i64
      %1 = llvm.add %a, %0 : i64
      llvm.return %1 : i64
  }]

def or_signbit_shl_before := [llvm|
{
^0(%arg21 : i32):
  %0 = llvm.mlir.constant(-65536 : i32) : i32
  %1 = llvm.mlir.constant(8 : i32) : i32
  %2 = llvm.or %arg21, %0 : i32
  %3 = llvm.shl %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def ashrsgt_01_13_exact_before := [llvm|
{
^0(%arg88 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(-3 : i4) : i4
  %2 = llvm.ashr exact %arg88, %0 : i4
  %3 = llvm.icmp "sgt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def n3_before := [llvm|
{
^0(%arg1 : i8, %arg2 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.shl %0, %arg2 : i8
  %2 = llvm.xor %1, %0 : i8
  %3 = llvm.icmp "ugt" %2, %arg1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def land_lor_right1_before := [llvm|
{
^0(%arg46 : i1, %arg47 : i1):
  %0 = llvm.mlir.constant(false) : i1
  %1 = llvm.mlir.constant(true) : i1
  %2 = "llvm.select"(%arg46, %arg47, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %3 = "llvm.select"(%arg46, %1, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def negNumToTerm : TSyntax ``neg_num → MacroM Term
  | `(neg_num| $x:num) => `($x:num)
  | `(neg_num| -$x:num) => `(-$x:num)
  | _ => Macro.throwUnsupported

structure Tensor2d' (α : Type) where
  dim₀ : Index
  dim₁ : Index
  mat : Matrix (Fin dim₀) (Fin dim₁) α

def isOpenBracket(c: Char): Option Bracket :=
match c with
| '(' => some .Round
| '[' => some .Square
| '{' => some .Curly
| '<' => some .Angle
| _ => none

def test_add_zero_lhs_LHS := [mod_arith q, hq| {
  ^bb0(%x : !R):
    %zero = mod_arith.constant 0 : !R
    %add = mod_arith.add %zero, %x : !R
    return %add : !R
}]

def test6_after := [llvm|
{
^0(%arg204 : i8):
  "llvm.return"(%arg204) : (i8) -> ()
}
]

def irc_constants_AMinusC1MinusC2_neg1_neg1 : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%a: i64):
      %c1 = llvm.mlir.constant (-1) : i64
      %c2 = llvm.mlir.constant (-1) : i64
      %0 = llvm.sub %a, %c1 : i64
      %1 = llvm.sub %0, %c2 : i64
      llvm.return %1 : i64
  }]
  rhs := [LV| {
    ^entry (%a: i64):
      %c1 = llvm.mlir.constant (-1) : i64
      %c2 = llvm.mlir.constant (-1) : i64
      %0 = llvm.add %c1, %c2 : i64
      %1 = llvm.sub %a, %0 : i64
      llvm.return %1 : i64
  }]

def or_and_xor_not_constant_commute1_before := [llvm|
{
^0(%arg166 : i9, %arg167 : i9):
  %0 = llvm.mlir.constant(42 : i9) : i9
  %1 = llvm.mlir.constant(-43 : i9) : i9
  %2 = llvm.xor %arg167, %arg166 : i9
  %3 = llvm.and %2, %0 : i9
  %4 = llvm.and %arg167, %1 : i9
  %5 = llvm.or %3, %4 : i9
  "llvm.return"(%5) : (i9) -> ()
}
]

def ule_or_min_logical_after := [llvm|
{
^0(%arg140 : i8, %arg141 : i8):
  %0 = llvm.icmp "ule" %arg140, %arg141 : i8
  "llvm.return"(%0) : (i1) -> ()
}
]

def test68_xor_before := [llvm|
{
^0(%arg162 : i32, %arg163 : i32):
  %0 = llvm.mlir.constant(128 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(2 : i32) : i32
  %3 = llvm.and %arg162, %0 : i32
  %4 = llvm.icmp "eq" %3, %1 : i32
  %5 = llvm.xor %arg163, %2 : i32
  %6 = "llvm.select"(%4, %arg163, %5) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def pr33078_3_before := [llvm|
{
^0(%arg3 : i8):
  %0 = llvm.mlir.constant(12 : i16) : i16
  %1 = llvm.sext %arg3 : i8 to i16
  %2 = llvm.lshr %1, %0 : i16
  %3 = llvm.trunc %2 : i16 to i4
  "llvm.return"(%3) : (i4) -> ()
}
]

def test3a_after := [llvm|
{
^0(%arg100 : i32):
  %0 = llvm.mlir.constant(7 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.and %arg100, %0 : i32
  %3 = llvm.icmp "ne" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def demorgan_nand_before := [llvm|
{
^0(%arg38 : i8, %arg39 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.xor %arg38, %0 : i8
  %2 = llvm.and %1, %arg39 : i8
  %3 = llvm.xor %2, %0 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

Lean.initSearchPath in Lean.Util.Path

DFA.toNFA in Mathlib.Computability.NFA

def two_inst_concrete_macro_proof :
    two_inst_concrete_macro ⊑ two_inst_concrete_macro :=

def xor_or_xor_common_op_commute8_before := [llvm|
{
^0(%arg59 : i32, %arg60 : i32, %arg61 : i32):
  %0 = llvm.xor %arg61, %arg59 : i32
  %1 = llvm.or %arg60, %arg59 : i32
  %2 = llvm.xor %1, %0 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def or_nand_xor_common_op_commute0_before := [llvm|
{
^0(%arg77 : i4, %arg78 : i4, %arg79 : i4):
  %0 = llvm.mlir.constant(-1 : i4) : i4
  %1 = llvm.and %arg77, %arg79 : i4
  %2 = llvm.xor %1, %0 : i4
  %3 = llvm.xor %arg77, %arg78 : i4
  %4 = llvm.or %2, %3 : i4
  "llvm.return"(%4) : (i4) -> ()
}
]

def test2_after := [llvm|
{
^0(%arg0 : i52, %arg1 : i52):
  %0 = llvm.icmp "ugt" %arg0, %arg1 : i52
  "llvm.return"(%0) : (i1) -> ()
}
]

def ashr_sge_exact_before := [llvm|
{
^0(%arg166 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.mlir.constant(10 : i8) : i8
  %2 = llvm.ashr exact %arg166, %0 : i8
  %3 = llvm.icmp "sge" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def lt_unsigned_to_large_unsigned_after := [llvm|
{
^0(%arg47 : i8):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def xor_or_xor_common_op_commute6_before := [llvm|
{
^0(%arg65 : i32, %arg66 : i32, %arg67 : i32):
  %0 = llvm.xor %arg67, %arg65 : i32
  %1 = llvm.or %arg65, %arg66 : i32
  %2 = llvm.xor %1, %0 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def masked_icmps_mask_notallzeros_bmask_mixed_negated_6_after := [llvm|
{
^0(%arg58 : i32):
  %0 = llvm.mlir.constant(15 : i32) : i32
  %1 = llvm.mlir.constant(8 : i32) : i32
  %2 = llvm.and %arg58, %0 : i32
  %3 = llvm.icmp "ne" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

@[simp_denote]
def slli_llvm_i64 := [LV| {
    ^entry (%a: i64):
    %0 = llvm.mlir.constant (7) : i64
    %1 = llvm.shl %a, %0 : i64
    llvm.return %1 : i64
  }]

def canonicalize_icmp_eq_1 : LLVMPeepholeRewriteRefine 1 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%x: i64):
      %c = llvm.mlir.constant 1 : i64
      %1 = llvm.icmp.eq %c, %x : i64
      llvm.return %1 : i1
  }]
  rhs := [LV| {
    ^entry (%x: i64):
      %c = llvm.mlir.constant 1 : i64
      %1 = llvm.icmp.eq %x, %c : i64
      llvm.return %1 : i1
  }]

def llvm_mul_lower_riscv_nsw_flag_32 : LLVMPeepholeRewriteRefine 32 [Ty.llvm (.bitvec 32), Ty.llvm (.bitvec 32)] where
  lhs := mul_llvm_nsw_32
  rhs := mul_riscv_32

def negative_not_less_than_logical_before := [llvm|
{
^0(%arg8 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.mlir.constant(256 : i32) : i32
  %2 = llvm.mlir.constant(false) : i1
  %3 = llvm.icmp "sgt" %arg8, %0 : i32
  %4 = llvm.add %arg8, %1 : i32
  %5 = llvm.icmp "ult" %4, %1 : i32
  %6 = "llvm.select"(%3, %5, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%6) : (i1) -> ()
}
]

def negate_add_with_single_negatible_operand_depth2_after := [llvm|
{
^0(%arg21 : i8, %arg22 : i8):
  %0 = llvm.mlir.constant(-21 : i8) : i8
  %1 = llvm.sub %0, %arg21 : i8
  %2 = llvm.mul %1, %arg22 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def test_nsw_dropped_before := [llvm|
{
^0(%arg6 : i32):
  %0 = llvm.mlir.constant(1073741823 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(2 : i32) : i32
  %3 = llvm.and %arg6, %0 : i32
  %4 = llvm.icmp "eq" %3, %1 : i32
  %5 = llvm.shl %arg6, %2 overflow<nsw> : i32
  %6 = "llvm.select"(%4, %1, %5) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%6) : (i32) -> ()
}
]

Prod.fst in Init.Prelude

def ashr_ult_7_after := [llvm|
{
^0(%arg89 : i4):
  %0 = llvm.mlir.constant(-1 : i4) : i4
  %1 = llvm.icmp "sgt" %arg89, %0 : i4
  "llvm.return"(%1) : (i1) -> ()
}
]

def lowmask_add_zext_wrong_mask_after := [llvm|
{
^0(%arg231 : i8, %arg232 : i32):
  %0 = llvm.mlir.constant(511 : i32) : i32
  %1 = llvm.zext %arg231 : i8 to i32
  %2 = llvm.add %arg232, %1 : i32
  %3 = llvm.and %2, %0 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def t2_before := [llvm|
{
^0(%arg25 : i8, %arg26 : i1, %arg27 : i1):
  %0 = llvm.sext %arg26 : i1 to i8
  %1 = llvm.sext %arg27 : i1 to i8
  %2 = llvm.add %0, %arg25 : i8
  %3 = llvm.xor %2, %1 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def zext_nneg_sext_sle_op0_narrow_before := [llvm|
{
^0(%arg50 : i8, %arg51 : i16):
  %0 = llvm.zext nneg %arg50 : i8 to i32
  %1 = llvm.sext %arg51 : i16 to i32
  %2 = llvm.icmp "sle" %0, %1 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def getBoolAttr (attr : String) : Except TransformError Bool := do
  let .bool b ← op.getAttr attr
    | .error <| .generic s!"Expected attribute `{attr}` to be of type Bool, but found:\n\
        \t{attr}"
  return b

@[reducible]
instance : DialectDenote Ex where
  denote
    | .cst n, _, _ => n ::ₕ .nil
    | .add, .cons (a : Nat) (.cons b .nil), _ => a + b ::ₕ .nil
    | .beq, .cons (a : Nat) (.cons b .nil), _ => (a == b) ::ₕ .nil

def scalar_i8_shl_uge_const_before := [llvm|
{
^0(%arg13 : i8):
  %0 = llvm.mlir.constant(5 : i8) : i8
  %1 = llvm.mlir.constant(64 : i8) : i8
  %2 = llvm.shl %arg13, %0 : i8
  %3 = llvm.icmp "uge" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def sub_not_after := [llvm|
{
^0(%arg22 : i8, %arg23 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.xor %arg22, %0 : i8
  %2 = llvm.add %arg23, %1 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def sge_smin4_after := [llvm|
{
^0(%arg73 : i32, %arg74 : i32):
  %0 = llvm.mlir.constant(3 : i32) : i32
  %1 = llvm.add %arg73, %0 : i32
  %2 = llvm.icmp "sge" %arg74, %1 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def is_rem32_pos_i8_before := [llvm|
{
^0(%arg55 : i8):
  %0 = llvm.mlir.constant(32 : i8) : i8
  %1 = llvm.mlir.constant(0 : i8) : i8
  %2 = llvm.srem %arg55, %0 : i8
  %3 = llvm.icmp "sgt" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def both_before := [llvm|
{
^0(%arg17 : i8, %arg18 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.shl %0, %arg17 : i8
  %2 = llvm.xor %1, %0 : i8
  %3 = llvm.shl %0, %arg18 : i8
  %4 = llvm.xor %3, %0 : i8
  %5 = llvm.icmp "ult" %2, %4 : i8
  "llvm.return"(%5) : (i1) -> ()
}
]

def test9_after := [llvm|
{
^0(%arg72 : i32):
  %0 = llvm.mlir.constant(42 : i8) : i8
  %1 = llvm.trunc %arg72 : i32 to i8
  %2 = llvm.and %1, %0 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def negative5_before := [llvm|
{
^0(%arg2 : i32, %arg3 : i32):
  %0 = llvm.mlir.constant(2147483647 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.and %arg3, %0 : i32
  %3 = llvm.icmp "slt" %arg2, %2 : i32
  %4 = llvm.icmp "sge" %arg2, %1 : i32
  %5 = llvm.or %3, %4 : i1
  "llvm.return"(%5) : (i1) -> ()
}
]

def elabDefSignatureFor (dialect : Term) (alts : TSyntax ``matchAltsSig) : CommandElabM Unit := do
  let msg := (return m!"{exceptEmoji ·} Defining operation signature for {dialect} dialect")
  withTraceNode `LeanMLIR.Elab msg (collapsed := false) <| do
    let alts := getMatchAlts alts
    let alts ← do
      alts.mapM fun view => do
        trace[LeanMLIR.Elab] m!"Parsing match alternative with\n\
          \tpatterns: {view.patterns}\n\
          \tsignature: {view.rhs}"
        let rhs ← parseSignature view.rhs
        return { view with rhs }

    |

def test_before := [llvm|
{
^0(%arg0 : i64):
  %0 = llvm.mlir.constant(4294967294) : i64
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.or %arg0, %0 : i64
  %3 = llvm.trunc %2 : i64 to i32
  %4 = llvm.srem %3, %1 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def ashr_lshr_exact_both_after := [llvm|
{
^0(%arg129 : i32, %arg130 : i32):
  %0 = llvm.ashr exact %arg129, %arg130 : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

def add_const_add_const_before := [llvm|
{
^0(%arg71 : i32):
  %0 = llvm.mlir.constant(8 : i32) : i32
  %1 = llvm.mlir.constant(2 : i32) : i32
  %2 = llvm.add %arg71, %0 : i32
  %3 = llvm.add %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def add_constant_equal_with_the_top_bit_of_demandedbits_insertpt_before := [llvm|
{
^0(%arg4 : i32, %arg5 : i32):
  %0 = llvm.mlir.constant(16 : i32) : i32
  %1 = llvm.mlir.constant(24 : i32) : i32
  %2 = llvm.add %arg4, %0 : i32
  %3 = llvm.or %2, %arg5 : i32
  %4 = llvm.and %3, %1 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def test2_after := [llvm|
{
^0(%arg31 : i32):
  %0 = llvm.mlir.constant(64 : i32) : i32
  %1 = llvm.icmp "ugt" %arg31, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def not? {w : Nat} (x : BitVec w) : IntW w := do
  .value (~~~x)

def select_add_after := [llvm|
{
^0(%arg15 : i1, %arg16 : i64, %arg17 : i64):
  %0 = llvm.mlir.constant(0) : i64
  %1 = "llvm.select"(%arg15, %arg17, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i64, i64) -> i64
  %2 = llvm.add %arg16, %1 : i64
  "llvm.return"(%2) : (i64) -> ()
}
]

def xor_of_icmps_after := [llvm|
{
^0(%arg31 : i64):
  %0 = llvm.mlir.constant(1) : i64
  %1 = llvm.icmp "sgt" %arg31, %0 : i64
  "llvm.return"(%1) : (i1) -> ()
}
]

def ashrsgt_02_11_exact_after := [llvm|
{
^0(%arg74 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def EnvFin.cons (env : EnvFin w n) (b : BitVec w) : EnvFin w (n + 1) :=
  fun i => i.cases b env

def test_shift_and_cmp_changed4_after := [llvm|
{
^0(%arg0 : i8):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def mul {w : Nat} (x y : IntW w) (flags : NoWrapFlags := {nsw := false , nuw := false}) : IntW w := do
  let x' ← x
  let y' ← y

  if flags.nsw ∧ BitVec.smulOverflow x' y' then
    .poison
  else if flags.nuw ∧ BitVec.umulOverflow x' y' then
    .poison
  else
    mul? x' y'

def PR42691_8_logical_after := [llvm|
{
^0(%arg328 : i32):
  %0 = llvm.mlir.constant(2147483647 : i32) : i32
  %1 = llvm.mlir.constant(-2147483635 : i32) : i32
  %2 = llvm.add %arg328, %0 : i32
  %3 = llvm.icmp "ult" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def shift_trunc_wrong_cmp_after := [llvm|
{
^0(%arg0 : i32):
  %0 = llvm.mlir.constant(24 : i32) : i32
  %1 = llvm.mlir.constant(1 : i8) : i8
  %2 = llvm.lshr %arg0, %0 : i32
  %3 = llvm.trunc %2 overflow<nuw> : i32 to i8
  %4 = llvm.icmp "slt" %3, %1 : i8
  "llvm.return"(%4) : (i1) -> ()
}
]

def scalar_i16_shl_ult_const_before := [llvm|
{
^0(%arg16 : i16):
  %0 = llvm.mlir.constant(8 : i16) : i16
  %1 = llvm.mlir.constant(1024 : i16) : i16
  %2 = llvm.shl %arg16, %0 : i16
  %3 = llvm.icmp "ult" %2, %1 : i16
  "llvm.return"(%3) : (i1) -> ()
}
]

def irc_constants_C2MinusAPlusC1_neg2_neg2 : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%a: i64):
      %c1 = llvm.mlir.constant (-2) : i64
      %c2 = llvm.mlir.constant (-2) : i64
      %0 = llvm.add %a, %c1 : i64
      %1 = llvm.sub %c2, %0 : i64
      llvm.return %1 : i64
  }]
  rhs := [LV| {
    ^entry (%a: i64):
      %c1 = llvm.mlir.constant (-2) : i64
      %c2 = llvm.mlir.constant (-2) : i64
      %0 = llvm.sub %c2, %c1 : i64
      %1 = llvm.sub %0, %a : i64
      llvm.return %1 : i64
  }]

def positive_biggerLshr_after := [llvm|
{
^0(%arg33 : i32):
  %0 = llvm.mlir.constant(5 : i32) : i32
  %1 = llvm.mlir.constant(4194303 : i32) : i32
  %2 = llvm.lshr %arg33, %0 : i32
  %3 = llvm.and %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def Context (Ty : Type) : Type :=
  List (VarName × Ty)

def main4c_logical_before := [llvm|
{
^0(%arg123 : i32):
  %0 = llvm.mlir.constant(7 : i32) : i32
  %1 = llvm.mlir.constant(48 : i32) : i32
  %2 = llvm.mlir.constant(true) : i1
  %3 = llvm.mlir.constant(0 : i32) : i32
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.and %arg123, %0 : i32
  %6 = llvm.icmp "ne" %5, %0 : i32
  %7 = llvm.and %arg123, %1 : i32
  %8 = llvm.icmp "ne" %7, %1 : i32
  %9 = "llvm.select"(%6, %2, %8) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %10 = "llvm.select"(%9, %3, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%10) : (i32) -> ()
}
]

def test13_before := [llvm|
{
^0(%arg44 : i32, %arg45 : i32):
  %0 = llvm.mlir.constant(-1431655767 : i32) : i32
  %1 = llvm.mlir.constant(1431655766 : i32) : i32
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.or %arg44, %0 : i32
  %4 = llvm.xor %3, %1 : i32
  %5 = llvm.add %arg45, %2 : i32
  %6 = llvm.add %5, %4 : i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def lshrult_03_14_before := [llvm|
{
^0(%arg321 : i4):
  %0 = llvm.mlir.constant(3 : i4) : i4
  %1 = llvm.mlir.constant(-2 : i4) : i4
  %2 = llvm.lshr %arg321, %0 : i4
  %3 = llvm.icmp "ult" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def negate_lshr_after := [llvm|
{
^0(%arg108 : i8, %arg109 : i8):
  %0 = llvm.mlir.constant(7 : i8) : i8
  %1 = llvm.ashr %arg109, %0 : i8
  %2 = llvm.add %1, %arg108 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def not_and_and_or_no_or_commute2_before := [llvm|
{
^0(%arg151 : i32, %arg152 : i32, %arg153 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.sdiv %0, %arg152 : i32
  %3 = llvm.or %2, %arg151 : i32
  %4 = llvm.xor %3, %1 : i32
  %5 = llvm.xor %arg151, %1 : i32
  %6 = llvm.and %2, %5 : i32
  %7 = llvm.and %6, %arg153 : i32
  %8 = llvm.or %7, %4 : i32
  "llvm.return"(%8) : (i32) -> ()
}
]

def icmp_eq_and_pow2_shl_pow2_negative2_before := [llvm|
{
^0(%arg60 : i32):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.mlir.constant(14 : i32) : i32
  %2 = llvm.mlir.constant(0 : i32) : i32
  %3 = llvm.shl %0, %arg60 : i32
  %4 = llvm.and %3, %1 : i32
  %5 = llvm.icmp "eq" %4, %2 : i32
  %6 = llvm.zext %5 : i1 to i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def select_same_val : List (Σ Γ, LLVMPeepholeRewriteRefine 64  Γ) :=
  [⟨_, select_same_val_self⟩]

def slt_swap_and_not_max_logical_before := [llvm|
{
^0(%arg116 : i8, %arg117 : i8):
  %0 = llvm.mlir.constant(127 : i8) : i8
  %1 = llvm.mlir.constant(false) : i1
  %2 = llvm.icmp "sgt" %arg117, %arg116 : i8
  %3 = llvm.icmp "ne" %arg116, %0 : i8
  %4 = "llvm.select"(%2, %3, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def t0_after := [llvm|
{
^0(%arg23 : i32, %arg24 : i16):
  %0 = llvm.mlir.constant(8 : i16) : i16
  %1 = llvm.trunc %arg23 : i32 to i16
  %2 = llvm.shl %1, %0 : i16
  "llvm.return"(%2) : (i16) -> ()
}
]

def ashrsgt_03_09_after := [llvm|
{
^0(%arg276 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

Fin.succRecOn in Init.Data.Fin.Lemmas

def BinaryRelationKind.toSmtLib : BinaryRelationKind → SexprPBV.BinaryRelationKind
| .eq => .eq
| .ne => .ne
| .ule => .ule
| .slt => .slt
| .sle => .sle
| .ult => .ult

def reduce_xor_common_op_commute0_before := [llvm|
{
^0(%arg10 : i4, %arg11 : i4, %arg12 : i4):
  %0 = llvm.xor %arg10, %arg11 : i4
  %1 = llvm.xor %0, %arg12 : i4
  %2 = llvm.or %1, %arg10 : i4
  "llvm.return"(%2) : (i4) -> ()
}
]

def sub_mask1_lshr_after := [llvm|
{
^0(%arg21 : i8):
  %0 = llvm.mlir.constant(6 : i8) : i8
  %1 = llvm.mlir.constant(7 : i8) : i8
  %2 = llvm.mlir.constant(10 : i8) : i8
  %3 = llvm.shl %arg21, %0 : i8
  %4 = llvm.ashr %3, %1 : i8
  %5 = llvm.add %4, %2 overflow<nsw> : i8
  "llvm.return"(%5) : (i8) -> ()
}
]

instance : Coe (Γ.Var t) ((Γ ++ ts).Var t) where coe := appendInl

def ashrsgt_02_01_before := [llvm|
{
^0(%arg300 : i4):
  %0 = llvm.mlir.constant(2 : i4) : i4
  %1 = llvm.mlir.constant(1 : i4) : i4
  %2 = llvm.ashr %arg300, %0 : i4
  %3 = llvm.icmp "sgt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def n1_before := [llvm|
{
^0(%arg3 : i8):
  %0 = llvm.mlir.constant(5 : i8) : i8
  %1 = llvm.shl %arg3, %0 : i8
  %2 = llvm.lshr exact %1, %0 : i8
  %3 = llvm.icmp "ne" %2, %arg3 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def test82_before := [llvm|
{
^0(%arg64 : i64):
  %0 = llvm.mlir.constant(8 : i32) : i32
  %1 = llvm.mlir.constant(9 : i32) : i32
  %2 = llvm.trunc %arg64 : i64 to i32
  %3 = llvm.lshr %2, %0 : i32
  %4 = llvm.shl %3, %1 : i32
  %5 = llvm.zext %4 : i32 to i64
  "llvm.return"(%5) : (i64) -> ()
}
]

def test15_after := [llvm|
{
^0(%arg44 : i8, %arg45 : i8):
  %0 = llvm.mlir.constant(33 : i8) : i8
  %1 = llvm.xor %arg45, %arg44 : i8
  %2 = llvm.xor %arg44, %arg45 : i8
  %3 = llvm.xor %2, %0 : i8
  %4 = llvm.and %1, %3 : i8
  %5 = llvm.mul %4, %3 : i8
  "llvm.return"(%5) : (i8) -> ()
}
]

def lshrugt_01_15_exact_after := [llvm|
{
^0(%arg206 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def or_xor_and_commuted2_after := [llvm|
{
^0(%arg48 : i32, %arg49 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.mul %arg49, %arg49 : i32
  %2 = llvm.mul %arg48, %arg48 : i32
  %3 = llvm.xor %2, %0 : i32
  %4 = llvm.or %1, %3 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def splat_mul_unknown_lz_before := [llvm|
{
^0(%arg71 : i32):
  %0 = llvm.mlir.constant(18446744078004518913 : i128) : i128
  %1 = llvm.mlir.constant(95 : i128) : i128
  %2 = llvm.mlir.constant(0 : i128) : i128
  %3 = llvm.zext %arg71 : i32 to i128
  %4 = llvm.mul %3, %0 : i128
  %5 = llvm.lshr %4, %1 : i128
  %6 = llvm.icmp "eq" %5, %2 : i128
  "llvm.return"(%6) : (i1) -> ()
}
]

def nomask_lhs_logical_before := [llvm|
{
^0(%arg114 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.mlir.constant(1 : i32) : i32
  %2 = llvm.mlir.constant(true) : i1
  %3 = llvm.icmp "eq" %arg114, %0 : i32
  %4 = llvm.and %arg114, %1 : i32
  %5 = llvm.icmp "eq" %4, %0 : i32
  %6 = "llvm.select"(%3, %2, %5) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%6) : (i1) -> ()
}
]

def TermUnop.openTerm (op : TermUnop) : Term :=
  match op with
  | .neg => .neg (.var 0)
  | .not => .not (.var 0)
  | .shiftL k => .shiftL (.var 0) k

@[simp_denote]
def sdiv_llvm_no_exact_64 := [LV| {
  ^entry (%x: i64, %y: i64):
    %1 = llvm.sdiv %x, %y : i64
    llvm.return %1 : i64
  }]

def Pointer.offsetInBits (p : Pointer) : Nat :=
  8 * p.offset.toNat

def visitSUB_APlusBPlusCNegB : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64), Ty.llvm (.bitvec 64), Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%a: i64, %b: i64, %c: i64):
      %0 = llvm.add %b, %c : i64
      %1 = llvm.add %a, %0 : i64
      %2 = llvm.sub %1, %b : i64
      llvm.return %2 : i64
  }]
  rhs := [LV| {
    ^entry (%a: i64, %b: i64, %c: i64):
      %0 = llvm.add %a, %c : i64
      llvm.return %0 : i64
  }]

def t4_commutative_before := [llvm|
{
^0(%arg22 : i8, %arg23 : i8):
  %0 = llvm.add %arg22, %arg23 : i8
  %1 = llvm.icmp "ugt" %arg23, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def RawCNFA.transBV (m : RawCNFA A) (s : m.states) (a : A) : BitVec m.stateMax :=
  let ts := m.trans.getD (s, a) ∅
  BitVec.ofFn (fun n => n ∈ ts)

def rem_euclid_pow2_false_arm_folded_before := [llvm|
{
^0(%arg2 : i32):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.srem %arg2, %0 : i32
  %4 = llvm.icmp "sge" %3, %1 : i32
  %5 = "llvm.select"(%4, %3, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def add_select_zext_before := [llvm|
{
^0(%arg29 : i1):
  %0 = llvm.mlir.constant(64) : i64
  %1 = llvm.mlir.constant(1) : i64
  %2 = "llvm.select"(%arg29, %0, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i64, i64) -> i64
  %3 = llvm.zext %arg29 : i1 to i64
  %4 = llvm.add %2, %3 : i64
  "llvm.return"(%4) : (i64) -> ()
}
]

private def mkElab (ext : NameExt) (ty : Lean.Expr) : Elab.Term.TermElabM Lean.Expr := do
  let mut stx := #[]
  for (_, n4) in ext.getState (← getEnv) do
    stx := stx.push $ ← `($(mkIdent n4):ident)
  let listStx := (← `([$stx,*]))
  let list ← `($listStx)
  Elab.Term.elabTerm list (some ty)

def test20_before := [llvm|
{
^0(%arg148 : i32, %arg149 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg149, %0 : i32
  %2 = llvm.xor %arg148, %0 : i32
  %3 = llvm.or %arg148, %arg149 : i32
  %4 = llvm.or %1, %2 : i32
  %5 = llvm.xor %3, %4 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def lshr_and_add_fail_after := [llvm|
{
^0(%arg94 : i8, %arg95 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.mlir.constant(123 : i8) : i8
  %2 = llvm.lshr %arg94, %0 : i8
  %3 = llvm.lshr %arg95, %0 : i8
  %4 = llvm.and %3, %1 : i8
  %5 = llvm.add %2, %4 overflow<nuw> : i8
  "llvm.return"(%5) : (i8) -> ()
}
]

def xor_of_icmps_before := [llvm|
{
^0(%arg31 : i64):
  %0 = llvm.mlir.constant(0) : i64
  %1 = llvm.mlir.constant(1) : i64
  %2 = llvm.icmp "sgt" %arg31, %0 : i64
  %3 = llvm.icmp "eq" %arg31, %1 : i64
  %4 = llvm.xor %3, %2 : i1
  "llvm.return"(%4) : (i1) -> ()
}
]

@[match_pattern] abbrev lshr (w : Nat) (flag : ExactFlag := {} ) : LLVM.Op := MOp.lshr (.concrete w) flag

def srem2_ashr_mask_before := [llvm|
{
^0(%arg6 : i32):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.mlir.constant(31 : i32) : i32
  %2 = llvm.srem %arg6, %0 : i32
  %3 = llvm.ashr %2, %1 : i32
  %4 = llvm.and %3, %0 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def test1_before := [llvm|
{
^0(%arg232 : i32, %arg233 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.or %arg232, %arg233 : i32
  %2 = llvm.xor %1, %0 : i32
  %3 = llvm.or %arg232, %2 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def tryFactorization_add_nuw_mul_nuw_mul_nuw_var_after := [llvm|
{
^0(%arg9 : i32, %arg10 : i32, %arg11 : i32):
  %0 = llvm.add %arg10, %arg11 : i32
  %1 = llvm.mul %arg9, %0 overflow<nuw> : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

@[match_pattern] def sdiv (w : Width φ)
  (ExactFlag : ExactFlag := {exact := false} ) : MOp φ
    := .binary w (.sdiv ExactFlag )

def ashr_lshr_no_ashr_after := [llvm|
{
^0(%arg75 : i32, %arg76 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.lshr %arg75, %arg76 : i32
  %2 = llvm.xor %arg75, %arg76 : i32
  %3 = llvm.icmp "slt" %arg75, %0 : i32
  %4 = "llvm.select"(%3, %2, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def icmp_and_ashr_multiuse_logical_after := [llvm|
{
^0(%arg4 : i32):
  %0 = llvm.mlir.constant(240 : i32) : i32
  %1 = llvm.mlir.constant(224 : i32) : i32
  %2 = llvm.mlir.constant(496 : i32) : i32
  %3 = llvm.mlir.constant(432 : i32) : i32
  %4 = llvm.and %arg4, %0 : i32
  %5 = llvm.icmp "ne" %4, %1 : i32
  %6 = llvm.and %arg4, %2 : i32
  %7 = llvm.icmp "ne" %6, %3 : i32
  %8 = llvm.and %5, %7 : i1
  "llvm.return"(%8) : (i1) -> ()
}
]

def test67_after := [llvm|
{
^0(%arg38 : i16):
  %0 = llvm.mlir.constant(4 : i16) : i16
  %1 = llvm.mlir.constant(0 : i16) : i16
  %2 = llvm.mlir.constant(42 : i32) : i32
  %3 = llvm.mlir.constant(40 : i32) : i32
  %4 = llvm.and %arg38, %0 : i16
  %5 = llvm.icmp "eq" %4, %1 : i16
  %6 = "llvm.select"(%5, %2, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%6) : (i32) -> ()
}
]

@[reducible]
instance : DialectDenote Ex where
  denote
    | .cst n, _, _ => n ::ₕ .nil
    | .add, (a : Nat) ::ₕ b ::ₕ .nil, _ => a + b    ::ₕ .nil
    | .beq, (a : Nat) ::ₕ b ::ₕ .nil, _ => (a == b) ::ₕ .nil

def NFA.msbSA (q : msbState) : Language (BitVec 1) :=
  match q with
  | .i => ⊤
  | .f => msbLang

def llvm_or_lower_riscv_noflag_64 : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64), Ty.llvm (.bitvec 64)] where
  lhs := or_llvm_noflag_64
  rhs := or_riscv_64

def positive_sameconst_shlnsw_lshrexact_before := [llvm|
{
^0(%arg36 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.lshr exact %arg36, %0 : i8
  %2 = llvm.shl %1, %0 overflow<nsw> : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def sub_ashr_or_i8_after := [llvm|
{
^0(%arg39 : i8, %arg40 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.icmp "slt" %arg40, %arg39 : i8
  %2 = "llvm.select"(%1, %0, %arg39) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def positive_with_extra_and_logical_before := [llvm|
{
^0(%arg51 : i32, %arg52 : i1):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.mlir.constant(128 : i32) : i32
  %2 = llvm.mlir.constant(256 : i32) : i32
  %3 = llvm.mlir.constant(false) : i1
  %4 = llvm.icmp "sgt" %arg51, %0 : i32
  %5 = llvm.add %arg51, %1 : i32
  %6 = llvm.icmp "ult" %5, %2 : i32
  %7 = "llvm.select"(%4, %arg52, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %8 = "llvm.select"(%6, %7, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%8) : (i1) -> ()
}
]

def rewritePeepholeRecursively (fuel : ℕ)
    (pr : PeepholeRewrite d Γ t) (target : Com d Γ₂ eff t₂) :
    { out : Com d Γ₂ eff t₂ // out.denote = target.denote } :=
  match fuel with
  | 0 => ⟨target, rfl⟩
  | fuel + 1 =>
    let target' := rewritePeephole fuel pr target
    have htarget'_denote_eq_htarget : target'.denote = target.denote := by admit /- proof elided -/

def scalar_i8_shl_and_negC_eq_before := [llvm|
{
^0(%arg35 : i8, %arg36 : i8):
  %0 = llvm.mlir.constant(-4 : i8) : i8
  %1 = llvm.mlir.constant(0 : i8) : i8
  %2 = llvm.shl %arg35, %arg36 : i8
  %3 = llvm.and %2, %0 : i8
  %4 = llvm.icmp "eq" %3, %1 : i8
  "llvm.return"(%4) : (i1) -> ()
}
]

def masked_icmps_mask_notallzeros_bmask_mixed_negated_swapped_0_logical_after := [llvm|
{
^0(%arg29 : i32):
  %0 = llvm.mlir.constant(12 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(3 : i32) : i32
  %3 = llvm.mlir.constant(1 : i32) : i32
  %4 = llvm.and %arg29, %0 : i32
  %5 = llvm.icmp "eq" %4, %1 : i32
  %6 = llvm.and %arg29, %2 : i32
  %7 = llvm.icmp "ne" %6, %3 : i32
  %8 = llvm.or %7, %5 : i1
  "llvm.return"(%8) : (i1) -> ()
}
]

def basic_after := [llvm|
{
^0(%arg25 : i8, %arg26 : i8):
  %0 = llvm.sub %arg25, %arg26 : i8
  "llvm.return"(%0) : (i8) -> ()
}
]

def shl_add_nsw_nuw_before := [llvm|
{
^0(%arg23 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.shl %0, %arg23 : i32
  %3 = llvm.add %2, %1 overflow<nsw,nuw> : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def lshrult_01_02_before := [llvm|
{
^0(%arg365 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(2 : i4) : i4
  %2 = llvm.lshr %arg365, %0 : i4
  %3 = llvm.icmp "ult" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def positive_with_signbit_logical_after := [llvm|
{
^0(%arg61 : i32):
  %0 = llvm.mlir.constant(128 : i32) : i32
  %1 = llvm.icmp "ult" %arg61, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def ashr_ule_exact_after := [llvm|
{
^0(%arg168 : i8):
  %0 = llvm.mlir.constant(88 : i8) : i8
  %1 = llvm.icmp "ult" %arg168, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

@[simp_denote]
def and_riscv_i64 :=
  [LV| {
    ^entry (%arg0: i64, %arg1: i64):
    %a = "builtin.unrealized_conversion_cast" (%arg0) : (i64) -> (!i64)
    %b = "builtin.unrealized_conversion_cast" (%arg1) : (i64) -> (!i64)
    %0 = and %a, %b : !i64
    %1 = "builtin.unrealized_conversion_cast" (%0) : (!i64) -> (i64)
    llvm.return %1 : i64
  }]

RV64.clz in RISCV.Instructions

def slt_and_not_max_logical_after := [llvm|
{
^0(%arg124 : i8, %arg125 : i8):
  %0 = llvm.icmp "slt" %arg124, %arg125 : i8
  "llvm.return"(%0) : (i1) -> ()
}
]

def canonicalize_icmp_ne_neg3 : LLVMPeepholeRewriteRefine 1 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%x: i64):
      %c = llvm.mlir.constant -3 : i64
      %1 = llvm.icmp.ne %c, %x : i64
      llvm.return %1 : i1
  }]
  rhs := [LV| {
    ^entry (%x: i64):
      %c = llvm.mlir.constant -3 : i64
      %1 = llvm.icmp.ne %x, %c : i64
      llvm.return %1 : i1
  }]

def test0_after := [llvm|
{
^0(%arg3 : i32):
  %0 = llvm.mlir.constant(-1431655766 : i32) : i32
  %1 = llvm.and %arg3, %0 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def uge_swap_and_max_logical_before := [llvm|
{
^0(%arg228 : i8, %arg229 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.mlir.constant(false) : i1
  %2 = llvm.icmp "ule" %arg229, %arg228 : i8
  %3 = llvm.icmp "eq" %arg228, %0 : i8
  %4 = "llvm.select"(%2, %3, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def test_lshr_exact__exact_is_safe_after := [llvm|
{
^0(%arg62 : i32, %arg63 : i64):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.mlir.constant(15 : i32) : i32
  %2 = llvm.lshr %arg62, %0 : i32
  %3 = llvm.and %2, %1 : i32
  %4 = llvm.zext nneg %3 : i32 to i64
  %5 = llvm.ashr %arg63, %4 : i64
  "llvm.return"(%5) : (i64) -> ()
}
]

Function.RightInverse in Init.Data.Function

def flip_add_of_shift_neg_after := [llvm|
{
^0(%arg12 : i8, %arg13 : i8, %arg14 : i8):
  %0 = llvm.shl %arg12, %arg13 : i8
  %1 = llvm.sub %arg14, %0 : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

HDiv.hDiv in Init.Prelude

def trunc_shl_31_i32_i64_before := [llvm|
{
^0(%arg43 : i64):
  %0 = llvm.mlir.constant(31) : i64
  %1 = llvm.shl %arg43, %0 : i64
  %2 = llvm.trunc %1 : i64 to i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def PR39793_bswap_u32_as_u16_trunc_after := [llvm|
{
^0(%arg24 : i32):
  %0 = llvm.mlir.constant(8 : i32) : i32
  %1 = llvm.lshr %arg24, %0 : i32
  %2 = llvm.trunc %1 : i32 to i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def eval (assign : Std.HashMap Nat BVExpr.PackedBitVec) : FpPredicate → Bool
  | bin lhs op rhs =>
    match op with
    | .eq => (lhs.eval assign) = (rhs.eval assign)

PartialOrder in Mathlib.Order.Defs.PartialOrder

def ne_commuted_equal_minus_1_before := [llvm|
{
^0(%arg0 : i8, %arg1 : i8):
  %0 = llvm.mlir.constant(42 : i8) : i8
  %1 = llvm.mlir.constant(1 : i8) : i8
  %2 = llvm.mlir.constant(-1 : i8) : i8
  %3 = llvm.sdiv %0, %arg1 : i8
  %4 = llvm.add %arg0, %1 : i8
  %5 = llvm.icmp "ne" %arg0, %2 : i8
  %6 = llvm.icmp "uge" %3, %4 : i8
  %7 = llvm.and %5, %6 : i1
  "llvm.return"(%7) : (i1) -> ()
}
]

instance : Inhabited (
  {lets : Lets d Γstart .pure Γ} →
  State d lets →
  (com: Com d Γ .pure α) →
  { com' : Com d Γ .pure α // ∀ (V: Ctxt.Valuation Γ), com.denote V = com'.denote V }) where
  default := fun _s com => ⟨com, by admit /- proof elided -/
  ⟩

def a_false_implies_b_true_after := [llvm|
{
^0(%arg15 : i8, %arg16 : i1, %arg17 : i1):
  %0 = llvm.mlir.constant(10 : i8) : i8
  %1 = llvm.mlir.constant(true) : i1
  %2 = llvm.icmp "ugt" %arg15, %0 : i8
  %3 = "llvm.select"(%2, %1, %arg16) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def bools_logical_commute0_and2_after := [llvm|
{
^0(%arg102 : i1, %arg103 : i1, %arg104 : i1):
  %0 = "llvm.select"(%arg104, %arg103, %arg102) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def ashrsgt_02_14_exact_after := [llvm|
{
^0(%arg71 : i4):
  %0 = llvm.mlir.constant(-8 : i4) : i4
  %1 = llvm.icmp "ne" %arg71, %0 : i4
  "llvm.return"(%1) : (i1) -> ()
}
]

Lean.ofReduceBool in Init.Core

inductive Region
  | mk (entry : BasicBlock) (blocks : List BasicBlock)

def lshrult_01_11_after := [llvm|
{
^0(%arg356 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def mul_selectp2_x_after := [llvm|
{
^0(%arg22 : i8, %arg23 : i1):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.mlir.constant(2 : i8) : i8
  %2 = "llvm.select"(%arg23, %0, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  %3 = llvm.shl %arg22, %2 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def main5_like_logical_before := [llvm|
{
^0(%arg111 : i32, %arg112 : i32):
  %0 = llvm.mlir.constant(7 : i32) : i32
  %1 = llvm.mlir.constant(false) : i1
  %2 = llvm.mlir.constant(0 : i32) : i32
  %3 = llvm.mlir.constant(1 : i32) : i32
  %4 = llvm.and %arg111, %0 : i32
  %5 = llvm.icmp "eq" %4, %0 : i32
  %6 = llvm.and %arg112, %0 : i32
  %7 = llvm.icmp "eq" %6, %0 : i32
  %8 = "llvm.select"(%5, %7, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %9 = "llvm.select"(%8, %2, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%9) : (i32) -> ()
}
]

def shl_nsw_add_nsw_nuw_before := [llvm|
{
^0(%arg19 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.shl %0, %arg19 overflow<nsw> : i32
  %3 = llvm.add %2, %1 overflow<nsw,nuw> : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def lshrult_01_06_exact_after := [llvm|
{
^0(%arg143 : i4):
  %0 = llvm.mlir.constant(-4 : i4) : i4
  %1 = llvm.icmp "ult" %arg143, %0 : i4
  "llvm.return"(%1) : (i1) -> ()
}
]

Sigma in Init.Core

def icmp_slt_0_and_icmp_ne_neg2_i32_fail_after := [llvm|
{
^0(%arg44 : i32):
  %0 = llvm.mlir.constant(-2 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.icmp "ne" %arg44, %0 : i32
  %3 = llvm.icmp "slt" %arg44, %1 : i32
  %4 = llvm.and %3, %2 : i1
  %5 = llvm.zext %4 : i1 to i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def select_icmp_ne_0_and_32_xor_4096_after := [llvm|
{
^0(%arg199 : i32, %arg200 : i32):
  %0 = llvm.mlir.constant(7 : i32) : i32
  %1 = llvm.mlir.constant(4096 : i32) : i32
  %2 = llvm.shl %arg199, %0 : i32
  %3 = llvm.and %2, %1 : i32
  %4 = llvm.xor %3, %arg200 : i32
  %5 = llvm.xor %4, %1 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def IsGoodTermBoolFSM_mkTermFSM (wcard tcard bcard ncard icard pcard : Nat) {tctx : Term.Ctx wcard tcard}
    (t : Term bcard ncard icard pcard tctx .bool) :
    (HTermBoolFSMToBitStream (mkTermFSM wcard tcard bcard ncard icard pcard (.ofDepTerm t))) :=

@[inline]
def CNFA.proj (m: CNFA n2) (f : Fin n1 → Fin n2) : CNFA n1 :=
  ⟨m.m.proj f, m.m.proj_wf m.wf⟩

def test_with_neg_5_after := [llvm|
{
^0(%arg314 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.icmp "eq" %arg314, %0 : i32
  %2 = llvm.zext %1 : i1 to i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def t22_sign_check_before := [llvm|
{
^0(%arg12 : i32, %arg13 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.icmp "slt" %arg12, %0 : i32
  %3 = "llvm.select"(%2, %1, %arg13) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def scalar_i32_shl_and_negC_slt_before := [llvm|
{
^0(%arg2 : i32, %arg3 : i32):
  %0 = llvm.mlir.constant(-8 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.shl %arg2, %arg3 : i32
  %3 = llvm.and %2, %0 : i32
  %4 = llvm.icmp "slt" %3, %1 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def PR42691_2_after := [llvm|
{
^0(%arg341 : i32):
  %0 = llvm.mlir.constant(-2 : i32) : i32
  %1 = llvm.icmp "sgt" %arg341, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def add_umin_constant_limit_before := [llvm|
{
^0(%arg55 : i32):
  %0 = llvm.mlir.constant(41 : i32) : i32
  %1 = llvm.mlir.constant(42 : i32) : i32
  %2 = llvm.add %arg55, %0 overflow<nuw> : i32
  %3 = llvm.icmp "ult" %2, %1 : i32
  %4 = "llvm.select"(%3, %2, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%4) : (i32) -> ()
}
]

@[simp_denote]
def sext_riscv_i8_to_i16 := [LV| {
  ^entry (%arg: i8):
    %0 = "builtin.unrealized_conversion_cast"(%arg) : (i8) -> (!i64)
    %1 = sext.b %0 : !i64
    %res = "builtin.unrealized_conversion_cast"(%1) : (!i64) -> (i16)
    llvm.return %res : i16
  }]

def or_eq_with_one_bit_diff_constants2_after := [llvm|
{
^0(%arg362 : i32):
  %0 = llvm.mlir.constant(-33 : i32) : i32
  %1 = llvm.mlir.constant(65 : i32) : i32
  %2 = llvm.and %arg362, %0 : i32
  %3 = llvm.icmp "eq" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

RV64.divu in RISCV.Instructions

def masked_icmps_mask_notallzeros_bmask_mixed_5_after := [llvm|
{
^0(%arg82 : i32):
  %0 = llvm.mlir.constant(15 : i32) : i32
  %1 = llvm.mlir.constant(8 : i32) : i32
  %2 = llvm.and %arg82, %0 : i32
  %3 = llvm.icmp "eq" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def bw (w : Nat) (x : BitVec v) : BitVec w := x.signExtend w

def positive_samevar_after := [llvm|
{
^0(%arg62 : i8, %arg63 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.shl %0, %arg63 overflow<nsw> : i8
  %2 = llvm.and %1, %arg62 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def t7_after := [llvm|
{
^0(%arg209 : i32):
  %0 = llvm.mlir.constant(4 : i32) : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

def irc_constants_AMinusC1MinusC2_neg2_1 : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%a: i64):
      %c1 = llvm.mlir.constant (-2) : i64
      %c2 = llvm.mlir.constant (1) : i64
      %0 = llvm.sub %a, %c1 : i64
      %1 = llvm.sub %0, %c2 : i64
      llvm.return %1 : i64
  }]
  rhs := [LV| {
    ^entry (%a: i64):
      %c1 = llvm.mlir.constant (-2) : i64
      %c2 = llvm.mlir.constant (1) : i64
      %0 = llvm.add %c1, %c2 : i64
      %1 = llvm.sub %a, %0 : i64
      llvm.return %1 : i64
  }]

def ashrsgt_02_07_before := [llvm|
{
^0(%arg294 : i4):
  %0 = llvm.mlir.constant(2 : i4) : i4
  %1 = llvm.mlir.constant(7 : i4) : i4
  %2 = llvm.ashr %arg294, %0 : i4
  %3 = llvm.icmp "sgt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def or_not_and_wrong_c_after := [llvm|
{
^0(%arg488 : i32, %arg489 : i32, %arg490 : i32, %arg491 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.or %arg488, %arg489 : i32
  %2 = llvm.xor %1, %0 : i32
  %3 = llvm.and %arg490, %2 : i32
  %4 = llvm.or %arg488, %arg491 : i32
  %5 = llvm.xor %4, %0 : i32
  %6 = llvm.and %arg489, %5 : i32
  %7 = llvm.or %3, %6 : i32
  "llvm.return"(%7) : (i32) -> ()
}
]

def ashrsgt_03_00_exact_before := [llvm|
{
^0(%arg69 : i4):
  %0 = llvm.mlir.constant(3 : i4) : i4
  %1 = llvm.mlir.constant(0 : i4) : i4
  %2 = llvm.ashr exact %arg69, %0 : i4
  %3 = llvm.icmp "sgt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def ashrslt_01_07_before := [llvm|
{
^0(%arg262 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(7 : i4) : i4
  %2 = llvm.ashr %arg262, %0 : i4
  %3 = llvm.icmp "slt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def IntToString (i: Int): String := i.repr

def lshrugt_03_07_exact_after := [llvm|
{
^0(%arg182 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def udiv_common_divisor_before := [llvm|
{
^0(%arg65 : i1, %arg66 : i5, %arg67 : i5, %arg68 : i5):
  %0 = llvm.udiv %arg67, %arg66 : i5
  %1 = llvm.udiv %arg68, %arg66 : i5
  %2 = "llvm.select"(%arg65, %1, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i5, i5) -> i5
  "llvm.return"(%2) : (i5) -> ()
}
]

def test4_before := [llvm|
{
^0(%arg206 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %0, %arg206 : i32
  %2 = llvm.xor %arg206, %1 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def test15_before := [llvm|
{
^0(%arg172 : i32, %arg173 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg173, %0 : i32
  %2 = llvm.xor %arg172, %0 : i32
  %3 = llvm.and %arg172, %1 : i32
  %4 = llvm.and %2, %arg173 : i32
  %5 = llvm.xor %3, %4 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def test42_after := [llvm|
{
^0(%arg208 : i32, %arg209 : i32, %arg210 : i32):
  %0 = llvm.mul %arg209, %arg210 : i32
  %1 = llvm.and %0, %arg208 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

inductive Scf.Op (Op' Ty' : Type) (m') [TyDenote Ty'] [DialectSignature ⟨Op', Ty', m'⟩]
    [DialectDenote ⟨Op', Ty', m'⟩] : Type _
  | coe (o : Op')
  | iterate (k : ℕ) 
  | run (inputty : Ty')  
  | if (inputty retty' : Ty')  
  | for (ty : Ty')
  deriving DecidableEq, Repr

def commutativity_constant_14_vary_before := [llvm|
{
^0(%arg12 : i4, %arg13 : i4):
  %0 = llvm.mlir.constant(-2 : i4) : i4
  %1 = llvm.mlir.constant(1 : i4) : i4
  %2 = llvm.xor %arg12, %0 : i4
  %3 = llvm.and %2, %1 : i4
  %4 = llvm.xor %arg12, %3 : i4
  "llvm.return"(%4) : (i4) -> ()
}
]

def t17_nocse_mismatching_x_before := [llvm|
{
^0(%arg0 : i8, %arg1 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.mlir.constant(-1 : i8) : i8
  %2 = llvm.shl %0, %arg0 : i8
  %3 = llvm.shl %0, %arg1 : i8
  %4 = llvm.add %2, %1 : i8
  %5 = llvm.or %4, %3 : i8
  "llvm.return"(%5) : (i8) -> ()
}
]

def masked_icmps_mask_notallzeros_bmask_mixed_negated_swapped_3_logical_after := [llvm|
{
^0(%arg21 : i32):
  %0 = llvm.mlir.constant(15 : i32) : i32
  %1 = llvm.mlir.constant(8 : i32) : i32
  %2 = llvm.and %arg21, %0 : i32
  %3 = llvm.icmp "ne" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def positive_biggershl_shlnuwnsw_lshrexact_before := [llvm|
{
^0(%arg24 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.mlir.constant(6 : i8) : i8
  %2 = llvm.lshr exact %arg24, %0 : i8
  %3 = llvm.shl %2, %1 overflow<nsw,nuw> : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def slt_or_not_max_commute_logical_before := [llvm|
{
^0(%arg56 : i8, %arg57 : i8):
  %0 = llvm.mlir.constant(127 : i8) : i8
  %1 = llvm.mlir.constant(true) : i1
  %2 = llvm.icmp "slt" %arg56, %arg57 : i8
  %3 = llvm.icmp "ne" %arg56, %0 : i8
  %4 = "llvm.select"(%3, %1, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def and_orn_cmp_1_logical_before := [llvm|
{
^0(%arg128 : i32, %arg129 : i32, %arg130 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.mlir.constant(false) : i1
  %2 = llvm.icmp "sgt" %arg128, %arg129 : i32
  %3 = llvm.icmp "sle" %arg128, %arg129 : i32
  %4 = "llvm.select"(%arg130, %0, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %5 = "llvm.select"(%2, %4, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%5) : (i1) -> ()
}
]

instance : Inhabited (MLIRType φ) where
  default := MLIRType.undefined "INHABITANT"

def Tensor2d'.error (α : Type) : Tensor2d' α where
  dim₀ := 0
  dim₁ := 0
  mat := Matrix.of fun x _y => x.elim0

def ashrsgt_02_03_exact_after := [llvm|
{
^0(%arg82 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

instance (priority := low) : Monad (pure.toMonad m) :=

unsafe def elabIntoEIO {α : Type} (env : Lean.Environment) (typeName : Lean.Expr)
    (stx : Lean.Syntax) : EIO ParseError α :=
  fun s =>
    let resE : EIO Exception α :=
        elabIntoCore (α := α) typeName stx |>.run'
        {fileName := "parserHack", fileMap := default, maxHeartbeats := 0} {env := env}
    match resE s with
    | .ok a s => .ok a s
    | .error exception s =>
      let errMsgIO : IO String := exception.toMessageData.toString
      match errMsgIO s with
      | .ok errMsg s => .error s!"failed elaboration {stx}. Error: {errMsg}" s
      | .error e s => .error (s!" Failed elaborating {stx}.\n" ++
        s!"Unable to pretty-print exception at 'elabIntoEIO':\n{e}.") s

def or_and_shift_shift_and_after := [llvm|
{
^0(%arg12 : i32):
  %0 = llvm.mlir.constant(3 : i32) : i32
  %1 = llvm.mlir.constant(56 : i32) : i32
  %2 = llvm.mlir.constant(2 : i32) : i32
  %3 = llvm.mlir.constant(28 : i32) : i32
  %4 = llvm.shl %arg12, %0 : i32
  %5 = llvm.and %4, %1 : i32
  %6 = llvm.shl %arg12, %2 : i32
  %7 = llvm.and %6, %3 : i32
  %8 = llvm.or %5, %7 : i32
  "llvm.return"(%8) : (i32) -> ()
}
]

def ashrsgt_03_00_after := [llvm|
{
^0(%arg285 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def lshrugt_01_08_exact_before := [llvm|
{
^0(%arg213 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(-8 : i4) : i4
  %2 = llvm.lshr exact %arg213, %0 : i4
  %3 = llvm.icmp "ugt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def sle_or_not_min_commute_logical_after := [llvm|
{
^0(%arg282 : i8, %arg283 : i8):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def parseExprs (lhsExpr rhsExpr : Expr) (width : Nat): ParseExprM (Option ParsedBVLogicalExpr)  := do
  let some lhsRes ← toBVExpr lhsExpr width | throwError "Could not extract lhs: {lhsExpr}"

  let state ← get
  let lhs: ParsedBVExpr := {bvExpr := lhsRes.bvExpr, width := lhsRes.width, symVars := state.symVarToVal, inputVars := state.inputVarIdToVariable}

  let some rhsRes ← toBVExpr rhsExpr width | throwError "Could not extract rhs: {rhsExpr}"
  let state ← get

  let rhsInputVars := state.inputVarIdToVariable.filter fun k _ => !lhs.inputVars.contains k
  let rhsSymVars := state.symVarToVal.filter fun k _ => !lhs.symVars.contains k

  let rhs: ParsedBVExpr := {bvExpr := rhsRes.bvExpr, width := rhsRes.width, symVars := rhsSymVars, inputVars := rhsInputVars}

  trace[Generalize] m! "lhs width: {lhsRes.width}; rhs width: {rhsRes.width}"
  if h : lhsRes.width = rhsRes.width then
    let rhsExpr := h ▸ rhsRes.bvExpr
    let bvLogicalExpr := BoolExpr.literal (GenBVPred.bin lhsRes.bvExpr BVBinPred.eq rhsExpr)
    trace[Generalize] m! "BVLogicalExpr: {bvLogicalExpr}"

    return some {lhs := lhs, rhs := rhs, state := state, logicalExpr := bvLogicalExpr}

  return none

def neg_nsw_slt_1_after := [llvm|
{
^0(%arg19 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.icmp "sgt" %arg19, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def not_and_and_or_no_or_commute1_before := [llvm|
{
^0(%arg154 : i32, %arg155 : i32, %arg156 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.or %arg154, %arg155 : i32
  %2 = llvm.xor %1, %0 : i32
  %3 = llvm.xor %arg154, %0 : i32
  %4 = llvm.and %3, %arg155 : i32
  %5 = llvm.and %4, %arg156 : i32
  %6 = llvm.or %5, %2 : i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def ashr_can_be_lshr_after := [llvm|
{
^0(%arg1 : i32):
  %0 = llvm.mlir.constant(16 : i32) : i32
  %1 = llvm.lshr exact %arg1, %0 : i32
  %2 = llvm.trunc %1 overflow<nuw> : i32 to i16
  "llvm.return"(%2) : (i16) -> ()
}
]

def ugt_swap_or_not_min_logical_after := [llvm|
{
^0(%arg4 : i8, %arg5 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.icmp "ne" %arg4, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def bar_after := [llvm|
{
^0(%arg109 : i32, %arg110 : i32, %arg111 : i32, %arg112 : i32):
  %0 = llvm.icmp "slt" %arg109, %arg110 : i32
  %1 = "llvm.select"(%0, %arg111, %arg112) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%1) : (i32) -> ()
}
]

@[simp]
def Env.getD_getElem?_ofEnvFin (envFin : EnvFin w n) (i : Nat) :
    (Env.ofEnvFin envFin)[i]?.getD (0#w) = if h : i < n then envFin ⟨i, h⟩ else 0#w :=

def TypedSSAVal.mkVal [instTransformTy : TransformTy d φ] (Γ : Ctxt d.Ty) : TypedSSAVal φ →
    ReaderM d (Σ (ty : d.Ty), Ctxt.Var Γ ty)
| (.name valStx, tyStx) => do
    let ty ← instTransformTy.mkTy tyStx
    let var ← getValFromCtxt Γ valStx ty
    return ⟨ty, var⟩

def test_negative_nuw_and_signed_pred_after := [llvm|
{
^0(%arg53 : i64):
  %0 = llvm.mlir.constant(7) : i64
  %1 = llvm.icmp "ugt" %arg53, %0 : i64
  "llvm.return"(%1) : (i1) -> ()
}
]

def icmp_slt_0_and_icmp_sge_neg1_i64_fail_after := [llvm|
{
^0(%arg59 : i64):
  %0 = llvm.mlir.constant(-2) : i64
  %1 = llvm.mlir.constant(62) : i64
  %2 = llvm.mlir.constant(1) : i64
  %3 = llvm.mlir.constant(0) : i64
  %4 = llvm.icmp "sgt" %arg59, %0 : i64
  %5 = llvm.lshr %arg59, %1 : i64
  %6 = llvm.and %5, %2 : i64
  %7 = "llvm.select"(%4, %6, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i64, i64) -> i64
  "llvm.return"(%7) : (i64) -> ()
}
]

def lshrult_03_06_exact_before := [llvm|
{
^0(%arg111 : i4):
  %0 = llvm.mlir.constant(3 : i4) : i4
  %1 = llvm.mlir.constant(6 : i4) : i4
  %2 = llvm.lshr exact %arg111, %0 : i4
  %3 = llvm.icmp "ult" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def PR44545_before := [llvm|
{
^0(%arg0 : i32, %arg1 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(-1 : i16) : i16
  %3 = llvm.add %arg0, %0 overflow<nsw,nuw> : i32
  %4 = llvm.icmp "eq" %arg1, %1 : i32
  %5 = "llvm.select"(%4, %1, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %6 = llvm.trunc %5 : i32 to i16
  %7 = llvm.add %6, %2 overflow<nsw> : i16
  "llvm.return"(%7) : (i16) -> ()
}
]

def slt_swap_or_not_max_commute_logical_after := [llvm|
{
^0(%arg48 : i8, %arg49 : i8):
  %0 = llvm.mlir.constant(127 : i8) : i8
  %1 = llvm.icmp "ne" %arg48, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def icmp_slt_0_and_icmp_ne_neg2_i32_fail_before := [llvm|
{
^0(%arg44 : i32):
  %0 = llvm.mlir.constant(-2 : i32) : i32
  %1 = llvm.mlir.constant(31 : i32) : i32
  %2 = llvm.icmp "ne" %arg44, %0 : i32
  %3 = llvm.zext %2 : i1 to i32
  %4 = llvm.lshr %arg44, %1 : i32
  %5 = llvm.and %4, %3 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

@[simp] def evalv [DecidableEq α] : ∀ (c : Circuit α), (∀ a ∈ vars c, Bool) → Bool
  | tru, _ => true
  | fals, _ => false
  | var b x, f => if b then f x (by admit /- proof elided -/
  ) else !(f x (by admit /- proof elided -/
  ))
  | and c₁ c₂, f => (evalv c₁ (fun i hi => f i (by admit /- proof elided -/
  ))) &&
    (evalv c₂ (fun i hi => f i (by admit /- proof elided -/
    )))
  | or c₁ c₂, f => (evalv c₁ (fun i hi => f i (by admit /- proof elided -/
  ))) ||
    (evalv c₂ (fun i hi => f i (by admit /- proof elided -/
    )))
  | xor c₁ c₂, f => Bool.xor (evalv c₁ (fun i hi => f i (by admit /- proof elided -/
  )))
    (evalv c₂ (fun i hi => f i (by admit /- proof elided -/
    )))

def pr33078_1_before := [llvm|
{
^0(%arg5 : i8):
  %0 = llvm.mlir.constant(8 : i16) : i16
  %1 = llvm.sext %arg5 : i8 to i16
  %2 = llvm.lshr %1, %0 : i16
  %3 = llvm.trunc %2 : i16 to i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def test2_before := [llvm|
{
^0(%arg0 : i999, %arg1 : i999):
  %0 = llvm.mlir.constant(65280 : i999) : i999
  %1 = llvm.and %arg0, %0 : i999
  %2 = llvm.and %arg1, %0 : i999
  %3 = llvm.icmp "ne" %1, %2 : i999
  "llvm.return"(%3) : (i1) -> ()
}
]

def fold_add_udiv_urem_or_disjoint_after := [llvm|
{
^0(%arg5 : i32):
  %0 = llvm.mlir.constant(10 : i32) : i32
  %1 = llvm.mlir.constant(6 : i32) : i32
  %2 = llvm.udiv %arg5, %0 : i32
  %3 = llvm.mul %2, %1 overflow<nuw> : i32
  %4 = llvm.add %3, %arg5 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def reduce_xor_common_op_commute1_after := [llvm|
{
^0(%arg7 : i4, %arg8 : i4, %arg9 : i4):
  %0 = llvm.xor %arg8, %arg9 : i4
  %1 = llvm.or %0, %arg7 : i4
  "llvm.return"(%1) : (i4) -> ()
}
]

def Body.return : (body : Body Op Γ ty) → Var body.returnContext ty
  | ⟨⟨_, ret⟩, h⟩ => ⟨ret, by admit /- proof elided -/
  ⟩

def pr40493_neg1_before := [llvm|
{
^0(%arg17 : i32):
  %0 = llvm.mlir.constant(11 : i32) : i32
  %1 = llvm.mlir.constant(4 : i32) : i32
  %2 = llvm.mlir.constant(0 : i32) : i32
  %3 = llvm.mul %arg17, %0 : i32
  %4 = llvm.and %3, %1 : i32
  %5 = llvm.icmp "eq" %4, %2 : i32
  "llvm.return"(%5) : (i1) -> ()
}
]

def shl_bad_sub_i64_after := [llvm|
{
^0(%arg7 : i64):
  %0 = llvm.mlir.constant(67) : i64
  %1 = llvm.mlir.constant(1) : i64
  %2 = llvm.sub %0, %arg7 : i64
  %3 = llvm.shl %1, %2 overflow<nuw> : i64
  "llvm.return"(%3) : (i64) -> ()
}
]

def test_shl__nuw_is_safe_after := [llvm|
{
^0(%arg76 : i32, %arg77 : i64):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.mlir.constant(-8 : i32) : i32
  %2 = llvm.shl %arg76, %0 : i32
  %3 = llvm.and %2, %1 : i32
  %4 = llvm.zext nneg %3 : i32 to i64
  %5 = llvm.ashr %arg77, %4 : i64
  "llvm.return"(%5) : (i64) -> ()
}
]

def ashrslt_02_01_exact_after := [llvm|
{
^0(%arg36 : i4):
  %0 = llvm.mlir.constant(4 : i4) : i4
  %1 = llvm.icmp "slt" %arg36, %0 : i4
  "llvm.return"(%1) : (i1) -> ()
}
]

BitVec.nil in Init.Data.BitVec.Basic

def test1_before := [llvm|
{
^0(%arg14 : i32, %arg15 : i32):
  %0 = llvm.icmp "slt" %arg14, %arg15 : i32
  %1 = llvm.zext %0 : i1 to i32
  %2 = llvm.icmp "sgt" %arg14, %arg15 : i32
  %3 = llvm.zext %2 : i1 to i32
  %4 = llvm.and %1, %3 : i32
  %5 = llvm.trunc %4 : i32 to i1
  "llvm.return"(%5) : (i1) -> ()
}
]

def visitOR_0 : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%x: i64):
      %c = llvm.mlir.constant (0) : i64
      %0 = llvm.or %x, %c : i64
      llvm.return %0 : i64
  }]
  rhs := [LV| {
    ^entry (%x: i64):
      llvm.return %x : i64
  }]

def p0_after := [llvm|
{
^0(%arg28 : i8, %arg29 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.lshr %arg28, %arg29 : i8
  %2 = llvm.icmp "ne" %1, %0 : i8
  "llvm.return"(%2) : (i1) -> ()
}
]

def llvm_trunc_riscv_32_to_8_nuw_nsw : LLVMPeepholeRewriteRefine 8 [Ty.llvm (.bitvec 32)] :=
  {lhs:= trunc_llvm_32_to_8_nsw_nuw, rhs:= trunc_riscv_32_to_8_nsw_nuw}

def irc_constants_AMinusC1MinusC2_neg2_0 : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%a: i64):
      %c1 = llvm.mlir.constant (-2) : i64
      %c2 = llvm.mlir.constant (0) : i64
      %0 = llvm.sub %a, %c1 : i64
      %1 = llvm.sub %0, %c2 : i64
      llvm.return %1 : i64
  }]
  rhs := [LV| {
    ^entry (%a: i64):
      %c1 = llvm.mlir.constant (-2) : i64
      %c2 = llvm.mlir.constant (0) : i64
      %0 = llvm.add %c1, %c2 : i64
      %1 = llvm.sub %a, %0 : i64
      llvm.return %1 : i64
  }]

def NFA.msbLang : Language (BitVec 1) := { bvs  | bvs.getLast? = some 1 }

def abs_must_be_positive_before := [llvm|
{
^0(%arg48 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.sub %0, %arg48 overflow<nsw> : i32
  %2 = llvm.icmp "sge" %arg48, %0 : i32
  %3 = "llvm.select"(%2, %arg48, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %4 = llvm.icmp "sge" %3, %0 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def abs_diff_signed_slt_swap_wrong_pred1_before := [llvm|
{
^0(%arg15 : i32, %arg16 : i32):
  %0 = llvm.icmp "eq" %arg15, %arg16 : i32
  %1 = llvm.sub %arg16, %arg15 overflow<nsw> : i32
  %2 = llvm.sub %arg15, %arg16 overflow<nsw> : i32
  %3 = "llvm.select"(%0, %1, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def compose [FinEnum arity] [DecidableEq arity] [Hashable arity]
    (new_arity : Type)        
    (q_arity : arity → Type)  
    (vars : ∀ (a : arity), q_arity a → new_arity)
    
    
    (q : ∀ (a : arity), FSM (q_arity a)) : 
    FSM new_arity :=
  { α := p.α ⊕ (Σ a, (q a).α),
    i := by admit /- proof elided -/

def masked_icmps_mask_notallzeros_bmask_mixed_negated_7b_logical_after := [llvm|
{
^0(%arg53 : i32):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

IO.FS.Handle in Init.System.IO

def Expr.mkPredicateEvalEqFSM (p : Expr) : Expr :=
    mkApp (.const ``predicateEvalEqFSM []) p

def scalar_i64_shl_ult_const_before := [llvm|
{
^0(%arg14 : i64):
  %0 = llvm.mlir.constant(25) : i64
  %1 = llvm.mlir.constant(8589934592) : i64
  %2 = llvm.shl %arg14, %0 : i64
  %3 = llvm.icmp "ult" %2, %1 : i64
  "llvm.return"(%3) : (i1) -> ()
}
]

def ashrsgt_01_10_exact_after := [llvm|
{
^0(%arg91 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

@[simp_denote]
def sra_llvm_i32 := [LV| {
    ^entry (%a: i32, %b: i32):
    %0 = llvm.ashr %a, %b : i32
    llvm.return %0 : i32
  }]

def eq_umin3_before := [llvm|
{
^0(%arg56 : i32, %arg57 : i32):
  %0 = llvm.mlir.constant(3 : i32) : i32
  %1 = llvm.add %arg56, %0 : i32
  %2 = llvm.icmp "ult" %1, %arg57 : i32
  %3 = "llvm.select"(%2, %1, %arg57) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %4 = llvm.icmp "eq" %1, %3 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def logical_and_icmps1_before := [llvm|
{
^0(%arg36 : i32, %arg37 : i1):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.mlir.constant(false) : i1
  %2 = llvm.mlir.constant(10086 : i32) : i32
  %3 = llvm.icmp "sgt" %arg36, %0 : i32
  %4 = "llvm.select"(%arg37, %3, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %5 = llvm.icmp "slt" %arg36, %2 : i32
  %6 = "llvm.select"(%4, %5, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%6) : (i1) -> ()
}
]

def Expr.KInductionCircuits.mkIsLawful_mkN (fsm : Expr) (n : Expr) : MetaM Expr :=
  mkAppM ``ReflectVerif.BvDecide.KInductionCircuits.IsLawful_mkN #[fsm, n]

def test19_after := [llvm|
{
^0(%arg192 : i32, %arg193 : i32):
  "llvm.return"(%arg193) : (i32) -> ()
}
]

def neg_not_signbit2_before := [llvm|
{
^0(%arg4 : i8):
  %0 = llvm.mlir.constant(6 : i8) : i8
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.lshr %arg4, %0 : i8
  %3 = llvm.zext %2 : i8 to i32
  %4 = llvm.sub %1, %3 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def uaddo_commute4_before := [llvm|
{
^0(%arg22 : i32, %arg23 : i32, %arg24 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg23, %0 : i32
  %2 = llvm.add %arg23, %arg22 : i32
  %3 = llvm.icmp "ult" %1, %arg22 : i32
  %4 = "llvm.select"(%3, %arg24, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def and_logic_and_logic_or_2_after := [llvm|
{
^0(%arg135 : i1, %arg136 : i1, %arg137 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.mlir.constant(false) : i1
  %2 = "llvm.select"(%arg136, %0, %arg137) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %3 = "llvm.select"(%arg135, %2, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%3) : (i1) -> ()
}
]

Lean.Meta.MetaM in Lean.Meta.Basic

def p_constmask2_before := [llvm|
{
^0(%arg41 : i32, %arg42 : i32):
  %0 = llvm.mlir.constant(61440 : i32) : i32
  %1 = llvm.mlir.constant(-65281 : i32) : i32
  %2 = llvm.and %arg41, %0 : i32
  %3 = llvm.and %arg42, %1 : i32
  %4 = llvm.or %2, %3 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def test_sub_nsw__all_are_safe_after := [llvm|
{
^0(%arg29 : i32):
  %0 = llvm.mlir.constant(255 : i32) : i32
  %1 = llvm.mlir.constant(-254 : i32) : i32
  %2 = llvm.and %arg29, %0 : i32
  %3 = llvm.sub %1, %2 overflow<nsw,nuw> : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

abbrev Ix := Nat

def fold_sext_to_and3_before := [llvm|
{
^0(%arg14 : i8):
  %0 = llvm.mlir.constant(1073741826 : i32) : i32
  %1 = llvm.mlir.constant(2 : i32) : i32
  %2 = llvm.sext %arg14 : i8 to i32
  %3 = llvm.and %2, %0 : i32
  %4 = llvm.icmp "ne" %3, %1 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def or_xor_tree_1000_before := [llvm|
{
^0(%arg21 : i32, %arg22 : i32, %arg23 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mul %arg21, %0 : i32
  %2 = llvm.mul %arg22, %0 : i32
  %3 = llvm.mul %arg23, %0 : i32
  %4 = llvm.xor %1, %2 : i32
  %5 = llvm.xor %2, %3 : i32
  %6 = llvm.xor %5, %1 : i32
  %7 = llvm.or %6, %4 : i32
  "llvm.return"(%7) : (i32) -> ()
}
]

def lshrult_01_11_before := [llvm|
{
^0(%arg356 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(-5 : i4) : i4
  %2 = llvm.lshr %arg356, %0 : i4
  %3 = llvm.icmp "ult" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def ashrsgt_03_14_exact_before := [llvm|
{
^0(%arg55 : i4):
  %0 = llvm.mlir.constant(3 : i4) : i4
  %1 = llvm.mlir.constant(-2 : i4) : i4
  %2 = llvm.ashr exact %arg55, %0 : i4
  %3 = llvm.icmp "sgt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def and_two_ranges_to_mask_and_range_no_add_on_one_range_before := [llvm|
{
^0(%arg249 : i16):
  %0 = llvm.mlir.constant(12 : i16) : i16
  %1 = llvm.mlir.constant(16 : i16) : i16
  %2 = llvm.mlir.constant(28 : i16) : i16
  %3 = llvm.icmp "uge" %arg249, %0 : i16
  %4 = llvm.icmp "ult" %arg249, %1 : i16
  %5 = llvm.icmp "uge" %arg249, %2 : i16
  %6 = llvm.or %4, %5 : i1
  %7 = llvm.and %3, %6 : i1
  "llvm.return"(%7) : (i1) -> ()
}
]

def add_signbit_select_shl_before := [llvm|
{
^0(%arg34 : i32, %arg35 : i1):
  %0 = llvm.mlir.constant(-65536 : i32) : i32
  %1 = llvm.mlir.constant(8 : i32) : i32
  %2 = llvm.add %arg34, %0 : i32
  %3 = "llvm.select"(%arg35, %2, %arg34) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %4 = llvm.shl %3, %1 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def bitwise_or_bitwise_or_icmps_comm2_before := [llvm|
{
^0(%arg190 : i8, %arg191 : i8, %arg192 : i8):
  %0 = llvm.mlir.constant(42 : i8) : i8
  %1 = llvm.mlir.constant(1 : i8) : i8
  %2 = llvm.mlir.constant(0 : i8) : i8
  %3 = llvm.icmp "eq" %arg191, %0 : i8
  %4 = llvm.and %arg190, %1 : i8
  %5 = llvm.shl %1, %arg192 : i8
  %6 = llvm.and %arg190, %5 : i8
  %7 = llvm.icmp "eq" %4, %2 : i8
  %8 = llvm.icmp "eq" %6, %2 : i8
  %9 = llvm.or %7, %3 : i1
  %10 = llvm.or %9, %8 : i1
  "llvm.return"(%10) : (i1) -> ()
}
]

noncomputable def R.fromTensor' (coeffs : List Int) : (ZMod q)[X] :=
  coeffs.zipIdx.foldl (init := 0) fun res (c, i) =>
    res + (Polynomial.monomial i ↑c)

def Expr.KInductionCircuits.mkIndHypCycleBreaking (circs : Expr) : MetaM Expr :=
  mkAppM ``ReflectVerif.BvDecide.KInductionCircuits.mkIndHypCycleBreaking #[circs]

def add_smax_simplify_after := [llvm|
{
^0(%arg25 : i8):
  %0 = llvm.mlir.constant(126 : i8) : i8
  %1 = llvm.add %arg25, %0 overflow<nsw> : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def or_simplify_ule_fail_before := [llvm|
{
^0(%arg13 : i8, %arg14 : i8):
  %0 = llvm.mlir.constant(64 : i8) : i8
  %1 = llvm.mlir.constant(127 : i8) : i8
  %2 = llvm.or %arg13, %0 : i8
  %3 = llvm.and %arg14, %1 : i8
  %4 = llvm.or %2, %3 : i8
  %5 = llvm.icmp "ule" %4, %3 : i8
  "llvm.return"(%5) : (i1) -> ()
}
]

def n1_after := [llvm|
{
^0(%arg3 : i8):
  %0 = llvm.mlir.constant(8 : i8) : i8
  %1 = llvm.icmp "ult" %arg3, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

instLTBitVec in Init.Prelude

def sgt_and_min_commute_after := [llvm|
{
^0(%arg348 : i8, %arg349 : i8):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def both_sides_fold_eq_before := [llvm|
{
^0(%arg37 : i32, %arg38 : i1):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(9 : i32) : i32
  %2 = "llvm.select"(%arg38, %0, %arg37) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %3 = "llvm.select"(%arg38, %1, %arg37) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %4 = llvm.icmp "eq" %3, %2 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def canonicalize_icmp_ugt_neg1 : LLVMPeepholeRewriteRefine 1 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%x: i64):
      %c = llvm.mlir.constant -1 : i64
      %1 = llvm.icmp.ugt %c, %x : i64
      llvm.return %1 : i1
  }]
  rhs := [LV| {
    ^entry (%x: i64):
      %c = llvm.mlir.constant -1 : i64
      %1 = llvm.icmp.ult %x, %c : i64
      llvm.return %1 : i1
  }]

def test9_after := [llvm|
{
^0(%arg87 : i32):
  %0 = llvm.mlir.constant(42 : i8) : i8
  %1 = llvm.trunc %arg87 : i32 to i8
  %2 = llvm.and %1, %0 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def t2_after := [llvm|
{
^0(%arg11 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.icmp "sgt" %arg11, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def same_signbit_wrong_type_before := [llvm|
{
^0(%arg34 : i8, %arg35 : i32):
  %0 = llvm.mlir.constant(7 : i8) : i8
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.lshr %arg34, %0 : i8
  %3 = llvm.icmp "sgt" %arg35, %1 : i32
  %4 = llvm.zext %3 : i1 to i8
  %5 = llvm.icmp "ne" %2, %4 : i8
  "llvm.return"(%5) : (i1) -> ()
}
]

def lshrult_03_03_exact_before := [llvm|
{
^0(%arg114 : i4):
  %0 = llvm.mlir.constant(3 : i4) : i4
  %1 = llvm.lshr exact %arg114, %0 : i4
  %2 = llvm.icmp "ult" %1, %0 : i4
  "llvm.return"(%2) : (i1) -> ()
}
]

def scalar_i32_lshr_and_negC_eq_X_is_constant1_after := [llvm|
{
^0(%arg9 : i32):
  %0 = llvm.mlir.constant(12345 : i32) : i32
  %1 = llvm.mlir.constant(8 : i32) : i32
  %2 = llvm.lshr %0, %arg9 : i32
  %3 = llvm.icmp "ult" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def test7_before := [llvm|
{
^0(%arg0 : i47):
  %0 = llvm.mlir.constant(70368744177663 : i47) : i47
  %1 = llvm.mlir.constant(703687463 : i47) : i47
  %2 = llvm.or %arg0, %0 : i47
  %3 = llvm.xor %2, %1 : i47
  "llvm.return"(%3) : (i47) -> ()
}
]

def masked_icmps_mask_notallzeros_bmask_mixed_negated_7b_before := [llvm|
{
^0(%arg54 : i32):
  %0 = llvm.mlir.constant(6 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(15 : i32) : i32
  %3 = llvm.mlir.constant(8 : i32) : i32
  %4 = llvm.and %arg54, %0 : i32
  %5 = llvm.icmp "eq" %4, %1 : i32
  %6 = llvm.and %arg54, %2 : i32
  %7 = llvm.icmp "ne" %6, %3 : i32
  %8 = llvm.or %5, %7 : i1
  "llvm.return"(%8) : (i1) -> ()
}
]

Fin.subNat in Init.Data.Fin.Basic

def n9_wrong_x0_before := [llvm|
{
^0(%arg16 : i8, %arg17 : i8):
  %0 = llvm.mlir.constant(15 : i8) : i8
  %1 = llvm.mlir.constant(0 : i8) : i8
  %2 = llvm.mlir.constant(16 : i8) : i8
  %3 = llvm.mlir.constant(-16 : i8) : i8
  %4 = llvm.and %arg16, %0 : i8
  %5 = llvm.icmp "eq" %4, %1 : i8
  %6 = llvm.add %arg16, %2 : i8
  %7 = llvm.and %6, %3 : i8
  %8 = "llvm.select"(%5, %arg17, %7) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%8) : (i8) -> ()
}
]

def ugt_umax3_before := [llvm|
{
^0(%arg32 : i32, %arg33 : i32):
  %0 = llvm.mlir.constant(3 : i32) : i32
  %1 = llvm.add %arg32, %0 : i32
  %2 = llvm.icmp "ugt" %1, %arg33 : i32
  %3 = "llvm.select"(%2, %1, %arg33) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %4 = llvm.icmp "ult" %1, %3 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def ne_smax4_before := [llvm|
{
^0(%arg41 : i32, %arg42 : i32):
  %0 = llvm.mlir.constant(3 : i32) : i32
  %1 = llvm.add %arg41, %0 : i32
  %2 = llvm.icmp "sgt" %arg42, %1 : i32
  %3 = "llvm.select"(%2, %arg42, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %4 = llvm.icmp "ne" %1, %3 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def PR60818_ne_before := [llvm|
{
^0(%arg5 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.sub %0, %arg5 : i32
  %2 = llvm.icmp "ne" %1, %arg5 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def xor_icmp_to_ne_before := [llvm|
{
^0(%arg6 : i32):
  %0 = llvm.mlir.constant(4 : i32) : i32
  %1 = llvm.mlir.constant(6 : i32) : i32
  %2 = llvm.icmp "sgt" %arg6, %0 : i32
  %3 = llvm.icmp "slt" %arg6, %1 : i32
  %4 = llvm.xor %2, %3 : i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def icmp_ne_zext_ne_non_boolean_after := [llvm|
{
^0(%arg33 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.icmp "ne" %arg33, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def test11_before := [llvm|
{
^0(%arg30 : i23):
  %0 = llvm.mlir.constant(3 : i23) : i23
  %1 = llvm.mlir.constant(11 : i23) : i23
  %2 = llvm.mlir.constant(12 : i23) : i23
  %3 = llvm.mul %arg30, %0 : i23
  %4 = llvm.lshr %3, %1 : i23
  %5 = llvm.shl %4, %2 : i23
  "llvm.return"(%5) : (i23) -> ()
}
]

def test13_logical_before := [llvm|
{
^0(%arg286 : i32, %arg287 : i32):
  %0 = llvm.mlir.constant(false) : i1
  %1 = llvm.icmp "ult" %arg286, %arg287 : i32
  %2 = llvm.icmp "ugt" %arg286, %arg287 : i32
  %3 = "llvm.select"(%1, %2, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%3) : (i1) -> ()
}
]

Qq.synthInstanceQ in Qq.MetaM

def trunc_sel_larger_sext_before := [llvm|
{
^0(%arg85 : i32, %arg86 : i1):
  %0 = llvm.mlir.constant(42 : i16) : i16
  %1 = llvm.trunc %arg85 : i32 to i16
  %2 = "llvm.select"(%arg86, %1, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i16, i16) -> i16
  %3 = llvm.sext %2 : i16 to i64
  "llvm.return"(%3) : (i64) -> ()
}
]

@[simp_denote]
def add_shl_moreOneUse_sh4add_riscv := [LV| {
    ^entry (%a: i64):
    %a0 = "builtin.unrealized_conversion_cast" (%a) : (i64) -> (!i64)
    %0 = ori %a0, 1 : !i64
    %1 = slli %a0, 4 : !i64
    %2 = ori %1, 16 : !i64
    %3 = add %2, %0 : !i64
    %4 = "builtin.unrealized_conversion_cast" (%3) : (!i64) -> (i64)
    llvm.return %4 : i64
  }]

def positive_samevar_ashrexact_before := [llvm|
{
^0(%arg42 : i8, %arg43 : i8):
  %0 = llvm.ashr exact %arg42, %arg43 : i8
  %1 = llvm.shl %0, %arg43 : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def udiv_i32_c_multiuse_before := [llvm|
{
^0(%arg12 : i8):
  %0 = llvm.mlir.constant(10 : i32) : i32
  %1 = llvm.zext %arg12 : i8 to i32
  %2 = llvm.udiv %1, %0 : i32
  %3 = llvm.add %1, %2 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def slt_and_shl_one_after := [llvm|
{
^0(%arg25 : i8, %arg26 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.shl %0, %arg26 overflow<nuw> : i8
  %2 = llvm.and %arg25, %1 : i8
  %3 = llvm.icmp "slt" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def ashr_sle_exact_before := [llvm|
{
^0(%arg164 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.mlir.constant(10 : i8) : i8
  %2 = llvm.ashr exact %arg164, %0 : i8
  %3 = llvm.icmp "sle" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

Trans in Init.Prelude

def sgt_x_impliesF_eq_smin_todo_before := [llvm|
{
^0(%arg11 : i8, %arg12 : i8, %arg13 : i8):
  %0 = llvm.mlir.constant(-128 : i8) : i8
  %1 = llvm.icmp "sgt" %arg11, %arg13 : i8
  %2 = "llvm.select"(%1, %0, %arg12) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  %3 = llvm.icmp "eq" %2, %arg11 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def sdiv_ult_smin_before := [llvm|
{
^0(%arg18 : i8, %arg19 : i8):
  %0 = llvm.mlir.constant(-128 : i8) : i8
  %1 = llvm.sdiv %arg18, %arg19 : i8
  %2 = llvm.icmp "ult" %1, %0 : i8
  "llvm.return"(%2) : (i1) -> ()
}
]

def select_xor_inv_icmp_after := [llvm|
{
^0(%arg266 : i32, %arg267 : i32, %arg268 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.icmp "eq" %arg266, %0 : i32
  %2 = "llvm.select"(%1, %arg268, %arg267) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def lshrult_03_07_after := [llvm|
{
^0(%arg328 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def combined_sdiv_srem_correct := [LV| {
  ^entry (%a: i64, %b: i64):
    %0= llvm.sdiv %a, %b : i64
    %1 = llvm.mul %b, %0 : i64
    %2 = llvm.sub %a, %1 : i64
    llvm.return %2 : i64
  }]

@[simp_denote]
def trunc_llvm_64_to_32_nuw := [LV| {
  ^entry (%lhs: i64):
    %0 = llvm.trunc %lhs overflow<nuw> : i64 to i32
    llvm.return %0 : i32
  }]

def test1_after := [llvm|
{
^0(%arg10 : i32, %arg11 : i32):
  %0 = llvm.mlir.constant(7 : i32) : i32
  %1 = llvm.and %arg10, %0 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def low_bitmask_ugt_after := [llvm|
{
^0(%arg9 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.mul %arg9, %arg9 : i8
  %2 = llvm.icmp "ne" %1, %0 : i8
  "llvm.return"(%2) : (i1) -> ()
}
]

HAppend in Init.Prelude

def main4c_after := [llvm|
{
^0(%arg124 : i32):
  %0 = llvm.mlir.constant(55 : i32) : i32
  %1 = llvm.and %arg124, %0 : i32
  %2 = llvm.icmp "eq" %1, %0 : i32
  %3 = llvm.zext %2 : i1 to i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def test_or_eq_a_b_after := [llvm|
{
^0(%arg36 : i1, %arg37 : i8, %arg38 : i8):
  %0 = "llvm.select"(%arg36, %arg37, %arg38) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%0) : (i8) -> ()
}
]

def or_eq_with_one_bit_diff_constants1_logical_before := [llvm|
{
^0(%arg365 : i32):
  %0 = llvm.mlir.constant(50 : i32) : i32
  %1 = llvm.mlir.constant(51 : i32) : i32
  %2 = llvm.mlir.constant(true) : i1
  %3 = llvm.icmp "eq" %arg365, %0 : i32
  %4 = llvm.icmp "eq" %arg365, %1 : i32
  %5 = "llvm.select"(%3, %2, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%5) : (i1) -> ()
}
]

@[simp_denote]
def and_riscv_i16 :=
  [LV| {
    ^entry (%arg0: i16, %arg1: i16 ):
    %a = "builtin.unrealized_conversion_cast" (%arg0) : (i16) -> (!i64)
    %b = "builtin.unrealized_conversion_cast" (%arg1) : (i16) -> (!i64)
    %0 = and %a, %b : !i64
    %1 = "builtin.unrealized_conversion_cast" (%0) : (!i64) -> (i16)
    llvm.return %1 :i16
  }]

def t2_commutative_before := [llvm|
{
^0(%arg20 : i8, %arg21 : i8):
  %0 = llvm.sub %arg20, %arg21 : i8
  %1 = llvm.icmp "ult" %arg20, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def select_icmp_ne_0_and_4096_xor_4096_after := [llvm|
{
^0(%arg229 : i32, %arg230 : i32):
  %0 = llvm.mlir.constant(4096 : i32) : i32
  %1 = llvm.and %arg229, %0 : i32
  %2 = llvm.xor %1, %arg230 : i32
  %3 = llvm.xor %2, %0 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def test_ult_xor_before := [llvm|
{
^0(%arg36 : i32, %arg37 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg36, %0 : i32
  %2 = llvm.xor %1, %arg37 : i32
  %3 = llvm.icmp "ult" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def t2_symmetry_after := [llvm|
{
^0(%arg37 : i8, %arg38 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.xor %arg37, %0 : i8
  %2 = llvm.icmp "ule" %arg38, %1 : i8
  "llvm.return"(%2) : (i1) -> ()
}
]

def test6a_before := [llvm|
{
^0(%arg1 : i1):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.zext %arg1 : i1 to i32
  %2 = llvm.icmp "ne" %1, %0 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def function : Parser :=
  leading_parser argumentList >> arrow >> termParser

def t0_before := [llvm|
{
^0(%arg41 : i1, %arg42 : i8, %arg43 : i8, %arg44 : i8, %arg45 : i8):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.icmp "eq" %arg42, %arg43 : i8
  %2 = llvm.xor %arg41, %0 : i1
  %3 = "llvm.select"(%2, %0, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %4 = "llvm.select"(%3, %arg44, %arg45) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%4) : (i8) -> ()
}
]

def positive_samevar_shlnsw_after := [llvm|
{
^0(%arg52 : i8, %arg53 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.shl %0, %arg53 overflow<nsw> : i8
  %2 = llvm.and %1, %arg52 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def ashrsgt_01_01_exact_after := [llvm|
{
^0(%arg100 : i4):
  %0 = llvm.mlir.constant(2 : i4) : i4
  %1 = llvm.icmp "sgt" %arg100, %0 : i4
  "llvm.return"(%1) : (i1) -> ()
}
]

def negate_sext_after := [llvm|
{
^0(%arg98 : i8, %arg99 : i1):
  %0 = llvm.zext %arg99 : i1 to i8
  %1 = llvm.add %arg98, %0 : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def dec_mask_commute_neg_i32_after := [llvm|
{
^0(%arg6 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.sdiv %0, %arg6 : i32
  %3 = llvm.add %2, %1 overflow<nsw> : i32
  %4 = llvm.xor %2, %1 : i32
  %5 = llvm.and %3, %4 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def List.product (l₁ : List α) (l₂ : List β) : List (α × β) := l₁.flatMap fun a => l₂.map (Prod.mk a)

def t8_twoshifts3_before := [llvm|
{
^0(%arg24 : i32, %arg25 : i32, %arg26 : i32, %arg27 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.shl %arg24, %arg25 : i32
  %3 = llvm.shl %0, %arg27 : i32
  %4 = llvm.and %3, %2 : i32
  %5 = llvm.icmp "eq" %4, %1 : i32
  "llvm.return"(%5) : (i1) -> ()
}
]

def urem_i1_is_zero_before := [llvm|
{
^0(%arg0 : i1, %arg1 : i1):
  %0 = llvm.urem %arg0, %arg1 : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def sle_swap_and_min_logical_after := [llvm|
{
^0(%arg212 : i8, %arg213 : i8):
  %0 = llvm.mlir.constant(-128 : i8) : i8
  %1 = llvm.icmp "eq" %arg212, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def icmp_eq_x_invertable_y2_todo_after := [llvm|
{
^0(%arg4 : i8, %arg5 : i1):
  %0 = llvm.mlir.constant(-8 : i8) : i8
  %1 = llvm.mlir.constant(-25 : i8) : i8
  %2 = llvm.mlir.constant(-1 : i8) : i8
  %3 = "llvm.select"(%arg5, %0, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  %4 = llvm.or %arg4, %3 : i8
  %5 = llvm.icmp "eq" %4, %2 : i8
  "llvm.return"(%5) : (i1) -> ()
}
]

def BasicBlock.substitute (σ : Substitution) : BasicBlock Op T → BasicBlock Op T
  | ⟨label, args, program⟩ =>
      let σ' := args.foldl Substitution.removeMappingFor σ
      ⟨label, args, program.substitute σ'⟩

def test15_before := [llvm|
{
^0(%arg6 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(8) : i64
  %2 = llvm.ashr %arg6, %0 : i32
  %3 = llvm.sext %2 : i32 to i64
  %4 = llvm.sub %1, %3 : i64
  "llvm.return"(%4) : (i64) -> ()
}
]

def ule_umax2_after := [llvm|
{
^0(%arg50 : i32, %arg51 : i32):
  %0 = llvm.icmp "ule" %arg51, %arg50 : i32
  "llvm.return"(%0) : (i1) -> ()
}
]

def icmp_ne_and_pow2_shl1_after := [llvm|
{
^0(%arg67 : i32):
  %0 = llvm.mlir.constant(4 : i32) : i32
  %1 = llvm.icmp "eq" %arg67, %0 : i32
  %2 = llvm.zext %1 : i1 to i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def shl_nsw_nuw_add_nsw_after := [llvm|
{
^0(%arg13 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.shl %0, %arg13 overflow<nsw> : i32
  %2 = llvm.xor %1, %0 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def sle_swap_or_not_min_after := [llvm|
{
^0(%arg280 : i8, %arg281 : i8):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def t0_lshr_after := [llvm|
{
^0(%arg30 : i32, %arg31 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.shl %0, %arg31 overflow<nsw> : i32
  %2 = llvm.and %1, %arg30 : i32
  %3 = llvm.lshr exact %2, %arg31 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def PR42691_7_after := [llvm|
{
^0(%arg331 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.add %arg331, %0 : i32
  %3 = llvm.icmp "slt" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def ult_or_not_max_logical_after := [llvm|
{
^0(%arg44 : i8, %arg45 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.icmp "ne" %arg44, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def ashrsgt_01_01_exact_after := [llvm|
{
^0(%arg100 : i4):
  %0 = llvm.mlir.constant(2 : i4) : i4
  %1 = llvm.icmp "sgt" %arg100, %0 : i4
  "llvm.return"(%1) : (i1) -> ()
}
]

def n2_badmask_after := [llvm|
{
^0(%arg6 : i32, %arg7 : i32, %arg8 : i32, %arg9 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg9, %0 : i32
  %2 = llvm.or %arg6, %1 : i32
  %3 = llvm.or %arg8, %arg7 : i32
  %4 = llvm.and %2, %3 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def not_not_cmp_before := [llvm|
{
^0(%arg147 : i32, %arg148 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg147, %0 : i32
  %2 = llvm.xor %arg148, %0 : i32
  %3 = llvm.icmp "slt" %1, %2 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def freeze_match : List (Σ Γ, Σ ty, PeepholeRewrite LLVMPlusRiscV Γ ty) := [
  mkRewrite (LLVMToRiscvPeepholeRewriteRefine.toPeepholeUNSOUND llvm_freeze_lower_riscv_8),
  mkRewrite (LLVMToRiscvPeepholeRewriteRefine.toPeepholeUNSOUND llvm_freeze_lower_riscv_16),
  mkRewrite (LLVMToRiscvPeepholeRewriteRefine.toPeepholeUNSOUND llvm_freeze_lower_riscv_32),
  mkRewrite (LLVMToRiscvPeepholeRewriteRefine.toPeepholeUNSOUND llvm_freeze_lower_riscv_64)
]

def masked_icmps_mask_notallzeros_bmask_mixed_7b_after := [llvm|
{
^0(%arg76 : i32):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def mul_to_shl_4 : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%x: i64):
      %c = llvm.mlir.constant (4) : i64
      %0 = llvm.mul %x, %c : i64
      llvm.return %0 : i64
  }]
  rhs := [LV| {
    ^entry (%x: i64):
      %c = llvm.mlir.constant (2) : i64
      %0 = llvm.shl %x, %c : i64
      llvm.return %0 : i64
  }]

RV64.sh3add in RISCV.Instructions

def a_or_b_const2_before := [llvm|
{
^0(%arg6 : i32, %arg7 : i32, %arg8 : i32, %arg9 : i32):
  %0 = llvm.icmp "eq" %arg6, %arg8 : i32
  %1 = llvm.icmp "ne" %arg7, %arg9 : i32
  %2 = llvm.and %0, %1 : i1
  %3 = llvm.icmp "ne" %arg6, %arg8 : i32
  %4 = llvm.icmp "eq" %arg7, %arg9 : i32
  %5 = llvm.and %3, %4 : i1
  %6 = llvm.or %2, %5 : i1
  "llvm.return"(%6) : (i1) -> ()
}
]

def negative_not_less_than_after := [llvm|
{
^0(%arg9 : i32):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def test12_after := [llvm|
{
^0(%arg46 : i32, %arg47 : i32):
  %0 = llvm.mlir.constant(1431655765 : i32) : i32
  %1 = llvm.and %arg46, %0 : i32
  %2 = llvm.sub %arg47, %1 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def land_land_left2_before := [llvm|
{
^0(%arg100 : i1, %arg101 : i1):
  %0 = llvm.mlir.constant(false) : i1
  %1 = "llvm.select"(%arg101, %arg100, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %2 = "llvm.select"(%1, %arg100, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%2) : (i1) -> ()
}
]

def test_before := [llvm|
{
^0(%arg0 : i8, %arg1 : i8):
  %0 = llvm.zext %arg0 : i8 to i32
  %1 = llvm.zext %arg1 : i8 to i32
  %2 = llvm.icmp "sgt" %0, %1 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def ashrsgt_02_09_before := [llvm|
{
^0(%arg292 : i4):
  %0 = llvm.mlir.constant(2 : i4) : i4
  %1 = llvm.mlir.constant(-7 : i4) : i4
  %2 = llvm.ashr %arg292, %0 : i4
  %3 = llvm.icmp "sgt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def test11_after := [llvm|
{
^0(%arg197 : i8):
  %0 = llvm.mlir.constant(-13 : i8) : i8
  %1 = llvm.mlir.constant(8 : i8) : i8
  %2 = llvm.and %arg197, %0 : i8
  %3 = llvm.or disjoint %2, %1 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

BitVec.zeroExtend in Init.Data.BitVec.Basic

def test19_commutative0_before := [llvm|
{
^0(%arg74 : i32, %arg75 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.shl %0, %arg74 : i32
  %2 = llvm.shl %0, %arg75 : i32
  %3 = llvm.and %2, %1 : i32
  %4 = llvm.add %3, %1 : i32
  %5 = llvm.urem %arg75, %4 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

Finsupp.mk in Mathlib.Data.Finsupp.Defs

def zext_sext_add_icmp_slt_1_type_not_i1_after := [llvm|
{
^0(%arg47 : i2, %arg48 : i1):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.zext %arg47 : i2 to i8
  %2 = llvm.sext %arg48 : i1 to i8
  %3 = llvm.add %1, %2 overflow<nsw> : i8
  %4 = llvm.icmp "slt" %3, %0 : i8
  "llvm.return"(%4) : (i1) -> ()
}
]

def no_shift_xor_multiuse_or_after := [llvm|
{
^0(%arg134 : i32, %arg135 : i32):
  %0 = llvm.mlir.constant(4096 : i32) : i32
  %1 = llvm.and %arg134, %0 : i32
  %2 = llvm.or %arg135, %0 : i32
  %3 = llvm.xor %1, %0 : i32
  %4 = llvm.or %arg135, %3 : i32
  %5 = llvm.mul %4, %2 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def l_before := [llvm|
{
^0(%arg0 : i32, %arg1 : i32, %arg2 : i32, %arg3 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.sub %0, %arg1 : i32
  %2 = llvm.sub %0, %arg2 : i32
  %3 = llvm.add %2, %1 : i32
  %4 = llvm.add %3, %arg3 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def lshrult_03_09_exact_before := [llvm|
{
^0(%arg108 : i4):
  %0 = llvm.mlir.constant(3 : i4) : i4
  %1 = llvm.mlir.constant(-7 : i4) : i4
  %2 = llvm.lshr exact %arg108, %0 : i4
  %3 = llvm.icmp "ult" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def shrink_select_before := [llvm|
{
^0(%arg52 : i1, %arg53 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = "llvm.select"(%arg52, %arg53, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %2 = llvm.trunc %1 : i32 to i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def scalar_i32_udiv_and_negC_eq_X_is_constant3_before := [llvm|
{
^0(%arg7 : i32):
  %0 = llvm.mlir.constant(12345 : i32) : i32
  %1 = llvm.mlir.constant(16376 : i32) : i32
  %2 = llvm.mlir.constant(0 : i32) : i32
  %3 = llvm.udiv %0, %arg7 : i32
  %4 = llvm.and %3, %1 : i32
  %5 = llvm.icmp "ne" %4, %2 : i32
  "llvm.return"(%5) : (i1) -> ()
}
]

def slt_zero_sgt_minus1_after := [llvm|
{
^0(%arg22 : i4, %arg23 : i4):
  %0 = llvm.mlir.constant(-1 : i4) : i4
  %1 = llvm.xor %arg22, %arg23 : i4
  %2 = llvm.icmp "sgt" %1, %0 : i4
  "llvm.return"(%2) : (i1) -> ()
}
]

def sub_add_reg_x_add_y_sub_y : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64), Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%x: i64, %y: i64):
      %1 = llvm.add %x, %y : i64
      %2 = llvm.sub %1, %y : i64
      llvm.return %2 : i64
  }]
  rhs := [LV| {
    ^entry (%x: i64, %y: i64):
      llvm.return %x : i64
  }]

def test24_before := [llvm|
{
^0(%arg53 : i32):
  %0 = llvm.mlir.constant(-2147483648 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.urem %arg53, %0 : i32
  %3 = llvm.icmp "ne" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def shl_trunc_smaller_shl_after := [llvm|
{
^0(%arg39 : i32):
  %0 = llvm.mlir.constant(6 : i8) : i8
  %1 = llvm.trunc %arg39 : i32 to i8
  %2 = llvm.shl %1, %0 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def icmp_slt_0_xor_icmp_sgt_neg2_i32_before := [llvm|
{
^0(%arg54 : i32):
  %0 = llvm.mlir.constant(-2 : i32) : i32
  %1 = llvm.mlir.constant(31 : i32) : i32
  %2 = llvm.icmp "sgt" %arg54, %0 : i32
  %3 = llvm.zext %2 : i1 to i32
  %4 = llvm.lshr %arg54, %1 : i32
  %5 = llvm.xor %4, %3 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def alive_Select_1105_src  (w : Nat)   :=
[llvm( w )| {
^bb0(%Y : _, %X : _):
  %v1 = llvm.mlir.constant 0 :  i1
  %v2 = llvm.select %v1,%X, %Y
  llvm.return %v2
}]

def or_not_and_wrong_b_before := [llvm|
{
^0(%arg484 : i32, %arg485 : i32, %arg486 : i32, %arg487 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.or %arg484, %arg485 : i32
  %2 = llvm.xor %1, %0 : i32
  %3 = llvm.and %2, %arg486 : i32
  %4 = llvm.or %arg484, %arg486 : i32
  %5 = llvm.xor %4, %0 : i32
  %6 = llvm.and %5, %arg487 : i32
  %7 = llvm.or %3, %6 : i32
  "llvm.return"(%7) : (i32) -> ()
}
]

def neg_or_lshr_i32_commute_after := [llvm|
{
^0(%arg6 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.sdiv %0, %arg6 : i32
  %3 = llvm.icmp "ne" %2, %1 : i32
  %4 = llvm.zext %3 : i1 to i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def ashrsgt_03_11_after := [llvm|
{
^0(%arg274 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def or_xor_tree_1001_after := [llvm|
{
^0(%arg18 : i32, %arg19 : i32, %arg20 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mul %arg18, %0 : i32
  %2 = llvm.mul %arg19, %0 : i32
  %3 = llvm.mul %arg20, %0 : i32
  %4 = llvm.xor %2, %1 : i32
  %5 = llvm.or %4, %3 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def and_or_not_not_wrong_a_before := [llvm|
{
^0(%arg332 : i32, %arg333 : i32, %arg334 : i32, %arg335 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.and %arg333, %arg335 : i32
  %2 = llvm.xor %1, %0 : i32
  %3 = llvm.and %arg332, %arg334 : i32
  %4 = llvm.xor %3, %0 : i32
  %5 = llvm.or %4, %arg333 : i32
  %6 = llvm.and %5, %2 : i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def mul_of_pow2_after := [llvm|
{
^0(%arg83 : i32, %arg84 : i8):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def fold_icmp_shl_nuw_c2_after := [llvm|
{
^0(%arg8 : i32):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.icmp "ult" %arg8, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def uaddo_wrong_pred2_before := [llvm|
{
^0(%arg4 : i32, %arg5 : i32, %arg6 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg5, %0 : i32
  %2 = llvm.add %arg4, %arg5 : i32
  %3 = llvm.icmp "uge" %arg4, %1 : i32
  %4 = "llvm.select"(%3, %arg6, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def select_icmp_ne_0_and_32_xor_4096_after := [llvm|
{
^0(%arg199 : i32, %arg200 : i32):
  %0 = llvm.mlir.constant(7 : i32) : i32
  %1 = llvm.mlir.constant(4096 : i32) : i32
  %2 = llvm.shl %arg199, %0 : i32
  %3 = llvm.and %2, %1 : i32
  %4 = llvm.xor %3, %arg200 : i32
  %5 = llvm.xor %4, %1 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def sgt_or_not_min_before := [llvm|
{
^0(%arg30 : i8, %arg31 : i8):
  %0 = llvm.mlir.constant(-128 : i8) : i8
  %1 = llvm.icmp "sgt" %arg30, %arg31 : i8
  %2 = llvm.icmp "ne" %arg30, %0 : i8
  %3 = llvm.or %1, %2 : i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def constLLVM14 : Com LLVMPlusRiscV ⟨[]⟩ .pure (.llvm (.bitvec 64)) := [LV| {
  ^entry ():
    %1 = llvm.mlir.constant (14) : i64
    llvm.return %1 : i64
  }]

def ashrslt_03_03_exact_after := [llvm|
{
^0(%arg18 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

@[simp_denote]
def lshr_llvm_exact_64 := [LV| {
  ^entry (%x: i64, %amount: i64):
    %1 = llvm.lshr exact %x, %amount : i64
    llvm.return %1 : i64
  }]

def or_xor_common_op_commute7_after := [llvm|
{
^0(%arg114 : i8, %arg115 : i8, %arg116 : i8):
  %0 = llvm.or %arg115, %arg114 : i8
  %1 = llvm.or %0, %arg116 : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def not_not_false_before := [llvm|
{
^0(%arg236 : i1, %arg237 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.mlir.constant(false) : i1
  %2 = llvm.xor %arg236, %0 : i1
  %3 = llvm.xor %arg237, %0 : i1
  %4 = "llvm.select"(%2, %3, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def sub_shl_same_amount_partial_nuw1_after := [llvm|
{
^0(%arg5 : i6, %arg6 : i6, %arg7 : i6):
  %0 = llvm.sub %arg5, %arg6 : i6
  %1 = llvm.shl %0, %arg7 : i6
  "llvm.return"(%1) : (i6) -> ()
}
]

def zext_before := [llvm|
{
^0(%arg10 : i1):
  %0 = llvm.mlir.constant(1 : i41) : i41
  %1 = llvm.mlir.constant(0 : i41) : i41
  %2 = "llvm.select"(%arg10, %0, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i41, i41) -> i41
  "llvm.return"(%2) : (i41) -> ()
}
]

DFA in Mathlib.Computability.DFA

def uge_swap_and_max_commute_before := [llvm|
{
^0(%arg226 : i8, %arg227 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.icmp "ule" %arg227, %arg226 : i8
  %2 = llvm.icmp "eq" %arg226, %0 : i8
  %3 = llvm.and %2, %1 : i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def and_logic_and_logic_or_1_before := [llvm|
{
^0(%arg138 : i1, %arg139 : i1, %arg140 : i1):
  %0 = llvm.mlir.constant(false) : i1
  %1 = llvm.mlir.constant(true) : i1
  %2 = llvm.and %arg138, %arg139 : i1
  %3 = "llvm.select"(%arg138, %arg140, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %4 = "llvm.select"(%2, %1, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def shl_nsw_add_negative_before := [llvm|
{
^0(%arg45 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.mlir.constant(2 : i32) : i32
  %2 = llvm.add %arg45, %0 : i32
  %3 = llvm.shl %1, %2 overflow<nsw> : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

BitVec.shiftConcat in Init.Data.BitVec.Basic

def test_mul_nuw_nsw__none_are_safe_after := [llvm|
{
^0(%arg3 : i32):
  %0 = llvm.mlir.constant(9 : i32) : i32
  %1 = llvm.mul %arg3, %0 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def shl_xor_xor_good_mask_before := [llvm|
{
^0(%arg100 : i8, %arg101 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.mlir.constant(88 : i8) : i8
  %2 = llvm.shl %arg100, %0 : i8
  %3 = llvm.shl %arg101, %0 : i8
  %4 = llvm.xor %3, %1 : i8
  %5 = llvm.xor %2, %4 : i8
  "llvm.return"(%5) : (i8) -> ()
}
]

def lshrult_03_09_after := [llvm|
{
^0(%arg326 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def t_2_4_before := [llvm|
{
^0(%arg12 : i8):
  %0 = llvm.mlir.constant(2 : i8) : i8
  %1 = llvm.mlir.constant(4 : i8) : i8
  %2 = llvm.icmp "ugt" %arg12, %0 : i8
  %3 = "llvm.select"(%2, %arg12, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  %4 = llvm.and %3, %1 : i8
  "llvm.return"(%4) : (i8) -> ()
}
]

def PR52261_before := [llvm|
{
^0(%arg208 : i1):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.mlir.constant(-2 : i32) : i32
  %2 = llvm.mlir.constant(0 : i32) : i32
  %3 = "llvm.select"(%arg208, %0, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %4 = llvm.sub %2, %3 overflow<nsw> : i32
  %5 = llvm.and %3, %4 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def test51_before := [llvm|
{
^0(%arg133 : i64, %arg134 : i1):
  %0 = llvm.mlir.constant(-2 : i32) : i32
  %1 = llvm.mlir.constant(1 : i32) : i32
  %2 = llvm.trunc %arg133 : i64 to i32
  %3 = llvm.and %2, %0 : i32
  %4 = llvm.or %2, %1 : i32
  %5 = "llvm.select"(%arg134, %3, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %6 = llvm.sext %5 : i32 to i64
  "llvm.return"(%6) : (i64) -> ()
}
]

def positive_biggerashr_shlnsw_ashrexact_after := [llvm|
{
^0(%arg35 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.ashr exact %arg35, %0 : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

List.Nodup in Init.Data.List.Basic

def t1_before := [llvm|
{
^0(%arg12 : i4):
  %0 = llvm.mlir.constant(-4 : i4) : i4
  %1 = llvm.mlir.constant(-6 : i4) : i4
  %2 = llvm.or %arg12, %0 : i4
  %3 = llvm.xor %2, %1 : i4
  "llvm.return"(%3) : (i4) -> ()
}
]

def select_sub_icmp_after := [llvm|
{
^0(%arg214 : i32, %arg215 : i32, %arg216 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.icmp "eq" %arg214, %0 : i32
  %2 = "llvm.select"(%1, %arg216, %arg215) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def visitAND_Sameop : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%x: i64):
      %0 = llvm.and %x, %x : i64
      llvm.return %0 : i64
  }]
  rhs := [LV| {
    ^entry (%x: i64):
      llvm.return %x : i64
  }]

def test83_before := [llvm|
{
^0(%arg62 : i16, %arg63 : i64):
  %0 = llvm.mlir.constant(-1) : i64
  %1 = llvm.sext %arg62 : i16 to i32
  %2 = llvm.add %arg63, %0 overflow<nsw> : i64
  %3 = llvm.trunc %2 : i64 to i32
  %4 = llvm.shl %1, %3 : i32
  %5 = llvm.zext %4 : i32 to i64
  "llvm.return"(%5) : (i64) -> ()
}
]

def neg_mask_before := [llvm|
{
^0(%arg1 : i32, %arg2 : i16):
  %0 = llvm.mlir.constant(15 : i16) : i16
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.sext %arg2 : i16 to i32
  %3 = llvm.sub %arg1, %2 overflow<nsw> : i32
  %4 = llvm.lshr %arg2, %0 : i16
  %5 = llvm.zext %4 : i16 to i32
  %6 = llvm.sub %1, %5 overflow<nsw> : i32
  %7 = llvm.and %3, %6 : i32
  "llvm.return"(%7) : (i32) -> ()
}
]

def src_srem_shl_demand_min_signbit_mask_hit_last_demand_after := [llvm|
{
^0(%arg20 : i32):
  %0 = llvm.mlir.constant(536870912 : i32) : i32
  %1 = llvm.mlir.constant(1 : i32) : i32
  %2 = llvm.mlir.constant(-1073741822 : i32) : i32
  %3 = llvm.srem %arg20, %0 : i32
  %4 = llvm.shl %3, %1 overflow<nsw> : i32
  %5 = llvm.and %4, %2 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def trunc_equality_nsw_zext_after := [llvm|
{
^0(%arg16 : i32, %arg17 : i8):
  %0 = llvm.zext %arg17 : i8 to i32
  %1 = llvm.icmp "ne" %arg16, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def positive_biggerlshr_lshrexact_after := [llvm|
{
^0(%arg40 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.lshr exact %arg40, %0 : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def test_with_neg_5_before := [llvm|
{
^0(%arg314 : i32):
  %0 = llvm.mlir.constant(-5 : i32) : i32
  %1 = llvm.mlir.constant(1 : i32) : i32
  %2 = llvm.shl %0, %arg314 : i32
  %3 = llvm.and %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def ashrsgt_03_02_before := [llvm|
{
^0(%arg283 : i4):
  %0 = llvm.mlir.constant(3 : i4) : i4
  %1 = llvm.mlir.constant(2 : i4) : i4
  %2 = llvm.ashr %arg283, %0 : i4
  %3 = llvm.icmp "sgt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def squared_nsw_sgt0_after := [llvm|
{
^0(%arg178 : i5):
  %0 = llvm.mlir.constant(0 : i5) : i5
  %1 = llvm.icmp "ne" %arg178, %0 : i5
  "llvm.return"(%1) : (i1) -> ()
}
]

def lshrult_03_11_before := [llvm|
{
^0(%arg324 : i4):
  %0 = llvm.mlir.constant(3 : i4) : i4
  %1 = llvm.mlir.constant(-5 : i4) : i4
  %2 = llvm.lshr %arg324, %0 : i4
  %3 = llvm.icmp "ult" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def ult_rem_zero_after := [llvm|
{
^0(%arg174 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.icmp "ult" %arg174, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def masked_or_allzeroes_notoptimised_logical_after := [llvm|
{
^0(%arg116 : i32):
  %0 = llvm.mlir.constant(15 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(39 : i32) : i32
  %3 = llvm.and %arg116, %0 : i32
  %4 = llvm.icmp "eq" %3, %1 : i32
  %5 = llvm.and %arg116, %2 : i32
  %6 = llvm.icmp "eq" %5, %1 : i32
  %7 = llvm.or %4, %6 : i1
  "llvm.return"(%7) : (i1) -> ()
}
]

def test33_after := [llvm|
{
^0(%arg253 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.xor %arg253, %0 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def land_land_right1_before := [llvm|
{
^0(%arg54 : i1, %arg55 : i1):
  %0 = llvm.mlir.constant(false) : i1
  %1 = "llvm.select"(%arg54, %arg55, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %2 = "llvm.select"(%arg54, %1, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%2) : (i1) -> ()
}
]

def neg_mask_before := [llvm|
{
^0(%arg1 : i32, %arg2 : i16):
  %0 = llvm.mlir.constant(15 : i16) : i16
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.sext %arg2 : i16 to i32
  %3 = llvm.sub %arg1, %2 overflow<nsw> : i32
  %4 = llvm.lshr %arg2, %0 : i16
  %5 = llvm.zext %4 : i16 to i32
  %6 = llvm.sub %1, %5 overflow<nsw> : i32
  %7 = llvm.and %3, %6 : i32
  "llvm.return"(%7) : (i32) -> ()
}
]

def f_var0_after := [llvm|
{
^0(%arg52 : i32, %arg53 : i32):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.or %arg53, %0 : i32
  %3 = llvm.and %arg52, %2 : i32
  %4 = llvm.icmp "ne" %3, %1 : i32
  %5 = llvm.zext %4 : i1 to i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def not_and_and_or_no_or_commute1_and_before := [llvm|
{
^0(%arg160 : i32, %arg161 : i32, %arg162 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.or %arg161, %arg160 : i32
  %2 = llvm.xor %1, %0 : i32
  %3 = llvm.xor %arg160, %0 : i32
  %4 = llvm.and %arg162, %arg161 : i32
  %5 = llvm.and %4, %3 : i32
  %6 = llvm.or %5, %2 : i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def test6a_after := [llvm|
{
^0(%arg1 : i1):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def same_source_shifted_signbit_after := [llvm|
{
^0(%arg2 : i32):
  %0 = llvm.mlir.constant(24 : i32) : i32
  %1 = llvm.ashr %arg2, %0 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def test_negative_nsw_and_unsigned_pred_before := [llvm|
{
^0(%arg52 : i64):
  %0 = llvm.mlir.constant(10) : i64
  %1 = llvm.mlir.constant(3) : i64
  %2 = llvm.sub %0, %arg52 overflow<nsw> : i64
  %3 = llvm.icmp "ult" %2, %1 : i64
  "llvm.return"(%3) : (i1) -> ()
}
]

def liRiscv15 := [LV| {
  ^entry ():
    %0 = "li"() {imm = 15 : !i64} : (!i64) -> (!i64)
    %1 = "builtin.unrealized_conversion_cast"(%0) : (!i64) -> (i64)
    llvm.return %1 : i64
  }]

@[simp_denote]
def add_llvm_nuw_flags_8 := [LV| {
  ^entry (%lhs: i8, %rhs: i8):
    %1 = llvm.add %lhs, %rhs overflow<nuw> : i8
    llvm.return %1 : i8
  }]

def masked_icmps_mask_notallzeros_bmask_mixed_swapped_1b_logical_before := [llvm|
{
^0(%arg47 : i32):
  %0 = llvm.mlir.constant(14 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(3 : i32) : i32
  %3 = llvm.mlir.constant(1 : i32) : i32
  %4 = llvm.mlir.constant(false) : i1
  %5 = llvm.and %arg47, %0 : i32
  %6 = llvm.icmp "ne" %5, %1 : i32
  %7 = llvm.and %arg47, %2 : i32
  %8 = llvm.icmp "eq" %7, %3 : i32
  %9 = "llvm.select"(%8, %6, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%9) : (i1) -> ()
}
]

def zext_add_scalar_before := [llvm|
{
^0(%arg40 : i1):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.zext %arg40 : i1 to i32
  %2 = llvm.add %1, %0 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def t1_flags_nuw_nsw_second_before := [llvm|
{
^0(%arg30 : i8, %arg31 : i8, %arg32 : i8):
  %0 = llvm.sub %arg30, %arg31 : i8
  %1 = llvm.sub %0, %arg32 overflow<nsw,nuw> : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def add_nsw_const_const_sub_nsw_ov_before := [llvm|
{
^0(%arg57 : i8):
  %0 = llvm.mlir.constant(2 : i8) : i8
  %1 = llvm.mlir.constant(-127 : i8) : i8
  %2 = llvm.add %arg57, %0 overflow<nsw> : i8
  %3 = llvm.sub %1, %2 overflow<nsw> : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

@[simp_denote]
def andi_riscv :=
  [LV| {
    ^entry (%arg: i16):
    %a =  "builtin.unrealized_conversion_cast" (%arg) : (i16) -> (!i64)
    %0 =andi %a, 6 : !i64
    %1 = "builtin.unrealized_conversion_cast" (%0) : (!i64) -> (i16)
    llvm.return %1 :i16
  }]

def and1_lshr1_is_cmp_eq_0_multiuse_before := [llvm|
{
^0(%arg10 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.lshr %0, %arg10 : i8
  %2 = llvm.and %1, %0 : i8
  %3 = llvm.add %1, %2 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def positive_biggerShl_before := [llvm|
{
^0(%arg34 : i32):
  %0 = llvm.mlir.constant(10 : i32) : i32
  %1 = llvm.mlir.constant(5 : i32) : i32
  %2 = llvm.shl %arg34, %0 : i32
  %3 = llvm.lshr %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def llvm_const_lower_riscv_li_44 : LLVMPeepholeRewriteRefine 64 [] :=
  {lhs := constLLVM_44, rhs:= liRiscv_44,
   correct := by admit /- proof elided -/

instance instDCTyDenote : TyDenote Ty where
toType := fun
| Ty.tokenstream => CIRCTStream.DCOp.TokenStream
| Ty.tokenstream2 => CIRCTStream.DCOp.TokenStream × CIRCTStream.DCOp.TokenStream
| Ty.valuestream w => CIRCTStream.DCOp.ValueStream (BitVec w)
| Ty.valuestream2 w => CIRCTStream.DCOp.ValueStream (BitVec w) × CIRCTStream.DCOp.ValueStream (BitVec w)
| Ty.valuetokenstream w => CIRCTStream.DCOp.ValueStream (BitVec w) × CIRCTStream.DCOp.TokenStream
| Ty.variadicvaluetokenstream w => CIRCTStream.DCOp.VariadicValueStream w × CIRCTStream.DCOp.TokenStream


def_denote for DC where
  | .fst => fun s => [s.fst]ₕ
  | .fstVal _ => fun s => [s.fst]ₕ
  | .fstVal' _ => fun s => [s.fst.mapOpt (·[0]?)]ₕ
  | .snd => fun s => [s.snd]ₕ
  | .pair _ => fun s₁ s₂ => [(s₁, s₂)]ₕ
  | .sndVal _ => fun s => [s.snd]ₕ
  | .sndVal' _ => fun s => [s.fst.mapOpt (·[0]?)]ₕ
  | .tokVal' _ => fun s => [s.snd]ₕ
  | .merge => fun s₁ s₂ => [CIRCTStream.DCOp.merge s₁ s₂]ₕ
  | .branch => fun s => [CIRCTStream.DCOp.branch s]ₕ
  | .fork => fun s => [CIRCTStream.DCOp.fork s]ₕ
  | .join => fun s₁ s₂ => [CIRCTStream.DCOp.join s₁ s₂]ₕ
  | .select => fun s₁ s₂ c => [CIRCTStream.DCOp.select s₁ s₂ c]ₕ
  | .sink => fun s => [CIRCTStream.DCOp.sink s]ₕ
  | .source => [CIRCTStream.DCOp.source]ₕ
  | .pack _ => fun s₁ s₂ => [CIRCTStream.DCOp.pack s₁ s₂]ₕ
  | .pack2 _ => fun s₁ => [CIRCTStream.DCOp.pack2 s₁]ₕ
  | .unpack _ => fun s => [CIRCTStream.DCOp.unpack s]ₕ
  | .unpack2 _ => fun s₁ s₂ => [CIRCTStream.DCOp.unpack2 s₁ s₂]ₕ

def andcond.100.inv.inner.cond.in.outer.cond_before := [llvm|
{
^0(%arg55 : i1, %arg56 : i1, %arg57 : i8, %arg58 : i8, %arg59 : i8):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.mlir.constant(false) : i1
  %2 = llvm.xor %arg55, %0 : i1
  %3 = "llvm.select"(%2, %arg56, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %4 = "llvm.select"(%arg55, %arg57, %arg58) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  %5 = "llvm.select"(%3, %arg59, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%5) : (i8) -> ()
}
]

def ashrsgt_02_08_before := [llvm|
{
^0(%arg293 : i4):
  %0 = llvm.mlir.constant(2 : i4) : i4
  %1 = llvm.mlir.constant(-8 : i4) : i4
  %2 = llvm.ashr %arg293, %0 : i4
  %3 = llvm.icmp "sgt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

Lean.Meta.mkEq in Lean.Meta.AppBuilder

@[simp_denote]
def shl_llvm_64 := [LV| {
  ^entry (%x: i64, %y: i64):
    %1 = llvm.shl %x, %y : i64
    llvm.return %1 : i64
  }]

def no_shift_no_xor_multiuse_cmp_or_before := [llvm|
{
^0(%arg60 : i32, %arg61 : i32, %arg62 : i32, %arg63 : i32):
  %0 = llvm.mlir.constant(4096 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.and %arg60, %0 : i32
  %3 = llvm.icmp "eq" %2, %1 : i32
  %4 = llvm.or %arg61, %0 : i32
  %5 = "llvm.select"(%3, %arg61, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %6 = "llvm.select"(%3, %arg62, %arg63) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %7 = llvm.mul %5, %6 : i32
  %8 = llvm.mul %7, %4 : i32
  "llvm.return"(%8) : (i32) -> ()
}
]

def ult_swap_or_not_max_logical_before := [llvm|
{
^0(%arg36 : i8, %arg37 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.mlir.constant(true) : i1
  %2 = llvm.icmp "ugt" %arg37, %arg36 : i8
  %3 = llvm.icmp "ne" %arg36, %0 : i8
  %4 = "llvm.select"(%2, %1, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

@[match_pattern] def add (w : Width φ)
  (NoWrapFlags: NoWrapFlags := {nsw := false , nuw := false}) : MOp φ
    := .binary w (.add NoWrapFlags )

def test82_after := [llvm|
{
^0(%arg64 : i64):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(-512 : i32) : i32
  %2 = llvm.trunc %arg64 : i64 to i32
  %3 = llvm.shl %2, %0 : i32
  %4 = llvm.and %3, %1 : i32
  %5 = llvm.zext %4 : i32 to i64
  "llvm.return"(%5) : (i64) -> ()
}
]

def lshr_32_add_not_known_32_leading_zeroes_after := [llvm|
{
^0(%arg13 : i64, %arg14 : i64):
  %0 = llvm.mlir.constant(8589934591) : i64
  %1 = llvm.mlir.constant(4294967295) : i64
  %2 = llvm.mlir.constant(32) : i64
  %3 = llvm.and %arg13, %0 : i64
  %4 = llvm.and %arg14, %1 : i64
  %5 = llvm.add %3, %4 overflow<nsw,nuw> : i64
  %6 = llvm.lshr %5, %2 : i64
  "llvm.return"(%6) : (i64) -> ()
}
]

def trunc_ashr_after := [llvm|
{
^0(%arg98 : i32):
  %0 = llvm.mlir.constant(8 : i32) : i32
  %1 = llvm.mlir.constant(-8388608 : i32) : i32
  %2 = llvm.lshr %arg98, %0 : i32
  %3 = llvm.or %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

Membership.mem in Init.Prelude

instance : DecidableEq (IntW w) :=

private def Expr.isBitVecOfWidth (e : Expr) (w : Expr) : MetaM Bool := do
  match_expr ← inferType e with
  | BitVec w' => return w == w'
  | _ => return false

instance : DialectToExpr Handshake where
  toExprM := .const ``Id [0]
  toExprDialect := .const ``Handshake []

def sub_select_not_sext_before := [llvm|
{
^0(%arg20 : i1, %arg21 : i64):
  %0 = llvm.mlir.constant(64) : i64
  %1 = llvm.mlir.constant(true) : i1
  %2 = "llvm.select"(%arg20, %arg21, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i64, i64) -> i64
  %3 = llvm.xor %arg20, %1 : i1
  %4 = llvm.sext %3 : i1 to i64
  %5 = llvm.sub %2, %4 : i64
  "llvm.return"(%5) : (i64) -> ()
}
]

def xor_ugt_2_after := [llvm|
{
^0(%arg13 : i8, %arg14 : i8, %arg15 : i8):
  %0 = llvm.mlir.constant(63 : i8) : i8
  %1 = llvm.mlir.constant(64 : i8) : i8
  %2 = llvm.add %arg13, %arg15 : i8
  %3 = llvm.and %arg14, %0 : i8
  %4 = llvm.or disjoint %3, %1 : i8
  %5 = llvm.xor %2, %4 : i8
  %6 = llvm.icmp "ugt" %2, %5 : i8
  "llvm.return"(%6) : (i1) -> ()
}
]

def constLLVM48 : Com LLVMPlusRiscV ⟨[]⟩ .pure (.llvm (.bitvec 64)) := [LV| {
  ^entry ():
    %1 = llvm.mlir.constant (48) : i64
    llvm.return %1 : i64
  }]

def ashrslt_03_06_exact_after := [llvm|
{
^0(%arg15 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def lshrugt_01_12_exact_before := [llvm|
{
^0(%arg209 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(-4 : i4) : i4
  %2 = llvm.lshr exact %arg209, %0 : i4
  %3 = llvm.icmp "ugt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def t0_before := [llvm|
{
^0(%arg51 : i8, %arg52 : i8, %arg53 : i8):
  %0 = llvm.sub %arg51, %arg52 : i8
  %1 = llvm.sub %0, %arg53 : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def or_signbit_select_shl_after := [llvm|
{
^0(%arg42 : i32, %arg43 : i1):
  %0 = llvm.mlir.constant(8 : i32) : i32
  %1 = llvm.mlir.constant(-16777216 : i32) : i32
  %2 = llvm.shl %arg42, %0 : i32
  %3 = llvm.or %2, %1 : i32
  %4 = "llvm.select"(%arg43, %3, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def test48_after := [llvm|
{
^0(%arg137 : i8, %arg138 : i8):
  %0 = llvm.mlir.constant(8 : i32) : i32
  %1 = llvm.zext %arg137 : i8 to i32
  %2 = llvm.shl %1, %0 overflow<nsw,nuw> : i32
  %3 = llvm.or disjoint %2, %1 : i32
  %4 = llvm.zext nneg %3 : i32 to i64
  "llvm.return"(%4) : (i64) -> ()
}
]

def logical_or_not_after := [llvm|
{
^0(%arg260 : i1, %arg261 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.xor %arg260, %0 : i1
  %2 = "llvm.select"(%1, %0, %arg261) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%2) : (i1) -> ()
}
]

def lshrugt_01_07_exact_after := [llvm|
{
^0(%arg214 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def test12commuted_after := [llvm|
{
^0(%arg87 : i32, %arg88 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.and %arg87, %arg88 : i32
  %2 = llvm.xor %1, %0 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def ashrslt_01_13_exact_after := [llvm|
{
^0(%arg40 : i4):
  %0 = llvm.mlir.constant(-6 : i4) : i4
  %1 = llvm.icmp "slt" %arg40, %0 : i4
  "llvm.return"(%1) : (i1) -> ()
}
]

def land_lor_right1_after := [llvm|
{
^0(%arg46 : i1, %arg47 : i1):
  "llvm.return"(%arg46) : (i1) -> ()
}
]

def masked_icmps_mask_notallzeros_bmask_mixed_negated_7_logical_after := [llvm|
{
^0(%arg55 : i32):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

Quotient in Init.Core
</all_available_defs>

<all_available_lemmas>
Finset.mem_range in Mathlib.Data.Finset.Range
Nat.lt_of_le_of_lt in Init.Prelude
Set.mem_insert_iff in Mathlib.Data.Set.Insert
Set.union_singleton in Mathlib.Data.Set.Insert
not_lt in Mathlib.Order.Defs.LinearOrder

theorem Std.HashSet.fold_induction [BEq α] [LawfulBEq α] [Hashable α]
  {f : β → α → β} {m : HashSet α} {motive : β → Set α → Prop} :
    motive b ∅ →
    (∀ b x s, x ∉ s → motive b s → motive (f b x) (s ∪ {x})) →
    motive (m.fold f b) m.toSet

theorem Std.HashSet.toSet_toList[BEq α] [LawfulBEq α] [Hashable α] (m : HashSet α) : m.toSet = { x | x ∈ m.toList }

theorem e_1934 :
    4 * ( ~~~(a &&&  ~~~b) &&& (b ^^^ c)) + 11 * (a ^^^ (b &&& c)) - 6 * ((b &&& c) ||| ( ~~~a &&& (b ||| c))) + 11 * (c &&& (a ||| b)) - 5 * (c ^^^ ( ~~~a ||| (b ||| c))) - 7 * (b &&& (a |||  ~~~c)) + 1 * (c ||| (a ^^^ b)) + 1 * b + 7 * (c ||| (a &&&  ~~~b)) - 2 * c - 1 * (c ^^^ (a &&& ( ~~~b ||| c))) - 1 * ( ~~~(a &&&  ~~~b) &&& (a ^^^ (b ^^^ c))) - 2 * ((a ||| b) &&& (a ^^^ (b ^^^ c))) - 6 *  ~~~( ~~~a &&& (b ^^^ c)) + 1 * (c |||  ~~~(a |||  ~~~b)) - 1 *  ~~~a - 11 *  ~~~(a &&& c) + 5 *  ~~~(a ||| (b &&& c)) - 6 * ((a &&&  ~~~b) |||  ~~~(a ^^^ (b ^^^ c))) + 2 *  ~~~(b |||  ~~~c) + 1 * (a ||| c) - 7 * (a |||  ~~~c) + 2 * ((a &&& c) ^^^ (a ^^^ (b &&& c))) - 11 * (c ^^^ (a ||| ( ~~~b &&& c))) + 2 * (c ^^^  ~~~(a &&& b)) - 3 * (b ^^^ (a &&& c)) - 2 *  ~~~( ~~~a ||| (b ^^^ c)) - 11 *  ~~~(a ||| (b ^^^ c)) + 2 * (c ^^^  ~~~( ~~~a ||| ( ~~~b &&& c))) - 1 * ( ~~~a ||| (b ||| c)) - 11 * ( ~~~c |||  ~~~(a ^^^ b)) + 4 * (b ^^^ (a ||| (b ||| c))) + 3 * (c &&& (a |||  ~~~b)) - 1 * (c ^^^  ~~~(a ||| b)) + 2 * ((a &&& b) |||  ~~~(b ||| c)) + 4 * (c ^^^  ~~~(a &&& ( ~~~b &&& c))) - 1 * ((a &&& c) ||| (b &&&  ~~~c)) - 2 * ((a ^^^ b) &&&  ~~~(a ^^^ c)) - 11 * (b ||| (a &&& c)) + 1 * (c |||  ~~~(a ||| b)) + 2 * ( ~~~a ||| ( ~~~b &&& c)) - 6 * (b ^^^ (a &&& ( ~~~b ||| c))) + 4 * (b ^^^  ~~~(a ||| (b ^^^ c))) - 1 * (c ^^^ ( ~~~a ||| ( ~~~b &&& c))) + 43 *  ~~~(a ||| (b ||| c)) + 52 *  ~~~(a ||| ( ~~~b ||| c)) + 29 *  ~~~( ~~~a ||| (b ||| c)) + 55 *  ~~~( ~~~a ||| ( ~~~b ||| c)) + 1 * ( ~~~a &&& ( ~~~b &&& c)) + 39 * ( ~~~a &&& (b &&& c)) - 2 * (a &&& ( ~~~b &&& c)) + 23 * (a &&& (b &&& c)) = 2 * (b ^^^ (a |||  ~~~c))

theorem icmp_sgt9_thm (e : IntW 8) :
  icmp IntPred.sgt (shl e (const? 8 7) { «nsw» := true, «nuw» := false }) (const? 8 (-128)) ⊑
    icmp IntPred.eq e (const? 8 0)

theorem neg_test_icmp_non_equality_proof : neg_test_icmp_non_equality_before ⊑ neg_test_icmp_non_equality_after

theorem select_xor_icmp_meta_thm (e e_1 e_2 : IntW 32) :
  select (icmp IntPred.eq e_2 (const? 32 0)) (LLVM.xor e_2 e_1) e ⊑
    select (icmp IntPred.eq e_2 (const? 32 0)) e_1 e

theorem ashrsgt_02_04_proof : ashrsgt_02_04_before ⊑ ashrsgt_02_04_after

theorem and_not_or_commute8_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 32),
  ¬((x_2 == 0 || 32 != 1 && 42#32 == intMin 32 && x_2 == -1) = true ∨
        (x_1 == 0 || 32 != 1 && 42#32 == intMin 32 && x_1 == -1) = true ∨
          (x_1 == 0 || 32 != 1 && 42#32 == intMin 32 && x_1 == -1) = true ∨
            (x_2 == 0 || 32 != 1 && 42#32 == intMin 32 && x_2 == -1) = true) →
    (x_1 == 0 || 32 != 1 && 42#32 == intMin 32 && x_1 == -1) = true ∨
        (x_2 == 0 || 32 != 1 && 42#32 == intMin 32 && x_2 == -1) = true →
      False

theorem alive_AndOrXor_1733  (w : Nat)   : alive_AndOrXor_1733_src w  ⊑ alive_AndOrXor_1733_tgt w

theorem main3c_logical_proof : main3c_logical_before ⊑ main3c_logical_after

theorem e_959 :
     - 6 * t - 1 *  ~~~t + 1 *  ~~~(z ||| t) + 6 *  ~~~(z |||  ~~~t) + 2 * (z &&&  ~~~t) + 7 * (z &&& t) = 1 * z

theorem test2_thm.extracted_1._1 : ∀ (x : BitVec 1005), x ^^^ 0#1005 = x

theorem e_322 :
    3 *  ~~~(x &&&  ~~~y) - 3 *  ~~~(x &&&  ~~~x) + 4 * (x |||  ~~~y) - 2 *  ~~~x - 2 *  ~~~(x ||| y) + 2 *  ~~~(x |||  ~~~y) - 1 * (x &&&  ~~~y) = 4 * (x &&& y)

theorem sdiv_icmp3_proof : sdiv_icmp3_before ⊑ sdiv_icmp3_after

theorem test_add_nuw_nsw__nuw_is_safe_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ofBool (x &&& 2147483647#32 == 2147483647#32) = 1#1 →
    ¬(True ∧ (x &&& 2147483647#32).uaddOverflow 1#32 = true) →
      BitVec.ofInt 32 (-2147483648) = (x &&& 2147483647#32) + 1#32

theorem xor_1_thm (e e_1 e_2 : IntW 8) (e_3 : IntW 1) :
  LLVM.xor (LLVM.xor (select e_3 (LLVM.xor e_2 (const? 8 (-1))) (LLVM.xor e_1 (const? 8 123))) e) (const? 8 (-1)) ⊑
    LLVM.xor (select e_3 e_2 (LLVM.xor e_1 (const? 8 (-124)))) e

theorem test_and3_logical_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ofBool (x <ₛ x_1 &&& 2147483647#32) = 1#1 → ofBool (0#32 ≤ₛ x) = ofBool (x <ᵤ x_1 &&& 2147483647#32)

theorem xor_2_proof : xor_2_before ⊑ xor_2_after

theorem test24_proof : test24_before ⊑ test24_after

theorem test47_proof : test47_before ⊑ test47_after

theorem masked_icmps_mask_notallzeros_bmask_mixed_negated_swapped_1b_logical_proof : masked_icmps_mask_notallzeros_bmask_mixed_negated_swapped_1b_logical_before ⊑ masked_icmps_mask_notallzeros_bmask_mixed_negated_swapped_1b_logical_after

theorem icmp_eq_mul_nuw_nonequal_proof : icmp_eq_mul_nuw_nonequal_before ⊑ icmp_eq_mul_nuw_nonequal_after

theorem negative2_logical_proof : negative2_logical_before ⊑ negative2_logical_after

@[simp] theorem val_toArgResult (mapOut : MatchVarResult lets v (.var matchLets matchExpr) w.appendInl mapIn) :
    mapOut.toArgResult.val = mapOut.val

theorem eq_smin3_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ofBool (x_1 + 3#32 <ₛ x) = 1#1 → ofBool (x_1 + 3#32 == x_1 + 3#32) = ofBool (x_1 + 3#32 ≤ₛ x)

theorem or_trunc_lshr_more_proof : or_trunc_lshr_more_before ⊑ or_trunc_lshr_more_after

theorem zext_zext_ule_op0_wide_proof : zext_zext_ule_op0_wide_before ⊑ zext_zext_ule_op0_wide_after

theorem bools_multi_uses2_logical_thm.extracted_1._18 : ∀ (x x_1 : BitVec 1),
  ¬x_1 ^^^ 1#1 = 1#1 → ¬x_1 = 1#1 → 0#1 = 1#1 → ¬True → False

theorem scalar_i16_lshr_and_signbit_eq_thm.extracted_1._1 : ∀ (x x_1 : BitVec 16),
  ¬x ≥ ↑16 → ofBool (x_1 >>> x &&& BitVec.ofInt 16 (-32768) == 0#16) = ofBool (-1#16 <ₛ x_1 >>> x)

theorem logical_and_bitwise_and_icmps_comm1_thm.extracted_1._2 : ∀ (x x_1 x_2 : BitVec 8),
  ¬x_1 ≥ ↑8 → ofBool (x_2 &&& 1#8 <<< x_1 != 0#8) = 1#1 → True ∧ 1#8 <<< x_1 >>> x_1 ≠ 1#8 ∨ x_1 ≥ ↑8 → False

theorem ult_umin1_proof : ult_umin1_before ⊑ ult_umin1_after

theorem sdiv2_thm (e : IntW 32) :
  LLVM.sdiv e (const? 32 8) { «exact» := true } ⊑ ashr e (const? 32 3) { «exact» := true }

theorem main12_proof : main12_before ⊑ main12_after

theorem canonicalize_logic_first_and0_nsw_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬(True ∧ x.saddOverflow 48#8 = true) → True ∧ (x &&& BitVec.ofInt 8 (-10)).saddOverflow 48#8 = true → False

theorem test2_thm (e : IntW 8) (e_1 : IntW 32) :
  LLVM.and (LLVM.or e_1 (zext 32 e)) (const? 32 65536) ⊑ LLVM.and e_1 (const? 32 65536)

theorem pr33078_1_thm.extracted_1._2 : ∀ (x : BitVec 8),
  ¬8#16 ≥ ↑16 → ¬7#8 ≥ ↑8 → truncate 8 (signExtend 16 x >>> 8#16) = x.sshiftRight' 7#8

theorem prove_exact_with_high_mask_proof : prove_exact_with_high_mask_before ⊑ prove_exact_with_high_mask_after

theorem shl_add_thm (e e_1 : IntW 8) :
  shl (add (shl e_1 (const? 8 3)) e) (const? 8 2) ⊑ add (shl e_1 (const? 8 5)) (shl e (const? 8 2))

theorem test1_thm (e : IntW 32) : LLVM.and e (const? 32 0) ⊑ const? 32 0

theorem select_bittest_to_shl_negative_test_proof : select_bittest_to_shl_negative_test_before ⊑ select_bittest_to_shl_negative_test_after

theorem xor_congr (e1 : a ≈ʷ b) (e2 : c ≈ʷ d) : (a ^^^ c) ≈ʷ (b ^^^ d)

theorem neg_or_lshr_i32_commute_proof : neg_or_lshr_i32_commute_before ⊑ neg_or_lshr_i32_commute_after

theorem lshrult_03_12_proof : lshrult_03_12_before ⊑ lshrult_03_12_after

theorem icmp_slt_0_and_icmp_sgt_neg1_i64_thm.extracted_1._1 : ∀ (x : BitVec 64),
  ¬63#64 ≥ ↑64 → x >>> 63#64 &&& zeroExtend 64 (ofBool (-1#64 <ₛ x)) = 0#64

theorem band_land_left2_thm.extracted_1._2 : ∀ (x x_1 : BitVec 1), ¬x_1 &&& x = 1#1 → 0#1 = x_1 &&& x

theorem masked_icmps_mask_notallzeros_bmask_mixed_1_logical_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬ofBool (x &&& 12#32 != 0#32) = 1#1 → 0#1 = ofBool (x &&& 15#32 == 9#32)

theorem foo1_or_signbit_lshr_without_shifting_signbit_proof : foo1_or_signbit_lshr_without_shifting_signbit_before ⊑ foo1_or_signbit_lshr_without_shifting_signbit_after

theorem andn_or_cmp_4_proof : andn_or_cmp_4_before ⊑ andn_or_cmp_4_after

theorem bools_logical_commute0_and1_thm.extracted_1._3 : ∀ (x x_1 : BitVec 1),
  ¬(x_1 ^^^ 1#1) &&& x = 1#1 → ¬x_1 = 1#1 → 0#1 = x

theorem trunc_unsigned_nsw_sext_thm.extracted_1._1 : ∀ (x : BitVec 8) (x_1 : BitVec 32),
  ¬(True ∧ signExtend 32 (truncate 16 x_1) ≠ x_1) →
    ofBool (truncate 16 x_1 <ᵤ signExtend 16 x) = ofBool (x_1 <ᵤ signExtend 32 x)

theorem sext_zext_apint2_thm.extracted_1._1 : ∀ (x : BitVec 11), signExtend 47 (zeroExtend 39 x) = zeroExtend 47 x

theorem negate_zext_thm.extracted_1._1 : ∀ (x : BitVec 1) (x_1 : BitVec 8),
  x_1 - zeroExtend 8 x = x_1 + signExtend 8 x

theorem udiv2_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬(x ≥ ↑32 ∨ True ∧ x_1.umod (1#32 <<< x) ≠ 0 ∨ 1#32 <<< x = 0) → True ∧ x_1 >>> x <<< x ≠ x_1 ∨ x ≥ ↑32 → False

theorem sle_or_min_logical_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ofBool (x_1 ≤ₛ x) = 1#1 → 1#1 = ofBool (x_1 ≤ₛ x)

theorem scalar_i32_shl_ult_const_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬11#32 ≥ ↑32 → ofBool (x <<< 11#32 <ᵤ 131072#32) = ofBool (x &&& 2097088#32 == 0#32)

theorem test67_thm.extracted_1._2 : ∀ (x : BitVec 16),
  ¬ofBool (x &&& 4#16 != 0#16) = 1#1 → ¬ofBool (x &&& 4#16 == 0#16) = 1#1 → 42#32 = 40#32

theorem ashr_bitwidth_mask_proof : ashr_bitwidth_mask_before ⊑ ashr_bitwidth_mask_after

theorem bv_AndOrXor_887_2 :
    ∀ (e e_1 : LLVM.IntW w), LLVM.and (LLVM.icmp LLVM.IntPred.eq e e_1) (LLVM.icmp LLVM.IntPred.ne e e_1) ⊑ LLVM.const? 1 0

theorem findLargestIxOf.eq_iff (x : BitStream) (n : Nat) (value : Bool) :
    (findLargestIxOf x n value = some ix ↔
    (ix ≤ n ∧ x ix = value ∧
      -- it's the larget 'ix < j ≤ n' with value 'value'.
      (∀ (j : Nat), ix < j → j ≤ n → x j ≠ value))) ∧
    (findLargestIxOf x n value = none ↔
      ∀ (j : Nat), j ≤ n → x j ≠ value)

theorem n9_wrong_x2_proof : n9_wrong_x2_before ⊑ n9_wrong_x2_after

theorem main9_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬ofBool (x &&& 64#32 != 0#32) &&& ofBool (truncate 8 x <ₛ 0#8) = 1#1 →
    ofBool (x &&& 192#32 == 192#32) = 1#1 → 1#32 = 2#32

theorem scalar_i32_lshr_and_negC_eq_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬x ≥ ↑32 → ofBool (x_1 >>> x &&& BitVec.ofInt 32 (-262144) == 0#32) = ofBool (x_1 >>> x <ᵤ 262144#32)

theorem lshrugt_01_14_exact_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬(True ∧ x >>> 1#4 <<< 1#4 ≠ x ∨ 1#4 ≥ ↑4) → ofBool (BitVec.ofInt 4 (-2) <ᵤ x >>> 1#4) = 0#1

theorem a_thm.extracted_1._1 : ∀ (x : BitVec 32), 8#32 - x &&& 7#32 = 0#32 - x &&& 7#32

theorem ashrslt_03_02_thm (e : IntW 4) : icmp IntPred.slt (ashr e (const? 4 3)) (const? 4 2) ⊑ const? 1 1

theorem land_land_left1_thm.extracted_1._3 : ∀ (x x_1 : BitVec 1), x_1 = 1#1 → ¬x = 1#1 → 0#1 = x

theorem subAux_inductive_lemma (i : Nat) :
    a.subAux b i = ⟨(a.addAux b.neg i).1, subCarries? a b i⟩

theorem ashrsgt_01_00_proof : ashrsgt_01_00_before ⊑ ashrsgt_01_00_after

theorem trunc_shl_shl_infloop_thm (e : IntW 64) :
  trunc 32 (shl (shl e (const? 64 1)) (const? 64 2)) ⊑ shl (trunc 32 e) (const? 32 3)

theorem test17_proof : test17_before ⊑ test17_after

theorem eq_umax2_proof : eq_umax2_before ⊑ eq_umax2_after

theorem test17_thm (e e_1 : IntW 8) :
  mul (LLVM.or (LLVM.xor e_1 e) (LLVM.xor (LLVM.xor e (const? 8 33)) e_1)) (LLVM.xor (LLVM.xor e (const? 8 33)) e_1) ⊑
    mul (LLVM.or (LLVM.xor e_1 e) (LLVM.xor (LLVM.xor e e_1) (const? 8 33)))
      (LLVM.xor (LLVM.xor e e_1) (const? 8 33))

theorem test_or2_proof : test_or2_before ⊑ test_or2_after

theorem t0_const_lshr_shl_ne_thm.extracted_1._2 : ∀ (x x_1 : BitVec 32),
  ¬(1#32 ≥ ↑32 ∨ 1#32 ≥ ↑32) →
    ¬2#32 ≥ ↑32 → ofBool (x_1 <<< 1#32 &&& x >>> 1#32 != 0#32) = ofBool (x >>> 2#32 &&& x_1 != 0#32)

theorem masked_bit_set_proof : masked_bit_set_before ⊑ masked_bit_set_after

theorem n10_thm.extracted_1._1 : ∀ (x : BitVec 64),
  ¬63#64 ≥ ↑64 → 1#64 - x >>> 63#64 = zeroExtend 64 (ofBool (-1#64 <ₛ x))

theorem test_thm : zext 32 (icmp IntPred.eq (const? 32 1) (const? 32 2)) ⊑ const? 32 0

theorem sdiv_exact_ne_1_proof : sdiv_exact_ne_1_before ⊑ sdiv_exact_ne_1_after

theorem e_650 :
    7 * (x |||  ~~~y) + 4 *  ~~~y - 2 *  ~~~x + 11 * (x ^^^ y) - 7 *  ~~~(x ^^^ y) - 5 * x - 1 *  ~~~(x &&&  ~~~y) + 3 * (x ||| y) - 1 *  ~~~(x ||| y) - 11 *  ~~~(x |||  ~~~y) = 20 * (x &&&  ~~~y) - 3 * (x &&& y)

theorem icmp_x_slt_0_and_icmp_y_ne_neg2_i32_fail_proof : icmp_x_slt_0_and_icmp_y_ne_neg2_i32_fail_before ⊑ icmp_x_slt_0_and_icmp_y_ne_neg2_i32_fail_after

theorem scalar_i32_shl_and_negC_eq_nonzero_thm (e e_1 : IntW 32) :
  icmp IntPred.eq (LLVM.and (shl e_1 e) (const? 32 (-8))) (const? 32 1) ⊑ const? 1 0

theorem slt_thm.extracted_1._1 : ∀ (x : BitVec 64),
  ¬(31#32 ≥ ↑32 ∨ 32#64 ≥ ↑64) →
    31#32 ≥ ↑32 ∨ 32#64 ≥ ↑64 ∨ True ∧ zeroExtend 64 (truncate 32 (x >>> 32#64)) ≠ x >>> 32#64 → False

theorem test_proof : test_before ⊑ test_after

theorem zero_sign_bit_thm (e : IntW 16) :
  add (LLVM.and e (const? 16 32767)) (const? 16 512) ⊑
    add (LLVM.and e (const? 16 32767)) (const? 16 512) { «nsw» := false, «nuw» := true }

theorem masked_and_notA_slightly_optimized_logical_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬ofBool (8#32 ≤ᵤ x) = 1#1 → 0#1 = ofBool (x &&& BitVec.ofInt 32 (-40) != 0#32)

theorem tail_iterate'' {α} {n} {s : Stream' α} : Stream'.iterate Stream'.tail s n m = s (n + m)

theorem trunc_shl_lshr_infloop_thm (e : IntW 64) :
  trunc 32 (shl (lshr e (const? 64 1)) (const? 64 2)) ⊑
    LLVM.and (shl (trunc 32 e) (const? 32 1)) (const? 32 (-4))

theorem or_and2_proof : or_and2_before ⊑ or_and2_after

theorem t2_ashr_thm.extracted_1._2 : ∀ (x : BitVec 8) (x_1 : BitVec 32),
  ¬signExtend 32 x ≥ ↑32 →
    ¬(True ∧ x.msb = true ∨ zeroExtend 32 x ≥ ↑32) →
      x_1.sshiftRight' (signExtend 32 x) = x_1.sshiftRight' (zeroExtend 32 x)

theorem alive_AndOrXor_1294_A__B__A__B___A__B : alive_AndOrXor_1294_A__B__A__B___A__B_src ⊑ alive_AndOrXor_1294_A__B__A__B___A__B_tgt

theorem main2_logical_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x &&& 1#32 == 0#32) = 1#1 → True → 0#32 = zeroExtend 32 (ofBool (x &&& 3#32 == 3#32))

theorem xor_logic_and_logic_or1_thm (e e_1 e_2 : IntW 1) :
  LLVM.xor (select e_2 e_1 (const? 1 0)) (select e_2 (const? 1 1) e) ⊑ select e_2 (LLVM.xor e_1 (const? 1 1)) e

theorem lshr_mul_times_5_div_4_exact_2_thm (e : IntW 32) :
  lshr (mul e (const? 32 5) { «nsw» := false, «nuw» := true }) (const? 32 2) { «exact» := true } ⊑
    add e (lshr e (const? 32 2) { «exact» := true }) { «nsw» := false, «nuw» := true }

theorem test_nuw_nsw_and_signed_pred_proof : test_nuw_nsw_and_signed_pred_before ⊑ test_nuw_nsw_and_signed_pred_after

theorem lt_unsigned_to_large_signed_proof : lt_unsigned_to_large_signed_before ⊑ lt_unsigned_to_large_signed_after

theorem e_1518 :
     - 1 * (a ^^^ (b ^^^ c)) - 1 * (b ^^^ (a &&& (b ||| c))) + 1 *  ~~~(a ||| (b &&& c)) + 3 * ((a &&& c) ||| (b &&&  ~~~c)) - 1 *  ~~~(a ||| (b ||| c)) - 2 *  ~~~(a ||| ( ~~~b ||| c)) + 1 *  ~~~( ~~~a ||| (b ||| c)) - 3 *  ~~~( ~~~a ||| ( ~~~b ||| c)) + 1 * ( ~~~a &&& (b &&& c)) - 2 * (a &&& (b &&& c)) = 2 * (a &&& ( ~~~b &&& c))

theorem select_icmp_x_and_8_ne_0_y_xor_8_thm.extracted_1._2 : ∀ (x : BitVec 64) (x_1 : BitVec 32),
  ofBool (x_1 &&& 8#32 == 0#32) = 1#1 →
    ¬(True ∧ (x_1 &&& 8#32 ^^^ 8#32).msb = true) → x ^^^ 8#64 = x ^^^ zeroExtend 64 (x_1 &&& 8#32 ^^^ 8#32)

theorem icmp_eq_or_z_or_pow2orz_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ofBool (x_1 == 0#8 - x &&& x) ||

theorem or_nosignbit_select_shl_proof : or_nosignbit_select_shl_before ⊑ or_nosignbit_select_shl_after

theorem signed_sign_bit_extract_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬31#32 ≥ ↑32 → ofBool (x.sshiftRight' 31#32 != 0#32) = ofBool (x <ₛ 0#32)

theorem main5f_like_logical_thm.extracted_1._10 : ∀ (x x_1 x_2 : BitVec 32),
  ¬ofBool (x_2 &&& x_1 != x_2) = 1#1 →
    ofBool (x_2 &&& x_1 == x_2) = 1#1 →
      ¬ofBool (x_2 &&& x != x_2) = 1#1 → 1#32 = zeroExtend 32 (ofBool (x_2 &&& x == x_2))

theorem trunc_sel_larger_zext_thm.extracted_1._4 : ∀ (x : BitVec 32) (x_1 : BitVec 1),
  ¬x_1 = 1#1 → zeroExtend 64 42#16 = 42#64

theorem nomask_rhs_logical_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬ofBool (x &&& 1#32 == 0#32) = 1#1 → ofBool (x == 0#32) = ofBool (x &&& 1#32 == 0#32)

theorem ne_smax2_proof : ne_smax2_before ⊑ ne_smax2_after

theorem udiv_lshr_mul_nuw_proof : udiv_lshr_mul_nuw_before ⊑ udiv_lshr_mul_nuw_after

theorem e_596 :
    2 *  ~~~x + 1 * (x ^^^ y) - 1 * x + 2 *  ~~~(x &&&  ~~~x) - 5 *  ~~~y - 1 * (x |||  ~~~y) + 5 *  ~~~(x ||| y) - 5 *  ~~~(x |||  ~~~y) + 4 * (x &&&  ~~~y) + 3 * (x &&& y) = 3 *  ~~~(x ^^^ y)

theorem main10_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x &&& 64#32 == 0#32) &&& ofBool (0#8 ≤ₛ truncate 8 x) = 1#1 →
    ¬ofBool (x &&& 192#32 == 0#32) = 1#1 → 2#32 = 1#32

theorem src_srem_shl_demand_max_mask_proof : src_srem_shl_demand_max_mask_before ⊑ src_srem_shl_demand_max_mask_after

theorem PR24763_thm.extracted_1._1 : ∀ (x : BitVec 8), ¬1#32 ≥ ↑32 → 1#8 ≥ ↑8 → False

theorem src_thm.extracted_1._1 : ∀ (x : BitVec 1),
  ¬(zeroExtend 32 x ≥ ↑32 ∨ zeroExtend 32 x ≥ ↑32) →
    True ∧ ((-1#32) <<< zeroExtend 32 x).sshiftRight' (zeroExtend 32 x) ≠ -1#32 ∨
        zeroExtend 32 x ≥ ↑32 ∨
          True ∧
              ((((-1#32) <<< zeroExtend 32 x ^^^ -1#32) &&& zeroExtend 32 x) <<< zeroExtend 32 x).sshiftRight'
                  (zeroExtend 32 x) ≠
                ((-1#32) <<< zeroExtend 32 x ^^^ -1#32) &&& zeroExtend 32 x ∨
            True ∧
                (((-1#32) <<< zeroExtend 32 x ^^^ -1#32) &&& zeroExtend 32 x) <<< zeroExtend 32 x >>> zeroExtend 32 x ≠
                  ((-1#32) <<< zeroExtend 32 x ^^^ -1#32) &&& zeroExtend 32 x ∨
              zeroExtend 32 x ≥ ↑32 →
      False

theorem ashr_sle_exact_thm (e : IntW 8) :
  icmp IntPred.sle (ashr e (const? 8 3) { «exact» := true }) (const? 8 10) ⊑
    icmp IntPred.slt e (const? 8 88)

theorem main5e_like_logical_thm.extracted_1._2 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (x_1 &&& x == x_1) = 1#1 → ofBool (x_1 &&& x != x_1) = 1#1 → ¬0#1 = 1#1 → 1#32 = zeroExtend 32 1#1

theorem positive_sameconst_ashrexact_proof : positive_sameconst_ashrexact_before ⊑ positive_sameconst_ashrexact_after

theorem e_2490 :
     - 3 * (f ^^^  ~~~(d ||| ( ~~~e &&& f))) - 11 * (d ^^^ e) + 3 * ( ~~~(d &&& e) &&& (e ^^^ f)) + 3 * (f &&&  ~~~(d ^^^ e)) + 5 * (f ^^^  ~~~(d |||  ~~~e)) + 2 * ( ~~~(d &&& e) &&& (d ^^^ (e ^^^ f))) + 1 * (d ^^^ (e ||| f)) + 7 * (e ^^^ (d &&& (e ||| f))) + 5 * (e ^^^  ~~~( ~~~d &&& ( ~~~e &&& f))) + 5 * ( ~~~(d ||| e) ||| (d ^^^ (e ^^^ f))) - 1 * ((d ^^^ e) &&&  ~~~(d ^^^ f)) + 7 * ((d &&& e) ^^^ (e |||  ~~~f)) + 3 * ( ~~~d ||| ( ~~~e &&& f)) - 11 * ((d ^^^ e) ||| (d ^^^ f)) + 1 * ( ~~~e ||| (d ^^^ f)) - 3 * (f ^^^ (d ||| (e &&& f))) + 2 * (d &&& e) - 5 * (e ||| f) - 2 *  ~~~(d ^^^ (e ^^^ f)) + 1 * ( ~~~d ||| ( ~~~e ||| f)) - 11 * ((d |||  ~~~e) &&&  ~~~(d ^^^ (e ^^^ f))) - 1 * (e ||| (d &&& f)) - 7 * ((d ^^^ e) |||  ~~~(d ^^^ f)) + 7 * ((e &&&  ~~~f) ^^^ (d ||| (e ^^^ f))) + 7 * ((d ||| e) &&&  ~~~(e ^^^ f)) - 1 * ((d &&& f) ^^^ (d ^^^ ( ~~~e &&& f))) - 2 * (f &&&  ~~~(d &&& e)) - 2 *  ~~~(d &&&  ~~~e) + 5 *  ~~~( ~~~d &&& ( ~~~e ||| f)) - 1 * ((d &&& e) ^^^ (d ^^^ (e &&& f))) + 2 * (e ^^^ (d &&&  ~~~f)) - 6 * ( ~~~(d ^^^ e) |||  ~~~(d ^^^ f)) + 5 * (f ^^^  ~~~(d &&& ( ~~~e ||| f))) - 2 * (f ^^^  ~~~( ~~~d ||| (e &&& f))) - 11 *  ~~~e + 2 * (e ^^^ f) - 2 * (e ^^^ ( ~~~d ||| ( ~~~e ||| f))) + 1 * (d &&&  ~~~f) + 5 * ((d &&& f) ^^^ (d ^^^ (e &&& f))) - 1 * ((e &&& f) ^^^  ~~~( ~~~d &&& (e ^^^ f))) + 2 * (e ^^^ (d |||  ~~~f)) - 1 * ( ~~~(d |||  ~~~e) |||  ~~~(d ^^^ (e ^^^ f))) - 1 * (e ^^^ (d ||| ( ~~~e &&& f))) + 2 *  ~~~(d ^^^ (e &&& f)) - 5 *  ~~~f + 1 * f + 3 * (d ||| (e &&& f)) + 4 * (f ^^^ ( ~~~d ||| (e &&& f))) - 2 *  ~~~(d &&& e) + 4 * (e ^^^  ~~~(d &&& ( ~~~e &&& f))) - 2 * (f ^^^  ~~~(d &&& (e &&& f))) - 3 * ( ~~~(d &&&  ~~~e) &&&  ~~~(e ^^^ f)) + 7 * (e ^^^  ~~~( ~~~d ||| (e ^^^ f))) + 7 * ( ~~~(d |||  ~~~e) |||  ~~~(e ^^^ f)) + 1 * (e &&& (d ^^^ f)) + 2 * (f ^^^ (d &&& (e ||| f))) + 2 * ( ~~~f &&& (d ^^^ e)) - 3 * (e ^^^ (d &&& (e ^^^ f))) - 1 * ((d |||  ~~~e) &&& (e ^^^ f)) + 4 * (f ^^^ ( ~~~d &&& ( ~~~e ||| f))) + 11 *  ~~~(e &&& f) + 11 *  ~~~(d &&& (e ^^^ f)) + 2 * (f ^^^ ( ~~~d &&& (e ||| f))) + 4 * (e ^^^  ~~~( ~~~d &&& (e ^^^ f))) - 7 * ((e &&& f) ^^^  ~~~(d &&& (e ^^^ f))) - 7 * (d ||| e) - 1 * ( ~~~(d &&&  ~~~e) &&& (e ^^^ f)) + 1 * (d ||| ( ~~~e ||| f)) - 1 * ((e &&& f) ||| ( ~~~d &&& (e ||| f))) - 2 * (e ^^^ (d &&& ( ~~~e ||| f))) - 7 * ( ~~~(d ||| e) |||  ~~~(e ^^^ f)) + 1 * (f |||  ~~~(d ^^^ e)) - 7 * (e ^^^  ~~~( ~~~d ||| (e &&& f))) - 7 * ( ~~~e &&& (d ^^^ f)) + 7 *  ~~~(d &&& f) - 14 *  ~~~(d ||| (e ||| f)) - 20 *  ~~~(d ||| ( ~~~e ||| f)) - 12 *  ~~~( ~~~d ||| (e ||| f)) + 11 *  ~~~( ~~~d ||| ( ~~~e ||| f)) + 1 * ( ~~~d &&& (e &&& f)) + 22 * (d &&& ( ~~~e &&& f)) - 23 * (d &&& (e &&& f)) =  - 1 * ( ~~~f |||  ~~~(d ^^^ e)) - 1 *  ~~~(e |||  ~~~f)

theorem test4_thm (e : IntW 32) :
  sext 64 (LLVM.udiv e (const? 32 3)) ⊑ zext 64 (LLVM.udiv e (const? 32 3)) { «nneg» := true }

theorem eq_basic_proof : eq_basic_before ⊑ eq_basic_after

theorem test4_thm.extracted_1._1 : ∀ (x x_1 : BitVec 67),
  ¬66#67 ≥ ↑67 → (x_1 ||| x >>> 66#67) &&& 2#67 = x_1 &&& 2#67

theorem bools_logical_commute3_and2_thm.extracted_1._9 : ∀ (x x_1 x_2 : BitVec 1),
  x_2 = 1#1 → ¬x_1 = 1#1 → x_1 ^^^ 1#1 = 1#1 → 1#1 = x_2

theorem and_xor_commute3_proof : and_xor_commute3_before ⊑ and_xor_commute3_after

theorem test_shl__none_are_safe_thm.extracted_1._2 : ∀ (x : BitVec 64) (x_1 : BitVec 32),
  ofBool (x_1 &&& BitVec.ofInt 32 (-2) == 0#32) = 1#1 →
    ¬(2#32 ≥ ↑32 ∨
          True ∧ (x_1 <<< 2#32 &&& BitVec.ofInt 32 (-8)).msb = true ∨
            zeroExtend 64 (x_1 <<< 2#32 &&& BitVec.ofInt 32 (-8)) ≥ ↑64) →
      x = x.sshiftRight' (zeroExtend 64 (x_1 <<< 2#32 &&& BitVec.ofInt 32 (-8)))

theorem logic_and_logic_or_2_thm.extracted_1._4 : ∀ (x x_1 : BitVec 1), ¬x_1 = 1#1 → 0#1 = 1#1 → False

theorem ne_commuted_equal_minus_1_proof : ne_commuted_equal_minus_1_before ⊑ ne_commuted_equal_minus_1_after

theorem test_with_neg_even_proof : test_with_neg_even_before ⊑ test_with_neg_even_after

theorem or_and_not_not_commute6_thm.extracted_1._2 : ∀ (x x_1 x_2 : BitVec 32),
  ¬((x_2 == 0 || 32 != 1 && 42#32 == intMin 32 && x_2 == -1) = true ∨
        (x_2 == 0 || 32 != 1 && 42#32 == intMin 32 && x_2 == -1) = true) →
    ¬(x_2 == 0 || 32 != 1 && 42#32 == intMin 32 && x_2 == -1) = true →
      (42#32).sdiv x_2 &&& ((x_1 ||| x) ^^^ -1#32) ||

theorem e_1721 :
     - 1 * ( ~~~(a &&&  ~~~b) &&&  ~~~(a ^^^ (b ^^^ c))) - 2 * (a ^^^ c) - 3 * ((a ^^^ b) ||| (a ^^^ c)) - 5 * ((a |||  ~~~b) &&& (b ^^^ c)) - 1 * (c ^^^ (a &&& ( ~~~b ||| c))) + 5 * ( ~~~a ||| (b ^^^ c)) - 7 * ((b &&&  ~~~c) |||  ~~~(a ||| ( ~~~b &&& c))) + 2 * (a ^^^ ( ~~~b &&& c)) + 2 * ( ~~~(a &&&  ~~~b) &&&  ~~~(b ^^^ c)) - 7 * (c |||  ~~~(a ||| b)) + 7 * ( ~~~(a |||  ~~~b) |||  ~~~(a ^^^ (b ^^^ c))) - 6 * (b ^^^ ( ~~~a ||| (b &&& c))) + 11 * (c &&&  ~~~(a ^^^ b)) + 1 * (a ^^^ ( ~~~b ||| c)) - 1 * (a ||| (b ^^^ c)) - 5 * (b ^^^ (a &&& c)) - 6 * (b |||  ~~~(a |||  ~~~c)) + 5 * ((a &&&  ~~~b) ||| (a ^^^ (b ^^^ c))) + 2 * (a &&& (b ||| c)) - 1 * ((a &&& c) ||| (b &&&  ~~~c)) - 3 * (a |||  ~~~c) - 7 * (c ^^^  ~~~( ~~~a &&& ( ~~~b &&& c))) - 11 * (c ||| (a &&& b)) + 16 *  ~~~(a ||| (b ||| c)) + 16 *  ~~~(a ||| ( ~~~b ||| c)) + 13 *  ~~~( ~~~a ||| (b ||| c)) + 41 *  ~~~( ~~~a ||| ( ~~~b ||| c)) + 25 * ( ~~~a &&& ( ~~~b &&& c)) + 28 * ( ~~~a &&& (b &&& c)) + 20 * (a &&& ( ~~~b &&& c)) + 10 * (a &&& (b &&& c)) = 3 * (a &&& ( ~~~b ||| c))

theorem zext_nneg_thm.extracted_1._1 : ∀ (x : BitVec 16),
  ¬(True ∧ (x &&& 32767#16).msb = true) →
    zeroExtend 24 (x &&& 32767#16) &&& 8388607#24 = zeroExtend 24 (x &&& 32767#16)

theorem test_proof : test_before ⊑ test_after

theorem mul_select_zext_thm.extracted_1._3 : ∀ (x : BitVec 64) (x_1 : BitVec 1),
  ¬x_1 = 1#1 → 1#64 * zeroExtend 64 x_1 = 0#64

theorem test1_proof : test1_before ⊑ test1_after

theorem icmp_eq_and1_lshr_pow2_thm (e : IntW 32) :
  zext 32 (icmp IntPred.eq (LLVM.and (lshr (const? 32 8) e) (const? 32 1)) (const? 32 0)) ⊑
    zext 32 (icmp IntPred.ne e (const? 32 3))

theorem shl_nsw_sgt_n1_thm (e e_1 : IntW 8) :
  icmp IntPred.sgt (shl e_1 e { «nsw» := true, «nuw» := false }) (const? 8 (-1)) ⊑
    icmp IntPred.sgt e_1 (const? 8 (-1))

theorem ashr_mul_thm.extracted_1._2 : ∀ (x x_1 : BitVec 8),
  ¬8#20 ≥ ↑20 →
    ¬(True ∧ (signExtend 16 x_1).smulOverflow (signExtend 16 x) = true ∨ 8#16 ≥ ↑16) →
      truncate 16 ((signExtend 20 x_1 * signExtend 20 x).sshiftRight' 8#20) =
        (signExtend 16 x_1 * signExtend 16 x).sshiftRight' 8#16

theorem e_218 :
    5 *  ~~~(x &&&  ~~~x) - 7 *  ~~~(x &&& y) - 2 * (x ^^^ y) - 3 *  ~~~(x ||| y) + 4 *  ~~~(x |||  ~~~y) - 1 * (x &&&  ~~~y) - 10 * (x &&& y) =  - 5 * (x |||  ~~~y)

theorem ule_and_min_commute_proof : ule_and_min_commute_before ⊑ ule_and_min_commute_after

theorem test_shl__none_are_safe_thm.extracted_1._1 : ∀ (x : BitVec 64) (x_1 : BitVec 32),
  ofBool (x_1 &&& BitVec.ofInt 32 (-2) == 0#32) = 1#1 →
    2#32 ≥ ↑32 ∨
        True ∧ (x_1 <<< 2#32 &&& BitVec.ofInt 32 (-8)).msb = true ∨
          zeroExtend 64 (x_1 <<< 2#32 &&& BitVec.ofInt 32 (-8)) ≥ ↑64 →
      False

theorem PR60818_sgt_proof : PR60818_sgt_before ⊑ PR60818_sgt_after

theorem bools_logical_commute1_and2_proof : bools_logical_commute1_and2_before ⊑ bools_logical_commute1_and2_after

theorem test23_proof : test23_before ⊑ test23_after

theorem shrink_and_thm (e : IntW 64) :
  trunc 31 (LLVM.and e (const? 64 42)) ⊑ trunc 31 (LLVM.and e (const? 64 42)) { «nsw» := true, «nuw» := true }

theorem or_consts_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (4#32 &&& x != 0#32) &&& ofBool (8#32 &&& x != 0#32) = ofBool (x &&& 12#32 == 12#32)

theorem main3d_logical_thm.extracted_1._4 : ∀ (x : BitVec 32),
  ¬ofBool (x &&& 7#32 != 0#32) = 1#1 →
    ¬ofBool (x &&& 16#32 == 16#32) = 1#1 → 1#32 = zeroExtend 32 (ofBool (x &&& 23#32 == 0#32))

theorem e_1673 :
     - 1 * ( ~~~(a ^^^ b) &&&  ~~~(a ^^^ c)) + 3 * (b ^^^  ~~~(a &&& ( ~~~b ||| c))) - 3 * (b |||  ~~~(a |||  ~~~c)) - 6 * (a ||| ( ~~~b ||| c)) - 1 * (b ^^^ (a ||| ( ~~~b ||| c))) + 2 * ( ~~~c |||  ~~~(a ^^^ b)) - 1 * (c ^^^ (a ||| (b ||| c))) + 5 * (b &&&  ~~~(a ^^^ c)) - 1 * (b ^^^  ~~~( ~~~a &&& (b &&& c))) + 2 * (b ^^^  ~~~(a ||| c)) - 1 * (c ^^^ (a ||| ( ~~~b ||| c))) - 2 * (a &&&  ~~~c) + 11 * ((a ||| b) &&&  ~~~(b ^^^ c)) + 1 * (b ^^^  ~~~(a &&& ( ~~~b &&& c))) - 1 * (b ^^^  ~~~( ~~~a ||| ( ~~~b &&& c))) - 1 *  ~~~( ~~~a ||| (b ^^^ c)) + 2 * ( ~~~(a ||| b) ||| (a ^^^ (b ^^^ c))) + 7 * (c |||  ~~~(a ^^^ b)) - 7 *  ~~~(a ||| (b ||| c)) - 3 *  ~~~(a ||| ( ~~~b ||| c)) - 11 *  ~~~( ~~~a ||| (b ||| c)) - 3 *  ~~~( ~~~a ||| ( ~~~b ||| c)) - 4 * ( ~~~a &&& ( ~~~b &&& c)) - 9 * ( ~~~a &&& (b &&& c)) - 8 * (a &&& ( ~~~b &&& c)) - 21 * (a &&& (b &&& c)) =  - 4 * (a &&&  ~~~b) - 5 *  ~~~( ~~~a ||| (b &&& c))

theorem lshr_sext_i1_to_i128_thm.extracted_1._2 : ∀ (x : BitVec 1),
  ¬42#128 ≥ ↑128 → ¬x = 1#1 → signExtend 128 x >>> 42#128 = 0#128

theorem lshrult_01_15_proof : lshrult_01_15_before ⊑ lshrult_01_15_after

theorem ashrslt_03_12_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬3#4 ≥ ↑4 → ofBool (x.sshiftRight' 3#4 <ₛ BitVec.ofInt 4 (-4)) = 0#1

theorem exact_lshr_ne_proof : exact_lshr_ne_before ⊑ exact_lshr_ne_after

theorem zext_or_eq_ult_add_thm (e : IntW 32) :
  zext 32
      (LLVM.or (icmp IntPred.ult (add e (const? 32 (-3))) (const? 32 3)) (icmp IntPred.eq e (const? 32 5))) ⊑
    zext 32 (icmp IntPred.ult (add e (const? 32 (-3))) (const? 32 3))

theorem nomask_lhs_logical_thm (e : IntW 32) :
  select (icmp IntPred.eq e (const? 32 0)) (const? 1 1)
      (icmp IntPred.eq (LLVM.and e (const? 32 1)) (const? 32 0)) ⊑
    icmp IntPred.eq (LLVM.and e (const? 32 1)) (const? 32 0)

theorem and_or_hoist_mask_proof : and_or_hoist_mask_before ⊑ and_or_hoist_mask_after

theorem not_mul_of_pow2_proof : not_mul_of_pow2_before ⊑ not_mul_of_pow2_after

theorem ashrslt_03_07_thm (e : IntW 4) : icmp IntPred.slt (ashr e (const? 4 3)) (const? 4 7) ⊑ const? 1 1

theorem neg_sgt_1_proof : neg_sgt_1_before ⊑ neg_sgt_1_after

theorem sle_smax1_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ofBool (x <ₛ x_1) = 1#1 → ofBool (x_1 ≤ₛ x_1) = ofBool (x ≤ₛ x_1)

theorem positive_biggerashr_shlnsw_ashrexact_proof : positive_biggerashr_shlnsw_ashrexact_before ⊑ positive_biggerashr_shlnsw_ashrexact_after

theorem not_cond_proof : not_cond_before ⊑ not_cond_after

theorem test5_thm.extracted_1._1 : ∀ (x : BitVec 700),
  (x ||| 288230376151711743#700) ^^^ 288230376151711743#700 = x &&& BitVec.ofInt 700 (-288230376151711744)

theorem trunc_sel_smaller_zext_thm.extracted_1._3 : ∀ (x : BitVec 64) (x_1 : BitVec 1),
  ¬x_1 = 1#1 → zeroExtend 32 42#16 = 42#32

theorem ult_rem_nz_thm (e : IntW 8) :
  icmp IntPred.ult (mul e (const? 8 5) { «nsw» := false, «nuw» := true }) (const? 8 21) ⊑
    icmp IntPred.ult e (const? 8 5)

theorem eval_fsmTermUle_eq_decide_le {wcard tcard : Nat}
    (tctx : Term.Ctx wcard tcard)
    {wenv : WidthExpr.Env wcard}
    (tenv : tctx.Env wenv)
    (benv : Term.BoolEnv bcard)
    (nenv : Term.NatEnv ncard)
    (ienv : Term.IntEnv icard)
    (w : WidthExpr wcard)
    (a : Term bcard ncard icard pcard tctx (.bv w))
    (b : Term bcard ncard icard pcard tctx (.bv w))
    (afsm : TermFSM wcard tcard bcard ncard icard pcard (.ofDepTerm a))
    (hafsm : HTermFSMToBitStream afsm)
    (bfsm : TermFSM wcard tcard bcard ncard icard pcard (.ofDepTerm b))
    (hbfsm : HTermFSMToBitStream bfsm)
    (fsmEnv : StateSpace wcard tcard bcard ncard icard pcard → BitStream)
    (henv : HTermEnv fsmEnv tenv benv)
    :
    ((fsmTermUle
      afsm
      bfsm)).eval fsmEnv i =
       decide (((a.toBV benv nenv ienv penv tenv).setWidth i) ≤ ((b.toBV benv nenv ienv penv tenv).setWidth i))

theorem fold_icmp_shl_nuw_c2_indivisible_proof : fold_icmp_shl_nuw_c2_indivisible_before ⊑ fold_icmp_shl_nuw_c2_indivisible_after

theorem lowmask_or_zext_commute_thm.extracted_1._1 : ∀ (x : BitVec 16) (x_1 : BitVec 24),
  (x_1 ||| zeroExtend 24 x) &&& 65535#24 = zeroExtend 24 (x ||| truncate 16 x_1)

theorem positive_biggerashr_proof : positive_biggerashr_before ⊑ positive_biggerashr_after

theorem e_1129 :
     - 1 * (z |||  ~~~t) + 5 *  ~~~(z ^^^ t) + 5 *  ~~~(z &&&  ~~~z) + 11 * t - 3 *  ~~~z - 6 *  ~~~(z ||| t) - 4 * (z &&&  ~~~t) - 20 * (z &&& t) = 13 *  ~~~(z |||  ~~~t)

theorem masked_and_notA_proof : masked_and_notA_before ⊑ masked_and_notA_after

theorem test_negative_nsw_and_unsigned_pred_thm.extracted_1._1 : ∀ (x : BitVec 64),
  ¬(True ∧ (10#64).ssubOverflow x = true) → ofBool (10#64 - x <ᵤ 3#64) = ofBool (x + BitVec.ofInt 64 (-8) <ᵤ 3#64)

theorem lshrult_02_04_exact_proof : lshrult_02_04_exact_before ⊑ lshrult_02_04_exact_after

theorem test1_proof : test1_before ⊑ test1_after

theorem ule_swap_or_min_logical_proof : ule_swap_or_min_logical_before ⊑ ule_swap_or_min_logical_after

theorem select_add_icmp_bad_thm.extracted_1._2 : ∀ (x x_1 x_2 : BitVec 32),
  ofBool (x_2 == 1#32) = 1#1 → x_2 + x_1 = x_1 + 1#32

theorem ule_swap_or_min_logical_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ofBool (x ≤ᵤ x_1) = 1#1 → 1#1 = ofBool (x ≤ᵤ x_1)

theorem test_and_xor_freely_invertable_proof : test_and_xor_freely_invertable_before ⊑ test_and_xor_freely_invertable_after

theorem nonexact_ashr_ne_noexactdiv_proof : nonexact_ashr_ne_noexactdiv_before ⊑ nonexact_ashr_ne_noexactdiv_after

theorem test3_thm.extracted_1._1 : ∀ (x : BitVec 64), zeroExtend 64 (truncate 8 x) = x &&& 255#64

theorem masked_icmps_mask_notallzeros_bmask_mixed_negated_5_logical_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x &&& 15#32 == 0#32) = 1#1 → 1#1 = ofBool (x &&& 15#32 != 8#32)

theorem masked_icmps_mask_notallzeros_bmask_mixed_negated_swapped_3_thm (e : IntW 32) :
  LLVM.or (icmp IntPred.ne (LLVM.and e (const? 32 7)) (const? 32 0))
      (icmp IntPred.eq (LLVM.and e (const? 32 15)) (const? 32 0)) ⊑
    icmp IntPred.ne (LLVM.and e (const? 32 15)) (const? 32 8)

theorem e_1914 :
     - 6 * (b ^^^  ~~~( ~~~a &&& ( ~~~b ||| c))) - 1 * ( ~~~(a ^^^ b) |||  ~~~(a ^^^ c)) - 2 * (a ||| b) - 1 *  ~~~(b &&&  ~~~c) - 6 * (c ^^^ (a &&& (b ||| c))) - 1 * (b ^^^  ~~~(a &&& c)) - 1 * (b ^^^ (a ||| ( ~~~b ||| c))) - 2 * (b ^^^  ~~~( ~~~a ||| ( ~~~b &&& c))) + 1 *  ~~~(b |||  ~~~c) - 3 * (c ^^^ ( ~~~a ||| (b ||| c))) - 5 * (b ^^^  ~~~(a &&& (b &&& c))) - 11 * (b ^^^  ~~~(a ||| (b ^^^ c))) + 7 *  ~~~(a |||  ~~~b) + 3 * (c ^^^  ~~~(a ||| b)) - 6 * (b ||| (a &&&  ~~~c)) - 2 * ( ~~~(a &&& b) &&& (b ^^^ c)) + 5 *  ~~~(a &&&  ~~~c) + 4 * (b &&&  ~~~(a ^^^ c)) + 2 * (b ||| c) + 1 * ((a &&&  ~~~b) |||  ~~~(a ^^^ (b ^^^ c))) + 3 * ( ~~~a &&& ( ~~~b ||| c)) + 3 *  ~~~(a &&& c) + 11 * (c ^^^ (a &&& ( ~~~b ||| c))) + 1 * (c ^^^  ~~~(a &&& (b &&& c))) + 1 * (b ^^^  ~~~( ~~~a &&& (b &&& c))) - 7 * ((a &&& b) ^^^ (a ^^^ ( ~~~b ||| c))) + 1 * (a |||  ~~~c) - 5 * (b &&&  ~~~c) + 2 * (b ||| (a &&& c)) + 4 * (b ^^^ (a &&&  ~~~c)) - 5 * ( ~~~a ||| (b ||| c)) - 7 * ( ~~~(a &&& b) &&&  ~~~(b ^^^ c)) - 7 * ((a |||  ~~~b) &&& (a ^^^ (b ^^^ c))) - 3 * ((a &&& b) ||| (b ^^^ c)) + 4 * ( ~~~c &&& (a ^^^ b)) - 1 * ( ~~~c &&&  ~~~(a ^^^ b)) - 2 *  ~~~(b &&& c) + 2 * ((a &&& b) ^^^  ~~~(a ^^^ (b &&& c))) - 1 *  ~~~(a &&& (b ||| c)) + 11 *  ~~~(a ^^^ c) + 1 *  ~~~(a ^^^ b) - 6 *  ~~~(a ^^^ (b ^^^ c)) + 20 *  ~~~(a ||| (b ||| c)) - 2 *  ~~~(a ||| ( ~~~b ||| c)) + 22 *  ~~~( ~~~a ||| (b ||| c)) + 38 *  ~~~( ~~~a ||| ( ~~~b ||| c)) + 13 * ( ~~~a &&& ( ~~~b &&& c)) + 7 * ( ~~~a &&& (b &&& c)) + 14 * (a &&& ( ~~~b &&& c)) + 15 * (a &&& (b &&& c)) = 7 * (a &&&  ~~~b)

theorem sext_sub_const_thm.extracted_1._1 : ∀ (x : BitVec 1), x = 1#1 → 42#64 - signExtend 64 x = 43#64

theorem e_2287 :
    2 * ((e &&&  ~~~f) ^^^ (d ||| (e ^^^ f))) + 2 * (f ^^^ ( ~~~d ||| (e ||| f))) - 1 * (d ^^^ (e &&& f)) - 5 * ( ~~~d ||| (e ^^^ f)) + 11 * ((d |||  ~~~e) &&& (e ^^^ f)) - 1 * (f ^^^  ~~~(d ||| (e &&& f))) - 2 *  ~~~(d ||| ( ~~~e &&& f)) - 1 * ( ~~~(d ^^^ e) &&& (d ^^^ f)) - 5 * ( ~~~(d &&& e) &&&  ~~~(d ^^^ (e ^^^ f))) + 1 * ( ~~~e ||| (d ^^^ f)) + 3 * (e ^^^  ~~~( ~~~d ||| ( ~~~e &&& f))) + 11 * d - 11 * (f ^^^ ( ~~~d ||| ( ~~~e &&& f))) + 4 * (f ^^^  ~~~( ~~~d &&& ( ~~~e &&& f))) - 7 * (f &&&  ~~~(d &&&  ~~~e)) + 2 * ( ~~~(d ||| e) ||| (e ^^^ f)) + 3 * (e ^^^ ( ~~~d ||| (e ^^^ f))) + 1 *  ~~~(d &&&  ~~~e) + 5 * (d ||| (e ^^^ f)) - 1 *  ~~~( ~~~d &&& ( ~~~e &&& f)) + 2 * (e ||| (d &&& f)) - 1 *  ~~~(d ^^^ e) + 2 * (e ^^^  ~~~(d &&& ( ~~~e ||| f))) - 7 * ((d &&& e) ||| (d ^^^ (e ^^^ f))) - 5 * (f ||| (d &&& e)) + 1 * (e &&& (d |||  ~~~f)) - 1 * ((d &&& e) ^^^ (d ^^^ ( ~~~e ||| f))) + 3 * ((e &&& f) ||| ( ~~~d &&& (e ||| f))) - 1 *  ~~~(d &&& e) + 1 * (f ^^^  ~~~(d &&& ( ~~~e &&& f))) - 7 * (e &&&  ~~~(d &&&  ~~~f)) - 1 * (f ||| (d ^^^ e)) - 5 * (e ^^^  ~~~(d ||| f)) + 2 *  ~~~(d ||| (e ^^^ f)) + 7 * ( ~~~(d &&&  ~~~e) &&& (d ^^^ (e ^^^ f))) + 1 * (d &&& e) + 2 * ( ~~~d ||| (e ||| f)) + 2 * (d ^^^ (e ^^^ f)) + 5 * (e |||  ~~~(d ||| f)) - 3 * ((d ^^^ e) ||| (d ^^^ f)) - 2 * (f ^^^ (d ||| (e ||| f))) - 11 *  ~~~(d ||| f) - 2 * (d ||| f) - 7 * ( ~~~(d &&& e) &&& (e ^^^ f)) + 7 *  ~~~(d &&&  ~~~f) + 1 * (f ^^^ (d &&& (e ||| f))) + 1 * e + 2 * ((d &&& e) ^^^  ~~~(d ^^^ ( ~~~e ||| f))) - 1 *  ~~~(d &&& ( ~~~e ||| f)) + 3 * ( ~~~f &&& (d ^^^ e)) + 7 * ( ~~~(d ^^^ e) ||| (d ^^^ f)) + 4 * ((d &&&  ~~~e) ||| (e ^^^ f)) + 1 *  ~~~(d ^^^ (e ^^^ f)) + 5 *  ~~~(d ||| (e ||| f)) + 4 *  ~~~(d ||| ( ~~~e ||| f)) - 20 *  ~~~( ~~~d ||| (e ||| f)) - 31 *  ~~~( ~~~d ||| ( ~~~e ||| f)) - 16 * ( ~~~d &&& ( ~~~e &&& f)) + 13 * ( ~~~d &&& (e &&& f)) - 16 * (d &&& ( ~~~e &&& f)) - 12 * (d &&& (e &&& f)) = 6 * (e ^^^ (d ||| (e ||| f))) + 1 * (e ^^^ (d &&&  ~~~f))

theorem test8_proof : test8_before ⊑ test8_after

theorem test7_logical_thm.extracted_1._3 : ∀ (x : BitVec 32),
  ¬ofBool (x <ₛ 1#32) = 1#1 → ¬ofBool (x == 0#32) = 1#1 → 0#1 = 1#1 → ofBool (-1#32 <ₛ x) = 0#1

theorem alive_820'   : alive_820'_src ⊑ alive_820'_tgt

theorem bools_multi_uses1_logical_thm.extracted_1._13 : ∀ (x x_1 x_2 : BitVec 1),
  x_2 ^^^ 1#1 = 1#1 → x_2 = 1#1 → x_1 = 1#1 → 1#1 ^^^ x_1 = x ^^^ x_1

theorem e_2225 :
     - 6 * (e ^^^ ( ~~~d ||| ( ~~~e &&& f))) - 3 * ( ~~~(d |||  ~~~e) ||| (d ^^^ (e ^^^ f))) + 4 * (f ^^^  ~~~( ~~~d &&& (e &&& f))) + 1 * (f ||| (d &&& e)) - 7 * (f ^^^  ~~~(d &&& e)) + 1 * (e |||  ~~~(d ^^^ f)) - 2 * (e ^^^  ~~~(d ||| (e ^^^ f))) + 7 *  ~~~(d &&& (e &&& f)) + 2 * ((d ||| e) &&& (e ^^^ f)) - 1 *  ~~~( ~~~d ||| (e &&& f)) + 1 * ((d |||  ~~~e) &&& (d ^^^ (e ^^^ f))) - 2 * (e ||| (d ^^^ f)) + 5 * (d &&& ( ~~~e ||| f)) + 4 * ((d ^^^ e) |||  ~~~(d ^^^ f)) - 1 * (d ^^^ ( ~~~e ||| f)) + 2 * (d ||| (e ^^^ f)) - 6 * ((d ^^^ e) &&&  ~~~(d ^^^ f)) + 11 *  ~~~( ~~~d &&& (e &&& f)) - 11 *  ~~~( ~~~d &&& ( ~~~e &&& f)) + 7 * (d ||| ( ~~~e &&& f)) - 7 * ( ~~~d &&& (e ^^^ f)) + 7 *  ~~~(d ^^^ e) - 1 * (d |||  ~~~e) + 1 * ((d ^^^ e) ||| (d ^^^ f)) - 11 *  ~~~( ~~~d ||| ( ~~~e &&& f)) - 1 * (e ^^^ ( ~~~d ||| (e ^^^ f))) + 7 * ((d &&& e) ^^^  ~~~(d ^^^ ( ~~~e ||| f))) + 2 * (e ||| (d &&& f)) - 6 * (f &&&  ~~~(d ^^^ e)) + 1 * ((d &&& e) ^^^ (d ^^^ ( ~~~e ||| f))) - 1 * (f &&&  ~~~(d &&& e)) + 11 * ((d &&& e) |||  ~~~(e ||| f)) - 2 * ((d &&& f) ^^^ (d ^^^ ( ~~~e &&& f))) - 1 *  ~~~(d ||| (e &&& f)) - 6 * ( ~~~(d ^^^ e) &&&  ~~~(d ^^^ f)) - 2 *  ~~~(d ||| (e ^^^ f)) - 1 * ((e &&&  ~~~f) ^^^ (d ||| (e ^^^ f))) - 1 * (f |||  ~~~(d |||  ~~~e)) + 5 * (e ^^^ (d ||| ( ~~~e ||| f))) - 2 * (e ^^^ (d &&& (e ^^^ f))) + 1 * ((d &&& e) |||  ~~~(d ^^^ (e ^^^ f))) + 5 * ((d &&&  ~~~e) |||  ~~~(e ^^^ f)) - 3 * (f ^^^ (d &&& e)) + 3 *  ~~~(d ^^^ ( ~~~e ||| f)) + 1 * ( ~~~f |||  ~~~(d ^^^ e)) + 1 * (f ^^^ ( ~~~d ||| ( ~~~e &&& f))) - 15 *  ~~~(d ||| (e ||| f)) - 3 *  ~~~(d ||| ( ~~~e ||| f)) - 35 *  ~~~( ~~~d ||| (e ||| f)) - 19 *  ~~~( ~~~d ||| ( ~~~e ||| f)) - 2 * ( ~~~d &&& ( ~~~e &&& f)) + 5 * ( ~~~d &&& (e &&& f)) - 22 * (d &&& ( ~~~e &&& f)) - 4 * (d &&& (e &&& f)) = 6 * ( ~~~d ||| (e ^^^ f))

theorem test7_proof : test7_before ⊑ test7_after

theorem multiuse_add_thm.extracted_1._2 : ∀ (x : BitVec 1), ¬x = 1#1 → 1#64 + zeroExtend 64 x + 1#64 = 2#64

theorem e_786 :
     - 1 *  ~~~t - 1 * (z |||  ~~~t) - 7 * z + 2 *  ~~~(z ||| t) + 9 * (z &&&  ~~~t) =  - 8 * (z &&& t)

theorem trunc_shl_16_i32_i64_thm.extracted_1._2 : ∀ (x : BitVec 64),
  ¬16#64 ≥ ↑64 → ¬16#32 ≥ ↑32 → truncate 32 (x <<< 16#64) = truncate 32 x <<< 16#32

theorem e_2375 :
     - 3 *  ~~~(d ^^^ ( ~~~e &&& f)) - 7 * (f ^^^  ~~~( ~~~d ||| (e &&& f))) + 1 * (d &&& f) + 11 * (e ^^^  ~~~(d &&& (e ||| f))) + 1 * (e ^^^ (d &&&  ~~~f)) + 7 * (f ^^^  ~~~(d &&& ( ~~~e &&& f))) - 7 * ( ~~~d ||| ( ~~~e ||| f)) - 3 * (d ^^^ ( ~~~e ||| f)) - 1 * ( ~~~(d &&&  ~~~e) &&&  ~~~(d ^^^ (e ^^^ f))) - 6 * (f ^^^ (d ||| (e &&& f))) - 7 * (d |||  ~~~f) + 11 * ((d ||| e) &&&  ~~~(d ^^^ (e ^^^ f))) + 11 * ( ~~~e |||  ~~~(d ^^^ f)) - 1 * (d ^^^ e) - 2 * (f ^^^  ~~~(d &&& (e &&& f))) - 6 * (d ||| (e ^^^ f)) - 1 * (d &&& (e ^^^ f)) - 1 * (e &&&  ~~~(d &&& f)) - 1 * (e ^^^  ~~~(d ||| ( ~~~e &&& f))) - 3 * (f ^^^ ( ~~~d &&& (e ||| f))) + 11 * (e ^^^  ~~~( ~~~d &&& (e &&& f))) + 1 * (f |||  ~~~(d ||| e)) + 5 * (e &&& (d |||  ~~~f)) + 1 * ((d &&& e) |||  ~~~(e |||  ~~~f)) + 5 * ( ~~~(d ||| e) |||  ~~~(d ^^^ (e ^^^ f))) - 5 * (d ^^^ f) - 6 * (e ^^^ (d &&& (e ^^^ f))) - 1 * ((d ^^^ e) &&&  ~~~(d ^^^ f)) + 7 * ((d |||  ~~~e) &&&  ~~~(e ^^^ f)) + 5 * ( ~~~d ||| (e ^^^ f)) - 11 *  ~~~(d &&&  ~~~d) + 5 * (d &&&  ~~~e) - 2 * (e ^^^ ( ~~~d ||| (e ||| f))) - 2 * (f ^^^  ~~~(d &&& (e ||| f))) + 11 * (f ^^^ (d ||| ( ~~~e ||| f))) + 1 * (d |||  ~~~e) - 1 * ( ~~~(d &&&  ~~~e) &&&  ~~~(e ^^^ f)) - 1 * ((d &&&  ~~~e) ||| (d ^^^ (e ^^^ f))) - 2 * ( ~~~f &&&  ~~~(d ^^^ e)) - 1 *  ~~~(d ||| f) - 2 * ( ~~~(d &&& e) &&& (d ^^^ (e ^^^ f))) - 7 * ((d &&& e) ^^^  ~~~(d ^^^ (e &&& f))) + 1 * ( ~~~(d ||| e) |||  ~~~(e ^^^ f)) - 2 * ((d &&& e) ^^^  ~~~(d ^^^ ( ~~~e ||| f))) - 6 * (f ||| (d &&& e)) - 11 * (e ^^^  ~~~( ~~~d ||| (e ^^^ f))) + 4 * (e ^^^ (d ||| ( ~~~e &&& f))) + 2 * (f ^^^ (d ||| (e ||| f))) - 6 * ((d &&& e) ^^^ (d ^^^ ( ~~~e ||| f))) - 1 *  ~~~(d &&&  ~~~f) + 1 * (d &&& ( ~~~e ||| f)) + 2 * (f ^^^  ~~~(d &&&  ~~~e)) - 5 * ( ~~~d &&& (e ^^^ f)) - 3 * (e ^^^ ( ~~~d ||| (e ^^^ f))) - 3 * ((d &&&  ~~~e) |||  ~~~(d ^^^ (e ^^^ f))) + 7 *  ~~~(d ||| ( ~~~e &&& f)) + 1 * (d ^^^ (e ^^^ f)) + 1 * (e ^^^  ~~~( ~~~d &&& (e ^^^ f))) - 5 *  ~~~e + 4 * ((e &&&  ~~~f) ^^^ ( ~~~d ||| (e ^^^ f))) - 11 * (d ||| f) - 1 * (f ^^^ ( ~~~d ||| (e ||| f))) + 5 * (e ^^^  ~~~( ~~~d &&& ( ~~~e &&& f))) - 21 *  ~~~(d ||| (e ||| f)) + 35 *  ~~~(d ||| ( ~~~e ||| f)) + 9 *  ~~~( ~~~d ||| (e ||| f)) + 33 *  ~~~( ~~~d ||| ( ~~~e ||| f)) + 38 * ( ~~~d &&& ( ~~~e &&& f)) + 34 * ( ~~~d &&& (e &&& f)) + 6 * (d &&& ( ~~~e &&& f)) =  - 39 * (d &&& (e &&& f))

theorem no_shift_no_xor_multiuse_cmp_with_xor_thm (e e_1 e_2 e_3 : IntW 32) :
  mul (select (icmp IntPred.eq (LLVM.and e_3 (const? 32 4096)) (const? 32 0)) e_2 (LLVM.xor e_2 (const? 32 4096)))
      (select (icmp IntPred.eq (LLVM.and e_3 (const? 32 4096)) (const? 32 0)) e_1 e) ⊑
    mul (LLVM.xor e_2 (LLVM.and e_3 (const? 32 4096)))
      (select (icmp IntPred.eq (LLVM.and e_3 (const? 32 4096)) (const? 32 0)) e_1 e)

theorem e_109 :
    1 *  ~~~(x ^^^ y) - 3 * x - 1 *  ~~~(x ||| y) + 6 *  ~~~(x |||  ~~~y) + 10 * (x &&&  ~~~y) + 8 * (x &&& y) = 7 * (x ||| y) - 1 * y

theorem test8_thm.extracted_1._1 : ∀ (x : BitVec 8), x &&& 3#8 &&& 4#8 = 0#8

theorem e_994 :
     - 2 *  ~~~(z &&&  ~~~t) + 4 * (z ^^^ t) - 5 *  ~~~t + 11 *  ~~~(z &&&  ~~~z) - 5 * (z |||  ~~~t) - 13 *  ~~~(z |||  ~~~t) - 4 * (z &&& t) = 5 * (z &&&  ~~~t) - 1 *  ~~~(z ||| t)

theorem and_logic_and_logic_or_6_thm.extracted_1._6 : ∀ (x x_1 x_2 : BitVec 1),
  x_2 = 1#1 → ¬x_1 = 1#1 → x_1 &&& x = x_1 &&& 1#1

theorem test_shl_nuw_nsw__all_are_safe_thm.extracted_1._2 : ∀ (x : BitVec 64) (x_1 : BitVec 32),
  ofBool (x_1 &&& 15#32 == 0#32) = 1#1 →
    ¬(2#32 ≥ ↑32 ∨ True ∧ (x_1 <<< 2#32 &&& 60#32).msb = true ∨ zeroExtend 64 (x_1 <<< 2#32 &&& 60#32) ≥ ↑64) →
      x = x.sshiftRight' (zeroExtend 64 (x_1 <<< 2#32 &&& 60#32))

theorem test1_thm (e : IntW 33) : LLVM.udiv e (const? 33 4096) ⊑ lshr e (const? 33 12)

theorem lshrult_02_15_proof : lshrult_02_15_before ⊑ lshrult_02_15_after

theorem ne_umin1_thm.extracted_1._2 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (x_1 <ᵤ x) = 1#1 → ofBool (x != x_1) = ofBool (x <ᵤ x_1)

theorem pr51551_neg2_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬(True ∧ (x_1 &&& BitVec.ofInt 32 (-7)).smulOverflow x = true) →
    truncate 1 x_1 ^^^ 1#1 = 1#1 → ofBool ((x_1 &&& BitVec.ofInt 32 (-7)) * x &&& 7#32 == 0#32) = 1#1

theorem unmasked_shlop_insufficient_mask_shift_amount_proof : unmasked_shlop_insufficient_mask_shift_amount_before ⊑ unmasked_shlop_insufficient_mask_shift_amount_after

theorem lshrugt_01_12_proof : lshrugt_01_12_before ⊑ lshrugt_01_12_after

theorem main5e_like_logical_thm.extracted_1._11 : ∀ (x x_1 x_2 : BitVec 32),
  ¬ofBool (x_2 &&& x_1 == x_2) = 1#1 →
    ¬ofBool (x_2 &&& x_1 != x_2) = 1#1 → 0#1 = 1#1 → 0#32 = zeroExtend 32 (ofBool (x_2 &&& x != x_2))

theorem e_459 :
     - 3 *  ~~~(x &&&  ~~~y) - 1 *  ~~~(x &&&  ~~~x) - 1 * (x ||| y) + 4 * (x ^^^ y) - 3 * x + 2 *  ~~~x - 2 *  ~~~(x ||| y) - 1 *  ~~~(x |||  ~~~y) - 3 * (x &&&  ~~~y) =  - 8 * (x &&& y) - 4 *  ~~~y

theorem trunc_sel_smaller_zext_proof : trunc_sel_smaller_zext_before ⊑ trunc_sel_smaller_zext_after

theorem test21_proof : test21_before ⊑ test21_after

theorem negate_lshr_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8), ¬7#8 ≥ ↑8 → x_1 - x >>> 7#8 = x.sshiftRight' 7#8 + x_1

theorem PR39793_bswap_u64_as_u16_trunc_thm.extracted_1._1 : ∀ (x : BitVec 64),
  ¬(8#64 ≥ ↑64 ∨ 8#64 ≥ ↑64) → 8#64 ≥ ↑64 → False

theorem main3e_like_logical_thm.extracted_1._2 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (x_1 &&& x == 0#32) = 1#1 → ofBool (x_1 &&& x != 0#32) = 1#1 → ¬0#1 = 1#1 → 1#32 = zeroExtend 32 1#1

theorem e_2384 :
    2 * ( ~~~(d ||| e) |||  ~~~(e ^^^ f)) - 6 *  ~~~(d ^^^ (e ^^^ f)) - 5 * (e ^^^ (d &&& f)) - 1 *  ~~~(e |||  ~~~f) - 3 * (f ^^^  ~~~(d ||| (e &&& f))) - 6 * ((d ||| e) &&& (d ^^^ (e ^^^ f))) + 2 * (e |||  ~~~f) - 6 * (e ||| (d &&&  ~~~f)) + 1 * ((e &&& f) ||| ( ~~~d &&& (e ||| f))) + 4 *  ~~~(d &&&  ~~~d) + 11 * (f ^^^ (d &&& (e ||| f))) + 2 * ( ~~~d ||| ( ~~~e ||| f)) - 5 * (d ||| (e ||| f)) + 5 * ((d &&&  ~~~e) |||  ~~~(e ^^^ f)) - 7 * (f ^^^ (d ||| ( ~~~e ||| f))) + 2 * (d &&& (e ||| f)) - 11 *  ~~~e - 5 * (e ^^^  ~~~( ~~~d ||| ( ~~~e &&& f))) + 5 *  ~~~(e &&& f) + 1 * ((d &&&  ~~~e) |||  ~~~(d ^^^ (e ^^^ f))) + 3 * ((e &&&  ~~~f) |||  ~~~( ~~~d ||| ( ~~~e &&& f))) + 5 * ( ~~~e &&&  ~~~(d ^^^ f)) - 3 *  ~~~( ~~~d ||| (e &&& f)) - 1 * (f ^^^ ( ~~~d ||| ( ~~~e &&& f))) - 2 * (f ^^^ (d |||  ~~~e)) + 2 * (e ^^^ ( ~~~d ||| ( ~~~e &&& f))) - 2 * ( ~~~f |||  ~~~(d ^^^ e)) + 1 * ( ~~~(d ^^^ e) &&& (d ^^^ f)) - 1 * (e ^^^  ~~~( ~~~d &&& (e ^^^ f))) - 1 * (e &&&  ~~~(d &&&  ~~~f)) - 2 * ((d &&& e) ^^^  ~~~(d ^^^ ( ~~~e ||| f))) + 1 * ((d &&& f) |||  ~~~(e ||| f)) - 1 * ((d &&& f) ^^^  ~~~(e &&&  ~~~f)) + 7 * (e ^^^  ~~~(d &&& f)) + 2 * ((d ||| e) &&&  ~~~(d ^^^ (e ^^^ f))) + 11 * (e ^^^ f) + 3 * (f ^^^ ( ~~~d ||| (e &&& f))) + 3 * ((d &&& e) ||| (d ^^^ (e ^^^ f))) + 2 * (f &&& (d ||| e)) - 2 * (e ^^^ (d &&& (e ||| f))) - 1 * (e ^^^ ( ~~~d &&& (e ||| f))) - 3 * (e ^^^ ( ~~~d ||| (e ||| f))) - 5 * ( ~~~(d ^^^ e) |||  ~~~(d ^^^ f)) - 6 * ( ~~~d ||| ( ~~~e &&& f)) + 1 * (e &&& (d |||  ~~~f)) - 1 * ( ~~~e ||| (d ^^^ f)) - 1 * ((d |||  ~~~e) &&& (e ^^^ f)) + 3 * ( ~~~(d ||| e) ||| (e ^^^ f)) - 2 *  ~~~(d &&& e) - 11 * (e ^^^  ~~~( ~~~d &&& (e &&& f))) + 1 *  ~~~(d ||| ( ~~~e &&& f)) + 4 * (f ^^^ (d ||| (e &&& f))) + 2 * ( ~~~(d |||  ~~~e) |||  ~~~(d ^^^ (e ^^^ f))) + 1 * ((d &&&  ~~~e) ||| (e ^^^ f)) - 6 * (e ^^^ (d ||| (e ^^^ f))) + 2 * ((d &&& e) ^^^  ~~~(d ^^^ (e &&& f))) - 1 *  ~~~(d &&& (e ^^^ f)) - 1 * ( ~~~d &&& (e ||| f)) + 7 * ((e &&&  ~~~f) |||  ~~~(d ||| ( ~~~e &&& f))) + 4 * (e ||| (d &&& f)) + 1 *  ~~~(d &&& (e &&& f)) - 1 * (e &&&  ~~~(d ^^^ f)) + 9 *  ~~~(d ||| (e ||| f)) - 1 *  ~~~(d ||| ( ~~~e ||| f)) + 32 *  ~~~( ~~~d ||| (e ||| f)) - 26 *  ~~~( ~~~d ||| ( ~~~e ||| f)) - 2 * ( ~~~d &&& ( ~~~e &&& f)) + 20 * ( ~~~d &&& (e &&& f)) + 20 * (d &&& ( ~~~e &&& f)) - 9 * (d &&& (e &&& f)) = 1 * ( ~~~(d &&& e) &&&  ~~~(e ^^^ f)) + 2 * (f &&& (d ^^^ e))

theorem lshr_add_xor_fail_proof : lshr_add_xor_fail_before ⊑ lshr_add_xor_fail_after

theorem n2_proof : n2_before ⊑ n2_after

@[simp, simp_denote, simp_sllvm] theorem not_ptr_isRefinedBy_bitvec :
    ¬(@Ty.IsRefinedBy ptr (bitvec w) x y)

theorem e_1783 :
    3 * ( ~~~a ||| ( ~~~b &&& c)) - 3 * (b ^^^  ~~~(a ||| (b ^^^ c))) + 1 *  ~~~(a &&& (b ||| c)) - 2 *  ~~~(b ||| c) + 1 *  ~~~(b ^^^ c) + 3 * ( ~~~(a &&& b) &&&  ~~~(a ^^^ (b ^^^ c))) + 4 * ((a |||  ~~~b) &&&  ~~~(a ^^^ (b ^^^ c))) + 1 * (b |||  ~~~c) - 3 * ( ~~~(a ^^^ b) ||| (a ^^^ c)) - 1 * (b |||  ~~~(a |||  ~~~c)) + 11 * ((a &&& b) ^^^ (b ||| c)) - 6 * (c ^^^  ~~~(a |||  ~~~b)) + 1 * (c ^^^  ~~~( ~~~a &&& (b &&& c))) + 3 * ( ~~~(a ||| b) |||  ~~~(b ^^^ c)) + 1 * (c ^^^  ~~~(a &&& (b &&& c))) + 7 * ((a ^^^ b) &&& (a ^^^ c)) - 2 * ((a |||  ~~~b) &&&  ~~~(b ^^^ c)) + 4 * (c ^^^ (a ||| (b &&& c))) - 7 * ((a &&& c) ^^^  ~~~(a ^^^ ( ~~~b &&& c))) - 7 * (c ^^^ (a |||  ~~~b)) + 4 * (c ^^^  ~~~(a &&& (b ||| c))) + 2 *  ~~~(b &&&  ~~~c) + 3 * (b ^^^ (a ||| (b ||| c))) - 3 * (c |||  ~~~(a ^^^ b)) + 2 * (b &&&  ~~~c) + 7 * (b ^^^ ( ~~~a ||| (b ^^^ c))) + 7 * (a ^^^ (b ^^^ c)) + 1 *  ~~~(b &&& c) - 1 * (a &&& ( ~~~b ||| c)) + 5 * ( ~~~(a ||| b) ||| (b ^^^ c)) - 10 *  ~~~(a ||| (b ||| c)) - 23 *  ~~~(a ||| ( ~~~b ||| c)) - 21 *  ~~~( ~~~a ||| (b ||| c)) - 5 *  ~~~( ~~~a ||| ( ~~~b ||| c)) - 34 * ( ~~~a &&& ( ~~~b &&& c)) - 15 * ( ~~~a &&& (b &&& c)) - 33 * (a &&& ( ~~~b &&& c)) =  - 3 * (b &&&  ~~~(a &&& c))

lemma CNFA.lift_spec (m : CNFA n1) (f : Fin n1 → Fin n2) {M : NFA' n1} :
    m.Sim M → (m.lift f |>.Sim (M.lift f))

theorem icmp_select_var_select_thm.extracted_1._12 : ∀ (x x_1 : BitVec 8) (x_2 : BitVec 1),
  ¬x_2 = 1#1 → ofBool (x_1 == 0#8) = 1#1 ∧ x_2 = 1#1 → ofBool (x_1 == 0#8) = 1#1 → True → ofBool (x == x_1) = 1#1

theorem shl_add_thm.extracted_1._1 : ∀ (x : BitVec 8), ¬(x ≥ ↑8 ∨ x + 1#8 ≥ ↑8) → x ≥ ↑8 → False

theorem or_umin_proof : or_umin_before ⊑ or_umin_after

theorem test_ne_proof : test_ne_before ⊑ test_ne_after

theorem masked_icmps_mask_notallzeros_bmask_mixed_0_logical_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x &&& 12#32 != 0#32) = 1#1 →
    ofBool (x &&& 3#32 == 1#32) = ofBool (x &&& 12#32 != 0#32) &&& ofBool (x &&& 3#32 == 1#32)

@[simp]
theorem Vars.castLe_state_Inputs_mk_eq_state_castLe_Inputs_mk {n m : Nat}
    (hnm : n ≤ m) {s : σ} {i : Fin (n + 1)} :
    (Vars.state (Inputs.mk i s) : Vars σ ι n).castLe hnm =
    (Vars.state (Inputs.mk (i.castLE (by omega)) s) : Vars σ ι m)

theorem e_1720 :
    3 * ( ~~~(a ^^^ b) &&& (a ^^^ c)) - 5 * (c ^^^ (a &&& ( ~~~b ||| c))) - 3 * ((a &&&  ~~~b) |||  ~~~(b ^^^ c)) - 3 * (c ^^^  ~~~(a &&& (b &&& c))) - 1 *  ~~~( ~~~a ||| (b ^^^ c)) + 7 * (a &&&  ~~~c) + 7 * (b ^^^  ~~~(a &&& c)) - 1 * ((a &&& c) ^^^ (a ^^^ ( ~~~b &&& c))) - 1 * ((a &&& b) ^^^  ~~~(a ^^^ ( ~~~b ||| c))) - 2 * (b ^^^  ~~~(a ||| (b &&& c))) - 1 * (b ^^^  ~~~(a ||| (b ^^^ c))) - 7 * (c ^^^  ~~~( ~~~a ||| (b &&& c))) + 4 * ((a &&& b) ||| (b ^^^ c)) - 5 * (a &&& ( ~~~b ||| c)) + 1 * ((a ^^^ b) ||| (a ^^^ c)) - 5 * (a |||  ~~~b) + 5 * (a ^^^ (b ^^^ c)) - 11 *  ~~~(a &&& (b &&& c)) - 1 *  ~~~( ~~~a ||| (b &&& c)) + 4 * (c ^^^  ~~~(a &&&  ~~~b)) - 1 * (b &&&  ~~~c) + 5 * (c ^^^ ( ~~~a &&& ( ~~~b ||| c))) - 2 * (b ^^^  ~~~( ~~~a ||| (b &&& c))) + 2 * ( ~~~b ||| (a ^^^ c)) + 4 *  ~~~(a ||| (b ||| c)) + 5 *  ~~~(a ||| ( ~~~b ||| c)) + 23 *  ~~~( ~~~a ||| (b ||| c)) + 12 *  ~~~( ~~~a ||| ( ~~~b ||| c)) + 9 * ( ~~~a &&& ( ~~~b &&& c)) + 10 * (a &&& ( ~~~b &&& c)) + 8 * (a &&& (b &&& c)) =  - 24 * ( ~~~a &&& (b &&& c)) - 3 * ( ~~~(a &&& b) &&&  ~~~(a ^^^ (b ^^^ c)))

theorem ashr_and_thm.extracted_1._2 : ∀ (x : BitVec 8),
  ¬(x ≥ ↑8 ∨ x + 1#8 ≥ ↑8) →
    ¬x ≥ ↑8 →
      (BitVec.ofInt 8 (-64)).sshiftRight' x &&& (BitVec.ofInt 8 (-128)).sshiftRight' (x + 1#8) =
        (BitVec.ofInt 8 (-64)).sshiftRight' x

theorem e_2221 :
     - 1 * (e ^^^  ~~~(d &&& ( ~~~e &&& f))) - 3 * (e ^^^  ~~~( ~~~d &&& ( ~~~e &&& f))) - 1 * (f ^^^ ( ~~~d ||| ( ~~~e &&& f))) - 1 * ((d |||  ~~~e) &&& (e ^^^ f)) - 2 * (d &&&  ~~~f) + 1 * ( ~~~(d &&&  ~~~e) &&&  ~~~(e ^^^ f)) + 5 * ((d &&& e) ^^^ (e ||| f)) + 4 * ( ~~~d &&& (e ^^^ f)) - 1 * ((d |||  ~~~e) &&&  ~~~(e ^^^ f)) + 1 * (e ^^^ (d |||  ~~~f)) - 7 * (d |||  ~~~e) - 5 * (f ^^^ (d ||| ( ~~~e &&& f))) - 2 * (e ^^^ (d ||| f)) + 2 * ((d &&&  ~~~e) |||  ~~~(d ^^^ (e ^^^ f))) + 3 *  ~~~(d &&& (e ^^^ f)) + 11 * ( ~~~f ||| (d ^^^ e)) + 4 * (f ^^^  ~~~(d ||| e)) - 1 * (e ^^^  ~~~( ~~~d ||| ( ~~~e &&& f))) - 2 * (e &&& (d ||| f)) + 1 * (e |||  ~~~(d ^^^ f)) + 7 * (e &&& (d |||  ~~~f)) + 7 * (e ^^^  ~~~(d |||  ~~~f)) + 2 * ( ~~~d ||| ( ~~~e &&& f)) + 1 * (f |||  ~~~(d ||| e)) + 4 * (e &&& f) + 7 * (d ||| ( ~~~e &&& f)) - 6 * (e |||  ~~~(d ||| f)) - 2 * (d |||  ~~~f) - 1 * (f ^^^  ~~~(d &&&  ~~~e)) - 6 * (e &&&  ~~~(d &&&  ~~~f)) - 2 * ( ~~~(d |||  ~~~e) |||  ~~~(d ^^^ (e ^^^ f))) + 5 * (e &&& (d ^^^ f)) - 1 * (f |||  ~~~(d ^^^ e)) - 1 * (f ^^^ (d ||| (e ||| f))) - 1 * (d ||| f) - 5 * (e ^^^  ~~~(d ||| (e &&& f))) + 4 * ( ~~~(d &&&  ~~~e) &&& (d ^^^ (e ^^^ f))) + 2 *  ~~~(d ^^^ (e &&& f)) + 1 * ((d ^^^ e) ||| (d ^^^ f)) - 3 *  ~~~f - 2 * ((d &&& f) ^^^  ~~~(d ^^^ (e &&& f))) - 2 * (f ^^^ ( ~~~d &&& ( ~~~e ||| f))) - 11 *  ~~~( ~~~d &&& (e &&& f)) + 2 * (f ^^^  ~~~( ~~~d ||| (e &&& f))) - 2 * (e ^^^ (d &&&  ~~~f)) + 4 * ((d &&& f) ^^^ (e ||| f)) - 3 *  ~~~( ~~~d ||| ( ~~~e &&& f)) + 20 *  ~~~(d ||| (e ||| f)) - 16 *  ~~~(d ||| ( ~~~e ||| f)) + 13 *  ~~~( ~~~d ||| (e ||| f)) + 6 *  ~~~( ~~~d ||| ( ~~~e ||| f)) - 11 * ( ~~~d &&& ( ~~~e &&& f)) - 16 * ( ~~~d &&& (e &&& f)) + 2 * (d &&& (e &&& f)) =  - 5 * ((d ||| e) &&& (d ^^^ (e ^^^ f)))

theorem AvoidCollision_setWidth_add (x y : BitVec w) (h : i ≤ w) :
    (x + y).setWidth i = x.setWidth i + y.setWidth i

theorem bisim_tail_of_head_eq_none {a : Stream α} (h : a.head = none) :
    a ~ a.tail

theorem neg_thm.extracted_1._1 : ∀ (x : BitVec 8), ¬42#8 = 0 → 0#8 - x ^^^ x / 42#8 = x / 42#8 ^^^ 0#8 - x

theorem main3b_logical_proof : main3b_logical_before ⊑ main3b_logical_after

theorem shr_umax_proof : shr_umax_before ⊑ shr_umax_after

@[simp]
lemma complete_eval {M : NFA α σ} {w} (q : σ) :
    (.inl q ∈ M.complete.eval w) ↔ q ∈ M.eval w

theorem alive_AndOrXor_2416 : alive_AndOrXor_2416_src ⊑ alive_AndOrXor_2416_tgt

theorem and_two_ranges_to_mask_and_range_different_sizes_thm (e : IntW 8) :
  LLVM.and (icmp IntPred.ugt (add e (const? 8 (-97))) (const? 8 25))
      (icmp IntPred.ugt (add e (const? 8 (-65))) (const? 8 24)) ⊑
    LLVM.and (icmp IntPred.ult (add e (const? 8 (-123))) (const? 8 (-26)))
      (icmp IntPred.ult (add e (const? 8 (-90))) (const? 8 (-25)))

theorem e_574 :
     - 2 *  ~~~(x &&&  ~~~y) - 6 * (x ^^^ y) - 3 *  ~~~(x &&&  ~~~x) - 1 *  ~~~y + 11 * (x ||| y) + 6 *  ~~~(x ||| y) - 1 *  ~~~(x |||  ~~~y) - 1 * (x &&&  ~~~y) - 7 * (x &&& y) =  - 1 * y

theorem imp2 (w : Nat) (a b : BitVec w) : ((a ≤ b) ∧ (b ≤ a)) → (a = b)

theorem lshrugt_02_12_proof : lshrugt_02_12_before ⊑ lshrugt_02_12_after

theorem e_1416 :
    7 *  ~~~(z &&&  ~~~z) - 5 *  ~~~z - 5 * z - 2 * (z ||| t) + 1 *  ~~~(z &&&  ~~~t) + 2 * (z ^^^ t) - 3 *  ~~~(z ||| t) - 4 *  ~~~(z |||  ~~~t) - 2 * (z &&&  ~~~t) - 2 * (z &&& t) =  - 1 * t

theorem test69_xor_proof : test69_xor_before ⊑ test69_xor_after

theorem e_1155 :
    11 * (z |||  ~~~t) + 5 * t - 11 * z + 1 *  ~~~(z ^^^ t) - 12 *  ~~~(z ||| t) - 6 *  ~~~(z |||  ~~~t) - 1 * (z &&&  ~~~t) - 6 * (z &&& t) =  - 1 * (z ^^^ t)

theorem ashr_ult_12_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬1#4 ≥ ↑4 → ofBool (x.sshiftRight' 1#4 <ᵤ BitVec.ofInt 4 (-4)) = ofBool (-1#4 <ₛ x)

theorem e_1059 :
     - 2 *  ~~~(z ^^^ t) + 1 *  ~~~t - 3 * z - 5 *  ~~~(z &&&  ~~~z) + 6 *  ~~~(z ||| t) + 7 * (z &&&  ~~~t) + 10 * (z &&& t) =  - 5 *  ~~~(z |||  ~~~t)

theorem test4_thm (e : IntW 32) : icmp IntPred.sgt e e ⊑ const? 1 0

theorem slt_zero_slt_i1_fail_proof : slt_zero_slt_i1_fail_before ⊑ slt_zero_slt_i1_fail_after

theorem lshrugt_01_04_exact_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬(True ∧ x >>> 1#4 <<< 1#4 ≠ x ∨ 1#4 ≥ ↑4) → ofBool (4#4 <ᵤ x >>> 1#4) = ofBool (BitVec.ofInt 4 (-8) <ᵤ x)

theorem test13_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32), ofBool (x_1 <ᵤ x) &&& ofBool (x <ᵤ x_1) = 0#1

theorem bv_152 :
    ∀ (e : LLVM.IntW w), LLVM.mul e (LLVM.const? w (-1)) ⊑ LLVM.sub (LLVM.const? w 0) e

theorem fast_div_201_thm.extracted_1._2 : ∀ (x : BitVec 8),
  ¬(8#16 ≥ ↑16 ∨ 8#16 ≥ ↑16 ∨ 1#8 ≥ ↑8 ∨ 7#8 ≥ ↑8) →
    ¬(True ∧ (zeroExtend 16 x).smulOverflow 71#16 = true ∨
          True ∧ (zeroExtend 16 x).umulOverflow 71#16 = true ∨
            8#16 ≥ ↑16 ∨
              True ∧
                  signExtend 16 (truncate 8 ((zeroExtend 16 x * 71#16) >>> 8#16)) ≠ (zeroExtend 16 x * 71#16) >>> 8#16 ∨
                True ∧
                    zeroExtend 16 (truncate 8 ((zeroExtend 16 x * 71#16) >>> 8#16)) ≠
                      (zeroExtend 16 x * 71#16) >>> 8#16 ∨
                  1#8 ≥ ↑8 ∨
                    True ∧ (zeroExtend 16 x).smulOverflow 71#16 = true ∨
                      True ∧ (zeroExtend 16 x).umulOverflow 71#16 = true ∨
                        8#16 ≥ ↑16 ∨
                          True ∧
                              signExtend 16 (truncate 8 ((zeroExtend 16 x * 71#16) >>> 8#16)) ≠
                                (zeroExtend 16 x * 71#16) >>> 8#16 ∨
                            True ∧
                                zeroExtend 16 (truncate 8 ((zeroExtend 16 x * 71#16) >>> 8#16)) ≠
                                  (zeroExtend 16 x * 71#16) >>> 8#16 ∨
                              True ∧
                                  ((x - truncate 8 ((zeroExtend 16 x * 71#16) >>> 8#16)) >>> 1#8).uaddOverflow
                                      (truncate 8 ((zeroExtend 16 x * 71#16) >>> 8#16)) =
                                    true ∨
                                7#8 ≥ ↑8) →
      (truncate 8 ((zeroExtend 16 x * 71#16) >>> 8#16) +
            (x - truncate 8 ((zeroExtend 16 x * 71#16) >>> 8#16)) >>> 1#8) >>>
          7#8 =
        ((x - truncate 8 ((zeroExtend 16 x * 71#16) >>> 8#16)) >>> 1#8 +
            truncate 8 ((zeroExtend 16 x * 71#16) >>> 8#16)) >>>
          7#8

theorem test_mul_nuw__nsw_is_safe_thm (e : IntW 32) :
  select (icmp IntPred.eq (LLVM.or e (const? 32 (-83886080))) (const? 32 (-83886079))) (const? 32 (-754974711))
      (mul (LLVM.or e (const? 32 (-83886080))) (const? 32 9) { «nsw» := false, «nuw» := true }) ⊑
    mul (LLVM.or e (const? 32 (-83886080))) (const? 32 9) { «nsw» := true, «nuw» := false }

theorem main7g_logical_thm.extracted_1._9 : ∀ (x x_1 x_2 x_3 x_4 : BitVec 32),
  ofBool (x_4 &&& x_3 == x_4 &&& x_3 &&& x_2) = 1#1 →
    ofBool (x_4 &&& x_3 != x_4 &&& x_3 &&& x_2) = 1#1 →
      ofBool (x_1 &&& x == x_1 &&& x &&& x_2) = 1#1 → 0#32 = zeroExtend 32 1#1

theorem not_signbit_alt_xor_proof : not_signbit_alt_xor_before ⊑ not_signbit_alt_xor_after

theorem e_715 :
    7 *  ~~~(x &&&  ~~~y) - 1 *  ~~~(x ^^^ y) - 3 * y + 4 * (x ^^^ y) + 2 * (x ||| y) + 1 *  ~~~x + 2 * x - 3 * (x |||  ~~~y) - 4 *  ~~~(x ||| y) - 11 *  ~~~(x |||  ~~~y) - 4 * (x &&& y) = 5 * (x &&&  ~~~y)

theorem main15_logical_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (0#16 ≤ₛ truncate 16 x) = 1#1 → ofBool (x &&& 32896#32 == 32896#32) = 1#1 → True → 2#32 = 1#32

theorem alive_Select_1105  (w : Nat)   : alive_Select_1105_src w  ⊑ alive_Select_1105_tgt w

theorem lshrult_01_03_exact_proof : lshrult_01_03_exact_before ⊑ lshrult_01_03_exact_after

@[simp]
lemma product_accept {M : NFA α σ} {N : NFA α ς} :
    (q1, q2) ∈ (M.product accept? N).accept ↔ accept? (q1 ∈ M.accept) (q2 ∈ N.accept)

@[simp] theorem cons_getElem_toCons (x : A a) (v : Var Γ u)
    (h : as = Γ.toList := by rfl) (h' : a :: as = (Γ.cons a).toList := by rfl) :
    (HVector.cons x xs)[v.toCons (t' := a)]'h' = xs[v]'h

theorem and_consts_thm (e : IntW 32) :
  LLVM.or (icmp IntPred.eq (LLVM.and (const? 32 4) e) (const? 32 0))
      (icmp IntPred.eq (LLVM.and (const? 32 8) e) (const? 32 0)) ⊑
    icmp IntPred.ne (LLVM.and e (const? 32 12)) (const? 32 12)

theorem test7_proof : test7_before ⊑ test7_after

theorem eq_smin1_thm (e e_1 : IntW 32) :
  icmp IntPred.eq (select (icmp IntPred.slt e_1 e) e_1 e) e_1 ⊑ icmp IntPred.sle e_1 e

theorem or_not_xor_common_op_commute5_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 8),
  x_2 ^^^ x_1 ||

theorem neg_mask_thm.extracted_1._1 : ∀ (x : BitVec 16) (x_1 : BitVec 32),
  ¬(True ∧ x_1.ssubOverflow (signExtend 32 x) = true ∨
        15#16 ≥ ↑16 ∨ True ∧ (0#32).ssubOverflow (zeroExtend 32 (x >>> 15#16)) = true) →
    ofBool (x <ₛ 0#16) = 1#1 → True ∧ x_1.ssubOverflow (signExtend 32 x) = true → False

theorem or_basic_commuted_thm.extracted_1._1 : ∀ (x : BitVec 16),
  ofBool (x &&& BitVec.ofInt 16 (-256) != 32512#16) ||

theorem xor_lshr_proof : xor_lshr_before ⊑ xor_lshr_after

theorem lshrult_03_11_proof : lshrult_03_11_before ⊑ lshrult_03_11_after

theorem ashr_ugt_exact_thm (e : IntW 8) :
  icmp IntPred.ugt (ashr e (const? 8 3) { «exact» := true }) (const? 8 10) ⊑
    icmp IntPred.ugt e (const? 8 80)

theorem test5_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 19), x_2 - (x_1 - x) = x - x_1 + x_2

theorem alive_AndOrXor_144  (w : Nat)   : alive_AndOrXor_144_src w  ⊑ alive_AndOrXor_144_tgt w

theorem sle_and_min_commute_logical_thm.extracted_1._2 : ∀ (x x_1 : BitVec 8),
  ofBool (x_1 == BitVec.ofInt 8 (-128)) = 1#1 → ofBool (x_1 ≤ₛ x) = ofBool (x_1 == BitVec.ofInt 8 (-128))

theorem e_682 :
     - 1 *  ~~~(x &&&  ~~~y) - 1 *  ~~~(x ^^^ y) - 2 * y - 11 *  ~~~(x &&& y) + 11 * (x ^^^ y) - 1 *  ~~~(x &&&  ~~~x) + 11 * (x |||  ~~~y) - 2 *  ~~~(x ||| y) - 11 * (x &&&  ~~~y) - 6 * (x &&& y) =  - 4 *  ~~~x - 1 *  ~~~y

theorem src_is_notmask_x_xor_neg_x_inv_thm.extracted_1._3 : ∀ (x x_1 : BitVec 8) (x_2 : BitVec 1),
  ¬x_2 = 1#1 → ofBool (BitVec.ofInt 8 (-8) &&& (x ^^^ 123#8) == 0#8) = ofBool (x ^^^ 123#8 ≤ᵤ 7#8)

theorem lshrult_01_12_exact_thm (e : IntW 4) :
  icmp IntPred.ult (lshr e (const? 4 1) { «exact» := true }) (const? 4 (-4)) ⊑ const? 1 1

theorem test2_proof : test2_before ⊑ test2_after

theorem or_test2_thm (e : IntW 7) : LLVM.or (shl e (const? 7 6)) (const? 7 (-64)) ⊑ const? 7 (-64)

@[simp] theorem denote_mk {lets : Lets d Γ_in eff Γ_out} {com : Com d Γ_out eff ty} :
    denote ⟨lets, com⟩ = fun V => (lets.denote V) >>= com.denote

theorem negate_lowbitmask_proof : negate_lowbitmask_before ⊑ negate_lowbitmask_after

theorem ashrslt_02_05_exact_proof : ashrslt_02_05_exact_before ⊑ ashrslt_02_05_exact_after

theorem ashr_xor_thm.extracted_1._2 : ∀ (x : BitVec 8),
  ¬(x ≥ ↑8 ∨ x + 1#8 ≥ ↑8) →
    ¬x ≥ ↑8 → (BitVec.ofInt 8 (-128)).sshiftRight' x ^^^ (BitVec.ofInt 8 (-64)).sshiftRight' (x + 1#8) = 96#8 >>> x

theorem ule_swap_or_not_min_proof : ule_swap_or_not_min_before ⊑ ule_swap_or_not_min_after

theorem is_rem4_neg_i16_proof : is_rem4_neg_i16_before ⊑ is_rem4_neg_i16_after

theorem main13_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬ofBool (truncate 16 x <ₛ 0#16) &&& ofBool (truncate 8 x <ₛ 0#8) = 1#1 →
    ofBool (x &&& 32896#32 == 32896#32) = 1#1 → 1#32 = 2#32

theorem trunc_shl_31_i32_i64_proof : trunc_shl_31_i32_i64_before ⊑ trunc_shl_31_i32_i64_after

theorem lshrult_03_09_exact_thm (e : IntW 4) :
  icmp IntPred.ult (lshr e (const? 4 3) { «exact» := true }) (const? 4 (-7)) ⊑ const? 1 1

theorem ugt_rem_nz_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬(True ∧ x.umulOverflow 5#8 = true) → ofBool (21#8 <ᵤ x * 5#8) = ofBool (4#8 <ᵤ x)

theorem icmp_ne_and_z_and_onefail_proof : icmp_ne_and_z_and_onefail_before ⊑ icmp_ne_and_z_and_onefail_after

theorem sel_false_val_is_a_masked_shl_of_true_val2_thm.extracted_1._4 : ∀ (x : BitVec 64) (x_1 : BitVec 32),
  ¬(True ∧ ((x_1 &&& 15#32) <<< 2#32).sshiftRight' 2#32 ≠ x_1 &&& 15#32 ∨
        True ∧ (x_1 &&& 15#32) <<< 2#32 >>> 2#32 ≠ x_1 &&& 15#32 ∨ 2#32 ≥ ↑32) →
    ¬ofBool ((x_1 &&& 15#32) <<< 2#32 == 0#32) = 1#1 →
      ¬(True ∧ ((x_1 &&& 15#32) <<< 2#32).sshiftRight' 2#32 ≠ x_1 &&& 15#32 ∨
            True ∧ (x_1 &&& 15#32) <<< 2#32 >>> 2#32 ≠ x_1 &&& 15#32 ∨
              2#32 ≥ ↑32 ∨ zeroExtend 64 ((x_1 &&& 15#32) <<< 2#32) ≥ ↑64) →
        ¬(2#32 ≥ ↑32 ∨ True ∧ (x_1 <<< 2#32 &&& 60#32).msb = true ∨ zeroExtend 64 (x_1 <<< 2#32 &&& 60#32) ≥ ↑64) →
          x.sshiftRight' (zeroExtend 64 ((x_1 &&& 15#32) <<< 2#32)) =
            x.sshiftRight' (zeroExtend 64 (x_1 <<< 2#32 &&& 60#32))

theorem ult_2_thm (e : IntW 32) :
  icmp IntPred.ult (trunc 8 e) (const? 8 2) ⊑
    icmp IntPred.eq (LLVM.and e (const? 32 254)) (const? 32 0)

theorem shl_sub_lshr_reverse_nsw_on_op1_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 32),
  ¬(True ∧ (x_1 <<< x).sshiftRight' x ≠ x_1 ∨
        True ∧ x_1 <<< x >>> x ≠ x_1 ∨
          x ≥ ↑32 ∨
            True ∧ x_2.usubOverflow (x_1 <<< x) = true ∨
              True ∧ (x_2 - x_1 <<< x) >>> x <<< x ≠ x_2 - x_1 <<< x ∨ x ≥ ↑32) →
    True ∧ x_2 >>> x <<< x ≠ x_2 ∨ x ≥ ↑32 ∨ True ∧ (x_2 >>> x).usubOverflow x_1 = true → False

theorem match_unsigned_thm.extracted_1._2 : ∀ (x : BitVec 64),
  ¬(299#64 = 0 ∨ 299#64 = 0 ∨ 64#64 = 0) → ¬19136#64 = 0 → x % 299#64 + x / 299#64 % 64#64 * 299#64 = x % 19136#64

theorem e_76 :
     - 1 * y - 1 * (x ||| y) - 7 *  ~~~(x ||| y) - 5 *  ~~~(x |||  ~~~y) + 1 * (x &&&  ~~~y) =  - 7 *  ~~~(x &&&  ~~~y) + 5 * (x &&& y)

theorem not_and_and_or_not_or_or_commute3_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 32),
  ¬((x_2 == 0 || 32 != 1 && 42#32 == intMin 32 && x_2 == -1) = true ∨
        (x_2 == 0 || 32 != 1 && 42#32 == intMin 32 && x_2 == -1) = true) →
    (x_2 == 0 || 32 != 1 && 42#32 == intMin 32 && x_2 == -1) = true → False

theorem foo1_and_commuted_thm (e e_1 e_2 : IntW 32) :
  LLVM.or (icmp IntPred.eq (LLVM.and (mul e_2 e_2) (shl (const? 32 1) e_1)) (const? 32 0))
      (icmp IntPred.eq (LLVM.and (shl (const? 32 1) e) (mul e_2 e_2)) (const? 32 0)) ⊑
    icmp IntPred.ne
      (LLVM.and (mul e_2 e_2)
        (LLVM.or (shl (const? 32 1) e_1 { «nsw» := false, «nuw» := true })
          (shl (const? 32 1) e { «nsw» := false, «nuw» := true })))
      (LLVM.or (shl (const? 32 1) e_1 { «nsw» := false, «nuw» := true })
        (shl (const? 32 1) e { «nsw» := false, «nuw» := true }))

theorem not_or_or_and_not_and_and_commute4_thm (e e_1 e_2 : IntW 32) :
  LLVM.and (LLVM.or (LLVM.sdiv (const? 32 42) e_2) (LLVM.or (LLVM.xor e_1 (const? 32 (-1))) e))
      (LLVM.xor (LLVM.and (LLVM.and e e_1) (LLVM.sdiv (const? 32 42) e_2)) (const? 32 (-1))) ⊑
    LLVM.or (LLVM.xor (LLVM.sdiv (const? 32 42) e_2) e) (LLVM.xor e_1 (const? 32 (-1)))

theorem ule_umax3_proof : ule_umax3_before ⊑ ule_umax3_after

theorem test_proof : test_before ⊑ test_after

theorem cmpeq_bitwise_proof : cmpeq_bitwise_before ⊑ cmpeq_bitwise_after

theorem sdiv_shl_pair3_thm.extracted_1._2 : ∀ (x x_1 x_2 : BitVec 32),
  ¬(True ∧ (x_2 <<< x_1).sshiftRight' x_1 ≠ x_2 ∨
        x_1 ≥ ↑32 ∨
          True ∧ (x_2 <<< x).sshiftRight' x ≠ x_2 ∨
            x ≥ ↑32 ∨ (x_2 <<< x == 0 || 32 != 1 && x_2 <<< x_1 == intMin 32 && x_2 <<< x == -1) = true) →
    ¬(True ∧ 1#32 <<< x_1 >>> x_1 ≠ 1#32 ∨ x_1 ≥ ↑32 ∨ x ≥ ↑32) → (x_2 <<< x_1).sdiv (x_2 <<< x) = 1#32 <<< x_1 >>> x

theorem a_true_implies_b_false2_thm.extracted_1._2 : ∀ (x : BitVec 1) (x_1 : BitVec 8),
  ofBool (x_1 == 10#8) = 1#1 → ¬ofBool (20#8 <ᵤ x_1) = 1#1 → ofBool (20#8 <ᵤ x_1) &&& x = 0#1

theorem lshrugt_01_07_thm.extracted_1._1 : ∀ (x : BitVec 4), ¬1#4 ≥ ↑4 → ofBool (7#4 <ᵤ x >>> 1#4) = 0#1

theorem t1_flags_nuw_nsw_first_proof : t1_flags_nuw_nsw_first_before ⊑ t1_flags_nuw_nsw_first_after

theorem xor_icmp_to_icmp_add_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (3#32 <ₛ x) ^^^ ofBool (x <ₛ 6#32) = ofBool (x + BitVec.ofInt 32 (-6) <ᵤ BitVec.ofInt 32 (-2))

theorem p_constmask2_proof : p_constmask2_before ⊑ p_constmask2_after

theorem scalar_i64_signbit_lshr_and_eq_thm.extracted_1._1 : ∀ (x x_1 : BitVec 64),
  ¬x_1 ≥ ↑64 →
    True ∧ BitVec.ofInt 64 (-9223372036854775808) >>> x_1 <<< x_1 ≠ BitVec.ofInt 64 (-9223372036854775808) ∨ x_1 ≥ ↑64 →
      False

theorem ashr_mul_thm.extracted_1._2 : ∀ (x x_1 : BitVec 8),
  ¬8#20 ≥ ↑20 →
    ¬(True ∧ (signExtend 16 x_1).smulOverflow (signExtend 16 x) = true ∨ 8#16 ≥ ↑16) →
      truncate 16 ((signExtend 20 x_1 * signExtend 20 x).sshiftRight' 8#20) =
        (signExtend 16 x_1 * signExtend 16 x).sshiftRight' 8#16

theorem test_ule_xor_proof : test_ule_xor_before ⊑ test_ule_xor_after

theorem test23_thm (e : IntW 32) :
  LLVM.and (icmp IntPred.sgt e (const? 32 1)) (icmp IntPred.sle e (const? 32 2)) ⊑
    icmp IntPred.eq e (const? 32 2)

theorem scalar_i32_shl_and_negC_eq_nonzero_proof : scalar_i32_shl_and_negC_eq_nonzero_before ⊑ scalar_i32_shl_and_negC_eq_nonzero_after

theorem main4f_like_logical_proof : main4f_like_logical_before ⊑ main4f_like_logical_after

theorem is_ascii_alphabetic_proof : is_ascii_alphabetic_before ⊑ is_ascii_alphabetic_after

theorem uge_and_max_thm (e e_1 : IntW 8) :
  LLVM.and (icmp IntPred.uge e_1 e) (icmp IntPred.eq e_1 (const? 8 (-1))) ⊑
    icmp IntPred.eq e_1 (const? 8 (-1))

theorem ne_umin4_thm (e e_1 : IntW 32) :
  icmp IntPred.ne (add e_1 (const? 32 3))
      (select (icmp IntPred.ult e (add e_1 (const? 32 3))) e (add e_1 (const? 32 3))) ⊑
    icmp IntPred.ugt (add e_1 (const? 32 3)) e

theorem sub_const_add_const_thm (e : IntW 32) : add (sub e (const? 32 8)) (const? 32 2) ⊑ add e (const? 32 (-6))

theorem select_or_disjoint_or_proof : select_or_disjoint_or_before ⊑ select_or_disjoint_or_after

theorem xor_ashr_not_proof : xor_ashr_not_before ⊑ xor_ashr_not_after

theorem canonicalize_logic_first_or0_proof : canonicalize_logic_first_or0_before ⊑ canonicalize_logic_first_or0_after

theorem trunc_ashr_trunc_outofrange_thm (e : IntW 64) :
  trunc 8 (ashr (trunc 32 e) (const? 32 25)) ⊑
    trunc 8 (ashr (trunc 32 e) (const? 32 25)) { «nsw» := true, «nuw» := false }

theorem main12_thm (e : IntW 32) :
  select (LLVM.or (icmp IntPred.slt (trunc 16 e) (const? 16 0)) (icmp IntPred.slt (trunc 8 e) (const? 8 0)))
      (const? 32 2) (const? 32 1) ⊑
    select (icmp IntPred.eq (LLVM.and e (const? 32 32896)) (const? 32 0)) (const? 32 1) (const? 32 2)

theorem e_435 :
     - 11 *  ~~~(x ^^^ y) + 11 *  ~~~(x &&&  ~~~y) + 7 * (x ^^^ y) + 4 *  ~~~y + 2 *  ~~~x - 9 *  ~~~(x |||  ~~~y) - 5 * (x &&&  ~~~y) + 6 * (x &&& y) = 11 *  ~~~(x &&&  ~~~x) - 5 * (x |||  ~~~y)

theorem t7_ashr_proof : t7_ashr_before ⊑ t7_ashr_after

theorem test17_thm (e : IntW 1) : sub (const? 32 0) (sext 32 e) ⊑ zext 32 e

theorem test_xor_eq_proof : test_xor_eq_before ⊑ test_xor_eq_after

theorem main7c_logical_thm.extracted_1._12 : ∀ (x x_1 x_2 : BitVec 32),
  ¬ofBool (x_2 == x_2 &&& x_1) = 1#1 →
    ¬ofBool (x_2 != x_2 &&& x_1) = 1#1 → ¬0#1 = 1#1 → 1#32 = zeroExtend 32 (ofBool (x != x &&& x_1))

theorem test_thm.extracted_1._3 : ∀ (x : BitVec 1) (x_1 : BitVec 32), ¬x = 1#1 → ¬1#32 = 0 → 0#32 ≥ ↑32 → False

theorem p0_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬(5#8 ≥ ↑8 ∨ True ∧ x <<< 5#8 >>> 5#8 <<< 5#8 ≠ x <<< 5#8 ∨ 5#8 ≥ ↑8) →
    ofBool ((x <<< 5#8).sshiftRight' 5#8 != x) = ofBool (x + BitVec.ofInt 8 (-4) <ᵤ BitVec.ofInt 8 (-8))

theorem or_trunc_lshr_small_mask_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬4#8 ≥ ↑8 →
    4#8 ≥ ↑8 ∨
        True ∧ signExtend 8 (truncate 6 (x >>> 4#8)) ≠ x >>> 4#8 ∨
          True ∧ zeroExtend 8 (truncate 6 (x >>> 4#8)) ≠ x >>> 4#8 →
      False

theorem badimm1_thm.extracted_1._2 : ∀ (x : BitVec 16),
  ¬(7#8 ≥ ↑8 ∨ 9#16 ≥ ↑16) →
    ¬ofBool ((truncate 8 x).sshiftRight' 7#8 == truncate 8 (x >>> 9#16)) = 1#1 →
      ¬15#16 ≥ ↑16 →
        7#8 ≥ ↑8 ∨
            9#16 ≥ ↑16 ∨
              True ∧ signExtend 16 (truncate 8 (x >>> 9#16)) ≠ x >>> 9#16 ∨
                True ∧ zeroExtend 16 (truncate 8 (x >>> 9#16)) ≠ x >>> 9#16 →
          False

@[simp] lemma eval_incr (x : Unit → BitStream) : incr.eval x = (x ()).incr

theorem e_1871 :
    11 * ((b &&& c) ^^^  ~~~( ~~~a &&& (b ^^^ c))) - 2 * (c ^^^  ~~~( ~~~a &&& (b ||| c))) + 7 * (b ||| (a &&&  ~~~c)) + 1 * ( ~~~b ||| (a ^^^ c)) - 2 * (a ||| b) + 1 * ((a &&& b) ^^^  ~~~(a ^^^ (b &&& c))) - 3 * (c ||| (a ^^^ b)) + 1 * (c ^^^ (a &&& ( ~~~b ||| c))) + 1 * ((a &&& c) ||| (b &&&  ~~~c)) - 11 * ((b &&&  ~~~c) |||  ~~~( ~~~a ||| ( ~~~b &&& c))) + 7 *  ~~~(a &&& ( ~~~b ||| c)) - 6 * (b |||  ~~~(a ^^^ c)) - 7 * (c ^^^ ( ~~~a ||| (b &&& c))) - 5 * (b &&& (a ^^^ c)) - 11 * ((a |||  ~~~b) &&& (b ^^^ c)) + 1 *  ~~~(a ||| (b ^^^ c)) + 3 * ((a &&&  ~~~b) |||  ~~~(a ^^^ (b ^^^ c))) + 5 * (b ||| (a &&& c)) + 2 *  ~~~(a &&&  ~~~a) + 11 * ( ~~~a ||| (b ^^^ c)) - 2 * (a ^^^ c) + 2 * (b ^^^ (a ||| (b &&& c))) + 11 * (b ^^^  ~~~(a ||| ( ~~~b &&& c))) + 5 *  ~~~(a ^^^ (b &&& c)) - 1 * (b &&&  ~~~(a ^^^ c)) - 2 * (c ^^^  ~~~(a &&& b)) - 1 * (c &&&  ~~~(a &&& b)) - 1 * (c |||  ~~~(a |||  ~~~b)) - 1 * (b ^^^  ~~~(a ||| (b ^^^ c))) - 6 * (a &&&  ~~~b) - 1 * ( ~~~c &&& (a ^^^ b)) - 11 *  ~~~(a ^^^ b) - 2 * (a ||| ( ~~~b &&& c)) + 1 * ((a &&& b) ||| (b ^^^ c)) + 4 * (c ||| (a &&& b)) - 1 * (c ^^^ ( ~~~a ||| ( ~~~b &&& c))) - 1 * ((a &&& b) ^^^ (b |||  ~~~c)) - 7 *  ~~~(b ^^^ c) - 7 * ( ~~~(a ||| b) ||| (b ^^^ c)) - 8 *  ~~~(a ||| (b ||| c)) + 2 *  ~~~(a ||| ( ~~~b ||| c)) + 13 *  ~~~( ~~~a ||| (b ||| c)) - 4 *  ~~~( ~~~a ||| ( ~~~b ||| c)) + 8 * ( ~~~a &&& ( ~~~b &&& c)) - 11 * ( ~~~a &&& (b &&& c)) + 6 * (a &&& ( ~~~b &&& c)) + 12 * (a &&& (b &&& c)) = 1 * (c ^^^  ~~~( ~~~a ||| ( ~~~b &&& c)))

theorem lshrult_03_14_proof : lshrult_03_14_before ⊑ lshrult_03_14_after

theorem shl_nuw_add_nsw_nuw_proof : shl_nuw_add_nsw_nuw_before ⊑ shl_nuw_add_nsw_nuw_after

theorem or_and_shifts1_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬(3#32 ≥ ↑32 ∨ 5#32 ≥ ↑32) →
    ¬(3#32 ≥ ↑32 ∨ 5#32 ≥ ↑32 ∨ True ∧ (x <<< 3#32 &&& 8#32 &&& (x <<< 5#32 &&& 32#32) != 0) = true) →
      x <<< 3#32 &&& 15#32 ||

theorem slt_and_shl_one_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ¬(x ≥ ↑8 ∨ x ≥ ↑8) → True ∧ 1#8 <<< x >>> x ≠ 1#8 ∨ x ≥ ↑8 ∨ True ∧ 1#8 <<< x >>> x ≠ 1#8 ∨ x ≥ ↑8 → False

theorem f_proof : f_before ⊑ f_after

theorem e_628 :
    5 * (x ^^^ y) + 1 *  ~~~x + 4 *  ~~~(x &&&  ~~~y) - 2 * x + 4 *  ~~~(x &&& y) + 2 *  ~~~(x ^^^ y) + 11 *  ~~~y - 22 *  ~~~(x ||| y) - 14 *  ~~~(x |||  ~~~y) - 18 * (x &&&  ~~~y) = 4 * (x &&& y)

theorem fold_select_trunc_nuw_true_thm.extracted_1._2 : ∀ (x x_1 : BitVec 8),
  ¬(True ∧ zeroExtend 8 (truncate 1 x_1) ≠ x_1) → truncate 1 x_1 = 1#1 → x_1 = 1#8

theorem main7a_logical_thm.extracted_1._5 : ∀ (x x_1 x_2 : BitVec 32),
  ofBool (x_2 &&& x_1 == x_2) = 1#1 →
    ofBool (x_2 &&& x_1 != x_2) = 1#1 → ofBool (x &&& x_1 == x) = 1#1 → 0#32 = zeroExtend 32 1#1

theorem masked_icmps_mask_notallzeros_bmask_mixed_2_logical_proof : masked_icmps_mask_notallzeros_bmask_mixed_2_logical_before ⊑ masked_icmps_mask_notallzeros_bmask_mixed_2_logical_after

theorem p_constmask_commutative_thm (e e_1 : IntW 32) :
  LLVM.xor (LLVM.and e_1 (const? 32 (-65281))) (LLVM.and e (const? 32 65280)) ⊑
    LLVM.or (LLVM.and e_1 (const? 32 (-65281))) (LLVM.and e (const? 32 65280)) { «disjoint» := true }

@[simp, grind =]
theorem mem_toList [LawfulBEq α] {k : α} :
    k ∈ m.toList ↔ k ∈ m

theorem t3_no_extrause_thm (e e_1 : IntW 8) :
  icmp IntPred.uge (LLVM.xor e_1 (const? 8 (-1))) e ⊑
    icmp IntPred.ule e (LLVM.xor e_1 (const? 8 (-1)))

theorem and_shl_thm.extracted_1._2 : ∀ (x x_1 x_2 x_3 : BitVec 8),
  ¬(x_2 ≥ ↑8 ∨ x_2 ≥ ↑8) → ¬x_2 ≥ ↑8 → x_3 <<< x_2 &&& (x_1 <<< x_2 &&& x) = (x_1 &&& x_3) <<< x_2 &&& x

theorem ashrsgt_03_07_thm (e : IntW 4) : icmp IntPred.sgt (ashr e (const? 4 3)) (const? 4 7) ⊑ const? 1 0

theorem test_shl_nsw__nuw_is_safe_proof : test_shl_nsw__nuw_is_safe_before ⊑ test_shl_nsw__nuw_is_safe_after

@[simp]
theorem Term.toBV_boolConst {wenv : WidthExpr.Env wcard}
    {tctx : Term.Ctx wcard tcard}
    (benv : Term.BoolEnv bcard)
    (tenv : tctx.Env wenv) (b : Bool) :
  Term.toBV benv nenv ienv penv tenv (.boolConst b) = b

theorem test24_proof : test24_before ⊑ test24_after

theorem denote_insertPureCom {zip : Zipper d Γ_in eff t₁} [LawfulMonad d.m]
    {newCom : Com d zip.Γ_mid .pure newTys} {vs : HVector zip.Γ_mid.Var newTys} :
    (zip.insertPureCom vs newCom).denote = (fun (V_in : Valuation Γ_in) => do
      let V_mid ← zip.top.denote V_in
      zip.bot.denote
        ((Com.denoteLets newCom V_mid).comap <| newCom.outContextHom.with vs newCom.returnVars)
      )

theorem bv_AndOrXor_698 :
    ∀ (e e_1 e_2 : LLVM.IntW w),
      LLVM.and (LLVM.icmp LLVM.IntPred.eq (LLVM.and e e_1) (LLVM.const? w 0))
          (LLVM.icmp LLVM.IntPred.eq (LLVM.and e e_2) (LLVM.const? w 0)) ⊑
        LLVM.icmp LLVM.IntPred.eq (LLVM.and e (LLVM.or e_1 e_2)) (LLVM.const? w 0)

theorem splat_mul_known_lz_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬96#128 ≥ ↑128 → ofBool ((zeroExtend 128 x * 18446744078004518913#128) >>> 96#128 == 0#128) = 1#1

theorem e_1465 :
     - 1 *  ~~~(z &&&  ~~~t) + 2 * (z |||  ~~~t) + 3 * z + 3 *  ~~~(z &&& t) - 3 * t + 1 *  ~~~z - 11 *  ~~~t + 11 * (z ^^^ t) + 3 *  ~~~(z ||| t) - 14 *  ~~~(z |||  ~~~t) - 4 * (z &&& t) = 11 * (z &&&  ~~~t) - 3 *  ~~~(z &&&  ~~~z)

theorem positive_samevar_shlnuwnsw_lshrexact_proof : positive_samevar_shlnuwnsw_lshrexact_before ⊑ positive_samevar_shlnuwnsw_lshrexact_after

theorem e_1477 :
    7 *  ~~~(z &&&  ~~~z) - 7 *  ~~~z - 6 *  ~~~(z &&&  ~~~t) + 5 *  ~~~(z &&& t) + 2 * (z |||  ~~~t) + 5 * (z ^^^ t) + 2 *  ~~~t - 3 *  ~~~(z ||| t) + 1 *  ~~~(z |||  ~~~t) - 21 * (z &&&  ~~~t) + 2 * (z &&& t) = 5 * t

theorem n2_thm.extracted_1._2 : ∀ (x : BitVec 1), x = 1#1 → ¬x ^^^ 1#1 = 1#1 → 1#1 ^^^ 1#1 = 0#1

@[bv_multi_width_normalize] theorem BitVec.one_mul (x : BitVec w) : 1#w * x = x

theorem PR60818_sgt_thm (e : IntW 32) :
  icmp IntPred.sgt (sub (const? 32 0) e) e ⊑ icmp IntPred.slt e (sub (const? 32 0) e)

theorem main7b_logical_thm.extracted_1._10 : ∀ (x x_1 x_2 : BitVec 32),
  ¬ofBool (x_2 == x_1 &&& x_2) = 1#1 → ofBool (x_2 != x_1 &&& x_2) = 1#1 → ¬0#1 = 1#1 → 1#32 = zeroExtend 32 1#1

theorem e_695 :
     - 11 * (x |||  ~~~y) + 7 *  ~~~(x &&&  ~~~x) - 11 * (x ^^^ y) - 2 * (x ||| y) - 2 *  ~~~x - 11 *  ~~~(x &&&  ~~~y) + 2 *  ~~~(x &&& y) + 12 *  ~~~(x ||| y) + 15 * (x &&&  ~~~y) + 14 * (x &&& y) =  - 17 *  ~~~(x |||  ~~~y) - 3 *  ~~~(x ^^^ y)

theorem PR44545_thm.extracted_1._3 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (x_1 == 0#32) = 1#1 →
    ¬(True ∧ x.saddOverflow 1#32 = true ∨ True ∧ x.uaddOverflow 1#32 = true) →
      ¬(True ∧ (truncate 16 (x + 1#32)).saddOverflow (-1#16) = true) → truncate 16 (x + 1#32) + -1#16 = truncate 16 x

theorem xor_of_icmps_to_ne_commute_thm.extracted_1._1 : ∀ (x : BitVec 64),
  ofBool (x <ₛ 6#64) ^^^ ofBool (4#64 <ₛ x) = ofBool (x != 5#64)

theorem main3f_like_logical_thm.extracted_1._4 : ∀ (x x_1 : BitVec 32),
  ofBool (x_1 &&& x != 0#32) = 1#1 → ¬ofBool (x_1 &&& x == 0#32) = 1#1 → ¬True → 0#32 = zeroExtend 32 0#1

theorem in_constant_14_vary_thm.extracted_1._1 : ∀ (x : BitVec 4),
  (x ^^^ BitVec.ofInt 4 (-2)) &&& 1#4 ^^^ x = x &&& BitVec.ofInt 4 (-2)

theorem t1_proof : t1_before ⊑ t1_after

theorem main7d_thm (e e_1 e_2 e_3 e_4 : IntW 32) :
  select
      (LLVM.and (icmp IntPred.eq (LLVM.and e_4 (LLVM.and e_3 e_2)) (LLVM.and e_3 e_2))
        (icmp IntPred.eq (LLVM.and e_4 (LLVM.and e_1 e)) (LLVM.and e_1 e)))
      (const? 32 0) (const? 32 1) ⊑
    zext 32
      (icmp IntPred.ne (LLVM.and e_4 (LLVM.or (LLVM.and e_3 e_2) (LLVM.and e_1 e)))
        (LLVM.or (LLVM.and e_3 e_2) (LLVM.and e_1 e)))

theorem test_sub_0_Y_eq_0_thm (e : IntW 8) :
  icmp IntPred.eq (sub (const? 8 0) e) (const? 8 0) ⊑ icmp IntPred.eq e (const? 8 0)

theorem p0_thm (e : IntW 8) :
  icmp IntPred.sge (LLVM.and e (const? 8 3)) e ⊑ icmp IntPred.slt e (const? 8 4)

theorem main3c_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬ofBool (x &&& 7#32 != 0#32) ||

theorem p14_commutativity1_proof : p14_commutativity1_before ⊑ p14_commutativity1_after

theorem test25_logical_proof : test25_logical_before ⊑ test25_logical_after

theorem sext_xor_sub_1_thm.extracted_1._2 : ∀ (x : BitVec 64) (x_1 : BitVec 1),
  ¬x_1 = 1#1 → (signExtend 64 x_1 ^^^ x) - signExtend 64 x_1 = x

theorem select_icmp_x_and_8_ne_0_y_xor_8_thm.extracted_1._4 : ∀ (x : BitVec 64) (x_1 : BitVec 32),
  ¬ofBool (x_1 &&& 8#32 == 0#32) = 1#1 →
    ¬(True ∧ (x_1 &&& 8#32 ^^^ 8#32).msb = true) → x = x ^^^ zeroExtend 64 (x_1 &&& 8#32 ^^^ 8#32)

theorem test_implied_true_proof : test_implied_true_before ⊑ test_implied_true_after

theorem fold_eq_lhs_fail_eq_nonzero_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ¬x_1 ≥ ↑8 → True ∧ ((-1#8) <<< x_1).sshiftRight' x_1 ≠ -1#8 ∨ x_1 ≥ ↑8 → False

theorem or_to_nxor_multiuse_thm (e e_1 : IntW 32) :
  mul (mul (LLVM.and e_1 e) (LLVM.xor (LLVM.or e_1 e) (const? 32 (-1))))
      (LLVM.or (LLVM.and e_1 e) (LLVM.xor (LLVM.or e_1 e) (const? 32 (-1)))) ⊑
    mul (mul (LLVM.and e_1 e) (LLVM.xor (LLVM.or e_1 e) (const? 32 (-1))))
      (LLVM.or (LLVM.and e_1 e) (LLVM.xor (LLVM.or e_1 e) (const? 32 (-1))) { «disjoint» := true })

theorem e_1831 :
     - 11 *  ~~~( ~~~a ||| ( ~~~b &&& c)) - 2 *  ~~~(a ^^^ (b ^^^ c)) + 2 * (a ^^^ (b &&& c)) - 5 * (b ^^^  ~~~( ~~~a &&& (b ^^^ c))) - 1 * ( ~~~a &&& (b ^^^ c)) - 11 * (a ||| (b ^^^ c)) + 1 * ( ~~~b |||  ~~~(a ^^^ c)) - 7 *  ~~~(a ^^^ c) + 2 * (b &&&  ~~~c) - 2 *  ~~~(a ^^^ ( ~~~b &&& c)) + 2 * (c ^^^ (a &&& ( ~~~b ||| c))) - 5 * (c ^^^  ~~~(a &&& ( ~~~b &&& c))) - 2 * (a &&& (b ||| c)) - 6 * (b &&&  ~~~(a ^^^ c)) + 5 * ((a &&& c) ^^^ (a ^^^ ( ~~~b &&& c))) + 2 * (b ^^^ ( ~~~a ||| (b &&& c))) + 1 * (c |||  ~~~(a |||  ~~~b)) + 1 * (b ^^^  ~~~(a ||| ( ~~~b &&& c))) + 4 * (c &&&  ~~~(a &&&  ~~~b)) - 3 * ((a ||| b) &&& (b ^^^ c)) - 1 * (c ||| (a &&& b)) + 11 * (a ^^^ (b ^^^ c)) + 7 * (a ^^^ b) - 1 * (a &&& (b ^^^ c)) - 3 *  ~~~(a ^^^ (b &&& c)) + 2 *  ~~~(a &&& b) + 3 * (b ^^^ (a ||| (b ^^^ c))) + 4 * ( ~~~a &&& ( ~~~b ||| c)) + 2 * (c ^^^  ~~~( ~~~a &&& (b ||| c))) + 5 * b + 4 * (a ^^^ (b ||| c)) + 3 * ((a ||| b) &&&  ~~~(b ^^^ c)) - 7 * ((a &&& b) ^^^  ~~~(a ^^^ (b &&& c))) - 1 * ( ~~~b ||| (a ^^^ c)) + 1 * ( ~~~a ||| ( ~~~b ||| c)) + 20 *  ~~~(a ||| (b ||| c)) + 16 *  ~~~(a ||| ( ~~~b ||| c)) - 10 *  ~~~( ~~~a ||| (b ||| c)) + 26 *  ~~~( ~~~a ||| ( ~~~b ||| c)) - 17 * ( ~~~a &&& ( ~~~b &&& c)) - 33 * ( ~~~a &&& (b &&& c)) + 18 * (a &&& ( ~~~b &&& c)) + 15 * (a &&& (b &&& c)) = 1 * (b ^^^  ~~~(a ||| (b &&& c)))

theorem ugt_and_min_proof : ugt_and_min_before ⊑ ugt_and_min_after

theorem shrink_select_thm.extracted_1._2 : ∀ (x : BitVec 32) (x_1 : BitVec 1), ¬x_1 = 1#1 → truncate 8 42#32 = 42#8

theorem test_mul_nuw__nsw_is_safe_proof : test_mul_nuw__nsw_is_safe_before ⊑ test_mul_nuw__nsw_is_safe_after

theorem shl_trunc_smaller_ashr_thm (e : IntW 32) :
  shl (trunc 24 (ashr e (const? 32 10))) (const? 24 13) ⊑
    LLVM.and (shl (trunc 24 e) (const? 24 3)) (const? 24 (-8192))

theorem Predicate.evalEq_denote_false_iff {w : Nat} (a b : Term) (vars : List (BitVec w)) :
    evalEq (a.eval (List.map .ofBitVecSext vars)) (b.eval (List.map .ofBitVecSext vars)) w = false ↔
    Term.denote w a vars = Term.denote w b vars

theorem bigOr_append_equiv_bigOr_cons {α : Type _}
    (c : Circuit α) (cs : List (Circuit α)) :
    Equiv (bigOr (cs ++ [c])) (Circuit.bigOr (c :: cs))

theorem e_1870 :
    2 * ( ~~~(a ^^^ b) &&& (a ^^^ c)) - 6 * (c ||| (a ^^^ b)) + 1 *  ~~~( ~~~a &&& ( ~~~b &&& c)) + 1 * ( ~~~(a ^^^ b) &&&  ~~~(a ^^^ c)) - 2 * ((b &&& c) ^^^  ~~~(a &&& (b ^^^ c))) - 11 * (c ^^^  ~~~( ~~~a ||| (b &&& c))) - 6 * ((b &&& c) ||| (a &&& (b ||| c))) - 1 * ( ~~~a &&& ( ~~~b ||| c)) + 4 *  ~~~( ~~~a &&& (b ||| c)) - 1 * (a ^^^ b) + 1 * (c ^^^ (a ||| ( ~~~b &&& c))) - 5 * (a &&& c) - 1 * (b ^^^  ~~~(a |||  ~~~c)) - 2 * (b ^^^  ~~~( ~~~a &&& (b ^^^ c))) + 4 * (c ^^^  ~~~(a ||| b)) + 3 * ( ~~~(a |||  ~~~b) ||| (a ^^^ (b ^^^ c))) + 2 * ((a ^^^ b) ||| (a ^^^ c)) + 1 * (c ^^^  ~~~( ~~~a &&& ( ~~~b ||| c))) - 11 * ((a &&& b) ^^^ (a ^^^ (b &&& c))) + 1 * ((a ^^^ b) &&&  ~~~(a ^^^ c)) - 5 * (b ^^^ (a &&& (b ^^^ c))) + 4 * ((a &&&  ~~~b) |||  ~~~(a ^^^ (b ^^^ c))) + 1 * (b ^^^ ( ~~~a &&& (b ||| c))) - 1 *  ~~~a + 4 *  ~~~(b ||| c) - 1 *  ~~~(a ^^^ (b ^^^ c)) - 3 *  ~~~(a ^^^ (b ||| c)) - 2 * (b ^^^ ( ~~~a ||| ( ~~~b &&& c))) - 7 * (c ^^^ (a &&& b)) + 3 * (c ^^^  ~~~( ~~~a &&& (b &&& c))) - 1 *  ~~~(a ||| b) + 2 * (b ^^^ (a |||  ~~~c)) + 1 * (a ^^^ (b ||| c)) - 3 * ((a &&&  ~~~b) ||| (b ^^^ c)) - 1 * ((a ||| b) &&&  ~~~(a ^^^ (b ^^^ c))) - 5 * (c |||  ~~~(a |||  ~~~b)) - 3 * (b ^^^ ( ~~~a ||| (b ^^^ c))) + 7 * (a ^^^ (b ^^^ c)) + 1 * ( ~~~a ||| (b ||| c)) + 7 * ( ~~~(a |||  ~~~b) ||| (b ^^^ c)) - 8 *  ~~~(a ||| (b ||| c)) - 1 *  ~~~(a ||| ( ~~~b ||| c)) + 3 *  ~~~( ~~~a ||| (b ||| c)) + 8 *  ~~~( ~~~a ||| ( ~~~b ||| c)) + 18 * ( ~~~a &&& ( ~~~b &&& c)) + 26 * ( ~~~a &&& (b &&& c)) + 36 * (a &&& (b &&& c)) =  - 35 * (a &&& ( ~~~b &&& c))

theorem select_constants_and_icmp_ne0_common_bit_proof : select_constants_and_icmp_ne0_common_bit_before ⊑ select_constants_and_icmp_ne0_common_bit_after

theorem e_259 :
    7 * y - 5 * x - 2 * (x |||  ~~~y) + 2 *  ~~~(x ||| y) - 8 *  ~~~(x |||  ~~~y) + 6 * (x &&&  ~~~y) + 2 * (x &&& y) =  - 3 * (x ^^^ y) + 2 * (x ||| y)

theorem both_proof : both_before ⊑ both_after

theorem n2_thm.extracted_1._1 : ∀ (x : BitVec 16),
  ¬15#32 ≥ ↑32 → zeroExtend 32 x <<< 15#32 &&& BitVec.ofInt 32 (-2147483648) = 0#32

theorem sext_sext_ult_proof : sext_sext_ult_before ⊑ sext_sext_ult_after

@[simp]
theorem BitVec.zero_concat (b : Bool) : (0#0).concat b = BitVec.ofBool b

theorem pr51551_neg1_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬(True ∧ (x_1 &&& BitVec.ofInt 32 (-3) ||| 1#32).smulOverflow x = true) →
    True ∧ (x_1 &&& 4#32 &&& 1#32 != 0) = true → False

theorem t0_commutative_thm (e e_1 : IntW 8) (e_2 : IntW 1) (e_3 e_4 : IntW 8) :
  select (select (icmp IntPred.eq e_4 e_3) (LLVM.xor e_2 (const? 1 1)) (const? 1 0)) e_1 e ⊑
    select (select (icmp IntPred.ne e_4 e_3) (const? 1 1) e_2) e e_1

theorem t7_thm.extracted_1._3 : ∀ (x : BitVec 8) (x_1 : BitVec 1) (x_2 : BitVec 8),
  ¬x_1 = 1#1 → ¬x ≥ ↑8 → True ∧ ((-1#8) <<< x).sshiftRight' x ≠ -1#8 ∨ x ≥ ↑8 → False

theorem a_false_implies_b_false2_comm_proof : a_false_implies_b_false2_comm_before ⊑ a_false_implies_b_false2_comm_after

theorem ugt_swap_or_not_min_logical_proof : ugt_swap_or_not_min_logical_before ⊑ ugt_swap_or_not_min_logical_after

theorem test_nsw_and_signed_pred_proof : test_nsw_and_signed_pred_before ⊑ test_nsw_and_signed_pred_after

theorem zext_zext_eq_thm (e e_1 : IntW 8) :
  icmp IntPred.eq (zext 32 e_1) (zext 32 e) ⊑ icmp IntPred.eq e_1 e

theorem ne_smax2_proof : ne_smax2_before ⊑ ne_smax2_after

theorem f_t15_t01_t09_thm.extracted_1._2 : ∀ (x : BitVec 40),
  ¬(31#40 ≥ ↑40 ∨ 16#32 ≥ ↑32) →
    ¬(15#40 ≥ ↑40 ∨ True ∧ signExtend 40 (truncate 32 (x.sshiftRight' 15#40)) ≠ x.sshiftRight' 15#40) →
      truncate 32 (x.sshiftRight' 31#40) <<< 16#32 = truncate 32 (x.sshiftRight' 15#40) &&& BitVec.ofInt 32 (-65536)

theorem src_is_mask_zext_fail_not_mask_proof : src_is_mask_zext_fail_not_mask_before ⊑ src_is_mask_zext_fail_not_mask_after

theorem main3d_logical_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x &&& 7#32 != 0#32) = 1#1 → True → 0#32 = zeroExtend 32 (ofBool (x &&& 23#32 == 0#32))

theorem sdiv_icmp5_thm (e : IntW 64) :
  icmp IntPred.eq (LLVM.sdiv e (const? 64 (-5)) { «exact» := true }) (const? 64 1) ⊑
    icmp IntPred.eq e (const? 64 (-5))

theorem icmp_sle11_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬(True ∧ (x <<< 7#8).sshiftRight' 7#8 ≠ x ∨ 7#8 ≥ ↑8) →
    ofBool (x <<< 7#8 ≤ₛ BitVec.ofInt 8 (-2)) = ofBool (x <ₛ 0#8)

theorem is_ascii_alphabetic_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬(True ∧ x.saddOverflow (BitVec.ofInt 32 (-65)) = true) →
    ¬ofBool (x + BitVec.ofInt 32 (-65) <ᵤ 26#32) = 1#1 →
      ¬(True ∧ x.saddOverflow (BitVec.ofInt 32 (-97)) = true) →
        ofBool (x + BitVec.ofInt 32 (-97) <ᵤ 26#32) =
          ofBool ((x &&& BitVec.ofInt 32 (-33)) + BitVec.ofInt 32 (-65) <ᵤ 26#32)

theorem sext_sext_ult_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ofBool (signExtend 32 x_1 <ᵤ signExtend 32 x) = ofBool (x_1 <ᵤ x)

theorem AvoidCollision_getElem?_setWidth (m : Nat) (x : BitVec n) (i : Nat) :
    (x.setWidth m)[i]? = if i < m then some (x.getLsbD i) else none

theorem substitute_constant_and_eq_eq_logical_thm (e e_1 : IntW 8) :
  select (icmp IntPred.eq e_1 (const? 8 42)) (icmp IntPred.eq e_1 e) (const? 1 0) ⊑
    select (icmp IntPred.eq e_1 (const? 8 42)) (icmp IntPred.eq e (const? 8 42)) (const? 1 0)

theorem samesign_commute2_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ofBool (x_1 &&& x <ₛ 0#32) ||

@[simp] theorem Com.denote_var [LawfulMonad d.m] {e : Expr d Γ eff α} :
    (Com.var e body).denote =
    fun Γv => (e.denote Γv) >>= body.denote

theorem Lets.Γ_out_eq (l : Lets Op Γ_in Γ_out) : Γ_out = (Lets.outContext l.val Γ_in)

theorem bitwise_and_logical_and_icmps_thm (e e_1 e_2 : IntW 8) :
  LLVM.and
      (select (icmp IntPred.eq e_2 (const? 8 42)) (icmp IntPred.ne (LLVM.and e_1 (const? 8 1)) (const? 8 0))
        (const? 1 0))
      (icmp IntPred.ne (LLVM.and e_1 (shl (const? 8 1) e)) (const? 8 0)) ⊑
    select (icmp IntPred.eq e_2 (const? 8 42))
      (icmp IntPred.eq (LLVM.and e_1 (LLVM.or (shl (const? 8 1) e { «nsw» := false, «nuw» := true }) (const? 8 1)))
        (LLVM.or (shl (const? 8 1) e { «nsw» := false, «nuw» := true }) (const? 8 1)))
      (const? 1 0)

theorem masked_icmps_mask_notallzeros_bmask_mixed_negated_2_proof : masked_icmps_mask_notallzeros_bmask_mixed_negated_2_before ⊑ masked_icmps_mask_notallzeros_bmask_mixed_negated_2_after

theorem e_2136 :
     - 5 *  ~~~( ~~~d ||| (e &&& f)) + 3 * (e ^^^ ( ~~~d &&& (e ||| f))) + 2 * (f ^^^  ~~~( ~~~d &&& ( ~~~e ||| f))) + 1 * (e &&& f) + 7 * (f ^^^  ~~~( ~~~d &&& (e &&& f))) + 7 *  ~~~(d ^^^ ( ~~~e ||| f)) + 1 * (f ^^^  ~~~( ~~~d &&& (e ||| f))) - 1 * (d ||| (e &&& f)) + 7 * (e ^^^  ~~~( ~~~d ||| ( ~~~e &&& f))) - 3 * ((d &&& e) ^^^ (e |||  ~~~f)) + 4 * (f &&& (d ||| e)) - 3 * (e &&& (d |||  ~~~f)) - 1 * ((d &&& e) ^^^  ~~~(d ^^^ ( ~~~e ||| f))) - 2 * (f ^^^  ~~~(d ||| e)) - 2 * ( ~~~(d ||| e) ||| (d ^^^ (e ^^^ f))) + 7 * (f ^^^ (d ||| (e ||| f))) - 7 *  ~~~( ~~~d &&& (e ||| f)) + 2 * ( ~~~e &&& (d ^^^ f)) - 11 *  ~~~(d ^^^ f) + 7 *  ~~~(d &&& (e ^^^ f)) + 2 * ( ~~~(d |||  ~~~e) |||  ~~~(d ^^^ (e ^^^ f))) + 5 * (f |||  ~~~(d ^^^ e)) + 4 * (d ||| ( ~~~e ||| f)) + 11 * (f ^^^ ( ~~~d &&& (e ||| f))) + 1 * (e ^^^ (d ||| (e ^^^ f))) - 1 *  ~~~(e |||  ~~~f) - 2 *  ~~~(e &&& f) + 4 *  ~~~(d &&& e) - 6 * ((d &&& e) ^^^ (e ||| f)) + 3 * (f ^^^ (d &&&  ~~~e)) - 2 * ( ~~~d ||| (e ^^^ f)) + 11 * (e ||| (d ^^^ f)) + 1 *  ~~~(d &&& f) + 5 * (e ^^^ (d &&& f)) - 7 * (e ^^^ (d ||| ( ~~~e &&& f))) - 6 * (e ^^^  ~~~(d &&&  ~~~f)) + 4 * (e ^^^  ~~~(d &&& ( ~~~e ||| f))) + 7 * ( ~~~(d &&& e) &&&  ~~~(e ^^^ f)) - 5 * (f ^^^  ~~~( ~~~d &&& ( ~~~e &&& f))) - 2 *  ~~~(d ||| (e ||| f)) - 30 *  ~~~(d ||| ( ~~~e ||| f)) - 16 *  ~~~( ~~~d ||| ( ~~~e ||| f)) - 18 * ( ~~~d &&& ( ~~~e &&& f)) - 51 * ( ~~~d &&& (e &&& f)) + 7 * (d &&& ( ~~~e &&& f)) - 34 * (d &&& (e &&& f)) =  - 1 * (e ^^^ (d ||| f)) + 39 *  ~~~( ~~~d ||| (e ||| f))

theorem carry_decr (x : Unit → BitStream) : ∀ (n : ℕ), decr.carry x (n+1) =
    fun _ => (BitStream.decrAux (x ()) n).2

theorem lshr_xor_thm (e e_1 : IntW 8) :
  shl (LLVM.xor (lshr e_1 (const? 8 3)) (LLVM.srem e (const? 8 42))) (const? 8 3) ⊑
    LLVM.xor (LLVM.and e_1 (const? 8 (-8))) (shl (LLVM.srem e (const? 8 42)) (const? 8 3))

theorem or_and3_commuted_thm.extracted_1._3 : ∀ (x : BitVec 1) (x_1 x_2 : BitVec 32),
  ofBool (x_2 == x_1) ||

theorem test31_proof : test31_before ⊑ test31_after

theorem ashr_lshr_wrong_operands_thm.extracted_1._2 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (0#32 ≤ₛ x_1) = 1#1 → ¬x ≥ ↑32 → ¬ofBool (x_1 <ₛ 0#32) = 1#1 → x_1 >>> x = x_1.sshiftRight' x

theorem test8_thm.extracted_1._1 : ∀ (x : BitVec 7), ¬(4#7 ≥ ↑7 ∨ 3#7 ≥ ↑7) → x <<< 4#7 <<< 3#7 = 0#7

theorem test_shl__all_are_safe_thm.extracted_1._1 : ∀ (x : BitVec 64) (x_1 : BitVec 32),
  ofBool (x_1 &&& 15#32 == 0#32) = 1#1 →
    2#32 ≥ ↑32 ∨ True ∧ (x_1 <<< 2#32 &&& 60#32).msb = true ∨ zeroExtend 64 (x_1 <<< 2#32 &&& 60#32) ≥ ↑64 → False

theorem sel_sext_thm (e : IntW 32) (e_1 : IntW 1) :
  sext 64 (select e_1 e (const? 32 42)) ⊑ select e_1 (sext 64 e) (const? 64 42)

theorem lshr_exact_add_nuw_proof : lshr_exact_add_nuw_before ⊑ lshr_exact_add_nuw_after

theorem positive_sameconst_shlnuwnsw_lshrexact_proof : positive_sameconst_shlnuwnsw_lshrexact_before ⊑ positive_sameconst_shlnuwnsw_lshrexact_after

theorem absdiff1_proof : absdiff1_before ⊑ absdiff1_after

theorem scalar1_thm.extracted_1._2 : ∀ (x x_1 : BitVec 4),
  ¬(True ∧ (x_1 &&& BitVec.ofInt 4 (-2) &&& (x &&& 1#4) != 0) = true) →
    (x_1 ^^^ x) &&& BitVec.ofInt 4 (-2) ^^^ x = x_1 &&& BitVec.ofInt 4 (-2) ||

theorem and_sext_multiuse_thm.extracted_1._2 : ∀ (x x_1 x_2 x_3 : BitVec 32),
  ¬ofBool (x_2 <ₛ x_3) = 1#1 →
    (signExtend 32 (ofBool (x_2 <ₛ x_3)) &&& x_1) + (signExtend 32 (ofBool (x_2 <ₛ x_3)) &&& x) = 0#32

theorem not_select_bool_const4_proof : not_select_bool_const4_before ⊑ not_select_bool_const4_after

theorem e_592 :
     - 1 * (x |||  ~~~y) + 1 * (x ||| y) - 5 *  ~~~(x &&& y) + 1 *  ~~~(x &&&  ~~~y) + 2 *  ~~~y + 7 * (x ^^^ y) + 14 *  ~~~(x ||| y) + 7 *  ~~~(x |||  ~~~y) + 8 * (x &&&  ~~~y) + 11 * (x &&& y) = 1 * x + 11 *  ~~~(x &&&  ~~~x)

theorem logical_or_bitwise_or_icmps_comm1_thm.extracted_1._2 : ∀ (x x_1 x_2 : BitVec 8),
  ¬x_1 ≥ ↑8 → ofBool (x_2 &&& 1#8 <<< x_1 == 0#8) = 1#1 → True ∧ 1#8 <<< x_1 >>> x_1 ≠ 1#8 ∨ x_1 ≥ ↑8 → False

theorem test1_proof : test1_before ⊑ test1_after

theorem test10b_proof : test10b_before ⊑ test10b_after

theorem t5_ugt_slt_0_thm (e e_1 e_2 : IntW 32) :
  select (icmp IntPred.ugt (add e_2 (const? 32 16)) (const? 32 143))
      (select (icmp IntPred.slt e_2 (const? 32 (-16))) e_1 e) e_2 ⊑
    select (icmp IntPred.sgt e_2 (const? 32 127)) e
      (select (icmp IntPred.slt e_2 (const? 32 (-16))) e_1 e_2)

theorem udiv_eq_umax_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ¬x = 0 → ofBool (x_1 / x == -1#8) = ofBool (x_1 == -1#8) &&& ofBool (x == 1#8)

theorem orn_and_cmp_2_logical_proof : orn_and_cmp_2_logical_before ⊑ orn_and_cmp_2_logical_after

theorem udiv_shl_pair_const_proof : udiv_shl_pair_const_before ⊑ udiv_shl_pair_const_after

theorem zext_ult_zext_thm (e : IntW 1) (e_1 : IntW 8) :
  icmp IntPred.ult (zext 16 (mul e_1 e_1)) (zext 16 e) ⊑
    LLVM.and (icmp IntPred.eq (mul e_1 e_1) (const? 8 0)) e

@[simp] theorem Com.outContextHom_var :
    (var e body : Com d Γ eff t).outContextHom
    = e.contextHom.comp body.outContextHom

theorem main4e_like_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 32),
  ofBool (x_2 &&& x_1 == x_1) &&& ofBool (x_2 &&& x == x) = 1#1 →
    0#32 = zeroExtend 32 (ofBool (x_2 &&& (x_1 ||| x) != x_1 ||| x))

theorem bv_AndOrXor_2607 :
    ∀ (e e_1 : LLVM.IntW w),
      LLVM.xor (LLVM.or e (LLVM.xor e_1 (LLVM.const? w (-1)))) (LLVM.or (LLVM.xor e (LLVM.const? w (-1))) e_1) ⊑
        LLVM.xor e e_1

theorem t0_sub_of_trueval_thm (e e_1 : IntW 8) (e_2 : IntW 1) :
  sub (select e_2 e_1 e) e_1 ⊑ select e_2 (const? 8 0) (sub e e_1)

theorem urem_illegal_type_proof : urem_illegal_type_before ⊑ urem_illegal_type_after

theorem e_1525 :
    5 * ( ~~~(a |||  ~~~b) |||  ~~~(a ^^^ (b ^^^ c))) + 2 * ( ~~~a ||| (b ||| c)) + 7 * (c ^^^ (a ||| ( ~~~b ||| c))) - 14 *  ~~~(a ||| (b ||| c)) - 6 *  ~~~(a ||| ( ~~~b ||| c)) - 6 *  ~~~( ~~~a ||| (b ||| c)) - 14 *  ~~~( ~~~a ||| ( ~~~b ||| c)) - 2 * ( ~~~a &&& ( ~~~b &&& c)) - 7 * ( ~~~a &&& (b &&& c)) - 6 * (a &&& ( ~~~b &&& c)) - 1 * (a &&& (b &&& c)) = 1 *  ~~~(a ^^^ ( ~~~b ||| c))

theorem PR2844_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬ofBool (x == 0#32) ||

theorem eq_iff_EqualUpTo (x y : BitStream) :
  x = y ↔ (∀ w, EqualUpTo w x y)

theorem ashr_can_be_lshr_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬(True ∧ x >>> 16#32 <<< 16#32 ≠ x ∨
        16#32 ≥ ↑32 ∨ True ∧ signExtend 32 (truncate 16 (x.sshiftRight' 16#32)) ≠ x.sshiftRight' 16#32) →
    True ∧ x >>> 16#32 <<< 16#32 ≠ x ∨ 16#32 ≥ ↑32 ∨ True ∧ zeroExtend 32 (truncate 16 (x >>> 16#32)) ≠ x >>> 16#32 →
      False

theorem test3_proof : test3_before ⊑ test3_after

theorem e_470 :
    3 * (x ||| y) + 1 * (x ^^^ y) - 2 *  ~~~(x &&&  ~~~y) - 1 * x + 2 *  ~~~(x &&&  ~~~x) - 2 *  ~~~x + 2 *  ~~~(x ||| y) - 5 * (x &&&  ~~~y) - 2 * (x &&& y) = 2 *  ~~~(x |||  ~~~y)

theorem test70_proof : test70_before ⊑ test70_after

theorem zext_sext_add_icmp_sgt_0_thm.extracted_1._1 : ∀ (x x_1 : BitVec 1),
  ofBool (0#8 <ₛ zeroExtend 8 x_1 + signExtend 8 x) = x_1 &&& (x ^^^ 1#1)

theorem e_1552 :
     - 7 * (b ^^^ ( ~~~a ||| (b &&& c))) - 6 * (b ^^^ (a ||| (b &&& c))) + 1 * (b ^^^  ~~~(a &&& ( ~~~b ||| c))) - 11 * (b ^^^ ( ~~~a &&& (b ^^^ c))) + 5 * (a ||| (b ||| c)) + 6 *  ~~~(a ||| (b ||| c)) - 1 *  ~~~(a ||| ( ~~~b ||| c)) - 1 *  ~~~( ~~~a ||| (b ||| c)) + 11 *  ~~~( ~~~a ||| ( ~~~b ||| c)) + 12 * ( ~~~a &&& ( ~~~b &&& c)) + 6 * ( ~~~a &&& (b &&& c)) - 1 * (a &&& ( ~~~b &&& c)) + 3 * (a &&& (b &&& c)) =  - 2 *  ~~~( ~~~a &&& ( ~~~b ||| c))

theorem com_ty : com.2.2.1 = [.bitvec 32]

theorem test23_logical_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (1#32 <ₛ x) = 1#1 → ofBool (x ≤ₛ 2#32) = ofBool (x == 2#32)

theorem udiv_c_i32_proof : udiv_c_i32_before ⊑ udiv_c_i32_after

theorem foo4_thm (e e_1 : IntW 1) : LLVM.sdiv e_1 e ⊑ e_1

theorem no_shift_xor_multiuse_cmp_thm.extracted_1._7 : ∀ (x x_1 x_2 x_3 : BitVec 32),
  ¬ofBool (0#32 != x_3 &&& 4096#32) = 1#1 →
    ofBool (x_3 &&& 4096#32 == 0#32) = 1#1 → (x_2 ||| 4096#32) * x = (x_2 ||| x_3 &&& 4096#32 ^^^ 4096#32) * x

theorem src_is_notmask_sext_proof : src_is_notmask_sext_before ⊑ src_is_notmask_sext_after

theorem mul_sel_op0_proof : mul_sel_op0_before ⊑ mul_sel_op0_after

theorem sext_multi_uses_thm.extracted_1._1 : ∀ (x : BitVec 64) (x_1 : BitVec 1) (x_2 : BitVec 64),
  x_1 = 1#1 → x_2 * signExtend 64 x_1 + ((x ^^^ signExtend 64 x_1) - signExtend 64 x_1) = 0#64 - (x_2 + x)

theorem ashrsgt_01_13_exact_proof : ashrsgt_01_13_exact_before ⊑ ashrsgt_01_13_exact_after

theorem icmp_eq_sext_eq_allones_thm (e : IntW 32) :
  icmp IntPred.eq (sext 32 (icmp IntPred.eq e (const? 32 (-1)))) e ⊑
    icmp IntPred.ult (add e (const? 32 1)) (const? 32 2)

theorem e_2482 :
    1 * (e ^^^  ~~~(d &&& (e ||| f))) + 7 *  ~~~( ~~~d &&& ( ~~~e &&& f)) + 1 * (e |||  ~~~(d ||| f)) + 11 * ((d &&& e) |||  ~~~(e ^^^ f)) - 5 * (f ^^^ ( ~~~d ||| ( ~~~e &&& f))) + 3 * (e &&& (d ||| f)) + 1 * (e ^^^  ~~~(d ||| ( ~~~e &&& f))) + 3 * (d ^^^ (e ||| f)) - 1 * (e ^^^ ( ~~~d &&& (e ^^^ f))) - 1 * ( ~~~d &&& (e ^^^ f)) + 2 * (e ^^^  ~~~(d &&& f)) + 2 *  ~~~(d &&& (e ^^^ f)) + 5 * (f |||  ~~~(d |||  ~~~e)) + 2 * (d ||| (e ^^^ f)) - 1 * (e ^^^ ( ~~~d &&& (e ||| f))) + 7 * ((d &&& f) ||| (e &&&  ~~~f)) - 2 * ( ~~~(d &&& e) &&&  ~~~(e ^^^ f)) + 1 * ( ~~~d ||| (e ||| f)) - 1 * ((d &&& f) ^^^  ~~~(d ^^^ (e &&& f))) + 7 *  ~~~( ~~~d &&& (e ||| f)) + 2 * (d ||| (e ||| f)) - 1 * ( ~~~e &&& (d ^^^ f)) + 2 *  ~~~(d &&&  ~~~d) + 1 * (e ^^^  ~~~( ~~~d ||| (e &&& f))) - 11 * ((d &&& e) ^^^ (e ||| f)) - 1 * (e &&&  ~~~f) - 2 * ((d &&& e) ^^^  ~~~(d ^^^ (e &&& f))) + 5 * (f &&&  ~~~(d &&& e)) - 3 * ((d &&& e) |||  ~~~(e ||| f)) - 3 * ((d &&& f) ^^^  ~~~(e &&&  ~~~f)) + 4 * (f ^^^  ~~~( ~~~d &&& (e ||| f))) - 1 * (f ^^^ (d &&& e)) - 7 * ((e &&& f) ^^^  ~~~(d &&& (e ^^^ f))) + 7 * ((d &&&  ~~~e) ||| (e ^^^ f)) - 6 *  ~~~(d &&& f) + 2 * ((d &&& f) ^^^ (d ^^^ (e &&& f))) + 5 * (d &&&  ~~~e) - 5 * (e ^^^ (d &&& (e ||| f))) - 7 * (e &&&  ~~~(d &&&  ~~~f)) + 1 * (f ^^^  ~~~(d &&& ( ~~~e &&& f))) - 1 * (e ^^^ ( ~~~d ||| (e ||| f))) - 2 * ( ~~~(d &&&  ~~~e) &&&  ~~~(e ^^^ f)) + 5 *  ~~~(d ^^^ (e ^^^ f)) + 1 * ((d &&& e) ^^^  ~~~(d ^^^ ( ~~~e ||| f))) + 3 * (d &&& (e ||| f)) - 11 *  ~~~(d ^^^ (e &&& f)) - 3 * (e ^^^  ~~~(d ||| (e &&& f))) + 11 * (e ^^^ f) - 1 * ((e &&& f) ^^^  ~~~( ~~~d &&& (e ^^^ f))) - 7 * ( ~~~(d ||| e) |||  ~~~(e ^^^ f)) + 1 * (d ||| f) + 4 * (e |||  ~~~(d ^^^ f)) - 2 * (f ^^^ ( ~~~d ||| (e &&& f))) - 2 * (e ^^^ ( ~~~d ||| ( ~~~e &&& f))) + 1 * (e ^^^  ~~~(d &&& (e &&& f))) - 5 * (e &&& f) + 1 * (f ^^^ (d ||| e)) + 1 * (e ^^^  ~~~( ~~~d ||| ( ~~~e &&& f))) + 5 *  ~~~(d ||| ( ~~~e &&& f)) + 5 * ( ~~~(d &&& e) &&& (e ^^^ f)) + 7 * (e ^^^  ~~~(d |||  ~~~f)) - 7 * f + 2 * (f ^^^  ~~~(d ||| ( ~~~e &&& f))) - 6 * ( ~~~f |||  ~~~(d ^^^ e)) + 4 * ( ~~~d ||| ( ~~~e &&& f)) - 3 * ((d &&& e) ||| (e ^^^ f)) + 4 * (e ^^^ (d ||| ( ~~~e &&& f))) + 1 *  ~~~(d &&& ( ~~~e ||| f)) - 7 * (d |||  ~~~f) - 1 * (e ^^^  ~~~(d ||| (e ^^^ f))) + 1 * (e ||| f) + 1 * ( ~~~(d |||  ~~~e) ||| (e ^^^ f)) - 2 *  ~~~( ~~~d &&& (e ^^^ f)) - 3 *  ~~~(d ||| (e ||| f)) - 24 *  ~~~(d ||| ( ~~~e ||| f)) - 23 *  ~~~( ~~~d ||| (e ||| f)) - 66 *  ~~~( ~~~d ||| ( ~~~e ||| f)) - 15 * ( ~~~d &&& ( ~~~e &&& f)) - 29 * ( ~~~d &&& (e &&& f)) - 67 * (d &&& ( ~~~e &&& f)) - 3 * (d &&& (e &&& f)) =  - 4 * ((e &&&  ~~~f) ^^^ ( ~~~d ||| (e ^^^ f))) - 11 * ( ~~~d ||| (e ^^^ f))

theorem exact_lshr_eq_both_equal_proof : exact_lshr_eq_both_equal_before ⊑ exact_lshr_eq_both_equal_after

theorem bools2_logical_commute0_and2_thm.extracted_1._1 : ∀ (x : BitVec 1), ¬x = 1#1 → 0#1 = 1#1 → False

omit [Fintype S] [DecidableEq S] [LawfulBEq A] in
theorem addOrCreateState_grow (st : worklist.St A S) (b : Bool) (sa : S) :
    let (_, st') := st.addOrCreateState _ _ b sa
    ∃ sas, List.Perm st'.map.keys (sas ++ st.map.keys) ∧ st'.worklist.toList = st.worklist.toList ++ sas

theorem test_sub_nuw__nuw_is_safe_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x &&& 2147483647#32 == 1073741824#32) = 1#1 →
    True ∧ (BitVec.ofInt 32 (-2147483648)).usubOverflow (x &&& 2147483647#32) = true → False

theorem test3_thm (e : IntW 32) : LLVM.xor e e ⊑ const? 32 0

theorem or_xor_xor_normal_variant2_proof : or_xor_xor_normal_variant2_before ⊑ or_xor_xor_normal_variant2_after

theorem land_lor_left1_thm.extracted_1._3 : ∀ (x x_1 : BitVec 1), ¬x_1 = 1#1 → 0#1 = 1#1 → 1#1 = x_1

theorem masked_icmps_mask_notallzeros_bmask_mixed_negated_6_thm (e : IntW 32) :
  LLVM.or (icmp IntPred.eq (LLVM.and e (const? 32 12)) (const? 32 0))
      (icmp IntPred.ne (LLVM.and e (const? 32 15)) (const? 32 8)) ⊑
    icmp IntPred.ne (LLVM.and e (const? 32 15)) (const? 32 8)

theorem ne_nsw_rem_nz_thm (e : IntW 8) :
  icmp IntPred.ne (mul e (const? 8 5) { «nsw» := true, «nuw» := false }) (const? 8 (-126)) ⊑ const? 1 1

theorem sge_or_not_max_commute_logical_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ¬ofBool (x_1 != 127#8) = 1#1 → ofBool (x ≤ₛ x_1) = 1#1

theorem ashrslt_02_01_exact_thm (e : IntW 4) :
  icmp IntPred.slt (ashr e (const? 4 2) { «exact» := true }) (const? 4 1) ⊑
    icmp IntPred.slt e (const? 4 4)

theorem ashr_sgt_exact_proof : ashr_sgt_exact_before ⊑ ashr_sgt_exact_after

theorem xor_and_logic_or1_thm.extracted_1._2 : ∀ (x x_1 x_2 : BitVec 1),
  x_2 = 1#1 → x_2 &&& x_1 ^^^ 1#1 = x_1 ^^^ 1#1

theorem lshr_xor_or_good_mask_thm.extracted_1._2 : ∀ (x x_1 : BitVec 8),
  ¬(4#8 ≥ ↑8 ∨ 4#8 ≥ ↑8) →
    ¬(4#8 ≥ ↑8 ∨ True ∧ ((x ||| x_1) >>> 4#8 &&& 48#8 != 0) = true) →
      x_1 >>> 4#8 ||

theorem ashrslt_03_13_thm (e : IntW 4) : icmp IntPred.slt (ashr e (const? 4 3)) (const? 4 (-3)) ⊑ const? 1 0

theorem ashrsgt_03_15_proof : ashrsgt_03_15_before ⊑ ashrsgt_03_15_after

theorem nonexact_lshr_eq_exactdiv_proof : nonexact_lshr_eq_exactdiv_before ⊑ nonexact_lshr_eq_exactdiv_after

theorem sext_sub_const_proof : sext_sub_const_before ⊑ sext_sub_const_after

theorem eq_getLsbD_toBitVec_of_lt (x : BitStream) (i : Nat) (hi : i < w) :
    x i = (x.toBitVec w).getLsbD i

theorem negate_select_of_op_vs_negated_op_nsw_xyyx_proof : negate_select_of_op_vs_negated_op_nsw_xyyx_before ⊑ negate_select_of_op_vs_negated_op_nsw_xyyx_after

theorem sge_and_max_logical_proof : sge_and_max_logical_before ⊑ sge_and_max_logical_after

theorem positive_samevar_shlnuw_proof : positive_samevar_shlnuw_before ⊑ positive_samevar_shlnuw_after

theorem t2_ult_sgt_65536_thm.extracted_1._2 : ∀ (x x_1 : BitVec 32),
  ofBool (x_1 <ᵤ 65536#32) = 1#1 → ofBool (65535#32 <ₛ x_1) = 1#1 → x_1 = x

theorem test71_proof : test71_before ⊑ test71_after

theorem test16_proof : test16_before ⊑ test16_after

theorem e_1853 :
     - 1 * ( ~~~a &&& ( ~~~b ||| c)) - 2 * (b ^^^ ( ~~~a ||| ( ~~~b &&& c))) + 2 * (c |||  ~~~(a ||| b)) + 2 * ( ~~~(a ||| b) ||| (b ^^^ c)) + 1 *  ~~~(b |||  ~~~c) - 3 *  ~~~(b &&&  ~~~c) - 1 *  ~~~(a ||| c) + 7 * (b ^^^  ~~~( ~~~a ||| (b &&& c))) - 5 * (b ^^^ ( ~~~a ||| ( ~~~b ||| c))) - 7 * (c |||  ~~~(a ^^^ b)) + 11 * ( ~~~(a &&&  ~~~b) &&&  ~~~(b ^^^ c)) + 4 * (b ^^^  ~~~(a &&&  ~~~c)) - 6 * (c ||| (a &&&  ~~~b)) + 5 *  ~~~(a &&& c) - 7 * (c ^^^  ~~~( ~~~a ||| (b &&& c))) - 1 * (a ||| ( ~~~b ||| c)) - 1 * ((b &&&  ~~~c) ^^^ (a ||| (b ^^^ c))) - 6 * ((a &&& b) ||| (a ^^^ (b ^^^ c))) + 5 * ((a &&& b) ||| (b ^^^ c)) + 2 * (b ^^^ (a &&& (b ||| c))) - 1 * (b ^^^ (a |||  ~~~c)) - 1 * (b ^^^ (a ||| (b &&& c))) - 1 * (c ^^^ ( ~~~a ||| ( ~~~b ||| c))) + 2 * ( ~~~b |||  ~~~(a ^^^ c)) + 2 * ((a &&&  ~~~b) |||  ~~~(a ^^^ (b ^^^ c))) - 3 * (c ^^^  ~~~( ~~~a &&& (b ||| c))) - 3 * (b &&&  ~~~(a &&& c)) - 2 * (c ||| (a &&& b)) + 2 *  ~~~(a ^^^ b) - 1 * (c ^^^  ~~~(a ||| (b &&& c))) - 3 * (b ^^^  ~~~( ~~~a &&& (b ||| c))) + 1 * (b |||  ~~~(a ||| c)) + 1 * ((a &&& b) ^^^  ~~~(a ^^^ (b &&& c))) + 1 * ((a &&& c) ^^^  ~~~(b &&&  ~~~c)) + 4 * (b |||  ~~~(a |||  ~~~c)) + 1 * (a &&& ( ~~~b ||| c)) - 1 *  ~~~( ~~~a &&& (b ^^^ c)) - 1 * (b ^^^ (a &&& c)) - 7 *  ~~~(a ||| ( ~~~b ||| c)) + 26 *  ~~~( ~~~a ||| (b ||| c)) + 17 *  ~~~( ~~~a ||| ( ~~~b ||| c)) + 15 * ( ~~~a &&& ( ~~~b &&& c)) + 10 * ( ~~~a &&& (b &&& c)) + 12 * (a &&& ( ~~~b &&& c)) + 2 * (a &&& (b &&& c)) =  - 2 *  ~~~(a ||| (b ||| c)) + 5 * ( ~~~c ||| (a ^^^ b))

theorem lshrult_03_13_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬3#4 ≥ ↑4 → ofBool (x >>> 3#4 <ᵤ BitVec.ofInt 4 (-3)) = 1#1

theorem e_1557 :
     - 7 * (c ^^^ ( ~~~a ||| ( ~~~b &&& c))) - 5 * (c ^^^ (a &&& b)) + 5 * (c ^^^  ~~~(a &&& (b ||| c))) + 2 * (b ^^^ ( ~~~a ||| (b &&& c))) - 5 * ( ~~~(a ||| b) |||  ~~~(a ^^^ (b ^^^ c))) - 3 * (b ||| (a ^^^ c)) - 1 * (b ^^^  ~~~( ~~~a &&& (b ||| c))) + 7 *  ~~~(a ||| (b ||| c)) + 7 *  ~~~(a ||| ( ~~~b ||| c)) - 1 *  ~~~( ~~~a ||| (b ||| c)) + 12 *  ~~~( ~~~a ||| ( ~~~b ||| c)) + 12 * ( ~~~a &&& ( ~~~b &&& c)) + 15 * ( ~~~a &&& (b &&& c)) + 6 * (a &&& ( ~~~b &&& c)) = 1 *  ~~~(a &&& ( ~~~b ||| c)) - 5 * (a &&& (b &&& c))

theorem trunc_sandwich_big_sum_shift1_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬(21#32 ≥ ↑32 ∨ 11#12 ≥ ↑12) → truncate 12 (x >>> 21#32) >>> 11#12 = 0#12

theorem sel_false_val_is_a_masked_ashr_of_true_val2_thm.extracted_1._3 : ∀ (x : BitVec 64) (x_1 : BitVec 32),
  ¬2#32 ≥ ↑32 →
    ¬ofBool ((x_1 &&& BitVec.ofInt 32 (-2147483588)).sshiftRight' 2#32 == 0#32) = 1#1 →
      ¬(2#32 ≥ ↑32 ∨ zeroExtend 64 ((x_1 &&& BitVec.ofInt 32 (-2147483588)).sshiftRight' 2#32) ≥ ↑64) →
        2#32 ≥ ↑32 ∨
            True ∧ (x_1.sshiftRight' 2#32 &&& BitVec.ofInt 32 (-536870897)).msb = true ∨
              zeroExtend 64 (x_1.sshiftRight' 2#32 &&& BitVec.ofInt 32 (-536870897)) ≥ ↑64 →
          False

theorem test2_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ofBool (-1#32 <ₛ x_1) ||

theorem lshrult_02_14_exact_proof : lshrult_02_14_exact_before ⊑ lshrult_02_14_exact_after

theorem lor_land_right1_thm (e e_1 : IntW 1) : select e_1 (select e_1 (const? 1 1) e) (const? 1 0) ⊑ e_1

theorem shl_mask_weird_type_thm (e : IntW 37) :
  LLVM.or (LLVM.and e (const? 37 255)) (shl (LLVM.and e (const? 37 255)) (const? 37 8)) ⊑
    LLVM.or (LLVM.and e (const? 37 255))
      (shl (LLVM.and e (const? 37 255)) (const? 37 8) { «nsw» := true, «nuw» := true }) { «disjoint» := true }

theorem PR51351_thm.extracted_1._1 : ∀ (x : BitVec 64) (x_1 : BitVec 32),
  ¬(zeroExtend 64 x_1 ≥ ↑64 ∨ zeroExtend 64 x_1 ≥ ↑64 ∨ x_1 + BitVec.ofInt 32 (-33) ≥ ↑32) →
    x_1 + BitVec.ofInt 32 (-33) ≥ ↑32 → False

theorem e_632 :
    2 *  ~~~(x &&&  ~~~x) + 7 *  ~~~x + 2 * (x |||  ~~~y) + 2 * (x ||| y) - 7 * x + 2 *  ~~~(x &&&  ~~~y) - 15 *  ~~~(x ||| y) - 13 *  ~~~(x |||  ~~~y) - 1 * (x &&&  ~~~y) - 1 * (x &&& y) =  - 2 *  ~~~y

theorem sub_ule_sext_thm.extracted_1._1 : ∀ (x : BitVec 1) (x_1 x_2 : BitVec 8),
  ofBool (x_2 - x_1 ≤ᵤ signExtend 8 x) = ofBool (x_2 == x_1) ||

theorem xor_orn_commute1_thm.extracted_1._2 : ∀ (x x_1 : BitVec 8),
  ¬(x_1 = 0 ∨ x_1 = 0) → ¬x_1 = 0 → 42#8 / x_1 ^^^ (42#8 / x_1 ^^^ -1#8 ||| x) = 42#8 / x_1 &&& x ^^^ -1#8

theorem pr51551_proof : pr51551_before ⊑ pr51551_after

theorem ugt_swap_and_not_min_logical_thm (e e_1 : IntW 8) :
  select (icmp IntPred.ult e_1 e) (icmp IntPred.ne e (const? 8 0)) (const? 1 0) ⊑
    icmp IntPred.ult e_1 e

theorem and_ne_with_diff_one_signed_logical_thm (e : IntW 64) :
  select (icmp IntPred.ne e (const? 64 (-1))) (icmp IntPred.ne e (const? 64 0)) (const? 1 0) ⊑
    icmp IntPred.ult (add e (const? 64 (-1))) (const? 64 (-2))

theorem shl_add_and_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8), ¬(1#8 ≥ ↑8 ∨ 1#8 ≥ ↑8) → 1#8 ≥ ↑8 → False

theorem negate_shl_xor_proof : negate_shl_xor_before ⊑ negate_shl_xor_after

theorem n4_thm.extracted_1._1 : ∀ (x : BitVec 16),
  ¬16#32 ≥ ↑32 → True ∧ zeroExtend 32 x <<< 16#32 >>> 16#32 ≠ zeroExtend 32 x ∨ 16#32 ≥ ↑32 → False

theorem select_ashr_icmp_bad_thm.extracted_1._4 : ∀ (x x_1 x_2 : BitVec 32),
  ofBool (x_2 == 1#32) = 1#1 → ¬x_2 ≥ ↑32 → ¬1#32 ≥ ↑32 → x_1.sshiftRight' x_2 = x_1.sshiftRight' 1#32

theorem sub_to_xor_and_commuted_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  (x_1 &&& x) - (x ||| x_1) = 0#32 - (x_1 ^^^ x)

@[simp] theorem Com.toLets_castPureToEff {com : Com d Γ .pure ty} :
    (com.castPureToEff eff).toLets = cast (by simp) (com.toLets.castPureToEff eff)

theorem trunc_shl_1_i32_i64_thm.extracted_1._2 : ∀ (x : BitVec 64),
  ¬1#64 ≥ ↑64 → ¬1#32 ≥ ↑32 → truncate 32 (x <<< 1#64) = truncate 32 x <<< 1#32

@[simp]
theorem ofBitVecSextMsb_eq_concat_ofBitVec (x : BitVec w) :
    ofBitVecSextMsb x = (ofBitVecSext x).concat false

theorem thisdoesnotloop_proof : thisdoesnotloop_before ⊑ thisdoesnotloop_after

theorem main5c_like_logical_thm.extracted_1._7 : ∀ (x x_1 : BitVec 32),
  ofBool (x_1 &&& 7#32 != 7#32) = 1#1 → ¬ofBool (x_1 &&& 7#32 == 7#32) = 1#1 → True → 0#32 = zeroExtend 32 0#1

theorem t2_proof : t2_before ⊑ t2_after

theorem p1_thm.extracted_1._4 : ∀ (x x_1 x_2 : BitVec 8),
  ¬ofBool (x_2 &&& 1#8 != 0#8) = 1#1 → ¬ofBool (x_2 &&& 1#8 == 0#8) = 1#1 → x = x_1

theorem p0_scalar_urem_by_const_thm (e : IntW 32) :
  icmp IntPred.eq (urem (LLVM.and e (const? 32 128)) (const? 32 6)) (const? 32 0) ⊑
    icmp IntPred.eq (LLVM.and e (const? 32 128)) (const? 32 0)

theorem smear_set_bit_different_dest_type_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬7#8 ≥ ↑8 →
    24#32 ≥ ↑32 ∨
        31#32 ≥ ↑32 ∨
          True ∧ signExtend 32 (truncate 16 ((x <<< 24#32).sshiftRight' 31#32)) ≠ (x <<< 24#32).sshiftRight' 31#32 →
      False

theorem ashr_thm (e : IntW 32) :
  add (LLVM.xor (lshr e (const? 32 5)) (const? 32 67108864)) (const? 32 (-67108864)) ⊑ ashr e (const? 32 5)

theorem and_two_ranges_to_mask_and_range_no_add_on_one_range_thm.extracted_1._1 : ∀ (x : BitVec 16),
  ofBool (12#16 ≤ᵤ x) &&& (ofBool (x <ᵤ 16#16) ||| ofBool (28#16 ≤ᵤ x)) =
    ofBool (11#16 <ᵤ x &&& BitVec.ofInt 16 (-20))

theorem shl_sub_i64_proof : shl_sub_i64_before ⊑ shl_sub_i64_after

theorem main13_proof : main13_before ⊑ main13_after

theorem main5_like_logical_thm.extracted_1._9 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (x_1 &&& 7#32 == 7#32) = 1#1 → ofBool (x_1 &&& 7#32 != 7#32) = 1#1 → 0#1 = 1#1 → 0#32 = zeroExtend 32 1#1

theorem ashrsgt_03_04_proof : ashrsgt_03_04_before ⊑ ashrsgt_03_04_after

theorem e_565 :
     - 11 *  ~~~(x &&& y) - 11 *  ~~~(x &&&  ~~~x) + 1 * x - 2 *  ~~~y - 6 * (x ||| y) + 4 *  ~~~(x ^^^ y) + 22 *  ~~~(x ||| y) + 31 * (x &&&  ~~~y) + 14 * (x &&& y) = 2 * (x |||  ~~~y) - 28 *  ~~~(x |||  ~~~y)

theorem e_919 :
     - 6 * (z ^^^ t) - 7 *  ~~~z + 5 * t + 7 *  ~~~(z ||| t) + 4 *  ~~~(z |||  ~~~t) + 2 * (z &&&  ~~~t) =  - 4 * (z ||| t) + 9 * (z &&& t)

theorem exactly_one_set_signbit_proof : exactly_one_set_signbit_before ⊑ exactly_one_set_signbit_after

theorem exact_ashr_ne_exactdiv_proof : exact_ashr_ne_exactdiv_before ⊑ exact_ashr_ne_exactdiv_after

theorem scalar_i64_shl_and_signbit_eq_thm (e e_1 : IntW 64) :
  icmp IntPred.eq (LLVM.and (shl e_1 e) (const? 64 (-9223372036854775808))) (const? 64 0) ⊑
    icmp IntPred.sgt (shl e_1 e) (const? 64 (-1))

theorem main7b_logical_thm.extracted_1._11 : ∀ (x x_1 x_2 : BitVec 32),
  ¬ofBool (x_2 == x_1 &&& x_2) = 1#1 →
    ¬ofBool (x_2 != x_1 &&& x_2) = 1#1 → 0#1 = 1#1 → 0#32 = zeroExtend 32 (ofBool (x != x_1 &&& x))

theorem trunc_ashr_thm (e : IntW 32) :
  trunc 32 (ashr (LLVM.or (zext 36 e) (const? 36 (-2147483648))) (const? 36 8)) ⊑
    LLVM.or (lshr e (const? 32 8)) (const? 32 (-8388608))

theorem test_shl__all_are_safe_proof : test_shl__all_are_safe_before ⊑ test_shl__all_are_safe_after

theorem main3c_logical_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x &&& 7#32 != 0#32) = 1#1 → True → 0#32 = zeroExtend 32 (ofBool (x &&& 55#32 == 0#32))

theorem PR38781_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬(31#32 ≥ ↑32 ∨ 31#32 ≥ ↑32) →
    (x_1 >>> 31#32 ^^^ 1#32) &&& (x >>> 31#32 ^^^ 1#32) = zeroExtend 32 (ofBool (-1#32 <ₛ x_1 ||| x))

theorem test10_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  x_1 ^^^ x ||

theorem e_1850 :
    11 * (b ^^^  ~~~( ~~~a &&& ( ~~~b ||| c))) + 1 * (b ^^^ (a ||| ( ~~~b &&& c))) - 1 * ((a &&&  ~~~b) |||  ~~~(b ^^^ c)) + 11 * ( ~~~a &&& (b ||| c)) + 5 * ((a &&& b) |||  ~~~(b ^^^ c)) + 7 * (b ^^^ ( ~~~a ||| ( ~~~b ||| c))) + 1 * ( ~~~a ||| ( ~~~b ||| c)) - 11 * ((a ||| b) &&& (b ^^^ c)) + 5 * ((a &&& b) ^^^ (b ||| c)) + 5 * ( ~~~b &&& (a ^^^ c)) + 1 *  ~~~(a |||  ~~~c) + 2 * (a ||| (b &&& c)) - 2 *  ~~~(a ||| ( ~~~b &&& c)) - 6 * (b ^^^  ~~~(a ||| c)) + 4 * ((a ^^^ b) |||  ~~~(a ^^^ c)) - 5 * (c ^^^  ~~~(a &&& (b ||| c))) - 6 * (b &&&  ~~~c) - 6 *  ~~~(a &&& ( ~~~b &&& c)) - 2 *  ~~~(a |||  ~~~b) + 5 * ( ~~~(a &&& b) &&&  ~~~(a ^^^ (b ^^^ c))) - 7 * (b ^^^  ~~~( ~~~a &&& (b ^^^ c))) - 3 * (b ^^^  ~~~(a ||| (b ^^^ c))) - 11 * ((a ^^^ b) ||| (a ^^^ c)) - 1 *  ~~~( ~~~a &&& (b ||| c)) - 1 * ( ~~~(a &&&  ~~~b) &&&  ~~~(a ^^^ (b ^^^ c))) + 3 *  ~~~( ~~~a ||| (b ^^^ c)) + 4 * (c ^^^  ~~~( ~~~a &&& (b &&& c))) + 2 * ((a &&& c) ^^^ (a ^^^ (b &&& c))) - 1 * (b ^^^ (a ||| c)) - 7 *  ~~~(a ^^^ ( ~~~b &&& c)) - 1 * (c ||| (a &&&  ~~~b)) + 1 * (b ||| c) - 2 * (a &&&  ~~~c) + 11 * ((a &&& b) |||  ~~~(a ^^^ (b ^^^ c))) - 5 *  ~~~c - 7 * (a ^^^ b) + 4 * (b ||| (a &&&  ~~~c)) - 5 * ((a &&& b) |||  ~~~(b |||  ~~~c)) - 2 * (a ^^^ c) + 7 *  ~~~(a ||| (b ||| c)) + 22 *  ~~~( ~~~a ||| ( ~~~b ||| c)) - 7 * ( ~~~a &&& ( ~~~b &&& c)) - 23 * ( ~~~a &&& (b &&& c)) + 9 * (a &&& ( ~~~b &&& c)) - 6 * (a &&& (b &&& c)) =  - 42 *  ~~~(a ||| ( ~~~b ||| c)) - 1 * (b ^^^ ( ~~~a &&& (b ^^^ c)))

theorem select_icmp_eq_and_32_0_xor_8_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ofBool (x_1 &&& 32#32 == 0#32) = 1#1 → 2#32 ≥ ↑32 → False

theorem and_shl_thm.extracted_1._1 : ∀ (x x_1 x_2 x_3 : BitVec 8), ¬(x_2 ≥ ↑8 ∨ x_2 ≥ ↑8) → x_2 ≥ ↑8 → False

theorem t2_ult_sgt_128_thm (e e_1 e_2 : IntW 32) :
  select (icmp IntPred.ult (add e_2 (const? 32 16)) (const? 32 144)) e_2
      (select (icmp IntPred.sgt e_2 (const? 32 127)) e_1 e) ⊑
    select (icmp IntPred.sgt e_2 (const? 32 127)) e_1
      (select (icmp IntPred.slt e_2 (const? 32 (-16))) e e_2)

theorem ashrslt_02_05_thm.extracted_1._1 : ∀ (x : BitVec 4), ¬2#4 ≥ ↑4 → ofBool (x.sshiftRight' 2#4 <ₛ 5#4) = 1#1

theorem and1_shl1_is_cmp_eq_0_multiuse_proof : and1_shl1_is_cmp_eq_0_multiuse_before ⊑ and1_shl1_is_cmp_eq_0_multiuse_after

theorem sub_from_constant_proof : sub_from_constant_before ⊑ sub_from_constant_after

theorem Tensor2d'.transpose_transpose (t : Tensor2d' α) : t.transpose.transpose = t

theorem lshrult_01_09_proof : lshrult_01_09_before ⊑ lshrult_01_09_after

theorem zext_false_val_must_be_zero_thm.extracted_1._1 : ∀ (x : BitVec 1), ¬x = 1#1 → zeroExtend 32 x = 0#32

theorem trunc_equality_both_sext_thm.extracted_1._1 : ∀ (x : BitVec 8) (x_1 : BitVec 32),
  ¬(True ∧ signExtend 32 (truncate 16 x_1) ≠ x_1 ∨ True ∧ zeroExtend 32 (truncate 16 x_1) ≠ x_1) →
    ofBool (truncate 16 x_1 != signExtend 16 x) = ofBool (x_1 != signExtend 32 x)

theorem icmp_eq_sext_ne_allones_proof : icmp_eq_sext_ne_allones_before ⊑ icmp_eq_sext_ne_allones_after

theorem AvoidCollision_setWidth_ofNat_one_eq_ofNat_one_of_lt {v w : Nat} (hv : 0 < v) :
    (BitVec.ofNat v 1).setWidth w = BitVec.ofNat w 1

theorem uge_or_max_logical_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ofBool (x ≤ᵤ x_1) = 1#1 → 1#1 = ofBool (x ≤ᵤ x_1)

theorem test2_proof : test2_before ⊑ test2_after

theorem icmp_ne_sext_eq_allones_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (signExtend 32 (ofBool (x == -1#32)) != x) = ofBool (x + -1#32 <ᵤ BitVec.ofInt 32 (-2))

theorem test19_proof : test19_before ⊑ test19_after

theorem logic_and_logic_or_4_proof : logic_and_logic_or_4_before ⊑ logic_and_logic_or_4_after

theorem test_shl__nsw_is_safe_proof : test_shl__nsw_is_safe_before ⊑ test_shl__nsw_is_safe_after

theorem no_masks_with_logical_or2_thm.extracted_1._5 : ∀ (x x_1 x_2 : BitVec 32),
  ¬ofBool (x_2 != -1#32) = 1#1 →
    ofBool (x_2 &&& x != -1#32) = 1#1 → ofBool (x_1 != 63#32) ||

theorem xor_logic_and_or1_proof : xor_logic_and_or1_before ⊑ xor_logic_and_or1_after

theorem positive_biggershl_ashrexact_proof : positive_biggershl_ashrexact_before ⊑ positive_biggershl_ashrexact_after

theorem src_x_and_nmask_ne_thm.extracted_1._1 : ∀ (x : BitVec 1) (x_1 : BitVec 8),
  ¬x = 1#1 → ofBool (x_1 &&& 0#8 != 0#8) = 0#1

theorem e_1076 :
     - 6 * t + 2 * (z ||| t) - 6 *  ~~~(z &&&  ~~~t) - 1 *  ~~~(z ||| t) + 10 *  ~~~(z |||  ~~~t) - 9 * (z &&&  ~~~t) + 3 * (z &&& t) =  - 7 * (z |||  ~~~t)

theorem or_not_and_and_not_and_xor_commute4_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 32),
  ¬((x_2 == 0 || 32 != 1 && 42#32 == intMin 32 && x_2 == -1) = true ∨
        (x_2 == 0 || 32 != 1 && 42#32 == intMin 32 && x_2 == -1) = true) →
    ((42#32).sdiv x_2 ||| x_1 &&& x ^^^ -1#32) &&& ((42#32).sdiv x_2 &&& (x_1 ^^^ x) ^^^ -1#32) =
      (42#32).sdiv x_2 &&& (x_1 ^^^ x) ^^^ ((42#32).sdiv x_2 ||| x_1 &&& x ^^^ -1#32)

theorem e_757 :
    3 *  ~~~(z &&&  ~~~t) - 1 *  ~~~(z &&&  ~~~z) - 2 * (z ||| t) + 3 * (z &&&  ~~~t) = 2 *  ~~~(z ||| t)

theorem gt_unsigned_to_small_signed_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ofBool (17#32 <ₛ zeroExtend 32 x) = ofBool (17#8 <ᵤ x)

theorem n5_thm (e e_1 e_2 : IntW 8) :
  select (icmp IntPred.eq (LLVM.and e_2 (const? 8 1)) (const? 8 2)) e_1 e ⊑ e

theorem positive_sameconst_shlnsw_proof : positive_sameconst_shlnsw_before ⊑ positive_sameconst_shlnsw_after

theorem e_604 :
     - 1 *  ~~~y - 1 * y + 3 * (x ^^^ y) - 7 *  ~~~(x &&& y) - 2 * x - 1 *  ~~~(x ^^^ y) + 1 * (x ||| y) - 1 * (x |||  ~~~y) + 6 *  ~~~(x ||| y) + 3 * (x &&&  ~~~y) =  - 4 *  ~~~(x &&&  ~~~x)

theorem exact_lshr_ne_opposite_msb_thm (e : IntW 8) :
  icmp IntPred.ne (lshr (const? 8 (-128)) e { «exact» := true }) (const? 8 1) ⊑
    icmp IntPred.ne e (const? 8 7)

theorem zext_or_masked_bit_test_proof : zext_or_masked_bit_test_before ⊑ zext_or_masked_bit_test_after

theorem ashr_ugt_14_proof : ashr_ugt_14_before ⊑ ashr_ugt_14_after

theorem or_xor_commute1_thm (e e_1 : IntW 32) :
  LLVM.xor (LLVM.udiv (const? 32 42) e_1) (LLVM.or (LLVM.udiv (const? 32 42) e_1) (LLVM.udiv (const? 32 42) e)) ⊑
    LLVM.and (LLVM.udiv (const? 32 42) e) (LLVM.xor (LLVM.udiv (const? 32 42) e_1) (const? 32 (-1)))

theorem or_xor_common_op_commute6_thm (e e_1 e_2 : IntW 8) :
  LLVM.or (LLVM.xor e_2 e_1) (LLVM.or e_1 e) ⊑ LLVM.or (LLVM.or e_1 e) e_2

theorem icmp_select_var_select_proof : icmp_select_var_select_before ⊑ icmp_select_var_select_after

theorem shl_bad_sub_i8_thm (e : IntW 8) :
  shl (const? 8 1) (sub (const? 8 4) e) ⊑
    shl (const? 8 1) (sub (const? 8 4) e) { «nsw» := false, «nuw» := true }

theorem e_1390 :
     - 6 *  ~~~(z ^^^ t) + 5 * t + 2 *  ~~~z - 11 *  ~~~(z &&&  ~~~z) + 11 * (z ||| t) - 6 * (z ^^^ t) - 7 * (z |||  ~~~t) - 1 *  ~~~(z |||  ~~~t) + 18 * (z &&&  ~~~t) + 13 * (z &&& t) = 5 * z - 22 *  ~~~(z ||| t)

theorem lshrugt_03_06_proof : lshrugt_03_06_before ⊑ lshrugt_03_06_after

theorem different_size_zext_zext_ugt_proof : different_size_zext_zext_ugt_before ⊑ different_size_zext_zext_ugt_after

theorem e_2452 :
    7 * (d ^^^ ( ~~~e &&& f)) - 7 *  ~~~f + 2 * (d ||| (e ||| f)) + 1 * (d ||| (e ^^^ f)) - 1 * (f ||| (d &&& e)) + 2 * (f ^^^ (d |||  ~~~e)) - 3 * (f ^^^  ~~~(d ||| ( ~~~e &&& f))) - 1 * (d ^^^ (e &&& f)) + 3 * (e |||  ~~~(d ||| f)) + 4 * (e &&& f) + 3 * (f &&& (d ||| e)) - 1 * (e ^^^  ~~~(d &&& f)) + 5 * (e ^^^  ~~~( ~~~d ||| (e ^^^ f))) - 11 * ( ~~~(d &&&  ~~~e) &&& (e ^^^ f)) + 1 * (e &&& (d ^^^ f)) + 3 * ((d &&& e) ^^^ (d ^^^ (e &&& f))) - 11 * ((e &&&  ~~~f) |||  ~~~(d ||| ( ~~~e &&& f))) + 11 * ( ~~~(d &&&  ~~~e) &&&  ~~~(d ^^^ (e ^^^ f))) + 1 * (e ^^^ (d &&& (e ||| f))) - 7 * ( ~~~d &&& (e ^^^ f)) - 2 * ((d &&& f) ^^^ (e ||| f)) + 11 * (e ^^^  ~~~( ~~~d &&& ( ~~~e ||| f))) + 1 *  ~~~(d ^^^ e) - 5 * ( ~~~e ||| (d ^^^ f)) - 2 * (f ^^^ ( ~~~d &&& ( ~~~e ||| f))) + 1 * (e |||  ~~~(d |||  ~~~f)) - 1 *  ~~~(d &&&  ~~~d) - 2 * ((e &&&  ~~~f) |||  ~~~( ~~~d ||| ( ~~~e &&& f))) - 1 *  ~~~(d &&& (e ||| f)) - 2 *  ~~~(d ||| (e &&& f)) + 4 * ((d &&&  ~~~e) ||| (d ^^^ (e ^^^ f))) + 1 * ( ~~~(d ||| e) ||| (e ^^^ f)) - 5 * f - 6 *  ~~~( ~~~d ||| ( ~~~e &&& f)) - 11 * (d &&&  ~~~e) + 2 * (f ^^^  ~~~( ~~~d &&& ( ~~~e &&& f))) + 1 *  ~~~(e ^^^ f) - 1 *  ~~~(e &&& f) - 3 * (e ^^^  ~~~(d ||| (e ^^^ f))) - 2 *  ~~~(d ||| (e ^^^ f)) - 11 * (f |||  ~~~(d |||  ~~~e)) + 11 * (f ||| (d ^^^ e)) + 1 *  ~~~(d &&&  ~~~e) + 2 *  ~~~(d &&& ( ~~~e &&& f)) - 5 * (d ||| e) - 1 * (f ^^^  ~~~( ~~~d ||| ( ~~~e &&& f))) + 5 * (f ^^^  ~~~(d &&&  ~~~e)) - 3 * ((d &&& e) ||| (d ^^^ (e ^^^ f))) - 11 * ((d &&& f) ^^^ (d ^^^ ( ~~~e &&& f))) - 2 * (f ^^^ (d ||| ( ~~~e &&& f))) - 6 * (e &&&  ~~~(d &&& f)) + 1 * (e &&& (d |||  ~~~f)) - 1 *  ~~~(d &&& e) + 1 *  ~~~(d ^^^ f) + 4 * ((d &&& e) ^^^  ~~~(d ^^^ ( ~~~e ||| f))) + 2 * ((d ||| e) &&& (e ^^^ f)) + 7 * ( ~~~(d &&&  ~~~e) &&&  ~~~(e ^^^ f)) + 7 *  ~~~( ~~~d &&& ( ~~~e &&& f)) - 3 * (f ^^^  ~~~( ~~~d &&& ( ~~~e ||| f))) + 5 * (e &&&  ~~~(d &&&  ~~~f)) + 5 * (f ^^^ (d &&& (e ||| f))) + 4 * ( ~~~(d ||| e) |||  ~~~(e ^^^ f)) + 7 *  ~~~(d &&&  ~~~f) - 6 * (f ^^^ (d ||| e)) - 1 * (e ^^^  ~~~( ~~~d &&& (e ||| f))) - 1 * ( ~~~(d |||  ~~~e) ||| (d ^^^ (e ^^^ f))) + 2 * (d ^^^ ( ~~~e ||| f)) - 1 * (e ^^^  ~~~(d &&& (e ^^^ f))) + 4 * (e ^^^ (d ||| f)) - 15 *  ~~~(d ||| (e ||| f)) + 7 *  ~~~(d ||| ( ~~~e ||| f)) + 1 *  ~~~( ~~~d ||| (e ||| f)) + 23 *  ~~~( ~~~d ||| ( ~~~e ||| f)) + 12 * ( ~~~d &&& ( ~~~e &&& f)) - 39 * ( ~~~d &&& (e &&& f)) - 18 * (d &&& ( ~~~e &&& f)) - 32 * (d &&& (e &&& f)) =  - 11 * ( ~~~(d &&& e) &&& (e ^^^ f))

theorem main2_logical_thm.extracted_1._3 : ∀ (x : BitVec 32),
  ¬ofBool (x &&& 1#32 == 0#32) = 1#1 →
    ofBool (x &&& 2#32 == 0#32) = 1#1 → 0#32 = zeroExtend 32 (ofBool (x &&& 3#32 == 3#32))

theorem p0_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ¬x_1 ≥ ↑8 → ofBool (((-1#8) <<< x_1 ^^^ -1#8) &&& x != x) = ofBool (x >>> x_1 != 0#8)

theorem and_nosignbit_select_shl_thm.extracted_1._1 : ∀ (x : BitVec 32) (x_1 : BitVec 1),
  x_1 = 1#1 → ¬8#32 ≥ ↑32 → (x &&& 2147418112#32) <<< 8#32 = x <<< 8#32 &&& BitVec.ofInt 32 (-16777216)

theorem sle_and_min_logical_proof : sle_and_min_logical_before ⊑ sle_and_min_logical_after

theorem sub_1_thm.extracted_1._2 : ∀ (x x_1 : BitVec 8) (x_2 : BitVec 1),
  ¬x_2 = 1#1 → (x_1 ^^^ 123#8) - x ^^^ -1#8 = (x_1 ^^^ BitVec.ofInt 8 (-124)) + x

theorem both_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ¬(x_1 ≥ ↑8 ∨ x ≥ ↑8) → True ∧ 1#8 <<< x >>> x ≠ 1#8 ∨ x ≥ ↑8 ∨ x_1 ≥ ↑8 → False

theorem PR28476_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  zeroExtend 32 (ofBool (x_1 != 0#32) &&& ofBool (x != 0#32)) ^^^ 1#32 =
    zeroExtend 32 (ofBool (x_1 == 0#32) ||| ofBool (x == 0#32))

theorem basic_preserve_nuw_nsw_thm (e e_1 : IntW 8) :
  LLVM.xor (add (LLVM.xor e_1 (const? 8 (-1))) e { «nsw» := true, «nuw» := true }) (const? 8 (-1)) ⊑
    sub e_1 e { «nsw» := true, «nuw» := true }

theorem logic_or_logic_and_7_thm.extracted_1._8 : ∀ (x x_1 x_2 : BitVec 1),
  ¬x_2 = 1#1 → ¬x = 1#1 → ¬x_1 = 1#1 → ¬0#1 = 1#1 → 0#1 = x_1

theorem src3_thm (e e_1 : IntW 32) :
  add (LLVM.and e_1 e) (LLVM.and (LLVM.xor e (const? 32 (-1))) (LLVM.xor e_1 (const? 32 (-1)))) ⊑
    LLVM.xor (LLVM.xor e_1 e) (const? 32 (-1))

theorem e_304 :
    2 *  ~~~x + 2 * x - 2 *  ~~~(x ^^^ y) + 2 * (x ^^^ y) - 15 *  ~~~(x |||  ~~~y) - 15 * (x &&&  ~~~y) - 11 * (x &&& y) =  - 11 * (x ||| y)

theorem bools_multi_uses2_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 1),
  x_2 = 1#1 → ((x_2 ^^^ 1#1) &&& x_1 ||| x_2 &&& x) &&& ((x_2 ^^^ 1#1) &&& x_1) + (x_2 &&& x) = x

theorem bools2_logical_commute1_and1_proof : bools2_logical_commute1_and1_before ⊑ bools2_logical_commute1_and1_after

theorem basic_com_add_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8), x_1 + (x ^^^ -1#8) ^^^ -1#8 = x - x_1

@[simp, grind=] theorem castCtxt_castCtxt (h₁ : Γ = Δ) (h₂ : Δ = Ξ) :
    (v.castCtxt h₁).castCtxt h₂ = v.castCtxt (by simp [*])

theorem shift_xor_multiuse_cmp_with_xor_thm (e e_1 e_2 e_3 : IntW 32) :
  mul (select (icmp IntPred.ne (const? 32 0) (LLVM.and e_3 (const? 32 4096))) e_2 (LLVM.xor e_2 (const? 32 2048)))
      (select (icmp IntPred.ne (const? 32 0) (LLVM.and e_3 (const? 32 4096))) e_1 e) ⊑
    mul
      (select (icmp IntPred.eq (LLVM.and e_3 (const? 32 4096)) (const? 32 0)) (LLVM.xor e_2 (const? 32 2048)) e_2)
      (select (icmp IntPred.eq (LLVM.and e_3 (const? 32 4096)) (const? 32 0)) e e_1)

theorem test8_thm.extracted_1._1 : ∀ (x : BitVec 27), 3#27 ≥ ↑27 → False

theorem and_and_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x &&& 2#32 == 0#32) = 1#1 → x &&& 1#32 = zeroExtend 32 (ofBool (x &&& 3#32 != 0#32))

theorem test_shl_nuw_nsw__none_are_safe_thm (e : IntW 64) (e_1 : IntW 32) :
  select (icmp IntPred.eq (LLVM.and e_1 (const? 32 (-2))) (const? 32 0)) e
      (ashr e (zext 64 (shl (LLVM.and e_1 (const? 32 (-2))) (const? 32 2) { «nsw» := true, «nuw» := true }))) ⊑
    ashr e (zext 64 (LLVM.and (shl e_1 (const? 32 2)) (const? 32 (-8))) { «nneg» := true })

theorem test11d_proof : test11d_before ⊑ test11d_after

theorem lshrugt_02_08_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬2#4 ≥ ↑4 → ofBool (BitVec.ofInt 4 (-8) <ᵤ x >>> 2#4) = 0#1

theorem test_sub_nuw__all_are_safe_proof : test_sub_nuw__all_are_safe_before ⊑ test_sub_nuw__all_are_safe_after

theorem lowmask_mul_zext_thm.extracted_1._1 : ∀ (x : BitVec 32) (x_1 : BitVec 8),
  zeroExtend 32 x_1 * x &&& 255#32 = zeroExtend 32 (x_1 * truncate 8 x)

theorem or_simplify_ult_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ofBool (x_1 &&& BitVec.ofInt 8 (-5) <ᵤ x ||| 36#8 ||| x_1 &&& BitVec.ofInt 8 (-5)) =
    ofBool (x_1 &&& BitVec.ofInt 8 (-5) <ᵤ x ||| x_1 ||| 36#8)

theorem slt_zero_eq_ne_0_thm (e : IntW 32) :
  icmp IntPred.eq (zext 32 (icmp IntPred.ne e (const? 32 0))) (lshr e (const? 32 31)) ⊑
    icmp IntPred.slt e (const? 32 1)

theorem e_595 :
     - 1 * (x ^^^ y) - 2 * (x ||| y) - 2 * (x |||  ~~~y) + 4 * y + 3 * x + 1 *  ~~~(x &&&  ~~~y) + 11 *  ~~~(x ^^^ y) - 8 *  ~~~(x ||| y) + 1 * (x &&&  ~~~y) - 15 * (x &&& y) =  - 1 *  ~~~(x &&& y) + 3 *  ~~~x

theorem sle_smax4_proof : sle_smax4_before ⊑ sle_smax4_after

theorem ashr_x_by_const_cmp_sge_x_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬5#32 ≥ ↑32 → ofBool (x ≤ₛ x.sshiftRight' 5#32) = ofBool (x <ₛ 1#32)

theorem t_0_10_thm.extracted_1._1 : ∀ (x : BitVec 8), ¬ofBool (0#8 <ᵤ x) = 1#1 → 0#8 &&& 10#8 = x &&& 10#8

theorem scalar_i8_shl_ugt_const_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬5#8 ≥ ↑8 → ofBool (63#8 <ᵤ x <<< 5#8) = ofBool (x &&& 6#8 != 0#8)

theorem t0_thm (e : IntW 8) : sext 16 (trunc 4 (lshr e (const? 8 4))) ⊑ sext 16 (ashr e (const? 8 4))

theorem shl_nsw_add_nuw_proof : shl_nsw_add_nuw_before ⊑ shl_nsw_add_nuw_after

theorem basic_preserve_nsw_proof : basic_preserve_nsw_before ⊑ basic_preserve_nsw_after

theorem lshrult_02_12_exact_proof : lshrult_02_12_exact_before ⊑ lshrult_02_12_exact_after

theorem poison_ne_value (a : α) :
    @Ne (no_index _) poison (value a)

theorem slt_swap_or_not_max_commute_proof : slt_swap_or_not_max_commute_before ⊑ slt_swap_or_not_max_commute_after

theorem logic_or_logic_and_7_thm.extracted_1._2 : ∀ (x x_1 : BitVec 1), ¬x_1 = 1#1 → ¬x = 1#1 → ¬0#1 = 1#1 → 0#1 = x

theorem add_or_sub_comb_i8_commuted2_nsw_thm.extracted_1._2 : ∀ (x : BitVec 8),
  ¬(True ∧ (x * x).saddOverflow (0#8 - x * x ||| x * x) = true) →
    ¬(True ∧ (x * x).saddOverflow (-1#8) = true) → x * x + (0#8 - x * x ||| x * x) = x * x + -1#8 &&& x * x

theorem t1_sub_of_falseval_thm (e e_1 : IntW 8) (e_2 : IntW 1) :
  sub (select e_2 e_1 e) e ⊑ select e_2 (sub e_1 e) (const? 8 0)

theorem eq_of_ofBitVec_eq (x y : BitVec w) :
    ofBitVecSext x ={≤w} ofBitVecSext y → x = y

theorem ult_umin3_proof : ult_umin3_before ⊑ ult_umin3_after

theorem lshrugt_02_03_exact_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬(True ∧ x >>> 2#4 <<< 2#4 ≠ x ∨ 2#4 ≥ ↑4) → ofBool (3#4 <ᵤ x >>> 2#4) = 0#1

theorem t3_proof : t3_before ⊑ t3_after

theorem e_2192 :
    11 *  ~~~(e ^^^ f) - 1 *  ~~~(e |||  ~~~f) + 4 * ((d &&& e) ^^^  ~~~(d ^^^ (e &&& f))) - 1 * ((e &&& f) ^^^  ~~~(d &&& (e ^^^ f))) + 1 *  ~~~( ~~~d ||| (e ^^^ f)) - 1 * (e ^^^  ~~~(d |||  ~~~f)) + 1 * (f ^^^ (d ||| ( ~~~e ||| f))) - 6 *  ~~~(d &&&  ~~~f) - 3 *  ~~~(d ^^^ e) - 3 * ( ~~~d ||| (e &&& f)) - 11 * (e ^^^  ~~~(d ||| f)) - 2 * (f |||  ~~~(d ||| e)) + 2 * (e ^^^ ( ~~~d &&& (e ^^^ f))) + 3 * (f ^^^  ~~~( ~~~d ||| ( ~~~e &&& f))) + 2 * (e ^^^  ~~~( ~~~d ||| (e &&& f))) - 2 * f + 11 * ((d &&& e) |||  ~~~(e |||  ~~~f)) - 11 * (f ^^^ (d ||| (e &&& f))) + 2 * ((e &&& f) ^^^  ~~~( ~~~d &&& (e ^^^ f))) + 7 * (d &&& (e ||| f)) - 2 * (f ^^^ (d &&& ( ~~~e ||| f))) + 3 *  ~~~(d ^^^ (e ^^^ f)) - 2 * (d ||| (e ||| f)) + 2 * (f ^^^  ~~~(d ||| (e &&& f))) - 3 * (f ^^^ (d &&& e)) - 1 * (e &&& f) - 5 * (d ^^^ (e &&& f)) + 4 * e + 1 * ((e &&&  ~~~f) ^^^ (d ||| (e ^^^ f))) + 4 * (f ^^^  ~~~( ~~~d &&& ( ~~~e ||| f))) + 1 *  ~~~(d &&&  ~~~e) - 1 * ((d &&&  ~~~e) ||| (e ^^^ f)) + 1 * ((d ^^^ e) |||  ~~~(d ^^^ f)) - 11 * ((d &&& e) |||  ~~~(d ^^^ (e ^^^ f))) - 11 * ((e &&& f) ||| (d &&& (e ||| f))) + 2 * (e ^^^ ( ~~~d ||| ( ~~~e &&& f))) + 5 * ( ~~~e ||| (d ^^^ f)) + 2 * (e ||| (d ^^^ f)) - 7 * (e ^^^  ~~~( ~~~d &&& (e ^^^ f))) - 5 * (d ||| ( ~~~e ||| f)) - 2 * ((d &&&  ~~~e) |||  ~~~(e ^^^ f)) - 11 *  ~~~(e ||| f) + 3 * (e ^^^ (d ||| ( ~~~e ||| f))) + 30 *  ~~~(d ||| (e ||| f)) - 3 *  ~~~(d ||| ( ~~~e ||| f)) + 14 *  ~~~( ~~~d ||| (e ||| f)) + 12 *  ~~~( ~~~d ||| ( ~~~e ||| f)) + 1 * ( ~~~d &&& ( ~~~e &&& f)) + 29 * ( ~~~d &&& (e &&& f)) + 12 * (d &&& ( ~~~e &&& f)) + 9 * (d &&& (e &&& f)) = 3 * (f ^^^  ~~~( ~~~d &&& (e &&& f))) - 4 * ((d &&& e) ||| (e ^^^ f))

theorem ashr_16_to_64_add_zext_basic_thm.extracted_1._1 : ∀ (x x_1 : BitVec 16),
  ¬16#64 ≥ ↑64 →
    (zeroExtend 64 x_1 + zeroExtend 64 x).sshiftRight' 16#64 = zeroExtend 64 (ofBool (x_1 ^^^ -1#16 <ᵤ x))

theorem e_1485 :
     - 2 *  ~~~(z &&&  ~~~t) + 2 *  ~~~(z &&& t) + 5 * z + 1 * (z |||  ~~~t) - 2 *  ~~~z + 3 *  ~~~(z ^^^ t) + 1 * (z ^^^ t) - 3 *  ~~~(z &&&  ~~~z) + 1 *  ~~~(z ||| t) + 12 *  ~~~(z |||  ~~~t) + 4 * (z &&& t) = 2 * t + 6 * (z ||| t)

@[simp]
theorem HTermEnv.of_mkFsmEnvOfTenv {wcard tcard bcard ncard icard pcard : Nat}
    {wenv : Fin wcard → Nat} {tctx : Term.Ctx wcard tcard}
    (tenv : tctx.Env wenv)
    (benv : Term.BoolEnv bcard)
    (nenv : Term.NatEnv ncard)
    (ienv : Term.IntEnv icard)
    (penv : Predicate.Env pcard) :
    HTermEnv (mkFsmEnvOfTenv tenv benv nenv ienv penv) tenv benv

theorem twoway_clamp_lt_thm (e : IntW 32) :
  select
      (icmp IntPred.sgt (select (icmp IntPred.slt e (const? 32 13768)) e (const? 32 13768)) (const? 32 13767))
      (select (icmp IntPred.slt e (const? 32 13768)) e (const? 32 13768)) (const? 32 13767) ⊑
    select (icmp IntPred.sgt e (const? 32 13767)) (const? 32 13768) (const? 32 13767)

theorem not_mul_of_bool_thm.extracted_1._1 : ∀ (x : BitVec 8) (x_1 : BitVec 32),
  True ∧ (x_1 &&& 3#32).smulOverflow (zeroExtend 32 x) = true ∨
      True ∧ (x_1 &&& 3#32).umulOverflow (zeroExtend 32 x) = true →
    False

theorem t0_proof : t0_before ⊑ t0_after

theorem shl_xor_xor_no_const_proof : shl_xor_xor_no_const_before ⊑ shl_xor_xor_no_const_after

theorem t6_ugt_sgt_65536_thm.extracted_1._4 : ∀ (x x_1 : BitVec 32),
  ofBool (65535#32 <ᵤ x_1) = 1#1 → ¬ofBool (65535#32 <ₛ x_1) = 1#1 → ¬ofBool (x_1 <ₛ 0#32) = 1#1 → x = x_1

theorem and_or3_commuted_thm (e e_1 : IntW 1) (e_2 e_3 : IntW 32) :
  select (LLVM.and (icmp IntPred.eq e_3 e_2) e_1) e e_1 ⊑
    select e_1 (select (icmp IntPred.ne e_3 e_2) (const? 1 1) e) (const? 1 0)

theorem slt_swap_and_not_max_commute_proof : slt_swap_and_not_max_commute_before ⊑ slt_swap_and_not_max_commute_after

theorem and_xor_or3_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 64),
  ¬(x_2 = 0 ∨ x_1 = 0 ∨ x = 0 ∨ x = 0) → x_2 = 0 ∨ x = 0 → False

theorem lshrult_03_09_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬3#4 ≥ ↑4 → ofBool (x >>> 3#4 <ᵤ BitVec.ofInt 4 (-7)) = 1#1

theorem bv_InstCombineShift__239 :
    ∀ (e e_1 : LLVM.IntW w), LLVM.lshr (LLVM.shl e e_1) e_1 ⊑ LLVM.and e (LLVM.lshr (LLVM.const? w (-1)) e_1)

lemma CNFA.proj_bv_language {m : CNFA n2} {f : Fin n1 → Fin n2} :
    m.bv_recognizes L → (m.proj f |>.bv_recognizes (BitVecs.transport f '' L))

theorem shl_trunc_bigger_lshr_thm (e : IntW 32) :
  shl (trunc 8 (lshr e (const? 32 5))) (const? 8 3) ⊑ LLVM.and (trunc 8 (lshr e (const? 32 2))) (const? 8 (-8))

theorem test30_thm (e : IntW 1) : LLVM.and (zext 32 e) (const? 32 1) ⊑ zext 32 e

theorem test18_proof : test18_before ⊑ test18_after

theorem test4c_proof : test4c_before ⊑ test4c_after

theorem test22_proof : test22_before ⊑ test22_after

theorem urem_i1_is_zero_proof : urem_i1_is_zero_before ⊑ urem_i1_is_zero_after

theorem main7d_logical_thm.extracted_1._10 : ∀ (x x_1 x_2 x_3 x_4 : BitVec 32),
  ofBool (x_4 &&& (x_3 &&& x_2) == x_3 &&& x_2) = 1#1 →
    ofBool (x_4 &&& (x_3 &&& x_2) != x_3 &&& x_2) = 1#1 →
      ¬ofBool (x_4 &&& (x_1 &&& x) == x_1 &&& x) = 1#1 → 1#32 = zeroExtend 32 1#1

theorem and_ashr_not_proof : and_ashr_not_before ⊑ and_ashr_not_after

theorem logical_or_not_thm.extracted_1._2 : ∀ (x x_1 : BitVec 1), x_1 = 1#1 → x_1 ^^^ 1#1 = 1#1 → x = 1#1

theorem t10_almost_highest_bit_thm.extracted_1._1 : ∀ (x : BitVec 64) (x_1 x_2 : BitVec 32),
  ¬(64#32 - x_1 ≥ ↑32 ∨ zeroExtend 64 (x_1 + BitVec.ofInt 32 (-2)) ≥ ↑64) →
    64#32 - x_1 ≥ ↑32 ∨
        True ∧ (x_1 + BitVec.ofInt 32 (-2)).msb = true ∨ zeroExtend 64 (x_1 + BitVec.ofInt 32 (-2)) ≥ ↑64 →
      False

theorem srem8_ashr_mask_proof : srem8_ashr_mask_before ⊑ srem8_ashr_mask_after

theorem test_zext1_thm.extracted_1._2 : ∀ (x x_1 : BitVec 1), ¬x_1 = 1#1 → 0#32 = zeroExtend 32 0#1

theorem test29_proof : test29_before ⊑ test29_after

theorem test_shr_and_1_ne_0_samesign_proof : test_shr_and_1_ne_0_samesign_before ⊑ test_shr_and_1_ne_0_samesign_after

theorem select_lshr_icmp_thm.extracted_1._2 : ∀ (x x_1 x_2 : BitVec 32),
  ofBool (x_2 == 0#32) = 1#1 → ¬x_2 ≥ ↑32 → x_1 >>> x_2 = x_1

theorem sext_false_val_must_be_zero_thm.extracted_1._1 : ∀ (x : BitVec 1), ¬x = 1#1 → signExtend 32 x = 0#32

theorem test_add_nuw_nsw__all_are_safe_proof : test_add_nuw_nsw__all_are_safe_before ⊑ test_add_nuw_nsw__all_are_safe_after

theorem neg_slt_0_proof : neg_slt_0_before ⊑ neg_slt_0_after

theorem mul_add_to_mul_3_thm.extracted_1._1 : ∀ (x : BitVec 16),
  ¬(True ∧ (x * 2#16).saddOverflow (x * 3#16) = true) → x * 2#16 + x * 3#16 = x * 5#16

theorem bv_select_1100 :
    ∀ (e e_1 : LLVM.IntW w), LLVM.select (LLVM.const? 1 1) e_1 e ⊑ e_1

theorem or_and2_commuted_thm (e e_1 e_2 : IntW 1) :
  select (LLVM.or e_2 (LLVM.xor e_1 (const? 1 1))) e_2 e ⊑ select e_2 (const? 1 1) (select e_1 e (const? 1 0))

theorem fake_sext_proof : fake_sext_before ⊑ fake_sext_after

theorem scalar_i32_signbit_lshr_and_eq_X_is_constant2_proof : scalar_i32_signbit_lshr_and_eq_X_is_constant2_before ⊑ scalar_i32_signbit_lshr_and_eq_X_is_constant2_after

theorem ashrsgt_01_13_exact_proof : ashrsgt_01_13_exact_before ⊑ ashrsgt_01_13_exact_after

theorem e_9 :
     - 2 * (x ^^^ y) + 11 * (x ||| y) + 5 * y - 9 * (x &&&  ~~~y) = 14 *  ~~~(x |||  ~~~y) + 16 * (x &&& y)

theorem ofBitVec_sub : ofBitVecSext (x - y) ≈ʷ (ofBitVecSext x) - (ofBitVecSext y)

theorem add_or_sub_comb_i8_commuted2_nsw_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬(True ∧ (x * x).saddOverflow (0#8 - x * x ||| x * x) = true) → True ∧ (x * x).saddOverflow (-1#8) = true → False

theorem is_ascii_alphabetic_inverted_thm (e : IntW 32) :
  select (icmp IntPred.ult (add e (const? 32 (-91)) { «nsw» := true, «nuw» := false }) (const? 32 (-26)))
      (icmp IntPred.ult (add e (const? 32 (-123)) { «nsw» := true, «nuw» := false }) (const? 32 (-26)))
      (const? 1 0) ⊑
    icmp IntPred.ult (add (LLVM.and e (const? 32 (-33))) (const? 32 (-91))) (const? 32 (-26))

@[simp] theorem bind_poison : a? >>= (fun _ => @poison β) = poison

theorem fold_inverted_icmp_preds_reverse_proof : fold_inverted_icmp_preds_reverse_before ⊑ fold_inverted_icmp_preds_reverse_after

theorem sub_to_xor_and_commuted_proof : sub_to_xor_and_commuted_before ⊑ sub_to_xor_and_commuted_after

theorem ashr_lshr_wrong_operands_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ofBool (0#32 ≤ₛ x_1) = 1#1 → ¬x ≥ ↑32 → ofBool (x_1 <ₛ 0#32) = 1#1 → x_1.sshiftRight' x = x_1 >>> x

theorem uge_umin1_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ofBool (x_1 <ᵤ x) = 1#1 → ofBool (x_1 ≤ᵤ x_1) = ofBool (x_1 ≤ᵤ x)

theorem different_size_zext_zext_sgt_thm.extracted_1._1 : ∀ (x : BitVec 4) (x_1 : BitVec 7),
  ofBool (zeroExtend 25 x <ₛ zeroExtend 25 x_1) = ofBool (zeroExtend 7 x <ᵤ x_1)

@[simp, simp_denote, simp_sllvm]
lemma run_map (x : EffectM α) :
    StateT.run (f <$> x : EffectM β) s = (fun p => (f p.1, p.2)) <$> StateT.run x s

@[simp] theorem map'_nil : map' f g nil = nil

theorem e_746 :
    11 * y - 1 *  ~~~(x ^^^ y) - 3 * (x ||| y) - 2 *  ~~~(x &&&  ~~~y) - 3 *  ~~~(x &&&  ~~~x) + 3 * (x ^^^ y) - 1 * (x |||  ~~~y) + 7 *  ~~~(x ||| y) - 6 *  ~~~(x |||  ~~~y) + 9 * (x &&&  ~~~y) + 4 * (x &&& y) = 5 * x

theorem icmp_ne_sext_ne_allones_proof : icmp_ne_sext_ne_allones_before ⊑ icmp_ne_sext_ne_allones_after

theorem uge_or_max_logical_thm.extracted_1._2 : ∀ (x x_1 : BitVec 8),
  ¬ofBool (x ≤ᵤ x_1) = 1#1 → ofBool (x_1 == -1#8) = ofBool (x ≤ᵤ x_1)

theorem select_icmp_ne_0_and_4096_xor_32_thm.extracted_1._3 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (0#32 != x_1 &&& 4096#32) = 1#1 → 7#32 ≥ ↑32 → False

theorem or_simplify_ule_fail_proof : or_simplify_ule_fail_before ⊑ or_simplify_ule_fail_after

theorem nonexact_ashr_ne_exactdiv_proof : nonexact_ashr_ne_exactdiv_before ⊑ nonexact_ashr_ne_exactdiv_after

theorem lshr_lshr_pow2_const_negative_nopow2_1_thm.extracted_1._1 : ∀ (x : BitVec 16),
  ¬(x ≥ ↑16 ∨ 6#16 ≥ ↑16) → x ≥ ↑16 → False

theorem ult_umin2_thm (e e_1 : IntW 32) :
  icmp IntPred.ult (select (icmp IntPred.ult e_1 e) e_1 e) e ⊑ icmp IntPred.ult e_1 e

theorem negtest_near_pow2_cmpval_isnt_close_to_pow2_proof : negtest_near_pow2_cmpval_isnt_close_to_pow2_before ⊑ negtest_near_pow2_cmpval_isnt_close_to_pow2_after

theorem fold_mask_cmps_to_false_logical_proof : fold_mask_cmps_to_false_logical_before ⊑ fold_mask_cmps_to_false_logical_after

theorem or_to_nxor4_thm (e e_1 : IntW 32) :
  LLVM.or (LLVM.xor (LLVM.or e_1 e) (const? 32 (-1))) (LLVM.and e e_1) ⊑
    LLVM.xor (LLVM.xor e e_1) (const? 32 (-1))

@[simp] theorem Expr.args_toPure     : (e.toPure h).args = e.args

theorem ashrslt_01_02_proof : ashrslt_01_02_before ⊑ ashrslt_01_02_after

theorem and_signbit_ashr_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬8#32 ≥ ↑32 → (x &&& BitVec.ofInt 32 (-65536)).sshiftRight' 8#32 = x.sshiftRight' 8#32 &&& BitVec.ofInt 32 (-256)

theorem ne_21_logical_proof : ne_21_logical_before ⊑ ne_21_logical_after

theorem icmp_eq_and_pow2_minus1_shl1_negative2_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬x ≥ ↑32 → zeroExtend 32 (ofBool (32#32 <<< x &&& 15#32 == 0#32)) = 1#32

theorem eq_smax1_proof : eq_smax1_before ⊑ eq_smax1_after

theorem canonicalize_logic_first_or0_nsw_thm (e : IntW 32) :
  LLVM.or (add e (const? 32 112) { «nsw» := true, «nuw» := false }) (const? 32 15) ⊑
    add (LLVM.or e (const? 32 15)) (const? 32 112) { «nsw» := true, «nuw» := false }

theorem test13_logical_proof : test13_logical_before ⊑ test13_logical_after

theorem test69_and_proof : test69_and_before ⊑ test69_and_after

theorem both_thm.extracted_1._2 : ∀ (x x_1 : BitVec 8),
  ¬(x_1 ≥ ↑8 ∨ x ≥ ↑8) →
    ¬(True ∧ ((-1#8) <<< x_1).sshiftRight' x_1 ≠ -1#8 ∨
          x_1 ≥ ↑8 ∨ True ∧ ((-1#8) <<< x).sshiftRight' x ≠ -1#8 ∨ x ≥ ↑8) →
      ofBool ((-1#8) <<< x ^^^ -1#8 ≤ᵤ (-1#8) <<< x_1 ^^^ -1#8) = ofBool ((-1#8) <<< x_1 ≤ᵤ (-1#8) <<< x)

theorem positive_biggerlshr_shlnsw_proof : positive_biggerlshr_shlnsw_before ⊑ positive_biggerlshr_shlnsw_after

theorem sle_smin3_thm.extracted_1._2 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (x_1 + 3#32 <ₛ x) = 1#1 → ofBool (x ≤ₛ x_1 + 3#32) = 1#1

theorem test15f_proof : test15f_before ⊑ test15f_after

theorem t14_and_with_const0_proof : t14_and_with_const0_before ⊑ t14_and_with_const0_after

theorem mul_may_overflow_thm (e e_1 : IntW 32) :
  zext 32 (icmp IntPred.ule (mul (zext 34 e_1) (zext 34 e)) (const? 34 4294967295)) ⊑
    zext 32 (icmp IntPred.ult (mul (zext 34 e_1) (zext 34 e)) (const? 34 4294967296))

theorem ule_umax1_proof : ule_umax1_before ⊑ ule_umax1_after

theorem select_1_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8) (x_2 : BitVec 1),
  x_2 = 1#1 → x_1 ^^^ (x ^^^ 45#8) ^^^ -1#8 = x ^^^ x_1 ^^^ BitVec.ofInt 8 (-46)

theorem neg_congr (e1 : a ≈ʷ b) : (-a) ≈ʷ -b

theorem test35_with_trunc_thm (e : IntW 64) :
  select (icmp IntPred.sge (trunc 32 e) (const? 32 0)) (const? 32 60) (const? 32 100) ⊑
    select (icmp IntPred.eq (LLVM.and e (const? 64 2147483648)) (const? 64 0)) (const? 32 60)
      (const? 32 100)

theorem test19_proof : test19_before ⊑ test19_after

theorem main7f_logical_thm.extracted_1._2 : ∀ (x x_1 x_2 : BitVec 32),
  ¬ofBool (x_2 &&& x_1 == x &&& (x_2 &&& x_1)) = 1#1 →
    ofBool (x_2 &&& x_1 != x &&& (x_2 &&& x_1)) = 1#1 → ¬0#1 = 1#1 → 1#32 = zeroExtend 32 1#1

theorem eq_commuted_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ¬(x == 0 || 8 != 1 && 43#8 == intMin 8 && x == -1) = true →
    ofBool (x_1 == 0#8) ||

theorem icmp_eq_and1_lshr_pow2_minus_one_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬x ≥ ↑32 → zeroExtend 32 (ofBool (7#32 >>> x &&& 1#32 == 0#32)) = zeroExtend 32 (ofBool (2#32 <ᵤ x))

theorem sdiv_common_divisor_defined_cond_proof : sdiv_common_divisor_defined_cond_before ⊑ sdiv_common_divisor_defined_cond_after

theorem a_false_implies_b_false_thm.extracted_1._2 : ∀ (x x_1 : BitVec 1) (x_2 : BitVec 8),
  ¬ofBool (10#8 <ᵤ x_2) = 1#1 → ofBool (20#8 <ᵤ x_2) = 1#1 → x_1 = x

theorem lshr_shl_pow2_const_case1_proof : lshr_shl_pow2_const_case1_before ⊑ lshr_shl_pow2_const_case1_after

theorem shl1_nsw_not_exact_thm (e e_1 : IntW 8) :
  LLVM.sdiv e_1 (shl (const? 8 1) e { «nsw» := true, «nuw» := false }) ⊑
    LLVM.sdiv e_1 (shl (const? 8 1) e { «nsw» := true, «nuw» := true })

theorem pr33078_2_thm.extracted_1._1 : ∀ (x : BitVec 8), ¬4#16 ≥ ↑16 → 4#8 ≥ ↑8 → False

theorem ashr_sub_nsw_proof : ashr_sub_nsw_before ⊑ ashr_sub_nsw_after

theorem and_logic_and_logic_or_2_thm.extracted_1._2 : ∀ (x x_1 : BitVec 1), x_1 &&& x = 1#1 → ¬x_1 = 1#1 → 1#1 = 0#1

theorem masked_icmps_mask_notallzeros_bmask_mixed_4_logical_thm (e : IntW 32) :
  select (icmp IntPred.ne (LLVM.and e (const? 32 255)) (const? 32 0))
      (icmp IntPred.eq (LLVM.and e (const? 32 15)) (const? 32 8)) (const? 1 0) ⊑
    icmp IntPred.eq (LLVM.and e (const? 32 15)) (const? 32 8)

theorem lshrugt_03_11_exact_proof : lshrugt_03_11_exact_before ⊑ lshrugt_03_11_exact_after

theorem main7b_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 32),
  ofBool (x_2 == x_1 &&& x_2) &&& ofBool (x * 42#32 == x_1 &&& x * 42#32) = 1#1 →
    0#32 = zeroExtend 32 (ofBool (x_1 &&& (x_2 ||| x * 42#32) != x_2 ||| x * 42#32))

theorem e_1905 :
    1 * (a ^^^ c) + 1 * (c ^^^  ~~~(a &&& ( ~~~b &&& c))) - 5 * (a ||| ( ~~~b &&& c)) + 2 * ( ~~~b |||  ~~~(a ^^^ c)) + 1 * (a &&&  ~~~c) + 5 * ( ~~~c &&&  ~~~(a ^^^ b)) + 3 * ((a &&&  ~~~b) ||| (b ^^^ c)) - 7 *  ~~~(b ^^^ c) + 2 * (a ||| c) + 7 * ((a &&& c) ||| (b &&&  ~~~c)) - 2 * ( ~~~(a ||| b) ||| (b ^^^ c)) + 1 * (a ^^^ ( ~~~b ||| c)) - 3 *  ~~~(b &&&  ~~~c) - 2 * ((a &&& b) ^^^ (a ^^^ (b &&& c))) + 4 * (a ||| ( ~~~b ||| c)) - 1 * (b ^^^  ~~~(a &&& ( ~~~b ||| c))) - 1 * ((a &&& c) ^^^  ~~~(b &&&  ~~~c)) + 1 * (c ^^^ (a ||| (b &&& c))) - 7 * (c ^^^ (a &&&  ~~~b)) + 1 * ( ~~~a ||| ( ~~~b &&& c)) - 11 * (b &&& c) - 2 *  ~~~(a ^^^ ( ~~~b &&& c)) + 5 * (a ||| b) - 1 * (b &&& (a |||  ~~~c)) + 1 * ((a &&& b) |||  ~~~(a ^^^ (b ^^^ c))) - 1 *  ~~~(a ||| c) - 5 * a + 11 * (a &&& (b ||| c)) + 2 * (a ^^^ (b ^^^ c)) - 1 * (c ^^^  ~~~( ~~~a &&& (b &&& c))) - 6 * (c &&& (a ^^^ b)) - 3 *  ~~~(a &&& ( ~~~b &&& c)) - 3 * ((a &&&  ~~~b) |||  ~~~(a ^^^ (b ^^^ c))) + 1 * (a &&& ( ~~~b ||| c)) + 3 * ((a &&&  ~~~b) ||| (a ^^^ (b ^^^ c))) - 1 * (c ^^^  ~~~(a &&& (b ||| c))) + 2 * ((a &&& b) |||  ~~~(b ||| c)) + 4 *  ~~~(a &&& (b ^^^ c)) + 3 * ( ~~~a ||| (b ||| c)) + 2 * (c &&&  ~~~(a &&&  ~~~b)) + 1 * (b |||  ~~~(a ^^^ c)) + 11 * (b ^^^ ( ~~~a &&& (b ^^^ c))) - 2 * (a &&& (b ^^^ c)) - 28 *  ~~~(a ||| ( ~~~b ||| c)) + 6 *  ~~~( ~~~a ||| (b ||| c)) - 42 *  ~~~( ~~~a ||| ( ~~~b ||| c)) - 22 * ( ~~~a &&& ( ~~~b &&& c)) + 3 * ( ~~~a &&& (b &&& c)) - 21 * (a &&& ( ~~~b &&& c)) - 18 * (a &&& (b &&& c)) =  - 3 * (b ^^^ (a &&& (b ^^^ c))) - 4 * ( ~~~(a |||  ~~~b) ||| (b ^^^ c))

@[simp] lemma eval_simplify :
    p.simplify.eval = p.eval

theorem select_1_thm.extracted_1._6 : ∀ (x : BitVec 8) (x_1 : BitVec 1) (x_2 x_3 : BitVec 8) (x_4 : BitVec 1),
  x_4 = 1#1 → x_3 ^^^ (x_2 ^^^ 45#8) ^^^ -1#8 = x_2 ^^^ x_3 ^^^ BitVec.ofInt 8 (-46)

theorem canonicalize_logic_first_xor_0_nsw_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬(True ∧ x.saddOverflow 96#8 = true) → True ∧ (x ^^^ 31#8).saddOverflow 96#8 = true → False

theorem and_zext_eq_odd_proof : and_zext_eq_odd_before ⊑ and_zext_eq_odd_after

theorem ashrsgt_02_13_exact_thm (e : IntW 4) :
  icmp IntPred.sgt (ashr e (const? 4 2) { «exact» := true }) (const? 4 (-3)) ⊑ const? 1 1

theorem ne_umin1_thm (e e_1 : IntW 32) :
  icmp IntPred.ne (select (icmp IntPred.ult e_1 e) e_1 e) e_1 ⊑ icmp IntPred.ugt e_1 e

theorem t0_commutative_thm.extracted_1._9 : ∀ (x : BitVec 8) (x_1 : BitVec 1) (x_2 x_3 : BitVec 8),
  ¬ofBool (x_3 == x_2) = 1#1 → ¬ofBool (x_3 != x_2) = 1#1 → ¬0#1 = 1#1 → ¬x_1 = 1#1 → False

@[simp] theorem carry_borrow (x : Bool → BitStream) : ∀ (n : ℕ), borrow.carry x (n+1) =
    fun _ => (x true).borrow (x false) n

theorem masked_icmps_mask_notallzeros_bmask_mixed_negated_swapped_1_proof : masked_icmps_mask_notallzeros_bmask_mixed_negated_swapped_1_before ⊑ masked_icmps_mask_notallzeros_bmask_mixed_negated_swapped_1_after

theorem Factor.reflectFin_toNat_eq_add
    {w : Nat} {x : Factor} {env : EnvFin (w +1) x.numVars} :
    (x.reflectFin env).toNat = 2 * (x.reflectFin env.getNonLsbs).toNat + ((x.reflectFin env.getLsb).getLsbD 0).toNat

theorem icmp_eq_zext_eq_non_boolean_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (zeroExtend 32 (ofBool (x == 2#32)) == x) = ofBool (x == 0#32)

theorem logical_and_bitwise_and_icmps_comm3_proof : logical_and_bitwise_and_icmps_comm3_before ⊑ logical_and_bitwise_and_icmps_comm3_after

theorem icmp_eq_x_invertable_y2_proof : icmp_eq_x_invertable_y2_before ⊑ icmp_eq_x_invertable_y2_after

@[simp]
lemma proj_accepts (M : NFA' m) (f : Fin n → Fin m) :
    (M.proj f).accepts = BitVecs.transport f '' M.accepts

theorem shift_no_xor_multiuse_cmp_with_xor_thm.extracted_1._7 : ∀ (x x_1 x_2 x_3 : BitVec 32),
  ¬ofBool (x_3 &&& 1#32 == 0#32) = 1#1 →
    True ∧ ((x_3 &&& 1#32) <<< 1#32).sshiftRight' 1#32 ≠ x_3 &&& 1#32 ∨
        True ∧ (x_3 &&& 1#32) <<< 1#32 >>> 1#32 ≠ x_3 &&& 1#32 ∨ 1#32 ≥ ↑32 →
      False

theorem bools_logical_commute0_and1_thm (e e_1 e_2 : IntW 1) :
  select (LLVM.and (LLVM.xor e_2 (const? 1 1)) e_1) (const? 1 1) (select e_2 e (const? 1 0)) ⊑ select e_2 e e_1

theorem t3_const_after_fold_lshr_shl_ne_thm.extracted_1._2 : ∀ (x x_1 x_2 : BitVec 32),
  ¬(32#32 - x_1 ≥ ↑32 ∨ x_1 + -1#32 ≥ ↑32) →
    ¬31#32 ≥ ↑32 →
      ofBool (x_2 >>> (32#32 - x_1) &&& x <<< (x_1 + -1#32) != 0#32) = ofBool (x_2 >>> 31#32 &&& x != 0#32)

@[simp]
lemma swapLastTwo_same (x : Fin n) : swapLastTwo (n := n) (x.castLE (by omega)) = x.castLE (by omega)

theorem e_1528 :
     - 1 * ((a &&& c) ||| (b &&&  ~~~c)) - 11 *  ~~~(a &&&  ~~~c) - 5 * ( ~~~(a ||| b) ||| (a ^^^ (b ^^^ c))) + 5 *  ~~~(a ||| (b ||| c)) + 19 *  ~~~(a ||| ( ~~~b ||| c)) - 4 *  ~~~( ~~~a ||| (b ||| c)) - 10 *  ~~~( ~~~a ||| ( ~~~b ||| c)) + 5 * ( ~~~a &&& ( ~~~b &&& c)) + 2 * ( ~~~a &&& (b &&& c)) + 12 * (a &&& ( ~~~b &&& c)) + 6 * (a &&& (b &&& c)) =  - 11 * ( ~~~(a ^^^ b) ||| (a ^^^ c)) + 2 * (b ^^^  ~~~( ~~~a ||| ( ~~~b &&& c)))

theorem logic_or_logic_and_2_proof : logic_or_logic_and_2_before ⊑ logic_or_logic_and_2_after

theorem sgt_or_not_min_commute_thm (e e_1 : IntW 8) :
  LLVM.or (icmp IntPred.ne e_1 (const? 8 (-128))) (icmp IntPred.sgt e_1 e) ⊑
    icmp IntPred.ne e_1 (const? 8 (-128))

theorem t9_nocse_thm (e : IntW 8) :
  LLVM.or (add (shl (const? 8 1) e) (const? 8 (-1))) (shl (const? 8 1) e) ⊑
    LLVM.or (shl (const? 8 1) e { «nsw» := false, «nuw» := true })
      (LLVM.xor (shl (const? 8 (-1)) e { «nsw» := true, «nuw» := false }) (const? 8 (-1)))

theorem test_sdiv_canonicalize_op0_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬(True ∧ (0#32).ssubOverflow x_1 = true ∨ (x == 0 || 32 != 1 && 0#32 - x_1 == intMin 32 && x == -1) = true) →
    (x == 0 || 32 != 1 && x_1 == intMin 32 && x == -1) = true ∨ True ∧ (0#32).ssubOverflow (x_1.sdiv x) = true →
      False

theorem lt_signed_to_large_negative_proof : lt_signed_to_large_negative_before ⊑ lt_signed_to_large_negative_after

theorem main7f_logical_thm.extracted_1._5 : ∀ (x x_1 x_2 x_3 : BitVec 32),
  ¬ofBool (x_3 &&& x_2 == x_1 &&& (x_3 &&& x_2)) = 1#1 →
    ofBool (x_3 &&& x_2 != x_1 &&& (x_3 &&& x_2)) = 1#1 → 0#1 = 1#1 → 0#32 = zeroExtend 32 1#1

theorem e_1574 :
     - 5 * (b &&& c) + 1 * (c ^^^ ( ~~~a ||| ( ~~~b ||| c))) + 2 * ((a &&& c) ||| (b &&&  ~~~c)) - 6 * ((b &&& c) ||| ( ~~~a &&& (b ||| c))) + 2 * ( ~~~(a &&& b) &&& (a ^^^ (b ^^^ c))) - 7 * (b ^^^ (a ||| c)) + 1 * (b ^^^  ~~~( ~~~a ||| (b ^^^ c))) + 4 * (c ^^^  ~~~( ~~~a &&& (b ||| c))) - 5 *  ~~~(a ||| (b ||| c)) + 12 *  ~~~(a ||| ( ~~~b ||| c)) + 4 *  ~~~( ~~~a ||| (b ||| c)) - 7 *  ~~~( ~~~a ||| ( ~~~b ||| c)) + 7 * ( ~~~a &&& ( ~~~b &&& c)) + 6 * ( ~~~a &&& (b &&& c)) + 10 * (a &&& ( ~~~b &&& c)) + 14 * (a &&& (b &&& c)) = 5 *  ~~~(a ^^^ ( ~~~b ||| c))

theorem lor_land_left2_thm.extracted_1._1 : ∀ (x x_1 : BitVec 1), ¬x_1 = 1#1 → ¬x = 1#1 → 0#1 = x

theorem ofBitVecZext_eq_ofBitVecSext_of_lt (x : BitVec w)
    (h : i < w) :
    BitStream.ofBitVecZext x i =
    BitStream.ofBitVecSext x i

theorem icmp_ne_sext_ne_otherwise_proof : icmp_ne_sext_ne_otherwise_before ⊑ icmp_ne_sext_ne_otherwise_after

theorem zext_zext_sle_op0_narrow_proof : zext_zext_sle_op0_narrow_before ⊑ zext_zext_sle_op0_narrow_after

theorem test13_thm (e e_1 : IntW 32) : LLVM.xor (LLVM.or e_1 e) (LLVM.xor e_1 e) ⊑ LLVM.and e e_1

theorem no_shift_xor_multiuse_cmp_xor_thm.extracted_1._4 : ∀ (x x_1 x_2 x_3 : BitVec 32),
  ¬ofBool (0#32 != x_3 &&& 4096#32) = 1#1 →
    ¬ofBool (x_3 &&& 4096#32 == 0#32) = 1#1 →
      (x_2 ^^^ 4096#32) * x * (x_2 ^^^ 4096#32) = x_2 * x_1 * (x_2 ^^^ 4096#32)

theorem uge_to_slt_thm (e : IntW 8) :
  icmp IntPred.uge (LLVM.xor e (const? 8 127)) (const? 8 15) ⊑ icmp IntPred.slt e (const? 8 113)

theorem test3_thm.extracted_1._2 : ∀ (x : BitVec 1) (x_1 : BitVec 599),
  x = 1#1 → ¬70368744177664#599 = 0 → ¬46#599 ≥ ↑599 → x_1 / 70368744177664#599 = x_1 >>> 46#599

theorem e_265 :
    1 * (x ||| y) - 1 * (x ^^^ y) + 2 *  ~~~(x ^^^ y) - 1 * x + 7 * y - 7 *  ~~~(x |||  ~~~y) - 9 * (x &&& y) =  - 1 *  ~~~y + 3 *  ~~~(x ||| y)

theorem verifyAIG_correct {α : Type} [DecidableEq α] [Fintype α] [Hashable α]
    {entry : Entrypoint α} {cert : String}
    (h : verifyAIG entry cert) :
    entry.Unsat

theorem shl_add_and_fail_mismatch_shift_thm (e e_1 : IntW 8) :
  LLVM.and (shl e_1 (const? 8 1)) (add (lshr e (const? 8 1)) (const? 8 123)) ⊑
    LLVM.and (shl e_1 (const? 8 1))
      (add (lshr e (const? 8 1)) (const? 8 123) { «nsw» := false, «nuw» := true })
</all_available_lemmas>

<local_ctx>
import Mathlib.Data.Fintype.Prod

import Blase.AutoStructs.Worklist

import Mathlib.Tactic.ApplyFun

open SetRel

section sink

variable {A : Type} [BEq A] [Hashable A] [DecidableEq A] [FinEnum A]

end sink

section generic_prod

variable {α} [BEq α] [Hashable α] [LawfulBEq α]

variable {β} [BEq β] [Hashable β] [LawfulBEq β]

variable {S₁ : Finset α} {S₂ : Finset β}

variable {γ} (f : S₁ → S₂ → γ) (hinj : Function.Injective2 f)

variable {m₁ : Std.HashSet α} (hm₁ : ∀ s₁ ∈ m₁, s₁ ∈ S₁)

variable {m₂ : Std.HashSet β} (hm₂ : ∀ s₂ ∈ m₂, s₂ ∈ S₂)

end generic_prod

section product

variable {A : Type} [BEq A] [LawfulBEq A] [Hashable A] [DecidableEq A] [FinEnum A]

end product

section determinization

variable {A : Type} [BEq A] [LawfulBEq A] [Hashable A] [DecidableEq A] [FinEnum A]

private def bv_to_set (bv : BitVec w) : Set State :=
  { s | bv.getLsbD s }
</local_ctx>

<target_theorem>
@[simp]
lemma transBV_spec {m : CNFA n} {res} {s : m.m.states} :
    s' ∈ bv_to_set (m.m.transBV' res s a) ↔
      (s' ∈ bv_to_set res ∨ s' ∈ m.m.tr s a) :=
</target_theorem>

