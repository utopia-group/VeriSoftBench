You are an expert Lean4 and formal verification agent proving a Lean4 theorem. Your output **must** strictly adhere to the specified format.

### Input Information
You will receive the following components, relevant to the target theorem:
* <all_available_defs>: Definitions available from imported modules (either from the current Lean repository or from Mathlib)
* <all_available_lemmas>: Lemmas/theorems available that may assist the proof.
* <local_ctx>...</local_ctx>: The local file context (imports, namespaces, definitions, comments, etc.) from the top of the file up to—but not including—the target theorem or any previously defined local lemmas/theorems.
* <target_theorem>...</target_theorem>: The target theorem statement, ending with `:=`.

**Notes**
1. Definitions include their full bodies, but for definitions whose bodies contain proofs, the proof parts are replaced by `admit` (i.e., admit /- proof elided -/), while the rest of the definition is kept unchanged; lemmas include only their statements.
2. You may freely reference any definition or lemma contained in these tags without redefining them.
3. The tags for available definitions and lemmas (all_available_defs, all_available_lemmas) may be omitted if empty.

### Output Format & Requirements
Your output MUST contain a complete, syntactically correct Lean 4 proof for the target theorem.

**Strict Output Structure:**
<reasoning> 
...
</reasoning> 

<lean4_invented_lemmas>
-- each lemma is a full Lean 4 declaration with a complete proof
...
</lean4_invented_lemmas>

<lean4_proof>
-- Lean 4 proof body of the target theorem
...
</lean4_proof>

**Requirements:**
1. <reasoning> and <lean4_invented_lemmas> are OPTIONAL. Include them only if they aid proof construction.
2. <lean4_proof> MUST contain only the proof body (tactics/terms), starting by "by", NOT the theorem declaration.
3. <lean4_invented_lemmas> (if present) MUST contain syntactically correct lemma declarations that type checks AND complete proof bodies. Defining a lemma using `axiom` is NOT allowed.
4. <reasoning> contains high-level proof planning.
5. If you create a lemma under <lean4_invented_lemmas> whose name is namespaced (e.g., X.Y.Z), you MUST always refer to it using its fully qualified name. Do NOT rely on shortened names. For example, write rw [X.Y.Z], not rw [Z] for invented lemmas.
6. All Lean 4 code MUST be syntactically correct. No `sorry`, `admit`, or non-Lean text. Comments allowed using `--` or `/- ... -/`.
7. Follow the tags and structure EXACTLY. No extra text before, between, or after the sections.
8. Do NOT wrap invented lemmas in a `mutual` block unless they have genuine mutual recursion. Declare each lemma independently.

### Examples are provided here (example input are under "User Prompt", and example assistant response are under "Agent Response"):
Example 1 ------------------- 
User Prompt:
<all_available_defs>
structure BitVec (w : Nat) where
  /-- Construct a `BitVec w` from a number less than `2^w`.
  O(1), because we use `Fin` as the internal representation of a bitvector. -/
  ofFin ::

  /-- Interpret a bitvector as a number less than `2^w`.
  O(1), because we use `Fin` as the internal representation of a bitvector. -/
  toFin : Fin (hPow 2 w)
</all_available_defs>

<all_available_lemmas>
theorem List.getElem_append_left{α : Type u_1} {l₁ l₂ : List α} {i : Nat} (hn : i < l₁.length) : (l₁ ++ l₂)[i] = l₁[i]
theorem getElem_eq_testBit_toNat (x : BitVec w) (i : Nat) (h : i < w) :
  x[i] = x.toNat.testBit i := rfl
@[simp, grind =] theorem toNat_cons (b : Bool) (x : BitVec w) :
    (cons b x).toNat = (b.toNat <<< w) ||| x.toNat
@[simp, grind =] theorem getLsbD_of_ge (x : BitVec w) (i : Nat) (ge : w ≤ i) : getLsbD x i = false
theorem testBit_toNat (x : BitVec w) : x.toNat.testBit i = x.getLsbD i
</all_available_lemmas>

<local_ctx>
import Mathlib.Computability.NFA
import Mathlib.Data.FinEnum
import Mathlib.Data.Rel
import Mathlib.Data.Vector.Basic
import Blase.AutoStructs.ForLean

open Set
open Mathlib
open SetRel

-- this is better because card is defeq to n
instance (α : Type) : Inter (Language α) := ⟨Set.inter⟩
instance (α : Type) : Union (Language α) := ⟨Set.union⟩

/--
The set of `n`-tuples of bit vectors of an arbitrary width.
-/
structure BitVecs (n : Nat) where
  w : Nat
  bvs : List.Vector (BitVec w) n

def BitVecs.cast (bvs : BitVecs n) (h : n = n') : BitVecs n' :=
  { w := bvs.w, bvs := h ▸ bvs.bvs }

abbrev BitVecs.empty : BitVecs n := ⟨0, List.Vector.replicate n .nil⟩
abbrev BitVecs.singleton {w : Nat} (bv : BitVec w) : BitVecs 1 := ⟨w, bv ::ᵥ .nil⟩
abbrev BitVecs.pair {w : Nat} (bv1 bv2 : BitVec w) : BitVecs 2 := ⟨w, bv1 ::ᵥ bv2 ::ᵥ .nil⟩

/--
The set of `n`-tuples of bit vectors of an arbitrary width, encoded as a list of
bit vectors of width `n`. The width of the encoded bit vectors is the length of
the list.
-/
abbrev BitVecs' (n : Nat) := List (BitVec n)

@[simps]
def dec (bvs' : BitVecs' n) : BitVecs n where
  w := bvs'.length
  bvs := List.Vector.ofFn fun k => BitVec.ofFn fun i => bvs'[i].getLsbD k

@[simp]
</local_ctx>

<target_theorem>
lemma dec_snoc n (bvs' : BitVecs' n) (a : BitVec n) :
  dec (bvs' ++ [a]) =
    { w := bvs'.length + 1
      bvs := List.Vector.ofFn fun k =>
        BitVec.cons (a.getLsbD k) ((dec bvs').bvs.get k) } :=
</target_theorem>

Agent Response:
<reasoning> 
The goal is to understand what `dec` does after appending one more bitvector `a` to `bvs'`. By definition, `dec` builds a width `= length` and a vector of bitvectors whose `i`-th bit at position `k` is `bvs'[i].getLsbD k`. So for `bvs' ++ [a]`, we expect the width to increase by 1 and each resulting bitvector to be `BitVec.cons` of the new bit coming from `a`.

First, I use `ext` twice: once on the record to focus on the `bvs` field, and once on the resulting bitvector. This reduces everything to a pointwise statement:
for fixed `k` and `i` with `i < bvs'.length + 1`,
the bit `(bvs' ++ [a])[i].getLsbD k` should match the bit at index `i` of `BitVec.cons (a.getLsbD k) ((dec bvs').bvs.get k)`.

At this point I need a clean description of indexing into `BitVec.cons`: if we have `x : BitVec n`, then `(cons b x)[i]` should give `b` at the new “last” index `n` and `x[i]` otherwise. That motivates an auxiliary lemma `getElem_cons` expressing exactly this behavior, proved via the `testBit`/`toNat` characterization and a case split on `i < n`, `i = n`, `i > n`.

Using `getElem_cons`, the RHS becomes an `if` on whether `i = bvs'.length`. So I split into cases:
- If `i = bvs'.length`, then `(bvs' ++ [a])[i]` is the appended `a`, so both sides reduce to `a.getLsbD k`.
- If `i ≠ bvs'.length`, the bound `i < bvs'.length + 1` forces `i < bvs'.length`. Then `(bvs' ++ [a])[i] = bvs'[i]` by `List.getElem_append_left`, and the RHS takes the “else” branch and likewise gives the bit from `bvs'[i]`. In both subcases, `simp` (plus the definition of `dec`) finishes.

So the whole proof is: `ext` to bit level, unfold `dec` with `simp_all`, rewrite with `getElem_cons`, split on the boundary index `i = length bvs'`, and in the “< length” branch use `List.getElem_append_left` and bounds to line up both sides.
</reasoning> 

<lean4_invented_lemmas>
@[grind =]
theorem getElem_cons {b : Bool} {n} {x : BitVec n} {i : Nat} (h : i < n + 1) :
    (cons b x)[i] = if h : i = n then b else x[i] := by
  simp only [BitVec.getElem_eq_testBit_toNat, BitVec.toNat_cons, Nat.testBit_or]
  rw [Nat.testBit_shiftLeft]
  rcases Nat.lt_trichotomy i n with i_lt_n | i_eq_n | n_lt_i
  · have p1 : ¬(n ≤ i) := by omega
    have p2 : i ≠ n := by omega
    simp [p1, p2]
  · simp only [i_eq_n, ge_iff_le, Nat.le_refl, decide_true, Nat.sub_self, Nat.testBit_zero,
    Bool.true_and, BitVec.testBit_toNat, BitVec.getLsbD_of_ge, Bool.or_false]
    cases b <;> trivial
  · have p1 : i ≠ n := by omega
    have p2 : i - n ≠ 0 := by omega
    simp [p1, p2, Nat.testBit_bool_toNat]
</lean4_invented_lemmas>

<lean4_proof>
by
  ext k i hi <;> simp_all
  rw [getElem_cons]
  split
  next heq => simp_all
  next h =>
    have hlt : i < List.length bvs' := by simp at hi; omega
    rw [List.getElem_append_left hlt]
    simp
</lean4_proof>

### Your task:
<all_available_defs>
Bool in Init.Prelude
Nat in Init.Prelude
Int.xor in Mathlib.Data.Int.Bitwise
Nat.testBit in Init.Data.Nat.Bitwise.Basic
Fin in Init.Prelude
Fin.castLE in Init.Data.Fin.Basic
Fin.last in Init.Data.Fin.Basic
List in Init.Prelude

syntax "max" : MLIR.Pretty.uniform_op

syntax "slt" : MLIR.Pretty.uniform_op

macro_rules
  | `(mlir_op| $res:mlir_op_operand = const ($x)
      $[: $outer_type]? ) => do
      let outer_type ← outer_type.getDM `(mlir_type| _)
      `(mlir_op| $res:mlir_op_operand = "const"()
          {val = $x:num : $outer_type} : ($outer_type) -> ($outer_type) )

macro_rules
  | `(mlir_op| $res:mlir_op_operand = li ($x)
     $[: $outer_type]?  ) => do
      let outer_type ← outer_type.getDM `(mlir_type| _ )
      `(mlir_op| $res:mlir_op_operand = "li"()
          {imm = $x:num : $outer_type } : ($outer_type) -> ($outer_type))

macro_rules
| `(mlir_op| $res:mlir_op_operand = $op1:MLIR.Pretty.RV.opWithImmediate $reg1 , $x : $t)  => do
    let some opName := MLIR.EDSL.Pretty.extractOpName op1.raw
      | Macro.throwUnsupported
    `(mlir_op| $res:mlir_op_operand = $opName ($reg1) {imm = $x:num : $t} : ($t) -> ($t) )

macro_rules
| `(mlir_op| $res:mlir_op_operand = $op1:MLIR.Pretty.RV.opWithShamt $reg1 , $x  : $t )  => do
    let some opName := MLIR.EDSL.Pretty.extractOpName op1.raw
      | Macro.throwUnsupported
    `(mlir_op| $res:mlir_op_operand = $opName ($reg1) {shamt = $x:num : $t}  : ($t) -> ($t) )

def Predicate.evalUlt (t₁ t₂ : BitStream) : BitStream := (~~~ (t₁.borrow t₂)).concat true

def BitStream : Type := Nat → Bool

def borrow (x y : BitStream) : BitStream :=
  fun n => (subAux x y n).2

def subAux (x y : BitStream) : Nat → Bool × Bool
  | 0 => (xor (x 0) (y 0), !(x 0) && y 0)
  | n+1 =>
    let borrow := (subAux x y n).2
    let a := x (n + 1)
    let b := y (n + 1)
    (xor a (xor b borrow), !a && b || ((!(xor a b)) && borrow))

inductive Predicate : Type where
 
| width (wp : WidthPredicate) (n : Nat) : Predicate
| binary (p : BinaryPredicate) (t₁ t₂ : Term)
| land  (p q : Predicate) : Predicate
| lor (p q : Predicate) : Predicate
deriving Repr, Inhabited, Lean.ToExpr

@[simp] def Predicate.evalFin (p : Predicate) (vars : Fin (arity p) → BitStream) : BitStream :=
match p with
| .width .eq n => BitStream.falseIffEq n
| .width .neq n => BitStream.falseIffNeq n
| .width .lt n => BitStream.falseIffLt n
| .width .le n => BitStream.falseIffLe n
| .width .gt n => BitStream.falseIffGt n
| .width .ge n => BitStream.falseIffGe n
| .binary .eq t₁ t₂ =>
    let x₁ := t₁.evalFin (fun i => vars (Fin.castLE (by admit /- proof elided -/
    ) i))
    let x₂ := t₂.evalFin (fun i => vars (Fin.castLE (by admit /- proof elided -/
    ) i))
    Predicate.evalEq x₁ x₂
| .binary .neq t₁ t₂  =>
    let x₁ := t₁.evalFin (fun i => vars (Fin.castLE (by admit /- proof elided -/
    ) i))
    let x₂ := t₂.evalFin (fun i => vars (Fin.castLE (by admit /- proof elided -/
    ) i))
    Predicate.evalNeq x₁ x₂
| .land p q =>
  
  
  let x₁ := p.evalFin (fun i => vars (Fin.castLE (by admit /- proof elided -/
  ) i))
  let x₂ := q.evalFin (fun i => vars (Fin.castLE (by admit /- proof elided -/
  ) i))
  Predicate.evalLand x₁ x₂
| .lor p q =>
  
  let x₁ := p.evalFin (fun i => vars (Fin.castLE (by admit /- proof elided -/
  ) i))
  let x₂ := q.evalFin (fun i => vars (Fin.castLE (by admit /- proof elided -/
  ) i))
  Predicate.evalLor x₁ x₂
| .binary .slt p q =>
  let x₁ := p.evalFin (fun i => vars (Fin.castLE (by admit /- proof elided -/
  ) i))
  let x₂ := q.evalFin (fun i => vars (Fin.castLE (by admit /- proof elided -/
  ) i))
  Predicate.evalSlt x₁ x₂
| .binary .sle p q =>
  let x₁ := p.evalFin (fun i => vars (Fin.castLE (by admit /- proof elided -/
  ) i))
  let x₂ := q.evalFin (fun i => vars (Fin.castLE (by admit /- proof elided -/
  ) i))
  Predicate.evalLor (Predicate.evalSlt x₁ x₂) (Predicate.evalEq x₁ x₂)
| .binary .ult p q =>
  let x₁ := p.evalFin (fun i => vars (Fin.castLE (by admit /- proof elided -/
  ) i))
  let x₂ := q.evalFin (fun i => vars (Fin.castLE (by admit /- proof elided -/
  ) i))
  (Predicate.evalUlt x₁ x₂)
| .binary .ule p q =>
  let x₁ := p.evalFin (fun i => vars (Fin.castLE (by admit /- proof elided -/
  ) i))
  let x₂ := q.evalFin (fun i => vars (Fin.castLE (by admit /- proof elided -/
  ) i))
  Predicate.evalLor (Predicate.evalUlt x₁ x₂) (Predicate.evalEq x₁ x₂)

def Predicate.evalLor (t₁ t₂ : BitStream) : BitStream := (t₁ &&& t₂)

@[simp] def Term.evalFin (t : Term) (vars : Fin (arity t) → BitStream) : BitStream :=
  match t with
  | var n => vars (Fin.last n)
  | zero    => BitStream.zero
  | one     => BitStream.one
  | negOne  => BitStream.negOne
  | ofNat n => BitStream.ofNat n
  | and t₁ t₂ =>
      let x₁ := t₁.evalFin (fun i => vars (Fin.castLE (by admit /- proof elided -/
      ) i))
      let x₂ := t₂.evalFin (fun i => vars (Fin.castLE (by admit /- proof elided -/
      ) i))
      x₁ &&& x₂
  | or t₁ t₂ =>
      let x₁ := t₁.evalFin (fun i => vars (Fin.castLE (by admit /- proof elided -/
      ) i))
      let x₂ := t₂.evalFin (fun i => vars (Fin.castLE (by admit /- proof elided -/
      ) i))
      x₁ ||| x₂
  | xor t₁ t₂ =>
      let x₁ := t₁.evalFin (fun i => vars (Fin.castLE (by admit /- proof elided -/
      ) i))
      let x₂ := t₂.evalFin (fun i => vars (Fin.castLE (by admit /- proof elided -/
      ) i))
      x₁ ^^^ x₂
  | not t     => ~~~(t.evalFin vars)
  | add t₁ t₂ =>
      let x₁ := t₁.evalFin (fun i => vars (Fin.castLE (by admit /- proof elided -/
      ) i))
      let x₂ := t₂.evalFin (fun i => vars (Fin.castLE (by admit /- proof elided -/
      ) i))
      x₁ + x₂
  | sub t₁ t₂ =>
      let x₁ := t₁.evalFin (fun i => vars (Fin.castLE (by admit /- proof elided -/
      ) i))
      let x₂ := t₂.evalFin (fun i => vars (Fin.castLE (by admit /- proof elided -/
      ) i))
      x₁ - x₂
  | neg t       => -(Term.evalFin t vars)
 
 
  | shiftL t n  => BitStream.shiftLeft (Term.evalFin t vars) n

abbrev negOne : BitStream := fun _ => true

def shiftLeft (x : BitStream) (k : Nat) : BitStream :=
  fun i => if i < k then false else x (i - k)

def ofNat (x : Nat) : BitStream :=
  Nat.testBit x

abbrev one    : BitStream := (· == 0)

abbrev zero   : BitStream := fun _ => false

@[simp] def Term.arity : Term → Nat
| (var n) => n+1
| zero => 0
| one => 0
| negOne => 0
| ofNat _ => 0
| Term.and t₁ t₂ => max (arity t₁) (arity t₂)
| Term.or t₁ t₂ => max (arity t₁) (arity t₂)
| Term.xor t₁ t₂ => max (arity t₁) (arity t₂)
| Term.not t => arity t
| add t₁ t₂ => max (arity t₁) (arity t₂)
| sub t₁ t₂ => max (arity t₁) (arity t₂)
| neg t => arity t

| shiftL t .. => arity t

inductive Term : Type
| var : Nat → Term
 
| zero : Term
 
| negOne : Term
 
| one : Term
 
| ofNat (n : Nat) : Term
 
| and : Term → Term → Term
 
| or : Term → Term → Term
 
| xor : Term → Term → Term
 
| not : Term → Term
 
| add : Term → Term → Term
 
| sub : Term → Term → Term
 
| neg : Term → Term

| shiftL : Term → Nat → Term

deriving Repr, Inhabited, Lean.ToExpr

def Predicate.evalSlt (t₁ t₂ : BitStream) : BitStream :=
    (((Predicate.evalUlt t₁ t₂)) ^^^ (Predicate.evalMsbEq t₁ t₂))

def Predicate.evalMsbEq (t₁ t₂ : BitStream) : BitStream :=
  (t₁ ^^^ t₂).concat false

def Predicate.evalLand (t₁ t₂ : BitStream) : BitStream := (t₁ ||| t₂)

def Predicate.evalNeq (t₁ t₂ : BitStream) : BitStream := (t₁.nxor t₂).concat true |>.scanAnd

def nxor (a b : BitStream) : BitStream := fun i => a i == b i

def scanAnd (s : BitStream) : BitStream := scanl true Bool.and s

abbrev scanl (init : Bool) (f : Bool → Bool → Bool) (s : BitStream) : BitStream :=
  fun n => match n with
    | 0 => f init (s 0)
    | n+1 => f (scanl init f s n) (s (n + 1))

def Predicate.evalEq (t₁ t₂ : BitStream) : BitStream := (t₁ ^^^ t₂).concat false |>.scanOr

def scanOr (s : BitStream) : BitStream := scanl false Bool.or s

abbrev falseIffNeq (n : Nat) : BitStream := fun i => decide (i == n)

abbrev falseIffLt (n : Nat) : BitStream := fun i => decide (i ≥ n)

abbrev falseIffLe (n : Nat) : BitStream := fun i => decide (i > n)

abbrev falseIffGe (n : Nat) : BitStream := fun i => decide (i < n)

abbrev falseIffEq (n : Nat) : BitStream := fun i => decide (i != n)

abbrev falseIffGt (n : Nat) : BitStream := fun i => decide (i ≤ n)

def Term.width (t : Term) : WidthExpr :=
  match t with

| .ofNat w _n => w
  | .var _v w => w
  | .add w _a _b => w
  | .zext _a wnew => wnew
  | .setWidth _a wnew => wnew
  | .sext _a wnew => wnew
  | .bor w _a _b => w
  | .band w _a _b => w
  | .bxor w _a _b => w
  | .bnot w _a => w
  | .boolVar _v => WidthExpr.const 1 
  | .boolConst _b => WidthExpr.const 1
  | .shiftl w _a _k => w
  | .bvOfBool _b => WidthExpr.const 1
  | binWidthRel _k wa wb => WidthExpr.const 0
  | binRel _k w _a _b => w
  | or _p1 _p2 => WidthExpr.const 0
  | and _p1 _p2 => WidthExpr.const 0
  | pvar _v => WidthExpr.const 0
  | boolBinRel _k _a _b => WidthExpr.const 0

@[simp] def Predicate.arity : Predicate → Nat
| .width _ _ => 0
| .binary .eq t1 t2 => max t1.arity t2.arity
| .binary .neq t₁ t₂ => max t₁.arity t₂.arity
| .binary .ult t₁ t₂ => max t₁.arity t₂.arity
| .binary .ule t₁ t₂ => t₁.arity ⊔ t₂.arity ⊔ (t₁.arity ⊔ t₂.arity)
| .binary .slt t₁ t₂ => (t₁.arity ⊔ t₂.arity ⊔ (t₁.arity ⊔ t₂.arity))
| .binary .sle t₁ t₂ => (t₁.arity ⊔ t₂.arity ⊔ (t₁.arity ⊔ t₂.arity) ⊔ (t₁.arity ⊔ t₂.arity))
| .lor p q => max p.arity q.arity
| .land p q => max p.arity q.arity

inductive BinaryPredicate
| eq
| neq
| ult
| ule
| slt
| sle
deriving Repr, Lean.ToExpr

inductive WidthPredicate
| eq
| neq
| lt
| le
| gt
| ge
deriving Repr, Inhabited, Lean.ToExpr

def Predicate.eval (p : Predicate) (vars : List BitStream) : BitStream :=
  match p with
  | .width .eq n => BitStream.falseIffEq n
  | .width .neq n => BitStream.falseIffNeq n
  | .width .lt n => BitStream.falseIffLt n
  | .width .le n => BitStream.falseIffLe n
  | .width .gt n => BitStream.falseIffGt n
  | .width .ge n => BitStream.falseIffGe n
  | lor p q => Predicate.evalLor (p.eval vars) (q.eval vars)
  | land p q => Predicate.evalLand (p.eval vars) (q.eval vars)
  | binary .eq t₁ t₂ => Predicate.evalEq (t₁.eval vars) (t₂.eval vars)
   
  | binary .neq t1 t2 => Predicate.evalNeq (t1.eval vars) (t2.eval vars)
  | binary .ult t₁ t₂ => Predicate.evalUlt (t₁.eval vars) (t₂.eval vars)
  | binary .ule t₁ t₂ =>
     Predicate.evalLor
       (Predicate.evalEq (t₁.eval vars) (t₂.eval vars))
       (Predicate.evalUlt (t₁.eval vars) (t₂.eval vars))
  | binary .slt t₁ t₂ => Predicate.evalSlt (t₁.eval vars) (t₂.eval vars)
  | binary .sle t₁ t₂ => Predicate.evalLor
       (Predicate.evalEq (t₁.eval vars) (t₂.eval vars))
       (Predicate.evalSlt (t₁.eval vars) (t₂.eval vars))

def Term.eval (t : Term) (vars : List BitStream) : BitStream :=
  match t with
  | var n       => vars.getD n default
  | zero        => BitStream.zero
  | one         => BitStream.one
  | negOne      => BitStream.negOne
  | ofNat n     => BitStream.ofNat n
  | and t₁ t₂   => (t₁.eval vars) &&& (t₂.eval vars)
  | or t₁ t₂    => (t₁.eval vars) ||| (t₂.eval vars)
  | xor t₁ t₂   => (t₁.eval vars) ^^^ (t₂.eval vars)
  | not t       => ~~~(t.eval vars)
  | add t₁ t₂   => (Term.eval t₁ vars) + (Term.eval t₂ vars)
  | sub t₁ t₂   => (Term.eval t₁ vars) - (Term.eval t₂ vars)
  | neg t       => -(Term.eval t vars)

| shiftL t n  => BitStream.shiftLeft (Term.eval t vars) n

def example00 := [RV64_com| {
^bb0(%0 : !riscv.reg, %1 : !riscv.reg):
    %2 = "slt"(%0, %1) : (!riscv.reg, !riscv.reg) -> (!riscv.reg)
    %3 = "andi" (%2){imm = 1 : !i64} : (!riscv.reg) -> (!riscv.reg)
    %4 = "sra"(%0, %0) : (!riscv.reg, !riscv.reg) -> (!riscv.reg)
    %5 = "add"(%0, %0) : (!riscv.reg, !riscv.reg) -> (!riscv.reg)
    %6 = "sra"(%2, %5) : (!riscv.reg, !riscv.reg) -> (!riscv.reg)
  "ret" (%0) : (!riscv.reg) -> ()
 }].denote

def n3_constmask_samemask_before := [llvm|
{
^0(%arg0 : i32, %arg1 : i32):
  %0 = llvm.mlir.constant(65280 : i32) : i32
  %1 = llvm.and %arg0, %0 : i32
  %2 = llvm.and %arg1, %0 : i32
  %3 = llvm.add %1, %2 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

AndOp in Init.Prelude

def alive_AndOrXor_1294_A__B__A__B___A__B_tgt :=
[sllvm| {
^bb0(%A : i64, %B : i64):
  %v1 = llvm.or %A, %B : i64
  %v2 = llvm.mlir.constant -1 : i64
  %v3 = llvm.xor %A, %v2 : i64
  %v4 = llvm.xor %v3, %B : i64
  %v5 = llvm.and %A, %B : i64
  llvm.return %v5 : i64
}]

def test11_before := [llvm|
{
^0(%arg6 : i32, %arg7 : i32):
  %0 = llvm.mlir.constant(8 : i32) : i32
  %1 = llvm.mlir.constant(128 : i32) : i32
  %2 = llvm.shl %arg6, %0 : i32
  %3 = llvm.add %2, %arg7 : i32
  %4 = llvm.and %3, %1 : i32
  %5 = llvm.mul %4, %2 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def n1_before := [llvm|
{
^0(%arg7 : i8, %arg8 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.mlir.constant(1 : i8) : i8
  %2 = llvm.shl %0, %arg8 : i8
  %3 = llvm.xor %2, %1 : i8
  %4 = llvm.icmp "uge" %3, %arg7 : i8
  "llvm.return"(%4) : (i1) -> ()
}
]

def pr40493_neg3_after := [llvm|
{
^0(%arg15 : i32):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.mlir.constant(4 : i32) : i32
  %2 = llvm.shl %arg15, %0 : i32
  %3 = llvm.and %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def scalar_i32_lshr_and_negC_slt_before := [llvm|
{
^0(%arg4 : i32, %arg5 : i32):
  %0 = llvm.mlir.constant(-8 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.lshr %arg4, %arg5 : i32
  %3 = llvm.and %2, %0 : i32
  %4 = llvm.icmp "slt" %3, %1 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def test35_with_trunc_after := [llvm|
{
^0(%arg48 : i64):
  %0 = llvm.mlir.constant(2147483648) : i64
  %1 = llvm.mlir.constant(0) : i64
  %2 = llvm.mlir.constant(60 : i32) : i32
  %3 = llvm.mlir.constant(100 : i32) : i32
  %4 = llvm.and %arg48, %0 : i64
  %5 = llvm.icmp "eq" %4, %1 : i64
  %6 = "llvm.select"(%5, %2, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def ashr_ult_3_after := [llvm|
{
^0(%arg93 : i4):
  %0 = llvm.mlir.constant(6 : i4) : i4
  %1 = llvm.icmp "ult" %arg93, %0 : i4
  "llvm.return"(%1) : (i1) -> ()
}
]

def lshrult_02_10_exact_before := [llvm|
{
^0(%arg123 : i4):
  %0 = llvm.mlir.constant(2 : i4) : i4
  %1 = llvm.mlir.constant(-6 : i4) : i4
  %2 = llvm.lshr exact %arg123, %0 : i4
  %3 = llvm.icmp "ult" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def ashr_lshr_shift_amt_mismatch_after := [llvm|
{
^0(%arg72 : i32, %arg73 : i32, %arg74 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.lshr %arg72, %arg73 : i32
  %2 = llvm.ashr %arg72, %arg74 : i32
  %3 = llvm.icmp "slt" %arg72, %0 : i32
  %4 = "llvm.select"(%3, %2, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def lshr_add_exact_after := [llvm|
{
^0(%arg6 : i8, %arg7 : i8):
  %0 = llvm.mlir.constant(-4 : i8) : i8
  %1 = llvm.mlir.constant(2 : i8) : i8
  %2 = llvm.and %arg6, %0 : i8
  %3 = llvm.and %arg7, %1 : i8
  %4 = llvm.lshr exact %2, %3 : i8
  "llvm.return"(%4) : (i8) -> ()
}
]

def abs_must_be_positive_before := [llvm|
{
^0(%arg48 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.sub %0, %arg48 overflow<nsw> : i32
  %2 = llvm.icmp "sge" %arg48, %0 : i32
  %3 = "llvm.select"(%2, %arg48, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %4 = llvm.icmp "sge" %3, %0 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def main6d_logical_before := [llvm|
{
^0(%arg87 : i32):
  %0 = llvm.mlir.constant(7 : i32) : i32
  %1 = llvm.mlir.constant(3 : i32) : i32
  %2 = llvm.mlir.constant(16 : i32) : i32
  %3 = llvm.mlir.constant(0 : i32) : i32
  %4 = llvm.mlir.constant(true) : i1
  %5 = llvm.mlir.constant(1 : i32) : i32
  %6 = llvm.and %arg87, %0 : i32
  %7 = llvm.icmp "ne" %6, %1 : i32
  %8 = llvm.and %arg87, %2 : i32
  %9 = llvm.icmp "eq" %8, %3 : i32
  %10 = "llvm.select"(%7, %4, %9) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %11 = "llvm.select"(%10, %3, %5) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%11) : (i32) -> ()
}
]

def bad_shl2_sub_i32_after := [llvm|
{
^0(%arg9 : i32):
  %0 = llvm.mlir.constant(-31 : i32) : i32
  %1 = llvm.mlir.constant(1 : i32) : i32
  %2 = llvm.add %arg9, %0 : i32
  %3 = llvm.shl %1, %2 overflow<nuw> : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def test15c_before := [llvm|
{
^0(%arg25 : i32):
  %0 = llvm.mlir.constant(16 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.and %arg25, %0 : i32
  %3 = llvm.icmp "eq" %2, %0 : i32
  %4 = "llvm.select"(%3, %0, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def alive_Select_1100_src  (w : Nat)   :=
[llvm( w )| {
^bb0(%Y : _, %X : _):
  %v1 = llvm.mlir.constant 1 :  i1
  %v2 = llvm.select %v1, %X, %Y
  llvm.return %v2
}]

def t0_after := [llvm|
{
^0(%arg30 : i1, %arg31 : i8, %arg32 : i8, %arg33 : i8, %arg34 : i8):
  %0 = llvm.icmp "ne" %arg31, %arg32 : i8
  %1 = llvm.or %0, %arg30 : i1
  %2 = "llvm.select"(%1, %arg34, %arg33) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def PR2330_after := [llvm|
{
^0(%arg0 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.icmp "ne" %arg0, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def lshr_shl_demand4_after := [llvm|
{
^0(%arg6 : i8):
  %0 = llvm.mlir.constant(60 : i8) : i8
  %1 = llvm.mlir.constant(3 : i8) : i8
  %2 = llvm.mlir.constant(7 : i8) : i8
  %3 = llvm.lshr %0, %arg6 : i8
  %4 = llvm.shl %3, %1 : i8
  %5 = llvm.or disjoint %4, %2 : i8
  "llvm.return"(%5) : (i8) -> ()
}
]

def logical_and_icmps2_after := [llvm|
{
^0(%arg34 : i32, %arg35 : i1):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def test5_before := [llvm|
{
^0(%arg104 : i32):
  %0 = llvm.mlir.constant(16 : i128) : i128
  %1 = llvm.zext %arg104 : i32 to i128
  %2 = llvm.lshr %1, %0 : i128
  %3 = llvm.trunc %2 : i128 to i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def neg_of_sub_from_constant_before := [llvm|
{
^0(%arg188 : i8):
  %0 = llvm.mlir.constant(42 : i8) : i8
  %1 = llvm.mlir.constant(0 : i8) : i8
  %2 = llvm.sub %0, %arg188 : i8
  %3 = llvm.sub %1, %2 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def lshrult_02_05_after := [llvm|
{
^0(%arg346 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

inductive MOp.UnaryOp (φ : Nat) : Type
  | neg
  | not
  | copy
  | freeze
  | trunc (w' : Width φ) (noWrapFlags : NoWrapFlags := {nsw := false, nuw := false} )
  | zext  (w' : Width φ) (nneg : NonNegFlag := {nneg := false} )
  | sext  (w' : Width φ)
deriving Repr, DecidableEq, Inhabited, Lean.ToExpr

def invert_both_cmp_operands_complex_after := [llvm|
{
^0(%arg32 : i1, %arg33 : i32, %arg34 : i32, %arg35 : i32):
  %0 = llvm.sub %arg33, %arg35 : i32
  %1 = "llvm.select"(%arg32, %0, %arg34) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %2 = llvm.icmp "sge" %1, %arg35 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def src_is_notmask_ashr_after := [llvm|
{
^0(%arg55 : i16, %arg56 : i8, %arg57 : i16):
  %0 = llvm.mlir.constant(-32 : i8) : i8
  %1 = llvm.mlir.constant(-124 : i16) : i16
  %2 = llvm.shl %0, %arg56 : i8
  %3 = llvm.sext %2 : i8 to i16
  %4 = llvm.ashr %3, %arg57 : i16
  %5 = llvm.xor %arg55, %1 : i16
  %6 = llvm.icmp "uge" %5, %4 : i16
  "llvm.return"(%6) : (i1) -> ()
}
]

def zext_nneg_sext_sle_op0_narrow_before := [llvm|
{
^0(%arg50 : i8, %arg51 : i16):
  %0 = llvm.zext nneg %arg50 : i8 to i32
  %1 = llvm.sext %arg51 : i16 to i32
  %2 = llvm.icmp "sle" %0, %1 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def n1_after := [llvm|
{
^0(%arg3 : i8):
  %0 = llvm.mlir.constant(8 : i8) : i8
  %1 = llvm.icmp "ult" %arg3, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

instance {test : ConcreteCliTest} : ToString (toType test.ty) where
  toString :=
    match test.ty with
    | bitvec w => inferInstanceAs (ToString (PoisonOr <| BitVec w)) |>.toString

def icmp_and_ashr_multiuse_logical_after := [llvm|
{
^0(%arg4 : i32):
  %0 = llvm.mlir.constant(240 : i32) : i32
  %1 = llvm.mlir.constant(224 : i32) : i32
  %2 = llvm.mlir.constant(496 : i32) : i32
  %3 = llvm.mlir.constant(432 : i32) : i32
  %4 = llvm.and %arg4, %0 : i32
  %5 = llvm.icmp "ne" %4, %1 : i32
  %6 = llvm.and %arg4, %2 : i32
  %7 = llvm.icmp "ne" %6, %3 : i32
  %8 = llvm.and %5, %7 : i1
  "llvm.return"(%8) : (i1) -> ()
}
]

def mkStateUniqueCircuitN {arity : Type _}
  [DecidableEq arity] [Fintype arity] [Hashable arity]
  (p : FSM arity) (n : Nat) : Circuit (Vars p.α arity n) :=
  let sn : p.α → Circuit (Vars p.α arity n) := fun s =>
    Circuit.var true (Vars.stateN s n)
  let circs := (List.range n).attach |>.map fun ⟨i, hi⟩ =>
    let si : p.α → Circuit (Vars p.α arity n) := fun s =>
      Circuit.var true (Vars.stateN s i (by admit /- proof elided -/
      ))
    (mkStateNeqCircuit p si sn)
  Circuit.bigOr circs

def PR42691_5_logical_before := [llvm|
{
^0(%arg334 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(2147483647 : i32) : i32
  %2 = llvm.mlir.constant(true) : i1
  %3 = llvm.icmp "slt" %arg334, %0 : i32
  %4 = llvm.icmp "eq" %arg334, %1 : i32
  %5 = "llvm.select"(%3, %2, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%5) : (i1) -> ()
}
]

def ult_swap_and_not_max_commute_before := [llvm|
{
^0(%arg98 : i8, %arg99 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.icmp "ugt" %arg99, %arg98 : i8
  %2 = llvm.icmp "ne" %arg98, %0 : i8
  %3 = llvm.and %2, %1 : i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def and_two_ranges_to_mask_and_range_no_add_on_one_range_before := [llvm|
{
^0(%arg249 : i16):
  %0 = llvm.mlir.constant(12 : i16) : i16
  %1 = llvm.mlir.constant(16 : i16) : i16
  %2 = llvm.mlir.constant(28 : i16) : i16
  %3 = llvm.icmp "uge" %arg249, %0 : i16
  %4 = llvm.icmp "ult" %arg249, %1 : i16
  %5 = llvm.icmp "uge" %arg249, %2 : i16
  %6 = llvm.or %4, %5 : i1
  %7 = llvm.and %3, %6 : i1
  "llvm.return"(%7) : (i1) -> ()
}
]

def and_xor_or2_after := [llvm|
{
^0(%arg670 : i64, %arg671 : i64, %arg672 : i64):
  %0 = llvm.mlir.constant(42) : i64
  %1 = llvm.udiv %0, %arg671 : i64
  %2 = llvm.udiv %0, %arg672 : i64
  %3 = llvm.or %2, %1 : i64
  "llvm.return"(%3) : (i64) -> ()
}
]

def test4_after := [llvm|
{
^0(%arg4 : i32, %arg5 : i32):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.and %arg4, %0 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def and_two_ranges_to_mask_and_range_different_sizes_after := [llvm|
{
^0(%arg250 : i8):
  %0 = llvm.mlir.constant(-123 : i8) : i8
  %1 = llvm.mlir.constant(-26 : i8) : i8
  %2 = llvm.mlir.constant(-90 : i8) : i8
  %3 = llvm.mlir.constant(-25 : i8) : i8
  %4 = llvm.add %arg250, %0 : i8
  %5 = llvm.icmp "ult" %4, %1 : i8
  %6 = llvm.add %arg250, %2 : i8
  %7 = llvm.icmp "ult" %6, %3 : i8
  %8 = llvm.and %5, %7 : i1
  "llvm.return"(%8) : (i1) -> ()
}
]

StateT.lift in Init.Control.State

def icmp_ne_and_pow2_shl_pow2_before := [llvm|
{
^0(%arg63 : i32):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.mlir.constant(16 : i32) : i32
  %2 = llvm.mlir.constant(0 : i32) : i32
  %3 = llvm.shl %0, %arg63 : i32
  %4 = llvm.and %3, %1 : i32
  %5 = llvm.icmp "ne" %4, %2 : i32
  %6 = llvm.zext %5 : i1 to i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def PR20945_before := [llvm|
{
^0(%arg132 : i32):
  %0 = llvm.mlir.constant(-9 : i32) : i32
  %1 = llvm.mlir.constant(-5 : i32) : i32
  %2 = llvm.ashr %0, %arg132 : i32
  %3 = llvm.icmp "ne" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def masked_icmps_mask_notallzeros_bmask_mixed_negated_4_before := [llvm|
{
^0(%arg62 : i32):
  %0 = llvm.mlir.constant(255 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(15 : i32) : i32
  %3 = llvm.mlir.constant(8 : i32) : i32
  %4 = llvm.and %arg62, %0 : i32
  %5 = llvm.icmp "eq" %4, %1 : i32
  %6 = llvm.and %arg62, %2 : i32
  %7 = llvm.icmp "ne" %6, %3 : i32
  %8 = llvm.or %5, %7 : i1
  "llvm.return"(%8) : (i1) -> ()
}
]

def lshrugt_03_10_exact_after := [llvm|
{
^0(%arg179 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def not_select_bool_const1_before := [llvm|
{
^0(%arg68 : i1, %arg69 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = "llvm.select"(%arg68, %arg69, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %2 = llvm.xor %1, %0 : i1
  "llvm.return"(%2) : (i1) -> ()
}
]

def ripple_nsw3_after := [llvm|
{
^0(%arg19 : i16, %arg20 : i16):
  %0 = llvm.mlir.constant(-21845 : i16) : i16
  %1 = llvm.mlir.constant(21843 : i16) : i16
  %2 = llvm.and %arg20, %0 : i16
  %3 = llvm.and %arg19, %1 : i16
  %4 = llvm.add %2, %3 overflow<nsw,nuw> : i16
  "llvm.return"(%4) : (i16) -> ()
}
]

def udiv_exact_ne_0_after := [llvm|
{
^0(%arg14 : i8, %arg15 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.icmp "ne" %arg14, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def test_srem_canonicalize_op0_before := [llvm|
{
^0(%arg8 : i32, %arg9 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.sub %0, %arg8 overflow<nsw> : i32
  %2 = llvm.srem %1, %arg9 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def test_sub_rhs_add_const_RHS := [mod_arith q, hq| {
  ^bb0(%x : !R):
    %res0 = mod_arith.constant 20 : !R
    %res1 = mod_arith.add %x, %res0 : !R
    return %res1 : !R
}]

def lshrugt_02_00_after := [llvm|
{
^0(%arg399 : i4):
  %0 = llvm.mlir.constant(3 : i4) : i4
  %1 = llvm.icmp "ugt" %arg399, %0 : i4
  "llvm.return"(%1) : (i1) -> ()
}
]

Matrix in Mathlib.LinearAlgebra.Matrix.Defs

def ashr_xor_after := [llvm|
{
^0(%arg20 : i8):
  %0 = llvm.mlir.constant(96 : i8) : i8
  %1 = llvm.lshr %0, %arg20 : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def mullo_variant3_after := [llvm|
{
^0(%arg4 : i64, %arg5 : i64):
  %0 = llvm.mul %arg4, %arg5 : i64
  "llvm.return"(%0) : (i64) -> ()
}
]

def negative_not_less_than_before := [llvm|
{
^0(%arg9 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.mlir.constant(256 : i32) : i32
  %2 = llvm.icmp "sgt" %arg9, %0 : i32
  %3 = llvm.add %arg9, %1 : i32
  %4 = llvm.icmp "ult" %3, %1 : i32
  %5 = llvm.and %2, %4 : i1
  "llvm.return"(%5) : (i1) -> ()
}
]

def or_not_xor_common_op_commute3_after := [llvm|
{
^0(%arg98 : i8, %arg99 : i8, %arg100 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.mlir.constant(-1 : i8) : i8
  %2 = llvm.sub %0, %arg100 : i8
  %3 = llvm.and %arg98, %arg99 : i8
  %4 = llvm.xor %3, %1 : i8
  %5 = llvm.or %4, %2 : i8
  "llvm.return"(%5) : (i8) -> ()
}
]

def match_unsigned_after := [llvm|
{
^0(%arg18 : i64):
  %0 = llvm.mlir.constant(19136) : i64
  %1 = llvm.urem %arg18, %0 : i64
  "llvm.return"(%1) : (i64) -> ()
}
]

Dvd.dvd in Init.Prelude

def test3_after := [llvm|
{
^0(%arg51 : i32):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def lshrugt_03_12_exact_after := [llvm|
{
^0(%arg177 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def unopNfa (op : Unop) (m : CNFA n) : CNFA n :=
  match op with
  | .neg => m.neg

def demorgan_nand_before := [llvm|
{
^0(%arg38 : i8, %arg39 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.xor %arg38, %0 : i8
  %2 = llvm.and %1, %arg39 : i8
  %3 = llvm.xor %2, %0 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def sub_from_constant_before := [llvm|
{
^0(%arg6 : i5, %arg7 : i5):
  %0 = llvm.mlir.constant(10 : i5) : i5
  %1 = llvm.sub %0, %arg6 : i5
  %2 = llvm.add %1, %arg7 : i5
  "llvm.return"(%2) : (i5) -> ()
}
]

def test1_after := [llvm|
{
^0(%arg3 : i57, %arg4 : i57, %arg5 : i57):
  %0 = llvm.xor %arg3, %arg4 : i57
  %1 = llvm.and %arg5, %0 : i57
  "llvm.return"(%1) : (i57) -> ()
}
]

@[simp_denote]
def sext_riscv_i1_to_i8 := [LV| {
  ^entry (%arg: i1):
    %0 = "builtin.unrealized_conversion_cast"(%arg) : (i1) -> (!i64)
    %1 = slli %0, 63 : !i64
    %2 = srai %1, 63 : !i64
    %res = "builtin.unrealized_conversion_cast"(%2) : (!i64) -> (i8)
    llvm.return %res: i8
  }]

def trunc_sandwich_before := [llvm|
{
^0(%arg70 : i32):
  %0 = llvm.mlir.constant(28 : i32) : i32
  %1 = llvm.mlir.constant(2 : i12) : i12
  %2 = llvm.lshr %arg70, %0 : i32
  %3 = llvm.trunc %2 : i32 to i12
  %4 = llvm.lshr %3, %1 : i12
  "llvm.return"(%4) : (i12) -> ()
}
]

def lshrugt_02_03_exact_before := [llvm|
{
^0(%arg202 : i4):
  %0 = llvm.mlir.constant(2 : i4) : i4
  %1 = llvm.mlir.constant(3 : i4) : i4
  %2 = llvm.lshr exact %arg202, %0 : i4
  %3 = llvm.icmp "ugt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def and_two_ranges_to_mask_and_range_no_add_on_one_range_before := [llvm|
{
^0(%arg249 : i16):
  %0 = llvm.mlir.constant(12 : i16) : i16
  %1 = llvm.mlir.constant(16 : i16) : i16
  %2 = llvm.mlir.constant(28 : i16) : i16
  %3 = llvm.icmp "uge" %arg249, %0 : i16
  %4 = llvm.icmp "ult" %arg249, %1 : i16
  %5 = llvm.icmp "uge" %arg249, %2 : i16
  %6 = llvm.or %4, %5 : i1
  %7 = llvm.and %3, %6 : i1
  "llvm.return"(%7) : (i1) -> ()
}
]

def max_sub_ult_c0_before := [llvm|
{
^0(%arg0 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.icmp "ult" %arg0, %0 : i32
  %3 = llvm.add %arg0, %1 : i32
  %4 = "llvm.select"(%2, %3, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def addMax (a : BitVec v) (b : BitVec w) : BitVec (max v w + 1) :=
   a.signExtend _ + b.signExtend _

def fold_sext_to_and3_after := [llvm|
{
^0(%arg14 : i8):
  %0 = llvm.mlir.constant(-126 : i8) : i8
  %1 = llvm.mlir.constant(2 : i8) : i8
  %2 = llvm.and %arg14, %0 : i8
  %3 = llvm.icmp "ne" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def not_cmp_constant_before := [llvm|
{
^0(%arg144 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.mlir.constant(42 : i32) : i32
  %2 = llvm.xor %arg144, %0 : i32
  %3 = llvm.icmp "ugt" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def zero_sign_bit_before := [llvm|
{
^0(%arg31 : i16):
  %0 = llvm.mlir.constant(32767 : i16) : i16
  %1 = llvm.mlir.constant(512 : i16) : i16
  %2 = llvm.and %arg31, %0 : i16
  %3 = llvm.add %2, %1 : i16
  "llvm.return"(%3) : (i16) -> ()
}
]

def test_or_eq_a_b_before := [llvm|
{
^0(%arg36 : i1, %arg37 : i8, %arg38 : i8):
  %0 = llvm.icmp "eq" %arg37, %arg38 : i8
  %1 = llvm.or %arg36, %0 : i1
  %2 = "llvm.select"(%1, %arg37, %arg38) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def alive_Select_1105_src  (w : Nat)   :=
[llvm( w )| {
^bb0(%Y : _, %X : _):
  %v1 = llvm.mlir.constant 0 :  i1
  %v2 = llvm.select %v1,%X, %Y
  llvm.return %v2
}]

def sext_xor_sub_before := [llvm|
{
^0(%arg28 : i64, %arg29 : i1):
  %0 = llvm.sext %arg29 : i1 to i64
  %1 = llvm.xor %arg28, %0 : i64
  %2 = llvm.sub %1, %0 : i64
  "llvm.return"(%2) : (i64) -> ()
}
]

def bools_logical_commute0_and2_before := [llvm|
{
^0(%arg102 : i1, %arg103 : i1, %arg104 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.mlir.constant(false) : i1
  %2 = llvm.xor %arg104, %0 : i1
  %3 = "llvm.select"(%2, %arg102, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %4 = llvm.and %arg104, %arg103 : i1
  %5 = "llvm.select"(%3, %0, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%5) : (i1) -> ()
}
]

def test15_after := [llvm|
{
^0(%arg284 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  "llvm.return"(%0) : (i8) -> ()
}
]

def add_shl_same_amount_nuw_after := [llvm|
{
^0(%arg53 : i64, %arg54 : i64, %arg55 : i64):
  %0 = llvm.add %arg53, %arg54 overflow<nuw> : i64
  %1 = llvm.shl %0, %arg55 overflow<nuw> : i64
  "llvm.return"(%1) : (i64) -> ()
}
]

@[simp_denote]
def or_llvm_i16:= [LV| {
    ^entry (%a: i16,%b: i16 ):
    %0 = llvm.or %a, %b : i16
    llvm.return %0 :i16
  }]

def main4d_logical_after := [llvm|
{
^0(%arg121 : i32):
  %0 = llvm.mlir.constant(23 : i32) : i32
  %1 = llvm.and %arg121, %0 : i32
  %2 = llvm.icmp "eq" %1, %0 : i32
  %3 = llvm.zext %2 : i1 to i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def shl_sub_i64_before := [llvm|
{
^0(%arg15 : i64):
  %0 = llvm.mlir.constant(63) : i64
  %1 = llvm.mlir.constant(1) : i64
  %2 = llvm.sub %0, %arg15 : i64
  %3 = llvm.shl %1, %2 : i64
  "llvm.return"(%3) : (i64) -> ()
}
]

def ashrsgt_02_01_exact_after := [llvm|
{
^0(%arg84 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def ashrslt_01_13_exact_before := [llvm|
{
^0(%arg40 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(-3 : i4) : i4
  %2 = llvm.ashr exact %arg40, %0 : i4
  %3 = llvm.icmp "slt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def t9_before := [llvm|
{
^0(%arg192 : i8, %arg193 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.sub %arg193, %arg192 : i8
  %2 = llvm.sub %0, %1 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def eq_and_shl_one_after := [llvm|
{
^0(%arg35 : i8, %arg36 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.mlir.constant(0 : i8) : i8
  %2 = llvm.shl %0, %arg36 overflow<nuw> : i8
  %3 = llvm.and %2, %arg35 : i8
  %4 = llvm.icmp "ne" %3, %1 : i8
  "llvm.return"(%4) : (i1) -> ()
}
]

def slt_or_not_max_logical_before := [llvm|
{
^0(%arg60 : i8, %arg61 : i8):
  %0 = llvm.mlir.constant(127 : i8) : i8
  %1 = llvm.mlir.constant(true) : i1
  %2 = llvm.icmp "slt" %arg60, %arg61 : i8
  %3 = llvm.icmp "ne" %arg60, %0 : i8
  %4 = "llvm.select"(%2, %1, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def positive_biggerLshr_lshrexact_after := [llvm|
{
^0(%arg32 : i32):
  %0 = llvm.mlir.constant(5 : i32) : i32
  %1 = llvm.mlir.constant(4194303 : i32) : i32
  %2 = llvm.lshr exact %arg32, %0 : i32
  %3 = llvm.and %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

inductive Op
| fst
| snd
| pair (w : Nat)
| fstVal (w : Nat)
| fstValPure (w : Nat)
| sndVal (w : Nat)
| sndValPure (w : Nat)
| fstVal' (w : Nat)
| sndVal' (w : Nat)
| tokVal' (w : Nat)
| fork
| forkVal
| join
| merge
| mux
| muxVal
| cMerge
| branch
| source
| sourceOnes
| sink
| supp
| not
deriving Inhabited, DecidableEq, Repr, Lean.ToExpr

def lt_signed_to_large_signed_after := [llvm|
{
^0(%arg52 : i8):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def or_xor_tree_0110_after := [llvm|
{
^0(%arg27 : i32, %arg28 : i32, %arg29 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mul %arg27, %0 : i32
  %2 = llvm.mul %arg28, %0 : i32
  %3 = llvm.mul %arg29, %0 : i32
  %4 = llvm.xor %1, %2 : i32
  %5 = llvm.or %4, %3 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def test22_logical_before := [llvm|
{
^0(%arg5 : i32, %arg6 : i32):
  %0 = llvm.mlir.constant(100663295 : i32) : i32
  %1 = llvm.mlir.constant(268435456 : i32) : i32
  %2 = llvm.mlir.constant(7 : i32) : i32
  %3 = llvm.mlir.constant(-1 : i32) : i32
  %4 = llvm.mlir.constant(true) : i1
  %5 = llvm.and %arg5, %0 : i32
  %6 = llvm.icmp "ult" %5, %1 : i32
  %7 = llvm.and %arg6, %2 : i32
  %8 = llvm.icmp "sgt" %7, %3 : i32
  %9 = "llvm.select"(%6, %4, %8) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%9) : (i1) -> ()
}
]

def negate_ashr_before := [llvm|
{
^0(%arg110 : i8, %arg111 : i8):
  %0 = llvm.mlir.constant(7 : i8) : i8
  %1 = llvm.ashr %arg111, %0 : i8
  %2 = llvm.sub %arg110, %1 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def test_trunc_after := [llvm|
{
^0(%arg24 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.icmp "ne" %arg24, %0 : i8
  %2 = llvm.sext %1 : i1 to i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def ashrslt_03_13_before := [llvm|
{
^0(%arg224 : i4):
  %0 = llvm.mlir.constant(3 : i4) : i4
  %1 = llvm.mlir.constant(-3 : i4) : i4
  %2 = llvm.ashr %arg224, %0 : i4
  %3 = llvm.icmp "slt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def or_basic_before := [llvm|
{
^0(%arg15 : i16):
  %0 = llvm.mlir.constant(127 : i8) : i8
  %1 = llvm.mlir.constant(-256 : i16) : i16
  %2 = llvm.mlir.constant(17664 : i16) : i16
  %3 = llvm.trunc %arg15 : i16 to i8
  %4 = llvm.icmp "ne" %3, %0 : i8
  %5 = llvm.and %arg15, %1 : i16
  %6 = llvm.icmp "ne" %5, %2 : i16
  %7 = llvm.or %4, %6 : i1
  "llvm.return"(%7) : (i1) -> ()
}
]

def masked_and_notallzeroes_logical_after := [llvm|
{
^0(%arg132 : i32):
  %0 = llvm.mlir.constant(7 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.and %arg132, %0 : i32
  %3 = llvm.icmp "ne" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def nonexact_lshr_eq_noexactlog_after := [llvm|
{
^0(%arg136 : i8):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def test_shift_and_cmp_changed4_after := [llvm|
{
^0(%arg0 : i8):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def src_is_mask_lshr_after := [llvm|
{
^0(%arg96 : i8, %arg97 : i8, %arg98 : i8, %arg99 : i1):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.mlir.constant(15 : i8) : i8
  %2 = llvm.mlir.constant(123 : i8) : i8
  %3 = llvm.add %arg97, %0 : i8
  %4 = llvm.xor %arg97, %3 : i8
  %5 = "llvm.select"(%arg99, %4, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  %6 = llvm.lshr %5, %arg98 : i8
  %7 = llvm.xor %arg96, %2 : i8
  %8 = llvm.icmp "ugt" %7, %6 : i8
  "llvm.return"(%8) : (i1) -> ()
}
]

def icmp_slt_0_and_icmp_sge_neg1_i64_fail_after := [llvm|
{
^0(%arg59 : i64):
  %0 = llvm.mlir.constant(-2) : i64
  %1 = llvm.mlir.constant(62) : i64
  %2 = llvm.mlir.constant(1) : i64
  %3 = llvm.mlir.constant(0) : i64
  %4 = llvm.icmp "sgt" %arg59, %0 : i64
  %5 = llvm.lshr %arg59, %1 : i64
  %6 = llvm.and %5, %2 : i64
  %7 = "llvm.select"(%4, %6, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i64, i64) -> i64
  "llvm.return"(%7) : (i64) -> ()
}
]

def no_shift_xor_multiuse_or_before := [llvm|
{
^0(%arg134 : i32, %arg135 : i32):
  %0 = llvm.mlir.constant(4096 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.and %arg134, %0 : i32
  %3 = llvm.icmp "ne" %1, %2 : i32
  %4 = llvm.or %arg135, %0 : i32
  %5 = "llvm.select"(%3, %arg135, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %6 = llvm.mul %5, %4 : i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def test3_before := [llvm|
{
^0(%arg307 : i1):
  %0 = llvm.mlir.constant(false) : i1
  %1 = llvm.and %arg307, %0 : i1
  "llvm.return"(%1) : (i1) -> ()
}
]

def test_ne_before := [llvm|
{
^0(%arg9 : i32):
  %0 = llvm.mlir.constant(1073741823 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(2 : i32) : i32
  %3 = llvm.and %arg9, %0 : i32
  %4 = llvm.icmp "ne" %3, %1 : i32
  %5 = llvm.shl %arg9, %2 : i32
  %6 = "llvm.select"(%4, %5, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def test9_before := [llvm|
{
^0(%arg0 : i77):
  %0 = llvm.mlir.constant(562949953421310 : i77) : i77
  %1 = llvm.mlir.constant(1 : i77) : i77
  %2 = llvm.and %arg0, %0 : i77
  %3 = llvm.add %2, %1 : i77
  "llvm.return"(%3) : (i77) -> ()
}
]

private def attrVal4Symbol : AttrVal := [mlir_attr_val| @"foo" ]

def ult_rem_zero_before := [llvm|
{
^0(%arg174 : i8):
  %0 = llvm.mlir.constant(7 : i8) : i8
  %1 = llvm.mlir.constant(21 : i8) : i8
  %2 = llvm.mul %arg174, %0 overflow<nuw> : i8
  %3 = llvm.icmp "ult" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

abbrev tctx : Term.Ctx (wcard := 1) (tcard := 1) := (Term.Ctx.empty (wcard := 1))
  
  |>.cons (WidthExpr.var ⟨0, by admit /- proof elided -/
  ⟩)

def and_zext_eq_odd_after := [llvm|
{
^0(%arg31 : i32):
  %0 = llvm.mlir.constant(3 : i32) : i32
  %1 = llvm.icmp "eq" %arg31, %0 : i32
  %2 = llvm.zext %1 : i1 to i32
  "llvm.return"(%2) : (i32) -> ()
}
]

@[simp_denote]
def add_llvm_nsw_flags_8 := [LV| {
  ^entry (%lhs: i8, %rhs: i8):
    %1 = llvm.add %lhs, %rhs overflow<nsw> : i8
    llvm.return %1 : i8
  }]

def oppositesign_after := [llvm|
{
^0(%arg32 : i16, %arg33 : i16):
  %0 = llvm.mlir.constant(-32768 : i16) : i16
  %1 = llvm.mlir.constant(32767 : i16) : i16
  %2 = llvm.or %arg32, %0 : i16
  %3 = llvm.and %arg33, %1 : i16
  %4 = llvm.add %2, %3 overflow<nsw> : i16
  "llvm.return"(%4) : (i16) -> ()
}
]

def llvm_trunc_riscv_32_to_8_nuw_nsw : LLVMPeepholeRewriteRefine 8 [Ty.llvm (.bitvec 32)] :=
  {lhs:= trunc_llvm_32_to_8_nsw_nuw, rhs:= trunc_riscv_32_to_8_nsw_nuw}

def sink (x : TokenStream) : TokenStream :=
  Stream.corec (β := TokenStream) x fun x => (none, x.tail)

def ule_and_min_commute_logical_after := [llvm|
{
^0(%arg200 : i8, %arg201 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.icmp "eq" %arg200, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def t1_exact_before := [llvm|
{
^0(%arg9 : i64):
  %0 = llvm.mlir.constant(63) : i64
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.lshr exact %arg9, %0 : i64
  %3 = llvm.trunc %2 : i64 to i32
  %4 = llvm.sub %1, %3 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def double_icmp_zero_combine : List (Σ Γ, LLVMPeepholeRewriteRefine 1 Γ) :=
  [⟨_, double_icmp_zero_and_combine⟩,
  ⟨_, double_icmp_zero_or_combine⟩]

def and_to_xor1_after := [llvm|
{
^0(%arg119 : i32, %arg120 : i32):
  %0 = llvm.xor %arg119, %arg120 : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

def slt_zero_slt_i1_fail_before := [llvm|
{
^0(%arg4 : i32, %arg5 : i1):
  %0 = llvm.mlir.constant(31 : i32) : i32
  %1 = llvm.zext %arg5 : i1 to i32
  %2 = llvm.lshr %arg4, %0 : i32
  %3 = llvm.icmp "slt" %1, %2 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def bitwise_or_logical_or_icmps_comm3_after := [llvm|
{
^0(%arg175 : i8, %arg176 : i8, %arg177 : i8):
  %0 = llvm.mlir.constant(42 : i8) : i8
  %1 = llvm.mlir.constant(1 : i8) : i8
  %2 = llvm.mlir.constant(true) : i1
  %3 = llvm.icmp "eq" %arg176, %0 : i8
  %4 = llvm.shl %1, %arg177 overflow<nuw> : i8
  %5 = llvm.or %4, %1 : i8
  %6 = llvm.and %arg175, %5 : i8
  %7 = llvm.icmp "ne" %6, %5 : i8
  %8 = "llvm.select"(%7, %2, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%8) : (i1) -> ()
}
]

def TotalOrder.getIx? (ix : Nat) {α : Type} [Hashable α] [BEq α] (toOrder : TotalOrder α) : Option α :=
    toOrder.ix2val[ix]?

def or_eq_notY_eq_0_after := [llvm|
{
^0(%arg45 : i8, %arg46 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.and %arg45, %arg46 : i8
  %2 = llvm.icmp "eq" %1, %0 : i8
  "llvm.return"(%2) : (i1) -> ()
}
]

def test_sub_0_Y_ne_0_after := [llvm|
{
^0(%arg48 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.icmp "ne" %arg48, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def ashrsgt_03_15_before := [llvm|
{
^0(%arg270 : i4):
  %0 = llvm.mlir.constant(3 : i4) : i4
  %1 = llvm.mlir.constant(-1 : i4) : i4
  %2 = llvm.ashr %arg270, %0 : i4
  %3 = llvm.icmp "sgt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

structure Item where
 name : String
 tac : Syntax

def Expr.KInductionCircuits.mkIsLawful_mkN (fsm : Expr) (n : Expr) : SolverM Expr := do
  let out ← mkAppM ``ReflectVerif.BvDecide.KInductionCircuits.IsLawful_mkN #[fsm, n]
  debugCheck out
  return out

def sub_to_add_neg2 : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%x: i64):
      %c = llvm.mlir.constant -2 : i64
      %1 = llvm.sub %x, %c : i64
      llvm.return %1 : i64
  }]
  rhs := [LV| {
    ^entry (%x: i64):
      %c = llvm.mlir.constant 2 : i64
      %1 = llvm.add %x, %c : i64
      llvm.return %1 : i64
  }]

def match_signed_before := [llvm|
{
^0(%arg15 : i64):
  %0 = llvm.mlir.constant(299) : i64
  %1 = llvm.mlir.constant(64) : i64
  %2 = llvm.mlir.constant(19136) : i64
  %3 = llvm.mlir.constant(9) : i64
  %4 = llvm.srem %arg15, %0 : i64
  %5 = llvm.sdiv %arg15, %0 : i64
  %6 = llvm.srem %5, %1 : i64
  %7 = llvm.sdiv %arg15, %2 : i64
  %8 = llvm.srem %7, %3 : i64
  %9 = llvm.mul %6, %0 : i64
  %10 = llvm.add %4, %9 : i64
  %11 = llvm.mul %8, %2 : i64
  %12 = llvm.add %10, %11 : i64
  "llvm.return"(%12) : (i64) -> ()
}
]

instance {n} : ShiftLeft (BitVec n) := ⟨fun x y => x <<< y.toNat⟩

def neg_slt_42_before := [llvm|
{
^0(%arg30 : i128):
  %0 = llvm.mlir.constant(0 : i128) : i128
  %1 = llvm.mlir.constant(42 : i128) : i128
  %2 = llvm.sub %0, %arg30 : i128
  %3 = llvm.icmp "slt" %2, %1 : i128
  "llvm.return"(%3) : (i1) -> ()
}
]

def merge (x y : TokenStream) : ValueStream (BitVec 1) :=
  Stream.corec (β := TokenStream × TokenStream) (x, y) fun ⟨x, y⟩ =>
    match x 0, y 0 with
    | some _, some _ => (some 1, (x.tail, y))
    | some _, none => (some 1, (x.tail, y.tail))
    | none, some _ => (some 0, (x.tail, y.tail))
    | none, none => (none, (x.tail, y.tail))

def trunc_shl_lshr_var_before := [llvm|
{
^0(%arg33 : i64, %arg34 : i64):
  %0 = llvm.mlir.constant(2) : i64
  %1 = llvm.lshr %arg33, %arg34 : i64
  %2 = llvm.shl %1, %0 : i64
  %3 = llvm.trunc %2 : i64 to i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def a_false_implies_b_false2_comm_before := [llvm|
{
^0(%arg0 : i8, %arg1 : i1, %arg2 : i1):
  %0 = llvm.mlir.constant(10 : i8) : i8
  %1 = llvm.mlir.constant(20 : i8) : i8
  %2 = llvm.icmp "ugt" %arg0, %0 : i8
  %3 = llvm.icmp "ugt" %arg0, %1 : i8
  %4 = "llvm.select"(%3, %arg1, %arg2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %5 = llvm.or %4, %2 : i1
  "llvm.return"(%5) : (i1) -> ()
}
]

def masked_icmps_mask_notallzeros_bmask_mixed_negated_6_logical_before := [llvm|
{
^0(%arg57 : i32):
  %0 = llvm.mlir.constant(12 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(15 : i32) : i32
  %3 = llvm.mlir.constant(8 : i32) : i32
  %4 = llvm.mlir.constant(true) : i1
  %5 = llvm.and %arg57, %0 : i32
  %6 = llvm.icmp "eq" %5, %1 : i32
  %7 = llvm.and %arg57, %2 : i32
  %8 = llvm.icmp "ne" %7, %3 : i32
  %9 = "llvm.select"(%6, %4, %8) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%9) : (i1) -> ()
}
]

def t14_x_is_one_after := [llvm|
{
^0(%arg6 : i32, %arg7 : i32):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def lshrugt_03_03_after := [llvm|
{
^0(%arg380 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def or_and_not_constant_commute3_before := [llvm|
{
^0(%arg106 : i32, %arg107 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(-2 : i32) : i32
  %2 = llvm.or %arg106, %arg107 : i32
  %3 = llvm.and %0, %2 : i32
  %4 = llvm.and %1, %arg107 : i32
  %5 = llvm.or %4, %3 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def select_of_anyext_rw : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 32), Ty.llvm (.bitvec 32), Ty.llvm (.bitvec 1)] where
  lhs := [LV| {
    ^entry (%cond: i1, %true_val: i32, %false_val: i32):
      %0 = llvm.select %cond, %true_val, %false_val : i32
      %1 = llvm.sext %0 : i32 to i64
      llvm.return %1 : i64
  }]
  rhs := [LV| {
    ^entry (%cond: i1, %true_val: i32, %false_val: i32):
      %0 = llvm.sext %true_val : i32 to i64
      %1 = llvm.sext %false_val : i32 to i64
      %2 = llvm.select %cond, %0, %1 : i64
      llvm.return %2 : i64
  }]

def or_eq_with_diff_one_logical_before := [llvm|
{
^0(%arg353 : i8):
  %0 = llvm.mlir.constant(13 : i8) : i8
  %1 = llvm.mlir.constant(14 : i8) : i8
  %2 = llvm.mlir.constant(true) : i1
  %3 = llvm.icmp "eq" %arg353, %0 : i8
  %4 = llvm.icmp "eq" %arg353, %1 : i8
  %5 = "llvm.select"(%3, %2, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%5) : (i1) -> ()
}
]

def and_not_or_commute5_after := [llvm|
{
^0(%arg466 : i32, %arg467 : i32, %arg468 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.sdiv %0, %arg466 : i32
  %3 = llvm.sdiv %0, %arg468 : i32
  %4 = llvm.xor %arg467, %3 : i32
  %5 = llvm.and %4, %2 : i32
  %6 = llvm.xor %5, %1 : i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def selection00 : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs:= [LV| {
  ^entry (%arg0: i64):
    %c = llvm.mlir.constant (4) : i64
    %1 = llvm.mul %arg0, %c : i64
    llvm.return %1 : i64
  }]
  rhs:= [LV| {
  ^entry (%arg0: i64):
    %r1 = "builtin.unrealized_conversion_cast" (%arg0) : (i64) -> (!riscv.reg)
    %c = slli %r1, 2 : !riscv.reg
    %rd = "builtin.unrealized_conversion_cast" (%c) : (!riscv.reg) -> (i64)
    llvm.return %rd : i64
  }]

def ofList (vals : List (Option α)) : Stream α :=
  fun i => vals[i]?.join

def eq_nsw_rem_nz_after := [llvm|
{
^0(%arg158 : i8):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def t2_symmetry_after := [llvm|
{
^0(%arg37 : i8, %arg38 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.xor %arg37, %0 : i8
  %2 = llvm.icmp "ule" %arg38, %1 : i8
  "llvm.return"(%2) : (i1) -> ()
}
]

def negative1_logical_before := [llvm|
{
^0(%arg18 : i32, %arg19 : i32):
  %0 = llvm.mlir.constant(2147483647 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(false) : i1
  %3 = llvm.and %arg19, %0 : i32
  %4 = llvm.icmp "slt" %arg18, %3 : i32
  %5 = llvm.icmp "sgt" %arg18, %1 : i32
  %6 = "llvm.select"(%4, %5, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%6) : (i1) -> ()
}
]

def not_or_or_not_commute1_before := [llvm|
{
^0(%arg546 : i32, %arg547 : i32, %arg548 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg547, %0 : i32
  %2 = llvm.xor %arg548, %0 : i32
  %3 = llvm.or %1, %arg546 : i32
  %4 = llvm.or %3, %2 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def ult_umin4_after := [llvm|
{
^0(%arg30 : i32, %arg31 : i32):
  %0 = llvm.mlir.constant(3 : i32) : i32
  %1 = llvm.add %arg30, %0 : i32
  %2 = llvm.icmp "ult" %arg31, %1 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def mul_by_neg_one_const : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%x: i64):
      %c = llvm.mlir.constant (-1) : i64
      %0 = llvm.mul %x, %c : i64
      llvm.return %0 : i64
  }]
  rhs := [LV| {
    ^entry (%x: i64):
      %c = llvm.mlir.constant (0) : i64
      %0 = llvm.sub %c, %x : i64
      llvm.return %0 : i64
  }]

def scalar_i64_lshr_and_signbit_eq_after := [llvm|
{
^0(%arg29 : i64, %arg30 : i64):
  %0 = llvm.mlir.constant(-1) : i64
  %1 = llvm.lshr %arg29, %arg30 : i64
  %2 = llvm.icmp "sgt" %1, %0 : i64
  "llvm.return"(%2) : (i1) -> ()
}
]

def test2_after := [llvm|
{
^0(%arg5 : i1005):
  "llvm.return"(%arg5) : (i1005) -> ()
}
]

def elabDefSignatureFor (dialect : Term) (alts : TSyntax ``matchAltsSig) : CommandElabM Unit := do
  let msg := (return m!"{exceptEmoji ·} Defining operation signature for {dialect} dialect")
  withTraceNode `LeanMLIR.Elab msg (collapsed := false) <| do
    let alts := getMatchAlts alts
    let alts ← do
      alts.mapM fun view => do
        trace[LeanMLIR.Elab] m!"Parsing match alternative with\n\
          \tpatterns: {view.patterns}\n\
          \tsignature: {view.rhs}"
        let rhs ← parseSignature view.rhs
        return { view with rhs }

    |

def or_xor_xor_normal_variant4_before := [llvm|
{
^0(%arg11 : i64, %arg12 : i64):
  %0 = llvm.and %arg12, %arg11 : i64
  %1 = llvm.xor %0, %arg12 : i64
  %2 = llvm.xor %0, %arg11 : i64
  %3 = llvm.or %1, %2 : i64
  "llvm.return"(%3) : (i64) -> ()
}
]

def ashrslt_01_07_exact_after := [llvm|
{
^0(%arg46 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def MLIRTy.i (width : Nat) : MLIRTy φ := MLIRType.int Signedness.Signless width

def t3_before := [llvm|
{
^0(%arg10 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.sub %0, %arg10 overflow<nsw> : i8
  %2 = llvm.icmp "sle" %1, %arg10 : i8
  "llvm.return"(%2) : (i1) -> ()
}
]

List.Nodup in Init.Data.List.Basic

def smear_sign_and_widen_before := [llvm|
{
^0(%arg169 : i8):
  %0 = llvm.mlir.constant(24 : i32) : i32
  %1 = llvm.sext %arg169 : i8 to i32
  %2 = llvm.lshr %1, %0 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def pow2_or_zero_is_negative_commute_before := [llvm|
{
^0(%arg7 : i8):
  %0 = llvm.mlir.constant(42 : i8) : i8
  %1 = llvm.mlir.constant(0 : i8) : i8
  %2 = llvm.mul %0, %arg7 : i8
  %3 = llvm.sub %1, %2 : i8
  %4 = llvm.and %3, %2 : i8
  %5 = llvm.icmp "slt" %4, %1 : i8
  "llvm.return"(%5) : (i1) -> ()
}
]

def Com.ty : Com d Γ eff [t] → d.Ty := fun _ => t

def sgt_swap_and_min_logical_after := [llvm|
{
^0(%arg342 : i8, %arg343 : i8):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def and_orn_xor_after := [llvm|
{
^0(%arg80 : i4, %arg81 : i4):
  %0 = llvm.mlir.constant(-1 : i4) : i4
  %1 = llvm.xor %arg80, %0 : i4
  %2 = llvm.and %arg81, %1 : i4
  "llvm.return"(%2) : (i4) -> ()
}
]

def lshrult_03_02_after := [llvm|
{
^0(%arg333 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def fold_sext_to_and_wrong_after := [llvm|
{
^0(%arg9 : i8):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def not_and_and_or_not_or_or_commute2_after := [llvm|
{
^0(%arg235 : i32, %arg236 : i32, %arg237 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.sdiv %0, %arg237 : i32
  %3 = llvm.xor %2, %arg236 : i32
  %4 = llvm.or %3, %arg235 : i32
  %5 = llvm.xor %4, %1 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def shift_xor_multiuse_cmp_xor_before := [llvm|
{
^0(%arg32 : i32, %arg33 : i32, %arg34 : i32, %arg35 : i32):
  %0 = llvm.mlir.constant(4096 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(2048 : i32) : i32
  %3 = llvm.and %arg32, %0 : i32
  %4 = llvm.icmp "ne" %1, %3 : i32
  %5 = llvm.xor %arg33, %2 : i32
  %6 = "llvm.select"(%4, %arg33, %5) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %7 = "llvm.select"(%4, %arg34, %arg35) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %8 = llvm.mul %6, %7 : i32
  %9 = llvm.mul %8, %5 : i32
  "llvm.return"(%9) : (i32) -> ()
}
]

def add_nsw_before := [llvm|
{
^0(%arg0 : i1, %arg1 : i8):
  %0 = llvm.mlir.constant(7 : i8) : i8
  %1 = llvm.mlir.constant(64 : i8) : i8
  %2 = "llvm.select"(%arg0, %arg1, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  %3 = llvm.add %2, %1 overflow<nsw> : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def const_sub_add_const_before := [llvm|
{
^0(%arg30 : i32):
  %0 = llvm.mlir.constant(8 : i32) : i32
  %1 = llvm.mlir.constant(2 : i32) : i32
  %2 = llvm.sub %0, %arg30 : i32
  %3 = llvm.add %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

class HydrableGeneralize (parsedExpr : Type) (genPred : outParam Type) (genExpr : outParam (Nat → Type)) extends
  HydrableInitialParserState,
  HydrableExistsForall parsedExpr  genPred genExpr,
  HydrableChangePredWidth genPred,
  HydrableReduceWidth parsedExpr genPred genExpr,
  HydrableSynthesizeWithNoPrecondition parsedExpr genPred genExpr,
  HydrableCheckForPreconditions parsedExpr genPred genExpr
  where

def lshrult_03_15_exact_before := [llvm|
{
^0(%arg102 : i4):
  %0 = llvm.mlir.constant(3 : i4) : i4
  %1 = llvm.mlir.constant(-1 : i4) : i4
  %2 = llvm.lshr exact %arg102, %0 : i4
  %3 = llvm.icmp "ult" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def add_nsw_poison_constant_fold_after := [llvm|
{
^0(%arg2 : i1, %arg3 : i8):
  %0 = llvm.mlir.constant(64 : i8) : i8
  %1 = llvm.mlir.constant(-127 : i8) : i8
  %2 = llvm.add %arg3, %0 overflow<nsw> : i8
  %3 = "llvm.select"(%arg2, %2, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%3) : (i8) -> ()
}
]

Trans in Init.Prelude

def trunc_lshr_sext_exact_before := [llvm|
{
^0(%arg45 : i8):
  %0 = llvm.mlir.constant(6 : i32) : i32
  %1 = llvm.sext %arg45 : i8 to i32
  %2 = llvm.lshr exact %1, %0 : i32
  %3 = llvm.trunc %2 : i32 to i8
  "llvm.return"(%3) : (i8) -> ()
}
]

@[simp_denote]
def add_multiuse_riscv_i64 :=
  [LV| {
    ^entry (%x: i64):
    %0 = "li"() {imm = -1 : !i64} : (!i64) -> (!i64)
    %1 = slli %0, 40 : !i64
    %2 = addi %1, 1 : !i64
    %a0  = "builtin.unrealized_conversion_cast" (%x) : (i64) -> (!i64)
    %3 = add %a0, %2 : !i64
    %4 = and %3, %2 : !i64
    %5 = "builtin.unrealized_conversion_cast" (%4) : (!i64) -> (i64)
    llvm.return %5 : i64
  }]

def cMerge (x y : TokenStream) : ValueStream (BitVec 1) × TokenStream :=
  Stream.corec₂ (β := TokenStream × TokenStream) (x, y) fun ⟨x, y⟩ =>
    match x 0, y 0 with
    | some x', some _ => (some 1, some x', (x.tail, y))
    | some x', none => (some 1, some x', (x.tail, y.tail))
    | none, some y' => (some 0, some y', (x.tail, y.tail))
    | none, none => (none, none, (x.tail, y.tail))

instance : Lean.ToExpr RegIndex := inherit

def prove_exact_with_high_mask_after := [llvm|
{
^0(%arg8 : i8, %arg9 : i8):
  %0 = llvm.mlir.constant(2 : i8) : i8
  %1 = llvm.mlir.constant(-2 : i8) : i8
  %2 = llvm.ashr %arg8, %0 : i8
  %3 = llvm.and %2, %1 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def constLLVM39 : Com LLVMPlusRiscV ⟨[]⟩ .pure (.llvm (.bitvec 64)) := [LV| {
  ^entry ():
    %1 = llvm.mlir.constant (39) : i64
    llvm.return %1 : i64
  }]

def lshrult_01_02_before := [llvm|
{
^0(%arg365 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(2 : i4) : i4
  %2 = llvm.lshr %arg365, %0 : i4
  %3 = llvm.icmp "ult" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def and_sequence_30_lhs (w : Nat)   :=
[llvm( w )| {
^bb0(%C1 : _, %Z : _):
  %v1 = llvm.and %Z, %C1
  %v2 = llvm.and %v1, %C1
  %v3 = llvm.and %v2, %C1
  %v4 = llvm.and %v3, %C1
  %v5 = llvm.and %v4, %C1
  %v6 = llvm.and %v5, %C1
  %v7 = llvm.and %v6, %C1
  %v8 = llvm.and %v7, %C1
  %v9 = llvm.and %v8, %C1
  %v10 = llvm.and %v9, %C1
  %v11 = llvm.and %v10, %C1
  %v12 = llvm.and %v11, %C1
  %v13 = llvm.and %v12, %C1
  %v14 = llvm.and %v13, %C1
  %v15 = llvm.and %v14, %C1
  %v16 = llvm.and %v15, %C1
  %v17 = llvm.and %v16, %C1
  %v18 = llvm.and %v17, %C1
  %v19 = llvm.and %v18, %C1
  %v20 = llvm.and %v19, %C1
  %v21 = llvm.and %v20, %C1
  %v22 = llvm.and %v21, %C1
  %v23 = llvm.and %v22, %C1
  %v24 = llvm.and %v23, %C1
  %v25 = llvm.and %v24, %C1
  %v26 = llvm.and %v25, %C1
  %v27 = llvm.and %v26, %C1
  %v28 = llvm.and %v27, %C1
  %v29 = llvm.and %v28, %C1
  %v30 = llvm.and %v29, %C1
  llvm.return %v30
}]

def product.inits_nodup : inits m₁ m₂ |>.toList.Nodup :=

def sub {Γ : Ctxt (Ty q)} (x y : Var Γ .modLike)
    : Expr (ModArith q) Γ .pure .modLike :=
  Expr.mk
    (op      := .sub)
    (ty_eq   := rfl)
    (eff_le  := by admit /- proof elided -/
    )
    (args    := .cons x (.cons y .nil))
    (regArgs := .nil)

def constLLVM43 : Com LLVMPlusRiscV ⟨[]⟩ .pure (.llvm (.bitvec 64)) := [LV| {
  ^entry ():
    %1 = llvm.mlir.constant (43) : i64
    llvm.return %1 : i64
  }]

def or_not_xor_common_op_commute6_before := [llvm|
{
^0(%arg89 : i8, %arg90 : i8, %arg91 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.mlir.constant(-1 : i8) : i8
  %2 = llvm.sub %0, %arg91 : i8
  %3 = llvm.xor %arg89, %1 : i8
  %4 = llvm.xor %arg90, %arg89 : i8
  %5 = llvm.or %2, %3 : i8
  %6 = llvm.or %4, %5 : i8
  "llvm.return"(%6) : (i8) -> ()
}
]

def ashrslt_01_15_exact_before := [llvm|
{
^0(%arg38 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(-1 : i4) : i4
  %2 = llvm.ashr exact %arg38, %0 : i4
  %3 = llvm.icmp "slt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def constLLVM33 : Com LLVMPlusRiscV ⟨[]⟩ .pure (.llvm (.bitvec 64)) := [LV| {
  ^entry ():
    %1 = llvm.mlir.constant (33) : i64
    llvm.return %1 : i64
  }]

def packedBitVecToFpSubstitutionValue (map: Std.HashMap Nat BVExpr.PackedBitVec) :
    Std.HashMap Nat (SubstitutionValue FpExpr) :=
  Std.HashMap.ofList (List.map (fun item => (item.fst, SubstitutionValue.packedBV item.snd)) map.toList)

def zext_sext_add_icmp_ne_1_after := [llvm|
{
^0(%arg70 : i1, %arg71 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.xor %arg70, %0 : i1
  %2 = llvm.or %arg71, %1 : i1
  "llvm.return"(%2) : (i1) -> ()
}
]

def lshrult_01_05_after := [llvm|
{
^0(%arg362 : i4):
  %0 = llvm.mlir.constant(-6 : i4) : i4
  %1 = llvm.icmp "ult" %arg362, %0 : i4
  "llvm.return"(%1) : (i1) -> ()
}
]

def NFA.msbLang : Language (BitVec 1) := { bvs  | bvs.getLast? = some 1 }

@[simp_denote] def RegionRet (t : Arith.Ty) {Γ : Ctxt Arith.Ty} (v : Var Γ t) :
    Com ScfArith Γ .impure t := .ret v

@[simp_llvm_option]
def urem {w : Nat} (x y : IntW w) : IntW w := do
  let x' ← x
  let y' ← y
  urem? x' y'

def test2_before := [llvm|
{
^0(%arg11 : i47):
  %0 = llvm.mlir.constant(-70368744177664 : i47) : i47
  %1 = llvm.xor %arg11, %0 : i47
  %2 = llvm.add %1, %0 : i47
  "llvm.return"(%2) : (i47) -> ()
}
]

abbrev Expr.outContext (_ : Expr d Γ eff ts) : Ctxt d.Ty :=
  ts ++ Γ

def lshrult_03_14_exact_after := [llvm|
{
^0(%arg103 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def vars [DecidableEq α] : Circuit α → List α
  | tru => []
  | fals => []
  | var _ x => [x]
  | and c₁ c₂ => (vars c₁ ++ vars c₂).dedup
  | or c₁ c₂ => (vars c₁ ++ vars c₂).dedup
  | xor c₁ c₂ => (vars c₁ ++ vars c₂).dedup

def lshrult_01_13_exact_after := [llvm|
{
^0(%arg136 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def xor_to_xor2_after := [llvm|
{
^0(%arg83 : i32, %arg84 : i32):
  %0 = llvm.xor %arg83, %arg84 : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

def alive_AndOrXor_2627_tgt  (w : Nat)  :=
[llvm( w )| {
^bb0(%a : _, %c : _, %b : _):
  %v1 = llvm.mlir.constant -1
  %v2 = llvm.xor %a, %v1
  %v3 = llvm.and %v2, %b
  %v4 = llvm.xor %a, %c
  %v5 = llvm.or %a, %b
  %v6 = llvm.xor %v3, %c
  llvm.return %v6
}]

def and_orn_xor_before := [llvm|
{
^0(%arg80 : i4, %arg81 : i4):
  %0 = llvm.mlir.constant(-1 : i4) : i4
  %1 = llvm.xor %arg80, %arg81 : i4
  %2 = llvm.xor %arg80, %0 : i4
  %3 = llvm.or %2, %arg81 : i4
  %4 = llvm.and %3, %1 : i4
  "llvm.return"(%4) : (i4) -> ()
}
]

def test_zext4_after := [llvm|
{
^0(%arg35 : i1, %arg36 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.xor %arg36, %0 : i1
  %2 = "llvm.select"(%1, %0, %arg35) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %3 = llvm.zext %2 : i1 to i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def masked_icmps_mask_notallzeros_bmask_mixed_negated_4_after := [llvm|
{
^0(%arg62 : i32):
  %0 = llvm.mlir.constant(15 : i32) : i32
  %1 = llvm.mlir.constant(8 : i32) : i32
  %2 = llvm.and %arg62, %0 : i32
  %3 = llvm.icmp "ne" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

List.range in Init.Data.List.Basic

def scalar_i32_signbit_lshr_and_ne_before := [llvm|
{
^0(%arg27 : i32, %arg28 : i32):
  %0 = llvm.mlir.constant(-2147483648 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.lshr %0, %arg28 : i32
  %3 = llvm.and %2, %arg27 : i32
  %4 = llvm.icmp "ne" %3, %1 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def positive_samevar_shlnsw_ashrexact_after := [llvm|
{
^0(%arg37 : i8, %arg38 : i8):
  "llvm.return"(%arg37) : (i8) -> ()
}
]

def test_mul_mul_const_LHS := [mod_arith q, hq| {
  ^bb0(%x : !R):
    %c0 = mod_arith.constant 12 : !R
    %c1 = mod_arith.constant 34 : !R
    %mul = mod_arith.mul %x, %c0 : !R
    %mul2 = mod_arith.mul %mul, %c1 : !R
    return %mul2 : !R
}]

def ne_smax4_before := [llvm|
{
^0(%arg41 : i32, %arg42 : i32):
  %0 = llvm.mlir.constant(3 : i32) : i32
  %1 = llvm.add %arg41, %0 : i32
  %2 = llvm.icmp "sgt" %arg42, %1 : i32
  %3 = "llvm.select"(%2, %arg42, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %4 = llvm.icmp "ne" %1, %3 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def and_or2_after := [llvm|
{
^0(%arg200 : i1, %arg201 : i1, %arg202 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.mlir.constant(false) : i1
  %2 = "llvm.select"(%arg202, %0, %arg200) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %3 = "llvm.select"(%arg201, %2, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%3) : (i1) -> ()
}
]

BitVec.cast in Init.Data.BitVec.Basic

def slt_zero_ne_ne_0_before := [llvm|
{
^0(%arg5 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.mlir.constant(31 : i32) : i32
  %2 = llvm.icmp "ne" %arg5, %0 : i32
  %3 = llvm.zext %2 : i1 to i32
  %4 = llvm.lshr %arg5, %1 : i32
  %5 = llvm.icmp "ne" %3, %4 : i32
  "llvm.return"(%5) : (i1) -> ()
}
]

def lshrult_03_00_before := [llvm|
{
^0(%arg335 : i4):
  %0 = llvm.mlir.constant(3 : i4) : i4
  %1 = llvm.mlir.constant(0 : i4) : i4
  %2 = llvm.lshr %arg335, %0 : i4
  %3 = llvm.icmp "ult" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def lshrult_03_12_exact_after := [llvm|
{
^0(%arg105 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def test4_after := [llvm|
{
^0(%arg1 : i8):
  %0 = llvm.mlir.constant(127 : i8) : i8
  %1 = llvm.icmp "ne" %arg1, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def ashrsgt_02_08_before := [llvm|
{
^0(%arg293 : i4):
  %0 = llvm.mlir.constant(2 : i4) : i4
  %1 = llvm.mlir.constant(-8 : i4) : i4
  %2 = llvm.ashr %arg293, %0 : i4
  %3 = llvm.icmp "sgt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def ule_or_not_min_logical_after := [llvm|
{
^0(%arg270 : i427, %arg271 : i427):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def nth {α : Type u} {n : Nat} (l : LengthIndexedList α n) (i : Fin n) : α :=
  match l, i with
  | LengthIndexedList.cons x _, ⟨0, _⟩ => x
  | LengthIndexedList.cons _ xs, ⟨i + 1, h⟩ => nth xs ⟨i, Nat.succ_lt_succ_iff.1 h⟩

def sge_swap_or_not_max_after := [llvm|
{
^0(%arg312 : i8, %arg313 : i8):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def icmp_shl_nsw_eq_before := [llvm|
{
^0(%arg26 : i32):
  %0 = llvm.mlir.constant(5 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.shl %arg26, %0 overflow<nsw> : i32
  %3 = llvm.icmp "eq" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def test_and1_before := [llvm|
{
^0(%arg52 : i32, %arg53 : i32):
  %0 = llvm.mlir.constant(2147483647 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.and %arg53, %0 : i32
  %3 = llvm.icmp "sge" %arg52, %1 : i32
  %4 = llvm.icmp "slt" %arg52, %2 : i32
  %5 = llvm.and %3, %4 : i1
  "llvm.return"(%5) : (i1) -> ()
}
]

def foo_before := [llvm|
{
^0(%arg0 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.mlir.constant(7 : i32) : i32
  %2 = llvm.or %0, %1 : i32
  %3 = llvm.and %arg0, %2 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def select_icmp_ne_0_and_1073741824_or_8_before := [llvm|
{
^0(%arg195 : i32, %arg196 : i8):
  %0 = llvm.mlir.constant(1073741824 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(8 : i8) : i8
  %3 = llvm.and %arg195, %0 : i32
  %4 = llvm.icmp "ne" %1, %3 : i32
  %5 = llvm.or %arg196, %2 : i8
  %6 = "llvm.select"(%4, %arg196, %5) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%6) : (i8) -> ()
}
]

def and_not_or_commute9_after := [llvm|
{
^0(%arg454 : i32, %arg455 : i32, %arg456 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.sdiv %0, %arg454 : i32
  %3 = llvm.sdiv %0, %arg455 : i32
  %4 = llvm.sdiv %0, %arg456 : i32
  %5 = llvm.xor %3, %4 : i32
  %6 = llvm.and %5, %2 : i32
  %7 = llvm.xor %6, %1 : i32
  "llvm.return"(%7) : (i32) -> ()
}
]

def test1_after := [llvm|
{
^0(%arg2 : i33, %arg3 : i33):
  %0 = llvm.mlir.constant(65280 : i33) : i33
  %1 = llvm.mlir.constant(0 : i33) : i33
  %2 = llvm.xor %arg2, %arg3 : i33
  %3 = llvm.and %2, %0 : i33
  %4 = llvm.icmp "ne" %3, %1 : i33
  "llvm.return"(%4) : (i1) -> ()
}
]

def test_invert_demorgan_or3_after := [llvm|
{
^0(%arg13 : i32, %arg14 : i32):
  %0 = llvm.mlir.constant(178206 : i32) : i32
  %1 = llvm.mlir.constant(-196608 : i32) : i32
  %2 = llvm.mlir.constant(-1506 : i32) : i32
  %3 = llvm.mlir.constant(-917760 : i32) : i32
  %4 = llvm.mlir.constant(-716213 : i32) : i32
  %5 = llvm.mlir.constant(-1114112 : i32) : i32
  %6 = llvm.mlir.constant(-196112 : i32) : i32
  %7 = llvm.icmp "ne" %arg13, %0 : i32
  %8 = llvm.add %arg14, %1 : i32
  %9 = llvm.icmp "ult" %8, %2 : i32
  %10 = llvm.add %arg14, %3 : i32
  %11 = llvm.icmp "ult" %10, %4 : i32
  %12 = llvm.add %arg14, %5 : i32
  %13 = llvm.icmp "ult" %12, %6 : i32
  %14 = llvm.and %7, %9 : i1
  %15 = llvm.and %14, %11 : i1
  %16 = llvm.and %15, %13 : i1
  "llvm.return"(%16) : (i1) -> ()
}
]

def trunc_sel_larger_sext_after := [llvm|
{
^0(%arg85 : i32, %arg86 : i1):
  %0 = llvm.mlir.constant(42) : i64
  %1 = llvm.trunc %arg85 : i32 to i16
  %2 = llvm.sext %1 : i16 to i64
  %3 = "llvm.select"(%arg86, %2, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i64, i64) -> i64
  "llvm.return"(%3) : (i64) -> ()
}
]

def lshr_by_const_cmp_sge_value_before := [llvm|
{
^0(%arg7 : i32):
  %0 = llvm.mlir.constant(3 : i32) : i32
  %1 = llvm.lshr %arg7, %0 : i32
  %2 = llvm.icmp "sge" %1, %arg7 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def PR45977_f1_after := [llvm|
{
^0(%arg140 : i32, %arg141 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg140, %0 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def List.Vector.transport (v : Vector α m) (f : Fin n → Fin m) : Vector α n :=
  Vector.ofFn fun i => v.get (f i)

def slt_swap_and_not_max_logical_after := [llvm|
{
^0(%arg116 : i8, %arg117 : i8):
  %0 = llvm.icmp "sgt" %arg117, %arg116 : i8
  "llvm.return"(%0) : (i1) -> ()
}
]

Monad in Init.Prelude

def test1_after := [llvm|
{
^0(%arg14 : i32, %arg15 : i32):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def signed_sign_bit_extract_trunc_after := [llvm|
{
^0(%arg1 : i64):
  %0 = llvm.mlir.constant(0) : i64
  %1 = llvm.icmp "slt" %arg1, %0 : i64
  "llvm.return"(%1) : (i1) -> ()
}
]

def foo_after := [llvm|
{
^0(%arg54 : i32):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.mlir.constant(20 : i32) : i32
  %2 = llvm.mlir.constant(-20 : i32) : i32
  %3 = llvm.icmp "sgt" %arg54, %0 : i32
  %4 = "llvm.select"(%3, %1, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %5 = llvm.add %arg54, %4 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def scalar_i16_signbit_lshr_and_eq_before := [llvm|
{
^0(%arg33 : i16, %arg34 : i16):
  %0 = llvm.mlir.constant(-32768 : i16) : i16
  %1 = llvm.mlir.constant(0 : i16) : i16
  %2 = llvm.lshr %0, %arg34 : i16
  %3 = llvm.and %2, %arg33 : i16
  %4 = llvm.icmp "eq" %3, %1 : i16
  "llvm.return"(%4) : (i1) -> ()
}
]

def positive_trunc_base_logical_after := [llvm|
{
^0(%arg38 : i32):
  %0 = llvm.mlir.constant(65408 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.and %arg38, %0 : i32
  %3 = llvm.icmp "eq" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def bswap_and_mask_1_after := [llvm|
{
^0(%arg19 : i64):
  %0 = llvm.mlir.constant(56) : i64
  %1 = llvm.mlir.constant(40) : i64
  %2 = llvm.mlir.constant(65280) : i64
  %3 = llvm.lshr %arg19, %0 : i64
  %4 = llvm.lshr %arg19, %1 : i64
  %5 = llvm.and %4, %2 : i64
  %6 = llvm.or disjoint %5, %3 : i64
  "llvm.return"(%6) : (i64) -> ()
}
]

def test12_before := [llvm|
{
^0(%arg196 : i8):
  %0 = llvm.mlir.constant(4 : i8) : i8
  %1 = llvm.mlir.constant(0 : i8) : i8
  %2 = llvm.xor %arg196, %0 : i8
  %3 = llvm.icmp "ne" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def masked_icmps_mask_notallzeros_bmask_mixed_1b_logical_after := [llvm|
{
^0(%arg91 : i32):
  %0 = llvm.mlir.constant(14 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(3 : i32) : i32
  %3 = llvm.mlir.constant(1 : i32) : i32
  %4 = llvm.and %arg91, %0 : i32
  %5 = llvm.icmp "ne" %4, %1 : i32
  %6 = llvm.and %arg91, %2 : i32
  %7 = llvm.icmp "eq" %6, %3 : i32
  %8 = llvm.and %5, %7 : i1
  "llvm.return"(%8) : (i1) -> ()
}
]

def test20_after := [llvm|
{
^0(%arg277 : i8):
  %0 = llvm.mlir.constant(7 : i8) : i8
  %1 = llvm.lshr %arg277, %0 : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def masked_bit_clear_commute_after := [llvm|
{
^0(%arg77 : i32, %arg78 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.srem %0, %arg77 : i32
  %4 = llvm.xor %3, %1 : i32
  %5 = llvm.lshr %4, %arg78 : i32
  %6 = llvm.and %5, %2 : i32
  "llvm.return"(%6) : (i32) -> ()
}
]

List.Sublist in Init.Data.List.Basic

def test_after := [llvm|
{
^0(%arg0 : i26):
  "llvm.return"(%arg0) : (i26) -> ()
}
]

def llvm_add_lower_riscv_nuw_nsw_flag_16 : LLVMPeepholeRewriteRefine 16 [Ty.llvm (.bitvec 16), Ty.llvm (.bitvec 16)] where
  lhs:= add_llvm_nsw_nuw_flags_16
  rhs:= add_riscv_16

Lean.SyntaxNodeKinds in Init.Prelude

def xor_lshr_multiuse_after := [llvm|
{
^0(%arg596 : i8, %arg597 : i8, %arg598 : i8, %arg599 : i8):
  %0 = llvm.lshr %arg596, %arg599 : i8
  %1 = llvm.xor %0, %arg598 : i8
  %2 = llvm.xor %arg596, %arg597 : i8
  %3 = llvm.lshr %2, %arg599 : i8
  %4 = llvm.xor %3, %arg598 : i8
  %5 = llvm.sdiv %1, %4 : i8
  "llvm.return"(%5) : (i8) -> ()
}
]

def positive_samevar_shlnuwnsw_lshrexact_after := [llvm|
{
^0(%arg27 : i8, %arg28 : i8):
  "llvm.return"(%arg27) : (i8) -> ()
}
]

Sum.elim in Init.Data.Sum.Basic

def test_logical_before := [llvm|
{
^0(%arg0 : i32):
  %0 = llvm.mlir.constant(34 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.mlir.constant(false) : i1
  %3 = llvm.icmp "ne" %arg0, %0 : i32
  %4 = llvm.icmp "sgt" %arg0, %1 : i32
  %5 = "llvm.select"(%3, %4, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%5) : (i1) -> ()
}
]

def select_0_1 : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 1)] where
  lhs := [LV| {
    ^entry (%c: i1):
      %t = llvm.mlir.constant (0) : i64
      %f = llvm.mlir.constant (1) : i64
      %0 = llvm.select %c, %t, %f : i64
      llvm.return %0 : i64
  }]
  rhs := [LV| {
    ^entry (%c: i1):
      %0 = llvm.not %c : i1
      %1 = llvm.zext %0: i1 to i64
      llvm.return %1 : i64
  }]

def llvm_mul_lower_riscv_nsw_flag_32 : LLVMPeepholeRewriteRefine 32 [Ty.llvm (.bitvec 32), Ty.llvm (.bitvec 32)] where
  lhs := mul_llvm_nsw_32
  rhs := mul_riscv_32

instance : Inhabited (
          {lets : Lets d Γstart .pure Γ} →
          State d lets →
          {ts : RegionSignature d.Ty} →
          (rs : HVector (fun t => Com d t.1 .impure t.2) ts) →
          { rs' : HVector (fun t => Com d t.1 .impure t.2) ts // HVector.denote rs =
            HVector.denote rs' }) where
  default := fun _s _ts rs => ⟨rs, rfl⟩

def trunc_equality_nsw_zext_after := [llvm|
{
^0(%arg16 : i32, %arg17 : i8):
  %0 = llvm.zext %arg17 : i8 to i32
  %1 = llvm.icmp "ne" %arg16, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def lshrugt_01_08_exact_before := [llvm|
{
^0(%arg213 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(-8 : i4) : i4
  %2 = llvm.lshr exact %arg213, %0 : i4
  %3 = llvm.icmp "ugt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def a_true_implies_b_true2_before := [llvm|
{
^0(%arg30 : i8, %arg31 : i1, %arg32 : i1):
  %0 = llvm.mlir.constant(20 : i8) : i8
  %1 = llvm.mlir.constant(10 : i8) : i8
  %2 = llvm.icmp "ugt" %arg30, %0 : i8
  %3 = llvm.icmp "ugt" %arg30, %1 : i8
  %4 = "llvm.select"(%3, %arg31, %arg32) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %5 = llvm.and %2, %4 : i1
  "llvm.return"(%5) : (i1) -> ()
}
]

def udiv_exact_eq_1_before := [llvm|
{
^0(%arg10 : i8, %arg11 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.udiv exact %arg10, %arg11 : i8
  %2 = llvm.icmp "ne" %1, %0 : i8
  "llvm.return"(%2) : (i1) -> ()
}
]

def sub_zext_trunc_lshr_after := [llvm|
{
^0(%arg15 : i64):
  %0 = llvm.mlir.constant(16 : i32) : i32
  %1 = llvm.mlir.constant(31 : i32) : i32
  %2 = llvm.mlir.constant(10 : i32) : i32
  %3 = llvm.trunc %arg15 : i64 to i32
  %4 = llvm.shl %3, %0 : i32
  %5 = llvm.ashr %4, %1 : i32
  %6 = llvm.add %5, %2 overflow<nsw> : i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def ashrsgt_01_04_exact_after := [llvm|
{
^0(%arg97 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def a_true_implies_b_true2_comm_before := [llvm|
{
^0(%arg27 : i8, %arg28 : i1, %arg29 : i1):
  %0 = llvm.mlir.constant(20 : i8) : i8
  %1 = llvm.mlir.constant(10 : i8) : i8
  %2 = llvm.icmp "ugt" %arg27, %0 : i8
  %3 = llvm.icmp "ugt" %arg27, %1 : i8
  %4 = "llvm.select"(%3, %arg28, %arg29) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %5 = llvm.and %4, %2 : i1
  "llvm.return"(%5) : (i1) -> ()
}
]

def PR45977_f2_before := [llvm|
{
^0(%arg138 : i32, %arg139 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.or %arg138, %arg139 : i32
  %2 = llvm.xor %arg139, %0 : i32
  %3 = llvm.or %arg138, %2 : i32
  %4 = llvm.xor %1, %3 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def ult_rem_nz_nsw_before := [llvm|
{
^0(%arg171 : i8):
  %0 = llvm.mlir.constant(5 : i8) : i8
  %1 = llvm.mlir.constant(21 : i8) : i8
  %2 = llvm.mul %arg171, %0 overflow<nsw,nuw> : i8
  %3 = llvm.icmp "ult" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

abbrev Width φ := ConcreteOrMVar Nat φ

def n11_wrong_pred3_after := [llvm|
{
^0(%arg8 : i8, %arg9 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.icmp "ne" %arg8, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

structure CliTest where
  name : Name
  mvars : Nat
  context : MContext mvars
  ty : MTy mvars
  eff : EffectKind
  code : MCom mvars context eff [ty]

def t15_before := [llvm|
{
^0(%arg198 : i32, %arg199 : i32):
  %0 = llvm.shl %arg198, %arg199 overflow<nuw> : i32
  %1 = llvm.udiv %0, %arg198 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def test_logical_before := [llvm|
{
^0(%arg0 : i32):
  %0 = llvm.mlir.constant(13 : i32) : i32
  %1 = llvm.mlir.constant(15 : i32) : i32
  %2 = llvm.mlir.constant(false) : i1
  %3 = llvm.icmp "ugt" %arg0, %0 : i32
  %4 = llvm.icmp "eq" %arg0, %1 : i32
  %5 = "llvm.select"(%3, %4, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%5) : (i1) -> ()
}
]

def sub_0xffffffffff_i64_test : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := sub_0xffffffffff_llvm_i64
  rhs :=  sub_0xffffffffff_riscv_i64

def lshrugt_01_09_exact_after := [llvm|
{
^0(%arg212 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def positive_biggerShl_before := [llvm|
{
^0(%arg34 : i32):
  %0 = llvm.mlir.constant(10 : i32) : i32
  %1 = llvm.mlir.constant(5 : i32) : i32
  %2 = llvm.shl %arg34, %0 : i32
  %3 = llvm.lshr %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def scalar_i32_shl_and_negC_eq_after := [llvm|
{
^0(%arg31 : i32, %arg32 : i32):
  %0 = llvm.mlir.constant(262144 : i32) : i32
  %1 = llvm.shl %arg31, %arg32 : i32
  %2 = llvm.icmp "ult" %1, %0 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def scalar_i32_signbit_shl_and_eq_X_is_constant2_after := [llvm|
{
^0(%arg4 : i32):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def trunc_unsigned_nuw_after := [llvm|
{
^0(%arg60 : i16, %arg61 : i16):
  %0 = llvm.icmp "ult" %arg60, %arg61 : i16
  "llvm.return"(%0) : (i1) -> ()
}
]

def ashrsgt_03_05_exact_after := [llvm|
{
^0(%arg64 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def shl_lshr_and_exact_after := [llvm|
{
^0(%arg88 : i32, %arg89 : i32, %arg90 : i32):
  %0 = llvm.lshr %arg90, %arg89 : i32
  %1 = llvm.and %0, %arg88 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def ult_rem_zero_after := [llvm|
{
^0(%arg174 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.icmp "ult" %arg174, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def add_const_add_const_after := [llvm|
{
^0(%arg71 : i32):
  %0 = llvm.mlir.constant(10 : i32) : i32
  %1 = llvm.add %arg71, %0 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def substitute_constant_and_eq_eq_commute_logical_after := [llvm|
{
^0(%arg316 : i8, %arg317 : i8):
  %0 = llvm.mlir.constant(42 : i8) : i8
  %1 = llvm.icmp "eq" %arg316, %0 : i8
  %2 = llvm.icmp "eq" %arg317, %0 : i8
  %3 = llvm.and %1, %2 : i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def bitwise_and_logical_and_masked_icmp_allzeros_after := [llvm|
{
^0(%arg147 : i1, %arg148 : i32):
  %0 = llvm.mlir.constant(15 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(false) : i1
  %3 = llvm.and %arg148, %0 : i32
  %4 = llvm.icmp "eq" %3, %1 : i32
  %5 = "llvm.select"(%4, %arg147, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%5) : (i1) -> ()
}
]

@[simp_denote]
def sub_riscv_self_64 := [LV| {
  ^entry (%x: i64):
    %0 = "builtin.unrealized_conversion_cast"(%x) : (i64) -> (!i64)
    %2 = sub %0, %0 : !i64
    %3 = "builtin.unrealized_conversion_cast"(%2) : (!i64) -> (i64)
    llvm.return %3 : i64
  }]

def logical_and_implies_before := [llvm|
{
^0(%arg249 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.mlir.constant(42 : i32) : i32
  %2 = llvm.mlir.constant(false) : i1
  %3 = llvm.icmp "ne" %arg249, %0 : i32
  %4 = llvm.icmp "ne" %arg249, %1 : i32
  %5 = "llvm.select"(%3, %4, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%5) : (i1) -> ()
}
]

def shl_add_log_may_cause_poison_pr62175_with_nsw_after := [llvm|
{
^0(%arg0 : i8, %arg1 : i8):
  %0 = llvm.mlir.constant(2 : i8) : i8
  %1 = llvm.add %arg0, %0 : i8
  %2 = llvm.shl %arg1, %1 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def getNegativeExamples [H : HydrableGetNegativeExamples parsedExpr genPred genExpr] (bvExpr: BoolExpr genPred) (numEx: Nat) :
              GeneralizerStateM parsedExpr genPred (List (Std.HashMap Nat BVExpr.PackedBitVec)) := do
  let targetExpr := BoolExpr.not bvExpr
  return (← helper targetExpr numEx)
  where
        helper (expr: BoolExpr genPred) (depth : Nat)
          : GeneralizerStateM parsedExpr  genPred (List (Std.HashMap Nat BVExpr.PackedBitVec)) := do
        match depth with
          | 0 => return []
          | n + 1 =>
              let solution ← solve expr

              match solution with
              | none => return []
              | some assignment =>
                   let newConstraints := assignment.toList.map (fun c => BoolExpr.not (H.eq (H.genExprVar c.fst) (H.genExprConst c.snd.bv)))
                   let res ← helper (bigAnd <| expr::newConstraints) n
                   return [assignment] ++ res

def urem_pow2_to_mask_32 : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%x: i64):
      %c = llvm.mlir.constant (32) : i64
      %0 = llvm.urem %x, %c : i64
      llvm.return %0 : i64
  }]
  rhs := [LV| {
    ^entry (%x: i64):
      %c = llvm.mlir.constant (31) : i64
      %0 = llvm.and %x, %c : i64
      llvm.return %0 : i64
  }]

def lshr_add_fail_after := [llvm|
{
^0(%arg15 : i8):
  %0 = llvm.mlir.constant(16 : i8) : i8
  %1 = llvm.mlir.constant(1 : i8) : i8
  %2 = llvm.mlir.constant(7 : i8) : i8
  %3 = llvm.lshr %0, %arg15 : i8
  %4 = llvm.add %arg15, %1 : i8
  %5 = llvm.lshr %2, %4 : i8
  %6 = llvm.add %3, %5 overflow<nsw,nuw> : i8
  "llvm.return"(%6) : (i8) -> ()
}
]

def test_sub_nuw__nuw_is_safe_after := [llvm|
{
^0(%arg26 : i32):
  %0 = llvm.mlir.constant(2147483647 : i32) : i32
  %1 = llvm.mlir.constant(-2147483648 : i32) : i32
  %2 = llvm.and %arg26, %0 : i32
  %3 = llvm.sub %1, %2 overflow<nuw> : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def test2_after := [llvm|
{
^0(%arg59 : i32):
  %0 = llvm.mlir.constant(39 : i32) : i32
  %1 = llvm.and %arg59, %0 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def PR42691_3_logical_after := [llvm|
{
^0(%arg338 : i32):
  %0 = llvm.mlir.constant(-2147483647 : i32) : i32
  %1 = llvm.icmp "ult" %arg338, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def tryFactorization_xor_ashr_lshr_before := [llvm|
{
^0(%arg40 : i32):
  %0 = llvm.mlir.constant(-3 : i32) : i32
  %1 = llvm.mlir.constant(5 : i32) : i32
  %2 = llvm.ashr %0, %arg40 : i32
  %3 = llvm.lshr %1, %arg40 : i32
  %4 = llvm.xor %2, %3 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def shift_trunc_wrong_cmp_after := [llvm|
{
^0(%arg0 : i32):
  %0 = llvm.mlir.constant(24 : i32) : i32
  %1 = llvm.mlir.constant(1 : i8) : i8
  %2 = llvm.lshr %arg0, %0 : i32
  %3 = llvm.trunc %2 overflow<nuw> : i32 to i8
  %4 = llvm.icmp "slt" %3, %1 : i8
  "llvm.return"(%4) : (i1) -> ()
}
]

def irc_constants_C1Minus2MinusC2_0_1 : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%a: i64):
      %c1 = llvm.mlir.constant (0) : i64
      %c2 = llvm.mlir.constant (1) : i64
      %0 = llvm.sub %c1, %a : i64
      %1 = llvm.sub %0, %c2 : i64
      llvm.return %1 : i64
  }]
  rhs := [LV| {
    ^entry (%a: i64):
      %c1 = llvm.mlir.constant (0) : i64
      %c2 = llvm.mlir.constant (1) : i64
      %0 = llvm.sub %c1, %c2 : i64
      %1 = llvm.sub %0, %a : i64
      llvm.return %1 : i64
  }]

def not_mul_of_bool_commute_after := [llvm|
{
^0(%arg87 : i32, %arg88 : i32):
  %0 = llvm.mlir.constant(30 : i32) : i32
  %1 = llvm.mlir.constant(255 : i32) : i32
  %2 = llvm.lshr %arg87, %0 : i32
  %3 = llvm.and %arg88, %1 : i32
  %4 = llvm.mul %3, %2 overflow<nsw,nuw> : i32
  %5 = llvm.icmp "ugt" %4, %1 : i32
  "llvm.return"(%5) : (i1) -> ()
}
]

def test15d_after := [llvm|
{
^0(%arg24 : i32):
  %0 = llvm.mlir.constant(16 : i32) : i32
  %1 = llvm.and %arg24, %0 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def ex1_post_cse_post_dce :
  { com : Com Ex ∅ .pure [.nat] // ∀ V, ex1_post_cse.val.denote V = com.denote V } :=
    (DCE.dce' ex1_post_cse.val)

def lshrugt_02_14_after := [llvm|
{
^0(%arg385 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def negative3_before := [llvm|
{
^0(%arg11 : i32, %arg12 : i32, %arg13 : i32):
  %0 = llvm.mlir.constant(2147483647 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.and %arg13, %0 : i32
  %3 = llvm.icmp "slt" %arg11, %2 : i32
  %4 = llvm.icmp "sge" %arg12, %1 : i32
  %5 = llvm.and %3, %4 : i1
  "llvm.return"(%5) : (i1) -> ()
}
]

LawfulMonad in Init.Control.Lawful.Basic

def xor_icmp_invalid_range_after := [llvm|
{
^0(%arg3 : i8):
  %0 = llvm.mlir.constant(-5 : i8) : i8
  %1 = llvm.mlir.constant(0 : i8) : i8
  %2 = llvm.and %arg3, %0 : i8
  %3 = llvm.icmp "ne" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def slt_swap_and_not_max_logical_before := [llvm|
{
^0(%arg116 : i8, %arg117 : i8):
  %0 = llvm.mlir.constant(127 : i8) : i8
  %1 = llvm.mlir.constant(false) : i1
  %2 = llvm.icmp "sgt" %arg117, %arg116 : i8
  %3 = llvm.icmp "ne" %arg116, %0 : i8
  %4 = "llvm.select"(%2, %3, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def positive_sameconst_shlnuw_ashrexact_before := [llvm|
{
^0(%arg31 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.ashr exact %arg31, %0 : i8
  %2 = llvm.shl %1, %0 overflow<nuw> : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def main6b_before := [llvm|
{
^0(%arg92 : i32):
  %0 = llvm.mlir.constant(7 : i32) : i32
  %1 = llvm.mlir.constant(3 : i32) : i32
  %2 = llvm.mlir.constant(16 : i32) : i32
  %3 = llvm.mlir.constant(0 : i32) : i32
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.and %arg92, %0 : i32
  %6 = llvm.icmp "eq" %5, %1 : i32
  %7 = llvm.and %arg92, %2 : i32
  %8 = llvm.icmp "ne" %7, %3 : i32
  %9 = llvm.and %6, %8 : i1
  %10 = "llvm.select"(%9, %3, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%10) : (i32) -> ()
}
]

def test11b_before := [llvm|
{
^0(%arg101 : i32, %arg102 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg102, %arg101 : i32
  %2 = llvm.xor %arg101, %0 : i32
  %3 = llvm.xor %2, %arg102 : i32
  %4 = llvm.and %3, %1 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def set_bits_after := [llvm|
{
^0(%arg26 : i8, %arg27 : i1):
  %0 = llvm.mlir.constant(-6 : i8) : i8
  %1 = llvm.mlir.constant(5 : i8) : i8
  %2 = llvm.mlir.constant(0 : i8) : i8
  %3 = llvm.and %arg26, %0 : i8
  %4 = "llvm.select"(%arg27, %1, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  %5 = llvm.or disjoint %3, %4 : i8
  "llvm.return"(%5) : (i8) -> ()
}
]

@[inline] private def TacticM.runCore (x : TacticM α) (ctx : Context) (s : State) :
    TermElabM (α × State) :=
  x ctx |>.run s

def and_slt_to_mask_before := [llvm|
{
^0(%arg5 : i8):
  %0 = llvm.mlir.constant(-124 : i8) : i8
  %1 = llvm.mlir.constant(2 : i8) : i8
  %2 = llvm.mlir.constant(0 : i8) : i8
  %3 = llvm.icmp "slt" %arg5, %0 : i8
  %4 = llvm.and %arg5, %1 : i8
  %5 = llvm.icmp "eq" %4, %2 : i8
  %6 = llvm.and %3, %5 : i1
  "llvm.return"(%6) : (i1) -> ()
}
]

def replicate (x : BitVec w) (n : Nat) : BitVec (w * n) :=
  BitVec.replicate n x

def Expr.KInductionCircuits.mkIndHypCycleBreaking (circs : Expr) : MetaM Expr :=
  mkAppM ``ReflectVerif.BvDecide.KInductionCircuits.mkIndHypCycleBreaking #[circs]

def test54_before := [llvm|
{
^0(%arg130 : i64):
  %0 = llvm.mlir.constant(-32574 : i16) : i16
  %1 = llvm.mlir.constant(-25350 : i16) : i16
  %2 = llvm.trunc %arg130 : i64 to i16
  %3 = llvm.or %2, %0 : i16
  %4 = llvm.and %3, %1 : i16
  %5 = llvm.sext %4 : i16 to i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def region0Expr := (Expr.app (Expr.const `MLIR.AST.Region []) (Expr.const `Nat.zero []))

def lshrult_01_01_before := [llvm|
{
^0(%arg366 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.lshr %arg366, %0 : i4
  %2 = llvm.icmp "ult" %1, %0 : i4
  "llvm.return"(%2) : (i1) -> ()
}
]

def positive_sameconst_shlnsw_before := [llvm|
{
^0(%arg51 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.ashr %arg51, %0 : i8
  %2 = llvm.shl %1, %0 overflow<nsw> : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def eq_umin3_before := [llvm|
{
^0(%arg56 : i32, %arg57 : i32):
  %0 = llvm.mlir.constant(3 : i32) : i32
  %1 = llvm.add %arg56, %0 : i32
  %2 = llvm.icmp "ult" %1, %arg57 : i32
  %3 = "llvm.select"(%2, %1, %arg57) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %4 = llvm.icmp "eq" %1, %3 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def udiv_common_dividend_defined_cond_after := [llvm|
{
^0(%arg17 : i1, %arg18 : i5, %arg19 : i5, %arg20 : i5):
  %0 = "llvm.select"(%arg17, %arg20, %arg19) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i5, i5) -> i5
  %1 = llvm.udiv %arg18, %0 : i5
  "llvm.return"(%1) : (i5) -> ()
}
]

def sdiv_ult_smin_before := [llvm|
{
^0(%arg18 : i8, %arg19 : i8):
  %0 = llvm.mlir.constant(-128 : i8) : i8
  %1 = llvm.sdiv %arg18, %arg19 : i8
  %2 = llvm.icmp "ult" %1, %0 : i8
  "llvm.return"(%2) : (i1) -> ()
}
]

def test19_after := [llvm|
{
^0(%arg7 : i10):
  %0 = llvm.mlir.constant(1 : i3) : i3
  %1 = llvm.mlir.constant(0 : i3) : i3
  %2 = llvm.trunc %arg7 : i10 to i3
  %3 = llvm.and %2, %0 : i3
  %4 = llvm.sub %1, %3 overflow<nsw> : i3
  %5 = llvm.sext %4 : i3 to i10
  "llvm.return"(%5) : (i10) -> ()
}
]

def select2_after := [llvm|
{
^0(%arg9 : i1, %arg10 : i8, %arg11 : i8, %arg12 : i8):
  %0 = llvm.add %arg10, %arg11 : i8
  %1 = "llvm.select"(%arg9, %arg12, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def ashrsgt_01_04_exact_before := [llvm|
{
^0(%arg97 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(4 : i4) : i4
  %2 = llvm.ashr exact %arg97, %0 : i4
  %3 = llvm.icmp "sgt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def shl_and_xor_after := [llvm|
{
^0(%arg158 : i8, %arg159 : i8):
  %0 = llvm.mlir.constant(10 : i8) : i8
  %1 = llvm.mlir.constant(1 : i8) : i8
  %2 = llvm.and %arg158, %0 : i8
  %3 = llvm.xor %arg159, %2 : i8
  %4 = llvm.shl %3, %1 : i8
  "llvm.return"(%4) : (i8) -> ()
}
]

def sdiv_shl_pair1_before := [llvm|
{
^0(%arg43 : i32, %arg44 : i32, %arg45 : i32):
  %0 = llvm.shl %arg43, %arg44 overflow<nsw> : i32
  %1 = llvm.shl %arg43, %arg45 overflow<nsw,nuw> : i32
  %2 = llvm.sdiv %0, %1 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def sub_zext_trunc_lshr_before := [llvm|
{
^0(%arg15 : i64):
  %0 = llvm.mlir.constant(15) : i64
  %1 = llvm.mlir.constant(10 : i32) : i32
  %2 = llvm.lshr %arg15, %0 : i64
  %3 = llvm.trunc %2 : i64 to i1
  %4 = llvm.zext %3 : i1 to i32
  %5 = llvm.sub %1, %4 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def test9a_before := [llvm|
{
^0(%arg297 : i32):
  %0 = llvm.mlir.constant(-2147483648 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.and %arg297, %0 : i32
  %3 = llvm.icmp "ne" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def icmp_ult_riscv_eq_icmp_ult_llvm_64 : LLVMPeepholeRewriteRefine 1 [Ty.llvm (.bitvec 64), Ty.llvm (.bitvec 64)] :=
  {lhs:= icmp_ult_llvm_64, rhs:= icmp_ult_riscv_64}

 instance : Coe (AttrDict φ) (List (AttrEntry φ)) where
  coe
  | AttrDict.mk as => as

def icmp' {w : Nat} (c : IntPred) (x y : BitVec w) : Bool :=
  match c with
    | .eq => (x == y)
    | .ne => (x != y)
    | .sgt => (x >ₛ y)
    | .sge => (x ≥ₛ y)
    | .slt => (x <ₛ y)
    | .sle => (x ≤ₛ y)
    | .ugt => (x >ᵤ y)
    | .uge => (x ≥ᵤ y)
    | .ult => (x <ᵤ y)
    | .ule => (x ≤ᵤ y)

def test5_before := [llvm|
{
^0(%arg118 : i32):
  %0 = llvm.mlir.constant(1234 : i32) : i32
  %1 = llvm.mlir.constant(8 : i32) : i32
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.xor %arg118, %0 : i32
  %4 = llvm.lshr %3, %1 : i32
  %5 = llvm.xor %4, %2 : i32
  %6 = llvm.add %5, %3 : i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def xor_icmp_to_ne_before := [llvm|
{
^0(%arg6 : i32):
  %0 = llvm.mlir.constant(4 : i32) : i32
  %1 = llvm.mlir.constant(6 : i32) : i32
  %2 = llvm.icmp "sgt" %arg6, %0 : i32
  %3 = llvm.icmp "slt" %arg6, %1 : i32
  %4 = llvm.xor %2, %3 : i1
  "llvm.return"(%4) : (i1) -> ()
}
]

instance :  HydrableCheckForPreconditions ParsedFpExpr FpPredicate FpExpr where
 checkForPreconditions := checkForPreconditions

def land_lor_right1_before := [llvm|
{
^0(%arg46 : i1, %arg47 : i1):
  %0 = llvm.mlir.constant(false) : i1
  %1 = llvm.mlir.constant(true) : i1
  %2 = "llvm.select"(%arg46, %arg47, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %3 = "llvm.select"(%arg46, %1, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def samesign_inverted_commute3_before := [llvm|
{
^0(%arg97 : i32, %arg98 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.and %arg97, %arg98 : i32
  %3 = llvm.icmp "sgt" %2, %0 : i32
  %4 = llvm.or %arg98, %arg97 : i32
  %5 = llvm.icmp "slt" %4, %1 : i32
  %6 = llvm.and %5, %3 : i1
  "llvm.return"(%6) : (i1) -> ()
}
]

def negate_sdiv_after := [llvm|
{
^0(%arg132 : i8, %arg133 : i8):
  %0 = llvm.mlir.constant(-42 : i8) : i8
  %1 = llvm.sdiv %arg133, %0 : i8
  %2 = llvm.add %1, %arg132 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def not_select_bool_const4_before := [llvm|
{
^0(%arg62 : i1, %arg63 : i1):
  %0 = llvm.mlir.constant(false) : i1
  %1 = llvm.mlir.constant(true) : i1
  %2 = "llvm.select"(%arg62, %0, %arg63) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %3 = llvm.xor %2, %1 : i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def llvm_const_lower_riscv_li_40 : LLVMPeepholeRewriteRefine 64 [] :=
  {lhs := constLLVM_40, rhs:= liRiscv_40,
   correct := by admit /- proof elided -/

Function.uncurry in Init.Data.Function

def compose [FinEnum arity] [DecidableEq arity] [Hashable arity]
    (new_arity : Type)        
    (q_arity : arity → Type)  
    (vars : ∀ (a : arity), q_arity a → new_arity)
    
    
    (q : ∀ (a : arity), FSM (q_arity a)) : 
    FSM new_arity :=
  { α := p.α ⊕ (Σ a, (q a).α),
    i := by admit /- proof elided -/

noncomputable def R.toTensor {q n} (a : R q n) : List Int :=
  List.range a.repLength |>.map fun i =>
        a.coeff i |>.toInt

def or_nontrivial_mask2_after := [llvm|
{
^0(%arg11 : i16):
  %0 = llvm.mlir.constant(-3841 : i16) : i16
  %1 = llvm.mlir.constant(20607 : i16) : i16
  %2 = llvm.and %arg11, %0 : i16
  %3 = llvm.icmp "ne" %2, %1 : i16
  "llvm.return"(%3) : (i1) -> ()
}
]

def binop_left_to_zero_mul : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%x: i64):
      %c = llvm.mlir.constant (0) : i64
      %0 = llvm.mul%c, %x : i64
      llvm.return %0 : i64
  }]
  rhs := [LV| {
    ^entry (%x: i64):
      %c = llvm.mlir.constant (0) : i64
      llvm.return %c : i64
  }]

def t2_before := [llvm|
{
^0(%arg30 : i8):
  %0 = llvm.mlir.constant(15 : i8) : i8
  %1 = llvm.mlir.constant(0 : i8) : i8
  %2 = llvm.mlir.constant(-16 : i8) : i8
  %3 = llvm.and %arg30, %0 : i8
  %4 = llvm.icmp "eq" %3, %1 : i8
  %5 = llvm.add %arg30, %0 : i8
  %6 = llvm.and %5, %2 : i8
  %7 = "llvm.select"(%4, %arg30, %6) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%7) : (i8) -> ()
}
]

def boolExprToSmtLib (pred : BoolExpr α) (f : α → SexprPBV.Predicate)
    (displayNames : Std.HashMap Nat HydraVariable) (widthVals : Std.HashMap Nat HydraVariable) : SexprPBV.Predicate :=
  match pred with
  | .literal litPred => f litPred
  | .not expr => SexprPBV.Predicate.not (boolExprToSmtLib expr f displayNames widthVals)
  | .gate gate lhs rhs =>
      
      
      
      match gate with
      | .beq => SexprPBV.Predicate.eq (boolExprToSmtLib lhs f displayNames widthVals) (boolExprToSmtLib rhs f displayNames widthVals)
      | .xor => SexprPBV.Predicate.xor (boolExprToSmtLib lhs f displayNames widthVals) (boolExprToSmtLib rhs f displayNames widthVals)
      | .and => SexprPBV.Predicate.and (boolExprToSmtLib lhs f displayNames widthVals) (boolExprToSmtLib rhs f displayNames widthVals)
      | .or  => SexprPBV.Predicate.or (boolExprToSmtLib lhs f displayNames widthVals) (boolExprToSmtLib rhs f displayNames widthVals)
  | .ite cond positive negative =>
      SexprPBV.Predicate.ite (boolExprToSmtLib cond f displayNames widthVals)
                            (boolExprToSmtLib positive f displayNames widthVals)
                            (boolExprToSmtLib negative f displayNames widthVals)
  | .const b => SexprPBV.Predicate.boolConstPred b

def masked_icmps_mask_notallzeros_bmask_mixed_negated_6_after := [llvm|
{
^0(%arg58 : i32):
  %0 = llvm.mlir.constant(15 : i32) : i32
  %1 = llvm.mlir.constant(8 : i32) : i32
  %2 = llvm.and %arg58, %0 : i32
  %3 = llvm.icmp "ne" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def lshrult_01_12_exact_after := [llvm|
{
^0(%arg137 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def xor_add_before := [llvm|
{
^0(%arg4 : i32):
  %0 = llvm.mlir.constant(31 : i32) : i32
  %1 = llvm.mlir.constant(42 : i32) : i32
  %2 = llvm.and %arg4, %0 : i32
  %3 = llvm.xor %2, %0 : i32
  %4 = llvm.add %3, %1 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def positive_trunc_signbit_logical_before := [llvm|
{
^0(%arg40 : i32):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.mlir.constant(128 : i32) : i32
  %2 = llvm.mlir.constant(256 : i32) : i32
  %3 = llvm.mlir.constant(false) : i1
  %4 = llvm.trunc %arg40 : i32 to i8
  %5 = llvm.icmp "sgt" %4, %0 : i8
  %6 = llvm.add %arg40, %1 : i32
  %7 = llvm.icmp "ult" %6, %2 : i32
  %8 = "llvm.select"(%5, %7, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%8) : (i1) -> ()
}
]

def positive_with_mask_logical_before := [llvm|
{
^0(%arg59 : i32):
  %0 = llvm.mlir.constant(1107296256 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(128 : i32) : i32
  %3 = llvm.mlir.constant(256 : i32) : i32
  %4 = llvm.mlir.constant(false) : i1
  %5 = llvm.and %arg59, %0 : i32
  %6 = llvm.icmp "eq" %5, %1 : i32
  %7 = llvm.add %arg59, %2 : i32
  %8 = llvm.icmp "ult" %7, %3 : i32
  %9 = "llvm.select"(%6, %8, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%9) : (i1) -> ()
}
]

def test22_before := [llvm|
{
^0(%arg189 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.mlir.constant(1 : i32) : i32
  %2 = llvm.xor %arg189, %0 : i1
  %3 = llvm.zext %2 : i1 to i32
  %4 = llvm.xor %3, %1 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

instance : ToString (CIRCTStream.Stream (BitVec w))where
  toString s := toString (Stream.toList 10 s)

private def levelParamsToMessageData (levelParams : List Name) : MessageData :=
  match levelParams with
  | []    => ""
  | u::us => Id.run do
    let mut m := m!".\{{u}"
    for u in us do
      m := m ++ ", " ++ toMessageData u
    return m ++ "}"

def sextbool_add_after := [llvm|
{
^0(%arg12 : i1, %arg13 : i32):
  %0 = llvm.sext %arg12 : i1 to i32
  %1 = llvm.add %arg13, %0 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def testi128i128_before := [llvm|
{
^0(%arg7 : i128):
  %0 = llvm.mlir.constant(127 : i128) : i128
  %1 = llvm.mlir.constant(27 : i128) : i128
  %2 = llvm.ashr %arg7, %0 : i128
  %3 = llvm.xor %2, %1 : i128
  "llvm.return"(%3) : (i128) -> ()
}
]

def ashr_mul_times_3_div_2_exact_2_after := [llvm|
{
^0(%arg17 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.ashr exact %arg17, %0 : i32
  %2 = llvm.add %arg17, %1 overflow<nsw> : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def sub_not_after := [llvm|
{
^0(%arg22 : i8, %arg23 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.xor %arg22, %0 : i8
  %2 = llvm.add %arg23, %1 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def test_sub_nuw_nsw__all_are_safe_after := [llvm|
{
^0(%arg31 : i32):
  %0 = llvm.mlir.constant(255 : i32) : i32
  %1 = llvm.mlir.constant(-254 : i32) : i32
  %2 = llvm.and %arg31, %0 : i32
  %3 = llvm.sub %1, %2 overflow<nsw,nuw> : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def select_icmp_ne_pow2_flipped_after := [llvm|
{
^0(%arg9 : i8):
  %0 = llvm.mlir.constant(4 : i8) : i8
  %1 = llvm.or %arg9, %0 : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def lshrult_02_01_exact_before := [llvm|
{
^0(%arg132 : i4):
  %0 = llvm.mlir.constant(2 : i4) : i4
  %1 = llvm.mlir.constant(1 : i4) : i4
  %2 = llvm.lshr exact %arg132, %0 : i4
  %3 = llvm.icmp "ult" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def trunc_shl_zext_32_before := [llvm|
{
^0(%arg1 : i32):
  %0 = llvm.mlir.constant(4 : i16) : i16
  %1 = llvm.trunc %arg1 : i32 to i16
  %2 = llvm.shl %1, %0 : i16
  %3 = llvm.zext %2 : i16 to i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def XorAshrAshr : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64), Ty.llvm (.bitvec 64), Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%x: i64, %y: i64, %z: i64):
      %0 = llvm.ashr %x, %z : i64
      %1 = llvm.ashr %y, %z : i64
      %2 = llvm.xor %0, %1 : i64
      llvm.return %2 : i64
  }]
  rhs := [LV| {
    ^entry (%x: i64, %y: i64, %z: i64):
      %0 = llvm.xor %x, %y : i64
      %1 = llvm.ashr %0, %z : i64
      llvm.return %1 : i64
  }]

def test24_after := [llvm|
{
^0(%arg171 : i1):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def lshrult_02_06_exact_after := [llvm|
{
^0(%arg127 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def uge_swap_and_max_logical_before := [llvm|
{
^0(%arg228 : i8, %arg229 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.mlir.constant(false) : i1
  %2 = llvm.icmp "ule" %arg229, %arg228 : i8
  %3 = llvm.icmp "eq" %arg228, %0 : i8
  %4 = "llvm.select"(%2, %3, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def test_with_neg_5_after := [llvm|
{
^0(%arg314 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.icmp "eq" %arg314, %0 : i32
  %2 = llvm.zext %1 : i1 to i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def test11_before := [llvm|
{
^0(%arg48 : i32, %arg49 : i32):
  %0 = llvm.mlir.constant(-1431655766 : i32) : i32
  %1 = llvm.mlir.constant(1431655765 : i32) : i32
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.or %arg48, %0 : i32
  %4 = llvm.xor %3, %1 : i32
  %5 = llvm.add %arg49, %2 : i32
  %6 = llvm.add %5, %4 : i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def main3c_after := [llvm|
{
^0(%arg145 : i32):
  %0 = llvm.mlir.constant(55 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.and %arg145, %0 : i32
  %3 = llvm.icmp "eq" %2, %1 : i32
  %4 = llvm.zext %3 : i1 to i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def mul_splat_fold_no_nuw_before := [llvm|
{
^0(%arg79 : i32):
  %0 = llvm.mlir.constant(65537 : i32) : i32
  %1 = llvm.mlir.constant(16 : i32) : i32
  %2 = llvm.mul %arg79, %0 overflow<nsw> : i32
  %3 = llvm.lshr %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def Holor.map (f : α → β) (h : Holor α ds) : Holor β ds :=
  f ∘ h

def src_srem_shl_demand_min_signbit_mask_hit_last_demand_after := [llvm|
{
^0(%arg20 : i32):
  %0 = llvm.mlir.constant(536870912 : i32) : i32
  %1 = llvm.mlir.constant(1 : i32) : i32
  %2 = llvm.mlir.constant(-1073741822 : i32) : i32
  %3 = llvm.srem %arg20, %0 : i32
  %4 = llvm.shl %3, %1 overflow<nsw> : i32
  %5 = llvm.and %4, %2 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def hoist_ashr_ahead_of_sext_1_after := [llvm|
{
^0(%arg3 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.ashr %arg3, %0 : i8
  %2 = llvm.sext %1 : i8 to i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def test1_after := [llvm|
{
^0(%arg8 : i17, %arg9 : i17):
  %0 = llvm.mlir.constant(7 : i17) : i17
  %1 = llvm.and %arg8, %0 : i17
  "llvm.return"(%1) : (i17) -> ()
}
]

def ult_umin3_before := [llvm|
{
^0(%arg32 : i32, %arg33 : i32):
  %0 = llvm.mlir.constant(3 : i32) : i32
  %1 = llvm.add %arg32, %0 : i32
  %2 = llvm.icmp "ult" %1, %arg33 : i32
  %3 = "llvm.select"(%2, %1, %arg33) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %4 = llvm.icmp "ugt" %1, %3 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def ex1_lhs : Com [.nat] .nat :=
  Com.var (rgn (k := 0) ⟨0, by admit /- proof elided -/
  ⟩ (
      Com.var (add ⟨0, by admit /- proof elided -/
      ⟩ ⟨0, by admit /- proof elided -/
      ⟩) 
      <| Com.ret ⟨0, by admit /- proof elided -/
      ⟩
  )) <|
  Com.ret ⟨0, by admit /- proof elided -/
  ⟩

def icmp_sle7_after := [llvm|
{
^0(%arg6 : i8):
  %0 = llvm.mlir.constant(63 : i8) : i8
  %1 = llvm.icmp "slt" %arg6, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def lshrugt_01_04_after := [llvm|
{
^0(%arg411 : i4):
  %0 = llvm.mlir.constant(-7 : i4) : i4
  %1 = llvm.icmp "ugt" %arg411, %0 : i4
  "llvm.return"(%1) : (i1) -> ()
}
]

def lor_lor_left2_after := [llvm|
{
^0(%arg68 : i1, %arg69 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = "llvm.select"(%arg69, %0, %arg68) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%1) : (i1) -> ()
}
]

def test8_after := [llvm|
{
^0(%arg46 : i32):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def ex1 := [HSxComb_com| {
  ^entry(%0: !Stream_BitVec_1):
    "return" (%0) : (!Stream_BitVec_1) -> ()
  }]

def or_logic_or_logic_and_7_before := [llvm|
{
^0(%arg30 : i1, %arg31 : i1, %arg32 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.mlir.constant(false) : i1
  %2 = llvm.or %arg31, %arg30 : i1
  %3 = "llvm.select"(%arg30, %0, %arg32) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %4 = "llvm.select"(%3, %2, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

@[simp, reducible]
def Op.sig : Op → List Ty
  | .li _ => []
  | .mulh  => [Ty.bv, Ty.bv]
  | .mulhu  => [Ty.bv, Ty.bv]
  | .mulhsu  => [Ty.bv, Ty.bv]
  | .divu =>  [Ty.bv, Ty.bv]
  | .remuw  => [Ty.bv, Ty.bv]
  | .remu  =>  [Ty.bv, Ty.bv]
  | .addiw (_imm : BitVec 12) => [Ty.bv]
  | .lui (_imm : BitVec 20) => [Ty.bv]
  | .auipc (_imm : BitVec 20)  => [Ty.bv]
  | .slliw (_shamt : BitVec 5)  => [Ty.bv]
  | .srliw (_shamt : BitVec 5) => [Ty.bv]
  | .sraiw (_shamt : BitVec 5) => [Ty.bv]
  | .slli (_shamt : BitVec 6) => [Ty.bv]
  | .srli (_shamt : BitVec 6) => [Ty.bv]
  | .srai (_shamt : BitVec 6) => [Ty.bv]
  | .addw => [Ty.bv, Ty.bv]
  | .subw => [Ty.bv, Ty.bv]
  | .sllw => [Ty.bv, Ty.bv]
  | .srlw => [Ty.bv, Ty.bv]
  | .sraw => [Ty.bv, Ty.bv]
  | .add => [Ty.bv, Ty.bv]
  | .slt => [Ty.bv, Ty.bv]
  | .sltu => [Ty.bv, Ty.bv]
  | .and => [Ty.bv, Ty.bv]
  | .or => [Ty.bv, Ty.bv]
  | .xor => [Ty.bv, Ty.bv]
  | .sll => [Ty.bv, Ty.bv]
  | .srl => [Ty.bv, Ty.bv]
  | .sub => [Ty.bv, Ty.bv]
  | .sra => [Ty.bv, Ty.bv]
  | .remw  => [Ty.bv, Ty.bv]
  | .rem  =>  [Ty.bv, Ty.bv]
  | .mul => [Ty.bv, Ty.bv]
  | .mulw => [Ty.bv, Ty.bv]
  | .div  =>  [Ty.bv, Ty.bv]
  | .divw  =>  [Ty.bv, Ty.bv]
  | .divuw  =>  [Ty.bv, Ty.bv]
  | .addi (_imm : BitVec 12) => [Ty.bv]
  | .slti (_imm : BitVec 12) => [Ty.bv]
  | .sltiu (_imm : BitVec 12) => [Ty.bv]
  | .andi (_imm : BitVec 12) => [Ty.bv]
  | .ori (_imm : BitVec 12) => [Ty.bv]
  | .xori (_imm : BitVec 12) => [Ty.bv]
  | .bclr => [Ty.bv, Ty.bv]
  | .bext => [Ty.bv, Ty.bv]
  | .binv => [Ty.bv, Ty.bv]
  | .bset  => [Ty.bv, Ty.bv]
  | .bclri (_shamt : BitVec 6) => [Ty.bv]
  | .bexti (_shamt : BitVec 6) => [Ty.bv]
  | .binvi (_shamt : BitVec 6) => [Ty.bv]
  | .bseti (_shamt : BitVec 6) => [Ty.bv]
  | .adduw => [Ty.bv, Ty.bv]
  | .sh1adduw => [Ty.bv, Ty.bv]
  | .sh2adduw => [Ty.bv, Ty.bv]
  | .sh3adduw => [Ty.bv, Ty.bv]
  | .sh1add => [Ty.bv, Ty.bv]
  | .sh2add => [Ty.bv, Ty.bv]
  | .sh3add => [Ty.bv, Ty.bv]
  | .slliuw (_shamt : BitVec 6) => [Ty.bv]
  | .andn => [Ty.bv, Ty.bv]
  | .orn => [Ty.bv, Ty.bv]
  | .xnor => [Ty.bv, Ty.bv]
  | .clz
  | .clzw
  | .ctz
  | .ctzw
  | .max => [Ty.bv, Ty.bv]
  | .maxu => [Ty.bv, Ty.bv]
  | .min  => [Ty.bv, Ty.bv]
  | .minu  => [Ty.bv, Ty.bv]
  | .sextb => [Ty.bv]
  | .sexth => [Ty.bv]
  | .zexth => [Ty.bv]
  | .rol => [Ty.bv, Ty.bv]
  | .rolw => [Ty.bv, Ty.bv]
  | .ror => [Ty.bv, Ty.bv]
  | .rori (_shamt : BitVec 6) =>[Ty.bv]
  | .roriw (_shamt : BitVec 5) =>[Ty.bv]
  | .rorw => [Ty.bv, Ty.bv]
  | .pack => [Ty.bv, Ty.bv]
  | .packh => [Ty.bv, Ty.bv]
  | .packw => [Ty.bv, Ty.bv]
  | .mv => [Ty.bv]
  | .not => [Ty.bv]
  | .neg => [Ty.bv]
  | .negw => [Ty.bv]
  | .sextw => [Ty.bv]
  | .zextb => [Ty.bv]
  | .zextw => [Ty.bv]
  | .seqz => [Ty.bv]
  | .snez => [Ty.bv]
  | .sltz => [Ty.bv]
  | .sgtz => [Ty.bv]

def mkReturn (Γ : Ctxt _) (opStx : MLIR.AST.Op 0) : MLIR.AST.ReaderM (Handshake)
    (Σ eff ty, Com Handshake Γ eff ty) :=
  if opStx.name == "return"
  then match opStx.args with
  | vStx::[] => do
    let ⟨ty, v⟩ ← MLIR.AST.TypedSSAVal.mkVal Γ vStx
    return ⟨.pure, [ty], Com.ret v⟩
  | _ => throw <| .generic s!"Ill-formed return statement (wrong arity, expected 1, got {opStx.args.length})"
  else throw <| .generic s!"Tried to build return out of non-return statement {opStx.name}"

def ashrslt_01_00_after := [llvm|
{
^0(%arg269 : i4):
  %0 = llvm.mlir.constant(0 : i4) : i4
  %1 = llvm.icmp "slt" %arg269, %0 : i4
  "llvm.return"(%1) : (i1) -> ()
}
]

def positive_samevar_after := [llvm|
{
^0(%arg62 : i8, %arg63 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.shl %0, %arg63 overflow<nsw> : i8
  %2 = llvm.and %1, %arg62 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def mkReturn (Γ : Ctxt _) (opStx : MLIR.AST.Op 0) : MLIR.AST.ReaderM (DC)
    (Σ eff ty, Com DC Γ eff ty) :=
  if opStx.name == "return"
  then match opStx.args with
  | vStx::[] => do
    let ⟨ty, v⟩ ← MLIR.AST.TypedSSAVal.mkVal Γ vStx
    return ⟨.pure, [ty], Com.ret v⟩
  | _ => throw <| .generic s!"Ill-formed return statement (wrong arity, expected 1, got {opStx.args.length})"
  else throw <| .generic s!"Tried to build return out of non-return statement {opStx.name}"

def trunc_shl_15_i16_i32_before := [llvm|
{
^0(%arg38 : i32):
  %0 = llvm.mlir.constant(15 : i32) : i32
  %1 = llvm.shl %arg38, %0 : i32
  %2 = llvm.trunc %1 : i32 to i16
  "llvm.return"(%2) : (i16) -> ()
}
]

def reduce_xor_common_op_commute0_before := [llvm|
{
^0(%arg10 : i4, %arg11 : i4, %arg12 : i4):
  %0 = llvm.xor %arg10, %arg11 : i4
  %1 = llvm.xor %0, %arg12 : i4
  %2 = llvm.or %1, %arg10 : i4
  "llvm.return"(%2) : (i4) -> ()
}
]

def n2_before := [llvm|
{
^0(%arg36 : i32, %arg37 : i32, %arg38 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.icmp "eq" %arg36, %arg37 : i32
  %2 = "llvm.select"(%arg38, %0, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %3 = llvm.xor %2, %0 : i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def sub_ashr_and_i16_after := [llvm|
{
^0(%arg29 : i16, %arg30 : i16):
  %0 = llvm.mlir.constant(0 : i16) : i16
  %1 = llvm.icmp "slt" %arg30, %arg29 : i16
  %2 = "llvm.select"(%1, %arg29, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i16, i16) -> i16
  "llvm.return"(%2) : (i16) -> ()
}
]

HXor.hXor in Init.Prelude

def not_select_bool_const1_after := [llvm|
{
^0(%arg68 : i1, %arg69 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.mlir.constant(false) : i1
  %2 = llvm.xor %arg69, %0 : i1
  %3 = "llvm.select"(%arg68, %2, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def test12commuted_after := [llvm|
{
^0(%arg87 : i32, %arg88 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.and %arg87, %arg88 : i32
  %2 = llvm.xor %1, %0 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def PR96857_xor_without_noundef_before := [llvm|
{
^0(%arg30 : i4, %arg31 : i4, %arg32 : i4):
  %0 = llvm.mlir.constant(-1 : i4) : i4
  %1 = llvm.and %arg32, %arg30 : i4
  %2 = llvm.xor %arg32, %0 : i4
  %3 = llvm.and %2, %arg31 : i4
  %4 = llvm.xor %1, %3 : i4
  "llvm.return"(%4) : (i4) -> ()
}
]

def select_icmp_eq_and_1_0_or_2_before := [llvm|
{
^0(%arg255 : i32, %arg256 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(2 : i32) : i32
  %3 = llvm.and %arg255, %0 : i32
  %4 = llvm.icmp "eq" %3, %1 : i32
  %5 = llvm.or %arg256, %2 : i32
  %6 = "llvm.select"(%4, %arg256, %5) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%6) : (i32) -> ()
}
]

RV64.sh2adduw in RISCV.Instructions

def zext_or_masked_bit_test_after := [llvm|
{
^0(%arg54 : i32, %arg55 : i32, %arg56 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.shl %0, %arg55 overflow<nuw> : i32
  %3 = llvm.and %2, %arg54 : i32
  %4 = llvm.icmp "ne" %3, %1 : i32
  %5 = llvm.icmp "eq" %arg56, %arg55 : i32
  %6 = llvm.or %4, %5 : i1
  %7 = llvm.zext %6 : i1 to i32
  "llvm.return"(%7) : (i32) -> ()
}
]

def select_icmp_eq_and_32_0_or_8_after := [llvm|
{
^0(%arg241 : i32, %arg242 : i32):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.mlir.constant(8 : i32) : i32
  %2 = llvm.lshr %arg241, %0 : i32
  %3 = llvm.and %2, %1 : i32
  %4 = llvm.or %arg242, %3 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def is_rem32_pos_i8_after := [llvm|
{
^0(%arg55 : i8):
  %0 = llvm.mlir.constant(-97 : i8) : i8
  %1 = llvm.mlir.constant(0 : i8) : i8
  %2 = llvm.and %arg55, %0 : i8
  %3 = llvm.icmp "sgt" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def lor_land_right1_after := [llvm|
{
^0(%arg26 : i1, %arg27 : i1):
  "llvm.return"(%arg26) : (i1) -> ()
}
]

IsTrans in Mathlib.Order.Defs.Unbundled

def ashrsgt_01_14_exact_before := [llvm|
{
^0(%arg87 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(-2 : i4) : i4
  %2 = llvm.ashr exact %arg87, %0 : i4
  %3 = llvm.icmp "sgt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

Nat.add in Init.Prelude

def ashr_sgt_noexact_before := [llvm|
{
^0(%arg157 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.mlir.constant(10 : i8) : i8
  %2 = llvm.ashr %arg157, %0 : i8
  %3 = llvm.icmp "sgt" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def not_or_or_and_not_and_and_after := [llvm|
{
^0(%arg208 : i32, %arg209 : i32, %arg210 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg208, %0 : i32
  %2 = llvm.xor %arg210, %arg209 : i32
  %3 = llvm.or %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

@[simp_denote]
def llvm_urem_64 : Com  LLVMPlusRiscV ⟨[.llvm (.bitvec 64), .llvm (.bitvec 64)]⟩
  .pure (.llvm (.bitvec 64)) := [LV| {
  ^entry (%x: i64, %y: i64 ):
    %1 = llvm.urem    %x, %y : i64
    llvm.return %1 : i64
  }]

def udiv_shl_shl_nuw_nsw2_before := [llvm|
{
^0(%arg55 : i8, %arg56 : i8, %arg57 : i8):
  %0 = llvm.shl %arg55, %arg57 overflow<nsw,nuw> : i8
  %1 = llvm.shl %arg56, %arg57 overflow<nsw> : i8
  %2 = llvm.udiv %0, %1 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def both_sides_fold_eq_before := [llvm|
{
^0(%arg37 : i32, %arg38 : i1):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(9 : i32) : i32
  %2 = "llvm.select"(%arg38, %0, %arg37) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %3 = "llvm.select"(%arg38, %1, %arg37) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %4 = llvm.icmp "eq" %3, %2 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def lshrult_02_14_exact_after := [llvm|
{
^0(%arg119 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def commutativity_constant_6_vary_invmask_after := [llvm|
{
^0(%arg16 : i4, %arg17 : i4):
  %0 = llvm.mlir.constant(6 : i4) : i4
  %1 = llvm.xor %arg16, %0 : i4
  %2 = llvm.and %1, %arg17 : i4
  %3 = llvm.xor %2, %0 : i4
  "llvm.return"(%3) : (i4) -> ()
}
]

def or_lshr_before := [llvm|
{
^0(%arg628 : i8, %arg629 : i8, %arg630 : i8, %arg631 : i8):
  %0 = llvm.lshr %arg628, %arg631 : i8
  %1 = llvm.lshr %arg629, %arg631 : i8
  %2 = llvm.or %0, %arg630 : i8
  %3 = llvm.or %1, %2 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def negative_not_next_power_of_two_logical_before := [llvm|
{
^0(%arg4 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.mlir.constant(64 : i32) : i32
  %2 = llvm.mlir.constant(256 : i32) : i32
  %3 = llvm.mlir.constant(false) : i1
  %4 = llvm.icmp "sgt" %arg4, %0 : i32
  %5 = llvm.add %arg4, %1 : i32
  %6 = llvm.icmp "ult" %5, %2 : i32
  %7 = "llvm.select"(%4, %6, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%7) : (i1) -> ()
}
]

def match_signed_after := [llvm|
{
^0(%arg15 : i64):
  %0 = llvm.mlir.constant(172224) : i64
  %1 = llvm.srem %arg15, %0 : i64
  "llvm.return"(%1) : (i64) -> ()
}
]

@[match_pattern] abbrev copy   : Nat → LLVM.Op := MOp.copy   ∘ .concrete

def main3f_like_logical_before := [llvm|
{
^0(%arg136 : i32, %arg137 : i32, %arg138 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.mlir.constant(true) : i1
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.and %arg136, %arg137 : i32
  %4 = llvm.icmp "ne" %3, %0 : i32
  %5 = llvm.and %arg136, %arg138 : i32
  %6 = llvm.icmp "ne" %5, %0 : i32
  %7 = "llvm.select"(%4, %1, %6) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %8 = "llvm.select"(%7, %0, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%8) : (i32) -> ()
}
]

def ashrsgt_01_05_before := [llvm|
{
^0(%arg312 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(5 : i4) : i4
  %2 = llvm.ashr %arg312, %0 : i4
  %3 = llvm.icmp "sgt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def test3 : BitVec 1 :=
  CombEg3.denote (Ctxt.Valuation.ofPair bv2' bv1')

def icmp_ugt_before := [llvm|
{
^0(%arg41 : i32, %arg42 : i32):
  %0 = llvm.lshr %arg41, %arg42 : i32
  %1 = llvm.icmp "ugt" %0, %arg41 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def OrZextOr_after := [llvm|
{
^0(%arg4 : i3):
  %0 = llvm.mlir.constant(11 : i5) : i5
  %1 = llvm.zext %arg4 : i3 to i5
  %2 = llvm.or %1, %0 : i5
  "llvm.return"(%2) : (i5) -> ()
}
]

@[simp_denote]
def sltu_riscv :=
  [LV| {
    ^entry (%arg0: i16, %arg1: i16):
    %a0 = "builtin.unrealized_conversion_cast" (%arg0) : (i16) -> (!i64)
    %a1 = "builtin.unrealized_conversion_cast" (%arg1) : (i16) -> (!i64)
    %0 = li (149595403036) : !i64 
    %1 = "lui" (%0) {imm = 16 : !i64} : (!i64) -> (!i64)
    %2 = "addi" (%1) {imm = -1 : !i64} : (!i64) -> (!i64)
    %3 = and %2, %a1 : !i64
    %4 = and %2, %a0 : !i64
    %5 = sltu %4, %3 : !i64
    %6 = "builtin.unrealized_conversion_cast" (%5) : (!i64) -> (i16)
    llvm.return %6 :i16
  }]

def select_exact_lshr_icmp_const_after := [llvm|
{
^0(%arg146 : i32):
  %0 = llvm.mlir.constant(5 : i32) : i32
  %1 = llvm.lshr %arg146, %0 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def demorgan_and_zext_after := [llvm|
{
^0(%arg14 : i1, %arg15 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.or %arg14, %arg15 : i1
  %2 = llvm.xor %1, %0 : i1
  %3 = llvm.zext %2 : i1 to i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def shl_sub_lshr_reverse_nsw_on_op1_after := [llvm|
{
^0(%arg130 : i32, %arg131 : i32, %arg132 : i32):
  %0 = llvm.lshr exact %arg132, %arg131 : i32
  %1 = llvm.sub %0, %arg130 overflow<nuw> : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def test86_after := [llvm|
{
^0(%arg59 : i16):
  %0 = llvm.mlir.constant(4 : i16) : i16
  %1 = llvm.ashr %arg59, %0 : i16
  "llvm.return"(%1) : (i16) -> ()
}
]

def positive_sameconst_shlnuwnsw_ashrexact_after := [llvm|
{
^0(%arg26 : i8):
  "llvm.return"(%arg26) : (i8) -> ()
}
]

def sge_smin1_before := [llvm|
{
^0(%arg79 : i32, %arg80 : i32):
  %0 = llvm.icmp "slt" %arg79, %arg80 : i32
  %1 = "llvm.select"(%0, %arg79, %arg80) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %2 = llvm.icmp "sge" %1, %arg79 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def scalar_i8_shl_ult_const_2_before := [llvm|
{
^0(%arg18 : i8):
  %0 = llvm.mlir.constant(6 : i8) : i8
  %1 = llvm.mlir.constant(64 : i8) : i8
  %2 = llvm.shl %arg18, %0 : i8
  %3 = llvm.icmp "ult" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def scalar_i8_signbit_lshr_and_eq_before := [llvm|
{
^0(%arg35 : i8, %arg36 : i8):
  %0 = llvm.mlir.constant(-128 : i8) : i8
  %1 = llvm.mlir.constant(0 : i8) : i8
  %2 = llvm.lshr %0, %arg36 : i8
  %3 = llvm.and %2, %arg35 : i8
  %4 = llvm.icmp "eq" %3, %1 : i8
  "llvm.return"(%4) : (i1) -> ()
}
]

def src_x_and_nmask_eq_after := [llvm|
{
^0(%arg30 : i8, %arg31 : i8, %arg32 : i1):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.mlir.constant(true) : i1
  %2 = llvm.shl %0, %arg31 overflow<nsw> : i8
  %3 = llvm.icmp "ule" %2, %arg30 : i8
  %4 = llvm.xor %arg32, %1 : i1
  %5 = "llvm.select"(%4, %1, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%5) : (i1) -> ()
}
]

def lshrugt_01_14_exact_before := [llvm|
{
^0(%arg207 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(-2 : i4) : i4
  %2 = llvm.lshr exact %arg207, %0 : i4
  %3 = llvm.icmp "ugt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def andcond.100.inv.inner.cond.in.outer.cond_before := [llvm|
{
^0(%arg55 : i1, %arg56 : i1, %arg57 : i8, %arg58 : i8, %arg59 : i8):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.mlir.constant(false) : i1
  %2 = llvm.xor %arg55, %0 : i1
  %3 = "llvm.select"(%2, %arg56, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %4 = "llvm.select"(%arg55, %arg57, %arg58) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  %5 = "llvm.select"(%3, %arg59, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%5) : (i8) -> ()
}
]

instance [Inhabited σ] : Inhabited (Vars σ ι n) where
  default := .state (Inputs.mk ⟨0, by admit /- proof elided -/
  ⟩ default)

def ugt_swap_or_not_min_logical_after := [llvm|
{
^0(%arg4 : i8, %arg5 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.icmp "ne" %arg4, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def ashrslt_03_13_exact_after := [llvm|
{
^0(%arg8 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def trunc_shl_lshr_var_after := [llvm|
{
^0(%arg33 : i64, %arg34 : i64):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.lshr %arg33, %arg34 : i64
  %2 = llvm.trunc %1 : i64 to i32
  %3 = llvm.shl %2, %0 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

@[simp]
instance Valuation.instAppendHVector (Γ : Ctxt Ty) (ts : List Ty) :
    HAppend (HVector toType ts) (Valuation Γ) (Valuation <| ⟨ts⟩ ++ Γ) where
  hAppend vals V :=
    (Valuation.ofHVector vals) ++ V

def test_shl_nsw__none_are_safe_after := [llvm|
{
^0(%arg66 : i32, %arg67 : i64):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.mlir.constant(-8 : i32) : i32
  %2 = llvm.shl %arg66, %0 : i32
  %3 = llvm.and %2, %1 : i32
  %4 = llvm.zext nneg %3 : i32 to i64
  %5 = llvm.ashr %arg67, %4 : i64
  "llvm.return"(%5) : (i64) -> ()
}
]

def add_shl_moreOneUse_sh3add_no_ZBA_test : LLVMPeepholeRewriteRefine 32 [Ty.llvm (.bitvec 32)] where
  lhs := add_shl_moreOneUse_sh3add
  rhs := add_shl_moreOneUse_sh3add_riscv_no_ZBA

def select_ashr_before := [llvm|
{
^0(%arg6 : i1, %arg7 : i128, %arg8 : i128):
  %0 = llvm.ashr %arg7, %arg8 : i128
  %1 = "llvm.select"(%arg6, %0, %arg7) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i128, i128) -> i128
  "llvm.return"(%1) : (i128) -> ()
}
]

def icmp_slt_0_and_icmp_sgt_neg1_i64_after := [llvm|
{
^0(%arg60 : i64):
  %0 = llvm.mlir.constant(0) : i64
  "llvm.return"(%0) : (i64) -> ()
}
]

def select_xor_inv_icmp_before := [llvm|
{
^0(%arg266 : i32, %arg267 : i32, %arg268 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.icmp "eq" %arg266, %0 : i32
  %2 = llvm.xor %arg268, %arg266 : i32
  %3 = "llvm.select"(%1, %2, %arg267) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def ugt_rem_zero_after := [llvm|
{
^0(%arg167 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.icmp "ugt" %arg167, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def not_xor_to_or_not2_after := [llvm|
{
^0(%arg36 : i3, %arg37 : i3, %arg38 : i3):
  %0 = llvm.mlir.constant(-1 : i3) : i3
  %1 = llvm.or %arg38, %arg37 : i3
  %2 = llvm.and %arg36, %arg38 : i3
  %3 = llvm.xor %1, %0 : i3
  %4 = llvm.or %2, %3 : i3
  "llvm.return"(%4) : (i3) -> ()
}
]

def composeQuinaryAux' (p : FSM (Fin 5)) (q₀ q₁ q₂ q₃ q₄: FSM α) : FSM α :=
  p.compose (α)
    (λ _ => α)
    (λ _ i => i)
    (λ v =>
      v.cases q₀ fun v =>
        v.cases q₁ fun v =>
          v.cases q₂ fun v =>
            v.cases q₃ fun v =>
              v.cases q₄ fun v => v.elim0)

def slt_swap_or_not_max_commute_logical_after := [llvm|
{
^0(%arg48 : i8, %arg49 : i8):
  %0 = llvm.mlir.constant(127 : i8) : i8
  %1 = llvm.icmp "ne" %arg48, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def not_and_and_or_not_or_or_commute4_after := [llvm|
{
^0(%arg229 : i32, %arg230 : i32, %arg231 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.sdiv %0, %arg231 : i32
  %3 = llvm.xor %2, %arg230 : i32
  %4 = llvm.or %3, %arg229 : i32
  %5 = llvm.xor %4, %1 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def test2_before := [llvm|
{
^0(%arg0 : i999, %arg1 : i999):
  %0 = llvm.mlir.constant(65280 : i999) : i999
  %1 = llvm.and %arg0, %0 : i999
  %2 = llvm.and %arg1, %0 : i999
  %3 = llvm.icmp "ne" %1, %2 : i999
  "llvm.return"(%3) : (i1) -> ()
}
]

def trunc_shl_7_i8_i64_after := [llvm|
{
^0(%arg37 : i64):
  %0 = llvm.mlir.constant(7 : i8) : i8
  %1 = llvm.trunc %arg37 : i64 to i8
  %2 = llvm.shl %1, %0 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

@[simp_denote]
def liRiscv0_1bit := [LV| {
  ^entry ():
    %0 = "li"() {imm = 0 : !i64} : (!i64) -> (!i64)
    %1 = "builtin.unrealized_conversion_cast"(%0) : (!i64) -> (i1)
    llvm.return %1 : i1
  }]

def pr40493_neg1_before := [llvm|
{
^0(%arg17 : i32):
  %0 = llvm.mlir.constant(11 : i32) : i32
  %1 = llvm.mlir.constant(4 : i32) : i32
  %2 = llvm.mlir.constant(0 : i32) : i32
  %3 = llvm.mul %arg17, %0 : i32
  %4 = llvm.and %3, %1 : i32
  %5 = llvm.icmp "eq" %4, %2 : i32
  "llvm.return"(%5) : (i1) -> ()
}
]

def udiv_exact_ne_0_before := [llvm|
{
^0(%arg14 : i8, %arg15 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.udiv exact %arg14, %arg15 : i8
  %2 = llvm.icmp "ne" %1, %0 : i8
  "llvm.return"(%2) : (i1) -> ()
}
]

def not_after := [llvm|
{
^0(%arg7 : i8):
  %0 = llvm.mlir.constant(42 : i8) : i8
  %1 = llvm.mlir.constant(-1 : i8) : i8
  %2 = llvm.udiv %arg7, %0 : i8
  %3 = llvm.xor %arg7, %1 : i8
  %4 = llvm.mul %2, %3 : i8
  "llvm.return"(%4) : (i8) -> ()
}
]

def positive_with_aggressive_icmp_after := [llvm|
{
^0(%arg56 : i32):
  %0 = llvm.mlir.constant(128 : i32) : i32
  %1 = llvm.icmp "ult" %arg56, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def ashrsgt_02_12_before := [llvm|
{
^0(%arg289 : i4):
  %0 = llvm.mlir.constant(2 : i4) : i4
  %1 = llvm.mlir.constant(-4 : i4) : i4
  %2 = llvm.ashr %arg289, %0 : i4
  %3 = llvm.icmp "sgt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def main7g_before := [llvm|
{
^0(%arg34 : i32, %arg35 : i32, %arg36 : i32, %arg37 : i32, %arg38 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.mlir.constant(1 : i32) : i32
  %2 = llvm.and %arg35, %arg37 : i32
  %3 = llvm.and %arg36, %arg38 : i32
  %4 = llvm.and %2, %arg34 : i32
  %5 = llvm.icmp "eq" %2, %4 : i32
  %6 = llvm.and %3, %arg34 : i32
  %7 = llvm.icmp "eq" %3, %6 : i32
  %8 = llvm.and %5, %7 : i1
  %9 = "llvm.select"(%8, %0, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%9) : (i32) -> ()
}
]

def p_commutative4_before := [llvm|
{
^0(%arg22 : i32, %arg23 : i32, %arg24 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.and %arg24, %arg22 : i32
  %2 = llvm.xor %arg24, %0 : i32
  %3 = llvm.and %2, %arg23 : i32
  %4 = llvm.or %3, %1 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def lshr_31_i32_add_zext_basic_after := [llvm|
{
^0(%arg21 : i32, %arg22 : i32):
  %0 = llvm.mlir.constant(31) : i64
  %1 = llvm.zext %arg21 : i32 to i64
  %2 = llvm.zext %arg22 : i32 to i64
  %3 = llvm.add %1, %2 overflow<nsw,nuw> : i64
  %4 = llvm.lshr %3, %0 : i64
  "llvm.return"(%4) : (i64) -> ()
}
]

def test2_after := [llvm|
{
^0(%arg0 : i49, %arg1 : i49, %arg2 : i49):
  %0 = llvm.xor %arg0, %arg1 : i49
  %1 = llvm.ashr %0, %arg2 : i49
  "llvm.return"(%1) : (i49) -> ()
}
]

def and_zext_eq_odd_before := [llvm|
{
^0(%arg31 : i32):
  %0 = llvm.mlir.constant(3 : i32) : i32
  %1 = llvm.icmp "eq" %arg31, %0 : i32
  %2 = llvm.zext %1 : i1 to i32
  %3 = llvm.and %arg31, %2 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def Env.getNonLsbs {w : Nat} (env : Env (w + 1)) : Env w := env.map <| fun x => x.extractLsb' 1 w

def exact_ashr_eq_both_equal_before := [llvm|
{
^0(%arg168 : i8):
  %0 = llvm.mlir.constant(-128 : i8) : i8
  %1 = llvm.ashr exact %0, %arg168 : i8
  %2 = llvm.icmp "eq" %1, %0 : i8
  "llvm.return"(%2) : (i1) -> ()
}
]

def Expr.mkToFSM (self : Expr) : MetaM Expr :=
  mkAppM ``FSMPredicateSolution.toFSM #[self]

def logic_and_logic_or_3_after := [llvm|
{
^0(%arg171 : i1, %arg172 : i1, %arg173 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.mlir.constant(false) : i1
  %2 = "llvm.select"(%arg172, %0, %arg173) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %3 = "llvm.select"(%2, %arg171, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def main7c_before := [llvm|
{
^0(%arg72 : i32, %arg73 : i32, %arg74 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.mul %arg74, %0 : i32
  %4 = llvm.and %arg73, %arg72 : i32
  %5 = llvm.icmp "eq" %arg73, %4 : i32
  %6 = llvm.and %3, %arg72 : i32
  %7 = llvm.icmp "eq" %3, %6 : i32
  %8 = llvm.and %5, %7 : i1
  %9 = "llvm.select"(%8, %1, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%9) : (i32) -> ()
}
]

Lean.Exception in Lean.Exception

def ule_umax2_after := [llvm|
{
^0(%arg50 : i32, %arg51 : i32):
  %0 = llvm.icmp "ule" %arg51, %arg50 : i32
  "llvm.return"(%0) : (i1) -> ()
}
]

def alive_AndOrXor_1280_ABA___AB_src :=
[sllvm| {
^bb0(%A : i64, %B : i64):
  %v1 = llvm.mlir.constant -1 : i64
  %v2 = llvm.xor %A, %v1 : i64
  %v3 = llvm.or %v2, %B : i64
  %v4 = llvm.and %v3, %A : i64
  llvm.return %v4 : i64
}]

instance : Inhabited (Ctxt.Valuation (∅ : Ctxt Ty)) := ⟨Valuation.nil⟩

def sdiv_common_dividend_defined_cond_before := [llvm|
{
^0(%arg25 : i1, %arg26 : i5, %arg27 : i5, %arg28 : i5):
  %0 = llvm.sdiv %arg26, %arg27 : i5
  %1 = llvm.sdiv %arg26, %arg28 : i5
  %2 = "llvm.select"(%arg25, %1, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i5, i5) -> i5
  "llvm.return"(%2) : (i5) -> ()
}
]

def ugt_umax4_before := [llvm|
{
^0(%arg30 : i32, %arg31 : i32):
  %0 = llvm.mlir.constant(3 : i32) : i32
  %1 = llvm.add %arg30, %0 : i32
  %2 = llvm.icmp "ugt" %arg31, %1 : i32
  %3 = "llvm.select"(%2, %arg31, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %4 = llvm.icmp "ult" %1, %3 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def udiv_x_by_const_cmp_x_before := [llvm|
{
^0(%arg14 : i32):
  %0 = llvm.mlir.constant(123 : i32) : i32
  %1 = llvm.udiv %arg14, %0 : i32
  %2 = llvm.icmp "slt" %1, %arg14 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def land_land_left2_before := [llvm|
{
^0(%arg100 : i1, %arg101 : i1):
  %0 = llvm.mlir.constant(false) : i1
  %1 = "llvm.select"(%arg101, %arg100, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %2 = "llvm.select"(%1, %arg100, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%2) : (i1) -> ()
}
]

def shl_add_before := [llvm|
{
^0(%arg26 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.shl %0, %arg26 : i32
  %3 = llvm.add %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def sltiu_test: LLVMPeepholeRewriteRefine 16 [Ty.llvm (.bitvec 16)] where
  lhs := sltiu_llvm
  rhs := sltiu_riscv

instance : DecidableNFA' (NFA'.autMsbSet) where

expr in Leanwuzla.Sexp.Basic

def exact_lshr_ne_before := [llvm|
{
^0(%arg157 : i8):
  %0 = llvm.mlir.constant(4 : i8) : i8
  %1 = llvm.mlir.constant(1 : i8) : i8
  %2 = llvm.lshr exact %0, %arg157 : i8
  %3 = llvm.icmp "ne" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def foo1_or_signbit_lshr_before := [llvm|
{
^0(%arg127 : i32, %arg128 : i32, %arg129 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(-2147483648 : i32) : i32
  %2 = llvm.mlir.constant(0 : i32) : i32
  %3 = llvm.shl %0, %arg128 : i32
  %4 = llvm.lshr %1, %arg129 : i32
  %5 = llvm.and %3, %arg127 : i32
  %6 = llvm.icmp "ne" %5, %2 : i32
  %7 = llvm.and %4, %arg127 : i32
  %8 = llvm.icmp "ne" %7, %2 : i32
  %9 = llvm.and %6, %8 : i1
  "llvm.return"(%9) : (i1) -> ()
}
]

def testi16i8_before := [llvm|
{
^0(%arg12 : i16):
  %0 = llvm.mlir.constant(8 : i16) : i16
  %1 = llvm.mlir.constant(7 : i8) : i8
  %2 = llvm.lshr %arg12, %0 : i16
  %3 = llvm.trunc %2 : i16 to i8
  %4 = llvm.trunc %arg12 : i16 to i8
  %5 = llvm.ashr %4, %1 : i8
  %6 = llvm.icmp "eq" %5, %3 : i8
  "llvm.return"(%6) : (i1) -> ()
}
]

def PR42691_8_logical_after := [llvm|
{
^0(%arg328 : i32):
  %0 = llvm.mlir.constant(2147483647 : i32) : i32
  %1 = llvm.mlir.constant(-2147483635 : i32) : i32
  %2 = llvm.add %arg328, %0 : i32
  %3 = llvm.icmp "ult" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def t7_ashr_after := [llvm|
{
^0(%arg29 : i32, %arg30 : i32):
  %0 = llvm.mlir.constant(30 : i32) : i32
  %1 = llvm.ashr %arg29, %0 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def n1_before := [llvm|
{
^0(%arg7 : i8, %arg8 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.mlir.constant(1 : i8) : i8
  %2 = llvm.shl %0, %arg8 : i8
  %3 = llvm.xor %2, %1 : i8
  %4 = llvm.icmp "ult" %3, %arg7 : i8
  "llvm.return"(%4) : (i1) -> ()
}
]

def uge_and_max_commute_after := [llvm|
{
^0(%arg234 : i8, %arg235 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.icmp "eq" %arg234, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

Erased in Mathlib.Data.Erased

def or_and_or_pat8_after := [llvm|
{
^0(%arg10 : i8, %arg11 : i8, %arg12 : i8, %arg13 : i8):
  %0 = llvm.or %arg13, %arg10 : i8
  %1 = llvm.and %0, %arg11 : i8
  %2 = llvm.or %1, %arg12 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def icmp_slt_0_and_icmp_ne_neg2_i32_fail_before := [llvm|
{
^0(%arg44 : i32):
  %0 = llvm.mlir.constant(-2 : i32) : i32
  %1 = llvm.mlir.constant(31 : i32) : i32
  %2 = llvm.icmp "ne" %arg44, %0 : i32
  %3 = llvm.zext %2 : i1 to i32
  %4 = llvm.lshr %arg44, %1 : i32
  %5 = llvm.and %4, %3 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def neg_nsw_sgt_0_before := [llvm|
{
^0(%arg17 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.sub %0, %arg17 overflow<nsw> : i8
  %2 = llvm.icmp "sgt" %1, %0 : i8
  "llvm.return"(%2) : (i1) -> ()
}
]

def negate_add_with_single_negatible_operand_depth2_after := [llvm|
{
^0(%arg35 : i8, %arg36 : i8):
  %0 = llvm.mlir.constant(-21 : i8) : i8
  %1 = llvm.sub %0, %arg35 : i8
  %2 = llvm.mul %1, %arg36 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

instance hq : Fact (q > 1) := ⟨by admit /- proof elided -/
⟩

def test6_after := [llvm|
{
^0(%arg1 : i7):
  "llvm.return"(%arg1) : (i7) -> ()
}
]

def icmp_ne_mul_nsw_nonequal_after := [llvm|
{
^0(%arg28 : i8, %arg29 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.icmp "ne" %arg29, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def shl_nsw_nuw_add_nsw_before := [llvm|
{
^0(%arg13 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.shl %0, %arg13 overflow<nsw,nuw> : i32
  %3 = llvm.add %2, %1 overflow<nsw> : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def narrow_sext_xor_before := [llvm|
{
^0(%arg48 : i16, %arg49 : i32):
  %0 = llvm.sext %arg48 : i16 to i32
  %1 = llvm.xor %0, %arg49 : i32
  %2 = llvm.trunc %1 : i32 to i16
  "llvm.return"(%2) : (i16) -> ()
}
]

structure BVExprWrapper where
  width : Nat
  bvExpr: GenBVExpr width

def test5_after := [llvm|
{
^0(%arg118 : i32):
  %0 = llvm.mlir.constant(1234 : i32) : i32
  %1 = llvm.mlir.constant(8 : i32) : i32
  %2 = llvm.mlir.constant(5 : i32) : i32
  %3 = llvm.xor %arg118, %0 : i32
  %4 = llvm.lshr %arg118, %1 : i32
  %5 = llvm.xor %4, %2 : i32
  %6 = llvm.add %5, %3 : i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def xor_and_logic_or2_after := [llvm|
{
^0(%arg27 : i1, %arg28 : i1, %arg29 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.xor %arg28, %0 : i1
  %2 = "llvm.select"(%arg27, %1, %arg29) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%2) : (i1) -> ()
}
]

def anyext_trunc_fold_zext_32 : LLVMPeepholeRewriteRefine 32 [Ty.llvm (.bitvec 32)] where
  lhs := [LV| {
    ^entry (%x: i32):
      %0 = llvm.zext %x: i32 to i64
      %1 = llvm.trunc %0: i64 to i32
      llvm.return %1 : i32
  }]
  rhs := [LV| {
    ^entry (%x: i32):
      llvm.return %x : i32
  }]

def ugt_swap_and_not_min_commute_before := [llvm|
{
^0(%arg66 : i8, %arg67 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.icmp "ult" %arg67, %arg66 : i8
  %2 = llvm.icmp "ne" %arg66, %0 : i8
  %3 = llvm.and %2, %1 : i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def slt_swap_and_not_max_commute_after := [llvm|
{
^0(%arg114 : i8, %arg115 : i8):
  %0 = llvm.icmp "sgt" %arg115, %arg114 : i8
  "llvm.return"(%0) : (i1) -> ()
}
]

def n9_before := [llvm|
{
^0(%arg1 : i64):
  %0 = llvm.mlir.constant(62) : i64
  %1 = llvm.mlir.constant(0) : i64
  %2 = llvm.lshr %arg1, %0 : i64
  %3 = llvm.sub %1, %2 : i64
  "llvm.return"(%3) : (i64) -> ()
}
]

def test1_before := [llvm|
{
^0(%arg14 : i32, %arg15 : i32):
  %0 = llvm.icmp "slt" %arg14, %arg15 : i32
  %1 = llvm.zext %0 : i1 to i32
  %2 = llvm.icmp "sgt" %arg14, %arg15 : i32
  %3 = llvm.zext %2 : i1 to i32
  %4 = llvm.and %1, %3 : i32
  %5 = llvm.trunc %4 : i32 to i1
  "llvm.return"(%5) : (i1) -> ()
}
]

def lshr_pow2_ult_smin_before := [llvm|
{
^0(%arg60 : i8):
  %0 = llvm.mlir.constant(-128 : i8) : i8
  %1 = llvm.lshr %0, %arg60 : i8
  %2 = llvm.icmp "ult" %1, %0 : i8
  "llvm.return"(%2) : (i1) -> ()
}
]

def positive_samevar_shlnuw_ashrexact_after := [llvm|
{
^0(%arg32 : i8, %arg33 : i8):
  "llvm.return"(%arg32) : (i8) -> ()
}
]

def eq_smax3_after := [llvm|
{
^0(%arg59 : i32, %arg60 : i32):
  %0 = llvm.mlir.constant(3 : i32) : i32
  %1 = llvm.add %arg59, %0 : i32
  %2 = llvm.icmp "sge" %1, %arg60 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

Lean.Meta.Context in Lean.Meta.Basic

def positive_with_icmp_logical_before := [llvm|
{
^0(%arg57 : i32):
  %0 = llvm.mlir.constant(512 : i32) : i32
  %1 = llvm.mlir.constant(128 : i32) : i32
  %2 = llvm.mlir.constant(256 : i32) : i32
  %3 = llvm.mlir.constant(false) : i1
  %4 = llvm.icmp "ult" %arg57, %0 : i32
  %5 = llvm.add %arg57, %1 : i32
  %6 = llvm.icmp "ult" %5, %2 : i32
  %7 = "llvm.select"(%4, %6, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%7) : (i1) -> ()
}
]

def ashrsgt_02_08_exact_after := [llvm|
{
^0(%arg77 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def uaddo_commute4_before := [llvm|
{
^0(%arg22 : i32, %arg23 : i32, %arg24 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg23, %0 : i32
  %2 = llvm.add %arg23, %arg22 : i32
  %3 = llvm.icmp "ult" %1, %arg22 : i32
  %4 = "llvm.select"(%3, %arg24, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def SimplePathOfPath.hCarry (this : SimplePathOfPath fsm s0 n inputs)
  (hs0 : s0 = fsm.initCarry := by rfl) :
    fsm.carry inputs n = fsm.carry this.simplePath this.k :=

def n3_constmask_samemask_before := [llvm|
{
^0(%arg0 : i32, %arg1 : i32):
  %0 = llvm.mlir.constant(65280 : i32) : i32
  %1 = llvm.and %arg0, %0 : i32
  %2 = llvm.and %arg1, %0 : i32
  %3 = llvm.add %1, %2 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def or_and2_before := [llvm|
{
^0(%arg138 : i1, %arg139 : i1, %arg140 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.xor %arg140, %0 : i1
  %2 = llvm.or %1, %arg138 : i1
  %3 = "llvm.select"(%2, %arg138, %arg139) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def ashr_ult_7_after := [llvm|
{
^0(%arg89 : i4):
  %0 = llvm.mlir.constant(-1 : i4) : i4
  %1 = llvm.icmp "sgt" %arg89, %0 : i4
  "llvm.return"(%1) : (i1) -> ()
}
]

def ashr_lshr_no_exact_after := [llvm|
{
^0(%arg131 : i32, %arg132 : i32):
  %0 = llvm.ashr %arg131, %arg132 : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

def and_zext_eq_zero_after := [llvm|
{
^0(%arg28 : i32, %arg29 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.icmp "eq" %arg28, %0 : i32
  %2 = llvm.zext %1 : i1 to i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def mkCarryAssignCircuitNAux {arity : Type _}
  [DecidableEq arity]
  [Fintype arity]
  [Hashable arity]
  (p : FSM arity) (s : p.α) (n : Nat) : Circuit (Vars p.α arity (n + 1)) :=
    (p.nextStateCirc s).map fun v =>
      match v with
        | .inl t => Vars.stateN t n
        | .inr i => Vars.inputN i n

def logical_and_implies_after := [llvm|
{
^0(%arg249 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.mlir.constant(42 : i32) : i32
  %2 = llvm.icmp "ne" %arg249, %0 : i32
  %3 = llvm.icmp "ne" %arg249, %1 : i32
  %4 = llvm.and %2, %3 : i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def add {w : Nat} (l : List (BitVec w)) : BitVec w :=
  List.foldr BitVec.add (0#w) l

def or_nontrivial_mask2_before := [llvm|
{
^0(%arg11 : i16):
  %0 = llvm.mlir.constant(127 : i8) : i8
  %1 = llvm.mlir.constant(-4096 : i16) : i16
  %2 = llvm.mlir.constant(20480 : i16) : i16
  %3 = llvm.trunc %arg11 : i16 to i8
  %4 = llvm.icmp "ne" %3, %0 : i8
  %5 = llvm.and %arg11, %1 : i16
  %6 = llvm.icmp "ne" %5, %2 : i16
  %7 = llvm.or %4, %6 : i1
  "llvm.return"(%7) : (i1) -> ()
}
]

def binop_left_to_zero_lshr : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%x: i64):
      %c = llvm.mlir.constant (0) : i64
      %0 = llvm.lshr %c, %x : i64
      llvm.return %0 : i64
  }]
  rhs := [LV| {
    ^entry (%x: i64):
      %c = llvm.mlir.constant (0) : i64
      llvm.return %c : i64
  }]

def icmp_select_implied_cond_ne_before := [llvm|
{
^0(%arg58 : i8, %arg59 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.icmp "eq" %arg58, %0 : i8
  %2 = "llvm.select"(%1, %0, %arg59) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  %3 = llvm.icmp "ne" %2, %arg58 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

noncomputable def R.fromTensorFinsupp (q : Nat) (coeffs : List Int) : (ZMod q)[X] :=
  Polynomial.ofFinsupp (List.toFinsupp (coeffs.map Int.cast))

def add_const_const_sub_nuw_after := [llvm|
{
^0(%arg54 : i8):
  %0 = llvm.mlir.constant(-128 : i8) : i8
  %1 = llvm.sub %0, %arg54 : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def lshr_exact_ne_0_after := [llvm|
{
^0(%arg121 : i32, %arg122 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.icmp "ne" %arg121, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def masked_or_allzeroes_notoptimised_logical_after := [llvm|
{
^0(%arg116 : i32):
  %0 = llvm.mlir.constant(15 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(39 : i32) : i32
  %3 = llvm.and %arg116, %0 : i32
  %4 = llvm.icmp "eq" %3, %1 : i32
  %5 = llvm.and %arg116, %2 : i32
  %6 = llvm.icmp "eq" %5, %1 : i32
  %7 = llvm.or %4, %6 : i1
  "llvm.return"(%7) : (i1) -> ()
}
]

def select_icmp_slt_zero_smin_flipped_after := [llvm|
{
^0(%arg6 : i8):
  %0 = llvm.mlir.constant(127 : i8) : i8
  %1 = llvm.and %arg6, %0 : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def liRiscv22 := [LV| {
  ^entry ():
    %0 = "li"() {imm = 22 : !i64} : (!i64) -> (!i64)
    %1 = "builtin.unrealized_conversion_cast"(%0) : (!i64) -> (i64)
    llvm.return %1 : i64
  }]

def trunc_shl_32_i32_i64_before := [llvm|
{
^0(%arg47 : i64):
  %0 = llvm.mlir.constant(32) : i64
  %1 = llvm.shl %arg47, %0 : i64
  %2 = llvm.trunc %1 : i64 to i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def and_not_or_or_not_or_xor_commute2_after := [llvm|
{
^0(%arg319 : i32, %arg320 : i32, %arg321 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.sdiv %0, %arg319 : i32
  %3 = llvm.or %arg320, %arg321 : i32
  %4 = llvm.xor %arg320, %arg321 : i32
  %5 = llvm.or %4, %2 : i32
  %6 = llvm.and %3, %5 : i32
  %7 = llvm.xor %6, %1 : i32
  "llvm.return"(%7) : (i32) -> ()
}
]

def ripple_nsw6_before := [llvm|
{
^0(%arg13 : i16, %arg14 : i16):
  %0 = llvm.mlir.constant(-21845 : i16) : i16
  %1 = llvm.mlir.constant(-10923 : i16) : i16
  %2 = llvm.or %arg14, %0 : i16
  %3 = llvm.or %arg13, %1 : i16
  %4 = llvm.add %3, %2 : i16
  "llvm.return"(%4) : (i16) -> ()
}
]

def icmp_select_implied_cond_relational_before := [llvm|
{
^0(%arg52 : i8, %arg53 : i8):
  %0 = llvm.mlir.constant(10 : i8) : i8
  %1 = llvm.icmp "ugt" %arg52, %0 : i8
  %2 = "llvm.select"(%1, %0, %arg53) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  %3 = llvm.icmp "ult" %2, %arg52 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def positive_samevar_shlnsw_ashrexact_after := [llvm|
{
^0(%arg37 : i8, %arg38 : i8):
  "llvm.return"(%arg37) : (i8) -> ()
}
]

def ashrsgt_02_05_after := [llvm|
{
^0(%arg296 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def test28_sub_before := [llvm|
{
^0(%arg175 : i32):
  %0 = llvm.mlir.constant(-2147483647 : i32) : i32
  %1 = llvm.mlir.constant(-2147483648 : i32) : i32
  %2 = llvm.sub %0, %arg175 : i32
  %3 = llvm.xor %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

abbrev HasNat (d : Dialect) [TyDenote d.Ty] [DialectSignature d] : Type := HasTy d Nat

def join {Γ : Ctxt _}  (a b : Γ.Var (MLIR2DCPlus.Ty.tokenstream)) : Expr (DCPlus) Γ .pure (.tokenstream) :=
  Expr.mk
    (op := .join)
    (ty_eq := rfl)
    (eff_le := by admit /- proof elided -/
    )
    (args := .cons a <| .cons b <| .nil)
    (regArgs := .nil)

def sge_to_ult_after := [llvm|
{
^0(%arg17 : i8):
  %0 = llvm.mlir.constant(113 : i8) : i8
  %1 = llvm.icmp "ult" %arg17, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def test3_logical_before := [llvm|
{
^0(%arg306 : i1):
  %0 = llvm.mlir.constant(false) : i1
  %1 = "llvm.select"(%arg306, %0, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%1) : (i1) -> ()
}
]

def icmp_equality_test_wrong_and_before := [llvm|
{
^0(%arg6 : i64, %arg7 : i64, %arg8 : i64):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.mlir.constant(false) : i1
  %2 = llvm.icmp "eq" %arg6, %arg8 : i64
  %3 = llvm.icmp "eq" %arg7, %arg8 : i64
  %4 = llvm.icmp "eq" %arg6, %arg7 : i64
  %5 = llvm.xor %3, %0 : i1
  %6 = "llvm.select"(%5, %1, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %7 = "llvm.select"(%2, %3, %6) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%7) : (i1) -> ()
}
]

def Body.return : (body : Body Op Γ ty) → Var body.returnContext ty
  | ⟨⟨_, ret⟩, h⟩ => ⟨ret, by admit /- proof elided -/
  ⟩

def test10_before := [llvm|
{
^0(%arg16 : i64):
  %0 = llvm.mlir.constant(0) : i64
  %1 = llvm.mlir.constant(1) : i64
  %2 = llvm.sub %0, %arg16 overflow<nsw> : i64
  %3 = llvm.and %2, %1 : i64
  %4 = llvm.add %2, %3 : i64
  "llvm.return"(%4) : (i64) -> ()
}
]

Sigma.fst in Init.Core

def sext_zext_nneg_ult_after := [llvm|
{
^0(%arg38 : i8, %arg39 : i8):
  %0 = llvm.icmp "ult" %arg38, %arg39 : i8
  "llvm.return"(%0) : (i1) -> ()
}
]

def or_eq_with_one_bit_diff_constants1_logical_before := [llvm|
{
^0(%arg365 : i32):
  %0 = llvm.mlir.constant(50 : i32) : i32
  %1 = llvm.mlir.constant(51 : i32) : i32
  %2 = llvm.mlir.constant(true) : i1
  %3 = llvm.icmp "eq" %arg365, %0 : i32
  %4 = llvm.icmp "eq" %arg365, %1 : i32
  %5 = "llvm.select"(%3, %2, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%5) : (i1) -> ()
}
]

def xor_with_or_disjoint_ab_after := [llvm|
{
^0(%arg26 : i32, %arg27 : i32):
  "llvm.return"(%arg27) : (i32) -> ()
}
]

def and_not_or_or_not_or_xor_commute2_before := [llvm|
{
^0(%arg319 : i32, %arg320 : i32, %arg321 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.sdiv %0, %arg319 : i32
  %3 = llvm.or %arg320, %arg321 : i32
  %4 = llvm.xor %3, %1 : i32
  %5 = llvm.and %2, %4 : i32
  %6 = llvm.xor %arg320, %arg321 : i32
  %7 = llvm.or %6, %2 : i32
  %8 = llvm.xor %7, %1 : i32
  %9 = llvm.or %5, %8 : i32
  "llvm.return"(%9) : (i32) -> ()
}
]

def function : Parser :=
  leading_parser argumentList >> arrow >> termParser

def test3a_after := [llvm|
{
^0(%arg100 : i32):
  %0 = llvm.mlir.constant(7 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.and %arg100, %0 : i32
  %3 = llvm.icmp "ne" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def xor_nosignbit_ashr_after := [llvm|
{
^0(%arg2 : i32):
  %0 = llvm.mlir.constant(8 : i32) : i32
  %1 = llvm.mlir.constant(8388352 : i32) : i32
  %2 = llvm.ashr %arg2, %0 : i32
  %3 = llvm.xor %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def icmp_eq_zext_eq_zero_after := [llvm|
{
^0(%arg40 : i32):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def shl_mul_mask_after := [llvm|
{
^0(%arg1 : i32):
  %0 = llvm.mlir.constant(255 : i32) : i32
  %1 = llvm.mlir.constant(65537 : i32) : i32
  %2 = llvm.mlir.constant(8 : i32) : i32
  %3 = llvm.and %arg1, %0 : i32
  %4 = llvm.mul %3, %1 overflow<nsw,nuw> : i32
  %5 = llvm.shl %3, %2 overflow<nsw,nuw> : i32
  %6 = llvm.or %4, %5 : i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def or_shl_after := [llvm|
{
^0(%arg640 : i8, %arg641 : i8, %arg642 : i8, %arg643 : i8):
  %0 = llvm.or %arg640, %arg641 : i8
  %1 = llvm.shl %0, %arg643 : i8
  %2 = llvm.or %1, %arg642 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def select_xor_icmp_bad_5_after := [llvm|
{
^0(%arg172 : i32, %arg173 : i32, %arg174 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.icmp "eq" %arg172, %0 : i32
  %2 = llvm.xor %arg172, %arg174 : i32
  %3 = "llvm.select"(%1, %arg173, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def slt_zero_sgt_minus1_after := [llvm|
{
^0(%arg22 : i4, %arg23 : i4):
  %0 = llvm.mlir.constant(-1 : i4) : i4
  %1 = llvm.xor %arg22, %arg23 : i4
  %2 = llvm.icmp "sgt" %1, %0 : i4
  "llvm.return"(%2) : (i1) -> ()
}
]

def src_is_mask_const_slt_before := [llvm|
{
^0(%arg48 : i8):
  %0 = llvm.mlir.constant(123 : i8) : i8
  %1 = llvm.mlir.constant(7 : i8) : i8
  %2 = llvm.xor %arg48, %0 : i8
  %3 = llvm.and %2, %1 : i8
  %4 = llvm.icmp "slt" %2, %3 : i8
  "llvm.return"(%4) : (i1) -> ()
}
]

IO.FS.Handle.mk in Init.System.IO

def ashrsgt_01_12_after := [llvm|
{
^0(%arg305 : i4):
  %0 = llvm.mlir.constant(-7 : i4) : i4
  %1 = llvm.icmp "sgt" %arg305, %0 : i4
  "llvm.return"(%1) : (i1) -> ()
}
]

def shl_nsw_nuw_uge_Csle0_before := [llvm|
{
^0(%arg10 : i8, %arg11 : i8):
  %0 = llvm.mlir.constant(-120 : i8) : i8
  %1 = llvm.shl %arg10, %arg11 overflow<nsw,nuw> : i8
  %2 = llvm.icmp "uge" %1, %0 : i8
  "llvm.return"(%2) : (i1) -> ()
}
]

def sle_swap_and_min_logical_after := [llvm|
{
^0(%arg212 : i8, %arg213 : i8):
  %0 = llvm.mlir.constant(-128 : i8) : i8
  %1 = llvm.icmp "eq" %arg212, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def c0_before := [llvm|
{
^0(%arg6 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.and %arg6, %0 : i8
  %2 = llvm.icmp "ugt" %1, %arg6 : i8
  "llvm.return"(%2) : (i1) -> ()
}
]

def ashrsgt_02_14_exact_before := [llvm|
{
^0(%arg71 : i4):
  %0 = llvm.mlir.constant(2 : i4) : i4
  %1 = llvm.mlir.constant(-2 : i4) : i4
  %2 = llvm.ashr exact %arg71, %0 : i4
  %3 = llvm.icmp "sgt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def sgt_swap_or_not_min_commute_after := [llvm|
{
^0(%arg18 : i8, %arg19 : i8):
  %0 = llvm.mlir.constant(-128 : i8) : i8
  %1 = llvm.icmp "ne" %arg18, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def scalar_i8_shl_ule_const_before := [llvm|
{
^0(%arg12 : i8):
  %0 = llvm.mlir.constant(5 : i8) : i8
  %1 = llvm.mlir.constant(63 : i8) : i8
  %2 = llvm.shl %arg12, %0 : i8
  %3 = llvm.icmp "ule" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def test4_before := [llvm|
{
^0(%arg25 : i32):
  %0 = llvm.mlir.constant(64 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.udiv %0, %arg25 : i32
  %3 = llvm.icmp "ne" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def llvm_zext_lower_riscv_1_to_16 : LLVMPeepholeRewriteRefine 16 [Ty.llvm (.bitvec 1)] :=
  {lhs:= zext_llvm_1_to_16, rhs:= zext_riscv_1_to_16}

def lshrult_03_02_exact_after := [llvm|
{
^0(%arg115 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def test17_after := [llvm|
{
^0(%arg154 : i8, %arg155 : i8):
  %0 = llvm.mlir.constant(33 : i8) : i8
  %1 = llvm.xor %arg155, %arg154 : i8
  %2 = llvm.xor %arg154, %arg155 : i8
  %3 = llvm.xor %2, %0 : i8
  %4 = llvm.or %1, %3 : i8
  %5 = llvm.mul %4, %3 : i8
  "llvm.return"(%5) : (i8) -> ()
}
]

def test_before := [llvm|
{
^0(%arg0 : i64):
  %0 = llvm.mlir.constant(16) : i64
  %1 = llvm.shl %arg0, %0 : i64
  %2 = llvm.ashr %1, %0 : i64
  "llvm.return"(%2) : (i64) -> ()
}
]

def sle_or_min_logical_before := [llvm|
{
^0(%arg156 : i8, %arg157 : i8):
  %0 = llvm.mlir.constant(-128 : i8) : i8
  %1 = llvm.mlir.constant(true) : i1
  %2 = llvm.icmp "sle" %arg156, %arg157 : i8
  %3 = llvm.icmp "eq" %arg156, %0 : i8
  %4 = "llvm.select"(%2, %1, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def sle_swap_or_not_min_after := [llvm|
{
^0(%arg280 : i8, %arg281 : i8):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def ashrslt_02_04_exact_after := [llvm|
{
^0(%arg33 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def ashrsgt_01_09_after := [llvm|
{
^0(%arg308 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def set_to_clear_decomposebittest_before := [llvm|
{
^0(%arg10 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.mlir.constant(3 : i8) : i8
  %2 = llvm.mlir.constant(-125 : i8) : i8
  %3 = llvm.icmp "slt" %arg10, %0 : i8
  %4 = "llvm.select"(%3, %1, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%4) : (i8) -> ()
}
]

def RawCNFA.addFinal (m : RawCNFA A) (s : State) : RawCNFA A :=
  { m with finals := m.finals.insert s }

def neg_not_signbit2_before := [llvm|
{
^0(%arg4 : i8):
  %0 = llvm.mlir.constant(6 : i8) : i8
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.lshr %arg4, %0 : i8
  %3 = llvm.zext %2 : i8 to i32
  %4 = llvm.sub %1, %3 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def eq_10_before := [llvm|
{
^0(%arg130 : i32, %arg131 : i32):
  %0 = llvm.mlir.constant(8 : i32) : i32
  %1 = llvm.trunc %arg130 : i32 to i8
  %2 = llvm.lshr %arg130, %0 : i32
  %3 = llvm.trunc %2 : i32 to i8
  %4 = llvm.trunc %arg131 : i32 to i8
  %5 = llvm.lshr %arg131, %0 : i32
  %6 = llvm.trunc %5 : i32 to i8
  %7 = llvm.icmp "eq" %1, %4 : i8
  %8 = llvm.icmp "eq" %3, %6 : i8
  %9 = llvm.and %7, %8 : i1
  "llvm.return"(%9) : (i1) -> ()
}
]

def shrink_or_after := [llvm|
{
^0(%arg11 : i6):
  %0 = llvm.mlir.constant(1 : i3) : i3
  %1 = llvm.trunc %arg11 : i6 to i3
  %2 = llvm.or %1, %0 : i3
  "llvm.return"(%2) : (i3) -> ()
}
]

@[simp, simp_denote]
instance instRefinement : DialectHRefinement SLLVM SLLVM where
  MonadIsRefinedBy := inferInstanceAs <| HRefinement (EffectM _) (EffectM _)
  IsRefinedBy := { IsRefinedBy := Ty.IsRefinedBy }

def lteZero (expr: GenBVExpr w) (widthId : Nat) : BoolExpr GenBVPred :=
  BoolExpr.gate Gate.or (eqToZero expr) (negative expr widthId)

def llvm_const_lower_riscv_li_33 : LLVMPeepholeRewriteRefine 64 [] :=
  {lhs := constLLVM_33, rhs:= liRiscv_33,
   correct := by admit /- proof elided -/

def test94_before := [llvm|
{
^0(%arg1 : i32):
  %0 = llvm.mlir.constant(-2 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i8) : i8
  %2 = llvm.icmp "eq" %arg1, %0 : i32
  %3 = llvm.sext %2 : i1 to i8
  %4 = llvm.xor %3, %1 : i8
  %5 = llvm.sext %4 : i8 to i64
  "llvm.return"(%5) : (i64) -> ()
}
]

def alive_AddSub_1043_tgt  (w : Nat)  :=
[llvm( w )| {
^bb0(%C1 : _, %Z : _, %RHS : _):
  %v1 = llvm.not %C1
  %v2 = llvm.or %Z, %v1
  %v3 = llvm.and %Z, %C1
  %v4 = llvm.xor %v3, %C1
  %v5 = llvm.mlir.constant 1
  %v6 = llvm.add %v4, %v5
  %v7 = llvm.sub %RHS, %v2
  llvm.return %v7
}]

def lt_unsigned_to_large_unsigned_after := [llvm|
{
^0(%arg47 : i8):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def scalar_i32_lshr_and_negC_eq_X_is_constant2_before := [llvm|
{
^0(%arg4 : i32):
  %0 = llvm.mlir.constant(-2147483648 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.lshr %0, %arg4 : i32
  %3 = llvm.and %2, %0 : i32
  %4 = llvm.icmp "eq" %3, %1 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def is_rem2_neg_i8_before := [llvm|
{
^0(%arg57 : i8):
  %0 = llvm.mlir.constant(2 : i8) : i8
  %1 = llvm.mlir.constant(0 : i8) : i8
  %2 = llvm.srem %arg57, %0 : i8
  %3 = llvm.icmp "slt" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def test_add_nuw_nsw__nuw_is_safe_after := [llvm|
{
^0(%arg43 : i32):
  %0 = llvm.mlir.constant(2147483647 : i32) : i32
  %1 = llvm.mlir.constant(1 : i32) : i32
  %2 = llvm.and %arg43, %0 : i32
  %3 = llvm.add %2, %1 overflow<nuw> : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def not_or_neg_before := [llvm|
{
^0(%arg79 : i8, %arg80 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.mlir.constant(-1 : i8) : i8
  %2 = llvm.sub %0, %arg80 : i8
  %3 = llvm.or %2, %arg79 : i8
  %4 = llvm.xor %3, %1 : i8
  "llvm.return"(%4) : (i8) -> ()
}
]

def visitADD_XorNeg1Plus1 : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%a: i64):
      %c = llvm.mlir.constant (-1) : i64
      %0 = llvm.xor %a, %c : i64
      %d = llvm.mlir.constant (1) : i64
      %1 = llvm.add %0, %d : i64
      llvm.return %1 : i64
  }]
  rhs := [LV| {
    ^entry (%a: i64):
      %c = llvm.mlir.constant (0) : i64
      %0 = llvm.sub %c, %a : i64
      llvm.return %0 : i64
  }]

def test_with_5_after := [llvm|
{
^0(%arg315 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.icmp "eq" %arg315, %0 : i32
  %2 = llvm.zext %1 : i1 to i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def add_const_add_const_before := [llvm|
{
^0(%arg71 : i32):
  %0 = llvm.mlir.constant(8 : i32) : i32
  %1 = llvm.mlir.constant(2 : i32) : i32
  %2 = llvm.add %arg71, %0 : i32
  %3 = llvm.add %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def negtest_near_pow2_cmpval_ashr_wrong_cmp_pred_after := [llvm|
{
^0(%arg2 : i8):
  %0 = llvm.mlir.constant(10 : i8) : i8
  %1 = llvm.icmp "eq" %arg2, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def Complete (M : NFA α σ) : Prop := ∀ w, Nonempty (M.eval w)

def tryFactorization_add_mul_nuw_after := [llvm|
{
^0(%arg13 : i32):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.shl %arg13, %0 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def n4_before := [llvm|
{
^0(%arg8 : i16):
  %0 = llvm.mlir.constant(16 : i32) : i32
  %1 = llvm.mlir.constant(-1073741824 : i32) : i32
  %2 = llvm.zext %arg8 : i16 to i32
  %3 = llvm.shl %2, %0 : i32
  %4 = llvm.and %3, %1 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def scalar_i32_lshr_and_negC_eq_X_is_constant2_after := [llvm|
{
^0(%arg4 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.icmp "ne" %arg4, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def add_nuw_nsw_or_and_after := [llvm|
{
^0(%arg7 : i32, %arg8 : i32):
  %0 = llvm.add %arg7, %arg8 overflow<nsw,nuw> : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

def test4_after := [llvm|
{
^0(%arg25 : i32):
  %0 = llvm.mlir.constant(65 : i32) : i32
  %1 = llvm.icmp "ult" %arg25, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def positive_samevar_shlnsw_before := [llvm|
{
^0(%arg52 : i8, %arg53 : i8):
  %0 = llvm.lshr %arg52, %arg53 : i8
  %1 = llvm.shl %0, %arg53 overflow<nsw> : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def test21_before := [llvm|
{
^0(%arg0 : i8):
  %0 = llvm.mlir.constant(7 : i8) : i8
  %1 = llvm.mlir.constant(1 : i8) : i8
  %2 = llvm.ashr %arg0, %0 : i8
  %3 = llvm.and %2, %1 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def xor_icmp_true_signed_before := [llvm|
{
^0(%arg11 : i32):
  %0 = llvm.mlir.constant(5 : i32) : i32
  %1 = llvm.mlir.constant(6 : i32) : i32
  %2 = llvm.icmp "sgt" %arg11, %0 : i32
  %3 = llvm.icmp "slt" %arg11, %1 : i32
  %4 = llvm.xor %2, %3 : i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def fold_nested_logic_zext_icmp_after := [llvm|
{
^0(%arg87 : i64, %arg88 : i64, %arg89 : i64, %arg90 : i64):
  %0 = llvm.icmp "sgt" %arg87, %arg88 : i64
  %1 = llvm.icmp "slt" %arg87, %arg89 : i64
  %2 = llvm.and %0, %1 : i1
  %3 = llvm.icmp "eq" %arg87, %arg90 : i64
  %4 = llvm.or %2, %3 : i1
  %5 = llvm.zext %4 : i1 to i8
  "llvm.return"(%5) : (i8) -> ()
}
]

Lean.Meta.Simp.Step in Lean.Meta.Tactic.Simp.Types

def positive_trunc_base_logical_before := [llvm|
{
^0(%arg38 : i32):
  %0 = llvm.mlir.constant(-1 : i16) : i16
  %1 = llvm.mlir.constant(128 : i16) : i16
  %2 = llvm.mlir.constant(256 : i16) : i16
  %3 = llvm.mlir.constant(false) : i1
  %4 = llvm.trunc %arg38 : i32 to i16
  %5 = llvm.icmp "sgt" %4, %0 : i16
  %6 = llvm.add %4, %1 : i16
  %7 = llvm.icmp "ult" %6, %2 : i16
  %8 = "llvm.select"(%5, %7, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%8) : (i1) -> ()
}
]

def lshrugt_02_11_after := [llvm|
{
^0(%arg388 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def positive_and_odd_eq_after := [llvm|
{
^0(%arg44 : i32):
  %0 = llvm.mlir.constant(-2147483647 : i32) : i32
  %1 = llvm.mlir.constant(1 : i32) : i32
  %2 = llvm.and %arg44, %0 : i32
  %3 = llvm.icmp "eq" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def exactly_one_set_signbit_wrong_pred_before := [llvm|
{
^0(%arg28 : i8, %arg29 : i8):
  %0 = llvm.mlir.constant(7 : i8) : i8
  %1 = llvm.mlir.constant(-1 : i8) : i8
  %2 = llvm.lshr %arg28, %0 : i8
  %3 = llvm.icmp "sgt" %arg29, %1 : i8
  %4 = llvm.zext %3 : i1 to i8
  %5 = llvm.icmp "sgt" %2, %4 : i8
  "llvm.return"(%5) : (i1) -> ()
}
]

def select_icmp_eq_0_and_1_or_1_before := [llvm|
{
^0(%arg217 : i64, %arg218 : i32):
  %0 = llvm.mlir.constant(1) : i64
  %1 = llvm.mlir.constant(0) : i64
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.and %arg217, %0 : i64
  %4 = llvm.icmp "eq" %3, %1 : i64
  %5 = llvm.or %arg218, %2 : i32
  %6 = "llvm.select"(%4, %arg218, %5) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def select_icmp_eq_and_32_0_xor_8_after := [llvm|
{
^0(%arg237 : i32, %arg238 : i32):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.mlir.constant(8 : i32) : i32
  %2 = llvm.lshr %arg237, %0 : i32
  %3 = llvm.and %2, %1 : i32
  %4 = llvm.xor %arg238, %3 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def fsmWidthEq (a b : FSM α) : FSM α :=
  composeUnaryAux FSM.scanAnd (composeBinaryAux' FSM.nxor a b)

def land_lor_right1_after := [llvm|
{
^0(%arg46 : i1, %arg47 : i1):
  "llvm.return"(%arg46) : (i1) -> ()
}
]

abbrev Term.Ctx.Env
  (tctx : Term.Ctx wcard tcard)
  (wenv : WidthExpr.Env wcard) :=
  (v : Fin tcard) → BitVec ((tctx v).toNat wenv)

def sgt_and_not_min_logical_after := [llvm|
{
^0(%arg92 : i8, %arg93 : i8):
  %0 = llvm.icmp "sgt" %arg92, %arg93 : i8
  "llvm.return"(%0) : (i1) -> ()
}
]

def uge_swap_and_max_commute_before := [llvm|
{
^0(%arg226 : i8, %arg227 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.icmp "ule" %arg227, %arg226 : i8
  %2 = llvm.icmp "eq" %arg226, %0 : i8
  %3 = llvm.and %2, %1 : i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def shl_nsw_add_negative_before := [llvm|
{
^0(%arg45 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.mlir.constant(2 : i32) : i32
  %2 = llvm.add %arg45, %0 : i32
  %3 = llvm.shl %1, %2 overflow<nsw> : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def and_xor_commute1_before := [llvm|
{
^0(%arg155 : i32, %arg156 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.udiv %0, %arg155 : i32
  %2 = llvm.udiv %0, %arg156 : i32
  %3 = llvm.and %2, %1 : i32
  %4 = llvm.xor %2, %3 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def eq_basic_equal_minus_1_before := [llvm|
{
^0(%arg30 : i8, %arg31 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.mlir.constant(-1 : i8) : i8
  %2 = llvm.add %arg30, %0 : i8
  %3 = llvm.icmp "eq" %arg30, %1 : i8
  %4 = llvm.icmp "ugt" %2, %arg31 : i8
  %5 = llvm.or %3, %4 : i1
  "llvm.return"(%5) : (i1) -> ()
}
]

def t_0_1_after := [llvm|
{
^0(%arg15 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.and %arg15, %0 : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def scalar_i8_lshr_and_negC_eq_not_negatedPowerOf2_before := [llvm|
{
^0(%arg0 : i8, %arg1 : i8):
  %0 = llvm.mlir.constant(-3 : i8) : i8
  %1 = llvm.mlir.constant(0 : i8) : i8
  %2 = llvm.lshr %arg0, %arg1 : i8
  %3 = llvm.and %2, %0 : i8
  %4 = llvm.icmp "eq" %3, %1 : i8
  "llvm.return"(%4) : (i1) -> ()
}
]

def or_or_and_complex_after := [llvm|
{
^0(%arg82 : i64):
  %0 = llvm.mlir.constant(8) : i64
  %1 = llvm.mlir.constant(71777214294589695) : i64
  %2 = llvm.mlir.constant(-71777214294589696) : i64
  %3 = llvm.lshr %arg82, %0 : i64
  %4 = llvm.shl %arg82, %0 : i64
  %5 = llvm.and %3, %1 : i64
  %6 = llvm.and %4, %2 : i64
  %7 = llvm.or disjoint %5, %6 : i64
  "llvm.return"(%7) : (i64) -> ()
}
]

def icmp_sgt6_before := [llvm|
{
^0(%arg19 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.mlir.constant(16 : i8) : i8
  %2 = llvm.shl %arg19, %0 overflow<nsw> : i8
  %3 = llvm.icmp "sgt" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def lshrugt_01_11_exact_before := [llvm|
{
^0(%arg210 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(-5 : i4) : i4
  %2 = llvm.lshr exact %arg210, %0 : i4
  %3 = llvm.icmp "ugt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def lshr_ne_opposite_msb_after := [llvm|
{
^0(%arg161 : i8):
  %0 = llvm.mlir.constant(7 : i8) : i8
  %1 = llvm.icmp "ne" %arg161, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def or_and1_after := [llvm|
{
^0(%arg141 : i1, %arg142 : i1, %arg143 : i1):
  %0 = llvm.mlir.constant(false) : i1
  %1 = llvm.mlir.constant(true) : i1
  %2 = "llvm.select"(%arg143, %arg141, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %3 = "llvm.select"(%arg142, %1, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def xor_nosignbit_select_lshr_after := [llvm|
{
^0(%arg20 : i32, %arg21 : i1):
  %0 = llvm.mlir.constant(8 : i32) : i32
  %1 = llvm.mlir.constant(8388352 : i32) : i32
  %2 = llvm.lshr %arg20, %0 : i32
  %3 = llvm.xor %2, %1 : i32
  %4 = "llvm.select"(%arg21, %3, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def ofFinCases
    {motive : ∀ {t}, Γ.Var t → Sort u}
    (ofFin : (i : Fin Γ.length) → motive (ofFin i))
    (v : Γ.Var t) :
    motive v :=

@[simp]
abbrev Diff.Valid (Γ₁ Γ₂ : Ctxt Ty) (d : Nat) : Prop :=
  ∀ {i t}, Γ₁[i]? = some t → Γ₂[i+d]? = some t

def and_to_xor2_after := [llvm|
{
^0(%arg117 : i32, %arg118 : i32):
  %0 = llvm.xor %arg117, %arg118 : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

def main7c_after := [llvm|
{
^0(%arg72 : i32, %arg73 : i32, %arg74 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mul %arg74, %0 : i32
  %2 = llvm.or %arg73, %1 : i32
  %3 = llvm.and %arg72, %2 : i32
  %4 = llvm.icmp "ne" %3, %2 : i32
  %5 = llvm.zext %4 : i1 to i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def test_invert_demorgan_and3_after := [llvm|
{
^0(%arg5 : i32, %arg6 : i32):
  %0 = llvm.mlir.constant(4095 : i32) : i32
  %1 = llvm.sub %arg5, %arg6 : i32
  %2 = llvm.and %1, %0 : i32
  %3 = llvm.icmp "eq" %2, %0 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def test8_before := [llvm|
{
^0(%arg200 : i32, %arg201 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg201, %0 : i32
  %2 = llvm.xor %arg200, %1 : i32
  %3 = llvm.or %arg201, %2 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def CNFA.autWidth (wp : WidthPredicate) (n : Nat) : CNFA 0 :=
  ⟨RawCNFA.autWidth wp n, RawCNFA.autWidth_wf⟩

def test_add_nuw__all_are_safe_after := [llvm|
{
^0(%arg46 : i32):
  %0 = llvm.mlir.constant(1073741823 : i32) : i32
  %1 = llvm.mlir.constant(1 : i32) : i32
  %2 = llvm.and %arg46, %0 : i32
  %3 = llvm.add %2, %1 overflow<nsw,nuw> : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def fold_icmp_shl_nuw_c2_precondition1_before := [llvm|
{
^0(%arg2 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.mlir.constant(63 : i32) : i32
  %2 = llvm.shl %0, %arg2 overflow<nuw> : i32
  %3 = llvm.icmp "ult" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def ashrslt_01_10_exact_after := [llvm|
{
^0(%arg43 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def mul_of_bools_before := [llvm|
{
^0(%arg91 : i32, %arg92 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(2 : i32) : i32
  %2 = llvm.and %arg91, %0 : i32
  %3 = llvm.and %arg92, %0 : i32
  %4 = llvm.mul %2, %3 : i32
  %5 = llvm.icmp "ult" %4, %1 : i32
  "llvm.return"(%5) : (i1) -> ()
}
]

def and_min_7_7_after := [llvm|
{
^0(%arg2 : i8):
  %0 = llvm.mlir.constant(-8 : i8) : i8
  %1 = llvm.and %arg2, %0 : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

inductive NatPredicate (wcard : Nat) : Type
| eq : WidthExpr wcard → WidthExpr wcard → NatPredicate wcard

def XorZextXor_after := [llvm|
{
^0(%arg6 : i3):
  %0 = llvm.mlir.constant(15 : i5) : i5
  %1 = llvm.zext %arg6 : i3 to i5
  %2 = llvm.xor %1, %0 : i5
  "llvm.return"(%2) : (i5) -> ()
}
]

def uge_swap_and_max_before := [llvm|
{
^0(%arg230 : i8, %arg231 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.icmp "ule" %arg231, %arg230 : i8
  %2 = llvm.icmp "eq" %arg230, %0 : i8
  %3 = llvm.and %1, %2 : i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def main7e_after := [llvm|
{
^0(%arg54 : i32, %arg55 : i32, %arg56 : i32, %arg57 : i32, %arg58 : i32):
  %0 = llvm.and %arg55, %arg57 : i32
  %1 = llvm.and %arg56, %arg58 : i32
  %2 = llvm.or %0, %1 : i32
  %3 = llvm.and %arg54, %2 : i32
  %4 = llvm.icmp "ne" %3, %2 : i32
  %5 = llvm.zext %4 : i1 to i32
  "llvm.return"(%5) : (i32) -> ()
}
]

RV64.sh1add in RISCV.Instructions

def test8_after := [llvm|
{
^0(%arg6 : i999):
  %0 = llvm.mlir.constant(0 : i999) : i999
  "llvm.return"(%0) : (i999) -> ()
}
]

def masked_icmps_mask_notallzeros_bmask_mixed_5_after := [llvm|
{
^0(%arg82 : i32):
  %0 = llvm.mlir.constant(15 : i32) : i32
  %1 = llvm.mlir.constant(8 : i32) : i32
  %2 = llvm.and %arg82, %0 : i32
  %3 = llvm.icmp "eq" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

@[simp_llvm]
def icmp? {w : Nat} (c : IntPred) (x y : BitVec w) : IntW 1 :=
  .value ↑(icmp' c x y)

def add_and_or_after := [llvm|
{
^0(%arg15 : i32, %arg16 : i32):
  %0 = llvm.add %arg15, %arg16 : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

def or_xor_tree_1011_before := [llvm|
{
^0(%arg12 : i32, %arg13 : i32, %arg14 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mul %arg12, %0 : i32
  %2 = llvm.mul %arg13, %0 : i32
  %3 = llvm.mul %arg14, %0 : i32
  %4 = llvm.xor %2, %1 : i32
  %5 = llvm.xor %3, %2 : i32
  %6 = llvm.xor %5, %1 : i32
  %7 = llvm.or %6, %4 : i32
  "llvm.return"(%7) : (i32) -> ()
}
]

def ashr_ult_exact_before := [llvm|
{
^0(%arg169 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.mlir.constant(10 : i8) : i8
  %2 = llvm.ashr exact %arg169, %0 : i8
  %3 = llvm.icmp "ult" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def masked_or_A_logical_after := [llvm|
{
^0(%arg120 : i32):
  %0 = llvm.mlir.constant(-79 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.and %arg120, %0 : i32
  %3 = llvm.icmp "eq" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def add_or_and_after := [llvm|
{
^0(%arg19 : i32, %arg20 : i32):
  %0 = llvm.add %arg19, %arg20 : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

def scalar_i64_lshr_and_signbit_eq_before := [llvm|
{
^0(%arg29 : i64, %arg30 : i64):
  %0 = llvm.mlir.constant(-9223372036854775808) : i64
  %1 = llvm.mlir.constant(0) : i64
  %2 = llvm.lshr %arg29, %arg30 : i64
  %3 = llvm.and %2, %0 : i64
  %4 = llvm.icmp "eq" %3, %1 : i64
  "llvm.return"(%4) : (i1) -> ()
}
]

def no_masks_with_logical_or_after := [llvm|
{
^0(%arg10 : i32, %arg11 : i32, %arg12 : i32):
  %0 = llvm.mlir.constant(63 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(true) : i1
  %3 = llvm.icmp "ne" %arg11, %0 : i32
  %4 = llvm.or %arg10, %arg12 : i32
  %5 = llvm.icmp "ne" %4, %1 : i32
  %6 = "llvm.select"(%5, %2, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%6) : (i1) -> ()
}
]

def test23_before := [llvm|
{
^0(%arg276 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(2 : i32) : i32
  %2 = llvm.icmp "sgt" %arg276, %0 : i32
  %3 = llvm.icmp "sle" %arg276, %1 : i32
  %4 = llvm.and %2, %3 : i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def visitADD_ANegBPlusBNegC : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64), Ty.llvm (.bitvec 64), Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%a: i64, %b: i64, %c: i64):
      %0 = llvm.sub %a, %b : i64
      %1 = llvm.sub %b, %c : i64
      %2 = llvm.add %0, %1 : i64
      llvm.return %2 : i64
  }]
  rhs := [LV| {
    ^entry (%a: i64, %b: i64, %c: i64):
      %0 = llvm.sub %a, %c : i64
      llvm.return %0 : i64
  }]

@[simp_denote]
def xori_llvm_i64 := [LV| {
    ^entry (%a: i64):
    %0 = llvm.mlir.constant (4) : i64
    %1 = llvm.xor %a, %0 : i64
    llvm.return %1 : i64
  }]

def dec_mask_neg_i32_before := [llvm|
{
^0(%arg7 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.sub %0, %arg7 : i32
  %3 = llvm.and %2, %arg7 : i32
  %4 = llvm.add %3, %1 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def sub_const_const_sub_after := [llvm|
{
^0(%arg35 : i32):
  %0 = llvm.mlir.constant(10 : i32) : i32
  %1 = llvm.sub %0, %arg35 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def ult_swap_or_not_max_logical_before := [llvm|
{
^0(%arg36 : i8, %arg37 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.mlir.constant(true) : i1
  %2 = llvm.icmp "ugt" %arg37, %arg36 : i8
  %3 = llvm.icmp "ne" %arg36, %0 : i8
  %4 = "llvm.select"(%2, %1, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def getIntWidth {Γ : Ctxt SLLVM.Ty} : (Σ t, Γ.Var t) → ReaderM Nat
  | ⟨Ty.bitvec w, _⟩ => return w
  | ⟨t, _⟩ => throw <| .generic s!"Expected type `bitvec _`, but found: {t}"

def test_shl_nuw__nuw_is_safe_after := [llvm|
{
^0(%arg80 : i32, %arg81 : i64):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.mlir.constant(-8 : i32) : i32
  %2 = llvm.shl %arg80, %0 : i32
  %3 = llvm.and %2, %1 : i32
  %4 = llvm.zext nneg %3 : i32 to i64
  %5 = llvm.ashr %arg81, %4 : i64
  "llvm.return"(%5) : (i64) -> ()
}
]

def positive_biggershl_shlnuw_lshrexact_before := [llvm|
{
^0(%arg29 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.mlir.constant(6 : i8) : i8
  %2 = llvm.lshr exact %arg29, %0 : i8
  %3 = llvm.shl %2, %1 overflow<nuw> : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def and_xor_commute2_after := [llvm|
{
^0(%arg153 : i32, %arg154 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.udiv %0, %arg153 : i32
  %3 = llvm.udiv %0, %arg154 : i32
  %4 = llvm.xor %2, %1 : i32
  %5 = llvm.and %3, %4 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def scalar_i32_lshr_and_negC_slt_before := [llvm|
{
^0(%arg4 : i32, %arg5 : i32):
  %0 = llvm.mlir.constant(-8 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.lshr %arg4, %arg5 : i32
  %3 = llvm.and %2, %0 : i32
  %4 = llvm.icmp "slt" %3, %1 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def test_before := [llvm|
{
^0(%arg0 : i32):
  %0 = llvm.mlir.constant(5 : i32) : i32
  %1 = llvm.mlir.constant(-5 : i32) : i32
  %2 = llvm.add %arg0, %0 : i32
  %3 = llvm.add %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def t9_after := [llvm|
{
^0(%arg4 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.icmp "ne" %arg4, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def sub_add_reg_x_sub_y_add_x : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64), Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%x: i64, %y: i64):
      %1 = llvm.add %y, %x : i64
      %2 = llvm.sub %x, %1 : i64
      llvm.return %2 : i64
  }]
  rhs := [LV| {
    ^entry (%x: i64, %y: i64):
      %c = llvm.mlir.constant (0) : i64
      %0 = llvm.sub %c, %y : i64
      llvm.return %0 : i64
  }]

def p0_after := [llvm|
{
^0(%arg16 : i8):
  %0 = llvm.mlir.constant(4 : i8) : i8
  %1 = llvm.icmp "ult" %arg16, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def lshr_and_or_disjoint_after := [llvm|
{
^0(%arg43 : i8, %arg44 : i8):
  %0 = llvm.mlir.constant(42 : i8) : i8
  %1 = llvm.mlir.constant(2 : i8) : i8
  %2 = llvm.mlir.constant(52 : i8) : i8
  %3 = llvm.srem %arg43, %0 : i8
  %4 = llvm.shl %3, %1 : i8
  %5 = llvm.and %arg44, %2 : i8
  %6 = llvm.or disjoint %5, %4 : i8
  "llvm.return"(%6) : (i8) -> ()
}
]

def not_and_and_not_commute1_before := [llvm|
{
^0(%arg561 : i32, %arg562 : i32, %arg563 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg562, %0 : i32
  %2 = llvm.xor %arg563, %0 : i32
  %3 = llvm.and %1, %arg561 : i32
  %4 = llvm.and %3, %2 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def n12_after := [llvm|
{
^0(%arg0 : i32, %arg1 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.mlir.constant(2 : i32) : i32
  %2 = llvm.xor %arg0, %0 : i32
  %3 = llvm.add %arg1, %2 : i32
  %4 = llvm.add %3, %1 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def ashrsgt_01_01_after := [llvm|
{
^0(%arg316 : i4):
  %0 = llvm.mlir.constant(3 : i4) : i4
  %1 = llvm.icmp "sgt" %arg316, %0 : i4
  "llvm.return"(%1) : (i1) -> ()
}
]

def slt_0_after := [llvm|
{
^0(%arg39 : i32):
  %0 = llvm.mlir.constant(128 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.and %arg39, %0 : i32
  %3 = llvm.icmp "ne" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def Region.appendOps (bb: Region φ) (ops: List (Op φ)): Region φ :=
  match bb with
  | Region.mk name args bbs => Region.mk name args (bbs ++ ops)

def test_add_fold_LHS :=
[mod_arith q, hq| {
  ^bb0():
    %e1 = mod_arith.constant 12 : !R
    %e2 = mod_arith.constant 34 : !R
    %add = mod_arith.add %e1, %e2 : !R
    %e3 = mod_arith.constant 56 : !R
    %add2 = mod_arith.add %add, %e3 : !R
    return %add2 : !R
}]

def test18a_before := [llvm|
{
^0(%arg280 : i8):
  %0 = llvm.mlir.constant(-2 : i8) : i8
  %1 = llvm.mlir.constant(0 : i8) : i8
  %2 = llvm.and %arg280, %0 : i8
  %3 = llvm.icmp "eq" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def test_shl_nsw__none_are_safe_after := [llvm|
{
^0(%arg66 : i32, %arg67 : i64):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.mlir.constant(-8 : i32) : i32
  %2 = llvm.shl %arg66, %0 : i32
  %3 = llvm.and %2, %1 : i32
  %4 = llvm.zext nneg %3 : i32 to i64
  %5 = llvm.ashr %arg67, %4 : i64
  "llvm.return"(%5) : (i64) -> ()
}
]

def factorize2_before := [llvm|
{
^0(%arg8 : i32):
  %0 = llvm.mlir.constant(3 : i32) : i32
  %1 = llvm.mlir.constant(2 : i32) : i32
  %2 = llvm.mul %0, %arg8 : i32
  %3 = llvm.mul %1, %arg8 : i32
  %4 = llvm.sub %2, %3 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def sub_negative_constant_lhs_i32_test : LLVMPeepholeRewriteRefine 32 [Ty.llvm (.bitvec 32)] where
  lhs := sub_negative_constant_lhs_llvm_i32
  rhs := sub_negative_constant_lhs_riscv_i32

def t3_ult_sgt_neg1_after := [llvm|
{
^0(%arg57 : i32, %arg58 : i32, %arg59 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.mlir.constant(65535 : i32) : i32
  %2 = llvm.icmp "slt" %arg57, %0 : i32
  %3 = llvm.icmp "sgt" %arg57, %1 : i32
  %4 = "llvm.select"(%2, %arg58, %arg57) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %5 = "llvm.select"(%3, %arg59, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def not_and_and_or_not_or_or_commute3_after := [llvm|
{
^0(%arg232 : i32, %arg233 : i32, %arg234 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.sdiv %0, %arg233 : i32
  %3 = llvm.xor %arg234, %2 : i32
  %4 = llvm.or %3, %arg232 : i32
  %5 = llvm.xor %4, %1 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def squared_nsw_eq0_after := [llvm|
{
^0(%arg185 : i5):
  %0 = llvm.mlir.constant(0 : i5) : i5
  %1 = llvm.icmp "eq" %arg185, %0 : i5
  "llvm.return"(%1) : (i1) -> ()
}
]

def ugt_swap_and_not_min_before := [llvm|
{
^0(%arg70 : i8, %arg71 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.icmp "ult" %arg71, %arg70 : i8
  %2 = llvm.icmp "ne" %arg70, %0 : i8
  %3 = llvm.and %1, %2 : i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def PR52261_after := [llvm|
{
^0(%arg208 : i1):
  %0 = llvm.mlir.constant(2 : i32) : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

def neg_mask_before := [llvm|
{
^0(%arg1 : i32, %arg2 : i16):
  %0 = llvm.mlir.constant(15 : i16) : i16
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.sext %arg2 : i16 to i32
  %3 = llvm.sub %arg1, %2 overflow<nsw> : i32
  %4 = llvm.lshr %arg2, %0 : i16
  %5 = llvm.zext %4 : i16 to i32
  %6 = llvm.sub %1, %5 overflow<nsw> : i32
  %7 = llvm.and %3, %6 : i32
  "llvm.return"(%7) : (i32) -> ()
}
]

def lshr_C1_add_A_C2_i32_before := [llvm|
{
^0(%arg76 : i32):
  %0 = llvm.mlir.constant(65535 : i32) : i32
  %1 = llvm.mlir.constant(5 : i32) : i32
  %2 = llvm.mlir.constant(6 : i32) : i32
  %3 = llvm.and %arg76, %0 : i32
  %4 = llvm.add %3, %1 : i32
  %5 = llvm.shl %2, %4 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def lshrult_01_06_exact_before := [llvm|
{
^0(%arg143 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(6 : i4) : i4
  %2 = llvm.lshr exact %arg143, %0 : i4
  %3 = llvm.icmp "ult" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def lshr_shl_pow2_const_case2_after := [llvm|
{
^0(%arg58 : i16):
  %0 = llvm.mlir.constant(12 : i16) : i16
  %1 = llvm.mlir.constant(32 : i16) : i16
  %2 = llvm.mlir.constant(0 : i16) : i16
  %3 = llvm.icmp "eq" %arg58, %0 : i16
  %4 = "llvm.select"(%3, %1, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i16, i16) -> i16
  "llvm.return"(%4) : (i16) -> ()
}
]

def lshrugt_03_11_exact_after := [llvm|
{
^0(%arg178 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def positive_biggershl_shlnuwnsw_ashrexact_before := [llvm|
{
^0(%arg24 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.mlir.constant(6 : i8) : i8
  %2 = llvm.ashr exact %arg24, %0 : i8
  %3 = llvm.shl %2, %1 overflow<nsw,nuw> : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def gteZero (expr: GenBVExpr w) (widthId : Nat) : BoolExpr GenBVPred :=
  positive expr widthId

def is_ascii_alphabetic_before := [llvm|
{
^0(%arg248 : i32):
  %0 = llvm.mlir.constant(-65 : i32) : i32
  %1 = llvm.mlir.constant(26 : i32) : i32
  %2 = llvm.mlir.constant(-97 : i32) : i32
  %3 = llvm.mlir.constant(true) : i1
  %4 = llvm.add %arg248, %0 overflow<nsw> : i32
  %5 = llvm.icmp "ult" %4, %1 : i32
  %6 = llvm.add %arg248, %2 overflow<nsw> : i32
  %7 = llvm.icmp "ult" %6, %1 : i32
  %8 = "llvm.select"(%5, %3, %7) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%8) : (i1) -> ()
}
]

def simplify_and_common_op_commute2_after := [llvm|
{
^0(%arg25 : i4, %arg26 : i4, %arg27 : i4, %arg28 : i4):
  %0 = llvm.mlir.constant(0 : i4) : i4
  "llvm.return"(%0) : (i4) -> ()
}
]

def icmp_power2_and_icmp_shifted_mask_swapped_8_6_after := [llvm|
{
^0(%arg34 : i32):
  %0 = llvm.mlir.constant(6 : i32) : i32
  %1 = llvm.icmp "ult" %arg34, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def or_nontrivial_mask1_before := [llvm|
{
^0(%arg12 : i16):
  %0 = llvm.mlir.constant(127 : i8) : i8
  %1 = llvm.mlir.constant(3840 : i16) : i16
  %2 = llvm.mlir.constant(1280 : i16) : i16
  %3 = llvm.trunc %arg12 : i16 to i8
  %4 = llvm.icmp "ne" %3, %0 : i8
  %5 = llvm.and %arg12, %1 : i16
  %6 = llvm.icmp "ne" %5, %2 : i16
  %7 = llvm.or %4, %6 : i1
  "llvm.return"(%7) : (i1) -> ()
}
]

def select_icmp_eq_pow2_after := [llvm|
{
^0(%arg13 : i8):
  %0 = llvm.mlir.constant(-5 : i8) : i8
  %1 = llvm.and %arg13, %0 : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def not_or_or_and_not_and_and_commute2_after := [llvm|
{
^0(%arg190 : i32, %arg191 : i32, %arg192 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.sdiv %0, %arg192 : i32
  %3 = llvm.xor %arg190, %1 : i32
  %4 = llvm.xor %2, %arg191 : i32
  %5 = llvm.or %4, %3 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

Neg.neg in Init.Prelude
</all_available_defs>

<all_available_lemmas>
...

theorem and_comm (x y : BitStream) : x &&& y = y &&& x

theorem test_logical_or_eq_a_b_thm (e e_1 : IntW 8) (e_2 : IntW 1) :
  select (select e_2 (const? 1 1) (icmp IntPred.eq e_1 e)) e_1 e ⊑ select e_2 e_1 e

theorem p_commutative4_thm.extracted_1._2 : ∀ (x x_1 x_2 : BitVec 32),
  ¬(True ∧ (x_1 &&& (x_2 ^^^ -1#32) &&& (x_2 &&& x) != 0) = true) →
    ((x_2 ^^^ -1#32) &&& x_1) + (x_2 &&& x) = x_1 &&& (x_2 ^^^ -1#32) ||

theorem zext_sext_add_icmp_slt_minus1_thm.extracted_1._1 : ∀ (x x_1 : BitVec 1),
  ofBool (zeroExtend 8 x_1 + signExtend 8 x <ₛ -1#8) = 0#1

theorem logical_or_logical_or_icmps_comm1_thm.extracted_1._5 : ∀ (x x_1 x_2 : BitVec 8),
  ¬x_1 ≥ ↑8 →
    ¬(ofBool (x_2 &&& 1#8 <<< x_1 == 0#8) = 1#1 ∨ ofBool (x == 42#8) = 1#1) →
      ¬(True ∧ 1#8 <<< x_1 >>> x_1 ≠ 1#8 ∨ x_1 ≥ ↑8) →
        ofBool (x_2 &&& 1#8 <<< x_1 == 0#8) = 1#1 → True → ofBool (x_2 &&& 1#8 == 0#8) = 1#1

theorem and_ne_with_diff_one_logical_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬ofBool (x != 40#32) = 1#1 → 0#1 = ofBool (x + BitVec.ofInt 32 (-41) <ᵤ BitVec.ofInt 32 (-2))

theorem R.fromTensor_eq_concat_zero (tensor : List Int) :
  R.fromTensor (q := q) (n := n) tensor = R.fromTensor (q := q) (n := n) (tensor ++ [0])

theorem bools2_logical_commute1_and1_thm.extracted_1._2 : ∀ (x x_1 : BitVec 1), x_1 &&& x = 1#1 → ¬x = 1#1 → False

@[simp] theorem HVector.denote_nil
    (T : HVector (fun (t : Ctxt d.Ty × List d.Ty) => Com d t.1 .impure t.2) []) :
    HVector.denote T = HVector.nil

theorem sge_and_max_commute_logical_proof : sge_and_max_commute_logical_before ⊑ sge_and_max_commute_logical_after

theorem ashrsgt_02_10_exact_thm (e : IntW 4) :
  icmp IntPred.sgt (ashr e (const? 4 2) { «exact» := true }) (const? 4 (-6)) ⊑ const? 1 1

theorem main7f_logical_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 32),
  ¬ofBool (x_2 &&& x_1 == x &&& (x_2 &&& x_1)) = 1#1 →
    ofBool (x_2 &&& x_1 != x &&& (x_2 &&& x_1)) = 1#1 → 0#1 = 1#1 → 0#32 = zeroExtend 32 1#1

theorem t6_no_extrause_thm (e e_1 : IntW 8) :
  icmp IntPred.uge (add e_1 e) e ⊑ icmp IntPred.ule e_1 (LLVM.xor e (const? 8 (-1)))

theorem bools2_logical_commute1_and1_and2_proof : bools2_logical_commute1_and1_and2_before ⊑ bools2_logical_commute1_and1_and2_after

theorem icmp_ne_and1_lshr_pow2_proof : icmp_ne_and1_lshr_pow2_before ⊑ icmp_ne_and1_lshr_pow2_after

theorem sgt_positive_multip_rem_nz_thm (e : IntW 8) :
  icmp IntPred.sgt (mul e (const? 8 5) { «nsw» := true, «nuw» := false }) (const? 8 21) ⊑
    icmp IntPred.sgt e (const? 8 4)

theorem lshrult_03_03_proof : lshrult_03_03_before ⊑ lshrult_03_03_after

theorem R.toTensor_getD [Fact (q > 1)] (a : R q n) (i : Nat) :
    a.toTensor.getD i 0 = (a.coeff i).toInt

theorem ashrslt_03_10_exact_thm (e : IntW 4) :
  icmp IntPred.slt (ashr e (const? 4 3) { «exact» := true }) (const? 4 (-6)) ⊑ const? 1 0

theorem t2_thm (e e_1 : IntW 8) : sub e_1 (shl (const? 8 (-42)) e) ⊑ add (shl (const? 8 42) e) e_1

theorem src_is_mask_zext_thm (e : IntW 8) (e_1 : IntW 16) :
  icmp IntPred.eq (LLVM.and (LLVM.xor e_1 (const? 16 123)) (zext 16 (lshr (const? 8 (-1)) e)))
      (LLVM.xor e_1 (const? 16 123)) ⊑
    icmp IntPred.ule (LLVM.xor e_1 (const? 16 123)) (zext 16 (lshr (const? 8 (-1)) e))

theorem shift_xor_multiuse_or_thm (e e_1 : IntW 32) :
  mul (select (icmp IntPred.ne (const? 32 0) (LLVM.and e_1 (const? 32 4096))) e (LLVM.or e (const? 32 2048)))
      (LLVM.or e (const? 32 2048)) ⊑
    mul (select (icmp IntPred.eq (LLVM.and e_1 (const? 32 4096)) (const? 32 0)) (LLVM.or e (const? 32 2048)) e)
      (LLVM.or e (const? 32 2048))

theorem samesign_inverted_commute1_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ofBool (x_1 ||| x <ₛ 0#32) &&& ofBool (-1#32 <ₛ x_1 &&& x) = ofBool (x_1 ^^^ x <ₛ 0#32)

theorem t0_shl_proof : t0_shl_before ⊑ t0_shl_after

theorem e_599 :
    2 *  ~~~y + 4 * y - 5 *  ~~~(x &&& y) + 2 * (x ^^^ y) + 7 * (x ||| y) + 4 *  ~~~(x &&&  ~~~x) - 2 *  ~~~(x ||| y) - 12 *  ~~~(x |||  ~~~y) - 11 * (x &&&  ~~~y) - 16 * (x &&& y) =  - 1 * (x |||  ~~~y)

theorem lshrugt_01_01_thm (e : IntW 4) :
  icmp IntPred.ugt (lshr e (const? 4 1)) (const? 4 1) ⊑ icmp IntPred.ugt e (const? 4 3)

theorem and_logic_and_logic_or_8_thm.extracted_1._2 : ∀ (x x_1 : BitVec 1), x_1 = 1#1 → x = 1#1 → 1#1 = x &&& 1#1

theorem fold_select_trunc_nuw_true_proof : fold_select_trunc_nuw_true_before ⊑ fold_select_trunc_nuw_true_after

theorem gt_unsigned_to_large_negative_proof : gt_unsigned_to_large_negative_before ⊑ gt_unsigned_to_large_negative_after

theorem not_zext_thm.extracted_1._1 : ∀ (x : BitVec 1), x = 1#1 → 0#999 = zeroExtend 999 (x ^^^ 1#1)

theorem p_commutative0_proof : p_commutative0_before ⊑ p_commutative0_after

theorem in_constant_mone_vary_invmask_thm (e e_1 : IntW 4) :
  LLVM.xor (LLVM.and (LLVM.xor (const? 4 (-1)) e_1) (LLVM.xor e (const? 4 (-1)))) e_1 ⊑
    LLVM.or e_1 (LLVM.xor e (const? 4 (-1)))

theorem alive_805 : forall (w : Nat) (X : Bitvec 1)
, TSSA.eval
  (Op := Op) (e := e)
  (i := TSSAIndex.STMT (UserType.base (BaseType.bitvec w)))
  [dsl_bb|
  ^bb
  %v0 := unit: ;
  %v1 := op:const (1) %v0;
  %v2 := op:const (X) %v0;
  %v3 := pair:%v1 %v2;
  %v4 := op:sdiv w %v3
  dsl_ret %v4
  ]  ⊑
  TSSA.eval
  (Op := Op) (e := e)
  (i := TSSAIndex.STMT (UserType.base (BaseType.bitvec w)))
  [dsl_bb|
  ^bb
  %v0 := unit: ;
  %v1 := op:const (X) %v0;
  %v2 := op:const (1) %v0;
  %v3 := pair:%v1 %v2;
  %v4 := op:add w %v3;
  %v5 := op:const (Bitvec.ofInt w (3)) %v0;
  %v6 := pair:%v4 %v5;
  %v7 := op:icmp ult  w %v6;
  %v8 := op:const (0) %v0;
  %v9 := triple:%v7 %v1 %v8;
  %v10 := op:select w %v9
  dsl_ret %v10
  ]

theorem e_2269 :
     - 6 * (d ^^^ (e &&& f)) - 1 * ((d &&& f) ^^^ (d ^^^ (e &&& f))) - 1 *  ~~~(e |||  ~~~f) - 1 * ((d |||  ~~~e) &&& (d ^^^ (e ^^^ f))) - 1 * ((d |||  ~~~e) &&&  ~~~(d ^^^ (e ^^^ f))) + 2 * ((d &&& e) ^^^ (e |||  ~~~f)) - 1 * ((d &&& e) |||  ~~~(e ^^^ f)) + 2 * ((d &&& e) |||  ~~~(e ||| f)) - 2 * (f ^^^ ( ~~~d ||| (e ||| f))) - 6 * ((d &&&  ~~~e) |||  ~~~(d ^^^ (e ^^^ f))) - 11 * ((d |||  ~~~e) &&& (e ^^^ f)) + 1 * (e ||| f) - 2 *  ~~~( ~~~d ||| (e &&& f)) - 2 * (e ^^^ (d ||| (e &&& f))) + 5 * (e ||| (d &&&  ~~~f)) + 11 * (e ^^^  ~~~( ~~~d ||| (e &&& f))) - 2 * ( ~~~(d &&&  ~~~e) &&& (e ^^^ f)) + 3 *  ~~~( ~~~d &&& ( ~~~e ||| f)) + 7 * (f ^^^  ~~~(d &&& ( ~~~e ||| f))) + 11 * (e ^^^  ~~~(d ||| (e ^^^ f))) - 3 * (e ||| (d &&& f)) + 1 * (e ^^^ (d &&&  ~~~f)) + 1 * (e ^^^  ~~~(d &&& (e ^^^ f))) + 11 * (e ^^^  ~~~(d ||| (e &&& f))) + 1 *  ~~~(d &&& f) + 11 * (f ^^^  ~~~(d &&&  ~~~e)) + 7 *  ~~~(d ||| (e ^^^ f)) - 1 * (f |||  ~~~(d |||  ~~~e)) + 1 * ( ~~~e &&& (d ^^^ f)) + 3 *  ~~~(d ^^^ e) + 7 * (e &&& f) + 7 * (d &&& e) + 2 * (d &&& (e ||| f)) + 1 * (e ^^^  ~~~(d &&& ( ~~~e &&& f))) - 6 * (e ^^^  ~~~( ~~~d &&& ( ~~~e ||| f))) - 1 * (f ^^^  ~~~(d ||| (e &&& f))) - 6 * ( ~~~d &&& (e ||| f)) + 5 * (f ^^^ (d ||| (e &&& f))) - 5 * (d &&& ( ~~~e ||| f)) + 3 *  ~~~d + 5 * ((d &&& f) ^^^  ~~~(d ^^^ (e &&& f))) - 11 *  ~~~(d &&& (e ||| f)) + 2 * (e ^^^ ( ~~~d ||| (e ||| f))) - 7 * (f ||| (d &&&  ~~~e)) - 2 * ((d ^^^ e) &&&  ~~~(d ^^^ f)) - 5 * ( ~~~d ||| ( ~~~e ||| f)) - 3 * (e ^^^ (d ||| (e ||| f))) + 4 *  ~~~( ~~~d &&& (e ^^^ f)) + 2 *  ~~~(d &&&  ~~~f) + 3 * ( ~~~d ||| (e &&& f)) + 1 * ( ~~~d ||| (e ^^^ f)) - 49 *  ~~~(d ||| (e ||| f)) - 31 *  ~~~(d ||| ( ~~~e ||| f)) + 19 *  ~~~( ~~~d ||| (e ||| f)) - 39 *  ~~~( ~~~d ||| ( ~~~e ||| f)) + 8 * ( ~~~d &&& ( ~~~e &&& f)) - 4 * ( ~~~d &&& (e &&& f)) + 13 * (d &&& ( ~~~e &&& f)) - 54 * (d &&& (e &&& f)) = 1 * (e |||  ~~~(d ||| f))

theorem sub_sext_mask1_trunc_lshr_thm.extracted_1._1 : ∀ (x : BitVec 64),
  ¬15#64 ≥ ↑64 →
    48#64 ≥ ↑64 ∨
        63#64 ≥ ↑64 ∨
          True ∧ signExtend 64 (truncate 8 ((x <<< 48#64).sshiftRight' 63#64)) ≠ (x <<< 48#64).sshiftRight' 63#64 ∨
            True ∧ (truncate 8 ((x <<< 48#64).sshiftRight' 63#64)).saddOverflow 10#8 = true →
      False

theorem logic_or_logic_and_6_thm.extracted_1._5 : ∀ (x x_1 x_2 : BitVec 1),
  ¬x_2 = 1#1 → x = 1#1 → x_1 = 1#1 → 1#1 = x

theorem ashr_exact_add_nuw_proof : ashr_exact_add_nuw_before ⊑ ashr_exact_add_nuw_after

theorem test6_thm.extracted_1._1 : ∀ (x : BitVec 64),
  ¬32#128 ≥ ↑128 → 32#64 ≥ ↑64 ∨ True ∧ zeroExtend 64 (truncate 32 (x >>> 32#64)) ≠ x >>> 32#64 → False

theorem test_proof : test_before ⊑ test_after

theorem BitVec.add_getElem_succ (x y : BitVec w) (hw : i + 1 < w) : (x + y)[i + 1] =
    (x[i + 1] ^^ (y[i + 1]) ^^ BitVec.carry (i + 1) x y false)

theorem main3f_like_logical_thm.extracted_1._2 : ∀ (x x_1 : BitVec 32),
  ofBool (x_1 &&& x != 0#32) = 1#1 → ofBool (x_1 &&& x == 0#32) = 1#1 → ¬True → False

theorem eq_umin2_proof : eq_umin2_before ⊑ eq_umin2_after

theorem test_thm (e : IntW 32) :
  LLVM.and (icmp IntPred.sgt e (const? 32 (-1))) (icmp IntPred.eq e (const? 32 1)) ⊑
    icmp IntPred.eq e (const? 32 1)

@[simp] theorem ofBitVec_and {w : Nat} {x y : BitVec w} : ofBitVecSext (x &&& y) = (ofBitVecSext x) &&& (ofBitVecSext y)

theorem e_1542 :
     - 7 * (a &&& c) - 5 * ((a |||  ~~~b) &&&  ~~~(a ^^^ (b ^^^ c))) + 1 * ( ~~~(a ||| b) ||| (a ^^^ (b ^^^ c))) - 6 * (b ^^^  ~~~(a ||| (b ^^^ c))) - 1 * ((a &&& c) ^^^  ~~~(a ^^^ ( ~~~b &&& c))) + 11 *  ~~~(a ||| (b ||| c)) + 6 *  ~~~(a ||| ( ~~~b ||| c)) - 1 *  ~~~( ~~~a ||| (b ||| c)) + 11 *  ~~~( ~~~a ||| ( ~~~b ||| c)) - 1 * ( ~~~a &&& ( ~~~b &&& c)) + 1 * ( ~~~a &&& (b &&& c)) + 12 * (a &&& ( ~~~b &&& c)) =  - 13 * (a &&& (b &&& c))

theorem icmp_eq_select_thm (e e_1 : IntW 32) (e_2 : IntW 1) :
  icmp IntPred.eq (select e_2 e_1 e) (select e_2 e e_1) ⊑ icmp IntPred.eq e_1 e

theorem mul_sel_op0_thm.extracted_1._1 : ∀ (x : BitVec 32) (x_1 : BitVec 1), x_1 = 1#1 → 0#32 * x = 0#32

theorem shl_shl_constants_div_thm (e e_1 : IntW 32) :
  LLVM.udiv e_1 (shl (shl (const? 32 1) e) (const? 32 2)) ⊑ lshr e_1 (add e (const? 32 2))

theorem foo_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬(-1#32 == 0 || 32 != 1 && x == intMin 32 && -1#32 == -1) = true → ofBool (x.srem (-1#32) == 0#32) = 1#1

theorem e_1598 :
    1 * ( ~~~b &&& (a ^^^ c)) - 11 * ((a ||| b) &&& (b ^^^ c)) - 3 * ( ~~~(a |||  ~~~b) ||| (b ^^^ c)) + 7 * ( ~~~(a &&&  ~~~b) &&&  ~~~(a ^^^ (b ^^^ c))) - 3 * (c ^^^  ~~~(a &&& (b &&& c))) + 4 * ( ~~~b |||  ~~~(a ^^^ c)) + 11 * (b ^^^  ~~~(a &&& (b &&& c))) + 1 * (a &&& ( ~~~b ||| c)) - 11 * ((a &&& b) |||  ~~~(b ||| c)) + 2 * (b ^^^ c) + 1 * (c ^^^ ( ~~~a ||| (b ||| c))) - 10 *  ~~~(a ||| (b ||| c)) - 3 *  ~~~( ~~~a ||| (b ||| c)) + 18 *  ~~~( ~~~a ||| ( ~~~b ||| c)) - 15 * ( ~~~a &&& ( ~~~b &&& c)) - 5 * ( ~~~a &&& (b &&& c)) - 4 * (a &&& ( ~~~b &&& c)) - 2 * (a &&& (b &&& c)) =  - 1 *  ~~~(a ||| (b ^^^ c)) - 10 *  ~~~(a ||| ( ~~~b ||| c))

theorem t2_thm (e : IntW 64) : sub (const? 64 0) (ashr e (const? 64 63)) ⊑ lshr e (const? 64 63)

theorem PR42691_3_thm (e : IntW 32) :
  LLVM.or (icmp IntPred.sge e (const? 32 0)) (icmp IntPred.eq e (const? 32 (-2147483648))) ⊑
    icmp IntPred.ult e (const? 32 (-2147483647))

theorem main12_logical_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ofBool (truncate 16 x <ₛ 0#16) = 1#1 → ofBool (x &&& 32896#32 == 0#32) = 1#1 → ¬True → 2#32 = 1#32

theorem zext (b : BitVec 8) : (b.zeroExtend 10 |>.zeroExtend 8) = b

theorem t0_thm.extracted_1._4 : ∀ (x : BitVec 8) (x_1 : BitVec 1),
  x_1 ^^^ 1#1 = 1#1 → ¬x_1 = 1#1 → ¬True → 0#1 = 1#1 → False

theorem t0_thm.extracted_1._25 : ∀ (x x_1 x_2 x_3 : BitVec 8) (x_4 : BitVec 1),
  x_4 ^^^ 1#1 = 1#1 → x_4 = 1#1 → True → ofBool (x_3 != x_2) = 1#1 → x_1 = x

@[simp]
theorem extractLsb'_eq_setWidth {x : BitVec w} : x.extractLsb' 0 n = x.setWidth n

theorem main3d_logical_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ofBool (x &&& 7#32 != 0#32) = 1#1 → ¬True → 0#32 = zeroExtend 32 (ofBool (x &&& 23#32 == 0#32))

theorem foo_thm.extracted_1._1 : ∀ (x x_1 : BitVec 64),
  zeroExtend 64 (truncate 32 x_1 &&& truncate 32 x) = x_1 &&& x &&& 4294967295#64

theorem select_icmp_ne_0_and_32_or_4096_thm.extracted_1._3 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (0#32 != x_1 &&& 32#32) = 1#1 → 7#32 ≥ ↑32 → False

theorem positive_trunc_base_logical_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (-1#16 <ₛ truncate 16 x) = 1#1 → ofBool (truncate 16 x + 128#16 <ᵤ 256#16) = ofBool (x &&& 65408#32 == 0#32)

theorem nonexact_ashr_ne_proof : nonexact_ashr_ne_before ⊑ nonexact_ashr_ne_after

theorem sge_and_max_commute_logical_thm.extracted_1._3 : ∀ (x x_1 : BitVec 8),
  ¬ofBool (x_1 == 127#8) = 1#1 → 0#1 = ofBool (x_1 == 127#8)

theorem test4_proof : test4_before ⊑ test4_after

theorem hoist_ashr_ahead_of_sext_1_proof : hoist_ashr_ahead_of_sext_1_before ⊑ hoist_ashr_ahead_of_sext_1_after

theorem positive_trunc_base_logical_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (-1#16 <ₛ truncate 16 x) = 1#1 → ofBool (truncate 16 x + 128#16 <ᵤ 256#16) = ofBool (x &&& 65408#32 == 0#32)

theorem test_proof : test_before ⊑ test_after

theorem src3_proof : src3_before ⊑ src3_after

theorem e_375 :
    3 * y - 7 *  ~~~y + 2 * (x ^^^ y) - 11 *  ~~~x + 3 * x + 7 *  ~~~(x ||| y) - 5 *  ~~~(x |||  ~~~y) - 17 * (x &&& y) =  - 2 * (x &&&  ~~~y) - 11 *  ~~~(x &&&  ~~~y)

theorem neg_sgt_42_proof : neg_sgt_42_before ⊑ neg_sgt_42_after

theorem t0_proof : t0_before ⊑ t0_after

theorem or_and_not_not_commute4_proof : or_and_not_not_commute4_before ⊑ or_and_not_not_commute4_after

theorem alive_AndOrXor_2063__X__C1__C2____X__C2__C1__C2  (w : Nat)   : alive_AndOrXor_2063__X__C1__C2____X__C2__C1__C2_src w  ⊑ alive_AndOrXor_2063__X__C1__C2____X__C2__C1__C2_tgt w

theorem neg_mask_thm.extracted_1._1 : ∀ (x : BitVec 16) (x_1 : BitVec 32),
  ¬(True ∧ x_1.ssubOverflow (signExtend 32 x) = true ∨
        15#16 ≥ ↑16 ∨ True ∧ (0#32).ssubOverflow (zeroExtend 32 (x >>> 15#16)) = true) →
    ofBool (x <ₛ 0#16) = 1#1 → True ∧ x_1.ssubOverflow (signExtend 32 x) = true → False

theorem lshrugt_01_15_proof : lshrugt_01_15_before ⊑ lshrugt_01_15_after

theorem testi32i8_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬(7#8 ≥ ↑8 ∨ 8#32 ≥ ↑32) →
    ¬ofBool ((truncate 8 x).sshiftRight' 7#8 == truncate 8 (x >>> 8#32)) = 1#1 →
      ¬15#32 ≥ ↑32 → truncate 8 (x.sshiftRight' 15#32) ^^^ 127#8 = truncate 8 (x >>> 15#32) ^^^ 127#8

theorem bools2_logical_commute2_proof : bools2_logical_commute2_before ⊑ bools2_logical_commute2_after

theorem sge_swap_or_not_max_commute_logical_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ¬ofBool (x_1 != 127#8) = 1#1 → ofBool (x ≤ₛ x_1) = 1#1

theorem test3_thm.extracted_1._4 : ∀ (x : BitVec 1) (x_1 : BitVec 59),
  ¬x = 1#1 → ¬4096#59 = 0 → ¬12#59 ≥ ↑59 → x_1 / 4096#59 = x_1 >>> 12#59

theorem ashr_bitwidth_mask_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ¬7#8 ≥ ↑8 → ofBool (x_1 <ₛ 0#8) = 1#1 → x_1.sshiftRight' 7#8 &&& x = x

theorem test18_thm (e : IntW 16) (e_1 : IntW 32) :
  urem e_1 (select (icmp IntPred.ne (LLVM.and e (const? 16 4)) (const? 16 0)) (const? 32 32) (const? 32 64)) ⊑
    LLVM.and e_1
      (select (icmp IntPred.eq (LLVM.and e (const? 16 4)) (const? 16 0)) (const? 32 63) (const? 32 31))

theorem band_land_left2_thm.extracted_1._2 : ∀ (x x_1 : BitVec 1), ¬x_1 &&& x = 1#1 → 0#1 = x_1 &&& x

theorem or_logic_or_logic_and_1_proof : or_logic_or_logic_and_1_before ⊑ or_logic_or_logic_and_1_after

theorem main8_proof : main8_before ⊑ main8_after

theorem different_size_zext_zext_slt_thm.extracted_1._1 : ∀ (x : BitVec 4) (x_1 : BitVec 7),
  ofBool (zeroExtend 25 x_1 <ₛ zeroExtend 25 x) = ofBool (x_1 <ᵤ zeroExtend 7 x)

theorem lshr_pow2_ult_proof : lshr_pow2_ult_before ⊑ lshr_pow2_ult_after

theorem test15f_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ofBool (x &&& 128#32 != 0#32) = 1#1 → ¬1#32 ≥ ↑32 → 0#32 = x <<< 1#32 &&& 256#32 ^^^ 256#32

theorem rewrite_n (stream_d : Stream α) :
    HandshakeOp.sink ((HandshakeOp.fork stream_d).fst) = HandshakeOp.sink stream_d

theorem test10_proof : test10_before ⊑ test10_after

theorem ashr_lshr_cst_proof : ashr_lshr_cst_before ⊑ ashr_lshr_cst_after

theorem e_85 :
    1 *  ~~~y + 2 * (x |||  ~~~y) - 4 *  ~~~(x ||| y) - 3 * (x &&&  ~~~y) - 2 * (x &&& y) =  - 1 *  ~~~x + 1 *  ~~~(x |||  ~~~y)

theorem sgt_smax4_proof : sgt_smax4_before ⊑ sgt_smax4_after

theorem uge_swap_or_max_commute_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ofBool (x_1 == -1#8) ||

theorem masked_icmps_mask_notallzeros_bmask_mixed_0_logical_proof : masked_icmps_mask_notallzeros_bmask_mixed_0_logical_before ⊑ masked_icmps_mask_notallzeros_bmask_mixed_0_logical_after

theorem scalar_i8_shl_ult_const_2_proof : scalar_i8_shl_ult_const_2_before ⊑ scalar_i8_shl_ult_const_2_after

theorem test_proof : test_before ⊑ test_after

theorem a_false_implies_b_true2_comm_thm (e e_1 : IntW 1) (e_2 : IntW 8) :
  LLVM.or (select (icmp IntPred.ult e_2 (const? 8 20)) e_1 e) (icmp IntPred.ugt e_2 (const? 8 10)) ⊑
    select (icmp IntPred.ugt e_2 (const? 8 10)) (const? 1 1) e_1

theorem bools_logical_commute0_and2_thm.extracted_1._11 : ∀ (x x_1 x_2 : BitVec 1),
  x_2 ^^^ 1#1 = 1#1 → x_2 = 1#1 → x_1 = 1#1 → 1#1 = x

theorem or_test2_proof : or_test2_before ⊑ or_test2_after

theorem ugt_and_min_commute_proof : ugt_and_min_commute_before ⊑ ugt_and_min_commute_after

theorem select_icmp_slt_zero_smin_flipped_proof : select_icmp_slt_zero_smin_flipped_before ⊑ select_icmp_slt_zero_smin_flipped_after

theorem and_not_or_thm (e e_1 e_2 : IntW 32) :
  LLVM.and (LLVM.or (LLVM.xor (LLVM.and e_2 e_1) (const? 32 (-1))) e)
      (LLVM.or (LLVM.xor (LLVM.and e_2 e) (const? 32 (-1))) e_1) ⊑
    LLVM.xor (LLVM.and (LLVM.xor e_1 e) e_2) (const? 32 (-1))

theorem and_logic_and_logic_or_2_thm.extracted_1._5 : ∀ (x x_1 x_2 : BitVec 1),
  ¬x_2 &&& x_1 = 1#1 → x = 1#1 → x_2 = 1#1 → x_1 = 1#1 → x_2 = 1#1

theorem nonexact_ashr_eq_noexactlog_proof : nonexact_ashr_eq_noexactlog_before ⊑ nonexact_ashr_eq_noexactlog_after

theorem arbitrary_mask_sub_i8_proof : arbitrary_mask_sub_i8_before ⊑ arbitrary_mask_sub_i8_after

theorem udiv_ne_big_proof : udiv_ne_big_before ⊑ udiv_ne_big_after

theorem test6_proof : test6_before ⊑ test6_after

theorem test_thm.extracted_1._1 : ¬(BitVec.ofInt 32 (-2147483648) == 0 ||
        32 != 1 && 0#32 == intMin 32 && BitVec.ofInt 32 (-2147483648) == -1) =
      true →
  ofBool ((0#32).sdiv (BitVec.ofInt 32 (-2147483648)) == 0#32) = 1#1

theorem select_xor_icmp_bad_6_thm.extracted_1._5 : ∀ (x x_1 x_2 : BitVec 32),
  ¬ofBool (x_2 != 1#32) = 1#1 → ofBool (x_2 == 1#32) = 1#1 → x_2 ^^^ x = x ^^^ 1#32

theorem scalar_i32_lshr_and_signbit_ne_proof : scalar_i32_lshr_and_signbit_ne_before ⊑ scalar_i32_lshr_and_signbit_ne_after

theorem sext_zext_nneg_ult_proof : sext_zext_nneg_ult_before ⊑ sext_zext_nneg_ult_after

theorem t10_shift_by_one_proof : t10_shift_by_one_before ⊑ t10_shift_by_one_after

theorem or_xor_tree_1111_thm (e e_1 e_2 : IntW 32) :
  LLVM.or (LLVM.xor (mul e_2 (const? 32 42)) (LLVM.xor (mul e_1 (const? 32 42)) (mul e (const? 32 42))))
      (LLVM.xor (mul e (const? 32 42)) (mul e_2 (const? 32 42))) ⊑
    LLVM.or (LLVM.xor (mul e (const? 32 42)) (mul e_2 (const? 32 42))) (mul e_1 (const? 32 42))

theorem shr_umax_proof : shr_umax_before ⊑ shr_umax_after

theorem n7_wrong_pred2_thm (e e_1 : IntW 8) :
  icmp IntPred.eq (sub e_1 e) e_1 ⊑ icmp IntPred.eq e (const? 8 0)

theorem reused_mul_nuw_xy_z_selectnonzero_ugt_thm.extracted_1._6 : ∀ (x x_1 x_2 : BitVec 8),
  ¬ofBool (x_2 != 0#8) = 1#1 →
    ¬ofBool (x_2 == 0#8) = 1#1 → True ∧ x_1.umulOverflow x_2 = true ∨ True ∧ x.umulOverflow x_2 = true → False

lemma deterministic_stepSet_subsingleton {M : NFA α σ} {S : Set σ} (hd : M.Deterministic) :
    S.Subsingleton → (M.stepSet S a |>.Subsingleton)

theorem t0_sub_of_trueval_thm (e e_1 : IntW 8) (e_2 : IntW 1) :
  sub (select e_2 e_1 e) e_1 ⊑ select e_2 (const? 8 0) (sub e e_1)

theorem fold_mask_cmps_to_true_logical_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬ofBool (x != 2147483647#32) = 1#1 → ofBool (x &&& 2147483647#32 != 0#32) = 1#1

theorem test2_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ofBool (x_1 ^^^ x == 0#32) ^^^ ofBool (x_1 ^^^ x == 32#32) = ofBool (x_1 == x) ^^^ ofBool (x_1 ^^^ x == 32#32)

theorem main7b_logical_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (x_1 == x &&& x_1) = 1#1 → ofBool (x_1 != x &&& x_1) = 1#1 → 0#1 = 1#1 → 0#32 = zeroExtend 32 1#1

theorem foo1_and_thm (e e_1 e_2 : IntW 32) :
  LLVM.or (icmp IntPred.eq (LLVM.and (shl (const? 32 1) e_2) e_1) (const? 32 0))
      (icmp IntPred.eq (LLVM.and (shl (const? 32 1) e) e_1) (const? 32 0)) ⊑
    icmp IntPred.ne
      (LLVM.and e_1
        (LLVM.or (shl (const? 32 1) e_2 { «nsw» := false, «nuw» := true })
          (shl (const? 32 1) e { «nsw» := false, «nuw» := true })))
      (LLVM.or (shl (const? 32 1) e_2 { «nsw» := false, «nuw» := true })
        (shl (const? 32 1) e { «nsw» := false, «nuw» := true }))

theorem basic_proof : basic_before ⊑ basic_after

theorem PR42691_9_logical_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬ofBool (13#32 <ₛ x) = 1#1 → 0#1 = ofBool (x + BitVec.ofInt 32 (-14) <ᵤ 2147483633#32)

theorem test17_proof : test17_before ⊑ test17_after

theorem e_1560 :
     - 2 * (a &&&  ~~~c) + 11 * (b ^^^  ~~~(a &&& c)) + 1 * ((a ^^^ b) ||| (a ^^^ c)) + 1 * ( ~~~a &&& (b ||| c)) + 11 * ( ~~~(a ||| b) |||  ~~~(b ^^^ c)) - 6 * ( ~~~b |||  ~~~(a ^^^ c)) + 2 * (c ^^^ (a ||| (b ||| c))) - 16 *  ~~~(a ||| (b ||| c)) + 2 *  ~~~(a ||| ( ~~~b ||| c)) - 17 *  ~~~( ~~~a ||| (b ||| c)) - 18 * ( ~~~a &&& ( ~~~b &&& c)) - 13 * ( ~~~a &&& (b &&& c)) + 5 * (a &&& ( ~~~b &&& c)) - 16 * (a &&& (b &&& c)) = 1 *  ~~~( ~~~a ||| ( ~~~b ||| c))

theorem udiv_common_dividend_defined_cond_thm (e e_1 e_2 : IntW 5) (e_3 : IntW 1) :
  select e_3 (LLVM.udiv e_2 e_1) (LLVM.udiv e_2 e) ⊑ LLVM.udiv e_2 (select e_3 e_1 e)

theorem ashrslt_03_06_proof : ashrslt_03_06_before ⊑ ashrslt_03_06_after

theorem shift_xor_multiuse_or_proof : shift_xor_multiuse_or_before ⊑ shift_xor_multiuse_or_after

theorem test_zext4_thm.extracted_1._3 : ∀ (x x_1 : BitVec 1),
  x_1 = 1#1 → x_1 ^^^ 1#1 = 1#1 → zeroExtend 32 x = zeroExtend 32 1#1

theorem PR2330_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ofBool (x_1 <ᵤ 8#32) &&& ofBool (x <ᵤ 8#32) = ofBool (x_1 ||| x <ᵤ 8#32)

theorem p0_ult_65536_thm (e e_1 : IntW 32) :
  select (icmp IntPred.ult e_1 (const? 32 65536)) e (const? 32 65535) ⊑
    select (icmp IntPred.ugt e_1 (const? 32 65535)) (const? 32 65535) e

theorem lshrult_02_00_thm.extracted_1._1 : ∀ (x : BitVec 4), ¬2#4 ≥ ↑4 → ofBool (x >>> 2#4 <ᵤ 0#4) = 0#1

theorem or_xor_common_op_commute0_thm (e e_1 e_2 : IntW 8) :
  LLVM.or (LLVM.or e_2 e_1) (LLVM.xor e_2 e) ⊑ LLVM.or (LLVM.or e_2 e_1) e

theorem ashr_mul_times_5_div_4_exact_2_thm (e : IntW 32) :
  ashr (mul e (const? 32 5) { «nsw» := true, «nuw» := false }) (const? 32 2) { «exact» := true } ⊑
    add e (ashr e (const? 32 2) { «exact» := true }) { «nsw» := true, «nuw» := false }

theorem rewrite_n (stream_d : DCOp.TokenStream) :
    DCOp.sink ((DCOp.fork stream_d).fst) = DCOp.sink stream_d

theorem lshr_by_const_cmp_sge_value_proof : lshr_by_const_cmp_sge_value_before ⊑ lshr_by_const_cmp_sge_value_after

theorem xor_or_xor_common_op_commute5_proof : xor_or_xor_common_op_commute5_before ⊑ xor_or_xor_common_op_commute5_after

theorem fold_sext_to_and_wrong6_proof : fold_sext_to_and_wrong6_before ⊑ fold_sext_to_and_wrong6_after

lemma bisimul_eval_one (hsim : Bisimul R M₁ M₂) :
    R.set_eq Q₁ Q₂ → R.set_eq (M₁.stepSet Q₁ a) (M₂.stepSet Q₂ a)

theorem shl_lshr_eq_amt_multi_use_proof : shl_lshr_eq_amt_multi_use_before ⊑ shl_lshr_eq_amt_multi_use_after

theorem trunc_ashr_thm (e : IntW 32) :
  trunc 32 (ashr (LLVM.or (zext 36 e) (const? 36 (-2147483648))) (const? 36 8)) ⊑
    LLVM.or (lshr e (const? 32 8)) (const? 32 (-8388608))

theorem pb_thm (e : IntW 65) :
  icmp IntPred.eq e (ashr (shl e (const? 65 1)) (const? 65 1) { «exact» := true }) ⊑
    icmp IntPred.sgt (add e (const? 65 9223372036854775808)) (const? 65 (-1))

theorem masked_and_notA_logical_proof : masked_and_notA_logical_before ⊑ masked_and_notA_logical_after

theorem lshrugt_01_08_exact_proof : lshrugt_01_08_exact_before ⊑ lshrugt_01_08_exact_after

theorem exact_lshr_ne_proof : exact_lshr_ne_before ⊑ exact_lshr_ne_after

@[grind =, simp]
lemma RawCNFA.addInitial_finals {m : RawCNFA A} : (m.addInitial s).finals = m.finals

theorem and_umin_thm (e : IntW 32) :
  LLVM.and (select (icmp IntPred.ult (const? 32 15) e) (const? 32 15) e) (const? 32 (-32)) ⊑ const? 32 0

theorem addsub_combine_constants_proof : addsub_combine_constants_before ⊑ addsub_combine_constants_after

theorem lshrult_02_01_proof : lshrult_02_01_before ⊑ lshrult_02_01_after

theorem masked_icmps_mask_notallzeros_bmask_mixed_negated_1b_logical_thm (e : IntW 32) :
  select (icmp IntPred.eq (LLVM.and e (const? 32 14)) (const? 32 0)) (const? 1 1)
      (icmp IntPred.ne (LLVM.and e (const? 32 3)) (const? 32 1)) ⊑
    LLVM.or (icmp IntPred.eq (LLVM.and e (const? 32 14)) (const? 32 0))
      (icmp IntPred.ne (LLVM.and e (const? 32 3)) (const? 32 1))

theorem twoway_clamp_lt_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬ofBool (x <ₛ 13768#32) = 1#1 →
    ofBool (13767#32 <ₛ x) = 1#1 → ¬ofBool (13767#32 <ₛ 13768#32) = 1#1 → 13767#32 = 13768#32

theorem foo_proof : foo_before ⊑ foo_after

theorem e_606 :
     - 2 * x + 2 * (x |||  ~~~y) - 1 *  ~~~(x &&& y) - 6 *  ~~~(x &&&  ~~~y) + 5 * (x ||| y) - 2 *  ~~~y - 1 *  ~~~(x &&&  ~~~x) + 3 * (x ^^^ y) + 8 *  ~~~(x ||| y) - 4 * (x &&&  ~~~y) =  - 2 * (x &&& y)

theorem and_xor_common_op_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬(x_1 = 0 ∨ x_1 = 0 ∨ x = 0) → x_1 = 0 ∨ x = 0 → False

theorem land_lor_right2_thm.extracted_1._3 : ∀ (x x_1 : BitVec 1), ¬x_1 = 1#1 → ¬x = 1#1 → 0#1 = x_1

theorem test_invalid_simplify_other_thm (e e_1 : IntW 8) :
  select (icmp IntPred.eq e_1 (const? 8 0)) (const? 8 0) (sub e (const? 8 1)) ⊑
    select (icmp IntPred.eq e_1 (const? 8 0)) (const? 8 0) (add e (const? 8 (-1)))

theorem p_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 32),
  True ∧ (x_2 &&& x_1 &&& (x &&& (x_1 ^^^ -1#32)) != 0) = true → False

theorem lshrult_01_01_thm (e : IntW 4) :
  icmp IntPred.ult (lshr e (const? 4 1)) (const? 4 1) ⊑ icmp IntPred.ult e (const? 4 2)

theorem not_false_not_thm.extracted_1._2 : ∀ (x x_1 : BitVec 1), x_1 ^^^ 1#1 = 1#1 → x_1 = 1#1 → 0#1 = x ^^^ 1#1

theorem test87_thm.extracted_1._2 : ∀ (x : BitVec 16),
  ¬(True ∧ (signExtend 32 x).smulOverflow 16#32 = true ∨ 16#32 ≥ ↑32) →
    ¬12#16 ≥ ↑16 → truncate 16 ((signExtend 32 x * 16#32).sshiftRight' 16#32) = x.sshiftRight' 12#16

theorem XorZextXor_thm.extracted_1._1 : ∀ (x : BitVec 3), zeroExtend 5 (x ^^^ 3#3) ^^^ 12#5 = zeroExtend 5 x ^^^ 15#5

theorem e_1900 :
    2 * (b ^^^ (a &&&  ~~~c)) - 11 * (b ^^^  ~~~(a &&& (b ^^^ c))) - 3 * (b &&&  ~~~(a &&&  ~~~c)) - 1 * (b ^^^ (a |||  ~~~c)) - 2 * (a ||| ( ~~~b &&& c)) + 11 * ( ~~~a ||| (b ||| c)) + 2 * (c ||| (a &&&  ~~~b)) - 1 * (a ||| b) - 5 * (c ^^^ (a &&& b)) + 7 * (b ^^^  ~~~(a &&& ( ~~~b &&& c))) + 4 *  ~~~(b &&&  ~~~c) + 7 * (a ^^^ c) - 1 * ((a &&& b) |||  ~~~(a ^^^ (b ^^^ c))) + 7 * (b ^^^ ( ~~~a &&& ( ~~~b ||| c))) + 11 * (b ^^^ ( ~~~a ||| (b &&& c))) + 1 * (b &&& c) + 1 * ((a ^^^ b) ||| (a ^^^ c)) - 5 * (b ^^^ (a ||| (b ^^^ c))) - 6 * (a &&& (b ||| c)) - 2 * ( ~~~(a |||  ~~~b) ||| (b ^^^ c)) + 7 *  ~~~(a ^^^ (b ||| c)) + 2 *  ~~~(a ||| (b &&& c)) - 7 * ( ~~~b &&&  ~~~(a ^^^ c)) + 3 * ( ~~~(a &&& b) &&& (a ^^^ (b ^^^ c))) - 6 * c - 2 * ((a &&& c) ^^^ (a ^^^ ( ~~~b &&& c))) + 11 *  ~~~(a &&&  ~~~b) - 3 * ( ~~~(a |||  ~~~b) |||  ~~~(a ^^^ (b ^^^ c))) + 7 *  ~~~(a |||  ~~~b) + 2 * (a &&&  ~~~c) - 11 *  ~~~(a &&&  ~~~c) + 11 *  ~~~( ~~~a &&& (b ||| c)) - 2 * (b ^^^ ( ~~~a &&& (b ||| c))) + 4 * ( ~~~(a &&& b) &&&  ~~~(a ^^^ (b ^^^ c))) + 4 * (a ^^^ (b &&& c)) + 1 * (c ^^^  ~~~( ~~~a ||| ( ~~~b &&& c))) - 2 *  ~~~(b |||  ~~~c) + 1 * ( ~~~b |||  ~~~(a ^^^ c)) + 2 *  ~~~(b &&& c) + 11 * (b ^^^  ~~~(a ||| ( ~~~b &&& c))) + 1 * ( ~~~(a ||| b) |||  ~~~(b ^^^ c)) - 56 *  ~~~(a ||| (b ||| c)) - 28 *  ~~~(a ||| ( ~~~b ||| c)) - 27 *  ~~~( ~~~a ||| (b ||| c)) - 52 *  ~~~( ~~~a ||| ( ~~~b ||| c)) - 24 * ( ~~~a &&& ( ~~~b &&& c)) - 18 * ( ~~~a &&& (b &&& c)) + 5 * (a &&& ( ~~~b &&& c)) - 37 * (a &&& (b &&& c)) =  - 1 * ((a &&&  ~~~b) ||| (b ^^^ c))

theorem masked_icmps_mask_notallzeros_bmask_mixed_negated_swapped_3b_logical_proof : masked_icmps_mask_notallzeros_bmask_mixed_negated_swapped_3b_logical_before ⊑ masked_icmps_mask_notallzeros_bmask_mixed_negated_swapped_3b_logical_after

theorem test6a_proof : test6a_before ⊑ test6a_after

theorem e_215 :
     - 6 * (x ||| y) + 5 * (x |||  ~~~y) - 3 *  ~~~y + 2 * x + 13 *  ~~~(x |||  ~~~y) + 9 * (x &&&  ~~~y) + 6 * (x &&& y) = 7 *  ~~~(x &&&  ~~~x) - 5 *  ~~~(x ||| y)

theorem test6_thm.extracted_1._2 : ∀ (x : BitVec 64),
  ¬32#128 ≥ ↑128 →
    ¬(32#64 ≥ ↑64 ∨ True ∧ zeroExtend 64 (truncate 32 (x >>> 32#64)) ≠ x >>> 32#64) →
      truncate 32 (zeroExtend 128 x >>> 32#128) = truncate 32 (x >>> 32#64)

theorem ashr_1_thm (e e_1 e_2 : IntW 8) (e_3 : IntW 1) :
  LLVM.xor (ashr (select e_3 (LLVM.xor e_2 (const? 8 (-1))) (LLVM.xor e_1 (const? 8 123))) e) (const? 8 (-1)) ⊑
    ashr (select e_3 e_2 (LLVM.xor e_1 (const? 8 (-124)))) e

theorem test7_proof : test7_before ⊑ test7_after

theorem icmp_select_var_both_fold_thm.extracted_1._2 : ∀ (x x_1 : BitVec 8),
  ¬ofBool (x_1 == 0#8) = 1#1 → ofBool (2#8 == x ||| 1#8) = ofBool (x_1 == 0#8)

theorem sle_or_not_min_commute_thm (e e_1 : IntW 8) :
  LLVM.or (icmp IntPred.ne e_1 (const? 8 (-128))) (icmp IntPred.sle e_1 e) ⊑ const? 1 1

theorem or_trunc_lshr_more_thm.extracted_1._2 : ∀ (x : BitVec 8),
  ¬4#8 ≥ ↑8 →
    ¬(4#6 ≥ ↑6 ∨ True ∧ (truncate 6 x >>> 4#6 &&& BitVec.ofInt 6 (-4) != 0) = true) →
      truncate 6 (x >>> 4#8) ||

theorem testi64i32_ne_thm.extracted_1._1 : ∀ (x : BitVec 64),
  ¬(31#32 ≥ ↑32 ∨ 32#64 ≥ ↑64) →
    ofBool ((truncate 32 x).sshiftRight' 31#32 != truncate 32 (x >>> 32#64)) =
      ofBool (x + BitVec.ofInt 64 (-2147483648) <ᵤ BitVec.ofInt 64 (-4294967296))

theorem zext_sext_add_icmp_slt_1_proof : zext_sext_add_icmp_slt_1_before ⊑ zext_sext_add_icmp_slt_1_after

theorem not_masked_sub_i8_thm (e : IntW 8) :
  sub (const? 8 11) (LLVM.and e (const? 8 7)) ⊑
    sub (const? 8 11) (LLVM.and e (const? 8 7)) { «nsw» := true, «nuw» := true }

theorem thisdoesnotloop_proof : thisdoesnotloop_before ⊑ thisdoesnotloop_after

theorem sext_xor_sub_1_proof : sext_xor_sub_1_before ⊑ sext_xor_sub_1_after

theorem bv_AndOrXor_2658 :
    ∀ (e e_1 : LLVM.IntW w),
      LLVM.xor (LLVM.and e (LLVM.xor e_1 (LLVM.const? w (-1)))) (LLVM.xor e (LLVM.const? w (-1))) ⊑
        LLVM.xor (LLVM.and e e_1) (LLVM.const? w (-1))

@[simp]
lemma enc_length (bvs : BitVecs n) : (enc bvs).length = bvs.w

theorem test1_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬(1#32 ≥ ↑32 ∨
        True ∧ (x.sshiftRight' 1#32 &&& 1431655765#32 ^^^ -1#32).saddOverflow 1#32 = true ∨
          True ∧ x.saddOverflow ((x.sshiftRight' 1#32 &&& 1431655765#32 ^^^ -1#32) + 1#32) = true) →
    1#32 ≥ ↑32 ∨ True ∧ x.ssubOverflow (x >>> 1#32 &&& 1431655765#32) = true → False

theorem ugt_swap_or_not_min_commute_logical_thm (e e_1 : IntW 823) :
  select (icmp IntPred.ne e_1 (const? 823 0)) (const? 1 1) (icmp IntPred.ult e e_1) ⊑
    icmp IntPred.ne e_1 (const? 823 0)

theorem zext_sext_ugt_known_nonneg_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ofBool (signExtend 32 x <ᵤ zeroExtend 32 (x_1 &&& 127#8)) = ofBool (x <ᵤ x_1 &&& 127#8)

theorem and_nosignbit_select_lshr_proof : and_nosignbit_select_lshr_before ⊑ and_nosignbit_select_lshr_after

theorem main7d_logical_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 32),
  ¬ofBool (x_2 &&& (x_1 &&& x) == x_1 &&& x) = 1#1 →
    ofBool (x_2 &&& (x_1 &&& x) != x_1 &&& x) = 1#1 → 0#1 = 1#1 → 0#32 = zeroExtend 32 1#1

theorem bools_logical_proof : bools_logical_before ⊑ bools_logical_after

theorem main13_logical_thm (e : IntW 32) :
  select
      (select (icmp IntPred.slt (trunc 16 e) (const? 16 0)) (icmp IntPred.slt (trunc 8 e) (const? 8 0))
        (const? 1 0))
      (const? 32 2) (const? 32 1) ⊑
    select (icmp IntPred.eq (LLVM.and e (const? 32 32896)) (const? 32 32896)) (const? 32 2) (const? 32 1)

theorem bools_logical_commute0_thm.extracted_1._15 : ∀ (x x_1 x_2 : BitVec 1),
  x_2 ^^^ 1#1 = 1#1 → ¬x_2 = 1#1 → ¬x_1 = 1#1 → 0#1 = x_1

@[simp] theorem toCom_nil {com : Com d Γ eff ty} : toCom ⟨.nil, com⟩ = com

theorem Predicate.eval_eq_denote (w : Nat) (p : Predicate) (vars : List (BitVec w)) :
    (p.eval (vars.map .ofBitVecSext) w = false) ↔ p.denote w vars

theorem ashrslt_01_02_proof : ashrslt_01_02_before ⊑ ashrslt_01_02_after

theorem Predicate.evalEq_denote_false_iff {w : Nat} (a b : Term) (vars : List (BitVec w)) :
    evalEq (a.eval (List.map .ofBitVecSext vars)) (b.eval (List.map .ofBitVecSext vars)) w = false ↔
    Term.denote w a vars = Term.denote w b vars

theorem e_459 :
     - 3 *  ~~~(x &&&  ~~~y) - 1 *  ~~~(x &&&  ~~~x) - 1 * (x ||| y) + 4 * (x ^^^ y) - 3 * x + 2 *  ~~~x - 2 *  ~~~(x ||| y) - 1 *  ~~~(x |||  ~~~y) - 3 * (x &&&  ~~~y) =  - 8 * (x &&& y) - 4 *  ~~~y

theorem and_not_or_or_not_or_xor_commute2_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 32),
  ¬((x_2 == 0 || 32 != 1 && 42#32 == intMin 32 && x_2 == -1) = true ∨
        (x_2 == 0 || 32 != 1 && 42#32 == intMin 32 && x_2 == -1) = true) →
    (x_2 == 0 || 32 != 1 && 42#32 == intMin 32 && x_2 == -1) = true → False

theorem test17_thm (e : IntW 106) :
  icmp IntPred.eq (lshr e (const? 106 3)) (const? 106 1234) ⊑
    icmp IntPred.eq (LLVM.and e (const? 106 (-8))) (const? 106 9872)

theorem exactly_one_set_signbit_wrong_pred_thm (e e_1 : IntW 8) :
  icmp IntPred.sgt (lshr e_1 (const? 8 7)) (zext 8 (icmp IntPred.sgt e (const? 8 (-1)))) ⊑
    icmp IntPred.slt (LLVM.and e e_1) (const? 8 0)

theorem ashr_exact_eq_0_proof : ashr_exact_eq_0_before ⊑ ashr_exact_eq_0_after

theorem e_1128 :
    7 * (z ^^^ t) + 1 *  ~~~(z ^^^ t) - 7 *  ~~~z - 3 *  ~~~(z &&& t) + 11 * t + 9 *  ~~~(z ||| t) - 8 *  ~~~(z |||  ~~~t) - 4 * (z &&&  ~~~t) = 12 * (z &&& t)

theorem exact_lshr_ne_proof : exact_lshr_ne_before ⊑ exact_lshr_ne_after

theorem test_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬(17#32 ≥ ↑32 ∨ 17#32 ≥ ↑32) → ¬31#32 ≥ ↑32 → (x.sshiftRight' 17#32).sshiftRight' 17#32 = x.sshiftRight' 31#32

theorem Tensor2d'.map_functorial (g : β → γ) (f : α → β) (t : Tensor2d' α) :
  t.map (g ∘ f) = (t.map f).map g

theorem e_1266 :
    3 *  ~~~z + 1 * z + 11 *  ~~~(z &&&  ~~~z) - 6 * t - 1 *  ~~~(z &&& t) - 13 *  ~~~(z ||| t) - 9 *  ~~~(z |||  ~~~t) - 13 * (z &&&  ~~~t) - 6 * (z &&& t) =  - 2 * (z ^^^ t)

theorem demorgan_nand_apint2_thm (e e_1 : IntW 117) :
  LLVM.xor (LLVM.and (LLVM.xor e_1 (const? 117 (-1))) e) (const? 117 (-1)) ⊑
    LLVM.or e_1 (LLVM.xor e (const? 117 (-1)))

theorem icmp_ule_thm (e e_1 : IntW 32) : icmp IntPred.ule (lshr e_1 e) e_1 ⊑ const? 1 1

theorem logic_or_logic_and_2_proof : logic_or_logic_and_2_before ⊑ logic_or_logic_and_2_after

theorem scalar_i32_signbit_lshr_and_eq_nonzero_proof : scalar_i32_signbit_lshr_and_eq_nonzero_before ⊑ scalar_i32_signbit_lshr_and_eq_nonzero_after

theorem or_nand_xor_common_op_commute0_thm (e e_1 e_2 : IntW 4) :
  LLVM.or (LLVM.xor (LLVM.and e_2 e_1) (const? 4 (-1))) (LLVM.xor e_2 e) ⊑
    LLVM.xor (LLVM.and (LLVM.and e_2 e_1) e) (const? 4 (-1))

@[simp] theorem bv_isRefinedBy_iff (x y : BitVec w) : x ⊑ y ↔ x = y

theorem bv_275 :
    ∀ (e e_1 : LLVM.IntW 5), LLVM.mul (LLVM.udiv e_1 e) e ⊑ LLVM.sub e_1 (LLVM.urem e_1 e)

theorem t3_exact_thm.extracted_1._2 : ∀ (x : BitVec 64),
  ¬(True ∧ x >>> 63#64 <<< 63#64 ≠ x ∨ 63#64 ≥ ↑64) →
    ¬(True ∧ x >>> 63#64 <<< 63#64 ≠ x ∨
          63#64 ≥ ↑64 ∨
            True ∧ signExtend 64 (truncate 32 (x >>> 63#64)) ≠ x >>> 63#64 ∨
              True ∧ zeroExtend 64 (truncate 32 (x >>> 63#64)) ≠ x >>> 63#64) →
      0#32 - truncate 32 (x.sshiftRight' 63#64) = truncate 32 (x >>> 63#64)

theorem test1_proof : test1_before ⊑ test1_after

theorem R.representative'_zero_ideal : R.representative' q n 0 ∈ Ideal.span {f q n}

theorem bv_AndOrXor_1294_A__B__A__B___A__B :
    ∀ (e e_1 : LLVM.IntW w), LLVM.and (LLVM.or e e_1) (LLVM.xor (LLVM.xor e (LLVM.const? w (-1))) e_1) ⊑ LLVM.and e e_1

theorem rawspeed_signbit_thm.extracted_1._1 : ∀ (x : BitVec 64) (x_1 : BitVec 32),
  ¬(True ∧ x_1.saddOverflow (-1#32) = true ∨
        x_1 + -1#32 ≥ ↑32 ∨ True ∧ (64#32).ssubOverflow x_1 = true ∨ zeroExtend 64 (64#32 - x_1) ≥ ↑64) →
    ofBool (1#32 <<< (x_1 + -1#32) &&& truncate 32 (x >>> zeroExtend 64 (64#32 - x_1)) == 0#32) = ofBool (-1#64 <ₛ x)

theorem sub_ashr_and_i32_commute_thm (e e_1 : IntW 32) :
  LLVM.and e_1 (ashr (sub e e_1 { «nsw» := true, «nuw» := false }) (const? 32 31)) ⊑
    select (icmp IntPred.slt e e_1) e_1 (const? 32 0)

theorem basic_preserve_nsw_thm.extracted_1._2 : ∀ (x x_1 : BitVec 8),
  ¬(True ∧ (x_1 ^^^ -1#8).saddOverflow x = true) →
    ¬(True ∧ x_1.ssubOverflow x = true) → (x_1 ^^^ -1#8) + x ^^^ -1#8 = x_1 - x

theorem icmp_select_const_proof : icmp_select_const_before ⊑ icmp_select_const_after

theorem bools_multi_uses2_logical_thm.extracted_1._7 : ∀ (x x_1 : BitVec 1),
  ¬x_1 ^^^ 1#1 = 1#1 → ¬x_1 = 1#1 → 0#1 = 1#1 → x = 1#1 → True → 0#1 + 0#1 = 0#1 ^^^ 0#1

theorem n0_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 8),
  ¬x_2 ≥ ↑8 → True ∧ ((-1#8) <<< x_2).sshiftRight' x_2 ≠ -1#8 ∨ x_2 ≥ ↑8 → False

theorem lshr_x_by_const_cmp_x_proof : lshr_x_by_const_cmp_x_before ⊑ lshr_x_by_const_cmp_x_after

theorem srem_constant_dividend_select_of_constants_divisor_0_arm_proof : srem_constant_dividend_select_of_constants_divisor_0_arm_before ⊑ srem_constant_dividend_select_of_constants_divisor_0_arm_after

theorem trunc_shl_lshr_infloop_thm.extracted_1._2 : ∀ (x : BitVec 64),
  ¬(1#64 ≥ ↑64 ∨ 2#64 ≥ ↑64) →
    ¬1#32 ≥ ↑32 → truncate 32 (x >>> 1#64 <<< 2#64) = truncate 32 x <<< 1#32 &&& BitVec.ofInt 32 (-4)

theorem bv_AndOrXor_1683_2 :
    ∀ (e e_1 : LLVM.IntW w), LLVM.or (LLVM.icmp LLVM.IntPred.uge e e_1) (LLVM.icmp LLVM.IntPred.ne e e_1) ⊑ LLVM.const? 1 1

theorem trunc_equality_nuw_thm.extracted_1._1 : ∀ (x x_1 : BitVec 16),
  ¬(True ∧ zeroExtend 16 (truncate 8 x_1) ≠ x_1 ∨ True ∧ zeroExtend 16 (truncate 8 x) ≠ x) →
    ofBool (truncate 8 x_1 == truncate 8 x) = ofBool (x_1 == x)

theorem PR30273_three_bools_thm.extracted_1._8 : ∀ (x x_1 x_2 : BitVec 1),
  ¬x_2 = 1#1 →
    x_1 = 1#1 →
      ¬(True ∧ (zeroExtend 32 x).saddOverflow 1#32 = true) →
        x = 1#1 →
          ¬(True ∧ (2#32).saddOverflow (zeroExtend 32 x_2) = true ∨
                True ∧ (2#32).uaddOverflow (zeroExtend 32 x_2) = true) →
            zeroExtend 32 x + 1#32 = 2#32 + zeroExtend 32 x_2

theorem select_icmp_eq_and_1_0_or_2_proof : select_icmp_eq_and_1_0_or_2_before ⊑ select_icmp_eq_and_1_0_or_2_after

@[simp] theorem Valuation.append_appendInr {v : Var Δ t} :
    (V ++ W) v.appendInr = W v

theorem pow2_or_zero_is_not_negative_commute_thm (e : IntW 8) :
  icmp IntPred.sgt (LLVM.and (sub (const? 8 0) (mul (const? 8 42) e)) (mul (const? 8 42) e)) (const? 8 (-1)) ⊑
    icmp IntPred.ne (mul e (const? 8 42)) (const? 8 (-128))

theorem select_or_icmp_bad_proof : select_or_icmp_bad_before ⊑ select_or_icmp_bad_after

theorem test_nuw_and_unsigned_pred_thm (e : IntW 64) :
  icmp IntPred.ult (sub (const? 64 10) e { «nsw» := false, «nuw» := true }) (const? 64 3) ⊑
    icmp IntPred.ugt e (const? 64 7)

theorem test_sub_4_Y_ne_4_proof : test_sub_4_Y_ne_4_before ⊑ test_sub_4_Y_ne_4_after

theorem alive_InstCombineShift__582 : alive_InstCombineShift__582_src ⊑ alive_InstCombineShift__582_tgt

theorem neg_test_icmp_non_equality_proof : neg_test_icmp_non_equality_before ⊑ neg_test_icmp_non_equality_after

theorem shl_sub_no_commute_proof : shl_sub_no_commute_before ⊑ shl_sub_no_commute_after

theorem select_2_thm.extracted_1._14 : ∀ (x x_1 x_2 : BitVec 8) (x_3 x_4 : BitVec 1),
  x_4 = 1#1 → x_3 = 1#1 → x_2 ^^^ -1#8 ^^^ -1#8 = x_2

theorem sext_multiuse_proof : sext_multiuse_before ⊑ sext_multiuse_after

theorem select_bittest_to_shl_negative_test_proof : select_bittest_to_shl_negative_test_before ⊑ select_bittest_to_shl_negative_test_after

theorem slt_swap_or_not_max_commute_proof : slt_swap_or_not_max_commute_before ⊑ slt_swap_or_not_max_commute_after

@[simp] theorem pure_le (e : EffectKind) : pure ≤ e

theorem test2_proof : test2_before ⊑ test2_after

@[simp]
theorem Valuation.ofPair_fst {t₁ t₂ : Ty} (v₁: ⟦t₁⟧) (v₂ : ⟦t₂⟧) :
  (Ctxt.Valuation.ofPair v₁ v₂) ⟨0, by rfl⟩ = v₁

theorem not_or_or_and_not_and_and_commute1_and_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 32),
  (x_2 ^^^ -1#32 ||| x_1 ||| x) &&& (x &&& x_2 &&& x_1 ^^^ -1#32) = x ^^^ x_1 ||

theorem p0_thm (e e_1 : IntW 8) :
  icmp IntPred.ult (LLVM.xor (shl (const? 8 (-1)) e_1) (const? 8 (-1))) e ⊑
    icmp IntPred.ne (lshr e e_1) (const? 8 0)

theorem xor_nosignbit_lshr_thm (e : IntW 32) :
  lshr (LLVM.xor e (const? 32 2147418112)) (const? 32 8) ⊑ LLVM.xor (lshr e (const? 32 8)) (const? 32 8388352)

theorem shl_xor_thm (e : IntW 8) :
  LLVM.xor (shl (const? 8 16) e) (shl (const? 8 3) (add e (const? 8 1))) ⊑ shl (const? 8 22) e

theorem icmp_sle_x_negy_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ofBool ((x_1 ||| BitVec.ofInt 8 (-128)) &&& x ≤ₛ x) = 1#1

@[simp]
lemma evalRelation_coe (rel : Relation) (bv1 bv2 : BitVec w1) (heq : w1 = w2) :
    evalRelation rel (heq ▸ bv1) (heq ▸ bv2) = evalRelation rel bv1 bv2

theorem sext_ule_sext_thm.extracted_1._1 : ∀ (x : BitVec 1) (x_1 : BitVec 8),
  ofBool (signExtend 16 (x_1 * x_1) ≤ᵤ signExtend 16 x) = ofBool (x_1 * x_1 == 0#8) ||

theorem t2_proof : t2_before ⊑ t2_after

theorem xor_common_op_commute2_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  x_1 ^^^ 5#8 ||

theorem shl_lshr_demand3_thm (e : IntW 8) :
  LLVM.or (lshr (shl (const? 8 40) e) (const? 8 3)) (const? 8 (-64)) ⊑
    LLVM.or (lshr (shl (const? 8 40) e) (const? 8 3) { «exact» := true }) (const? 8 (-64))
      { «disjoint» := true }

theorem select_non_const_sides_thm.extracted_1._3 : ∀ (x x_1 : BitVec 64) (x_2 : BitVec 1),
  x_2 = 1#1 → x_1 - zeroExtend 64 x_2 = x_1 + -1#64

@[simp]
theorem eval_fsmUnaryMax_eq_decide
  (a : NatFSM wcard tcard bcard ncard icard pcard (.ofDep v))
  (b : NatFSM wcard tcard bcard ncard icard pcard (.ofDep w))
  {wenv : WidthExpr.Env wcard}
  {fsmEnv : StateSpace wcard tcard bcard ncard icard pcard → BitStream}
  (henv : HWidthEnv fsmEnv wenv)
  (ha : HNatFSMToBitstream a) (hb : HNatFSMToBitstream b) :
  ((fsmUnaryMax a.toFsm b.toFsm).eval fsmEnv) i =
    (i < (max (v.toNat wenv) (w.toNat wenv)))

theorem src_x_and_nmask_uge_thm.extracted_1._7 : ∀ (x : BitVec 8) (x_1 : BitVec 1) (x_2 : BitVec 8),
  ¬x_1 = 1#1 → ¬x_1 ^^^ 1#1 = 1#1 → True ∧ ((-1#8) <<< x).sshiftRight' x ≠ -1#8 ∨ x ≥ ↑8 → False

theorem ashrslt_03_12_exact_proof : ashrslt_03_12_exact_before ⊑ ashrslt_03_12_exact_after

theorem t0_proof : t0_before ⊑ t0_after

theorem slt_proof : slt_before ⊑ slt_after

theorem test83_thm.extracted_1._2 : ∀ (x : BitVec 64) (x_1 : BitVec 16),
  ¬(True ∧ x.saddOverflow (-1#64) = true ∨ truncate 32 (x + -1#64) ≥ ↑32) →
    ¬truncate 32 x + -1#32 ≥ ↑32 →
      zeroExtend 64 (signExtend 32 x_1 <<< truncate 32 (x + -1#64)) =
        zeroExtend 64 (signExtend 32 x_1 <<< (truncate 32 x + -1#32))

theorem bools2_logical_commute1_thm.extracted_1._7 : ∀ (x x_1 : BitVec 1),
  ¬x_1 = 1#1 → ¬x ^^^ 1#1 = 1#1 → x = 1#1 → 0#1 = 1#1 → 1#1 = x_1

theorem bitwise_and_logical_and_icmps_comm3_thm.extracted_1._5 : ∀ (x x_1 x_2 : BitVec 8),
  ¬x_1 ≥ ↑8 →
    ofBool (x_2 &&& 1#8 != 0#8) = 1#1 →
      ¬(True ∧ 1#8 <<< x_1 >>> x_1 ≠ 1#8 ∨ x_1 ≥ ↑8 ∨ True ∧ 1#8 <<< x_1 >>> x_1 ≠ 1#8 ∨ x_1 ≥ ↑8) →
        ¬ofBool (x_2 &&& (1#8 <<< x_1 ||| 1#8) == 1#8 <<< x_1 ||| 1#8) = 1#1 →
          ofBool (x_2 &&& 1#8 <<< x_1 != 0#8) &&& ofBool (x == 42#8) = 0#1

theorem ashr_sel_op1_proof : ashr_sel_op1_before ⊑ ashr_sel_op1_after

theorem test56_thm.extracted_1._1 : ∀ (x : BitVec 16),
  ¬5#32 ≥ ↑32 → 5#32 ≥ ↑32 ∨ True ∧ (signExtend 32 x >>> 5#32).msb = true → False

theorem negate_select_of_op_vs_negated_op_nsw_commuted_thm (e : IntW 8) (e_1 : IntW 1) (e_2 : IntW 8) :
  sub e_2 (select e_1 e (sub (const? 8 0) e { «nsw» := true, «nuw» := false })) ⊑
    add (select e_1 (sub (const? 8 0) e) e) e_2

theorem n3_constmask_samemask_proof : n3_constmask_samemask_before ⊑ n3_constmask_samemask_after

theorem test11d_proof : test11d_before ⊑ test11d_after

theorem test6_thm (e : IntW 32) :
  add (sext 64 (ashr e (const? 32 1))) (const? 64 (-1073741824)) ⊑
    sext 64 (add (ashr e (const? 32 1)) (const? 32 (-1073741824)) { «nsw» := true, «nuw» := false })

theorem src_fv_ne_proof : src_fv_ne_before ⊑ src_fv_ne_after

theorem main12_logical_proof : main12_logical_before ⊑ main12_logical_after

theorem slt_smin3_thm (e e_1 : IntW 32) :
  icmp IntPred.sgt (add e_1 (const? 32 3))
      (select (icmp IntPred.slt (add e_1 (const? 32 3)) e) (add e_1 (const? 32 3)) e) ⊑
    icmp IntPred.slt e (add e_1 (const? 32 3))

theorem main4f_like_logical_thm.extracted_1._5 : ∀ (x x_1 x_2 : BitVec 32),
  ofBool (x_2 &&& x_1 != x_1) = 1#1 →
    ofBool (x_2 &&& x_1 == x_1) = 1#1 → True → 0#32 = zeroExtend 32 (ofBool (x_2 &&& x == x))

theorem logic_and_logic_or_3_thm.extracted_1._9 : ∀ (x x_1 x_2 : BitVec 1),
  ¬x_2 = 1#1 → x = 1#1 → 0#1 = 1#1 → 1#1 = x_1

theorem icmp_slt_0_and_icmp_sgt_neg1_i64_thm.extracted_1._1 : ∀ (x : BitVec 64),
  ¬63#64 ≥ ↑64 → x >>> 63#64 &&& zeroExtend 64 (ofBool (-1#64 <ₛ x)) = 0#64

theorem nonexact_lshr_ne_noexactlog_proof : nonexact_lshr_ne_noexactlog_before ⊑ nonexact_lshr_ne_noexactlog_after

@[bv_automata_preprocess] theorem BitVec.mul_nat_eq_ofNat_mul (x : BitVec w) (n : Nat) :
  x * n = BitVec.ofNat w n * x

theorem icmp_power2_and_icmp_shifted_mask_swapped_2147483648_805306368_proof : icmp_power2_and_icmp_shifted_mask_swapped_2147483648_805306368_before ⊑ icmp_power2_and_icmp_shifted_mask_swapped_2147483648_805306368_after

theorem lor_lor_left1_proof : lor_lor_left1_before ⊑ lor_lor_left1_after

theorem xor_ashr_not_fail_invalid_xor_constant_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 8),
  ¬(x_1 ≥ ↑8 ∨ x_1 ≥ ↑8) → x_1 ≥ ↑8 → False

theorem t0_thm.extracted_1._8 : ∀ (x x_1 : BitVec 8) (x_2 : BitVec 1),
  x_2 ^^^ 1#1 = 1#1 → ¬x_2 = 1#1 → ¬True → 0#1 = 1#1 → False

theorem test_lshr_exact__exact_is_unsafe_proof : test_lshr_exact__exact_is_unsafe_before ⊑ test_lshr_exact__exact_is_unsafe_after

theorem test4_proof : test4_before ⊑ test4_after

theorem add_constant_equal_with_the_top_bit_of_demandedbits_pass_proof : add_constant_equal_with_the_top_bit_of_demandedbits_pass_before ⊑ add_constant_equal_with_the_top_bit_of_demandedbits_pass_after

theorem test5_thm.extracted_1._1 : ∀ (x : BitVec 32), x &&& x = x

theorem ult_2_proof : ult_2_before ⊑ ult_2_after

theorem lshrult_03_11_exact_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬(True ∧ x >>> 3#4 <<< 3#4 ≠ x ∨ 3#4 ≥ ↑4) → ofBool (x >>> 3#4 <ᵤ BitVec.ofInt 4 (-5)) = 1#1

theorem masked_icmps_mask_notallzeros_bmask_mixed_1_logical_proof : masked_icmps_mask_notallzeros_bmask_mixed_1_logical_before ⊑ masked_icmps_mask_notallzeros_bmask_mixed_1_logical_after

theorem or_test2_thm.extracted_1._1 : ∀ (x : BitVec 7),
  ¬6#7 ≥ ↑7 → x <<< 6#7 ||

theorem sdiv_icmp6_thm.extracted_1._1 : ∀ (x : BitVec 64),
  ¬(True ∧ x.smod (BitVec.ofInt 64 (-5)) ≠ 0 ∨
        (BitVec.ofInt 64 (-5) == 0 || 64 != 1 && x == intMin 64 && BitVec.ofInt 64 (-5) == -1) = true) →
    ofBool (x.sdiv (BitVec.ofInt 64 (-5)) == -1#64) = ofBool (x == 5#64)

theorem icmp_sgt6_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬(True ∧ (x <<< 1#8).sshiftRight' 1#8 ≠ x ∨ 1#8 ≥ ↑8) → ofBool (16#8 <ₛ x <<< 1#8) = ofBool (8#8 <ₛ x)

theorem test_logical_or_eq_a_b_proof : test_logical_or_eq_a_b_before ⊑ test_logical_or_eq_a_b_after

@[simp]
lemma RawCNFA.autSignedCmp_m_wf : autSignedCmp.m.1 |>.WF

theorem main5e_like_logical_thm (e e_1 e_2 : IntW 32) :
  select (select (icmp IntPred.eq (LLVM.and e_2 e_1) e_2) (icmp IntPred.eq (LLVM.and e_2 e) e_2) (const? 1 0))
      (const? 32 0) (const? 32 1) ⊑
    zext 32
      (select (icmp IntPred.ne (LLVM.and e_2 e_1) e_2) (const? 1 1)
        (icmp IntPred.ne (LLVM.and e_2 e) e_2))

omit [LawfulBEq A] [Fintype S] [DecidableEq S] in
lemma processOneElem_visited (st : worklist.St A S) :
    let st' := processOneElem _ _  final s st (a, sa')
    st'.visited = st.visited

theorem bv_AddSub_1614 :
    ∀ (e e_1 : LLVM.IntW w), LLVM.sub e_1 (LLVM.add e_1 e) ⊑ LLVM.sub (LLVM.const? w 0) e

theorem max_of_min_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (0#32 <ₛ x) = 1#1 → ofBool (-1#32 <ₛ x ^^^ -1#32) = 1#1 ∧ ofBool (0#32 <ₛ x) = 1#1 → x ^^^ -1#32 = -1#32

theorem bools2_logical_commute0_thm.extracted_1._18 : ∀ (x x_1 x_2 : BitVec 1),
  ¬x_2 = 1#1 → ¬x_2 ^^^ 1#1 = 1#1 → 0#1 = 1#1 → 1#1 = x

theorem testtrunclowhigh_thm.extracted_1._2 : ∀ (x : BitVec 16) (x_1 : BitVec 32),
  ¬ofBool (x_1 + 128#32 <ᵤ 256#32) = 1#1 → ¬ofBool (-1#32 <ₛ x_1) = 1#1 → ¬ofBool (x_1 <ₛ 0#32) = 1#1 → False

theorem eq_nsw_rem_nz_thm (e : IntW 8) :
  icmp IntPred.eq (mul e (const? 8 5) { «nsw» := true, «nuw» := false }) (const? 8 (-11)) ⊑ const? 1 0

theorem test22_proof : test22_before ⊑ test22_after

theorem sel_false_val_is_a_masked_ashr_of_true_val1_proof : sel_false_val_is_a_masked_ashr_of_true_val1_before ⊑ sel_false_val_is_a_masked_ashr_of_true_val1_after

@[simp]
theorem BitVec.zero_concat (b : Bool) : (0#0).concat b = BitVec.ofBool b

theorem eq_21_comm_eq_thm (e e_1 : IntW 32) :
  LLVM.and (icmp IntPred.eq (trunc 8 (lshr e_1 (const? 32 16))) (trunc 8 (lshr e (const? 32 16))))
      (icmp IntPred.eq (trunc 8 (lshr e (const? 32 8))) (trunc 8 (lshr e_1 (const? 32 8)))) ⊑
    icmp IntPred.eq (trunc 16 (lshr e_1 (const? 32 8))) (trunc 16 (lshr e (const? 32 8)))

theorem or_nontrivial_mask1_proof : or_nontrivial_mask1_before ⊑ or_nontrivial_mask1_after

theorem t3_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬(32#32 - x ≥ ↑32 ∨ zeroExtend 64 (x + BitVec.ofInt 32 (-16)) ≥ ↑64) →
    ofBool (x_1 <<< (32#32 - x) &&& truncate 32 (131071#64 >>> zeroExtend 64 (x + BitVec.ofInt 32 (-16))) != 0#32) =
      ofBool (x_1 &&& 1#32 != 0#32)

theorem or_nontrivial_mask1_thm.extracted_1._1 : ∀ (x : BitVec 16),
  ofBool (truncate 8 x != 127#8) ||

lemma CNFA.addSink_spec (m : CNFA n) (M : NFA' n) :
    m.Sim M →
    m.addSink.Sim M.complete

@[simp] theorem cons_getElem_toCons (x : A a) (v : Var Γ u)
    (h : as = Γ.toList := by rfl) (h' : a :: as = (Γ.cons a).toList := by rfl) :
    (HVector.cons x xs)[v.toCons (t' := a)]'h' = xs[v]'h

theorem and_umax_less_proof : and_umax_less_before ⊑ and_umax_less_after

theorem canonicalize_logic_first_or0_nswnuw_proof : canonicalize_logic_first_or0_nswnuw_before ⊑ canonicalize_logic_first_or0_nswnuw_after

theorem udiv_i8_thm (e e_1 : IntW 8) : trunc 8 (LLVM.udiv (zext 32 e_1) (zext 32 e)) ⊑ LLVM.udiv e_1 e

theorem or_simplify_ult_proof : or_simplify_ult_before ⊑ or_simplify_ult_after

theorem lshr_shl_pow2_const_case2_proof : lshr_shl_pow2_const_case2_before ⊑ lshr_shl_pow2_const_case2_after

theorem urem_constant_dividend_select_of_constants_divisor_0_arm_thm (e : IntW 1) : urem (const? 32 42) (select e (const? 32 12) (const? 32 0)) ⊑ const? 32 6

theorem neg_not_signbit2_thm (e : IntW 8) :
  sub (const? 32 0) (zext 32 (lshr e (const? 8 6))) ⊑
    sub (const? 32 0) (zext 32 (lshr e (const? 8 6)) { «nneg» := true }) { «nsw» := true, «nuw» := false }

theorem sge_to_ugt_proof : sge_to_ugt_before ⊑ sge_to_ugt_after

theorem invert_both_cmp_operands_sub_thm (e e_1 : IntW 32) :
  icmp IntPred.ult (sub (LLVM.xor e_1 (const? 32 (-1))) e) (const? 32 42) ⊑
    icmp IntPred.ugt (add e_1 e) (const? 32 (-43))

theorem alive_constant_fold_10: forall (w : Nat), TSSA.eval
  (Op := Op) (e := e)
  (i := TSSAIndex.STMT (UserType.base (BaseType.bitvec w)))
  [dsl_bb|
  ^bb
  %v0 := unit: ;
  %v1 := op:const (Bitvec.ofInt w (0)) %v0
  dsl_ret %v1
  ]  ⊑
  TSSA.eval
  (Op := Op) (e := e)
  (i := TSSAIndex.STMT (UserType.base (BaseType.bitvec w)))
  [dsl_bb|
  ^bb
  %v000 := unit: ;
  %v001 := op:const (Bitvec.ofInt w (0)) %v000;
  %v100 := pair:%v001 %v001;
  %v101 := op:add w %v100;
  %v110 := pair:%v101 %v001;
  %v111 := op:add w %v110;
  %v120 := pair:%v111 %v001;
  %v121 := op:add w %v120;
  %v130 := pair:%v121 %v001;
  %v131 := op:add w %v130;
  %v140 := pair:%v131 %v001;
  %v141 := op:add w %v140;
  %v150 := pair:%v141 %v001;
  %v151 := op:add w %v150;
  %v160 := pair:%v151 %v001;
  %v161 := op:add w %v160;
  %v170 := pair:%v161 %v001;
  %v171 := op:add w %v170;
  %v180 := pair:%v171 %v001;
  %v181 := op:add w %v180;
  %v190 := pair:%v181 %v001;
  %v191 := op:add w %v190
  dsl_ret %v191
  ]

theorem basic_preserve_nuw_nsw_thm (e e_1 : IntW 8) :
  LLVM.xor (add (LLVM.xor e_1 (const? 8 (-1))) e { «nsw» := true, «nuw» := true }) (const? 8 (-1)) ⊑
    sub e_1 e { «nsw» := true, «nuw» := true }

theorem ult_rem_zero_nsw_thm (e : IntW 8) :
  icmp IntPred.ult (mul e (const? 8 7) { «nsw» := true, «nuw» := true }) (const? 8 21) ⊑
    icmp IntPred.ult e (const? 8 3)

theorem ult_and_max_commute_logical_proof : ult_and_max_commute_logical_before ⊑ ult_and_max_commute_logical_after

theorem test_lshr__exact_is_unsafe_thm.extracted_1._2 : ∀ (x : BitVec 64) (x_1 : BitVec 32),
  ofBool (x_1 &&& 63#32 == 0#32) = 1#1 →
    ¬(2#32 ≥ ↑32 ∨ True ∧ (x_1 >>> 2#32 &&& 15#32).msb = true ∨ zeroExtend 64 (x_1 >>> 2#32 &&& 15#32) ≥ ↑64) →
      x = x.sshiftRight' (zeroExtend 64 (x_1 >>> 2#32 &&& 15#32))

theorem ashr_exact_poison_constant_fold_thm.extracted_1._2 : ∀ (x : BitVec 8) (x_1 : BitVec 1),
  x_1 = 1#1 → 3#8 ≥ ↑8 → ¬(True ∧ x >>> 3#8 <<< 3#8 ≠ x ∨ 3#8 ≥ ↑8) → False

theorem ashrsgt_02_12_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬2#4 ≥ ↑4 → ofBool (BitVec.ofInt 4 (-4) <ₛ x.sshiftRight' 2#4) = 1#1

theorem trunc_sel_equal_sext_thm.extracted_1._1 : ∀ (x : BitVec 1), ¬x = 1#1 → signExtend 32 42#16 = 42#32

theorem foo_proof : foo_before ⊑ foo_after

theorem lowmask_or_zext_commute_proof : lowmask_or_zext_commute_before ⊑ lowmask_or_zext_commute_after

theorem modulo32_proof : modulo32_before ⊑ modulo32_after

@[deprecated "liftEffect_eq_pure_cast_of" (since := "")]
theorem liftEffect_pure [Pure m] {e} (hle : e ≤ pure) :
    liftEffect hle (α := α) (m := m) = cast (by rw [eq_of_le_pure hle])

theorem test10_thm (e : IntW 123) : LLVM.and (LLVM.and e (const? 123 127)) (const? 123 128) ⊑ const? 123 0

@[simp]
theorem denote_splitProgramAt [LawfulMonad d.m] {pos : ℕ} {prog : Com d Γ eff t}
    {res : _} (hres : res ∈ splitProgramAt pos prog) :
    res.denote = prog.denote

theorem select_icmp_ne_0_and_1073741824_and_not_8_proof : select_icmp_ne_0_and_1073741824_and_not_8_before ⊑ select_icmp_ne_0_and_1073741824_and_not_8_after

theorem test_add__nuw_is_safe_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x &&& 2147483647#32 == 2147483647#32) = 1#1 → True ∧ (x &&& 2147483647#32).uaddOverflow 1#32 = true → False

theorem scalar_i16_lshr_and_negC_eq_thm.extracted_1._1 : ∀ (x x_1 : BitVec 16),
  ¬x ≥ ↑16 → ofBool (x_1 >>> x &&& BitVec.ofInt 16 (-128) == 0#16) = ofBool (x_1 >>> x <ᵤ 128#16)

theorem zext_nneg_sext_ule_op0_wide_thm (e : IntW 8) (e_1 : IntW 9) :
  icmp IntPred.ule (zext 32 e_1 { «nneg» := true }) (sext 32 e) ⊑ icmp IntPred.ule e_1 (sext 9 e)

theorem test15_commuted_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  (x_1 ^^^ -1#32) &&& x ^^^ (x ^^^ -1#32) &&& x_1 = x ^^^ x_1

theorem scalar_i64_signbit_lshr_and_eq_proof : scalar_i64_signbit_lshr_and_eq_before ⊑ scalar_i64_signbit_lshr_and_eq_after

theorem BitVec.getLsbD_eq_toInt_testBit' (b : BitVec w) (hk : k < w) : b.getLsbD k = b.toInt.testBit' k

theorem test2_proof : test2_before ⊑ test2_after

theorem test_ashr_exact__exact_is_safe_thm.extracted_1._1 : ∀ (x : BitVec 64) (x_1 : BitVec 32),
  ofBool (x_1 &&& BitVec.ofInt 32 (-2147483588) == 0#32) = 1#1 →
    2#32 ≥ ↑32 ∨
        True ∧ (x_1.sshiftRight' 2#32 &&& BitVec.ofInt 32 (-536870897)).msb = true ∨
          zeroExtend 64 (x_1.sshiftRight' 2#32 &&& BitVec.ofInt 32 (-536870897)) ≥ ↑64 →
      False

theorem test5_proof : test5_before ⊑ test5_after

theorem e_2168 :
     - 2 * ((d ||| e) &&&  ~~~(e ^^^ f)) - 1 * (f ^^^  ~~~(d &&& ( ~~~e &&& f))) + 7 * (f ^^^ ( ~~~d ||| ( ~~~e ||| f))) - 11 * ( ~~~f &&& (d ^^^ e)) + 4 *  ~~~(e ^^^ f) + 2 * (f ^^^ (d &&& (e ||| f))) - 2 * (e ^^^ ( ~~~d ||| (e &&& f))) - 7 * ( ~~~d ||| (e ^^^ f)) + 3 * ((d &&& e) |||  ~~~(d ^^^ (e ^^^ f))) + 1 * ((d &&& f) ^^^ (d ^^^ ( ~~~e &&& f))) + 5 *  ~~~(d ^^^ f) + 11 * (e &&&  ~~~(d ^^^ f)) + 11 * (f ^^^ ( ~~~d ||| (e ||| f))) + 3 * ( ~~~e ||| (d ^^^ f)) + 1 * (e ^^^ (d &&& ( ~~~e ||| f))) + 2 * (f ^^^ (d ||| ( ~~~e &&& f))) + 7 * (f ^^^  ~~~(d ||| e)) - 1 * ( ~~~(d ^^^ e) &&& (d ^^^ f)) - 7 * (e ^^^  ~~~(d ||| (e &&& f))) - 1 * (e ||| (d &&&  ~~~f)) + 1 * (e ^^^ ( ~~~d ||| (e ^^^ f))) - 1 * (e ||| f) + 1 * ((d &&& f) |||  ~~~(e ||| f)) - 1 * (d ^^^ (e &&& f)) - 3 * ((d &&& e) |||  ~~~(e |||  ~~~f)) + 1 *  ~~~( ~~~d &&& ( ~~~e &&& f)) + 1 * (e ^^^ ( ~~~d &&& ( ~~~e ||| f))) + 5 * (e ^^^  ~~~(d &&& ( ~~~e ||| f))) + 3 * (f ^^^ ( ~~~d ||| (e &&& f))) - 6 * (e ^^^  ~~~(d &&& f)) + 4 * (f ^^^  ~~~(d ||| ( ~~~e &&& f))) + 1 * ( ~~~d &&& (e ^^^ f)) + 1 *  ~~~(d &&& e) + 4 *  ~~~f + 1 * ( ~~~f &&&  ~~~(d ^^^ e)) - 11 * (e ^^^  ~~~( ~~~d &&& ( ~~~e ||| f))) + 1 * (e ^^^  ~~~( ~~~d &&& ( ~~~e &&& f))) - 5 * ((d |||  ~~~e) &&& (e ^^^ f)) - 3 * ( ~~~(d &&& e) &&& (d ^^^ (e ^^^ f))) + 1 *  ~~~( ~~~d ||| (e &&& f)) + 7 * (f &&& (d ^^^ e)) - 43 *  ~~~(d ||| (e ||| f)) - 28 *  ~~~(d ||| ( ~~~e ||| f)) + 7 *  ~~~( ~~~d ||| (e ||| f)) - 2 *  ~~~( ~~~d ||| ( ~~~e ||| f)) + 17 * ( ~~~d &&& ( ~~~e &&& f)) - 4 * ( ~~~d &&& (e &&& f)) - 10 * (d &&& ( ~~~e &&& f)) - 25 * (d &&& (e &&& f)) = 1 * ((d &&&  ~~~e) ||| (d ^^^ (e ^^^ f))) - 3 * ( ~~~(d |||  ~~~e) |||  ~~~(e ^^^ f))

theorem xor_sge_proof : xor_sge_before ⊑ xor_sge_after

theorem test11_proof : test11_before ⊑ test11_after

theorem test_invert_demorgan_and2_proof : test_invert_demorgan_and2_before ⊑ test_invert_demorgan_and2_after

theorem lshrugt_03_15_thm.extracted_1._1 : ∀ (x : BitVec 4), ¬3#4 ≥ ↑4 → ofBool (-1#4 <ᵤ x >>> 3#4) = 0#1

theorem e_511 :
    11 *  ~~~(x ^^^ y) + 2 * (x ||| y) - 7 *  ~~~x - 1 * (x |||  ~~~y) - 3 * y - 1 *  ~~~y + 8 *  ~~~(x |||  ~~~y) + 2 * (x &&&  ~~~y) - 7 * (x &&& y) = 2 * x + 2 *  ~~~(x ||| y)

theorem masked_icmps_mask_notallzeros_bmask_mixed_swapped_3b_logical_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬ofBool (x &&& 3#32 == 0#32) = 1#1 → 0#1 = ofBool (x &&& 3#32 == 0#32) &&& ofBool (x &&& 15#32 != 0#32)

theorem select_mul_icmp_thm (e e_1 e_2 : IntW 32) :
  select (icmp IntPred.eq e_2 (const? 32 1)) (mul e_2 e_1) e ⊑
    select (icmp IntPred.eq e_2 (const? 32 1)) e_1 e

theorem sdiv_x_by_const_cmp_x_proof : sdiv_x_by_const_cmp_x_before ⊑ sdiv_x_by_const_cmp_x_after

theorem e_1669 :
    1 *  ~~~( ~~~a ||| (b ^^^ c)) - 1 * (c ||| (a &&&  ~~~b)) + 5 * ( ~~~(a |||  ~~~b) |||  ~~~(b ^^^ c)) - 5 * ( ~~~a ||| ( ~~~b &&& c)) + 2 *  ~~~(a |||  ~~~b) - 7 *  ~~~a - 2 * ( ~~~c &&&  ~~~(a ^^^ b)) - 3 *  ~~~(a &&& (b ^^^ c)) - 1 * ( ~~~(a |||  ~~~b) ||| (b ^^^ c)) - 2 *  ~~~(a ^^^ (b &&& c)) + 11 * (a |||  ~~~c) - 11 * (b ^^^  ~~~( ~~~a &&& ( ~~~b ||| c))) - 11 * (b ^^^ (a ||| (b &&& c))) + 5 * ((a ^^^ b) &&&  ~~~(a ^^^ c)) + 2 *  ~~~(a ||| b) + 2 *  ~~~( ~~~a ||| (b &&& c)) - 2 * (c ^^^  ~~~(a ||| ( ~~~b &&& c))) + 2 * (b ^^^ (a &&& ( ~~~b ||| c))) + 13 *  ~~~(a ||| ( ~~~b ||| c)) + 12 *  ~~~( ~~~a ||| (b ||| c)) - 5 *  ~~~( ~~~a ||| ( ~~~b ||| c)) + 26 * ( ~~~a &&& ( ~~~b &&& c)) + 19 * ( ~~~a &&& (b &&& c)) + 18 * (a &&& ( ~~~b &&& c)) - 9 * (a &&& (b &&& c)) = 7 * ((a &&&  ~~~b) ||| (b ^^^ c)) - 3 *  ~~~(a ||| (b ||| c))

theorem lshrult_01_08_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬1#4 ≥ ↑4 → ofBool (x >>> 1#4 <ᵤ BitVec.ofInt 4 (-8)) = 1#1

theorem t0_thm (e : IntW 8) :
  sub (LLVM.and e (const? 8 42)) e ⊑ sub (const? 8 0) (LLVM.and e (const? 8 (-43)))

theorem p14_commutativity1_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x <ᵤ 65536#32) = 1#1 → ofBool (65535#32 <ᵤ x) = 1#1 → 65535#32 = 42#32

theorem shl_add_proof : shl_add_before ⊑ shl_add_after

theorem sub_eq_xor_sub_mul_not_and :
    x - y = (x ^^^ y) - 2 * (~~~ x &&& y)

theorem shl_nsw_nuw_add_nsw_proof : shl_nsw_nuw_add_nsw_before ⊑ shl_nsw_nuw_add_nsw_after

theorem test2_proof : test2_before ⊑ test2_after

theorem lshrult_03_08_exact_proof : lshrult_03_08_exact_before ⊑ lshrult_03_08_exact_after

theorem not_or_or_and_not_and_and_commute1_proof : not_or_or_and_not_and_and_commute1_before ⊑ not_or_or_and_not_and_and_commute1_after

theorem logic_and_logic_or_4_proof : logic_and_logic_or_4_before ⊑ logic_and_logic_or_4_after

theorem sdiv?_denom_zero_eq_poison {w : Nat} (x : BitVec w) :
  LLVM.sdiv? x 0 = .poison

theorem addhshlhsdivhscalar0_proof : addhshlhsdivhscalar0_before ⊑ addhshlhsdivhscalar0_after

theorem icmp_select_implied_cond_relational_proof : icmp_select_implied_cond_relational_before ⊑ icmp_select_implied_cond_relational_after

theorem positive_with_icmp_logical_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬ofBool (x <ᵤ 512#32) = 1#1 → 0#1 = ofBool (x <ᵤ 128#32)

theorem ashr_ugt_3_proof : ashr_ugt_3_before ⊑ ashr_ugt_3_after

theorem negate_zext_thm.extracted_1._1 : ∀ (x : BitVec 1) (x_1 : BitVec 8),
  x_1 - zeroExtend 8 x = x_1 + signExtend 8 x

theorem e_1735 :
    4 * ( ~~~(a &&&  ~~~b) &&&  ~~~(b ^^^ c)) - 1 *  ~~~(b &&&  ~~~c) - 5 * (b ^^^  ~~~(a &&& ( ~~~b ||| c))) - 1 * (b ^^^ ( ~~~a &&& ( ~~~b ||| c))) - 11 * (b ^^^  ~~~( ~~~a &&& (b ^^^ c))) - 7 * (c ^^^  ~~~(a |||  ~~~b)) - 6 * (b ^^^ (a ||| c)) + 1 * ( ~~~b ||| (a ^^^ c)) - 2 * ((a &&& b) ||| (a ^^^ (b ^^^ c))) - 1 * ((a &&& b) ^^^  ~~~(a ^^^ (b &&& c))) - 2 * (b &&& c) - 6 * (b |||  ~~~(a |||  ~~~c)) + 1 * (a ||| b) - 1 *  ~~~(a &&& (b &&& c)) + 11 * ((b &&&  ~~~c) |||  ~~~(a ||| ( ~~~b &&& c))) + 4 * ( ~~~(a &&&  ~~~b) &&&  ~~~(a ^^^ (b ^^^ c))) + 4 * (c ^^^ (a ||| (b ||| c))) + 2 * (b ^^^ (a ||| ( ~~~b ||| c))) - 7 * ( ~~~c &&&  ~~~(a ^^^ b)) + 4 *  ~~~( ~~~a ||| (b ^^^ c)) - 3 * (c ^^^ ( ~~~a ||| ( ~~~b ||| c))) + 1 * (c ^^^ (a ||| ( ~~~b ||| c))) + 3 * (c ^^^  ~~~(a ||| (b &&& c))) + 4 * (c ^^^  ~~~(a &&&  ~~~b)) - 5 *  ~~~(a ||| (b ||| c)) + 13 *  ~~~(a ||| ( ~~~b ||| c)) + 11 *  ~~~( ~~~a ||| (b ||| c)) - 13 *  ~~~( ~~~a ||| ( ~~~b ||| c)) + 27 * ( ~~~a &&& ( ~~~b &&& c)) - 19 * ( ~~~a &&& (b &&& c)) + 15 * (a &&& ( ~~~b &&& c)) + 7 * (a &&& (b &&& c)) =  - 5 * (b ^^^  ~~~(a ||| c))

theorem ashrslt_01_05_thm (e : IntW 4) : icmp IntPred.slt (ashr e (const? 4 1)) (const? 4 5) ⊑ const? 1 1

theorem neg_or_lshr_i32_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬31#32 ≥ ↑32 → (0#32 - x ||| x) >>> 31#32 = zeroExtend 32 (ofBool (x != 0#32))

theorem test15_proof : test15_before ⊑ test15_after

theorem shl_and_lshr_comm_thm (e e_1 e_2 : IntW 32) :
  lshr (LLVM.and e_2 (shl e_1 e { «nsw» := false, «nuw» := true })) e ⊑ LLVM.and (lshr e_2 e) e_1

theorem ashr_can_be_lshr_thm (e : IntW 32) :
  trunc 16 (ashr e (const? 32 16) { «exact» := true }) { «nsw» := true, «nuw» := false } ⊑
    trunc 16 (lshr e (const? 32 16) { «exact» := true }) { «nsw» := false, «nuw» := true }

theorem no_shift_no_xor_multiuse_cmp_xor_thm (e e_1 e_2 e_3 : IntW 32) :
  mul
      (mul
        (select (icmp IntPred.eq (LLVM.and e_3 (const? 32 4096)) (const? 32 0)) e_2
          (LLVM.xor e_2 (const? 32 4096)))
        (select (icmp IntPred.eq (LLVM.and e_3 (const? 32 4096)) (const? 32 0)) e_1 e))
      (LLVM.xor e_2 (const? 32 4096)) ⊑
    mul
      (mul (LLVM.xor e_2 (LLVM.and e_3 (const? 32 4096)))
        (select (icmp IntPred.eq (LLVM.and e_3 (const? 32 4096)) (const? 32 0)) e_1 e))
      (LLVM.xor e_2 (const? 32 4096))

theorem foo1_and_signbit_lshr_without_shifting_signbit_both_sides_proof : foo1_and_signbit_lshr_without_shifting_signbit_both_sides_before ⊑ foo1_and_signbit_lshr_without_shifting_signbit_both_sides_after

theorem select_icmp_x_and_8_ne_0_y_or_8_thm.extracted_1._3 : ∀ (x : BitVec 64) (x_1 : BitVec 32),
  ¬ofBool (x_1 &&& 8#32 == 0#32) = 1#1 → True ∧ (x_1 &&& 8#32 ^^^ 8#32).msb = true → False

theorem neg_not_signbit2_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬6#8 ≥ ↑8 →
    6#8 ≥ ↑8 ∨ True ∧ (x >>> 6#8).msb = true ∨ True ∧ (0#32).ssubOverflow (zeroExtend 32 (x >>> 6#8)) = true → False

theorem neg_nsw_slt_n1_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬(True ∧ (0#8).ssubOverflow x = true) → ofBool (0#8 - x <ₛ -1#8) = ofBool (1#8 <ₛ x)

theorem add_nsw_const_const_sub_proof : add_nsw_const_const_sub_before ⊑ add_nsw_const_const_sub_after

theorem main5f_like_logical_proof : main5f_like_logical_before ⊑ main5f_like_logical_after

theorem e_1826 :
    5 * (b ^^^  ~~~( ~~~a &&& (b ||| c))) + 4 * (b ^^^  ~~~( ~~~a &&& (b &&& c))) - 6 *  ~~~(a &&& (b ||| c)) + 5 * (c ^^^  ~~~( ~~~a &&& (b ||| c))) + 1 * (b ^^^ ( ~~~a &&& (b ^^^ c))) - 1 * (a ||| c) + 2 * ((a ^^^ b) &&& (a ^^^ c)) - 2 * (c ^^^  ~~~( ~~~a ||| (b &&& c))) - 5 * c + 2 * (b ^^^ (a ||| (b &&& c))) + 1 *  ~~~( ~~~a ||| (b ^^^ c)) + 11 *  ~~~(b |||  ~~~c) - 7 * ((b &&&  ~~~c) ^^^ ( ~~~a ||| (b ^^^ c))) + 3 * (c ^^^  ~~~(a |||  ~~~b)) + 11 * ( ~~~b |||  ~~~(a ^^^ c)) + 1 * (b ^^^ (a ||| (b ||| c))) + 11 * (a &&& (b ||| c)) - 7 * ( ~~~(a &&&  ~~~b) &&&  ~~~(a ^^^ (b ^^^ c))) - 3 *  ~~~b + 1 * (a ||| (b ||| c)) + 1 * ( ~~~(a &&& b) &&& (a ^^^ (b ^^^ c))) - 2 * (b ^^^ ( ~~~a ||| ( ~~~b &&& c))) - 1 * (c ^^^ ( ~~~a ||| ( ~~~b ||| c))) - 1 * (c ^^^ (a &&& b)) - 2 *  ~~~( ~~~a &&& (b &&& c)) + 1 * (c |||  ~~~(a ^^^ b)) + 1 *  ~~~(a ^^^ (b ||| c)) + 11 *  ~~~(a ||| c) + 3 * (c ^^^  ~~~( ~~~a ||| ( ~~~b &&& c))) - 11 * (b ^^^ (a ||| c)) + 1 * (c ^^^  ~~~(a ||| ( ~~~b &&& c))) + 1 *  ~~~(b &&&  ~~~c) - 2 * (b &&&  ~~~(a &&&  ~~~c)) + 4 * ((a ^^^ b) &&&  ~~~(a ^^^ c)) - 12 *  ~~~(a ||| (b ||| c)) - 17 *  ~~~(a ||| ( ~~~b ||| c)) - 15 *  ~~~( ~~~a ||| (b ||| c)) - 8 *  ~~~( ~~~a ||| ( ~~~b ||| c)) - 8 * ( ~~~a &&& ( ~~~b &&& c)) + 4 * ( ~~~a &&& (b &&& c)) - 32 * (a &&& ( ~~~b &&& c)) - 22 * (a &&& (b &&& c)) =  - 4 * (c ||| (a &&&  ~~~b))

theorem sge_swap_or_max_proof : sge_swap_or_max_before ⊑ sge_swap_or_max_after

theorem test17_thm (e : IntW 8) : icmp IntPred.eq (LLVM.or e (const? 8 1)) (const? 8 2) ⊑ const? 1 0

theorem lshr_or_proof : lshr_or_before ⊑ lshr_or_after

theorem ugt_swap_and_min_logical_thm (e e_1 : IntW 8) :
  select (icmp IntPred.ult e_1 e) (icmp IntPred.eq e (const? 8 0)) (const? 1 0) ⊑ const? 1 0

theorem canonicalize_logic_first_and0_nswnuw_thm (e : IntW 8) :
  LLVM.and (add e (const? 8 48) { «nsw» := true, «nuw» := true }) (const? 8 (-10)) ⊑
    add (LLVM.and e (const? 8 (-10))) (const? 8 48) { «nsw» := true, «nuw» := true }

theorem not_and_and_or_not_or_or_commute2_or_thm (e e_1 e_2 : IntW 32) :
  LLVM.or (LLVM.and (LLVM.and (LLVM.xor e_2 (const? 32 (-1))) e_1) e)
      (LLVM.xor (LLVM.or (LLVM.or e_1 e) e_2) (const? 32 (-1))) ⊑
    LLVM.xor (LLVM.or (LLVM.xor e e_1) e_2) (const? 32 (-1))

theorem masked_icmps_mask_notallzeros_bmask_mixed_swapped_4_logical_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬ofBool (x &&& 15#32 == 8#32) = 1#1 → 0#1 = ofBool (x &&& 15#32 == 8#32)

theorem e_279 :
     - 6 * y - 2 *  ~~~(x &&&  ~~~y) + 11 *  ~~~x - 1 *  ~~~(x &&& y) - 8 *  ~~~(x ||| y) + 1 *  ~~~(x |||  ~~~y) + 8 * (x &&& y) = 3 * (x ^^^ y) - 4 * (x &&&  ~~~y)

theorem main5f_like_logical_thm.extracted_1._7 : ∀ (x x_1 x_2 : BitVec 32),
  ofBool (x_2 &&& x_1 != x_2) = 1#1 → ¬ofBool (x_2 &&& x_1 == x_2) = 1#1 → True → 0#32 = zeroExtend 32 0#1

theorem icmp_slt_0_or_icmp_sge_neg1_i32_proof : icmp_slt_0_or_icmp_sge_neg1_i32_before ⊑ icmp_slt_0_or_icmp_sge_neg1_i32_after

theorem xor_ashr_not_fail_lshr_ashr_thm (e e_1 e_2 : IntW 8) :
  LLVM.xor (lshr e_2 e_1) (LLVM.xor (ashr e e_1) (const? 8 (-1))) ⊑
    LLVM.xor (LLVM.xor (ashr e e_1) (lshr e_2 e_1)) (const? 8 (-1))

theorem t2_symmetry_proof : t2_symmetry_before ⊑ t2_symmetry_after

theorem ne_umax2_proof : ne_umax2_before ⊑ ne_umax2_after

theorem test20_thm (e : IntW 8) : LLVM.and (lshr e (const? 8 7)) (const? 8 1) ⊑ lshr e (const? 8 7)

theorem test_proof : test_before ⊑ test_after

theorem add_eq_xor_add_mul_and_nt (x y : BitVec w) :
    x + y = (x ^^^ y) + 2 * (x &&& y)

theorem lowmask_add_zext_thm (e : IntW 32) (e_1 : IntW 8) :
  LLVM.and (add (zext 32 e_1) e) (const? 32 255) ⊑ zext 32 (add e_1 (trunc 8 e))

theorem test92_proof : test92_before ⊑ test92_after

theorem select_icmp_ne_0_and_4096_xor_4096_proof : select_icmp_ne_0_and_4096_xor_4096_before ⊑ select_icmp_ne_0_and_4096_xor_4096_after

theorem trunc_lshr_thm.extracted_1._2 : ∀ (x : BitVec 8),
  ¬2#8 ≥ ↑8 → ¬2#6 ≥ ↑6 → truncate 6 (x >>> 2#8) &&& 14#6 = truncate 6 x >>> 2#6 &&& 14#6

theorem e_157 :
     - 2 * (x |||  ~~~y) - 3 *  ~~~(x ^^^ y) + 5 *  ~~~(x ||| y) + 18 *  ~~~(x |||  ~~~y) + 20 * (x &&&  ~~~y) + 12 * (x &&& y) = 7 * (x ||| y) + 11 * (x ^^^ y)

theorem n2_proof : n2_before ⊑ n2_after

theorem shl_add_and_proof : shl_add_and_before ⊑ shl_add_and_after

theorem test16_thm (e : IntW 8) : LLVM.and (shl e (const? 8 2)) (const? 8 3) ⊑ const? 8 0

theorem shl_xor_lshr_thm (e e_1 e_2 : IntW 32) :
  lshr (LLVM.xor (shl e_2 e_1 { «nsw» := false, «nuw» := true }) e) e_1 ⊑ LLVM.xor (lshr e e_1) e_2

theorem sge_and_max_logical_proof : sge_and_max_logical_before ⊑ sge_and_max_logical_after

theorem add_shl_same_amount_constants_proof : add_shl_same_amount_constants_before ⊑ add_shl_same_amount_constants_after

theorem AvoidCollision_toFin_signExtend_of_le {x : BitVec w} (hv : v ≤ w):
    (x.signExtend v).toFin = Fin.ofNat (2 ^ v) x.toNat

theorem lshrugt_03_14_exact_thm (e : IntW 4) :
  icmp IntPred.ugt (lshr e (const? 4 3) { «exact» := true }) (const? 4 (-2)) ⊑ const? 1 0

theorem PR2844_logical_proof : PR2844_logical_before ⊑ PR2844_logical_after

theorem e_1473 :
    1 *  ~~~(z &&&  ~~~z) + 1 * z + 1 *  ~~~t + 1 *  ~~~(z &&& t) - 7 * (z ||| t) + 7 * (z ^^^ t) - 2 * t - 5 *  ~~~(z ||| t) - 2 *  ~~~(z |||  ~~~t) - 4 * (z &&&  ~~~t) + 5 * (z &&& t) =  - 2 *  ~~~(z &&&  ~~~t)

theorem sub_from_constant_of_sub_from_constant_thm.extracted_1._1 : ∀ (x : BitVec 8),
  11#8 - (42#8 - x) = x + BitVec.ofInt 8 (-31)

theorem ashrslt_01_07_exact_proof : ashrslt_01_07_exact_before ⊑ ashrslt_01_07_exact_after

theorem udiv1_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32), ¬(True ∧ x_1.umod x ≠ 0 ∨ x = 0) → x_1 / x * x = x_1

theorem e_136 :
     - 1 * y + 3 * (x ^^^ y) - 2 * (x |||  ~~~y) + 2 *  ~~~(x ||| y) - 2 *  ~~~(x |||  ~~~y) + 3 * (x &&& y) = 1 * (x &&&  ~~~y)

theorem not_cond_thm.extracted_1._4 : ∀ (x x_1 : BitVec 32) (x_2 : BitVec 1),
  ¬x_2 ^^^ 1#1 = 1#1 → ¬x_2 = 1#1 → x = x_1

theorem test_shl_nuw__none_are_safe_proof : test_shl_nuw__none_are_safe_before ⊑ test_shl_nuw__none_are_safe_after

theorem e_604 :
     - 1 *  ~~~y - 1 * y + 3 * (x ^^^ y) - 7 *  ~~~(x &&& y) - 2 * x - 1 *  ~~~(x ^^^ y) + 1 * (x ||| y) - 1 * (x |||  ~~~y) + 6 *  ~~~(x ||| y) + 3 * (x &&&  ~~~y) =  - 4 *  ~~~(x &&&  ~~~x)

theorem icmp_sle3_proof : icmp_sle3_before ⊑ icmp_sle3_after

theorem e_256 :
     - 11 * (x |||  ~~~y) - 5 * y + 2 *  ~~~x - 5 * (x ||| y) + 1 * (x ^^^ y) + 7 *  ~~~(x |||  ~~~y) + 15 * (x &&&  ~~~y) =  - 21 * (x &&& y) - 9 *  ~~~(x ||| y)

theorem not_and_and_or_not_or_or_commute1_or_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 32),
  (x_2 ^^^ -1#32) &&& x_1 &&& x ||

theorem t1_lshr_thm.extracted_1._2 : ∀ (x : BitVec 8) (x_1 : BitVec 32),
  ¬signExtend 32 x ≥ ↑32 →
    ¬(True ∧ x.msb = true ∨ zeroExtend 32 x ≥ ↑32) → x_1 >>> signExtend 32 x = x_1 >>> zeroExtend 32 x

theorem nomask_rhs_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x &&& 1#32 == 0#32) ||

theorem foo1_and_signbit_lshr_without_shifting_signbit_logical_proof : foo1_and_signbit_lshr_without_shifting_signbit_logical_before ⊑ foo1_and_signbit_lshr_without_shifting_signbit_logical_after

theorem icmp_equality_test_swift_optional_pointers_thm.extracted_1._2 : ∀ (x x_1 : BitVec 64),
  ofBool (x_1 == 0#64) = 1#1 → ¬True → ofBool (x == 0#64) = ofBool (x_1 == x)

theorem subAux_inductive_lemma (i : Nat) :
    a.subAux b i = ⟨(a.addAux b.neg i).1, subCarries? a b i⟩

theorem t11_no_shift_proof : t11_no_shift_before ⊑ t11_no_shift_after

theorem lshrult_03_04_exact_proof : lshrult_03_04_exact_before ⊑ lshrult_03_04_exact_after

theorem xor_i8_to_i64_shl_save_and_ne_thm.extracted_1._2 : ∀ (x : BitVec 64) (x_1 : BitVec 8),
  ofBool (x_1 &&& 1#8 != 0#8) = 1#1 →
    ¬63#64 ≥ ↑64 → x ^^^ BitVec.ofInt 64 (-9223372036854775808) = x ^^^ zeroExtend 64 x_1 <<< 63#64

theorem main4c_thm (e : IntW 32) :
  select
      (LLVM.or (icmp IntPred.ne (LLVM.and e (const? 32 7)) (const? 32 7))
        (icmp IntPred.ne (LLVM.and e (const? 32 48)) (const? 32 48)))
      (const? 32 0) (const? 32 1) ⊑
    zext 32 (icmp IntPred.eq (LLVM.and e (const? 32 55)) (const? 32 55))

theorem main7c_logical_thm.extracted_1._12 : ∀ (x x_1 x_2 : BitVec 32),
  ¬ofBool (x_2 == x_2 &&& x_1) = 1#1 →
    ¬ofBool (x_2 != x_2 &&& x_1) = 1#1 → ¬0#1 = 1#1 → 1#32 = zeroExtend 32 (ofBool (x != x &&& x_1))

theorem scalar0_proof : scalar0_before ⊑ scalar0_after

theorem test_add_nsw__all_are_safe_proof : test_add_nsw__all_are_safe_before ⊑ test_add_nsw__all_are_safe_after

theorem positive_sameconst_shlnsw_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬(3#8 ≥ ↑8 ∨ True ∧ (x.sshiftRight' 3#8 <<< 3#8).sshiftRight' 3#8 ≠ x.sshiftRight' 3#8 ∨ 3#8 ≥ ↑8) →
    x.sshiftRight' 3#8 <<< 3#8 = x &&& BitVec.ofInt 8 (-8)

theorem t5_ugt_slt_0_thm.extracted_1._10 : ∀ (x x_1 x_2 : BitVec 32),
  ¬ofBool (65535#32 <ᵤ x_2) = 1#1 → ofBool (65535#32 <ₛ x_2) = 1#1 → x_2 = x

theorem test_or2_logical_thm (e e_1 : IntW 32) :
  select (icmp IntPred.sle e_1 (const? 32 (-1))) (const? 1 1)
      (icmp IntPred.sgt e_1 (LLVM.and e (const? 32 2147483647))) ⊑
    select (icmp IntPred.slt e_1 (const? 32 0)) (const? 1 1)
      (icmp IntPred.sgt e_1 (LLVM.and e (const? 32 2147483647)))

theorem mul_setnzV_unkV_nuw_eq_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ¬(True ∧ (x_1 ||| 2#8).umulOverflow x = true) → ofBool ((x_1 ||| 2#8) * x == 0#8) = ofBool (x == 0#8)

theorem icmp_ne_sext_sgt_zero_nofold_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (signExtend 32 (ofBool (0#32 <ₛ x)) != x) = ofBool (x != signExtend 32 (ofBool (0#32 <ₛ x)))

theorem test28_thm (e : IntW 32) :
  LLVM.xor (add e (const? 32 (-2147483647))) (const? 32 (-2147483648)) ⊑ add e (const? 32 1)

theorem main10_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x &&& 64#32 == 0#32) &&& ofBool (0#8 ≤ₛ truncate 8 x) = 1#1 →
    ¬ofBool (x &&& 192#32 == 0#32) = 1#1 → 2#32 = 1#32

theorem thisdoesnotloop_thm.extracted_1._2 : ∀ (x x_1 : BitVec 32),
  ofBool (x_1 <ₛ BitVec.ofInt 32 (-128)) = 1#1 → truncate 8 128#32 = BitVec.ofInt 8 (-128)

theorem ugt_swap_and_not_min_logical_proof : ugt_swap_and_not_min_logical_before ⊑ ugt_swap_and_not_min_logical_after

theorem test15a_thm (e : IntW 32) :
  select (icmp IntPred.eq (LLVM.and e (const? 32 16)) (const? 32 0)) (const? 32 0) (const? 32 16) ⊑
    LLVM.and e (const? 32 16)

theorem sub_to_xor_and_commuted_proof : sub_to_xor_and_commuted_before ⊑ sub_to_xor_and_commuted_after

theorem positive_biggershl_shlnuw_lshrexact_thm.extracted_1._2 : ∀ (x : BitVec 8),
  ¬(True ∧ x >>> 3#8 <<< 3#8 ≠ x ∨ 3#8 ≥ ↑8 ∨ True ∧ x >>> 3#8 <<< 6#8 >>> 6#8 ≠ x >>> 3#8 ∨ 6#8 ≥ ↑8) →
    ¬(True ∧ x <<< 3#8 >>> 3#8 ≠ x ∨ 3#8 ≥ ↑8) → x >>> 3#8 <<< 6#8 = x <<< 3#8

theorem e_801 :
     - 11 * t - 1 *  ~~~(z &&&  ~~~t) + 18 *  ~~~(z |||  ~~~t) + 6 * (z &&&  ~~~t) + 18 * (z &&& t) = 6 * (z ||| t) - 1 *  ~~~(z ||| t)

theorem lshr_xor_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ¬(3#8 ≥ ↑8 ∨ (42#8 == 0 || 8 != 1 && x == intMin 8 && 42#8 == -1) = true ∨ 3#8 ≥ ↑8) →
    (42#8 == 0 || 8 != 1 && x == intMin 8 && 42#8 == -1) = true ∨ 3#8 ≥ ↑8 → False

theorem t0_thm.extracted_1._12 : ∀ (x x_1 x_2 : BitVec 8) (x_3 : BitVec 1),
  ¬x_3 ^^^ 1#1 = 1#1 → ¬x_3 = 1#1 → ¬0#1 = 1#1 → ¬ofBool (x_2 != x_1) = 1#1 → False

theorem exact_lshr_ne_opposite_msb_proof : exact_lshr_ne_opposite_msb_before ⊑ exact_lshr_ne_opposite_msb_after

theorem e_2430 :
    1 * e + 1 * ( ~~~(d |||  ~~~e) |||  ~~~(d ^^^ (e ^^^ f))) - 5 * ((d ^^^ e) |||  ~~~(d ^^^ f)) - 6 * (d ||| (e ^^^ f)) + 1 * (e |||  ~~~(d |||  ~~~f)) - 6 * ((e &&& f) ||| ( ~~~d &&& (e ||| f))) - 2 * (e ||| (d &&&  ~~~f)) + 4 * (f ^^^ (d &&& ( ~~~e ||| f))) - 2 * ((d &&& e) ||| (d ^^^ (e ^^^ f))) + 2 * ( ~~~(d &&&  ~~~e) &&&  ~~~(d ^^^ (e ^^^ f))) + 4 * ((d |||  ~~~e) &&&  ~~~(e ^^^ f)) + 4 * (e ^^^ ( ~~~d &&& (e ||| f))) + 2 * ((d &&& e) ^^^  ~~~(d ^^^ (e &&& f))) + 1 * ( ~~~d ||| ( ~~~e ||| f)) + 2 * (f ^^^ ( ~~~d ||| (e &&& f))) - 11 *  ~~~(d &&& (e &&& f)) + 1 * ((d &&& e) |||  ~~~(e ^^^ f)) + 7 * (d ^^^ f) + 11 *  ~~~( ~~~d &&& ( ~~~e ||| f)) + 4 * ((e &&&  ~~~f) ^^^ (d ||| (e ^^^ f))) - 3 * (f ^^^ (d ||| ( ~~~e &&& f))) - 6 * (f ^^^  ~~~(d &&& (e &&& f))) + 5 * ((d &&& f) ^^^ (d ^^^ ( ~~~e &&& f))) - 5 * (e ^^^  ~~~( ~~~d ||| (e &&& f))) + 5 * (f &&&  ~~~(d &&& e)) + 1 * ((d &&& f) ^^^  ~~~(e &&&  ~~~f)) - 7 *  ~~~d + 3 * (d ^^^ (e ^^^ f)) + 2 *  ~~~( ~~~d &&& ( ~~~e &&& f)) - 5 * (f ^^^ (d &&& (e ||| f))) + 5 *  ~~~(d &&& f) + 2 * (f ^^^  ~~~(d &&& (e ||| f))) - 2 * (f ^^^  ~~~(d ||| (e &&& f))) + 3 * (e ^^^ f) - 2 * (e ^^^  ~~~( ~~~d ||| (e ^^^ f))) - 2 *  ~~~( ~~~d &&& (e ||| f)) - 1 *  ~~~( ~~~d &&& (e &&& f)) + 11 * (e ||| f) - 3 * (e &&& (d ||| f)) - 2 * ((e &&&  ~~~f) |||  ~~~(d ||| ( ~~~e &&& f))) - 1 * (e |||  ~~~(d ||| f)) - 3 *  ~~~(d ||| f) - 3 * (f ^^^  ~~~(d ||| e)) + 1 * ( ~~~d ||| ( ~~~e &&& f)) - 1 * (e &&&  ~~~(d &&& f)) - 11 * (e ^^^  ~~~( ~~~d &&& (e ||| f))) + 5 * ( ~~~d ||| (e ^^^ f)) + 11 * ((d &&& e) ^^^  ~~~(d ^^^ ( ~~~e ||| f))) - 2 *  ~~~e + 11 * (d ^^^ e) + 2 * ( ~~~(d &&& e) &&&  ~~~(d ^^^ (e ^^^ f))) + 1 * (e &&& (d ^^^ f)) - 7 * ( ~~~(d ^^^ e) ||| (d ^^^ f)) - 3 *  ~~~(d ^^^ ( ~~~e ||| f)) + 7 * ((d &&& e) ^^^ (d ^^^ (e &&& f))) + 11 * ( ~~~(d &&&  ~~~e) &&&  ~~~(e ^^^ f)) - 2 *  ~~~( ~~~d ||| ( ~~~e &&& f)) + 1 * ( ~~~(d |||  ~~~e) ||| (e ^^^ f)) - 1 *  ~~~(d ^^^ (e ^^^ f)) + 1 *  ~~~(e &&& f) + 2 *  ~~~(d ||| e) + 5 * ( ~~~(d ^^^ e) &&&  ~~~(d ^^^ f)) + 1 * (f ^^^  ~~~( ~~~d &&& (e &&& f))) - 1 * (f |||  ~~~(d |||  ~~~e)) - 1 * ((d &&& f) |||  ~~~(e ||| f)) + 4 * (d |||  ~~~f) - 6 * (d ||| (e ||| f)) + 10 *  ~~~(d ||| (e ||| f)) + 3 *  ~~~(d ||| ( ~~~e ||| f)) - 8 *  ~~~( ~~~d ||| (e ||| f)) - 10 *  ~~~( ~~~d ||| ( ~~~e ||| f)) - 5 * ( ~~~d &&& ( ~~~e &&& f)) + 9 * ( ~~~d &&& (e &&& f)) - 30 * (d &&& ( ~~~e &&& f)) - 1 * (d &&& (e &&& f)) = 7 * (e ^^^ ( ~~~d &&& (e ^^^ f)))

theorem and_logic_and_logic_or_3_proof : and_logic_and_logic_or_3_before ⊑ and_logic_and_logic_or_3_after

theorem test3_proof : test3_before ⊑ test3_after

theorem xor_logic_and_logic_or2_thm.extracted_1._1 : ∀ (x x_1 : BitVec 1), ¬x_1 = 1#1 → x = 1#1 → 0#1 ^^^ 1#1 = x

@[simp]
lemma CNFA.SignedCmp_stateMax cmp : (autSignedCmp cmp).m.stateMax = 5

theorem com_Γ : com.1 = (Γn 1)

theorem lshr_sub_proof : lshr_sub_before ⊑ lshr_sub_after

theorem shl_bad_sub_i8_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬4#8 - x ≥ ↑8 → True ∧ 1#8 <<< (4#8 - x) >>> (4#8 - x) ≠ 1#8 ∨ 4#8 - x ≥ ↑8 → False

theorem e_2322 :
    5 *  ~~~( ~~~d &&& (e ^^^ f)) + 4 *  ~~~(d &&& ( ~~~e &&& f)) - 1 * ( ~~~(d ^^^ e) |||  ~~~(d ^^^ f)) + 7 * (e ^^^ (d ||| f)) - 1 * ( ~~~(d ||| e) ||| (d ^^^ (e ^^^ f))) + 1 * ((d ||| e) &&&  ~~~(d ^^^ (e ^^^ f))) - 2 * ( ~~~(d ^^^ e) &&& (d ^^^ f)) + 11 * ( ~~~(d &&&  ~~~e) &&&  ~~~(d ^^^ (e ^^^ f))) - 2 * ( ~~~e &&& (d ^^^ f)) + 5 * ( ~~~(d |||  ~~~e) ||| (e ^^^ f)) + 1 * (f ^^^ (d ||| (e ||| f))) - 2 *  ~~~(d &&& f) + 1 * (e ^^^  ~~~(d &&& ( ~~~e &&& f))) - 5 * ((d &&& e) ^^^  ~~~(d ^^^ (e &&& f))) - 5 * (f ^^^  ~~~( ~~~d ||| ( ~~~e &&& f))) - 5 *  ~~~e - 1 * ((d &&& f) ^^^ (d ^^^ ( ~~~e &&& f))) + 1 * (e ^^^  ~~~( ~~~d &&& (e ||| f))) - 11 * (e ^^^  ~~~(d &&& (e ||| f))) + 3 * ((d &&& f) ^^^  ~~~(d ^^^ (e &&& f))) + 4 * (f ^^^ (d &&& ( ~~~e ||| f))) + 2 * (e &&& f) - 6 * ( ~~~d ||| (e ^^^ f)) + 5 * (e ^^^ (d |||  ~~~f)) + 11 * (e ^^^ (d &&& (e ^^^ f))) + 7 * ((e &&&  ~~~f) ^^^ (d ||| (e ^^^ f))) + 1 *  ~~~(d ||| e) - 6 *  ~~~(d &&& (e &&& f)) + 1 * ((d &&& f) ^^^  ~~~(e &&&  ~~~f)) + 7 * (e ^^^ (d &&& (e ||| f))) + 4 * (e ^^^ ( ~~~d &&& ( ~~~e ||| f))) - 3 *  ~~~(e &&&  ~~~f) + 1 * (f &&&  ~~~(d ^^^ e)) + 2 * (f ^^^  ~~~(d ||| e)) - 1 * (e ^^^  ~~~(d &&&  ~~~f)) - 11 * (e ^^^  ~~~( ~~~d ||| ( ~~~e &&& f))) + 1 *  ~~~(d ||| (e ^^^ f)) - 1 * (f ^^^  ~~~(d &&& ( ~~~e ||| f))) + 2 * d - 6 * (f ^^^ (d ||| (e &&& f))) - 2 *  ~~~(d ^^^ (e ^^^ f)) + 1 * (e &&& (d ^^^ f)) + 7 * (e ^^^ (d &&& f)) - 1 * ( ~~~(d ^^^ e) ||| (d ^^^ f)) + 1 * ( ~~~d &&& (e ^^^ f)) - 2 * ((d &&&  ~~~e) ||| (d ^^^ (e ^^^ f))) - 7 * (e ^^^  ~~~(d ||| f)) + 7 * (f ^^^  ~~~( ~~~d ||| (e &&& f))) + 2 *  ~~~(d &&& (e ^^^ f)) - 1 * (d &&& (e ||| f)) + 3 *  ~~~( ~~~d &&& ( ~~~e &&& f)) + 3 *  ~~~( ~~~d ||| ( ~~~e &&& f)) + 4 * ((d &&& f) |||  ~~~(e ||| f)) + 2 * ((d &&& f) ||| (e &&&  ~~~f)) - 11 * (e ^^^  ~~~( ~~~d ||| (e ^^^ f))) + 1 * ((e &&&  ~~~f) |||  ~~~( ~~~d ||| ( ~~~e &&& f))) + 5 * ( ~~~d ||| (e &&& f)) - 1 *  ~~~(d ||| (e ||| f)) - 18 *  ~~~(d ||| ( ~~~e ||| f)) + 9 *  ~~~( ~~~d ||| (e ||| f)) + 12 *  ~~~( ~~~d ||| ( ~~~e ||| f)) + 7 * ( ~~~d &&& ( ~~~e &&& f)) - 31 * ( ~~~d &&& (e &&& f)) - 37 * (d &&& (e &&& f)) = 38 * (d &&& ( ~~~e &&& f))

theorem masked_icmps_mask_notallzeros_bmask_mixed_negated_swapped_5_logical_proof : masked_icmps_mask_notallzeros_bmask_mixed_negated_swapped_5_logical_before ⊑ masked_icmps_mask_notallzeros_bmask_mixed_negated_swapped_5_logical_after

theorem eq_commuted_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ¬(x == 0 || 8 != 1 && 43#8 == intMin 8 && x == -1) = true →
    ofBool (x_1 == 0#8) ||

@[simp]
theorem Array.take_ge_size {a : Array α} {n} (h : n ≥ a.size) : a.take n = a

theorem lshr_shl_pow2_const_overflow_proof : lshr_shl_pow2_const_overflow_before ⊑ lshr_shl_pow2_const_overflow_after

theorem udiv_mul_shl_nuw_exact_commute1_proof : udiv_mul_shl_nuw_exact_commute1_before ⊑ udiv_mul_shl_nuw_exact_commute1_after

theorem neg_not_signbit3_proof : neg_not_signbit3_before ⊑ neg_not_signbit3_after

theorem e_2389 :
     - 1 * (f ^^^  ~~~( ~~~d ||| (e &&& f))) + 11 * (e ^^^ ( ~~~d ||| (e &&& f))) + 2 * (f ^^^  ~~~(d &&& e)) + 4 * (f ^^^  ~~~( ~~~d &&& ( ~~~e &&& f))) - 2 * ((d &&& e) ^^^ (e ||| f)) + 1 * ((d &&& e) |||  ~~~(e ^^^ f)) + 2 * ( ~~~(d ^^^ e) &&& (d ^^^ f)) + 2 * (e ^^^ (d &&& f)) + 1 * (f &&&  ~~~(d ^^^ e)) - 5 * (f &&& (d ^^^ e)) - 1 * ( ~~~d ||| (e ||| f)) - 1 * (e ^^^ (d &&& (e ^^^ f))) - 2 * (e ^^^ ( ~~~d &&& ( ~~~e ||| f))) + 5 * (e ^^^ (d ||| (e ^^^ f))) + 1 * (f ^^^  ~~~(d &&& (e &&& f))) + 11 * (e ^^^  ~~~(d ||| ( ~~~e &&& f))) + 7 *  ~~~(d ^^^ (e ^^^ f)) - 1 * (f ^^^ ( ~~~d &&& ( ~~~e ||| f))) + 2 * (d &&& ( ~~~e ||| f)) - 1 * ((d &&&  ~~~e) |||  ~~~(e ^^^ f)) - 1 * ( ~~~(d &&& e) &&& (d ^^^ (e ^^^ f))) - 3 *  ~~~(e ^^^ f) + 1 * ( ~~~d &&& ( ~~~e ||| f)) - 5 * ( ~~~(d ||| e) |||  ~~~(d ^^^ (e ^^^ f))) + 3 * (e ^^^ (d ||| (e ||| f))) + 1 *  ~~~(d &&& (e ^^^ f)) + 1 * ((d &&& f) |||  ~~~(e ||| f)) - 7 * (f &&& (d ||| e)) + 2 * ( ~~~d ||| (e &&& f)) + 3 * (e ^^^  ~~~( ~~~d ||| (e ^^^ f))) - 7 * ((d |||  ~~~e) &&&  ~~~(d ^^^ (e ^^^ f))) - 2 * ((d ||| e) &&& (d ^^^ (e ^^^ f))) + 1 *  ~~~( ~~~d ||| ( ~~~e &&& f)) + 2 * ( ~~~f |||  ~~~(d ^^^ e)) - 2 * ((d ||| e) &&& (e ^^^ f)) + 2 * (f ^^^ ( ~~~d ||| ( ~~~e ||| f))) - 1 * ((d &&& e) |||  ~~~(e ||| f)) - 5 * ((e &&&  ~~~f) |||  ~~~( ~~~d ||| ( ~~~e &&& f))) - 6 * (d ^^^ ( ~~~e ||| f)) + 3 *  ~~~(e &&&  ~~~f) + 1 * (d &&& (e ||| f)) - 1 * (f ^^^ (d ||| (e &&& f))) - 6 * (d |||  ~~~e) - 11 * ((d ^^^ e) ||| (d ^^^ f)) - 1 *  ~~~(d &&& f) - 2 * (f ^^^  ~~~(d |||  ~~~e)) - 3 *  ~~~( ~~~d &&& (e &&& f)) + 11 *  ~~~(d ||| f) - 2 *  ~~~(d &&&  ~~~f) - 1 * ((d &&& e) ^^^ (e |||  ~~~f)) + 1 * (f ^^^ (d ||| ( ~~~e ||| f))) + 11 * (f |||  ~~~(d |||  ~~~e)) - 1 * ((e &&& f) ^^^  ~~~( ~~~d &&& (e ^^^ f))) - 7 * ( ~~~d ||| ( ~~~e &&& f)) - 2 * ((d &&& f) ^^^ (e ||| f)) + 1 * (f ^^^  ~~~(d ||| (e &&& f))) + 2 * (f ^^^ (d ||| e)) + 4 * (d ||| ( ~~~e ||| f)) - 11 * (f ^^^ (d &&&  ~~~e)) + 1 * (f ^^^ ( ~~~d &&& (e ||| f))) - 5 * (d ||| ( ~~~e &&& f)) - 7 * ((d &&& e) |||  ~~~(d ^^^ (e ^^^ f))) + 7 * (e ^^^ (d &&&  ~~~f)) - 11 *  ~~~(d ||| (e ||| f)) + 4 *  ~~~(d ||| ( ~~~e ||| f)) + 20 *  ~~~( ~~~d ||| (e ||| f)) + 25 *  ~~~( ~~~d ||| ( ~~~e ||| f)) + 17 * ( ~~~d &&& ( ~~~e &&& f)) + 26 * ( ~~~d &&& (e &&& f)) + 46 * (d &&& ( ~~~e &&& f)) + 8 * (d &&& (e &&& f)) = 11 * ((d &&& e) ^^^  ~~~(d ^^^ ( ~~~e ||| f)))

theorem test_and_ne_a_b_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8) (x_2 : BitVec 1),
  x_2 &&& ofBool (x_1 != x) = 1#1 → ¬x_2 = 1#1 → x_1 = x

theorem trunc_lshr_sext_exact_thm (e : IntW 8) :
  trunc 8 (lshr (sext 32 e) (const? 32 6) { «exact» := true }) ⊑ ashr e (const? 8 6) { «exact» := true }

theorem or_consts_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (4#32 &&& x != 0#32) &&& ofBool (8#32 &&& x != 0#32) = ofBool (x &&& 12#32 == 12#32)

theorem ashrsgt_01_09_proof : ashrsgt_01_09_before ⊑ ashrsgt_01_09_after

theorem lt_signed_to_small_unsigned_proof : lt_signed_to_small_unsigned_before ⊑ lt_signed_to_small_unsigned_after

theorem test9_proof : test9_before ⊑ test9_after

theorem main3d_logical_thm.extracted_1._3 : ∀ (x : BitVec 32),
  ¬ofBool (x &&& 7#32 != 0#32) = 1#1 →
    ofBool (x &&& 16#32 == 16#32) = 1#1 → 0#32 = zeroExtend 32 (ofBool (x &&& 23#32 == 0#32))

theorem test13_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32), ¬(8#32 ≥ ↑32 ∨ 8#32 ≥ ↑32) → 8#32 ≥ ↑32 → False

theorem ashrsgt_01_15_thm (e : IntW 4) :
  icmp IntPred.sgt (ashr e (const? 4 1)) (const? 4 (-1)) ⊑ icmp IntPred.sgt e (const? 4 (-1))

theorem lshrult_01_12_exact_thm (e : IntW 4) :
  icmp IntPred.ult (lshr e (const? 4 1) { «exact» := true }) (const? 4 (-4)) ⊑ const? 1 1

theorem sub_ashr_and_i32_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬(True ∧ x_1.ssubOverflow x = true ∨ 31#32 ≥ ↑32) →
    ofBool (x_1 <ₛ x) = 1#1 → (x_1 - x).sshiftRight' 31#32 &&& x = x

theorem negate_zext_proof : negate_zext_before ⊑ negate_zext_after

theorem and_logic_and_logic_or_5_thm.extracted_1._2 : ∀ (x x_1 : BitVec 1), ¬x_1 = 1#1 → 0#1 = 1#1 → 1#1 = 0#1

theorem scalar_i32_lshr_and_negC_ne_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬x ≥ ↑32 → ofBool (x_1 >>> x &&& BitVec.ofInt 32 (-262144) != 0#32) = ofBool (262143#32 <ᵤ x_1 >>> x)

@[simp]
theorem Expr.regArgs_mk {Γ : Ctxt d.Ty} {ty eff op}
    (ty_eq : ty = DialectSignature.returnTypes op)
    (eff_le : DialectSignature.effectKind op ≤ eff)
    (args : HVector (Var Γ) (DialectSignature.sig op)) (regArgs) :
    (Expr.mk op ty_eq eff_le args regArgs).regArgs = regArgs

theorem scalar_i32_shl_and_signbit_ne_proof : scalar_i32_shl_and_signbit_ne_before ⊑ scalar_i32_shl_and_signbit_ne_after

theorem ashrslt_02_07_proof : ashrslt_02_07_before ⊑ ashrslt_02_07_after

theorem add_constant_equal_with_the_top_bit_of_demandedbits_insertpt_proof : add_constant_equal_with_the_top_bit_of_demandedbits_insertpt_before ⊑ add_constant_equal_with_the_top_bit_of_demandedbits_insertpt_after

theorem and_ne_with_one_bit_diff_constants3_logical_proof : and_ne_with_one_bit_diff_constants3_logical_before ⊑ and_ne_with_one_bit_diff_constants3_logical_after

theorem or_xor_or_proof : or_xor_or_before ⊑ or_xor_or_after

@[simp]
theorem Factor.numVars_term : (Factor.var n).numVars = n + 1

theorem pow2_or_zero_is_negative_commute_thm (e : IntW 8) :
  icmp IntPred.slt (LLVM.and (sub (const? 8 0) (mul (const? 8 42) e)) (mul (const? 8 42) e)) (const? 8 0) ⊑
    icmp IntPred.eq (mul e (const? 8 42)) (const? 8 (-128))

theorem logical_or_bitwise_or_icmps_comm1_thm.extracted_1._2 : ∀ (x x_1 x_2 : BitVec 8),
  ¬x_1 ≥ ↑8 → ofBool (x_2 &&& 1#8 <<< x_1 == 0#8) = 1#1 → True ∧ 1#8 <<< x_1 >>> x_1 ≠ 1#8 ∨ x_1 ≥ ↑8 → False

theorem p0_proof : p0_before ⊑ p0_after

theorem test_mul_nuw_nsw__nsw_is_safe_thm.extracted_1._3 : ∀ (x : BitVec 32),
  ¬ofBool (x ||| BitVec.ofInt 32 (-83886080) == BitVec.ofInt 32 (-83886079)) = 1#1 →
    ¬(True ∧ (x ||| BitVec.ofInt 32 (-83886080)).smulOverflow 9#32 = true ∨
          True ∧ (x ||| BitVec.ofInt 32 (-83886080)).umulOverflow 9#32 = true) →
      True ∧ (x ||| BitVec.ofInt 32 (-83886080)).smulOverflow 9#32 = true → False

theorem e_1485 :
     - 2 *  ~~~(z &&&  ~~~t) + 2 *  ~~~(z &&& t) + 5 * z + 1 * (z |||  ~~~t) - 2 *  ~~~z + 3 *  ~~~(z ^^^ t) + 1 * (z ^^^ t) - 3 *  ~~~(z &&&  ~~~z) + 1 *  ~~~(z ||| t) + 12 *  ~~~(z |||  ~~~t) + 4 * (z &&& t) = 2 * t + 6 * (z ||| t)

theorem sgt_zero_eq_not_neg_sgt_zero (A : BitVec w) (h_ne_intMin : A ≠ intMin w)
    (h_ne_zero : A ≠ 0) : (A >ₛ 0#w) ↔ ¬ ((-A) >ₛ 0#w)

theorem test14_thm (e : IntW 32) (e_1 : IntW 64) :
  urem e_1 (zext 64 (shl (const? 32 1) e)) ⊑
    LLVM.and e_1
      (add (zext 64 (shl (const? 32 1) e { «nsw» := false, «nuw» := true })) (const? 64 (-1))
        { «nsw» := true, «nuw» := false })

theorem sdiv_icmp6_proof : sdiv_icmp6_before ⊑ sdiv_icmp6_after

theorem e_1369 :
    2 * (z |||  ~~~t) + 3 *  ~~~t - 1 * (z ||| t) - 6 *  ~~~(z &&&  ~~~z) - 2 * t - 5 * (z ^^^ t) + 2 *  ~~~(z &&& t) + 12 *  ~~~(z |||  ~~~t) + 5 * (z &&&  ~~~t) + 8 * (z &&& t) = 1 *  ~~~(z ^^^ t)

theorem a_true_implies_b_false2_comm_thm.extracted_1._8 : ∀ (x x_1 : BitVec 1) (x_2 : BitVec 8),
  ¬ofBool (x_2 == 10#8) = 1#1 → ¬ofBool (20#8 <ᵤ x_2) = 1#1 → x &&& ofBool (20#8 <ᵤ x_2) = 0#1

theorem test15e_proof : test15e_before ⊑ test15e_after

theorem add_const_const_sub_nsw_proof : add_const_const_sub_nsw_before ⊑ add_const_const_sub_nsw_after

theorem t0_thm.extracted_1._2 : ∀ (x : BitVec 16) (x_1 : BitVec 32),
  ¬(zeroExtend 32 (32#16 - x) ≥ ↑32 ∨ x + -1#16 ≥ ↑16) →
    ¬(31#32 ≥ ↑32 ∨ True ∧ signExtend 32 (truncate 16 (x_1.sshiftRight' 31#32)) ≠ x_1.sshiftRight' 31#32) →
      (truncate 16 (x_1.sshiftRight' (zeroExtend 32 (32#16 - x)))).sshiftRight' (x + -1#16) =
        truncate 16 (x_1.sshiftRight' 31#32)

theorem sdiv_i1_is_op0_thm (e e_1 : IntW 1) : LLVM.sdiv e_1 e ⊑ e_1

theorem exact_ashr_ne_both_equal_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬(True ∧ BitVec.ofInt 8 (-128) >>> x <<< x ≠ BitVec.ofInt 8 (-128) ∨ x ≥ ↑8) →
    ofBool ((BitVec.ofInt 8 (-128)).sshiftRight' x != BitVec.ofInt 8 (-128)) = ofBool (x != 0#8)

theorem shl_nsw_ule_Csle0_fail_missing_flag_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ¬(True ∧ (x_1 <<< x).sshiftRight' x ≠ x_1 ∨ x ≥ ↑8) →
    ofBool (x_1 <<< x ≤ᵤ BitVec.ofInt 8 (-19)) = ofBool (x_1 <<< x <ᵤ BitVec.ofInt 8 (-18))

theorem testi16i8_ne_com_thm.extracted_1._1 : ∀ (x : BitVec 16),
  ¬(8#16 ≥ ↑16 ∨ 7#8 ≥ ↑8) →
    ofBool (truncate 8 (x >>> 8#16) != (truncate 8 x).sshiftRight' 7#8) =
      ofBool (x + BitVec.ofInt 16 (-128) <ᵤ BitVec.ofInt 16 (-256))

theorem and_signbit_select_ashr_proof : and_signbit_select_ashr_before ⊑ and_signbit_select_ashr_after

theorem e_1498 :
     - 1 * z + 4 *  ~~~t + 3 *  ~~~(z ^^^ t) + 2 *  ~~~(z &&&  ~~~z) + 5 * (z |||  ~~~t) + 1 *  ~~~z + 1 *  ~~~(z &&& t) - 16 *  ~~~(z ||| t) - 15 *  ~~~(z |||  ~~~t) - 11 * (z &&&  ~~~t) - 20 * (z &&& t) =  - 11 * t

theorem ripple_nsw1_proof : ripple_nsw1_before ⊑ ripple_nsw1_after

theorem positive_biggerlshr_shlnsw_lshrexact_thm (e : IntW 8) :
  shl (lshr e (const? 8 6) { «exact» := true }) (const? 8 3) { «nsw» := true, «nuw» := false } ⊑
    lshr e (const? 8 3) { «exact» := true }

theorem p0_proof : p0_before ⊑ p0_after

theorem e_1045 :
     - 1 *  ~~~(z &&&  ~~~t) + 1 *  ~~~(z &&&  ~~~z) + 1 * (z ||| t) - 5 * (z |||  ~~~t) + 1 *  ~~~(z |||  ~~~t) + 5 * (z &&&  ~~~t) + 4 * (z &&& t) = 2 *  ~~~(z &&& t) - 7 *  ~~~(z ||| t)

theorem slt_negative_multip_rem_zero_thm (e : IntW 8) :
  icmp IntPred.slt (mul e (const? 8 (-7)) { «nsw» := true, «nuw» := false }) (const? 8 21) ⊑
    icmp IntPred.sgt e (const? 8 (-3))

@[simp]
lemma Fin.clamp_eq_bound : Fin.clamp m n = Fin.last n ↔ n ≤ m

theorem and_xor_or6_thm (e e_1 e_2 : IntW 64) :
  LLVM.or (LLVM.udiv (const? 64 42) e_2)
      (LLVM.xor (LLVM.and (LLVM.udiv (const? 64 42) e_2) (LLVM.udiv (const? 64 42) e_1)) (LLVM.udiv (const? 64 42) e)) ⊑
    LLVM.or (LLVM.udiv (const? 64 42) e_2) (LLVM.udiv (const? 64 42) e)

theorem no_shift_no_xor_multiuse_cmp_or_thm.extracted_1._2 : ∀ (x x_1 x_2 : BitVec 32),
  ¬ofBool (x_2 &&& 4096#32 == 0#32) = 1#1 →
    (x_1 ||| 4096#32) * x * (x_1 ||| 4096#32) = (x_1 ||| x_2 &&& 4096#32) * x * (x_1 ||| 4096#32)

theorem e_140 :
     - 11 *  ~~~x + 5 * (x ||| y) + 4 *  ~~~(x ^^^ y) + 7 *  ~~~(x ||| y) + 6 *  ~~~(x |||  ~~~y) - 9 * (x &&& y) = 5 * (x &&&  ~~~y)

theorem lshrult_03_07_thm.extracted_1._1 : ∀ (x : BitVec 4), ¬3#4 ≥ ↑4 → ofBool (x >>> 3#4 <ᵤ 7#4) = 1#1

@[bv_multi_width_normalize]
theorem Nat.lt_of_not_le (v w : Nat) : ¬ (v ≤ w) ↔ w < v

theorem sub_sext_mask1_trunc_lshr_proof : sub_sext_mask1_trunc_lshr_before ⊑ sub_sext_mask1_trunc_lshr_after

theorem AvoidCollision_setWidth_zero (m n : Nat) : setWidth m 0#n = 0#m

theorem add_select_not_zext_thm (e : IntW 1) :
  add (select e (const? 64 64) (const? 64 1)) (zext 64 (LLVM.xor e (const? 1 1))) ⊑
    select e (const? 64 64) (const? 64 2)

theorem test8_thm (e : IntW 32) :
  icmp IntPred.ugt (LLVM.udiv (const? 32 4) e) (const? 32 3) ⊑ icmp IntPred.ult e (const? 32 2)

theorem or_or_xor_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 4),
  (x_2 ||| x_1) ^^^ (x_2 ||| x) = (x_1 ^^^ x) &&& (x_2 ^^^ -1#4)

theorem positive_with_extra_and_proof : positive_with_extra_and_before ⊑ positive_with_extra_and_after

theorem t7_thm.extracted_1._4 : ∀ (x : BitVec 8) (x_1 : BitVec 1) (x_2 : BitVec 8),
  ¬x_1 = 1#1 →
    ¬x ≥ ↑8 → ¬(True ∧ ((-1#8) <<< x).sshiftRight' x ≠ -1#8 ∨ x ≥ ↑8) → x_2 - 1#8 <<< x = (-1#8) <<< x + x_2

theorem test7_proof : test7_before ⊑ test7_after

theorem select_bittest_to_add_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x &&& 1#32 == 0#32) = 1#1 →
    True ∧ (x &&& 1#32).saddOverflow 3#32 = true ∨ True ∧ (x &&& 1#32).uaddOverflow 3#32 = true → False

theorem _root_.AList.mem_of_mem_entries {α : Type _} {β : α → Type _} {s : AList β}
    {k : α} {v : β k} :
    ⟨k, v⟩ ∈ s.entries → k ∈ s

theorem t0_proof : t0_before ⊑ t0_after

theorem clear_to_clear_decomposebittest_thm.extracted_1._2 : ∀ (x : BitVec 8),
  ofBool (-1#8 <ₛ x) = 1#1 →
    ¬(True ∧ (x &&& BitVec.ofInt 8 (-128) &&& 3#8 != 0) = true) → 3#8 = x &&& BitVec.ofInt 8 (-128) ||

theorem e_632 :
    2 *  ~~~(x &&&  ~~~x) + 7 *  ~~~x + 2 * (x |||  ~~~y) + 2 * (x ||| y) - 7 * x + 2 *  ~~~(x &&&  ~~~y) - 15 *  ~~~(x ||| y) - 13 *  ~~~(x |||  ~~~y) - 1 * (x &&&  ~~~y) - 1 * (x &&& y) =  - 2 *  ~~~y

theorem e_1084 :
     - 6 * t + 1 *  ~~~(z &&& t) + 1 * z - 6 *  ~~~(z ^^^ t) - 1 * (z ||| t) + 5 *  ~~~(z ||| t) + 6 *  ~~~(z |||  ~~~t) - 1 * (z &&&  ~~~t) =  - 12 * (z &&& t)

theorem bools2_logical_commute1_and1_thm.extracted_1._7 : ∀ (x x_1 x_2 : BitVec 1),
  ¬x_2 &&& x_1 = 1#1 → x_1 ^^^ 1#1 = 1#1 → x_1 = 1#1 → x = x_2

theorem e_2059 :
    2 * (f ^^^  ~~~(d |||  ~~~e)) - 1 * (e ||| (d &&& f)) + 3 * ((e &&& f) ||| (d &&& (e ||| f))) + 11 * (e ^^^ ( ~~~d ||| (e ^^^ f))) + 1 * (d &&& e) - 1 * (e ^^^  ~~~( ~~~d ||| (e ^^^ f))) + 1 * (f ^^^  ~~~( ~~~d ||| ( ~~~e &&& f))) - 6 * (e ^^^ (d ||| ( ~~~e &&& f))) - 1 * (e ^^^ ( ~~~d ||| ( ~~~e ||| f))) + 7 * (e ^^^  ~~~( ~~~d ||| ( ~~~e &&& f))) + 3 * (e ^^^ ( ~~~d ||| (e ||| f))) + 7 * (f &&& (d ^^^ e)) - 1 * (f &&&  ~~~(d ^^^ e)) - 11 * (f ^^^  ~~~(d ||| (e &&& f))) - 2 * (f ^^^  ~~~(d &&& ( ~~~e &&& f))) - 2 * ( ~~~(d ^^^ e) &&& (d ^^^ f)) - 1 *  ~~~(d &&&  ~~~f) + 1 *  ~~~(d ||| ( ~~~e &&& f)) - 3 * (f &&&  ~~~(d &&&  ~~~e)) + 1 *  ~~~(d &&& ( ~~~e ||| f)) + 5 * (e ^^^ (d ||| (e &&& f))) - 3 *  ~~~( ~~~d &&& ( ~~~e &&& f)) + 7 * (e &&&  ~~~(d &&& f)) - 1 *  ~~~(d ||| (e &&& f)) - 3 * ( ~~~e &&& (d ^^^ f)) - 7 * (e ^^^ ( ~~~d &&& (e ^^^ f))) - 1 * (f ^^^  ~~~(d &&&  ~~~e)) - 5 * ( ~~~d &&& (e ||| f)) + 1 * ((d ||| e) &&& (d ^^^ (e ^^^ f))) - 11 *  ~~~(d ||| e) + 12 *  ~~~(d ||| (e ||| f)) + 5 *  ~~~(d ||| ( ~~~e ||| f)) - 1 *  ~~~( ~~~d ||| (e ||| f)) + 4 *  ~~~( ~~~d ||| ( ~~~e ||| f)) + 23 * ( ~~~d &&& ( ~~~e &&& f)) + 9 * ( ~~~d &&& (e &&& f)) - 9 * (d &&& ( ~~~e &&& f)) + 8 * (d &&& (e &&& f)) =  - 1 * (d |||  ~~~f) - 2 * (e ^^^  ~~~( ~~~d &&& (e ||| f)))

theorem main14_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (0#16 ≤ₛ truncate 16 x) &&& ofBool (0#8 ≤ₛ truncate 8 x) = 1#1 →
    ¬ofBool (x &&& 32896#32 == 0#32) = 1#1 → 2#32 = 1#32

theorem ule_swap_or_min_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ofBool (x ≤ᵤ x_1) ||

theorem icmp_ne_and_pow2_shl_pow2_proof : icmp_ne_and_pow2_shl_pow2_before ⊑ icmp_ne_and_pow2_shl_pow2_after

theorem narrow_sext_mul_proof : narrow_sext_mul_before ⊑ narrow_sext_mul_after

theorem masked_icmps_mask_notallzeros_bmask_mixed_negated_7_logical_thm (e : IntW 32) :
  select (icmp IntPred.eq (LLVM.and e (const? 32 7)) (const? 32 0)) (const? 1 1)
      (icmp IntPred.ne (LLVM.and e (const? 32 15)) (const? 32 8)) ⊑
    const? 1 1

theorem test69_xor_thm.extracted_1._2 : ∀ (x x_1 : BitVec 32),
  ofBool (x_1 &&& 128#32 != 0#32) = 1#1 → ¬6#32 ≥ ↑32 → x = x_1 >>> 6#32 &&& 2#32 ^^^ x ^^^ 2#32

theorem e_721 :
    3 *  ~~~x - 1 * (x |||  ~~~y) + 3 *  ~~~(x &&&  ~~~y) - 2 *  ~~~y + 7 *  ~~~(x &&& y) - 3 * x - 6 * (x ^^^ y) - 1 * (x ||| y) - 10 *  ~~~(x ||| y) + 6 * (x &&&  ~~~y) + 2 * (x &&& y) = 6 *  ~~~(x |||  ~~~y)

theorem shift_xor_multiuse_cmp_xor_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 32),
  ofBool (0#32 != x_2 &&& 4096#32) = 1#1 → ofBool (x_2 &&& 4096#32 == 0#32) = 1#1 → False

theorem demorgan_and_apint2_proof : demorgan_and_apint2_before ⊑ demorgan_and_apint2_after

theorem lshr_add_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ¬(5#8 ≥ ↑8 ∨ (42#8 == 0 || 8 != 1 && x == intMin 8 && 42#8 == -1) = true ∨ 5#8 ≥ ↑8) →
    (42#8 == 0 || 8 != 1 && x == intMin 8 && 42#8 == -1) = true ∨ 5#8 ≥ ↑8 → False

theorem e_444 :
    1 *  ~~~(x &&&  ~~~x) - 5 *  ~~~y - 5 * (x ^^^ y) + 3 *  ~~~(x &&& y) + 1 *  ~~~(x ||| y) - 3 *  ~~~(x |||  ~~~y) + 5 * (x &&&  ~~~y) - 6 * (x &&& y) =  - 4 * y - 1 * x

theorem select_1_thm.extracted_1._19 : ∀ (x x_1 : BitVec 8) (x_2 : BitVec 1) (x_3 x_4 : BitVec 8) (x_5 : BitVec 1),
  ¬x_5 = 1#1 → x_2 = 1#1 → x_1 ^^^ -1#8 ^^^ -1#8 = x_1

theorem main7a_logical_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (x_1 &&& x == x_1) = 1#1 → ofBool (x_1 &&& x != x_1) = 1#1 → 0#1 = 1#1 → 0#32 = zeroExtend 32 1#1

theorem test4_thm.extracted_1._1 : ∀ (x : BitVec 49), (x &&& BitVec.ofInt 49 (-2)) + 1#49 = x ||

theorem e_2434 :
    1 * (d ||| f) - 2 *  ~~~(d ||| f) - 7 * (f &&&  ~~~(d &&&  ~~~e)) + 5 * (f ^^^  ~~~( ~~~d &&& (e &&& f))) + 1 * ((d &&& e) ^^^  ~~~(d ^^^ ( ~~~e ||| f))) - 7 * ( ~~~(d ^^^ e) &&& (d ^^^ f)) + 7 * (f ^^^  ~~~(d ||| (e &&& f))) - 7 * ( ~~~(d &&&  ~~~e) &&& (e ^^^ f)) - 2 * (e ^^^  ~~~( ~~~d ||| (e &&& f))) - 11 *  ~~~(d &&&  ~~~e) - 3 * (d &&&  ~~~e) + 1 * (e ^^^  ~~~(d &&& ( ~~~e ||| f))) - 5 * (e ^^^  ~~~(d ||| (e &&& f))) + 1 * ((e &&& f) ^^^  ~~~( ~~~d &&& (e ^^^ f))) + 2 * (f &&&  ~~~(d ^^^ e)) - 1 * ((e &&&  ~~~f) ^^^ (d ||| (e ^^^ f))) + 4 *  ~~~(d ^^^ (e &&& f)) - 3 * (e ^^^ (d ||| f)) + 11 * (d |||  ~~~e) + 1 * ((d &&& e) ^^^  ~~~(d ^^^ (e &&& f))) - 7 * ( ~~~(d &&& e) &&& (d ^^^ (e ^^^ f))) - 1 * ( ~~~(d ||| e) ||| (d ^^^ (e ^^^ f))) - 2 * (f ^^^  ~~~(d &&& (e &&& f))) - 5 * (e ^^^ (d ||| ( ~~~e ||| f))) + 3 * (d ||| ( ~~~e &&& f)) + 4 *  ~~~( ~~~d &&& (e ^^^ f)) + 5 * (f ^^^  ~~~(d &&& (e ||| f))) - 6 *  ~~~(d ^^^ (e ^^^ f)) + 11 * (d &&& ( ~~~e ||| f)) + 1 * ( ~~~(d |||  ~~~e) ||| (d ^^^ (e ^^^ f))) + 7 * ((d &&& e) |||  ~~~(e ^^^ f)) + 3 * (e &&& f) - 2 * ((d ||| e) &&&  ~~~(d ^^^ (e ^^^ f))) + 1 * ((d &&& f) |||  ~~~(e ||| f)) - 11 *  ~~~(d ^^^ ( ~~~e ||| f)) - 3 * (d ^^^ e) + 7 * (f ^^^  ~~~(d &&& e)) + 5 *  ~~~( ~~~d ||| ( ~~~e &&& f)) - 1 * (e ^^^  ~~~( ~~~d ||| (e ^^^ f))) + 2 *  ~~~( ~~~d &&& ( ~~~e &&& f)) - 1 * (f ^^^ ( ~~~d ||| (e ||| f))) + 2 * (d &&& (e ^^^ f)) - 1 * ( ~~~(d ^^^ e) |||  ~~~(d ^^^ f)) - 5 * ( ~~~f &&&  ~~~(d ^^^ e)) - 7 * (f ^^^  ~~~(d |||  ~~~e)) - 1 * (e ^^^  ~~~(d &&& (e ^^^ f))) + 11 * ((d |||  ~~~e) &&&  ~~~(d ^^^ (e ^^^ f))) + 4 * (e ^^^  ~~~(d |||  ~~~f)) + 3 * (d ||| ( ~~~e ||| f)) + 1 * ( ~~~(d ||| e) ||| (e ^^^ f)) + 11 *  ~~~(e |||  ~~~f) + 7 * (e ^^^  ~~~(d &&& ( ~~~e &&& f))) + 2 *  ~~~(d &&&  ~~~d) - 2 * (e ^^^  ~~~(d ||| f)) - 1 * e + 2 *  ~~~(d &&& f) - 5 * ( ~~~(d &&& e) &&& (e ^^^ f)) - 6 * ((e &&& f) ||| (d &&& (e ||| f))) + 1 *  ~~~(e &&& f) + 2 * (e &&&  ~~~(d &&& f)) - 2 * (e ^^^ (d ||| ( ~~~e &&& f))) - 11 * (e |||  ~~~f) + 5 *  ~~~(d &&& (e ^^^ f)) - 1 * d + 1 * (f ^^^  ~~~( ~~~d &&& ( ~~~e ||| f))) + 7 * ((d &&& f) ||| (e &&&  ~~~f)) + 1 * ((d &&& f) ^^^ (d ^^^ ( ~~~e &&& f))) + 1 * (d ||| (e &&& f)) - 29 *  ~~~(d ||| (e ||| f)) + 25 *  ~~~(d ||| ( ~~~e ||| f)) - 33 *  ~~~( ~~~d ||| (e ||| f)) - 8 *  ~~~( ~~~d ||| ( ~~~e ||| f)) + 15 * ( ~~~d &&& ( ~~~e &&& f)) + 13 * ( ~~~d &&& (e &&& f)) - 23 * (d &&& ( ~~~e &&& f)) - 27 * (d &&& (e &&& f)) = 1 * (d ^^^ ( ~~~e &&& f)) + 6 * (e ^^^ ( ~~~d ||| (e ||| f)))

theorem a_true_implies_b_true2_thm.extracted_1._3 : ∀ (x : BitVec 1) (x_1 : BitVec 8),
  ¬ofBool (10#8 <ᵤ x_1) = 1#1 → ofBool (20#8 <ᵤ x_1) = 1#1 → False

theorem test3_thm.extracted_1._1 : ∀ (x : BitVec 32), ofBool (x <ₛ x) = 0#1

theorem uge_swap_and_max_commute_logical_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬ofBool (x == -1#8) = 1#1 → 0#1 = ofBool (x == -1#8)

theorem foo2_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (2#32 <ₛ x_1) = 1#1 → ¬(True ∧ x_1.ssubOverflow x = true) → x_1 - x = x_1 + (0#32 - x)

theorem sext_ule_sext_proof : sext_ule_sext_before ⊑ sext_ule_sext_after

theorem ult_rem_zero_thm (e : IntW 8) :
  icmp IntPred.ult (mul e (const? 8 7) { «nsw» := false, «nuw» := true }) (const? 8 21) ⊑
    icmp IntPred.ult e (const? 8 3)

theorem n0_proof : n0_before ⊑ n0_after

theorem udiv_lshr_mul_nuw_proof : udiv_lshr_mul_nuw_before ⊑ udiv_lshr_mul_nuw_after

theorem and_xor_or5_thm (e e_1 e_2 : IntW 64) :
  LLVM.or (LLVM.udiv (const? 64 42) e_2)
      (LLVM.xor (LLVM.and (LLVM.udiv (const? 64 42) e_1) (LLVM.udiv (const? 64 42) e_2)) (LLVM.udiv (const? 64 42) e)) ⊑
    LLVM.or (LLVM.udiv (const? 64 42) e_2) (LLVM.udiv (const? 64 42) e)

theorem p_commutative4_proof : p_commutative4_before ⊑ p_commutative4_after

theorem and_logic_and_logic_or_1_thm.extracted_1._3 : ∀ (x x_1 x_2 : BitVec 1),
  x_2 &&& x_1 = 1#1 → x_2 = 1#1 → ¬x_1 = 1#1 → 1#1 = x

theorem positive_samevar_shlnsw_ashrexact_proof : positive_samevar_shlnsw_ashrexact_before ⊑ positive_samevar_shlnsw_ashrexact_after

theorem trunc_ashr_trunc_exact_thm.extracted_1._1 : ∀ (x : BitVec 64),
  ¬(True ∧ truncate 32 x >>> 8#32 <<< 8#32 ≠ truncate 32 x ∨ 8#32 ≥ ↑32) →
    True ∧ x >>> 8#64 <<< 8#64 ≠ x ∨ 8#64 ≥ ↑64 → False

theorem e_2321 :
     - 11 *  ~~~(e ^^^ f) + 2 * (e ^^^ (d &&& (e ^^^ f))) + 2 * ( ~~~f |||  ~~~(d ^^^ e)) - 11 * ( ~~~d ||| (e ||| f)) + 3 * (e ^^^  ~~~(d &&& ( ~~~e &&& f))) + 7 * ((d &&&  ~~~e) |||  ~~~(d ^^^ (e ^^^ f))) - 3 * (f &&&  ~~~(d &&& e)) - 7 * ((d &&&  ~~~e) ||| (d ^^^ (e ^^^ f))) + 1 * (d &&& ( ~~~e ||| f)) + 1 *  ~~~(d &&& ( ~~~e ||| f)) - 1 * (d &&&  ~~~f) + 1 * (e ^^^  ~~~(d ||| (e ^^^ f))) - 11 * ( ~~~(d &&& e) &&& (e ^^^ f)) - 2 * ((d &&& f) ^^^  ~~~(d ^^^ ( ~~~e &&& f))) + 2 *  ~~~(d &&& (e ^^^ f)) - 2 * (e |||  ~~~(d ||| f)) + 1 * (f ^^^ ( ~~~d ||| ( ~~~e &&& f))) - 11 * ((d &&& f) ^^^  ~~~(d ^^^ (e &&& f))) + 11 * (d ^^^ (e ^^^ f)) - 1 * ( ~~~d ||| (e &&& f)) - 1 * ((d ||| e) &&&  ~~~(e ^^^ f)) + 2 * ( ~~~f &&&  ~~~(d ^^^ e)) - 1 * (e ^^^  ~~~(d &&& (e ^^^ f))) - 1 * (e ^^^ ( ~~~d &&& ( ~~~e ||| f))) - 1 * (e ^^^ (d &&& f)) + 1 *  ~~~(d ^^^ (e &&& f)) - 2 * ((d ^^^ e) &&&  ~~~(d ^^^ f)) + 4 * (d |||  ~~~e) + 11 * ( ~~~d &&& (e ||| f)) - 3 * (d &&& e) + 7 * (e ^^^  ~~~(d ||| f)) + 3 * (e &&&  ~~~(d &&&  ~~~f)) + 7 * (f ^^^ (d ||| ( ~~~e ||| f))) - 1 * (f ^^^  ~~~( ~~~d &&& (e ||| f))) + 3 * ( ~~~d &&& (e ^^^ f)) - 6 * ((d ||| e) &&& (e ^^^ f)) - 5 * ((d |||  ~~~e) &&& (d ^^^ (e ^^^ f))) + 3 * (f &&& (d ||| e)) + 1 * ((d &&&  ~~~e) ||| (e ^^^ f)) - 3 * (f ^^^ ( ~~~d ||| ( ~~~e ||| f))) - 11 * (e ^^^ (d ||| f)) - 11 * ((d &&& e) ^^^  ~~~(d ^^^ (e &&& f))) + 1 * ( ~~~(d &&&  ~~~e) &&& (d ^^^ (e ^^^ f))) + 11 * (f &&&  ~~~(d &&&  ~~~e)) + 1 * (f ^^^ ( ~~~d ||| (e &&& f))) + 5 * ((d ^^^ e) &&& (d ^^^ f)) - 5 * (e ^^^ (d &&& (e ||| f))) - 1 * (d ||| (e &&& f)) + 2 * (e ^^^ (d |||  ~~~f)) + 1 * (d |||  ~~~f) - 7 * (f |||  ~~~(d ^^^ e)) - 5 *  ~~~( ~~~d ||| (e &&& f)) + 1 *  ~~~d + 3 * ( ~~~(d &&& e) &&&  ~~~(e ^^^ f)) + 11 * ( ~~~(d |||  ~~~e) ||| (d ^^^ (e ^^^ f))) - 7 * ( ~~~(d |||  ~~~e) ||| (e ^^^ f)) + 14 *  ~~~(d ||| (e ||| f)) + 38 *  ~~~(d ||| ( ~~~e ||| f)) - 13 *  ~~~( ~~~d ||| (e ||| f)) + 23 *  ~~~( ~~~d ||| ( ~~~e ||| f)) + 23 * ( ~~~d &&& ( ~~~e &&& f)) - 18 * ( ~~~d &&& (e &&& f)) + 66 * (d &&& ( ~~~e &&& f)) - 12 * (d &&& (e &&& f)) =  - 2 * (e ^^^  ~~~(d ||| (e &&& f)))

theorem main12_logical_thm.extracted_1._4 : ∀ (x : BitVec 32),
  ¬ofBool (truncate 16 x <ₛ 0#16) = 1#1 →
    ¬ofBool (x &&& 32896#32 == 0#32) = 1#1 → ¬ofBool (truncate 8 x <ₛ 0#8) = 1#1 → 1#32 = 2#32

theorem uge_or_max_proof : uge_or_max_before ⊑ uge_or_max_after

theorem masked_and_notA_logical_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x &&& 14#32 != x) = 1#1 → ofBool (x &&& 78#32 != x) = ofBool (x &&& BitVec.ofInt 32 (-79) != 0#32)

theorem xor_or_xor_common_op_commute5_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 32),
  (x_2 ||| x_1) ^^^ (x_2 ^^^ x) = x_1 &&& (x_2 ^^^ -1#32) ^^^ x

theorem e_897 :
     - 1 *  ~~~z + 2 *  ~~~(z &&& t) + 1 *  ~~~(z &&&  ~~~t) + 7 * t - 2 * (z &&&  ~~~t) - 8 * (z &&& t) = 2 *  ~~~(z ||| t) + 9 *  ~~~(z |||  ~~~t)

theorem p0_scalar_proof : p0_scalar_before ⊑ p0_scalar_after

theorem e_369 :
     - 5 * (x ^^^ y) - 3 * (x |||  ~~~y) - 11 * y + 2 * (x ||| y) + 5 *  ~~~(x ^^^ y) + 1 * x - 2 *  ~~~(x ||| y) + 5 * (x &&&  ~~~y) =  - 6 * (x &&& y) - 14 *  ~~~(x |||  ~~~y)

@[simp]
lemma CNFA.autUnsignedCmp_stateMax cmp : (autUnsignedCmp cmp).m.stateMax = 3

theorem test15_thm (e : IntW 32) :
  sub (const? 64 8) (sext 64 (ashr e (const? 32 1))) ⊑
    sext 64 (sub (const? 32 8) (ashr e (const? 32 1)) { «nsw» := true, «nuw» := false })

theorem e_751 :
     - 7 * (z ||| t) + 2 *  ~~~z + 7 * z =  - 5 *  ~~~(z |||  ~~~t) + 2 *  ~~~(z ||| t)

theorem substitute_constant_and_eq_ugt_swap_logical_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ofBool (x <ᵤ x_1) = 1#1 → ofBool (x == 42#8) = ofBool (x == 42#8) &&& ofBool (42#8 <ᵤ x_1)

theorem sdiv_icmp2_thm (e : IntW 64) :
  icmp IntPred.eq (LLVM.sdiv e (const? 64 5) { «exact» := true }) (const? 64 1) ⊑
    icmp IntPred.eq e (const? 64 5)

theorem t2_ult_sgt_128_thm.extracted_1._8 : ∀ (x x_1 x_2 : BitVec 32),
  ofBool (x_2 + 16#32 <ᵤ 144#32) = 1#1 →
    ¬ofBool (127#32 <ₛ x_2) = 1#1 → ofBool (x_2 <ₛ BitVec.ofInt 32 (-16)) = 1#1 → x_2 = x

theorem not_logicalOr_not_op1_thm.extracted_1._2 : ∀ (x : BitVec 1), x = 1#1 → ¬x ^^^ 1#1 = 1#1 → 1#1 ^^^ 1#1 = 0#1

theorem n2_thm (e : IntW 8) :
  LLVM.sdiv e (const? 8 (-128)) ⊑ zext 8 (icmp IntPred.eq e (const? 8 (-128)))

theorem for_return {t : Arith.Ty} (istart istep: Var Γ Arith.Ty.int)
    (niters : Var Γ .nat) (v : Var Γ t) :
    Expr.denoteOp (for_ (t := t) istart istep niters v (RegionRet t ⟨1, by simp⟩)) Γv = [Γv v]ₕ

theorem masked_icmps_mask_notallzeros_bmask_mixed_swapped_5_logical_thm (e : IntW 32) :
  select (icmp IntPred.eq (LLVM.and e (const? 32 15)) (const? 32 8))
      (icmp IntPred.ne (LLVM.and e (const? 32 15)) (const? 32 0)) (const? 1 0) ⊑
    icmp IntPred.eq (LLVM.and e (const? 32 15)) (const? 32 8)

theorem positive_different_trunc_both_logical_proof : positive_different_trunc_both_logical_before ⊑ positive_different_trunc_both_logical_after

theorem test19_proof : test19_before ⊑ test19_after

theorem e_1798 :
     - 1 *  ~~~(a ^^^ ( ~~~b &&& c)) + 11 * (b &&&  ~~~(a ^^^ c)) - 1 * ((a &&&  ~~~b) |||  ~~~(a ^^^ (b ^^^ c))) + 3 * ( ~~~b &&&  ~~~(a ^^^ c)) + 11 * (b &&&  ~~~(a &&&  ~~~c)) - 5 *  ~~~( ~~~a &&& (b ||| c)) - 2 * (a ||| (b ||| c)) - 11 * (a ||| ( ~~~b ||| c)) + 3 * ( ~~~(a &&&  ~~~b) &&&  ~~~(b ^^^ c)) + 5 * ((a ||| b) &&& (a ^^^ (b ^^^ c))) + 7 * ((a ||| b) &&&  ~~~(b ^^^ c)) + 1 * a - 2 * (b &&& c) + 1 *  ~~~(b |||  ~~~c) - 1 * ( ~~~(a &&&  ~~~b) &&& (a ^^^ (b ^^^ c))) - 7 * ((a |||  ~~~b) &&&  ~~~(b ^^^ c)) + 3 * (b |||  ~~~c) - 1 * (c ^^^  ~~~(a &&& (b &&& c))) - 1 * ( ~~~(a ^^^ b) ||| (a ^^^ c)) - 1 *  ~~~(a ^^^ (b &&& c)) + 1 * ((b &&&  ~~~c) |||  ~~~(a ||| ( ~~~b &&& c))) + 4 * (c ^^^  ~~~( ~~~a &&& (b ||| c))) - 11 *  ~~~b - 1 * (c ^^^  ~~~(a ||| ( ~~~b &&& c))) + 2 * (a ^^^ (b ||| c)) + 5 * (c ^^^  ~~~( ~~~a &&& ( ~~~b ||| c))) + 4 *  ~~~(a ^^^ (b ||| c)) + 5 *  ~~~(a ||| c) - 7 * ( ~~~(a |||  ~~~b) |||  ~~~(b ^^^ c)) - 3 * ((a ^^^ b) |||  ~~~(a ^^^ c)) + 11 * (b ^^^  ~~~(a |||  ~~~c)) - 7 * (b ^^^  ~~~(a ||| c)) + 34 *  ~~~(a ||| (b ||| c)) - 37 *  ~~~(a ||| ( ~~~b ||| c)) + 22 *  ~~~( ~~~a ||| (b ||| c)) - 1 *  ~~~( ~~~a ||| ( ~~~b ||| c)) + 5 * ( ~~~a &&& ( ~~~b &&& c)) - 1 * ( ~~~a &&& (b &&& c)) - 7 * (a &&& (b &&& c)) =  - 26 * (a &&& ( ~~~b &&& c))

theorem fold_select_trunc_nsw_false_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬(True ∧ signExtend 8 (truncate 1 x) ≠ x ∨ truncate 1 x = 1#1) → x = 0#8

theorem foo_thm.extracted_1._2 : ∀ (x x_1 x_2 x_3 : BitVec 32),
  ¬ofBool (x_2 <ₛ x_1) = 1#1 →
    x_3 &&& signExtend 32 (ofBool (x_2 <ₛ x_1)) ||

theorem test6_thm.extracted_1._1 : ∀ (x : BitVec 8), x ^^^ 17#8 ^^^ 17#8 = x

theorem gt_unsigned_to_large_signed_proof : gt_unsigned_to_large_signed_before ⊑ gt_unsigned_to_large_signed_after

theorem no_shift_xor_multiuse_cmp_proof : no_shift_xor_multiuse_cmp_before ⊑ no_shift_xor_multiuse_cmp_after

@[simp] theorem Com.denote_castPureToEff {com : Com d Γ .pure ty} :
    denote (com.castPureToEff eff) = fun V => pure (com.denote V)

theorem uadd_sat_via_add_swapped_cmp_nonstrict_proof : uadd_sat_via_add_swapped_cmp_nonstrict_before ⊑ uadd_sat_via_add_swapped_cmp_nonstrict_after

theorem e_709 :
    7 *  ~~~(x &&&  ~~~y) - 1 *  ~~~(x &&&  ~~~x) + 2 * (x |||  ~~~y) - 11 * x + 5 *  ~~~x + 11 * (x ||| y) - 13 *  ~~~(x ||| y) - 20 *  ~~~(x |||  ~~~y) + 1 * (x &&&  ~~~y) - 8 * (x &&& y) = 2 * (x ^^^ y)

theorem ashrsgt_03_01_exact_proof : ashrsgt_03_01_exact_before ⊑ ashrsgt_03_01_exact_after

theorem positive_sameconst_shlnuw_thm (e : IntW 8) :
  shl (lshr e (const? 8 3)) (const? 8 3) { «nsw» := false, «nuw» := true } ⊑ LLVM.and e (const? 8 (-8))

theorem a_thm (e : IntW 32) :
  LLVM.and (LLVM.srem e (const? 32 8)) (const? 32 1) ⊑ LLVM.and e (const? 32 1)

theorem logical_and_bitwise_and_icmps_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 8),
  ofBool (x_2 == 42#8) &&& ofBool (x_1 &&& 1#8 != 0#8) = 1#1 →
    ¬x ≥ ↑8 → True ∧ 1#8 <<< x >>> x ≠ 1#8 ∨ x ≥ ↑8 → False

theorem test_trunc_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬(True ∧ (zeroExtend 32 x).saddOverflow (-1#32) = true ∨ 31#32 ≥ ↑32) →
    truncate 8 ((zeroExtend 32 x + -1#32).sshiftRight' 31#32) ^^^ -1#8 = signExtend 8 (ofBool (x != 0#8))

theorem or_not_and_and_not_and_xor_commute2_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 32),
  ¬((x_2 == 0 || 32 != 1 && 42#32 == intMin 32 && x_2 == -1) = true ∨
        (x_2 == 0 || 32 != 1 && 42#32 == intMin 32 && x_2 == -1) = true) →
    ((42#32).sdiv x_2 ||| x_1 &&& x ^^^ -1#32) &&& ((x_1 ^^^ x) &&& (42#32).sdiv x_2 ^^^ -1#32) =
      (x_1 ^^^ x) &&& (42#32).sdiv x_2 ^^^ ((42#32).sdiv x_2 ||| x_1 &&& x ^^^ -1#32)

theorem ashrslt_03_05_exact_thm (e : IntW 4) :
  icmp IntPred.slt (ashr e (const? 4 3) { «exact» := true }) (const? 4 5) ⊑ const? 1 1

theorem e_1477 :
    7 *  ~~~(z &&&  ~~~z) - 7 *  ~~~z - 6 *  ~~~(z &&&  ~~~t) + 5 *  ~~~(z &&& t) + 2 * (z |||  ~~~t) + 5 * (z ^^^ t) + 2 *  ~~~t - 3 *  ~~~(z ||| t) + 1 *  ~~~(z |||  ~~~t) - 21 * (z &&&  ~~~t) + 2 * (z &&& t) = 5 * t

theorem narrow_sext_and_thm (e : IntW 32) (e_1 : IntW 16) :
  trunc 16 (LLVM.and (sext 32 e_1) e) ⊑ LLVM.and e_1 (trunc 16 e)

theorem logical_and_icmps2_proof : logical_and_icmps2_before ⊑ logical_and_icmps2_after

theorem add_shl_same_amount_proof : add_shl_same_amount_before ⊑ add_shl_same_amount_after

theorem foo1_or_commuted_thm.extracted_1._2 : ∀ (x x_1 x_2 : BitVec 32),
  ¬(x_1 ≥ ↑32 ∨ x ≥ ↑32) →
    ¬(True ∧ 1#32 <<< x_1 >>> x_1 ≠ 1#32 ∨
          x_1 ≥ ↑32 ∨
            True ∧ 1#32 <<< x >>> x ≠ 1#32 ∨
              x ≥ ↑32 ∨ True ∧ 1#32 <<< x_1 >>> x_1 ≠ 1#32 ∨ x_1 ≥ ↑32 ∨ True ∧ 1#32 <<< x >>> x ≠ 1#32 ∨ x ≥ ↑32) →
      ofBool (x_2 * x_2 &&& 1#32 <<< x_1 != 0#32) &&& ofBool (1#32 <<< x &&& x_2 * x_2 != 0#32) =
        ofBool (x_2 * x_2 &&& (1#32 <<< x_1 ||| 1#32 <<< x) == 1#32 <<< x_1 ||| 1#32 <<< x)

theorem foo_proof : foo_before ⊑ foo_after

theorem bools2_logical_commute0_and1_and2_thm.extracted_1._3 : ∀ (x x_1 x_2 : BitVec 1),
  x_2 &&& x_1 = 1#1 → x_2 = 1#1 → 1#1 = x_1

theorem uge_swap_and_max_commute_thm (e e_1 : IntW 8) :
  LLVM.and (icmp IntPred.eq e_1 (const? 8 (-1))) (icmp IntPred.ule e e_1) ⊑
    icmp IntPred.eq e_1 (const? 8 (-1))

theorem bools2_logical_commute2_and1_thm.extracted_1._2 : ∀ (x x_1 : BitVec 1), x_1 &&& x = 1#1 → ¬x_1 = 1#1 → False

theorem logical_or_logical_or_icmps_comm3_thm.extracted_1._6 : ∀ (x x_1 x_2 : BitVec 8),
  ¬x_1 ≥ ↑8 →
    ¬(ofBool (x_2 &&& 1#8 <<< x_1 == 0#8) = 1#1 ∨ ofBool (x_2 &&& 1#8 == 0#8) = 1#1) →
      ¬(True ∧ 1#8 <<< x_1 >>> x_1 ≠ 1#8 ∨ x_1 ≥ ↑8 ∨ True ∧ 1#8 <<< x_1 >>> x_1 ≠ 1#8 ∨ x_1 ≥ ↑8) →
        ofBool (x_2 &&& (1#8 <<< x_1 ||| 1#8) != 1#8 <<< x_1 ||| 1#8) = 1#1 → ofBool (x == 42#8) = 1#1

theorem eq_nsw_rem_zero_thm (e : IntW 8) :
  icmp IntPred.eq (mul e (const? 8 (-5)) { «nsw» := true, «nuw» := false }) (const? 8 20) ⊑
    icmp IntPred.eq e (const? 8 (-4))

theorem t3_const_after_fold_lshr_shl_ne_thm.extracted_1._2 : ∀ (x x_1 x_2 : BitVec 32),
  ¬(32#32 - x_1 ≥ ↑32 ∨ x_1 + -1#32 ≥ ↑32) →
    ¬31#32 ≥ ↑32 →
      ofBool (x_2 >>> (32#32 - x_1) &&& x <<< (x_1 + -1#32) != 0#32) = ofBool (x_2 >>> 31#32 &&& x != 0#32)

theorem e_2100 :
    2 *  ~~~(d &&& ( ~~~e &&& f)) + 1 * (e ^^^ ( ~~~d ||| (e ^^^ f))) - 2 * (e ^^^  ~~~(d &&& (e ||| f))) - 1 *  ~~~(d |||  ~~~e) - 1 * (d &&& ( ~~~e ||| f)) - 5 *  ~~~(e |||  ~~~f) + 5 * ( ~~~d &&& (e ^^^ f)) + 3 * ((d &&&  ~~~e) ||| (d ^^^ (e ^^^ f))) - 2 * ( ~~~(d |||  ~~~e) |||  ~~~(e ^^^ f)) - 11 * ( ~~~(d |||  ~~~e) ||| (e ^^^ f)) + 7 * (e ||| (d &&& f)) - 2 *  ~~~(d ||| (e ^^^ f)) + 11 * (f ^^^  ~~~(d &&& ( ~~~e &&& f))) + 11 *  ~~~(d &&& ( ~~~e ||| f)) + 7 * (f ^^^  ~~~( ~~~d ||| ( ~~~e &&& f))) - 2 * ( ~~~(d &&&  ~~~e) &&& (e ^^^ f)) - 1 * (e &&&  ~~~f) + 1 * (d ||| (e ||| f)) - 3 * (d ^^^ (e ||| f)) - 6 * (e ^^^ (d &&& (e ||| f))) - 6 * (f ^^^  ~~~(d ||| (e &&& f))) - 1 * (f ^^^ (d &&&  ~~~e)) - 1 *  ~~~( ~~~d ||| (e &&& f)) + 1 *  ~~~( ~~~d &&& (e ||| f)) + 1 * ( ~~~d ||| (e ^^^ f)) + 2 * (d |||  ~~~f) + 5 * d - 3 * (f ^^^  ~~~(d &&& ( ~~~e ||| f))) - 3 *  ~~~(d ^^^ f) - 1 * (f &&& (d |||  ~~~e)) + 5 * ( ~~~f &&&  ~~~(d ^^^ e)) - 11 * ( ~~~d ||| ( ~~~e ||| f)) + 2 * (e |||  ~~~(d ||| f)) + 1 * (e &&&  ~~~(d &&& f)) + 11 * ((d |||  ~~~e) &&&  ~~~(d ^^^ (e ^^^ f))) + 4 * ((d &&& e) ^^^ (e ||| f)) + 5 *  ~~~( ~~~d &&& ( ~~~e ||| f)) - 18 *  ~~~(d ||| (e ||| f)) - 7 *  ~~~(d ||| ( ~~~e ||| f)) - 17 *  ~~~( ~~~d ||| (e ||| f)) - 54 *  ~~~( ~~~d ||| ( ~~~e ||| f)) + 6 * ( ~~~d &&& (e &&& f)) - 13 * (d &&& ( ~~~e &&& f)) =  - 1 * (d ||| (e ^^^ f)) - 1 * ((d ||| e) &&&  ~~~(d ^^^ (e ^^^ f)))

theorem and_logic_and_logic_or_8_proof : and_logic_and_logic_or_8_before ⊑ and_logic_and_logic_or_8_after

theorem scalar_i32_shl_and_negC_slt_proof : scalar_i32_shl_and_negC_slt_before ⊑ scalar_i32_shl_and_negC_slt_after

theorem logical_and_cond_reuse_proof : logical_and_cond_reuse_before ⊑ logical_and_cond_reuse_after

theorem ashr_ult_2_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬1#4 ≥ ↑4 → ofBool (x.sshiftRight' 1#4 <ᵤ 2#4) = ofBool (x <ᵤ 4#4)

theorem e_202 :
    3 *  ~~~(x &&& y) - 7 *  ~~~(x &&&  ~~~x) - 1 * (x |||  ~~~y) + 5 *  ~~~(x ||| y) + 1 * (x &&&  ~~~y) + 8 * (x &&& y) =  - 4 * (x ^^^ y)

theorem positive_sameconst_shlnuwnsw_ashrexact_thm (e : IntW 8) :
  shl (ashr e (const? 8 3) { «exact» := true }) (const? 8 3) { «nsw» := true, «nuw» := true } ⊑ e

theorem bitwise_and_logical_and_masked_icmp_allones_thm.extracted_1._4 : ∀ (x : BitVec 1) (x_1 : BitVec 32),
  ofBool (x_1 &&& 8#32 == 8#32) = 1#1 →
    ¬ofBool (x_1 &&& 15#32 == 15#32) = 1#1 → x &&& ofBool (x_1 &&& 7#32 == 7#32) = 0#1

theorem test9_thm.extracted_1._2 : ∀ (x : BitVec 77),
  ¬(True ∧ (x &&& 562949953421310#77 &&& 1#77 != 0) = true) →
    (x &&& 562949953421310#77) + 1#77 = x &&& 562949953421310#77 ||

theorem ult_rem_nz_proof : ult_rem_nz_before ⊑ ult_rem_nz_after

theorem e_649 :
     - 7 *  ~~~x + 1 * (x ^^^ y) + 1 *  ~~~(x &&&  ~~~y) + 3 *  ~~~(x ^^^ y) + 5 *  ~~~y + 7 * (x |||  ~~~y) - 8 *  ~~~(x ||| y) + 6 *  ~~~(x |||  ~~~y) - 12 * (x &&&  ~~~y) - 10 * (x &&& y) = 1 *  ~~~(x &&&  ~~~x)

theorem or_xor_commute3_proof : or_xor_commute3_before ⊑ or_xor_commute3_after

theorem ashrsgt_01_08_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬1#4 ≥ ↑4 → ofBool (BitVec.ofInt 4 (-8) <ₛ x.sshiftRight' 1#4) = 1#1

theorem lshrult_01_13_exact_proof : lshrult_01_13_exact_before ⊑ lshrult_01_13_exact_after

theorem mul_of_udiv_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬(True ∧ x.umod 12#8 ≠ 0 ∨ 12#8 = 0) → True ∧ x >>> 1#8 <<< 1#8 ≠ x ∨ 1#8 ≥ ↑8 → False

theorem add_mask_sign_commute_i32_proof : add_mask_sign_commute_i32_before ⊑ add_mask_sign_commute_i32_after

theorem test15i_thm (e : IntW 32) :
  select (icmp IntPred.ne (LLVM.and e (const? 32 2)) (const? 32 0)) (const? 32 577) (const? 32 1089) ⊑
    select (icmp IntPred.eq (LLVM.and e (const? 32 2)) (const? 32 0)) (const? 32 1089) (const? 32 577)

theorem test13_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬(x == 0 || 32 != 1 && x == intMin 32 && x == -1) = true → x.srem x = 0#32

theorem PR24873_proof : PR24873_before ⊑ PR24873_after

theorem fold_and_zext_icmp_thm (e e_1 e_2 : IntW 64) :
  LLVM.and (zext 8 (icmp IntPred.sgt e_2 e_1)) (zext 8 (icmp IntPred.slt e_2 e)) ⊑
    zext 8 (LLVM.and (icmp IntPred.sgt e_2 e_1) (icmp IntPred.slt e_2 e))

theorem rem_euclid_add_different_const_proof : rem_euclid_add_different_const_before ⊑ rem_euclid_add_different_const_after

theorem fold_sext_to_and_wrong3_proof : fold_sext_to_and_wrong3_before ⊑ fold_sext_to_and_wrong3_after

theorem lshr_pow2_sgt_proof : lshr_pow2_sgt_before ⊑ lshr_pow2_sgt_after

theorem icmp_ne_sext_ne_zero_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (signExtend 32 (ofBool (x != 0#32)) != x) = ofBool (x + -1#32 <ᵤ BitVec.ofInt 32 (-2))

theorem bv_Select_1105 :
    ∀ (e e_1 : LLVM.IntW w), LLVM.select (LLVM.const? 1 0) e_1 e ⊑ e

theorem t4_commutative_proof : t4_commutative_before ⊑ t4_commutative_after

theorem t3_singlebit_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬(32#32 - x ≥ ↑32 ∨ zeroExtend 64 (x + BitVec.ofInt 32 (-16)) ≥ ↑64) →
    ofBool (x_1 <<< (32#32 - x) &&& truncate 32 (65536#64 >>> zeroExtend 64 (x + BitVec.ofInt 32 (-16))) != 0#32) =
      ofBool (x_1 &&& 1#32 != 0#32)

theorem shl_add_lshr_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 32),
  ¬(True ∧ x_2 <<< x_1 >>> x_1 ≠ x_2 ∨ x_1 ≥ ↑32 ∨ True ∧ (x_2 <<< x_1).uaddOverflow x = true ∨ x_1 ≥ ↑32) →
    x_1 ≥ ↑32 ∨ True ∧ (x >>> x_1).uaddOverflow x_2 = true → False

theorem t0_thm.extracted_1._1 : ∀ (x : BitVec 16),
  ¬16#32 ≥ ↑32 →
    zeroExtend 32 x <<< 16#32 &&& BitVec.ofInt 32 (-2147483648) = signExtend 32 x &&& BitVec.ofInt 32 (-2147483648)

theorem test1_thm.extracted_1._1 : ∀ (x : BitVec 333), ¬70368744177664#333 = 0 → 46#333 ≥ ↑333 → False

theorem logical_and_implies_thm (e : IntW 32) :
  select (icmp IntPred.ne e (const? 32 0)) (icmp IntPred.ne e (const? 32 42)) (const? 1 0) ⊑
    LLVM.and (icmp IntPred.ne e (const? 32 0)) (icmp IntPred.ne e (const? 32 42))

theorem logical_and_not_thm (e e_1 : IntW 1) :
  select e_1 (const? 1 0) e ⊑ select (LLVM.xor e_1 (const? 1 1)) e (const? 1 0)

theorem bool2 (x y : Bool) (h : x = y) : y = x

theorem e_1225 :
     - 11 *  ~~~(z ^^^ t) + 11 *  ~~~(z &&& t) + 5 * (z |||  ~~~t) + 7 *  ~~~(z &&&  ~~~z) + 5 *  ~~~t - 18 *  ~~~(z ||| t) - 19 *  ~~~(z |||  ~~~t) - 26 * (z &&&  ~~~t) + 1 * (z &&& t) = 2 * z - 1 *  ~~~z

theorem ashr_ult_6_proof : ashr_ult_6_before ⊑ ashr_ult_6_after

theorem test_lshr_exact__exact_is_unsafe_thm.extracted_1._4 : ∀ (x : BitVec 64) (x_1 : BitVec 32),
  ¬ofBool (x_1 &&& 63#32 == 0#32) = 1#1 →
    ¬(True ∧ (x_1 &&& 63#32) >>> 2#32 <<< 2#32 ≠ x_1 &&& 63#32 ∨
          2#32 ≥ ↑32 ∨ zeroExtend 64 ((x_1 &&& 63#32) >>> 2#32) ≥ ↑64) →
      ¬(2#32 ≥ ↑32 ∨ True ∧ (x_1 >>> 2#32 &&& 15#32).msb = true ∨ zeroExtend 64 (x_1 >>> 2#32 &&& 15#32) ≥ ↑64) →
        x.sshiftRight' (zeroExtend 64 ((x_1 &&& 63#32) >>> 2#32)) =
          x.sshiftRight' (zeroExtend 64 (x_1 >>> 2#32 &&& 15#32))

theorem test92_thm.extracted_1._2 : ∀ (x : BitVec 64),
  ¬32#96 ≥ ↑96 → ¬32#64 ≥ ↑64 → truncate 64 (signExtend 96 x >>> 32#96) = x.sshiftRight' 32#64

theorem or_to_nxor4_thm (e e_1 : IntW 32) :
  LLVM.or (LLVM.xor (LLVM.or e_1 e) (const? 32 (-1))) (LLVM.and e e_1) ⊑
    LLVM.xor (LLVM.xor e e_1) (const? 32 (-1))

theorem PR38139_proof : PR38139_before ⊑ PR38139_after

theorem sgt_and_min_commute_logical_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ofBool (x_1 == BitVec.ofInt 8 (-128)) = 1#1 → ofBool (x <ₛ x_1) = 0#1

theorem test4_proof : test4_before ⊑ test4_after

theorem lshr_mul_times_5_div_4_exact_2_proof : lshr_mul_times_5_div_4_exact_2_before ⊑ lshr_mul_times_5_div_4_exact_2_after

theorem add_select_zext_thm.extracted_1._1 : ∀ (x : BitVec 1), x = 1#1 → 64#64 + zeroExtend 64 x = 65#64

theorem not_or_or_and_not_and_and_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 32),
  (x_2 ^^^ -1#32 ||| x_1 ||| x) &&& (x_1 &&& x_2 &&& x ^^^ -1#32) = x ^^^ x_1 ||

theorem exact_ashr_eq_noexactdiv_proof : exact_ashr_eq_noexactdiv_before ⊑ exact_ashr_eq_noexactdiv_after

theorem or_ne_notY_eq_1s_fail_bad_not_proof : or_ne_notY_eq_1s_fail_bad_not_before ⊑ or_ne_notY_eq_1s_fail_bad_not_after

theorem test_or3_logical_thm.extracted_1._2 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (x_1 &&& 2147483647#32 ≤ₛ x) = 1#1 → ofBool (x <ₛ 0#32) = ofBool (x_1 &&& 2147483647#32 ≤ᵤ x)

theorem PR38139_thm (e : IntW 8) :
  icmp IntPred.ne (LLVM.or e (const? 8 (-64))) e ⊑ icmp IntPred.ult e (const? 8 (-64))

theorem test6_thm (e e_1 : IntW 57) : sub e_1 (LLVM.and e_1 e) ⊑ LLVM.and e_1 (LLVM.xor e (const? 57 (-1)))

theorem ashr_mul_times_3_div_2_exact_2_thm (e : IntW 32) :
  ashr (mul e (const? 32 3) { «nsw» := true, «nuw» := false }) (const? 32 1) { «exact» := true } ⊑
    add e (ashr e (const? 32 1) { «exact» := true }) { «nsw» := true, «nuw» := false }

theorem e_1275 :
     - 3 *  ~~~(z &&&  ~~~z) + 2 * (z ^^^ t) - 7 *  ~~~t + 3 * z + 2 *  ~~~(z &&& t) + 7 *  ~~~(z &&&  ~~~t) + 1 *  ~~~(z ||| t) + 3 * (z &&&  ~~~t) - 5 * (z &&& t) = 2 * t + 6 *  ~~~(z |||  ~~~t)

theorem sub_from_constant_commute_proof : sub_from_constant_commute_before ⊑ sub_from_constant_commute_after

theorem zext_sext_add_icmp_slt_1_rhs_not_const_thm (e : IntW 8) (e_1 e_2 : IntW 1) :
  icmp IntPred.slt (add (zext 8 e_2) (sext 8 e_1)) e ⊑
    icmp IntPred.slt (add (zext 8 e_2) (sext 8 e_1) { «nsw» := true, «nuw» := false }) e

theorem t0_thm.extracted_1._8 : ∀ (x x_1 x_2 : BitVec 8) (x_3 : BitVec 1),
  ¬x_3 ^^^ 1#1 = 1#1 → ¬x_3 = 1#1 → 0#1 = 1#1 → ofBool (x_2 != x_1) = 1#1 → False

theorem lshrult_02_13_exact_proof : lshrult_02_13_exact_before ⊑ lshrult_02_13_exact_after

theorem test_add_nsw__nuw_is_safe_thm.extracted_1._3 : ∀ (x : BitVec 32),
  ¬ofBool (x &&& 2147483647#32 == 2147483647#32) = 1#1 →
    ¬(True ∧ (x &&& 2147483647#32).saddOverflow 1#32 = true) →
      True ∧ (x &&& 2147483647#32).uaddOverflow 1#32 = true → False

theorem sub_eq (a b : BitStream) : a.sub b = a - b

theorem e_515 :
     - 6 *  ~~~(x ^^^ y) + 2 * y + 2 * (x |||  ~~~y) + 3 * (x ^^^ y) + 2 *  ~~~y + 3 *  ~~~(x ||| y) - 4 *  ~~~(x |||  ~~~y) - 4 * (x &&&  ~~~y) + 5 * (x &&& y) = 2 * x + 1 *  ~~~(x &&&  ~~~x)

theorem rem_euclid_i128_thm (e : IntW 128) :
  select (icmp IntPred.slt (LLVM.srem e (const? 128 8)) (const? 128 0))
      (add (LLVM.srem e (const? 128 8)) (const? 128 8)) (LLVM.srem e (const? 128 8)) ⊑
    LLVM.and e (const? 128 7)

theorem mul_select_zext_thm.extracted_1._1 : ∀ (x : BitVec 1), ¬x = 1#1 → 1#64 * zeroExtend 64 x = 0#64

theorem t1_ult_slt_0_proof : t1_ult_slt_0_before ⊑ t1_ult_slt_0_after

theorem ashr_can_be_lshr_2_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬(34#64 ≥ ↑64 ∨
        True ∧
            (zeroExtend 64 x ||| 4278190080#64) <<< 34#64 >>> 32#64 <<< 32#64 ≠
              (zeroExtend 64 x ||| 4278190080#64) <<< 34#64 ∨
          32#64 ≥ ↑64 ∨
            True ∧
              signExtend 64 (truncate 32 (((zeroExtend 64 x ||| 4278190080#64) <<< 34#64).sshiftRight' 32#64)) ≠
                ((zeroExtend 64 x ||| 4278190080#64) <<< 34#64).sshiftRight' 32#64) →
    2#32 ≥ ↑32 → False

theorem eq_21_comm_eq2_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬(16#32 ≥ ↑32 ∨ 16#32 ≥ ↑32 ∨ 8#32 ≥ ↑32 ∨ 8#32 ≥ ↑32) → 8#32 ≥ ↑32 ∨ 8#32 ≥ ↑32 → False

theorem narrow_sext_sub_thm.extracted_1._1 : ∀ (x : BitVec 32) (x_1 : BitVec 16),
  truncate 16 (signExtend 32 x_1 - x) = x_1 - truncate 16 x

theorem test1_proof : test1_before ⊑ test1_after

theorem or_and_not_not_commute6_thm.extracted_1._2 : ∀ (x x_1 x_2 : BitVec 32),
  ¬((x_2 == 0 || 32 != 1 && 42#32 == intMin 32 && x_2 == -1) = true ∨
        (x_2 == 0 || 32 != 1 && 42#32 == intMin 32 && x_2 == -1) = true) →
    ¬(x_2 == 0 || 32 != 1 && 42#32 == intMin 32 && x_2 == -1) = true →
      (42#32).sdiv x_2 &&& ((x_1 ||| x) ^^^ -1#32) ||

theorem uge_umin1_proof : uge_umin1_before ⊑ uge_umin1_after

theorem select_or_disjoint_or_proof : select_or_disjoint_or_before ⊑ select_or_disjoint_or_after

theorem test91_thm (e : IntW 64) :
  trunc 64 (lshr (sext 96 e) (const? 96 48)) ⊑
    trunc 64 (lshr (sext 96 e) (const? 96 48)) { «nsw» := true, «nuw» := true }

theorem sgt_or_not_min_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ofBool (x <ₛ x_1) ||

theorem and_two_ranges_to_mask_and_range_proof : and_two_ranges_to_mask_and_range_before ⊑ and_two_ranges_to_mask_and_range_after

theorem select_ashr_thm.extracted_1._3 : ∀ (x x_1 : BitVec 128) (x_2 : BitVec 1), ¬x_2 = 1#1 → 0#128 ≥ ↑128 → False

theorem ashrsgt_02_05_exact_proof : ashrsgt_02_05_exact_before ⊑ ashrsgt_02_05_exact_after

theorem urem_common_dividend_defined_cond_proof : urem_common_dividend_defined_cond_before ⊑ urem_common_dividend_defined_cond_after

theorem lshr_and_and_thm (e e_1 : IntW 8) :
  shl (LLVM.and (LLVM.and (lshr e_1 (const? 8 2)) (const? 8 13)) (LLVM.srem e (const? 8 42))) (const? 8 2) ⊑
    LLVM.and (LLVM.and e_1 (const? 8 52)) (shl (LLVM.srem e (const? 8 42)) (const? 8 2))

theorem lshr_C1_add_A_C2_i32_thm (e : IntW 32) :
  shl (const? 32 6) (add (LLVM.and e (const? 32 65535)) (const? 32 5)) ⊑
    shl (const? 32 192) (LLVM.and e (const? 32 65535))

theorem nomask_rhs_proof : nomask_rhs_before ⊑ nomask_rhs_after

theorem lshrult_03_06_proof : lshrult_03_06_before ⊑ lshrult_03_06_after

theorem e_480 :
     - 1 *  ~~~(x &&&  ~~~x) + 1 *  ~~~(x &&& y) + 3 *  ~~~y + 1 * (x ^^^ y) + 1 * (x |||  ~~~y) - 2 *  ~~~(x &&&  ~~~y) - 2 *  ~~~(x ||| y) + 1 *  ~~~(x |||  ~~~y) - 5 * (x &&&  ~~~y) =  - 2 * (x &&& y)

theorem main4f_like_logical_thm.extracted_1._10 : ∀ (x x_1 x_2 : BitVec 32),
  ¬ofBool (x_2 &&& x_1 != x_1) = 1#1 →
    ofBool (x_2 &&& x_1 == x_1) = 1#1 →
      ¬ofBool (x_2 &&& x != x) = 1#1 → 1#32 = zeroExtend 32 (ofBool (x_2 &&& x == x))

theorem neg_signbit_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬7#8 ≥ ↑8 → 0#32 - zeroExtend 32 (x >>> 7#8) = signExtend 32 (x.sshiftRight' 7#8)

theorem ashr_ne_both_equal_thm (e : IntW 8) :
  icmp IntPred.ne (ashr (const? 8 (-128)) e) (const? 8 (-128)) ⊑ icmp IntPred.ne e (const? 8 0)

theorem ashrslt_01_14_proof : ashrslt_01_14_before ⊑ ashrslt_01_14_after

theorem l_thm (e e_1 e_2 : IntW 32) :
  add (add (sub (const? 32 0) e_2) (sub (const? 32 0) e_1)) e ⊑ sub e (add e_2 e_1)

theorem t4_proof : t4_before ⊑ t4_after

theorem lshrugt_03_02_exact_proof : lshrugt_03_02_exact_before ⊑ lshrugt_03_02_exact_after

theorem test5_apint_thm (e e_1 : IntW 71) :
  LLVM.xor (LLVM.or (LLVM.xor e_1 (const? 71 (-1))) (LLVM.xor e (const? 71 (-1)))) (const? 71 (-1)) ⊑
    LLVM.and e_1 e

theorem lshrugt_01_07_thm.extracted_1._1 : ∀ (x : BitVec 4), ¬1#4 ≥ ↑4 → ofBool (7#4 <ᵤ x >>> 1#4) = 0#1

theorem mul_of_sdiv_thm.extracted_1._2 : ∀ (x : BitVec 8),
  ¬(True ∧ x.smod 12#8 ≠ 0 ∨ (12#8 == 0 || 8 != 1 && x == intMin 8 && 12#8 == -1) = true) →
    ¬(True ∧ x >>> 1#8 <<< 1#8 ≠ x ∨ 1#8 ≥ ↑8 ∨ True ∧ (0#8).ssubOverflow (x.sshiftRight' 1#8) = true) →
      x.sdiv 12#8 * BitVec.ofInt 8 (-6) = 0#8 - x.sshiftRight' 1#8

theorem bv_AndOrXor_1288_A__B__B__C__A___A__B__C :
    ∀ (e e_1 e_2 : LLVM.IntW w),
      LLVM.and (LLVM.xor e e_2) (LLVM.xor (LLVM.xor e_2 e_1) e) ⊑
        LLVM.and (LLVM.xor e e_2) (LLVM.xor e_1 (LLVM.const? w (-1)))

theorem ashrslt_03_10_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬3#4 ≥ ↑4 → ofBool (x.sshiftRight' 3#4 <ₛ BitVec.ofInt 4 (-6)) = 0#1

theorem shl_or_thm.extracted_1._2 : ∀ (x x_1 : BitVec 16),
  ¬((42#16 == 0 || 16 != 1 && x_1 == intMin 16 && 42#16 == -1) = true ∨ 5#16 ≥ ↑16 ∨ 7#16 ≥ ↑16) →
    ¬(12#16 ≥ ↑16 ∨
          (42#16 == 0 || 16 != 1 && x_1 == intMin 16 && 42#16 == -1) = true ∨
            True ∧ (x_1.srem 42#16 <<< 7#16).sshiftRight' 7#16 ≠ x_1.srem 42#16 ∨ 7#16 ≥ ↑16) →
      (x_1.srem 42#16 ||| x <<< 5#16) <<< 7#16 = x <<< 12#16 ||

theorem lshrult_01_01_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬1#4 ≥ ↑4 → ofBool (x >>> 1#4 <ᵤ 1#4) = ofBool (x <ᵤ 2#4)

theorem trunc_nuw_xor_thm (e e_1 : IntW 8) :
  trunc 1 (LLVM.xor e_1 e) { «nsw» := false, «nuw» := true } ⊑ icmp IntPred.ne e_1 e

theorem n6_thm.extracted_1._3 : ∀ (x : BitVec 32),
  ¬ofBool (x &&& 1#32 != 0#32) = 1#1 → ¬ofBool (x &&& 1#32 == 0#32) = 1#1 → ¬2#32 ≥ ↑32 → 1#32 = x >>> 2#32 &&& 1#32

theorem demorgan_nor_thm (e e_1 : IntW 8) :
  LLVM.xor (LLVM.or (LLVM.xor e_1 (const? 8 (-1))) e) (const? 8 (-1)) ⊑
    LLVM.and e_1 (LLVM.xor e (const? 8 (-1)))

theorem e_33 :
     - 1 * (x ||| y) - 1 *  ~~~(x &&& y) + 1 *  ~~~(x ||| y) + 1 * (x &&&  ~~~y) + 1 * (x &&& y) =  - 1 * (x ^^^ y) - 1 *  ~~~(x |||  ~~~y)

theorem positive_biggerlshr_thm.extracted_1._2 : ∀ (x : BitVec 8),
  ¬(6#8 ≥ ↑8 ∨ 3#8 ≥ ↑8) → ¬3#8 ≥ ↑8 → x >>> 6#8 <<< 3#8 = x >>> 3#8 &&& 24#8

theorem test46_thm (e e_1 : IntW 32) :
  LLVM.and e_1 (LLVM.or (LLVM.xor e_1 (const? 32 (-1))) e) ⊑ LLVM.and e_1 e

theorem and_add_bool_to_select_thm.extracted_1._1 : ∀ (x : BitVec 32) (x_1 : BitVec 1),
  x_1 = 1#1 → -1#32 + zeroExtend 32 x_1 &&& x = 0#32

theorem lshrult_03_02_exact_thm (e : IntW 4) :
  icmp IntPred.ult (lshr e (const? 4 3) { «exact» := true }) (const? 4 2) ⊑ const? 1 1

theorem ashr_ult_exact_near_pow2_cmpval_thm (e : IntW 8) :
  icmp IntPred.ult (ashr e (const? 8 1) { «exact» := true }) (const? 8 5) ⊑
    icmp IntPred.ult e (const? 8 9)

theorem test_shl_nsw__nsw_is_safe_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ofBool (x ||| BitVec.ofInt 32 (-83886080) == BitVec.ofInt 32 (-83886079)) = 1#1 →
    ¬(True ∧ ((x ||| BitVec.ofInt 32 (-83886080)) <<< 2#32).sshiftRight' 2#32 ≠ x ||| BitVec.ofInt 32 (-83886080) ∨
          2#32 ≥ ↑32) →
      ¬(True ∧ ((x ||| BitVec.ofInt 32 (-83886080)) <<< 2#32).sshiftRight' 2#32 ≠ x ||| BitVec.ofInt 32 (-83886080) ∨
            2#32 ≥ ↑32 ∨
              True ∧
                  ((x ||| BitVec.ofInt 32 (-83886080)) <<< 2#32).sshiftRight' 2#32 ≠ x ||| BitVec.ofInt 32 (-83886080) ∨
                2#32 ≥ ↑32) →
        BitVec.ofInt 32 (-335544316) * (x ||| BitVec.ofInt 32 (-83886080)) *
            (x ||| BitVec.ofInt 32 (-83886080)) <<< 2#32 =
          (x ||| BitVec.ofInt 32 (-83886080)) <<< 2#32 * (x ||| BitVec.ofInt 32 (-83886080)) *
            (x ||| BitVec.ofInt 32 (-83886080)) <<< 2#32

theorem PR60818_ne_proof : PR60818_ne_before ⊑ PR60818_ne_after

theorem ashrsgt_02_07_exact_thm (e : IntW 4) :
  icmp IntPred.sgt (ashr e (const? 4 2) { «exact» := true }) (const? 4 7) ⊑ const? 1 0

theorem neg_nsw_sgt_n1_proof : neg_nsw_sgt_n1_before ⊑ neg_nsw_sgt_n1_after

theorem sgt_smax2_proof : sgt_smax2_before ⊑ sgt_smax2_after

theorem ne_nsw_rem_nz_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬(True ∧ x.smulOverflow 5#8 = true) → ofBool (x * 5#8 != BitVec.ofInt 8 (-126)) = 1#1

theorem main7d_logical_thm.extracted_1._6 : ∀ (x x_1 x_2 x_3 : BitVec 32),
  ¬ofBool (x_3 &&& (x_2 &&& x_1) == x_2 &&& x_1) = 1#1 →
    ofBool (x_3 &&& (x_2 &&& x_1) != x_2 &&& x_1) = 1#1 → ¬0#1 = 1#1 → 1#32 = zeroExtend 32 1#1

theorem masked_icmps_mask_notallzeros_bmask_mixed_negated_0_logical_proof : masked_icmps_mask_notallzeros_bmask_mixed_negated_0_logical_before ⊑ masked_icmps_mask_notallzeros_bmask_mixed_negated_0_logical_after

theorem sle_smax4_proof : sle_smax4_before ⊑ sle_smax4_after

theorem test26_proof : test26_before ⊑ test26_after

theorem test15_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬1#32 ≥ ↑32 →
    ¬(1#32 ≥ ↑32 ∨ True ∧ (8#32).ssubOverflow (x.sshiftRight' 1#32) = true) →
      8#64 - signExtend 64 (x.sshiftRight' 1#32) = signExtend 64 (8#32 - x.sshiftRight' 1#32)

theorem test18 (x y : BitVec w) : (x &&&  (~~~ y)) = ((x ||| y) - y)

theorem eq_umax4_proof : eq_umax4_before ⊑ eq_umax4_after

omit [Fintype S] [DecidableEq S] [LawfulBEq A] in
theorem processOneElem_grow (st : worklist.St A S) (final : S → Bool) (a : A) (sa' : S) (s : State) :
      let st' := processOneElem _ _ final s st (a, sa')
      ∃ sas, List.Perm st'.map.keys (sas ++ st.map.keys) ∧ st'.worklist.toList = st.worklist.toList ++ sas

theorem test_add__nsw_is_safe_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x ||| BitVec.ofInt 32 (-2147483648) == -1#32) = 1#1 →
    True ∧ (x ||| BitVec.ofInt 32 (-2147483648)).saddOverflow 1#32 = true → False

theorem bor_lor_right2_thm (e e_1 : IntW 1) : select e_1 (const? 1 1) (LLVM.or e e_1) ⊑ select e_1 (const? 1 1) e

theorem sle_swap_or_not_min_commute_logical_proof : sle_swap_or_not_min_commute_logical_before ⊑ sle_swap_or_not_min_commute_logical_after

theorem trunc_shl_nsw_31_i32_i64_thm (e : IntW 64) :
  trunc 32 (shl e (const? 64 31) { «nsw» := true, «nuw» := false }) ⊑ shl (trunc 32 e) (const? 32 31)

theorem trunc_equality_both_thm.extracted_1._1 : ∀ (x x_1 : BitVec 16),
  ¬(True ∧ signExtend 16 (truncate 8 x_1) ≠ x_1 ∨
        True ∧ zeroExtend 16 (truncate 8 x_1) ≠ x_1 ∨
          True ∧ signExtend 16 (truncate 8 x) ≠ x ∨ True ∧ zeroExtend 16 (truncate 8 x) ≠ x) →
    ofBool (truncate 8 x_1 == truncate 8 x) = ofBool (x_1 == x)

theorem ashr_lshr_shift_base_mismatch_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ofBool (0#32 ≤ₛ x_1) = 1#1 → ¬x ≥ ↑32 → ofBool (x_1 <ₛ 0#32) = 1#1 ∨ x ≥ ↑32 → False

theorem test_mul_nuw_nsw__nuw_is_safe_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ofBool (x &&& 268435457#32 == 268435456#32) = 1#1 →
    ¬(True ∧ (x &&& 268435457#32).umulOverflow 9#32 = true) →
      BitVec.ofInt 32 (-1879048192) = (x &&& 268435457#32) * 9#32

theorem e_624 :
    7 *  ~~~(x ^^^ y) + 2 * (x ||| y) - 2 * (x |||  ~~~y) - 11 * (x ^^^ y) - 11 *  ~~~x + 2 *  ~~~(x &&&  ~~~y) + 5 *  ~~~(x ||| y) + 25 *  ~~~(x |||  ~~~y) + 12 * (x &&&  ~~~y) - 2 * (x &&& y) = 1 *  ~~~(x &&&  ~~~x) + 6 * y

theorem masked_icmps_mask_notallzeros_bmask_mixed_negated_swapped_4_thm (e : IntW 32) :
  LLVM.or (icmp IntPred.ne (LLVM.and e (const? 32 15)) (const? 32 8))
      (icmp IntPred.eq (LLVM.and e (const? 32 255)) (const? 32 0)) ⊑
    icmp IntPred.ne (LLVM.and e (const? 32 15)) (const? 32 8)

theorem e_2361 :
     - 7 * (d ||| ( ~~~e &&& f)) + 1 * ((e &&&  ~~~f) ^^^ ( ~~~d ||| (e ^^^ f))) - 1 * ( ~~~d &&& (e ||| f)) - 2 * ((d |||  ~~~e) &&& (d ^^^ (e ^^^ f))) + 7 * (f ^^^ ( ~~~d ||| ( ~~~e &&& f))) + 2 * ((d &&& e) ^^^ (e ||| f)) - 3 * (e |||  ~~~f) + 11 * (f ^^^  ~~~(d &&& ( ~~~e &&& f))) - 2 * (f &&&  ~~~(d &&&  ~~~e)) + 5 * ( ~~~d &&& (e ^^^ f)) - 2 * ((d &&& f) ^^^ (d ^^^ ( ~~~e &&& f))) + 1 *  ~~~( ~~~d ||| (e &&& f)) - 3 * (e &&& f) + 7 * (e ^^^  ~~~(d ||| ( ~~~e &&& f))) + 4 * (e ||| (d &&& f)) - 7 * ( ~~~(d &&& e) &&& (d ^^^ (e ^^^ f))) + 11 * (f &&& (d ||| e)) + 3 *  ~~~e - 6 * ((d &&& e) ||| (e ^^^ f)) - 6 *  ~~~( ~~~d &&& ( ~~~e ||| f)) + 2 * (e ^^^ ( ~~~d &&& (e ^^^ f))) + 2 * (f &&&  ~~~(d &&& e)) - 11 * ((d &&& e) ^^^  ~~~(d ^^^ (e &&& f))) - 1 *  ~~~(e &&& f) - 1 * (f ^^^  ~~~( ~~~d &&& ( ~~~e ||| f))) + 2 * (e ^^^  ~~~( ~~~d &&& (e &&& f))) + 1 * (e ^^^  ~~~(d &&& f)) - 5 * (e ^^^ (d ||| (e ^^^ f))) + 1 * (f ^^^  ~~~( ~~~d &&& (e &&& f))) + 1 * ( ~~~d ||| (e &&& f)) + 11 * ( ~~~d &&& ( ~~~e ||| f)) + 4 * ( ~~~(d |||  ~~~e) ||| (e ^^^ f)) + 4 * (f ^^^ (d ||| (e &&& f))) - 6 *  ~~~(d &&& e) + 3 * (e ^^^ (d &&& (e ^^^ f))) - 2 *  ~~~(d ^^^ (e &&& f)) + 11 * ((d &&& f) |||  ~~~(e ||| f)) - 7 * (d |||  ~~~f) - 2 * ( ~~~(d ||| e) ||| (d ^^^ (e ^^^ f))) - 6 * ( ~~~f &&& (d ^^^ e)) - 2 * (f ^^^ (d &&& (e ||| f))) + 1 * (e &&&  ~~~(d ^^^ f)) + 1 * (e &&&  ~~~(d &&& f)) - 3 * ((d &&& f) ^^^  ~~~(d ^^^ (e &&& f))) - 2 * (e ||| (d ^^^ f)) + 11 * ( ~~~e &&& (d ^^^ f)) - 2 * ( ~~~e ||| (d ^^^ f)) - 1 * ((d &&& f) ^^^ (d ^^^ (e &&& f))) - 11 * (e ||| f) - 1 * (e ^^^  ~~~( ~~~d ||| ( ~~~e &&& f))) + 1 *  ~~~( ~~~d &&& ( ~~~e &&& f)) + 1 * ((d &&& f) ||| (e &&&  ~~~f)) - 1 * ((e &&& f) ^^^  ~~~( ~~~d &&& (e ^^^ f))) + 2 * ((d ||| e) &&& (d ^^^ (e ^^^ f))) - 1 * (f &&& (d |||  ~~~e)) - 1 * (e ^^^  ~~~(d ||| (e &&& f))) + 1 * ( ~~~(d ^^^ e) &&&  ~~~(d ^^^ f)) + 11 *  ~~~(e ||| f) - 6 * (e ^^^  ~~~( ~~~d &&& (e ^^^ f))) - 7 *  ~~~(e ^^^ f) - 17 *  ~~~(d ||| (e ||| f)) + 38 *  ~~~(d ||| ( ~~~e ||| f)) + 16 *  ~~~( ~~~d ||| (e ||| f)) + 27 *  ~~~( ~~~d ||| ( ~~~e ||| f)) + 28 * ( ~~~d &&& ( ~~~e &&& f)) - 3 * ( ~~~d &&& (e &&& f)) + 2 * (d &&& ( ~~~e &&& f)) + 10 * (d &&& (e &&& f)) =  - 5 * (f &&& (d ^^^ e))

theorem e_443 :
    7 * y - 11 * (x |||  ~~~y) + 2 *  ~~~(x ^^^ y) - 7 *  ~~~y + 2 * (x ||| y) + 11 *  ~~~x + 5 *  ~~~(x ||| y) - 20 *  ~~~(x |||  ~~~y) =  - 16 * (x &&&  ~~~y)

theorem lshr_pow2_sgt_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬x ≥ ↑8 → True ∧ BitVec.ofInt 8 (-128) >>> x <<< x ≠ BitVec.ofInt 8 (-128) ∨ x ≥ ↑8 → False

theorem or_xor_tree_1111_proof : or_xor_tree_1111_before ⊑ or_xor_tree_1111_after

theorem shift_mul:
    [llvm(w)| {
  ^bb0(%X : _, %Y : _):
    %c1 = llvm.mlir.constant(1)
    %poty = llvm.shl %c1, %Y
    %r = llvm.mul %poty, %X
    llvm.return %r
  }] ⊑  [llvm(w)| {
  ^bb0(%X : _, %Y : _):
    %r = llvm.shl %X, %Y
    llvm.return %r
  }]

theorem test_zext4_proof : test_zext4_before ⊑ test_zext4_after

@[simp]
theorem castLe_mk_eq_mk {α : Type _} {n m : Nat} (i : Fin n) (h : n ≤ m) (x : α) :
    (Inputs.mk i x).castLe h = Inputs.mk (i.castLE (by omega)) x

theorem add_nuw_or_and_proof : add_nuw_or_and_before ⊑ add_nuw_or_and_after

theorem not_and_and_or_not_or_or_commute1_and_proof : not_and_and_or_not_or_or_commute1_and_before ⊑ not_and_and_or_not_or_or_commute1_and_after
</all_available_lemmas>

<local_ctx>
import Mathlib.Data.Fintype.Card

import Mathlib.Data.Fintype.Sum

import Mathlib.Data.Fintype.Sigma

import Mathlib.Data.Fintype.BigOperators

import Mathlib.Tactic.Zify

import Mathlib.Tactic.Ring

import Blase.Fast.Defs

import Blase.Fast.BitStream

open Term
</local_ctx>

<target_theorem>
lemma Predicate.evalFin_eq_eval (p : Predicate)
   (varsList : List BitStream) (varsFin : Fin p.arity → BitStream)
   (hvars : ∀ (i : Fin p.arity), varsList.getD i default = (varsFin i)) :
    Predicate.evalFin p varsFin  = Predicate.eval p varsList :=
</target_theorem>

