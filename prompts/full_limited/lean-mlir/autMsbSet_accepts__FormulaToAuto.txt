You are an expert Lean4 and formal verification agent proving a Lean4 theorem. Your output **must** strictly adhere to the specified format.

### Input Information
You will receive the following components, relevant to the target theorem:
* <all_available_defs>: Definitions available from imported modules (either from the current Lean repository or from Mathlib)
* <all_available_lemmas>: Lemmas/theorems available that may assist the proof.
* <local_ctx>...</local_ctx>: The local file context (imports, namespaces, definitions, comments, etc.) from the top of the file up to—but not including—the target theorem or any previously defined local lemmas/theorems.
* <target_theorem>...</target_theorem>: The target theorem statement, ending with `:=`.

**Notes**
1. Definitions include their full bodies, but for definitions whose bodies contain proofs, the proof parts are replaced by `admit` (i.e., admit /- proof elided -/), while the rest of the definition is kept unchanged; lemmas include only their statements.
2. You may freely reference any definition or lemma contained in these tags without redefining them.
3. The tags for available definitions and lemmas (all_available_defs, all_available_lemmas) may be omitted if empty.

### Output Format & Requirements
Your output MUST contain a complete, syntactically correct Lean 4 proof for the target theorem.

**Strict Output Structure:**
<reasoning> 
...
</reasoning> 

<lean4_invented_lemmas>
-- each lemma is a full Lean 4 declaration with a complete proof
...
</lean4_invented_lemmas>

<lean4_proof>
-- Lean 4 proof body of the target theorem
...
</lean4_proof>

**Requirements:**
1. <reasoning> and <lean4_invented_lemmas> are OPTIONAL. Include them only if they aid proof construction.
2. <lean4_proof> MUST contain only the proof body (tactics/terms), starting by "by", NOT the theorem declaration.
3. <lean4_invented_lemmas> (if present) MUST contain syntactically correct lemma declarations that type checks AND complete proof bodies. Defining a lemma using `axiom` is NOT allowed.
4. <reasoning> contains high-level proof planning.
5. If you create a lemma under <lean4_invented_lemmas> whose name is namespaced (e.g., X.Y.Z), you MUST always refer to it using its fully qualified name. Do NOT rely on shortened names. For example, write rw [X.Y.Z], not rw [Z] for invented lemmas.
6. All Lean 4 code MUST be syntactically correct. No `sorry`, `admit`, or non-Lean text. Comments allowed using `--` or `/- ... -/`.
7. Follow the tags and structure EXACTLY. No extra text before, between, or after the sections.
8. Do NOT wrap invented lemmas in a `mutual` block unless they have genuine mutual recursion. Declare each lemma independently.

### Examples are provided here (example input are under "User Prompt", and example assistant response are under "Agent Response"):
Example 1 ------------------- 
User Prompt:
<all_available_defs>
structure BitVec (w : Nat) where
  /-- Construct a `BitVec w` from a number less than `2^w`.
  O(1), because we use `Fin` as the internal representation of a bitvector. -/
  ofFin ::

  /-- Interpret a bitvector as a number less than `2^w`.
  O(1), because we use `Fin` as the internal representation of a bitvector. -/
  toFin : Fin (hPow 2 w)
</all_available_defs>

<all_available_lemmas>
theorem List.getElem_append_left{α : Type u_1} {l₁ l₂ : List α} {i : Nat} (hn : i < l₁.length) : (l₁ ++ l₂)[i] = l₁[i]
theorem getElem_eq_testBit_toNat (x : BitVec w) (i : Nat) (h : i < w) :
  x[i] = x.toNat.testBit i := rfl
@[simp, grind =] theorem toNat_cons (b : Bool) (x : BitVec w) :
    (cons b x).toNat = (b.toNat <<< w) ||| x.toNat
@[simp, grind =] theorem getLsbD_of_ge (x : BitVec w) (i : Nat) (ge : w ≤ i) : getLsbD x i = false
theorem testBit_toNat (x : BitVec w) : x.toNat.testBit i = x.getLsbD i
</all_available_lemmas>

<local_ctx>
import Mathlib.Computability.NFA
import Mathlib.Data.FinEnum
import Mathlib.Data.Rel
import Mathlib.Data.Vector.Basic
import Blase.AutoStructs.ForLean

open Set
open Mathlib
open SetRel

-- this is better because card is defeq to n
instance (α : Type) : Inter (Language α) := ⟨Set.inter⟩
instance (α : Type) : Union (Language α) := ⟨Set.union⟩

/--
The set of `n`-tuples of bit vectors of an arbitrary width.
-/
structure BitVecs (n : Nat) where
  w : Nat
  bvs : List.Vector (BitVec w) n

def BitVecs.cast (bvs : BitVecs n) (h : n = n') : BitVecs n' :=
  { w := bvs.w, bvs := h ▸ bvs.bvs }

abbrev BitVecs.empty : BitVecs n := ⟨0, List.Vector.replicate n .nil⟩
abbrev BitVecs.singleton {w : Nat} (bv : BitVec w) : BitVecs 1 := ⟨w, bv ::ᵥ .nil⟩
abbrev BitVecs.pair {w : Nat} (bv1 bv2 : BitVec w) : BitVecs 2 := ⟨w, bv1 ::ᵥ bv2 ::ᵥ .nil⟩

/--
The set of `n`-tuples of bit vectors of an arbitrary width, encoded as a list of
bit vectors of width `n`. The width of the encoded bit vectors is the length of
the list.
-/
abbrev BitVecs' (n : Nat) := List (BitVec n)

@[simps]
def dec (bvs' : BitVecs' n) : BitVecs n where
  w := bvs'.length
  bvs := List.Vector.ofFn fun k => BitVec.ofFn fun i => bvs'[i].getLsbD k

@[simp]
</local_ctx>

<target_theorem>
lemma dec_snoc n (bvs' : BitVecs' n) (a : BitVec n) :
  dec (bvs' ++ [a]) =
    { w := bvs'.length + 1
      bvs := List.Vector.ofFn fun k =>
        BitVec.cons (a.getLsbD k) ((dec bvs').bvs.get k) } :=
</target_theorem>

Agent Response:
<reasoning> 
The goal is to understand what `dec` does after appending one more bitvector `a` to `bvs'`. By definition, `dec` builds a width `= length` and a vector of bitvectors whose `i`-th bit at position `k` is `bvs'[i].getLsbD k`. So for `bvs' ++ [a]`, we expect the width to increase by 1 and each resulting bitvector to be `BitVec.cons` of the new bit coming from `a`.

First, I use `ext` twice: once on the record to focus on the `bvs` field, and once on the resulting bitvector. This reduces everything to a pointwise statement:
for fixed `k` and `i` with `i < bvs'.length + 1`,
the bit `(bvs' ++ [a])[i].getLsbD k` should match the bit at index `i` of `BitVec.cons (a.getLsbD k) ((dec bvs').bvs.get k)`.

At this point I need a clean description of indexing into `BitVec.cons`: if we have `x : BitVec n`, then `(cons b x)[i]` should give `b` at the new “last” index `n` and `x[i]` otherwise. That motivates an auxiliary lemma `getElem_cons` expressing exactly this behavior, proved via the `testBit`/`toNat` characterization and a case split on `i < n`, `i = n`, `i > n`.

Using `getElem_cons`, the RHS becomes an `if` on whether `i = bvs'.length`. So I split into cases:
- If `i = bvs'.length`, then `(bvs' ++ [a])[i]` is the appended `a`, so both sides reduce to `a.getLsbD k`.
- If `i ≠ bvs'.length`, the bound `i < bvs'.length + 1` forces `i < bvs'.length`. Then `(bvs' ++ [a])[i] = bvs'[i]` by `List.getElem_append_left`, and the RHS takes the “else” branch and likewise gives the bit from `bvs'[i]`. In both subcases, `simp` (plus the definition of `dec`) finishes.

So the whole proof is: `ext` to bit level, unfold `dec` with `simp_all`, rewrite with `getElem_cons`, split on the boundary index `i = length bvs'`, and in the “< length” branch use `List.getElem_append_left` and bounds to line up both sides.
</reasoning> 

<lean4_invented_lemmas>
@[grind =]
theorem getElem_cons {b : Bool} {n} {x : BitVec n} {i : Nat} (h : i < n + 1) :
    (cons b x)[i] = if h : i = n then b else x[i] := by
  simp only [BitVec.getElem_eq_testBit_toNat, BitVec.toNat_cons, Nat.testBit_or]
  rw [Nat.testBit_shiftLeft]
  rcases Nat.lt_trichotomy i n with i_lt_n | i_eq_n | n_lt_i
  · have p1 : ¬(n ≤ i) := by omega
    have p2 : i ≠ n := by omega
    simp [p1, p2]
  · simp only [i_eq_n, ge_iff_le, Nat.le_refl, decide_true, Nat.sub_self, Nat.testBit_zero,
    Bool.true_and, BitVec.testBit_toNat, BitVec.getLsbD_of_ge, Bool.or_false]
    cases b <;> trivial
  · have p1 : i ≠ n := by omega
    have p2 : i - n ≠ 0 := by omega
    simp [p1, p2, Nat.testBit_bool_toNat]
</lean4_invented_lemmas>

<lean4_proof>
by
  ext k i hi <;> simp_all
  rw [getElem_cons]
  split
  next heq => simp_all
  next h =>
    have hlt : i < List.length bvs' := by simp at hi; omega
    rw [List.getElem_append_left hlt]
    simp
</lean4_proof>

### Your task:
<all_available_defs>
Polynomial.X in Mathlib.Algebra.Polynomial.Basic
ZMod in Mathlib.Data.ZMod.Defs
NFA in Mathlib.Computability.NFA
DecidableEq in Init.Prelude
Fintype in Mathlib.Data.Fintype.Defs
BitVec in Init.Prelude
List in Init.Prelude
NFA.accept in Mathlib.Computability.NFA
NFA.start in Mathlib.Computability.NFA
NFA.step in Mathlib.Computability.NFA
Language in Mathlib.Computability.Language
FinEnum in Mathlib.Data.FinEnum
BitVec.ofFin in Init.Prelude
List.reverseRecOn in Mathlib.Data.List.Induction
NFA.stepSet in Mathlib.Computability.NFA
Nat in Init.Prelude
List.Vector in Mathlib.Data.Vector.Defs
Set in Mathlib.Data.Set.Defs
Bool in Init.Prelude
Fin in Init.Prelude
BitVec.iunfoldr in Init.Data.BitVec.Folds
List.finRange in Init.Data.List.FinRange
List.Vector.ofFn in Mathlib.Data.Vector.Defs
BitVec.cons in Init.Data.BitVec.Basic
List.Vector.replicate in Mathlib.Data.Vector.Defs
Function.RightInverse in Init.Data.Function

noncomputable def f : (ZMod q)[X] := X^(2^n) + 1

instance instFinEnumBV : FinEnum (BitVec w) where
  card := 2^w
  equiv := {
    toFun := fun x => x.toFin
    invFun := fun x => BitVec.ofFin x
    left_inv := by admit /- proof elided -/

@[simp]
def langMsb : Set (BitVecs 1) := { bvs | bvs.bvs.get 0 |>.msb }

structure BitVecs (n : Nat) where
  w : Nat
  bvs : List.Vector (BitVec w) n

def head (x : BitStream) : Bool      := x 0

def BitStream : Type := Nat → Bool

def enc (bvs : BitVecs n) : BitVecs' n :=
  (List.finRange bvs.w).map (fun i =>
    BitVec.ofFn (fun (k : Fin n) => (bvs.bvs.get k)[i]))

abbrev BitVecs' (n : Nat) := List (BitVec n)

def BitVec.ofFn {w : Nat} (f : Fin w → Bool) : BitVec w :=
  BitVec.iunfoldr (fun i _ => ((), f i)) () |>.2

@[simps]
def dec (bvs' : BitVecs' n) : BitVecs n where
  w := bvs'.length
  bvs := List.Vector.ofFn fun k => BitVec.ofFn fun i => bvs'[i].getLsbD k

def accepts (M : NFA' n) : Set (BitVecs n) := dec '' M.accepts'

structure NFA' (n : Nat) where
  σ : Type
  M : NFA (BitVec n) σ

def accepts' (M : NFA' n) : Set (BitVecs' n) := M.M.accepts

@[simp_denote]
def add_riscv_i32 :=
  [LV| {
    ^entry (%arg0: i32, %arg1: i32):
    %a = "builtin.unrealized_conversion_cast" (%arg0) : (i32) -> (!i64)
    %b = "builtin.unrealized_conversion_cast" (%arg1) : (i32) -> (!i64)
    %0 = addw %a, %b : !i64
    %1 = "builtin.unrealized_conversion_cast" (%0) : (!i64) -> (i32)
    llvm.return %1 : i32
  }]

def slt_zero_slt_i1_fail_before := [llvm|
{
^0(%arg4 : i32, %arg5 : i1):
  %0 = llvm.mlir.constant(31 : i32) : i32
  %1 = llvm.zext %arg5 : i1 to i32
  %2 = llvm.lshr %arg4, %0 : i32
  %3 = llvm.icmp "slt" %1, %2 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def no_shift_xor_multiuse_or_before := [llvm|
{
^0(%arg134 : i32, %arg135 : i32):
  %0 = llvm.mlir.constant(4096 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.and %arg134, %0 : i32
  %3 = llvm.icmp "ne" %1, %2 : i32
  %4 = llvm.or %arg135, %0 : i32
  %5 = "llvm.select"(%3, %arg135, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %6 = llvm.mul %5, %4 : i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def ult_to_sgt_before := [llvm|
{
^0(%arg24 : i8, %arg25 : i8):
  %0 = llvm.mlir.constant(127 : i8) : i8
  %1 = llvm.xor %arg24, %0 : i8
  %2 = llvm.xor %arg25, %0 : i8
  %3 = llvm.icmp "ult" %1, %2 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def freeze_match : List (Σ Γ, Σ ty, PeepholeRewrite LLVMPlusRiscV Γ ty) := [
  mkRewrite (LLVMToRiscvPeepholeRewriteRefine.toPeepholeUNSOUND llvm_freeze_lower_riscv_8),
  mkRewrite (LLVMToRiscvPeepholeRewriteRefine.toPeepholeUNSOUND llvm_freeze_lower_riscv_16),
  mkRewrite (LLVMToRiscvPeepholeRewriteRefine.toPeepholeUNSOUND llvm_freeze_lower_riscv_32),
  mkRewrite (LLVMToRiscvPeepholeRewriteRefine.toPeepholeUNSOUND llvm_freeze_lower_riscv_64)
]

def test13_after := [llvm|
{
^0(%arg10 : i79):
  %0 = llvm.mlir.constant(78 : i79) : i79
  %1 = llvm.ashr %arg10, %0 : i79
  "llvm.return"(%1) : (i79) -> ()
}
]

def and_xor_or5_after := [llvm|
{
^0(%arg661 : i64, %arg662 : i64, %arg663 : i64):
  %0 = llvm.mlir.constant(42) : i64
  %1 = llvm.udiv %0, %arg662 : i64
  %2 = llvm.udiv %0, %arg663 : i64
  %3 = llvm.or %1, %2 : i64
  "llvm.return"(%3) : (i64) -> ()
}
]

def t0_commutative_after := [llvm|
{
^0(%arg36 : i1, %arg37 : i8, %arg38 : i8, %arg39 : i8, %arg40 : i8):
  %0 = llvm.mlir.constant(false) : i1
  %1 = llvm.icmp "ne" %arg37, %arg38 : i8
  %2 = "llvm.select"(%1, %arg36, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %3 = "llvm.select"(%2, %arg40, %arg39) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%3) : (i8) -> ()
}
]

private def pretty_test_overflow :=
  [llvm()|{
  ^bb0(%arg0: i32):
    %0 = llvm.mlir.constant 8 : i32
    %1 = llvm.add %0, %arg0 overflow<nsw> : i32
    %2 = llvm.mul %1, %arg0 : i32
    %3 = llvm.not %2 : i32
    llvm.return %3 : i32
  }]

def test5_after := [llvm|
{
^0(%arg49 : i32):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def not_logicalOr_not_op1_after := [llvm|
{
^0(%arg50 : i1, %arg51 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.mlir.constant(false) : i1
  %2 = llvm.xor %arg50, %0 : i1
  %3 = "llvm.select"(%2, %arg51, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def pow2_or_zero_is_negative_commute_before := [llvm|
{
^0(%arg7 : i8):
  %0 = llvm.mlir.constant(42 : i8) : i8
  %1 = llvm.mlir.constant(0 : i8) : i8
  %2 = llvm.mul %0, %arg7 : i8
  %3 = llvm.sub %1, %2 : i8
  %4 = llvm.and %3, %2 : i8
  %5 = llvm.icmp "slt" %4, %1 : i8
  "llvm.return"(%5) : (i1) -> ()
}
]

def shl_nsw_add_before := [llvm|
{
^0(%arg22 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.shl %0, %arg22 overflow<nsw> : i32
  %3 = llvm.add %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def test1_after := [llvm|
{
^0(%arg14 : i32, %arg15 : i32):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def Reflect.Map.empty : List (BitVec w) := []

def shl_bad_sub_i32_before := [llvm|
{
^0(%arg12 : i32):
  %0 = llvm.mlir.constant(32 : i32) : i32
  %1 = llvm.mlir.constant(1 : i32) : i32
  %2 = llvm.sub %0, %arg12 : i32
  %3 = llvm.shl %1, %2 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def fold_icmp_shl_nuw_c2_non_pow2_after := [llvm|
{
^0(%arg7 : i32):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.icmp "ult" %arg7, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def p0_before := [llvm|
{
^0(%arg28 : i8, %arg29 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.shl %0, %arg29 : i8
  %2 = llvm.xor %1, %0 : i8
  %3 = llvm.icmp "uge" %2, %arg28 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def invert_both_cmp_operands_sub_before := [llvm|
{
^0(%arg36 : i32, %arg37 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.mlir.constant(42 : i32) : i32
  %2 = llvm.xor %arg36, %0 : i32
  %3 = llvm.sub %2, %arg37 : i32
  %4 = llvm.icmp "ult" %3, %1 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def ashrslt_02_09_exact_before := [llvm|
{
^0(%arg28 : i4):
  %0 = llvm.mlir.constant(2 : i4) : i4
  %1 = llvm.mlir.constant(-7 : i4) : i4
  %2 = llvm.ashr exact %arg28, %0 : i4
  %3 = llvm.icmp "slt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def add_shl_moreOneUse_sh3add_no_ZBA_test : LLVMPeepholeRewriteRefine 32 [Ty.llvm (.bitvec 32)] where
  lhs := add_shl_moreOneUse_sh3add
  rhs := add_shl_moreOneUse_sh3add_riscv_no_ZBA

def doBvGeneralize (g : MVarId) : GenM (Expr × MVarId) := do
  let lctx ← getLCtx
  let mut allFVars := #[]
  for h in lctx do
    if not h.isImplementationDetail then
      allFVars := allFVars.push h.fvarId
  let (_, g) ← g.revert allFVars
  let e ← visit (← g.getType)
  let mut newVars := #[]
  for x in (←get).mapping.elements do
    newVars := newVars.push x

  let e ← mkForallFVars newVars e (binderInfoForMVars := .default)
  let e ← instantiateMVars e
  pure (e, g)

def select_xor_icmp_bad_5_after := [llvm|
{
^0(%arg172 : i32, %arg173 : i32, %arg174 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.icmp "eq" %arg172, %0 : i32
  %2 = llvm.xor %arg172, %arg174 : i32
  %3 = "llvm.select"(%1, %arg173, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def icmp_sle6_before := [llvm|
{
^0(%arg7 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.mlir.constant(16 : i8) : i8
  %2 = llvm.shl %arg7, %0 overflow<nsw> : i8
  %3 = llvm.icmp "sle" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

Function.update in Mathlib.Logic.Function.Basic

def constLLVM_49 : Com LLVMPlusRiscV ⟨[]⟩ .pure (.llvm (.bitvec 64)) := [LV| {
  ^entry ():
    %1 = llvm.mlir.constant (-49) : i64
    llvm.return %1 : i64
  }]

def slt_or_not_max_logical_before := [llvm|
{
^0(%arg60 : i8, %arg61 : i8):
  %0 = llvm.mlir.constant(127 : i8) : i8
  %1 = llvm.mlir.constant(true) : i1
  %2 = llvm.icmp "slt" %arg60, %arg61 : i8
  %3 = llvm.icmp "ne" %arg60, %0 : i8
  %4 = "llvm.select"(%2, %1, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

Lean.levelZero in Lean.Level

def test_or_eq_a_b_commuted_before := [llvm|
{
^0(%arg30 : i1, %arg31 : i8, %arg32 : i8):
  %0 = llvm.icmp "eq" %arg31, %arg32 : i8
  %1 = llvm.or %arg30, %0 : i1
  %2 = "llvm.select"(%1, %arg32, %arg31) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def test0_before := [llvm|
{
^0(%arg3 : i32):
  %0 = llvm.mlir.constant(1431655765 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.and %arg3, %0 : i32
  %4 = llvm.xor %3, %1 : i32
  %5 = llvm.add %4, %2 overflow<nsw> : i32
  %6 = llvm.add %arg3, %5 overflow<nsw> : i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def icmp_equality_test_commute_select2_before := [llvm|
{
^0(%arg14 : i64, %arg15 : i64, %arg16 : i64):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.mlir.constant(false) : i1
  %2 = llvm.icmp "eq" %arg14, %arg16 : i64
  %3 = llvm.icmp "eq" %arg15, %arg16 : i64
  %4 = llvm.icmp "eq" %arg14, %arg15 : i64
  %5 = llvm.xor %2, %0 : i1
  %6 = "llvm.select"(%3, %1, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %7 = "llvm.select"(%5, %6, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%7) : (i1) -> ()
}
]

def test_shl_nuw__nuw_is_safe_after := [llvm|
{
^0(%arg80 : i32, %arg81 : i64):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.mlir.constant(-8 : i32) : i32
  %2 = llvm.shl %arg80, %0 : i32
  %3 = llvm.and %2, %1 : i32
  %4 = llvm.zext nneg %3 : i32 to i64
  %5 = llvm.ashr %arg81, %4 : i64
  "llvm.return"(%5) : (i64) -> ()
}
]

def min_of_max_before := [llvm|
{
^0(%arg20 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.xor %arg20, %0 : i32
  %3 = llvm.icmp "slt" %arg20, %1 : i32
  %4 = "llvm.select"(%3, %2, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %5 = llvm.icmp "slt" %4, %0 : i32
  %6 = "llvm.select"(%5, %4, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def or_or_and_pat4_before := [llvm|
{
^0(%arg62 : i8, %arg63 : i8, %arg64 : i8, %arg65 : i8):
  %0 = llvm.mlir.constant(42 : i8) : i8
  %1 = llvm.udiv %0, %arg64 : i8
  %2 = llvm.and %arg62, %arg63 : i8
  %3 = llvm.and %arg65, %arg63 : i8
  %4 = llvm.or %1, %3 : i8
  %5 = llvm.or %4, %2 : i8
  "llvm.return"(%5) : (i8) -> ()
}
]

inductive Ty (q : Nat) (n : Nat)
  | index : Ty q n
  | integer : Ty q n
  | tensor : Ty q n
  | polynomialLike : Ty q n
  deriving DecidableEq, Repr

def Term.bcard (t : Term) : Nat :=
  match t with
  | .ofNat _w _n => 0
  | .var _v _w => 0
  | .add _w a b => max (Term.bcard a) (Term.bcard b)
  | .zext a _wnew => (Term.bcard a)
  | .sext a _wnew => (Term.bcard a)
  | .setWidth a _wnew => (Term.bcard a)
  | .bor _w a b => (max (Term.bcard a) (Term.bcard b))
  | .band _w a b => (max (Term.bcard a) (Term.bcard b))
  | .bxor _w a b => (max (Term.bcard a) (Term.bcard b))
  | .bnot _w a => (Term.bcard a)
  | .boolVar v => v + 1
  | .boolConst _b => 0
  | .shiftl _w a _k => (Term.bcard a)
  | bvOfBool b => b.bcard
  | binWidthRel _k _wa _wb => 0
  | binRel _k _w a b => max (Term.bcard a) (Term.bcard b)
  | or p1 p2 => max (Term.bcard p1) (Term.bcard p2)
  | and p1 p2 => max (Term.bcard p1) (Term.bcard p2)
  | pvar _v => 0
  | boolBinRel _k a b => max (a.bcard) (b.bcard)

instance : DialectToExpr DCxComb where
  toExprM := .const ``Id [0]
  toExprDialect := .const ``DCxComb []

def is_ascii_alphabetic_after := [llvm|
{
^0(%arg248 : i32):
  %0 = llvm.mlir.constant(-33 : i32) : i32
  %1 = llvm.mlir.constant(-65 : i32) : i32
  %2 = llvm.mlir.constant(26 : i32) : i32
  %3 = llvm.and %arg248, %0 : i32
  %4 = llvm.add %3, %1 : i32
  %5 = llvm.icmp "ult" %4, %2 : i32
  "llvm.return"(%5) : (i1) -> ()
}
]

def prove_exact_with_high_mask_after := [llvm|
{
^0(%arg8 : i8, %arg9 : i8):
  %0 = llvm.mlir.constant(2 : i8) : i8
  %1 = llvm.mlir.constant(-2 : i8) : i8
  %2 = llvm.ashr %arg8, %0 : i8
  %3 = llvm.and %2, %1 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def sgt_swap_or_not_min_logical_before := [llvm|
{
^0(%arg20 : i8, %arg21 : i8):
  %0 = llvm.mlir.constant(-128 : i8) : i8
  %1 = llvm.mlir.constant(true) : i1
  %2 = llvm.icmp "slt" %arg21, %arg20 : i8
  %3 = llvm.icmp "ne" %arg20, %0 : i8
  %4 = "llvm.select"(%2, %1, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def test47_before := [llvm|
{
^0(%arg139 : i8):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.sext %arg139 : i8 to i32
  %2 = llvm.or %1, %0 : i32
  %3 = llvm.zext %2 : i32 to i64
  "llvm.return"(%3) : (i64) -> ()
}
]

def ConcreteCliTest.printSignature (test : ConcreteCliTest) : String :=
  s!"{test.context.toList.reverse} → {test.ty}"

def icmp_slt_0_and_icmp_sge_neg1_i64_fail_after := [llvm|
{
^0(%arg59 : i64):
  %0 = llvm.mlir.constant(-2) : i64
  %1 = llvm.mlir.constant(62) : i64
  %2 = llvm.mlir.constant(1) : i64
  %3 = llvm.mlir.constant(0) : i64
  %4 = llvm.icmp "sgt" %arg59, %0 : i64
  %5 = llvm.lshr %arg59, %1 : i64
  %6 = llvm.and %5, %2 : i64
  %7 = "llvm.select"(%4, %6, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i64, i64) -> i64
  "llvm.return"(%7) : (i64) -> ()
}
]

def test_imply_not2_before := [llvm|
{
^0(%arg3 : i32, %arg4 : i1):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.mlir.constant(false) : i1
  %2 = llvm.mlir.constant(true) : i1
  %3 = llvm.icmp "eq" %arg3, %0 : i32
  %4 = "llvm.select"(%3, %arg4, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %5 = llvm.xor %3, %2 : i1
  %6 = llvm.or %4, %5 : i1
  "llvm.return"(%6) : (i1) -> ()
}
]

def Expr.denoteOpIntoSubtype (e : Expr d Γ_in eff tys) (Γv : Valuation Γ_in) :
    eff.toMonad d.m {x // e.IsDenotationForPureE Γv x} :=
  match h_pure : e.toPure? with
    | some ePure => pure ⟨ePure.denoteOp Γv, by admit /- proof elided -/
    ⟩
    | none => (Subtype.mk · (by admit /- proof elided -/
    )) <$> (e.denoteOp Γv)

def not_and_and_or_no_or_commute2_and_before := [llvm|
{
^0(%arg157 : i32, %arg158 : i32, %arg159 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.or %arg158, %arg157 : i32
  %2 = llvm.xor %1, %0 : i32
  %3 = llvm.xor %arg157, %0 : i32
  %4 = llvm.and %3, %arg159 : i32
  %5 = llvm.and %4, %arg158 : i32
  %6 = llvm.or %5, %2 : i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def shl_or_after := [llvm|
{
^0(%arg67 : i16, %arg68 : i16):
  %0 = llvm.mlir.constant(42 : i16) : i16
  %1 = llvm.mlir.constant(12 : i16) : i16
  %2 = llvm.mlir.constant(7 : i16) : i16
  %3 = llvm.srem %arg68, %0 : i16
  %4 = llvm.shl %arg67, %1 : i16
  %5 = llvm.shl %3, %2 overflow<nsw> : i16
  %6 = llvm.or %4, %5 : i16
  "llvm.return"(%6) : (i16) -> ()
}
]

def mul_constant_eq_before := [llvm|
{
^0(%arg140 : i32, %arg141 : i32):
  %0 = llvm.mlir.constant(5 : i32) : i32
  %1 = llvm.mul %arg140, %0 : i32
  %2 = llvm.mul %arg141, %0 : i32
  %3 = llvm.icmp "eq" %1, %2 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def and_signbit_select_lshr_after := [llvm|
{
^0(%arg30 : i32, %arg31 : i1):
  %0 = llvm.mlir.constant(8 : i32) : i32
  %1 = llvm.mlir.constant(16776960 : i32) : i32
  %2 = llvm.lshr %arg30, %0 : i32
  %3 = llvm.and %2, %1 : i32
  %4 = "llvm.select"(%arg31, %3, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def zext_nneg_sext_sle_op0_narrow_before := [llvm|
{
^0(%arg50 : i8, %arg51 : i16):
  %0 = llvm.zext nneg %arg50 : i8 to i32
  %1 = llvm.sext %arg51 : i16 to i32
  %2 = llvm.icmp "sle" %0, %1 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def select_exact_lshr_icmp_const_after := [llvm|
{
^0(%arg146 : i32):
  %0 = llvm.mlir.constant(5 : i32) : i32
  %1 = llvm.lshr %arg146, %0 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def irc_constants_AMinusC1MinusC2_neg2_neg2 : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%a: i64):
      %c1 = llvm.mlir.constant (-2) : i64
      %c2 = llvm.mlir.constant (-2) : i64
      %0 = llvm.sub %a, %c1 : i64
      %1 = llvm.sub %0, %c2 : i64
      llvm.return %1 : i64
  }]
  rhs := [LV| {
    ^entry (%a: i64):
      %c1 = llvm.mlir.constant (-2) : i64
      %c2 = llvm.mlir.constant (-2) : i64
      %0 = llvm.add %c1, %c2 : i64
      %1 = llvm.sub %a, %0 : i64
      llvm.return %1 : i64
  }]

def and_slt_to_mask_before := [llvm|
{
^0(%arg5 : i8):
  %0 = llvm.mlir.constant(-124 : i8) : i8
  %1 = llvm.mlir.constant(2 : i8) : i8
  %2 = llvm.mlir.constant(0 : i8) : i8
  %3 = llvm.icmp "slt" %arg5, %0 : i8
  %4 = llvm.and %arg5, %1 : i8
  %5 = llvm.icmp "eq" %4, %2 : i8
  %6 = llvm.and %3, %5 : i1
  "llvm.return"(%6) : (i1) -> ()
}
]

def no_shift_no_xor_multiuse_cmp_xor_before := [llvm|
{
^0(%arg56 : i32, %arg57 : i32, %arg58 : i32, %arg59 : i32):
  %0 = llvm.mlir.constant(4096 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.and %arg56, %0 : i32
  %3 = llvm.icmp "eq" %2, %1 : i32
  %4 = llvm.xor %arg57, %0 : i32
  %5 = "llvm.select"(%3, %arg57, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %6 = "llvm.select"(%3, %arg58, %arg59) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %7 = llvm.mul %5, %6 : i32
  %8 = llvm.mul %7, %4 : i32
  "llvm.return"(%8) : (i32) -> ()
}
]

def t0_before := [llvm|
{
^0(%arg12 : i16):
  %0 = llvm.mlir.constant(16 : i32) : i32
  %1 = llvm.mlir.constant(-2147483648 : i32) : i32
  %2 = llvm.zext %arg12 : i16 to i32
  %3 = llvm.shl %2, %0 : i32
  %4 = llvm.and %3, %1 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def binop_left_to_zero_lshr : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%x: i64):
      %c = llvm.mlir.constant (0) : i64
      %0 = llvm.lshr %c, %x : i64
      llvm.return %0 : i64
  }]
  rhs := [LV| {
    ^entry (%x: i64):
      %c = llvm.mlir.constant (0) : i64
      llvm.return %c : i64
  }]

def lshrugt_03_05_exact_before := [llvm|
{
^0(%arg184 : i4):
  %0 = llvm.mlir.constant(3 : i4) : i4
  %1 = llvm.mlir.constant(5 : i4) : i4
  %2 = llvm.lshr exact %arg184, %0 : i4
  %3 = llvm.icmp "ugt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def select_sub_icmp_bad_2_before := [llvm|
{
^0(%arg68 : i32, %arg69 : i32, %arg70 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.icmp "eq" %arg68, %0 : i32
  %2 = llvm.sub %arg70, %arg68 : i32
  %3 = "llvm.select"(%1, %2, %arg69) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def ashr_C1_add_A_C2_i32_after := [llvm|
{
^0(%arg7 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

@[simp_denote]
def select_llvm_32 := [LV| {
  ^entry (%cond : i1, %arg0: i32, %arg1: i32):
    %0 = "llvm.select"(%cond, %arg0, %arg1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
    llvm.return %0 : i32
  }]

def shift_xor_multiuse_xor_before := [llvm|
{
^0(%arg126 : i32, %arg127 : i32):
  %0 = llvm.mlir.constant(4096 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(2048 : i32) : i32
  %3 = llvm.and %arg126, %0 : i32
  %4 = llvm.icmp "ne" %1, %3 : i32
  %5 = llvm.xor %arg127, %2 : i32
  %6 = "llvm.select"(%4, %arg127, %5) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %7 = llvm.mul %6, %5 : i32
  "llvm.return"(%7) : (i32) -> ()
}
]

def sub_ashr_or_i8_after := [llvm|
{
^0(%arg39 : i8, %arg40 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.icmp "slt" %arg40, %arg39 : i8
  %2 = "llvm.select"(%1, %0, %arg39) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def xor_icmp_to_ne_before := [llvm|
{
^0(%arg6 : i32):
  %0 = llvm.mlir.constant(4 : i32) : i32
  %1 = llvm.mlir.constant(6 : i32) : i32
  %2 = llvm.icmp "sgt" %arg6, %0 : i32
  %3 = llvm.icmp "slt" %arg6, %1 : i32
  %4 = llvm.xor %2, %3 : i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def add_nsw_poison_constant_fold_after := [llvm|
{
^0(%arg2 : i1, %arg3 : i8):
  %0 = llvm.mlir.constant(64 : i8) : i8
  %1 = llvm.mlir.constant(-127 : i8) : i8
  %2 = llvm.add %arg3, %0 overflow<nsw> : i8
  %3 = "llvm.select"(%arg2, %2, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def not_and_and_or_no_or_commute3_after := [llvm|
{
^0(%arg148 : i32, %arg149 : i32, %arg150 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.sdiv %0, %arg150 : i32
  %3 = llvm.xor %arg148, %1 : i32
  %4 = llvm.xor %arg149, %1 : i32
  %5 = llvm.or %2, %4 : i32
  %6 = llvm.and %5, %3 : i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def trunc_lshr_sext_exact_before := [llvm|
{
^0(%arg45 : i8):
  %0 = llvm.mlir.constant(6 : i32) : i32
  %1 = llvm.sext %arg45 : i8 to i32
  %2 = llvm.lshr exact %1, %0 : i32
  %3 = llvm.trunc %2 : i32 to i8
  "llvm.return"(%3) : (i8) -> ()
}
]

instance : AST.TransformReturn LLVM 0 := { mkReturn }

def or_nosignbit_lshr_before := [llvm|
{
^0(%arg12 : i32):
  %0 = llvm.mlir.constant(2147418112 : i32) : i32
  %1 = llvm.mlir.constant(8 : i32) : i32
  %2 = llvm.or %arg12, %0 : i32
  %3 = llvm.lshr %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def test5_before := [llvm|
{
^0(%arg192 : i1):
  %0 = llvm.zext %arg192 : i1 to i8
  %1 = llvm.zext %0 : i8 to i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def main6d_logical_after := [llvm|
{
^0(%arg87 : i32):
  %0 = llvm.mlir.constant(23 : i32) : i32
  %1 = llvm.mlir.constant(19 : i32) : i32
  %2 = llvm.and %arg87, %0 : i32
  %3 = llvm.icmp "eq" %2, %1 : i32
  %4 = llvm.zext %3 : i1 to i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def ashrsgt_02_14_exact_before := [llvm|
{
^0(%arg71 : i4):
  %0 = llvm.mlir.constant(2 : i4) : i4
  %1 = llvm.mlir.constant(-2 : i4) : i4
  %2 = llvm.ashr exact %arg71, %0 : i4
  %3 = llvm.icmp "sgt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def xor_or_xor_common_op_commute5_after := [llvm|
{
^0(%arg68 : i32, %arg69 : i32, %arg70 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg68, %0 : i32
  %2 = llvm.and %arg69, %1 : i32
  %3 = llvm.xor %2, %arg70 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def t2_commutative_before := [llvm|
{
^0(%arg20 : i8, %arg21 : i8):
  %0 = llvm.sub %arg20, %arg21 : i8
  %1 = llvm.icmp "uge" %arg20, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def test53_after := [llvm|
{
^0(%arg131 : i32):
  %0 = llvm.mlir.constant(7224 : i16) : i16
  %1 = llvm.mlir.constant(-32574 : i16) : i16
  %2 = llvm.trunc %arg131 : i32 to i16
  %3 = llvm.and %2, %0 : i16
  %4 = llvm.or disjoint %3, %1 : i16
  %5 = llvm.zext %4 : i16 to i64
  "llvm.return"(%5) : (i64) -> ()
}
]

def test_shift_and_cmp_changed4_after := [llvm|
{
^0(%arg0 : i8):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

@[simp_sllvm]
def urem (x y : LLVM.IntW w) : EffectM (LLVM.IntW w) := do
  if y.canBe 0#w then
    throwUB
  else
    pure <| LLVM.urem x y

def select_replace_udiv_non_speculatable_before := [llvm|
{
^0(%arg1 : i32, %arg2 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.icmp "eq" %arg1, %0 : i32
  %2 = llvm.udiv %arg2, %arg1 : i32
  %3 = "llvm.select"(%1, %2, %arg2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def masked_or_allzeroes_notoptimised_logical_after := [llvm|
{
^0(%arg116 : i32):
  %0 = llvm.mlir.constant(15 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(39 : i32) : i32
  %3 = llvm.and %arg116, %0 : i32
  %4 = llvm.icmp "eq" %3, %1 : i32
  %5 = llvm.and %arg116, %2 : i32
  %6 = llvm.icmp "eq" %5, %1 : i32
  %7 = llvm.or %4, %6 : i1
  "llvm.return"(%7) : (i1) -> ()
}
]

def ashrsgt_02_01_exact_after := [llvm|
{
^0(%arg84 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

Matrix.of in Mathlib.LinearAlgebra.Matrix.Defs

Fin.instOfNat in Init.Data.Fin.Basic

def ashrsgt_03_12_after := [llvm|
{
^0(%arg273 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def xor_or_xor_common_op_commute6_before := [llvm|
{
^0(%arg65 : i32, %arg66 : i32, %arg67 : i32):
  %0 = llvm.xor %arg67, %arg65 : i32
  %1 = llvm.or %arg65, %arg66 : i32
  %2 = llvm.xor %1, %0 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def ugt_rem_zero_nsw_before := [llvm|
{
^0(%arg166 : i8):
  %0 = llvm.mlir.constant(7 : i8) : i8
  %1 = llvm.mlir.constant(21 : i8) : i8
  %2 = llvm.mul %arg166, %0 overflow<nsw,nuw> : i8
  %3 = llvm.icmp "ugt" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def icmp_slt_0_or_icmp_sgt_0_i64_before := [llvm|
{
^0(%arg73 : i64):
  %0 = llvm.mlir.constant(0) : i64
  %1 = llvm.icmp "slt" %arg73, %0 : i64
  %2 = llvm.icmp "sgt" %arg73, %0 : i64
  %3 = llvm.zext %1 : i1 to i64
  %4 = llvm.zext %2 : i1 to i64
  %5 = llvm.or %3, %4 : i64
  "llvm.return"(%5) : (i64) -> ()
}
]

def nonexact_ashr_eq_noexactlog_before := [llvm|
{
^0(%arg134 : i8):
  %0 = llvm.mlir.constant(-90 : i8) : i8
  %1 = llvm.mlir.constant(-30 : i8) : i8
  %2 = llvm.ashr %0, %arg134 : i8
  %3 = llvm.icmp "eq" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def bitwise_and_logical_and_masked_icmp_allones_after := [llvm|
{
^0(%arg139 : i1, %arg140 : i32):
  %0 = llvm.mlir.constant(15 : i32) : i32
  %1 = llvm.mlir.constant(false) : i1
  %2 = llvm.and %arg140, %0 : i32
  %3 = llvm.icmp "eq" %2, %0 : i32
  %4 = "llvm.select"(%3, %arg139, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def n3_after := [llvm|
{
^0(%arg1 : i8, %arg2 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.shl %0, %arg2 overflow<nsw> : i8
  %2 = llvm.xor %1, %0 : i8
  %3 = llvm.icmp "uge" %arg1, %2 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def masked_icmps_mask_notallzeros_bmask_mixed_swapped_1_before := [llvm|
{
^0(%arg50 : i32):
  %0 = llvm.mlir.constant(12 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(7 : i32) : i32
  %3 = llvm.mlir.constant(1 : i32) : i32
  %4 = llvm.and %arg50, %0 : i32
  %5 = llvm.icmp "ne" %4, %1 : i32
  %6 = llvm.and %arg50, %2 : i32
  %7 = llvm.icmp "eq" %6, %3 : i32
  %8 = llvm.and %7, %5 : i1
  "llvm.return"(%8) : (i1) -> ()
}
]

def icmp_slt_0_xor_icmp_sgt_neg2_i32_after := [llvm|
{
^0(%arg54 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.icmp "ne" %arg54, %0 : i32
  %2 = llvm.zext %1 : i1 to i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def test_mul__nuw_is_safe_before := [llvm|
{
^0(%arg8 : i32):
  %0 = llvm.mlir.constant(268435457 : i32) : i32
  %1 = llvm.mlir.constant(268435456 : i32) : i32
  %2 = llvm.mlir.constant(9 : i32) : i32
  %3 = llvm.mlir.constant(-1879048192 : i32) : i32
  %4 = llvm.and %arg8, %0 : i32
  %5 = llvm.icmp "eq" %4, %1 : i32
  %6 = llvm.mul %4, %2 : i32
  %7 = "llvm.select"(%5, %3, %6) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%7) : (i32) -> ()
}
]

def positive_biggershl_after := [llvm|
{
^0(%arg59 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.mlir.constant(-64 : i8) : i8
  %2 = llvm.shl %arg59, %0 : i8
  %3 = llvm.and %2, %1 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def ashrsgt_02_04_exact_before := [llvm|
{
^0(%arg81 : i4):
  %0 = llvm.mlir.constant(2 : i4) : i4
  %1 = llvm.mlir.constant(4 : i4) : i4
  %2 = llvm.ashr exact %arg81, %0 : i4
  %3 = llvm.icmp "sgt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def src3_after := [llvm|
{
^0(%arg8 : i32, %arg9 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg9, %arg8 : i32
  %2 = llvm.xor %1, %0 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def or_or_and_complex_after := [llvm|
{
^0(%arg82 : i64):
  %0 = llvm.mlir.constant(8) : i64
  %1 = llvm.mlir.constant(71777214294589695) : i64
  %2 = llvm.mlir.constant(-71777214294589696) : i64
  %3 = llvm.lshr %arg82, %0 : i64
  %4 = llvm.shl %arg82, %0 : i64
  %5 = llvm.and %3, %1 : i64
  %6 = llvm.and %4, %2 : i64
  %7 = llvm.or disjoint %5, %6 : i64
  "llvm.return"(%7) : (i64) -> ()
}
]

def max_of_min_before := [llvm|
{
^0(%arg22 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.xor %arg22, %0 : i32
  %3 = llvm.icmp "sgt" %arg22, %1 : i32
  %4 = "llvm.select"(%3, %2, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %5 = llvm.icmp "sgt" %4, %0 : i32
  %6 = "llvm.select"(%5, %4, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def multiuse_shl_shl_after := [llvm|
{
^0(%arg36 : i42):
  %0 = llvm.mlir.constant(8 : i42) : i42
  %1 = llvm.mlir.constant(17 : i42) : i42
  %2 = llvm.shl %arg36, %0 : i42
  %3 = llvm.shl %arg36, %1 : i42
  %4 = llvm.mul %2, %3 : i42
  "llvm.return"(%4) : (i42) -> ()
}
]

def shl1_trunc_sgt4_after := [llvm|
{
^0(%arg15 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(4 : i16) : i16
  %2 = llvm.shl %0, %arg15 overflow<nuw> : i32
  %3 = llvm.trunc %2 : i32 to i16
  %4 = llvm.icmp "sgt" %3, %1 : i16
  "llvm.return"(%4) : (i1) -> ()
}
]

def trunc_sel_smaller_sext_before := [llvm|
{
^0(%arg81 : i64, %arg82 : i1):
  %0 = llvm.mlir.constant(42 : i16) : i16
  %1 = llvm.trunc %arg81 : i64 to i16
  %2 = "llvm.select"(%arg82, %1, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i16, i16) -> i16
  %3 = llvm.sext %2 : i16 to i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def or_logic_or_logic_and_5_after := [llvm|
{
^0(%arg36 : i1, %arg37 : i1, %arg38 : i1):
  %0 = llvm.mlir.constant(false) : i1
  %1 = llvm.mlir.constant(true) : i1
  %2 = "llvm.select"(%arg37, %arg38, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %3 = "llvm.select"(%arg36, %1, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def not_sub_before := [llvm|
{
^0(%arg133 : i32):
  %0 = llvm.mlir.constant(123 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.sub %0, %arg133 : i32
  %3 = llvm.xor %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def positive_biggerashr_shlnsw_ashrexact_before := [llvm|
{
^0(%arg35 : i8):
  %0 = llvm.mlir.constant(6 : i8) : i8
  %1 = llvm.mlir.constant(3 : i8) : i8
  %2 = llvm.ashr exact %arg35, %0 : i8
  %3 = llvm.shl %2, %1 overflow<nsw> : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def lshr_not_nneg2_after := [llvm|
{
^0(%arg20 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.mlir.constant(-128 : i8) : i8
  %2 = llvm.lshr %arg20, %0 : i8
  %3 = llvm.or disjoint %2, %1 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def add_nuw_const_const_sub_nuw_after := [llvm|
{
^0(%arg56 : i8):
  %0 = llvm.mlir.constant(-128 : i8) : i8
  %1 = llvm.sub %0, %arg56 overflow<nuw> : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def positive_biggershl_before := [llvm|
{
^0(%arg59 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.mlir.constant(6 : i8) : i8
  %2 = llvm.lshr %arg59, %0 : i8
  %3 = llvm.shl %2, %1 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def ule_bignum_after := [llvm|
{
^0(%arg145 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.icmp "eq" %arg145, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def lshrult_03_13_exact_before := [llvm|
{
^0(%arg104 : i4):
  %0 = llvm.mlir.constant(3 : i4) : i4
  %1 = llvm.mlir.constant(-3 : i4) : i4
  %2 = llvm.lshr exact %arg104, %0 : i4
  %3 = llvm.icmp "ult" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

@[simp_denote]
def add_negative_high_bound_accept_llvm := [LV| {
  ^entry (%a: i32):
  %0 = llvm.mlir.constant (-2049) : i32
  %1 = llvm.add %a, %0 : i32
  llvm.return %1 : i32
}]

def llvm_trunc_riscv_32_to_8_nuw_nsw : LLVMPeepholeRewriteRefine 8 [Ty.llvm (.bitvec 32)] :=
  {lhs:= trunc_llvm_32_to_8_nsw_nuw, rhs:= trunc_riscv_32_to_8_nsw_nuw}

def multiuse2_before := [llvm|
{
^0(%arg10 : i32):
  %0 = llvm.mlir.constant(6 : i32) : i32
  %1 = llvm.mlir.constant(8 : i32) : i32
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.mlir.constant(24 : i32) : i32
  %4 = llvm.mlir.constant(96 : i32) : i32
  %5 = llvm.and %arg10, %0 : i32
  %6 = llvm.shl %5, %1 overflow<nsw,nuw> : i32
  %7 = llvm.shl %5, %2 overflow<nsw,nuw> : i32
  %8 = llvm.and %arg10, %3 : i32
  %9 = llvm.shl %8, %1 overflow<nsw,nuw> : i32
  %10 = llvm.shl %8, %2 overflow<nsw,nuw> : i32
  %11 = llvm.and %arg10, %4 : i32
  %12 = llvm.shl %11, %1 overflow<nsw,nuw> : i32
  %13 = llvm.shl %11, %2 overflow<nsw,nuw> : i32
  %14 = llvm.or %6, %9 : i32
  %15 = llvm.or %12, %14 : i32
  %16 = llvm.or %13, %10 : i32
  %17 = llvm.or %7, %16 : i32
  %18 = llvm.or %15, %17 : i32
  "llvm.return"(%18) : (i32) -> ()
}
]

def liRiscv_1 := [LV| {
  ^entry ():
    %0 = "li"() {imm = -1 : !i64} : (!i64) -> (!i64)
    %1 = "builtin.unrealized_conversion_cast"(%0) : (!i64) -> (i64)
    llvm.return %1 : i64
  }]

def lshrugt_03_08_exact_after := [llvm|
{
^0(%arg181 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def t5_ugt_slt_0_after := [llvm|
{
^0(%arg51 : i32, %arg52 : i32, %arg53 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.mlir.constant(65535 : i32) : i32
  %2 = llvm.icmp "slt" %arg51, %0 : i32
  %3 = llvm.icmp "sgt" %arg51, %1 : i32
  %4 = "llvm.select"(%2, %arg52, %arg51) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %5 = "llvm.select"(%3, %arg53, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def test5_before := [llvm|
{
^0(%arg23 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.udiv %0, %arg23 : i32
  %3 = llvm.icmp "ne" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def test14_after := [llvm|
{
^0(%arg5 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.icmp "ugt" %arg5, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def t2_commutative_after := [llvm|
{
^0(%arg20 : i8, %arg21 : i8):
  %0 = llvm.icmp "uge" %arg20, %arg21 : i8
  "llvm.return"(%0) : (i1) -> ()
}
]

def test24_after := [llvm|
{
^0(%arg171 : i1):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

decidable_of_decidable_of_iff in Init.Core

def n7_wrong_pred2_before := [llvm|
{
^0(%arg10 : i8, %arg11 : i8):
  %0 = llvm.sub %arg10, %arg11 : i8
  %1 = llvm.icmp "eq" %0, %arg10 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def uadd_sat_flipped_wrong_bounds7_after := [llvm|
{
^0(%arg90 : i32):
  %0 = llvm.mlir.constant(-11 : i32) : i32
  %1 = llvm.mlir.constant(9 : i32) : i32
  %2 = llvm.mlir.constant(-1 : i32) : i32
  %3 = llvm.icmp "ult" %arg90, %0 : i32
  %4 = llvm.add %arg90, %1 : i32
  %5 = "llvm.select"(%3, %4, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def lshrult_03_03_exact_before := [llvm|
{
^0(%arg114 : i4):
  %0 = llvm.mlir.constant(3 : i4) : i4
  %1 = llvm.lshr exact %arg114, %0 : i4
  %2 = llvm.icmp "ult" %1, %0 : i4
  "llvm.return"(%2) : (i1) -> ()
}
]

def lshrult_03_08_exact_before := [llvm|
{
^0(%arg109 : i4):
  %0 = llvm.mlir.constant(3 : i4) : i4
  %1 = llvm.mlir.constant(-8 : i4) : i4
  %2 = llvm.lshr exact %arg109, %0 : i4
  %3 = llvm.icmp "ult" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def foo_before := [llvm|
{
^0(%arg0 : i32):
  %0 = llvm.mlir.constant(5 : i32) : i32
  %1 = llvm.mlir.constant(2 : i32) : i32
  %2 = llvm.sub %0, %arg0 : i32
  %3 = llvm.and %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def urem? {w : Nat} (x y : BitVec w) : IntW w :=
  if y = 0 then
    .poison
  else
    .value <| x % y

def test44_after := [llvm|
{
^0(%arg203 : i32, %arg204 : i32):
  %0 = llvm.and %arg203, %arg204 : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

def exact_lshr_ne_before := [llvm|
{
^0(%arg157 : i8):
  %0 = llvm.mlir.constant(4 : i8) : i8
  %1 = llvm.mlir.constant(1 : i8) : i8
  %2 = llvm.lshr exact %0, %arg157 : i8
  %3 = llvm.icmp "ne" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def ashr_ugt_8_after := [llvm|
{
^0(%arg106 : i4):
  %0 = llvm.mlir.constant(0 : i4) : i4
  %1 = llvm.icmp "slt" %arg106, %0 : i4
  "llvm.return"(%1) : (i1) -> ()
}
]

def constantLowering64bit : List (Σ Γ, LLVMPeepholeRewriteRefine 64 Γ) :=
  [⟨_, llvm_const_lower_riscv_li_50⟩,
  ⟨_, llvm_const_lower_riscv_li_49⟩,
  ⟨_, llvm_const_lower_riscv_li_48⟩,
  ⟨_, llvm_const_lower_riscv_li_47⟩,
  ⟨_, llvm_const_lower_riscv_li_46⟩,
  ⟨_, llvm_const_lower_riscv_li_45⟩,
  ⟨_, llvm_const_lower_riscv_li_44⟩,
  ⟨_, llvm_const_lower_riscv_li_43⟩,
  ⟨_, llvm_const_lower_riscv_li_42⟩,
  ⟨_, llvm_const_lower_riscv_li_41⟩,
  ⟨_, llvm_const_lower_riscv_li_40⟩,
  ⟨_, llvm_const_lower_riscv_li_39⟩,
  ⟨_, llvm_const_lower_riscv_li_38⟩,
  ⟨_, llvm_const_lower_riscv_li_37⟩,
  ⟨_, llvm_const_lower_riscv_li_36⟩,
  ⟨_, llvm_const_lower_riscv_li_35⟩,
  ⟨_, llvm_const_lower_riscv_li_34⟩,
  ⟨_, llvm_const_lower_riscv_li_33⟩,
  ⟨_, llvm_const_lower_riscv_li_32⟩,
  ⟨_, llvm_const_lower_riscv_li_31⟩,
  ⟨_, llvm_const_lower_riscv_li_30⟩,
  ⟨_, llvm_const_lower_riscv_li_29⟩,
  ⟨_, llvm_const_lower_riscv_li_28⟩,
  ⟨_, llvm_const_lower_riscv_li_27⟩,
  ⟨_, llvm_const_lower_riscv_li_26⟩,
  ⟨_, llvm_const_lower_riscv_li_25⟩,
  ⟨_, llvm_const_lower_riscv_li_24⟩,
  ⟨_, llvm_const_lower_riscv_li_23⟩,
  ⟨_, llvm_const_lower_riscv_li_22⟩,
  ⟨_, llvm_const_lower_riscv_li_21⟩,
  ⟨_, llvm_const_lower_riscv_li_20⟩,
  ⟨_, llvm_const_lower_riscv_li_19⟩,
  ⟨_, llvm_const_lower_riscv_li_18⟩,
  ⟨_, llvm_const_lower_riscv_li_17⟩,
  ⟨_, llvm_const_lower_riscv_li_16⟩,
  ⟨_, llvm_const_lower_riscv_li_15⟩,
  ⟨_, llvm_const_lower_riscv_li_14⟩,
  ⟨_, llvm_const_lower_riscv_li_13⟩,
  ⟨_, llvm_const_lower_riscv_li_12⟩,
  ⟨_, llvm_const_lower_riscv_li_11⟩,
  ⟨_, llvm_const_lower_riscv_li_10⟩,
  ⟨_, llvm_const_lower_riscv_li_9⟩,
  ⟨_, llvm_const_lower_riscv_li_8⟩,
  ⟨_, llvm_const_lower_riscv_li_7⟩,
  ⟨_, llvm_const_lower_riscv_li_6⟩,
  ⟨_, llvm_const_lower_riscv_li_5⟩,
  ⟨_, llvm_const_lower_riscv_li_4⟩,
  ⟨_, llvm_const_lower_riscv_li_3⟩,
  ⟨_, llvm_const_lower_riscv_li_2⟩,
  ⟨_, llvm_const_lower_riscv_li_1⟩,
  ⟨_, llvm_const_lower_riscv_li0⟩,
  ⟨_, llvm_const_lower_riscv_li1⟩,
  ⟨_, llvm_const_lower_riscv_li2⟩,
  ⟨_, llvm_const_lower_riscv_li3⟩,
  ⟨_, llvm_const_lower_riscv_li4⟩,
  ⟨_, llvm_const_lower_riscv_li5⟩,
  ⟨_, llvm_const_lower_riscv_li6⟩,
  ⟨_, llvm_const_lower_riscv_li7⟩,
  ⟨_, llvm_const_lower_riscv_li8⟩,
  ⟨_, llvm_const_lower_riscv_li9⟩,
  ⟨_, llvm_const_lower_riscv_li10⟩,
  ⟨_, llvm_const_lower_riscv_li11⟩,
  ⟨_, llvm_const_lower_riscv_li12⟩,
  ⟨_, llvm_const_lower_riscv_li13⟩,
  ⟨_, llvm_const_lower_riscv_li14⟩,
  ⟨_, llvm_const_lower_riscv_li15⟩,
  ⟨_, llvm_const_lower_riscv_li16⟩,
  ⟨_, llvm_const_lower_riscv_li17⟩,
  ⟨_, llvm_const_lower_riscv_li18⟩,
  ⟨_, llvm_const_lower_riscv_li19⟩,
  ⟨_, llvm_const_lower_riscv_li20⟩,
  ⟨_, llvm_const_lower_riscv_li21⟩,
  ⟨_, llvm_const_lower_riscv_li22⟩,
  ⟨_, llvm_const_lower_riscv_li23⟩,
  ⟨_, llvm_const_lower_riscv_li24⟩,
  ⟨_, llvm_const_lower_riscv_li25⟩,
  ⟨_, llvm_const_lower_riscv_li26⟩,
  ⟨_, llvm_const_lower_riscv_li27⟩,
  ⟨_, llvm_const_lower_riscv_li28⟩,
  ⟨_, llvm_const_lower_riscv_li29⟩,
  ⟨_, llvm_const_lower_riscv_li30⟩,
  ⟨_, llvm_const_lower_riscv_li31⟩,
  ⟨_, llvm_const_lower_riscv_li32⟩,
  ⟨_, llvm_const_lower_riscv_li33⟩,
  ⟨_, llvm_const_lower_riscv_li34⟩,
  ⟨_, llvm_const_lower_riscv_li35⟩,
  ⟨_, llvm_const_lower_riscv_li36⟩,
  ⟨_, llvm_const_lower_riscv_li37⟩,
  ⟨_, llvm_const_lower_riscv_li38⟩,
  ⟨_, llvm_const_lower_riscv_li39⟩,
  ⟨_, llvm_const_lower_riscv_li40⟩,
  ⟨_, llvm_const_lower_riscv_li41⟩,
  ⟨_, llvm_const_lower_riscv_li42⟩,
  ⟨_, llvm_const_lower_riscv_li43⟩,
  ⟨_, llvm_const_lower_riscv_li44⟩,
  ⟨_, llvm_const_lower_riscv_li45⟩,
  ⟨_, llvm_const_lower_riscv_li46⟩,
  ⟨_, llvm_const_lower_riscv_li47⟩,
  ⟨_, llvm_const_lower_riscv_li48⟩,
  ⟨_, llvm_const_lower_riscv_li49⟩]

def udiv_exact_eq_1_before := [llvm|
{
^0(%arg10 : i8, %arg11 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.udiv exact %arg10, %arg11 : i8
  %2 = llvm.icmp "ne" %1, %0 : i8
  "llvm.return"(%2) : (i1) -> ()
}
]

def ashrslt_01_02_exact_after := [llvm|
{
^0(%arg51 : i4):
  %0 = llvm.mlir.constant(3 : i4) : i4
  %1 = llvm.icmp "slt" %arg51, %0 : i4
  "llvm.return"(%1) : (i1) -> ()
}
]

def test10_before := [llvm|
{
^0(%arg4 : i123):
  %0 = llvm.mlir.constant(127 : i123) : i123
  %1 = llvm.mlir.constant(128 : i123) : i123
  %2 = llvm.and %arg4, %0 : i123
  %3 = llvm.and %2, %1 : i123
  "llvm.return"(%3) : (i123) -> ()
}
]

def logical_or_not_after := [llvm|
{
^0(%arg260 : i1, %arg261 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.xor %arg260, %0 : i1
  %2 = "llvm.select"(%1, %0, %arg261) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%2) : (i1) -> ()
}
]

def test18_after := [llvm|
{
^0(%arg34 : i32, %arg35 : i32):
  %0 = llvm.mlir.constant(1431655765 : i32) : i32
  %1 = llvm.or %arg34, %0 : i32
  %2 = llvm.sub %arg35, %1 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def x_after := [llvm|
{
^0(%arg0 : i32):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def icmp_and_ashr_multiuse_logical_after := [llvm|
{
^0(%arg4 : i32):
  %0 = llvm.mlir.constant(240 : i32) : i32
  %1 = llvm.mlir.constant(224 : i32) : i32
  %2 = llvm.mlir.constant(496 : i32) : i32
  %3 = llvm.mlir.constant(432 : i32) : i32
  %4 = llvm.and %arg4, %0 : i32
  %5 = llvm.icmp "ne" %4, %1 : i32
  %6 = llvm.and %arg4, %2 : i32
  %7 = llvm.icmp "ne" %6, %3 : i32
  %8 = llvm.and %5, %7 : i1
  "llvm.return"(%8) : (i1) -> ()
}
]

def test15_after := [llvm|
{
^0(%arg44 : i8, %arg45 : i8):
  %0 = llvm.mlir.constant(33 : i8) : i8
  %1 = llvm.xor %arg45, %arg44 : i8
  %2 = llvm.xor %arg44, %arg45 : i8
  %3 = llvm.xor %2, %0 : i8
  %4 = llvm.and %1, %3 : i8
  %5 = llvm.mul %4, %3 : i8
  "llvm.return"(%5) : (i8) -> ()
}
]

def lshrult_02_13_exact_after := [llvm|
{
^0(%arg120 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def test12_after := [llvm|
{
^0(%arg9 : i32):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.icmp "ugt" %arg9, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def land_lor_right1_before := [llvm|
{
^0(%arg46 : i1, %arg47 : i1):
  %0 = llvm.mlir.constant(false) : i1
  %1 = llvm.mlir.constant(true) : i1
  %2 = "llvm.select"(%arg46, %arg47, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %3 = "llvm.select"(%arg46, %1, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def trunc_lshr_big_mask_after := [llvm|
{
^0(%arg8 : i8):
  %0 = llvm.mlir.constant(2 : i8) : i8
  %1 = llvm.mlir.constant(31 : i6) : i6
  %2 = llvm.lshr %arg8, %0 : i8
  %3 = llvm.trunc %2 overflow<nuw> : i8 to i6
  %4 = llvm.and %3, %1 : i6
  "llvm.return"(%4) : (i6) -> ()
}
]

def t_0_10_after := [llvm|
{
^0(%arg14 : i8):
  %0 = llvm.mlir.constant(10 : i8) : i8
  %1 = llvm.and %arg14, %0 : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def test67_before := [llvm|
{
^0(%arg113 : i1, %arg114 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(24 : i32) : i32
  %2 = llvm.mlir.constant(-16777216 : i32) : i32
  %3 = llvm.mlir.constant(0 : i8) : i8
  %4 = llvm.zext %arg113 : i1 to i32
  %5 = llvm.xor %4, %0 : i32
  %6 = llvm.and %arg114, %5 : i32
  %7 = llvm.shl %6, %1 overflow<nsw,nuw> : i32
  %8 = llvm.xor %7, %2 : i32
  %9 = llvm.ashr exact %8, %1 : i32
  %10 = llvm.trunc %9 : i32 to i8
  %11 = llvm.icmp "eq" %10, %3 : i8
  "llvm.return"(%11) : (i1) -> ()
}
]

def and_ranges_overlap_single_before := [llvm|
{
^0(%arg255 : i8):
  %0 = llvm.mlir.constant(5 : i8) : i8
  %1 = llvm.mlir.constant(10 : i8) : i8
  %2 = llvm.mlir.constant(20 : i8) : i8
  %3 = llvm.icmp "uge" %arg255, %0 : i8
  %4 = llvm.icmp "ule" %arg255, %1 : i8
  %5 = llvm.and %3, %4 : i1
  %6 = llvm.icmp "uge" %arg255, %1 : i8
  %7 = llvm.icmp "ule" %arg255, %2 : i8
  %8 = llvm.and %6, %7 : i1
  %9 = llvm.and %5, %8 : i1
  "llvm.return"(%9) : (i1) -> ()
}
]

def main9_after := [llvm|
{
^0(%arg26 : i32):
  %0 = llvm.mlir.constant(192 : i32) : i32
  %1 = llvm.mlir.constant(2 : i32) : i32
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.and %arg26, %0 : i32
  %4 = llvm.icmp "eq" %3, %0 : i32
  %5 = "llvm.select"(%4, %1, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def and_logic_and_logic_or_1_after := [llvm|
{
^0(%arg138 : i1, %arg139 : i1, %arg140 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.mlir.constant(false) : i1
  %2 = "llvm.select"(%arg139, %0, %arg140) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %3 = "llvm.select"(%arg138, %2, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def t15_before := [llvm|
{
^0(%arg198 : i32, %arg199 : i32):
  %0 = llvm.shl %arg198, %arg199 overflow<nuw> : i32
  %1 = llvm.udiv %0, %arg198 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def masked_icmps_mask_notallzeros_bmask_mixed_swapped_7_logical_before := [llvm|
{
^0(%arg33 : i32):
  %0 = llvm.mlir.constant(7 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(15 : i32) : i32
  %3 = llvm.mlir.constant(8 : i32) : i32
  %4 = llvm.mlir.constant(false) : i1
  %5 = llvm.and %arg33, %0 : i32
  %6 = llvm.icmp "ne" %5, %1 : i32
  %7 = llvm.and %arg33, %2 : i32
  %8 = llvm.icmp "eq" %7, %3 : i32
  %9 = "llvm.select"(%8, %6, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%9) : (i1) -> ()
}
]

def t0_after := [llvm|
{
^0(%arg32 : i8):
  %0 = llvm.mlir.constant(15 : i8) : i8
  %1 = llvm.mlir.constant(-16 : i8) : i8
  %2 = llvm.add %arg32, %0 : i8
  %3 = llvm.and %2, %1 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def ashrsgt_01_14_after := [llvm|
{
^0(%arg303 : i4):
  %0 = llvm.mlir.constant(-3 : i4) : i4
  %1 = llvm.icmp "sgt" %arg303, %0 : i4
  "llvm.return"(%1) : (i1) -> ()
}
]

def test3a_after := [llvm|
{
^0(%arg100 : i32):
  %0 = llvm.mlir.constant(7 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.and %arg100, %0 : i32
  %3 = llvm.icmp "ne" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def shl_and_add_after := [llvm|
{
^0(%arg156 : i8, %arg157 : i8):
  %0 = llvm.mlir.constant(59 : i8) : i8
  %1 = llvm.mlir.constant(1 : i8) : i8
  %2 = llvm.and %arg157, %0 : i8
  %3 = llvm.add %arg156, %2 : i8
  %4 = llvm.shl %3, %1 : i8
  "llvm.return"(%4) : (i8) -> ()
}
]

def ashr_1_after := [llvm|
{
^0(%arg97 : i8, %arg98 : i1, %arg99 : i8, %arg100 : i8):
  %0 = llvm.mlir.constant(-124 : i8) : i8
  %1 = llvm.xor %arg100, %0 : i8
  %2 = "llvm.select"(%arg98, %arg99, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  %3 = llvm.ashr %2, %arg97 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def absdiff1_before := [llvm|
{
^0(%arg2 : i64, %arg3 : i64):
  %0 = llvm.icmp "ult" %arg2, %arg3 : i64
  %1 = llvm.sext %0 : i1 to i64
  %2 = llvm.sub %arg2, %arg3 : i64
  %3 = llvm.xor %2, %1 : i64
  %4 = llvm.sub %3, %1 : i64
  "llvm.return"(%4) : (i64) -> ()
}
]

def lshr_exact_ne_0_after := [llvm|
{
^0(%arg121 : i32, %arg122 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.icmp "ne" %arg121, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def or_trunc_lshr_before := [llvm|
{
^0(%arg2 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.mlir.constant(-32 : i6) : i6
  %2 = llvm.lshr %arg2, %0 : i8
  %3 = llvm.trunc %2 : i8 to i6
  %4 = llvm.or %3, %1 : i6
  "llvm.return"(%4) : (i6) -> ()
}
]

def ashr_sgt_exact_after := [llvm|
{
^0(%arg167 : i8):
  %0 = llvm.mlir.constant(80 : i8) : i8
  %1 = llvm.icmp "sgt" %arg167, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

@[match_pattern] abbrev trunc (w w': Nat) (flags: NoWrapFlags := {}) : LLVM.Op :=
  MOp.trunc (.concrete w) (.concrete w') flags

def test1_after := [llvm|
{
^0(%arg34 : i32, %arg35 : i32):
  %0 = llvm.icmp "ugt" %arg35, %arg34 : i32
  "llvm.return"(%0) : (i1) -> ()
}
]

Std.Tactic.BVDecide.BVExpr.PackedBitVec.mk in Std.Tactic.BVDecide.Bitblast.BVExpr.Basic

def main4e_like_logical_before := [llvm|
{
^0(%arg125 : i32, %arg126 : i32, %arg127 : i32):
  %0 = llvm.mlir.constant(false) : i1
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.and %arg125, %arg126 : i32
  %4 = llvm.icmp "eq" %3, %arg126 : i32
  %5 = llvm.and %arg125, %arg127 : i32
  %6 = llvm.icmp "eq" %5, %arg127 : i32
  %7 = "llvm.select"(%4, %6, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %8 = "llvm.select"(%7, %1, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%8) : (i32) -> ()
}
]

def mul_add_to_mul_4_after := [llvm|
{
^0(%arg29 : i16):
  %0 = llvm.mlir.constant(9 : i16) : i16
  %1 = llvm.mul %arg29, %0 overflow<nsw> : i16
  "llvm.return"(%1) : (i16) -> ()
}
]

instance : AST.TransformExpr (MetaLLVM φ) φ := { mkExpr }

def uge_swap_and_max_commute_after := [llvm|
{
^0(%arg226 : i8, %arg227 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.icmp "eq" %arg226, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def scalar_i32_signbit_shl_and_eq_X_is_constant2_after := [llvm|
{
^0(%arg4 : i32):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

instance : Lean.ToExpr RegIndex := inherit

def shl_trunc_smaller_shl_after := [llvm|
{
^0(%arg39 : i32):
  %0 = llvm.mlir.constant(6 : i8) : i8
  %1 = llvm.trunc %arg39 : i32 to i8
  %2 = llvm.shl %1, %0 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def nonexact_lshr_eq_noexactlog_after := [llvm|
{
^0(%arg136 : i8):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def or_basic_commuted_after := [llvm|
{
^0(%arg14 : i16):
  %0 = llvm.mlir.constant(32581 : i16) : i16
  %1 = llvm.icmp "ne" %arg14, %0 : i16
  "llvm.return"(%1) : (i1) -> ()
}
]

def test44_before := [llvm|
{
^0(%arg203 : i32, %arg204 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg204, %0 : i32
  %2 = llvm.or %1, %arg203 : i32
  %3 = llvm.and %2, %arg204 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def two_inst_com_proof (w : Nat) :
    two_inst_com w ⊑ two_inst_com w :=

Quotient in Init.Core

def mkOutputAssignCircuitLeN {arity : Type _}
  [DecidableEq arity]
  [Fintype arity]
  [Hashable arity]
  (p : FSM arity) (n : Nat) :
  Circuit (Vars p.α arity (n + 1)) :=
    let ixs := List.range (n + 1) |>.attach
    let circs := ixs.map fun ⟨i, hi⟩ =>
      mkOutputAssignCircuitN p i |>.map (fun v => v.castLe (by admit /- proof elided -/
      ))
    Circuit.bigOr circs

def or_xor_tree_0011_after := [llvm|
{
^0(%arg36 : i32, %arg37 : i32, %arg38 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mul %arg36, %0 : i32
  %2 = llvm.mul %arg37, %0 : i32
  %3 = llvm.mul %arg38, %0 : i32
  %4 = llvm.xor %2, %1 : i32
  %5 = llvm.or %4, %3 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def test14_before := [llvm|
{
^0(%arg42 : i32, %arg43 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(-1431655767 : i32) : i32
  %2 = llvm.mlir.constant(1431655766 : i32) : i32
  %3 = llvm.add %arg43, %0 overflow<nsw> : i32
  %4 = llvm.or %arg42, %1 : i32
  %5 = llvm.xor %4, %2 : i32
  %6 = llvm.add %3, %5 overflow<nsw> : i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def and_xor_commute3_after := [llvm|
{
^0(%arg151 : i32, %arg152 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.udiv %0, %arg151 : i32
  %3 = llvm.udiv %0, %arg152 : i32
  %4 = llvm.xor %2, %1 : i32
  %5 = llvm.and %3, %4 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def or_xor_and_commuted1_after := [llvm|
{
^0(%arg50 : i32, %arg51 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.mul %arg51, %arg51 : i32
  %2 = llvm.xor %arg50, %0 : i32
  %3 = llvm.or %1, %2 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def constLLVM41 : Com LLVMPlusRiscV ⟨[]⟩ .pure (.llvm (.bitvec 64)) := [LV| {
  ^entry ():
    %1 = llvm.mlir.constant (41) : i64
    llvm.return %1 : i64
  }]

def a_or_b_const2_after := [llvm|
{
^0(%arg6 : i32, %arg7 : i32, %arg8 : i32, %arg9 : i32):
  %0 = llvm.icmp "eq" %arg6, %arg8 : i32
  %1 = llvm.icmp "eq" %arg7, %arg9 : i32
  %2 = llvm.xor %0, %1 : i1
  "llvm.return"(%2) : (i1) -> ()
}
]

def slt_zero_eq_ne_0_fail2_after := [llvm|
{
^0(%arg0 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.mlir.constant(30 : i32) : i32
  %2 = llvm.icmp "ne" %arg0, %0 : i32
  %3 = llvm.zext %2 : i1 to i32
  %4 = llvm.lshr %arg0, %1 : i32
  %5 = llvm.icmp "eq" %4, %3 : i32
  "llvm.return"(%5) : (i1) -> ()
}
]

def lshr_and_sub_after := [llvm|
{
^0(%arg53 : i8, %arg54 : i8):
  %0 = llvm.mlir.constant(42 : i8) : i8
  %1 = llvm.mlir.constant(2 : i8) : i8
  %2 = llvm.mlir.constant(13 : i8) : i8
  %3 = llvm.srem %arg53, %0 : i8
  %4 = llvm.lshr %arg54, %1 : i8
  %5 = llvm.and %4, %2 : i8
  %6 = llvm.sub %3, %5 overflow<nsw> : i8
  %7 = llvm.shl %6, %1 : i8
  "llvm.return"(%7) : (i8) -> ()
}
]

def main4_logical_after := [llvm|
{
^0(%arg133 : i32):
  %0 = llvm.mlir.constant(55 : i32) : i32
  %1 = llvm.and %arg133, %0 : i32
  %2 = llvm.icmp "ne" %1, %0 : i32
  %3 = llvm.zext %2 : i1 to i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def negation_of_increment_via_or_with_no_common_bits_set_before := [llvm|
{
^0(%arg71 : i8, %arg72 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.shl %arg72, %0 : i8
  %2 = llvm.or %1, %0 : i8
  %3 = llvm.sub %arg71, %2 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

structure Item where
 name : String
 tac : Syntax

def shl_nsw_nuw_add_nuw_before := [llvm|
{
^0(%arg12 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.shl %0, %arg12 overflow<nsw,nuw> : i32
  %3 = llvm.add %2, %1 overflow<nuw> : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def lshrugt_03_10_before := [llvm|
{
^0(%arg373 : i4):
  %0 = llvm.mlir.constant(3 : i4) : i4
  %1 = llvm.mlir.constant(-6 : i4) : i4
  %2 = llvm.lshr %arg373, %0 : i4
  %3 = llvm.icmp "ugt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def ashrslt_03_12_exact_after := [llvm|
{
^0(%arg9 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def t8_before := [llvm|
{
^0(%arg5 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.sub %0, %arg5 overflow<nsw> : i8
  %2 = llvm.icmp "eq" %1, %arg5 : i8
  "llvm.return"(%2) : (i1) -> ()
}
]

def logical_and_logical_and_icmps_comm2_after := [llvm|
{
^0(%arg202 : i8, %arg203 : i8, %arg204 : i8):
  %0 = llvm.mlir.constant(42 : i8) : i8
  %1 = llvm.mlir.constant(1 : i8) : i8
  %2 = llvm.mlir.constant(0 : i8) : i8
  %3 = llvm.mlir.constant(false) : i1
  %4 = llvm.icmp "eq" %arg203, %0 : i8
  %5 = llvm.and %arg202, %1 : i8
  %6 = llvm.shl %1, %arg204 overflow<nuw> : i8
  %7 = llvm.and %arg202, %6 : i8
  %8 = llvm.icmp "ne" %5, %2 : i8
  %9 = llvm.icmp "ne" %7, %2 : i8
  %10 = "llvm.select"(%8, %4, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %11 = "llvm.select"(%10, %9, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%11) : (i1) -> ()
}
]

def add_constant_equal_with_the_top_bit_of_demandedbits_insertpt_after := [llvm|
{
^0(%arg4 : i32, %arg5 : i32):
  %0 = llvm.mlir.constant(16 : i32) : i32
  %1 = llvm.mlir.constant(24 : i32) : i32
  %2 = llvm.xor %arg4, %0 : i32
  %3 = llvm.or %2, %arg5 : i32
  %4 = llvm.and %3, %1 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def lshrult_03_02_before := [llvm|
{
^0(%arg333 : i4):
  %0 = llvm.mlir.constant(3 : i4) : i4
  %1 = llvm.mlir.constant(2 : i4) : i4
  %2 = llvm.lshr %arg333, %0 : i4
  %3 = llvm.icmp "ult" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def ugt_swap_and_not_min_commute_after := [llvm|
{
^0(%arg66 : i8, %arg67 : i8):
  %0 = llvm.icmp "ult" %arg67, %arg66 : i8
  "llvm.return"(%0) : (i1) -> ()
}
]

def llvm_sub_nuw_lower_riscv_16: LLVMPeepholeRewriteRefine 16 [Ty.llvm (.bitvec 16), Ty.llvm (.bitvec 16)] where
  lhs := llvm_sub_nuw_16
  rhs := sub_riscv_16

def xor_or_xor_common_op_commute3_before := [llvm|
{
^0(%arg74 : i32, %arg75 : i32, %arg76 : i32):
  %0 = llvm.xor %arg74, %arg76 : i32
  %1 = llvm.or %arg75, %arg74 : i32
  %2 = llvm.xor %0, %1 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def strictlyLTZero (expr: GenBVExpr w) (widthId : Nat) : BoolExpr GenBVPred :=
  negative expr widthId

def ugt_umax4_before := [llvm|
{
^0(%arg30 : i32, %arg31 : i32):
  %0 = llvm.mlir.constant(3 : i32) : i32
  %1 = llvm.add %arg30, %0 : i32
  %2 = llvm.icmp "ugt" %arg31, %1 : i32
  %3 = "llvm.select"(%2, %arg31, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %4 = llvm.icmp "ult" %1, %3 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def select_ashr_icmp_bad_before := [llvm|
{
^0(%arg45 : i32, %arg46 : i32, %arg47 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.icmp "eq" %arg45, %0 : i32
  %2 = llvm.ashr %arg47, %arg45 : i32
  %3 = "llvm.select"(%1, %2, %arg46) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def composeQuinaryAux' (p : FSM (Fin 5)) (q₀ q₁ q₂ q₃ q₄: FSM α) : FSM α :=
  p.compose (α)
    (λ _ => α)
    (λ _ i => i)
    (λ v =>
      v.cases q₀ fun v =>
        v.cases q₁ fun v =>
          v.cases q₂ fun v =>
            v.cases q₃ fun v =>
              v.cases q₄ fun v => v.elim0)

def mulh_to_lshr_32 : RISCVPeepholeRewrite [Ty.riscv (.bv)] where
  lhs := [LV| {
    ^entry (%x: !riscv.reg):
      %c = li (32) : !riscv.reg
      %0 = mulh %c, %x : !riscv.reg
      ret %0 : !riscv.reg
  }]
  rhs := [LV| {
    ^entry (%x: !riscv.reg):
      %c = li (59) : !riscv.reg
      %0 = sra %x, %c : !riscv.reg
      ret %0 : !riscv.reg
  }]

def and_shl_after := [llvm|
{
^0(%arg644 : i8, %arg645 : i8, %arg646 : i8, %arg647 : i8):
  %0 = llvm.and %arg644, %arg645 : i8
  %1 = llvm.shl %0, %arg647 : i8
  %2 = llvm.and %1, %arg646 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def masked_icmps_mask_notallzeros_bmask_mixed_7_before := [llvm|
{
^0(%arg78 : i32):
  %0 = llvm.mlir.constant(7 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(15 : i32) : i32
  %3 = llvm.mlir.constant(8 : i32) : i32
  %4 = llvm.and %arg78, %0 : i32
  %5 = llvm.icmp "ne" %4, %1 : i32
  %6 = llvm.and %arg78, %2 : i32
  %7 = llvm.icmp "eq" %6, %3 : i32
  %8 = llvm.and %5, %7 : i1
  "llvm.return"(%8) : (i1) -> ()
}
]

def pr40493_neg3_after := [llvm|
{
^0(%arg15 : i32):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.mlir.constant(4 : i32) : i32
  %2 = llvm.shl %arg15, %0 : i32
  %3 = llvm.and %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def example01 := [RV64_com| {
^bb0(%0 : !i64, %1 : !i64):
  
  
 
    %5 = "add"(%0, %0) : (!i64, !i64) -> (!i64)
  
  "ret" (%0) : (!i64) -> ()
 }]

def icmp_slt_0_and_icmp_ne_neg2_i32_fail_before := [llvm|
{
^0(%arg44 : i32):
  %0 = llvm.mlir.constant(-2 : i32) : i32
  %1 = llvm.mlir.constant(31 : i32) : i32
  %2 = llvm.icmp "ne" %arg44, %0 : i32
  %3 = llvm.zext %2 : i1 to i32
  %4 = llvm.lshr %arg44, %1 : i32
  %5 = llvm.and %4, %3 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def egLhs : Com SimpleReg ⟨[int]⟩ .pure [int] :=
  Com.var (cst 0) <|
  Com.var (add ⟨0, rfl⟩ ⟨1, rfl⟩) <| 
  Com.var (iterate (k := 0) (⟨0, rfl⟩) (
      Com.letPure (cst 0) <|
      Com.letPure (add ⟨0, rfl⟩ ⟨1, rfl⟩) 
      <| Com.rets [⟨0, rfl⟩]ₕ
  )) <|
  Com.rets [⟨0, rfl⟩]ₕ

def zero_sign_bit_before := [llvm|
{
^0(%arg31 : i16):
  %0 = llvm.mlir.constant(32767 : i16) : i16
  %1 = llvm.mlir.constant(512 : i16) : i16
  %2 = llvm.and %arg31, %0 : i16
  %3 = llvm.add %2, %1 : i16
  "llvm.return"(%3) : (i16) -> ()
}
]

def negative_with_nonuniform_bad_mask_logical_after := [llvm|
{
^0(%arg14 : i32):
  %0 = llvm.mlir.constant(1711276033 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(128 : i32) : i32
  %3 = llvm.mlir.constant(256 : i32) : i32
  %4 = llvm.and %arg14, %0 : i32
  %5 = llvm.icmp "eq" %4, %1 : i32
  %6 = llvm.add %arg14, %2 : i32
  %7 = llvm.icmp "ult" %6, %3 : i32
  %8 = llvm.and %5, %7 : i1
  "llvm.return"(%8) : (i1) -> ()
}
]

def not_signbit_zext_after := [llvm|
{
^0(%arg17 : i16):
  %0 = llvm.mlir.constant(-1 : i16) : i16
  %1 = llvm.icmp "sgt" %arg17, %0 : i16
  %2 = llvm.zext %1 : i1 to i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def t5_ugt_slt_0_after := [llvm|
{
^0(%arg51 : i32, %arg52 : i32, %arg53 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.mlir.constant(65535 : i32) : i32
  %2 = llvm.icmp "slt" %arg51, %0 : i32
  %3 = llvm.icmp "sgt" %arg51, %1 : i32
  %4 = "llvm.select"(%2, %arg52, %arg51) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %5 = "llvm.select"(%3, %arg53, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def ashr_bitwidth_mask_before := [llvm|
{
^0(%arg127 : i8, %arg128 : i8):
  %0 = llvm.mlir.constant(7 : i8) : i8
  %1 = llvm.ashr %arg127, %0 : i8
  %2 = llvm.and %1, %arg128 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def elabDefSignatureFor (dialect : Term) (alts : TSyntax ``matchAltsSig) : CommandElabM Unit := do
  let msg := (return m!"{exceptEmoji ·} Defining operation signature for {dialect} dialect")
  withTraceNode `LeanMLIR.Elab msg (collapsed := false) <| do
    let alts := getMatchAlts alts
    let alts ← do
      alts.mapM fun view => do
        trace[LeanMLIR.Elab] m!"Parsing match alternative with\n\
          \tpatterns: {view.patterns}\n\
          \tsignature: {view.rhs}"
        let rhs ← parseSignature view.rhs
        return { view with rhs }

    |

def ashr_32_add_zext_basic_after := [llvm|
{
^0(%arg9 : i32, %arg10 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg9, %0 : i32
  %2 = llvm.icmp "ugt" %arg10, %1 : i32
  %3 = llvm.zext %2 : i1 to i64
  "llvm.return"(%3) : (i64) -> ()
}
]

def or_ugt_after := [llvm|
{
^0(%arg58 : i8, %arg59 : i8):
  %0 = llvm.or %arg58, %arg59 : i8
  %1 = llvm.icmp "ne" %0, %arg58 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def and_orn_cmp_3_before := [llvm|
{
^0(%arg185 : i72, %arg186 : i72, %arg187 : i72):
  %0 = llvm.mlir.constant(42 : i72) : i72
  %1 = llvm.icmp "ugt" %arg185, %arg186 : i72
  %2 = llvm.icmp "ule" %arg185, %arg186 : i72
  %3 = llvm.icmp "ugt" %arg187, %0 : i72
  %4 = llvm.or %2, %3 : i1
  %5 = llvm.and %1, %4 : i1
  "llvm.return"(%5) : (i1) -> ()
}
]

def trunc_unsigned_both_before := [llvm|
{
^0(%arg56 : i16, %arg57 : i16):
  %0 = llvm.trunc %arg56 overflow<nsw,nuw> : i16 to i8
  %1 = llvm.trunc %arg57 overflow<nsw,nuw> : i16 to i8
  %2 = llvm.icmp "ult" %0, %1 : i8
  "llvm.return"(%2) : (i1) -> ()
}
]

def and_xor_or4_after := [llvm|
{
^0(%arg664 : i64, %arg665 : i64, %arg666 : i64):
  %0 = llvm.mlir.constant(42) : i64
  %1 = llvm.udiv %0, %arg665 : i64
  %2 = llvm.udiv %0, %arg666 : i64
  %3 = llvm.or %2, %1 : i64
  "llvm.return"(%3) : (i64) -> ()
}
]

def narrow_sext_and_before := [llvm|
{
^0(%arg56 : i16, %arg57 : i32):
  %0 = llvm.sext %arg56 : i16 to i32
  %1 = llvm.and %0, %arg57 : i32
  %2 = llvm.trunc %1 : i32 to i16
  "llvm.return"(%2) : (i16) -> ()
}
]

def trunc_shl_33_i32_i64_after := [llvm|
{
^0(%arg33 : i64):
  %0 = llvm.mlir.constant(0 : i32) : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

def and_zext_eq_even_before := [llvm|
{
^0(%arg33 : i32):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.icmp "eq" %arg33, %0 : i32
  %2 = llvm.zext %1 : i1 to i32
  %3 = llvm.and %arg33, %2 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def or_eq_with_one_bit_diff_constants1_logical_before := [llvm|
{
^0(%arg365 : i32):
  %0 = llvm.mlir.constant(50 : i32) : i32
  %1 = llvm.mlir.constant(51 : i32) : i32
  %2 = llvm.mlir.constant(true) : i1
  %3 = llvm.icmp "eq" %arg365, %0 : i32
  %4 = llvm.icmp "eq" %arg365, %1 : i32
  %5 = "llvm.select"(%3, %2, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%5) : (i1) -> ()
}
]

def or_xor_tree_1100_before := [llvm|
{
^0(%arg9 : i32, %arg10 : i32, %arg11 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mul %arg9, %0 : i32
  %2 = llvm.mul %arg10, %0 : i32
  %3 = llvm.mul %arg11, %0 : i32
  %4 = llvm.xor %1, %2 : i32
  %5 = llvm.xor %2, %3 : i32
  %6 = llvm.xor %1, %5 : i32
  %7 = llvm.or %6, %4 : i32
  "llvm.return"(%7) : (i32) -> ()
}
]

def masked_icmps_mask_notallzeros_bmask_mixed_7b_logical_before := [llvm|
{
^0(%arg75 : i32):
  %0 = llvm.mlir.constant(6 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(15 : i32) : i32
  %3 = llvm.mlir.constant(8 : i32) : i32
  %4 = llvm.mlir.constant(false) : i1
  %5 = llvm.and %arg75, %0 : i32
  %6 = llvm.icmp "ne" %5, %1 : i32
  %7 = llvm.and %arg75, %2 : i32
  %8 = llvm.icmp "eq" %7, %3 : i32
  %9 = "llvm.select"(%6, %8, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%9) : (i1) -> ()
}
]

def multiuse3_after := [llvm|
{
^0(%arg9 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(48 : i32) : i32
  %2 = llvm.mlir.constant(6 : i32) : i32
  %3 = llvm.mlir.constant(8064 : i32) : i32
  %4 = llvm.mlir.constant(15 : i32) : i32
  %5 = llvm.lshr %arg9, %0 : i32
  %6 = llvm.and %5, %1 : i32
  %7 = llvm.shl %arg9, %2 : i32
  %8 = llvm.and %7, %3 : i32
  %9 = llvm.lshr %arg9, %0 : i32
  %10 = llvm.and %9, %4 : i32
  %11 = llvm.or disjoint %6, %10 : i32
  %12 = llvm.or disjoint %11, %8 : i32
  "llvm.return"(%12) : (i32) -> ()
}
]

def PR42691_8_logical_after := [llvm|
{
^0(%arg328 : i32):
  %0 = llvm.mlir.constant(2147483647 : i32) : i32
  %1 = llvm.mlir.constant(-2147483635 : i32) : i32
  %2 = llvm.add %arg328, %0 : i32
  %3 = llvm.icmp "ult" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def ashrsgt_03_01_exact_before := [llvm|
{
^0(%arg68 : i4):
  %0 = llvm.mlir.constant(3 : i4) : i4
  %1 = llvm.mlir.constant(1 : i4) : i4
  %2 = llvm.ashr exact %arg68, %0 : i4
  %3 = llvm.icmp "sgt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def test85_before := [llvm|
{
^0(%arg60 : i32):
  %0 = llvm.mlir.constant(-16777216 : i32) : i32
  %1 = llvm.mlir.constant(23 : i32) : i32
  %2 = llvm.add %arg60, %0 overflow<nuw> : i32
  %3 = llvm.lshr exact %2, %1 : i32
  %4 = llvm.trunc %3 : i32 to i8
  "llvm.return"(%4) : (i8) -> ()
}
]

def llvm_mul_lower_riscv_nsw_flag_32 : LLVMPeepholeRewriteRefine 32 [Ty.llvm (.bitvec 32), Ty.llvm (.bitvec 32)] where
  lhs := mul_llvm_nsw_32
  rhs := mul_riscv_32

def alive_AndOrXor_1280_ABA___AB_src :=
[sllvm| {
^bb0(%A : i64, %B : i64):
  %v1 = llvm.mlir.constant -1 : i64
  %v2 = llvm.xor %A, %v1 : i64
  %v3 = llvm.or %v2, %B : i64
  %v4 = llvm.and %v3, %A : i64
  llvm.return %v4 : i64
}]

def test_after := [llvm|
{
^0(%arg0 : i26):
  "llvm.return"(%arg0) : (i26) -> ()
}
]

def not_and_and_not_commute1_before := [llvm|
{
^0(%arg561 : i32, %arg562 : i32, %arg563 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg562, %0 : i32
  %2 = llvm.xor %arg563, %0 : i32
  %3 = llvm.and %1, %arg561 : i32
  %4 = llvm.and %3, %2 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def ashrsgt_01_01_exact_after := [llvm|
{
^0(%arg100 : i4):
  %0 = llvm.mlir.constant(2 : i4) : i4
  %1 = llvm.icmp "sgt" %arg100, %0 : i4
  "llvm.return"(%1) : (i1) -> ()
}
]

inductive BasicBlock
  | mk (label : BlockLabel) (args : List VarName) (body : Body)

def lshr_exact_after := [llvm|
{
^0(%arg183 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.mlir.constant(63 : i8) : i8
  %2 = llvm.add %arg183, %0 : i8
  %3 = llvm.and %2, %1 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def demorgan_nand_before := [llvm|
{
^0(%arg38 : i8, %arg39 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.xor %arg38, %0 : i8
  %2 = llvm.and %1, %arg39 : i8
  %3 = llvm.xor %2, %0 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def mul? {w : Nat} (x y : BitVec w) : IntW w :=
  .value <| x * y

def shl_add_lshr_before := [llvm|
{
^0(%arg154 : i32, %arg155 : i32, %arg156 : i32):
  %0 = llvm.shl %arg154, %arg155 overflow<nuw> : i32
  %1 = llvm.add %0, %arg156 overflow<nuw> : i32
  %2 = llvm.lshr %1, %arg155 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def lshr_eq_msb_low_last_zero_after := [llvm|
{
^0(%arg177 : i8):
  %0 = llvm.mlir.constant(6 : i8) : i8
  %1 = llvm.icmp "ugt" %arg177, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

List.ofFn in Init.Data.List.OfFn

def scalar_i32_shl_and_negC_eq_after := [llvm|
{
^0(%arg31 : i32, %arg32 : i32):
  %0 = llvm.mlir.constant(262144 : i32) : i32
  %1 = llvm.shl %arg31, %arg32 : i32
  %2 = llvm.icmp "ult" %1, %0 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def n5_before := [llvm|
{
^0(%arg9 : i8, %arg10 : i8, %arg11 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.mlir.constant(2 : i8) : i8
  %2 = llvm.and %arg9, %0 : i8
  %3 = llvm.icmp "eq" %2, %1 : i8
  %4 = "llvm.select"(%3, %arg10, %arg11) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%4) : (i8) -> ()
}
]

def icmp {w : Nat} (c : IntPred) (x y : IntW w) : IntW 1 := do
  let x' ← x
  let y' ← y
  icmp? c x' y'

def test_negative_nuw_and_signed_pred_after := [llvm|
{
^0(%arg53 : i64):
  %0 = llvm.mlir.constant(7) : i64
  %1 = llvm.icmp "ugt" %arg53, %0 : i64
  "llvm.return"(%1) : (i1) -> ()
}
]

class SubstituteableTerminator (T : Type u) where
  substituteTerminator (σ : VarName → VarName) : T → T

def logical_and_logical_and_icmps_comm1_after := [llvm|
{
^0(%arg205 : i8, %arg206 : i8, %arg207 : i8):
  %0 = llvm.mlir.constant(42 : i8) : i8
  %1 = llvm.mlir.constant(1 : i8) : i8
  %2 = llvm.mlir.constant(0 : i8) : i8
  %3 = llvm.mlir.constant(false) : i1
  %4 = llvm.icmp "eq" %arg206, %0 : i8
  %5 = llvm.and %arg205, %1 : i8
  %6 = llvm.shl %1, %arg207 overflow<nuw> : i8
  %7 = llvm.and %arg205, %6 : i8
  %8 = llvm.icmp "ne" %5, %2 : i8
  %9 = llvm.icmp "ne" %7, %2 : i8
  %10 = "llvm.select"(%9, %4, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %11 = "llvm.select"(%10, %8, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%11) : (i1) -> ()
}
]

def lshr_32_add_zext_trunc_after := [llvm|
{
^0(%arg5 : i32, %arg6 : i32):
  %0 = llvm.add %arg5, %arg6 : i32
  %1 = llvm.icmp "ult" %0, %arg5 : i32
  %2 = llvm.zext %1 : i1 to i32
  %3 = llvm.add %0, %2 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def narrow_zext_ashr_keep_trunc_before := [llvm|
{
^0(%arg8 : i8, %arg9 : i8):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.sext %arg8 : i8 to i32
  %2 = llvm.sext %arg9 : i8 to i32
  %3 = llvm.add %1, %2 overflow<nsw> : i32
  %4 = llvm.ashr %3, %0 : i32
  %5 = llvm.trunc %4 : i32 to i8
  "llvm.return"(%5) : (i8) -> ()
}
]

def test_mul__nuw_is_safe_after := [llvm|
{
^0(%arg8 : i32):
  %0 = llvm.mlir.constant(268435457 : i32) : i32
  %1 = llvm.mlir.constant(9 : i32) : i32
  %2 = llvm.and %arg8, %0 : i32
  %3 = llvm.mul %2, %1 overflow<nuw> : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def shl_lshr_demand6_before := [llvm|
{
^0(%arg10 : i16):
  %0 = llvm.mlir.constant(-32624 : i16) : i16
  %1 = llvm.mlir.constant(4 : i16) : i16
  %2 = llvm.mlir.constant(4094 : i16) : i16
  %3 = llvm.shl %0, %arg10 : i16
  %4 = llvm.lshr %3, %1 : i16
  %5 = llvm.and %4, %2 : i16
  "llvm.return"(%5) : (i16) -> ()
}
]

def not_and_and_not_after := [llvm|
{
^0(%arg567 : i32, %arg568 : i32, %arg569 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.sdiv %0, %arg567 : i32
  %3 = llvm.or %arg568, %arg569 : i32
  %4 = llvm.xor %3, %1 : i32
  %5 = llvm.and %2, %4 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def f_before := [llvm|
{
^0(%arg0 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.or %arg0, %0 : i32
  %3 = llvm.srem %2, %0 : i32
  %4 = llvm.icmp "ne" %3, %1 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def zext_or_masked_bit_test_after := [llvm|
{
^0(%arg54 : i32, %arg55 : i32, %arg56 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.shl %0, %arg55 overflow<nuw> : i32
  %3 = llvm.and %2, %arg54 : i32
  %4 = llvm.icmp "ne" %3, %1 : i32
  %5 = llvm.icmp "eq" %arg56, %arg55 : i32
  %6 = llvm.or %4, %5 : i1
  %7 = llvm.zext %6 : i1 to i32
  "llvm.return"(%7) : (i32) -> ()
}
]

def lshrult_03_10_after := [llvm|
{
^0(%arg325 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def masked_or_allzeroes_logical_after := [llvm|
{
^0(%arg130 : i32):
  %0 = llvm.mlir.constant(7 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.and %arg130, %0 : i32
  %3 = llvm.icmp "eq" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def zext {w: Nat} (w': Nat) (x: IntW w) (flag : NonNegFlag := {nneg := false}) : IntW w' := do
  let x' <- x
  if flag.nneg ∧ x'.msb then
    .poison
  else
    zext? w' x'

def sge_smin1_before := [llvm|
{
^0(%arg79 : i32, %arg80 : i32):
  %0 = llvm.icmp "slt" %arg79, %arg80 : i32
  %1 = "llvm.select"(%0, %arg79, %arg80) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %2 = llvm.icmp "sge" %1, %arg79 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def n2_badmask_after := [llvm|
{
^0(%arg4 : i32, %arg5 : i32, %arg6 : i32, %arg7 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.and %arg6, %arg4 : i32
  %2 = llvm.xor %arg7, %0 : i32
  %3 = llvm.and %arg5, %2 : i32
  %4 = llvm.or %1, %3 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def shift_trunc_wrong_cmp_after := [llvm|
{
^0(%arg0 : i32):
  %0 = llvm.mlir.constant(24 : i32) : i32
  %1 = llvm.mlir.constant(1 : i8) : i8
  %2 = llvm.lshr %arg0, %0 : i32
  %3 = llvm.trunc %2 overflow<nuw> : i32 to i8
  %4 = llvm.icmp "slt" %3, %1 : i8
  "llvm.return"(%4) : (i1) -> ()
}
]

def trunc_equality_nsw_zext_after := [llvm|
{
^0(%arg16 : i32, %arg17 : i8):
  %0 = llvm.zext %arg17 : i8 to i32
  %1 = llvm.icmp "ne" %arg16, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

RV64.xnor in RISCV.Instructions

def testi64i32_ne_before := [llvm|
{
^0(%arg7 : i64):
  %0 = llvm.mlir.constant(32) : i64
  %1 = llvm.mlir.constant(31 : i32) : i32
  %2 = llvm.lshr %arg7, %0 : i64
  %3 = llvm.trunc %2 : i64 to i32
  %4 = llvm.trunc %arg7 : i64 to i32
  %5 = llvm.ashr %4, %1 : i32
  %6 = llvm.icmp "ne" %5, %3 : i32
  "llvm.return"(%6) : (i1) -> ()
}
]

def positive_biggershl_shlnuwnsw_before := [llvm|
{
^0(%arg44 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.mlir.constant(6 : i8) : i8
  %2 = llvm.ashr %arg44, %0 : i8
  %3 = llvm.shl %2, %1 overflow<nsw,nuw> : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def lshrugt_02_14_exact_after := [llvm|
{
^0(%arg191 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def wide_source_matching_signbits_before := [llvm|
{
^0(%arg5 : i32):
  %0 = llvm.mlir.constant(7 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.and %arg5, %0 : i32
  %3 = llvm.shl %1, %2 overflow<nsw> : i32
  %4 = llvm.trunc %3 : i32 to i8
  %5 = llvm.sext %4 : i8 to i24
  "llvm.return"(%5) : (i24) -> ()
}
]

def ashr_2_add_zext_basic_before := [llvm|
{
^0(%arg35 : i1, %arg36 : i1):
  %0 = llvm.mlir.constant(1 : i2) : i2
  %1 = llvm.zext %arg35 : i1 to i2
  %2 = llvm.zext %arg36 : i1 to i2
  %3 = llvm.add %1, %2 : i2
  %4 = llvm.ashr %3, %0 : i2
  "llvm.return"(%4) : (i2) -> ()
}
]

def lshrugt_03_03_exact_after := [llvm|
{
^0(%arg186 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def andcond.100.inv.inner.cond.in.outer.cond_before := [llvm|
{
^0(%arg55 : i1, %arg56 : i1, %arg57 : i8, %arg58 : i8, %arg59 : i8):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.mlir.constant(false) : i1
  %2 = llvm.xor %arg55, %0 : i1
  %3 = "llvm.select"(%2, %arg56, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %4 = "llvm.select"(%arg55, %arg57, %arg58) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  %5 = "llvm.select"(%3, %arg59, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%5) : (i8) -> ()
}
]

def andn_or_cmp_1_logical_after := [llvm|
{
^0(%arg173 : i37, %arg174 : i37, %arg175 : i37):
  %0 = llvm.mlir.constant(42 : i37) : i37
  %1 = llvm.mlir.constant(false) : i1
  %2 = llvm.icmp "sle" %arg173, %arg174 : i37
  %3 = llvm.icmp "ugt" %arg175, %0 : i37
  %4 = "llvm.select"(%2, %3, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def lshrugt_02_04_exact_after := [llvm|
{
^0(%arg201 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def lshrugt_02_04_after := [llvm|
{
^0(%arg395 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def ult_or_not_max_logical_after := [llvm|
{
^0(%arg44 : i8, %arg45 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.icmp "ne" %arg44, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def slt_swap_and_not_max_logical_before := [llvm|
{
^0(%arg116 : i8, %arg117 : i8):
  %0 = llvm.mlir.constant(127 : i8) : i8
  %1 = llvm.mlir.constant(false) : i1
  %2 = llvm.icmp "sgt" %arg117, %arg116 : i8
  %3 = llvm.icmp "ne" %arg116, %0 : i8
  %4 = "llvm.select"(%2, %3, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def ashrslt_02_12_exact_before := [llvm|
{
^0(%arg25 : i4):
  %0 = llvm.mlir.constant(2 : i4) : i4
  %1 = llvm.mlir.constant(-4 : i4) : i4
  %2 = llvm.ashr exact %arg25, %0 : i4
  %3 = llvm.icmp "slt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def test_with_5_after := [llvm|
{
^0(%arg315 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.icmp "eq" %arg315, %0 : i32
  %2 = llvm.zext %1 : i1 to i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def liRiscv38 := [LV| {
  ^entry ():
    %0 = "li"() {imm = 38 : !i64} : (!i64) -> (!i64)
    %1 = "builtin.unrealized_conversion_cast"(%0) : (!i64) -> (i64)
    llvm.return %1 : i64
  }]

@[simp_denote]
def icmp_ult_riscv_32 := [LV| {
  ^entry (%lhs: i32, %rhs: i32 ):
    %lhsr = "builtin.unrealized_conversion_cast"(%lhs) : (i32) -> (!i64)
    %rhsr = "builtin.unrealized_conversion_cast"(%rhs) : (i32) -> (!i64)
    %0 = sltu %lhsr, %rhsr : !i64
    %1 = "builtin.unrealized_conversion_cast"(%0) : (!i64) -> (i1)
    llvm.return %1 : i1
  }]

def not_is_canonical_before := [llvm|
{
^0(%arg87 : i32, %arg88 : i32):
  %0 = llvm.mlir.constant(1073741823 : i32) : i32
  %1 = llvm.mlir.constant(2 : i32) : i32
  %2 = llvm.xor %arg87, %0 : i32
  %3 = llvm.add %2, %arg88 : i32
  %4 = llvm.shl %3, %1 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def foo1_and_after := [llvm|
{
^0(%arg181 : i32, %arg182 : i32, %arg183 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.shl %0, %arg182 overflow<nuw> : i32
  %2 = llvm.shl %0, %arg183 overflow<nuw> : i32
  %3 = llvm.or %1, %2 : i32
  %4 = llvm.and %arg181, %3 : i32
  %5 = llvm.icmp "ne" %4, %3 : i32
  "llvm.return"(%5) : (i1) -> ()
}
]

def n13_overshift_before := [llvm|
{
^0(%arg7 : i32, %arg8 : i64, %arg9 : i32):
  %0 = llvm.mlir.constant(32 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.sub %0, %arg9 : i32
  %3 = llvm.lshr %arg7, %2 : i32
  %4 = llvm.add %arg9, %0 : i32
  %5 = llvm.zext %4 : i32 to i64
  %6 = llvm.shl %arg8, %5 : i64
  %7 = llvm.trunc %6 : i64 to i32
  %8 = llvm.and %3, %7 : i32
  %9 = llvm.icmp "ne" %8, %1 : i32
  "llvm.return"(%9) : (i1) -> ()
}
]

def icmp_equality_test_commute_icmp2_before := [llvm|
{
^0(%arg20 : i64, %arg21 : i64, %arg22 : i64):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.mlir.constant(false) : i1
  %2 = llvm.icmp "eq" %arg22, %arg20 : i64
  %3 = llvm.icmp "eq" %arg21, %arg22 : i64
  %4 = llvm.icmp "eq" %arg21, %arg20 : i64
  %5 = llvm.xor %3, %0 : i1
  %6 = "llvm.select"(%5, %4, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %7 = "llvm.select"(%2, %3, %6) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%7) : (i1) -> ()
}
]

def mul_of_bools_before := [llvm|
{
^0(%arg91 : i32, %arg92 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(2 : i32) : i32
  %2 = llvm.and %arg91, %0 : i32
  %3 = llvm.and %arg92, %0 : i32
  %4 = llvm.mul %2, %3 : i32
  %5 = llvm.icmp "ult" %4, %1 : i32
  "llvm.return"(%5) : (i1) -> ()
}
]

def add_const_const_sub_nsw_before := [llvm|
{
^0(%arg58 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.mlir.constant(-127 : i8) : i8
  %2 = llvm.add %arg58, %0 : i8
  %3 = llvm.sub %1, %2 overflow<nsw> : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def PR75692_1_after := [llvm|
{
^0(%arg3 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

private def levelParamsToMessageData (levelParams : List Name) : MessageData :=
  match levelParams with
  | []    => ""
  | u::us => Id.run do
    let mut m := m!".\{{u}"
    for u in us do
      m := m ++ ", " ++ toMessageData u
    return m ++ "}"

def sle_swap_and_min_logical_after := [llvm|
{
^0(%arg212 : i8, %arg213 : i8):
  %0 = llvm.mlir.constant(-128 : i8) : i8
  %1 = llvm.icmp "eq" %arg212, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def src_x_and_nmask_slt_after := [llvm|
{
^0(%arg19 : i8, %arg20 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.shl %0, %arg20 overflow<nsw> : i8
  %2 = llvm.icmp "sgt" %1, %arg19 : i8
  "llvm.return"(%2) : (i1) -> ()
}
]

def trunc_shl_7_i8_i64_before := [llvm|
{
^0(%arg37 : i64):
  %0 = llvm.mlir.constant(7) : i64
  %1 = llvm.shl %arg37, %0 : i64
  %2 = llvm.trunc %1 : i64 to i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def eq_smax3_after := [llvm|
{
^0(%arg59 : i32, %arg60 : i32):
  %0 = llvm.mlir.constant(3 : i32) : i32
  %1 = llvm.add %arg59, %0 : i32
  %2 = llvm.icmp "sge" %1, %arg60 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def lshrult_01_05_exact_before := [llvm|
{
^0(%arg144 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(5 : i4) : i4
  %2 = llvm.lshr exact %arg144, %0 : i4
  %3 = llvm.icmp "ult" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

liftM in Init.Prelude

def n12_after := [llvm|
{
^0(%arg0 : i32, %arg1 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.mlir.constant(2 : i32) : i32
  %2 = llvm.xor %arg0, %0 : i32
  %3 = llvm.add %arg1, %2 : i32
  %4 = llvm.add %3, %1 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def mullo_variant3_before := [llvm|
{
^0(%arg4 : i64, %arg5 : i64):
  %0 = llvm.mlir.constant(4294967295) : i64
  %1 = llvm.mlir.constant(32) : i64
  %2 = llvm.and %arg4, %0 : i64
  %3 = llvm.lshr %arg4, %1 : i64
  %4 = llvm.and %arg5, %0 : i64
  %5 = llvm.lshr %arg5, %1 : i64
  %6 = llvm.mul %4, %2 overflow<nuw> : i64
  %7 = llvm.mul %4, %3 overflow<nuw> : i64
  %8 = llvm.mul %5, %2 overflow<nuw> : i64
  %9 = llvm.add %8, %7 : i64
  %10 = llvm.shl %9, %1 : i64
  %11 = llvm.add %10, %6 : i64
  "llvm.return"(%11) : (i64) -> ()
}
]

def zext_sext_add_icmp_ugt_1_before := [llvm|
{
^0(%arg66 : i1, %arg67 : i1):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.zext %arg66 : i1 to i8
  %2 = llvm.sext %arg67 : i1 to i8
  %3 = llvm.add %1, %2 : i8
  %4 = llvm.icmp "ugt" %3, %0 : i8
  "llvm.return"(%4) : (i1) -> ()
}
]

def test10_commuted_after := [llvm|
{
^0(%arg194 : i32, %arg195 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg195, %arg194 : i32
  %2 = llvm.xor %arg194, %arg195 : i32
  %3 = llvm.xor %2, %0 : i32
  %4 = llvm.or %1, %3 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def and_logic_and_logic_or_2_before := [llvm|
{
^0(%arg135 : i1, %arg136 : i1, %arg137 : i1):
  %0 = llvm.mlir.constant(false) : i1
  %1 = llvm.mlir.constant(true) : i1
  %2 = llvm.and %arg135, %arg136 : i1
  %3 = "llvm.select"(%arg137, %arg135, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %4 = "llvm.select"(%2, %1, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def or_xor_commute2_before := [llvm|
{
^0(%arg164 : i32, %arg165 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.udiv %0, %arg164 : i32
  %2 = llvm.udiv %0, %arg165 : i32
  %3 = llvm.or %1, %2 : i32
  %4 = llvm.xor %3, %2 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def ashrsgt_01_13_exact_before := [llvm|
{
^0(%arg88 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(-3 : i4) : i4
  %2 = llvm.ashr exact %arg88, %0 : i4
  %3 = llvm.icmp "sgt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def fold_mask_cmps_to_false_logical_after := [llvm|
{
^0(%arg110 : i32):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def visitSRA : List (Σ Γ, LLVMPeepholeRewriteRefine 64 Γ) :=
  [⟨_, visitSRA_0⟩,
   ⟨_, visitSRA_Neg1⟩]

def NFA.msbLang : Language (BitVec 1) := { bvs  | bvs.getLast? = some 1 }

def Expr.KInductionCircuits.mkN (fsm : Expr) (n : Expr) : MetaM Expr :=
  mkAppM ``ReflectVerif.BvDecide.KInductionCircuits.mkN #[fsm, n]

def positive_samevar_shlnuwnsw_ashrexact_after := [llvm|
{
^0(%arg27 : i8, %arg28 : i8):
  "llvm.return"(%arg27) : (i8) -> ()
}
]

def and_two_ranges_to_mask_and_range_no_add_on_one_range_before := [llvm|
{
^0(%arg249 : i16):
  %0 = llvm.mlir.constant(12 : i16) : i16
  %1 = llvm.mlir.constant(16 : i16) : i16
  %2 = llvm.mlir.constant(28 : i16) : i16
  %3 = llvm.icmp "uge" %arg249, %0 : i16
  %4 = llvm.icmp "ult" %arg249, %1 : i16
  %5 = llvm.icmp "uge" %arg249, %2 : i16
  %6 = llvm.or %4, %5 : i1
  %7 = llvm.and %3, %6 : i1
  "llvm.return"(%7) : (i1) -> ()
}
]

def xor_nosignbit_select_ashr_before := [llvm|
{
^0(%arg4 : i32, %arg5 : i1):
  %0 = llvm.mlir.constant(2147418112 : i32) : i32
  %1 = llvm.mlir.constant(8 : i32) : i32
  %2 = llvm.xor %arg4, %0 : i32
  %3 = "llvm.select"(%arg5, %2, %arg4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %4 = llvm.ashr %3, %1 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def test5_after := [llvm|
{
^0(%arg23 : i32):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def icmp_slt_sext_ne_allones_nofold_after := [llvm|
{
^0(%arg3 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.icmp "ne" %arg3, %0 : i32
  %2 = llvm.sext %1 : i1 to i32
  %3 = llvm.icmp "sgt" %arg3, %2 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def testi64i32_after := [llvm|
{
^0(%arg8 : i64):
  %0 = llvm.mlir.constant(2147483648) : i64
  %1 = llvm.mlir.constant(4294967296) : i64
  %2 = llvm.add %arg8, %0 : i64
  %3 = llvm.icmp "ult" %2, %1 : i64
  "llvm.return"(%3) : (i1) -> ()
}
]

def positive_with_aggressive_icmp_logical_after := [llvm|
{
^0(%arg55 : i32):
  %0 = llvm.mlir.constant(128 : i32) : i32
  %1 = llvm.icmp "ult" %arg55, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def foo_before := [llvm|
{
^0(%arg0 : i1):
  %0 = llvm.zext %arg0 : i1 to i8
  "llvm.return"(%arg0) : (i1) -> ()
}
]

def add_mask_ashr27_i32_before := [llvm|
{
^0(%arg0 : i32):
  %0 = llvm.mlir.constant(27 : i32) : i32
  %1 = llvm.mlir.constant(8 : i32) : i32
  %2 = llvm.ashr %arg0, %0 : i32
  %3 = llvm.and %2, %1 : i32
  %4 = llvm.add %3, %2 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def or_xor_commute1_before := [llvm|
{
^0(%arg166 : i32, %arg167 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.udiv %0, %arg166 : i32
  %2 = llvm.udiv %0, %arg167 : i32
  %3 = llvm.or %2, %1 : i32
  %4 = llvm.xor %2, %3 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def or_or_logic_and_2_before := [llvm|
{
^0(%arg9 : i1, %arg10 : i1, %arg11 : i1):
  %0 = llvm.mlir.constant(false) : i1
  %1 = llvm.or %arg9, %arg10 : i1
  %2 = llvm.or %arg11, %arg9 : i1
  %3 = "llvm.select"(%2, %1, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def test48_before := [llvm|
{
^0(%arg137 : i8, %arg138 : i8):
  %0 = llvm.mlir.constant(8 : i32) : i32
  %1 = llvm.zext %arg138 : i8 to i32
  %2 = llvm.zext %arg137 : i8 to i32
  %3 = llvm.shl %2, %0 : i32
  %4 = llvm.or %3, %2 : i32
  %5 = llvm.zext %4 : i32 to i64
  "llvm.return"(%5) : (i64) -> ()
}
]

def ugt_umax2_after := [llvm|
{
^0(%arg34 : i32, %arg35 : i32):
  %0 = llvm.icmp "ugt" %arg35, %arg34 : i32
  "llvm.return"(%0) : (i1) -> ()
}
]

def inter (M N : NFA' n) : NFA' n := ⟨_, M.M.inter N.M⟩

partial def reflectFactor (e : Expr) : M Factor := do
  match_expr e with
  | HAnd.hAnd _bv _bv _bv _inst a b =>
     return Factor.and (← reflectFactor a) (← reflectFactor b)
  | HOr.hOr _bv _bv _bv _inst a b =>
     return Factor.or (← reflectFactor a) (← reflectFactor b)
  | HXor.hXor _bv _bv _bv _inst a b =>
     return Factor.xor (← reflectFactor a) (← reflectFactor b)
  | Complement.complement _bv _inst a =>
     return Factor.not (← reflectFactor a)
  | _ =>
    let s ← get
    match s.e2ix[e]? with
    | .some ix => return Factor.var ix
    | .none => do
       let ix := s.e2ix.size
       set { s with e2ix := s.e2ix.insert e ix }
       return .var ix

def mkCarryAssignCircuitNAux {arity : Type _}
  [DecidableEq arity]
  [Fintype arity]
  [Hashable arity]
  (p : FSM arity) (s : p.α) (n : Nat) : Circuit (Vars p.α arity (n + 1)) :=
    (p.nextStateCirc s).map fun v =>
      match v with
        | .inl t => Vars.stateN t n
        | .inr i => Vars.inputN i n

def mul_mask_notpow2_ne_after := [llvm|
{
^0(%arg19 : i8):
  %0 = llvm.mlir.constant(12 : i8) : i8
  %1 = llvm.mlir.constant(0 : i8) : i8
  %2 = llvm.mul %arg19, %0 : i8
  %3 = llvm.and %2, %0 : i8
  %4 = llvm.icmp "ne" %3, %1 : i8
  "llvm.return"(%4) : (i1) -> ()
}
]

def masked_icmps_mask_notallzeros_bmask_mixed_7b_after := [llvm|
{
^0(%arg76 : i32):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def uge_swap_and_max_logical_before := [llvm|
{
^0(%arg228 : i8, %arg229 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.mlir.constant(false) : i1
  %2 = llvm.icmp "ule" %arg229, %arg228 : i8
  %3 = llvm.icmp "eq" %arg228, %0 : i8
  %4 = "llvm.select"(%2, %3, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def test1_after := [llvm|
{
^0(%arg6 : i8, %arg7 : i8):
  %0 = llvm.add %arg6, %arg7 : i8
  "llvm.return"(%0) : (i8) -> ()
}
]

def trunc_equality_nuw_zext_after := [llvm|
{
^0(%arg20 : i32, %arg21 : i8):
  %0 = llvm.zext %arg21 : i8 to i32
  %1 = llvm.icmp "ne" %arg20, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def ashr_mul_times_3_div_2_exact_2_after := [llvm|
{
^0(%arg17 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.ashr exact %arg17, %0 : i32
  %2 = llvm.add %arg17, %1 overflow<nsw> : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def sext_diff_i1_xor_sub_before := [llvm|
{
^0(%arg15 : i64, %arg16 : i1, %arg17 : i1):
  %0 = llvm.sext %arg16 : i1 to i64
  %1 = llvm.sext %arg17 : i1 to i64
  %2 = llvm.xor %arg15, %0 : i64
  %3 = llvm.sub %0, %1 : i64
  "llvm.return"(%3) : (i64) -> ()
}
]

def and_xor_common_op_commute1_after := [llvm|
{
^0(%arg693 : i32, %arg694 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(43 : i32) : i32
  %2 = llvm.mlir.constant(-1 : i32) : i32
  %3 = llvm.udiv %0, %arg693 : i32
  %4 = llvm.udiv %1, %arg694 : i32
  %5 = llvm.xor %4, %2 : i32
  %6 = llvm.and %3, %5 : i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def PR42691_3_logical_after := [llvm|
{
^0(%arg338 : i32):
  %0 = llvm.mlir.constant(-2147483647 : i32) : i32
  %1 = llvm.icmp "ult" %arg338, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def irc_constants_AMinusC1MinusC2_neg2_1 : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%a: i64):
      %c1 = llvm.mlir.constant (-2) : i64
      %c2 = llvm.mlir.constant (1) : i64
      %0 = llvm.sub %a, %c1 : i64
      %1 = llvm.sub %0, %c2 : i64
      llvm.return %1 : i64
  }]
  rhs := [LV| {
    ^entry (%a: i64):
      %c1 = llvm.mlir.constant (-2) : i64
      %c2 = llvm.mlir.constant (1) : i64
      %0 = llvm.add %c1, %c2 : i64
      %1 = llvm.sub %a, %0 : i64
      llvm.return %1 : i64
  }]

def test12commuted_after := [llvm|
{
^0(%arg87 : i32, %arg88 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.and %arg87, %arg88 : i32
  %2 = llvm.xor %1, %0 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def scalar_i64_shl_ult_const_after := [llvm|
{
^0(%arg14 : i64):
  %0 = llvm.mlir.constant(549755813632) : i64
  %1 = llvm.mlir.constant(0) : i64
  %2 = llvm.and %arg14, %0 : i64
  %3 = llvm.icmp "eq" %2, %1 : i64
  "llvm.return"(%3) : (i1) -> ()
}
]

@[simp_llvm]
def const? (w : Nat) (i : Int): IntW w :=
  .value <| BitVec.ofInt w i

def icmp_equality_test_before := [llvm|
{
^0(%arg34 : i64, %arg35 : i64, %arg36 : i64):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.mlir.constant(false) : i1
  %2 = llvm.icmp "eq" %arg34, %arg36 : i64
  %3 = llvm.icmp "eq" %arg35, %arg36 : i64
  %4 = llvm.icmp "eq" %arg34, %arg35 : i64
  %5 = llvm.xor %3, %0 : i1
  %6 = "llvm.select"(%5, %4, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %7 = "llvm.select"(%2, %3, %6) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%7) : (i1) -> ()
}
]

def and_sext_multiuse_after := [llvm|
{
^0(%arg0 : i32, %arg1 : i32, %arg2 : i32, %arg3 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.icmp "sgt" %arg0, %arg1 : i32
  %2 = llvm.add %arg2, %arg3 : i32
  %3 = "llvm.select"(%1, %2, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def p1_scalar_urem_by_nonconst_after := [llvm|
{
^0(%arg18 : i32, %arg19 : i32):
  %0 = llvm.mlir.constant(128 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.and %arg18, %0 : i32
  %3 = llvm.icmp "eq" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def sext_before := [llvm|
{
^0(%arg7 : i4):
  %0 = llvm.mlir.constant(-8 : i4) : i4
  %1 = llvm.mlir.constant(-8 : i7) : i7
  %2 = llvm.xor %arg7, %0 : i4
  %3 = llvm.zext %2 : i4 to i7
  %4 = llvm.add %3, %1 overflow<nsw> : i7
  "llvm.return"(%4) : (i7) -> ()
}
]

def negative_with_wrong_mask_logical_after := [llvm|
{
^0(%arg10 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(128 : i32) : i32
  %3 = llvm.mlir.constant(256 : i32) : i32
  %4 = llvm.and %arg10, %0 : i32
  %5 = llvm.icmp "eq" %4, %1 : i32
  %6 = llvm.add %arg10, %2 : i32
  %7 = llvm.icmp "ult" %6, %3 : i32
  %8 = llvm.and %5, %7 : i1
  "llvm.return"(%8) : (i1) -> ()
}
]

def liRiscv30 := [LV| {
  ^entry ():
    %0 = "li"() {imm = 30 : !i64} : (!i64) -> (!i64)
    %1 = "builtin.unrealized_conversion_cast"(%0) : (!i64) -> (i64)
    llvm.return %1 : i64
  }]

CoeDep in Init.Coe

inductive Ty
| tokenstream : Ty
| tokenstream2 : Ty
| valuestream (w : Nat) : Ty 
| valuestream2 (w : Nat) : Ty 
| valuetokenstream (w : Nat) : Ty 
| variadicvaluetokenstream (w : Nat) : Ty 
deriving Inhabited, DecidableEq, Repr, Lean.ToExpr

def negate_lshr_after := [llvm|
{
^0(%arg108 : i8, %arg109 : i8):
  %0 = llvm.mlir.constant(7 : i8) : i8
  %1 = llvm.ashr %arg109, %0 : i8
  %2 = llvm.add %1, %arg108 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def udiv1_before := [llvm|
{
^0(%arg32 : i32, %arg33 : i32):
  %0 = llvm.udiv exact %arg32, %arg33 : i32
  %1 = llvm.mul %0, %arg33 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def icmp_uge_x_y_2_after := [llvm|
{
^0(%arg36 : i8, %arg37 : i8):
  %0 = llvm.mul %arg36, %arg36 : i8
  %1 = llvm.and %0, %arg37 : i8
  %2 = llvm.icmp "eq" %1, %0 : i8
  "llvm.return"(%2) : (i1) -> ()
}
]

def select_same_val_self : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 1), Ty.llvm (.bitvec 64) ] where
  lhs := [LV| {
    ^entry (%x: i64, %c: i1):
      %0 = llvm.select %c, %x, %x : i64
      llvm.return %0 : i64
  }]
  rhs := [LV| {
    ^entry (%x: i64, %c: i1):
      llvm.return %x : i64
  }]

def shl_nsw_add_nsw_nuw_after := [llvm|
{
^0(%arg19 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

def not_or_or_not_commute1_after := [llvm|
{
^0(%arg546 : i32, %arg547 : i32, %arg548 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.and %arg547, %arg548 : i32
  %2 = llvm.xor %1, %0 : i32
  %3 = llvm.or %arg546, %2 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def PR2330_before := [llvm|
{
^0(%arg369 : i32, %arg370 : i32):
  %0 = llvm.mlir.constant(8 : i32) : i32
  %1 = llvm.icmp "ult" %arg369, %0 : i32
  %2 = llvm.icmp "ult" %arg370, %0 : i32
  %3 = llvm.and %2, %1 : i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def test86_after := [llvm|
{
^0(%arg59 : i16):
  %0 = llvm.mlir.constant(4 : i16) : i16
  %1 = llvm.ashr %arg59, %0 : i16
  "llvm.return"(%1) : (i16) -> ()
}
]

private def attrVal5bint: AttrVal := [mlir_attr_val| -42 ]

def product.inits_nodup : inits m₁ m₂ |>.toList.Nodup :=

def alive_AndOrXor_2627_tgt  (w : Nat)  :=
[llvm( w )| {
^bb0(%a : _, %c : _, %b : _):
  %v1 = llvm.mlir.constant -1
  %v2 = llvm.xor %a, %v1
  %v3 = llvm.and %v2, %b
  %v4 = llvm.xor %a, %c
  %v5 = llvm.or %a, %b
  %v6 = llvm.xor %v3, %c
  llvm.return %v6
}]

def shl_bad_sub_i64_before := [llvm|
{
^0(%arg7 : i64):
  %0 = llvm.mlir.constant(67) : i64
  %1 = llvm.mlir.constant(1) : i64
  %2 = llvm.sub %0, %arg7 : i64
  %3 = llvm.shl %1, %2 : i64
  "llvm.return"(%3) : (i64) -> ()
}
]

def masked_icmps_mask_notallzeros_bmask_mixed_negated_swapped_3_logical_after := [llvm|
{
^0(%arg21 : i32):
  %0 = llvm.mlir.constant(15 : i32) : i32
  %1 = llvm.mlir.constant(8 : i32) : i32
  %2 = llvm.and %arg21, %0 : i32
  %3 = llvm.icmp "ne" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def attrDict0 : AttrDict 0 := [mlir_attr_dict| {}]

instance : Lean.ToExpr TestDialect.Op :=

def mul_of_pow2s_after := [llvm|
{
^0(%arg79 : i32, %arg80 : i32):
  %0 = llvm.mlir.constant(128 : i32) : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

def and_not_or_or_not_or_xor_commute2_after := [llvm|
{
^0(%arg319 : i32, %arg320 : i32, %arg321 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.sdiv %0, %arg319 : i32
  %3 = llvm.or %arg320, %arg321 : i32
  %4 = llvm.xor %arg320, %arg321 : i32
  %5 = llvm.or %4, %2 : i32
  %6 = llvm.and %3, %5 : i32
  %7 = llvm.xor %6, %1 : i32
  "llvm.return"(%7) : (i32) -> ()
}
]

def logic_or_logic_and_6_before := [llvm|
{
^0(%arg72 : i1, %arg73 : i1, %arg74 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.mlir.constant(false) : i1
  %2 = "llvm.select"(%arg73, %0, %arg72) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %3 = "llvm.select"(%arg72, %0, %arg74) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %4 = "llvm.select"(%3, %2, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def eq_210_before := [llvm|
{
^0(%arg128 : i32, %arg129 : i32):
  %0 = llvm.mlir.constant(8 : i32) : i32
  %1 = llvm.mlir.constant(16 : i32) : i32
  %2 = llvm.trunc %arg128 : i32 to i8
  %3 = llvm.lshr %arg128, %0 : i32
  %4 = llvm.trunc %3 : i32 to i8
  %5 = llvm.lshr %arg128, %1 : i32
  %6 = llvm.trunc %5 : i32 to i8
  %7 = llvm.trunc %arg129 : i32 to i8
  %8 = llvm.lshr %arg129, %0 : i32
  %9 = llvm.trunc %8 : i32 to i8
  %10 = llvm.lshr %arg129, %1 : i32
  %11 = llvm.trunc %10 : i32 to i8
  %12 = llvm.icmp "eq" %2, %7 : i8
  %13 = llvm.icmp "eq" %4, %9 : i8
  %14 = llvm.icmp "eq" %6, %11 : i8
  %15 = llvm.and %12, %13 : i1
  %16 = llvm.and %14, %15 : i1
  "llvm.return"(%16) : (i1) -> ()
}
]

def lshrugt_03_14_after := [llvm|
{
^0(%arg369 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

Lean.mkAtom in Init.Prelude

def shl_add_nuw_and_nsw_before := [llvm|
{
^0(%arg12 : i8, %arg13 : i8):
  %0 = llvm.mlir.constant(31 : i8) : i8
  %1 = llvm.mlir.constant(2 : i8) : i8
  %2 = llvm.and %arg12, %0 : i8
  %3 = llvm.and %arg13, %1 : i8
  %4 = llvm.shl %2, %3 : i8
  "llvm.return"(%4) : (i8) -> ()
}
]

def foo3_after := [llvm|
{
^0(%arg2 : i1, %arg3 : i1):
  "llvm.return"(%arg2) : (i1) -> ()
}
]

def p0_scalar_urem_by_const_before := [llvm|
{
^0(%arg20 : i32, %arg21 : i32):
  %0 = llvm.mlir.constant(128 : i32) : i32
  %1 = llvm.mlir.constant(6 : i32) : i32
  %2 = llvm.mlir.constant(0 : i32) : i32
  %3 = llvm.and %arg20, %0 : i32
  %4 = llvm.urem %3, %1 : i32
  %5 = llvm.icmp "eq" %4, %2 : i32
  "llvm.return"(%5) : (i1) -> ()
}
]

def canonicalize_icmp_sle_neg1 : LLVMPeepholeRewriteRefine 1 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%x: i64):
      %c = llvm.mlir.constant -1 : i64
      %1 = llvm.icmp.sle %c, %x : i64
      llvm.return %1 : i1
  }]
  rhs := [LV| {
    ^entry (%x: i64):
      %c = llvm.mlir.constant -1 : i64
      %1 = llvm.icmp.sge %x, %c : i64
      llvm.return %1 : i1
  }]

def test7_after := [llvm|
{
^0(%arg16 : i77):
  %0 = llvm.mlir.constant(-1 : i77) : i77
  %1 = llvm.xor %arg16, %0 : i77
  "llvm.return"(%1) : (i77) -> ()
}
]

def test_shl_nsw__nsw_is_safe_before := [llvm|
{
^0(%arg73 : i32):
  %0 = llvm.mlir.constant(-83886080 : i32) : i32
  %1 = llvm.mlir.constant(-83886079 : i32) : i32
  %2 = llvm.mlir.constant(2 : i32) : i32
  %3 = llvm.mlir.constant(-335544316 : i32) : i32
  %4 = llvm.or %arg73, %0 : i32
  %5 = llvm.icmp "eq" %4, %1 : i32
  %6 = llvm.shl %4, %2 overflow<nsw> : i32
  %7 = "llvm.select"(%5, %3, %6) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %8 = llvm.mul %7, %4 : i32
  %9 = llvm.mul %8, %6 : i32
  "llvm.return"(%9) : (i32) -> ()
}
]

def worklistRun'_spec :
    (worklistRun' A S final inits hinits f |>.Sim $ nfa inits final f) :=

def ashrsgt_02_01_before := [llvm|
{
^0(%arg300 : i4):
  %0 = llvm.mlir.constant(2 : i4) : i4
  %1 = llvm.mlir.constant(1 : i4) : i4
  %2 = llvm.ashr %arg300, %0 : i4
  %3 = llvm.icmp "sgt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def ashrsgt_01_01_after := [llvm|
{
^0(%arg316 : i4):
  %0 = llvm.mlir.constant(3 : i4) : i4
  %1 = llvm.icmp "sgt" %arg316, %0 : i4
  "llvm.return"(%1) : (i1) -> ()
}
]

def select_constants_and_icmp_ne0_common_bit_after := [llvm|
{
^0(%arg18 : i1, %arg19 : i1):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def lshrugt_01_00_exact_after := [llvm|
{
^0(%arg221 : i4):
  %0 = llvm.mlir.constant(0 : i4) : i4
  %1 = llvm.icmp "ne" %arg221, %0 : i4
  "llvm.return"(%1) : (i1) -> ()
}
]

def logic_or_logic_and_8_before := [llvm|
{
^0(%arg66 : i1, %arg67 : i1, %arg68 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.mlir.constant(false) : i1
  %2 = "llvm.select"(%arg66, %0, %arg67) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %3 = "llvm.select"(%arg68, %0, %arg66) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %4 = "llvm.select"(%3, %2, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def test22_after := [llvm|
{
^0(%arg9 : i14):
  %0 = llvm.mlir.constant(127 : i14) : i14
  %1 = llvm.mlir.constant(0 : i14) : i14
  %2 = llvm.and %arg9, %0 : i14
  %3 = llvm.icmp "eq" %2, %1 : i14
  "llvm.return"(%3) : (i1) -> ()
}
]

def test66_after := [llvm|
{
^0(%arg41 : i64):
  %0 = llvm.mlir.constant(4294967296) : i64
  %1 = llvm.mlir.constant(0) : i64
  %2 = llvm.mlir.constant(42 : i32) : i32
  %3 = llvm.mlir.constant(40 : i32) : i32
  %4 = llvm.and %arg41, %0 : i64
  %5 = llvm.icmp "eq" %4, %1 : i64
  %6 = "llvm.select"(%5, %2, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def throwUBIf [Pure m] (p : Prop) [Decidable p] : m Unit :=
  if p then HasUB.throwUB else pure ()

def positive_biggerShl_before := [llvm|
{
^0(%arg34 : i32):
  %0 = llvm.mlir.constant(10 : i32) : i32
  %1 = llvm.mlir.constant(5 : i32) : i32
  %2 = llvm.shl %arg34, %0 : i32
  %3 = llvm.lshr %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def const? (w : Nat) (i : Int): IntW w :=
  .value <| BitVec.ofInt w i

def ugt_swap_or_not_min_logical_after := [llvm|
{
^0(%arg4 : i8, %arg5 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.icmp "ne" %arg4, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def lshr_or_or_fail_after := [llvm|
{
^0(%arg150 : i8, %arg151 : i8):
  %0 = llvm.mlir.constant(5 : i8) : i8
  %1 = llvm.mlir.constant(-58 : i8) : i8
  %2 = llvm.or %arg151, %arg150 : i8
  %3 = llvm.lshr %2, %0 : i8
  %4 = llvm.or %3, %1 : i8
  "llvm.return"(%4) : (i8) -> ()
}
]

def icmp_shl_ule_2_after := [llvm|
{
^0(%arg8 : i8):
  %0 = llvm.mlir.constant(42 : i8) : i8
  %1 = llvm.mlir.constant(-1 : i8) : i8
  %2 = llvm.add %arg8, %0 : i8
  %3 = llvm.icmp "sgt" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def zext_sext_add_icmp_ne_1_after := [llvm|
{
^0(%arg70 : i1, %arg71 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.xor %arg70, %0 : i1
  %2 = llvm.or %arg71, %1 : i1
  "llvm.return"(%2) : (i1) -> ()
}
]

def ashrslt_01_07_after := [llvm|
{
^0(%arg262 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

inductive ExOp :  Type
  | add : ExOp
  | beq : ExOp
  | cst : ℕ → ExOp
  deriving DecidableEq

def samesign_inverted_commute3_before := [llvm|
{
^0(%arg97 : i32, %arg98 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.and %arg97, %arg98 : i32
  %3 = llvm.icmp "sgt" %2, %0 : i32
  %4 = llvm.or %arg98, %arg97 : i32
  %5 = llvm.icmp "slt" %4, %1 : i32
  %6 = llvm.and %5, %3 : i1
  "llvm.return"(%6) : (i1) -> ()
}
]

def ripple_nsw3_after := [llvm|
{
^0(%arg19 : i16, %arg20 : i16):
  %0 = llvm.mlir.constant(-21845 : i16) : i16
  %1 = llvm.mlir.constant(21843 : i16) : i16
  %2 = llvm.and %arg20, %0 : i16
  %3 = llvm.and %arg19, %1 : i16
  %4 = llvm.add %2, %3 overflow<nsw,nuw> : i16
  "llvm.return"(%4) : (i16) -> ()
}
]

def RawCNFA.empty : RawCNFA A := {
  stateMax := 0
  initials := ∅
  finals := ∅
  trans := ∅
}

def slt_swap_or_not_max_commute_logical_after := [llvm|
{
^0(%arg48 : i8, %arg49 : i8):
  %0 = llvm.mlir.constant(127 : i8) : i8
  %1 = llvm.icmp "ne" %arg48, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def c_1_1_0_after := [llvm|
{
^0(%arg16 : i4, %arg17 : i4):
  %0 = llvm.mlir.constant(-2 : i4) : i4
  %1 = llvm.mlir.constant(1 : i4) : i4
  %2 = llvm.and %arg17, %0 : i4
  %3 = llvm.and %arg16, %1 : i4
  %4 = llvm.or disjoint %2, %3 : i4
  "llvm.return"(%4) : (i4) -> ()
}
]

def or_trunc_lshr_after := [llvm|
{
^0(%arg2 : i8):
  %0 = llvm.mlir.constant(1 : i6) : i6
  %1 = llvm.mlir.constant(-32 : i6) : i6
  %2 = llvm.trunc %arg2 : i8 to i6
  %3 = llvm.lshr %2, %0 : i6
  %4 = llvm.or disjoint %3, %1 : i6
  "llvm.return"(%4) : (i6) -> ()
}
]

def test2_before := [llvm|
{
^0(%arg0 : i999, %arg1 : i999):
  %0 = llvm.mlir.constant(65280 : i999) : i999
  %1 = llvm.and %arg0, %0 : i999
  %2 = llvm.and %arg1, %0 : i999
  %3 = llvm.icmp "ne" %1, %2 : i999
  "llvm.return"(%3) : (i1) -> ()
}
]

def eq_umin3_before := [llvm|
{
^0(%arg56 : i32, %arg57 : i32):
  %0 = llvm.mlir.constant(3 : i32) : i32
  %1 = llvm.add %arg56, %0 : i32
  %2 = llvm.icmp "ult" %1, %arg57 : i32
  %3 = "llvm.select"(%2, %1, %arg57) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %4 = llvm.icmp "eq" %1, %3 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def test_shift_negative_before := [llvm|
{
^0(%arg2 : i32, %arg3 : i32):
  %0 = llvm.mlir.constant(-2147483648 : i32) : i32
  %1 = llvm.mlir.constant(7 : i32) : i32
  %2 = llvm.mlir.constant(0 : i32) : i32
  %3 = llvm.or %arg2, %0 : i32
  %4 = llvm.and %arg3, %1 : i32
  %5 = llvm.shl %3, %4 overflow<nsw> : i32
  %6 = llvm.icmp "slt" %5, %2 : i32
  "llvm.return"(%6) : (i1) -> ()
}
]

def pr40493_neg1_before := [llvm|
{
^0(%arg17 : i32):
  %0 = llvm.mlir.constant(11 : i32) : i32
  %1 = llvm.mlir.constant(4 : i32) : i32
  %2 = llvm.mlir.constant(0 : i32) : i32
  %3 = llvm.mul %arg17, %0 : i32
  %4 = llvm.and %3, %1 : i32
  %5 = llvm.icmp "eq" %4, %2 : i32
  "llvm.return"(%5) : (i1) -> ()
}
]

@[simp_riscv]
def sextw_pseudo (rs1_val : BitVec 64) : BitVec 64 :=
  RV64.addiw 0 rs1_val

def select_icmp_sgt_allones_smin_before := [llvm|
{
^0(%arg3 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.mlir.constant(-128 : i8) : i8
  %2 = llvm.icmp "sgt" %arg3, %0 : i8
  %3 = llvm.xor %arg3, %1 : i8
  %4 = "llvm.select"(%2, %arg3, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%4) : (i8) -> ()
}
]

def test6_after := [llvm|
{
^0(%arg204 : i8):
  "llvm.return"(%arg204) : (i8) -> ()
}
]

def fold_sext_to_and_wrong7_before := [llvm|
{
^0(%arg3 : i8):
  %0 = llvm.mlir.constant(-2147483647 : i32) : i32
  %1 = llvm.mlir.constant(128 : i32) : i32
  %2 = llvm.sext %arg3 : i8 to i32
  %3 = llvm.and %2, %0 : i32
  %4 = llvm.icmp "ne" %3, %1 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def ashr_lshr_cst_before := [llvm|
{
^0(%arg105 : i32, %arg106 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(8 : i32) : i32
  %2 = llvm.icmp "slt" %arg105, %0 : i32
  %3 = llvm.lshr %arg105, %1 : i32
  %4 = llvm.ashr exact %arg105, %1 : i32
  %5 = "llvm.select"(%2, %4, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def urem_illegal_type_before := [llvm|
{
^0(%arg15 : i9, %arg16 : i9):
  %0 = llvm.zext %arg15 : i9 to i32
  %1 = llvm.zext %arg16 : i9 to i32
  %2 = llvm.urem %0, %1 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def ashrsgt_02_06_exact_before := [llvm|
{
^0(%arg79 : i4):
  %0 = llvm.mlir.constant(2 : i4) : i4
  %1 = llvm.mlir.constant(6 : i4) : i4
  %2 = llvm.ashr exact %arg79, %0 : i4
  %3 = llvm.icmp "sgt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def defaultParsedExprState : ParsedInputState := { maxFreeVarId := 0, maxWidthId := 1, widthIdToVariable := {},
                                                                 widthValToVar := {}
                                                                 , numSymVars := 0, originalWidth := 32
                                                                , inputVarIdToVariable := {}, symVarToVal := {}
                                                                , symVarIdToVariable := {}, displayNameToVariable := {}, valToSymVar:= {}}

def src_x_and_nmask_sge_after := [llvm|
{
^0(%arg17 : i8, %arg18 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.shl %0, %arg18 overflow<nsw> : i8
  %2 = llvm.icmp "sle" %1, %arg17 : i8
  "llvm.return"(%2) : (i1) -> ()
}
]

def lshr_and_or_disjoint_after := [llvm|
{
^0(%arg43 : i8, %arg44 : i8):
  %0 = llvm.mlir.constant(42 : i8) : i8
  %1 = llvm.mlir.constant(2 : i8) : i8
  %2 = llvm.mlir.constant(52 : i8) : i8
  %3 = llvm.srem %arg43, %0 : i8
  %4 = llvm.shl %3, %1 : i8
  %5 = llvm.and %arg44, %2 : i8
  %6 = llvm.or disjoint %5, %4 : i8
  "llvm.return"(%6) : (i8) -> ()
}
]

def sgt_swap_and_min_after := [llvm|
{
^0(%arg344 : i8, %arg345 : i8):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def andn_or_cmp_4_logical_after := [llvm|
{
^0(%arg158 : i32, %arg159 : i32, %arg160 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(false) : i1
  %2 = llvm.icmp "ne" %arg158, %arg159 : i32
  %3 = llvm.icmp "ugt" %arg160, %0 : i32
  %4 = "llvm.select"(%2, %3, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

@[simp_denote]
def slt_riscv_i32 :=
  [LV| {
    ^entry (%arg0: i32, %arg1: i32):
    %a = "builtin.unrealized_conversion_cast" (%arg0) : (i32) -> (!i64)
    %b = "builtin.unrealized_conversion_cast" (%arg1) : (i32) -> (!i64)
    %0 = sext.w %a : !i64
    %1 = sext.w %b : !i64
    %2 = slt %0, %1 : !i64
    %3 = "builtin.unrealized_conversion_cast" (%2) : (!i64) -> (i32)
    llvm.return %3 : i32
  }]

SetRel.inv in Mathlib.Data.Rel

def positive_biggerlshr_after := [llvm|
{
^0(%arg60 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.mlir.constant(24 : i8) : i8
  %2 = llvm.lshr %arg60, %0 : i8
  %3 = llvm.and %2, %1 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def or_nosignbit_lshr_after := [llvm|
{
^0(%arg12 : i32):
  %0 = llvm.mlir.constant(8 : i32) : i32
  %1 = llvm.mlir.constant(8388352 : i32) : i32
  %2 = llvm.lshr %arg12, %0 : i32
  %3 = llvm.or %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def shl_add_lshr_flag_preservation_after := [llvm|
{
^0(%arg157 : i32, %arg158 : i32, %arg159 : i32):
  %0 = llvm.lshr exact %arg159, %arg158 : i32
  %1 = llvm.add %0, %arg157 overflow<nsw,nuw> : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def t0_before := [llvm|
{
^0(%arg12 : i8):
  %0 = llvm.mlir.constant(7 : i8) : i8
  %1 = llvm.shl %arg12, %0 : i8
  %2 = llvm.ashr %1, %0 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def ashrslt_03_06_exact_after := [llvm|
{
^0(%arg15 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def t2_symmetry_after := [llvm|
{
^0(%arg37 : i8, %arg38 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.xor %arg37, %0 : i8
  %2 = llvm.icmp "ule" %arg38, %1 : i8
  "llvm.return"(%2) : (i1) -> ()
}
]

def narrow_sext_xor_before := [llvm|
{
^0(%arg48 : i16, %arg49 : i32):
  %0 = llvm.sext %arg48 : i16 to i32
  %1 = llvm.xor %0, %arg49 : i32
  %2 = llvm.trunc %1 : i32 to i16
  "llvm.return"(%2) : (i16) -> ()
}
]

def redundant_binop_in_equality_XPlusYNeX : LLVMPeepholeRewriteRefine 1 [Ty.llvm (.bitvec 64), Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%x: i64, %y: i64):
      %0 = llvm.add %x, %y : i64
      %1 = llvm.icmp.ne %0, %x : i64
      llvm.return %1 : i1
  }]
  rhs := [LV| {
    ^entry (%x: i64, %y: i64):
      %0 = llvm.mlir.constant (0) : i64
      %1 = llvm.icmp.ne %y, %0 : i64
      llvm.return %1 : i1
  }]

def foo_before := [llvm|
{
^0(%arg0 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.mlir.constant(7 : i32) : i32
  %2 = llvm.or %0, %1 : i32
  %3 = llvm.and %arg0, %2 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def test7_after := [llvm|
{
^0(%arg96 : i64):
  %0 = llvm.mlir.constant(32) : i64
  %1 = llvm.lshr %arg96, %0 : i64
  %2 = llvm.zext nneg %1 : i64 to i92
  "llvm.return"(%2) : (i92) -> ()
}
]

def sgt_swap_and_min_commute_before := [llvm|
{
^0(%arg340 : i8, %arg341 : i8):
  %0 = llvm.mlir.constant(-128 : i8) : i8
  %1 = llvm.icmp "slt" %arg341, %arg340 : i8
  %2 = llvm.icmp "eq" %arg340, %0 : i8
  %3 = llvm.and %2, %1 : i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def uadd_sat_via_add_swapped_cmp_nonstrict_after := [llvm|
{
^0(%arg4 : i32, %arg5 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.add %arg4, %arg5 : i32
  %2 = llvm.icmp "ult" %arg5, %1 : i32
  %3 = "llvm.select"(%2, %1, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def clear_to_set_decomposebittest_after := [llvm|
{
^0(%arg13 : i8):
  %0 = llvm.mlir.constant(-128 : i8) : i8
  %1 = llvm.mlir.constant(-125 : i8) : i8
  %2 = llvm.and %arg13, %0 : i8
  %3 = llvm.xor %2, %1 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def test37_after := [llvm|
{
^0(%arg241 : i32):
  %0 = llvm.mlir.constant(7 : i32) : i32
  %1 = llvm.mlir.constant(240 : i32) : i32
  %2 = llvm.mul %arg241, %0 : i32
  %3 = llvm.and %2, %1 : i32
  %4 = llvm.zext nneg %3 : i32 to i64
  "llvm.return"(%4) : (i64) -> ()
}
]

def positive_sameconst_shlnsw_ashrexact_before := [llvm|
{
^0(%arg36 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.ashr exact %arg36, %0 : i8
  %2 = llvm.shl %1, %0 overflow<nsw> : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def sub_0xffffffffff_i64_test : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := sub_0xffffffffff_llvm_i64
  rhs :=  sub_0xffffffffff_riscv_i64

def or_logic_or_logic_and_7_after := [llvm|
{
^0(%arg30 : i1, %arg31 : i1, %arg32 : i1):
  %0 = llvm.mlir.constant(false) : i1
  %1 = llvm.mlir.constant(true) : i1
  %2 = "llvm.select"(%arg32, %arg31, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %3 = "llvm.select"(%arg30, %1, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def neg_slt_0_after := [llvm|
{
^0(%arg26 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.add %arg26, %0 : i8
  %2 = llvm.icmp "sgt" %1, %0 : i8
  "llvm.return"(%2) : (i1) -> ()
}
]

def src_is_mask_select_after := [llvm|
{
^0(%arg110 : i8, %arg111 : i8, %arg112 : i1):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.mlir.constant(15 : i8) : i8
  %2 = llvm.mlir.constant(123 : i8) : i8
  %3 = llvm.add %arg111, %0 : i8
  %4 = llvm.xor %arg111, %3 : i8
  %5 = "llvm.select"(%arg112, %4, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  %6 = llvm.xor %arg110, %2 : i8
  %7 = llvm.icmp "ugt" %6, %5 : i8
  "llvm.return"(%7) : (i1) -> ()
}
]

def or_not_and_commute7_before := [llvm|
{
^0(%arg516 : i32, %arg517 : i32, %arg518 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.or %arg517, %arg516 : i32
  %2 = llvm.xor %1, %0 : i32
  %3 = llvm.and %2, %arg518 : i32
  %4 = llvm.or %arg516, %arg518 : i32
  %5 = llvm.xor %4, %0 : i32
  %6 = llvm.and %5, %arg517 : i32
  %7 = llvm.or %3, %6 : i32
  "llvm.return"(%7) : (i32) -> ()
}
]

def masked_icmps_mask_notallzeros_bmask_mixed_7_after := [llvm|
{
^0(%arg78 : i32):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

noncomputable def R.toTensor {q n} (a : R q n) : List Int :=
  List.range a.repLength |>.map fun i =>
        a.coeff i |>.toInt

def and_orn_cmp_3_after := [llvm|
{
^0(%arg185 : i72, %arg186 : i72, %arg187 : i72):
  %0 = llvm.mlir.constant(42 : i72) : i72
  %1 = llvm.icmp "ugt" %arg185, %arg186 : i72
  %2 = llvm.icmp "ugt" %arg187, %0 : i72
  %3 = llvm.and %1, %2 : i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def ashrsgt_03_08_before := [llvm|
{
^0(%arg277 : i4):
  %0 = llvm.mlir.constant(3 : i4) : i4
  %1 = llvm.mlir.constant(-8 : i4) : i4
  %2 = llvm.ashr %arg277, %0 : i4
  %3 = llvm.icmp "sgt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def match_andAsRem_lshrAsDiv_shlAsMul_before := [llvm|
{
^0(%arg16 : i64):
  %0 = llvm.mlir.constant(63) : i64
  %1 = llvm.mlir.constant(6) : i64
  %2 = llvm.mlir.constant(9) : i64
  %3 = llvm.and %arg16, %0 : i64
  %4 = llvm.lshr %arg16, %1 : i64
  %5 = llvm.urem %4, %2 : i64
  %6 = llvm.shl %5, %1 : i64
  %7 = llvm.add %3, %6 : i64
  "llvm.return"(%7) : (i64) -> ()
}
]

def xor_signbit_shl_before := [llvm|
{
^0(%arg19 : i32):
  %0 = llvm.mlir.constant(-65536 : i32) : i32
  %1 = llvm.mlir.constant(8 : i32) : i32
  %2 = llvm.xor %arg19, %0 : i32
  %3 = llvm.shl %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def ashrslt_03_01_exact_before := [llvm|
{
^0(%arg20 : i4):
  %0 = llvm.mlir.constant(3 : i4) : i4
  %1 = llvm.mlir.constant(1 : i4) : i4
  %2 = llvm.ashr exact %arg20, %0 : i4
  %3 = llvm.icmp "slt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def lshrult_02_04_before := [llvm|
{
^0(%arg347 : i4):
  %0 = llvm.mlir.constant(2 : i4) : i4
  %1 = llvm.mlir.constant(4 : i4) : i4
  %2 = llvm.lshr %arg347, %0 : i4
  %3 = llvm.icmp "ult" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def foo1_and_signbit_lshr_after := [llvm|
{
^0(%arg136 : i32, %arg137 : i32, %arg138 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(-2147483648 : i32) : i32
  %2 = llvm.shl %0, %arg137 overflow<nuw> : i32
  %3 = llvm.lshr exact %1, %arg138 : i32
  %4 = llvm.or %2, %3 : i32
  %5 = llvm.and %arg136, %4 : i32
  %6 = llvm.icmp "ne" %5, %4 : i32
  "llvm.return"(%6) : (i1) -> ()
}
]

def lowmask_xor_zext_commute_after := [llvm|
{
^0(%arg219 : i8, %arg220 : i32):
  %0 = llvm.mul %arg220, %arg220 : i32
  %1 = llvm.trunc %0 : i32 to i8
  %2 = llvm.xor %arg219, %1 : i8
  %3 = llvm.zext %2 : i8 to i32
  "llvm.return"(%3) : (i32) -> ()
}
]

@[simp_denote]
def sdiv_riscv_32 := [LV| {
  ^entry (%reg1: i32, %reg2: i32):
    %0 = "builtin.unrealized_conversion_cast"(%reg1) : (i32) -> (!i64)
    %1 = "builtin.unrealized_conversion_cast"(%reg2) : (i32) -> (!i64)
    %2 = div %0, %1 : !i64
    %3 = "builtin.unrealized_conversion_cast"(%2) : (!i64) -> (i32)
    llvm.return %3 : i32
  }]

def test_shr_and_1_ne_0_samesign_after := [llvm|
{
^0(%arg9 : i32, %arg10 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.shl %0, %arg10 overflow<nuw> : i32
  %3 = llvm.and %arg9, %2 : i32
  %4 = llvm.icmp "ne" %3, %1 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def not_and_and_or_not_or_or_commute3_after := [llvm|
{
^0(%arg232 : i32, %arg233 : i32, %arg234 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.sdiv %0, %arg233 : i32
  %3 = llvm.xor %arg234, %2 : i32
  %4 = llvm.or %3, %arg232 : i32
  %5 = llvm.xor %4, %1 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def ashr_exact_poison_constant_fold_after := [llvm|
{
^0(%arg10 : i1, %arg11 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.mlir.constant(5 : i8) : i8
  %2 = llvm.ashr %arg11, %0 : i8
  %3 = "llvm.select"(%arg10, %2, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def and_or2_commuted_before := [llvm|
{
^0(%arg194 : i1, %arg195 : i1, %arg196 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.xor %arg196, %0 : i1
  %2 = llvm.and %arg195, %1 : i1
  %3 = "llvm.select"(%2, %arg194, %arg195) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def t3_singlebit_before := [llvm|
{
^0(%arg38 : i32, %arg39 : i32):
  %0 = llvm.mlir.constant(32 : i32) : i32
  %1 = llvm.mlir.constant(-16 : i32) : i32
  %2 = llvm.mlir.constant(65536) : i64
  %3 = llvm.mlir.constant(0 : i32) : i32
  %4 = llvm.sub %0, %arg39 : i32
  %5 = llvm.shl %arg38, %4 : i32
  %6 = llvm.add %arg39, %1 : i32
  %7 = llvm.zext %6 : i32 to i64
  %8 = llvm.lshr %2, %7 : i64
  %9 = llvm.trunc %8 : i64 to i32
  %10 = llvm.and %5, %9 : i32
  %11 = llvm.icmp "ne" %10, %3 : i32
  "llvm.return"(%11) : (i1) -> ()
}
]

def lshr_pow2_ult_smin_after := [llvm|
{
^0(%arg60 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.icmp "ne" %arg60, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def ashr_sge_noexact_before := [llvm|
{
^0(%arg156 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.mlir.constant(10 : i8) : i8
  %2 = llvm.ashr %arg156, %0 : i8
  %3 = llvm.icmp "sge" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def add_or_sub_comb_i8_negative_y_add_after := [llvm|
{
^0(%arg4 : i8, %arg5 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.sub %0, %arg4 : i8
  %2 = llvm.or %arg4, %1 : i8
  %3 = llvm.add %2, %arg5 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def test1_before := [llvm|
{
^0(%arg153 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg153, %0 : i32
  %2 = llvm.xor %1, %0 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def shl_nsw_nuw_uge_Csle0_before := [llvm|
{
^0(%arg10 : i8, %arg11 : i8):
  %0 = llvm.mlir.constant(-120 : i8) : i8
  %1 = llvm.shl %arg10, %arg11 overflow<nsw,nuw> : i8
  %2 = llvm.icmp "uge" %1, %0 : i8
  "llvm.return"(%2) : (i1) -> ()
}
]

def trunc_shl_zext_32_before := [llvm|
{
^0(%arg1 : i32):
  %0 = llvm.mlir.constant(4 : i16) : i16
  %1 = llvm.trunc %arg1 : i32 to i16
  %2 = llvm.shl %1, %0 : i16
  %3 = llvm.zext %2 : i16 to i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def test_logical_or_eq_a_b_after := [llvm|
{
^0(%arg9 : i1, %arg10 : i8, %arg11 : i8):
  %0 = "llvm.select"(%arg9, %arg10, %arg11) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%0) : (i8) -> ()
}
]

def foo1_or_signbit_lshr_without_shifting_signbit_logical_after := [llvm|
{
^0(%arg109 : i32, %arg110 : i32, %arg111 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(false) : i1
  %3 = llvm.shl %0, %arg110 overflow<nuw> : i32
  %4 = llvm.and %3, %arg109 : i32
  %5 = llvm.icmp "ne" %4, %1 : i32
  %6 = llvm.shl %arg109, %arg111 : i32
  %7 = llvm.icmp "slt" %6, %1 : i32
  %8 = "llvm.select"(%5, %7, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%8) : (i1) -> ()
}
]

def lshr_and_after := [llvm|
{
^0(%arg59 : i64, %arg60 : i64):
  %0 = llvm.mlir.constant(42) : i64
  %1 = llvm.mlir.constant(12) : i64
  %2 = llvm.mlir.constant(7) : i64
  %3 = llvm.srem %arg60, %0 : i64
  %4 = llvm.lshr %arg59, %1 : i64
  %5 = llvm.lshr %3, %2 : i64
  %6 = llvm.and %4, %5 : i64
  "llvm.return"(%6) : (i64) -> ()
}
]

def lshr_pow2_ugt1_after := [llvm|
{
^0(%arg68 : i8):
  %0 = llvm.mlir.constant(7 : i8) : i8
  %1 = llvm.icmp "ult" %arg68, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def t0_sub_of_trueval_before := [llvm|
{
^0(%arg13 : i1, %arg14 : i8, %arg15 : i8):
  %0 = "llvm.select"(%arg13, %arg14, %arg15) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  %1 = llvm.sub %0, %arg14 : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def icmp_select_var_both_fold_after := [llvm|
{
^0(%arg80 : i8, %arg81 : i8, %arg82 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.icmp "eq" %arg80, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def test15_after := [llvm|
{
^0(%arg6 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(8 : i32) : i32
  %2 = llvm.ashr %arg6, %0 : i32
  %3 = llvm.sub %1, %2 overflow<nsw> : i32
  %4 = llvm.sext %3 : i32 to i64
  "llvm.return"(%4) : (i64) -> ()
}
]

def select_sub_after := [llvm|
{
^0(%arg9 : i1, %arg10 : i17, %arg11 : i17):
  %0 = llvm.mlir.constant(0 : i17) : i17
  %1 = "llvm.select"(%arg9, %arg11, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i17, i17) -> i17
  %2 = llvm.sub %arg10, %1 : i17
  "llvm.return"(%2) : (i17) -> ()
}
]

def pr33078_2_after := [llvm|
{
^0(%arg4 : i8):
  %0 = llvm.mlir.constant(4 : i8) : i8
  %1 = llvm.ashr %arg4, %0 : i8
  %2 = llvm.sext %1 : i8 to i12
  "llvm.return"(%2) : (i12) -> ()
}
]

def masked_and_notallones_logical_after := [llvm|
{
^0(%arg128 : i32):
  %0 = llvm.mlir.constant(7 : i32) : i32
  %1 = llvm.and %arg128, %0 : i32
  %2 = llvm.icmp "ne" %1, %0 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def instantiate (as : List.Vector α φ) : ConcreteOrMVar α φ → α
  | .concrete w => w
  | .mvar i => as.get i

def icmp_sgt11_after := [llvm|
{
^0(%arg14 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.icmp "sgt" %arg14, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def ule_swap_or_not_min_commute_after := [llvm|
{
^0(%arg260 : i8, %arg261 : i8):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

@[inline]
def CNFA.autMsbSet : CNFA 1 :=
  ⟨RawCNFA.autMsbSet, RawCNFA.autMsbSet_wf⟩

def or_not_and_and_not_and_xor_commute1_after := [llvm|
{
^0(%arg286 : i32, %arg287 : i32, %arg288 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.and %arg288, %arg287 : i32
  %2 = llvm.xor %1, %0 : i32
  %3 = llvm.or %arg286, %2 : i32
  %4 = llvm.xor %arg287, %arg288 : i32
  %5 = llvm.and %4, %arg286 : i32
  %6 = llvm.xor %5, %3 : i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def lshrult_02_10_exact_after := [llvm|
{
^0(%arg123 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def icmp_ne_sext_slt_allones_nofold_after := [llvm|
{
^0(%arg4 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.icmp "slt" %arg4, %0 : i32
  %2 = llvm.sext %1 : i1 to i32
  %3 = llvm.icmp "ne" %arg4, %2 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def matchMulO: List (Σ Γ, LLVMPeepholeRewriteRefine 64 Γ) :=
  [⟨_, mulo_by_2_unsigned_signed⟩,
  ⟨_, mulo_by_2_unsigned⟩,
  ⟨_, mulo_by_2_signed⟩]

def sext_zext_uge_known_nonneg_op0_wide_before := [llvm|
{
^0(%arg6 : i16, %arg7 : i8):
  %0 = llvm.mlir.constant(12 : i8) : i8
  %1 = llvm.sext %arg6 : i16 to i32
  %2 = llvm.and %arg7, %0 : i8
  %3 = llvm.zext %2 : i8 to i32
  %4 = llvm.icmp "uge" %1, %3 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def ashrsgt_01_07_after := [llvm|
{
^0(%arg310 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def test_shl_nuw_nsw__all_are_safe_after := [llvm|
{
^0(%arg90 : i32, %arg91 : i64):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.mlir.constant(60 : i32) : i32
  %2 = llvm.shl %arg90, %0 : i32
  %3 = llvm.and %2, %1 : i32
  %4 = llvm.zext nneg %3 : i32 to i64
  %5 = llvm.ashr %arg91, %4 : i64
  "llvm.return"(%5) : (i64) -> ()
}
]

def or_eq_with_one_bit_diff_constants1_logical_before := [llvm|
{
^0(%arg365 : i32):
  %0 = llvm.mlir.constant(50 : i32) : i32
  %1 = llvm.mlir.constant(51 : i32) : i32
  %2 = llvm.mlir.constant(true) : i1
  %3 = llvm.icmp "eq" %arg365, %0 : i32
  %4 = llvm.icmp "eq" %arg365, %1 : i32
  %5 = "llvm.select"(%3, %2, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%5) : (i1) -> ()
}
]

def trunc_shl_7_i8_i64_after := [llvm|
{
^0(%arg37 : i64):
  %0 = llvm.mlir.constant(7 : i8) : i8
  %1 = llvm.trunc %arg37 : i64 to i8
  %2 = llvm.shl %1, %0 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def p_before := [llvm|
{
^0(%arg60 : i32, %arg61 : i32, %arg62 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.and %arg60, %arg62 : i32
  %2 = llvm.xor %arg62, %0 : i32
  %3 = llvm.and %2, %arg61 : i32
  %4 = llvm.or %1, %3 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def n11_after := [llvm|
{
^0(%arg5 : i32, %arg6 : i16):
  %0 = llvm.mlir.constant(30 : i16) : i16
  %1 = llvm.mlir.constant(-31 : i16) : i16
  %2 = llvm.sub %0, %arg6 : i16
  %3 = llvm.zext nneg %2 : i16 to i32
  %4 = llvm.shl %arg5, %3 : i32
  %5 = llvm.trunc %4 : i32 to i16
  %6 = llvm.add %arg6, %1 : i16
  %7 = llvm.shl %5, %6 : i16
  "llvm.return"(%7) : (i16) -> ()
}
]

def PR42691_4_after := [llvm|
{
^0(%arg337 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.icmp "slt" %arg337, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def function : Parser :=
  leading_parser argumentList >> arrow >> termParser

instance [DecidableEq α] : DecidableRel ((· ≤· ) : Circuit α → Circuit α → Prop) :=
  λ c₁ c₂ => decidable_of_iff (always_true ((~~~ c₁).or c₂)) <|
    by simp [always_true_iff, le_def, or_iff_not_imp_left]

def rotateleft_9_neg_mask_wide_amount_commute_after := [llvm|
{
^0(%arg29 : i9, %arg30 : i33):
  %0 = llvm.mlir.constant(0 : i33) : i33
  %1 = llvm.mlir.constant(8 : i33) : i33
  %2 = llvm.sub %0, %arg30 : i33
  %3 = llvm.and %arg30, %1 : i33
  %4 = llvm.and %2, %1 : i33
  %5 = llvm.zext %arg29 : i9 to i33
  %6 = llvm.shl %5, %3 overflow<nsw,nuw> : i33
  %7 = llvm.lshr %5, %4 : i33
  %8 = llvm.or %6, %7 : i33
  %9 = llvm.trunc %8 : i33 to i9
  "llvm.return"(%9) : (i9) -> ()
}
]

def select_sub_icmp_after := [llvm|
{
^0(%arg214 : i32, %arg215 : i32, %arg216 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.icmp "eq" %arg214, %0 : i32
  %2 = "llvm.select"(%1, %arg216, %arg215) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def test29_after := [llvm|
{
^0(%arg173 : i1):
  %0 = llvm.mlir.constant(915 : i32) : i32
  %1 = llvm.mlir.constant(113 : i32) : i32
  %2 = "llvm.select"(%arg173, %0, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def test1_after := [llvm|
{
^0(%arg309 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

def mul_splat_fold_before := [llvm|
{
^0(%arg161 : i32):
  %0 = llvm.mlir.constant(65537 : i32) : i32
  %1 = llvm.mlir.constant(16 : i32) : i32
  %2 = llvm.mul %arg161, %0 overflow<nuw> : i32
  %3 = llvm.lshr %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def ult_1_impliesF_eq_1_after := [llvm|
{
^0(%arg3 : i8, %arg4 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.mlir.constant(false) : i1
  %2 = llvm.icmp "ne" %arg3, %0 : i8
  %3 = llvm.icmp "eq" %arg4, %arg3 : i8
  %4 = "llvm.select"(%2, %3, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def LLVMIR_identity_combines_32 : List (Σ Γ, LLVMPeepholeRewriteRefine 32 Γ) := anyext_trunc_fold

def t3_before := [llvm|
{
^0(%arg23 : i8, %arg24 : i2):
  %0 = llvm.sext %arg24 : i2 to i8
  %1 = llvm.add %0, %arg23 : i8
  %2 = llvm.xor %1, %0 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def sle_swap_and_min_logical_after := [llvm|
{
^0(%arg212 : i8, %arg213 : i8):
  %0 = llvm.mlir.constant(-128 : i8) : i8
  %1 = llvm.icmp "eq" %arg212, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def main1_logical_before := [llvm|
{
^0(%arg158 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(2 : i32) : i32
  %3 = llvm.mlir.constant(false) : i1
  %4 = llvm.and %arg158, %0 : i32
  %5 = llvm.icmp "ne" %4, %1 : i32
  %6 = llvm.and %arg158, %2 : i32
  %7 = llvm.icmp "ne" %6, %1 : i32
  %8 = "llvm.select"(%5, %7, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %9 = "llvm.select"(%8, %2, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%9) : (i32) -> ()
}
]

def branch {Γ : Ctxt _} (c : Γ.Var (MLIR2DCPlus.Ty.valuestream 1)) (a : Γ.Var (MLIR2DCPlus.Ty.tokenstream)) : Expr (DCPlus) Γ .pure (.tokenstream2) :=
  Expr.mk
    (op := .branch)
    (ty_eq := rfl)
    (eff_le := by admit /- proof elided -/
    )
    (args := .cons c <| .cons a <| .nil)
    (regArgs := .nil)

def lshrult_02_12_exact_before := [llvm|
{
^0(%arg121 : i4):
  %0 = llvm.mlir.constant(2 : i4) : i4
  %1 = llvm.mlir.constant(-4 : i4) : i4
  %2 = llvm.lshr exact %arg121, %0 : i4
  %3 = llvm.icmp "ult" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

@[simp_denote]
def sext_riscv_i8_to_32 := [LV| {
  ^entry (%arg: i8):
    %0 = "builtin.unrealized_conversion_cast"(%arg) : (i8) -> (!i64)
    %1 = sext.b %0 : !i64
    %res = "builtin.unrealized_conversion_cast"(%1) : (!i64) -> (i32)
    llvm.return %res : i32
  }]

def ashr_ugt_13_after := [llvm|
{
^0(%arg101 : i4):
  %0 = llvm.mlir.constant(-5 : i4) : i4
  %1 = llvm.icmp "ugt" %arg101, %0 : i4
  "llvm.return"(%1) : (i1) -> ()
}
]

def ashrslt_01_15_exact_after := [llvm|
{
^0(%arg38 : i4):
  %0 = llvm.mlir.constant(-2 : i4) : i4
  %1 = llvm.icmp "slt" %arg38, %0 : i4
  "llvm.return"(%1) : (i1) -> ()
}
]

def gt_unsigned_to_large_negative_before := [llvm|
{
^0(%arg33 : i8):
  %0 = llvm.mlir.constant(-1024 : i32) : i32
  %1 = llvm.zext %arg33 : i8 to i32
  %2 = llvm.icmp "sgt" %1, %0 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def ashrsgt_01_04_before := [llvm|
{
^0(%arg313 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(4 : i4) : i4
  %2 = llvm.ashr %arg313, %0 : i4
  %3 = llvm.icmp "sgt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

noncomputable def toArgResult
    (mapOut : MatchVarResult lets v (.var matchLets matchExpr) w.appendInl mapIn) :
    let args := mapOut.getPureExpr_eq_some.choose
    MatchArgResult lets matchLets args matchExpr.args mapIn :=
  ⟨mapOut.1, by admit /- proof elided -/
  ⟩

def sle_swap_or_not_min_after := [llvm|
{
^0(%arg280 : i8, %arg281 : i8):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def NFA.msbCorrect : NFA.autMsbSet.correct msbSA msbLang :=

def liRiscv_18 := [LV| {
  ^entry ():
    %0 = "li"() {imm = -18 : !i64} : (!i64) -> (!i64)
    %1 = "builtin.unrealized_conversion_cast"(%0) : (!i64) -> (i64)
    llvm.return %1 : i64
  }]

def parseComFromFile (fileName : String) :
    IO (Option (Σ (Γ' : Ctxt LLVM.Ty) (eff : EffectKind) (ty : List LLVM.Ty), Com LLVM Γ' eff ty)) :=
  Com.parseFromFile LLVM fileName

def and_two_ranges_to_mask_and_range_no_add_on_one_range_after := [llvm|
{
^0(%arg249 : i16):
  %0 = llvm.mlir.constant(-20 : i16) : i16
  %1 = llvm.mlir.constant(11 : i16) : i16
  %2 = llvm.and %arg249, %0 : i16
  %3 = llvm.icmp "ugt" %2, %1 : i16
  "llvm.return"(%3) : (i1) -> ()
}
]

def compose [FinEnum arity] [DecidableEq arity] [Hashable arity]
    (new_arity : Type)        
    (q_arity : arity → Type)  
    (vars : ∀ (a : arity), q_arity a → new_arity)
    
    
    (q : ∀ (a : arity), FSM (q_arity a)) : 
    FSM new_arity :=
  { α := p.α ⊕ (Σ a, (q a).α),
    i := by admit /- proof elided -/

def src_x_or_mask_ne_before := [llvm|
{
^0(%arg3 : i8, %arg4 : i8, %arg5 : i1):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.mlir.constant(0 : i8) : i8
  %2 = llvm.lshr %0, %arg4 : i8
  %3 = "llvm.select"(%arg5, %2, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  %4 = llvm.xor %arg3, %0 : i8
  %5 = llvm.or %3, %4 : i8
  %6 = llvm.icmp "ne" %5, %0 : i8
  "llvm.return"(%6) : (i1) -> ()
}
]

def neg_mask_before := [llvm|
{
^0(%arg1 : i32, %arg2 : i16):
  %0 = llvm.mlir.constant(15 : i16) : i16
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.sext %arg2 : i16 to i32
  %3 = llvm.sub %arg1, %2 overflow<nsw> : i32
  %4 = llvm.lshr %arg2, %0 : i16
  %5 = llvm.zext %4 : i16 to i32
  %6 = llvm.sub %1, %5 overflow<nsw> : i32
  %7 = llvm.and %3, %6 : i32
  "llvm.return"(%7) : (i32) -> ()
}
]

def sub_to_add_0 : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%x: i64):
      %c = llvm.mlir.constant 0 : i64
      %1 = llvm.sub %x, %c : i64
      llvm.return %1 : i64
  }]
  rhs := [LV| {
    ^entry (%x: i64):
      %c = llvm.mlir.constant 0 : i64
      %1 = llvm.add %x, %c : i64
      llvm.return %1 : i64
  }]

def shift_xor_multiuse_and_after := [llvm|
{
^0(%arg124 : i32, %arg125 : i32):
  %0 = llvm.mlir.constant(4096 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(-2049 : i32) : i32
  %3 = llvm.and %arg124, %0 : i32
  %4 = llvm.icmp "eq" %3, %1 : i32
  %5 = llvm.and %arg125, %2 : i32
  %6 = "llvm.select"(%4, %5, %arg125) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %7 = llvm.mul %6, %5 : i32
  "llvm.return"(%7) : (i32) -> ()
}
]

def ne_smax4_before := [llvm|
{
^0(%arg41 : i32, %arg42 : i32):
  %0 = llvm.mlir.constant(3 : i32) : i32
  %1 = llvm.add %arg41, %0 : i32
  %2 = llvm.icmp "sgt" %arg42, %1 : i32
  %3 = "llvm.select"(%2, %arg42, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %4 = llvm.icmp "ne" %1, %3 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def test2_before := [llvm|
{
^0(%arg18 : i8):
  %0 = llvm.mlir.constant(7 : i32) : i32
  %1 = llvm.mlir.constant(3 : i32) : i32
  %2 = llvm.zext %arg18 : i8 to i32
  %3 = llvm.add %2, %0 : i32
  %4 = llvm.ashr %3, %1 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def shift_xor_multiuse_cmp_and_after := [llvm|
{
^0(%arg28 : i32, %arg29 : i32, %arg30 : i32, %arg31 : i32):
  %0 = llvm.mlir.constant(4096 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(2048 : i32) : i32
  %3 = llvm.and %arg28, %0 : i32
  %4 = llvm.icmp "eq" %3, %1 : i32
  %5 = llvm.and %arg29, %2 : i32
  %6 = "llvm.select"(%4, %5, %arg29) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %7 = "llvm.select"(%4, %arg31, %arg30) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %8 = llvm.mul %6, %7 : i32
  %9 = llvm.mul %8, %5 : i32
  "llvm.return"(%9) : (i32) -> ()
}
]

def trunc_lshr_zext_exact_after := [llvm|
{
^0(%arg11 : i8):
  %0 = llvm.mlir.constant(6 : i8) : i8
  %1 = llvm.lshr %arg11, %0 : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def PR42691_9_logical_after := [llvm|
{
^0(%arg326 : i32):
  %0 = llvm.mlir.constant(-14 : i32) : i32
  %1 = llvm.mlir.constant(2147483633 : i32) : i32
  %2 = llvm.add %arg326, %0 : i32
  %3 = llvm.icmp "ult" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def and_not_or_commute5_after := [llvm|
{
^0(%arg466 : i32, %arg467 : i32, %arg468 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.sdiv %0, %arg466 : i32
  %3 = llvm.sdiv %0, %arg468 : i32
  %4 = llvm.xor %arg467, %3 : i32
  %5 = llvm.and %4, %2 : i32
  %6 = llvm.xor %5, %1 : i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def test35_with_trunc_after := [llvm|
{
^0(%arg48 : i64):
  %0 = llvm.mlir.constant(2147483648) : i64
  %1 = llvm.mlir.constant(0) : i64
  %2 = llvm.mlir.constant(60 : i32) : i32
  %3 = llvm.mlir.constant(100 : i32) : i32
  %4 = llvm.and %arg48, %0 : i64
  %5 = llvm.icmp "eq" %4, %1 : i64
  %6 = "llvm.select"(%5, %2, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def ashr_ugt_2_before := [llvm|
{
^0(%arg112 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(2 : i4) : i4
  %2 = llvm.ashr %arg112, %0 : i4
  %3 = llvm.icmp "ugt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def alive_AddSub_1043_tgt  (w : Nat)  :=
[llvm( w )| {
^bb0(%C1 : _, %Z : _, %RHS : _):
  %v1 = llvm.not %C1
  %v2 = llvm.or %Z, %v1
  %v3 = llvm.and %Z, %C1
  %v4 = llvm.xor %v3, %C1
  %v5 = llvm.mlir.constant 1
  %v6 = llvm.add %v4, %v5
  %v7 = llvm.sub %RHS, %v2
  llvm.return %v7
}]

def lshrugt_02_15_before := [llvm|
{
^0(%arg384 : i4):
  %0 = llvm.mlir.constant(2 : i4) : i4
  %1 = llvm.mlir.constant(-1 : i4) : i4
  %2 = llvm.lshr %arg384, %0 : i4
  %3 = llvm.icmp "ugt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

reduceCtorEq in Lean.Meta.Tactic.Simp.BuiltinSimprocs.Core

def shl_lshr_pow2_const_negative_overflow1_before := [llvm|
{
^0(%arg70 : i16):
  %0 = llvm.mlir.constant(4096 : i16) : i16
  %1 = llvm.mlir.constant(6 : i16) : i16
  %2 = llvm.mlir.constant(8 : i16) : i16
  %3 = llvm.shl %0, %arg70 : i16
  %4 = llvm.lshr %3, %1 : i16
  %5 = llvm.and %4, %2 : i16
  "llvm.return"(%5) : (i16) -> ()
}
]

def mul130_low_before := [llvm|
{
^0(%arg12 : i130, %arg13 : i130):
  %0 = llvm.mlir.constant(36893488147419103231 : i130) : i130
  %1 = llvm.mlir.constant(65 : i130) : i130
  %2 = llvm.and %arg12, %0 : i130
  %3 = llvm.lshr %arg12, %1 : i130
  %4 = llvm.and %arg13, %0 : i130
  %5 = llvm.lshr %arg13, %1 : i130
  %6 = llvm.mul %5, %2 : i130
  %7 = llvm.mul %4, %3 : i130
  %8 = llvm.mul %4, %2 : i130
  %9 = llvm.add %6, %7 : i130
  %10 = llvm.shl %9, %1 : i130
  %11 = llvm.add %10, %8 : i130
  "llvm.return"(%11) : (i130) -> ()
}
]

def ult_1_impliesF_eq_1_after := [llvm|
{
^0(%arg3 : i8, %arg4 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.mlir.constant(false) : i1
  %2 = llvm.icmp "ne" %arg3, %0 : i8
  %3 = llvm.icmp "eq" %arg4, %arg3 : i8
  %4 = "llvm.select"(%2, %3, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def test15e_after := [llvm|
{
^0(%arg23 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(256 : i32) : i32
  %2 = llvm.shl %arg23, %0 : i32
  %3 = llvm.and %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

@[simp_denote]
def or_riscv_i32 :=
  [LV| {
    ^entry (%arg0: i32, %arg1: i32):
    %a = "builtin.unrealized_conversion_cast" (%arg0) : (i32) -> (!i64)
    %b = "builtin.unrealized_conversion_cast" (%arg1) : (i32) -> (!i64)
    %0 = or %a, %b : !i64
    %1 = "builtin.unrealized_conversion_cast" (%0) : (!i64) -> (i32)
    llvm.return %1 : i32
  }]

def lshrult_03_02_exact_before := [llvm|
{
^0(%arg115 : i4):
  %0 = llvm.mlir.constant(3 : i4) : i4
  %1 = llvm.mlir.constant(2 : i4) : i4
  %2 = llvm.lshr exact %arg115, %0 : i4
  %3 = llvm.icmp "ult" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def t0_after := [llvm|
{
^0(%arg14 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.icmp "slt" %arg14, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

instance : DecidableEq TestDialect.Ty :=

def not {Γ : Ctxt _} (a : Var Γ (.stream (.bitvec 1))) : Expr (Handshake) Γ .pure (.stream (.bitvec 1))  :=
  Expr.mk
    (op := .not)
    (ty_eq := rfl)
    (eff_le := by admit /- proof elided -/
    )
    (args := .cons a <| .nil)
    (regArgs := .nil)

def lshr_shl_pow2_const_case1_before := [llvm|
{
^0(%arg60 : i16):
  %0 = llvm.mlir.constant(256 : i16) : i16
  %1 = llvm.mlir.constant(2 : i16) : i16
  %2 = llvm.mlir.constant(8 : i16) : i16
  %3 = llvm.lshr %0, %arg60 : i16
  %4 = llvm.shl %3, %1 : i16
  %5 = llvm.and %4, %2 : i16
  "llvm.return"(%5) : (i16) -> ()
}
]

def sub_from_constant_of_sub_from_constant_before := [llvm|
{
^0(%arg186 : i8):
  %0 = llvm.mlir.constant(42 : i8) : i8
  %1 = llvm.mlir.constant(11 : i8) : i8
  %2 = llvm.sub %0, %arg186 : i8
  %3 = llvm.sub %1, %2 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def shrink_select_after := [llvm|
{
^0(%arg52 : i1, %arg53 : i32):
  %0 = llvm.mlir.constant(42 : i8) : i8
  %1 = llvm.trunc %arg53 : i32 to i8
  %2 = "llvm.select"(%arg52, %1, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def narrow_sext_mul_before := [llvm|
{
^0(%arg36 : i16, %arg37 : i32):
  %0 = llvm.sext %arg36 : i16 to i32
  %1 = llvm.mul %0, %arg37 : i32
  %2 = llvm.trunc %1 : i32 to i16
  "llvm.return"(%2) : (i16) -> ()
}
]

def different_size_sext_sext_eq_before := [llvm|
{
^0(%arg10 : i7, %arg11 : i4):
  %0 = llvm.sext %arg10 : i7 to i25
  %1 = llvm.sext %arg11 : i4 to i25
  %2 = llvm.icmp "eq" %0, %1 : i25
  "llvm.return"(%2) : (i1) -> ()
}
]

structure PreconditionSynthesisCacheValue where
  positiveExampleValues : List FpExprWrapper
  negativeExampleValues : List FpExprWrapper

def lshrugt_01_07_exact_before := [llvm|
{
^0(%arg214 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(7 : i4) : i4
  %2 = llvm.lshr exact %arg214, %0 : i4
  %3 = llvm.icmp "ugt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def zext_mul_before := [llvm|
{
^0(%arg13 : i8):
  %0 = llvm.mlir.constant(3 : i16) : i16
  %1 = llvm.zext %arg13 : i8 to i16
  %2 = llvm.mul %1, %0 : i16
  %3 = llvm.and %2, %1 : i16
  "llvm.return"(%3) : (i16) -> ()
}
]

def UnaryGt (largemask smallmask : BitVec o) : Prop :=
   UnaryLt smallmask largemask

def scalar_i8_shl_ult_const_1_before := [llvm|
{
^0(%arg19 : i8):
  %0 = llvm.mlir.constant(5 : i8) : i8
  %1 = llvm.mlir.constant(64 : i8) : i8
  %2 = llvm.shl %arg19, %0 : i8
  %3 = llvm.icmp "ult" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def test22_after := [llvm|
{
^0(%arg9 : i14):
  %0 = llvm.mlir.constant(127 : i14) : i14
  %1 = llvm.mlir.constant(0 : i14) : i14
  %2 = llvm.and %arg9, %0 : i14
  %3 = llvm.icmp "eq" %2, %1 : i14
  "llvm.return"(%3) : (i1) -> ()
}
]

def t0_after := [llvm|
{
^0(%arg12 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.mlir.constant(0 : i8) : i8
  %2 = llvm.and %arg12, %0 : i8
  %3 = llvm.sub %1, %2 overflow<nsw> : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def shift_xor_multiuse_xor_before := [llvm|
{
^0(%arg126 : i32, %arg127 : i32):
  %0 = llvm.mlir.constant(4096 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(2048 : i32) : i32
  %3 = llvm.and %arg126, %0 : i32
  %4 = llvm.icmp "ne" %1, %3 : i32
  %5 = llvm.xor %arg127, %2 : i32
  %6 = "llvm.select"(%4, %arg127, %5) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %7 = llvm.mul %6, %5 : i32
  "llvm.return"(%7) : (i32) -> ()
}
]

def lshr_or_before := [llvm|
{
^0(%arg24 : i8):
  %0 = llvm.mlir.constant(16 : i8) : i8
  %1 = llvm.mlir.constant(1 : i8) : i8
  %2 = llvm.mlir.constant(3 : i8) : i8
  %3 = llvm.lshr %0, %arg24 : i8
  %4 = llvm.add %arg24, %1 : i8
  %5 = llvm.lshr %2, %4 : i8
  %6 = llvm.or %3, %5 : i8
  "llvm.return"(%6) : (i8) -> ()
}
]

def negate_lshr_before := [llvm|
{
^0(%arg124 : i8, %arg125 : i8):
  %0 = llvm.mlir.constant(7 : i8) : i8
  %1 = llvm.lshr %arg125, %0 : i8
  %2 = llvm.sub %arg124, %1 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def shl_nsw_nuw_uge_Csle0_after := [llvm|
{
^0(%arg10 : i8, %arg11 : i8):
  %0 = llvm.mlir.constant(-121 : i8) : i8
  %1 = llvm.icmp "ugt" %arg10, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def trunc_shl_16_i32_i64_before := [llvm|
{
^0(%arg34 : i64):
  %0 = llvm.mlir.constant(16) : i64
  %1 = llvm.shl %arg34, %0 : i64
  %2 = llvm.trunc %1 : i64 to i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def test_add_nuw__all_are_safe_after := [llvm|
{
^0(%arg46 : i32):
  %0 = llvm.mlir.constant(1073741823 : i32) : i32
  %1 = llvm.mlir.constant(1 : i32) : i32
  %2 = llvm.and %arg46, %0 : i32
  %3 = llvm.add %2, %1 overflow<nsw,nuw> : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def and_or_not_not_before := [llvm|
{
^0(%arg375 : i32, %arg376 : i32, %arg377 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.and %arg376, %arg375 : i32
  %2 = llvm.xor %1, %0 : i32
  %3 = llvm.and %arg375, %arg377 : i32
  %4 = llvm.xor %3, %0 : i32
  %5 = llvm.or %4, %arg376 : i32
  %6 = llvm.and %5, %2 : i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def t2_before := [llvm|
{
^0(%arg25 : i8, %arg26 : i1, %arg27 : i1):
  %0 = llvm.sext %arg26 : i1 to i8
  %1 = llvm.sext %arg27 : i1 to i8
  %2 = llvm.add %0, %arg25 : i8
  %3 = llvm.xor %2, %1 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def icmp_eq_sext_eq_otherwise_before := [llvm|
{
^0(%arg15 : i32):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.icmp "eq" %arg15, %0 : i32
  %2 = llvm.sext %1 : i1 to i32
  %3 = llvm.icmp "eq" %2, %arg15 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

Polynomial.monomial in Mathlib.Algebra.Polynomial.Basic

def uge_swap_and_max_commute_before := [llvm|
{
^0(%arg226 : i8, %arg227 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.icmp "ule" %arg227, %arg226 : i8
  %2 = llvm.icmp "eq" %arg226, %0 : i8
  %3 = llvm.and %2, %1 : i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def slt_or_not_max_logical_before := [llvm|
{
^0(%arg60 : i8, %arg61 : i8):
  %0 = llvm.mlir.constant(127 : i8) : i8
  %1 = llvm.mlir.constant(true) : i1
  %2 = llvm.icmp "slt" %arg60, %arg61 : i8
  %3 = llvm.icmp "ne" %arg60, %0 : i8
  %4 = "llvm.select"(%2, %1, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def not_ashr_not_before := [llvm|
{
^0(%arg139 : i32, %arg140 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg139, %0 : i32
  %2 = llvm.ashr %1, %arg140 : i32
  %3 = llvm.xor %2, %0 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def shl_nsw_add_negative_before := [llvm|
{
^0(%arg45 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.mlir.constant(2 : i32) : i32
  %2 = llvm.add %arg45, %0 : i32
  %3 = llvm.shl %1, %2 overflow<nsw> : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

instance : AST.TransformReturn Comb 0 := { mkReturn }

def positive_and_odd_ne_before := [llvm|
{
^0(%arg42 : i32):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.mlir.constant(1 : i32) : i32
  %2 = llvm.srem %arg42, %0 : i32
  %3 = llvm.icmp "ne" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def t_0_10_before := [llvm|
{
^0(%arg14 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.mlir.constant(10 : i8) : i8
  %2 = llvm.icmp "ugt" %arg14, %0 : i8
  %3 = "llvm.select"(%2, %arg14, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  %4 = llvm.and %3, %1 : i8
  "llvm.return"(%4) : (i8) -> ()
}
]

def test2_before := [llvm|
{
^0(%arg0 : i32):
  %0 = llvm.mlir.constant(17 : i32) : i32
  %1 = llvm.shl %arg0, %0 : i32
  %2 = llvm.shl %1, %0 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def add_nosignbit_select_shl_after := [llvm|
{
^0(%arg32 : i32, %arg33 : i1):
  %0 = llvm.mlir.constant(8 : i32) : i32
  %1 = llvm.mlir.constant(-16777216 : i32) : i32
  %2 = llvm.shl %arg32, %0 : i32
  %3 = llvm.add %2, %1 : i32
  %4 = "llvm.select"(%arg33, %3, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%4) : (i32) -> ()
}
]

instance {test : ConcreteCliTest} : ToString (toType test.ty) where
  toString :=
    match test.ty with
    | bitvec w => inferInstanceAs (ToString (PoisonOr <| BitVec w)) |>.toString

def masked_icmps_mask_notallzeros_bmask_mixed_swapped_3_logical_before := [llvm|
{
^0(%arg43 : i32):
  %0 = llvm.mlir.constant(15 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(7 : i32) : i32
  %3 = llvm.mlir.constant(false) : i1
  %4 = llvm.and %arg43, %0 : i32
  %5 = llvm.icmp "ne" %4, %1 : i32
  %6 = llvm.and %arg43, %2 : i32
  %7 = llvm.icmp "eq" %6, %1 : i32
  %8 = "llvm.select"(%7, %5, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%8) : (i1) -> ()
}
]

def alive_Select_1105_src  (w : Nat)   :=
[llvm( w )| {
^bb0(%Y : _, %X : _):
  %v1 = llvm.mlir.constant 0 :  i1
  %v2 = llvm.select %v1,%X, %Y
  llvm.return %v2
}]

def sub_from_constant_commute_before := [llvm|
{
^0(%arg4 : i5, %arg5 : i5):
  %0 = llvm.mlir.constant(10 : i5) : i5
  %1 = llvm.mul %arg5, %arg5 : i5
  %2 = llvm.sub %0, %arg4 overflow<nsw> : i5
  %3 = llvm.add %1, %2 overflow<nsw> : i5
  "llvm.return"(%3) : (i5) -> ()
}
]

def test1_after := [llvm|
{
^0(%arg1 : i17):
  %0 = llvm.mlir.constant(8 : i17) : i17
  %1 = llvm.lshr %arg1, %0 : i17
  %2 = llvm.shl %arg1, %0 : i17
  %3 = llvm.or %1, %2 : i17
  "llvm.return"(%3) : (i17) -> ()
}
]

def shl_sub_i32_after := [llvm|
{
^0(%arg18 : i32):
  %0 = llvm.mlir.constant(-2147483648 : i32) : i32
  %1 = llvm.lshr exact %0, %arg18 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def shl_lshr_pow2_const_negative_overflow1_before := [llvm|
{
^0(%arg70 : i16):
  %0 = llvm.mlir.constant(4096 : i16) : i16
  %1 = llvm.mlir.constant(6 : i16) : i16
  %2 = llvm.mlir.constant(8 : i16) : i16
  %3 = llvm.shl %0, %arg70 : i16
  %4 = llvm.lshr %3, %1 : i16
  %5 = llvm.and %4, %2 : i16
  "llvm.return"(%5) : (i16) -> ()
}
]

def xor_nosignbit_select_shl_before := [llvm|
{
^0(%arg36 : i32, %arg37 : i1):
  %0 = llvm.mlir.constant(2147418112 : i32) : i32
  %1 = llvm.mlir.constant(8 : i32) : i32
  %2 = llvm.xor %arg36, %0 : i32
  %3 = "llvm.select"(%arg37, %2, %arg36) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %4 = llvm.shl %3, %1 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def masked_icmps_mask_notallzeros_bmask_mixed_negated_7b_logical_before := [llvm|
{
^0(%arg53 : i32):
  %0 = llvm.mlir.constant(6 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(15 : i32) : i32
  %3 = llvm.mlir.constant(8 : i32) : i32
  %4 = llvm.mlir.constant(true) : i1
  %5 = llvm.and %arg53, %0 : i32
  %6 = llvm.icmp "eq" %5, %1 : i32
  %7 = llvm.and %arg53, %2 : i32
  %8 = llvm.icmp "ne" %7, %3 : i32
  %9 = "llvm.select"(%6, %4, %8) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%9) : (i1) -> ()
}
]

def shrink_or_after := [llvm|
{
^0(%arg11 : i6):
  %0 = llvm.mlir.constant(1 : i3) : i3
  %1 = llvm.trunc %arg11 : i6 to i3
  %2 = llvm.or %1, %0 : i3
  "llvm.return"(%2) : (i3) -> ()
}
]

def andn_or_cmp_2_partial_logical_after := [llvm|
{
^0(%arg117 : i16, %arg118 : i16, %arg119 : i1):
  %0 = llvm.icmp "slt" %arg117, %arg118 : i16
  %1 = llvm.and %arg119, %0 : i1
  "llvm.return"(%1) : (i1) -> ()
}
]

def ex1 := [HSxComb_com| {
  ^entry(%0: !Stream_BitVec_1):
    "return" (%0) : (!Stream_BitVec_1) -> ()
  }]

@[simp_denote]
def select {Γ : Ctxt _} (w : ℕ) (l m r : Nat)
    (lp : (Γ[l]? = some (InstCombine.MTy.bitvec (ConcreteOrMVar.concrete 1)))
      := by admit /- proof elided -/
      )
    (mp : (Γ[m]? = some (InstCombine.MTy.bitvec (ConcreteOrMVar.concrete w)))
      := by admit /- proof elided -/
      )
    (rp : (Γ[r]? = some (InstCombine.MTy.bitvec (ConcreteOrMVar.concrete w)))
      := by admit /- proof elided -/
      ) :
    Expr InstCombine.LLVM Γ .pure (LLVM.Ty.bitvec w)  :=
  Expr.mk
    (op := InstCombine.MOp.select w)
    (eff_le := by admit /- proof elided -/
    )
    (ty_eq := rfl)
    (args := .cons ⟨l, lp⟩ <| .cons ⟨m, mp⟩ <| .cons ⟨r, rp⟩ .nil)
    (regArgs := .nil)

def or_xor_tree_0011_before := [llvm|
{
^0(%arg36 : i32, %arg37 : i32, %arg38 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mul %arg36, %0 : i32
  %2 = llvm.mul %arg37, %0 : i32
  %3 = llvm.mul %arg38, %0 : i32
  %4 = llvm.xor %2, %1 : i32
  %5 = llvm.xor %3, %2 : i32
  %6 = llvm.xor %5, %1 : i32
  %7 = llvm.or %4, %6 : i32
  "llvm.return"(%7) : (i32) -> ()
}
]

def alive_AddSub_1176_tgt :=
[sllvm| {
^bb0(%a : i64, %b : i64):
  %v1 = llvm.mlir.constant 0 : i64
  %v2 = llvm.sub %v1, %b : i64
  %v3 = llvm.sub %a, %b : i64
  llvm.return %v3 : i64
}]

def fold_inverted_icmp_preds_reverse_before := [llvm|
{
^0(%arg93 : i32, %arg94 : i32, %arg95 : i32, %arg96 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.icmp "slt" %arg93, %arg94 : i32
  %2 = "llvm.select"(%1, %0, %arg95) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %3 = llvm.icmp "sge" %arg93, %arg94 : i32
  %4 = "llvm.select"(%3, %0, %arg96) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %5 = llvm.or %2, %4 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def test1_before := [llvm|
{
^0(%arg14 : i32, %arg15 : i32):
  %0 = llvm.icmp "slt" %arg14, %arg15 : i32
  %1 = llvm.zext %0 : i1 to i32
  %2 = llvm.icmp "sgt" %arg14, %arg15 : i32
  %3 = llvm.zext %2 : i1 to i32
  %4 = llvm.and %1, %3 : i32
  %5 = llvm.trunc %4 : i32 to i1
  "llvm.return"(%5) : (i1) -> ()
}
]

def main3c_after := [llvm|
{
^0(%arg145 : i32):
  %0 = llvm.mlir.constant(55 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.and %arg145, %0 : i32
  %3 = llvm.icmp "eq" %2, %1 : i32
  %4 = llvm.zext %3 : i1 to i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def no_shift_no_xor_multiuse_cmp_xor_after := [llvm|
{
^0(%arg56 : i32, %arg57 : i32, %arg58 : i32, %arg59 : i32):
  %0 = llvm.mlir.constant(4096 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.and %arg56, %0 : i32
  %3 = llvm.icmp "eq" %2, %1 : i32
  %4 = llvm.xor %arg57, %0 : i32
  %5 = llvm.xor %arg57, %2 : i32
  %6 = "llvm.select"(%3, %arg58, %arg59) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %7 = llvm.mul %5, %6 : i32
  %8 = llvm.mul %7, %4 : i32
  "llvm.return"(%8) : (i32) -> ()
}
]

def lshr_and_after := [llvm|
{
^0(%arg73 : i8, %arg74 : i8):
  %0 = llvm.mlir.constant(42 : i8) : i8
  %1 = llvm.mlir.constant(6 : i8) : i8
  %2 = llvm.srem %arg73, %0 : i8
  %3 = llvm.shl %2, %1 : i8
  %4 = llvm.and %arg74, %3 : i8
  "llvm.return"(%4) : (i8) -> ()
}
]

def ashr_pow2_ult_before := [llvm|
{
^0(%arg59 : i8):
  %0 = llvm.mlir.constant(-128 : i8) : i8
  %1 = llvm.mlir.constant(-96 : i8) : i8
  %2 = llvm.ashr %0, %arg59 : i8
  %3 = llvm.icmp "ult" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def test65_after := [llvm|
{
^0(%arg43 : i64):
  %0 = llvm.mlir.constant(16) : i64
  %1 = llvm.mlir.constant(0) : i64
  %2 = llvm.mlir.constant(42 : i32) : i32
  %3 = llvm.mlir.constant(40 : i32) : i32
  %4 = llvm.and %arg43, %0 : i64
  %5 = llvm.icmp "eq" %4, %1 : i64
  %6 = "llvm.select"(%5, %2, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def fold_sext_to_and3_before := [llvm|
{
^0(%arg14 : i8):
  %0 = llvm.mlir.constant(1073741826 : i32) : i32
  %1 = llvm.mlir.constant(2 : i32) : i32
  %2 = llvm.sext %arg14 : i8 to i32
  %3 = llvm.and %2, %0 : i32
  %4 = llvm.icmp "ne" %3, %1 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def add_nuw_or_and_after := [llvm|
{
^0(%arg9 : i32, %arg10 : i32):
  %0 = llvm.add %arg9, %arg10 overflow<nuw> : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

def not_and_and_or_not_or_or_commute2_or_before := [llvm|
{
^0(%arg247 : i32, %arg248 : i32, %arg249 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.or %arg248, %arg249 : i32
  %2 = llvm.or %1, %arg247 : i32
  %3 = llvm.xor %2, %0 : i32
  %4 = llvm.xor %arg247, %0 : i32
  %5 = llvm.and %4, %arg248 : i32
  %6 = llvm.and %5, %arg249 : i32
  %7 = llvm.or %6, %3 : i32
  "llvm.return"(%7) : (i32) -> ()
}
]

def sdiv_pow2_16 : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%x: i64):
      %c = llvm.mlir.constant (16) : i64
      %0 = llvm.sdiv %x, %c : i64
      llvm.return %0 : i64
  }]
  rhs := [LV| {
    ^entry (%x: i64):
      %c0 = llvm.mlir.constant (63) : i64
      %c1 = llvm.mlir.constant (60) : i64
      %c2 = llvm.mlir.constant (4) : i64
      %0 = llvm.ashr %x, %c0 : i64
      %1 = llvm.lshr %0, %c1 : i64
      %2 = llvm.add %x, %1 : i64 
      %3 = llvm.ashr %2, %c2 : i64
      llvm.return %3 : i64
  }]

def or_and_not_not_after := [llvm|
{
^0(%arg425 : i32, %arg426 : i32, %arg427 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.and %arg427, %arg426 : i32
  %2 = llvm.or %1, %arg425 : i32
  %3 = llvm.xor %2, %0 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def sub_zext_trunc_lshr_after := [llvm|
{
^0(%arg15 : i64):
  %0 = llvm.mlir.constant(16 : i32) : i32
  %1 = llvm.mlir.constant(31 : i32) : i32
  %2 = llvm.mlir.constant(10 : i32) : i32
  %3 = llvm.trunc %arg15 : i64 to i32
  %4 = llvm.shl %3, %0 : i32
  %5 = llvm.ashr %4, %1 : i32
  %6 = llvm.add %5, %2 overflow<nsw> : i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def cond_eq_and_const_after := [llvm|
{
^0(%arg154 : i8, %arg155 : i8):
  %0 = llvm.mlir.constant(10 : i8) : i8
  %1 = llvm.mlir.constant(false) : i1
  %2 = llvm.icmp "eq" %arg154, %0 : i8
  %3 = llvm.icmp "ugt" %arg155, %0 : i8
  %4 = "llvm.select"(%2, %3, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def lshrugt_02_07_exact_after := [llvm|
{
^0(%arg198 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def llvm_const_lower_riscv_li_29 : LLVMPeepholeRewriteRefine 64 [] :=
  {lhs := constLLVM_29, rhs:= liRiscv_29,
   correct := by admit /- proof elided -/

private def attrVal6Symbol : AttrVal := [mlir_attr_val| @func_foo ]

Lean.ToMessageData in Lean.Message

def or_nosignbit_ashr_before := [llvm|
{
^0(%arg4 : i32):
  %0 = llvm.mlir.constant(2147418112 : i32) : i32
  %1 = llvm.mlir.constant(8 : i32) : i32
  %2 = llvm.or %arg4, %0 : i32
  %3 = llvm.ashr %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

Option in Init.Prelude

def test19_after := [llvm|
{
^0(%arg7 : i10):
  %0 = llvm.mlir.constant(1 : i3) : i3
  %1 = llvm.mlir.constant(0 : i3) : i3
  %2 = llvm.trunc %arg7 : i10 to i3
  %3 = llvm.and %2, %0 : i3
  %4 = llvm.sub %1, %3 overflow<nsw> : i3
  %5 = llvm.sext %4 : i3 to i10
  "llvm.return"(%5) : (i10) -> ()
}
]

def hoist_ashr_ahead_of_sext_2_before := [llvm|
{
^0(%arg1 : i8):
  %0 = llvm.mlir.constant(8 : i32) : i32
  %1 = llvm.sext %arg1 : i8 to i32
  %2 = llvm.ashr %1, %0 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

@[simp_llvm_option]
def icmp {w : Nat} (c : IntPred) (x y : IntW w) : IntW 1 := do
  let x' ← x
  let y' ← y
  icmp? c x' y'

def ashrslt_01_03_after := [llvm|
{
^0(%arg266 : i4):
  %0 = llvm.mlir.constant(6 : i4) : i4
  %1 = llvm.icmp "slt" %arg266, %0 : i4
  "llvm.return"(%1) : (i1) -> ()
}
]

def ori_i64_test : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := ori_llvm_i64
  rhs := ori_riscv_i64

def ult_swap_or_not_max_logical_before := [llvm|
{
^0(%arg36 : i8, %arg37 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.mlir.constant(true) : i1
  %2 = llvm.icmp "ugt" %arg37, %arg36 : i8
  %3 = llvm.icmp "ne" %arg36, %0 : i8
  %4 = "llvm.select"(%2, %1, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def lt_unsigned_to_large_negative_after := [llvm|
{
^0(%arg45 : i8):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def Valuation.singleton {t : Ty} (v : toType t) : Ctxt.Valuation ⟨[t]⟩ :=
  Ctxt.Valuation.nil.cons v

@[simps]
def proj (M: NFA (BitVec n1) σ) (f : Fin n2 → Fin n1) : NFA (BitVec n2) σ where
  start := M.start
  accept := M.accept
  step q a := { q' | ∃ a', a'.transport f = a ∧ q' ∈ M.step q a' }

def icmp_ne_sext_ne_zero_after := [llvm|
{
^0(%arg24 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.mlir.constant(-2 : i32) : i32
  %2 = llvm.add %arg24, %0 : i32
  %3 = llvm.icmp "ult" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def and_to_xor2_after := [llvm|
{
^0(%arg117 : i32, %arg118 : i32):
  %0 = llvm.xor %arg117, %arg118 : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

Polynomial.reverse in Mathlib.Algebra.Polynomial.Reverse

Sum in Init.Core
</all_available_defs>

<all_available_lemmas>
BitVec.eq_nil in Init.Data.BitVec.Basic
BitVec.getElem_one in Init.Data.BitVec.Lemmas
BitVec.getLsbD_eq_getElem in Init.Data.BitVec.Basic
BitVec.msb_eq_getLsbD_last in Init.Data.BitVec.Lemmas
BitVec.ofNat_eq_ofNat in Init.Data.BitVec.Basic
List.getElem?_eq_getElem in Init.GetElem
List.getLast?_eq_getElem? in Init.Data.List.Lemmas
Set.mem_image in Mathlib.Data.Set.Operations
Set.mem_setOf_eq in Mathlib.Data.Set.Operations
and_true in Init.SimpLemmas
decide_true in Init.Core

@[ext]
theorem ext {x y : BitStream} (h : ∀ i, x i = y i) : x = y

@[simp]
lemma dec_enc' : dec (enc bvs) = bvs

@[simp]
lemma dec_enc : Function.RightInverse (α := BitVecs' n) enc dec

lemma dec_enc_w (bvs : BitVecs n) : (dec (enc bvs)).w = bvs.w

@[simp]
theorem BitVec.ofFn_getElem {w : Nat} (f : Fin w → Bool) {i : Nat} (hi : i < w) :
    (BitVec.ofFn f)[i] = f ⟨i, hi⟩

@[simp]
theorem BitVec.ofFn_getLsbD {w : Nat} {f : Fin w → Bool} {i : Nat} (hi : i < w) :
    (BitVec.ofFn f).getLsbD i = f ⟨i, hi⟩

theorem BitVec.ofFn_getLsbD_fin {w : Nat} {f : Fin w → Bool} {i : Fin w} :
    (BitVec.ofFn f).getLsbD i = f i

theorem lshr_sub_nsw_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬(True ∧ x_1.ssubOverflow x = true ∨ 31#32 ≥ ↑32) → (x_1 - x) >>> 31#32 = zeroExtend 32 (ofBool (x_1 <ₛ x))

theorem sext_sext_sge_op0_narrow_thm.extracted_1._1 : ∀ (x : BitVec 8) (x_1 : BitVec 5),
  ofBool (signExtend 32 x ≤ₛ signExtend 32 x_1) = ofBool (x ≤ₛ signExtend 8 x_1)

theorem e_1953 :
     - 11 *  ~~~(a &&&  ~~~b) - 5 * ((a &&& b) ||| (b ^^^ c)) - 1 * ((a &&& b) ||| (a ^^^ (b ^^^ c))) - 7 * (b ^^^ ( ~~~a ||| (b ^^^ c))) - 1 * (a &&& (b ^^^ c)) - 6 *  ~~~(a ^^^ ( ~~~b &&& c)) + 7 * (c ^^^  ~~~( ~~~a ||| (b &&& c))) - 2 * (a ^^^ ( ~~~b ||| c)) + 2 * (b ^^^  ~~~(a &&&  ~~~c)) - 1 * (b ^^^ (a ||| (b &&& c))) + 2 * (b ^^^  ~~~( ~~~a &&& ( ~~~b &&& c))) + 5 * (b ^^^  ~~~(a &&& ( ~~~b ||| c))) + 7 * (a &&&  ~~~b) - 1 * (b &&&  ~~~(a ^^^ c)) + 1 *  ~~~(b ||| c) + 2 * ((a |||  ~~~b) &&&  ~~~(a ^^^ (b ^^^ c))) - 5 * (c ^^^  ~~~( ~~~a &&& ( ~~~b ||| c))) + 4 * (c ^^^ ( ~~~a ||| (b ||| c))) - 2 * ( ~~~(a ||| b) |||  ~~~(b ^^^ c)) + 2 * (b ^^^ (a &&& ( ~~~b ||| c))) + 3 * (b &&&  ~~~(a &&& c)) + 1 *  ~~~(a ||| b) - 1 * (b ^^^  ~~~(a &&& ( ~~~b &&& c))) + 1 * (c ^^^ (a ||| ( ~~~b ||| c))) + 7 * (b &&& (a |||  ~~~c)) - 2 * ( ~~~c &&&  ~~~(a ^^^ b)) + 11 * (c ^^^  ~~~(a ||| b)) + 1 * (a &&& c) - 5 * (c &&& (a ||| b)) + 4 * (b ^^^ (a &&&  ~~~c)) - 1 * (b ^^^ (a &&& (b ^^^ c))) - 6 * ((a |||  ~~~b) &&& (a ^^^ (b ^^^ c))) - 6 * (c ^^^  ~~~( ~~~a &&& ( ~~~b &&& c))) + 11 *  ~~~(a ||| (b ^^^ c)) - 1 * (c ^^^  ~~~(a &&& ( ~~~b ||| c))) + 4 *  ~~~( ~~~a &&& (b ^^^ c)) - 7 * ( ~~~a ||| (b ||| c)) - 1 * (a ^^^ c) + 3 * ((a &&& b) ^^^ (b ||| c)) - 1 * (b ^^^ ( ~~~a ||| ( ~~~b &&& c))) + 1 *  ~~~( ~~~a ||| ( ~~~b &&& c)) - 1 * (a ||| b) + 2 * (b ^^^  ~~~(a ||| ( ~~~b &&& c))) - 2 * (a |||  ~~~c) - 1 * ((b &&& c) ||| (a &&& (b ||| c))) + 4 *  ~~~(a ||| ( ~~~b &&& c)) + 11 *  ~~~(a &&& b) - 13 *  ~~~(a ||| (b ||| c)) + 10 *  ~~~(a ||| ( ~~~b ||| c)) - 14 *  ~~~( ~~~a ||| (b ||| c)) + 12 *  ~~~( ~~~a ||| ( ~~~b ||| c)) + 26 * ( ~~~a &&& ( ~~~b &&& c)) - 6 * (a &&& ( ~~~b &&& c)) + 10 * (a &&& (b &&& c)) = 18 * ( ~~~a &&& (b &&& c))

theorem add_select_not_sext_thm (e : IntW 1) :
  add (select e (const? 64 64) (const? 64 1)) (sext 64 (LLVM.xor e (const? 1 1))) ⊑
    select e (const? 64 64) (const? 64 0)

theorem bor_land_left1_thm.extracted_1._1 : ∀ (x x_1 : BitVec 1), ¬x_1 ||

theorem n5_proof : n5_before ⊑ n5_after

theorem icmp_power2_and_icmp_shifted_mask_8_6_proof : icmp_power2_and_icmp_shifted_mask_8_6_before ⊑ icmp_power2_and_icmp_shifted_mask_8_6_after

theorem select_icmp_ne_0_and_4096_xor_32_proof : select_icmp_ne_0_and_4096_xor_32_before ⊑ select_icmp_ne_0_and_4096_xor_32_after

theorem test3_thm.extracted_1._1 : ∀ (x : BitVec 1), x &&& 0#1 = 0#1

lemma RawCNFA.lift_wf (m : RawCNFA (BitVec n₁)) {f : Fin n₁ → Fin n₂} (hwf : m.WF) :
    m.lift f |>.WF

theorem sext_zext_nneg_slt_proof : sext_zext_nneg_slt_before ⊑ sext_zext_nneg_slt_after

theorem t5_thm.extracted_1._7 : ∀ (x x_1 : BitVec 1) (x_2 : BitVec 32),
  x_1 = 1#1 → ¬x = 1#1 → ¬64#32 = 0 → ¬6#32 ≥ ↑32 → x_2 / 64#32 = x_2 >>> 6#32

theorem lshr_pow2_ult_equal_constants_proof : lshr_pow2_ult_equal_constants_before ⊑ lshr_pow2_ult_equal_constants_after

theorem select_xor_icmp_bad_5_thm.extracted_1._4 : ∀ (x x_1 x_2 : BitVec 32),
  ¬ofBool (x_2 != 0#32) = 1#1 → ¬ofBool (x_2 == 0#32) = 1#1 → x = x_2 ^^^ x_1

theorem neg_not_signbit2_proof : neg_not_signbit2_before ⊑ neg_not_signbit2_after

theorem e_2015 :
    5 * (f ^^^ (d &&& e)) + 11 * ( ~~~e &&&  ~~~(d ^^^ f)) + 4 * (e ^^^  ~~~(d ||| ( ~~~e &&& f))) - 1 * (e |||  ~~~(d ||| f)) + 2 * (f ^^^  ~~~( ~~~d ||| ( ~~~e &&& f))) + 2 * (f ^^^  ~~~(d &&& e)) + 2 *  ~~~(d ^^^ e) + 3 * (e ^^^  ~~~( ~~~d ||| ( ~~~e &&& f))) - 1 * (f ^^^ (d ||| (e &&& f))) - 3 *  ~~~( ~~~d &&& (e &&& f)) + 3 * (f ^^^  ~~~( ~~~d &&& ( ~~~e &&& f))) + 1 * (e |||  ~~~f) + 1 * (e ^^^  ~~~( ~~~d ||| (e &&& f))) - 5 * (d &&& (e ^^^ f)) - 11 * ( ~~~d ||| (e ^^^ f)) - 6 * e + 1 * (f ^^^ ( ~~~d ||| ( ~~~e &&& f))) + 2 * ( ~~~(d ||| e) |||  ~~~(d ^^^ (e ^^^ f))) - 11 * (e ^^^  ~~~( ~~~d &&& ( ~~~e ||| f))) + 3 * (e ||| (d ^^^ f)) + 4 * ((d ^^^ e) ||| (d ^^^ f)) + 11 * (d ||| e) + 1 * (d ||| (e ^^^ f)) - 11 * ( ~~~(d &&&  ~~~e) &&&  ~~~(e ^^^ f)) + 11 *  ~~~(d &&& (e ^^^ f)) - 11 * (e &&&  ~~~(d &&& f)) - 18 *  ~~~(d ||| (e ||| f)) - 9 *  ~~~(d ||| ( ~~~e ||| f)) - 34 *  ~~~( ~~~d ||| (e ||| f)) - 7 *  ~~~( ~~~d ||| ( ~~~e ||| f)) - 18 * ( ~~~d &&& ( ~~~e &&& f)) + 1 * ( ~~~d &&& (e &&& f)) - 7 * (d &&& ( ~~~e &&& f)) - 23 * (d &&& (e &&& f)) =  - 7 * ((d &&& e) |||  ~~~(e ^^^ f))

theorem t10_shl_nuw_flag_preservation_thm (e e_1 : IntW 32) :
  shl (shl e_1 (sub (const? 32 32) e) { «nsw» := false, «nuw» := true }) (add e (const? 32 (-2)))
      { «nsw» := true, «nuw» := true } ⊑
    shl e_1 (const? 32 30) { «nsw» := false, «nuw» := true }

theorem or_signbit_shl_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬8#32 ≥ ↑32 → (x ||| BitVec.ofInt 32 (-65536)) <<< 8#32 = x <<< 8#32 ||

theorem not_ashr_const_proof : not_ashr_const_before ⊑ not_ashr_const_after

theorem icmp_ne_sext_eq_otherwise_proof : icmp_ne_sext_eq_otherwise_before ⊑ icmp_ne_sext_eq_otherwise_after

@[simp]
theorem MatchVar.liftM_bind_eq_some_iff (x? : Option α)
    (f : α → MatchVarM Δ Γ β) :
    ((liftM x? >>= f) mapIn = some mapOut)
    ↔ ( ∃ h : x?.isSome,
        f (x?.get h) mapIn = some mapOut )

theorem zext_false_val_must_be_zero_thm (e : IntW 1) : select e (const? 32 42) (zext 32 e) ⊑ select e (const? 32 42) (const? 32 0)

theorem e_555 :
    11 * (x |||  ~~~y) - 1 *  ~~~x + 4 *  ~~~(x &&&  ~~~y) + 7 *  ~~~(x ^^^ y) + 7 * (x ^^^ y) - 14 *  ~~~(x ||| y) - 3 *  ~~~(x |||  ~~~y) - 11 * (x &&&  ~~~y) - 15 * (x &&& y) = 7 *  ~~~(x &&&  ~~~x)

theorem icmp_eq_and_pow2_shl_pow2_proof : icmp_eq_and_pow2_shl_pow2_before ⊑ icmp_eq_and_pow2_shl_pow2_after

theorem test_zext1_thm.extracted_1._1 : ∀ (x : BitVec 1), ¬x = 1#1 → 0#32 = zeroExtend 32 0#1

theorem positive_biggershl_lshrexact_proof : positive_biggershl_lshrexact_before ⊑ positive_biggershl_lshrexact_after

theorem e_609 :
    4 *  ~~~(x &&& y) - 3 *  ~~~(x ^^^ y) - 6 * (x ^^^ y) - 2 *  ~~~(x &&&  ~~~y) - 6 *  ~~~x + 7 * x + 2 *  ~~~y + 5 *  ~~~(x ||| y) + 9 *  ~~~(x |||  ~~~y) - 7 * (x &&&  ~~~y) = 3 * (x &&& y) - 1 * y

theorem icmp_shl_ne_2_thm (e : IntW 8) :
  icmp IntPred.ne (LLVM.sdiv (const? 8 42) e) (shl (LLVM.sdiv (const? 8 42) e) (const? 8 1)) ⊑
    icmp IntPred.ne (LLVM.sdiv (const? 8 42) e) (const? 8 0)

theorem p0_thm (e e_1 : IntW 8) :
  icmp IntPred.ule (shl (const? 8 1) e_1) e ⊑ icmp IntPred.ne (lshr e e_1) (const? 8 0)

theorem ashrslt_01_01_exact_proof : ashrslt_01_01_exact_before ⊑ ashrslt_01_01_exact_after

theorem icmp_ne_and1_lshr_pow2_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬x ≥ ↑32 → zeroExtend 32 (ofBool (8#32 >>> x &&& 1#32 == 0#32)) = zeroExtend 32 (ofBool (x != 3#32))

theorem trunc_shl_lshr_var_thm.extracted_1._1 : ∀ (x x_1 : BitVec 64),
  ¬(x ≥ ↑64 ∨ 2#64 ≥ ↑64) → x ≥ ↑64 ∨ 2#32 ≥ ↑32 → False

theorem sle_swap_and_min_commute_logical_thm.extracted_1._2 : ∀ (x x_1 : BitVec 8),
  ofBool (x_1 == BitVec.ofInt 8 (-128)) = 1#1 → ofBool (x_1 ≤ₛ x) = ofBool (x_1 == BitVec.ofInt 8 (-128))

theorem negtest_near_pow2_cmpval_ashr_wrong_cmp_pred_thm (e : IntW 8) :
  icmp IntPred.eq (ashr e (const? 8 1) { «exact» := true }) (const? 8 5) ⊑
    icmp IntPred.eq e (const? 8 10)

theorem test_shl_nuw__none_are_safe_proof : test_shl_nuw__none_are_safe_before ⊑ test_shl_nuw__none_are_safe_after

theorem e_2261 :
    2 *  ~~~(d &&& f) + 4 * (d &&& e) - 11 *  ~~~(e &&& f) - 1 * ((d &&& e) |||  ~~~(e ||| f)) - 3 * (f &&&  ~~~(d &&& e)) + 1 * (e &&&  ~~~(d ^^^ f)) - 3 * (f ^^^  ~~~(d ||| (e &&& f))) + 5 * ( ~~~f &&& (d ^^^ e)) - 7 * (f &&& (d ^^^ e)) + 5 * (f &&&  ~~~(d ^^^ e)) + 11 * (e ^^^  ~~~(d &&& (e &&& f))) - 1 * (e ^^^ (d &&& ( ~~~e ||| f))) + 4 * (f ^^^  ~~~(d ||| ( ~~~e &&& f))) + 1 * (e ^^^ (d &&& f)) + 7 * (e ||| f) - 7 * ((e &&& f) ||| (d &&& (e ||| f))) + 7 * (d ^^^ ( ~~~e &&& f)) - 3 * (e ^^^ ( ~~~d ||| (e ^^^ f))) + 4 *  ~~~(d &&&  ~~~d) - 1 * (f ^^^  ~~~( ~~~d ||| (e &&& f))) + 1 * (e ^^^  ~~~(d &&&  ~~~f)) - 1 * ( ~~~e &&&  ~~~(d ^^^ f)) + 1 *  ~~~(d ^^^ (e ^^^ f)) - 2 * (f ||| (d &&&  ~~~e)) + 1 * (f ^^^ (d &&& (e ||| f))) + 5 *  ~~~(d &&& (e ^^^ f)) - 3 * (d ||| (e ||| f)) + 2 * e + 11 * ((d &&& e) ^^^ (e ||| f)) - 3 * (f &&& (d |||  ~~~e)) - 11 * ((d |||  ~~~e) &&& (d ^^^ (e ^^^ f))) + 2 * ((d &&& f) ^^^  ~~~(d ^^^ (e &&& f))) - 11 * ( ~~~d &&& (e ||| f)) - 6 * ( ~~~(d ||| e) ||| (e ^^^ f)) - 2 *  ~~~( ~~~d &&& ( ~~~e ||| f)) - 5 * ((e &&& f) ^^^  ~~~(d &&& (e ^^^ f))) - 5 * ((d &&&  ~~~e) ||| (d ^^^ (e ^^^ f))) + 1 *  ~~~( ~~~d &&& (e &&& f)) + 4 * ((d &&& e) |||  ~~~(e |||  ~~~f)) + 5 * ((d &&& e) ^^^ (d ^^^ ( ~~~e ||| f))) + 3 * ((d &&& e) |||  ~~~(d ^^^ (e ^^^ f))) - 5 * ((e &&& f) ||| ( ~~~d &&& (e ||| f))) - 11 * (e ^^^  ~~~( ~~~d &&& (e ^^^ f))) + 7 * ((d ||| e) &&&  ~~~(d ^^^ (e ^^^ f))) - 6 *  ~~~f + 5 * ((d ^^^ e) ||| (d ^^^ f)) + 1 * ((d &&& e) ^^^ (d ^^^ (e &&& f))) + 5 * f + 3 * (e ^^^ (d ||| ( ~~~e ||| f))) - 7 * (d &&& ( ~~~e ||| f)) + 5 *  ~~~(d ||| (e ||| f)) + 21 *  ~~~(d ||| ( ~~~e ||| f)) + 27 *  ~~~( ~~~d ||| (e ||| f)) - 7 *  ~~~( ~~~d ||| ( ~~~e ||| f)) - 14 * ( ~~~d &&& ( ~~~e &&& f)) - 17 * ( ~~~d &&& (e &&& f)) + 4 * (d &&& ( ~~~e &&& f)) - 11 * (d &&& (e &&& f)) = 5 * ((e &&&  ~~~f) |||  ~~~( ~~~d ||| ( ~~~e &&& f)))

theorem e_2376 :
    1 * (d ||| ( ~~~e &&& f)) - 2 * ((d &&&  ~~~e) |||  ~~~(e ^^^ f)) - 2 * (e ^^^ (d ||| (e ^^^ f))) - 2 * ( ~~~(d |||  ~~~e) ||| (d ^^^ (e ^^^ f))) - 1 * (f ^^^  ~~~(d &&& (e &&& f))) - 2 * ( ~~~d ||| (e &&& f)) + 2 * (f ||| (d &&& e)) + 11 * ( ~~~(d &&& e) &&&  ~~~(e ^^^ f)) - 2 * ((e &&& f) ^^^  ~~~(d &&& (e ^^^ f))) - 5 * (f ^^^  ~~~( ~~~d &&& (e &&& f))) - 2 * ( ~~~(d &&& e) &&&  ~~~(d ^^^ (e ^^^ f))) + 2 * ( ~~~e |||  ~~~(d ^^^ f)) - 1 * (d &&& (e ||| f)) + 7 * ((d |||  ~~~e) &&& (e ^^^ f)) + 1 * (d ^^^ e) + 2 * ( ~~~f &&&  ~~~(d ^^^ e)) - 6 * (f ^^^ (d ||| (e &&& f))) - 1 * (e ^^^  ~~~(d &&& (e ^^^ f))) - 5 * ( ~~~(d &&&  ~~~e) &&& (d ^^^ (e ^^^ f))) - 11 *  ~~~(d &&&  ~~~f) + 2 * ((d &&&  ~~~e) ||| (d ^^^ (e ^^^ f))) - 7 * (e ^^^  ~~~(d &&& ( ~~~e &&& f))) + 1 * (f ^^^ ( ~~~d ||| (e &&& f))) - 7 * ( ~~~(d |||  ~~~e) |||  ~~~(e ^^^ f)) - 1 * (e &&&  ~~~f) + 2 * ((d &&& e) |||  ~~~(e ||| f)) - 2 * (f ^^^  ~~~(d &&& ( ~~~e &&& f))) + 3 * (e &&& (d |||  ~~~f)) - 11 * (f ^^^ ( ~~~d &&& ( ~~~e ||| f))) + 4 * ((d |||  ~~~e) &&& (d ^^^ (e ^^^ f))) + 1 * (d ||| (e &&& f)) - 3 * (f ^^^  ~~~(d ||| (e &&& f))) - 1 * ((d &&& e) ^^^ (e ||| f)) - 1 * ((d ||| e) &&&  ~~~(d ^^^ (e ^^^ f))) + 3 * (e ||| f) - 7 * ( ~~~d &&& ( ~~~e ||| f)) + 1 * ((e &&& f) ||| (d &&& (e ||| f))) - 6 *  ~~~(d &&& ( ~~~e ||| f)) - 11 * ( ~~~d ||| (e ^^^ f)) + 11 * (e &&&  ~~~(d ^^^ f)) + 5 * ((d &&& e) |||  ~~~(e |||  ~~~f)) + 1 * (e ^^^ ( ~~~d ||| ( ~~~e &&& f))) + 1 * (d ||| (e ^^^ f)) + 2 * (e ^^^  ~~~(d &&&  ~~~f)) + 1 *  ~~~(d |||  ~~~f) - 6 * (f ^^^ (d |||  ~~~e)) - 1 *  ~~~(d &&& ( ~~~e &&& f)) + 1 * (f &&&  ~~~(d &&&  ~~~e)) + 4 * (d ^^^ (e ||| f)) - 6 * (d ^^^ f) + 2 *  ~~~(d ||| (e ^^^ f)) + 2 * (e ^^^ (d &&& f)) - 1 * (f |||  ~~~(d ^^^ e)) - 5 * ((d &&& f) ^^^  ~~~(d ^^^ (e &&& f))) - 5 * (f ^^^ (d &&& ( ~~~e ||| f))) - 6 * ((d &&& e) ^^^  ~~~(d ^^^ ( ~~~e ||| f))) - 1 * (e ^^^  ~~~(d &&& f)) + 5 *  ~~~(d &&&  ~~~d) + 1 *  ~~~f + 1 * ((d &&& e) ^^^  ~~~(d ^^^ (e &&& f))) + 7 * (f ^^^ ( ~~~d ||| ( ~~~e ||| f))) + 7 * (e ^^^ (d ||| (e ||| f))) - 2 * (d |||  ~~~f) + 60 *  ~~~(d ||| (e ||| f)) + 29 *  ~~~(d ||| ( ~~~e ||| f)) + 15 *  ~~~( ~~~d ||| (e ||| f)) + 17 *  ~~~( ~~~d ||| ( ~~~e ||| f)) + 33 * ( ~~~d &&& ( ~~~e &&& f)) + 17 * (d &&& ( ~~~e &&& f)) + 6 * (d &&& (e &&& f)) =  - 47 * ( ~~~d &&& (e &&& f)) + 1 * ( ~~~(d ^^^ e) &&&  ~~~(d ^^^ f))

theorem zext_false_val_must_be_zero_proof : zext_false_val_must_be_zero_before ⊑ zext_false_val_must_be_zero_after

theorem e_1802 :
     - 7 * ((a &&&  ~~~b) ||| (b ^^^ c)) - 1 *  ~~~(a ||| c) + 1 * (c ^^^ ( ~~~a ||| (b &&& c))) + 3 * ((a &&& b) |||  ~~~(b ^^^ c)) - 11 * (a ||| ( ~~~b &&& c)) + 4 * (b ||| (a ^^^ c)) + 11 * ( ~~~(a ||| b) |||  ~~~(b ^^^ c)) - 1 * ((a ^^^ b) ||| (a ^^^ c)) - 6 * ( ~~~(a &&&  ~~~b) &&& (b ^^^ c)) - 1 * ((a ^^^ b) &&&  ~~~(a ^^^ c)) - 1 * (a ^^^ (b ||| c)) - 1 * (c &&& (a ||| b)) - 5 *  ~~~(b &&&  ~~~c) + 11 * ((a |||  ~~~b) &&& (b ^^^ c)) + 11 * ( ~~~(a &&& b) &&& (a ^^^ (b ^^^ c))) - 2 * (b ^^^ (a &&& ( ~~~b ||| c))) + 7 * (c &&&  ~~~(a &&&  ~~~b)) - 7 *  ~~~(a ||| (b ^^^ c)) + 5 * (c ^^^  ~~~(a &&& ( ~~~b &&& c))) + 5 * (b &&& (a ||| c)) + 1 * ((a &&& b) |||  ~~~(a ^^^ (b ^^^ c))) - 7 * ( ~~~a ||| (b &&& c)) - 5 * ((a &&& b) ^^^  ~~~(a ^^^ ( ~~~b ||| c))) + 2 * ((a &&& c) ^^^  ~~~(a ^^^ ( ~~~b &&& c))) - 5 * ( ~~~(a |||  ~~~b) ||| (b ^^^ c)) - 2 *  ~~~(b |||  ~~~c) + 11 *  ~~~(a |||  ~~~b) - 1 * (a ^^^ c) - 5 * ((a ^^^ b) &&& (a ^^^ c)) + 3 * ( ~~~(a ||| b) ||| (b ^^^ c)) + 4 * (b ||| c) - 2 * (c ^^^ (a ||| ( ~~~b &&& c))) - 8 *  ~~~(a ||| (b ||| c)) - 6 *  ~~~(a ||| ( ~~~b ||| c)) + 4 *  ~~~( ~~~a ||| (b ||| c)) + 4 *  ~~~( ~~~a ||| ( ~~~b ||| c)) - 8 * ( ~~~a &&& ( ~~~b &&& c)) - 13 * ( ~~~a &&& (b &&& c)) + 13 * (a &&& ( ~~~b &&& c)) - 13 * (a &&& (b &&& c)) =  - 2 * (b ^^^  ~~~( ~~~a &&& (b &&& c))) - 1 * ( ~~~a &&& (b ^^^ c))

theorem exact_ashr_ne_proof : exact_ashr_ne_before ⊑ exact_ashr_ne_after

theorem in_constant_14_vary_thm.extracted_1._1 : ∀ (x : BitVec 4),
  (x ^^^ BitVec.ofInt 4 (-2)) &&& 1#4 ^^^ x = x &&& BitVec.ofInt 4 (-2)

theorem p0_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ofBool (x_1 &&& 1#8 == 1#8) = 1#1 → ofBool (x_1 &&& 1#8 == 0#8) = 1#1 → False

theorem lshrugt_02_07_exact_proof : lshrugt_02_07_exact_before ⊑ lshrugt_02_07_exact_after

theorem test_add_nuw_nsw__nsw_is_safe_proof : test_add_nuw_nsw__nsw_is_safe_before ⊑ test_add_nuw_nsw__nsw_is_safe_after

theorem test3_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32), (x_1 ^^^ -1#32) &&& (x ^^^ -1#32) ^^^ -1#32 = x_1 ||

theorem canonicalize_logic_first_and0_nswnuw_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬(True ∧ x.saddOverflow 48#8 = true ∨ True ∧ x.uaddOverflow 48#8 = true) →
    True ∧ (x &&& BitVec.ofInt 8 (-10)).saddOverflow 48#8 = true ∨
        True ∧ (x &&& BitVec.ofInt 8 (-10)).uaddOverflow 48#8 = true →
      False

theorem not_add_eq_not_sub :
    ~~~ (x + y) = ~~~ x - y

theorem e_1383 :
    11 * (z |||  ~~~t) + 3 * (z ||| t) + 3 *  ~~~(z &&&  ~~~t) + 4 * z - 6 *  ~~~t + 1 * t + 14 *  ~~~(z ||| t) + 15 *  ~~~(z |||  ~~~t) - 1 * (z &&&  ~~~t) - 22 * (z &&& t) = 11 *  ~~~z + 11 *  ~~~(z &&& t)

theorem test_and_xor_freely_invertable_thm (e : IntW 1) (e_1 e_2 : IntW 32) :
  LLVM.and (LLVM.xor (icmp IntPred.sgt e_2 e_1) e) e ⊑ LLVM.and (icmp IntPred.sle e_2 e_1) e

theorem or_not_and_commute9_thm.extracted_1._2 : ∀ (x x_1 x_2 : BitVec 32),
  ¬((x_2 == 0 || 32 != 1 && 42#32 == intMin 32 && x_2 == -1) = true ∨
        (x_1 == 0 || 32 != 1 && 42#32 == intMin 32 && x_1 == -1) = true ∨
          (x == 0 || 32 != 1 && 42#32 == intMin 32 && x == -1) = true ∨
            (x_1 == 0 || 32 != 1 && 42#32 == intMin 32 && x_1 == -1) = true ∨
              (x_2 == 0 || 32 != 1 && 42#32 == intMin 32 && x_2 == -1) = true ∨
                (x == 0 || 32 != 1 && 42#32 == intMin 32 && x == -1) = true) →
    ¬((x_1 == 0 || 32 != 1 && 42#32 == intMin 32 && x_1 == -1) = true ∨
          (x == 0 || 32 != 1 && 42#32 == intMin 32 && x == -1) = true ∨
            (x_2 == 0 || 32 != 1 && 42#32 == intMin 32 && x_2 == -1) = true) →
      (((42#32).sdiv x_2 ||| (42#32).sdiv x_1) ^^^ -1#32) &&& (42#32).sdiv x ||

theorem masked_icmps_mask_notallzeros_bmask_mixed_5_proof : masked_icmps_mask_notallzeros_bmask_mixed_5_before ⊑ masked_icmps_mask_notallzeros_bmask_mixed_5_after

theorem lshrugt_02_09_exact_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬(True ∧ x >>> 2#4 <<< 2#4 ≠ x ∨ 2#4 ≥ ↑4) → ofBool (BitVec.ofInt 4 (-7) <ᵤ x >>> 2#4) = 0#1

theorem main1_proof : main1_before ⊑ main1_after

theorem xor_or_xor_common_op_commute6_proof : xor_or_xor_common_op_commute6_before ⊑ xor_or_xor_common_op_commute6_after

theorem test19_proof : test19_before ⊑ test19_after

theorem arbitrary_mask_sub_i8_proof : arbitrary_mask_sub_i8_before ⊑ arbitrary_mask_sub_i8_after

theorem add_1_proof : add_1_before ⊑ add_1_after

theorem sub_shl_same_amount_thm.extracted_1._2 : ∀ (x x_1 x_2 : BitVec 6),
  ¬(x_1 ≥ ↑6 ∨ x_1 ≥ ↑6) → ¬x_1 ≥ ↑6 → x_2 <<< x_1 - x <<< x_1 = (x_2 - x) <<< x_1

theorem positive_biggerLshr_shlnuw_proof : positive_biggerLshr_shlnuw_before ⊑ positive_biggerLshr_shlnuw_after

theorem udiv_eq_big_proof : udiv_eq_big_before ⊑ udiv_eq_big_after

theorem trunc_shl_nsw_nuw_31_i32_i64_thm.extracted_1._2 : ∀ (x : BitVec 64),
  ¬(True ∧ (x <<< 31#64).sshiftRight' 31#64 ≠ x ∨ True ∧ x <<< 31#64 >>> 31#64 ≠ x ∨ 31#64 ≥ ↑64) →
    ¬31#32 ≥ ↑32 → truncate 32 (x <<< 31#64) = truncate 32 x <<< 31#32

theorem add_or_sub_comb_i8_negative_y_add_proof : add_or_sub_comb_i8_negative_y_add_before ⊑ add_or_sub_comb_i8_negative_y_add_after

theorem absdiff1_proof : absdiff1_before ⊑ absdiff1_after

theorem not_zext_proof : not_zext_before ⊑ not_zext_after

theorem lshrult_02_15_thm.extracted_1._1 : ∀ (x : BitVec 4), ¬2#4 ≥ ↑4 → ofBool (x >>> 2#4 <ᵤ -1#4) = 1#1

theorem test44_proof : test44_before ⊑ test44_after

theorem main3c_logical_thm.extracted_1._3 : ∀ (x : BitVec 32),
  ¬ofBool (x &&& 7#32 != 0#32) = 1#1 →
    ofBool (x &&& 48#32 != 0#32) = 1#1 → 0#32 = zeroExtend 32 (ofBool (x &&& 55#32 == 0#32))

@[simp] lemma BitVec.lk11 : (1#2 : BitVec 2)[1] = false

theorem xor_logic_and_logic_or4_proof : xor_logic_and_logic_or4_before ⊑ xor_logic_and_logic_or4_after

theorem lshrugt_03_11_proof : lshrugt_03_11_before ⊑ lshrugt_03_11_after

theorem bools2_logical_commute2_thm.extracted_1._3 : ∀ (x x_1 : BitVec 1), ¬x_1 = 1#1 → 0#1 = 1#1 → False

theorem test83_thm.extracted_1._1 : ∀ (x : BitVec 64) (x_1 : BitVec 16),
  ¬(True ∧ x.saddOverflow (-1#64) = true ∨ truncate 32 (x + -1#64) ≥ ↑32) → truncate 32 x + -1#32 ≥ ↑32 → False

theorem shl_add_proof : shl_add_before ⊑ shl_add_after

theorem select_xor_icmp_proof : select_xor_icmp_before ⊑ select_xor_icmp_after

theorem both_thm.extracted_1._2 : ∀ (x x_1 : BitVec 8),
  ¬(x_1 ≥ ↑8 ∨ x ≥ ↑8) →
    ¬(True ∧ ((-1#8) <<< x_1).sshiftRight' x_1 ≠ -1#8 ∨
          x_1 ≥ ↑8 ∨ True ∧ ((-1#8) <<< x).sshiftRight' x ≠ -1#8 ∨ x ≥ ↑8) →
      ofBool ((-1#8) <<< x_1 ^^^ -1#8 <ᵤ (-1#8) <<< x ^^^ -1#8) = ofBool ((-1#8) <<< x <ᵤ (-1#8) <<< x_1)

theorem main5c_like_logical_thm.extracted_1._3 : ∀ (x : BitVec 32),
  ofBool (x &&& 7#32 != 7#32) = 1#1 → ¬ofBool (x &&& 7#32 == 7#32) = 1#1 → True → 0#32 = zeroExtend 32 0#1

theorem ne_umin4_thm (e e_1 : IntW 32) :
  icmp IntPred.ne (add e_1 (const? 32 3))
      (select (icmp IntPred.ult e (add e_1 (const? 32 3))) e (add e_1 (const? 32 3))) ⊑
    icmp IntPred.ugt (add e_1 (const? 32 3)) e

theorem testi128i128_thm.extracted_1._2 : ∀ (x : BitVec 128),
  ¬127#128 ≥ ↑128 → ¬ofBool (-1#128 <ₛ x) = 1#1 → x.sshiftRight' 127#128 ^^^ 27#128 = BitVec.ofInt 128 (-28)

theorem mul_of_bool_proof : mul_of_bool_before ⊑ mul_of_bool_after

theorem and_consts_logical_thm (e : IntW 32) :
  select (icmp IntPred.eq (LLVM.and (const? 32 4) e) (const? 32 0)) (const? 1 1)
      (icmp IntPred.eq (LLVM.and (const? 32 8) e) (const? 32 0)) ⊑
    icmp IntPred.ne (LLVM.and e (const? 32 12)) (const? 32 12)

theorem not_not_cmp_proof : not_not_cmp_before ⊑ not_not_cmp_after

theorem trunc_shl_33_i32_i64_thm (e : IntW 64) : trunc 32 (shl e (const? 64 33)) ⊑ const? 32 0

theorem mkOutEqZeroCircuitLeN_eval_eq_false_iff {arity : Type _}
  [DecidableEq arity] [Fintype arity] [Hashable arity] (p : FSM arity) (n : Nat)
  (env : Vars p.α arity (n + 1) → Bool) :
  ((mkOutEqZeroCircuitLeN p n).eval env = false) ↔
  (∀ (i : Nat) (hi : i < n + 1),
    env (Vars.outputs ⟨i, by omega⟩) = false)

theorem ult_x_impliesT_eq_umax_todo_thm.extracted_1._2 : ∀ (x x_1 x_2 : BitVec 8),
  ofBool (x_1 <ᵤ x_2) = 1#1 → ofBool (-1#8 != x_1) = 1#1

theorem commutativity_constant_varx_6_invmask_thm.extracted_1._1 : ∀ (x x_1 : BitVec 4),
  (x_1 ^^^ -1#4) &&& (x ^^^ 6#4) ^^^ 6#4 = (x ^^^ 6#4) &&& x_1 ^^^ x

theorem and_not_or_commute4_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 32),
  ¬((x_2 == 0 || 32 != 1 && 42#32 == intMin 32 && x_2 == -1) = true ∨
        (x_2 == 0 || 32 != 1 && 42#32 == intMin 32 && x_2 == -1) = true) →
    (x_2 == 0 || 32 != 1 && 42#32 == intMin 32 && x_2 == -1) = true → False

theorem zext_masked_bit_zero_to_larger_bitwidth_thm.extracted_1._2 : ∀ (x x_1 : BitVec 32),
  ¬x_1 ≥ ↑32 →
    ¬(x_1 ≥ ↑32 ∨ True ∧ ((x ^^^ -1#32) >>> x_1 &&& 1#32).msb = true) →
      zeroExtend 64 (ofBool (1#32 <<< x_1 &&& x == 0#32)) = zeroExtend 64 ((x ^^^ -1#32) >>> x_1 &&& 1#32)

theorem or_basic_thm.extracted_1._1 : ∀ (x : BitVec 16),
  ofBool (truncate 8 x != 127#8) ||

theorem ashrslt_01_15_proof : ashrslt_01_15_before ⊑ ashrslt_01_15_after

theorem no_shift_no_xor_multiuse_or_proof : no_shift_no_xor_multiuse_or_before ⊑ no_shift_no_xor_multiuse_or_after

theorem lshrugt_02_05_exact_proof : lshrugt_02_05_exact_before ⊑ lshrugt_02_05_exact_after

theorem PR45977_f2_thm (e e_1 : IntW 32) :
  LLVM.xor (LLVM.or e_1 e) (LLVM.or e_1 (LLVM.xor e (const? 32 (-1)))) ⊑ LLVM.xor e_1 (const? 32 (-1))

theorem lshr_and_add_thm (e e_1 : IntW 8) :
  shl (add (LLVM.srem e_1 (const? 8 42)) (LLVM.and (lshr e (const? 8 3)) (const? 8 12))) (const? 8 3) ⊑
    add (LLVM.and e (const? 8 96)) (shl (LLVM.srem e_1 (const? 8 42)) (const? 8 3))

theorem shift_trunc_wrong_shift_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬23#32 ≥ ↑32 → ofBool (truncate 8 (x >>> 23#32) <ₛ 0#8) = ofBool (x &&& 1073741824#32 != 0#32)

theorem udiv1_thm (e e_1 : IntW 32) : mul (LLVM.udiv e_1 e { «exact» := true }) e ⊑ e_1

theorem test18_thm.extracted_1._1 : ∀ (x : BitVec 11), ¬10#11 ≥ ↑11 → ofBool (x >>> 10#11 == 123#11) = 0#1

theorem lshrult_02_12_exact_proof : lshrult_02_12_exact_before ⊑ lshrult_02_12_exact_after

theorem cv2_proof : cv2_before ⊑ cv2_after

theorem invert_both_cmp_operands_sub_thm (e e_1 : IntW 32) :
  icmp IntPred.ult (sub (LLVM.xor e_1 (const? 32 (-1))) e) (const? 32 42) ⊑
    icmp IntPred.ugt (add e_1 e) (const? 32 (-43))

theorem e_1574 :
     - 5 * (b &&& c) + 1 * (c ^^^ ( ~~~a ||| ( ~~~b ||| c))) + 2 * ((a &&& c) ||| (b &&&  ~~~c)) - 6 * ((b &&& c) ||| ( ~~~a &&& (b ||| c))) + 2 * ( ~~~(a &&& b) &&& (a ^^^ (b ^^^ c))) - 7 * (b ^^^ (a ||| c)) + 1 * (b ^^^  ~~~( ~~~a ||| (b ^^^ c))) + 4 * (c ^^^  ~~~( ~~~a &&& (b ||| c))) - 5 *  ~~~(a ||| (b ||| c)) + 12 *  ~~~(a ||| ( ~~~b ||| c)) + 4 *  ~~~( ~~~a ||| (b ||| c)) - 7 *  ~~~( ~~~a ||| ( ~~~b ||| c)) + 7 * ( ~~~a &&& ( ~~~b &&& c)) + 6 * ( ~~~a &&& (b &&& c)) + 10 * (a &&& ( ~~~b &&& c)) + 14 * (a &&& (b &&& c)) = 5 *  ~~~(a ^^^ ( ~~~b ||| c))

theorem sub_select_sext_thm (e : IntW 64) (e_1 : IntW 1) :
  sub (select e_1 (const? 64 64) e) (sext 64 e_1) ⊑ select e_1 (const? 64 65) e

theorem e_743 :
    1 * y - 6 * (x |||  ~~~y) + 7 *  ~~~x - 2 * (x ^^^ y) - 7 * x + 4 * (x ||| y) - 3 *  ~~~(x ^^^ y) + 2 *  ~~~y - 4 *  ~~~(x ||| y) + 5 * (x &&&  ~~~y) + 7 * (x &&& y) = 14 *  ~~~(x |||  ~~~y) - 4 *  ~~~(x &&&  ~~~x)

theorem ugt_sext_proof : ugt_sext_before ⊑ ugt_sext_after

theorem c0_proof : c0_before ⊑ c0_after

theorem sge_or_max_logical_proof : sge_or_max_logical_before ⊑ sge_or_max_logical_after

theorem positive_with_mask_thm (e : IntW 32) :
  LLVM.and (icmp IntPred.eq (LLVM.and e (const? 32 1107296256)) (const? 32 0))
      (icmp IntPred.ult (add e (const? 32 128)) (const? 32 256)) ⊑
    icmp IntPred.ult e (const? 32 128)

theorem positive_easyinvert_thm.extracted_1._1 : ∀ (x : BitVec 16) (x_1 : BitVec 8),
  ofBool (x_1 <ₛ 0#8) ^^^ ofBool (x <ₛ 0#16) ^^^ 1#1 = ofBool (x_1 <ₛ 0#8) ^^^ ofBool (-1#16 <ₛ x)

theorem shl_nsw_nuw_poison_constant_fold_thm (e : IntW 8) (e_1 : IntW 1) :
  shl (const? 8 16) (select e_1 (const? 8 3) e) { «nsw» := true, «nuw» := true } ⊑
    select e_1 (const? 8 (-128)) (shl (const? 8 16) e { «nsw» := true, «nuw» := true })

theorem add_smin_simplify2_proof : add_smin_simplify2_before ⊑ add_smin_simplify2_after

theorem alive_AndOrXor_2118___A__B__A___A__B : alive_AndOrXor_2118___A__B__A___A__B_src ⊑ alive_AndOrXor_2118___A__B__A___A__B_tgt

theorem ashrslt_02_14_exact_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬(True ∧ x >>> 2#4 <<< 2#4 ≠ x ∨ 2#4 ≥ ↑4) → ofBool (x.sshiftRight' 2#4 <ₛ BitVec.ofInt 4 (-2)) = 0#1

theorem not_mul_of_bool_commute_thm (e e_1 : IntW 32) :
  icmp IntPred.ugt (mul (LLVM.and e_1 (const? 32 255)) (lshr e (const? 32 30))) (const? 32 255) ⊑
    icmp IntPred.ugt (mul (LLVM.and e_1 (const? 32 255)) (lshr e (const? 32 30)) { «nsw» := true, «nuw» := true })
      (const? 32 255)

theorem test3_proof : test3_before ⊑ test3_after

@[simp] theorem Hom.castDomain_rfl {h : Δ = Δ} {f : Γ.Hom Δ} :
    (f.castCodomain h) = f

theorem test3_proof : test3_before ⊑ test3_after

theorem test85_proof : test85_before ⊑ test85_after

theorem zext_add_proof : zext_add_before ⊑ zext_add_after

theorem udiv_common_dividend_defined_cond_thm.extracted_1._1 : ∀ (x x_1 : BitVec 5) (x_2 : BitVec 1),
  ¬(x_2 = 1#1 ∨ x = 0) → x_2 = 1#1 → False

theorem test_proof : test_before ⊑ test_after

theorem icmp_eq_zext_ne_one_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (zeroExtend 32 (ofBool (x != 1#32)) == x) = 0#1

theorem src_srem_shl_demand_max_signbit_mask_hit_first_demand_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬((4#32 == 0 || 32 != 1 && x == intMin 32 && 4#32 == -1) = true ∨ 29#32 ≥ ↑32) →
    (4#32 == 0 || 32 != 1 && x == intMin 32 && 4#32 == -1) = true ∨
        True ∧ (x.srem 4#32 <<< 29#32).sshiftRight' 29#32 ≠ x.srem 4#32 ∨ 29#32 ≥ ↑32 →
      False

theorem e_2313 :
     - 1 * (f ^^^  ~~~(d &&& e)) + 2 * ((d |||  ~~~e) &&&  ~~~(e ^^^ f)) + 2 * (e &&&  ~~~(d &&&  ~~~f)) + 1 * (e &&& (d |||  ~~~f)) + 3 * (e ^^^  ~~~(d |||  ~~~f)) - 3 *  ~~~(d &&& ( ~~~e ||| f)) + 5 * (e ^^^ ( ~~~d &&& (e ||| f))) + 4 * (f ^^^ ( ~~~d ||| ( ~~~e ||| f))) - 7 * ( ~~~(d |||  ~~~e) ||| (e ^^^ f)) + 4 *  ~~~(d &&& (e ^^^ f)) - 2 * (f ^^^  ~~~(d &&& (e ||| f))) + 11 * ((d &&& f) ^^^ (d ^^^ (e &&& f))) + 11 *  ~~~(d |||  ~~~e) + 2 *  ~~~( ~~~d &&& ( ~~~e &&& f)) - 3 * ( ~~~(d &&&  ~~~e) &&& (d ^^^ (e ^^^ f))) + 3 * (e ||| (d &&& f)) + 1 * ((d &&& e) |||  ~~~(e ^^^ f)) - 5 * (f ^^^  ~~~(d ||| e)) - 7 * ( ~~~d &&& (e ||| f)) - 5 * (f ^^^ (d ||| (e ||| f))) - 3 * ( ~~~(d ^^^ e) |||  ~~~(d ^^^ f)) + 1 * (e ^^^ (d ||| (e ||| f))) + 4 * ((d &&& e) ^^^ (e |||  ~~~f)) + 5 * (f ^^^ (d &&&  ~~~e)) + 1 * (d ^^^ e) - 11 * ((d &&&  ~~~e) ||| (d ^^^ (e ^^^ f))) + 2 * (f ^^^  ~~~(d &&& ( ~~~e &&& f))) - 11 * ((d &&& e) |||  ~~~(e ||| f)) + 1 * (e ^^^  ~~~(d ||| (e ^^^ f))) - 1 * (f ^^^ (d &&& e)) - 1 * ((d &&& f) ^^^  ~~~(d ^^^ ( ~~~e &&& f))) - 6 * ((d ^^^ e) |||  ~~~(d ^^^ f)) - 7 *  ~~~( ~~~d &&& ( ~~~e ||| f)) + 11 * ( ~~~e |||  ~~~(d ^^^ f)) - 2 * (d ||| (e ^^^ f)) + 11 *  ~~~(d ^^^ ( ~~~e ||| f)) - 1 *  ~~~(d &&& (e ||| f)) - 2 * (e ^^^  ~~~(d &&& (e &&& f))) + 2 * (e ^^^ ( ~~~d &&& (e ^^^ f))) - 5 * ( ~~~(d ^^^ e) ||| (d ^^^ f)) + 1 * ((d ||| e) &&& (d ^^^ (e ^^^ f))) + 5 * (d ||| (e &&& f)) + 7 *  ~~~( ~~~d &&& (e ||| f)) + 3 * ((d |||  ~~~e) &&&  ~~~(d ^^^ (e ^^^ f))) + 2 * (e &&& f) - 5 * (e ^^^ ( ~~~d &&& ( ~~~e ||| f))) - 2 * (d ^^^ f) - 1 * (e &&&  ~~~(d &&& f)) - 5 * (e ^^^  ~~~( ~~~d ||| (e ^^^ f))) - 5 * (e ^^^ (d &&&  ~~~f)) - 7 *  ~~~(d ^^^ e) - 2 * ((d &&& e) ^^^  ~~~(d ^^^ ( ~~~e ||| f))) + 7 * ((d |||  ~~~e) &&& (e ^^^ f)) - 5 * ((d ||| e) &&& (e ^^^ f)) + 1 * ((d &&& e) ^^^ (e ||| f)) + 11 *  ~~~(d ||| (e ||| f)) + 20 *  ~~~(d ||| ( ~~~e ||| f)) - 5 *  ~~~( ~~~d ||| (e ||| f)) + 11 *  ~~~( ~~~d ||| ( ~~~e ||| f)) + 20 * ( ~~~d &&& ( ~~~e &&& f)) - 12 * ( ~~~d &&& (e &&& f)) - 8 * (d &&& ( ~~~e &&& f)) - 10 * (d &&& (e &&& f)) =  - 7 * ((e &&& f) ||| (d &&& (e ||| f)))

theorem test20_proof : test20_before ⊑ test20_after

theorem test_shift_and_cmp_changed1_thm (e e_1 : IntW 8) :
  icmp IntPred.slt
      (ashr (shl (LLVM.or (LLVM.and e_1 (const? 8 8)) (LLVM.and e (const? 8 6))) (const? 8 5)) (const? 8 5))
      (const? 8 1) ⊑
    icmp IntPred.slt (LLVM.and (shl e (const? 8 5)) (const? 8 (-64))) (const? 8 32)

theorem test_or2_logical_thm.extracted_1._2 : ∀ (x x_1 : BitVec 32),
  ofBool (x_1 ≤ₛ -1#32) = 1#1 → ¬ofBool (x_1 <ₛ 0#32) = 1#1 → 1#1 = ofBool (x &&& 2147483647#32 <ₛ x_1)

theorem mul32_low_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬(16#32 ≥ ↑32 ∨ 16#32 ≥ ↑32 ∨ 16#32 ≥ ↑32) →
    (x_1 >>> 16#32 * (x &&& 65535#32) + (x_1 &&& 65535#32) * x >>> 16#32) <<< 16#32 +
        (x_1 &&& 65535#32) * (x &&& 65535#32) =
      x * x_1

theorem scalar_i16_shl_and_negC_eq_proof : scalar_i16_shl_and_negC_eq_before ⊑ scalar_i16_shl_and_negC_eq_after

theorem bool_add_lshr_proof : bool_add_lshr_before ⊑ bool_add_lshr_after

theorem e_772 :
    4 *  ~~~(z &&&  ~~~z) + 4 *  ~~~(z &&&  ~~~t) - 6 * (z ^^^ t) - 2 *  ~~~(z |||  ~~~t) - 8 * (z &&& t) = 8 *  ~~~(z ||| t) - 2 * (z &&&  ~~~t)

theorem e_2154 :
    1 * (f ^^^  ~~~( ~~~d &&& ( ~~~e &&& f))) - 5 * ( ~~~(d ^^^ e) ||| (d ^^^ f)) - 1 * (f &&&  ~~~(d ^^^ e)) - 2 * ((d &&& e) ^^^  ~~~(d ^^^ ( ~~~e ||| f))) + 7 *  ~~~(d &&& f) + 1 * (e &&& f) + 2 *  ~~~(e ^^^ f) - 1 *  ~~~( ~~~d ||| (e &&& f)) + 5 * (e ^^^ ( ~~~d &&& (e ||| f))) + 5 * ( ~~~d ||| ( ~~~e ||| f)) + 2 * ( ~~~d &&& ( ~~~e ||| f)) - 1 * ( ~~~(d ^^^ e) &&&  ~~~(d ^^^ f)) + 11 * ((d &&& e) ^^^ (d ^^^ ( ~~~e ||| f))) + 7 * (f ^^^ ( ~~~d &&& (e ||| f))) - 11 * (f ^^^ (d &&& ( ~~~e ||| f))) + 2 * ( ~~~f &&& (d ^^^ e)) - 3 * (f &&& (d ^^^ e)) + 11 * ((d ^^^ e) |||  ~~~(d ^^^ f)) + 3 * ( ~~~(d |||  ~~~e) ||| (e ^^^ f)) - 5 * ( ~~~(d ||| e) ||| (e ^^^ f)) - 11 * (d &&& ( ~~~e ||| f)) - 1 * (e |||  ~~~f) + 2 * (d ^^^ (e ^^^ f)) + 1 * (f ^^^ ( ~~~d ||| (e ||| f))) - 5 *  ~~~(d ||| (e ^^^ f)) + 7 * (d ||| (e ||| f)) + 2 *  ~~~(d &&& e) + 1 *  ~~~(e &&& f) - 5 * ((e &&&  ~~~f) ^^^ ( ~~~d ||| (e ^^^ f))) - 1 * (e ^^^ ( ~~~d ||| (e &&& f))) - 1 * (f ^^^  ~~~(d &&& (e &&& f))) - 6 *  ~~~( ~~~d &&& (e &&& f)) + 1 * d - 5 * ( ~~~(d ^^^ e) &&& (d ^^^ f)) + 3 * ((d |||  ~~~e) &&& (d ^^^ (e ^^^ f))) + 11 * (f ^^^  ~~~(d &&& (e ||| f))) + 5 *  ~~~e + 11 * (f &&& (d ||| e)) + 3 * (f ^^^ (d ||| (e &&& f))) - 2 * (f ^^^ ( ~~~d ||| ( ~~~e ||| f))) - 16 *  ~~~(d ||| (e ||| f)) - 41 *  ~~~(d ||| ( ~~~e ||| f)) - 12 *  ~~~( ~~~d ||| (e ||| f)) + 11 *  ~~~( ~~~d ||| ( ~~~e ||| f)) - 16 * ( ~~~d &&& ( ~~~e &&& f)) - 32 * ( ~~~d &&& (e &&& f)) - 18 * (d &&& ( ~~~e &&& f)) - 38 * (d &&& (e &&& f)) = 2 * ((d &&& e) ||| (e ^^^ f)) + 11 *  ~~~( ~~~d &&& (e ||| f))

theorem t14_x_is_one_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬(32#32 - x ≥ ↑32 ∨ zeroExtend 64 (x + BitVec.ofInt 32 (-16)) ≥ ↑64) →
    ofBool (x_1 <<< (32#32 - x) &&& truncate 32 (1#64 >>> zeroExtend 64 (x + BitVec.ofInt 32 (-16))) != 0#32) = 0#1

theorem test_shl__nsw_is_safe_proof : test_shl__nsw_is_safe_before ⊑ test_shl__nsw_is_safe_after

theorem sge_or_not_max_proof : sge_or_not_max_before ⊑ sge_or_not_max_after

theorem e_1356 :
    2 * t + 7 * z + 3 * (z ^^^ t) + 7 *  ~~~(z &&&  ~~~t) + 1 *  ~~~(z &&&  ~~~z) - 6 *  ~~~(z ^^^ t) - 7 *  ~~~(z ||| t) - 13 *  ~~~(z |||  ~~~t) - 6 * (z &&&  ~~~t) - 6 * (z &&& t) = 5 * (z ||| t) - 5 *  ~~~z

theorem zext_masked_bit_zero_to_larger_bitwidth_proof : zext_masked_bit_zero_to_larger_bitwidth_before ⊑ zext_masked_bit_zero_to_larger_bitwidth_after

theorem t1_sub_of_falseval_proof : t1_sub_of_falseval_before ⊑ t1_sub_of_falseval_after

theorem ashrsgt_03_09_proof : ashrsgt_03_09_before ⊑ ashrsgt_03_09_after

theorem or_xor_xor_normal_binops_thm (e e_1 e_2 : IntW 32) :
  LLVM.or (LLVM.xor (LLVM.xor e_2 e_1) (LLVM.and (LLVM.xor e_2 e_1) (LLVM.xor e e_1)))
      (LLVM.xor (LLVM.xor e e_1) (LLVM.and (LLVM.xor e_2 e_1) (LLVM.xor e e_1))) ⊑
    LLVM.xor e_2 e

theorem sgt_smax1_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ofBool (x <ₛ x_1) = 1#1 → ofBool (x_1 <ₛ x_1) = ofBool (x_1 <ₛ x)

theorem ashr_x_by_const_cmp_sge_x_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬5#32 ≥ ↑32 → ofBool (x ≤ₛ x.sshiftRight' 5#32) = ofBool (x <ₛ 1#32)

theorem or_not_and_commute5_proof : or_not_and_commute5_before ⊑ or_not_and_commute5_after

theorem different_size_zext_zext_eq_thm.extracted_1._1 : ∀ (x : BitVec 7) (x_1 : BitVec 4),
  ofBool (zeroExtend 25 x_1 == zeroExtend 25 x) = ofBool (x == zeroExtend 7 x_1)

theorem negate_lshr_proof : negate_lshr_before ⊑ negate_lshr_after

@[bv_multi_width_normalize] theorem not_eq_eq {α : Sort u} (a b : α) : (¬ (a = b)) = (a ≠ b)

@[simp]
theorem BitVec.intCast_eq_ofInt : ((i : Int) : BitVec w) = BitVec.ofInt w i

theorem eq3 (w : Nat) (a b : BitVec w) : a = a ||

theorem cmpeq_xor_cst1_commuted_proof : cmpeq_xor_cst1_commuted_before ⊑ cmpeq_xor_cst1_commuted_after

@[simp]
theorem Eqn.denote_cons {w : Nat}
    (t : Term) (ts : List Term) (env : Env w) :
    Eqn.denote (t :: ts) env = t.denote env + Eqn.denote ts env

theorem or_xor_common_op_commute0_proof : or_xor_common_op_commute0_before ⊑ or_xor_common_op_commute0_after

theorem fold_add_udiv_urem_to_mul_proof : fold_add_udiv_urem_to_mul_before ⊑ fold_add_udiv_urem_to_mul_after

theorem e_904 :
     - 1 *  ~~~(z ^^^ t) + 7 * z + 2 * (z ^^^ t) + 8 *  ~~~(z ||| t) - 2 * (z &&&  ~~~t) - 6 * (z &&& t) = 7 *  ~~~t + 2 *  ~~~(z |||  ~~~t)

theorem ashrslt_02_12_exact_thm (e : IntW 4) :
  icmp IntPred.slt (ashr e (const? 4 2) { «exact» := true }) (const? 4 (-4)) ⊑ const? 1 0

theorem uge_zext_thm (e : IntW 8) (e_1 : IntW 1) :
  icmp IntPred.uge (zext 8 e_1) e ⊑ icmp IntPred.ule e (zext 8 e_1)

theorem icmp_ne_and1_lshr_pow2_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬x ≥ ↑32 → zeroExtend 32 (ofBool (8#32 >>> x &&& 1#32 == 0#32)) = zeroExtend 32 (ofBool (x != 3#32))

theorem sle_or_min_logical_thm.extracted_1._2 : ∀ (x x_1 : BitVec 8),
  ¬ofBool (x_1 ≤ₛ x) = 1#1 → ofBool (x_1 == BitVec.ofInt 8 (-128)) = ofBool (x_1 ≤ₛ x)

theorem merge_right_shift (hu : u >= p) (hts : t > s) (htq : t > q) :
  (bw r (shrMax (bw u (shrMax (bw p a) (bw q b))) (bw s c)))  =
  (bw r (shrMax (bw p a) (bw t (addMax (bw q b) (bw s c)))))

theorem add_signbit_select_shl_proof : add_signbit_select_shl_before ⊑ add_signbit_select_shl_after

theorem icmp_ne_zext_ne_zero_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (zeroExtend 32 (ofBool (x != 0#32)) != x) = ofBool (1#32 <ᵤ x)

theorem add_mask_ashr27_i32_thm (e : IntW 32) :
  add (LLVM.and (ashr e (const? 32 27)) (const? 32 8)) (ashr e (const? 32 27)) ⊑
    add (LLVM.and (ashr e (const? 32 27)) (const? 32 8)) (ashr e (const? 32 27))
      { «nsw» := true, «nuw» := false }

theorem demorgan_nor_proof : demorgan_nor_before ⊑ demorgan_nor_after

theorem test4_thm (e : IntW 1) (e_1 : IntW 32) :
  urem e_1 (select e (const? 32 1) (const? 32 8)) ⊑ LLVM.and e_1 (select e (const? 32 0) (const? 32 7))

theorem test14_proof : test14_before ⊑ test14_after

theorem zext_masked_bit_nonzero_to_smaller_bitwidth_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬x_1 ≥ ↑32 → zeroExtend 16 (ofBool (1#32 <<< x_1 &&& x != 0#32)) = truncate 16 (x >>> x_1) &&& 1#16

theorem ult_toNat (x y : BitVec n) :
    (BitVec.ult (n := n) x y) = decide (x.toNat < y.toNat)

theorem foo1_and_signbit_lshr_thm (e e_1 e_2 : IntW 32) :
  LLVM.or (icmp IntPred.eq (LLVM.and (shl (const? 32 1) e_2) e_1) (const? 32 0))
      (icmp IntPred.eq (LLVM.and (lshr (const? 32 (-2147483648)) e) e_1) (const? 32 0)) ⊑
    icmp IntPred.ne
      (LLVM.and e_1
        (LLVM.or (shl (const? 32 1) e_2 { «nsw» := false, «nuw» := true })
          (lshr (const? 32 (-2147483648)) e { «exact» := true })))
      (LLVM.or (shl (const? 32 1) e_2 { «nsw» := false, «nuw» := true })
        (lshr (const? 32 (-2147483648)) e { «exact» := true }))

theorem ashr_lshr_no_lshr_proof : ashr_lshr_no_lshr_before ⊑ ashr_lshr_no_lshr_after

theorem test_mul__nuw_is_safe_thm (e : IntW 32) :
  select (icmp IntPred.eq (LLVM.and e (const? 32 268435457)) (const? 32 268435456)) (const? 32 (-1879048192))
      (mul (LLVM.and e (const? 32 268435457)) (const? 32 9)) ⊑
    mul (LLVM.and e (const? 32 268435457)) (const? 32 9) { «nsw» := false, «nuw» := true }

theorem bitwise_or_logical_or_icmps_thm.extracted_1._3 : ∀ (x x_1 x_2 : BitVec 8),
  ¬ofBool (x_2 == 42#8) = 1#1 →
    ¬x ≥ ↑8 →
      ¬(True ∧ 1#8 <<< x >>> x ≠ 1#8 ∨ x ≥ ↑8 ∨ True ∧ 1#8 <<< x >>> x ≠ 1#8 ∨ x ≥ ↑8) →
        ofBool (x_1 &&& 1#8 == 0#8) ||

theorem e_656 :
     - 2 * (x ^^^ y) + 1 *  ~~~x + 1 *  ~~~(x &&&  ~~~y) + 1 * y + 1 * (x ||| y) - 7 *  ~~~(x ^^^ y) - 1 * (x |||  ~~~y) + 7 *  ~~~(x ||| y) + 3 * (x &&&  ~~~y) + 5 * (x &&& y) = 2 *  ~~~(x &&& y) - 1 *  ~~~y

theorem eq_10_proof : eq_10_before ⊑ eq_10_after

theorem not_and_and_or_not_or_or_commute2_and_proof : not_and_and_or_not_or_or_commute2_and_before ⊑ not_and_and_or_not_or_or_commute2_and_after

theorem t1_ult_slt_0_thm.extracted_1._10 : ∀ (x x_1 x_2 : BitVec 32),
  ¬ofBool (x_2 <ᵤ 65536#32) = 1#1 → ofBool (x_2 <ₛ 0#32) = 1#1 → ofBool (65535#32 <ₛ x_2) = 1#1 → x_1 = x

theorem test5_proof : test5_before ⊑ test5_after

theorem neg_nsw_slt_0_proof : neg_nsw_slt_0_before ⊑ neg_nsw_slt_0_after

theorem logical_or_implies_folds_proof : logical_or_implies_folds_before ⊑ logical_or_implies_folds_after

theorem fold_sext_to_and_wrong2_proof : fold_sext_to_and_wrong2_before ⊑ fold_sext_to_and_wrong2_after

theorem test5_proof : test5_before ⊑ test5_after

theorem select_icmp_and_2147483648_ne_0_xor_2147483648_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬ofBool (x &&& BitVec.ofInt 32 (-2147483648) == 0#32) = 1#1 →
    x ^^^ BitVec.ofInt 32 (-2147483648) = x &&& 2147483647#32

theorem main2_logical_thm.extracted_1._4 : ∀ (x : BitVec 32),
  ¬ofBool (x &&& 1#32 == 0#32) = 1#1 →
    ¬ofBool (x &&& 2#32 == 0#32) = 1#1 → 1#32 = zeroExtend 32 (ofBool (x &&& 3#32 == 3#32))

theorem test88_thm.extracted_1._2 : ∀ (x : BitVec 16),
  ¬18#32 ≥ ↑32 → ¬15#16 ≥ ↑16 → truncate 16 ((signExtend 32 x).sshiftRight' 18#32) = x.sshiftRight' 15#16

theorem substitute_constant_and_eq_eq_proof : substitute_constant_and_eq_eq_before ⊑ substitute_constant_and_eq_eq_after

theorem demorgan_and_apint5_thm.extracted_1._1 : ∀ (x x_1 : BitVec 47),
  (x_1 ^^^ -1#47) &&& (x ^^^ -1#47) = (x_1 ||| x) ^^^ -1#47

theorem zext_sext_add_icmp_ne_minus1_proof : zext_sext_add_icmp_ne_minus1_before ⊑ zext_sext_add_icmp_ne_minus1_after

theorem foo1_and_commuted_thm.extracted_1._2 : ∀ (x x_1 x_2 : BitVec 32),
  ¬(x_1 ≥ ↑32 ∨ x ≥ ↑32) →
    ¬(True ∧ 1#32 <<< x_1 >>> x_1 ≠ 1#32 ∨
          x_1 ≥ ↑32 ∨
            True ∧ 1#32 <<< x >>> x ≠ 1#32 ∨
              x ≥ ↑32 ∨ True ∧ 1#32 <<< x_1 >>> x_1 ≠ 1#32 ∨ x_1 ≥ ↑32 ∨ True ∧ 1#32 <<< x >>> x ≠ 1#32 ∨ x ≥ ↑32) →
      ofBool (x_2 * x_2 &&& 1#32 <<< x_1 == 0#32) ||

theorem trunc_nuw_xor_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ¬(True ∧ zeroExtend 8 (truncate 1 (x_1 ^^^ x)) ≠ x_1 ^^^ x) → truncate 1 (x_1 ^^^ x) = ofBool (x_1 != x)

theorem sub_const_add_const_thm (e : IntW 32) : add (sub e (const? 32 8)) (const? 32 2) ⊑ add e (const? 32 (-6))

theorem shl_nsw_nuw_poison_constant_fold_thm.extracted_1._1 : ∀ (x : BitVec 1),
  x = 1#1 →
    ¬(True ∧ (16#8 <<< 3#8).sshiftRight' 3#8 ≠ 16#8 ∨ True ∧ 16#8 <<< 3#8 >>> 3#8 ≠ 16#8 ∨ 3#8 ≥ ↑8) →
      16#8 <<< 3#8 = BitVec.ofInt 8 (-128)

theorem bools_logical_commute1_and2_thm.extracted_1._1 : ∀ (x : BitVec 1), ¬x = 1#1 → 0#1 = 1#1 → False

theorem shl_add_and_proof : shl_add_and_before ⊑ shl_add_and_after

theorem sub_ashr_and_i32_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬(True ∧ x_1.ssubOverflow x = true ∨ 31#32 ≥ ↑32) →
    ofBool (x_1 <ₛ x) = 1#1 → (x_1 - x).sshiftRight' 31#32 &&& x = x

theorem e_753 :
     - 2 *  ~~~z + 3 * (z ^^^ t) - 1 *  ~~~(z |||  ~~~t) =  - 2 *  ~~~t + 5 * (z &&&  ~~~t)

theorem signed_sign_bit_extract_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬31#32 ≥ ↑32 → ofBool (x.sshiftRight' 31#32 != 0#32) = ofBool (x <ₛ 0#32)

theorem sgt_x_impliesF_eq_smin_todo_proof : sgt_x_impliesF_eq_smin_todo_before ⊑ sgt_x_impliesF_eq_smin_todo_after

theorem fold_add_udiv_urem_commuted_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬(10#32 = 0 ∨ 10#32 = 0 ∨ 4#32 ≥ ↑32) →
    ¬(10#32 = 0 ∨ True ∧ (x / 10#32).umulOverflow 6#32 = true) →
      x % 10#32 + (x / 10#32) <<< 4#32 = x / 10#32 * 6#32 + x

theorem test_or_eq_a_b_thm.extracted_1._2 : ∀ (x x_1 : BitVec 8) (x_2 : BitVec 1),
  ¬x_2 ||

theorem n12_proof : n12_before ⊑ n12_after

theorem n7_proof : n7_before ⊑ n7_after

theorem scalar_i32_lshr_and_negC_eq_X_is_constant2_thm (e : IntW 32) :
  icmp IntPred.eq (LLVM.and (lshr (const? 32 (-2147483648)) e) (const? 32 (-2147483648))) (const? 32 0) ⊑
    icmp IntPred.ne e (const? 32 0)

theorem icmp_slt_0_and_icmp_sge_neg1_i64_fail_thm.extracted_1._1 : ∀ (x : BitVec 64),
  ¬62#64 ≥ ↑64 →
    ofBool (BitVec.ofInt 64 (-2) <ₛ x) = 1#1 →
      x >>> 62#64 &&& zeroExtend 64 (ofBool (-1#64 ≤ₛ x)) = x >>> 62#64 &&& 1#64

theorem xor_or_thm.extracted_1._4 : ∀ (x : BitVec 32) (x_1 : BitVec 1),
  x_1 = 1#1 → ¬x_1 ^^^ 1#1 = 1#1 → 1#1 ^^^ 1#1 = 0#1

theorem and_or2_commuted_thm.extracted_1._6 : ∀ (x x_1 x_2 : BitVec 1),
  ¬x_2 &&& (x_1 ^^^ 1#1) = 1#1 → x_2 = 1#1 → x_1 = 1#1 → x_2 = 1#1

private theorem not_gt_eq_le (A B : BitVec w) : (¬ (A >ₛ B)) = (A ≤ₛ B)

theorem test_sub_nuw_nsw__all_are_safe_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x &&& 255#32 == 6#32) = 1#1 →
    True ∧ (BitVec.ofInt 32 (-254)).ssubOverflow (x &&& 255#32) = true ∨
        True ∧ (BitVec.ofInt 32 (-254)).usubOverflow (x &&& 255#32) = true →
      False

theorem do_not_add_annotation_to_existing_instr_thm (e e_1 : IntW 32) : add (const? 32 0) (add e_1 e) ⊑ add e_1 e

theorem lshrult_01_05_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬1#4 ≥ ↑4 → ofBool (x >>> 1#4 <ᵤ 5#4) = ofBool (x <ᵤ BitVec.ofInt 4 (-6))

theorem or_xor_tree_0111_proof : or_xor_tree_0111_before ⊑ or_xor_tree_0111_after

theorem main4b_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x &&& 7#32 == 7#32) &&& ofBool (x &&& 16#32 != 0#32) = 1#1 →
    0#32 = zeroExtend 32 (ofBool (x &&& 23#32 != 23#32))

theorem main3e_like_logical_thm.extracted_1._8 : ∀ (x x_1 x_2 : BitVec 32),
  ofBool (x_2 &&& x_1 == 0#32) = 1#1 →
    ¬ofBool (x_2 &&& x_1 != 0#32) = 1#1 →
      ¬ofBool (x_2 &&& x == 0#32) = 1#1 → 1#32 = zeroExtend 32 (ofBool (x_2 &&& x != 0#32))

theorem or_and2_commuted_thm.extracted_1._6 : ∀ (x x_1 x_2 : BitVec 1),
  x_2 ||

theorem ashrslt_02_12_proof : ashrslt_02_12_before ⊑ ashrslt_02_12_after

theorem exact_lshr_ne_proof : exact_lshr_ne_before ⊑ exact_lshr_ne_after

theorem positive_sameconst_shlnsw_ashrexact_proof : positive_sameconst_shlnsw_ashrexact_before ⊑ positive_sameconst_shlnsw_ashrexact_after

theorem add_and_or_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32), (x_1 &&& x) + (x_1 ||| x) = x_1 + x

theorem bools2_logical_commute0_thm.extracted_1._14 : ∀ (x x_1 x_2 : BitVec 1),
  x_2 = 1#1 → x_2 ^^^ 1#1 = 1#1 → ¬x_1 = 1#1 → x = x_1

theorem e_962 :
     - 1 *  ~~~(z &&& t) + 7 *  ~~~(z ^^^ t) + 5 * (z ^^^ t) - 4 *  ~~~(z ||| t) - 4 * (z &&&  ~~~t) - 5 * (z &&& t) = 2 *  ~~~(z &&&  ~~~t) + 2 *  ~~~(z |||  ~~~t)

theorem e_9 :
     - 2 * (x ^^^ y) + 11 * (x ||| y) + 5 * y - 9 * (x &&&  ~~~y) = 14 *  ~~~(x |||  ~~~y) + 16 * (x &&& y)

theorem and_xor_commute4_thm.extracted_1._2 : ∀ (x x_1 : BitVec 32),
  ¬(x_1 = 0 ∨ x = 0 ∨ x_1 = 0) →
    ¬(x_1 = 0 ∨ x = 0) → 42#32 / x_1 ^^^ 42#32 / x &&& 42#32 / x_1 = 42#32 / x_1 &&& (42#32 / x ^^^ -1#32)

theorem test_and4_logical_proof : test_and4_logical_before ⊑ test_and4_logical_after

theorem sub_select_zext_op_swapped_non_const_args_thm.extracted_1._2 : ∀ (x : BitVec 6) (x_1 : BitVec 1),
  ¬x_1 = 1#1 → zeroExtend 6 x_1 - x = 0#6 - x

theorem logic_and_logic_or_5_thm.extracted_1._2 : ∀ (x x_1 : BitVec 1), ¬x_1 = 1#1 → 0#1 = 1#1 → 1#1 = 0#1

theorem basic_preserve_nuw_nsw_thm.extracted_1._2 : ∀ (x x_1 : BitVec 8),
  ¬(True ∧ (x_1 ^^^ -1#8).saddOverflow x = true ∨ True ∧ (x_1 ^^^ -1#8).uaddOverflow x = true) →
    ¬(True ∧ x_1.ssubOverflow x = true ∨ True ∧ x_1.usubOverflow x = true) → (x_1 ^^^ -1#8) + x ^^^ -1#8 = x_1 - x

theorem lshrult_01_11_exact_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬(True ∧ x >>> 1#4 <<< 1#4 ≠ x ∨ 1#4 ≥ ↑4) → ofBool (x >>> 1#4 <ᵤ BitVec.ofInt 4 (-5)) = 1#1

theorem sext_diff_i1_xor_sub_thm.extracted_1._2 : ∀ (x x_1 : BitVec 1),
  ¬(True ∧ (zeroExtend 64 x).saddOverflow (signExtend 64 x_1) = true) →
    signExtend 64 x_1 - signExtend 64 x = zeroExtend 64 x + signExtend 64 x_1

theorem select_zext_or_eq_ult_add_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬ofBool (x + BitVec.ofInt 32 (-3) <ᵤ 2#32) = 1#1 →
    zeroExtend 32 (ofBool (x == 5#32)) = zeroExtend 32 (ofBool (x + BitVec.ofInt 32 (-3) <ᵤ 3#32))

theorem and_xor_or8_thm.extracted_1._2 : ∀ (x x_1 x_2 : BitVec 64),
  ¬(x_2 = 0 ∨ x_1 = 0 ∨ x_2 = 0 ∨ x = 0) →
    ¬(x_2 = 0 ∨ x_1 = 0) → 42#64 / x_2 ||

theorem e_1294 :
     - 2 * (z ^^^ t) - 5 *  ~~~(z &&&  ~~~t) - 2 *  ~~~(z ^^^ t) + 7 * (z |||  ~~~t) + 11 *  ~~~z - 2 *  ~~~(z &&&  ~~~z) - 7 *  ~~~t - 2 *  ~~~(z ||| t) - 4 *  ~~~(z |||  ~~~t) =  - 2 * t - 4 * (z &&&  ~~~t)

theorem e_572 :
     - 11 *  ~~~(x ^^^ y) + 3 * (x ^^^ y) + 1 * y - 2 *  ~~~(x &&&  ~~~x) - 1 *  ~~~(x &&&  ~~~y) + 14 *  ~~~(x ||| y) - 3 *  ~~~(x |||  ~~~y) - 3 * (x &&&  ~~~y) + 11 * (x &&& y) =  - 2 * (x ||| y)

theorem demorgan_or_apint1_thm (e e_1 : IntW 43) :
  LLVM.or (LLVM.xor e_1 (const? 43 (-1))) (LLVM.xor e (const? 43 (-1))) ⊑
    LLVM.xor (LLVM.and e_1 e) (const? 43 (-1))

theorem eq_umin3_proof : eq_umin3_before ⊑ eq_umin3_after

theorem icmp_eq_or_z_or_pow2orz_logical_proof : icmp_eq_or_z_or_pow2orz_logical_before ⊑ icmp_eq_or_z_or_pow2orz_logical_after

theorem xor_logic_and_or2_thm.extracted_1._3 : ∀ (x x_1 x_2 : BitVec 1),
  ¬x_2 = 1#1 → x_1 = 1#1 → 0#1 ^^^ (x_1 ||| x) = x_2 ^^^ 1#1

theorem t7_ugt_sgt_neg1_thm.extracted_1._15 : ∀ (x x_1 x_2 : BitVec 32),
  ¬ofBool (65535#32 <ᵤ x_2) = 1#1 → ¬ofBool (65535#32 <ₛ x_2) = 1#1 → ofBool (x_2 <ₛ 0#32) = 1#1 → x_2 = x

theorem e_1843 :
    3 *  ~~~(a &&&  ~~~a) - 2 * ((a |||  ~~~b) &&& (b ^^^ c)) - 11 *  ~~~(a ^^^ b) + 1 * (b ^^^  ~~~( ~~~a &&& (b ^^^ c))) - 3 * (c ^^^  ~~~(a ||| b)) + 2 *  ~~~(a ^^^ ( ~~~b ||| c)) - 3 * (a ||| b) + 2 * ( ~~~(a ^^^ b) &&& (a ^^^ c)) - 7 * ( ~~~a &&& (b ^^^ c)) + 1 * ( ~~~c &&&  ~~~(a ^^^ b)) + 1 *  ~~~(a &&& (b ||| c)) + 4 *  ~~~(a |||  ~~~b) - 2 * (b ^^^  ~~~( ~~~a ||| (b &&& c))) + 11 * (c ^^^  ~~~(a ||| (b &&& c))) + 4 * ((a &&& c) ^^^  ~~~(a ^^^ (b &&& c))) + 5 * ( ~~~b &&& (a ^^^ c)) + 11 * (c ^^^  ~~~( ~~~a &&& ( ~~~b ||| c))) + 7 * (b ^^^ ( ~~~a ||| (b ||| c))) + 7 * (a &&&  ~~~c) - 1 * ( ~~~(a &&&  ~~~b) &&&  ~~~(a ^^^ (b ^^^ c))) + 2 *  ~~~(a &&& ( ~~~b &&& c)) - 1 * (c &&&  ~~~(a ^^^ b)) - 1 *  ~~~(b ||| c) - 7 * (b ^^^  ~~~( ~~~a ||| (b ^^^ c))) + 2 *  ~~~( ~~~a &&& ( ~~~b ||| c)) - 1 *  ~~~( ~~~a &&& (b ^^^ c)) - 6 * (b &&& c) - 6 * (b ^^^ (a ||| (b &&& c))) + 4 * (c ^^^  ~~~( ~~~a ||| ( ~~~b &&& c))) - 11 * (b ^^^  ~~~( ~~~a &&& ( ~~~b &&& c))) + 11 *  ~~~(a ^^^ (b &&& c)) + 7 * ((b &&&  ~~~c) ^^^ ( ~~~a ||| (b ^^^ c))) - 2 * ( ~~~a ||| (b &&& c)) - 2 *  ~~~a - 2 *  ~~~( ~~~a &&& (b &&& c)) + 4 * ( ~~~(a |||  ~~~b) ||| (a ^^^ (b ^^^ c))) - 14 *  ~~~(a ||| (b ||| c)) - 25 *  ~~~(a ||| ( ~~~b ||| c)) - 9 *  ~~~( ~~~a ||| (b ||| c)) + 2 *  ~~~( ~~~a ||| ( ~~~b ||| c)) - 27 * ( ~~~a &&& ( ~~~b &&& c)) - 13 * ( ~~~a &&& (b &&& c)) - 4 * (a &&& ( ~~~b &&& c)) - 4 * (a &&& (b &&& c)) = 7 * (c ^^^ (a &&& b))

theorem arbitrary_mask_sub_i8_thm (e : IntW 8) :
  sub (const? 8 11) (LLVM.and e (const? 8 10)) ⊑
    sub (const? 8 11) (LLVM.and e (const? 8 10)) { «nsw» := true, «nuw» := true }

theorem a_false_implies_b_true2_thm.extracted_1._3 : ∀ (x : BitVec 1) (x_1 : BitVec 8),
  ¬ofBool (x_1 <ᵤ 20#8) = 1#1 → ofBool (10#8 <ᵤ x_1) = 1#1 → ofBool (10#8 <ᵤ x_1) ||

theorem p0_thm (e e_1 : IntW 8) :
  icmp IntPred.ne (LLVM.and (LLVM.xor (shl (const? 8 (-1)) e_1) (const? 8 (-1))) e) e ⊑
    icmp IntPred.ne (lshr e e_1) (const? 8 0)

theorem shl_lshr_pow2_const_case1_thm (e : IntW 16) :
  LLVM.and (lshr (shl (const? 16 4) e) (const? 16 6)) (const? 16 8) ⊑
    select (icmp IntPred.eq e (const? 16 7)) (const? 16 8) (const? 16 0)

theorem and_nosignbit_select_ashr_thm.extracted_1._1 : ∀ (x : BitVec 32) (x_1 : BitVec 1),
  x_1 = 1#1 → ¬8#32 ≥ ↑32 → (x &&& 2147418112#32).sshiftRight' 8#32 = x.sshiftRight' 8#32 &&& 8388352#32

theorem sle_smin3_thm (e e_1 : IntW 32) :
  icmp IntPred.sge (add e_1 (const? 32 3))
      (select (icmp IntPred.slt (add e_1 (const? 32 3)) e) (add e_1 (const? 32 3)) e) ⊑
    const? 1 1

theorem ashr_lshr_shift_amt_mismatch_proof : ashr_lshr_shift_amt_mismatch_before ⊑ ashr_lshr_shift_amt_mismatch_after

theorem or_xor_commute2_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬(x_1 = 0 ∨ x = 0 ∨ x = 0) → x_1 = 0 ∨ x = 0 → False

theorem test15_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  x_1 + 1#32 + (x &&& BitVec.ofInt 32 (-1431655767) ^^^ BitVec.ofInt 32 (-1431655767)) = x_1 - (x ||| 1431655766#32)

theorem icmp_select_var_pred_ne_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ofBool (x_1 == 0#8) = 1#1 → ofBool (x_1 != 0#8) = 1#1 → False

theorem test_proof : test_before ⊑ test_after

theorem or_zext_zext_proof : or_zext_zext_before ⊑ or_zext_zext_after

theorem or_xor_xor_normal_variant2_proof : or_xor_xor_normal_variant2_before ⊑ or_xor_xor_normal_variant2_after

theorem a_true_implies_b_false2_comm_thm.extracted_1._6 : ∀ (x x_1 : BitVec 1) (x_2 : BitVec 8),
  ofBool (x_2 == 10#8) = 1#1 → ¬ofBool (20#8 <ᵤ x_2) = 1#1 → x_1 &&& ofBool (20#8 <ᵤ x_2) = 0#1

theorem shift_trunc_signbit_test_thm (e : IntW 32) :
  icmp IntPred.slt (trunc 8 (lshr e (const? 32 24))) (const? 8 0) ⊑ icmp IntPred.slt e (const? 32 0)

theorem shl_add_and_thm (e e_1 : IntW 8) :
  LLVM.and (shl e_1 (const? 8 1)) (add (shl e (const? 8 1)) (const? 8 123)) ⊑
    shl (LLVM.and e_1 (add e (const? 8 61))) (const? 8 1)

theorem ashrsgt_01_09_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬1#4 ≥ ↑4 → ofBool (BitVec.ofInt 4 (-7) <ₛ x.sshiftRight' 1#4) = 1#1

theorem icmp_slt_0_or_icmp_sgt_0_i64_fail0_proof : icmp_slt_0_or_icmp_sgt_0_i64_fail0_before ⊑ icmp_slt_0_or_icmp_sgt_0_i64_fail0_after

theorem e_411 :
     - 2 *  ~~~(x ^^^ y) + 2 *  ~~~x + 1 * (x ^^^ y) - 5 *  ~~~(x &&&  ~~~y) - 2 * (x |||  ~~~y) + 2 *  ~~~(x &&&  ~~~x) + 5 *  ~~~(x ||| y) + 1 *  ~~~(x |||  ~~~y) = 1 * (x ||| y) - 8 * (x &&& y)

theorem or_ashr_not_proof : or_ashr_not_before ⊑ or_ashr_not_after

theorem e_791 :
     - 2 *  ~~~(z &&&  ~~~z) + 5 *  ~~~(z ^^^ t) - 3 * (z ||| t) - 3 *  ~~~(z ||| t) + 5 *  ~~~(z |||  ~~~t) =  - 5 * (z &&&  ~~~t)

theorem trunc_sandwich_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬(28#32 ≥ ↑32 ∨ 2#12 ≥ ↑12) →
    ¬(30#32 ≥ ↑32 ∨
          True ∧ signExtend 32 (truncate 12 (x >>> 30#32)) ≠ x >>> 30#32 ∨
            True ∧ zeroExtend 32 (truncate 12 (x >>> 30#32)) ≠ x >>> 30#32) →
      truncate 12 (x >>> 28#32) >>> 2#12 = truncate 12 (x >>> 30#32)

theorem sle_smin3_proof : sle_smin3_before ⊑ sle_smin3_after

theorem udiv_icmp2_thm.extracted_1._1 : ∀ (x : BitVec 64),
  ¬(True ∧ x.umod 5#64 ≠ 0 ∨ 5#64 = 0) → ofBool (x / 5#64 == 0#64) = ofBool (x == 0#64)

theorem demorgan_nor_use2ab_proof : demorgan_nor_use2ab_before ⊑ demorgan_nor_use2ab_after

theorem select_icmp_ne_0_and_4096_xor_32_thm.extracted_1._4 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (0#32 != x_1 &&& 4096#32) = 1#1 → ¬7#32 ≥ ↑32 → x ^^^ 32#32 = x_1 >>> 7#32 &&& 32#32 ^^^ x ^^^ 32#32

theorem smear_set_bit_different_dest_type_thm (e : IntW 32) :
  sext 16 (ashr (trunc 8 e) (const? 8 7)) ⊑
    trunc 16 (ashr (shl e (const? 32 24)) (const? 32 31)) { «nsw» := true, «nuw» := false }

theorem test23_thm (e : IntW 8) :
  LLVM.xor (LLVM.or (LLVM.xor (LLVM.or e (const? 8 (-2))) (const? 8 13)) (const? 8 1)) (const? 8 12) ⊑
    const? 8 (-1)

theorem test21_proof : test21_before ⊑ test21_after

theorem test47_thm (e : IntW 8) :
  zext 64 (LLVM.or (sext 32 e) (const? 32 42)) ⊑ zext 64 (sext 32 (LLVM.or e (const? 8 42)))

theorem sdiv_icmp5_thm (e : IntW 64) :
  icmp IntPred.eq (LLVM.sdiv e (const? 64 (-5)) { «exact» := true }) (const? 64 1) ⊑
    icmp IntPred.eq e (const? 64 (-5))

theorem logical_and_logical_and_icmps_comm2_proof : logical_and_logical_and_icmps_comm2_before ⊑ logical_and_logical_and_icmps_comm2_after

theorem test21_proof : test21_before ⊑ test21_after

theorem e_439 :
     - 11 * y + 11 * (x |||  ~~~y) - 7 *  ~~~y + 3 *  ~~~(x &&&  ~~~y) - 17 *  ~~~(x ||| y) - 2 *  ~~~(x |||  ~~~y) - 3 * (x &&&  ~~~y) - 2 * (x &&& y) =  - 11 *  ~~~x + 1 *  ~~~(x &&&  ~~~x)

theorem gt_signed_to_large_unsigned_proof : gt_signed_to_large_unsigned_before ⊑ gt_signed_to_large_unsigned_after

theorem rem_euclid_non_const_pow2_thm.extracted_1._4 : ∀ (x x_1 : BitVec 8),
  ¬(x ≥ ↑8 ∨ (1#8 <<< x == 0 || 8 != 1 && x_1 == intMin 8 && 1#8 <<< x == -1) = true) →
    ¬ofBool (x_1.srem (1#8 <<< x) <ₛ 0#8) = 1#1 →
      ¬(True ∧ ((-1#8) <<< x).sshiftRight' x ≠ -1#8 ∨ x ≥ ↑8) →
        x_1.srem (1#8 <<< x) = x_1 &&& ((-1#8) <<< x ^^^ -1#8)

theorem ashr_sgt_noexact_proof : ashr_sgt_noexact_before ⊑ ashr_sgt_noexact_after

theorem test12_thm (e : IntW 1) : icmp IntPred.uge e (const? 1 0) ⊑ const? 1 1

theorem shl_nsw_add_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬(True ∧ (1#32 <<< x).sshiftRight' x ≠ 1#32 ∨ x ≥ ↑32) →
    True ∧ ((-1#32) <<< x).sshiftRight' x ≠ -1#32 ∨ x ≥ ↑32 → False

theorem test34_thm (e e_1 : IntW 32) : LLVM.and (LLVM.or e_1 e) e_1 ⊑ e_1

theorem shl_add_add_proof : shl_add_add_before ⊑ shl_add_add_after

theorem PR38021_proof : PR38021_before ⊑ PR38021_after

theorem lshr_eq_msb_low_last_zero_proof : lshr_eq_msb_low_last_zero_before ⊑ lshr_eq_msb_low_last_zero_after

theorem mul_selectp2_x_non_const_proof : mul_selectp2_x_non_const_before ⊑ mul_selectp2_x_non_const_after

theorem and_or_not_not_commute2_proof : and_or_not_not_commute2_before ⊑ and_or_not_not_commute2_after

theorem udiv_illegal_type_thm.extracted_1._1 : ∀ (x x_1 : BitVec 9), ¬zeroExtend 32 x = 0 → x = 0 → False

theorem AvoidCollision_setWidth_zero (m n : Nat) : setWidth m 0#n = 0#m

theorem select_xor_icmp_bad_3_thm.extracted_1._2 : ∀ (x x_1 x_2 : BitVec 32),
  ofBool (x_2 == 3#32) = 1#1 → x_2 ^^^ x_1 = x_1 ^^^ 3#32

theorem mul_selectp2_x_thm.extracted_1._1 : ∀ (x : BitVec 8) (x_1 : BitVec 1), x_1 = 1#1 → 1#8 ≥ ↑8 → False

theorem main3c_proof : main3c_before ⊑ main3c_after

theorem and_logic_and_logic_or_4_thm.extracted_1._3 : ∀ (x x_1 x_2 : BitVec 1),
  x_2 &&& x_1 = 1#1 → x_1 = 1#1 → ¬x_2 = 1#1 → 1#1 = x

theorem e_1080 :
     - 6 * (z |||  ~~~t) - 6 *  ~~~t - 6 * t - 1 *  ~~~(z &&&  ~~~z) - 11 * (z ^^^ t) + 18 *  ~~~(z |||  ~~~t) + 24 * (z &&&  ~~~t) + 13 * (z &&& t) =  - 13 *  ~~~(z ||| t)

theorem test1_thm.extracted_1._2 : ∀ (x : BitVec 33), ¬4096#33 = 0 → ¬12#33 ≥ ↑33 → x / 4096#33 = x >>> 12#33

theorem and_nosignbit_select_shl_proof : and_nosignbit_select_shl_before ⊑ and_nosignbit_select_shl_after

theorem lsb_mask_sign_sext_commuted_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬31#32 ≥ ↑32 → ((x ^^^ -1#32) &&& x + -1#32).sshiftRight' 31#32 = signExtend 32 (ofBool (x == 0#32))

theorem substitute_constant_and_ne_ugt_swap_logical_proof : substitute_constant_and_ne_ugt_swap_logical_before ⊑ substitute_constant_and_ne_ugt_swap_logical_after

theorem in_constant_6_vary_invmask_proof : in_constant_6_vary_invmask_before ⊑ in_constant_6_vary_invmask_after

theorem shl_add_add_thm (e e_1 : IntW 8) :
  add (shl e_1 (const? 8 2)) (add (shl e (const? 8 2)) (const? 8 48)) ⊑
    add (shl (add e e_1) (const? 8 2)) (const? 8 48)

theorem sge_or_not_max_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8), ofBool (x ≤ₛ x_1) ||

theorem udiv_x_by_const_cmp_x_proof : udiv_x_by_const_cmp_x_before ⊑ udiv_x_by_const_cmp_x_after

theorem icmp_ne_sext_eq_zero_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (signExtend 32 (ofBool (x == 0#32)) != x) = 1#1

theorem src_is_mask_lshr_thm.extracted_1._1 : ∀ (x : BitVec 8) (x_1 : BitVec 1) (x_2 : BitVec 8),
  ¬x_1 = 1#1 →
    ¬x ≥ ↑8 → ofBool (x_2 ^^^ 123#8 != 15#8 >>> x &&& (x_2 ^^^ 123#8)) = ofBool (15#8 >>> x <ᵤ x_2 ^^^ 123#8)

theorem sle_smin2_thm (e e_1 : IntW 32) :
  icmp IntPred.sle (select (icmp IntPred.slt e_1 e) e_1 e) e ⊑ const? 1 1

theorem pr40493_neg1_thm (e : IntW 32) :
  icmp IntPred.eq (LLVM.and (mul e (const? 32 11)) (const? 32 4)) (const? 32 0) ⊑
    icmp IntPred.eq (LLVM.and (mul e (const? 32 3)) (const? 32 4)) (const? 32 0)

theorem masked_and_notA_logical_thm (e : IntW 32) :
  select (icmp IntPred.ne (LLVM.and e (const? 32 14)) e) (icmp IntPred.ne (LLVM.and e (const? 32 78)) e)
      (const? 1 0) ⊑
    icmp IntPred.ne (LLVM.and e (const? 32 (-79))) (const? 32 0)

theorem t10_constants_thm.extracted_1._1 : ∀ (x : BitVec 64) (x_1 : BitVec 32),
  ¬(12#32 ≥ ↑32 ∨ 14#64 ≥ ↑64) → 26#32 ≥ ↑32 → False

theorem ashrslt_01_12_exact_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬(True ∧ x >>> 1#4 <<< 1#4 ≠ x ∨ 1#4 ≥ ↑4) → ofBool (x.sshiftRight' 1#4 <ₛ BitVec.ofInt 4 (-4)) = 0#1

theorem PR42691_10_proof : PR42691_10_before ⊑ PR42691_10_after

theorem foo1_and_commuted_proof : foo1_and_commuted_before ⊑ foo1_and_commuted_after

theorem main7d_proof : main7d_before ⊑ main7d_after

theorem trunc_shl_32_i32_i64_proof : trunc_shl_32_i32_i64_before ⊑ trunc_shl_32_i32_i64_after

theorem t4_ugt_slt_128_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬ofBool (143#32 <ᵤ x + 16#32) = 1#1 →
    ofBool (127#32 <ₛ x) = 1#1 ∨ ofBool (x <ₛ BitVec.ofInt 32 (-16)) = 1#1 → False

theorem shl_nsw_sgt_n1_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ¬(True ∧ (x_1 <<< x).sshiftRight' x ≠ x_1 ∨ x ≥ ↑8) → ofBool (-1#8 <ₛ x_1 <<< x) = ofBool (-1#8 <ₛ x_1)

theorem e_1867 :
    3 *  ~~~( ~~~a &&& (b &&& c)) - 2 * (b &&& (a ||| c)) + 7 * ((a ^^^ b) |||  ~~~(a ^^^ c)) + 4 *  ~~~( ~~~a &&& (b ||| c)) + 4 *  ~~~(a ||| (b &&& c)) - 5 * ( ~~~a &&& (b ^^^ c)) + 7 * ((a &&& b) ^^^ (b ||| c)) + 1 * ( ~~~(a |||  ~~~b) |||  ~~~(a ^^^ (b ^^^ c))) - 1 * (a ^^^ (b ||| c)) + 2 * ((a &&& c) ^^^  ~~~(a ^^^ (b &&& c))) + 3 * (c ^^^ (a ||| ( ~~~b ||| c))) + 2 * (b ^^^ ( ~~~a &&& (b ^^^ c))) + 11 * (c ^^^  ~~~(a &&& (b ||| c))) - 2 * (a &&& ( ~~~b ||| c)) + 2 * ( ~~~(a ||| b) |||  ~~~(b ^^^ c)) - 1 * ((a ||| b) &&&  ~~~(b ^^^ c)) - 1 * (c |||  ~~~(a ||| b)) + 3 * (b &&&  ~~~c) + 11 *  ~~~(a ||| b) - 3 * (b &&& c) - 3 * ( ~~~a ||| ( ~~~b &&& c)) - 5 * (b ^^^  ~~~(a &&&  ~~~c)) - 3 *  ~~~(a ^^^ (b &&& c)) + 4 * (b ^^^ (a ||| ( ~~~b &&& c))) + 2 * (b ^^^ (a &&& c)) + 4 * (c ^^^  ~~~(a |||  ~~~b)) + 7 * b - 2 * (b ^^^  ~~~(a ||| ( ~~~b &&& c))) - 1 * ( ~~~c &&&  ~~~(a ^^^ b)) + 1 * ((a ^^^ b) &&&  ~~~(a ^^^ c)) + 3 * (c ^^^  ~~~( ~~~a &&& (b &&& c))) + 1 * ( ~~~c |||  ~~~(a ^^^ b)) + 2 * (b ^^^  ~~~(a &&& (b ||| c))) + 1 *  ~~~(a &&& (b &&& c)) + 5 * ((a |||  ~~~b) &&& (b ^^^ c)) - 1 * ((a &&& c) ||| (b &&&  ~~~c)) - 1 * (b ^^^ (a ||| c)) + 11 * ((a |||  ~~~b) &&& (a ^^^ (b ^^^ c))) - 44 *  ~~~(a ||| (b ||| c)) - 46 *  ~~~(a ||| ( ~~~b ||| c)) - 51 *  ~~~( ~~~a ||| (b ||| c)) - 25 *  ~~~( ~~~a ||| ( ~~~b ||| c)) - 44 * ( ~~~a &&& ( ~~~b &&& c)) - 24 * ( ~~~a &&& (b &&& c)) - 38 * (a &&& ( ~~~b &&& c)) - 43 * (a &&& (b &&& c)) =  - 5 * (b ^^^  ~~~(a &&& c)) + 1 *  ~~~(a &&&  ~~~a)

theorem ashrslt_02_06_proof : ashrslt_02_06_before ⊑ ashrslt_02_06_after

@[simp]
theorem R.trimTensor_append_zeroes_eq (tensor : List Int) (n : Nat) :
    trimTensor (tensor ++ List.replicate n 0) = trimTensor tensor

theorem not_and_and_or_no_or_commute2_and_proof : not_and_and_or_no_or_commute2_and_before ⊑ not_and_and_or_no_or_commute2_and_after

theorem lshrult_03_11_exact_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬(True ∧ x >>> 3#4 <<< 3#4 ≠ x ∨ 3#4 ≥ ↑4) → ofBool (x >>> 3#4 <ᵤ BitVec.ofInt 4 (-5)) = 1#1

theorem sdiv_shl_pair3_thm.extracted_1._2 : ∀ (x x_1 x_2 : BitVec 32),
  ¬(True ∧ (x_2 <<< x_1).sshiftRight' x_1 ≠ x_2 ∨
        x_1 ≥ ↑32 ∨
          True ∧ (x_2 <<< x).sshiftRight' x ≠ x_2 ∨
            x ≥ ↑32 ∨ (x_2 <<< x == 0 || 32 != 1 && x_2 <<< x_1 == intMin 32 && x_2 <<< x == -1) = true) →
    ¬(True ∧ 1#32 <<< x_1 >>> x_1 ≠ 1#32 ∨ x_1 ≥ ↑32 ∨ x ≥ ↑32) → (x_2 <<< x_1).sdiv (x_2 <<< x) = 1#32 <<< x_1 >>> x

theorem shl_add_log_may_cause_poison_pr62175_with_nuw_proof : shl_add_log_may_cause_poison_pr62175_with_nuw_before ⊑ shl_add_log_may_cause_poison_pr62175_with_nuw_after

theorem icmp_eq_or_z_or_pow2orz_fail_logic_or_proof : icmp_eq_or_z_or_pow2orz_fail_logic_or_before ⊑ icmp_eq_or_z_or_pow2orz_fail_logic_or_after

theorem positive_biggershl_shlnsw_lshrexact_proof : positive_biggershl_shlnsw_lshrexact_before ⊑ positive_biggershl_shlnsw_lshrexact_after

theorem shl_xor_xor_good_mask_proof : shl_xor_xor_good_mask_before ⊑ shl_xor_xor_good_mask_after

theorem bv_AndOrXor_2416 :
    ∀ (e e_1 : LLVM.IntW w),
      LLVM.xor (LLVM.and (LLVM.xor e (LLVM.const? w (-1))) e_1) (LLVM.const? w (-1)) ⊑
        LLVM.or e (LLVM.xor e_1 (LLVM.const? w (-1)))

theorem mul_of_sdiv_fail_ub_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬(True ∧ x.smod 6#8 ≠ 0 ∨ (6#8 == 0 || 8 != 1 && x == intMin 8 && 6#8 == -1) = true) →
    x.sdiv 6#8 * BitVec.ofInt 8 (-6) = 0#8 - x

@[simp]
theorem mkSuccCarryAndOutsAssignPrecond_eval_eq_false_of_eq_envBoolStart_of_envBitstream
  {circs : KInductionCircuits fsm n}
  (hCircs : circs.IsLawful)
  (env : Vars fsm.α arity (n + 2) → Bool)
  (hEnv : env = envBoolStart_of_envBitstream fsm envBitstream (n + 1)) :
  (mkSuccCarryAndOutsAssignPrecond circs).eval env = false

theorem test5_proof : test5_before ⊑ test5_after

theorem sub_select_sext_proof : sub_select_sext_before ⊑ sub_select_sext_after

theorem uge_and_max_commute_logical_thm (e e_1 : IntW 8) :
  select (icmp IntPred.eq e_1 (const? 8 (-1))) (icmp IntPred.uge e_1 e) (const? 1 0) ⊑
    icmp IntPred.eq e_1 (const? 8 (-1))

theorem ashrsgt_03_05_exact_thm (e : IntW 4) :
  icmp IntPred.sgt (ashr e (const? 4 3) { «exact» := true }) (const? 4 5) ⊑ const? 1 0

theorem sdiv400_yes_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬(2#32 ≥ ↑32 ∨ (100#32 == 0 || 32 != 1 && x >>> 2#32 == intMin 32 && 100#32 == -1) = true) →
    ¬400#32 = 0 → (x >>> 2#32).sdiv 100#32 = x / 400#32

theorem test86_thm.extracted_1._2 : ∀ (x : BitVec 16),
  ¬4#32 ≥ ↑32 → ¬4#16 ≥ ↑16 → truncate 16 ((signExtend 32 x).sshiftRight' 4#32) = x.sshiftRight' 4#16

theorem select_add_icmp_proof : select_add_icmp_before ⊑ select_add_icmp_after

theorem and_logic_and_logic_or_3_thm.extracted_1._5 : ∀ (x x_1 x_2 : BitVec 1),
  ¬x_2 &&& x_1 = 1#1 → x_1 = 1#1 → x_2 = 1#1 → x = 1#1

theorem shift_no_xor_multiuse_cmp_with_xor_proof : shift_no_xor_multiuse_cmp_with_xor_before ⊑ shift_no_xor_multiuse_cmp_with_xor_after

theorem test24_logical_thm.extracted_1._2 : ∀ (x : BitVec 32), ¬ofBool (1#32 <ₛ x) = 1#1 → 0#1 = ofBool (2#32 <ₛ x)

theorem test55_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬(True ∧ (truncate 16 x &&& 7224#16 &&& BitVec.ofInt 16 (-32574) != 0) = true) →
    signExtend 64 ((truncate 16 x ||| BitVec.ofInt 16 (-32574)) &&& BitVec.ofInt 16 (-25350)) =
      signExtend 64 (truncate 16 x &&& 7224#16 ||| BitVec.ofInt 16 (-32574))

theorem tryFactorization_add_mul_nuw_thm (e : IntW 32) :
  add (mul e (const? 32 3)) e { «nsw» := false, «nuw» := true } ⊑ shl e (const? 32 2)

theorem lshrult_03_14_proof : lshrult_03_14_before ⊑ lshrult_03_14_after

theorem test1_thm (e : IntW 1) : add (LLVM.xor e (const? 1 1)) (const? 1 1) ⊑ e

theorem test2_proof : test2_before ⊑ test2_after

theorem test20_thm (e e_1 : IntW 32) :
  LLVM.xor (LLVM.or e_1 e) (LLVM.or (LLVM.xor e (const? 32 (-1))) (LLVM.xor e_1 (const? 32 (-1)))) ⊑
    LLVM.xor (LLVM.xor e_1 e) (const? 32 (-1))

theorem or_or_and_pat8_proof : or_or_and_pat8_before ⊑ or_or_and_pat8_after

theorem lshr_pow2_slt_thm (e : IntW 8) :
  icmp IntPred.slt (lshr (const? 8 (-128)) e) (const? 8 3) ⊑
    icmp IntPred.slt (lshr (const? 8 (-128)) e { «exact» := true }) (const? 8 3)

theorem test5_proof : test5_before ⊑ test5_after

theorem eq_21_proof : eq_21_before ⊑ eq_21_after

theorem PR75692_1_thm (e : IntW 32) :
  LLVM.and (LLVM.xor e (const? 32 4)) (LLVM.xor e (const? 32 (-5))) ⊑ const? 32 0

theorem test40_thm.extracted_1._2 : ∀ (x : BitVec 16),
  ¬(9#32 ≥ ↑32 ∨ 8#32 ≥ ↑32) →
    ¬(9#16 ≥ ↑16 ∨ 8#16 ≥ ↑16 ∨ True ∧ (x >>> 9#16 &&& x <<< 8#16 != 0) = true) →
      truncate 16 (zeroExtend 32 x >>> 9#32 ||| zeroExtend 32 x <<< 8#32) = x >>> 9#16 ||

theorem test3i_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬(29#32 ≥ ↑32 ∨ 29#32 ≥ ↑32) →
    zeroExtend 32 (ofBool (x_1 >>> 29#32 ||| 35#32 == x >>> 29#32 ||| 35#32)) =
      zeroExtend 32 (ofBool (-1#32 <ₛ x_1 ^^^ x))

theorem lshrugt_03_05_exact_proof : lshrugt_03_05_exact_before ⊑ lshrugt_03_05_exact_after

theorem main4_logical_thm.extracted_1._3 : ∀ (x : BitVec 32),
  ¬ofBool (x &&& 7#32 == 7#32) = 1#1 → 0#1 = 1#1 → 0#32 = zeroExtend 32 (ofBool (x &&& 55#32 != 55#32))

theorem exact_lshr_eq_both_equal_proof : exact_lshr_eq_both_equal_before ⊑ exact_lshr_eq_both_equal_after

theorem gt_signed_to_small_signed_proof : gt_signed_to_small_signed_before ⊑ gt_signed_to_small_signed_after

theorem main7f_logical_thm.extracted_1._14 : ∀ (x x_1 x_2 x_3 x_4 : BitVec 32),
  ¬ofBool (x_4 &&& x_3 == x_2 &&& (x_4 &&& x_3)) = 1#1 →
    ofBool (x_4 &&& x_3 != x_2 &&& (x_4 &&& x_3)) = 1#1 → ¬0#1 = 1#1 → 1#32 = zeroExtend 32 1#1

theorem fold_xor_zext_icmp_proof : fold_xor_zext_icmp_before ⊑ fold_xor_zext_icmp_after

theorem addhshlhsdivhscalar1_thm.extracted_1._2 : ∀ (x : BitVec 8),
  ¬((BitVec.ofInt 8 (-64) == 0 || 8 != 1 && x == intMin 8 && BitVec.ofInt 8 (-64) == -1) = true ∨ 6#8 ≥ ↑8) →
    ¬(64#8 == 0 || 8 != 1 && x == intMin 8 && 64#8 == -1) = true →
      x.sdiv (BitVec.ofInt 8 (-64)) <<< 6#8 + x = x.srem 64#8

theorem scalar_i64_shl_and_signbit_eq_thm (e e_1 : IntW 64) :
  icmp IntPred.eq (LLVM.and (shl e_1 e) (const? 64 (-9223372036854775808))) (const? 64 0) ⊑
    icmp IntPred.sgt (shl e_1 e) (const? 64 (-1))

theorem logical_or_logical_or_icmps_comm1_thm.extracted_1._7 : ∀ (x x_1 x_2 : BitVec 8),
  ¬x_1 ≥ ↑8 →
    ¬(ofBool (x_2 &&& 1#8 <<< x_1 == 0#8) = 1#1 ∨ ofBool (x == 42#8) = 1#1) →
      ¬(True ∧ 1#8 <<< x_1 >>> x_1 ≠ 1#8 ∨ x_1 ≥ ↑8) →
        ¬ofBool (x_2 &&& 1#8 <<< x_1 == 0#8) = 1#1 → ofBool (x == 42#8) = 1#1 → ofBool (x_2 &&& 1#8 == 0#8) = 1#1

theorem shl_lshr_pow2_const_case1_thm.extracted_1._1 : ∀ (x : BitVec 16),
  ¬(x ≥ ↑16 ∨ 6#16 ≥ ↑16) → ofBool (x == 7#16) = 1#1 → 4#16 <<< x >>> 6#16 &&& 8#16 = 8#16

theorem main6_logical_thm (e : IntW 32) :
  select
      (select (icmp IntPred.eq (LLVM.and e (const? 32 7)) (const? 32 3))
        (icmp IntPred.eq (LLVM.and e (const? 32 48)) (const? 32 16)) (const? 1 0))
      (const? 32 0) (const? 32 1) ⊑
    zext 32 (icmp IntPred.ne (LLVM.and e (const? 32 55)) (const? 32 19))

theorem test_sext3_thm.extracted_1._4 : ∀ (x x_1 : BitVec 1),
  x_1 = 1#1 → ¬x_1 ^^^ 1#1 = 1#1 → 0#32 = signExtend 32 0#1

theorem test3_proof : test3_before ⊑ test3_after

theorem land_bor_right1_proof : land_bor_right1_before ⊑ land_bor_right1_after

theorem e_1826 :
    5 * (b ^^^  ~~~( ~~~a &&& (b ||| c))) + 4 * (b ^^^  ~~~( ~~~a &&& (b &&& c))) - 6 *  ~~~(a &&& (b ||| c)) + 5 * (c ^^^  ~~~( ~~~a &&& (b ||| c))) + 1 * (b ^^^ ( ~~~a &&& (b ^^^ c))) - 1 * (a ||| c) + 2 * ((a ^^^ b) &&& (a ^^^ c)) - 2 * (c ^^^  ~~~( ~~~a ||| (b &&& c))) - 5 * c + 2 * (b ^^^ (a ||| (b &&& c))) + 1 *  ~~~( ~~~a ||| (b ^^^ c)) + 11 *  ~~~(b |||  ~~~c) - 7 * ((b &&&  ~~~c) ^^^ ( ~~~a ||| (b ^^^ c))) + 3 * (c ^^^  ~~~(a |||  ~~~b)) + 11 * ( ~~~b |||  ~~~(a ^^^ c)) + 1 * (b ^^^ (a ||| (b ||| c))) + 11 * (a &&& (b ||| c)) - 7 * ( ~~~(a &&&  ~~~b) &&&  ~~~(a ^^^ (b ^^^ c))) - 3 *  ~~~b + 1 * (a ||| (b ||| c)) + 1 * ( ~~~(a &&& b) &&& (a ^^^ (b ^^^ c))) - 2 * (b ^^^ ( ~~~a ||| ( ~~~b &&& c))) - 1 * (c ^^^ ( ~~~a ||| ( ~~~b ||| c))) - 1 * (c ^^^ (a &&& b)) - 2 *  ~~~( ~~~a &&& (b &&& c)) + 1 * (c |||  ~~~(a ^^^ b)) + 1 *  ~~~(a ^^^ (b ||| c)) + 11 *  ~~~(a ||| c) + 3 * (c ^^^  ~~~( ~~~a ||| ( ~~~b &&& c))) - 11 * (b ^^^ (a ||| c)) + 1 * (c ^^^  ~~~(a ||| ( ~~~b &&& c))) + 1 *  ~~~(b &&&  ~~~c) - 2 * (b &&&  ~~~(a &&&  ~~~c)) + 4 * ((a ^^^ b) &&&  ~~~(a ^^^ c)) - 12 *  ~~~(a ||| (b ||| c)) - 17 *  ~~~(a ||| ( ~~~b ||| c)) - 15 *  ~~~( ~~~a ||| (b ||| c)) - 8 *  ~~~( ~~~a ||| ( ~~~b ||| c)) - 8 * ( ~~~a &&& ( ~~~b &&& c)) + 4 * ( ~~~a &&& (b &&& c)) - 32 * (a &&& ( ~~~b &&& c)) - 22 * (a &&& (b &&& c)) =  - 4 * (c ||| (a &&&  ~~~b))

theorem fold_select_trunc_nuw_false_thm (e e_1 : IntW 8) :
  select (trunc 1 e_1 { «nsw» := false, «nuw» := true }) e e_1 ⊑
    select (trunc 1 e_1 { «nsw» := false, «nuw» := true }) e (const? 8 0)

theorem or_to_nxor3_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  (x_1 ||| x) ^^^ -1#32 ||

theorem main7a_logical_thm.extracted_1._7 : ∀ (x x_1 x_2 : BitVec 32),
  ofBool (x_2 &&& x_1 == x_2) = 1#1 →
    ¬ofBool (x_2 &&& x_1 != x_2) = 1#1 →
      ofBool (x &&& x_1 == x) = 1#1 → 0#32 = zeroExtend 32 (ofBool (x &&& x_1 != x))

theorem test_shl_nuw_nsw__all_are_safe_thm.extracted_1._4 : ∀ (x : BitVec 64) (x_1 : BitVec 32),
  ¬ofBool (x_1 &&& 15#32 == 0#32) = 1#1 →
    ¬(True ∧ ((x_1 &&& 15#32) <<< 2#32).sshiftRight' 2#32 ≠ x_1 &&& 15#32 ∨
          True ∧ (x_1 &&& 15#32) <<< 2#32 >>> 2#32 ≠ x_1 &&& 15#32 ∨
            2#32 ≥ ↑32 ∨ zeroExtend 64 ((x_1 &&& 15#32) <<< 2#32) ≥ ↑64) →
      ¬(2#32 ≥ ↑32 ∨ True ∧ (x_1 <<< 2#32 &&& 60#32).msb = true ∨ zeroExtend 64 (x_1 <<< 2#32 &&& 60#32) ≥ ↑64) →
        x.sshiftRight' (zeroExtend 64 ((x_1 &&& 15#32) <<< 2#32)) =
          x.sshiftRight' (zeroExtend 64 (x_1 <<< 2#32 &&& 60#32))

theorem not_mul_of_pow2_proof : not_mul_of_pow2_before ⊑ not_mul_of_pow2_after

theorem e_787 :
    4 *  ~~~(z ^^^ t) + 1 *  ~~~t + 6 *  ~~~(z |||  ~~~t) - 1 * (z &&&  ~~~t) - 4 * (z &&& t) = 6 *  ~~~z - 1 *  ~~~(z ||| t)

theorem test15f_thm.extracted_1._4 : ∀ (x : BitVec 32),
  ¬ofBool (x &&& 128#32 != 0#32) = 1#1 → ¬1#32 ≥ ↑32 → 256#32 = x <<< 1#32 &&& 256#32 ^^^ 256#32

theorem select_constants_and_icmp_eq0_zero_fval_proof : select_constants_and_icmp_eq0_zero_fval_before ⊑ select_constants_and_icmp_eq0_zero_fval_after

theorem or_xor_common_op_commute7_proof : or_xor_common_op_commute7_before ⊑ or_xor_common_op_commute7_after

theorem same_source_not_matching_signbits_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬(True ∧ ((-1#32) <<< (x &&& 8#32)).sshiftRight' (x &&& 8#32) ≠ -1#32 ∨ x &&& 8#32 ≥ ↑32) →
    ¬(x &&& 8#32 ≥ ↑32 ∨
          True ∧
              BitVec.ofInt 32 (-16777216) <<< (x &&& 8#32) >>> 24#32 <<< 24#32 ≠
                BitVec.ofInt 32 (-16777216) <<< (x &&& 8#32) ∨
            24#32 ≥ ↑32) →
      signExtend 32 (truncate 8 ((-1#32) <<< (x &&& 8#32))) =
        (BitVec.ofInt 32 (-16777216) <<< (x &&& 8#32)).sshiftRight' 24#32

theorem e_744 :
    1 * (x ^^^ y) - 11 *  ~~~(x &&&  ~~~x) + 11 * x + 3 *  ~~~(x &&& y) - 3 *  ~~~(x &&&  ~~~y) - 1 *  ~~~y + 1 * y + 14 *  ~~~(x ||| y) + 15 *  ~~~(x |||  ~~~y) - 3 * (x &&&  ~~~y) - 2 * (x &&& y) =  - 4 *  ~~~(x ^^^ y) + 6 *  ~~~x

theorem ashr_sgt_exact_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬(True ∧ x >>> 3#8 <<< 3#8 ≠ x ∨ 3#8 ≥ ↑8) → ofBool (10#8 <ₛ x.sshiftRight' 3#8) = ofBool (80#8 <ₛ x)

@[simp]
theorem eval_repeatN_zero (b : Bool) (env : Unit → BitStream) :
  (repeatN b 0).eval env = (env ())

theorem ult_192_proof : ult_192_before ⊑ ult_192_after

theorem foo_thm (e : IntW 32) :
  LLVM.and (sub (const? 32 5) e) (const? 32 2) ⊑ LLVM.and (sub (const? 32 1) e) (const? 32 2)

theorem exact_lshr_eq_opposite_msb_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬(True ∧ BitVec.ofInt 8 (-128) >>> x <<< x ≠ BitVec.ofInt 8 (-128) ∨ x ≥ ↑8) →
    ofBool (BitVec.ofInt 8 (-128) >>> x == 1#8) = ofBool (x == 7#8)

theorem e_1643 :
     - 1 * ((b &&&  ~~~c) ^^^ (a ||| (b ^^^ c))) - 7 * ((a ||| b) &&&  ~~~(a ^^^ (b ^^^ c))) + 1 * (a ^^^ b) - 3 * ( ~~~(a &&&  ~~~b) &&&  ~~~(a ^^^ (b ^^^ c))) + 11 * (c ^^^  ~~~(a |||  ~~~b)) - 5 * ( ~~~(a ^^^ b) |||  ~~~(a ^^^ c)) + 1 * ((b &&& c) ||| (a &&& (b ||| c))) + 4 * (b ^^^  ~~~(a &&& (b &&& c))) + 7 *  ~~~(a ||| (b ^^^ c)) + 3 * (b ^^^ (a &&&  ~~~c)) - 11 *  ~~~(a ^^^ ( ~~~b ||| c)) - 6 * c - 2 * ((a |||  ~~~b) &&& (b ^^^ c)) - 1 * ( ~~~c ||| (a ^^^ b)) + 4 * (c ^^^  ~~~(a &&& b)) - 1 * (b ||| c) - 6 *  ~~~(a ||| (b ||| c)) - 4 *  ~~~(a ||| ( ~~~b ||| c)) - 2 *  ~~~( ~~~a ||| (b ||| c)) + 6 * ( ~~~a &&& (b &&& c)) + 14 * (a &&& ( ~~~b &&& c)) + 1 * (a &&& (b &&& c)) =  - 3 * ((a &&& b) ^^^  ~~~(a ^^^ ( ~~~b ||| c))) - 15 *  ~~~( ~~~a ||| ( ~~~b ||| c))

theorem e_1518 :
     - 1 * (a ^^^ (b ^^^ c)) - 1 * (b ^^^ (a &&& (b ||| c))) + 1 *  ~~~(a ||| (b &&& c)) + 3 * ((a &&& c) ||| (b &&&  ~~~c)) - 1 *  ~~~(a ||| (b ||| c)) - 2 *  ~~~(a ||| ( ~~~b ||| c)) + 1 *  ~~~( ~~~a ||| (b ||| c)) - 3 *  ~~~( ~~~a ||| ( ~~~b ||| c)) + 1 * ( ~~~a &&& (b &&& c)) - 2 * (a &&& (b &&& c)) = 2 * (a &&& ( ~~~b &&& c))

theorem test_const_shr_and_1_ne_0_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬x ≥ ↑32 → True ∧ 1#32 <<< x >>> x ≠ 1#32 ∨ x ≥ ↑32 → False

theorem PR42691_7_logical_thm (e : IntW 32) :
  select (icmp IntPred.uge e (const? 32 (-2147483647))) (const? 1 1) (icmp IntPred.eq e (const? 32 0)) ⊑
    icmp IntPred.slt (add e (const? 32 (-1))) (const? 32 0)

theorem main11_logical_thm.extracted_1._3 : ∀ (x : BitVec 32),
  ¬ofBool (x &&& 64#32 == 0#32) = 1#1 →
    ofBool (x &&& 192#32 == 192#32) = 1#1 → ofBool (0#8 ≤ₛ truncate 8 x) = 1#1 → 2#32 = 1#32

theorem sge_or_not_max_commute_logical_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ¬ofBool (x_1 != 127#8) = 1#1 → ofBool (x ≤ₛ x_1) = 1#1

theorem e_1415 :
    5 * (z ||| t) - 3 *  ~~~t - 7 *  ~~~(z &&& t) + 2 *  ~~~z + 1 * z - 2 *  ~~~(z ^^^ t) - 6 *  ~~~(z &&&  ~~~t) + 22 *  ~~~(z ||| t) + 6 *  ~~~(z |||  ~~~t) + 8 * (z &&& t) =  - 10 * (z &&&  ~~~t) + 6 * (z |||  ~~~t)

theorem t0_proof : t0_before ⊑ t0_after

theorem f2_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (x_1 <ₛ 0#32) = 1#1 →
    ¬x ≥ ↑32 → zeroExtend 32 (ofBool ((7#32).sshiftRight' x <ₛ x_1)) = zeroExtend 32 (ofBool (7#32 >>> x <ₛ x_1))

theorem lshrult_01_13_exact_proof : lshrult_01_13_exact_before ⊑ lshrult_01_13_exact_after

theorem icmp_shl_ule_2_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬1#8 ≥ ↑8 → ofBool (42#8 + x ≤ᵤ (42#8 + x) <<< 1#8) = ofBool (-1#8 <ₛ x + 42#8)

theorem trunc_lshr_zext_exact_thm.extracted_1._2 : ∀ (x : BitVec 8),
  ¬(True ∧ zeroExtend 32 x >>> 6#32 <<< 6#32 ≠ zeroExtend 32 x ∨ 6#32 ≥ ↑32) →
    ¬6#8 ≥ ↑8 → truncate 8 (zeroExtend 32 x >>> 6#32) = x >>> 6#8

theorem e_588 :
    1 *  ~~~x + 3 * (x ^^^ y) + 11 *  ~~~(x &&& y) - 1 * x + 7 * (x ||| y) + 5 *  ~~~(x ^^^ y) + 2 *  ~~~(x &&&  ~~~x) - 19 *  ~~~(x ||| y) - 24 *  ~~~(x |||  ~~~y) - 22 * (x &&&  ~~~y) = 13 * (x &&& y)

theorem ashrsgt_01_04_exact_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬(True ∧ x >>> 1#4 <<< 1#4 ≠ x ∨ 1#4 ≥ ↑4) → ofBool (4#4 <ₛ x.sshiftRight' 1#4) = 0#1

theorem slt_smin1_proof : slt_smin1_before ⊑ slt_smin1_after

theorem lshr_not_nneg2_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬1#8 ≥ ↑8 → 1#8 ≥ ↑8 ∨ True ∧ (x >>> 1#8 &&& BitVec.ofInt 8 (-128) != 0) = true → False

theorem not_and_and_or_not_or_or_commute3_thm (e e_1 e_2 : IntW 32) :
  LLVM.or (LLVM.and (LLVM.and (LLVM.sdiv (const? 32 42) e_2) (LLVM.xor e_1 (const? 32 (-1)))) e)
      (LLVM.xor (LLVM.or (LLVM.or (LLVM.sdiv (const? 32 42) e_2) e_1) e) (const? 32 (-1))) ⊑
    LLVM.xor (LLVM.or (LLVM.xor e (LLVM.sdiv (const? 32 42) e_2)) e_1) (const? 32 (-1))

theorem positive_biggershl_shlnuwnsw_lshrexact_proof : positive_biggershl_shlnuwnsw_lshrexact_before ⊑ positive_biggershl_shlnuwnsw_lshrexact_after

theorem ashrslt_03_12_exact_thm (e : IntW 4) :
  icmp IntPred.slt (ashr e (const? 4 3) { «exact» := true }) (const? 4 (-4)) ⊑ const? 1 0

@[simp]
theorem FSM.eval_ite_eq_decide {α : Type}
    (cond t e : FSM α)
    (env : α → BitStream) (i : Nat) :
    (FSM.ite cond t e).eval env i =
    if (cond.eval env i) then t.eval env i else e.eval env i

theorem t_1_10_proof : t_1_10_before ⊑ t_1_10_after

theorem e_218 :
    5 *  ~~~(x &&&  ~~~x) - 7 *  ~~~(x &&& y) - 2 * (x ^^^ y) - 3 *  ~~~(x ||| y) + 4 *  ~~~(x |||  ~~~y) - 1 * (x &&&  ~~~y) - 10 * (x &&& y) =  - 5 * (x |||  ~~~y)

theorem select_constants_and_icmp_eq0_zero_tval_thm (e e_1 : IntW 1) :
  icmp IntPred.eq (LLVM.and (select e_1 (const? 8 0) (const? 8 12)) (select e (const? 8 0) (const? 8 12)))
      (const? 8 0) ⊑
    select e_1 (const? 1 1) e

theorem test95_proof : test95_before ⊑ test95_after

theorem logical_or_not_thm.extracted_1._2 : ∀ (x x_1 : BitVec 1), x_1 = 1#1 → x_1 ^^^ 1#1 = 1#1 → x = 1#1

theorem t1_ult_slt_0_thm.extracted_1._4 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (x_1 <ᵤ 65536#32) = 1#1 → ofBool (x_1 <ₛ 0#32) = 1#1 → ofBool (65535#32 <ₛ x_1) = 1#1 → False

theorem shrink_select_thm.extracted_1._2 : ∀ (x : BitVec 32) (x_1 : BitVec 1), ¬x_1 = 1#1 → truncate 8 42#32 = 42#8

theorem shl_add_and_fail_mismatch_shift_proof : shl_add_and_fail_mismatch_shift_before ⊑ shl_add_and_fail_mismatch_shift_after

theorem ashrslt_01_11_exact_thm (e : IntW 4) :
  icmp IntPred.slt (ashr e (const? 4 1) { «exact» := true }) (const? 4 (-5)) ⊑ const? 1 0

@[trans]
theorem Equiv_trans : ∀ {c₁ c₂ c₃ : Circuit α},
    Circuit.Equiv c₁ c₂ → Circuit.Equiv c₂ c₃ → Circuit.Equiv c₁ c₃

theorem logic_and_logic_or_7_thm.extracted_1._2 : ∀ (x x_1 : BitVec 1), x_1 = 1#1 → x = 1#1 → 1#1 = x

theorem t0_thm.extracted_1._1 : ∀ (x : BitVec 16),
  ¬16#32 ≥ ↑32 →
    zeroExtend 32 x <<< 16#32 &&& BitVec.ofInt 32 (-2147483648) = signExtend 32 x &&& BitVec.ofInt 32 (-2147483648)

theorem e_483 :
     - 7 *  ~~~(x &&&  ~~~y) + 11 *  ~~~(x ^^^ y) - 1 *  ~~~y + 4 *  ~~~x + 5 * (x |||  ~~~y) - 3 * x - 12 *  ~~~(x ||| y) + 4 *  ~~~(x |||  ~~~y) - 5 * (x &&& y) = 1 * (x ||| y)

theorem positive_biggershl_shlnuwnsw_lshrexact_thm.extracted_1._2 : ∀ (x : BitVec 8),
  ¬(True ∧ x >>> 3#8 <<< 3#8 ≠ x ∨
        3#8 ≥ ↑8 ∨
          True ∧ (x >>> 3#8 <<< 6#8).sshiftRight' 6#8 ≠ x >>> 3#8 ∨
            True ∧ x >>> 3#8 <<< 6#8 >>> 6#8 ≠ x >>> 3#8 ∨ 6#8 ≥ ↑8) →
    ¬(True ∧ (x <<< 3#8).sshiftRight' 3#8 ≠ x ∨ True ∧ x <<< 3#8 >>> 3#8 ≠ x ∨ 3#8 ≥ ↑8) →
      x >>> 3#8 <<< 6#8 = x <<< 3#8

theorem scalar_i32_shl_and_signbit_eq_X_is_constant1_thm (e : IntW 32) :
  icmp IntPred.eq (LLVM.and (shl (const? 32 12345) e) (const? 32 (-2147483648))) (const? 32 0) ⊑
    icmp IntPred.sgt (shl (const? 32 12345) e) (const? 32 (-1))

theorem test9_thm.extracted_1._1 : ∀ (x : BitVec 8), ofBool (x ^^^ 123#8 == 34#8) = ofBool (x == 89#8)

theorem e_2411 :
    3 * (e ^^^  ~~~( ~~~d ||| (e &&& f))) - 3 * (e &&& (d |||  ~~~f)) - 6 * (f &&&  ~~~(d &&& e)) + 11 * (f ^^^ (d ||| (e &&& f))) - 1 * (e ^^^ (d &&& (e ||| f))) + 4 *  ~~~e - 3 * (f ^^^  ~~~(d ||| (e &&& f))) - 1 * (e ^^^  ~~~( ~~~d ||| (e ^^^ f))) + 5 * ( ~~~d ||| (e &&& f)) - 5 *  ~~~(d ||| ( ~~~e &&& f)) + 7 * (f ^^^  ~~~(d &&& (e &&& f))) - 1 * (e ^^^  ~~~( ~~~d &&& (e &&& f))) - 2 *  ~~~(d |||  ~~~f) + 11 * (e ||| f) - 1 * (d |||  ~~~f) + 2 * ((e &&& f) ^^^  ~~~(d &&& (e ^^^ f))) + 2 * (d &&& f) - 7 * ((d ||| e) &&&  ~~~(d ^^^ (e ^^^ f))) - 1 * ( ~~~f &&&  ~~~(d ^^^ e)) - 1 * (f ^^^  ~~~( ~~~d &&& (e &&& f))) + 7 *  ~~~(d ||| (e ^^^ f)) - 6 * ( ~~~e |||  ~~~(d ^^^ f)) - 1 * (e ^^^ (d |||  ~~~f)) - 5 * d - 11 * (e ^^^ (d ||| (e &&& f))) - 1 * (f ^^^  ~~~( ~~~d ||| (e &&& f))) - 2 *  ~~~(e |||  ~~~f) + 11 * (f ^^^  ~~~(d ||| ( ~~~e &&& f))) + 2 * f - 5 * (f ^^^  ~~~( ~~~d ||| ( ~~~e &&& f))) + 1 * ((d &&& e) |||  ~~~(d ^^^ (e ^^^ f))) - 2 * ((d ^^^ e) &&&  ~~~(d ^^^ f)) + 4 * (e ^^^  ~~~(d &&& (e &&& f))) + 4 *  ~~~( ~~~d &&& ( ~~~e &&& f)) - 2 * ((d &&& e) ^^^  ~~~(d ^^^ ( ~~~e ||| f))) - 7 *  ~~~(d &&& (e ^^^ f)) + 1 * ( ~~~e &&&  ~~~(d ^^^ f)) + 3 *  ~~~(d ^^^ (e ^^^ f)) + 2 * (e |||  ~~~(d |||  ~~~f)) + 1 * (e ^^^  ~~~(d &&& (e ||| f))) - 11 * (e ^^^ ( ~~~d ||| (e ||| f))) + 3 *  ~~~( ~~~d &&& (e ^^^ f)) - 6 * (e ^^^ f) + 2 * ((e &&& f) ||| ( ~~~d &&& (e ||| f))) - 6 * (e ^^^ (d &&& (e ^^^ f))) - 2 * ((e &&&  ~~~f) |||  ~~~( ~~~d ||| ( ~~~e &&& f))) - 7 * (e ^^^  ~~~(d &&& (e ^^^ f))) + 2 *  ~~~(e ||| f) + 1 * (d ^^^ ( ~~~e ||| f)) - 7 * (e ^^^ ( ~~~d ||| ( ~~~e ||| f))) - 5 * (f ^^^ ( ~~~d &&& ( ~~~e ||| f))) - 11 * (d &&& ( ~~~e ||| f)) + 5 * (f |||  ~~~(d ||| e)) - 5 * (e &&&  ~~~(d &&& f)) + 7 * ((d &&& f) ||| (e &&&  ~~~f)) + 1 * ( ~~~(d |||  ~~~e) ||| (e ^^^ f)) + 2 * (f ^^^ (d &&& (e ||| f))) - 2 * ((d &&& f) ^^^  ~~~(e &&&  ~~~f)) + 7 * (d ^^^ e) + 3 * (e ||| (d ^^^ f)) + 1 *  ~~~(d &&&  ~~~f) - 3 * (e &&&  ~~~(d ^^^ f)) - 5 * (f ^^^  ~~~(d ||| e)) + 1 * (f ^^^ ( ~~~d ||| (e &&& f))) - 11 * ( ~~~d &&& (e ||| f)) + 1 *  ~~~(d ||| (e ||| f)) + 10 *  ~~~(d ||| ( ~~~e ||| f)) + 20 *  ~~~( ~~~d ||| (e ||| f)) - 2 *  ~~~( ~~~d ||| ( ~~~e ||| f)) + 6 * ( ~~~d &&& ( ~~~e &&& f)) + 8 * ( ~~~d &&& (e &&& f)) + 33 * (d &&& ( ~~~e &&& f)) - 16 * (d &&& (e &&& f)) = 1 * ((e &&&  ~~~f) |||  ~~~(d ||| ( ~~~e &&& f)))

theorem ne_rem_zero_nonuw_proof : ne_rem_zero_nonuw_before ⊑ ne_rem_zero_nonuw_after

theorem par_thm.extracted_1._2 : ∀ (x x_1 x_2 x_3 : BitVec 32),
  ¬ofBool (x_3 <ₛ x_2) = 1#1 → 0#32 &&& x_1 ||

theorem test2_proof : test2_before ⊑ test2_after

theorem and1_lshr1_is_cmp_eq_0_multiuse_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬(x ≥ ↑8 ∨ x ≥ ↑8) →
    x ≥ ↑8 ∨
        True ∧ (1#8 >>> x <<< 1#8).sshiftRight' 1#8 ≠ 1#8 >>> x ∨
          True ∧ 1#8 >>> x <<< 1#8 >>> 1#8 ≠ 1#8 >>> x ∨ 1#8 ≥ ↑8 →
      False

theorem test11_thm.extracted_1._2 : ∀ (x x_1 : BitVec 32),
  ¬zeroExtend 128 x &&& 31#128 ≥ ↑128 →
    ¬(True ∧ (x &&& 31#32).msb = true ∨
          True ∧
              (zeroExtend 64 x_1 <<< zeroExtend 64 (x &&& 31#32)).sshiftRight' (zeroExtend 64 (x &&& 31#32)) ≠
                zeroExtend 64 x_1 ∨
            True ∧
                zeroExtend 64 x_1 <<< zeroExtend 64 (x &&& 31#32) >>> zeroExtend 64 (x &&& 31#32) ≠ zeroExtend 64 x_1 ∨
              zeroExtend 64 (x &&& 31#32) ≥ ↑64) →
      truncate 64 (zeroExtend 128 x_1 <<< (zeroExtend 128 x &&& 31#128)) =
        zeroExtend 64 x_1 <<< zeroExtend 64 (x &&& 31#32)

theorem test1_thm.extracted_1._2 : ∀ (x : BitVec 333),
  ¬70368744177664#333 = 0 → ¬46#333 ≥ ↑333 → x / 70368744177664#333 = x >>> 46#333

theorem ashr_ult_8_proof : ashr_ult_8_before ⊑ ashr_ult_8_after

theorem and_logic_and_logic_or_5_thm.extracted_1._7 : ∀ (x x_1 x_2 : BitVec 1),
  ¬x_2 = 1#1 → ¬0#1 = 1#1 → x_2 &&& x = 0#1

theorem bad_add1_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬x ≥ ↑32 → True ∧ 1#32 <<< x >>> x ≠ 1#32 ∨ x ≥ ↑32 ∨ True ∧ (1#32 <<< x).uaddOverflow 1#32 = true → False

theorem icmp_sgt6_proof : icmp_sgt6_before ⊑ icmp_sgt6_after

theorem fake_sext_thm (e : IntW 3) :
  lshr (sext 18 e) (const? 18 17) ⊑ zext 18 (lshr e (const? 3 2)) { «nneg» := true }

theorem oppositesign_thm (e e_1 : IntW 16) :
  add (LLVM.or e_1 (const? 16 (-32768))) (LLVM.and e (const? 16 32767)) ⊑
    add (LLVM.or e_1 (const? 16 (-32768))) (LLVM.and e (const? 16 32767)) { «nsw» := true, «nuw» := false }

theorem test_srem_canonicalize_op0_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬(True ∧ (0#32).ssubOverflow x_1 = true ∨ (x == 0 || 32 != 1 && 0#32 - x_1 == intMin 32 && x == -1) = true) →
    (x == 0 || 32 != 1 && x_1 == intMin 32 && x == -1) = true ∨ True ∧ (0#32).ssubOverflow (x_1.srem x) = true →
      False

theorem or_and3_thm.extracted_1._6 : ∀ (x : BitVec 1) (x_1 x_2 : BitVec 32) (x_3 : BitVec 1),
  x_3 ||

theorem e_2305 :
    4 * (e ^^^ (d ||| f)) - 6 * (d ||| (e ||| f)) - 11 * (e ^^^  ~~~(d ||| ( ~~~e &&& f))) + 11 * (d ||| ( ~~~e ||| f)) + 11 * (f ^^^ (d &&& e)) + 1 *  ~~~(d ^^^ (e ^^^ f)) - 1 * (e ^^^ (d &&&  ~~~f)) + 5 *  ~~~(d &&&  ~~~e) + 2 * (d &&&  ~~~f) + 1 * ((d &&& f) ^^^ (d ^^^ (e &&& f))) - 11 * ((d ||| e) &&& (d ^^^ (e ^^^ f))) + 4 * (f ^^^  ~~~(d |||  ~~~e)) - 6 * ( ~~~(d |||  ~~~e) |||  ~~~(d ^^^ (e ^^^ f))) + 4 * ((d ||| e) &&&  ~~~(e ^^^ f)) - 1 * ((e &&&  ~~~f) |||  ~~~( ~~~d ||| ( ~~~e &&& f))) + 2 * (f ^^^ (d &&&  ~~~e)) + 4 *  ~~~(e |||  ~~~f) + 1 * (e ^^^  ~~~( ~~~d &&& ( ~~~e &&& f))) - 7 * (f &&& (d ||| e)) - 1 * (f ^^^ ( ~~~d ||| ( ~~~e &&& f))) - 2 * ((d |||  ~~~e) &&& (e ^^^ f)) - 1 * (e ^^^  ~~~( ~~~d &&& ( ~~~e ||| f))) + 1 * (d ^^^ ( ~~~e ||| f)) - 7 * ((d ^^^ e) &&& (d ^^^ f)) + 2 *  ~~~(e &&& f) + 1 *  ~~~e + 7 * (e ^^^  ~~~( ~~~d ||| (e &&& f))) - 1 *  ~~~( ~~~d ||| ( ~~~e &&& f)) - 1 * ( ~~~f ||| (d ^^^ e)) - 6 * (f ^^^  ~~~(d &&& (e &&& f))) + 3 * (d ^^^ f) + 5 * (e ^^^  ~~~(d &&& f)) + 1 * (e ^^^ (d ||| ( ~~~e &&& f))) + 7 *  ~~~(d &&&  ~~~d) - 2 * ((e &&&  ~~~f) ^^^ ( ~~~d ||| (e ^^^ f))) + 4 * e + 7 * (e ^^^  ~~~( ~~~d &&& (e ^^^ f))) - 1 * (e ^^^ (d ||| (e ^^^ f))) - 7 * ((d &&& e) ^^^ (e ||| f)) - 2 * (f ||| (d ^^^ e)) - 7 * (d ||| (e &&& f)) - 2 * (e &&& f) + 1 * (e ||| (d ^^^ f)) - 2 * (d &&&  ~~~e) - 3 * (f &&&  ~~~(d &&&  ~~~e)) - 1 * (f ^^^ ( ~~~d ||| ( ~~~e ||| f))) + 2 * (e ^^^ ( ~~~d &&& (e ^^^ f))) - 7 * (f ||| (d &&&  ~~~e)) - 2 * f + 1 * ((e &&&  ~~~f) |||  ~~~(d ||| ( ~~~e &&& f))) - 2 * (f ^^^ ( ~~~d &&& (e ||| f))) - 11 * ( ~~~f &&&  ~~~(d ^^^ e)) - 11 * (f ^^^ (d &&& (e ||| f))) + 3 * (f ^^^  ~~~(d ||| ( ~~~e &&& f))) - 1 * (e ^^^  ~~~(d &&& ( ~~~e &&& f))) - 3 * ((d ^^^ e) &&&  ~~~(d ^^^ f)) - 1 * ( ~~~d ||| (e &&& f)) - 4 *  ~~~(d ||| (e ||| f)) + 3 *  ~~~(d ||| ( ~~~e ||| f)) + 11 *  ~~~( ~~~d ||| ( ~~~e ||| f)) - 22 * ( ~~~d &&& ( ~~~e &&& f)) + 12 * ( ~~~d &&& (e &&& f)) - 6 * (d &&& ( ~~~e &&& f)) =  - 15 * (d &&& (e &&& f)) + 3 *  ~~~( ~~~d ||| (e ||| f))

theorem or_or_and_pat7_proof : or_or_and_pat7_before ⊑ or_or_and_pat7_after

theorem and_xor_or3_proof : and_xor_or3_before ⊑ and_xor_or3_after

theorem substitute_constant_or_ne_swap_sle_proof : substitute_constant_or_ne_swap_sle_before ⊑ substitute_constant_or_ne_swap_sle_after

theorem i_proof : i_before ⊑ i_after

theorem not_false_not_thm.extracted_1._3 : ∀ (x x_1 : BitVec 1), ¬x_1 ^^^ 1#1 = 1#1 → ¬x_1 = 1#1 → x ^^^ 1#1 = 0#1

theorem and_or3_commuted_thm (e e_1 : IntW 1) (e_2 e_3 : IntW 32) :
  select (LLVM.and (icmp IntPred.eq e_3 e_2) e_1) e e_1 ⊑
    select e_1 (select (icmp IntPred.ne e_3 e_2) (const? 1 1) e) (const? 1 0)

theorem shl_nuw_eq_0_thm (e e_1 : IntW 8) :
  icmp IntPred.eq (shl e_1 e { «nsw» := false, «nuw» := true }) (const? 8 0) ⊑
    icmp IntPred.eq e_1 (const? 8 0)

theorem sdiv_icmp1_thm.extracted_1._1 : ∀ (x : BitVec 64),
  ¬(True ∧ x.smod 5#64 ≠ 0 ∨ (5#64 == 0 || 64 != 1 && x == intMin 64 && 5#64 == -1) = true) →
    ofBool (x.sdiv 5#64 == 0#64) = ofBool (x == 0#64)

theorem exactly_one_set_signbit_proof : exactly_one_set_signbit_before ⊑ exactly_one_set_signbit_after

theorem masked_icmps_mask_notallzeros_bmask_mixed_1_proof : masked_icmps_mask_notallzeros_bmask_mixed_1_before ⊑ masked_icmps_mask_notallzeros_bmask_mixed_1_after

theorem fold_sext_to_and_wrong7_proof : fold_sext_to_and_wrong7_before ⊑ fold_sext_to_and_wrong7_after

theorem add_mask_sign_i32_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬(31#32 ≥ ↑32 ∨ 31#32 ≥ ↑32) →
    ofBool (x <ₛ 0#32) = 1#1 → (x.sshiftRight' 31#32 &&& 8#32) + x.sshiftRight' 31#32 = 7#32

theorem wide_source_matching_signbits_proof : wide_source_matching_signbits_before ⊑ wide_source_matching_signbits_after

theorem main_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬(6#8 ≥ ↑8 ∨ 7#8 ≥ ↑8) → 5#8 ≥ ↑8 ∨ True ∧ ((truncate 8 x ^^^ -1#8) <<< 5#8 &&& 64#8).msb = true → False

theorem a_thm.extracted_1._1 : ∀ (x x_1 : BitVec 1),
  x_1 = 1#1 → True ∧ (2#32).saddOverflow (signExtend 32 x) = true → False

theorem xor_sge_thm (e e_1 : IntW 8) :
  icmp IntPred.sge (mul e_1 e_1) (LLVM.xor (LLVM.or e (const? 8 (-128))) (mul e_1 e_1)) ⊑
    icmp IntPred.slt (LLVM.xor (LLVM.or e (const? 8 (-128))) (mul e_1 e_1)) (mul e_1 e_1)

@[bv_multi_width_normalize]
theorem iff_iff_and_or_not_and_not {P Q : Prop} : (P ↔ Q) ↔ ((P ∧ Q) ∨  (¬ P ∧ ¬ Q))

theorem mul_add_to_mul_5_thm.extracted_1._1 : ∀ (x : BitVec 16),
  ¬(True ∧ x.smulOverflow 3#16 = true ∨
        True ∧ x.smulOverflow 7#16 = true ∨ True ∧ (x * 3#16).saddOverflow (x * 7#16) = true) →
    True ∧ x.smulOverflow 10#16 = true → False

theorem shl_lshr_and_exact_proof : shl_lshr_and_exact_before ⊑ shl_lshr_and_exact_after

theorem reduce_xor_common_op_commute0_proof : reduce_xor_common_op_commute0_before ⊑ reduce_xor_common_op_commute0_after

theorem ult_rem_zero_proof : ult_rem_zero_before ⊑ ult_rem_zero_after

theorem tryFactorization_xor_ashr_ashr_thm (e : IntW 32) :
  LLVM.xor (ashr (const? 32 (-3)) e) (ashr (const? 32 (-5)) e) ⊑ lshr (const? 32 6) e

theorem ashrsgt_02_09_thm (e : IntW 4) : icmp IntPred.sgt (ashr e (const? 4 2)) (const? 4 (-7)) ⊑ const? 1 1

theorem add_mask_ashr28_non_pow2_i32_proof : add_mask_ashr28_non_pow2_i32_before ⊑ add_mask_ashr28_non_pow2_i32_after

theorem tryFactorization_xor_lshr_ashr_thm (e : IntW 32) :
  LLVM.xor (lshr (const? 32 5) e) (ashr (const? 32 (-3)) e) ⊑ ashr (const? 32 (-8)) e

omit rets var in
theorem Com.recAux'_eq :
    Com.recAux' (motive:=motive) = Com.rec' (motive:=motive)

private theorem sge_eq_sle (A B : BitVec w) : (A ≥ₛ B) = (B ≤ₛ A)

theorem or_signbit_shl_proof : or_signbit_shl_before ⊑ or_signbit_shl_after

theorem bools_logical_commute3_and2_thm.extracted_1._2 : ∀ (x x_1 : BitVec 1),
  x_1 = 1#1 → x = 1#1 → x ^^^ 1#1 = 1#1 → False

@[simp]
lemma step_cast {M : NFA α σ} (h : σ = ς) (q q' : σ): (h ▸ q') ∈ (h ▸ M).step (h ▸ q) a ↔ q' ∈  M.step q a

theorem ugt_and_min_commute_thm (e e_1 : IntW 8) :
  LLVM.and (icmp IntPred.eq e_1 (const? 8 0)) (icmp IntPred.ugt e_1 e) ⊑ const? 1 0

theorem outputWith_carryWith_eq_evalWith (p : FSM arity)
  (xs ys : arity → BitStream) (xN : arity → Bool)
  (hysLt : ∀ a i, i < n → ys a i = xs a i)
  (hysN : ∀ a, ys a n = xN a) :
  p.outputWith (p.carryWith p.initCarry xs n) xN = p.evalWith p.initCarry ys n

theorem exact_lshr_ne_both_equal_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬(True ∧ 126#8 >>> x <<< x ≠ 126#8 ∨ x ≥ ↑8) → ofBool (126#8 >>> x != 126#8) = ofBool (x != 0#8)

theorem e_2036 :
    2 * (f ^^^  ~~~(d &&&  ~~~e)) + 7 *  ~~~(d ^^^ ( ~~~e &&& f)) - 1 *  ~~~(e ||| f) - 1 * (f &&& (d ||| e)) + 2 * ( ~~~d &&& (e ||| f)) + 1 * (d &&&  ~~~e) - 1 * (f ^^^  ~~~( ~~~d &&& ( ~~~e &&& f))) - 2 * ((d ||| e) &&&  ~~~(e ^^^ f)) + 2 *  ~~~(e ^^^ f) - 7 * (d ^^^ (e ||| f)) + 4 * (f &&&  ~~~(d ^^^ e)) - 5 *  ~~~(d ||| f) - 1 * (d ||| f) + 3 *  ~~~(d ^^^ (e ^^^ f)) - 7 * (f ^^^ ( ~~~d &&& (e ||| f))) - 2 * (f ^^^  ~~~(d ||| ( ~~~e &&& f))) - 5 * ((d &&& f) ^^^ (d ^^^ ( ~~~e &&& f))) - 11 *  ~~~(e &&& f) - 2 *  ~~~(d ^^^ ( ~~~e ||| f)) - 7 * (f ^^^ ( ~~~d &&& ( ~~~e ||| f))) + 7 *  ~~~(d &&& e) + 2 *  ~~~f - 6 * ((d &&& e) |||  ~~~(d ^^^ (e ^^^ f))) - 1 * (f ^^^  ~~~(d ||| e)) + 11 * ((d &&&  ~~~e) ||| (d ^^^ (e ^^^ f))) - 2 *  ~~~( ~~~d &&& ( ~~~e &&& f)) - 2 * ( ~~~(d ||| e) ||| (e ^^^ f)) - 2 *  ~~~(d &&& (e ^^^ f)) - 1 *  ~~~(d ||| (e ^^^ f)) + 18 *  ~~~(d ||| (e ||| f)) + 9 *  ~~~(d ||| ( ~~~e ||| f)) + 11 *  ~~~( ~~~d ||| (e ||| f)) + 21 *  ~~~( ~~~d ||| ( ~~~e ||| f)) + 6 * ( ~~~d &&& ( ~~~e &&& f)) + 16 * (d &&& ( ~~~e &&& f)) + 16 * (d &&& (e &&& f)) =  - 1 * ( ~~~d &&& (e ^^^ f)) - 2 * ( ~~~d &&& (e &&& f))

theorem logic_or_logic_and_4_proof : logic_or_logic_and_4_before ⊑ logic_or_logic_and_4_after

theorem n0_thm.extracted_1._1 : ∀ (x : BitVec 8), ofBool (x &&& 4#8 == x) = ofBool (x &&& BitVec.ofInt 8 (-5) == 0#8)

theorem and_consts_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (4#32 &&& x == 0#32) ||

theorem t14_x_is_one_proof : t14_x_is_one_before ⊑ t14_x_is_one_after

theorem test_zext4_thm.extracted_1._3 : ∀ (x x_1 : BitVec 1),
  x_1 = 1#1 → x_1 ^^^ 1#1 = 1#1 → zeroExtend 32 x = zeroExtend 32 1#1

theorem e_1446 :
     - 7 *  ~~~(z ^^^ t) + 11 *  ~~~t - 7 * (z ||| t) + 3 * (z |||  ~~~t) + 5 *  ~~~(z &&&  ~~~t) + 5 * z + 1 *  ~~~(z &&&  ~~~z) - 11 *  ~~~(z ||| t) + 3 *  ~~~(z |||  ~~~t) - 13 * (z &&&  ~~~t) = 2 *  ~~~z

theorem icmp_ne_sext_slt_otherwise_nofold_thm (e : IntW 32) :
  icmp IntPred.ne (sext 32 (icmp IntPred.slt e (const? 32 2))) e ⊑
    icmp IntPred.ne e (sext 32 (icmp IntPred.slt e (const? 32 2)))

theorem ult_x_impliesT_eq_umax_todo_thm (e e_1 e_2 : IntW 8) :
  icmp IntPred.ne (select (icmp IntPred.ugt e_2 e_1) (const? 8 (-1)) e) e_1 ⊑
    select (icmp IntPred.ugt e_2 e_1) (const? 1 1) (icmp IntPred.ne e e_1)

theorem a_false_implies_b_false2_comm_proof : a_false_implies_b_false2_comm_before ⊑ a_false_implies_b_false2_comm_after

theorem and_def {α : Type _} (c d : Circuit α) :
  (c &&& d) = Circuit.simplifyAnd c d

theorem Holor.pointwise_mul_index [Mul α] (h₁ h₂ : Holor α ds) :
  (h₁ * h₂) i = h₁ i * h₂ i

theorem scalar_i32_signbit_lshr_and_eq_X_is_constant2_proof : scalar_i32_signbit_lshr_and_eq_X_is_constant2_before ⊑ scalar_i32_signbit_lshr_and_eq_X_is_constant2_after

theorem main7c_logical_thm.extracted_1._7 : ∀ (x x_1 x_2 : BitVec 32),
  ofBool (x_2 == x_2 &&& x_1) = 1#1 →
    ¬ofBool (x_2 != x_2 &&& x_1) = 1#1 →
      ofBool (x == x &&& x_1) = 1#1 → 0#32 = zeroExtend 32 (ofBool (x != x &&& x_1))

theorem or_xor_tree_1000_proof : or_xor_tree_1000_before ⊑ or_xor_tree_1000_after

theorem test_sub_nuw_nsw__all_are_safe_thm (e : IntW 32) :
  select (icmp IntPred.eq (LLVM.and e (const? 32 255)) (const? 32 6)) (const? 32 (-260))
      (sub (const? 32 (-254)) (LLVM.and e (const? 32 255)) { «nsw» := true, «nuw» := true }) ⊑
    sub (const? 32 (-254)) (LLVM.and e (const? 32 255)) { «nsw» := true, «nuw» := true }

theorem land_lor_left2_proof : land_lor_left2_before ⊑ land_lor_left2_after

theorem ashrslt_01_08_exact_thm (e : IntW 4) :
  icmp IntPred.slt (ashr e (const? 4 1) { «exact» := true }) (const? 4 (-8)) ⊑ const? 1 0

theorem ofBitVec_one_eqTo_ofNat : @ofBitVecSext w 1 ≈ʷ ofNat 1

@[simp]
theorem LLVM.select?_eq_value {w : Nat} {c : BitVec 1} {x y : LLVM.IntW w} :
    LLVM.select (.value c) x y =  if c = 1 then x else y

theorem not_sext_thm.extracted_1._2 : ∀ (x : BitVec 1), ¬x = 1#1 → -1#999 = signExtend 999 (x ^^^ 1#1)

theorem select_icmp_eq_and_1_0_lshr_fv_thm.extracted_1._2 : ∀ (x x_1 : BitVec 8),
  ofBool (x_1 &&& 1#8 == 0#8) = 1#1 → ¬(1#8 ≥ ↑8 ∨ x_1 <<< 1#8 &&& 2#8 ≥ ↑8) → x = x >>> (x_1 <<< 1#8 &&& 2#8)

theorem shl_sub_lshr_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 32),
  ¬(True ∧ x_2 <<< x_1 >>> x_1 ≠ x_2 ∨
        x_1 ≥ ↑32 ∨
          True ∧ (x_2 <<< x_1).ssubOverflow x = true ∨
            True ∧ (x_2 <<< x_1).usubOverflow x = true ∨
              True ∧ (x_2 <<< x_1 - x) >>> x_1 <<< x_1 ≠ x_2 <<< x_1 - x ∨ x_1 ≥ ↑32) →
    True ∧ x >>> x_1 <<< x_1 ≠ x ∨
        x_1 ≥ ↑32 ∨ True ∧ x_2.ssubOverflow (x >>> x_1) = true ∨ True ∧ x_2.usubOverflow (x >>> x_1) = true →
      False

@[simp] theorem dropUntil_last   : dropUntil (cons ty Γ) (Var.last Γ ty) = Γ

theorem icmp_select_implied_cond_ne_proof : icmp_select_implied_cond_ne_before ⊑ icmp_select_implied_cond_ne_after

theorem test_thm.extracted_1._1 : zeroExtend 32 (ofBool (1#32 == 2#32)) = 0#32

theorem test69_thm.extracted_1._3 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (x_1 &&& 128#32 != 0#32) = 1#1 → 6#32 ≥ ↑32 → False

theorem sext_sub_nuw_thm.extracted_1._1 : ∀ (x : BitVec 1) (x_1 : BitVec 8),
  ¬(True ∧ x_1.usubOverflow (signExtend 8 x) = true) → x_1 - signExtend 8 x = x_1 + zeroExtend 8 x

theorem e_595 :
     - 1 * (x ^^^ y) - 2 * (x ||| y) - 2 * (x |||  ~~~y) + 4 * y + 3 * x + 1 *  ~~~(x &&&  ~~~y) + 11 *  ~~~(x ^^^ y) - 8 *  ~~~(x ||| y) + 1 * (x &&&  ~~~y) - 15 * (x &&& y) =  - 1 *  ~~~(x &&& y) + 3 *  ~~~x

theorem icmp_ne_zext_eq_non_boolean_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (zeroExtend 32 (ofBool (x == 2#32)) != x) = ofBool (x != 0#32)

theorem no_shift_xor_multiuse_cmp_or_thm.extracted_1._4 : ∀ (x x_1 x_2 x_3 : BitVec 32),
  ¬ofBool (0#32 != x_3 &&& 4096#32) = 1#1 →
    ¬ofBool (x_3 &&& 4096#32 == 0#32) = 1#1 →
      (x_2 ||| 4096#32) * x * (x_2 ||| 4096#32) = x_2 * x_1 * (x_2 ||| 4096#32)

theorem main13_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬ofBool (truncate 16 x <ₛ 0#16) &&& ofBool (truncate 8 x <ₛ 0#8) = 1#1 →
    ofBool (x &&& 32896#32 == 32896#32) = 1#1 → 1#32 = 2#32

theorem test_sext3_thm.extracted_1._2 : ∀ (x : BitVec 1), x = 1#1 → ¬x ^^^ 1#1 = 1#1 → 0#32 = signExtend 32 0#1

theorem main14_thm (e : IntW 32) :
  select (LLVM.and (icmp IntPred.sge (trunc 16 e) (const? 16 0)) (icmp IntPred.sge (trunc 8 e) (const? 8 0)))
      (const? 32 2) (const? 32 1) ⊑
    select (icmp IntPred.eq (LLVM.and e (const? 32 32896)) (const? 32 0)) (const? 32 2) (const? 32 1)

theorem f_var1_proof : f_var1_before ⊑ f_var1_after

theorem in_constant_14_vary_thm (e : IntW 4) :
  LLVM.xor (LLVM.and (LLVM.xor e (const? 4 (-2))) (const? 4 1)) e ⊑ LLVM.and e (const? 4 (-2))

theorem test11_proof : test11_before ⊑ test11_after

theorem fold_eq_lhs_proof : fold_eq_lhs_before ⊑ fold_eq_lhs_after

theorem not_xor_to_or_not4_thm (e e_1 e_2 : IntW 3) :
  LLVM.xor (LLVM.xor (LLVM.and e_2 e_1) (LLVM.or e e_2)) (const? 3 (-1)) ⊑
    LLVM.or (LLVM.and e_2 e_1) (LLVM.xor (LLVM.or e e_2) (const? 3 (-1)))

theorem uge_umin2_proof : uge_umin2_before ⊑ uge_umin2_after

theorem and_sext_to_sel_thm.extracted_1._2 : ∀ (x : BitVec 32) (x_1 : BitVec 1),
  ¬x_1 = 1#1 → signExtend 32 x_1 &&& x = 0#32

theorem lt_signed_to_large_unsigned_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ofBool (signExtend 32 x <ᵤ 1024#32) = ofBool (-1#8 <ₛ x)

theorem icmp_eq_zext_eq_zero_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (zeroExtend 32 (ofBool (x == 0#32)) == x) = 0#1

theorem t0_basic_proof : t0_basic_before ⊑ t0_basic_after

theorem test2_logical_proof : test2_logical_before ⊑ test2_logical_after

theorem trunc_nuw_xor_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ¬(True ∧ zeroExtend 8 (truncate 1 (x_1 ^^^ x)) ≠ x_1 ^^^ x) → truncate 1 (x_1 ^^^ x) = ofBool (x_1 != x)

theorem select_icmp_eq_and_32_0_or_8_thm.extracted_1._4 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (x_1 &&& 32#32 == 0#32) = 1#1 → ¬2#32 ≥ ↑32 → x ||

theorem ashr_mul_times_3_div_2_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬(True ∧ x.smulOverflow 3#32 = true ∨ True ∧ x.umulOverflow 3#32 = true ∨ 1#32 ≥ ↑32) →
    1#32 ≥ ↑32 ∨ True ∧ x.saddOverflow (x >>> 1#32) = true ∨ True ∧ x.uaddOverflow (x >>> 1#32) = true → False

theorem and_or_not_not_wrong_a_proof : and_or_not_not_wrong_a_before ⊑ and_or_not_not_wrong_a_after

theorem t1_thm.extracted_1._2 : ∀ (x : BitVec 8) (x_1 : BitVec 1),
  ¬x_1 = 1#1 → signExtend 8 x_1 + x ^^^ signExtend 8 x_1 = x

theorem t6_ugt_sgt_128_thm.extracted_1._2 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (143#32 <ᵤ x_1 + 16#32) = 1#1 → ofBool (127#32 <ₛ x_1) = 1#1 → x_1 = x

theorem t6_ugt_sgt_128_thm.extracted_1._5 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (143#32 <ᵤ x_1 + 16#32) = 1#1 → ofBool (127#32 <ₛ x_1) = 1#1 → False

theorem test28 {w : Nat} (x : BitVec w) :
    x &&& x &&& x &&& x &&& x &&& x = x

@[simp] theorem toHom_comp_toHom (f : Γ.Diff Δ) (g : Δ.Diff Ξ) :
    f.toHom.comp g.toHom = (f + g).toHom

theorem bv_276_2 :
    ∀ (e e_1 : LLVM.IntW 5), LLVM.mul (LLVM.udiv e_1 e) (LLVM.sub (LLVM.const? 5 0) e) ⊑ LLVM.sub (LLVM.urem e_1 e) e_1

theorem n0_thm (e : IntW 8) :
  icmp IntPred.ne (LLVM.and e (const? 8 4)) e ⊑
    icmp IntPred.ne (LLVM.and e (const? 8 (-5))) (const? 8 0)

theorem main4b_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬ofBool (x &&& 7#32 == 7#32) &&& ofBool (x &&& 16#32 != 0#32) = 1#1 →
    1#32 = zeroExtend 32 (ofBool (x &&& 23#32 != 23#32))

theorem test69_thm.extracted_1._2 : ∀ (x x_1 : BitVec 32),
  ofBool (x_1 &&& 128#32 != 0#32) = 1#1 → ¬6#32 ≥ ↑32 → x = x ||

theorem main7d_logical_proof : main7d_logical_before ⊑ main7d_logical_after

theorem test10b_proof : test10b_before ⊑ test10b_after

theorem no_shift_no_xor_multiuse_cmp_with_xor_thm.extracted_1._4 : ∀ (x x_1 x_2 x_3 : BitVec 32),
  ¬ofBool (x_3 &&& 4096#32 == 0#32) = 1#1 → (x_2 ^^^ 4096#32) * x = (x_2 ^^^ x_3 &&& 4096#32) * x

theorem t0_commutative_thm (e e_1 : IntW 8) (e_2 : IntW 1) (e_3 e_4 : IntW 8) :
  select (select (icmp IntPred.eq e_4 e_3) (LLVM.xor e_2 (const? 1 1)) (const? 1 0)) e_1 e ⊑
    select (select (icmp IntPred.ne e_4 e_3) (const? 1 1) e_2) e e_1

theorem test34_thm.extracted_1._2 : ∀ (x : BitVec 16),
  ¬8#32 ≥ ↑32 → ¬8#16 ≥ ↑16 → truncate 16 (zeroExtend 32 x >>> 8#32) = x >>> 8#16

theorem e_183 :
     - 5 *  ~~~y + 1 *  ~~~(x &&&  ~~~x) + 4 *  ~~~(x ||| y) - 2 *  ~~~(x |||  ~~~y) + 3 * (x &&&  ~~~y) - 2 * (x &&& y) =  - 1 * (x ||| y)

theorem shl_add_and_fail_mismatch_shift_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ¬(1#8 ≥ ↑8 ∨ 1#8 ≥ ↑8) → 1#8 ≥ ↑8 ∨ 1#8 ≥ ↑8 ∨ True ∧ (x >>> 1#8).uaddOverflow 123#8 = true → False

theorem select_constants_and_icmp_eq0_thm (e e_1 : IntW 1) :
  icmp IntPred.eq (LLVM.and (select e_1 (const? 8 2) (const? 8 1)) (select e (const? 8 2) (const? 8 1)))
      (const? 8 0) ⊑
    LLVM.xor e_1 e

theorem test25_proof : test25_before ⊑ test25_after

theorem ashrsgt_03_04_thm.extracted_1._1 : ∀ (x : BitVec 4), ¬3#4 ≥ ↑4 → ofBool (4#4 <ₛ x.sshiftRight' 3#4) = 0#1

theorem slt_swap_or_not_max_commute_proof : slt_swap_or_not_max_commute_before ⊑ slt_swap_or_not_max_commute_after

theorem shl_nsw_nuw_poison_constant_fold_proof : shl_nsw_nuw_poison_constant_fold_before ⊑ shl_nsw_nuw_poison_constant_fold_after

theorem BitVec.ofFn_getElem_fin {w : Nat} (f : Fin w → Bool) (i : Fin w) :
    (BitVec.ofFn f)[i.val] = f i

theorem test2_proof : test2_before ⊑ test2_after

theorem sel_sext_constants_thm.extracted_1._1 : ∀ (x : BitVec 1), x = 1#1 → signExtend 16 (-1#8) = -1#16

theorem andn_or_cmp_4_proof : andn_or_cmp_4_before ⊑ andn_or_cmp_4_after

theorem AvoidCollision_toNat_signExtend (x : BitVec w) {v : Nat} :
    (x.signExtend v).toNat = (x.setWidth v).toNat + if x.msb then 2^v - 2^w else 0

theorem icmp_ne_zext_ne_zero_thm (e : IntW 32) :
  icmp IntPred.ne (zext 32 (icmp IntPred.ne e (const? 32 0))) e ⊑
    icmp IntPred.ugt e (const? 32 1)

theorem smear_set_bit_proof : smear_set_bit_before ⊑ smear_set_bit_after

theorem t2_ult_sgt_65536_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x <ᵤ 65536#32) = 1#1 → ofBool (65535#32 <ₛ x) = 1#1 ∨ ofBool (x <ₛ 0#32) = 1#1 → False

theorem a_true_implies_b_false_thm.extracted_1._1 : ∀ (x : BitVec 1) (x_1 : BitVec 8),
  ofBool (20#8 <ᵤ x_1) = 1#1 → ofBool (x_1 <ᵤ 10#8) = 1#1 → False

theorem icmp_select_var_commuted_thm.extracted_1._2 : ∀ (x x_1 x_2 : BitVec 8),
  ¬x_2 = 0 → ofBool (x_1 == 0#8) = 1#1 → ofBool (42#8 / x_2 == 42#8 / x_2) = 1#1

theorem test_mul_nsw__nsw_is_safe_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x ||| BitVec.ofInt 32 (-83886080) == BitVec.ofInt 32 (-83886079)) = 1#1 →
    True ∧ (x ||| BitVec.ofInt 32 (-83886080)).smulOverflow 9#32 = true → False

theorem test_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (13#32 <ᵤ x) &&& ofBool (x == 15#32) = ofBool (x == 15#32)

theorem e_957 :
     - 2 *  ~~~(z &&&  ~~~z) + 4 *  ~~~(z &&& t) - 2 * (z |||  ~~~t) + 5 *  ~~~(z |||  ~~~t) + 7 * (z &&&  ~~~t) + 11 * (z &&& t) = 7 * (z ||| t)

theorem ugt_rem_nz_thm (e : IntW 8) :
  icmp IntPred.ugt (mul e (const? 8 5) { «nsw» := false, «nuw» := true }) (const? 8 21) ⊑
    icmp IntPred.ugt e (const? 8 4)

theorem and_logic_and_logic_or_3_thm.extracted_1._1 : ∀ (x x_1 : BitVec 1),
  x_1 &&& x = 1#1 → x = 1#1 → ¬x_1 = 1#1 → False

theorem lshrugt_02_03_exact_proof : lshrugt_02_03_exact_before ⊑ lshrugt_02_03_exact_after

theorem lor_land_right2_thm (e e_1 : IntW 1) : select e_1 (select e (const? 1 1) e_1) (const? 1 0) ⊑ e_1

theorem test_sdiv_canonicalize_op0_exact_thm.extracted_1._2 : ∀ (x x_1 : BitVec 32),
  ¬(True ∧ (0#32).ssubOverflow x_1 = true ∨
        True ∧ (0#32 - x_1).smod x ≠ 0 ∨ (x == 0 || 32 != 1 && 0#32 - x_1 == intMin 32 && x == -1) = true) →
    ¬(True ∧ x_1.smod x ≠ 0 ∨
          (x == 0 || 32 != 1 && x_1 == intMin 32 && x == -1) = true ∨ True ∧ (0#32).ssubOverflow (x_1.sdiv x) = true) →
      (0#32 - x_1).sdiv x = 0#32 - x_1.sdiv x

theorem t3_exact_thm.extracted_1._2 : ∀ (x : BitVec 64),
  ¬(True ∧ x >>> 63#64 <<< 63#64 ≠ x ∨ 63#64 ≥ ↑64) →
    ¬(True ∧ x >>> 63#64 <<< 63#64 ≠ x ∨
          63#64 ≥ ↑64 ∨
            True ∧ signExtend 64 (truncate 32 (x >>> 63#64)) ≠ x >>> 63#64 ∨
              True ∧ zeroExtend 64 (truncate 32 (x >>> 63#64)) ≠ x >>> 63#64) →
      0#32 - truncate 32 (x.sshiftRight' 63#64) = truncate 32 (x >>> 63#64)

theorem icmp_equality_test_commute_icmp2_proof : icmp_equality_test_commute_icmp2_before ⊑ icmp_equality_test_commute_icmp2_after

theorem badimm1_thm.extracted_1._2 : ∀ (x : BitVec 16),
  ¬(7#8 ≥ ↑8 ∨ 9#16 ≥ ↑16) →
    ¬ofBool ((truncate 8 x).sshiftRight' 7#8 == truncate 8 (x >>> 9#16)) = 1#1 →
      ¬15#16 ≥ ↑16 →
        7#8 ≥ ↑8 ∨
            9#16 ≥ ↑16 ∨
              True ∧ signExtend 16 (truncate 8 (x >>> 9#16)) ≠ x >>> 9#16 ∨
                True ∧ zeroExtend 16 (truncate 8 (x >>> 9#16)) ≠ x >>> 9#16 →
          False

theorem t6_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬(True ∧ (0#8).ssubOverflow x = true) → ofBool (0#8 - x <ᵤ x) = ofBool (x <ₛ 0#8)

theorem sgt_and_min_commute_logical_proof : sgt_and_min_commute_logical_before ⊑ sgt_and_min_commute_logical_after

theorem e_1870 :
    2 * ( ~~~(a ^^^ b) &&& (a ^^^ c)) - 6 * (c ||| (a ^^^ b)) + 1 *  ~~~( ~~~a &&& ( ~~~b &&& c)) + 1 * ( ~~~(a ^^^ b) &&&  ~~~(a ^^^ c)) - 2 * ((b &&& c) ^^^  ~~~(a &&& (b ^^^ c))) - 11 * (c ^^^  ~~~( ~~~a ||| (b &&& c))) - 6 * ((b &&& c) ||| (a &&& (b ||| c))) - 1 * ( ~~~a &&& ( ~~~b ||| c)) + 4 *  ~~~( ~~~a &&& (b ||| c)) - 1 * (a ^^^ b) + 1 * (c ^^^ (a ||| ( ~~~b &&& c))) - 5 * (a &&& c) - 1 * (b ^^^  ~~~(a |||  ~~~c)) - 2 * (b ^^^  ~~~( ~~~a &&& (b ^^^ c))) + 4 * (c ^^^  ~~~(a ||| b)) + 3 * ( ~~~(a |||  ~~~b) ||| (a ^^^ (b ^^^ c))) + 2 * ((a ^^^ b) ||| (a ^^^ c)) + 1 * (c ^^^  ~~~( ~~~a &&& ( ~~~b ||| c))) - 11 * ((a &&& b) ^^^ (a ^^^ (b &&& c))) + 1 * ((a ^^^ b) &&&  ~~~(a ^^^ c)) - 5 * (b ^^^ (a &&& (b ^^^ c))) + 4 * ((a &&&  ~~~b) |||  ~~~(a ^^^ (b ^^^ c))) + 1 * (b ^^^ ( ~~~a &&& (b ||| c))) - 1 *  ~~~a + 4 *  ~~~(b ||| c) - 1 *  ~~~(a ^^^ (b ^^^ c)) - 3 *  ~~~(a ^^^ (b ||| c)) - 2 * (b ^^^ ( ~~~a ||| ( ~~~b &&& c))) - 7 * (c ^^^ (a &&& b)) + 3 * (c ^^^  ~~~( ~~~a &&& (b &&& c))) - 1 *  ~~~(a ||| b) + 2 * (b ^^^ (a |||  ~~~c)) + 1 * (a ^^^ (b ||| c)) - 3 * ((a &&&  ~~~b) ||| (b ^^^ c)) - 1 * ((a ||| b) &&&  ~~~(a ^^^ (b ^^^ c))) - 5 * (c |||  ~~~(a |||  ~~~b)) - 3 * (b ^^^ ( ~~~a ||| (b ^^^ c))) + 7 * (a ^^^ (b ^^^ c)) + 1 * ( ~~~a ||| (b ||| c)) + 7 * ( ~~~(a |||  ~~~b) ||| (b ^^^ c)) - 8 *  ~~~(a ||| (b ||| c)) - 1 *  ~~~(a ||| ( ~~~b ||| c)) + 3 *  ~~~( ~~~a ||| (b ||| c)) + 8 *  ~~~( ~~~a ||| ( ~~~b ||| c)) + 18 * ( ~~~a &&& ( ~~~b &&& c)) + 26 * ( ~~~a &&& (b &&& c)) + 36 * (a &&& (b &&& c)) =  - 35 * (a &&& ( ~~~b &&& c))

theorem shl_trunc_smaller_ashr_proof : shl_trunc_smaller_ashr_before ⊑ shl_trunc_smaller_ashr_after

theorem not_signbit_zext_thm.extracted_1._1 : ∀ (x : BitVec 16),
  ¬15#16 ≥ ↑16 → zeroExtend 32 ((x ^^^ -1#16) >>> 15#16) = zeroExtend 32 (ofBool (-1#16 <ₛ x))

theorem src_srem_shl_demand_max_mask_hit_demand_thm (e : IntW 32) :
  LLVM.and (shl (LLVM.srem e (const? 32 4)) (const? 32 1)) (const? 32 (-4)) ⊑
    LLVM.and (shl (LLVM.srem e (const? 32 4)) (const? 32 1) { «nsw» := true, «nuw» := false }) (const? 32 (-4))

theorem carry_add_succ (x : Bool → BitStream) (n : ℕ) :
    add.carry x (n+1) =
      fun _ => (BitStream.addAux (x true) (x false) n).2

theorem lor_lor_left2_thm.extracted_1._1 : ∀ (x x_1 : BitVec 1), ¬x_1 = 1#1 → x = 1#1 → 1#1 = x

theorem select_constants_and_icmp_ne0_zero_tval_thm.extracted_1._4 : ∀ (x x_1 : BitVec 1),
  ¬x_1 = 1#1 → ¬x = 1#1 → ofBool (12#8 &&& 12#8 != 0#8) = x ^^^ 1#1

theorem test_thm.extracted_1._1_1_1 : ∀ (x x_1 : BitVec 16),
  True ∧ (signExtend 32 x_1).saddOverflow (signExtend 32 x) = true → False

theorem e_604 :
     - 1 *  ~~~y - 1 * y + 3 * (x ^^^ y) - 7 *  ~~~(x &&& y) - 2 * x - 1 *  ~~~(x ^^^ y) + 1 * (x ||| y) - 1 * (x |||  ~~~y) + 6 *  ~~~(x ||| y) + 3 * (x &&&  ~~~y) =  - 4 *  ~~~(x &&&  ~~~x)

theorem test5_proof : test5_before ⊑ test5_after

theorem e_1541 :
     - 7 * (a ||| ( ~~~b &&& c)) - 2 * (b ^^^  ~~~( ~~~a &&& ( ~~~b ||| c))) + 5 * (b |||  ~~~(a ||| c)) - 2 * (a &&& (b ||| c)) - 6 * (b ^^^ c) + 1 * (a ||| (b ||| c)) - 5 *  ~~~(a ||| (b ||| c)) + 8 *  ~~~( ~~~a ||| (b ||| c)) + 9 *  ~~~( ~~~a ||| ( ~~~b ||| c)) + 12 * ( ~~~a &&& ( ~~~b &&& c)) - 4 * ( ~~~a &&& (b &&& c)) + 3 * (a &&& (b &&& c)) =  - 16 * (a &&& ( ~~~b &&& c))

theorem sel_false_val_is_a_masked_ashr_of_true_val1_proof : sel_false_val_is_a_masked_ashr_of_true_val1_before ⊑ sel_false_val_is_a_masked_ashr_of_true_val1_after

theorem not_logicalAnd_not_op1_proof : not_logicalAnd_not_op1_before ⊑ not_logicalAnd_not_op1_after

theorem test_implied_true_proof : test_implied_true_before ⊑ test_implied_true_after

theorem t1_ult_slt_0_thm.extracted_1._7 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (x_1 <ᵤ 65536#32) = 1#1 → ¬ofBool (x_1 <ₛ 0#32) = 1#1 → ¬ofBool (65535#32 <ₛ x_1) = 1#1 → x = x_1

theorem test_thm (e : IntW 64) :
  LLVM.srem (trunc 32 (LLVM.or e (const? 64 4294967294))) (const? 32 (-1)) ⊑ const? 32 0

theorem t3_ult_sgt_neg1_thm.extracted_1._3 : ∀ (x x_1 : BitVec 32),
  ofBool (x_1 <ᵤ 65536#32) = 1#1 → ¬ofBool (65535#32 <ₛ x_1) = 1#1 → ofBool (x_1 <ₛ 0#32) = 1#1 → False

@[simp] theorem pure_inf_eq      : min pure e = pure

theorem test8_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x != 0#32) &&& ofBool (x <ᵤ 14#32) = ofBool (x + -1#32 <ᵤ 13#32)

theorem sge_and_max_commute_logical_proof : sge_and_max_commute_logical_before ⊑ sge_and_max_commute_logical_after

theorem e_482 :
    4 * (x |||  ~~~y) + 2 *  ~~~(x ^^^ y) + 11 *  ~~~y - 11 * x - 1 *  ~~~x - 15 *  ~~~(x ||| y) + 2 *  ~~~(x |||  ~~~y) - 3 * (x &&&  ~~~y) + 5 * (x &&& y) = 1 *  ~~~(x &&& y)

theorem t22_sign_check_thm.extracted_1._3 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (x_1 <ₛ 0#32) = 1#1 → ¬ofBool (-1#32 <ₛ x_1) = 1#1 → x = -1#32

theorem slt_zero_slt_i1_fail_thm (e : IntW 32) (e_1 : IntW 1) :
  icmp IntPred.slt (zext 32 e_1) (lshr e (const? 32 31)) ⊑
    LLVM.and (icmp IntPred.slt e (const? 32 0)) (LLVM.xor e_1 (const? 1 1))

theorem srem2_ashr_mask_thm (e : IntW 32) :
  LLVM.and (ashr (LLVM.srem e (const? 32 2)) (const? 32 31)) (const? 32 2) ⊑
    LLVM.and (LLVM.srem e (const? 32 2)) (const? 32 2)

theorem test_or3_logical_thm.extracted_1._2 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (x_1 &&& 2147483647#32 ≤ₛ x) = 1#1 → ofBool (x <ₛ 0#32) = ofBool (x_1 &&& 2147483647#32 ≤ᵤ x)

theorem add_eq_addAux (x y : BitStream) : (x + y) i = (addAux x y i).1

theorem neg_of_add_with_constant_thm.extracted_1._1 : ∀ (x : BitVec 8), 0#8 - (x + 42#8) = BitVec.ofInt 8 (-42) - x

theorem test15c_proof : test15c_before ⊑ test15c_after

theorem not_and_and_or_no_or_thm (e e_1 e_2 : IntW 32) :
  LLVM.or (LLVM.and (LLVM.and (LLVM.xor e_2 (const? 32 (-1))) e_1) e) (LLVM.xor (LLVM.or e_1 e_2) (const? 32 (-1))) ⊑
    LLVM.and (LLVM.or e (LLVM.xor e_1 (const? 32 (-1)))) (LLVM.xor e_2 (const? 32 (-1)))

theorem reassoc_x2_add_nuw_proof : reassoc_x2_add_nuw_before ⊑ reassoc_x2_add_nuw_after

theorem lt_signed_to_large_unsigned_thm (e : IntW 8) :
  icmp IntPred.ult (sext 32 e) (const? 32 1024) ⊑ icmp IntPred.sgt e (const? 8 (-1))

theorem lt_unsigned_to_small_signed_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ofBool (zeroExtend 32 x <ₛ 17#32) = ofBool (x <ᵤ 17#8)

theorem e_1682 :
     - 7 * (b &&&  ~~~(a &&&  ~~~c)) + 1 * ( ~~~(a ^^^ b) &&&  ~~~(a ^^^ c)) + 1 * (a |||  ~~~b) - 2 * (b ^^^ ( ~~~a &&& (b ||| c))) - 1 * (b ^^^  ~~~( ~~~a &&& (b ^^^ c))) - 1 * (c ^^^ (a ||| ( ~~~b &&& c))) - 7 * (b ^^^ ( ~~~a &&& ( ~~~b ||| c))) + 2 * (b &&& (a |||  ~~~c)) + 1 * ((a &&& b) ^^^ (a ^^^ (b &&& c))) - 3 * ( ~~~(a ^^^ b) &&& (a ^^^ c)) + 4 * (a ||| ( ~~~b &&& c)) - 2 * (b ^^^  ~~~(a ||| c)) - 5 * (c ^^^ ( ~~~a &&& (b ||| c))) - 11 *  ~~~( ~~~a &&& (b ^^^ c)) + 1 * (a ||| c) - 2 * ((a &&& b) ^^^ (b ||| c)) - 7 * (c ^^^  ~~~(a |||  ~~~b)) + 7 * ((b &&&  ~~~c) |||  ~~~(a ||| ( ~~~b &&& c))) + 11 * (c ^^^ (a &&& ( ~~~b ||| c))) + 7 * ( ~~~(a &&& b) &&& (b ^^^ c)) + 12 *  ~~~(a ||| (b ||| c)) + 13 *  ~~~(a ||| ( ~~~b ||| c)) - 2 *  ~~~( ~~~a ||| (b ||| c)) + 14 *  ~~~( ~~~a ||| ( ~~~b ||| c)) + 3 * ( ~~~a &&& (b &&& c)) + 12 * (a &&& ( ~~~b &&& c)) + 31 * (a &&& (b &&& c)) = 3 * (c ^^^ (a ||| (b &&& c)))

theorem test2_proof : test2_before ⊑ test2_after

theorem exact_lshr_eq_both_equal_proof : exact_lshr_eq_both_equal_before ⊑ exact_lshr_eq_both_equal_after

theorem e_499 :
    2 * (x ||| y) - 1 *  ~~~y + 1 * y - 2 * x - 5 * (x |||  ~~~y) + 6 *  ~~~(x ||| y) - 2 *  ~~~(x |||  ~~~y) + 7 * (x &&&  ~~~y) + 4 * (x &&& y) = 1 * (x ^^^ y)

theorem src_x_and_nmask_slt_proof : src_x_and_nmask_slt_before ⊑ src_x_and_nmask_slt_after

theorem ashrslt_03_03_exact_proof : ashrslt_03_03_exact_before ⊑ ashrslt_03_03_exact_after

theorem e_1076 :
     - 6 * t + 2 * (z ||| t) - 6 *  ~~~(z &&&  ~~~t) - 1 *  ~~~(z ||| t) + 10 *  ~~~(z |||  ~~~t) - 9 * (z &&&  ~~~t) + 3 * (z &&& t) =  - 7 * (z |||  ~~~t)

theorem e_1836 :
    2 * ((a &&& b) ^^^  ~~~(a ^^^ (b &&& c))) + 2 * ((b &&& c) ^^^  ~~~(a &&& (b ^^^ c))) + 1 * (a &&&  ~~~b) + 2 * ((a ||| b) &&& (a ^^^ (b ^^^ c))) + 5 * ( ~~~(a &&& b) &&&  ~~~(a ^^^ (b ^^^ c))) + 11 * ((a |||  ~~~b) &&& (b ^^^ c)) - 6 * (c ^^^  ~~~( ~~~a ||| ( ~~~b &&& c))) + 4 * ((a &&& b) |||  ~~~(a ^^^ (b ^^^ c))) + 1 * ( ~~~a &&& (b ||| c)) - 5 *  ~~~(a ^^^ c) + 4 * ( ~~~(a ||| b) ||| (b ^^^ c)) - 1 * (a ||| (b &&& c)) + 3 *  ~~~(a &&& ( ~~~b &&& c)) + 7 * (b ^^^ (a ||| (b ||| c))) - 1 * (c ^^^  ~~~(a ||| b)) - 1 * (c ^^^ ( ~~~a ||| ( ~~~b &&& c))) - 2 * ((a &&&  ~~~b) |||  ~~~(a ^^^ (b ^^^ c))) + 1 * (c ^^^ ( ~~~a ||| ( ~~~b ||| c))) + 11 *  ~~~(a ||| (b &&& c)) + 1 * (c ^^^ (a &&& ( ~~~b ||| c))) + 4 * (c |||  ~~~(a ||| b)) - 6 * ((a |||  ~~~b) &&&  ~~~(b ^^^ c)) - 1 * (a &&& c) - 6 * ((a &&& c) ^^^  ~~~(a ^^^ (b &&& c))) + 2 * (c ^^^ (a ||| ( ~~~b &&& c))) + 11 * (b ^^^  ~~~(a &&& (b ^^^ c))) - 2 * ((a ^^^ b) &&& (a ^^^ c)) - 1 * (c ^^^  ~~~( ~~~a &&& ( ~~~b &&& c))) + 11 * ( ~~~b |||  ~~~(a ^^^ c)) + 11 * ( ~~~a ||| (b ^^^ c)) + 1 * (b ||| c) + 1 * (b &&& (a ^^^ c)) + 1 * ((a &&&  ~~~b) |||  ~~~(b ^^^ c)) - 2 * (b ^^^ (a ||| (b ^^^ c))) + 3 * (a ^^^ (b ||| c)) - 2 * (b ^^^ ( ~~~a &&& ( ~~~b ||| c))) - 37 *  ~~~(a ||| ( ~~~b ||| c)) - 29 *  ~~~( ~~~a ||| (b ||| c)) - 38 *  ~~~( ~~~a ||| ( ~~~b ||| c)) - 70 * ( ~~~a &&& ( ~~~b &&& c)) - 23 * ( ~~~a &&& (b &&& c)) - 36 * (a &&& ( ~~~b &&& c)) - 9 * (a &&& (b &&& c)) = 50 *  ~~~(a ||| (b ||| c)) - 4 * (b ^^^  ~~~(a &&& ( ~~~b &&& c)))

theorem andcond_proof : andcond_before ⊑ andcond_after

theorem e_2384 :
    2 * ( ~~~(d ||| e) |||  ~~~(e ^^^ f)) - 6 *  ~~~(d ^^^ (e ^^^ f)) - 5 * (e ^^^ (d &&& f)) - 1 *  ~~~(e |||  ~~~f) - 3 * (f ^^^  ~~~(d ||| (e &&& f))) - 6 * ((d ||| e) &&& (d ^^^ (e ^^^ f))) + 2 * (e |||  ~~~f) - 6 * (e ||| (d &&&  ~~~f)) + 1 * ((e &&& f) ||| ( ~~~d &&& (e ||| f))) + 4 *  ~~~(d &&&  ~~~d) + 11 * (f ^^^ (d &&& (e ||| f))) + 2 * ( ~~~d ||| ( ~~~e ||| f)) - 5 * (d ||| (e ||| f)) + 5 * ((d &&&  ~~~e) |||  ~~~(e ^^^ f)) - 7 * (f ^^^ (d ||| ( ~~~e ||| f))) + 2 * (d &&& (e ||| f)) - 11 *  ~~~e - 5 * (e ^^^  ~~~( ~~~d ||| ( ~~~e &&& f))) + 5 *  ~~~(e &&& f) + 1 * ((d &&&  ~~~e) |||  ~~~(d ^^^ (e ^^^ f))) + 3 * ((e &&&  ~~~f) |||  ~~~( ~~~d ||| ( ~~~e &&& f))) + 5 * ( ~~~e &&&  ~~~(d ^^^ f)) - 3 *  ~~~( ~~~d ||| (e &&& f)) - 1 * (f ^^^ ( ~~~d ||| ( ~~~e &&& f))) - 2 * (f ^^^ (d |||  ~~~e)) + 2 * (e ^^^ ( ~~~d ||| ( ~~~e &&& f))) - 2 * ( ~~~f |||  ~~~(d ^^^ e)) + 1 * ( ~~~(d ^^^ e) &&& (d ^^^ f)) - 1 * (e ^^^  ~~~( ~~~d &&& (e ^^^ f))) - 1 * (e &&&  ~~~(d &&&  ~~~f)) - 2 * ((d &&& e) ^^^  ~~~(d ^^^ ( ~~~e ||| f))) + 1 * ((d &&& f) |||  ~~~(e ||| f)) - 1 * ((d &&& f) ^^^  ~~~(e &&&  ~~~f)) + 7 * (e ^^^  ~~~(d &&& f)) + 2 * ((d ||| e) &&&  ~~~(d ^^^ (e ^^^ f))) + 11 * (e ^^^ f) + 3 * (f ^^^ ( ~~~d ||| (e &&& f))) + 3 * ((d &&& e) ||| (d ^^^ (e ^^^ f))) + 2 * (f &&& (d ||| e)) - 2 * (e ^^^ (d &&& (e ||| f))) - 1 * (e ^^^ ( ~~~d &&& (e ||| f))) - 3 * (e ^^^ ( ~~~d ||| (e ||| f))) - 5 * ( ~~~(d ^^^ e) |||  ~~~(d ^^^ f)) - 6 * ( ~~~d ||| ( ~~~e &&& f)) + 1 * (e &&& (d |||  ~~~f)) - 1 * ( ~~~e ||| (d ^^^ f)) - 1 * ((d |||  ~~~e) &&& (e ^^^ f)) + 3 * ( ~~~(d ||| e) ||| (e ^^^ f)) - 2 *  ~~~(d &&& e) - 11 * (e ^^^  ~~~( ~~~d &&& (e &&& f))) + 1 *  ~~~(d ||| ( ~~~e &&& f)) + 4 * (f ^^^ (d ||| (e &&& f))) + 2 * ( ~~~(d |||  ~~~e) |||  ~~~(d ^^^ (e ^^^ f))) + 1 * ((d &&&  ~~~e) ||| (e ^^^ f)) - 6 * (e ^^^ (d ||| (e ^^^ f))) + 2 * ((d &&& e) ^^^  ~~~(d ^^^ (e &&& f))) - 1 *  ~~~(d &&& (e ^^^ f)) - 1 * ( ~~~d &&& (e ||| f)) + 7 * ((e &&&  ~~~f) |||  ~~~(d ||| ( ~~~e &&& f))) + 4 * (e ||| (d &&& f)) + 1 *  ~~~(d &&& (e &&& f)) - 1 * (e &&&  ~~~(d ^^^ f)) + 9 *  ~~~(d ||| (e ||| f)) - 1 *  ~~~(d ||| ( ~~~e ||| f)) + 32 *  ~~~( ~~~d ||| (e ||| f)) - 26 *  ~~~( ~~~d ||| ( ~~~e ||| f)) - 2 * ( ~~~d &&& ( ~~~e &&& f)) + 20 * ( ~~~d &&& (e &&& f)) + 20 * (d &&& ( ~~~e &&& f)) - 9 * (d &&& (e &&& f)) = 1 * ( ~~~(d &&& e) &&&  ~~~(e ^^^ f)) + 2 * (f &&& (d ^^^ e))

theorem gt_unsigned_to_large_signed_proof : gt_unsigned_to_large_signed_before ⊑ gt_unsigned_to_large_signed_after

theorem fold_icmp_shl_nuw_c1_proof : fold_icmp_shl_nuw_c1_before ⊑ fold_icmp_shl_nuw_c1_after

@[simp]
theorem envBitstream_set_eq_of_eq₂   {x : arity → BitStream}
    {n : Nat} {v : arity → Bool} {a : arity} :
  (envBitstream_set x n v) a n = v a

theorem logical_or_logical_or_icmps_comm3_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ¬x ≥ ↑8 →
    ofBool (x_1 &&& 1#8 <<< x == 0#8) = 1#1 ∨ ofBool (x_1 &&& 1#8 == 0#8) = 1#1 →
      True ∧ 1#8 <<< x >>> x ≠ 1#8 ∨ x ≥ ↑8 ∨ True ∧ 1#8 <<< x >>> x ≠ 1#8 ∨ x ≥ ↑8 → False

theorem select_icmp_ne_0_and_8_or_1073741824_thm.extracted_1._2 : ∀ (x : BitVec 32) (x_1 : BitVec 8),
  ¬ofBool (0#8 != x_1 &&& 8#8) = 1#1 → ¬ofBool (x_1 &&& 8#8 == 0#8) = 1#1 → x ||

theorem or_logic_or_logic_and_1_thm.extracted_1._2 : ∀ (x x_1 : BitVec 1),
  ¬x_1 ||

theorem main7c_logical_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (x_1 == x_1 &&& x) = 1#1 → ofBool (x_1 != x_1 &&& x) = 1#1 → 0#1 = 1#1 → 0#32 = zeroExtend 32 1#1

theorem test8_proof : test8_before ⊑ test8_after

theorem positive_samevar_proof : positive_samevar_before ⊑ positive_samevar_after

theorem test_ashr_exact__exact_is_unsafe_thm.extracted_1._4 : ∀ (x : BitVec 64) (x_1 : BitVec 32),
  ¬ofBool (x_1 &&& BitVec.ofInt 32 (-2147483585) == 0#32) = 1#1 →
    ¬(True ∧ (x_1 &&& BitVec.ofInt 32 (-2147483585)) >>> 2#32 <<< 2#32 ≠ x_1 &&& BitVec.ofInt 32 (-2147483585) ∨
          2#32 ≥ ↑32 ∨ zeroExtend 64 ((x_1 &&& BitVec.ofInt 32 (-2147483585)).sshiftRight' 2#32) ≥ ↑64) →
      ¬(2#32 ≥ ↑32 ∨
            True ∧ (x_1.sshiftRight' 2#32 &&& BitVec.ofInt 32 (-536870897)).msb = true ∨
              zeroExtend 64 (x_1.sshiftRight' 2#32 &&& BitVec.ofInt 32 (-536870897)) ≥ ↑64) →
        x.sshiftRight' (zeroExtend 64 ((x_1 &&& BitVec.ofInt 32 (-2147483585)).sshiftRight' 2#32)) =
          x.sshiftRight' (zeroExtend 64 (x_1.sshiftRight' 2#32 &&& BitVec.ofInt 32 (-536870897)))

theorem test70_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8), ofBool (x_1 <ₛ 0#8) = 1#1 → 6#8 ≥ ↑8 → False

theorem andn_or_cmp_2_partial_logical_thm (e : IntW 1) (e_1 e_2 : IntW 16) :
  select (LLVM.or (icmp IntPred.sge e_2 e_1) e) (icmp IntPred.slt e_2 e_1) (const? 1 0) ⊑
    LLVM.and e (icmp IntPred.slt e_2 e_1)

theorem alive_AndOrXor_2247__A__B__A__B  (w : Nat)   : alive_AndOrXor_2247__A__B__A__B_src w  ⊑ alive_AndOrXor_2247__A__B__A__B_tgt w

theorem test3_proof : test3_before ⊑ test3_after

lemma carry_compose [FinEnum arity] [DecidableEq arity] [Hashable arity]
    (new_arity : Type)
    (q_arity : arity → Type)
    (vars : ∀ (a : arity), q_arity a → new_arity)
    (q : ∀ (a : arity), FSM (q_arity a))
    (x : new_arity → BitStream) : ∀ (n : ℕ),
    (p.compose new_arity q_arity vars q).carry x n =
      let z := p.carry (λ a => (q a).eval (fun i => x (vars _ i))) n
      Sum.elim z (fun a => (q a.1).carry (fun t => x (vars _ t)) n a.2)

theorem lshrugt_02_06_proof : lshrugt_02_06_before ⊑ lshrugt_02_06_after

theorem t10_shift_by_one_thm.extracted_1._1 : ∀ (x : BitVec 64) (x_1 x_2 : BitVec 32),
  ¬(64#32 - x_1 ≥ ↑32 ∨ zeroExtend 64 (x_1 + BitVec.ofInt 32 (-63)) ≥ ↑64) →
    64#32 - x_1 ≥ ↑32 ∨
        True ∧ (x_1 + BitVec.ofInt 32 (-63)).msb = true ∨ zeroExtend 64 (x_1 + BitVec.ofInt 32 (-63)) ≥ ↑64 →
      False

theorem bv_AndOrXor_2453 :
    ∀ (e e_1 : LLVM.IntW w),
      LLVM.xor (LLVM.icmp LLVM.IntPred.slt e_1 e) (LLVM.const? 1 (-1)) ⊑ LLVM.icmp LLVM.IntPred.sge e_1 e

theorem main4f_like_logical_thm.extracted_1._12 : ∀ (x x_1 x_2 : BitVec 32),
  ¬ofBool (x_2 &&& x_1 != x_1) = 1#1 →
    ¬ofBool (x_2 &&& x_1 == x_1) = 1#1 → ¬ofBool (x_2 &&& x != x) = 1#1 → 1#32 = zeroExtend 32 0#1

theorem negative_trunc_not_arg_logical_thm.extracted_1._3 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (-1#8 <ₛ truncate 8 x_1) = 1#1 →
    ofBool (x_1 &&& 128#32 == 0#32) = 1#1 → 0#1 = ofBool (x + 128#32 <ᵤ 256#32)

theorem lshr_or_proof : lshr_or_before ⊑ lshr_or_after

theorem or_not_xor_common_op_commute2_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 8),
  x_2 ^^^ x_1 ||

theorem src5_thm (e e_1 : IntW 32) :
  add (LLVM.xor (LLVM.or e_1 e) (const? 32 (-1))) (LLVM.and e_1 e) ⊑ LLVM.xor (LLVM.xor e_1 e) (const? 32 (-1))

theorem ashr_lshr_no_ashr_proof : ashr_lshr_no_ashr_before ⊑ ashr_lshr_no_ashr_after

theorem ashrsgt_02_12_exact_proof : ashrsgt_02_12_exact_before ⊑ ashrsgt_02_12_exact_after

theorem ashrsgt_02_01_thm (e : IntW 4) : icmp IntPred.sgt (ashr e (const? 4 2)) (const? 4 1) ⊑ const? 1 0

theorem lshr_exact_ne_0_thm (e e_1 : IntW 32) :
  icmp IntPred.ne (lshr e_1 e { «exact» := true }) (const? 32 0) ⊑ icmp IntPred.ne e_1 (const? 32 0)

theorem trunc_sel_equal_sext_thm.extracted_1._4 : ∀ (x : BitVec 32) (x_1 : BitVec 1),
  ¬x_1 = 1#1 → signExtend 32 42#16 = 42#32

theorem lshr_and_thm.extracted_1._2 : ∀ (x : BitVec 8),
  ¬(x ≥ ↑8 ∨ x + 1#8 ≥ ↑8) → ¬x ≥ ↑8 → 48#8 >>> x &&& 64#8 >>> (x + 1#8) = 32#8 >>> x

theorem masked_icmps_mask_notallzeros_bmask_mixed_swapped_3_thm (e : IntW 32) :
  LLVM.and (icmp IntPred.eq (LLVM.and e (const? 32 7)) (const? 32 0))
      (icmp IntPred.ne (LLVM.and e (const? 32 15)) (const? 32 0)) ⊑
    icmp IntPred.eq (LLVM.and e (const? 32 15)) (const? 32 8)

theorem and_two_ranges_to_mask_and_range_different_sizes_proof : and_two_ranges_to_mask_and_range_different_sizes_before ⊑ and_two_ranges_to_mask_and_range_different_sizes_after

theorem test_sub_nuw__nuw_is_safe_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ofBool (x &&& 2147483647#32 == 1073741824#32) = 1#1 →
    ¬(True ∧ (BitVec.ofInt 32 (-2147483648)).usubOverflow (x &&& 2147483647#32) = true) →
      1073741824#32 = BitVec.ofInt 32 (-2147483648) - (x &&& 2147483647#32)

theorem sub_to_xor_and_commuted_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  (x_1 &&& x) - (x ||| x_1) = 0#32 - (x_1 ^^^ x)

theorem main5c_like_logical_proof : main5c_like_logical_before ⊑ main5c_like_logical_after

theorem positive_biggershl_thm.extracted_1._1 : ∀ (x : BitVec 8), ¬(3#8 ≥ ↑8 ∨ 6#8 ≥ ↑8) → 3#8 ≥ ↑8 → False

theorem e_1567 :
    7 * ( ~~~a ||| ( ~~~b &&& c)) - 1 * (c ^^^ (a &&& (b ||| c))) + 1 * ( ~~~a &&& ( ~~~b ||| c)) + 11 * (c ^^^ (a ||| (b ||| c))) + 11 * ((a &&&  ~~~b) ||| (a ^^^ (b ^^^ c))) + 2 * (c ^^^  ~~~(a &&& (b ||| c))) + 2 *  ~~~( ~~~a ||| ( ~~~b &&& c)) - 5 * ((a ^^^ b) ||| (a ^^^ c)) - 10 *  ~~~(a ||| (b ||| c)) - 26 *  ~~~(a ||| ( ~~~b ||| c)) - 21 *  ~~~( ~~~a ||| (b ||| c)) - 7 *  ~~~( ~~~a ||| ( ~~~b ||| c)) - 13 * ( ~~~a &&& ( ~~~b &&& c)) - 15 * (a &&& ( ~~~b &&& c)) - 20 * (a &&& (b &&& c)) =  - 5 * (b &&& c) + 7 * ( ~~~a &&& (b &&& c))

@[simp] theorem toBitVec_negOne : BitStream.toBitVec w BitStream.negOne = BitVec.allOnes w

theorem test_add_nuw_nsw__nuw_is_safe_proof : test_add_nuw_nsw__nuw_is_safe_before ⊑ test_add_nuw_nsw__nuw_is_safe_after

theorem select_2_thm (e e_1 e_2 : IntW 8) (e_3 e_4 : IntW 1) :
  LLVM.xor
      (select e_4 (select e_3 (LLVM.xor e_2 (const? 8 (-1))) (LLVM.xor e_1 (const? 8 123))) (LLVM.xor e (const? 8 45)))
      (const? 8 (-1)) ⊑
    select e_4 (select e_3 e_2 (LLVM.xor e_1 (const? 8 (-124)))) (LLVM.xor e (const? 8 (-46)))

theorem ashr_exact_add_negative_shift_negative_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬(True ∧ BitVec.ofInt 32 (-2) >>> (x + -1#32) <<< (x + -1#32) ≠ BitVec.ofInt 32 (-2) ∨ x + -1#32 ≥ ↑32) →
    True ∧ BitVec.ofInt 32 (-4) >>> x <<< x ≠ BitVec.ofInt 32 (-4) ∨ x ≥ ↑32 → False

@[simp]
lemma BitVec.cons_ugt_iff {w} {bv1 bv2 : BitVec w} :
    ((BitVec.cons b2 bv2).ult (BitVec.cons b1 bv1)) ↔ (if b1 = b2 then bv2.ult bv1 else b1)

theorem eq_umin2_thm (e e_1 : IntW 32) :
  icmp IntPred.eq (select (icmp IntPred.ult e_1 e) e_1 e) e ⊑ icmp IntPred.ule e e_1

theorem PR42691_2_proof : PR42691_2_before ⊑ PR42691_2_after

theorem sub_sel_op1_thm.extracted_1._2 : ∀ (x : BitVec 1),
  ¬x = 1#1 → ¬(True ∧ (42#32).ssubOverflow 41#32 = true) → 42#32 - 41#32 = zeroExtend 32 (x ^^^ 1#1)

theorem factorize4_proof : factorize4_before ⊑ factorize4_after

theorem eq_nsw_rem_zero_thm (e : IntW 8) :
  icmp IntPred.eq (mul e (const? 8 (-5)) { «nsw» := true, «nuw» := false }) (const? 8 20) ⊑
    icmp IntPred.eq e (const? 8 (-4))

theorem main7c_logical_thm.extracted_1._12 : ∀ (x x_1 x_2 : BitVec 32),
  ¬ofBool (x_2 == x_2 &&& x_1) = 1#1 →
    ¬ofBool (x_2 != x_2 &&& x_1) = 1#1 → ¬0#1 = 1#1 → 1#32 = zeroExtend 32 (ofBool (x != x &&& x_1))

theorem not_cond_proof : not_cond_before ⊑ not_cond_after

theorem t2_thm (e : IntW 1) (e_1 : IntW 8) (e_2 : IntW 1) :
  LLVM.xor (add (sext 8 e_2) e_1) (sext 8 e) ⊑ LLVM.xor (add e_1 (sext 8 e_2)) (sext 8 e)

theorem lshrugt_02_12_exact_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬(True ∧ x >>> 2#4 <<< 2#4 ≠ x ∨ 2#4 ≥ ↑4) → ofBool (BitVec.ofInt 4 (-4) <ᵤ x >>> 2#4) = 0#1

theorem signbit_splat_mask_thm.extracted_1._2 : ∀ (x : BitVec 16) (x_1 : BitVec 8),
  ¬7#8 ≥ ↑8 → ¬ofBool (x_1 <ₛ 0#8) = 1#1 → signExtend 16 (x_1.sshiftRight' 7#8) &&& x = 0#16

theorem mul_select_zext_thm.extracted_1._1 : ∀ (x : BitVec 1), ¬x = 1#1 → 1#64 * zeroExtend 64 x = 0#64

theorem test1_proof : test1_before ⊑ test1_after

theorem e_655 :
    11 *  ~~~y + 3 *  ~~~(x ^^^ y) - 3 *  ~~~x + 2 * (x ||| y) - 2 *  ~~~(x &&&  ~~~y) - 11 *  ~~~(x &&&  ~~~x) + 7 * y + 2 *  ~~~(x ||| y) - 2 * (x &&&  ~~~y) + 1 * (x &&& y) =  - 7 *  ~~~(x |||  ~~~y)

theorem masked_and_notA_slightly_optimized_logical_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬ofBool (8#32 ≤ᵤ x) = 1#1 → 0#1 = ofBool (x &&& BitVec.ofInt 32 (-40) != 0#32)

@[simp]
theorem delta_eq_carryWith_one (carryState : p.α → Bool) (x : arity → BitStream) :
    p.delta carryState x = p.carryWith carryState x 1

theorem eq_smax2_thm.extracted_1._2 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (x <ₛ x_1) = 1#1 → ofBool (x == x) = ofBool (x_1 ≤ₛ x)

theorem lshrult_01_09_proof : lshrult_01_09_before ⊑ lshrult_01_09_after

theorem shl_and_lshr_proof : shl_and_lshr_before ⊑ shl_and_lshr_after

theorem n8_proof : n8_before ⊑ n8_after

theorem lshr_eq_both_equal_thm (e : IntW 8) :
  icmp IntPred.eq (lshr (const? 8 127) e) (const? 8 127) ⊑ icmp IntPred.eq e (const? 8 0)

theorem lshrugt_02_06_exact_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬(True ∧ x >>> 2#4 <<< 2#4 ≠ x ∨ 2#4 ≥ ↑4) → ofBool (6#4 <ᵤ x >>> 2#4) = 0#1

theorem icmp_mul_nsw_sgt_proof : icmp_mul_nsw_sgt_before ⊑ icmp_mul_nsw_sgt_after

theorem e_2245 :
    2 *  ~~~(d &&&  ~~~d) - 1 * (f |||  ~~~(d ||| e)) + 4 * ((d &&& e) ^^^ (e |||  ~~~f)) - 6 * (e ^^^  ~~~(d &&& (e &&& f))) - 2 * (d ^^^ e) - 2 * ((d &&& e) ||| (e ^^^ f)) + 1 * (e ^^^  ~~~( ~~~d ||| ( ~~~e &&& f))) - 6 * ((d &&& f) ^^^  ~~~(e &&&  ~~~f)) + 5 * (d &&& f) - 3 * (f ^^^ (d ||| ( ~~~e ||| f))) + 1 * (f ^^^  ~~~( ~~~d &&& (e ||| f))) + 5 * (f ||| (d &&& e)) - 5 * (e ^^^  ~~~( ~~~d &&& ( ~~~e ||| f))) + 3 * (e ||| f) + 4 *  ~~~( ~~~d &&& ( ~~~e &&& f)) + 5 * (f ^^^  ~~~(d ||| e)) - 1 * ((e &&&  ~~~f) |||  ~~~( ~~~d ||| ( ~~~e &&& f))) + 7 * (e ^^^  ~~~(d ||| ( ~~~e &&& f))) + 7 *  ~~~(e ^^^ f) - 3 * (d &&& (e ^^^ f)) + 7 * (e &&& (d ||| f)) + 7 * (f &&&  ~~~(d &&& e)) + 11 * ((d |||  ~~~e) &&&  ~~~(d ^^^ (e ^^^ f))) - 6 * (e ^^^  ~~~(d ||| (e &&& f))) + 1 * ((d ||| e) &&& (e ^^^ f)) - 1 * (e |||  ~~~(d ||| f)) - 1 *  ~~~e + 1 * ( ~~~(d &&&  ~~~e) &&& (e ^^^ f)) + 5 * ( ~~~d ||| ( ~~~e ||| f)) + 1 * ((d &&& e) ^^^ (e ||| f)) - 1 * ((d &&&  ~~~e) ||| (d ^^^ (e ^^^ f))) - 2 *  ~~~(d &&& f) + 2 * (f ^^^  ~~~(d &&& e)) - 3 *  ~~~( ~~~d &&& (e ^^^ f)) + 5 * ((d &&& f) ^^^ (e ||| f)) - 1 * (e ^^^  ~~~(d ||| (e ^^^ f))) - 1 * ((d &&& f) ^^^  ~~~(d ^^^ (e &&& f))) - 2 * ( ~~~d ||| (e &&& f)) + 2 * ((d ||| e) &&& (d ^^^ (e ^^^ f))) + 1 * ((d ||| e) &&&  ~~~(d ^^^ (e ^^^ f))) - 1 * (d &&&  ~~~e) + 11 * ( ~~~d &&& (e ||| f)) + 4 * ((d ^^^ e) ||| (d ^^^ f)) + 11 * ( ~~~(d ||| e) ||| (d ^^^ (e ^^^ f))) + 3 * (f &&&  ~~~(d ^^^ e)) - 1 * (e ^^^  ~~~(d &&& (e ||| f))) - 6 * ((d &&& e) ^^^  ~~~(d ^^^ (e &&& f))) - 1 * ( ~~~f |||  ~~~(d ^^^ e)) + 11 * ( ~~~f &&& (d ^^^ e)) - 23 *  ~~~(d ||| (e ||| f)) - 53 *  ~~~(d ||| ( ~~~e ||| f)) - 19 *  ~~~( ~~~d ||| (e ||| f)) - 27 *  ~~~( ~~~d ||| ( ~~~e ||| f)) - 23 * ( ~~~d &&& ( ~~~e &&& f)) - 43 * ( ~~~d &&& (e &&& f)) - 33 * (d &&& ( ~~~e &&& f)) - 45 * (d &&& (e &&& f)) =  - 5 * (f ^^^  ~~~(d &&& ( ~~~e ||| f))) + 2 * ((d ||| e) &&&  ~~~(e ^^^ f))

theorem ripple_nsw6_proof : ripple_nsw6_before ⊑ ripple_nsw6_after

theorem icmp_slt_0_or_icmp_eq_100_i32_fail_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬31#32 ≥ ↑32 →
    x >>> 31#32 ||

theorem select_icmp_x_and_2147483648_ne_0_or_2147483648_thm (e : IntW 32) :
  select (icmp IntPred.eq (LLVM.and e (const? 32 (-2147483648))) (const? 32 0))
      (LLVM.or e (const? 32 (-2147483648))) e ⊑
    LLVM.or e (const? 32 (-2147483648))

theorem ashrslt_01_04_exact_thm (e : IntW 4) :
  icmp IntPred.slt (ashr e (const? 4 1) { «exact» := true }) (const? 4 4) ⊑ const? 1 1

theorem alive_AddSub_1176 : alive_AddSub_1176_src ⊑ alive_AddSub_1176_tgt

theorem unsigned_sign_bit_extract_proof : unsigned_sign_bit_extract_before ⊑ unsigned_sign_bit_extract_after

theorem splat_mul_unknown_lz_proof : splat_mul_unknown_lz_before ⊑ splat_mul_unknown_lz_after

theorem icmp_ne_sext_eq_zero_thm (e : IntW 32) :
  icmp IntPred.ne (sext 32 (icmp IntPred.eq e (const? 32 0))) e ⊑ const? 1 1

theorem masked_icmps_mask_notallzeros_bmask_mixed_negated_6_logical_proof : masked_icmps_mask_notallzeros_bmask_mixed_negated_6_logical_before ⊑ masked_icmps_mask_notallzeros_bmask_mixed_negated_6_logical_after

theorem e_1855 :
     - 7 * ( ~~~b &&& (a ^^^ c)) - 1 * (b ^^^  ~~~(a &&& ( ~~~b &&& c))) + 4 *  ~~~( ~~~a ||| (b &&& c)) + 2 * (c ^^^  ~~~(a ||| b)) - 3 * ((a |||  ~~~b) &&& (b ^^^ c)) - 5 *  ~~~(a ||| ( ~~~b &&& c)) + 2 * ( ~~~c ||| (a ^^^ b)) + 2 * (c ^^^ (a ||| ( ~~~b &&& c))) - 2 * (b ^^^  ~~~( ~~~a ||| (b ^^^ c))) + 2 * (c ^^^  ~~~(a |||  ~~~b)) - 6 * ( ~~~(a ^^^ b) |||  ~~~(a ^^^ c)) + 1 * (c ^^^  ~~~( ~~~a &&& (b &&& c))) + 7 *  ~~~(a &&& (b &&& c)) + 7 * (b ^^^ (a &&& (b ||| c))) + 4 *  ~~~(a &&& b) + 1 *  ~~~(a &&& c) + 7 *  ~~~( ~~~a ||| (b ^^^ c)) - 11 * (b ^^^  ~~~( ~~~a &&& (b ||| c))) - 2 * ((b &&& c) ^^^  ~~~( ~~~a &&& (b ^^^ c))) - 2 * (b ^^^  ~~~(a &&& c)) + 1 * ((a &&& b) ^^^ (a ^^^ ( ~~~b ||| c))) - 3 * (b ^^^  ~~~(a &&&  ~~~c)) + 2 * (b ^^^  ~~~(a &&& (b ||| c))) - 5 * (a ||| ( ~~~b ||| c)) + 1 *  ~~~(a ||| b) - 1 *  ~~~b - 11 * (c &&& (a ^^^ b)) - 2 * (c ||| (a ^^^ b)) + 1 *  ~~~( ~~~a &&& (b ^^^ c)) - 1 * ((a &&&  ~~~b) ||| (b ^^^ c)) + 5 * (b ^^^ (a &&& c)) + 5 * ((a &&& b) ||| (a ^^^ (b ^^^ c))) + 5 * (c ^^^ (a ||| ( ~~~b ||| c))) + 3 * (b ^^^ ( ~~~a &&& (b ||| c))) + 3 * (c ^^^  ~~~( ~~~a ||| (b &&& c))) - 1 * (b ^^^ ( ~~~a ||| ( ~~~b ||| c))) + 1 * ((b &&& c) ||| (a &&& (b ||| c))) - 2 *  ~~~(a |||  ~~~c) + 21 *  ~~~(a ||| (b ||| c)) + 4 *  ~~~(a ||| ( ~~~b ||| c)) - 9 *  ~~~( ~~~a ||| (b ||| c)) - 19 *  ~~~( ~~~a ||| ( ~~~b ||| c)) + 16 * ( ~~~a &&& ( ~~~b &&& c)) + 1 * ( ~~~a &&& (b &&& c)) + 22 * (a &&& ( ~~~b &&& c)) = 1 * (a &&& (b &&& c)) + 11 * (c ^^^  ~~~(a ||| ( ~~~b &&& c)))

theorem negative4_logical_thm.extracted_1._2 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (x_1 != x &&& 2147483647#32) = 1#1 → 0#1 = ofBool (x_1 != x &&& 2147483647#32) &&& ofBool (-1#32 <ₛ x_1)

theorem test93_thm (e : IntW 32) : trunc 32 (lshr (sext 96 e) (const? 96 64)) ⊑ ashr e (const? 32 31)

theorem or_simplify_uge_proof : or_simplify_uge_before ⊑ or_simplify_uge_after

theorem ofInt_toInt_eq_signExtend {w w' : Nat} {x : BitVec w} :
    BitVec.ofInt w' x.toInt = x.signExtend w'

theorem neg_not_signbit1_thm (e : IntW 8) :
  sub (const? 32 1) (zext 32 (lshr e (const? 8 7))) ⊑ zext 32 (icmp IntPred.sgt e (const? 8 (-1)))

theorem e_1753 :
     - 7 * ((a &&& b) ^^^  ~~~(a ^^^ ( ~~~b ||| c))) - 1 * ( ~~~(a |||  ~~~b) ||| (b ^^^ c)) - 6 * ( ~~~c ||| (a ^^^ b)) - 1 * (b ^^^  ~~~(a &&&  ~~~c)) + 2 * (b ^^^  ~~~(a &&& c)) + 11 * (b ^^^ c) - 1 * ((a &&&  ~~~b) |||  ~~~(b ^^^ c)) + 7 * (c ^^^  ~~~(a &&& (b &&& c))) - 11 * ( ~~~(a &&&  ~~~b) &&&  ~~~(b ^^^ c)) + 3 * (a ^^^ c) - 7 * ( ~~~(a |||  ~~~b) ||| (a ^^^ (b ^^^ c))) - 6 * ((a &&& b) ^^^ (b |||  ~~~c)) + 1 *  ~~~(a &&& ( ~~~b ||| c)) + 1 * (c &&& (a ||| b)) - 5 * ((a |||  ~~~b) &&& (b ^^^ c)) - 2 * ( ~~~c |||  ~~~(a ^^^ b)) - 3 *  ~~~(b |||  ~~~c) + 7 * (a &&& b) + 1 * ( ~~~b |||  ~~~(a ^^^ c)) - 2 * (c ^^^  ~~~(a &&& ( ~~~b &&& c))) - 6 * (b ^^^  ~~~(a &&& ( ~~~b ||| c))) - 2 * ( ~~~a ||| ( ~~~b ||| c)) + 1 * a - 2 * (a ^^^ (b ^^^ c)) + 1 * ((a &&& c) ^^^  ~~~(b &&&  ~~~c)) - 7 * ((a &&& b) |||  ~~~(b |||  ~~~c)) + 7 * ( ~~~a &&& ( ~~~b ||| c)) + 18 *  ~~~(a ||| (b ||| c)) + 15 *  ~~~(a ||| ( ~~~b ||| c)) + 20 *  ~~~( ~~~a ||| (b ||| c)) + 10 * ( ~~~a &&& ( ~~~b &&& c)) + 21 * ( ~~~a &&& (b &&& c)) + 21 * (a &&& ( ~~~b &&& c)) + 19 * (a &&& (b &&& c)) =  - 1 *  ~~~( ~~~a ||| ( ~~~b ||| c))

theorem n9_proof : n9_before ⊑ n9_after

theorem sext_diff_i1_xor_sub_1_thm.extracted_1._1 : ∀ (x x_1 : BitVec 1),
  True ∧ (zeroExtend 64 x).saddOverflow (signExtend 64 x_1) = true → False

@[simp]
theorem Eqn.numVars_cons : Eqn.numVars (t :: es) = max t.numVars (Eqn.numVars es)

theorem PR30273_three_bools_proof : PR30273_three_bools_before ⊑ PR30273_three_bools_after

theorem uge_swap_or_max_logical_proof : uge_swap_or_max_logical_before ⊑ uge_swap_or_max_logical_after

theorem sge_swap_or_max_commute_proof : sge_swap_or_max_commute_before ⊑ sge_swap_or_max_commute_after

theorem udiv_i32_multiuse_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ¬zeroExtend 32 x = 0 →
    zeroExtend 32 x = 0 ∨
        True ∧ (zeroExtend 32 x_1).saddOverflow (zeroExtend 32 x) = true ∨
          True ∧ (zeroExtend 32 x_1).uaddOverflow (zeroExtend 32 x) = true ∨
            True ∧ (zeroExtend 32 x_1 / zeroExtend 32 x).smulOverflow (zeroExtend 32 x_1 + zeroExtend 32 x) = true ∨
              True ∧ (zeroExtend 32 x_1 / zeroExtend 32 x).umulOverflow (zeroExtend 32 x_1 + zeroExtend 32 x) = true →
      False

theorem trunc_shl_shl_var_thm.extracted_1._2 : ∀ (x x_1 : BitVec 64),
  ¬(x ≥ ↑64 ∨ 2#64 ≥ ↑64) →
    ¬(x ≥ ↑64 ∨ 2#32 ≥ ↑32) → truncate 32 (x_1 <<< x <<< 2#64) = truncate 32 (x_1 <<< x) <<< 2#32

theorem sgt_3_impliesF_eq_2_thm.extracted_1._3 : ∀ (x x_1 : BitVec 8),
  ofBool (3#8 <ₛ x_1) = 1#1 → ofBool (x_1 <ₛ 4#8) = 1#1 → ofBool (2#8 == x_1) = ofBool (x == x_1)

theorem sge_or_not_max_logical_proof : sge_or_not_max_logical_before ⊑ sge_or_not_max_logical_after

theorem icmp_eq_zext_eq_one_proof : icmp_eq_zext_eq_one_before ⊑ icmp_eq_zext_eq_one_after

theorem ule_or_min_commute_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ofBool (x_1 == 0#8) ||

theorem splat_mul_unknown_lz_proof : splat_mul_unknown_lz_before ⊑ splat_mul_unknown_lz_after

theorem and_ashr_not_commuted_thm.extracted_1._2 : ∀ (x x_1 x_2 : BitVec 8),
  ¬(x_1 ≥ ↑8 ∨ x_1 ≥ ↑8) →
    ¬x_1 ≥ ↑8 → (x_2.sshiftRight' x_1 ^^^ -1#8) &&& x.sshiftRight' x_1 = (x &&& (x_2 ^^^ -1#8)).sshiftRight' x_1

theorem n10_wrong_pred2_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8), ofBool (x_1 + x == x) = ofBool (x_1 == 0#8)

theorem alive_229 : alive_229_src ⊑ alive_229_tgt

theorem alive_InstCombineShift__476  (w : Nat)   : alive_InstCombineShift__476_src w  ⊑ alive_InstCombineShift__476_tgt w

theorem not_and_and_or_not_or_or_commute4_thm (e e_1 e_2 : IntW 32) :
  LLVM.or (LLVM.and (LLVM.sdiv (const? 32 42) e_2) (LLVM.and (LLVM.xor e_1 (const? 32 (-1))) e))
      (LLVM.xor (LLVM.or (LLVM.or e e_1) (LLVM.sdiv (const? 32 42) e_2)) (const? 32 (-1))) ⊑
    LLVM.xor (LLVM.or (LLVM.xor (LLVM.sdiv (const? 32 42) e_2) e) e_1) (const? 32 (-1))

theorem positive_sameconst_shlnsw_ashrexact_thm (e : IntW 8) :
  shl (ashr e (const? 8 3) { «exact» := true }) (const? 8 3) { «nsw» := true, «nuw» := false } ⊑ e

theorem select_xor_icmp_proof : select_xor_icmp_before ⊑ select_xor_icmp_after

theorem e_1539 :
    4 * ((a &&& b) ^^^ (b |||  ~~~c)) + 1 * ((a &&& c) ^^^  ~~~(a ^^^ (b &&& c))) + 3 *  ~~~( ~~~a &&& ( ~~~b ||| c)) - 5 * ( ~~~(a &&& b) &&& (b ^^^ c)) + 3 *  ~~~(a ^^^ c) - 8 *  ~~~(a ||| (b ||| c)) - 6 *  ~~~(a ||| ( ~~~b ||| c)) - 7 *  ~~~( ~~~a ||| (b ||| c)) - 10 *  ~~~( ~~~a ||| ( ~~~b ||| c)) - 3 * ( ~~~a &&& ( ~~~b &&& c)) - 2 * (a &&& ( ~~~b &&& c)) - 13 * (a &&& (b &&& c)) =  - 7 * (b ^^^ ( ~~~a &&& (b ^^^ c))) + 11 * ( ~~~a &&& (b &&& c))

theorem n2_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8), ¬x_1 ≥ ↑8 → True ∧ 1#8 <<< x_1 >>> x_1 ≠ 1#8 ∨ x_1 ≥ ↑8 → False

theorem slt_to_ugt_proof : slt_to_ugt_before ⊑ slt_to_ugt_after

theorem udiv_icmp1_proof : udiv_icmp1_before ⊑ udiv_icmp1_after

theorem neg_slt_0_proof : neg_slt_0_before ⊑ neg_slt_0_after

theorem ult_swap_or_not_max_thm (e e_1 : IntW 8) :
  LLVM.or (icmp IntPred.ugt e_1 e) (icmp IntPred.ne e (const? 8 (-1))) ⊑
    icmp IntPred.ne e (const? 8 (-1))

@[simp]
theorem fst_nextBit_fsmCarry'_eq_atLeastTwo {state : Unit → Bool} {env : Bool → Bool} :
    ((fsmCarry' initCarry).nextBit state env).1 =
      fun () => Bool.atLeastTwo (env true) (env false) (state ())

theorem icmp_eq_x_invertable_y2_todo_thm.extracted_1._3 : ∀ (x x_1 : BitVec 8) (x_2 : BitVec 1),
  ¬x_2 = 1#1 → ofBool (x_1 ^^^ -1#8 == x ||| x_1 ^^^ -1#8) = ofBool (x &&& x_1 == 0#8)

theorem addhshlhsdivhscalar2_proof : addhshlhsdivhscalar2_before ⊑ addhshlhsdivhscalar2_after

omit [Fintype S] [DecidableEq S] [LawfulBEq A] in
theorem processOneElem_grow (st : worklist.St A S) (final : S → Bool) (a : A) (sa' : S) (s : State) :
      let st' := processOneElem _ _ final s st (a, sa')
      ∃ sas, List.Perm st'.map.keys (sas ++ st.map.keys) ∧ st'.worklist.toList = st.worklist.toList ++ sas

theorem neg_nsw_sgt_1_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬(True ∧ (0#8).ssubOverflow x = true) → ofBool (1#8 <ₛ 0#8 - x) = ofBool (x <ₛ -1#8)

theorem ashrsgt_02_05_exact_thm (e : IntW 4) :
  icmp IntPred.sgt (ashr e (const? 4 2) { «exact» := true }) (const? 4 5) ⊑ const? 1 0

theorem e_1853 :
     - 1 * ( ~~~a &&& ( ~~~b ||| c)) - 2 * (b ^^^ ( ~~~a ||| ( ~~~b &&& c))) + 2 * (c |||  ~~~(a ||| b)) + 2 * ( ~~~(a ||| b) ||| (b ^^^ c)) + 1 *  ~~~(b |||  ~~~c) - 3 *  ~~~(b &&&  ~~~c) - 1 *  ~~~(a ||| c) + 7 * (b ^^^  ~~~( ~~~a ||| (b &&& c))) - 5 * (b ^^^ ( ~~~a ||| ( ~~~b ||| c))) - 7 * (c |||  ~~~(a ^^^ b)) + 11 * ( ~~~(a &&&  ~~~b) &&&  ~~~(b ^^^ c)) + 4 * (b ^^^  ~~~(a &&&  ~~~c)) - 6 * (c ||| (a &&&  ~~~b)) + 5 *  ~~~(a &&& c) - 7 * (c ^^^  ~~~( ~~~a ||| (b &&& c))) - 1 * (a ||| ( ~~~b ||| c)) - 1 * ((b &&&  ~~~c) ^^^ (a ||| (b ^^^ c))) - 6 * ((a &&& b) ||| (a ^^^ (b ^^^ c))) + 5 * ((a &&& b) ||| (b ^^^ c)) + 2 * (b ^^^ (a &&& (b ||| c))) - 1 * (b ^^^ (a |||  ~~~c)) - 1 * (b ^^^ (a ||| (b &&& c))) - 1 * (c ^^^ ( ~~~a ||| ( ~~~b ||| c))) + 2 * ( ~~~b |||  ~~~(a ^^^ c)) + 2 * ((a &&&  ~~~b) |||  ~~~(a ^^^ (b ^^^ c))) - 3 * (c ^^^  ~~~( ~~~a &&& (b ||| c))) - 3 * (b &&&  ~~~(a &&& c)) - 2 * (c ||| (a &&& b)) + 2 *  ~~~(a ^^^ b) - 1 * (c ^^^  ~~~(a ||| (b &&& c))) - 3 * (b ^^^  ~~~( ~~~a &&& (b ||| c))) + 1 * (b |||  ~~~(a ||| c)) + 1 * ((a &&& b) ^^^  ~~~(a ^^^ (b &&& c))) + 1 * ((a &&& c) ^^^  ~~~(b &&&  ~~~c)) + 4 * (b |||  ~~~(a |||  ~~~c)) + 1 * (a &&& ( ~~~b ||| c)) - 1 *  ~~~( ~~~a &&& (b ^^^ c)) - 1 * (b ^^^ (a &&& c)) - 7 *  ~~~(a ||| ( ~~~b ||| c)) + 26 *  ~~~( ~~~a ||| (b ||| c)) + 17 *  ~~~( ~~~a ||| ( ~~~b ||| c)) + 15 * ( ~~~a &&& ( ~~~b &&& c)) + 10 * ( ~~~a &&& (b &&& c)) + 12 * (a &&& ( ~~~b &&& c)) + 2 * (a &&& (b &&& c)) =  - 2 *  ~~~(a ||| (b ||| c)) + 5 * ( ~~~c ||| (a ^^^ b))

theorem sub_ult_zext_thm.extracted_1._1 : ∀ (x : BitVec 1) (x_1 x_2 : BitVec 8),
  ofBool (x_2 - x_1 <ᵤ zeroExtend 8 x) = ofBool (x_2 == x_1) &&& x

theorem add_shl_same_amount_partial_nuw2_proof : add_shl_same_amount_partial_nuw2_before ⊑ add_shl_same_amount_partial_nuw2_after

theorem src_is_mask_shl_lshr_fail_not_allones_thm.extracted_1._2 : ∀ (x x_1 : BitVec 8),
  ¬(x ≥ ↑8 ∨ x ≥ ↑8) →
    ¬x ≥ ↑8 →
      ofBool (0#8 != (x_1 ^^^ 123#8) &&& (BitVec.ofInt 8 (-2) <<< x >>> x ^^^ -1#8)) =
        ofBool (x_1 ^^^ BitVec.ofInt 8 (-124) ||| (-1#8) >>> x &&& BitVec.ofInt 8 (-2) != -1#8)

theorem ashrslt_01_09_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬1#4 ≥ ↑4 → ofBool (x.sshiftRight' 1#4 <ₛ BitVec.ofInt 4 (-7)) = 0#1

theorem not_and_and_or_no_or_commute3_thm (e e_1 e_2 : IntW 32) :
  LLVM.or (LLVM.and (LLVM.sdiv (const? 32 42) e_2) (LLVM.and (LLVM.xor e_1 (const? 32 (-1))) e))
      (LLVM.xor (LLVM.or e e_1) (const? 32 (-1))) ⊑
    LLVM.and (LLVM.or (LLVM.sdiv (const? 32 42) e_2) (LLVM.xor e (const? 32 (-1))))
      (LLVM.xor e_1 (const? 32 (-1)))

theorem lshrult_03_12_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬3#4 ≥ ↑4 → ofBool (x >>> 3#4 <ᵤ BitVec.ofInt 4 (-4)) = 1#1

theorem positive_samevar_shlnuw_proof : positive_samevar_shlnuw_before ⊑ positive_samevar_shlnuw_after

theorem fold_eq_lhs_fail_eq_nonzero_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ¬x_1 ≥ ↑8 → True ∧ ((-1#8) <<< x_1).sshiftRight' x_1 ≠ -1#8 ∨ x_1 ≥ ↑8 → False

theorem ashrsgt_02_01_thm.extracted_1._1 : ∀ (x : BitVec 4), ¬2#4 ≥ ↑4 → ofBool (1#4 <ₛ x.sshiftRight' 2#4) = 0#1

theorem or_basic_thm (e : IntW 16) :
  LLVM.or (icmp IntPred.ne (trunc 8 e) (const? 8 127))
      (icmp IntPred.ne (LLVM.and e (const? 16 (-256))) (const? 16 17664)) ⊑
    icmp IntPred.ne e (const? 16 17791)

theorem ashr_lshr_shift_wrong_pred_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ofBool (x_1 ≤ₛ 0#32) = 1#1 → ¬x ≥ ↑32 → ¬ofBool (x_1 <ₛ 1#32) = 1#1 → x_1 >>> x = x_1.sshiftRight' x

theorem ashrslt_02_15_exact_proof : ashrslt_02_15_exact_before ⊑ ashrslt_02_15_exact_after

theorem not_and_and_or_no_or_commute1_proof : not_and_and_or_no_or_commute1_before ⊑ not_and_and_or_no_or_commute1_after

theorem main7g_logical_thm (e e_1 e_2 e_3 e_4 : IntW 32) :
  select
      (select (icmp IntPred.eq (LLVM.and e_4 e_3) (LLVM.and (LLVM.and e_4 e_3) e_2))
        (icmp IntPred.eq (LLVM.and e_1 e) (LLVM.and (LLVM.and e_1 e) e_2)) (const? 1 0))
      (const? 32 0) (const? 32 1) ⊑
    zext 32
      (select (icmp IntPred.ne (LLVM.and e_4 e_3) (LLVM.and (LLVM.and e_4 e_3) e_2)) (const? 1 1)
        (icmp IntPred.ne (LLVM.and e_1 e) (LLVM.and (LLVM.and e_1 e) e_2)))

theorem and_not_or_commute6_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 32),
  (x_2 &&& x_1 ^^^ -1#32 ||| x) &&& (x &&& x_2 ^^^ -1#32 ||| x_1) = (x_1 ^^^ x) &&& x_2 ^^^ -1#32

theorem e_44 :
    2 * (x ||| y) - 1 * y + 11 * (x ^^^ y) - 12 *  ~~~(x |||  ~~~y) - 13 * (x &&&  ~~~y) = 1 * (x &&& y)

theorem shift_no_xor_multiuse_cmp_with_xor_thm.extracted_1._5 : ∀ (x x_1 x_2 x_3 : BitVec 32),
  ofBool (x_3 &&& 1#32 == 0#32) = 1#1 →
    True ∧ ((x_3 &&& 1#32) <<< 1#32).sshiftRight' 1#32 ≠ x_3 &&& 1#32 ∨
        True ∧ (x_3 &&& 1#32) <<< 1#32 >>> 1#32 ≠ x_3 &&& 1#32 ∨ 1#32 ≥ ↑32 →
      False

theorem PR42691_9_logical_proof : PR42691_9_logical_before ⊑ PR42691_9_logical_after

theorem masked_icmps_mask_notallzeros_bmask_mixed_negated_1b_logical_proof : masked_icmps_mask_notallzeros_bmask_mixed_negated_1b_logical_before ⊑ masked_icmps_mask_notallzeros_bmask_mixed_negated_1b_logical_after

theorem e_322 :
    3 *  ~~~(x &&&  ~~~y) - 3 *  ~~~(x &&&  ~~~x) + 4 * (x |||  ~~~y) - 2 *  ~~~x - 2 *  ~~~(x ||| y) + 2 *  ~~~(x |||  ~~~y) - 1 * (x &&&  ~~~y) = 4 * (x &&& y)

theorem bools2_logical_commute0_thm.extracted_1._11 : ∀ (x x_1 : BitVec 1),
  ¬x_1 = 1#1 → ¬x_1 ^^^ 1#1 = 1#1 → 0#1 = 1#1 → 1#1 = x

theorem or_and3_commuted_thm.extracted_1._6 : ∀ (x x_1 : BitVec 1) (x_2 x_3 : BitVec 32),
  ofBool (x_3 == x_2) ||

theorem sext_sext_sge_op0_narrow_thm.extracted_1._1 : ∀ (x : BitVec 8) (x_1 : BitVec 5),
  ofBool (signExtend 32 x ≤ₛ signExtend 32 x_1) = ofBool (x ≤ₛ signExtend 8 x_1)

theorem lshrugt_01_14_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬1#4 ≥ ↑4 → ofBool (BitVec.ofInt 4 (-2) <ᵤ x >>> 1#4) = 0#1

theorem t10_constants_proof : t10_constants_before ⊑ t10_constants_after

theorem lshrugt_02_15_thm.extracted_1._1 : ∀ (x : BitVec 4), ¬2#4 ≥ ↑4 → ofBool (-1#4 <ᵤ x >>> 2#4) = 0#1

theorem test8_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬16#32 ≥ ↑32 →
    ¬(16#32 ≥ ↑32 ∨ True ∧ (x.sshiftRight' 16#32).smulOverflow 32767#32 = true) →
      signExtend 64 (x.sshiftRight' 16#32) * 32767#64 = signExtend 64 (x.sshiftRight' 16#32 * 32767#32)

theorem icmp_eq_x_invertable_y2_proof : icmp_eq_x_invertable_y2_before ⊑ icmp_eq_x_invertable_y2_after

theorem lt_signed_to_large_negative_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ofBool (signExtend 32 x <ₛ BitVec.ofInt 32 (-1024)) = 0#1

theorem xor_logic_and_logic_or2_thm.extracted_1._4 : ∀ (x x_1 x_2 : BitVec 1), ¬x_2 = 1#1 → x = 1#1 → 0#1 ^^^ 1#1 = x

theorem main12_logical_thm.extracted_1._3 : ∀ (x : BitVec 32),
  ¬ofBool (truncate 16 x <ₛ 0#16) = 1#1 →
    ofBool (x &&& 32896#32 == 0#32) = 1#1 → ofBool (truncate 8 x <ₛ 0#8) = 1#1 → 2#32 = 1#32

theorem t1_thm.extracted_1._1 : ∀ (x : BitVec 64) (x_1 : BitVec 32),
  ¬(32#32 - x_1 ≥ ↑32 ∨ zeroExtend 64 (x_1 + BitVec.ofInt 32 (-16)) ≥ ↑64) →
    ofBool (65535#32 <<< (32#32 - x_1) &&& truncate 32 (x >>> zeroExtend 64 (x_1 + BitVec.ofInt 32 (-16))) != 0#32) =
      ofBool (x &&& 4294901760#64 != 0#64)

theorem e_1905 :
    1 * (a ^^^ c) + 1 * (c ^^^  ~~~(a &&& ( ~~~b &&& c))) - 5 * (a ||| ( ~~~b &&& c)) + 2 * ( ~~~b |||  ~~~(a ^^^ c)) + 1 * (a &&&  ~~~c) + 5 * ( ~~~c &&&  ~~~(a ^^^ b)) + 3 * ((a &&&  ~~~b) ||| (b ^^^ c)) - 7 *  ~~~(b ^^^ c) + 2 * (a ||| c) + 7 * ((a &&& c) ||| (b &&&  ~~~c)) - 2 * ( ~~~(a ||| b) ||| (b ^^^ c)) + 1 * (a ^^^ ( ~~~b ||| c)) - 3 *  ~~~(b &&&  ~~~c) - 2 * ((a &&& b) ^^^ (a ^^^ (b &&& c))) + 4 * (a ||| ( ~~~b ||| c)) - 1 * (b ^^^  ~~~(a &&& ( ~~~b ||| c))) - 1 * ((a &&& c) ^^^  ~~~(b &&&  ~~~c)) + 1 * (c ^^^ (a ||| (b &&& c))) - 7 * (c ^^^ (a &&&  ~~~b)) + 1 * ( ~~~a ||| ( ~~~b &&& c)) - 11 * (b &&& c) - 2 *  ~~~(a ^^^ ( ~~~b &&& c)) + 5 * (a ||| b) - 1 * (b &&& (a |||  ~~~c)) + 1 * ((a &&& b) |||  ~~~(a ^^^ (b ^^^ c))) - 1 *  ~~~(a ||| c) - 5 * a + 11 * (a &&& (b ||| c)) + 2 * (a ^^^ (b ^^^ c)) - 1 * (c ^^^  ~~~( ~~~a &&& (b &&& c))) - 6 * (c &&& (a ^^^ b)) - 3 *  ~~~(a &&& ( ~~~b &&& c)) - 3 * ((a &&&  ~~~b) |||  ~~~(a ^^^ (b ^^^ c))) + 1 * (a &&& ( ~~~b ||| c)) + 3 * ((a &&&  ~~~b) ||| (a ^^^ (b ^^^ c))) - 1 * (c ^^^  ~~~(a &&& (b ||| c))) + 2 * ((a &&& b) |||  ~~~(b ||| c)) + 4 *  ~~~(a &&& (b ^^^ c)) + 3 * ( ~~~a ||| (b ||| c)) + 2 * (c &&&  ~~~(a &&&  ~~~b)) + 1 * (b |||  ~~~(a ^^^ c)) + 11 * (b ^^^ ( ~~~a &&& (b ^^^ c))) - 2 * (a &&& (b ^^^ c)) - 28 *  ~~~(a ||| ( ~~~b ||| c)) + 6 *  ~~~( ~~~a ||| (b ||| c)) - 42 *  ~~~( ~~~a ||| ( ~~~b ||| c)) - 22 * ( ~~~a &&& ( ~~~b &&& c)) + 3 * ( ~~~a &&& (b &&& c)) - 21 * (a &&& ( ~~~b &&& c)) - 18 * (a &&& (b &&& c)) =  - 3 * (b ^^^ (a &&& (b ^^^ c))) - 4 * ( ~~~(a |||  ~~~b) ||| (b ^^^ c))

theorem same_source_matching_signbits_proof : same_source_matching_signbits_before ⊑ same_source_matching_signbits_after

theorem basic_preserve_nuw_thm (e e_1 : IntW 8) :
  LLVM.xor (add (LLVM.xor e_1 (const? 8 (-1))) e { «nsw» := false, «nuw» := true }) (const? 8 (-1)) ⊑
    sub e_1 e { «nsw» := false, «nuw» := true }

@[simp]
theorem BitVec.zero_concat (b : Bool) : (0#0).concat b = BitVec.ofBool b

theorem logic_and_logic_or_2_thm (e e_1 e_2 : IntW 1) :
  select (select e_2 e_1 (const? 1 0)) (const? 1 1) (select e_1 e (const? 1 0)) ⊑
    select e_1 (select e_2 (const? 1 1) e) (const? 1 0)

theorem sgt_n1_proof : sgt_n1_before ⊑ sgt_n1_after

theorem match_andAsRem_lshrAsDiv_shlAsMul_thm.extracted_1._1 : ∀ (x : BitVec 64),
  ¬(6#64 ≥ ↑64 ∨ 9#64 = 0 ∨ 6#64 ≥ ↑64) → 576#64 = 0 → False

@[grind ., simp, aesop 50% unsafe]
lemma wf_addInitial (m : RawCNFA A) (hwf : m.WF) (hin : s ∈ m.states) :
    (m.addInitial s).WF

theorem sge_to_ugt_proof : sge_to_ugt_before ⊑ sge_to_ugt_after

theorem main3f_like_logical_thm.extracted_1._4 : ∀ (x x_1 : BitVec 32),
  ofBool (x_1 &&& x != 0#32) = 1#1 → ¬ofBool (x_1 &&& x == 0#32) = 1#1 → ¬True → 0#32 = zeroExtend 32 0#1

theorem ashrsgt_03_04_proof : ashrsgt_03_04_before ⊑ ashrsgt_03_04_after

theorem test19_thm.extracted_1._1 : ∀ (x : BitVec 32), ¬3#32 ≥ ↑32 → x <<< 3#32 &&& BitVec.ofInt 32 (-2) = x <<< 3#32

theorem ashr_ugt_4_proof : ashr_ugt_4_before ⊑ ashr_ugt_4_after

theorem icmp_power2_and_icmp_shifted_mask_1073741824_1073741823_thm (e : IntW 32) :
  LLVM.and (icmp IntPred.ult e (const? 32 1073741824))
      (icmp IntPred.ne (LLVM.and e (const? 32 1073741823)) (const? 32 1073741823)) ⊑
    icmp IntPred.ult e (const? 32 1073741823)

theorem sdiv_exact_eq_9_no_of_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ¬(True ∧ x_1.smod (x &&& 7#8) ≠ 0 ∨ (x &&& 7#8 == 0 || 8 != 1 && x_1 == intMin 8 && x &&& 7#8 == -1) = true) →
    True ∧ (x &&& 7#8).smulOverflow 9#8 = true ∨ True ∧ (x &&& 7#8).umulOverflow 9#8 = true → False

theorem p_thm (e e_1 e_2 : IntW 32) :
  LLVM.or (LLVM.and e_2 e_1) (LLVM.and (LLVM.xor e_1 (const? 32 (-1))) e) ⊑
    LLVM.or (LLVM.and e_2 e_1) (LLVM.and e (LLVM.xor e_1 (const? 32 (-1)))) { «disjoint» := true }

theorem orn_and_cmp_2_partial_logical_proof : orn_and_cmp_2_partial_logical_before ⊑ orn_and_cmp_2_partial_logical_after

theorem lshrult_01_10_exact_proof : lshrult_01_10_exact_before ⊑ lshrult_01_10_exact_after

theorem sub_select_not_zext_thm.extracted_1._3 : ∀ (x : BitVec 64) (x_1 : BitVec 1),
  ¬x_1 = 1#1 → 64#64 - zeroExtend 64 (x_1 ^^^ 1#1) = 63#64

theorem icmp_eq_sext_ne_allones_thm (e : IntW 32) :
  icmp IntPred.eq (sext 32 (icmp IntPred.ne e (const? 32 (-1)))) e ⊑ const? 1 0

theorem PR39793_bswap_u64_as_u16_trunc_proof : PR39793_bswap_u64_as_u16_trunc_before ⊑ PR39793_bswap_u64_as_u16_trunc_after

@[simp] theorem Lets.denote_var_appendInl_pure (lets : Lets d Γ_in .pure Γ_out)
    (e : Expr d Γ_out .pure tys) (V_in : Valuation Γ_in) (v : Var _ u) :
    Lets.denote (var lets e) V_in v.appendInl
    = let xs : HVector .. := e.denoteOp (lets.denote V_in)
      xs[v]

@[simp]
theorem toBitVec_sub (a b : BitStream) :
    (a - b).toBitVec w = (a.toBitVec w) - (b.toBitVec w)

theorem e_634 :
     - 2 *  ~~~(x ^^^ y) - 5 * y + 2 *  ~~~(x &&& y) + 5 * x - 1 * (x ^^^ y) - 3 *  ~~~(x &&&  ~~~x) - 6 *  ~~~(x &&&  ~~~y) + 9 *  ~~~(x ||| y) - 1 * (x &&&  ~~~y) + 13 * (x &&& y) =  - 15 *  ~~~(x |||  ~~~y) + 2 * (x ||| y)

theorem t8_lshr_exact_flag_preservation_proof : t8_lshr_exact_flag_preservation_before ⊑ t8_lshr_exact_flag_preservation_after

theorem xor_or_xor_common_op_commute4_proof : xor_or_xor_common_op_commute4_before ⊑ xor_or_xor_common_op_commute4_after

theorem add_shl_same_amount_nuw_proof : add_shl_same_amount_nuw_before ⊑ add_shl_same_amount_nuw_after

theorem test7_logical_proof : test7_logical_before ⊑ test7_logical_after

theorem or_and_not_not_commute5_proof : or_and_not_not_commute5_before ⊑ or_and_not_not_commute5_after

theorem x_proof : x_before ⊑ x_after
</all_available_lemmas>

<local_ctx>
import Batteries.Data.Fin.Basic

import Batteries.Data.Fin.Lemmas

import Blase.SingleWidth.Defs

import Blase.AutoStructs.Constructions

import Blase.AutoStructs.Defs

import Blase.AutoStructs.FiniteStateMachine

import Mathlib.Tactic.Ring

import Mathlib.Data.Nat.Size -- TODO: remove and get rid of shiftLeft_eq_mul_pow use

import Mathlib.Data.BitVec

import Mathlib.Tactic.FinCases

open Fin.NatCast

open Mathlib

def NFA.sa (_ : NFA α σ) := σ → Language α

structure NFA.correct (M : NFA α σ) (ζ : M.sa) (L : Language α) where
  cond1 : ∀ w, (w ∈ L ↔ ∃ q ∈ M.accept, w ∈ ζ q)
  cond2 : ∀ w q, q ∈ M.eval w ↔ w ∈ ζ q

abbrev BVNRel n := ∀ ⦃w⦄, List.Vector (BitVec w) n → Prop

def NFA'.sa (M : NFA' n) := M.σ → BVNRel n

structure NFA'.correct (M : NFA' n) (ζ : M.sa) (L : BVNRel n) where
  cond1 : ∀ ⦃w⦄ (bvn : List.Vector (BitVec w) n), (L bvn ↔ ∃ q ∈ M.M.accept, ζ q bvn)
  cond2 q : q ∈ M.M.start ↔ ζ q (List.Vector.replicate n .nil)
  cond3 q a {w} (bvn : List.Vector (BitVec w) n) : q ∈ M.M.stepSet { q | ζ q bvn } a ↔
              ζ q (List.Vector.ofFn fun k => BitVec.cons (a.getLsbD k) (bvn.get k))

structure NFA'.correct2 (M : NFA' 2) (ζ : M.sa2) (L : BVRel) where
  cond1 : ∀ (bv1 bv2 : BitVec w), (L bv1 bv2 ↔ ∃ q ∈ M.M.accept, ζ q bv1 bv2)
  cond2 q : q ∈ M.M.start ↔ ζ q .nil .nil
  cond3 q a w (bv1 bv2 : BitVec w) : q ∈ M.M.stepSet { q | ζ q bv1 bv2 } a ↔
              ζ q (BitVec.cons (a.getLsbD 0) bv1) (BitVec.cons (a.getLsbD 1) bv2)

section fsm

variable {arity : Type} [FinEnum arity]

open BitStream in

end fsm

section nfas_relations

inductive NFA.msbState : Type where
| i | f
deriving DecidableEq, Fintype

def NFA.msbStep (q : NFA.msbState) (a : BitVec 1) : List NFA.msbState :=
  match q, a with
  | .i, 0 => [.i]
  | .i, 1 => [.i, .f]
  | _, _ => []

def NFA.autMsbSet : NFA (BitVec 1) msbState where
  step s a := { s' | s' ∈ msbStep s a }
  start := {.i}
  accept := {.f}

def NFA'.autMsbSet : NFA' 1 := ⟨_, NFA.autMsbSet⟩

def NFA.msbLang : Language (BitVec 1) := { bvs  | bvs.getLast? = some 1 }

def NFA.msbSA (q : msbState) : Language (BitVec 1) :=
  match q with
  | .i => ⊤
  | .f => msbLang

def NFA.msbCorrect : NFA.autMsbSet.correct msbSA msbLang :=
</local_ctx>

<target_theorem>
@[simp]
lemma autMsbSet_accepts : NFA'.autMsbSet.accepts = langMsb :=
</target_theorem>

