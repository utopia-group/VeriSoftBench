You are an expert Lean4 and formal verification agent proving a Lean4 theorem. Your output **must** strictly adhere to the specified format.

### Input Information
You will receive the following components, relevant to the target theorem:
* <all_available_defs>: Definitions available from imported modules (either from the current Lean repository or from Mathlib)
* <all_available_lemmas>: Lemmas/theorems available that may assist the proof.
* <local_ctx>...</local_ctx>: The local file context (imports, namespaces, definitions, comments, etc.) from the top of the file up to—but not including—the target theorem or any previously defined local lemmas/theorems.
* <target_theorem>...</target_theorem>: The target theorem statement, ending with `:=`.

**Notes**
1. Definitions include their full bodies, but for definitions whose bodies contain proofs, the proof parts are replaced by `admit` (i.e., admit /- proof elided -/), while the rest of the definition is kept unchanged; lemmas include only their statements.
2. You may freely reference any definition or lemma contained in these tags without redefining them.
3. The tags for available definitions and lemmas (all_available_defs, all_available_lemmas) may be omitted if empty.

### Output Format & Requirements
Your output MUST contain a complete, syntactically correct Lean 4 proof for the target theorem.

**Strict Output Structure:**
<reasoning> 
...
</reasoning> 

<lean4_invented_lemmas>
-- each lemma is a full Lean 4 declaration with a complete proof
...
</lean4_invented_lemmas>

<lean4_proof>
-- Lean 4 proof body of the target theorem
...
</lean4_proof>

**Requirements:**
1. <reasoning> and <lean4_invented_lemmas> are OPTIONAL. Include them only if they aid proof construction.
2. <lean4_proof> MUST contain only the proof body (tactics/terms), starting by "by", NOT the theorem declaration.
3. <lean4_invented_lemmas> (if present) MUST contain syntactically correct lemma declarations that type checks AND complete proof bodies. Defining a lemma using `axiom` is NOT allowed.
4. <reasoning> contains high-level proof planning.
5. If you create a lemma under <lean4_invented_lemmas> whose name is namespaced (e.g., X.Y.Z), you MUST always refer to it using its fully qualified name. Do NOT rely on shortened names. For example, write rw [X.Y.Z], not rw [Z] for invented lemmas.
6. All Lean 4 code MUST be syntactically correct. No `sorry`, `admit`, or non-Lean text. Comments allowed using `--` or `/- ... -/`.
7. Follow the tags and structure EXACTLY. No extra text before, between, or after the sections.
8. Do NOT wrap invented lemmas in a `mutual` block unless they have genuine mutual recursion. Declare each lemma independently.

### Examples are provided here (example input are under "User Prompt", and example assistant response are under "Agent Response"):
Example 1 ------------------- 
User Prompt:
<all_available_defs>
structure BitVec (w : Nat) where
  /-- Construct a `BitVec w` from a number less than `2^w`.
  O(1), because we use `Fin` as the internal representation of a bitvector. -/
  ofFin ::

  /-- Interpret a bitvector as a number less than `2^w`.
  O(1), because we use `Fin` as the internal representation of a bitvector. -/
  toFin : Fin (hPow 2 w)
</all_available_defs>

<all_available_lemmas>
theorem List.getElem_append_left{α : Type u_1} {l₁ l₂ : List α} {i : Nat} (hn : i < l₁.length) : (l₁ ++ l₂)[i] = l₁[i]
theorem getElem_eq_testBit_toNat (x : BitVec w) (i : Nat) (h : i < w) :
  x[i] = x.toNat.testBit i := rfl
@[simp, grind =] theorem toNat_cons (b : Bool) (x : BitVec w) :
    (cons b x).toNat = (b.toNat <<< w) ||| x.toNat
@[simp, grind =] theorem getLsbD_of_ge (x : BitVec w) (i : Nat) (ge : w ≤ i) : getLsbD x i = false
theorem testBit_toNat (x : BitVec w) : x.toNat.testBit i = x.getLsbD i
</all_available_lemmas>

<local_ctx>
import Mathlib.Computability.NFA
import Mathlib.Data.FinEnum
import Mathlib.Data.Rel
import Mathlib.Data.Vector.Basic
import Blase.AutoStructs.ForLean

open Set
open Mathlib
open SetRel

-- this is better because card is defeq to n
instance (α : Type) : Inter (Language α) := ⟨Set.inter⟩
instance (α : Type) : Union (Language α) := ⟨Set.union⟩

/--
The set of `n`-tuples of bit vectors of an arbitrary width.
-/
structure BitVecs (n : Nat) where
  w : Nat
  bvs : List.Vector (BitVec w) n

def BitVecs.cast (bvs : BitVecs n) (h : n = n') : BitVecs n' :=
  { w := bvs.w, bvs := h ▸ bvs.bvs }

abbrev BitVecs.empty : BitVecs n := ⟨0, List.Vector.replicate n .nil⟩
abbrev BitVecs.singleton {w : Nat} (bv : BitVec w) : BitVecs 1 := ⟨w, bv ::ᵥ .nil⟩
abbrev BitVecs.pair {w : Nat} (bv1 bv2 : BitVec w) : BitVecs 2 := ⟨w, bv1 ::ᵥ bv2 ::ᵥ .nil⟩

/--
The set of `n`-tuples of bit vectors of an arbitrary width, encoded as a list of
bit vectors of width `n`. The width of the encoded bit vectors is the length of
the list.
-/
abbrev BitVecs' (n : Nat) := List (BitVec n)

@[simps]
def dec (bvs' : BitVecs' n) : BitVecs n where
  w := bvs'.length
  bvs := List.Vector.ofFn fun k => BitVec.ofFn fun i => bvs'[i].getLsbD k

@[simp]
</local_ctx>

<target_theorem>
lemma dec_snoc n (bvs' : BitVecs' n) (a : BitVec n) :
  dec (bvs' ++ [a]) =
    { w := bvs'.length + 1
      bvs := List.Vector.ofFn fun k =>
        BitVec.cons (a.getLsbD k) ((dec bvs').bvs.get k) } :=
</target_theorem>

Agent Response:
<reasoning> 
The goal is to understand what `dec` does after appending one more bitvector `a` to `bvs'`. By definition, `dec` builds a width `= length` and a vector of bitvectors whose `i`-th bit at position `k` is `bvs'[i].getLsbD k`. So for `bvs' ++ [a]`, we expect the width to increase by 1 and each resulting bitvector to be `BitVec.cons` of the new bit coming from `a`.

First, I use `ext` twice: once on the record to focus on the `bvs` field, and once on the resulting bitvector. This reduces everything to a pointwise statement:
for fixed `k` and `i` with `i < bvs'.length + 1`,
the bit `(bvs' ++ [a])[i].getLsbD k` should match the bit at index `i` of `BitVec.cons (a.getLsbD k) ((dec bvs').bvs.get k)`.

At this point I need a clean description of indexing into `BitVec.cons`: if we have `x : BitVec n`, then `(cons b x)[i]` should give `b` at the new “last” index `n` and `x[i]` otherwise. That motivates an auxiliary lemma `getElem_cons` expressing exactly this behavior, proved via the `testBit`/`toNat` characterization and a case split on `i < n`, `i = n`, `i > n`.

Using `getElem_cons`, the RHS becomes an `if` on whether `i = bvs'.length`. So I split into cases:
- If `i = bvs'.length`, then `(bvs' ++ [a])[i]` is the appended `a`, so both sides reduce to `a.getLsbD k`.
- If `i ≠ bvs'.length`, the bound `i < bvs'.length + 1` forces `i < bvs'.length`. Then `(bvs' ++ [a])[i] = bvs'[i]` by `List.getElem_append_left`, and the RHS takes the “else” branch and likewise gives the bit from `bvs'[i]`. In both subcases, `simp` (plus the definition of `dec`) finishes.

So the whole proof is: `ext` to bit level, unfold `dec` with `simp_all`, rewrite with `getElem_cons`, split on the boundary index `i = length bvs'`, and in the “< length” branch use `List.getElem_append_left` and bounds to line up both sides.
</reasoning> 

<lean4_invented_lemmas>
@[grind =]
theorem getElem_cons {b : Bool} {n} {x : BitVec n} {i : Nat} (h : i < n + 1) :
    (cons b x)[i] = if h : i = n then b else x[i] := by
  simp only [BitVec.getElem_eq_testBit_toNat, BitVec.toNat_cons, Nat.testBit_or]
  rw [Nat.testBit_shiftLeft]
  rcases Nat.lt_trichotomy i n with i_lt_n | i_eq_n | n_lt_i
  · have p1 : ¬(n ≤ i) := by omega
    have p2 : i ≠ n := by omega
    simp [p1, p2]
  · simp only [i_eq_n, ge_iff_le, Nat.le_refl, decide_true, Nat.sub_self, Nat.testBit_zero,
    Bool.true_and, BitVec.testBit_toNat, BitVec.getLsbD_of_ge, Bool.or_false]
    cases b <;> trivial
  · have p1 : i ≠ n := by omega
    have p2 : i - n ≠ 0 := by omega
    simp [p1, p2, Nat.testBit_bool_toNat]
</lean4_invented_lemmas>

<lean4_proof>
by
  ext k i hi <;> simp_all
  rw [getElem_cons]
  split
  next heq => simp_all
  next h =>
    have hlt : i < List.length bvs' := by simp at hi; omega
    rw [List.getElem_append_left hlt]
    simp
</lean4_proof>

### Your task:
<all_available_defs>
Polynomial.X in Mathlib.Algebra.Polynomial.Basic
ZMod in Mathlib.Data.ZMod.Defs
Function.surjInv in Mathlib.Logic.Function.Basic
Nat in Init.Prelude
Polynomial in Mathlib.Algebra.Polynomial.Basic
Polynomial.degree in Mathlib.Algebra.Polynomial.Degree.Definitions
Ideal in Mathlib.RingTheory.Ideal.Defs
Ideal.Quotient.mk in Mathlib.RingTheory.Ideal.Quotient.Defs
Ideal.span in Mathlib.RingTheory.Ideal.Span
Polynomial.monomial in Mathlib.Algebra.Polynomial.Basic
Int in Init.Data.Int.Basic
List in Init.Prelude
Polynomial.coeff in Mathlib.Algebra.Polynomial.Basic
List.range in Init.Data.List.Basic
Polynomial.map in Mathlib.Algebra.Polynomial.Eval.Defs
Fact in Mathlib.Logic.Basic
Polynomial.Monic in Mathlib.Algebra.Polynomial.Degree.Definitions
ZMod.cast in Mathlib.Data.ZMod.Basic
List.map in Init.Prelude
WithBot in Mathlib.Order.TypeTags
List.length in Init.Prelude
Int.cast in Init.Data.Int.Basic
IntCast in Init.Data.Int.Basic
IntCast.intCast in Init.Data.Int.Basic
List.toFinsupp in Mathlib.Data.List.ToFinsupp
Polynomial.ofFinsupp in Mathlib.Algebra.Polynomial.Basic
List.getD in Init.Data.List.BasicAux
DecidableEq in Init.Prelude
Polynomial.toFinsupp in Mathlib.Algebra.Polynomial.Basic
Semiring in Mathlib.Algebra.Ring.Defs

syntax "neg" : MLIR.Pretty.uniform_op

macro_rules
  | `(mlir_op| $res:mlir_op_operand = const ($x)
      $[: $outer_type]? ) => do
      let outer_type ← outer_type.getDM `(mlir_type| _)
      `(mlir_op| $res:mlir_op_operand = "const"()
          {val = $x:num : $outer_type} : ($outer_type) -> ($outer_type) )

macro_rules
  | `(mlir_op| $res:mlir_op_operand = li ($x)
     $[: $outer_type]?  ) => do
      let outer_type ← outer_type.getDM `(mlir_type| _ )
      `(mlir_op| $res:mlir_op_operand = "li"()
          {imm = $x:num : $outer_type } : ($outer_type) -> ($outer_type))

macro_rules
| `(mlir_op| $res:mlir_op_operand = $op1:MLIR.Pretty.RV.opWithImmediate $reg1 , $x : $t)  => do
    let some opName := MLIR.EDSL.Pretty.extractOpName op1.raw
      | Macro.throwUnsupported
    `(mlir_op| $res:mlir_op_operand = $opName ($reg1) {imm = $x:num : $t} : ($t) -> ($t) )

macro_rules
| `(mlir_op| $res:mlir_op_operand = $op1:MLIR.Pretty.RV.opWithShamt $reg1 , $x  : $t )  => do
    let some opName := MLIR.EDSL.Pretty.extractOpName op1.raw
      | Macro.throwUnsupported
    `(mlir_op| $res:mlir_op_operand = $opName ($reg1) {shamt = $x:num : $t}  : ($t) -> ($t) )

noncomputable def R.repLength {q n} (a : R q n) : Nat := match
  Polynomial.degree a.representative with
    | none => 0
    | some d => d + 1

noncomputable def R.representative :
    R q n → (ZMod q)[X] := fun x => R.representative' q n x %ₘ (f q n)

private noncomputable def R.representative' :
    R q n → (ZMod q)[X] := Function.surjInv (R.surjective_fromPoly q n)

noncomputable def f : (ZMod q)[X] := X^(2^n) + 1

noncomputable def R.fromTensor {q n} (coeffs : List Int) : R q n :=
  coeffs.zipIdx.foldl (init := 0) fun res (c, i) =>
    res + R.monomial ↑c i

noncomputable def R.monomial {q n : Nat} (c : ZMod q) (i : Nat): R q n :=
  R.fromPoly (Polynomial.monomial i c)

abbrev R.fromPoly {q n : Nat} : (ZMod q)[X] →+* R q n := Ideal.Quotient.mk (Ideal.span {f q n})

noncomputable def R.toTensor {q n} (a : R q n) : List Int :=
  List.range a.repLength |>.map fun i =>
        a.coeff i |>.toInt

noncomputable def R.coeff {q n} (a : R q n) (i : Nat) : ZMod q :=
  Polynomial.coeff a.representative i

def ZMod.toInt (x : ZMod q) : Int := ZMod.cast x

noncomputable def R.fromTensorFinsupp (q : Nat) (coeffs : List Int) : (ZMod q)[X] :=
  Polynomial.ofFinsupp (List.toFinsupp (coeffs.map Int.cast))

abbrev R := (ZMod q)[X] ⧸ (Ideal.span {f q n})

@[simp_denote]
def srai_riscv_i32 :=
  [LV| {
    ^entry (%arg: i32):
    %a = "builtin.unrealized_conversion_cast" (%arg) : (i32) -> (!i64)
    %0 = sraiw %a, 9 : !i64
    %1 = "builtin.unrealized_conversion_cast" (%0) : (!i64) -> (i32)
    llvm.return %1 : i32
  }]

def lshr_lshr_pow2_const_negative_nopow2_1_before := [llvm|
{
^0(%arg63 : i16):
  %0 = llvm.mlir.constant(2047 : i16) : i16
  %1 = llvm.mlir.constant(6 : i16) : i16
  %2 = llvm.mlir.constant(4 : i16) : i16
  %3 = llvm.lshr %0, %arg63 : i16
  %4 = llvm.lshr %3, %1 : i16
  %5 = llvm.and %4, %2 : i16
  "llvm.return"(%5) : (i16) -> ()
}
]

def ashr_not_before := [llvm|
{
^0(%arg78 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.mlir.constant(5 : i8) : i8
  %2 = llvm.xor %arg78, %0 : i8
  %3 = llvm.ashr %2, %1 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def slt_zero_slt_i1_fail_before := [llvm|
{
^0(%arg4 : i32, %arg5 : i1):
  %0 = llvm.mlir.constant(31 : i32) : i32
  %1 = llvm.zext %arg5 : i1 to i32
  %2 = llvm.lshr %arg4, %0 : i32
  %3 = llvm.icmp "slt" %1, %2 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def Expr.substitute (σ : Substitution) : Expr Op T → Expr Op T
  | ⟨varName, op, args, regions⟩ =>
      let σ' := σ.removeMappingFor varName
      ⟨varName, op, σ'.apply <$> args, subRegions σ' regions⟩
  
  
  where subRegions (σ' : Substitution) : List (Region Op T) → List (Region Op T)
    | []    => []
    | r::rs => r.substitute σ' :: subRegions σ' rs

def src_is_mask_and_after := [llvm|
{
^0(%arg122 : i8, %arg123 : i8, %arg124 : i8):
  %0 = llvm.mlir.constant(7 : i8) : i8
  %1 = llvm.mlir.constant(-1 : i8) : i8
  %2 = llvm.mlir.constant(123 : i8) : i8
  %3 = llvm.lshr %0, %arg123 : i8
  %4 = llvm.lshr %1, %arg124 : i8
  %5 = llvm.and %3, %4 : i8
  %6 = llvm.xor %arg122, %2 : i8
  %7 = llvm.icmp "ule" %6, %5 : i8
  "llvm.return"(%7) : (i1) -> ()
}
]

def Eqn.denote {w : Nat} (e : Eqn) (env : Env w) : Int :=
  match e with
  | [] => 0
  | t :: ts => t.denote env + Eqn.denote ts env

@[tactic bvAutomataFragmentCheckReflected]
def evalBvAutomataFragmentCheckReflected : Tactic := fun
| `(tactic| bv_automata_fragment_reflect) => do
  let g ← getMainGoal
  g.withContext do
    let ws ← findExprBitwidths (← g.getType)
    let ws := ws.toArray
    if h0: ws.size = 0 then throwError m!"found no bitvector in the target: {indentD (← g.getType)}"
    else if hgt: ws.size > 1 then
      let (w1, wExample1) := ws[0]
      let (w2, wExample2) := ws[1]
      let mExample := m!"{w1} → {wExample1}; {w2} → {wExample2}"
      throwError m!"found multiple bitvector widths in the target: {indentD mExample}"
    else
      
      let (w, wExample) := ws[0]

      
      let g ← revertBvHyps g

      
      
      let .some g ← NNF.runNNFSimpSet g
        | trace[Bits.Frontend] m!"Converting to negation normal form automatically closed goal."
          return ()
      trace[Bits.Frontend] m!"goal after NNF: {indentD g}"

      let .some g ← Simplifications.runPreprocessing g
        | trace[Bits.Frontend] m!"Preprocessing automatically closed goal."
          return ()
      trace[Bits.Frontend] m!"goal after preprocessing: {indentD g}"
      
      let result ← reflectPredicateAux ∅ (← g.getType) w
      let bvToIxMapVal ← result.exprToIx.toExpr w

      let target := (mkAppN (mkConst ``Predicate.denote) #[result.e.quote, w, bvToIxMapVal])
      let g ← g.replaceTargetDefEq target
      trace[Bits.Frontend] m!"goal after reflection: {indentD g}"
      return ()
| _  => throwUnsupportedSyntax

def sextinreg2_after := [llvm|
{
^0(%arg6 : i32):
  %0 = llvm.mlir.constant(24 : i32) : i32
  %1 = llvm.shl %arg6, %0 : i32
  %2 = llvm.ashr exact %1, %0 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def shl_add_nuw_after := [llvm|
{
^0(%arg24 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

def lshrult_03_04_exact_before := [llvm|
{
^0(%arg113 : i4):
  %0 = llvm.mlir.constant(3 : i4) : i4
  %1 = llvm.mlir.constant(4 : i4) : i4
  %2 = llvm.lshr exact %arg113, %0 : i4
  %3 = llvm.icmp "ult" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def test1_after := [llvm|
{
^0(%arg14 : i32, %arg15 : i32):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def add_shl_same_amount_partial_nsw1_after := [llvm|
{
^0(%arg41 : i6, %arg42 : i6, %arg43 : i6):
  %0 = llvm.add %arg41, %arg42 : i6
  %1 = llvm.shl %0, %arg43 : i6
  "llvm.return"(%1) : (i6) -> ()
}
]

def masked_icmps_mask_notallzeros_bmask_mixed_7_logical_after := [llvm|
{
^0(%arg77 : i32):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def n1_after := [llvm|
{
^0(%arg3 : i8):
  %0 = llvm.mlir.constant(8 : i8) : i8
  %1 = llvm.icmp "ult" %arg3, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def sub_ashr_and_i16_after := [llvm|
{
^0(%arg29 : i16, %arg30 : i16):
  %0 = llvm.mlir.constant(0 : i16) : i16
  %1 = llvm.icmp "slt" %arg30, %arg29 : i16
  %2 = "llvm.select"(%1, %arg29, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i16, i16) -> i16
  "llvm.return"(%2) : (i16) -> ()
}
]

def ashrsgt_01_08_exact_after := [llvm|
{
^0(%arg93 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def sext_before := [llvm|
{
^0(%arg9 : i16):
  %0 = llvm.mlir.constant(32768 : i32) : i32
  %1 = llvm.mlir.constant(-32768 : i32) : i32
  %2 = llvm.zext %arg9 : i16 to i32
  %3 = llvm.xor %2, %0 : i32
  %4 = llvm.add %3, %1 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def scalar_i32_shl_and_signbit_eq_nonzero_before := [llvm|
{
^0(%arg0 : i32, %arg1 : i32):
  %0 = llvm.mlir.constant(-2147483648 : i32) : i32
  %1 = llvm.mlir.constant(1 : i32) : i32
  %2 = llvm.shl %arg0, %arg1 : i32
  %3 = llvm.and %2, %0 : i32
  %4 = llvm.icmp "eq" %3, %1 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def add_shl_moreOneUse_sh3add_no_ZBA_test : LLVMPeepholeRewriteRefine 32 [Ty.llvm (.bitvec 32)] where
  lhs := add_shl_moreOneUse_sh3add
  rhs := add_shl_moreOneUse_sh3add_riscv_no_ZBA

partial def getBitVecTypeWidths (t : Expr) (out : Std.HashSet Expr) :
    MetaM (Std.HashSet Expr) := do
  if let some w ← getBitVecTypeWidth? t then do
    
    if let some 1 ← getNatValue? w then
      return out
    return out.insert w
  else
    let (_f, args) := t.getAppFnArgs
    let mut out := out
    for arg in args do
      out ← getBitVecTypeWidths arg out
    return out

def select_xor_icmp_bad_5_after := [llvm|
{
^0(%arg172 : i32, %arg173 : i32, %arg174 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.icmp "eq" %arg172, %0 : i32
  %2 = llvm.xor %arg172, %arg174 : i32
  %3 = "llvm.select"(%1, %arg173, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def or_logic_or_logic_and_7_after := [llvm|
{
^0(%arg30 : i1, %arg31 : i1, %arg32 : i1):
  %0 = llvm.mlir.constant(false) : i1
  %1 = llvm.mlir.constant(true) : i1
  %2 = "llvm.select"(%arg32, %arg31, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %3 = "llvm.select"(%arg30, %1, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def test3_before := [llvm|
{
^0(%arg0 : i599, %arg1 : i1):
  %0 = llvm.mlir.constant(70368744177664 : i599) : i599
  %1 = llvm.mlir.constant(4096 : i599) : i599
  %2 = "llvm.select"(%arg1, %0, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i599, i599) -> i599
  %3 = llvm.udiv %arg0, %2 : i599
  "llvm.return"(%3) : (i599) -> ()
}
]

def t1_after := [llvm|
{
^0(%arg31 : i8):
  %0 = llvm.mlir.constant(31 : i8) : i8
  %1 = llvm.mlir.constant(-32 : i8) : i8
  %2 = llvm.add %arg31, %0 : i8
  %3 = llvm.and %2, %1 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def slt_or_not_max_logical_before := [llvm|
{
^0(%arg60 : i8, %arg61 : i8):
  %0 = llvm.mlir.constant(127 : i8) : i8
  %1 = llvm.mlir.constant(true) : i1
  %2 = llvm.icmp "slt" %arg60, %arg61 : i8
  %3 = llvm.icmp "ne" %arg60, %0 : i8
  %4 = "llvm.select"(%2, %1, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

OptionT.run in Init.Control.Option

def parseAndGeneralize
  [H : HydrableParseAndGeneralize parsedExpr genPred genExpr]
  (cfg : MedusaSynthGeneralizeConfig)
  (hExpr : Expr) (context: GeneralizeContext): TermElabM MessageData := do
    let targetWidth := 8
    let timeoutMs := 300000

    match_expr hExpr with
    | Eq w lhsExpr rhsExpr =>

          let some width ← H.getWidth w  | throwError m! "Could not determine the rewrite width from {w}"
          let startTime ← Core.liftIOCore IO.monoMsNow

          \n Input expression: {hExpr} has generalization: {pretty}"
                          | GeneralizeContext.Tactic _name =>
                            match cfg.output with
                            | .thmStmt =>
                              let name := Name.mkSimple "foo"
                              pure m! "{H.prettifyAsTheorem name res allVariables widthVals}"
                            | .sexpr =>
                              throwError (H.prettifyAsSexpr res allVariables) widthVals|> format
            | none => throwError m! "Could not generalize {bvLogicalExpr}"
    | _ => throwError m!"The top level constructor is not an equality predicate in {hExpr}"

def ashrslt_03_03_after := [llvm|
{
^0(%arg234 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def lshrugt_02_01_after := [llvm|
{
^0(%arg398 : i4):
  %0 = llvm.mlir.constant(0 : i4) : i4
  %1 = llvm.icmp "slt" %arg398, %0 : i4
  "llvm.return"(%1) : (i1) -> ()
}
]

def test_shl_nuw__nuw_is_safe_after := [llvm|
{
^0(%arg80 : i32, %arg81 : i64):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.mlir.constant(-8 : i32) : i32
  %2 = llvm.shl %arg80, %0 : i32
  %3 = llvm.and %2, %1 : i32
  %4 = llvm.zext nneg %3 : i32 to i64
  %5 = llvm.ashr %arg81, %4 : i64
  "llvm.return"(%5) : (i64) -> ()
}
]

def lshrugt_01_05_exact_before := [llvm|
{
^0(%arg216 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(5 : i4) : i4
  %2 = llvm.lshr exact %arg216, %0 : i4
  %3 = llvm.icmp "ugt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def or_or_and_pat4_before := [llvm|
{
^0(%arg62 : i8, %arg63 : i8, %arg64 : i8, %arg65 : i8):
  %0 = llvm.mlir.constant(42 : i8) : i8
  %1 = llvm.udiv %0, %arg64 : i8
  %2 = llvm.and %arg62, %arg63 : i8
  %3 = llvm.and %arg65, %arg63 : i8
  %4 = llvm.or %1, %3 : i8
  %5 = llvm.or %4, %2 : i8
  "llvm.return"(%5) : (i8) -> ()
}
]

def Term.bcard (t : Term) : Nat :=
  match t with
  | .ofNat _w _n => 0
  | .var _v _w => 0
  | .add _w a b => max (Term.bcard a) (Term.bcard b)
  | .zext a _wnew => (Term.bcard a)
  | .sext a _wnew => (Term.bcard a)
  | .setWidth a _wnew => (Term.bcard a)
  | .bor _w a b => (max (Term.bcard a) (Term.bcard b))
  | .band _w a b => (max (Term.bcard a) (Term.bcard b))
  | .bxor _w a b => (max (Term.bcard a) (Term.bcard b))
  | .bnot _w a => (Term.bcard a)
  | .boolVar v => v + 1
  | .boolConst _b => 0
  | .shiftl _w a _k => (Term.bcard a)
  | bvOfBool b => b.bcard
  | binWidthRel _k _wa _wb => 0
  | binRel _k _w a b => max (Term.bcard a) (Term.bcard b)
  | or p1 p2 => max (Term.bcard p1) (Term.bcard p2)
  | and p1 p2 => max (Term.bcard p1) (Term.bcard p2)
  | pvar _v => 0
  | boolBinRel _k a b => max (a.bcard) (b.bcard)

def masked_icmps_mask_notallzeros_bmask_mixed_negated_0_logical_after := [llvm|
{
^0(%arg73 : i32):
  %0 = llvm.mlir.constant(12 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(3 : i32) : i32
  %3 = llvm.mlir.constant(1 : i32) : i32
  %4 = llvm.and %arg73, %0 : i32
  %5 = llvm.icmp "eq" %4, %1 : i32
  %6 = llvm.and %arg73, %2 : i32
  %7 = llvm.icmp "ne" %6, %3 : i32
  %8 = llvm.or %5, %7 : i1
  "llvm.return"(%8) : (i1) -> ()
}
]

def prove_exact_with_high_mask_after := [llvm|
{
^0(%arg8 : i8, %arg9 : i8):
  %0 = llvm.mlir.constant(2 : i8) : i8
  %1 = llvm.mlir.constant(-2 : i8) : i8
  %2 = llvm.ashr %arg8, %0 : i8
  %3 = llvm.and %2, %1 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def liRiscv_26 := [LV| {
  ^entry ():
    %0 = "li"() {imm = -26 : !i64} : (!i64) -> (!i64)
    %1 = "builtin.unrealized_conversion_cast"(%0) : (!i64) -> (i64)
    llvm.return %1 : i64
  }]

def test47_before := [llvm|
{
^0(%arg139 : i8):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.sext %arg139 : i8 to i32
  %2 = llvm.or %1, %0 : i32
  %3 = llvm.zext %2 : i32 to i64
  "llvm.return"(%3) : (i64) -> ()
}
]

def lshrult_01_09_exact_before := [llvm|
{
^0(%arg140 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(-7 : i4) : i4
  %2 = llvm.lshr exact %arg140, %0 : i4
  %3 = llvm.icmp "ult" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def ConcreteCliTest.printSignature (test : ConcreteCliTest) : String :=
  s!"{test.context.toList.reverse} → {test.ty}"

def icmp_slt_0_and_icmp_sge_neg1_i64_fail_after := [llvm|
{
^0(%arg59 : i64):
  %0 = llvm.mlir.constant(-2) : i64
  %1 = llvm.mlir.constant(62) : i64
  %2 = llvm.mlir.constant(1) : i64
  %3 = llvm.mlir.constant(0) : i64
  %4 = llvm.icmp "sgt" %arg59, %0 : i64
  %5 = llvm.lshr %arg59, %1 : i64
  %6 = llvm.and %5, %2 : i64
  %7 = "llvm.select"(%4, %6, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i64, i64) -> i64
  "llvm.return"(%7) : (i64) -> ()
}
]

def PR60818_eq_after := [llvm|
{
^0(%arg4 : i32):
  %0 = llvm.mlir.constant(2147483647 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.and %arg4, %0 : i32
  %3 = llvm.icmp "eq" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

@[simp_denote] def if_ {Γ : Ctxt _} {t t': Arith.Ty}
  (cond : Var Γ Arith.Ty.bool) (v : Var Γ t) (then_ else_ : Com ScfArith ⟨[t]⟩ .impure t') :
    Expr ScfArith Γ .impure t' :=
  Expr.mk
    (op := .if t t')
    (ty_eq := rfl)
    (eff_le := by admit /- proof elided -/
    )
    (args := .cons cond <| .cons v .nil)
    (regArgs := HVector.cons then_ <| HVector.cons else_ <| HVector.nil)

def no_shift_no_xor_multiuse_cmp_xor_before := [llvm|
{
^0(%arg56 : i32, %arg57 : i32, %arg58 : i32, %arg59 : i32):
  %0 = llvm.mlir.constant(4096 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.and %arg56, %0 : i32
  %3 = llvm.icmp "eq" %2, %1 : i32
  %4 = llvm.xor %arg57, %0 : i32
  %5 = "llvm.select"(%3, %arg57, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %6 = "llvm.select"(%3, %arg58, %arg59) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %7 = llvm.mul %5, %6 : i32
  %8 = llvm.mul %7, %4 : i32
  "llvm.return"(%8) : (i32) -> ()
}
]

def not_and_and_or_no_or_commute2_and_before := [llvm|
{
^0(%arg157 : i32, %arg158 : i32, %arg159 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.or %arg158, %arg157 : i32
  %2 = llvm.xor %1, %0 : i32
  %3 = llvm.xor %arg157, %0 : i32
  %4 = llvm.and %3, %arg159 : i32
  %5 = llvm.and %4, %arg158 : i32
  %6 = llvm.or %5, %2 : i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def mul_constant_eq_before := [llvm|
{
^0(%arg140 : i32, %arg141 : i32):
  %0 = llvm.mlir.constant(5 : i32) : i32
  %1 = llvm.mul %arg140, %0 : i32
  %2 = llvm.mul %arg141, %0 : i32
  %3 = llvm.icmp "eq" %1, %2 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def sextinreg_before := [llvm|
{
^0(%arg14 : i32):
  %0 = llvm.mlir.constant(65535 : i32) : i32
  %1 = llvm.mlir.constant(-32768 : i32) : i32
  %2 = llvm.mlir.constant(32768 : i32) : i32
  %3 = llvm.and %arg14, %0 : i32
  %4 = llvm.xor %3, %1 : i32
  %5 = llvm.add %4, %2 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def add_signbit_select_shl_before := [llvm|
{
^0(%arg34 : i32, %arg35 : i1):
  %0 = llvm.mlir.constant(-65536 : i32) : i32
  %1 = llvm.mlir.constant(8 : i32) : i32
  %2 = llvm.add %arg34, %0 : i32
  %3 = "llvm.select"(%arg35, %2, %arg34) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %4 = llvm.shl %3, %1 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def zext_nneg_sext_sle_op0_narrow_before := [llvm|
{
^0(%arg50 : i8, %arg51 : i16):
  %0 = llvm.zext nneg %arg50 : i8 to i32
  %1 = llvm.sext %arg51 : i16 to i32
  %2 = llvm.icmp "sle" %0, %1 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def or_xor_tree_1110_after := [llvm|
{
^0(%arg3 : i32, %arg4 : i32, %arg5 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mul %arg3, %0 : i32
  %2 = llvm.mul %arg4, %0 : i32
  %3 = llvm.mul %arg5, %0 : i32
  %4 = llvm.xor %1, %2 : i32
  %5 = llvm.or %4, %3 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def select_exact_lshr_icmp_const_after := [llvm|
{
^0(%arg146 : i32):
  %0 = llvm.mlir.constant(5 : i32) : i32
  %1 = llvm.lshr %arg146, %0 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def test_add_nuw__nsw_is_safe_after := [llvm|
{
^0(%arg38 : i32):
  %0 = llvm.mlir.constant(-2147483648 : i32) : i32
  %1 = llvm.mlir.constant(1 : i32) : i32
  %2 = llvm.or %arg38, %0 : i32
  %3 = llvm.add %2, %1 overflow<nsw> : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def xor_logic_and_or1_after := [llvm|
{
^0(%arg18 : i1, %arg19 : i1, %arg20 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.xor %arg19, %0 : i1
  %2 = "llvm.select"(%arg18, %1, %arg20) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%2) : (i1) -> ()
}
]

def ashrslt_02_12_after := [llvm|
{
^0(%arg241 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def zext_mul_before := [llvm|
{
^0(%arg13 : i8):
  %0 = llvm.mlir.constant(3 : i16) : i16
  %1 = llvm.zext %arg13 : i8 to i16
  %2 = llvm.mul %1, %0 : i16
  %3 = llvm.and %2, %1 : i16
  "llvm.return"(%3) : (i16) -> ()
}
]

def and_slt_to_mask_before := [llvm|
{
^0(%arg5 : i8):
  %0 = llvm.mlir.constant(-124 : i8) : i8
  %1 = llvm.mlir.constant(2 : i8) : i8
  %2 = llvm.mlir.constant(0 : i8) : i8
  %3 = llvm.icmp "slt" %arg5, %0 : i8
  %4 = llvm.and %arg5, %1 : i8
  %5 = llvm.icmp "eq" %4, %2 : i8
  %6 = llvm.and %3, %5 : i1
  "llvm.return"(%6) : (i1) -> ()
}
]

def tryFactorization_xor_lshr_lshr_after := [llvm|
{
^0(%arg37 : i32):
  %0 = llvm.mlir.constant(-8 : i32) : i32
  %1 = llvm.lshr %0, %arg37 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def lshr_C1_add_A_C2_i32_after := [llvm|
{
^0(%arg6 : i32):
  %0 = llvm.mlir.constant(65535 : i32) : i32
  %1 = llvm.mlir.constant(192 : i32) : i32
  %2 = llvm.and %arg6, %0 : i32
  %3 = llvm.shl %1, %2 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def binop_same_val_or : RISCVPeepholeRewrite [Ty.riscv (.bv)] where
  lhs := [LV| {
    ^entry (%x: !riscv.reg):
      %0 = or %x, %x : !riscv.reg
      ret %0 : !riscv.reg
  }]
  rhs := [LV| {
    ^entry (%x: !riscv.reg):
      ret %x : !riscv.reg
  }]

def main15_after := [llvm|
{
^0(%arg14 : i32):
  %0 = llvm.mlir.constant(32896 : i32) : i32
  %1 = llvm.mlir.constant(1 : i32) : i32
  %2 = llvm.mlir.constant(2 : i32) : i32
  %3 = llvm.and %arg14, %0 : i32
  %4 = llvm.icmp "eq" %3, %0 : i32
  %5 = "llvm.select"(%4, %1, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def Env.getNonLsbs {w : Nat} (env : Env (w + 1)) : Env w := env.map <| fun x => x.extractLsb' 1 w

def select_sub_icmp_bad_2_before := [llvm|
{
^0(%arg68 : i32, %arg69 : i32, %arg70 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.icmp "eq" %arg68, %0 : i32
  %2 = llvm.sub %arg70, %arg68 : i32
  %3 = "llvm.select"(%1, %2, %arg69) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def mismatched_shifts_before := [llvm|
{
^0(%arg6 : i8):
  %0 = llvm.mlir.constant(16 : i8) : i8
  %1 = llvm.mlir.constant(1 : i8) : i8
  %2 = llvm.mlir.constant(3 : i8) : i8
  %3 = llvm.shl %0, %arg6 : i8
  %4 = llvm.add %arg6, %1 : i8
  %5 = llvm.lshr %2, %4 : i8
  %6 = llvm.or %3, %5 : i8
  "llvm.return"(%6) : (i8) -> ()
}
]

def neg_of_sub_from_constant_after := [llvm|
{
^0(%arg188 : i8):
  %0 = llvm.mlir.constant(-42 : i8) : i8
  %1 = llvm.add %arg188, %0 : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def xor_icmp_to_ne_before := [llvm|
{
^0(%arg6 : i32):
  %0 = llvm.mlir.constant(4 : i32) : i32
  %1 = llvm.mlir.constant(6 : i32) : i32
  %2 = llvm.icmp "sgt" %arg6, %0 : i32
  %3 = llvm.icmp "slt" %arg6, %1 : i32
  %4 = llvm.xor %2, %3 : i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def invert_icmp_after := [llvm|
{
^0(%arg151 : i32, %arg152 : i32):
  %0 = llvm.icmp "sgt" %arg151, %arg152 : i32
  "llvm.return"(%0) : (i1) -> ()
}
]

def add_nsw_poison_constant_fold_after := [llvm|
{
^0(%arg2 : i1, %arg3 : i8):
  %0 = llvm.mlir.constant(64 : i8) : i8
  %1 = llvm.mlir.constant(-127 : i8) : i8
  %2 = llvm.add %arg3, %0 overflow<nsw> : i8
  %3 = "llvm.select"(%arg2, %2, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def not_and_and_or_no_or_commute3_after := [llvm|
{
^0(%arg148 : i32, %arg149 : i32, %arg150 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.sdiv %0, %arg150 : i32
  %3 = llvm.xor %arg148, %1 : i32
  %4 = llvm.xor %arg149, %1 : i32
  %5 = llvm.or %2, %4 : i32
  %6 = llvm.and %5, %3 : i32
  "llvm.return"(%6) : (i32) -> ()
}
]

instance : DialectPrint Handshake where
  printOpName := reprStr
  printTy := reprStr
  printAttributes _ := ""
  dialectName := "handshake"
  printReturn _ := "return"

def test93_after := [llvm|
{
^0(%arg47 : i32):
  %0 = llvm.mlir.constant(31 : i32) : i32
  %1 = llvm.ashr %arg47, %0 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def add_of_selects_after := [llvm|
{
^0(%arg2 : i1, %arg3 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = "llvm.select"(%arg2, %arg3, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%1) : (i32) -> ()
}
]

instance : AST.TransformReturn LLVM 0 := { mkReturn }

def demorgan_and_apint1_before := [llvm|
{
^0(%arg58 : i477, %arg59 : i477):
  %0 = llvm.mlir.constant(-1 : i477) : i477
  %1 = llvm.xor %arg58, %0 : i477
  %2 = llvm.xor %arg59, %0 : i477
  %3 = llvm.and %1, %2 : i477
  "llvm.return"(%3) : (i477) -> ()
}
]

def test5_before := [llvm|
{
^0(%arg192 : i1):
  %0 = llvm.zext %arg192 : i1 to i8
  %1 = llvm.zext %0 : i8 to i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def main6d_before := [llvm|
{
^0(%arg88 : i32):
  %0 = llvm.mlir.constant(7 : i32) : i32
  %1 = llvm.mlir.constant(3 : i32) : i32
  %2 = llvm.mlir.constant(16 : i32) : i32
  %3 = llvm.mlir.constant(0 : i32) : i32
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.and %arg88, %0 : i32
  %6 = llvm.icmp "ne" %5, %1 : i32
  %7 = llvm.and %arg88, %2 : i32
  %8 = llvm.icmp "eq" %7, %3 : i32
  %9 = llvm.or %6, %8 : i1
  %10 = "llvm.select"(%9, %3, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%10) : (i32) -> ()
}
]

def xor_or_xor_common_op_commute5_after := [llvm|
{
^0(%arg68 : i32, %arg69 : i32, %arg70 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg68, %0 : i32
  %2 = llvm.and %arg69, %1 : i32
  %3 = llvm.xor %2, %arg70 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def bools_logical_commute0_and2_after := [llvm|
{
^0(%arg102 : i1, %arg103 : i1, %arg104 : i1):
  %0 = "llvm.select"(%arg104, %arg103, %arg102) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def t2_commutative_after := [llvm|
{
^0(%arg20 : i8, %arg21 : i8):
  %0 = llvm.icmp "ult" %arg20, %arg21 : i8
  "llvm.return"(%0) : (i1) -> ()
}
]

def test52_before := [llvm|
{
^0(%arg132 : i64):
  %0 = llvm.mlir.constant(-32574 : i16) : i16
  %1 = llvm.mlir.constant(-25350 : i16) : i16
  %2 = llvm.trunc %arg132 : i64 to i16
  %3 = llvm.or %2, %0 : i16
  %4 = llvm.and %3, %1 : i16
  %5 = llvm.zext %4 : i16 to i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def test_shift_and_cmp_changed4_after := [llvm|
{
^0(%arg0 : i8):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def sgt_smax1_before := [llvm|
{
^0(%arg39 : i32, %arg40 : i32):
  %0 = llvm.icmp "sgt" %arg39, %arg40 : i32
  %1 = "llvm.select"(%0, %arg39, %arg40) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %2 = llvm.icmp "sgt" %1, %arg39 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def select_replace_udiv_non_speculatable_before := [llvm|
{
^0(%arg1 : i32, %arg2 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.icmp "eq" %arg1, %0 : i32
  %2 = llvm.udiv %arg2, %arg1 : i32
  %3 = "llvm.select"(%1, %2, %arg2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def masked_or_allzeroes_notoptimised_logical_after := [llvm|
{
^0(%arg116 : i32):
  %0 = llvm.mlir.constant(15 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(39 : i32) : i32
  %3 = llvm.and %arg116, %0 : i32
  %4 = llvm.icmp "eq" %3, %1 : i32
  %5 = llvm.and %arg116, %2 : i32
  %6 = llvm.icmp "eq" %5, %1 : i32
  %7 = llvm.or %4, %6 : i1
  "llvm.return"(%7) : (i1) -> ()
}
]

def ashrsgt_01_13_exact_before := [llvm|
{
^0(%arg88 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(-3 : i4) : i4
  %2 = llvm.ashr exact %arg88, %0 : i4
  %3 = llvm.icmp "sgt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def trunc_lshr_big_mask_before := [llvm|
{
^0(%arg8 : i8):
  %0 = llvm.mlir.constant(2 : i8) : i8
  %1 = llvm.mlir.constant(31 : i6) : i6
  %2 = llvm.lshr %arg8, %0 : i8
  %3 = llvm.trunc %2 : i8 to i6
  %4 = llvm.and %3, %1 : i6
  "llvm.return"(%4) : (i6) -> ()
}
]

def p0_after := [llvm|
{
^0(%arg16 : i8, %arg17 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.lshr %0, %arg17 : i8
  %2 = llvm.icmp "ugt" %arg16, %1 : i8
  "llvm.return"(%2) : (i1) -> ()
}
]

def sdiv_common_divisor_defined_cond_before := [llvm|
{
^0(%arg41 : i1, %arg42 : i5, %arg43 : i5, %arg44 : i5):
  %0 = llvm.sdiv %arg43, %arg42 : i5
  %1 = llvm.sdiv %arg44, %arg42 : i5
  %2 = "llvm.select"(%arg41, %1, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i5, i5) -> i5
  "llvm.return"(%2) : (i5) -> ()
}
]

def multiuse3_after := [llvm|
{
^0(%arg9 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(48 : i32) : i32
  %2 = llvm.mlir.constant(6 : i32) : i32
  %3 = llvm.mlir.constant(8064 : i32) : i32
  %4 = llvm.mlir.constant(15 : i32) : i32
  %5 = llvm.lshr %arg9, %0 : i32
  %6 = llvm.and %5, %1 : i32
  %7 = llvm.shl %arg9, %2 : i32
  %8 = llvm.and %7, %3 : i32
  %9 = llvm.lshr %arg9, %0 : i32
  %10 = llvm.and %9, %4 : i32
  %11 = llvm.or disjoint %6, %10 : i32
  %12 = llvm.or disjoint %11, %8 : i32
  "llvm.return"(%12) : (i32) -> ()
}
]

def xor_or_xor_common_op_commute6_before := [llvm|
{
^0(%arg65 : i32, %arg66 : i32, %arg67 : i32):
  %0 = llvm.xor %arg67, %arg65 : i32
  %1 = llvm.or %arg65, %arg66 : i32
  %2 = llvm.xor %1, %0 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

IO.FS.Mode in Init.System.IO

def lshrult_01_08_after := [llvm|
{
^0(%arg359 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def Var.tryDelete? [TyDenote Ty] {Γ Γ' : Ctxt Ty} {delv : DeleteRange Γ}
  (DEL : Deleted Γ delv Γ') (vs : HVector Γ.Var β) :
    Option { v' : HVector Γ'.Var β // vs = v'.map DEL.toHom } := do
  match vs with
  | .nil => some ⟨.nil, rfl⟩
  | v ::ₕ vs => do
      let ⟨v, hv⟩ ← tryDeleteOne? DEL v
      let ⟨vs, hvs⟩ ← tryDelete? DEL vs
      return ⟨v ::ₕ vs, by admit /- proof elided -/
      ⟩

def lshr_32_add_known_32_leading_zeroes_after := [llvm|
{
^0(%arg15 : i64, %arg16 : i64):
  %0 = llvm.mlir.constant(4294967295) : i64
  %1 = llvm.mlir.constant(32) : i64
  %2 = llvm.and %arg15, %0 : i64
  %3 = llvm.and %arg16, %0 : i64
  %4 = llvm.add %2, %3 overflow<nsw,nuw> : i64
  %5 = llvm.lshr %4, %1 : i64
  "llvm.return"(%5) : (i64) -> ()
}
]

def bitwise_and_logical_and_masked_icmp_allzeros_before := [llvm|
{
^0(%arg147 : i1, %arg148 : i32):
  %0 = llvm.mlir.constant(8 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(false) : i1
  %3 = llvm.mlir.constant(7 : i32) : i32
  %4 = llvm.and %arg148, %0 : i32
  %5 = llvm.icmp "eq" %4, %1 : i32
  %6 = "llvm.select"(%5, %arg147, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %7 = llvm.and %arg148, %3 : i32
  %8 = llvm.icmp "eq" %7, %1 : i32
  %9 = llvm.and %6, %8 : i1
  "llvm.return"(%9) : (i1) -> ()
}
]

def mulh_to_lshr_256 : RISCVPeepholeRewrite [Ty.riscv (.bv)] where
  lhs := [LV| {
    ^entry (%x: !riscv.reg):
      %c = li (256) : !riscv.reg
      %0 = mulh %c, %x : !riscv.reg
      ret %0 : !riscv.reg
  }]
  rhs := [LV| {
    ^entry (%x: !riscv.reg):
      %c = li (56) : !riscv.reg
      %0 = sra %x, %c : !riscv.reg
      ret %0 : !riscv.reg
  }]

Iff in Init.Core

def test_mul__nuw_is_safe_before := [llvm|
{
^0(%arg8 : i32):
  %0 = llvm.mlir.constant(268435457 : i32) : i32
  %1 = llvm.mlir.constant(268435456 : i32) : i32
  %2 = llvm.mlir.constant(9 : i32) : i32
  %3 = llvm.mlir.constant(-1879048192 : i32) : i32
  %4 = llvm.and %arg8, %0 : i32
  %5 = llvm.icmp "eq" %4, %1 : i32
  %6 = llvm.mul %4, %2 : i32
  %7 = "llvm.select"(%5, %3, %6) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%7) : (i32) -> ()
}
]

def samesign_different_sign_bittest2_before := [llvm|
{
^0(%arg127 : i32, %arg128 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.and %arg127, %arg128 : i32
  %2 = llvm.icmp "slt" %1, %0 : i32
  %3 = llvm.or %arg127, %arg128 : i32
  %4 = llvm.icmp "sge" %3, %0 : i32
  %5 = llvm.or %2, %4 : i1
  "llvm.return"(%5) : (i1) -> ()
}
]

def test_sext2_after := [llvm|
{
^0(%arg47 : i1, %arg48 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = "llvm.select"(%arg48, %0, %arg47) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %2 = llvm.sext %1 : i1 to i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def or_or_and_complex_after := [llvm|
{
^0(%arg82 : i64):
  %0 = llvm.mlir.constant(8) : i64
  %1 = llvm.mlir.constant(71777214294589695) : i64
  %2 = llvm.mlir.constant(-71777214294589696) : i64
  %3 = llvm.lshr %arg82, %0 : i64
  %4 = llvm.shl %arg82, %0 : i64
  %5 = llvm.and %3, %1 : i64
  %6 = llvm.and %4, %2 : i64
  %7 = llvm.or disjoint %5, %6 : i64
  "llvm.return"(%7) : (i64) -> ()
}
]

def test19_before := [llvm|
{
^0(%arg13 : i1, %arg14 : i1):
  %0 = llvm.zext %arg13 : i1 to i32
  %1 = llvm.zext %arg14 : i1 to i32
  %2 = llvm.icmp "eq" %0, %1 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def llvm_const_lower_riscv_li0 : LLVMPeepholeRewriteRefine 64 [] :=
  {lhs := constLLVM0, rhs:= liRiscv0,
   correct := by admit /- proof elided -/

def logical_and_icmps2_before := [llvm|
{
^0(%arg34 : i32, %arg35 : i1):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.mlir.constant(false) : i1
  %2 = llvm.mlir.constant(10086 : i32) : i32
  %3 = llvm.icmp "slt" %arg34, %0 : i32
  %4 = "llvm.select"(%arg35, %3, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %5 = llvm.icmp "eq" %arg34, %2 : i32
  %6 = "llvm.select"(%4, %5, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%6) : (i1) -> ()
}
]

def invert_icmp_before := [llvm|
{
^0(%arg151 : i32, %arg152 : i32):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.icmp "sle" %arg151, %arg152 : i32
  %2 = llvm.xor %1, %0 : i1
  "llvm.return"(%2) : (i1) -> ()
}
]

def positive_biggerashr_ashrexact_before := [llvm|
{
^0(%arg40 : i8):
  %0 = llvm.mlir.constant(6 : i8) : i8
  %1 = llvm.mlir.constant(3 : i8) : i8
  %2 = llvm.ashr exact %arg40, %0 : i8
  %3 = llvm.shl %2, %1 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def scalar_i32_lshr_and_negC_eq_X_is_constant2_after := [llvm|
{
^0(%arg8 : i32):
  %0 = llvm.mlir.constant(25 : i32) : i32
  %1 = llvm.icmp "ugt" %arg8, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def fold_ne_rhs_before := [llvm|
{
^0(%arg17 : i8, %arg18 : i8):
  %0 = llvm.mlir.constant(123 : i8) : i8
  %1 = llvm.mlir.constant(-1 : i8) : i8
  %2 = llvm.mlir.constant(0 : i8) : i8
  %3 = llvm.xor %arg18, %0 : i8
  %4 = llvm.shl %1, %arg17 : i8
  %5 = llvm.and %3, %4 : i8
  %6 = llvm.icmp "ne" %5, %2 : i8
  "llvm.return"(%6) : (i1) -> ()
}
]

def ripple_nsw1_before := [llvm|
{
^0(%arg23 : i16, %arg24 : i16):
  %0 = llvm.mlir.constant(1 : i16) : i16
  %1 = llvm.mlir.constant(-16385 : i16) : i16
  %2 = llvm.and %arg24, %0 : i16
  %3 = llvm.and %arg23, %1 : i16
  %4 = llvm.add %2, %3 : i16
  "llvm.return"(%4) : (i16) -> ()
}
]

def not_bool_add_lshr_before := [llvm|
{
^0(%arg12 : i2, %arg13 : i2):
  %0 = llvm.mlir.constant(2 : i4) : i4
  %1 = llvm.zext %arg12 : i2 to i4
  %2 = llvm.zext %arg13 : i2 to i4
  %3 = llvm.add %1, %2 : i4
  %4 = llvm.lshr %3, %0 : i4
  "llvm.return"(%4) : (i4) -> ()
}
]

def ule_bignum_after := [llvm|
{
^0(%arg145 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.icmp "eq" %arg145, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def ashrsgt_02_06_before := [llvm|
{
^0(%arg295 : i4):
  %0 = llvm.mlir.constant(2 : i4) : i4
  %1 = llvm.mlir.constant(6 : i4) : i4
  %2 = llvm.ashr %arg295, %0 : i4
  %3 = llvm.icmp "sgt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

@[simps]
def proj (M: NFA (BitVec n1) σ) (f : Fin n2 → Fin n1) : NFA (BitVec n2) σ where
  start := M.start
  accept := M.accept
  step q a := { q' | ∃ a', a'.transport f = a ∧ q' ∈ M.step q a' }

def shl_lshr_pow2_const_negative_overflow2_after := [llvm|
{
^0(%arg69 : i16):
  %0 = llvm.mlir.constant(0 : i16) : i16
  "llvm.return"(%0) : (i16) -> ()
}
]

def or_not_xor_common_op_commute0_before := [llvm|
{
^0(%arg107 : i4, %arg108 : i4, %arg109 : i4):
  %0 = llvm.mlir.constant(-1 : i4) : i4
  %1 = llvm.xor %arg107, %0 : i4
  %2 = llvm.xor %arg107, %arg108 : i4
  %3 = llvm.or %1, %arg109 : i4
  %4 = llvm.or %3, %2 : i4
  "llvm.return"(%4) : (i4) -> ()
}
]

def llvm_trunc_riscv_32_to_8_nuw_nsw : LLVMPeepholeRewriteRefine 8 [Ty.llvm (.bitvec 32)] :=
  {lhs:= trunc_llvm_32_to_8_nsw_nuw, rhs:= trunc_riscv_32_to_8_nsw_nuw}

def llvm_const_lower_riscv_li_37 : LLVMPeepholeRewriteRefine 64 [] :=
  {lhs := constLLVM_37, rhs:= liRiscv_37,
   correct := by admit /- proof elided -/

def lshr_x_by_const_cmp_x_before := [llvm|
{
^0(%arg11 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.lshr %arg11, %0 : i32
  %2 = llvm.icmp "eq" %1, %arg11 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def ule_swap_and_min_logical_after := [llvm|
{
^0(%arg196 : i8, %arg197 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.icmp "eq" %arg196, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def and_xor_commute3_before := [llvm|
{
^0(%arg151 : i32, %arg152 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.udiv %0, %arg151 : i32
  %2 = llvm.udiv %0, %arg152 : i32
  %3 = llvm.and %2, %1 : i32
  %4 = llvm.xor %3, %2 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def scalar_i32_shl_ult_const_before := [llvm|
{
^0(%arg15 : i32):
  %0 = llvm.mlir.constant(11 : i32) : i32
  %1 = llvm.mlir.constant(131072 : i32) : i32
  %2 = llvm.shl %arg15, %0 : i32
  %3 = llvm.icmp "ult" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def t3_ult_sgt_neg1_before := [llvm|
{
^0(%arg57 : i32, %arg58 : i32, %arg59 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.mlir.constant(65536 : i32) : i32
  %2 = llvm.icmp "sgt" %arg57, %0 : i32
  %3 = "llvm.select"(%2, %arg59, %arg58) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %4 = llvm.icmp "ult" %arg57, %1 : i32
  %5 = "llvm.select"(%4, %arg57, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def test23_before := [llvm|
{
^0(%arg172 : i32):
  %0 = llvm.trunc %arg172 : i32 to i16
  %1 = llvm.zext %0 : i16 to i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def icmp_shl_ule_2_after := [llvm|
{
^0(%arg8 : i8):
  %0 = llvm.mlir.constant(42 : i8) : i8
  %1 = llvm.mlir.constant(-1 : i8) : i8
  %2 = llvm.add %arg8, %0 : i8
  %3 = llvm.icmp "sgt" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def subMax'Mask (pmask : BitVec o) (qmask : BitVec o) : BitVec o :=
    let added := unaryAdd pmask qmask
    unaryDouble added |> unaryIncr

private def tyi32NoGap : MLIRTy := [mlir_type| i32]

def t2_commutative_before := [llvm|
{
^0(%arg20 : i8, %arg21 : i8):
  %0 = llvm.sub %arg20, %arg21 : i8
  %1 = llvm.icmp "uge" %arg20, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

abbrev HasBool (d : Dialect) [TyDenote d.Ty] [DialectSignature d] : Type := HasTy d Bool

def no_shift_xor_multiuse_cmp_xor_before := [llvm|
{
^0(%arg44 : i32, %arg45 : i32, %arg46 : i32, %arg47 : i32):
  %0 = llvm.mlir.constant(4096 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.and %arg44, %0 : i32
  %3 = llvm.icmp "ne" %1, %2 : i32
  %4 = llvm.xor %arg45, %0 : i32
  %5 = "llvm.select"(%3, %arg45, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %6 = "llvm.select"(%3, %arg46, %arg47) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %7 = llvm.mul %5, %6 : i32
  %8 = llvm.mul %7, %4 : i32
  "llvm.return"(%8) : (i32) -> ()
}
]

def t9_highest_bit_before := [llvm|
{
^0(%arg25 : i32, %arg26 : i64, %arg27 : i32):
  %0 = llvm.mlir.constant(64 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.mlir.constant(0 : i32) : i32
  %3 = llvm.sub %0, %arg27 : i32
  %4 = llvm.shl %arg25, %3 : i32
  %5 = llvm.add %arg27, %1 : i32
  %6 = llvm.zext %5 : i32 to i64
  %7 = llvm.lshr %arg26, %6 : i64
  %8 = llvm.trunc %7 : i64 to i32
  %9 = llvm.and %4, %8 : i32
  %10 = llvm.icmp "ne" %9, %2 : i32
  "llvm.return"(%10) : (i1) -> ()
}
]

def ashrsgt_01_07_before := [llvm|
{
^0(%arg310 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(7 : i4) : i4
  %2 = llvm.ashr %arg310, %0 : i4
  %3 = llvm.icmp "sgt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def udiv {w : Nat} (x y : IntW w) (flag : ExactFlag := {exact := false}) : IntW w := do
  let x' ← x
  let y' ← y
  if flag.exact ∧ x'.umod y' ≠ 0 then
    .poison
  else
    udiv? x' y'

def exact_lshr_ne_before := [llvm|
{
^0(%arg157 : i8):
  %0 = llvm.mlir.constant(4 : i8) : i8
  %1 = llvm.mlir.constant(1 : i8) : i8
  %2 = llvm.lshr exact %0, %arg157 : i8
  %3 = llvm.icmp "ne" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def PR2330_after := [llvm|
{
^0(%arg0 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.icmp "ne" %arg0, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def test_before := [llvm|
{
^0(%arg2 : i64, %arg3 : i1):
  %0 = llvm.mlir.constant(16) : i64
  %1 = llvm.mlir.constant(8) : i64
  %2 = llvm.mlir.constant(0) : i64
  %3 = "llvm.select"(%arg3, %0, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i64, i64) -> i64
  %4 = llvm.udiv %arg2, %3 : i64
  %5 = "llvm.select"(%arg3, %1, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i64, i64) -> i64
  %6 = llvm.udiv %arg2, %5 : i64
  %7 = llvm.add %4, %6 : i64
  "llvm.return"(%7) : (i64) -> ()
}
]

def udiv_exact_eq_1_before := [llvm|
{
^0(%arg10 : i8, %arg11 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.udiv exact %arg10, %arg11 : i8
  %2 = llvm.icmp "ne" %1, %0 : i8
  "llvm.return"(%2) : (i1) -> ()
}
]

def ashrsgt_02_12_exact_after := [llvm|
{
^0(%arg73 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

IO.println in Init.System.IO

def fold_sext_to_and_wrong4_after := [llvm|
{
^0(%arg6 : i8):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def Eqn.reflectEqZero (w : Nat) (eqn : Eqn) (env : Env w) : Prop :=
  Eqn.reflect eqn env = BitVec.ofInt w 0

def ashrsgt_01_12_before := [llvm|
{
^0(%arg305 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(-4 : i4) : i4
  %2 = llvm.ashr %arg305, %0 : i4
  %3 = llvm.icmp "sgt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def icmp_and_ashr_multiuse_logical_after := [llvm|
{
^0(%arg4 : i32):
  %0 = llvm.mlir.constant(240 : i32) : i32
  %1 = llvm.mlir.constant(224 : i32) : i32
  %2 = llvm.mlir.constant(496 : i32) : i32
  %3 = llvm.mlir.constant(432 : i32) : i32
  %4 = llvm.and %arg4, %0 : i32
  %5 = llvm.icmp "ne" %4, %1 : i32
  %6 = llvm.and %arg4, %2 : i32
  %7 = llvm.icmp "ne" %6, %3 : i32
  %8 = llvm.and %5, %7 : i1
  "llvm.return"(%8) : (i1) -> ()
}
]

def test15_after := [llvm|
{
^0(%arg44 : i8, %arg45 : i8):
  %0 = llvm.mlir.constant(33 : i8) : i8
  %1 = llvm.xor %arg45, %arg44 : i8
  %2 = llvm.xor %arg44, %arg45 : i8
  %3 = llvm.xor %2, %0 : i8
  %4 = llvm.and %1, %3 : i8
  %5 = llvm.mul %4, %3 : i8
  "llvm.return"(%5) : (i8) -> ()
}
]

Function.Injective in Init.Data.Function

def masked_icmps_mask_notallzeros_bmask_mixed_7b_logical_after := [llvm|
{
^0(%arg75 : i32):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def land_lor_right1_before := [llvm|
{
^0(%arg46 : i1, %arg47 : i1):
  %0 = llvm.mlir.constant(false) : i1
  %1 = llvm.mlir.constant(true) : i1
  %2 = "llvm.select"(%arg46, %arg47, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %3 = "llvm.select"(%arg46, %1, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def or_and2_after := [llvm|
{
^0(%arg138 : i1, %arg139 : i1, %arg140 : i1):
  %0 = llvm.mlir.constant(false) : i1
  %1 = llvm.mlir.constant(true) : i1
  %2 = "llvm.select"(%arg140, %arg139, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %3 = "llvm.select"(%arg138, %1, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def lshrugt_02_15_before := [llvm|
{
^0(%arg384 : i4):
  %0 = llvm.mlir.constant(2 : i4) : i4
  %1 = llvm.mlir.constant(-1 : i4) : i4
  %2 = llvm.lshr %arg384, %0 : i4
  %3 = llvm.icmp "ugt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def PR42691_4_logical_after := [llvm|
{
^0(%arg336 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.icmp "slt" %arg336, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def t_0_10_after := [llvm|
{
^0(%arg14 : i8):
  %0 = llvm.mlir.constant(10 : i8) : i8
  %1 = llvm.and %arg14, %0 : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def test67_before := [llvm|
{
^0(%arg113 : i1, %arg114 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(24 : i32) : i32
  %2 = llvm.mlir.constant(-16777216 : i32) : i32
  %3 = llvm.mlir.constant(0 : i8) : i8
  %4 = llvm.zext %arg113 : i1 to i32
  %5 = llvm.xor %4, %0 : i32
  %6 = llvm.and %arg114, %5 : i32
  %7 = llvm.shl %6, %1 overflow<nsw,nuw> : i32
  %8 = llvm.xor %7, %2 : i32
  %9 = llvm.ashr exact %8, %1 : i32
  %10 = llvm.trunc %9 : i32 to i8
  %11 = llvm.icmp "eq" %10, %3 : i8
  "llvm.return"(%11) : (i1) -> ()
}
]

def lshrult_01_06_after := [llvm|
{
^0(%arg361 : i4):
  %0 = llvm.mlir.constant(-4 : i4) : i4
  %1 = llvm.icmp "ult" %arg361, %0 : i4
  "llvm.return"(%1) : (i1) -> ()
}
]

RV64.sltu in RISCV.Instructions

def lshrult_03_04_exact_before := [llvm|
{
^0(%arg113 : i4):
  %0 = llvm.mlir.constant(3 : i4) : i4
  %1 = llvm.mlir.constant(4 : i4) : i4
  %2 = llvm.lshr exact %arg113, %0 : i4
  %3 = llvm.icmp "ult" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def no_shift_no_xor_multiuse_xor_after := [llvm|
{
^0(%arg138 : i32, %arg139 : i32):
  %0 = llvm.mlir.constant(4096 : i32) : i32
  %1 = llvm.and %arg138, %0 : i32
  %2 = llvm.xor %arg139, %0 : i32
  %3 = llvm.xor %arg139, %1 : i32
  %4 = llvm.mul %3, %2 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def or_i32_test : LLVMPeepholeRewriteRefine 32 [Ty.llvm (.bitvec 32), Ty.llvm (.bitvec 32)] where
  lhs := or_llvm_i32
  rhs := or_riscv_i32

def t15_before := [llvm|
{
^0(%arg198 : i32, %arg199 : i32):
  %0 = llvm.shl %arg198, %arg199 overflow<nuw> : i32
  %1 = llvm.udiv %0, %arg198 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def test3a_after := [llvm|
{
^0(%arg100 : i32):
  %0 = llvm.mlir.constant(7 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.and %arg100, %0 : i32
  %3 = llvm.icmp "ne" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def snd {Γ : Ctxt _} (a : Γ.Var (.tokenstream2)) : Expr (DC) Γ .pure (.tokenstream)  :=
  Expr.mk
    (op := .snd)
    (ty_eq := rfl)
    (eff_le := by admit /- proof elided -/
    )
    (args := .cons a <| .nil)
    (regArgs := .nil)

def ashrslt_03_14_after := [llvm|
{
^0(%arg223 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def sext_non_bool_xor_sub_1_after := [llvm|
{
^0(%arg18 : i64, %arg19 : i8):
  %0 = llvm.sext %arg19 : i8 to i64
  %1 = llvm.xor %arg18, %0 : i64
  %2 = llvm.sub %1, %0 : i64
  "llvm.return"(%2) : (i64) -> ()
}
]

def a_before := [llvm|
{
^0(%arg48 : i1, %arg49 : i1):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.mlir.constant(1 : i32) : i32
  %2 = llvm.zext %arg48 : i1 to i32
  %3 = llvm.zext %arg49 : i1 to i32
  %4 = llvm.sub %0, %3 : i32
  %5 = llvm.add %2, %1 : i32
  %6 = llvm.add %5, %4 : i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def test_before := [llvm|
{
^0(%arg0 : i8):
  %0 = llvm.mlir.constant(8 : i32) : i32
  %1 = llvm.sext %arg0 : i8 to i32
  %2 = llvm.ashr %1, %0 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def lshr_exact_ne_0_after := [llvm|
{
^0(%arg121 : i32, %arg122 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.icmp "ne" %arg121, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def ugt_swap_and_not_min_commute_before := [llvm|
{
^0(%arg66 : i8, %arg67 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.icmp "ult" %arg67, %arg66 : i8
  %2 = llvm.icmp "ne" %arg66, %0 : i8
  %3 = llvm.and %2, %1 : i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def mul9_low_after := [llvm|
{
^0(%arg8 : i9, %arg9 : i9):
  %0 = llvm.mlir.constant(15 : i9) : i9
  %1 = llvm.mlir.constant(4 : i9) : i9
  %2 = llvm.and %arg8, %0 : i9
  %3 = llvm.lshr %arg8, %1 : i9
  %4 = llvm.and %arg9, %0 : i9
  %5 = llvm.lshr %arg9, %1 : i9
  %6 = llvm.mul %5, %2 overflow<nuw> : i9
  %7 = llvm.mul %4, %3 overflow<nuw> : i9
  %8 = llvm.mul %4, %2 overflow<nsw,nuw> : i9
  %9 = llvm.add %6, %7 : i9
  %10 = llvm.shl %9, %1 : i9
  %11 = llvm.add %10, %8 : i9
  "llvm.return"(%11) : (i9) -> ()
}
]

def and_umin_after := [llvm|
{
^0(%arg5 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

def test_before := [llvm|
{
^0(%arg0 : i32):
  %0 = llvm.mlir.constant(4 : i32) : i32
  %1 = llvm.mlir.constant(1073741824 : i32) : i32
  %2 = llvm.udiv %arg0, %0 : i32
  %3 = llvm.icmp "ult" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

Fin.natAdd in Init.Data.Fin.Basic

def sub_select_sext_op_swapped_non_const_args_before := [llvm|
{
^0(%arg6 : i1, %arg7 : i6, %arg8 : i6):
  %0 = "llvm.select"(%arg6, %arg7, %arg8) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i6, i6) -> i6
  %1 = llvm.sext %arg6 : i1 to i6
  %2 = llvm.sub %1, %0 : i6
  "llvm.return"(%2) : (i6) -> ()
}
]

instance : AST.TransformExpr (MetaLLVM φ) φ := { mkExpr }

def scalar_i32_signbit_shl_and_eq_X_is_constant1_after := [llvm|
{
^0(%arg5 : i32):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

Union in Init.Core

instance : Lean.ToExpr RegIndex := inherit

def test34_before := [llvm|
{
^0(%arg248 : i32, %arg249 : i32):
  %0 = llvm.or %arg249, %arg248 : i32
  %1 = llvm.and %0, %arg249 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def nonexact_lshr_eq_noexactlog_after := [llvm|
{
^0(%arg136 : i8):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def ashrslt_03_04_before := [llvm|
{
^0(%arg233 : i4):
  %0 = llvm.mlir.constant(3 : i4) : i4
  %1 = llvm.mlir.constant(4 : i4) : i4
  %2 = llvm.ashr %arg233, %0 : i4
  %3 = llvm.icmp "slt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def test_shl_nsw__none_are_safe_after := [llvm|
{
^0(%arg66 : i32, %arg67 : i64):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.mlir.constant(-8 : i32) : i32
  %2 = llvm.shl %arg66, %0 : i32
  %3 = llvm.and %2, %1 : i32
  %4 = llvm.zext nneg %3 : i32 to i64
  %5 = llvm.ashr %arg67, %4 : i64
  "llvm.return"(%5) : (i64) -> ()
}
]

def test20_before := [llvm|
{
^0(%arg277 : i8):
  %0 = llvm.mlir.constant(7 : i8) : i8
  %1 = llvm.mlir.constant(1 : i8) : i8
  %2 = llvm.lshr %arg277, %0 : i8
  %3 = llvm.and %2, %1 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def test_eq_11_and_15_add_10_before := [llvm|
{
^0(%arg1 : i8):
  %0 = llvm.mlir.constant(10 : i8) : i8
  %1 = llvm.mlir.constant(15 : i8) : i8
  %2 = llvm.mlir.constant(11 : i8) : i8
  %3 = llvm.add %arg1, %0 : i8
  %4 = llvm.and %3, %1 : i8
  %5 = llvm.icmp "eq" %4, %2 : i8
  "llvm.return"(%5) : (i1) -> ()
}
]

def mkOutputAssignCircuitLeN {arity : Type _}
  [DecidableEq arity]
  [Fintype arity]
  [Hashable arity]
  (p : FSM arity) (n : Nat) :
  Circuit (Vars p.α arity (n + 1)) :=
    let ixs := List.range (n + 1) |>.attach
    let circs := ixs.map fun ⟨i, hi⟩ =>
      mkOutputAssignCircuitN p i |>.map (fun v => v.castLe (by admit /- proof elided -/
      ))
    Circuit.bigOr circs

def test_sge_xor_before := [llvm|
{
^0(%arg38 : i32, %arg39 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg38, %0 : i32
  %2 = llvm.xor %1, %arg39 : i32
  %3 = llvm.icmp "sge" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def lshr_and_before := [llvm|
{
^0(%arg59 : i64, %arg60 : i64):
  %0 = llvm.mlir.constant(42) : i64
  %1 = llvm.mlir.constant(5) : i64
  %2 = llvm.mlir.constant(7) : i64
  %3 = llvm.srem %arg60, %0 : i64
  %4 = llvm.lshr %arg59, %1 : i64
  %5 = llvm.and %3, %4 : i64
  %6 = llvm.lshr %5, %2 : i64
  "llvm.return"(%6) : (i64) -> ()
}
]

@[simp_denote]
def riscvArgsFromHybrid : {tys : List RISCV64.RV64.Ty} →
  HVector TyDenote.toType (tys.map LLVMRiscV.Ty.riscv) → HVector TyDenote.toType tys
  | [], .nil => .nil
  | _ :: _, .cons x xs => .cons x (riscvArgsFromHybrid xs)

def ashrsgt_03_06_after := [llvm|
{
^0(%arg279 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

inductive Ty2
  | bitvec (w : Nat) : Ty2
deriving Inhabited, DecidableEq, Repr, Lean.ToExpr

def and_ne_with_diff_one_signed_after := [llvm|
{
^0(%arg348 : i64):
  %0 = llvm.mlir.constant(-1) : i64
  %1 = llvm.mlir.constant(-2) : i64
  %2 = llvm.add %arg348, %0 : i64
  %3 = llvm.icmp "ult" %2, %1 : i64
  "llvm.return"(%3) : (i1) -> ()
}
]

def or_disjoint_with_xor_after := [llvm|
{
^0(%arg28 : i32, %arg29 : i32):
  "llvm.return"(%arg29) : (i32) -> ()
}
]

def test13_after := [llvm|
{
^0(%arg40 : i1, %arg41 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.xor %arg41, %0 : i1
  %2 = llvm.or %arg40, %1 : i1
  "llvm.return"(%2) : (i1) -> ()
}
]

def fold_eq_lhs_after := [llvm|
{
^0(%arg23 : i8, %arg24 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.lshr %arg24, %arg23 : i8
  %2 = llvm.icmp "eq" %1, %0 : i8
  "llvm.return"(%2) : (i1) -> ()
}
]

def main4_before := [llvm|
{
^0(%arg135 : i32):
  %0 = llvm.mlir.constant(7 : i32) : i32
  %1 = llvm.mlir.constant(48 : i32) : i32
  %2 = llvm.mlir.constant(0 : i32) : i32
  %3 = llvm.mlir.constant(1 : i32) : i32
  %4 = llvm.and %arg135, %0 : i32
  %5 = llvm.icmp "eq" %4, %0 : i32
  %6 = llvm.and %arg135, %1 : i32
  %7 = llvm.icmp "eq" %6, %1 : i32
  %8 = llvm.and %5, %7 : i1
  %9 = "llvm.select"(%8, %2, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%9) : (i32) -> ()
}
]

def negate_sext_after := [llvm|
{
^0(%arg98 : i8, %arg99 : i1):
  %0 = llvm.zext %arg99 : i1 to i8
  %1 = llvm.add %arg98, %0 : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

structure Item where
 name : String
 tac : Syntax

def cmpne_xor_cst3_before := [llvm|
{
^0(%arg16 : i32, %arg17 : i32):
  %0 = llvm.mlir.constant(10 : i32) : i32
  %1 = llvm.xor %arg16, %0 : i32
  %2 = llvm.xor %arg17, %0 : i32
  %3 = llvm.icmp "ne" %1, %2 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def test_invert_demorgan_logical_and_before := [llvm|
{
^0(%arg3 : i64, %arg4 : i64):
  %0 = llvm.mlir.constant(27) : i64
  %1 = llvm.mlir.constant(0) : i64
  %2 = llvm.mlir.constant(false) : i1
  %3 = llvm.mlir.constant(true) : i1
  %4 = llvm.icmp "eq" %arg3, %0 : i64
  %5 = llvm.icmp "eq" %arg4, %1 : i64
  %6 = "llvm.select"(%4, %5, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %7 = llvm.icmp "eq" %arg3, %1 : i64
  %8 = llvm.or %7, %6 : i1
  %9 = llvm.xor %8, %3 : i1
  "llvm.return"(%9) : (i1) -> ()
}
]

def shl_nsw_nuw_add_nuw_before := [llvm|
{
^0(%arg12 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.shl %0, %arg12 overflow<nsw,nuw> : i32
  %3 = llvm.add %2, %1 overflow<nuw> : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def irc_constants_C2MinusAPlusC1_0_neg2 : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%a: i64):
      %c1 = llvm.mlir.constant (0) : i64
      %c2 = llvm.mlir.constant (-2) : i64
      %0 = llvm.add %a, %c1 : i64
      %1 = llvm.sub %c2, %0 : i64
      llvm.return %1 : i64
  }]
  rhs := [LV| {
    ^entry (%a: i64):
      %c1 = llvm.mlir.constant (0) : i64
      %c2 = llvm.mlir.constant (-2) : i64
      %0 = llvm.sub %c2, %c1 : i64
      %1 = llvm.sub %0, %a : i64
      llvm.return %1 : i64
  }]

def src_is_mask_const_sge_after := [llvm|
{
^0(%arg45 : i8):
  %0 = llvm.mlir.constant(123 : i8) : i8
  %1 = llvm.mlir.constant(32 : i8) : i8
  %2 = llvm.xor %arg45, %0 : i8
  %3 = llvm.icmp "slt" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def or_not_xor_common_op_commute3_after := [llvm|
{
^0(%arg98 : i8, %arg99 : i8, %arg100 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.mlir.constant(-1 : i8) : i8
  %2 = llvm.sub %0, %arg100 : i8
  %3 = llvm.and %arg98, %arg99 : i8
  %4 = llvm.xor %3, %1 : i8
  %5 = llvm.or %4, %2 : i8
  "llvm.return"(%5) : (i8) -> ()
}
]

macro "[balanced_brackets|" xs:balancedBrackets "]" : term => do
  match xs.raw[0] with
  | .atom _ val => return (Lean.quote val: TSyntax `str)
  | _  => Macro.throwErrorAt xs "expected balanced bracts to have atom"

def or_and3_commuted_after := [llvm|
{
^0(%arg100 : i1, %arg101 : i1, %arg102 : i32, %arg103 : i32):
  %0 = llvm.mlir.constant(false) : i1
  %1 = llvm.mlir.constant(true) : i1
  %2 = llvm.icmp "ne" %arg102, %arg103 : i32
  %3 = "llvm.select"(%2, %arg101, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %4 = "llvm.select"(%arg100, %1, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def xor_of_icmps_to_ne_commute_after := [llvm|
{
^0(%arg28 : i64):
  %0 = llvm.mlir.constant(5) : i64
  %1 = llvm.icmp "ne" %arg28, %0 : i64
  "llvm.return"(%1) : (i1) -> ()
}
]

def constLLVM50 : Com LLVMPlusRiscV ⟨[]⟩ .pure (.llvm (.bitvec 64)) := [LV| {
  ^entry ():
    %1 = llvm.mlir.constant (50) : i64
    llvm.return %1 : i64
  }]

def test13_after := [llvm|
{
^0(%arg0 : i1024):
  %0 = llvm.mlir.constant(1016 : i1024) : i1024
  %1 = llvm.lshr %arg0, %0 : i1024
  "llvm.return"(%1) : (i1024) -> ()
}
]

def ugt_umax4_before := [llvm|
{
^0(%arg30 : i32, %arg31 : i32):
  %0 = llvm.mlir.constant(3 : i32) : i32
  %1 = llvm.add %arg30, %0 : i32
  %2 = llvm.icmp "ugt" %arg31, %1 : i32
  %3 = "llvm.select"(%2, %arg31, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %4 = llvm.icmp "ult" %1, %3 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def select_ashr_icmp_bad_before := [llvm|
{
^0(%arg45 : i32, %arg46 : i32, %arg47 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.icmp "eq" %arg45, %0 : i32
  %2 = llvm.ashr %arg47, %arg45 : i32
  %3 = "llvm.select"(%1, %2, %arg46) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def test_invalid_simplify_other_after := [llvm|
{
^0(%arg204 : i8, %arg205 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.mlir.constant(-1 : i8) : i8
  %2 = llvm.icmp "eq" %arg204, %0 : i8
  %3 = llvm.add %arg205, %1 : i8
  %4 = "llvm.select"(%2, %0, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%4) : (i8) -> ()
}
]

def composeQuinaryAux' (p : FSM (Fin 5)) (q₀ q₁ q₂ q₃ q₄: FSM α) : FSM α :=
  p.compose (α)
    (λ _ => α)
    (λ _ i => i)
    (λ v =>
      v.cases q₀ fun v =>
        v.cases q₁ fun v =>
          v.cases q₂ fun v =>
            v.cases q₃ fun v =>
              v.cases q₄ fun v => v.elim0)

def test_shr_and_1_ne_0_samesign_after := [llvm|
{
^0(%arg9 : i32, %arg10 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.shl %0, %arg10 overflow<nuw> : i32
  %3 = llvm.and %arg9, %2 : i32
  %4 = llvm.icmp "ne" %3, %1 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def rewrite_a_T : PeepholeRewrite DCPlus [.valuestream 1, .tokenstream] [.tokenstream] :=
  { lhs := [DCPlus_com| {
      ^entry(%0 : !TokenStream, %1 : !ValueStream_1):
        %branch = "DCPlus.branch" (%1, %0) : (!ValueStream_1, !TokenStream) -> (!TokenStream2)
        %fst = "DCPlus.fst" (%branch) :  (!TokenStream2) -> (!TokenStream)
        "return" (%fst) : (!TokenStream) -> ()
      }],
    rhs := [DCPlus_com| {
      ^entry(%0 : !TokenStream, %1 : !ValueStream_1):
        %fork = "DCPlus.fork" (%0) : (!TokenStream) -> (!TokenStream2)
        %fst = "DCPlus.fst" (%fork) : (!TokenStream2) -> (!TokenStream)
        %forkVal = "DCPlus.forkVal" (%1) : (!ValueStream_1) -> (!ValueStream2_1)
        %fstValPure = "DCPlus.fstValPure" (%forkVal) : (!ValueStream2_1) -> (!ValueStream_1)
        %not = "DCPlus.not" (%fstValPure) : (!ValueStream_1) -> (!ValueStream_1)
        %supp = "DCPlus.supp" (%not, %fst) : (!ValueStream_1, !TokenStream) -> (!TokenStream)
        "return" (%supp) : (!TokenStream) -> ()
      }],
    correct :=
    by admit /- proof elided -/

def or_test2_after := [llvm|
{
^0(%arg0 : i7, %arg1 : i7):
  %0 = llvm.mlir.constant(-64 : i7) : i7
  "llvm.return"(%0) : (i7) -> ()
}
]

def pr40493_neg3_after := [llvm|
{
^0(%arg15 : i32):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.mlir.constant(4 : i32) : i32
  %2 = llvm.shl %arg15, %0 : i32
  %3 = llvm.and %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def ult_umin3_after := [llvm|
{
^0(%arg32 : i32, %arg33 : i32):
  %0 = llvm.mlir.constant(3 : i32) : i32
  %1 = llvm.add %arg32, %0 : i32
  %2 = llvm.icmp "ult" %arg33, %1 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def icmp_slt_0_and_icmp_ne_neg2_i32_fail_before := [llvm|
{
^0(%arg44 : i32):
  %0 = llvm.mlir.constant(-2 : i32) : i32
  %1 = llvm.mlir.constant(31 : i32) : i32
  %2 = llvm.icmp "ne" %arg44, %0 : i32
  %3 = llvm.zext %2 : i1 to i32
  %4 = llvm.lshr %arg44, %1 : i32
  %5 = llvm.and %4, %3 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def sendReadyValue (_ : Unit) (_ : Unit) : BitVec 1 := 1

def prove_exact_with_high_mask_limit_before := [llvm|
{
^0(%arg6 : i8, %arg7 : i8):
  %0 = llvm.mlir.constant(-32 : i8) : i8
  %1 = llvm.and %arg6, %0 : i8
  %2 = llvm.sdiv %1, %0 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def zero_sign_bit_before := [llvm|
{
^0(%arg31 : i16):
  %0 = llvm.mlir.constant(32767 : i16) : i16
  %1 = llvm.mlir.constant(512 : i16) : i16
  %2 = llvm.and %arg31, %0 : i16
  %3 = llvm.add %2, %1 : i16
  "llvm.return"(%3) : (i16) -> ()
}
]

def negative_trunc_not_arg_logical_before := [llvm|
{
^0(%arg20 : i32, %arg21 : i32):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.mlir.constant(128 : i32) : i32
  %2 = llvm.mlir.constant(256 : i32) : i32
  %3 = llvm.mlir.constant(false) : i1
  %4 = llvm.trunc %arg20 : i32 to i8
  %5 = llvm.icmp "sgt" %4, %0 : i8
  %6 = llvm.add %arg21, %1 : i32
  %7 = llvm.icmp "ult" %6, %2 : i32
  %8 = "llvm.select"(%5, %7, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%8) : (i1) -> ()
}
]

def masked_icmps_mask_notallzeros_bmask_mixed_swapped_1_logical_before := [llvm|
{
^0(%arg49 : i32):
  %0 = llvm.mlir.constant(12 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(7 : i32) : i32
  %3 = llvm.mlir.constant(1 : i32) : i32
  %4 = llvm.mlir.constant(false) : i1
  %5 = llvm.and %arg49, %0 : i32
  %6 = llvm.icmp "ne" %5, %1 : i32
  %7 = llvm.and %arg49, %2 : i32
  %8 = llvm.icmp "eq" %7, %3 : i32
  %9 = "llvm.select"(%8, %6, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%9) : (i1) -> ()
}
]

instance decPropToBitvec1 (p : Prop) [Decidable p] : CoeDep Prop p (BitVec 1) where
  coe := BitVec.ofBool $ decide p

def elabDefSignatureFor (dialect : Term) (alts : TSyntax ``matchAltsSig) : CommandElabM Unit := do
  let msg := (return m!"{exceptEmoji ·} Defining operation signature for {dialect} dialect")
  withTraceNode `LeanMLIR.Elab msg (collapsed := false) <| do
    let alts := getMatchAlts alts
    let alts ← do
      alts.mapM fun view => do
        trace[LeanMLIR.Elab] m!"Parsing match alternative with\n\
          \tpatterns: {view.patterns}\n\
          \tsignature: {view.rhs}"
        let rhs ← parseSignature view.rhs
        return { view with rhs }

    |

@[simp_denote]
def add_llvm_nsw_nuw_flags_8 := [LV| {
   ^entry (%lhs: i8, %rhs: i8):
    %1 = llvm.add %lhs, %rhs overflow<nsw,nuw> : i8
    llvm.return %1 : i8
  }]

def test11_after := [llvm|
{
^0(%arg184 : i32, %arg185 : i32):
  %0 = llvm.and %arg185, %arg184 : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

def and_xor_or3_after := [llvm|
{
^0(%arg667 : i64, %arg668 : i64, %arg669 : i64):
  %0 = llvm.mlir.constant(42) : i64
  %1 = llvm.udiv %0, %arg668 : i64
  %2 = llvm.udiv %0, %arg669 : i64
  %3 = llvm.or %2, %1 : i64
  "llvm.return"(%3) : (i64) -> ()
}
]

def narrow_sext_and_before := [llvm|
{
^0(%arg56 : i16, %arg57 : i32):
  %0 = llvm.sext %arg56 : i16 to i32
  %1 = llvm.and %0, %arg57 : i32
  %2 = llvm.trunc %1 : i32 to i16
  "llvm.return"(%2) : (i16) -> ()
}
]

def llvm_zext_lower_riscv_16_to_64 : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 16)] :=
  {lhs:= zext_llvm_16_to_64, rhs:= zext_riscv_16_to_64}

Prod in Init.Prelude

def select_icmp_ne_0_and_1073741824_or_8_before := [llvm|
{
^0(%arg195 : i32, %arg196 : i8):
  %0 = llvm.mlir.constant(1073741824 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(8 : i8) : i8
  %3 = llvm.and %arg195, %0 : i32
  %4 = llvm.icmp "ne" %1, %3 : i32
  %5 = llvm.or %arg196, %2 : i8
  %6 = "llvm.select"(%4, %arg196, %5) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%6) : (i8) -> ()
}
]

def icmp_shl_uge_2_after := [llvm|
{
^0(%arg12 : i5):
  %0 = llvm.mlir.constant(10 : i5) : i5
  %1 = llvm.mlir.constant(1 : i5) : i5
  %2 = llvm.add %arg12, %0 : i5
  %3 = llvm.icmp "slt" %2, %1 : i5
  "llvm.return"(%3) : (i1) -> ()
}
]

def n1_before := [llvm|
{
^0(%arg2 : i8, %arg3 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.mlir.constant(-1 : i8) : i8
  %2 = llvm.shl %0, %arg3 : i8
  %3 = llvm.xor %2, %1 : i8
  %4 = llvm.and %3, %arg2 : i8
  %5 = llvm.icmp "ne" %4, %arg2 : i8
  "llvm.return"(%5) : (i1) -> ()
}
]

def PR42691_8_logical_after := [llvm|
{
^0(%arg328 : i32):
  %0 = llvm.mlir.constant(2147483647 : i32) : i32
  %1 = llvm.mlir.constant(-2147483635 : i32) : i32
  %2 = llvm.add %arg328, %0 : i32
  %3 = llvm.icmp "ult" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def test85_before := [llvm|
{
^0(%arg60 : i32):
  %0 = llvm.mlir.constant(-16777216 : i32) : i32
  %1 = llvm.mlir.constant(23 : i32) : i32
  %2 = llvm.add %arg60, %0 overflow<nuw> : i32
  %3 = llvm.lshr exact %2, %1 : i32
  %4 = llvm.trunc %3 : i32 to i8
  "llvm.return"(%4) : (i8) -> ()
}
]

def negative2_after := [llvm|
{
^0(%arg16 : i32, %arg17 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.icmp "slt" %arg16, %arg17 : i32
  %2 = llvm.icmp "sgt" %arg16, %0 : i32
  %3 = llvm.and %1, %2 : i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def llvm_mul_lower_riscv_nsw_flag_32 : LLVMPeepholeRewriteRefine 32 [Ty.llvm (.bitvec 32), Ty.llvm (.bitvec 32)] where
  lhs := mul_llvm_nsw_32
  rhs := mul_riscv_32

def alive_AndOrXor_1280_ABA___AB_src :=
[sllvm| {
^bb0(%A : i64, %B : i64):
  %v1 = llvm.mlir.constant -1 : i64
  %v2 = llvm.xor %A, %v1 : i64
  %v3 = llvm.or %v2, %B : i64
  %v4 = llvm.and %v3, %A : i64
  llvm.return %v4 : i64
}]

def pack (x : ValueStream α) (y : TokenStream) : ValueStream α :=
  Stream.corec (β := ValueStream α × TokenStream) (x, y) fun ⟨x, y⟩ =>
    match x 0, y 0 with
    | some x₀, some _ => (x₀, (x.tail, y.tail))
    | some _, none => (none, (x, y.tail)) 
    | none, some _ => (none, (x.tail, y)) 
    | none, none => (none, (x.tail, y.tail))

def test_after := [llvm|
{
^0(%arg0 : i26):
  "llvm.return"(%arg0) : (i26) -> ()
}
]

def not_and_and_not_commute1_before := [llvm|
{
^0(%arg561 : i32, %arg562 : i32, %arg563 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg562, %0 : i32
  %2 = llvm.xor %arg563, %0 : i32
  %3 = llvm.and %1, %arg561 : i32
  %4 = llvm.and %3, %2 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def lshr_and_after := [llvm|
{
^0(%arg73 : i8, %arg74 : i8):
  %0 = llvm.mlir.constant(42 : i8) : i8
  %1 = llvm.mlir.constant(6 : i8) : i8
  %2 = llvm.srem %arg73, %0 : i8
  %3 = llvm.shl %2, %1 : i8
  %4 = llvm.and %arg74, %3 : i8
  "llvm.return"(%4) : (i8) -> ()
}
]

def demorgan_nand_before := [llvm|
{
^0(%arg38 : i8, %arg39 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.xor %arg38, %0 : i8
  %2 = llvm.and %1, %arg39 : i8
  %3 = llvm.xor %2, %0 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def add {w : Nat} (x y : IntW w) (flags : NoWrapFlags := {nsw := false , nuw := false}) : IntW w := do
  let x' ← x
  let y' ← y
  if flags.nsw ∧ BitVec.saddOverflow x' y' then
    .poison
  else if flags.nuw ∧ BitVec.uaddOverflow x' y' then
    .poison
  else
    add? x' y'

def lshrugt_02_12_after := [llvm|
{
^0(%arg387 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def n10_wrong_low_bit_mask_after := [llvm|
{
^0(%arg11 : i8):
  %0 = llvm.mlir.constant(31 : i8) : i8
  %1 = llvm.mlir.constant(0 : i8) : i8
  %2 = llvm.mlir.constant(-16 : i8) : i8
  %3 = llvm.mlir.constant(16 : i8) : i8
  %4 = llvm.and %arg11, %0 : i8
  %5 = llvm.icmp "eq" %4, %1 : i8
  %6 = llvm.and %arg11, %2 : i8
  %7 = llvm.add %6, %3 : i8
  %8 = "llvm.select"(%5, %arg11, %7) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%8) : (i8) -> ()
}
]

def irc_constants_C1Minus2MinusC2_neg2_2 : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%a: i64):
      %c1 = llvm.mlir.constant (-2) : i64
      %c2 = llvm.mlir.constant (2) : i64
      %0 = llvm.sub %c1, %a : i64
      %1 = llvm.sub %0, %c2 : i64
      llvm.return %1 : i64
  }]
  rhs := [LV| {
    ^entry (%a: i64):
      %c1 = llvm.mlir.constant (-2) : i64
      %c2 = llvm.mlir.constant (2) : i64
      %0 = llvm.sub %c1, %c2 : i64
      %1 = llvm.sub %0, %a : i64
      llvm.return %1 : i64
  }]

def lshr_eq_msb_low_last_zero_after := [llvm|
{
^0(%arg177 : i8):
  %0 = llvm.mlir.constant(6 : i8) : i8
  %1 = llvm.icmp "ugt" %arg177, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

instance : MLIR.AST.TransformExpr (FHE q n) 0 where
  mkExpr := mkExpr

def p0_before := [llvm|
{
^0(%arg14 : i8):
  %0 = llvm.mlir.constant(5 : i8) : i8
  %1 = llvm.shl %arg14, %0 : i8
  %2 = llvm.ashr exact %1, %0 : i8
  %3 = llvm.icmp "ne" %2, %arg14 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def xor_icmp_to_icmp_add_after := [llvm|
{
^0(%arg4 : i32):
  %0 = llvm.mlir.constant(-6 : i32) : i32
  %1 = llvm.mlir.constant(-2 : i32) : i32
  %2 = llvm.add %arg4, %0 : i32
  %3 = llvm.icmp "ult" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def mkTy : MLIR.AST.MLIRType φ → MLIR.AST.ExceptM DC DC.Ty
  | MLIR.AST.MLIRType.undefined s => do
    match s.splitOn "_" with
    | ["TokenStream"] =>
      return .tokenstream
    | ["TokenStream2"] =>
      return .tokenstream2
    | ["ValueStream", w] =>
      match w.toNat? with
      | some w' => return .valuestream w'
      | _ => throw .unsupportedType
    | ["ValueStream2", w] =>
      match w.toNat? with
      | some w' => return .valuestream2 w'
      | _ => throw .unsupportedType
    | ["ValueTokenStream", w] =>
    match w.toNat? with
      | some w' => return .valuetokenstream w'
      | _ => throw .unsupportedType
    | ["VariadicValueTokenStream", w] =>
    match w.toNat? with
      | some w' => return .variadicvaluetokenstream w'
      | _ => throw .unsupportedType
    | _ => throw .unsupportedType
  | _ => throw .unsupportedType

instance : ToString IntPred where
  toString
  | .eq => "eq"
  | .ne => "ne"
  | .ugt => "ugt"
  | .uge => "uge"
  | .ult => "ult"
  | .ule => "ule"
  | .sgt => "sgt"
  | .sge => "sge"
  | .slt => "slt"
  | .sle => "sle"

def ashr_slt_noexact_before := [llvm|
{
^0(%arg155 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.mlir.constant(10 : i8) : i8
  %2 = llvm.ashr %arg155, %0 : i8
  %3 = llvm.icmp "slt" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

Lean.Parser.Tactic.unknown in Lean.Parser.Tactic

def scalar_i32_shl_and_signbit_ne_after := [llvm|
{
^0(%arg27 : i32, %arg28 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.shl %arg27, %arg28 : i32
  %2 = llvm.icmp "slt" %1, %0 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def narrow_sext_sub_before := [llvm|
{
^0(%arg40 : i16, %arg41 : i32):
  %0 = llvm.sext %arg40 : i16 to i32
  %1 = llvm.sub %0, %arg41 : i32
  %2 = llvm.trunc %1 : i32 to i16
  "llvm.return"(%2) : (i16) -> ()
}
]

@[simp_denote]
def sub_llvm_i32 := [LV| {
    ^entry (%a: i32, %b: i32):
    %0 = llvm.sub %a, %b : i32
    llvm.return %0 : i32
  }]

def not_and_and_not_after := [llvm|
{
^0(%arg567 : i32, %arg568 : i32, %arg569 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.sdiv %0, %arg567 : i32
  %3 = llvm.or %arg568, %arg569 : i32
  %4 = llvm.xor %3, %1 : i32
  %5 = llvm.and %2, %4 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def PR60818_ne_after := [llvm|
{
^0(%arg5 : i32):
  %0 = llvm.mlir.constant(2147483647 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.and %arg5, %0 : i32
  %3 = llvm.icmp "ne" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def test69_and_after := [llvm|
{
^0(%arg152 : i32, %arg153 : i32):
  %0 = llvm.mlir.constant(128 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(2 : i32) : i32
  %3 = llvm.and %arg152, %0 : i32
  %4 = llvm.icmp "eq" %3, %1 : i32
  %5 = llvm.and %arg153, %2 : i32
  %6 = "llvm.select"(%4, %5, %arg153) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def f_before := [llvm|
{
^0(%arg0 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.or %arg0, %0 : i32
  %3 = llvm.srem %2, %0 : i32
  %4 = llvm.icmp "ne" %3, %1 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def test35_before := [llvm|
{
^0(%arg50 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.mlir.constant(60 : i32) : i32
  %2 = llvm.mlir.constant(100 : i32) : i32
  %3 = llvm.icmp "sge" %arg50, %0 : i32
  %4 = "llvm.select"(%3, %1, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def test25_before := [llvm|
{
^0(%arg0 : i32):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.and %arg0, %0 : i32
  %2 = llvm.icmp "ugt" %1, %0 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def zext_or_masked_bit_test_after := [llvm|
{
^0(%arg54 : i32, %arg55 : i32, %arg56 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.shl %0, %arg55 overflow<nuw> : i32
  %3 = llvm.and %2, %arg54 : i32
  %4 = llvm.icmp "ne" %3, %1 : i32
  %5 = llvm.icmp "eq" %arg56, %arg55 : i32
  %6 = llvm.or %4, %5 : i1
  %7 = llvm.zext %6 : i1 to i32
  "llvm.return"(%7) : (i32) -> ()
}
]

def masked_or_allzeroes_logical_after := [llvm|
{
^0(%arg130 : i32):
  %0 = llvm.mlir.constant(7 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.and %arg130, %0 : i32
  %3 = llvm.icmp "eq" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def trunc {w: Nat} (w': Nat) (x: IntW w) (noWrapFlags : NoWrapFlags := {nsw := false , nuw := false}) : IntW w' := do
  let x' <- x
  if noWrapFlags.nsw ∧ ((x'.truncate w').signExtend w ≠ x') then
    .poison
  else if noWrapFlags.nuw ∧ ((x'.truncate w').zeroExtend w ≠ x') then
    .poison
  else
    trunc? w' x'

def test7_before := [llvm|
{
^0(%arg300 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg300, %0 : i32
  %2 = llvm.and %arg300, %1 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def sge_smin1_before := [llvm|
{
^0(%arg79 : i32, %arg80 : i32):
  %0 = llvm.icmp "slt" %arg79, %arg80 : i32
  %1 = "llvm.select"(%0, %arg79, %arg80) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %2 = llvm.icmp "sge" %1, %arg79 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def n0_after := [llvm|
{
^0(%arg9 : i8, %arg10 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.mlir.constant(-1 : i8) : i8
  %2 = llvm.shl %0, %arg10 overflow<nuw> : i8
  %3 = llvm.xor %2, %1 : i8
  %4 = llvm.icmp "ugt" %arg9, %3 : i8
  "llvm.return"(%4) : (i1) -> ()
}
]

def shift_trunc_wrong_cmp_after := [llvm|
{
^0(%arg0 : i32):
  %0 = llvm.mlir.constant(24 : i32) : i32
  %1 = llvm.mlir.constant(1 : i8) : i8
  %2 = llvm.lshr %arg0, %0 : i32
  %3 = llvm.trunc %2 overflow<nuw> : i32 to i8
  %4 = llvm.icmp "slt" %3, %1 : i8
  "llvm.return"(%4) : (i1) -> ()
}
]

def trunc_equality_nsw_zext_after := [llvm|
{
^0(%arg16 : i32, %arg17 : i8):
  %0 = llvm.zext %arg17 : i8 to i32
  %1 = llvm.icmp "ne" %arg16, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def test28_before := [llvm|
{
^0(%arg177 : i32):
  %0 = llvm.mlir.constant(-2147483647 : i32) : i32
  %1 = llvm.mlir.constant(-2147483648 : i32) : i32
  %2 = llvm.add %arg177, %0 : i32
  %3 = llvm.xor %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def t15_and_with_const1_after := [llvm|
{
^0(%arg3 : i32, %arg4 : i32, %arg5 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.shl %0, %arg4 overflow<nuw> : i32
  %3 = llvm.and %arg3, %2 : i32
  %4 = llvm.icmp "eq" %3, %1 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def p1_ugt_after := [llvm|
{
^0(%arg52 : i32, %arg53 : i32):
  %0 = llvm.mlir.constant(65535 : i32) : i32
  %1 = llvm.icmp "ult" %arg52, %0 : i32
  %2 = "llvm.select"(%1, %0, %arg53) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def test46_before := [llvm|
{
^0(%arg199 : i32, %arg200 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg200, %0 : i32
  %2 = llvm.or %1, %arg199 : i32
  %3 = llvm.and %arg200, %2 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def add_constant_equal_with_the_top_bit_of_demandedbits_insertpt_before := [llvm|
{
^0(%arg4 : i32, %arg5 : i32):
  %0 = llvm.mlir.constant(16 : i32) : i32
  %1 = llvm.mlir.constant(24 : i32) : i32
  %2 = llvm.add %arg4, %0 : i32
  %3 = llvm.or %2, %arg5 : i32
  %4 = llvm.and %3, %1 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def test15g_before := [llvm|
{
^0(%arg21 : i32):
  %0 = llvm.mlir.constant(8 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(-1 : i32) : i32
  %3 = llvm.mlir.constant(-9 : i32) : i32
  %4 = llvm.and %arg21, %0 : i32
  %5 = llvm.icmp "ne" %4, %1 : i32
  %6 = "llvm.select"(%5, %2, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%6) : (i32) -> ()
}
]

Fintype in Mathlib.Data.Fintype.Defs

def liRiscv_36 := [LV| {
  ^entry ():
    %0 = "li"() {imm = -36 : !i64} : (!i64) -> (!i64)
    %1 = "builtin.unrealized_conversion_cast"(%0) : (!i64) -> (i64)
    llvm.return %1 : i64
  }]

def andcond.001.inv.outer.cond_before := [llvm|
{
^0(%arg75 : i1, %arg76 : i1, %arg77 : i1, %arg78 : i1, %arg79 : i1):
  %0 = llvm.mlir.constant(false) : i1
  %1 = llvm.mlir.constant(true) : i1
  %2 = "llvm.select"(%arg75, %arg76, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %3 = "llvm.select"(%arg75, %arg77, %arg78) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %4 = llvm.xor %2, %1 : i1
  %5 = "llvm.select"(%4, %3, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%5) : (i1) -> ()
}
]

def slt_zero_ne_ne_0_after := [llvm|
{
^0(%arg5 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.icmp "sgt" %arg5, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def masked_icmps_mask_notallzeros_bmask_mixed_negated_swapped_7_after := [llvm|
{
^0(%arg12 : i32):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def slt_swap_and_not_max_logical_before := [llvm|
{
^0(%arg116 : i8, %arg117 : i8):
  %0 = llvm.mlir.constant(127 : i8) : i8
  %1 = llvm.mlir.constant(false) : i1
  %2 = llvm.icmp "sgt" %arg117, %arg116 : i8
  %3 = llvm.icmp "ne" %arg116, %0 : i8
  %4 = "llvm.select"(%2, %3, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def or_not_and_wrong_b_before := [llvm|
{
^0(%arg484 : i32, %arg485 : i32, %arg486 : i32, %arg487 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.or %arg484, %arg485 : i32
  %2 = llvm.xor %1, %0 : i32
  %3 = llvm.and %2, %arg486 : i32
  %4 = llvm.or %arg484, %arg486 : i32
  %5 = llvm.xor %4, %0 : i32
  %6 = llvm.and %5, %arg487 : i32
  %7 = llvm.or %3, %6 : i32
  "llvm.return"(%7) : (i32) -> ()
}
]

def test_negative_nsw_and_unsigned_pred_before := [llvm|
{
^0(%arg52 : i64):
  %0 = llvm.mlir.constant(10) : i64
  %1 = llvm.mlir.constant(3) : i64
  %2 = llvm.sub %0, %arg52 overflow<nsw> : i64
  %3 = llvm.icmp "ult" %2, %1 : i64
  "llvm.return"(%3) : (i1) -> ()
}
]

@[simp_denote]
def icmp_ult_riscv_32 := [LV| {
  ^entry (%lhs: i32, %rhs: i32 ):
    %lhsr = "builtin.unrealized_conversion_cast"(%lhs) : (i32) -> (!i64)
    %rhsr = "builtin.unrealized_conversion_cast"(%rhs) : (i32) -> (!i64)
    %0 = sltu %lhsr, %rhsr : !i64
    %1 = "builtin.unrealized_conversion_cast"(%0) : (!i64) -> (i1)
    llvm.return %1 : i1
  }]

def test_trunc_before := [llvm|
{
^0(%arg24 : i8):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.mlir.constant(31 : i32) : i32
  %2 = llvm.mlir.constant(-1 : i8) : i8
  %3 = llvm.zext %arg24 : i8 to i32
  %4 = llvm.add %3, %0 overflow<nsw> : i32
  %5 = llvm.ashr %4, %1 : i32
  %6 = llvm.trunc %5 : i32 to i8
  %7 = llvm.xor %6, %2 : i8
  "llvm.return"(%7) : (i8) -> ()
}
]

def foo1_and_after := [llvm|
{
^0(%arg181 : i32, %arg182 : i32, %arg183 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.shl %0, %arg182 overflow<nuw> : i32
  %2 = llvm.shl %0, %arg183 overflow<nuw> : i32
  %3 = llvm.or %1, %2 : i32
  %4 = llvm.and %arg181, %3 : i32
  %5 = llvm.icmp "ne" %4, %3 : i32
  "llvm.return"(%5) : (i1) -> ()
}
]

def mul_of_bools_before := [llvm|
{
^0(%arg91 : i32, %arg92 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(2 : i32) : i32
  %2 = llvm.and %arg91, %0 : i32
  %3 = llvm.and %arg92, %0 : i32
  %4 = llvm.mul %2, %3 : i32
  %5 = llvm.icmp "ult" %4, %1 : i32
  "llvm.return"(%5) : (i1) -> ()
}
]

def and_xor_or8_after := [llvm|
{
^0(%arg652 : i64, %arg653 : i64, %arg654 : i64):
  %0 = llvm.mlir.constant(42) : i64
  %1 = llvm.udiv %0, %arg653 : i64
  %2 = llvm.udiv %0, %arg654 : i64
  %3 = llvm.or %1, %2 : i64
  "llvm.return"(%3) : (i64) -> ()
}
]

def bool_eq0_logical_after := [llvm|
{
^0(%arg32 : i64):
  %0 = llvm.mlir.constant(1) : i64
  %1 = llvm.icmp "sgt" %arg32, %0 : i64
  "llvm.return"(%1) : (i1) -> ()
}
]

def PR75692_1_after := [llvm|
{
^0(%arg3 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

def PR2539_A_after := [llvm|
{
^0(%arg1 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.xor %arg1, %0 : i1
  "llvm.return"(%1) : (i1) -> ()
}
]

private def levelParamsToMessageData (levelParams : List Name) : MessageData :=
  match levelParams with
  | []    => ""
  | u::us => Id.run do
    let mut m := m!".\{{u}"
    for u in us do
      m := m ++ ", " ++ toMessageData u
    return m ++ "}"

def trunc_shl_7_i8_i64_before := [llvm|
{
^0(%arg37 : i64):
  %0 = llvm.mlir.constant(7) : i64
  %1 = llvm.shl %arg37, %0 : i64
  %2 = llvm.trunc %1 : i64 to i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def eq_smax3_after := [llvm|
{
^0(%arg59 : i32, %arg60 : i32):
  %0 = llvm.mlir.constant(3 : i32) : i32
  %1 = llvm.add %arg59, %0 : i32
  %2 = llvm.icmp "sge" %1, %arg60 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def test28_before := [llvm|
{
^0(%arg177 : i32):
  %0 = llvm.mlir.constant(-2147483647 : i32) : i32
  %1 = llvm.mlir.constant(-2147483648 : i32) : i32
  %2 = llvm.add %arg177, %0 : i32
  %3 = llvm.xor %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def f_after := [llvm|
{
^0(%arg2 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.mlir.constant(7 : i32) : i32
  %2 = llvm.mlir.constant(true) : i1
  %3 = llvm.icmp "slt" %arg2, %0 : i32
  %4 = llvm.lshr %1, %arg2 : i32
  %5 = llvm.icmp "sgt" %arg2, %4 : i32
  %6 = "llvm.select"(%3, %2, %5) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%6) : (i1) -> ()
}
]

def mul_add_to_mul_5_after := [llvm|
{
^0(%arg28 : i16):
  %0 = llvm.mlir.constant(10 : i16) : i16
  %1 = llvm.mul %arg28, %0 overflow<nsw> : i16
  "llvm.return"(%1) : (i16) -> ()
}
]

def pr40493_before := [llvm|
{
^0(%arg18 : i32):
  %0 = llvm.mlir.constant(12 : i32) : i32
  %1 = llvm.mlir.constant(4 : i32) : i32
  %2 = llvm.mlir.constant(0 : i32) : i32
  %3 = llvm.mul %arg18, %0 : i32
  %4 = llvm.and %3, %1 : i32
  %5 = llvm.icmp "eq" %4, %2 : i32
  "llvm.return"(%5) : (i1) -> ()
}
]

def n12_after := [llvm|
{
^0(%arg0 : i32, %arg1 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.mlir.constant(2 : i32) : i32
  %2 = llvm.xor %arg0, %0 : i32
  %3 = llvm.add %arg1, %2 : i32
  %4 = llvm.add %3, %1 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def masked_icmps_mask_notallzeros_bmask_mixed_negated_swapped_0_logical_before := [llvm|
{
^0(%arg29 : i32):
  %0 = llvm.mlir.constant(12 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(3 : i32) : i32
  %3 = llvm.mlir.constant(1 : i32) : i32
  %4 = llvm.mlir.constant(true) : i1
  %5 = llvm.and %arg29, %0 : i32
  %6 = llvm.icmp "eq" %5, %1 : i32
  %7 = llvm.and %arg29, %2 : i32
  %8 = llvm.icmp "ne" %7, %3 : i32
  %9 = "llvm.select"(%8, %4, %6) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%9) : (i1) -> ()
}
]

RV64.xor in RISCV.Instructions

def test18a_after := [llvm|
{
^0(%arg280 : i8):
  %0 = llvm.mlir.constant(2 : i8) : i8
  %1 = llvm.icmp "ult" %arg280, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def shl_add_add_fail_before := [llvm|
{
^0(%arg166 : i8, %arg167 : i8):
  %0 = llvm.mlir.constant(2 : i8) : i8
  %1 = llvm.mlir.constant(48 : i8) : i8
  %2 = llvm.lshr %arg166, %0 : i8
  %3 = llvm.lshr %arg167, %0 : i8
  %4 = llvm.add %3, %1 : i8
  %5 = llvm.add %2, %4 : i8
  "llvm.return"(%5) : (i8) -> ()
}
]

def test13_after := [llvm|
{
^0(%arg16 : i8, %arg17 : i8):
  %0 = llvm.icmp "ne" %arg16, %arg17 : i8
  "llvm.return"(%0) : (i1) -> ()
}
]

def Op.appendRegion {φ} (o : Op φ) (r : Region φ) : Op φ :=
  match o with
  | Op.mk name res args regions attrs =>
      Op.mk name res args (regions ++ [r]) attrs

def llvm_const_lower_riscv_li9 : LLVMPeepholeRewriteRefine 64 [] :=
  {lhs := constLLVM9, rhs:= liRiscv9,
   correct := by admit /- proof elided -/

Id.run in Init.Control.Id

def tryFactorization_xor_lshr_ashr_before := [llvm|
{
^0(%arg39 : i32):
  %0 = llvm.mlir.constant(-3 : i32) : i32
  %1 = llvm.mlir.constant(5 : i32) : i32
  %2 = llvm.ashr %0, %arg39 : i32
  %3 = llvm.lshr %1, %arg39 : i32
  %4 = llvm.xor %3, %2 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

instance : DecidableEq (NFA'.autMsbSet).σ :=

def Expr.mkToFSM (self : Expr) : MetaM Expr :=
  mkAppM ``FSMPredicateSolution.toFSM #[self]

def and_two_ranges_to_mask_and_range_no_add_on_one_range_before := [llvm|
{
^0(%arg249 : i16):
  %0 = llvm.mlir.constant(12 : i16) : i16
  %1 = llvm.mlir.constant(16 : i16) : i16
  %2 = llvm.mlir.constant(28 : i16) : i16
  %3 = llvm.icmp "uge" %arg249, %0 : i16
  %4 = llvm.icmp "ult" %arg249, %1 : i16
  %5 = llvm.icmp "uge" %arg249, %2 : i16
  %6 = llvm.or %4, %5 : i1
  %7 = llvm.and %3, %6 : i1
  "llvm.return"(%7) : (i1) -> ()
}
]

def or_signbit_select_ashr_after := [llvm|
{
^0(%arg10 : i32, %arg11 : i1):
  %0 = llvm.mlir.constant(8 : i32) : i32
  %1 = llvm.mlir.constant(-256 : i32) : i32
  %2 = llvm.ashr %arg10, %0 : i32
  %3 = llvm.or %2, %1 : i32
  %4 = "llvm.select"(%arg11, %3, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def positive_with_mask_logical_after := [llvm|
{
^0(%arg59 : i32):
  %0 = llvm.mlir.constant(128 : i32) : i32
  %1 = llvm.icmp "ult" %arg59, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def select_icmp_ne_0_and_4096_or_4096_before := [llvm|
{
^0(%arg233 : i32, %arg234 : i32):
  %0 = llvm.mlir.constant(4096 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.and %arg233, %0 : i32
  %3 = llvm.icmp "ne" %1, %2 : i32
  %4 = llvm.or %arg234, %0 : i32
  %5 = "llvm.select"(%3, %arg234, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def slt_zero_ne_ne_b_after := [llvm|
{
^0(%arg2 : i32, %arg3 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.icmp "ne" %arg2, %arg3 : i32
  %2 = llvm.icmp "slt" %arg2, %0 : i32
  %3 = llvm.xor %2, %1 : i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def sub_ashr_and_i8_after := [llvm|
{
^0(%arg31 : i8, %arg32 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.icmp "slt" %arg32, %arg31 : i8
  %2 = "llvm.select"(%1, %arg31, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%2) : (i8) -> ()
}
]

@[simp_denote]
def sub_riscv_self_ex := [LV| {
  ^entry (%x: i64):
    %0 = "builtin.unrealized_conversion_cast"(%x) : (i64) -> (!i64)
    %2 = sub %0, %0 : !i64
    %4 = sltu %0, %0 : !i64
    %3 = "builtin.unrealized_conversion_cast"(%2) : (!i64) -> (i64)
    llvm.return %3 : i64
  }]

def trunc_sandwich_big_sum_shift2_after := [llvm|
{
^0(%arg63 : i32):
  %0 = llvm.mlir.constant(0 : i12) : i12
  "llvm.return"(%0) : (i12) -> ()
}
]

def t0_before := [llvm|
{
^0(%arg42 : i32, %arg43 : i32, %arg44 : i32, %arg45 : i32):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.icmp "eq" %arg42, %arg43 : i32
  %2 = llvm.icmp "eq" %arg44, %arg45 : i32
  %3 = llvm.and %2, %1 : i1
  %4 = llvm.xor %3, %0 : i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def test46_after := [llvm|
{
^0(%arg141 : i64):
  %0 = llvm.mlir.constant(8 : i32) : i32
  %1 = llvm.mlir.constant(10752 : i32) : i32
  %2 = llvm.trunc %arg141 : i64 to i32
  %3 = llvm.shl %2, %0 : i32
  %4 = llvm.and %3, %1 : i32
  %5 = llvm.zext nneg %4 : i32 to i64
  "llvm.return"(%5) : (i64) -> ()
}
]

def lshr_shl_demand3_before := [llvm|
{
^0(%arg7 : i8):
  %0 = llvm.mlir.constant(28 : i8) : i8
  %1 = llvm.mlir.constant(3 : i8) : i8
  %2 = llvm.lshr %0, %arg7 : i8
  %3 = llvm.shl %2, %1 : i8
  %4 = llvm.or %3, %1 : i8
  "llvm.return"(%4) : (i8) -> ()
}
]

def and_or1_commuted_before := [llvm|
{
^0(%arg197 : i1, %arg198 : i1, %arg199 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.xor %arg197, %0 : i1
  %2 = llvm.or %arg199, %1 : i1
  %3 = "llvm.select"(%2, %arg197, %arg198) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def src_x_and_nmask_sge_fail_maybe_z_after := [llvm|
{
^0(%arg11 : i8, %arg12 : i8, %arg13 : i1):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.mlir.constant(0 : i8) : i8
  %2 = llvm.shl %0, %arg12 overflow<nsw> : i8
  %3 = "llvm.select"(%arg13, %2, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  %4 = llvm.and %arg11, %3 : i8
  %5 = llvm.icmp "sge" %4, %3 : i8
  "llvm.return"(%5) : (i1) -> ()
}
]

def negative_trunc_not_arg_before := [llvm|
{
^0(%arg22 : i32, %arg23 : i32):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.mlir.constant(128 : i32) : i32
  %2 = llvm.mlir.constant(256 : i32) : i32
  %3 = llvm.trunc %arg22 : i32 to i8
  %4 = llvm.icmp "sgt" %3, %0 : i8
  %5 = llvm.add %arg23, %1 : i32
  %6 = llvm.icmp "ult" %5, %2 : i32
  %7 = llvm.and %4, %6 : i1
  "llvm.return"(%7) : (i1) -> ()
}
]

def mkCarryAssignCircuitNAux {arity : Type _}
  [DecidableEq arity]
  [Fintype arity]
  [Hashable arity]
  (p : FSM arity) (s : p.α) (n : Nat) : Circuit (Vars p.α arity (n + 1)) :=
    (p.nextStateCirc s).map fun v =>
      match v with
        | .inl t => Vars.stateN t n
        | .inr i => Vars.inputN i n

def mul_mask_fakepow2_ne0_before := [llvm|
{
^0(%arg21 : i8):
  %0 = llvm.mlir.constant(44 : i8) : i8
  %1 = llvm.mlir.constant(5 : i8) : i8
  %2 = llvm.mlir.constant(0 : i8) : i8
  %3 = llvm.mul %arg21, %0 : i8
  %4 = llvm.and %3, %1 : i8
  %5 = llvm.icmp "ne" %4, %2 : i8
  "llvm.return"(%5) : (i1) -> ()
}
]

def masked_icmps_mask_notallzeros_bmask_mixed_7b_after := [llvm|
{
^0(%arg76 : i32):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def uge_swap_and_max_logical_before := [llvm|
{
^0(%arg228 : i8, %arg229 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.mlir.constant(false) : i1
  %2 = llvm.icmp "ule" %arg229, %arg228 : i8
  %3 = llvm.icmp "eq" %arg228, %0 : i8
  %4 = "llvm.select"(%2, %3, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def add_or_and_after := [llvm|
{
^0(%arg19 : i32, %arg20 : i32):
  %0 = llvm.add %arg19, %arg20 : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

def ashr_mul_times_3_div_2_exact_2_after := [llvm|
{
^0(%arg17 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.ashr exact %arg17, %0 : i32
  %2 = llvm.add %arg17, %1 overflow<nsw> : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def lshrult_01_03_exact_before := [llvm|
{
^0(%arg146 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(3 : i4) : i4
  %2 = llvm.lshr exact %arg146, %0 : i4
  %3 = llvm.icmp "ult" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def test43_after := [llvm|
{
^0(%arg205 : i32, %arg206 : i32, %arg207 : i32):
  %0 = llvm.mul %arg206, %arg207 : i32
  %1 = llvm.and %0, %arg205 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def or_signbit_ashr_before := [llvm|
{
^0(%arg5 : i32):
  %0 = llvm.mlir.constant(-65536 : i32) : i32
  %1 = llvm.mlir.constant(8 : i32) : i32
  %2 = llvm.or %arg5, %0 : i32
  %3 = llvm.ashr %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def PR42691_3_logical_after := [llvm|
{
^0(%arg338 : i32):
  %0 = llvm.mlir.constant(-2147483647 : i32) : i32
  %1 = llvm.icmp "ult" %arg338, %0 : i32
  "llvm.return"(%1) : (i1) -> ()
}
]

def and_sext_multiuse_after := [llvm|
{
^0(%arg0 : i32, %arg1 : i32, %arg2 : i32, %arg3 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.icmp "sgt" %arg0, %arg1 : i32
  %2 = llvm.add %arg2, %arg3 : i32
  %3 = "llvm.select"(%1, %2, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def or_xor_not_after := [llvm|
{
^0(%arg56 : i32, %arg57 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg56, %0 : i32
  %2 = llvm.or %arg57, %1 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def not_or_or_and_not_and_and_commute2_and_after := [llvm|
{
^0(%arg202 : i32, %arg203 : i32, %arg204 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg202, %0 : i32
  %2 = llvm.xor %arg204, %arg203 : i32
  %3 = llvm.or %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def test12commuted_after := [llvm|
{
^0(%arg87 : i32, %arg88 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.and %arg87, %arg88 : i32
  %2 = llvm.xor %1, %0 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def eq_21_before := [llvm|
{
^0(%arg124 : i32, %arg125 : i32):
  %0 = llvm.mlir.constant(8 : i32) : i32
  %1 = llvm.mlir.constant(16 : i32) : i32
  %2 = llvm.lshr %arg124, %0 : i32
  %3 = llvm.trunc %2 : i32 to i8
  %4 = llvm.lshr %arg124, %1 : i32
  %5 = llvm.trunc %4 : i32 to i8
  %6 = llvm.lshr %arg125, %0 : i32
  %7 = llvm.trunc %6 : i32 to i8
  %8 = llvm.lshr %arg125, %1 : i32
  %9 = llvm.trunc %8 : i32 to i8
  %10 = llvm.icmp "eq" %3, %7 : i8
  %11 = llvm.icmp "eq" %5, %9 : i8
  %12 = llvm.and %11, %10 : i1
  "llvm.return"(%12) : (i1) -> ()
}
]

def transpose {A} {as : List α} (xs : HVector A as)
    {B : α → Type}
    (h : ∀ (i : Fin as.length), A as[i] = Stream (B as[i])) :
    Stream (HVector B as) :=
  transpose' <| xs.castFun h

def ashr_ult_exact_before := [llvm|
{
^0(%arg169 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.mlir.constant(10 : i8) : i8
  %2 = llvm.ashr exact %arg169, %0 : i8
  %3 = llvm.icmp "ult" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def t0_after := [llvm|
{
^0(%arg10 : i64):
  %0 = llvm.mlir.constant(63) : i64
  %1 = llvm.ashr %arg10, %0 : i64
  %2 = llvm.trunc %1 overflow<nsw> : i64 to i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def p1_scalar_urem_by_nonconst_after := [llvm|
{
^0(%arg18 : i32, %arg19 : i32):
  %0 = llvm.mlir.constant(128 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.and %arg18, %0 : i32
  %3 = llvm.icmp "eq" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def rem_euclid_pow2_false_arm_folded_after := [llvm|
{
^0(%arg2 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.and %arg2, %0 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def lshrugt_01_06_exact_before := [llvm|
{
^0(%arg215 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(6 : i4) : i4
  %2 = llvm.lshr exact %arg215, %0 : i4
  %3 = llvm.icmp "ugt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

@[simp_denote]
def slti_riscv_i32 :=
  [LV| {
    ^entry (%arg: i32):
    %a = "builtin.unrealized_conversion_cast" (%arg) : (i32) -> (!i64)
    %0 = "sext.w" (%a) : (!i64) -> (!i64)
    %1 = slti %0, 2 : !i64
    %2 = "builtin.unrealized_conversion_cast" (%1) : (!i64) -> (i32)
    llvm.return %2 : i32
  }]

def p15_commutativity2_after := [llvm|
{
^0(%arg24 : i32, %arg25 : i32):
  %0 = llvm.mlir.constant(65535 : i32) : i32
  %1 = llvm.mlir.constant(42 : i32) : i32
  %2 = llvm.icmp "ugt" %arg24, %0 : i32
  %3 = "llvm.select"(%2, %0, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def or_eq_with_one_bit_diff_constants2_logical_before := [llvm|
{
^0(%arg361 : i32):
  %0 = llvm.mlir.constant(97 : i32) : i32
  %1 = llvm.mlir.constant(65 : i32) : i32
  %2 = llvm.mlir.constant(true) : i1
  %3 = llvm.icmp "eq" %arg361, %0 : i32
  %4 = llvm.icmp "eq" %arg361, %1 : i32
  %5 = "llvm.select"(%3, %2, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%5) : (i1) -> ()
}
]

def test_shr_and_1_ne_0_samesign_before := [llvm|
{
^0(%arg9 : i32, %arg10 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.lshr %arg9, %arg10 : i32
  %3 = llvm.and %2, %0 : i32
  %4 = llvm.icmp "ne" %3, %1 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def or_simplify_ugt_fail_before := [llvm|
{
^0(%arg7 : i8, %arg8 : i8):
  %0 = llvm.mlir.constant(-2 : i8) : i8
  %1 = llvm.mlir.constant(1 : i8) : i8
  %2 = llvm.and %arg7, %0 : i8
  %3 = llvm.or %arg8, %1 : i8
  %4 = llvm.or %2, %3 : i8
  %5 = llvm.icmp "ugt" %4, %3 : i8
  "llvm.return"(%5) : (i1) -> ()
}
]

def select_icmp_and_8_ne_0_xor_8_after := [llvm|
{
^0(%arg182 : i32):
  %0 = llvm.mlir.constant(-9 : i32) : i32
  %1 = llvm.and %arg182, %0 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def negate_lshr_after := [llvm|
{
^0(%arg108 : i8, %arg109 : i8):
  %0 = llvm.mlir.constant(7 : i8) : i8
  %1 = llvm.ashr %arg109, %0 : i8
  %2 = llvm.add %1, %arg108 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def xor_andn_commute3_after := [llvm|
{
^0(%arg68 : i32, %arg69 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.udiv %0, %arg68 : i32
  %2 = llvm.or %1, %arg69 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

instance {φ} : DialectToExpr (MetaLLVM φ) where
  toExprM := .const ``Id [0]
  toExprDialect := .app (.const ``MetaLLVM []) (Lean.toExpr φ)

def icmp_ne_and_pow2_lshr_pow2_before := [llvm|
{
^0(%arg41 : i32):
  %0 = llvm.mlir.constant(8 : i32) : i32
  %1 = llvm.mlir.constant(4 : i32) : i32
  %2 = llvm.mlir.constant(0 : i32) : i32
  %3 = llvm.lshr %0, %arg41 : i32
  %4 = llvm.and %3, %1 : i32
  %5 = llvm.icmp "eq" %4, %2 : i32
  %6 = llvm.zext %5 : i1 to i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def t2_after := [llvm|
{
^0(%arg15 : i7):
  %0 = llvm.mlir.constant(3 : i7) : i7
  %1 = llvm.ashr %arg15, %0 : i7
  %2 = llvm.sext %1 : i7 to i16
  "llvm.return"(%2) : (i16) -> ()
}
]

def shl_nsw_add_nuw_before := [llvm|
{
^0(%arg20 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.shl %0, %arg20 overflow<nsw> : i32
  %3 = llvm.add %2, %1 overflow<nuw> : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def not_or_or_not_commute1_after := [llvm|
{
^0(%arg546 : i32, %arg547 : i32, %arg548 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.and %arg547, %arg548 : i32
  %2 = llvm.xor %1, %0 : i32
  %3 = llvm.or %arg546, %2 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def PR42691_5_after := [llvm|
{
^0(%arg335 : i32):
  %0 = llvm.mlir.constant(-2147483647 : i32) : i32
  %1 = llvm.mlir.constant(-2147483646 : i32) : i32
  %2 = llvm.add %arg335, %0 : i32
  %3 = llvm.icmp "ult" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def test86_after := [llvm|
{
^0(%arg59 : i16):
  %0 = llvm.mlir.constant(4 : i16) : i16
  %1 = llvm.ashr %arg59, %0 : i16
  "llvm.return"(%1) : (i16) -> ()
}
]

private def attrVal4Symbol : AttrVal := [mlir_attr_val| @"foo" ]

def product.inits_nodup : inits m₁ m₂ |>.toList.Nodup :=

def alive_AndOrXor_2627_tgt  (w : Nat)  :=
[llvm( w )| {
^bb0(%a : _, %c : _, %b : _):
  %v1 = llvm.mlir.constant -1
  %v2 = llvm.xor %a, %v1
  %v3 = llvm.and %v2, %b
  %v4 = llvm.xor %a, %c
  %v5 = llvm.or %a, %b
  %v6 = llvm.xor %v3, %c
  llvm.return %v6
}]

def masked_icmps_mask_notallzeros_bmask_mixed_negated_swapped_3_logical_after := [llvm|
{
^0(%arg21 : i32):
  %0 = llvm.mlir.constant(15 : i32) : i32
  %1 = llvm.mlir.constant(8 : i32) : i32
  %2 = llvm.and %arg21, %0 : i32
  %3 = llvm.icmp "ne" %2, %1 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def test_after := [llvm|
{
^0(%arg2 : i64, %arg3 : i1):
  %0 = llvm.mlir.constant(4) : i64
  %1 = llvm.mlir.constant(3) : i64
  %2 = llvm.lshr %arg2, %0 : i64
  %3 = llvm.lshr %arg2, %1 : i64
  %4 = llvm.add %2, %3 overflow<nsw,nuw> : i64
  "llvm.return"(%4) : (i64) -> ()
}
]

def poo_after := [llvm|
{
^0(%arg101 : i32, %arg102 : i32, %arg103 : i32, %arg104 : i32):
  %0 = llvm.icmp "slt" %arg101, %arg102 : i32
  %1 = "llvm.select"(%0, %arg103, %arg104) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def mul_of_pow2s_after := [llvm|
{
^0(%arg79 : i32, %arg80 : i32):
  %0 = llvm.mlir.constant(128 : i32) : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

def and_not_or_or_not_or_xor_commute2_after := [llvm|
{
^0(%arg319 : i32, %arg320 : i32, %arg321 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.sdiv %0, %arg319 : i32
  %3 = llvm.or %arg320, %arg321 : i32
  %4 = llvm.xor %arg320, %arg321 : i32
  %5 = llvm.or %4, %2 : i32
  %6 = llvm.and %3, %5 : i32
  %7 = llvm.xor %6, %1 : i32
  "llvm.return"(%7) : (i32) -> ()
}
]

def test13_after := [llvm|
{
^0(%arg53 : i32, %arg54 : i32):
  %0 = llvm.mlir.constant(31 : i32) : i32
  %1 = llvm.sext %arg53 : i32 to i64
  %2 = llvm.and %arg54, %0 : i32
  %3 = llvm.zext nneg %2 : i32 to i64
  %4 = llvm.ashr %1, %3 : i64
  "llvm.return"(%4) : (i64) -> ()
}
]

def n1_before := [llvm|
{
^0(%arg2 : i8, %arg3 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.mlir.constant(-1 : i8) : i8
  %2 = llvm.shl %0, %arg3 : i8
  %3 = llvm.xor %2, %1 : i8
  %4 = llvm.and %3, %arg2 : i8
  %5 = llvm.icmp "ne" %4, %arg2 : i8
  "llvm.return"(%5) : (i1) -> ()
}
]

def lshrugt_03_11_after := [llvm|
{
^0(%arg372 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

outParam in Init.Prelude

def ashrslt_01_06_exact_before := [llvm|
{
^0(%arg47 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(6 : i4) : i4
  %2 = llvm.ashr exact %arg47, %0 : i4
  %3 = llvm.icmp "slt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def a_or_b_after := [llvm|
{
^0(%arg15 : i32, %arg16 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.icmp "eq" %arg15, %0 : i32
  %2 = llvm.icmp "eq" %arg16, %0 : i32
  %3 = llvm.xor %1, %2 : i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def foo3_after := [llvm|
{
^0(%arg2 : i1, %arg3 : i1):
  "llvm.return"(%arg2) : (i1) -> ()
}
]

def xor_of_icmps_after := [llvm|
{
^0(%arg31 : i64):
  %0 = llvm.mlir.constant(1) : i64
  %1 = llvm.icmp "sgt" %arg31, %0 : i64
  "llvm.return"(%1) : (i1) -> ()
}
]

def flip_masked_bit_after := [llvm|
{
^0(%arg132 : i8):
  %0 = llvm.mlir.constant(16 : i8) : i8
  %1 = llvm.and %arg132, %0 : i8
  %2 = llvm.xor %1, %0 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def ashrsgt_02_15_exact_before := [llvm|
{
^0(%arg70 : i4):
  %0 = llvm.mlir.constant(2 : i4) : i4
  %1 = llvm.mlir.constant(-1 : i4) : i4
  %2 = llvm.ashr exact %arg70, %0 : i4
  %3 = llvm.icmp "sgt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def select_icmp_slt_zero_smin_flipped_before := [llvm|
{
^0(%arg6 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.mlir.constant(-128 : i8) : i8
  %2 = llvm.icmp "slt" %arg6, %0 : i8
  %3 = llvm.xor %arg6, %1 : i8
  %4 = "llvm.select"(%2, %3, %arg6) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%4) : (i8) -> ()
}
]

def test_shl_nuw__nsw_is_safe_before := [llvm|
{
^0(%arg74 : i32):
  %0 = llvm.mlir.constant(-83886080 : i32) : i32
  %1 = llvm.mlir.constant(-83886079 : i32) : i32
  %2 = llvm.mlir.constant(2 : i32) : i32
  %3 = llvm.mlir.constant(-335544316 : i32) : i32
  %4 = llvm.or %arg74, %0 : i32
  %5 = llvm.icmp "eq" %4, %1 : i32
  %6 = llvm.shl %4, %2 overflow<nuw> : i32
  %7 = "llvm.select"(%5, %3, %6) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %8 = llvm.mul %7, %4 : i32
  %9 = llvm.mul %8, %6 : i32
  "llvm.return"(%9) : (i32) -> ()
}
]

def badimm3_after := [llvm|
{
^0(%arg26 : i16):
  %0 = llvm.mlir.constant(128 : i16) : i16
  %1 = llvm.mlir.constant(256 : i16) : i16
  %2 = llvm.mlir.constant(14 : i16) : i16
  %3 = llvm.mlir.constant(127 : i8) : i8
  %4 = llvm.trunc %arg26 : i16 to i8
  %5 = llvm.add %arg26, %0 : i16
  %6 = llvm.icmp "ult" %5, %1 : i16
  %7 = llvm.ashr %arg26, %2 : i16
  %8 = llvm.trunc %7 overflow<nsw> : i16 to i8
  %9 = llvm.xor %8, %3 : i8
  %10 = "llvm.select"(%6, %4, %9) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%10) : (i8) -> ()
}
]

def lshrugt_03_06_exact_after := [llvm|
{
^0(%arg183 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def foo_after := [llvm|
{
^0(%arg113 : i32, %arg114 : i32, %arg115 : i32, %arg116 : i32):
  %0 = llvm.icmp "slt" %arg113, %arg114 : i32
  %1 = "llvm.select"(%0, %arg115, %arg116) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%1) : (i32) -> ()
}
]

def lshrugt_01_04_before := [llvm|
{
^0(%arg411 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(4 : i4) : i4
  %2 = llvm.lshr %arg411, %0 : i4
  %3 = llvm.icmp "ugt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def sel_false_val_is_a_masked_ashr_of_true_val2_after := [llvm|
{
^0(%arg0 : i32, %arg1 : i64):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.mlir.constant(-536870897 : i32) : i32
  %2 = llvm.ashr %arg0, %0 : i32
  %3 = llvm.and %2, %1 : i32
  %4 = llvm.zext nneg %3 : i32 to i64
  %5 = llvm.ashr %arg1, %4 : i64
  "llvm.return"(%5) : (i64) -> ()
}
]

def test_mul_nuw__nuw_is_safe_before := [llvm|
{
^0(%arg10 : i32):
  %0 = llvm.mlir.constant(268435457 : i32) : i32
  %1 = llvm.mlir.constant(268435456 : i32) : i32
  %2 = llvm.mlir.constant(9 : i32) : i32
  %3 = llvm.mlir.constant(-1879048192 : i32) : i32
  %4 = llvm.and %arg10, %0 : i32
  %5 = llvm.icmp "eq" %4, %1 : i32
  %6 = llvm.mul %4, %2 overflow<nuw> : i32
  %7 = "llvm.select"(%5, %3, %6) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%7) : (i32) -> ()
}
]

def ule_umax1_after := [llvm|
{
^0(%arg52 : i32, %arg53 : i32):
  %0 = llvm.icmp "ule" %arg53, %arg52 : i32
  "llvm.return"(%0) : (i1) -> ()
}
]

def select_constants_and_icmp_ne0_before := [llvm|
{
^0(%arg26 : i1, %arg27 : i1):
  %0 = llvm.mlir.constant(2 : i8) : i8
  %1 = llvm.mlir.constant(1 : i8) : i8
  %2 = llvm.mlir.constant(0 : i8) : i8
  %3 = "llvm.select"(%arg26, %0, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  %4 = "llvm.select"(%arg27, %0, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  %5 = llvm.and %3, %4 : i8
  %6 = llvm.icmp "ne" %5, %2 : i8
  "llvm.return"(%6) : (i1) -> ()
}
]

def eq_irregular_bit_widths_before := [llvm|
{
^0(%arg114 : i31, %arg115 : i31):
  %0 = llvm.mlir.constant(7 : i31) : i31
  %1 = llvm.mlir.constant(13 : i31) : i31
  %2 = llvm.lshr %arg114, %0 : i31
  %3 = llvm.trunc %2 : i31 to i6
  %4 = llvm.lshr %arg114, %1 : i31
  %5 = llvm.trunc %4 : i31 to i5
  %6 = llvm.lshr %arg115, %0 : i31
  %7 = llvm.trunc %6 : i31 to i6
  %8 = llvm.lshr %arg115, %1 : i31
  %9 = llvm.trunc %8 : i31 to i5
  %10 = llvm.icmp "eq" %3, %7 : i6
  %11 = llvm.icmp "eq" %5, %9 : i5
  %12 = llvm.and %11, %10 : i1
  "llvm.return"(%12) : (i1) -> ()
}
]

def lshrult_02_11_after := [llvm|
{
^0(%arg340 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

elab "[RV64_com| " reg:mlir_region "]" : term => do
  SSA.elabIntoCom reg q(RV64)

def positive_biggerShl_before := [llvm|
{
^0(%arg34 : i32):
  %0 = llvm.mlir.constant(10 : i32) : i32
  %1 = llvm.mlir.constant(5 : i32) : i32
  %2 = llvm.shl %arg34, %0 : i32
  %3 = llvm.lshr %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

noncomputable def TV_add_mul_neg_one_rhs : PeepholeRewrite (ModArith q) [.modLike, .modLike] .modLike :=
{
  lhs := test_add_mul_neg_one_rhs_LHS,
  rhs := test_add_mul_neg_one_rhs_RHS,
  correct := by admit /- proof elided -/

def icmp' {w : Nat} (c : IntPred) (x y : BitVec w) : Bool :=
  match c with
    | .eq => (x == y)
    | .ne => (x != y)
    | .sgt => (x >ₛ y)
    | .sge => (x ≥ₛ y)
    | .slt => (x <ₛ y)
    | .sle => (x ≤ₛ y)
    | .ugt => (x >ᵤ y)
    | .uge => (x ≥ᵤ y)
    | .ult => (x <ᵤ y)
    | .ule => (x ≤ᵤ y)

def ugt_swap_or_not_min_logical_after := [llvm|
{
^0(%arg4 : i8, %arg5 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.icmp "ne" %arg4, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def shl_add_add_fail_before := [llvm|
{
^0(%arg166 : i8, %arg167 : i8):
  %0 = llvm.mlir.constant(2 : i8) : i8
  %1 = llvm.mlir.constant(48 : i8) : i8
  %2 = llvm.lshr %arg166, %0 : i8
  %3 = llvm.lshr %arg167, %0 : i8
  %4 = llvm.add %3, %1 : i8
  %5 = llvm.add %2, %4 : i8
  "llvm.return"(%5) : (i8) -> ()
}
]

def canonicalize_logic_first_and0_after := [llvm|
{
^0(%arg28 : i8):
  %0 = llvm.mlir.constant(-10 : i8) : i8
  %1 = llvm.mlir.constant(48 : i8) : i8
  %2 = llvm.and %arg28, %0 : i8
  %3 = llvm.add %2, %1 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def test4_after := [llvm|
{
^0(%arg206 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

def shift_no_xor_multiuse_cmp_with_xor_after := [llvm|
{
^0(%arg116 : i32, %arg117 : i32, %arg118 : i32, %arg119 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.and %arg116, %0 : i32
  %3 = llvm.icmp "eq" %2, %1 : i32
  %4 = llvm.shl %2, %0 overflow<nsw,nuw> : i32
  %5 = llvm.xor %arg117, %4 : i32
  %6 = "llvm.select"(%3, %arg118, %arg119) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %7 = llvm.mul %5, %6 : i32
  "llvm.return"(%7) : (i32) -> ()
}
]

def zext_sext_add_icmp_ne_1_after := [llvm|
{
^0(%arg70 : i1, %arg71 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.xor %arg70, %0 : i1
  %2 = llvm.or %arg71, %1 : i1
  "llvm.return"(%2) : (i1) -> ()
}
]

def or_not_and_commute5_before := [llvm|
{
^0(%arg522 : i32, %arg523 : i32, %arg524 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.sdiv %0, %arg522 : i32
  %3 = llvm.sdiv %0, %arg524 : i32
  %4 = llvm.or %2, %arg523 : i32
  %5 = llvm.xor %4, %1 : i32
  %6 = llvm.and %3, %5 : i32
  %7 = llvm.or %2, %3 : i32
  %8 = llvm.xor %7, %1 : i32
  %9 = llvm.and %8, %arg523 : i32
  %10 = llvm.or %6, %9 : i32
  "llvm.return"(%10) : (i32) -> ()
}
]

def samesign_inverted_commute3_before := [llvm|
{
^0(%arg97 : i32, %arg98 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.and %arg97, %arg98 : i32
  %3 = llvm.icmp "sgt" %2, %0 : i32
  %4 = llvm.or %arg98, %arg97 : i32
  %5 = llvm.icmp "slt" %4, %1 : i32
  %6 = llvm.and %5, %3 : i1
  "llvm.return"(%6) : (i1) -> ()
}
]

def ripple_nsw3_after := [llvm|
{
^0(%arg19 : i16, %arg20 : i16):
  %0 = llvm.mlir.constant(-21845 : i16) : i16
  %1 = llvm.mlir.constant(21843 : i16) : i16
  %2 = llvm.and %arg20, %0 : i16
  %3 = llvm.and %arg19, %1 : i16
  %4 = llvm.add %2, %3 overflow<nsw,nuw> : i16
  "llvm.return"(%4) : (i16) -> ()
}
]

def RawCNFA.empty : RawCNFA A := {
  stateMax := 0
  initials := ∅
  finals := ∅
  trans := ∅
}

def slt_swap_or_not_max_commute_logical_after := [llvm|
{
^0(%arg48 : i8, %arg49 : i8):
  %0 = llvm.mlir.constant(127 : i8) : i8
  %1 = llvm.icmp "ne" %arg48, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def in_constant_mone_vary_before := [llvm|
{
^0(%arg24 : i4, %arg25 : i4):
  %0 = llvm.mlir.constant(-1 : i4) : i4
  %1 = llvm.mlir.constant(1 : i4) : i4
  %2 = llvm.xor %arg24, %0 : i4
  %3 = llvm.and %2, %1 : i4
  %4 = llvm.xor %3, %arg24 : i4
  "llvm.return"(%4) : (i4) -> ()
}
]

@[simp, simp_denote]
instance instRefinement : DialectHRefinement SLLVM SLLVM where
  MonadIsRefinedBy := inferInstanceAs <| HRefinement (EffectM _) (EffectM _)
  IsRefinedBy := { IsRefinedBy := Ty.IsRefinedBy }

def test2_before := [llvm|
{
^0(%arg0 : i999, %arg1 : i999):
  %0 = llvm.mlir.constant(65280 : i999) : i999
  %1 = llvm.and %arg0, %0 : i999
  %2 = llvm.and %arg1, %0 : i999
  %3 = llvm.icmp "ne" %1, %2 : i999
  "llvm.return"(%3) : (i1) -> ()
}
]

def eq_umin3_before := [llvm|
{
^0(%arg56 : i32, %arg57 : i32):
  %0 = llvm.mlir.constant(3 : i32) : i32
  %1 = llvm.add %arg56, %0 : i32
  %2 = llvm.icmp "ult" %1, %arg57 : i32
  %3 = "llvm.select"(%2, %1, %arg57) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %4 = llvm.icmp "eq" %1, %3 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def neg_nsw_slt_n1_after := [llvm|
{
^0(%arg21 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.icmp "sgt" %arg21, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def test6_before := [llvm|
{
^0(%arg3 : i16):
  %0 = llvm.mlir.constant(16 : i32) : i32
  %1 = llvm.zext %arg3 : i16 to i32
  %2 = llvm.shl %1, %0 : i32
  %3 = llvm.ashr %2, %0 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def pr40493_neg1_before := [llvm|
{
^0(%arg17 : i32):
  %0 = llvm.mlir.constant(11 : i32) : i32
  %1 = llvm.mlir.constant(4 : i32) : i32
  %2 = llvm.mlir.constant(0 : i32) : i32
  %3 = llvm.mul %arg17, %0 : i32
  %4 = llvm.and %3, %1 : i32
  %5 = llvm.icmp "eq" %4, %2 : i32
  "llvm.return"(%5) : (i1) -> ()
}
]

def MatchVarResult.toHom
    (map : MatchVarResult lets v matchLets w mapIn)
    (hvars : ∀ t (v : Var Δ_in t), ⟨t, v⟩ ∈ matchLets.vars w) :
    Δ_in.Hom Γ_out :=
  map.val.toHom <| map.isTotal_of hvars

@[simp_riscv]
def neg_pseudo (rs1_val : BitVec 64) : BitVec 64 :=
  RV64.sub rs1_val 0

def n1_after := [llvm|
{
^0(%arg2 : i8, %arg3 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.mlir.constant(0 : i8) : i8
  %2 = llvm.shl %0, %arg3 overflow<nuw> : i8
  %3 = llvm.and %arg2, %2 : i8
  %4 = llvm.icmp "ne" %3, %1 : i8
  "llvm.return"(%4) : (i1) -> ()
}
]

def cmpeq_xor_cst3_before := [llvm|
{
^0(%arg22 : i32, %arg23 : i32):
  %0 = llvm.mlir.constant(10 : i32) : i32
  %1 = llvm.xor %arg22, %0 : i32
  %2 = llvm.xor %arg23, %0 : i32
  %3 = llvm.icmp "eq" %1, %2 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def or_ashr_not_commuted_before := [llvm|
{
^0(%arg51 : i8, %arg52 : i8, %arg53 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.ashr %arg51, %arg53 : i8
  %2 = llvm.ashr %arg52, %arg53 : i8
  %3 = llvm.xor %2, %0 : i8
  %4 = llvm.or %3, %1 : i8
  "llvm.return"(%4) : (i8) -> ()
}
]

def p_constmask2_before := [llvm|
{
^0(%arg41 : i32, %arg42 : i32):
  %0 = llvm.mlir.constant(61440 : i32) : i32
  %1 = llvm.mlir.constant(-65281 : i32) : i32
  %2 = llvm.and %arg41, %0 : i32
  %3 = llvm.and %arg42, %1 : i32
  %4 = llvm.add %2, %3 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def ult_and_not_max_after := [llvm|
{
^0(%arg110 : i8, %arg111 : i8):
  %0 = llvm.icmp "ult" %arg110, %arg111 : i8
  "llvm.return"(%0) : (i1) -> ()
}
]

def lshr_and_or_disjoint_after := [llvm|
{
^0(%arg43 : i8, %arg44 : i8):
  %0 = llvm.mlir.constant(42 : i8) : i8
  %1 = llvm.mlir.constant(2 : i8) : i8
  %2 = llvm.mlir.constant(52 : i8) : i8
  %3 = llvm.srem %arg43, %0 : i8
  %4 = llvm.shl %3, %1 : i8
  %5 = llvm.and %arg44, %2 : i8
  %6 = llvm.or disjoint %5, %4 : i8
  "llvm.return"(%6) : (i8) -> ()
}
]

def wrongimm2_after := [llvm|
{
^0(%arg4 : i16):
  %0 = llvm.mlir.constant(8 : i16) : i16
  %1 = llvm.mlir.constant(6 : i8) : i8
  %2 = llvm.lshr %arg4, %0 : i16
  %3 = llvm.trunc %2 overflow<nuw> : i16 to i8
  %4 = llvm.trunc %arg4 : i16 to i8
  %5 = llvm.ashr %4, %1 : i8
  %6 = llvm.icmp "eq" %5, %3 : i8
  "llvm.return"(%6) : (i1) -> ()
}
]

def t2_after := [llvm|
{
^0(%arg8 : i64):
  %0 = llvm.mlir.constant(63) : i64
  %1 = llvm.lshr %arg8, %0 : i64
  %2 = llvm.trunc %1 overflow<nsw,nuw> : i64 to i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def scalar_i16_shl_ult_const_after := [llvm|
{
^0(%arg16 : i16):
  %0 = llvm.mlir.constant(252 : i16) : i16
  %1 = llvm.mlir.constant(0 : i16) : i16
  %2 = llvm.and %arg16, %0 : i16
  %3 = llvm.icmp "eq" %2, %1 : i16
  "llvm.return"(%3) : (i1) -> ()
}
]

RV64.sraiw in RISCV.Instructions

def test5_before := [llvm|
{
^0(%arg0 : i8):
  %0 = llvm.mlir.constant(127 : i8) : i8
  %1 = llvm.icmp "slt" %arg0, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def shl_or_with_or_disjoint_instead_of_add_before := [llvm|
{
^0(%arg1 : i8):
  %0 = llvm.mlir.constant(16 : i8) : i8
  %1 = llvm.mlir.constant(1 : i8) : i8
  %2 = llvm.mlir.constant(3 : i8) : i8
  %3 = llvm.shl %0, %arg1 : i8
  %4 = llvm.or disjoint %arg1, %1 : i8
  %5 = llvm.shl %2, %4 : i8
  %6 = llvm.or %3, %5 : i8
  "llvm.return"(%6) : (i8) -> ()
}
]

def bools2_logical_commute1_and1_before := [llvm|
{
^0(%arg49 : i1, %arg50 : i1, %arg51 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.mlir.constant(false) : i1
  %2 = llvm.xor %arg51, %0 : i1
  %3 = llvm.and %arg49, %arg51 : i1
  %4 = "llvm.select"(%2, %arg50, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %5 = "llvm.select"(%3, %0, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%5) : (i1) -> ()
}
]

def sameBothSides (pred : FpPredicate) : Bool :=
  match pred with
  | FpPredicate.bin lhs _ rhs => lhs == rhs

def sge_and_max_logical_after := [llvm|
{
^0(%arg254 : i8, %arg255 : i8):
  %0 = llvm.mlir.constant(127 : i8) : i8
  %1 = llvm.icmp "eq" %arg254, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def t2_symmetry_after := [llvm|
{
^0(%arg37 : i8, %arg38 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.xor %arg37, %0 : i8
  %2 = llvm.icmp "ule" %arg38, %1 : i8
  "llvm.return"(%2) : (i1) -> ()
}
]

def narrow_sext_xor_before := [llvm|
{
^0(%arg48 : i16, %arg49 : i32):
  %0 = llvm.sext %arg48 : i16 to i32
  %1 = llvm.xor %0, %arg49 : i32
  %2 = llvm.trunc %1 : i32 to i16
  "llvm.return"(%2) : (i16) -> ()
}
]

def sub_add_reg_x_sub_x_add_y : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64), Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%x: i64, %y: i64):
      %1 = llvm.add %x, %y : i64
      %2 = llvm.sub %x, %1 : i64
      llvm.return %2 : i64
  }]
  rhs := [LV| {
    ^entry (%x: i64, %y: i64):
      %c = llvm.mlir.constant (0) : i64
      %0 = llvm.sub %c, %y : i64
      llvm.return %0 : i64
  }]

def foo_before := [llvm|
{
^0(%arg0 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.mlir.constant(7 : i32) : i32
  %2 = llvm.or %0, %1 : i32
  %3 = llvm.and %arg0, %2 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def t0_after := [llvm|
{
^0(%arg14 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.icmp "slt" %arg14, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def absdiff1_before := [llvm|
{
^0(%arg2 : i64, %arg3 : i64):
  %0 = llvm.icmp "ult" %arg2, %arg3 : i64
  %1 = llvm.sext %0 : i1 to i64
  %2 = llvm.sub %arg2, %arg3 : i64
  %3 = llvm.xor %2, %1 : i64
  %4 = llvm.sub %3, %1 : i64
  "llvm.return"(%4) : (i64) -> ()
}
]

def lshrult_03_11_exact_after := [llvm|
{
^0(%arg106 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def constLLVM38 : Com LLVMPlusRiscV ⟨[]⟩ .pure (.llvm (.bitvec 64)) := [LV| {
  ^entry ():
    %1 = llvm.mlir.constant (38) : i64
    llvm.return %1 : i64
  }]

def sgt_and_min_logical_after := [llvm|
{
^0(%arg350 : i9, %arg351 : i9):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def uadd_sat_via_add_swapped_cmp_nonstrict_after := [llvm|
{
^0(%arg4 : i32, %arg5 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.add %arg4, %arg5 : i32
  %2 = llvm.icmp "ult" %arg5, %1 : i32
  %3 = "llvm.select"(%2, %1, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def trunc_shl_31_i32_i64_before := [llvm|
{
^0(%arg43 : i64):
  %0 = llvm.mlir.constant(31) : i64
  %1 = llvm.shl %arg43, %0 : i64
  %2 = llvm.trunc %1 : i64 to i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def lowbitmask_casted_shift_after := [llvm|
{
^0(%arg157 : i8):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.sext %arg157 : i8 to i32
  %2 = llvm.lshr %1, %0 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def ashrslt_03_03_exact_after := [llvm|
{
^0(%arg18 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def eval (assign : Std.HashMap Nat BVExpr.PackedBitVec) : FpExpr e → PackedFloat e mfixed
  | .var idx =>
    let packedBv := assign[idx]!
     
    if h : packedBv.w = 1 + e + mfixed then
     PackedFloat.ofBV (packedBv.bv.cast h)
    else
      
      PackedFloat.ofBV (packedBv.bv.setWidth _)
  | .const val => PackedFloat.ofBV val
  | .bin lhs op rhs =>
      match op with
        
      | .add => add (eval assign lhs) (eval assign rhs) .RNE

def or_logic_or_logic_and_7_after := [llvm|
{
^0(%arg30 : i1, %arg31 : i1, %arg32 : i1):
  %0 = llvm.mlir.constant(false) : i1
  %1 = llvm.mlir.constant(true) : i1
  %2 = "llvm.select"(%arg32, %arg31, %0) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %3 = "llvm.select"(%arg30, %1, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def mul128_low_after := [llvm|
{
^0(%arg18 : i128, %arg19 : i128):
  %0 = llvm.mul %arg18, %arg19 : i128
  "llvm.return"(%0) : (i128) -> ()
}
]

def icmp_slt_0_and_icmp_ne_neg2_i32_fail_before := [llvm|
{
^0(%arg44 : i32):
  %0 = llvm.mlir.constant(-2 : i32) : i32
  %1 = llvm.mlir.constant(31 : i32) : i32
  %2 = llvm.icmp "ne" %arg44, %0 : i32
  %3 = llvm.zext %2 : i1 to i32
  %4 = llvm.lshr %arg44, %1 : i32
  %5 = llvm.and %4, %3 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

instance : DecidableEq TestDialect.Ty :=

def masked_icmps_mask_notallzeros_bmask_mixed_swapped_4_logical_before := [llvm|
{
^0(%arg39 : i32):
  %0 = llvm.mlir.constant(255 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(15 : i32) : i32
  %3 = llvm.mlir.constant(8 : i32) : i32
  %4 = llvm.mlir.constant(false) : i1
  %5 = llvm.and %arg39, %0 : i32
  %6 = llvm.icmp "ne" %5, %1 : i32
  %7 = llvm.and %arg39, %2 : i32
  %8 = llvm.icmp "eq" %7, %3 : i32
  %9 = "llvm.select"(%8, %6, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%9) : (i1) -> ()
}
]

def lshrugt_02_05_exact_after := [llvm|
{
^0(%arg200 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def masked_icmps_mask_notallzeros_bmask_mixed_6_logical_before := [llvm|
{
^0(%arg79 : i32):
  %0 = llvm.mlir.constant(12 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(15 : i32) : i32
  %3 = llvm.mlir.constant(8 : i32) : i32
  %4 = llvm.mlir.constant(false) : i1
  %5 = llvm.and %arg79, %0 : i32
  %6 = llvm.icmp "ne" %5, %1 : i32
  %7 = llvm.and %arg79, %2 : i32
  %8 = llvm.icmp "eq" %7, %3 : i32
  %9 = "llvm.select"(%6, %8, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%9) : (i1) -> ()
}
]

def apply_patterns {Γl : List DCPlus.Ty} (fuel : Nat)
  (prog : Com DCPlus (Ctxt.ofList Γl) .pure ([.tokenstream])) :=
   multiRewritePeephole fuel rewrite_patterns prog

def and_logic_and_logic_or_7_after := [llvm|
{
^0(%arg120 : i1, %arg121 : i1, %arg122 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.mlir.constant(false) : i1
  %2 = "llvm.select"(%arg122, %0, %arg121) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %3 = "llvm.select"(%arg120, %2, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def test_sub_nsw__none_are_safe_before := [llvm|
{
^0(%arg17 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(-2147483648 : i32) : i32
  %2 = llvm.mlir.constant(2147483647 : i32) : i32
  %3 = llvm.icmp "eq" %arg17, %0 : i32
  %4 = llvm.sub %1, %arg17 overflow<nsw> : i32
  %5 = "llvm.select"(%3, %2, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def ashrslt_02_08_after := [llvm|
{
^0(%arg245 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

@[simp_denote]
def sdiv_riscv_32 := [LV| {
  ^entry (%reg1: i32, %reg2: i32):
    %0 = "builtin.unrealized_conversion_cast"(%reg1) : (i32) -> (!i64)
    %1 = "builtin.unrealized_conversion_cast"(%reg2) : (i32) -> (!i64)
    %2 = div %0, %1 : !i64
    %3 = "builtin.unrealized_conversion_cast"(%2) : (!i64) -> (i32)
    llvm.return %3 : i32
  }]

def p2_scalar_shifted_urem_by_const_before := [llvm|
{
^0(%arg16 : i32, %arg17 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(3 : i32) : i32
  %2 = llvm.mlir.constant(0 : i32) : i32
  %3 = llvm.and %arg16, %0 : i32
  %4 = llvm.shl %3, %arg17 : i32
  %5 = llvm.urem %4, %1 : i32
  %6 = llvm.icmp "eq" %5, %2 : i32
  "llvm.return"(%6) : (i1) -> ()
}
]

def not_and_and_or_not_or_or_commute3_after := [llvm|
{
^0(%arg232 : i32, %arg233 : i32, %arg234 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.sdiv %0, %arg233 : i32
  %3 = llvm.xor %arg234, %2 : i32
  %4 = llvm.or %3, %arg232 : i32
  %5 = llvm.xor %4, %1 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

@[simp_denote]
def sub_riscv_i64 :=
  [LV| {
    ^entry (%arg0: i64, %arg1: i64):
    %a = "builtin.unrealized_conversion_cast" (%arg0) : (i64) -> (!i64)
    %b = "builtin.unrealized_conversion_cast" (%arg1) : (i64) -> (!i64)
    %0 = sub %a, %b : !i64
    %1 = "builtin.unrealized_conversion_cast" (%0) : (!i64) -> (i64)
    llvm.return %1 : i64
  }]

inductive IcmpPredicate where
  | eq
  | ne
  | slt
  | sle
  | sgt
  | sge
  | ult
  | ule
  | ugt
  | uge
deriving Inhabited, DecidableEq, Repr

def icmp_ult_8_after := [llvm|
{
^0(%arg12 : i64):
  %0 = llvm.mlir.constant(16) : i64
  %1 = llvm.icmp "ult" %arg12, %0 : i64
  "llvm.return"(%1) : (i1) -> ()
}
]

def uge_swap_or_max_before := [llvm|
{
^0(%arg166 : i8, %arg167 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.icmp "ule" %arg167, %arg166 : i8
  %2 = llvm.icmp "eq" %arg166, %0 : i8
  %3 = llvm.or %1, %2 : i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def and_sext_to_sel_before := [llvm|
{
^0(%arg41 : i32, %arg42 : i1):
  %0 = llvm.sext %arg42 : i1 to i32
  %1 = llvm.and %0, %arg41 : i32
  "llvm.return"(%1) : (i32) -> ()
}
]

unsafe def elabIntoTermElab {α : Type} (expectedType : Expr) (stx : Lean.Syntax) :
    Elab.Term.TermElabM α := do
  elabIntoTermTactic (α := α) expectedType stx  |>.runCore' { elaborator := `ParserHack} default

def ashr_pow2_ugt_before := [llvm|
{
^0(%arg67 : i8):
  %0 = llvm.mlir.constant(-128 : i8) : i8
  %1 = llvm.mlir.constant(-96 : i8) : i8
  %2 = llvm.ashr %0, %arg67 : i8
  %3 = llvm.icmp "ugt" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def positive_sameconst_shlnuwnsw_before := [llvm|
{
^0(%arg46 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.ashr %arg46, %0 : i8
  %2 = llvm.shl %1, %0 overflow<nsw,nuw> : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

abbrev Comb : Dialect where
  Op := Op
  Ty := Ty

def ashrsgt_02_04_exact_before := [llvm|
{
^0(%arg81 : i4):
  %0 = llvm.mlir.constant(2 : i4) : i4
  %1 = llvm.mlir.constant(4 : i4) : i4
  %2 = llvm.ashr exact %arg81, %0 : i4
  %3 = llvm.icmp "sgt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

NFA.eval in Mathlib.Computability.NFA

def trunc_shl_zext_32_before := [llvm|
{
^0(%arg1 : i32):
  %0 = llvm.mlir.constant(4 : i16) : i16
  %1 = llvm.trunc %arg1 : i32 to i16
  %2 = llvm.shl %1, %0 : i16
  %3 = llvm.zext %2 : i16 to i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def foo1_or_signbit_lshr_without_shifting_signbit_before := [llvm|
{
^0(%arg112 : i32, %arg113 : i32, %arg114 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.shl %0, %arg113 : i32
  %3 = llvm.and %2, %arg112 : i32
  %4 = llvm.icmp "ne" %3, %1 : i32
  %5 = llvm.shl %arg112, %arg114 : i32
  %6 = llvm.icmp "slt" %5, %1 : i32
  %7 = llvm.and %4, %6 : i1
  "llvm.return"(%7) : (i1) -> ()
}
]

def select_icmp_eq_pow2_flipped_after := [llvm|
{
^0(%arg12 : i8):
  %0 = llvm.mlir.constant(4 : i8) : i8
  %1 = llvm.or %arg12, %0 : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def shl_xor_after := [llvm|
{
^0(%arg63 : i32, %arg64 : i32):
  %0 = llvm.mlir.constant(12 : i32) : i32
  %1 = llvm.mlir.constant(7 : i32) : i32
  %2 = llvm.shl %arg63, %0 : i32
  %3 = llvm.shl %arg64, %1 : i32
  %4 = llvm.xor %2, %3 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def shl_and_and_before := [llvm|
{
^0(%arg172 : i8, %arg173 : i8):
  %0 = llvm.mlir.constant(4 : i8) : i8
  %1 = llvm.mlir.constant(88 : i8) : i8
  %2 = llvm.shl %arg172, %0 : i8
  %3 = llvm.shl %arg173, %0 : i8
  %4 = llvm.and %3, %1 : i8
  %5 = llvm.and %2, %4 : i8
  "llvm.return"(%5) : (i8) -> ()
}
]

def mul8_low_after := [llvm|
{
^0(%arg26 : i8, %arg27 : i8):
  %0 = llvm.mul %arg26, %arg27 : i8
  "llvm.return"(%0) : (i8) -> ()
}
]

def src_is_mask_shl_lshr_after := [llvm|
{
^0(%arg103 : i8, %arg104 : i8, %arg105 : i1):
  %0 = llvm.mlir.constant(122 : i8) : i8
  %1 = llvm.mlir.constant(-1 : i8) : i8
  %2 = llvm.xor %arg103, %0 : i8
  %3 = llvm.lshr %1, %arg104 : i8
  %4 = llvm.icmp "ugt" %2, %3 : i8
  "llvm.return"(%4) : (i1) -> ()
}
]

def or_not_and_and_not_and_xor_commute4_after := [llvm|
{
^0(%arg277 : i32, %arg278 : i32, %arg279 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.sdiv %0, %arg277 : i32
  %3 = llvm.and %arg278, %arg279 : i32
  %4 = llvm.xor %3, %1 : i32
  %5 = llvm.or %2, %4 : i32
  %6 = llvm.xor %arg278, %arg279 : i32
  %7 = llvm.and %2, %6 : i32
  %8 = llvm.xor %7, %5 : i32
  "llvm.return"(%8) : (i32) -> ()
}
]

def negate_add_with_single_negatible_operand_after := [llvm|
{
^0(%arg23 : i8, %arg24 : i8):
  %0 = llvm.mlir.constant(-42 : i8) : i8
  %1 = llvm.sub %0, %arg23 : i8
  "llvm.return"(%1) : (i8) -> ()
}
]

def test7_after := [llvm|
{
^0(%arg16 : i77):
  %0 = llvm.mlir.constant(-1 : i77) : i77
  %1 = llvm.xor %arg16, %0 : i77
  "llvm.return"(%1) : (i77) -> ()
}
]

def icmp_select_var_select_before := [llvm|
{
^0(%arg83 : i8, %arg84 : i8, %arg85 : i1):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = "llvm.select"(%arg85, %arg83, %arg84) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  %2 = llvm.icmp "eq" %arg83, %0 : i8
  %3 = "llvm.select"(%2, %1, %arg84) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  %4 = llvm.icmp "eq" %1, %3 : i8
  "llvm.return"(%4) : (i1) -> ()
}
]

def lt_signed_to_small_signed_before := [llvm|
{
^0(%arg49 : i8):
  %0 = llvm.mlir.constant(17 : i32) : i32
  %1 = llvm.sext %arg49 : i8 to i32
  %2 = llvm.icmp "slt" %1, %0 : i32
  "llvm.return"(%2) : (i1) -> ()
}
]

def test_ashr_exact__exact_is_safe_before := [llvm|
{
^0(%arg54 : i32, %arg55 : i64):
  %0 = llvm.mlir.constant(-2147483588 : i32) : i32
  %1 = llvm.mlir.constant(2 : i32) : i32
  %2 = llvm.mlir.constant(0 : i32) : i32
  %3 = llvm.and %arg54, %0 : i32
  %4 = llvm.ashr exact %3, %1 : i32
  %5 = llvm.zext %4 : i32 to i64
  %6 = llvm.icmp "eq" %3, %2 : i32
  %7 = llvm.ashr %arg55, %5 : i64
  %8 = "llvm.select"(%6, %arg55, %7) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i64, i64) -> i64
  "llvm.return"(%8) : (i64) -> ()
}
]

def foo1_and_signbit_lshr_without_shifting_signbit_logical_after := [llvm|
{
^0(%arg115 : i32, %arg116 : i32, %arg117 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(-1 : i32) : i32
  %3 = llvm.mlir.constant(true) : i1
  %4 = llvm.shl %0, %arg116 overflow<nuw> : i32
  %5 = llvm.and %4, %arg115 : i32
  %6 = llvm.icmp "eq" %5, %1 : i32
  %7 = llvm.shl %arg115, %arg117 : i32
  %8 = llvm.icmp "sgt" %7, %2 : i32
  %9 = "llvm.select"(%6, %3, %8) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%9) : (i1) -> ()
}
]

def pr33078_1_before := [llvm|
{
^0(%arg5 : i8):
  %0 = llvm.mlir.constant(8 : i16) : i16
  %1 = llvm.sext %arg5 : i8 to i16
  %2 = llvm.lshr %1, %0 : i16
  %3 = llvm.trunc %2 : i16 to i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def factorize2_after := [llvm|
{
^0(%arg8 : i32):
  "llvm.return"(%arg8) : (i32) -> ()
}
]

def main7d_before := [llvm|
{
^0(%arg64 : i32, %arg65 : i32, %arg66 : i32, %arg67 : i32, %arg68 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.mlir.constant(1 : i32) : i32
  %2 = llvm.and %arg65, %arg67 : i32
  %3 = llvm.and %arg66, %arg68 : i32
  %4 = llvm.and %arg64, %2 : i32
  %5 = llvm.icmp "eq" %4, %2 : i32
  %6 = llvm.and %arg64, %3 : i32
  %7 = llvm.icmp "eq" %6, %3 : i32
  %8 = llvm.and %5, %7 : i1
  %9 = "llvm.select"(%8, %0, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%9) : (i32) -> ()
}
]

def unsigned_equiv cmp : (CNFA.autUnsignedCmp cmp).m.states ≃ (NFA'.autUnsignedCmp cmp).σ where
  toFun := fun ⟨s, hs⟩ =>
    match s with
    | 0 => .eq
    | 1 => .gt
    | _ => .lt
  invFun q :=
    match q with
    | .eq => ⟨0, by admit /- proof elided -/
    ⟩
    | .gt => ⟨1, by admit /- proof elided -/
    ⟩
    | .lt => ⟨2, by admit /- proof elided -/
    ⟩
  left_inv := by admit /- proof elided -/

Neg in Init.Prelude

def test_with_even_before := [llvm|
{
^0(%arg313 : i32):
  %0 = llvm.mlir.constant(4 : i32) : i32
  %1 = llvm.mlir.constant(1 : i32) : i32
  %2 = llvm.shl %0, %arg313 : i32
  %3 = llvm.and %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def ashrsgt_02_00_before := [llvm|
{
^0(%arg301 : i4):
  %0 = llvm.mlir.constant(2 : i4) : i4
  %1 = llvm.mlir.constant(0 : i4) : i4
  %2 = llvm.ashr %arg301, %0 : i4
  %3 = llvm.icmp "sgt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def llvm_const_lower_riscv_li_47 : LLVMPeepholeRewriteRefine 64 [] :=
  {lhs := constLLVM_47, rhs:= liRiscv_47,
   correct := by admit /- proof elided -/

def src_is_mask_const_slt_before := [llvm|
{
^0(%arg48 : i8):
  %0 = llvm.mlir.constant(123 : i8) : i8
  %1 = llvm.mlir.constant(7 : i8) : i8
  %2 = llvm.xor %arg48, %0 : i8
  %3 = llvm.and %2, %1 : i8
  %4 = llvm.icmp "slt" %2, %3 : i8
  "llvm.return"(%4) : (i1) -> ()
}
]

def mulo_by_2_unsigned_signed : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%x: i64):
      %c = llvm.mlir.constant (2) : i64
      %0 = llvm.mul %x, %c overflow<nsw, nuw> : i64
      llvm.return %0 : i64
  }]
  rhs := [LV| {
    ^entry (%x: i64):
      %0 = llvm.add %x, %x overflow<nsw, nuw> : i64
      llvm.return %0 : i64
  }]

def demorgan_nor_after := [llvm|
{
^0(%arg32 : i8, %arg33 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.xor %arg33, %0 : i8
  %2 = llvm.and %arg32, %1 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def icmp_eq_or_z_or_pow2orz_logical_after := [llvm|
{
^0(%arg25 : i8, %arg26 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.sub %0, %arg26 : i8
  %2 = llvm.and %arg26, %1 : i8
  %3 = llvm.and %arg25, %2 : i8
  %4 = llvm.icmp "eq" %3, %arg25 : i8
  "llvm.return"(%4) : (i1) -> ()
}
]

def test_shl_nuw_nsw__all_are_safe_after := [llvm|
{
^0(%arg90 : i32, %arg91 : i64):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.mlir.constant(60 : i32) : i32
  %2 = llvm.shl %arg90, %0 : i32
  %3 = llvm.and %2, %1 : i32
  %4 = llvm.zext nneg %3 : i32 to i64
  %5 = llvm.ashr %arg91, %4 : i64
  "llvm.return"(%5) : (i64) -> ()
}
]

def or_eq_with_one_bit_diff_constants1_logical_before := [llvm|
{
^0(%arg365 : i32):
  %0 = llvm.mlir.constant(50 : i32) : i32
  %1 = llvm.mlir.constant(51 : i32) : i32
  %2 = llvm.mlir.constant(true) : i1
  %3 = llvm.icmp "eq" %arg365, %0 : i32
  %4 = llvm.icmp "eq" %arg365, %1 : i32
  %5 = "llvm.select"(%3, %2, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%5) : (i1) -> ()
}
]

def trunc_shl_7_i8_i64_after := [llvm|
{
^0(%arg37 : i64):
  %0 = llvm.mlir.constant(7 : i8) : i8
  %1 = llvm.trunc %arg37 : i64 to i8
  %2 = llvm.shl %1, %0 : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

structure Bisimul (R : SetRel σ ς) (M₁ : NFA α σ) (M₂ : NFA α ς) where
  accept : q₁ ~[R] q₂ → (q₁ ∈ M₁.accept ↔ q₂ ∈ M₂.accept)
  start : R.set_eq M₁.start M₂.start
  trans_match₁ : q₁ ~[R] q₂ → q₁' ∈ M₁.step q₁ a → ∃ q₂', q₂' ∈ M₂.step q₂ a ∧ q₁' ~[R] q₂'
  trans_match₂ : q₁ ~[R] q₂ → q₂' ∈ M₂.step q₂ a → ∃ q₁', q₁' ∈ M₁.step q₁ a ∧ q₁' ~[R] q₂'

def icmp_eq_x_invertable_y2_todo_before := [llvm|
{
^0(%arg4 : i8, %arg5 : i1):
  %0 = llvm.mlir.constant(7 : i8) : i8
  %1 = llvm.mlir.constant(24 : i8) : i8
  %2 = "llvm.select"(%arg5, %0, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  %3 = llvm.and %arg4, %2 : i8
  %4 = llvm.icmp "eq" %2, %3 : i8
  "llvm.return"(%4) : (i1) -> ()
}
]

def test_negative_nuw_and_signed_pred_after := [llvm|
{
^0(%arg53 : i64):
  %0 = llvm.mlir.constant(7) : i64
  %1 = llvm.icmp "ugt" %arg53, %0 : i64
  "llvm.return"(%1) : (i1) -> ()
}
]

def slt_to_ugt_before := [llvm|
{
^0(%arg28 : i8, %arg29 : i8):
  %0 = llvm.mlir.constant(127 : i8) : i8
  %1 = llvm.xor %arg28, %0 : i8
  %2 = llvm.xor %arg29, %0 : i8
  %3 = llvm.icmp "slt" %1, %2 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def function : Parser :=
  leading_parser argumentList >> arrow >> termParser

def nonempty [DecidableEq α] (c : Circuit α) : Bool :=
  (nonemptyAux c c.vars rfl).1

def trunc_equality_nuw_zext_before := [llvm|
{
^0(%arg20 : i32, %arg21 : i8):
  %0 = llvm.trunc %arg20 overflow<nuw> : i32 to i16
  %1 = llvm.zext %arg21 : i8 to i16
  %2 = llvm.icmp "ne" %0, %1 : i16
  "llvm.return"(%2) : (i1) -> ()
}
]

def select_sub_icmp_after := [llvm|
{
^0(%arg214 : i32, %arg215 : i32, %arg216 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.icmp "eq" %arg214, %0 : i32
  %2 = "llvm.select"(%1, %arg216, %arg215) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def trunc_shl_lshr_infloop_before := [llvm|
{
^0(%arg26 : i64):
  %0 = llvm.mlir.constant(1) : i64
  %1 = llvm.mlir.constant(2) : i64
  %2 = llvm.lshr %arg26, %0 : i64
  %3 = llvm.shl %2, %1 : i64
  %4 = llvm.trunc %3 : i64 to i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def ashr_ashr_before := [llvm|
{
^0(%arg7 : i32):
  %0 = llvm.mlir.constant(5 : i32) : i32
  %1 = llvm.mlir.constant(7 : i32) : i32
  %2 = llvm.ashr %arg7, %0 : i32
  %3 = llvm.ashr %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def sgt_3_impliesT_sgt_2_after := [llvm|
{
^0(%arg14 : i8, %arg15 : i8):
  %0 = llvm.mlir.constant(4 : i8) : i8
  %1 = llvm.mlir.constant(false) : i1
  %2 = llvm.icmp "slt" %arg14, %0 : i8
  %3 = llvm.icmp "sgt" %arg15, %arg14 : i8
  %4 = "llvm.select"(%2, %3, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def idempotent_prop : List (Σ Γ, LLVMPeepholeRewriteRefine 64 Γ) :=
  [⟨_, idempotent_prop_freeze⟩]

def positive_biggershl_shlnuw_after := [llvm|
{
^0(%arg54 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.mlir.constant(-64 : i8) : i8
  %2 = llvm.shl %arg54, %0 overflow<nuw> : i8
  %3 = llvm.and %2, %1 : i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def test23_logical_before := [llvm|
{
^0(%arg275 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.mlir.constant(2 : i32) : i32
  %2 = llvm.mlir.constant(false) : i1
  %3 = llvm.icmp "sgt" %arg275, %0 : i32
  %4 = llvm.icmp "sle" %arg275, %1 : i32
  %5 = "llvm.select"(%3, %4, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%5) : (i1) -> ()
}
]

inductive AttrDict where
  | mk: List AttrEntry -> AttrDict

def sle_swap_and_min_logical_after := [llvm|
{
^0(%arg212 : i8, %arg213 : i8):
  %0 = llvm.mlir.constant(-128 : i8) : i8
  %1 = llvm.icmp "eq" %arg212, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def n2_after := [llvm|
{
^0(%arg42 : i64, %arg43 : i32):
  %0 = llvm.mlir.constant(32 : i32) : i32
  %1 = llvm.mlir.constant(131071 : i32) : i32
  %2 = llvm.mlir.constant(-16 : i32) : i32
  %3 = llvm.mlir.constant(0 : i32) : i32
  %4 = llvm.sub %0, %arg43 : i32
  %5 = llvm.shl %1, %4 : i32
  %6 = llvm.add %arg43, %2 : i32
  %7 = llvm.zext nneg %6 : i32 to i64
  %8 = llvm.lshr %arg42, %7 : i64
  %9 = llvm.trunc %8 : i64 to i32
  %10 = llvm.and %5, %9 : i32
  %11 = llvm.icmp "ne" %10, %3 : i32
  "llvm.return"(%11) : (i1) -> ()
}
]

def ashr_ugt_9_before := [llvm|
{
^0(%arg105 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(-7 : i4) : i4
  %2 = llvm.ashr %arg105, %0 : i4
  %3 = llvm.icmp "ugt" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def test_xor_eq_before := [llvm|
{
^0(%arg61 : i8, %arg62 : i8, %arg63 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.xor %arg63, %0 : i8
  %2 = llvm.xor %arg62, %0 : i8
  %3 = llvm.xor %2, %arg61 : i8
  %4 = llvm.icmp "eq" %1, %3 : i8
  "llvm.return"(%4) : (i1) -> ()
}
]

def ashrsgt_01_00_after := [llvm|
{
^0(%arg319 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.icmp "sgt" %arg319, %0 : i4
  "llvm.return"(%1) : (i1) -> ()
}
]

def test_after := [llvm|
{
^0(%arg0 : i64):
  %0 = llvm.mlir.constant(16) : i64
  %1 = llvm.shl %arg0, %0 : i64
  %2 = llvm.ashr exact %1, %0 : i64
  "llvm.return"(%2) : (i64) -> ()
}
]

def sle_swap_or_not_min_after := [llvm|
{
^0(%arg280 : i8, %arg281 : i8):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def scalar_i16_shl_ult_const_before := [llvm|
{
^0(%arg16 : i16):
  %0 = llvm.mlir.constant(8 : i16) : i16
  %1 = llvm.mlir.constant(1024 : i16) : i16
  %2 = llvm.shl %arg16, %0 : i16
  %3 = llvm.icmp "ult" %2, %1 : i16
  "llvm.return"(%3) : (i1) -> ()
}
]

instance : DecidableNFA' (NFA'.autMsbSet) where

def neg_nsw_slt_n1_after := [llvm|
{
^0(%arg21 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.icmp "sgt" %arg21, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def n2_after := [llvm|
{
^0(%arg19 : i1, %arg20 : i8, %arg21 : i8, %arg22 : i8, %arg23 : i8):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.icmp "eq" %arg20, %arg21 : i8
  %2 = llvm.xor %arg19, %0 : i1
  %3 = llvm.or %1, %2 : i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def test1_before := [llvm|
{
^0(%arg6 : i8, %arg7 : i8):
  %0 = llvm.zext %arg6 : i8 to i64
  %1 = llvm.zext %arg7 : i8 to i64
  %2 = llvm.add %0, %1 : i64
  %3 = llvm.trunc %2 : i64 to i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def icmp_slt_sext_ne_zero_nofold_after := [llvm|
{
^0(%arg5 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.icmp "ne" %arg5, %0 : i32
  %2 = llvm.sext %1 : i1 to i32
  %3 = llvm.icmp "sgt" %arg5, %2 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def lshrugt_02_04_after := [llvm|
{
^0(%arg395 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def compose [FinEnum arity] [DecidableEq arity] [Hashable arity]
    (new_arity : Type)        
    (q_arity : arity → Type)  
    (vars : ∀ (a : arity), q_arity a → new_arity)
    
    
    (q : ∀ (a : arity), FSM (q_arity a)) : 
    FSM new_arity :=
  { α := p.α ⊕ (Σ a, (q a).α),
    i := by admit /- proof elided -/

def add_nuw_nsw_or_and_after := [llvm|
{
^0(%arg7 : i32, %arg8 : i32):
  %0 = llvm.add %arg7, %arg8 overflow<nsw,nuw> : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

def neg_mask_before := [llvm|
{
^0(%arg1 : i32, %arg2 : i16):
  %0 = llvm.mlir.constant(15 : i16) : i16
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.sext %arg2 : i16 to i32
  %3 = llvm.sub %arg1, %2 overflow<nsw> : i32
  %4 = llvm.lshr %arg2, %0 : i16
  %5 = llvm.zext %4 : i16 to i32
  %6 = llvm.sub %1, %5 overflow<nsw> : i32
  %7 = llvm.and %3, %6 : i32
  "llvm.return"(%7) : (i32) -> ()
}
]

def sle_and_min_commute_logical_after := [llvm|
{
^0(%arg216 : i8, %arg217 : i8):
  %0 = llvm.mlir.constant(-128 : i8) : i8
  %1 = llvm.icmp "eq" %arg216, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def getAttr? : String → Option (AttrValue φ) :=
  op.attrs.getAttr

def ne_smax4_before := [llvm|
{
^0(%arg41 : i32, %arg42 : i32):
  %0 = llvm.mlir.constant(3 : i32) : i32
  %1 = llvm.add %arg41, %0 : i32
  %2 = llvm.icmp "sgt" %arg42, %1 : i32
  %3 = "llvm.select"(%2, %arg42, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %4 = llvm.icmp "ne" %1, %3 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def lshr_sext_i1_to_i16_before := [llvm|
{
^0(%arg54 : i1):
  %0 = llvm.mlir.constant(4 : i16) : i16
  %1 = llvm.sext %arg54 : i1 to i16
  %2 = llvm.lshr %1, %0 : i16
  "llvm.return"(%2) : (i16) -> ()
}
]

def unpack (x : ValueStream (BitVec w)) : ValueStream (BitVec w) × TokenStream :=
  Stream.corec₂ (β := Stream (BitVec w)) (x)
    fun x => Id.run <| do
      match x 0 with
      | some _ => return (x 0, some (), x.tail)
      | none => return (none, none, x.tail)

@[match_pattern] def udiv (w : Width φ)
  (ExactFlag : ExactFlag := {exact := false} ) : MOp φ
    := .binary w (.udiv ExactFlag )

def trunc_lshr_zext_before := [llvm|
{
^0(%arg12 : i8):
  %0 = llvm.mlir.constant(6 : i32) : i32
  %1 = llvm.zext %arg12 : i8 to i32
  %2 = llvm.lshr %1, %0 : i32
  %3 = llvm.trunc %2 : i32 to i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def main3c_logical_before := [llvm|
{
^0(%arg144 : i32):
  %0 = llvm.mlir.constant(7 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(48 : i32) : i32
  %3 = llvm.mlir.constant(true) : i1
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.and %arg144, %0 : i32
  %6 = llvm.icmp "ne" %5, %1 : i32
  %7 = llvm.and %arg144, %2 : i32
  %8 = llvm.icmp "ne" %7, %1 : i32
  %9 = "llvm.select"(%6, %3, %8) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %10 = "llvm.select"(%9, %1, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%10) : (i32) -> ()
}
]

def and_not_or_commute5_after := [llvm|
{
^0(%arg466 : i32, %arg467 : i32, %arg468 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(-1 : i32) : i32
  %2 = llvm.sdiv %0, %arg466 : i32
  %3 = llvm.sdiv %0, %arg468 : i32
  %4 = llvm.xor %arg467, %3 : i32
  %5 = llvm.and %4, %2 : i32
  %6 = llvm.xor %5, %1 : i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def alive_AddSub_1043_tgt  (w : Nat)  :=
[llvm( w )| {
^bb0(%C1 : _, %Z : _, %RHS : _):
  %v1 = llvm.not %C1
  %v2 = llvm.or %Z, %v1
  %v3 = llvm.and %Z, %C1
  %v4 = llvm.xor %v3, %C1
  %v5 = llvm.mlir.constant 1
  %v6 = llvm.add %v4, %v5
  %v7 = llvm.sub %RHS, %v2
  llvm.return %v7
}]

def uge_and_max_commute_logical_after := [llvm|
{
^0(%arg232 : i8, %arg233 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.icmp "eq" %arg232, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

partial def printBlockArgs (Γ : Ctxt d.Ty) : String :=
  let ts := Γ.toList
  let args := (List.range ts.length).zip ts.reverse |>.map
    (fun (i, t) => s!"%{i} : {printTy t}")
  "(" ++ String.intercalate ", " args ++ ")"

def irc_constants_APlusC1MinusC2_neg1_2 : LLVMPeepholeRewriteRefine 64 [Ty.llvm (.bitvec 64)] where
  lhs := [LV| {
    ^entry (%a: i64):
      %c1 = llvm.mlir.constant (-1) : i64
      %c2 = llvm.mlir.constant (2) : i64
      %0 = llvm.add %a, %c1 : i64
      %1 = llvm.sub %0, %c2 : i64
      llvm.return %1 : i64
  }]
  rhs := [LV| {
    ^entry (%a: i64):
      %c1 = llvm.mlir.constant (-1) : i64
      %c2 = llvm.mlir.constant (2) : i64
      %0 = llvm.sub %c1, %c2 : i64
      %1 = llvm.add %a, %0 : i64
      llvm.return %1 : i64
  }]

def visitSRA : List (Σ Γ, LLVMPeepholeRewriteRefine 64 Γ) :=
  [⟨_, visitSRA_0⟩,
   ⟨_, visitSRA_Neg1⟩]

def positive_sameconst_shlnsw_before := [llvm|
{
^0(%arg51 : i8):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.ashr %arg51, %0 : i8
  %2 = llvm.shl %1, %0 overflow<nsw> : i8
  "llvm.return"(%2) : (i8) -> ()
}
]

def mul_x_selectp2_after := [llvm|
{
^0(%arg10 : i8, %arg11 : i1):
  %0 = llvm.mlir.constant(3 : i8) : i8
  %1 = llvm.mlir.constant(0 : i8) : i8
  %2 = llvm.mul %arg10, %arg10 : i8
  %3 = "llvm.select"(%arg11, %0, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  %4 = llvm.shl %2, %3 : i8
  "llvm.return"(%4) : (i8) -> ()
}
]

def ugt_swap_and_min_after := [llvm|
{
^0(%arg328 : i8, %arg329 : i8):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def lshrugt_01_03_exact_after := [llvm|
{
^0(%arg218 : i4):
  %0 = llvm.mlir.constant(6 : i4) : i4
  %1 = llvm.icmp "ugt" %arg218, %0 : i4
  "llvm.return"(%1) : (i1) -> ()
}
]

def zext_mul_before := [llvm|
{
^0(%arg13 : i8):
  %0 = llvm.mlir.constant(3 : i16) : i16
  %1 = llvm.zext %arg13 : i8 to i16
  %2 = llvm.mul %1, %0 : i16
  %3 = llvm.and %2, %1 : i16
  "llvm.return"(%3) : (i16) -> ()
}
]

def nonexact_lshr_ne_noexactlog_before := [llvm|
{
^0(%arg135 : i8):
  %0 = llvm.mlir.constant(90 : i8) : i8
  %1 = llvm.mlir.constant(30 : i8) : i8
  %2 = llvm.lshr %0, %arg135 : i8
  %3 = llvm.icmp "ne" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def ult_and_max_logical_after := [llvm|
{
^0(%arg366 : i8, %arg367 : i8):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def fold_sext_to_and_wrong3_before := [llvm|
{
^0(%arg7 : i8):
  %0 = llvm.mlir.constant(128 : i32) : i32
  %1 = llvm.mlir.constant(-2147483648 : i32) : i32
  %2 = llvm.sext %arg7 : i8 to i32
  %3 = llvm.and %2, %0 : i32
  %4 = llvm.icmp "eq" %3, %1 : i32
  "llvm.return"(%4) : (i1) -> ()
}
]

def lshrult_03_15_after := [llvm|
{
^0(%arg320 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def exactly_one_set_signbit_wrong_pred_before := [llvm|
{
^0(%arg28 : i8, %arg29 : i8):
  %0 = llvm.mlir.constant(7 : i8) : i8
  %1 = llvm.mlir.constant(-1 : i8) : i8
  %2 = llvm.lshr %arg28, %0 : i8
  %3 = llvm.icmp "sgt" %arg29, %1 : i8
  %4 = llvm.zext %3 : i1 to i8
  %5 = llvm.icmp "sgt" %2, %4 : i8
  "llvm.return"(%5) : (i1) -> ()
}
]

def shl_nsw_nuw_ult_Csle0_after := [llvm|
{
^0(%arg14 : i8, %arg15 : i8):
  %0 = llvm.mlir.constant(-19 : i8) : i8
  %1 = llvm.icmp "ult" %arg14, %0 : i8
  "llvm.return"(%1) : (i1) -> ()
}
]

def n7_before := [llvm|
{
^0(%arg3 : i8, %arg4 : i8, %arg5 : i8):
  %0 = llvm.mlir.constant(1 : i8) : i8
  %1 = llvm.and %arg3, %0 : i8
  %2 = llvm.icmp "ne" %1, %0 : i8
  %3 = "llvm.select"(%2, %arg4, %arg5) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i8, i8) -> i8
  "llvm.return"(%3) : (i8) -> ()
}
]

def sext? {w: Nat} (w': Nat) (x: BitVec w) : IntW w' := do
  .value <| (BitVec.signExtend w' x)

def test12commuted_before := [llvm|
{
^0(%arg87 : i32, %arg88 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.xor %arg88, %0 : i32
  %2 = llvm.and %1, %arg87 : i32
  %3 = llvm.xor %arg87, %0 : i32
  %4 = llvm.xor %2, %3 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def no_shift_xor_multiuse_xor_after := [llvm|
{
^0(%arg132 : i32, %arg133 : i32):
  %0 = llvm.mlir.constant(4096 : i32) : i32
  %1 = llvm.and %arg132, %0 : i32
  %2 = llvm.xor %arg133, %0 : i32
  %3 = llvm.xor %1, %arg133 : i32
  %4 = llvm.xor %3, %0 : i32
  %5 = llvm.mul %4, %2 : i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def lshrult_01_00_before := [llvm|
{
^0(%arg367 : i4):
  %0 = llvm.mlir.constant(1 : i4) : i4
  %1 = llvm.mlir.constant(0 : i4) : i4
  %2 = llvm.lshr %arg367, %0 : i4
  %3 = llvm.icmp "ult" %2, %1 : i4
  "llvm.return"(%3) : (i1) -> ()
}
]

def trunc_sandwich_min_shift1_before := [llvm|
{
^0(%arg68 : i32):
  %0 = llvm.mlir.constant(20 : i32) : i32
  %1 = llvm.mlir.constant(1 : i12) : i12
  %2 = llvm.lshr %arg68, %0 : i32
  %3 = llvm.trunc %2 : i32 to i12
  %4 = llvm.lshr %3, %1 : i12
  "llvm.return"(%4) : (i12) -> ()
}
]

@[simp_denote]
def shl_llvm_nuw_8 := [LV| {
  ^entry (%x: i8, %y: i8):
    %1 = llvm.shl %x, %y overflow<nuw> : i8
    llvm.return %1 : i8
  }]

def p_commutative4_before := [llvm|
{
^0(%arg22 : i32, %arg23 : i32, %arg24 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.and %arg24, %arg22 : i32
  %2 = llvm.xor %arg24, %0 : i32
  %3 = llvm.and %2, %arg23 : i32
  %4 = llvm.or %3, %1 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def sext_multiuse_before := [llvm|
{
^0(%arg5 : i4):
  %0 = llvm.mlir.constant(-8 : i4) : i4
  %1 = llvm.mlir.constant(-8 : i7) : i7
  %2 = llvm.xor %arg5, %0 : i4
  %3 = llvm.zext %2 : i4 to i7
  %4 = llvm.add %3, %1 overflow<nsw> : i7
  %5 = llvm.sdiv %3, %4 : i7
  %6 = llvm.trunc %5 : i7 to i4
  %7 = llvm.sdiv %6, %2 : i4
  "llvm.return"(%7) : (i4) -> ()
}
]

def icmp_ne_sext_eq_otherwise_before := [llvm|
{
^0(%arg17 : i32):
  %0 = llvm.mlir.constant(2 : i32) : i32
  %1 = llvm.icmp "eq" %arg17, %0 : i32
  %2 = llvm.sext %1 : i1 to i32
  %3 = llvm.icmp "ne" %2, %arg17 : i32
  "llvm.return"(%3) : (i1) -> ()
}
]

def uge_swap_and_max_commute_before := [llvm|
{
^0(%arg226 : i8, %arg227 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.icmp "ule" %arg227, %arg226 : i8
  %2 = llvm.icmp "eq" %arg226, %0 : i8
  %3 = llvm.and %2, %1 : i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def c_1_1_0_after := [llvm|
{
^0(%arg16 : i4, %arg17 : i4):
  %0 = llvm.mlir.constant(-2 : i4) : i4
  %1 = llvm.mlir.constant(1 : i4) : i4
  %2 = llvm.and %arg17, %0 : i4
  %3 = llvm.and %arg16, %1 : i4
  %4 = llvm.or disjoint %2, %3 : i4
  "llvm.return"(%4) : (i4) -> ()
}
]

def shl_nsw_add_negative_before := [llvm|
{
^0(%arg45 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.mlir.constant(2 : i32) : i32
  %2 = llvm.add %arg45, %0 : i32
  %3 = llvm.shl %1, %2 overflow<nsw> : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def and_ne_with_one_bit_diff_constants1_before := [llvm|
{
^0(%arg364 : i32):
  %0 = llvm.mlir.constant(51 : i32) : i32
  %1 = llvm.mlir.constant(50 : i32) : i32
  %2 = llvm.icmp "ne" %arg364, %0 : i32
  %3 = llvm.icmp "ne" %arg364, %1 : i32
  %4 = llvm.and %2, %3 : i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def lhs : Com ScfArith ⟨[  t]⟩ .impure t :=
    Com.letPure (cst_nat niters1) <|
    Com.letPure (cst start1) <|
    Com.letPure (cst 1) <|
  
  Com.var (for_ (t := t) ⟨1, by admit /- proof elided -/
  ⟩ ⟨0, by admit /- proof elided -/
  ⟩ ⟨2, by admit /- proof elided -/
  ⟩ ⟨3, by admit /- proof elided -/
  ⟩ rgn) <|
    Com.letPure (cst_nat niters2) <|
    Com.letPure (cst <| niters1 + start1) <|
    Com.letPure (cst 1) <|
  Com.var (for_ (t := t) ⟨1, by admit /- proof elided -/
  ⟩ ⟨0, by admit /- proof elided -/
  ⟩ ⟨2, by admit /- proof elided -/
  ⟩ ⟨3, by admit /- proof elided -/
  ⟩ rgn) <|
  Com.ret ⟨0, rfl⟩

def test2_after := [llvm|
{
^0(%arg0 : i167):
  %0 = llvm.mlir.constant(9 : i167) : i167
  %1 = llvm.mlir.constant(8 : i167) : i167
  %2 = llvm.lshr %arg0, %0 : i167
  %3 = llvm.shl %arg0, %1 : i167
  %4 = llvm.or %2, %3 : i167
  "llvm.return"(%4) : (i167) -> ()
}
]

def xor_nosignbit_select_shl_before := [llvm|
{
^0(%arg36 : i32, %arg37 : i1):
  %0 = llvm.mlir.constant(2147418112 : i32) : i32
  %1 = llvm.mlir.constant(8 : i32) : i32
  %2 = llvm.xor %arg36, %0 : i32
  %3 = "llvm.select"(%arg37, %2, %arg36) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %4 = llvm.shl %3, %1 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

instance {test : ConcreteCliTest} : ToString (toType test.ty) where
  toString :=
    match test.ty with
    | bitvec w => inferInstanceAs (ToString (PoisonOr <| BitVec w)) |>.toString

def alive_Select_1105_src  (w : Nat)   :=
[llvm( w )| {
^bb0(%Y : _, %X : _):
  %v1 = llvm.mlir.constant 0 :  i1
  %v2 = llvm.select %v1,%X, %Y
  llvm.return %v2
}]

def addsub_combine_constants_after := [llvm|
{
^0(%arg14 : i7, %arg15 : i7):
  %0 = llvm.mlir.constant(52 : i7) : i7
  %1 = llvm.sub %arg14, %arg15 : i7
  %2 = llvm.add %1, %0 : i7
  "llvm.return"(%2) : (i7) -> ()
}
]

def test_const_shr_exact_and_1_ne_0_before := [llvm|
{
^0(%arg6 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(1 : i32) : i32
  %2 = llvm.mlir.constant(0 : i32) : i32
  %3 = llvm.lshr exact %0, %arg6 : i32
  %4 = llvm.and %3, %1 : i32
  %5 = llvm.icmp "ne" %4, %2 : i32
  "llvm.return"(%5) : (i1) -> ()
}
]

def llvm_const_lower_riscv_li_3 : LLVMPeepholeRewriteRefine 64 [] :=
  {lhs := constLLVM_3, rhs:= liRiscv_3,
   correct := by admit /- proof elided -/

def match_signed_after := [llvm|
{
^0(%arg15 : i64):
  %0 = llvm.mlir.constant(172224) : i64
  %1 = llvm.srem %arg15, %0 : i64
  "llvm.return"(%1) : (i64) -> ()
}
]

@[simp_llvm_option]
def lshr {w : Nat} (x y : IntW w) (flag : ExactFlag := {exact := false}) : IntW w := do
  let x' ← x
  let y' ← y
  if flag.exact ∧(x' >>> y') <<< y' ≠ x' then
    .poison
  else
    lshr? x' y'

def and_sequence_15_lhs (w : Nat)   :=
[llvm( w )| {
^bb0(%C1 : _, %Z : _):
  %v1 = llvm.and %Z, %C1
  %v2 = llvm.and %v1, %C1
  %v3 = llvm.and %v2, %C1
  %v4 = llvm.and %v3, %C1
  %v5 = llvm.and %v4, %C1
  %v6 = llvm.and %v5, %C1
  %v7 = llvm.and %v6, %C1
  %v8 = llvm.and %v7, %C1
  %v9 = llvm.and %v8, %C1
  %v10 = llvm.and %v9, %C1
  %v11 = llvm.and %v10, %C1
  %v12 = llvm.and %v11, %C1
  %v13 = llvm.and %v12, %C1
  llvm.return %v13
}]

def scalar_i16_signbit_lshr_and_eq_before := [llvm|
{
^0(%arg33 : i16, %arg34 : i16):
  %0 = llvm.mlir.constant(-32768 : i16) : i16
  %1 = llvm.mlir.constant(0 : i16) : i16
  %2 = llvm.lshr %0, %arg34 : i16
  %3 = llvm.and %2, %arg33 : i16
  %4 = llvm.icmp "eq" %3, %1 : i16
  "llvm.return"(%4) : (i1) -> ()
}
]

def shrink_or_after := [llvm|
{
^0(%arg11 : i6):
  %0 = llvm.mlir.constant(1 : i3) : i3
  %1 = llvm.trunc %arg11 : i6 to i3
  %2 = llvm.or %1, %0 : i3
  "llvm.return"(%2) : (i3) -> ()
}
]

def ex1 := [HSxComb_com| {
  ^entry(%0: !Stream_BitVec_1):
    "return" (%0) : (!Stream_BitVec_1) -> ()
  }]

def add_mask_ashr28_i32_before := [llvm|
{
^0(%arg2 : i32):
  %0 = llvm.mlir.constant(28 : i32) : i32
  %1 = llvm.mlir.constant(8 : i32) : i32
  %2 = llvm.ashr %arg2, %0 : i32
  %3 = llvm.and %2, %1 : i32
  %4 = llvm.add %3, %2 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def bitwise_and_bitwise_and_icmps_comm1_after := [llvm|
{
^0(%arg241 : i8, %arg242 : i8, %arg243 : i8):
  %0 = llvm.mlir.constant(42 : i8) : i8
  %1 = llvm.mlir.constant(1 : i8) : i8
  %2 = llvm.icmp "eq" %arg242, %0 : i8
  %3 = llvm.shl %1, %arg243 overflow<nuw> : i8
  %4 = llvm.or %3, %1 : i8
  %5 = llvm.and %arg241, %4 : i8
  %6 = llvm.icmp "eq" %5, %4 : i8
  %7 = llvm.and %2, %6 : i1
  "llvm.return"(%7) : (i1) -> ()
}
]

def alive_AddSub_1176_tgt :=
[sllvm| {
^bb0(%a : i64, %b : i64):
  %v1 = llvm.mlir.constant 0 : i64
  %v2 = llvm.sub %v1, %b : i64
  %v3 = llvm.sub %a, %b : i64
  llvm.return %v3 : i64
}]

def logic_and_logic_or_8_after := [llvm|
{
^0(%arg156 : i1, %arg157 : i1, %arg158 : i1):
  %0 = llvm.mlir.constant(true) : i1
  %1 = llvm.mlir.constant(false) : i1
  %2 = "llvm.select"(%arg158, %0, %arg157) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %3 = "llvm.select"(%arg156, %2, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%3) : (i1) -> ()
}
]

def test1_before := [llvm|
{
^0(%arg14 : i32, %arg15 : i32):
  %0 = llvm.icmp "slt" %arg14, %arg15 : i32
  %1 = llvm.zext %0 : i1 to i32
  %2 = llvm.icmp "sgt" %arg14, %arg15 : i32
  %3 = llvm.zext %2 : i1 to i32
  %4 = llvm.and %1, %3 : i32
  %5 = llvm.trunc %4 : i32 to i1
  "llvm.return"(%5) : (i1) -> ()
}
]

def main3e_like_logical_before := [llvm|
{
^0(%arg146 : i32, %arg147 : i32, %arg148 : i32):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.mlir.constant(false) : i1
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.and %arg146, %arg147 : i32
  %4 = llvm.icmp "eq" %3, %0 : i32
  %5 = llvm.and %arg146, %arg148 : i32
  %6 = llvm.icmp "eq" %5, %0 : i32
  %7 = "llvm.select"(%4, %6, %1) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  %8 = "llvm.select"(%7, %0, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%8) : (i32) -> ()
}
]

def shift_xor_multiuse_cmp_after := [llvm|
{
^0(%arg84 : i32, %arg85 : i32, %arg86 : i32, %arg87 : i32):
  %0 = llvm.mlir.constant(4096 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(2048 : i32) : i32
  %3 = llvm.and %arg84, %0 : i32
  %4 = llvm.icmp "eq" %3, %1 : i32
  %5 = llvm.or %arg85, %2 : i32
  %6 = "llvm.select"(%4, %5, %arg85) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %7 = "llvm.select"(%4, %arg87, %arg86) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  %8 = llvm.mul %6, %7 : i32
  "llvm.return"(%8) : (i32) -> ()
}
]

def or_xor_tree_1101_before := [llvm|
{
^0(%arg6 : i32, %arg7 : i32, %arg8 : i32):
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mul %arg6, %0 : i32
  %2 = llvm.mul %arg7, %0 : i32
  %3 = llvm.mul %arg8, %0 : i32
  %4 = llvm.xor %2, %1 : i32
  %5 = llvm.xor %2, %3 : i32
  %6 = llvm.xor %1, %5 : i32
  %7 = llvm.or %6, %4 : i32
  "llvm.return"(%7) : (i32) -> ()
}
]

def ashr_pow2_ult_before := [llvm|
{
^0(%arg59 : i8):
  %0 = llvm.mlir.constant(-128 : i8) : i8
  %1 = llvm.mlir.constant(-96 : i8) : i8
  %2 = llvm.ashr %0, %arg59 : i8
  %3 = llvm.icmp "ult" %2, %1 : i8
  "llvm.return"(%3) : (i1) -> ()
}
]

def test35_with_trunc_before := [llvm|
{
^0(%arg48 : i64):
  %0 = llvm.mlir.constant(0 : i32) : i32
  %1 = llvm.mlir.constant(60 : i32) : i32
  %2 = llvm.mlir.constant(100 : i32) : i32
  %3 = llvm.trunc %arg48 : i64 to i32
  %4 = llvm.icmp "sge" %3, %0 : i32
  %5 = "llvm.select"(%4, %1, %2) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i32, i32) -> i32
  "llvm.return"(%5) : (i32) -> ()
}
]

def lshrugt_01_10_exact_after := [llvm|
{
^0(%arg211 : i4):
  %0 = llvm.mlir.constant(false) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def t9_before := [llvm|
{
^0(%arg4 : i8):
  %0 = llvm.mlir.constant(0 : i8) : i8
  %1 = llvm.sub %0, %arg4 overflow<nsw> : i8
  %2 = llvm.icmp "ne" %1, %arg4 : i8
  "llvm.return"(%2) : (i1) -> ()
}
]

def not_and_and_or_not_or_or_commute1_or_before := [llvm|
{
^0(%arg250 : i32, %arg251 : i32, %arg252 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.or %arg252, %arg250 : i32
  %2 = llvm.or %1, %arg251 : i32
  %3 = llvm.xor %2, %0 : i32
  %4 = llvm.xor %arg250, %0 : i32
  %5 = llvm.and %4, %arg251 : i32
  %6 = llvm.and %5, %arg252 : i32
  %7 = llvm.or %6, %3 : i32
  "llvm.return"(%7) : (i32) -> ()
}
]

def sub_zext_trunc_lshr_after := [llvm|
{
^0(%arg15 : i64):
  %0 = llvm.mlir.constant(16 : i32) : i32
  %1 = llvm.mlir.constant(31 : i32) : i32
  %2 = llvm.mlir.constant(10 : i32) : i32
  %3 = llvm.trunc %arg15 : i64 to i32
  %4 = llvm.shl %3, %0 : i32
  %5 = llvm.ashr %4, %1 : i32
  %6 = llvm.add %5, %2 overflow<nsw> : i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def masked_icmps_mask_notallzeros_bmask_mixed_7b_logical_before := [llvm|
{
^0(%arg75 : i32):
  %0 = llvm.mlir.constant(6 : i32) : i32
  %1 = llvm.mlir.constant(0 : i32) : i32
  %2 = llvm.mlir.constant(15 : i32) : i32
  %3 = llvm.mlir.constant(8 : i32) : i32
  %4 = llvm.mlir.constant(false) : i1
  %5 = llvm.and %arg75, %0 : i32
  %6 = llvm.icmp "ne" %5, %1 : i32
  %7 = llvm.and %arg75, %2 : i32
  %8 = llvm.icmp "eq" %7, %3 : i32
  %9 = "llvm.select"(%6, %8, %4) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%9) : (i1) -> ()
}
]

def positive_samevar_lshrexact_after := [llvm|
{
^0(%arg42 : i8, %arg43 : i8):
  "llvm.return"(%arg42) : (i8) -> ()
}
]

RV64.andi in RISCV.Instructions

def or_nosignbit_lshr_before := [llvm|
{
^0(%arg12 : i32):
  %0 = llvm.mlir.constant(2147418112 : i32) : i32
  %1 = llvm.mlir.constant(8 : i32) : i32
  %2 = llvm.or %arg12, %0 : i32
  %3 = llvm.lshr %2, %1 : i32
  "llvm.return"(%3) : (i32) -> ()
}
]

def or_test1_after := [llvm|
{
^0(%arg2 : i231, %arg3 : i231):
  %0 = llvm.mlir.constant(1 : i231) : i231
  "llvm.return"(%0) : (i231) -> ()
}
]

def test19_after := [llvm|
{
^0(%arg7 : i10):
  %0 = llvm.mlir.constant(1 : i3) : i3
  %1 = llvm.mlir.constant(0 : i3) : i3
  %2 = llvm.trunc %arg7 : i10 to i3
  %3 = llvm.and %2, %0 : i3
  %4 = llvm.sub %1, %3 overflow<nsw> : i3
  %5 = llvm.sext %4 : i3 to i10
  "llvm.return"(%5) : (i10) -> ()
}
]

def ult_swap_or_not_max_logical_before := [llvm|
{
^0(%arg36 : i8, %arg37 : i8):
  %0 = llvm.mlir.constant(-1 : i8) : i8
  %1 = llvm.mlir.constant(true) : i1
  %2 = llvm.icmp "ugt" %arg37, %arg36 : i8
  %3 = llvm.icmp "ne" %arg36, %0 : i8
  %4 = "llvm.select"(%2, %1, %3) <{"fastmathFlags" = #llvm.fastmath<none>}> : (i1, i1, i1) -> i1
  "llvm.return"(%4) : (i1) -> ()
}
]

def p_commutative0_after := [llvm|
{
^0(%arg32 : i32, %arg33 : i32, %arg34 : i32):
  %0 = llvm.mlir.constant(-1 : i32) : i32
  %1 = llvm.and %arg34, %arg32 : i32
  %2 = llvm.xor %arg34, %0 : i32
  %3 = llvm.and %arg33, %2 : i32
  %4 = llvm.or disjoint %1, %3 : i32
  "llvm.return"(%4) : (i32) -> ()
}
]

def udiv_shl_pair3_after := [llvm|
{
^0(%arg24 : i32, %arg25 : i32, %arg26 : i32):
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.shl %0, %arg25 overflow<nuw> : i32
  %2 = llvm.lshr %1, %arg26 : i32
  "llvm.return"(%2) : (i32) -> ()
}
]

def ashrsgt_01_10_after := [llvm|
{
^0(%arg307 : i4):
  %0 = llvm.mlir.constant(true) : i1
  "llvm.return"(%0) : (i1) -> ()
}
]

def test24_before := [llvm|
{
^0(%arg2 : i32):
  %0 = llvm.mlir.constant(4 : i32) : i32
  %1 = llvm.mlir.constant(2 : i32) : i32
  %2 = llvm.mlir.constant(0 : i32) : i32
  %3 = llvm.and %arg2, %0 : i32
  %4 = llvm.lshr %3, %1 : i32
  %5 = llvm.icmp "eq" %4, %2 : i32
  %6 = llvm.zext %5 : i1 to i32
  "llvm.return"(%6) : (i32) -> ()
}
]

def and_to_xor2_after := [llvm|
{
^0(%arg117 : i32, %arg118 : i32):
  %0 = llvm.xor %arg117, %arg118 : i32
  "llvm.return"(%0) : (i32) -> ()
}
]

Holor in Mathlib.Data.Holor

AList.insert in Mathlib.Data.List.AList
</all_available_defs>

<all_available_lemmas>
List.getD_eq_default in Mathlib.Data.List.GetD
List.getD_eq_getElem in Mathlib.Data.List.GetD
Nat.not_lt in Init.Data.Nat.Basic
Polynomial.coeff_eq_zero_of_degree_lt in Mathlib.Algebra.Polynomial.Degree.Operations
WithBot.bot_lt_coe in Mathlib.Order.WithBot
WithBot.coe_lt_coe in Mathlib.Order.WithBot
ZMod.cast_zero in Mathlib.Data.ZMod.Basic
Fact.elim in Mathlib.Logic.Basic
Nat.cast_add in Mathlib.Data.Nat.Cast.Defs
Nat.cast_one in Mathlib.Data.Nat.Cast.Defs
Nat.succ_eq_add_one in Init.Data.Nat.Basic
ZMod.cast_eq_val in Mathlib.Data.ZMod.Basic
ZMod.natCast_val in Mathlib.Data.ZMod.Basic
ZMod.val_intCast in Mathlib.Data.ZMod.Basic
gt_iff_lt in Init.Core
not_lt_zero' in Mathlib.Algebra.Order.GroupWithZero.Canonical
Polynomial.coeff_inj in Mathlib.Algebra.Polynomial.Basic
Polynomial.degree_eq_bot in Mathlib.Algebra.Polynomial.Degree.Definitions
ZMod.coe_intCast in Mathlib.Data.ZMod.Basic

@[simp]
theorem R.fromPoly_kernel_eq_zero (x : (ZMod q)[X]) : R.fromPoly (n := n) (f q n * x) = 0

theorem R.representative_fromPoly :
    forall a : (ZMod q)[X], (R.fromPoly (n:=n) a).representative = a %ₘ (f q n)

theorem R.fromPoly_rep'_eq_ideal :
    forall a : (ZMod q)[X],
      ∃ i ∈ Ideal.span {f q n}, (R.fromPoly (n:=n) a).representative' = a + i

theorem f_monic : Monic (f q n)

theorem R.coeff_fromTensor (tensor : List Int)
    (htensorlen : tensor.length < 2^n) :
    (R.fromTensor (q := q) (n := n) tensor).coeff i = (tensor.getD i 0)

theorem R.fromTensorFinsupp_coeffs (coeffs : List Int) :
  Polynomial.coeff (fromTensorFinsupp q coeffs) i = ↑(List.getD coeffs i 0)

theorem R.fromTensorFinsupp_degree (q : Nat) (coeffs : List Int):
  (R.fromTensorFinsupp q coeffs).degree ≤ coeffs.length

theorem Polynomial.degree_toFinsupp [Semiring M] [DecidableEq M]
  (xs : List M) :
  degree { toFinsupp := List.toFinsupp (l := xs) } ≤ List.length xs

theorem R.fromTensor_eq_fromTensorFinsupp_fromPoly {coeffs : List Int} :
    R.fromTensor (q := q) (n := n) coeffs =
  R.fromPoly (q := q) (n := n) (R.fromTensorFinsupp q coeffs)

theorem R.fromTensorFinsupp_concat_monomial (c : Int) (cs : List Int) :
    (R.fromTensorFinsupp q (cs ++ [c])) =
      (R.fromTensorFinsupp q cs) +
        (Polynomial.monomial cs.length (Int.cast c : (ZMod q)))

@[simp]
theorem R.representative_fromPoly_eq (x : (ZMod q)[X]) (DEGREE: x.degree < (f q n).degree) :
   R.representative q n (R.fromPoly (n:=n) x) = x

theorem f_deg_eq : (f q n).degree = 2^n

@[simp]
theorem R.fromPoly_representative [Fact (q > 1)]:
    forall a : R q n, (R.fromPoly (n:=n) (R.representative q n a)) = a

theorem R.repLength_leq_representative_degree_plus_1 (a : R q n) :
  a.repLength ≤ (R.representative q n a).natDegree + 1

theorem R.toTensor_length {q n} (a : R q n) :
    (R.toTensor a).length = a.repLength

theorem and_add_bool_to_select_multi_use_thm.extracted_1._1 : ∀ (x : BitVec 32) (x_1 : BitVec 1),
  x_1 = 1#1 → (-1#32 + zeroExtend 32 x_1 &&& x) + (-1#32 + zeroExtend 32 x_1) = 0#32

theorem test9_thm.extracted_1._1 : ∀ (x : BitVec 32), truncate 8 (x &&& 42#32) = truncate 8 x &&& 42#8

theorem prove_exact_with_high_mask_limit_thm.extracted_1._2 : ∀ (x : BitVec 8),
  ¬(8#8 == 0 || 8 != 1 && x &&& BitVec.ofInt 8 (-8) == intMin 8 && 8#8 == -1) = true →
    ¬3#8 ≥ ↑8 → (x &&& BitVec.ofInt 8 (-8)).sdiv 8#8 = x.sshiftRight' 3#8

theorem pr9998_proof : pr9998_before ⊑ pr9998_after

theorem foo1_and_proof : foo1_and_before ⊑ foo1_and_after

theorem e_1995 :
     - 1 *  ~~~(a &&& (b ||| c)) + 1 * (b ^^^  ~~~(a &&&  ~~~c)) - 2 *  ~~~b + 1 *  ~~~( ~~~a ||| (b ^^^ c)) - 6 * (a &&& (b ||| c)) + 4 * (a ^^^ (b ||| c)) - 1 * (c ^^^  ~~~(a &&& b)) - 6 * (b ^^^ (a &&& (b ||| c))) + 1 *  ~~~(a ||| (b &&& c)) + 11 * ( ~~~b &&&  ~~~(a ^^^ c)) - 11 * (c ^^^ ( ~~~a &&& ( ~~~b ||| c))) + 7 * ((a &&&  ~~~b) |||  ~~~(a ^^^ (b ^^^ c))) - 2 *  ~~~(a &&&  ~~~a) - 11 * (b ^^^ ( ~~~a ||| ( ~~~b &&& c))) + 11 * (b ^^^ (a &&&  ~~~c)) + 7 * (c ^^^  ~~~(a ||| (b &&& c))) - 1 * ((b &&&  ~~~c) |||  ~~~( ~~~a ||| ( ~~~b &&& c))) + 11 * (b &&&  ~~~c) + 1 * ((a &&& b) |||  ~~~(b ||| c)) - 1 * ((a &&& b) ^^^  ~~~(a ^^^ (b &&& c))) + 2 *  ~~~(b |||  ~~~c) + 1 * (b ^^^  ~~~(a ||| (b ^^^ c))) - 2 * ( ~~~(a &&& b) &&& (a ^^^ (b ^^^ c))) - 2 * (a ||| b) + 1 *  ~~~(a ^^^ b) - 2 * (b ^^^  ~~~( ~~~a &&& (b ^^^ c))) - 3 * (b ^^^  ~~~(a &&& (b ^^^ c))) + 1 * ( ~~~a ||| ( ~~~b &&& c)) - 2 * ((a &&& c) ^^^ (a ^^^ (b &&& c))) - 7 * (c &&& (a ^^^ b)) + 2 * (a ||| ( ~~~b &&& c)) - 5 *  ~~~a + 2 * ( ~~~b ||| (a ^^^ c)) + 5 * (a &&& b) + 2 * (b ^^^  ~~~(a &&& ( ~~~b &&& c))) + 7 * ( ~~~a &&& (b ||| c)) + 3 * ((a &&& b) ^^^ (a ^^^ ( ~~~b ||| c))) + 5 * (b ^^^  ~~~(a &&& ( ~~~b ||| c))) + 1 * (a ^^^ c) - 1 * (b |||  ~~~(a ||| c)) - 2 * ((a &&&  ~~~b) |||  ~~~(b ^^^ c)) + 1 * (c ^^^  ~~~(a &&&  ~~~b)) + 2 * (c ^^^  ~~~( ~~~a &&& ( ~~~b ||| c))) - 1 * (b ||| (a &&&  ~~~c)) + 3 * (c ^^^  ~~~( ~~~a ||| (b &&& c))) - 7 * (c ^^^  ~~~(a &&& (b ||| c))) + 4 * ((a &&&  ~~~b) ||| (b ^^^ c)) - 2 * (b |||  ~~~(a ^^^ c)) - 6 * (a &&& ( ~~~b ||| c)) - 1 * (b ^^^ (a &&& (b ^^^ c))) - 2 *  ~~~(a ^^^ ( ~~~b ||| c)) + 6 *  ~~~(a ||| (b ||| c)) - 13 *  ~~~(a ||| ( ~~~b ||| c)) - 5 *  ~~~( ~~~a ||| (b ||| c)) - 11 *  ~~~( ~~~a ||| ( ~~~b ||| c)) - 15 * ( ~~~a &&& ( ~~~b &&& c)) - 16 * ( ~~~a &&& (b &&& c)) + 30 * (a &&& ( ~~~b &&& c)) + 18 * (a &&& (b &&& c)) =  - 1 * (b ^^^ ( ~~~a ||| ( ~~~b ||| c)))

theorem sle_swap_or_not_min_logical_thm (e e_1 : IntW 8) :
  select (icmp IntPred.sge e_1 e) (const? 1 1) (icmp IntPred.ne e (const? 8 (-128))) ⊑ const? 1 1

theorem sext_xor_sub_proof : sext_xor_sub_before ⊑ sext_xor_sub_after

theorem select_icmp_eq_and_4096_0_or_4096_proof : select_icmp_eq_and_4096_0_or_4096_before ⊑ select_icmp_eq_and_4096_0_or_4096_after

theorem and_and_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x &&& 2#32 == 0#32) = 1#1 → x &&& 1#32 = zeroExtend 32 (ofBool (x &&& 3#32 != 0#32))

theorem add_or_sub_comb_i8_negative_y_or_thm (e e_1 : IntW 8) :
  add (LLVM.or (sub (const? 8 0) e_1) e) e_1 ⊑ add (LLVM.or e (sub (const? 8 0) e_1)) e_1

lemma RawCNFA.reverse_spec_procesState {m : RawCNFA A} (hwf : m.WF) s₀ a₀ ss' (hs₀ : s₀ ∈ m.states) :
    let motive m' ss' :=
      (∀ s ∈ ss', s ∈ m.states) →
        m'.WF ∧ m'.stateMax = m.stateMax ∧ m'.initials = m.initials ∧ m'.finals = m.finals ∧
          ∀ s a s', s' ∈ m'.tr s a ↔ (s' ∈ m.tr s a ∨ s' = s₀ ∧ a = a₀ ∧ s ∈ ss')
    motive (RawCNFA.reverse.processState m (s₀, a₀) ss') ss'.toSet

theorem trunc_shl_nsw_31_i32_i64_proof : trunc_shl_nsw_31_i32_i64_before ⊑ trunc_shl_nsw_31_i32_i64_after

theorem ugt_3_thm.extracted_1._1 : ∀ (x : BitVec 32), ofBool (3#8 <ᵤ truncate 8 x) = ofBool (x &&& 252#32 != 0#32)

theorem icmp_slt_sext_ne_otherwise_nofold_thm (e : IntW 32) :
  icmp IntPred.slt (sext 32 (icmp IntPred.ne e (const? 32 2))) e ⊑
    icmp IntPred.sgt e (sext 32 (icmp IntPred.ne e (const? 32 2)))

theorem ugt_swap_and_not_min_commute_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ofBool (x_1 != 0#8) &&& ofBool (x <ᵤ x_1) = ofBool (x <ᵤ x_1)

theorem e_839 :
    1 * t + 2 *  ~~~(z &&&  ~~~z) - 1 *  ~~~(z ||| t) - 3 *  ~~~(z |||  ~~~t) - 1 * (z &&&  ~~~t) = 1 * (z |||  ~~~t) + 2 * (z &&& t)

theorem mul_of_bools_proof : mul_of_bools_before ⊑ mul_of_bools_after

theorem ashrslt_02_15_proof : ashrslt_02_15_before ⊑ ashrslt_02_15_after

theorem e_2008 :
     - 11 * (e ^^^ ( ~~~d ||| (e &&& f))) + 1 * ( ~~~(d ^^^ e) ||| (d ^^^ f)) + 4 * (e ^^^  ~~~(d ||| (e ^^^ f))) + 2 *  ~~~(e &&&  ~~~f) + 1 * ( ~~~d &&& (e ||| f)) + 1 * ((d ^^^ e) &&& (d ^^^ f)) - 1 * d - 3 * ( ~~~(d |||  ~~~e) ||| (e ^^^ f)) + 1 *  ~~~(d &&&  ~~~e) + 2 * (e ^^^ (d &&& (e ||| f))) - 6 * (d |||  ~~~f) + 7 * (d ^^^ e) - 5 * (e ^^^ (d &&& f)) + 3 * (e ||| f) - 11 * (e ^^^  ~~~(d &&& (e &&& f))) - 5 * ((d &&&  ~~~e) ||| (e ^^^ f)) + 2 * (f ^^^  ~~~( ~~~d &&& (e ||| f))) + 1 * ( ~~~f &&&  ~~~(d ^^^ e)) - 2 *  ~~~( ~~~d &&& (e ^^^ f)) - 2 * (f ^^^ (d &&&  ~~~e)) - 11 * ( ~~~(d &&& e) &&& (e ^^^ f)) - 2 * ((d &&& e) ||| (e ^^^ f)) + 1 * (e ^^^  ~~~( ~~~d &&& (e ^^^ f))) - 1 *  ~~~e + 1 * (e ||| (d ^^^ f)) + 7 * (e ^^^ ( ~~~d &&& (e ||| f))) + 17 *  ~~~(d ||| (e ||| f)) + 10 *  ~~~(d ||| ( ~~~e ||| f)) + 13 *  ~~~( ~~~d ||| (e ||| f)) + 13 *  ~~~( ~~~d ||| ( ~~~e ||| f)) - 9 * ( ~~~d &&& (e &&& f)) + 30 * (d &&& ( ~~~e &&& f)) + 5 * (d &&& (e &&& f)) =  - 2 * ( ~~~(d ||| e) ||| (e ^^^ f)) - 26 * ( ~~~d &&& ( ~~~e &&& f))

theorem bitwise_or_bitwise_or_icmps_comm3_proof : bitwise_or_bitwise_or_icmps_comm3_before ⊑ bitwise_or_bitwise_or_icmps_comm3_after

theorem not_lshr_const_proof : not_lshr_const_before ⊑ not_lshr_const_after

theorem mul_constant_eq_nsw_proof : mul_constant_eq_nsw_before ⊑ mul_constant_eq_nsw_after

theorem and_xor_commute1_thm.extracted_1._2 : ∀ (x x_1 : BitVec 32),
  ¬(x_1 = 0 ∨ x_1 = 0 ∨ x = 0) →
    ¬(x_1 = 0 ∨ x = 0) → 42#32 / x_1 ^^^ 42#32 / x_1 &&& 42#32 / x = 42#32 / x_1 &&& (42#32 / x ^^^ -1#32)

theorem not_or_or_and_not_and_and_commute2_proof : not_or_or_and_not_and_and_commute2_before ⊑ not_or_or_and_not_and_and_commute2_after

lemma CNFA.autSignedCmp_spec {cmp} : (CNFA.autSignedCmp cmp).Sim (NFA'.autSignedCmp cmp)

theorem sub_from_variable_of_sub_from_constant_proof : sub_from_variable_of_sub_from_constant_before ⊑ sub_from_variable_of_sub_from_constant_after

theorem ashr_lshr_shift_amt_mismatch_thm.extracted_1._3 : ∀ (x x_1 : BitVec 32),
  ¬(ofBool (0#32 ≤ₛ x_1) = 1#1 ∨ x ≥ ↑32) → ¬ofBool (x_1 <ₛ 0#32) = 1#1 → False

theorem positive_sameconst_shlnsw_thm (e : IntW 8) :
  shl (lshr e (const? 8 3)) (const? 8 3) { «nsw» := true, «nuw» := false } ⊑ LLVM.and e (const? 8 (-8))

theorem ashrsgt_03_10_exact_proof : ashrsgt_03_10_exact_before ⊑ ashrsgt_03_10_exact_after

theorem icmp_eq_and_pow2_lshr_pow2_proof : icmp_eq_and_pow2_lshr_pow2_before ⊑ icmp_eq_and_pow2_lshr_pow2_after

theorem AvoidCollision_setWidth_one_eq_ofBool_getLsb_zero (x : BitVec w) :
    x.setWidth 1 = BitVec.ofBool (x.getLsbD 0)

theorem masked_icmps_mask_notallzeros_bmask_mixed_negated_swapped_7b_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x &&& 15#32 != 8#32) ||

theorem negate_shl_xor_proof : negate_shl_xor_before ⊑ negate_shl_xor_after

theorem or_or_and_pat5_proof : or_or_and_pat5_before ⊑ or_or_and_pat5_after

theorem ashrslt_03_10_exact_thm (e : IntW 4) :
  icmp IntPred.slt (ashr e (const? 4 3) { «exact» := true }) (const? 4 (-6)) ⊑ const? 1 0

theorem test_shl_nuw_nsw__nuw_is_safe_proof : test_shl_nuw_nsw__nuw_is_safe_before ⊑ test_shl_nuw_nsw__nuw_is_safe_after

theorem sext_multiuse_thm.extracted_1._2 : ∀ (x : BitVec 4),
  ¬(True ∧ (zeroExtend 7 (x ^^^ BitVec.ofInt 4 (-8))).saddOverflow (BitVec.ofInt 7 (-8)) = true ∨
        (zeroExtend 7 (x ^^^ BitVec.ofInt 4 (-8)) + BitVec.ofInt 7 (-8) == 0 ||
              7 != 1 && zeroExtend 7 (x ^^^ BitVec.ofInt 4 (-8)) == intMin 7 &&
                zeroExtend 7 (x ^^^ BitVec.ofInt 4 (-8)) + BitVec.ofInt 7 (-8) == -1) =
            true ∨
          (x ^^^ BitVec.ofInt 4 (-8) == 0 ||
              4 != 1 &&
                  truncate 4
                      ((zeroExtend 7 (x ^^^ BitVec.ofInt 4 (-8))).sdiv
                        (zeroExtend 7 (x ^^^ BitVec.ofInt 4 (-8)) + BitVec.ofInt 7 (-8))) ==
                    intMin 4 &&
                x ^^^ BitVec.ofInt 4 (-8) == -1) =
            true) →
    ¬((signExtend 7 x == 0 || 7 != 1 && zeroExtend 7 (x ^^^ BitVec.ofInt 4 (-8)) == intMin 7 && signExtend 7 x == -1) =
            true ∨
          (x ^^^ BitVec.ofInt 4 (-8) == 0 ||
              4 != 1 && truncate 4 ((zeroExtend 7 (x ^^^ BitVec.ofInt 4 (-8))).sdiv (signExtend 7 x)) == intMin 4 &&
                x ^^^ BitVec.ofInt 4 (-8) == -1) =
            true) →
      (truncate 4
              ((zeroExtend 7 (x ^^^ BitVec.ofInt 4 (-8))).sdiv
                (zeroExtend 7 (x ^^^ BitVec.ofInt 4 (-8)) + BitVec.ofInt 7 (-8)))).sdiv
          (x ^^^ BitVec.ofInt 4 (-8)) =
        (truncate 4 ((zeroExtend 7 (x ^^^ BitVec.ofInt 4 (-8))).sdiv (signExtend 7 x))).sdiv
          (x ^^^ BitVec.ofInt 4 (-8))

theorem foo3_thm.extracted_1._1 : ∀ (x x_1 : BitVec 1), ¬x = 0 → x_1 / x = x_1

theorem sub_shl_same_amount_partial_nuw2_thm.extracted_1._2 : ∀ (x x_1 x_2 : BitVec 6),
  ¬(True ∧ x_2 <<< x_1 >>> x_1 ≠ x_2 ∨ x_1 ≥ ↑6 ∨ x_1 ≥ ↑6 ∨ True ∧ (x_2 <<< x_1).usubOverflow (x <<< x_1) = true) →
    ¬x_1 ≥ ↑6 → x_2 <<< x_1 - x <<< x_1 = (x_2 - x) <<< x_1

theorem lowmask_sub_zext_commute_thm.extracted_1._1 : ∀ (x : BitVec 5) (x_1 : BitVec 17),
  x_1 - zeroExtend 17 x &&& 31#17 = zeroExtend 17 (truncate 5 x_1 - x)

theorem test_lshr_exact__exact_is_safe_thm.extracted_1._4 : ∀ (x : BitVec 64) (x_1 : BitVec 32),
  ¬ofBool (x_1 &&& 60#32 == 0#32) = 1#1 →
    ¬(True ∧ (x_1 &&& 60#32) >>> 2#32 <<< 2#32 ≠ x_1 &&& 60#32 ∨
          2#32 ≥ ↑32 ∨ zeroExtend 64 ((x_1 &&& 60#32) >>> 2#32) ≥ ↑64) →
      ¬(2#32 ≥ ↑32 ∨ True ∧ (x_1 >>> 2#32 &&& 15#32).msb = true ∨ zeroExtend 64 (x_1 >>> 2#32 &&& 15#32) ≥ ↑64) →
        x.sshiftRight' (zeroExtend 64 ((x_1 &&& 60#32) >>> 2#32)) =
          x.sshiftRight' (zeroExtend 64 (x_1 >>> 2#32 &&& 15#32))

theorem e_2317 :
    3 * (f ^^^  ~~~(d ||| ( ~~~e &&& f))) + 1 *  ~~~( ~~~d &&& ( ~~~e ||| f)) + 1 * ( ~~~d &&& (e ^^^ f)) + 11 * (f ^^^ (d &&& e)) - 11 *  ~~~(d &&& (e ||| f)) + 11 * (e ^^^ (d &&& ( ~~~e ||| f))) - 7 * (e &&& (d ||| f)) - 7 * ((e &&& f) ||| ( ~~~d &&& (e ||| f))) - 6 *  ~~~(d &&& f) - 1 * ((d &&&  ~~~e) ||| (d ^^^ (e ^^^ f))) - 6 * ((d &&& f) ^^^ (d ^^^ ( ~~~e &&& f))) - 11 * (e ^^^  ~~~( ~~~d &&& (e &&& f))) - 1 * ( ~~~f |||  ~~~(d ^^^ e)) + 2 * (e ^^^  ~~~( ~~~d &&& ( ~~~e ||| f))) + 1 * ((d &&& e) ^^^  ~~~(d ^^^ (e &&& f))) + 4 * (f ^^^  ~~~(d &&&  ~~~e)) - 7 * ( ~~~(d ||| e) |||  ~~~(e ^^^ f)) + 4 * ( ~~~(d &&&  ~~~e) &&&  ~~~(d ^^^ (e ^^^ f))) - 11 * (d &&& f) + 4 * (f ^^^  ~~~( ~~~d &&& ( ~~~e &&& f))) - 1 *  ~~~(d ||| e) - 2 * (f ^^^ (d &&&  ~~~e)) - 7 * (f ^^^  ~~~(d &&& (e ||| f))) + 5 * (e &&&  ~~~(d &&& f)) + 7 * (f ^^^  ~~~(d ||| (e &&& f))) - 5 *  ~~~(d |||  ~~~e) + 2 * (f ^^^  ~~~( ~~~d &&& (e &&& f))) + 2 * ((d &&& f) ^^^ (e ||| f)) - 3 * ((d &&& f) ^^^ (d ^^^ (e &&& f))) - 6 * ((d |||  ~~~e) &&& (d ^^^ (e ^^^ f))) + 1 *  ~~~(d ^^^ f) + 1 *  ~~~(d &&&  ~~~e) - 1 * (d ||| (e &&& f)) - 7 * (d ||| (e ||| f)) + 7 *  ~~~(e ||| f) - 3 * (e ^^^ (d ||| f)) - 6 * (e ^^^ ( ~~~d &&& (e ^^^ f))) - 2 * (e ^^^  ~~~( ~~~d &&& (e ||| f))) - 11 *  ~~~(d |||  ~~~f) - 7 * ((d &&& e) ^^^  ~~~(d ^^^ ( ~~~e ||| f))) - 3 * (e ^^^ (d &&& (e ^^^ f))) - 6 * (f &&&  ~~~(d &&& e)) + 5 * ( ~~~(d &&& e) &&&  ~~~(e ^^^ f)) - 2 * (e &&&  ~~~(d ^^^ f)) + 1 * (f ^^^ (d &&& ( ~~~e ||| f))) + 3 * (d ||| ( ~~~e &&& f)) + 4 *  ~~~(d ^^^ (e ^^^ f)) - 5 * ( ~~~(d ^^^ e) &&&  ~~~(d ^^^ f)) + 7 * ( ~~~(d ||| e) ||| (e ^^^ f)) + 5 * ((d |||  ~~~e) &&&  ~~~(e ^^^ f)) - 5 * (f ^^^  ~~~(d &&& ( ~~~e ||| f))) - 11 * ((e &&&  ~~~f) ^^^ (d ||| (e ^^^ f))) - 3 * ((d ||| e) &&& (d ^^^ (e ^^^ f))) - 1 * (e &&& (d |||  ~~~f)) - 3 * (f ^^^  ~~~( ~~~d ||| ( ~~~e &&& f))) - 2 * (f ^^^ (d |||  ~~~e)) + 3 *  ~~~(d ||| (e ||| f)) + 19 *  ~~~(d ||| ( ~~~e ||| f)) + 57 *  ~~~( ~~~d ||| (e ||| f)) - 7 *  ~~~( ~~~d ||| ( ~~~e ||| f)) + 72 * ( ~~~d &&& ( ~~~e &&& f)) + 45 * ( ~~~d &&& (e &&& f)) + 30 * (d &&& ( ~~~e &&& f)) + 75 * (d &&& (e &&& f)) =  - 2 * (f ^^^ (d ||| (e ||| f)))

theorem xor_of_icmps_to_ne_commute_thm.extracted_1._1 : ∀ (x : BitVec 64),
  ofBool (x <ₛ 6#64) ^^^ ofBool (4#64 <ₛ x) = ofBool (x != 5#64)

theorem badimm2_proof : badimm2_before ⊑ badimm2_after

theorem main7g_logical_thm.extracted_1._6 : ∀ (x x_1 x_2 x_3 : BitVec 32),
  ¬ofBool (x_3 &&& x_2 == x_3 &&& x_2 &&& x_1) = 1#1 →
    ofBool (x_3 &&& x_2 != x_3 &&& x_2 &&& x_1) = 1#1 → ¬0#1 = 1#1 → 1#32 = zeroExtend 32 1#1

theorem e_1695 :
    4 * (c ^^^  ~~~(a &&& ( ~~~b &&& c))) + 1 * ( ~~~(a &&& b) &&& (a ^^^ (b ^^^ c))) + 1 * (b |||  ~~~c) - 3 * ((a &&& c) ^^^ (b ||| c)) + 7 * (b ^^^ (a &&& c)) + 7 * (b ^^^ (a &&& (b ^^^ c))) - 1 *  ~~~( ~~~a &&& (b ^^^ c)) + 1 * ((b &&& c) ^^^  ~~~( ~~~a &&& (b ^^^ c))) - 5 * (c ^^^ (a ||| (b &&& c))) + 2 * (a &&&  ~~~b) + 5 * (b ^^^ ( ~~~a &&& (b ^^^ c))) + 4 * (c ^^^ ( ~~~a ||| (b &&& c))) - 5 * a + 7 * ((a &&& b) ^^^ (b ||| c)) - 5 * (c ||| (a ^^^ b)) - 3 * (a ||| c) + 1 * (a ^^^ ( ~~~b &&& c)) + 2 * ( ~~~a ||| ( ~~~b &&& c)) + 4 * (b ^^^ (a &&& ( ~~~b ||| c))) - 2 *  ~~~a - 2 * (a ||| (b &&& c)) - 2 *  ~~~(a ||| (b ||| c)) - 27 *  ~~~(a ||| ( ~~~b ||| c)) + 7 *  ~~~( ~~~a ||| (b ||| c)) - 4 *  ~~~( ~~~a ||| ( ~~~b ||| c)) + 9 * ( ~~~a &&& ( ~~~b &&& c)) - 17 * ( ~~~a &&& (b &&& c)) - 22 * (a &&& ( ~~~b &&& c)) + 9 * (a &&& (b &&& c)) = 7 * (b ^^^  ~~~(a &&& ( ~~~b ||| c)))

theorem test_add_nsw__all_are_safe_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ofBool (x &&& 1073741823#32 == 3#32) = 1#1 →
    ¬(True ∧ (x &&& 1073741823#32).saddOverflow 1#32 = true ∨ True ∧ (x &&& 1073741823#32).uaddOverflow 1#32 = true) →
      4#32 = (x &&& 1073741823#32) + 1#32

theorem t8_thm (e : IntW 8) :
  icmp IntPred.eq (sub (const? 8 0) e { «nsw» := true, «nuw» := false }) e ⊑
    icmp IntPred.eq e (const? 8 0)

theorem e_1882 :
    5 * ((a &&& b) ||| (b ^^^ c)) + 5 * (c &&&  ~~~(a &&&  ~~~b)) - 5 *  ~~~( ~~~a &&& ( ~~~b &&& c)) - 1 * (a &&& (b ||| c)) + 4 * ((a ||| b) &&&  ~~~(a ^^^ (b ^^^ c))) + 11 * (a ^^^ ( ~~~b ||| c)) + 11 * (a ||| c) - 7 * b - 1 *  ~~~(a ^^^ (b ^^^ c)) - 3 * (b &&&  ~~~(a ^^^ c)) - 2 * ( ~~~a &&& (b ||| c)) - 7 * ( ~~~(a &&& b) &&& (b ^^^ c)) - 11 * ( ~~~a ||| (b ||| c)) - 1 * (a &&&  ~~~b) - 1 * (b |||  ~~~(a ||| c)) + 4 * (a ^^^ (b ^^^ c)) + 5 * (b ||| (a &&&  ~~~c)) + 2 * ( ~~~(a &&&  ~~~b) &&& (b ^^^ c)) + 7 *  ~~~( ~~~a &&& (b &&& c)) - 1 * ((a &&& c) ^^^  ~~~(a ^^^ ( ~~~b &&& c))) + 4 * (b ^^^  ~~~(a &&& ( ~~~b ||| c))) - 3 * ((b &&&  ~~~c) |||  ~~~( ~~~a ||| ( ~~~b &&& c))) + 11 * (c ^^^  ~~~( ~~~a ||| (b &&& c))) + 1 * ((a &&&  ~~~b) ||| (b ^^^ c)) - 3 * (c ^^^ (a ||| ( ~~~b &&& c))) - 2 * (b ^^^  ~~~(a &&&  ~~~c)) + 2 * ( ~~~b |||  ~~~(a ^^^ c)) - 1 * (b ^^^  ~~~(a ||| ( ~~~b &&& c))) + 4 * (a &&& c) - 2 * ( ~~~a ||| ( ~~~b &&& c)) - 11 * (a ||| ( ~~~b &&& c)) - 2 * (b &&& (a ^^^ c)) + 4 * ((b &&& c) ^^^  ~~~(a &&& (b ^^^ c))) - 1 *  ~~~(a ||| b) - 1 * (c |||  ~~~(a ||| b)) + 4 * (a ^^^ b) + 3 * (b ^^^ ( ~~~a &&& (b ^^^ c))) + 1 * (b ^^^ (a &&& (b ||| c))) - 1 *  ~~~(a ^^^ (b &&& c)) + 3 * (b ^^^ (a ||| (b &&& c))) - 1 *  ~~~(a ||| (b ||| c)) + 7 *  ~~~(a ||| ( ~~~b ||| c)) - 29 *  ~~~( ~~~a ||| (b ||| c)) - 11 *  ~~~( ~~~a ||| ( ~~~b ||| c)) - 31 * ( ~~~a &&& ( ~~~b &&& c)) - 20 * ( ~~~a &&& (b &&& c)) - 1 * (a &&& ( ~~~b &&& c)) - 14 * (a &&& (b &&& c)) = 2 * (b ^^^  ~~~(a |||  ~~~c)) - 1 * (c ||| (a &&& b))

@[simp]
lemma complete_eval {M : NFA α σ} {w} (q : σ) :
    (.inl q ∈ M.complete.eval w) ↔ q ∈ M.eval w

theorem e_1635 :
     - 1 * ((a &&& c) ||| (b &&&  ~~~c)) - 1 *  ~~~(a ^^^ c) + 2 * (a ||| (b ^^^ c)) + 5 * (c ^^^ ( ~~~a ||| (b &&& c))) + 4 * ((a &&& b) ^^^  ~~~(a ^^^ (b &&& c))) - 7 * ( ~~~(a ^^^ b) ||| (a ^^^ c)) + 1 * (c ^^^ (a ||| ( ~~~b &&& c))) - 1 * (c ^^^  ~~~(a ||| (b &&& c))) + 1 * (b ^^^ ( ~~~a &&& (b ^^^ c))) + 1 * (b &&& (a ^^^ c)) + 7 * (c ^^^  ~~~(a |||  ~~~b)) - 2 * (b &&&  ~~~(a ^^^ c)) + 1 * (c ^^^ (a ||| ( ~~~b ||| c))) + 1 * (a &&& (b ||| c)) + 1 * ((a ||| b) &&& (b ^^^ c)) - 1 *  ~~~(a ||| (b ||| c)) - 14 *  ~~~(a ||| ( ~~~b ||| c)) + 3 *  ~~~( ~~~a ||| (b ||| c)) - 4 *  ~~~( ~~~a ||| ( ~~~b ||| c)) - 7 * ( ~~~a &&& ( ~~~b &&& c)) + 5 * ( ~~~a &&& (b &&& c)) + 1 * (a &&& (b &&& c)) = 13 * (a &&& ( ~~~b &&& c))

theorem test7_thm (e : IntW 1) : sext 64 (zext 32 e) ⊑ zext 64 e

theorem bitwise_and_logical_and_icmps_comm3_thm.extracted_1._5 : ∀ (x x_1 x_2 : BitVec 8),
  ¬x_1 ≥ ↑8 →
    ofBool (x_2 &&& 1#8 != 0#8) = 1#1 →
      ¬(True ∧ 1#8 <<< x_1 >>> x_1 ≠ 1#8 ∨ x_1 ≥ ↑8 ∨ True ∧ 1#8 <<< x_1 >>> x_1 ≠ 1#8 ∨ x_1 ≥ ↑8) →
        ¬ofBool (x_2 &&& (1#8 <<< x_1 ||| 1#8) == 1#8 <<< x_1 ||| 1#8) = 1#1 →
          ofBool (x_2 &&& 1#8 <<< x_1 != 0#8) &&& ofBool (x == 42#8) = 0#1

theorem lshr_add_xor_fail_proof : lshr_add_xor_fail_before ⊑ lshr_add_xor_fail_after

theorem trunc_unsigned_nsw_sext_proof : trunc_unsigned_nsw_sext_before ⊑ trunc_unsigned_nsw_sext_after

theorem and_or2_proof : and_or2_before ⊑ and_or2_after

theorem icmp_shl_nsw_eq_proof : icmp_shl_nsw_eq_before ⊑ icmp_shl_nsw_eq_after

theorem positive_biggerashr_proof : positive_biggerashr_before ⊑ positive_biggerashr_after

theorem e_299 :
    1 * y + 1 * x - 5 *  ~~~y + 4 *  ~~~(x ||| y) - 2 *  ~~~(x |||  ~~~y) + 3 * (x &&&  ~~~y) - 3 * (x &&& y) =  - 1 *  ~~~(x &&&  ~~~x)

theorem e_1362 :
     - 11 *  ~~~(z ^^^ t) + 1 * (z ^^^ t) - 3 * t - 6 *  ~~~(z &&&  ~~~z) + 11 * (z |||  ~~~t) - 2 * z + 9 *  ~~~(z ||| t) + 11 *  ~~~(z |||  ~~~t) - 4 * (z &&&  ~~~t) + 11 * (z &&& t) = 3 *  ~~~z

theorem test3_thm.extracted_1._1 : ∀ (x : BitVec 23), x ^^^ x = 0#23

theorem a_false_implies_b_true2_comm_thm.extracted_1._1 : ∀ (x : BitVec 1) (x_1 : BitVec 8),
  ofBool (x_1 <ᵤ 20#8) = 1#1 → ofBool (10#8 <ᵤ x_1) = 1#1 → x ||

theorem ashrslt_03_00_exact_proof : ashrslt_03_00_exact_before ⊑ ashrslt_03_00_exact_after

theorem sext_xor_sub_2_proof : sext_xor_sub_2_before ⊑ sext_xor_sub_2_after

@[simp]
lemma List.Vector.transport_get {v : Vector α m} { f : Fin n → Fin m} :
    (v.transport f).get i = v.get (f i)

theorem test94_thm.extracted_1._1 : ∀ (x : BitVec 32),
  signExtend 64 (signExtend 8 (ofBool (x == BitVec.ofInt 32 (-2))) ^^^ -1#8) =
    signExtend 64 (ofBool (x != BitVec.ofInt 32 (-2)))

theorem positive_sameconst_shlnuwnsw_lshrexact_thm (e : IntW 8) :
  shl (lshr e (const? 8 3) { «exact» := true }) (const? 8 3) { «nsw» := true, «nuw» := true } ⊑ e

theorem zext_sext_add_icmp_slt_minus1_thm (e e_1 : IntW 1) :
  icmp IntPred.slt (add (zext 8 e_1) (sext 8 e)) (const? 8 (-1)) ⊑ const? 1 0

theorem ashr_xor_proof : ashr_xor_before ⊑ ashr_xor_after

theorem main10_logical_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ofBool (x &&& 64#32 == 0#32) = 1#1 →
    ¬ofBool (x &&& 192#32 == 0#32) = 1#1 → ofBool (0#8 ≤ₛ truncate 8 x) = 1#1 → 2#32 = 1#32

theorem src_is_notmask_neg_p2_fail_not_invertable_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ofBool (0#8 == 0#8 - (0#8 - x_1 &&& x_1) &&& (x ^^^ 123#8)) =
    ofBool (x_1 ||| 0#8 - x_1 ≤ᵤ x ^^^ BitVec.ofInt 8 (-124))

theorem PR28476_logical_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬ofBool (x != 0#32) = 1#1 → ofBool (x == 0#32) = 1#1 → zeroExtend 32 0#1 ^^^ 1#32 = zeroExtend 32 1#1

theorem e_1816 :
    1 * (b ^^^ (a &&& ( ~~~b ||| c))) - 1 * ((a &&& c) |||  ~~~(b ||| c)) - 1 * (b &&&  ~~~(a ^^^ c)) + 2 * ( ~~~(a &&&  ~~~b) &&& (b ^^^ c)) - 5 * (b ^^^ (a |||  ~~~c)) - 11 *  ~~~(b |||  ~~~c) - 1 * (b &&&  ~~~(a &&&  ~~~c)) - 1 * ( ~~~b &&& (a ^^^ c)) + 2 * (c ^^^  ~~~(a ||| ( ~~~b &&& c))) - 6 *  ~~~(a ||| (b &&& c)) + 1 * (c ^^^ (a ||| ( ~~~b &&& c))) - 6 * ((a &&&  ~~~b) |||  ~~~(a ^^^ (b ^^^ c))) + 4 *  ~~~(a ||| c) - 3 * ((a &&& c) ||| (b &&&  ~~~c)) - 2 * ((a ^^^ b) &&&  ~~~(a ^^^ c)) + 3 * (b ||| (a ^^^ c)) - 2 * (b ^^^  ~~~(a &&& (b ^^^ c))) + 7 * (a &&& ( ~~~b ||| c)) + 1 * (b ^^^ ( ~~~a ||| ( ~~~b ||| c))) + 1 * ((a ^^^ b) ||| (a ^^^ c)) + 2 * ((a ^^^ b) |||  ~~~(a ^^^ c)) + 11 * (b ^^^  ~~~(a ||| ( ~~~b &&& c))) - 11 *  ~~~(a &&& (b ^^^ c)) - 11 * (b ||| (a &&& c)) - 7 * ((a &&& b) ^^^ (b |||  ~~~c)) + 4 * a - 5 * ((a &&& b) ||| (b ^^^ c)) - 1 * (b ^^^ ( ~~~a ||| (b ^^^ c))) + 1 * (b |||  ~~~(a ||| c)) - 6 * ( ~~~(a &&& b) &&& (b ^^^ c)) + 4 * (c ^^^ (a ||| (b &&& c))) - 2 * (a ^^^ (b ^^^ c)) - 1 * (a ^^^ (b ||| c)) + 18 *  ~~~(a ||| (b ||| c)) + 40 *  ~~~(a ||| ( ~~~b ||| c)) + 12 *  ~~~( ~~~a ||| (b ||| c)) - 5 *  ~~~( ~~~a ||| ( ~~~b ||| c)) + 30 * ( ~~~a &&& ( ~~~b &&& c)) + 30 * ( ~~~a &&& (b &&& c)) + 30 * (a &&& ( ~~~b &&& c)) + 3 * (a &&& (b &&& c)) =  - 3 * (c ||| (a &&& b))

theorem foo1_and_thm (e e_1 e_2 : IntW 32) :
  LLVM.or (icmp IntPred.eq (LLVM.and (shl (const? 32 1) e_2) e_1) (const? 32 0))
      (icmp IntPred.eq (LLVM.and (shl (const? 32 1) e) e_1) (const? 32 0)) ⊑
    icmp IntPred.ne
      (LLVM.and e_1
        (LLVM.or (shl (const? 32 1) e_2 { «nsw» := false, «nuw» := true })
          (shl (const? 32 1) e { «nsw» := false, «nuw» := true })))
      (LLVM.or (shl (const? 32 1) e_2 { «nsw» := false, «nuw» := true })
        (shl (const? 32 1) e { «nsw» := false, «nuw» := true }))

theorem not_cmp_constant_proof : not_cmp_constant_before ⊑ not_cmp_constant_after

theorem bitwise_and_logical_and_icmps_comm1_thm.extracted_1._3 : ∀ (x x_1 x_2 : BitVec 8),
  ¬x_1 ≥ ↑8 → ¬ofBool (x == 42#8) = 1#1 → ofBool (x_2 &&& 1#8 <<< x_1 != 0#8) &&& 0#1 = 0#1

@[simp]
theorem mkCarryAssignCircuitNAux_eval_eq {arity : Type _}
    [DecidableEq arity]
    [Fintype arity]
    [Hashable arity]
    (p : FSM arity) (s : p.α) (n : Nat)
    {env : Vars p.α arity (n + 1) → Bool} :
    ((mkCarryAssignCircuitNAux p s n).eval env) = ((p.nextStateCirc s).eval
      (fun x => match x with | .inl x => env (Vars.stateN x n) | .inr x => env (Vars.inputN x n)))

theorem icmp_slt_0_and_icmp_sge_neg2_i64_thm.extracted_1._1 : ∀ (x : BitVec 64),
  ¬63#64 ≥ ↑64 →
    x >>> 63#64 &&& zeroExtend 64 (ofBool (BitVec.ofInt 64 (-2) ≤ₛ x)) =
      zeroExtend 64 (ofBool (BitVec.ofInt 64 (-3) <ᵤ x))

theorem PR21222_proof : PR21222_before ⊑ PR21222_after

theorem e_1172 :
    5 * (z |||  ~~~t) - 5 *  ~~~z - 5 *  ~~~t + 4 *  ~~~(z &&&  ~~~t) + 1 *  ~~~(z ||| t) + 12 *  ~~~(z |||  ~~~t) + 11 * (z &&&  ~~~t) + 2 * (z &&& t) = 11 * (z ||| t)

theorem test4_proof : test4_before ⊑ test4_after

theorem test7_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬zeroExtend 29 x ≥ ↑29 → (-1#29).sshiftRight' (zeroExtend 29 x) = -1#29

theorem ashrslt_01_08_proof : ashrslt_01_08_before ⊑ ashrslt_01_08_after

theorem masked_icmps_mask_notallzeros_bmask_mixed_swapped_1b_logical_proof : masked_icmps_mask_notallzeros_bmask_mixed_swapped_1b_logical_before ⊑ masked_icmps_mask_notallzeros_bmask_mixed_swapped_1b_logical_after

theorem ashr_sub_nsw_proof : ashr_sub_nsw_before ⊑ ashr_sub_nsw_after

theorem self_EqualUpTo_ofBitVecZext_toBitVec (x : BitStream) :
  EqualUpTo w x (BitStream.ofBitVecZext (x.toBitVec w))

theorem t5_thm.extracted_1._5 : ∀ (x x_1 : BitVec 1) (x_2 : BitVec 32),
  x_1 = 1#1 → x = 1#1 → ¬32#32 = 0 → ¬5#32 ≥ ↑32 → x_2 / 32#32 = x_2 >>> 5#32

theorem test_sext_zext_thm.extracted_1._1 : ∀ (x : BitVec 16), signExtend 64 (zeroExtend 32 x) = zeroExtend 64 x

theorem and_xor_or1_proof : and_xor_or1_before ⊑ and_xor_or1_after

theorem negate_zext_thm.extracted_1._1 : ∀ (x : BitVec 1) (x_1 : BitVec 8),
  x_1 - zeroExtend 8 x = x_1 + signExtend 8 x

theorem lshrult_02_05_exact_proof : lshrult_02_05_exact_before ⊑ lshrult_02_05_exact_after

@[simp]
theorem castLe_eq_self {α : Type _} {n : Nat} (i : Inputs α n) (h : n ≤ n) :
    i.castLe h = i

theorem lshr_32_add_zext_basic_proof : lshr_32_add_zext_basic_before ⊑ lshr_32_add_zext_basic_after

theorem PR2844_logical_thm.extracted_1._4 : ∀ (x : BitVec 32),
  ¬ofBool (x == 0#32) = 1#1 →
    ¬ofBool (x <ₛ BitVec.ofInt 32 (-638208501)) = 1#1 →
      1#32 = zeroExtend 32 (ofBool (x != 0#32) &&& ofBool (BitVec.ofInt 32 (-638208502) <ₛ x))

theorem ult_swap_and_max_proof : ult_swap_and_max_before ⊑ ult_swap_and_max_after

theorem p1_scalar_urem_by_nonconst_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬x ||

theorem test_ashr_exact__exact_is_unsafe_thm.extracted_1._3 : ∀ (x : BitVec 64) (x_1 : BitVec 32),
  ¬ofBool (x_1 &&& BitVec.ofInt 32 (-2147483585) == 0#32) = 1#1 →
    ¬(True ∧ (x_1 &&& BitVec.ofInt 32 (-2147483585)) >>> 2#32 <<< 2#32 ≠ x_1 &&& BitVec.ofInt 32 (-2147483585) ∨
          2#32 ≥ ↑32 ∨ zeroExtend 64 ((x_1 &&& BitVec.ofInt 32 (-2147483585)).sshiftRight' 2#32) ≥ ↑64) →
      2#32 ≥ ↑32 ∨
          True ∧ (x_1.sshiftRight' 2#32 &&& BitVec.ofInt 32 (-536870897)).msb = true ∨
            zeroExtend 64 (x_1.sshiftRight' 2#32 &&& BitVec.ofInt 32 (-536870897)) ≥ ↑64 →
        False

theorem test19_thm.extracted_1._1 : ∀ (x : BitVec 10),
  ¬(2#3 ≥ ↑3 ∨ 2#3 ≥ ↑3) → True ∧ (0#3).ssubOverflow (truncate 3 x &&& 1#3) = true → False

theorem PR42691_1_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x <ₛ 0#32) ||

theorem e_555 :
    11 * (x |||  ~~~y) - 1 *  ~~~x + 4 *  ~~~(x &&&  ~~~y) + 7 *  ~~~(x ^^^ y) + 7 * (x ^^^ y) - 14 *  ~~~(x ||| y) - 3 *  ~~~(x |||  ~~~y) - 11 * (x &&&  ~~~y) - 15 * (x &&& y) = 7 *  ~~~(x &&&  ~~~x)

theorem factorize3_proof : factorize3_before ⊑ factorize3_after

theorem select_ashr_icmp_bad_thm (e e_1 e_2 : IntW 32) :
  select (icmp IntPred.eq e_2 (const? 32 1)) (ashr e_1 e_2) e ⊑
    select (icmp IntPred.eq e_2 (const? 32 1)) (ashr e_1 (const? 32 1)) e

theorem testi16i8_ne_com_thm.extracted_1._1 : ∀ (x : BitVec 16),
  ¬(8#16 ≥ ↑16 ∨ 7#8 ≥ ↑8) →
    ofBool (truncate 8 (x >>> 8#16) != (truncate 8 x).sshiftRight' 7#8) =
      ofBool (x + BitVec.ofInt 16 (-128) <ᵤ BitVec.ofInt 16 (-256))

theorem test_nuw_nsw_and_signed_pred_proof : test_nuw_nsw_and_signed_pred_before ⊑ test_nuw_nsw_and_signed_pred_after

theorem logic_or_logic_and_6_proof : logic_or_logic_and_6_before ⊑ logic_or_logic_and_6_after

theorem foo1_and_commuted_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 32),
  ¬(x_1 ≥ ↑32 ∨ x ≥ ↑32) →
    True ∧ 1#32 <<< x_1 >>> x_1 ≠ 1#32 ∨
        x_1 ≥ ↑32 ∨
          True ∧ 1#32 <<< x >>> x ≠ 1#32 ∨
            x ≥ ↑32 ∨ True ∧ 1#32 <<< x_1 >>> x_1 ≠ 1#32 ∨ x_1 ≥ ↑32 ∨ True ∧ 1#32 <<< x >>> x ≠ 1#32 ∨ x ≥ ↑32 →
      False

theorem Tensor2d'.map_error (f : α → β) : (Tensor2d'.error α).map f = Tensor2d'.error β

theorem select_1_thm.extracted_1._19 : ∀ (x x_1 : BitVec 8) (x_2 : BitVec 1) (x_3 x_4 : BitVec 8) (x_5 : BitVec 1),
  ¬x_5 = 1#1 → x_2 = 1#1 → x_1 ^^^ -1#8 ^^^ -1#8 = x_1

theorem test21_proof : test21_before ⊑ test21_after

theorem main4e_like_logical_thm.extracted_1._2 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (x_1 &&& x == x) = 1#1 → ofBool (x_1 &&& x != x) = 1#1 → ¬0#1 = 1#1 → 1#32 = zeroExtend 32 1#1

theorem neg_slt_0_thm (e : IntW 8) :
  icmp IntPred.slt (sub (const? 8 0) e) (const? 8 0) ⊑
    icmp IntPred.sgt (add e (const? 8 (-1))) (const? 8 (-1))

theorem prove_exact_with_high_mask_thm.extracted_1._2 : ∀ (x : BitVec 8),
  ¬(4#8 == 0 || 8 != 1 && x &&& BitVec.ofInt 8 (-8) == intMin 8 && 4#8 == -1) = true →
    ¬2#8 ≥ ↑8 → (x &&& BitVec.ofInt 8 (-8)).sdiv 4#8 = x.sshiftRight' 2#8 &&& BitVec.ofInt 8 (-2)

theorem PR2844_logical_proof : PR2844_logical_before ⊑ PR2844_logical_after

theorem bools2_logical_commute0_and2_thm.extracted_1._1 : ∀ (x : BitVec 1), ¬x = 1#1 → 0#1 = 1#1 → False

theorem sub_from_constant_of_sub_from_constant_thm (e : IntW 8) : sub (const? 8 11) (sub (const? 8 42) e) ⊑ add e (const? 8 (-31))

theorem test16_proof : test16_before ⊑ test16_after

theorem icmp_sle9_thm (e : IntW 8) :
  icmp IntPred.sle (shl e (const? 8 7) { «nsw» := true, «nuw» := false }) (const? 8 (-128)) ⊑
    icmp IntPred.ne e (const? 8 0)

theorem e_889 :
     - 2 *  ~~~z + 1 *  ~~~(z &&&  ~~~z) - 2 * (z ||| t) + 1 *  ~~~(z ||| t) + 3 *  ~~~(z |||  ~~~t) + 1 * (z &&&  ~~~t) =  - 1 * (z &&& t)

theorem main4e_like_proof : main4e_like_before ⊑ main4e_like_after

theorem e_35 :
    11 * (x ^^^ y) - 7 *  ~~~(x &&& y) - 1 *  ~~~x - 3 *  ~~~(x |||  ~~~y) - 4 * (x &&&  ~~~y) =  - 8 *  ~~~(x ||| y)

theorem ashrsgt_02_02_thm (e : IntW 4) : icmp IntPred.sgt (ashr e (const? 4 2)) (const? 4 2) ⊑ const? 1 0

theorem and_shl_thm.extracted_1._2 : ∀ (x x_1 x_2 x_3 : BitVec 8),
  ¬(x_2 ≥ ↑8 ∨ x_2 ≥ ↑8) → ¬x_2 ≥ ↑8 → x_3 <<< x_2 &&& (x_1 <<< x_2 &&& x) = (x_1 &&& x_3) <<< x_2 &&& x

@[simp] theorem matchVar_nil_eq {lets : Lets d Γ_in eff Γ_out} :
    matchVar lets v (.nil : Lets d Δ .pure Δ) w = unifyVars w v

theorem sext_sext_sge_op0_narrow_thm.extracted_1._1 : ∀ (x : BitVec 8) (x_1 : BitVec 5),
  ofBool (signExtend 32 x ≤ₛ signExtend 32 x_1) = ofBool (x ≤ₛ signExtend 8 x_1)

theorem lshr_lshr_pow2_const_thm.extracted_1._1 : ∀ (x : BitVec 16),
  ¬(x ≥ ↑16 ∨ 6#16 ≥ ↑16) → ofBool (x == 3#16) = 1#1 → 2048#16 >>> x >>> 6#16 &&& 4#16 = 4#16

theorem negate_shl_xor_thm.extracted_1._1 : ∀ (x x_1 : BitVec 4),
  ¬x ≥ ↑4 → 0#4 - (x_1 ^^^ 5#4) <<< x = ((x_1 ^^^ BitVec.ofInt 4 (-6)) + 1#4) <<< x

theorem ult_and_max_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8), ofBool (x_1 <ᵤ x) &&& ofBool (x_1 == -1#8) = 0#1

theorem lshr_16_add_known_16_leading_zeroes_proof : lshr_16_add_known_16_leading_zeroes_before ⊑ lshr_16_add_known_16_leading_zeroes_after

theorem select_icmp_ne_pow2_flipped_proof : select_icmp_ne_pow2_flipped_before ⊑ select_icmp_ne_pow2_flipped_after

theorem lshrugt_01_07_proof : lshrugt_01_07_before ⊑ lshrugt_01_07_after

theorem ugt_swap_and_min_proof : ugt_swap_and_min_before ⊑ ugt_swap_and_min_after

theorem foo2_proof : foo2_before ⊑ foo2_after

theorem scalar1_thm (e e_1 : IntW 4) :
  LLVM.xor (LLVM.and (LLVM.xor e_1 e) (const? 4 (-2))) e ⊑
    LLVM.or (LLVM.and e_1 (const? 4 (-2))) (LLVM.and e (const? 4 1)) { «disjoint» := true }

@[simp] theorem ofBitVec_and {w : Nat} {x y : BitVec w} : ofBitVecSext (x &&& y) = (ofBitVecSext x) &&& (ofBitVecSext y)

theorem main4b_logical_proof : main4b_logical_before ⊑ main4b_logical_after

theorem main7c_logical_thm.extracted_1._3 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (x_1 == x_1 &&& x) = 1#1 → ¬ofBool (x_1 != x_1 &&& x) = 1#1 → 0#1 = 1#1 → False

@[simp]
theorem Factor.numVars_term : (Factor.var n).numVars = n + 1

theorem both_proof : both_before ⊑ both_after

theorem substitute_constant_and_eq_eq_proof : substitute_constant_and_eq_eq_before ⊑ substitute_constant_and_eq_eq_after

theorem ule_swap_or_not_min_proof : ule_swap_or_not_min_before ⊑ ule_swap_or_not_min_after

theorem test7_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬1#32 ≥ ↑32 →
    ¬(1#32 ≥ ↑32 ∨ True ∧ (x >>> 1#32).uaddOverflow 2147483647#32 = true) →
      zeroExtend 64 (x >>> 1#32) + 2147483647#64 = zeroExtend 64 (x >>> 1#32 + 2147483647#32)

theorem main9_logical_proof : main9_logical_before ⊑ main9_logical_after

theorem test_and3_logical_proof : test_and3_logical_before ⊑ test_and3_logical_after

theorem trunc_shl_7_i8_i64_thm (e : IntW 64) : trunc 8 (shl e (const? 64 7)) ⊑ shl (trunc 8 e) (const? 8 7)

theorem e_1499 :
    2 * (z ||| t) + 11 * (z |||  ~~~t) + 7 *  ~~~(z &&&  ~~~z) + 1 *  ~~~(z &&& t) - 7 *  ~~~z + 11 *  ~~~(z ^^^ t) - 1 * (z ^^^ t) - 23 *  ~~~(z ||| t) + 5 *  ~~~(z |||  ~~~t) - 19 * (z &&&  ~~~t) - 23 * (z &&& t) = 1 * z + 7 * t

theorem e_2045 :
    1 * (f &&&  ~~~(d ^^^ e)) - 2 * ((d ||| e) &&& (e ^^^ f)) - 1 * (e |||  ~~~(d ^^^ f)) - 2 *  ~~~( ~~~d &&& ( ~~~e ||| f)) + 5 * (f ^^^ ( ~~~d ||| (e ||| f))) - 2 * (f ^^^ (d ||| (e ||| f))) - 11 * (e ^^^ (d &&& ( ~~~e ||| f))) + 2 * (f ^^^ ( ~~~d &&& (e ||| f))) - 2 * (d ^^^ e) - 7 * ( ~~~f &&&  ~~~(d ^^^ e)) - 11 *  ~~~(e |||  ~~~f) - 1 * (d &&& ( ~~~e ||| f)) + 4 *  ~~~(d ^^^ ( ~~~e &&& f)) - 1 * ((d |||  ~~~e) &&& (d ^^^ (e ^^^ f))) + 7 *  ~~~(d ^^^ ( ~~~e ||| f)) + 5 *  ~~~( ~~~d &&& ( ~~~e &&& f)) + 11 * ((d &&& e) ^^^ (d ^^^ ( ~~~e ||| f))) + 2 * (f ||| (d ^^^ e)) - 1 * ((d &&& e) |||  ~~~(e ^^^ f)) - 11 * (f &&& (d ^^^ e)) + 3 *  ~~~(d |||  ~~~f) + 2 * (d ||| e) + 2 * ( ~~~d &&& ( ~~~e ||| f)) + 4 *  ~~~(d &&& f) + 2 * ((e &&& f) ^^^  ~~~(d &&& (e ^^^ f))) + 7 * (e ^^^ (d ||| ( ~~~e ||| f))) + 3 * (f ^^^  ~~~(d |||  ~~~e)) + 7 * (f ^^^ (d ||| ( ~~~e ||| f))) - 2 * (d ||| (e ^^^ f)) - 36 *  ~~~(d ||| (e ||| f)) - 21 *  ~~~(d ||| ( ~~~e ||| f)) - 12 *  ~~~( ~~~d ||| (e ||| f)) + 7 *  ~~~( ~~~d ||| ( ~~~e ||| f)) - 7 * ( ~~~d &&& (e &&& f)) + 13 * (d &&& ( ~~~e &&& f)) - 25 * (d &&& (e &&& f)) = 21 * ( ~~~d &&& ( ~~~e &&& f)) + 2 * ((e &&& f) ^^^  ~~~( ~~~d &&& (e ^^^ f)))

theorem test56_thm (e : IntW 16) :
  zext 64 (lshr (sext 32 e) (const? 32 5)) ⊑ zext 64 (lshr (sext 32 e) (const? 32 5)) { «nneg» := true }

theorem bools2_logical_commute2_thm.extracted_1._10 : ∀ (x x_1 x_2 : BitVec 1),
  x_2 = 1#1 → ¬x = 1#1 → x_1 = 1#1 → 1#1 = x_1

theorem test14_proof : test14_before ⊑ test14_after

theorem and_signbit_select_lshr_proof : and_signbit_select_lshr_before ⊑ and_signbit_select_lshr_after

theorem ne_optimized_highbits_cmp_proof : ne_optimized_highbits_cmp_before ⊑ ne_optimized_highbits_cmp_after

theorem e_2111 :
    7 *  ~~~(d |||  ~~~f) + 1 * ( ~~~(d &&& e) &&&  ~~~(d ^^^ (e ^^^ f))) + 1 * (e ^^^ (d ||| ( ~~~e &&& f))) - 5 * ((d &&&  ~~~e) ||| (d ^^^ (e ^^^ f))) + 5 * (f ^^^ ( ~~~d ||| (e ||| f))) - 1 * (f &&& (d ^^^ e)) - 6 * ((d &&& f) ^^^  ~~~(d ^^^ ( ~~~e &&& f))) + 3 * (f ^^^  ~~~(d ||| ( ~~~e &&& f))) - 1 *  ~~~(d ^^^ ( ~~~e &&& f)) + 5 * (f |||  ~~~(d ^^^ e)) + 1 * ((d |||  ~~~e) &&&  ~~~(e ^^^ f)) - 2 * (f &&& (d |||  ~~~e)) - 5 * ((d ||| e) &&&  ~~~(d ^^^ (e ^^^ f))) - 3 * ( ~~~d ||| ( ~~~e ||| f)) - 1 * (f ^^^ ( ~~~d ||| (e &&& f))) - 11 * (d &&& ( ~~~e ||| f)) - 1 * ((d ^^^ e) |||  ~~~(d ^^^ f)) - 2 * (e ^^^ (d |||  ~~~f)) - 2 * ((d &&& e) |||  ~~~(e |||  ~~~f)) + 7 *  ~~~(d &&& f) - 1 * ((d &&& f) |||  ~~~(e ||| f)) + 3 * ( ~~~(d ^^^ e) &&&  ~~~(d ^^^ f)) - 6 * (f ^^^  ~~~( ~~~d ||| (e &&& f))) - 5 * ((d &&& e) ^^^ (e ||| f)) - 1 * ((e &&& f) ^^^  ~~~(d &&& (e ^^^ f))) + 11 * ( ~~~(d |||  ~~~e) ||| (d ^^^ (e ^^^ f))) + 7 * (e &&& f) + 2 * ((d &&&  ~~~e) |||  ~~~(e ^^^ f)) + 1 * (e |||  ~~~f) - 6 * (e |||  ~~~(d ^^^ f)) - 7 * (d &&& f) - 11 * (e ^^^  ~~~( ~~~d ||| (e ^^^ f))) - 2 *  ~~~(d &&& e) - 2 * (e ||| (d &&&  ~~~f)) + 1 * (f ^^^  ~~~( ~~~d &&& (e &&& f))) - 1 * ( ~~~e &&&  ~~~(d ^^^ f)) - 9 *  ~~~(d ||| (e ||| f)) + 14 *  ~~~(d ||| ( ~~~e ||| f)) + 15 *  ~~~( ~~~d ||| (e ||| f)) + 7 *  ~~~( ~~~d ||| ( ~~~e ||| f)) - 13 * ( ~~~d &&& ( ~~~e &&& f)) + 8 * ( ~~~d &&& (e &&& f)) + 43 * (d &&& ( ~~~e &&& f)) + 14 * (d &&& (e &&& f)) =  - 5 * (e ^^^  ~~~(d &&& (e ||| f))) - 1 * ((d &&& e) ^^^  ~~~(d ^^^ ( ~~~e ||| f)))

@[ext]
theorem ext_getElem? {Γ Δ : Ctxt Ty} (h : ∀ (i : Nat), Γ[i]? = Δ[i]?) : Γ = Δ

@[simp]
theorem MatchVar.isMonotone_bind_liftM {x? : Option α} {g : α → MatchVar Δ Γ} :
    IsMonotone (liftM x? >>= g) ↔ (∀ x ∈ x?, (g x).IsMonotone)

theorem xor_logic_and_or2_thm.extracted_1._2 : ∀ (x x_1 x_2 : BitVec 1),
  x_2 = 1#1 → ¬x_1 = 1#1 → x_1 ^^^ (x_1 ||| x) = x

theorem zext_nneg_redundant_and_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬(True ∧ x.msb = true) → zeroExtend 32 x &&& 127#32 = zeroExtend 32 x

theorem PR42691_8_logical_thm (e : IntW 32) :
  select (icmp IntPred.slt e (const? 32 14)) (icmp IntPred.ne e (const? 32 (-2147483648))) (const? 1 0) ⊑
    icmp IntPred.ult (add e (const? 32 2147483647)) (const? 32 (-2147483635))

theorem e_1640 :
     - 3 * ((a ^^^ b) &&& (a ^^^ c)) + 1 * ( ~~~(a &&& b) &&&  ~~~(a ^^^ (b ^^^ c))) + 11 * (a &&& b) - 1 * ((b &&& c) ^^^  ~~~(a &&& (b ^^^ c))) + 2 * (b ^^^  ~~~( ~~~a &&& (b ||| c))) + 1 * (c ^^^  ~~~( ~~~a ||| (b &&& c))) - 6 *  ~~~( ~~~a &&& ( ~~~b &&& c)) - 6 *  ~~~(a |||  ~~~c) + 5 * (b ^^^ (a &&&  ~~~c)) + 1 * ((a &&& b) ^^^ (a ^^^ (b &&& c))) + 7 * (c ^^^ (a &&& b)) - 2 * ((a ||| b) &&&  ~~~(b ^^^ c)) - 5 * (b |||  ~~~(a ||| c)) + 11 * (c ^^^ (a ||| b)) + 9 *  ~~~(a ||| (b ||| c)) - 8 *  ~~~(a ||| ( ~~~b ||| c)) - 8 *  ~~~( ~~~a ||| (b ||| c)) - 19 *  ~~~( ~~~a ||| ( ~~~b ||| c)) - 12 * ( ~~~a &&& ( ~~~b &&& c)) + 3 * ( ~~~a &&& (b &&& c)) - 7 * (a &&& ( ~~~b &&& c)) - 7 * (a &&& (b &&& c)) =  - 2 * (b ^^^ (a &&& (b ^^^ c)))

theorem add_or_and_commutative_proof : add_or_and_commutative_before ⊑ add_or_and_commutative_after

theorem trunc_shl_shl_infloop_proof : trunc_shl_shl_infloop_before ⊑ trunc_shl_shl_infloop_after

theorem neg_of_add_with_constant_thm.extracted_1._1 : ∀ (x : BitVec 8), 0#8 - (x + 42#8) = BitVec.ofInt 8 (-42) - x

theorem a_thm.extracted_1._1 : ∀ (x x_1 : BitVec 1),
  x_1 = 1#1 → True ∧ (2#32).saddOverflow (signExtend 32 x) = true → False

@[simp] theorem map_nil (f : Ty → Ty') : map f ∅ = ∅

theorem test_shl_nuw__nuw_is_safe_thm.extracted_1._3 : ∀ (x : BitVec 64) (x_1 : BitVec 32),
  ¬ofBool (x_1 &&& 1073741822#32 == 0#32) = 1#1 →
    ¬(True ∧ (x_1 &&& 1073741822#32) <<< 2#32 >>> 2#32 ≠ x_1 &&& 1073741822#32 ∨
          2#32 ≥ ↑32 ∨ zeroExtend 64 ((x_1 &&& 1073741822#32) <<< 2#32) ≥ ↑64) →
      2#32 ≥ ↑32 ∨
          True ∧ (x_1 <<< 2#32 &&& BitVec.ofInt 32 (-8)).msb = true ∨
            zeroExtend 64 (x_1 <<< 2#32 &&& BitVec.ofInt 32 (-8)) ≥ ↑64 →
        False

theorem test25_logical_thm (e : IntW 32) :
  select (icmp IntPred.sge e (const? 32 50)) (icmp IntPred.slt e (const? 32 100)) (const? 1 0) ⊑
    icmp IntPred.ult (add e (const? 32 (-50))) (const? 32 50)

theorem demorgan_or_apint1_proof : demorgan_or_apint1_before ⊑ demorgan_or_apint1_after

theorem PR60818_ne_proof : PR60818_ne_before ⊑ PR60818_ne_after

theorem ashr_exact_poison_constant_fold_thm (e : IntW 8) (e_1 : IntW 1) :
  ashr (select e_1 e (const? 8 42)) (const? 8 3) { «exact» := true } ⊑
    select e_1 (ashr e (const? 8 3)) (const? 8 5)

theorem fold_icmp_shl_nuw_c2_non_pow2_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬(True ∧ 48#32 <<< x >>> x ≠ 48#32 ∨ x ≥ ↑32) → ofBool (48#32 <<< x <ᵤ 192#32) = ofBool (x <ᵤ 2#32)

theorem test12_logical_thm.extracted_1._2 : ∀ (x x_1 : BitVec 32), ¬ofBool (x_1 <ᵤ x) = 1#1 → 0#1 = ofBool (x_1 <ᵤ x)

theorem e_568 :
     - 5 *  ~~~x - 1 * (x ||| y) - 2 *  ~~~(x &&& y) + 1 * y - 5 *  ~~~(x &&&  ~~~x) + 7 *  ~~~(x &&&  ~~~y) + 5 *  ~~~(x ||| y) + 8 * (x &&&  ~~~y) - 2 * (x &&& y) =  - 5 *  ~~~(x |||  ~~~y)

theorem substitute_constant_and_eq_eq_commute_proof : substitute_constant_and_eq_eq_commute_before ⊑ substitute_constant_and_eq_eq_commute_after

@[simp] lemma eval_fsmCarry'' (x : Bool → BitStream) :
    (fsmCarry'' initCarry).eval x =
      (BitStream.carry' initCarry (x true) (x false))

theorem test_sub_4_Y_ne_4_proof : test_sub_4_Y_ne_4_before ⊑ test_sub_4_Y_ne_4_after

theorem positive_biggershl_thm (e : IntW 8) :
  shl (lshr e (const? 8 3)) (const? 8 6) ⊑ LLVM.and (shl e (const? 8 3)) (const? 8 (-64))

theorem add_nsw_const_const_sub_thm (e : IntW 8) :
  sub (const? 8 (-127)) (add e (const? 8 1) { «nsw» := true, «nuw» := false }) ⊑ sub (const? 8 (-128)) e

theorem test3_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32), ¬1#32 ≥ ↑32 → (x_1 ||| x <<< 1#32) &&& 1#32 = x_1 &&& 1#32

theorem logic_and_logic_or_7_proof : logic_and_logic_or_7_before ⊑ logic_and_logic_or_7_after

theorem not_logicalOr_not_op1_thm (e e_1 : IntW 1) :
  LLVM.xor (select e_1 (const? 1 1) (LLVM.xor e (const? 1 1))) (const? 1 1) ⊑
    select (LLVM.xor e_1 (const? 1 1)) e (const? 1 0)

theorem ashrslt_03_01_thm (e : IntW 4) : icmp IntPred.slt (ashr e (const? 4 3)) (const? 4 1) ⊑ const? 1 1

theorem or2_thm (e e_1 : IntW 64) : LLVM.or (LLVM.and e_1 e) (LLVM.xor e_1 e) ⊑ LLVM.or e_1 e

@[grind =, simp]
lemma RawCNFA.addInitial_tr {m : RawCNFA A} : (m.addInitial s'').tr s a = m.tr s a

omit [LawfulBEq A] [Fintype S] in
lemma processOneElem_rel {s₁ s₂ : State} :
    s₂ ~[(processOneElem A S final s₁ st (a, sa)).rel] sa' ↔
      (s₂ ~[st.rel] sa' ∨ (s₂ = st.m.stateMax ∧ sa' = sa ∧ st.map[sa']? = none))

@[simp] theorem appendList_eq : Γ ++ tys = Γ ++ ⟨tys⟩

theorem test11b_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  (x_1 ^^^ -1#32 ^^^ x) &&& (x ^^^ x_1) = (x ^^^ x_1) &&& (x_1 ^^^ x ^^^ -1#32)

theorem test1_thm (e : IntW 33) : LLVM.udiv e (const? 33 4096) ⊑ lshr e (const? 33 12)

theorem test13_thm (e e_1 : IntW 32) :
  LLVM.xor (LLVM.xor e_1 (const? 32 (-1))) (LLVM.and e_1 (LLVM.xor e (const? 32 (-1)))) ⊑
    LLVM.xor (LLVM.and e_1 e) (const? 32 (-1))

theorem t5_proof : t5_before ⊑ t5_after

theorem test29_proof : test29_before ⊑ test29_after

theorem or_trunc_lshr_more_thm.extracted_1._2 : ∀ (x : BitVec 8),
  ¬4#8 ≥ ↑8 →
    ¬(4#6 ≥ ↑6 ∨ True ∧ (truncate 6 x >>> 4#6 &&& BitVec.ofInt 6 (-4) != 0) = true) →
      truncate 6 (x >>> 4#8) ||

theorem ashr_ult_4_proof : ashr_ult_4_before ⊑ ashr_ult_4_after

theorem ashr_known_pos_exact_proof : ashr_known_pos_exact_before ⊑ ashr_known_pos_exact_after

theorem main3_logical_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ofBool (x &&& 7#32 == 0#32) = 1#1 →
    ¬ofBool (x &&& 48#32 == 0#32) = 1#1 → 1#32 = zeroExtend 32 (ofBool (x &&& 55#32 != 0#32))

theorem select_icmp_ne_0_and_32_or_4096_thm.extracted_1._2 : ∀ (x x_1 : BitVec 32),
  ofBool (0#32 != x_1 &&& 32#32) = 1#1 → ¬7#32 ≥ ↑32 → x = x ||

theorem test_shl__all_are_safe_thm.extracted_1._4 : ∀ (x : BitVec 64) (x_1 : BitVec 32),
  ¬ofBool (x_1 &&& 15#32 == 0#32) = 1#1 →
    ¬(2#32 ≥ ↑32 ∨ zeroExtend 64 ((x_1 &&& 15#32) <<< 2#32) ≥ ↑64) →
      ¬(2#32 ≥ ↑32 ∨ True ∧ (x_1 <<< 2#32 &&& 60#32).msb = true ∨ zeroExtend 64 (x_1 <<< 2#32 &&& 60#32) ≥ ↑64) →
        x.sshiftRight' (zeroExtend 64 ((x_1 &&& 15#32) <<< 2#32)) =
          x.sshiftRight' (zeroExtend 64 (x_1 <<< 2#32 &&& 60#32))

theorem sle_swap_or_not_min_proof : sle_swap_or_not_min_before ⊑ sle_swap_or_not_min_after

theorem eq_21_comm_and_proof : eq_21_comm_and_before ⊑ eq_21_comm_and_after

theorem commutativity_constant_14_vary_proof : commutativity_constant_14_vary_before ⊑ commutativity_constant_14_vary_after

theorem ugt_zext_thm (e : IntW 8) (e_1 : IntW 1) :
  icmp IntPred.ugt (zext 8 e_1) e ⊑ LLVM.and (icmp IntPred.eq e (const? 8 0)) e_1

theorem e_10 :
     - 3 * x - 2 *  ~~~y + 6 * (x &&&  ~~~y) + 4 * (x &&& y) =  - 3 *  ~~~(x ||| y) + 1 * (x |||  ~~~y)

theorem ashrslt_02_07_proof : ashrslt_02_07_before ⊑ ashrslt_02_07_after

theorem shl_C1_add_A_C2_i32_thm.extracted_1._2 : ∀ (x : BitVec 16),
  ¬zeroExtend 32 x + 5#32 ≥ ↑32 →
    ¬(True ∧ x.msb = true ∨ zeroExtend 32 x ≥ ↑32) → 6#32 <<< (zeroExtend 32 x + 5#32) = 192#32 <<< zeroExtend 32 x

theorem and_or1_commuted_thm.extracted_1._1 : ∀ (x x_1 : BitVec 1),
  x_1 ||

theorem test2_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ofBool (x_1 ^^^ x == 0#32) ^^^ ofBool (x_1 ^^^ x == 32#32) = ofBool (x_1 == x) ^^^ ofBool (x_1 ^^^ x == 32#32)

theorem shl_add_proof : shl_add_before ⊑ shl_add_after

theorem e_2 :
    1 *  ~~~x - 2 * (x ^^^ y) + 1 *  ~~~(x &&& y) = 2 *  ~~~(x ||| y) - 1 * (x &&&  ~~~y)

theorem sle_or_min_logical_thm.extracted_1._2 : ∀ (x x_1 : BitVec 8),
  ¬ofBool (x_1 ≤ₛ x) = 1#1 → ofBool (x_1 == BitVec.ofInt 8 (-128)) = ofBool (x_1 ≤ₛ x)

theorem icmp_eq_sext_ne_otherwise_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (signExtend 32 (ofBool (x != 2#32)) == x) = ofBool (x == -1#32)

theorem or_nosignbit_select_ashr_proof : or_nosignbit_select_ashr_before ⊑ or_nosignbit_select_ashr_after

theorem test13_thm (e : IntW 32) :
  icmp IntPred.ult (LLVM.udiv (const? 32 4) e) (const? 32 3) ⊑ icmp IntPred.ugt e (const? 32 1)

theorem test12_thm (e : IntW 32) : LLVM.srem (LLVM.and e (const? 32 (-4))) (const? 32 2) ⊑ const? 32 0

theorem a_true_implies_b_true2_comm_thm.extracted_1._4 : ∀ (x : BitVec 1) (x_1 : BitVec 8),
  ¬ofBool (10#8 <ᵤ x_1) = 1#1 → ¬ofBool (20#8 <ᵤ x_1) = 1#1 → x &&& ofBool (20#8 <ᵤ x_1) = 0#1

theorem tryFactorization_xor_ashr_lshr_proof : tryFactorization_xor_ashr_lshr_before ⊑ tryFactorization_xor_ashr_lshr_after

theorem neg_not_eq_add_one :
    - ~~~ x = x + 1

theorem e_431 :
    2 *  ~~~y + 11 * (x ||| y) - 3 *  ~~~(x ^^^ y) - 2 * y - 5 * (x |||  ~~~y) - 5 *  ~~~(x ||| y) - 19 * (x &&&  ~~~y) - 1 * (x &&& y) =  - 11 *  ~~~(x &&& y) + 20 *  ~~~(x |||  ~~~y)

theorem and_logic_and_logic_or_2_thm (e e_1 e_2 : IntW 1) :
  select (LLVM.and e_2 e_1) (const? 1 1) (select e e_2 (const? 1 0)) ⊑
    select e_2 (select e_1 (const? 1 1) e) (const? 1 0)

theorem e_566 :
    5 * (x ||| y) - 1 *  ~~~(x &&&  ~~~x) - 3 * y - 2 *  ~~~x + 5 *  ~~~(x &&&  ~~~y) + 2 *  ~~~(x &&& y) - 5 *  ~~~(x ||| y) - 6 *  ~~~(x |||  ~~~y) - 7 * (x &&& y) = 7 * (x &&&  ~~~y) - 1 * (x |||  ~~~y)

theorem ashrsgt_03_08_proof : ashrsgt_03_08_before ⊑ ashrsgt_03_08_after

theorem shl_add_lshr_flag_preservation_thm.extracted_1._2 : ∀ (x x_1 x_2 : BitVec 32),
  ¬(True ∧ x_2 <<< x_1 >>> x_1 ≠ x_2 ∨
        x_1 ≥ ↑32 ∨
          True ∧ (x_2 <<< x_1).saddOverflow x = true ∨
            True ∧ (x_2 <<< x_1).uaddOverflow x = true ∨
              True ∧ (x_2 <<< x_1 + x) >>> x_1 <<< x_1 ≠ x_2 <<< x_1 + x ∨ x_1 ≥ ↑32) →
    ¬(True ∧ x >>> x_1 <<< x_1 ≠ x ∨
          x_1 ≥ ↑32 ∨ True ∧ (x >>> x_1).saddOverflow x_2 = true ∨ True ∧ (x >>> x_1).uaddOverflow x_2 = true) →
      (x_2 <<< x_1 + x) >>> x_1 = x >>> x_1 + x_2

theorem test2_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32), 3#32 ≥ ↑32 → False

theorem pr51551_neg2_proof : pr51551_neg2_before ⊑ pr51551_neg2_after

theorem test9_proof : test9_before ⊑ test9_after

theorem t7_ugt_sgt_neg1_thm.extracted_1._15 : ∀ (x x_1 x_2 : BitVec 32),
  ¬ofBool (65535#32 <ᵤ x_2) = 1#1 → ¬ofBool (65535#32 <ₛ x_2) = 1#1 → ofBool (x_2 <ₛ 0#32) = 1#1 → x_2 = x

theorem e_1836 :
    2 * ((a &&& b) ^^^  ~~~(a ^^^ (b &&& c))) + 2 * ((b &&& c) ^^^  ~~~(a &&& (b ^^^ c))) + 1 * (a &&&  ~~~b) + 2 * ((a ||| b) &&& (a ^^^ (b ^^^ c))) + 5 * ( ~~~(a &&& b) &&&  ~~~(a ^^^ (b ^^^ c))) + 11 * ((a |||  ~~~b) &&& (b ^^^ c)) - 6 * (c ^^^  ~~~( ~~~a ||| ( ~~~b &&& c))) + 4 * ((a &&& b) |||  ~~~(a ^^^ (b ^^^ c))) + 1 * ( ~~~a &&& (b ||| c)) - 5 *  ~~~(a ^^^ c) + 4 * ( ~~~(a ||| b) ||| (b ^^^ c)) - 1 * (a ||| (b &&& c)) + 3 *  ~~~(a &&& ( ~~~b &&& c)) + 7 * (b ^^^ (a ||| (b ||| c))) - 1 * (c ^^^  ~~~(a ||| b)) - 1 * (c ^^^ ( ~~~a ||| ( ~~~b &&& c))) - 2 * ((a &&&  ~~~b) |||  ~~~(a ^^^ (b ^^^ c))) + 1 * (c ^^^ ( ~~~a ||| ( ~~~b ||| c))) + 11 *  ~~~(a ||| (b &&& c)) + 1 * (c ^^^ (a &&& ( ~~~b ||| c))) + 4 * (c |||  ~~~(a ||| b)) - 6 * ((a |||  ~~~b) &&&  ~~~(b ^^^ c)) - 1 * (a &&& c) - 6 * ((a &&& c) ^^^  ~~~(a ^^^ (b &&& c))) + 2 * (c ^^^ (a ||| ( ~~~b &&& c))) + 11 * (b ^^^  ~~~(a &&& (b ^^^ c))) - 2 * ((a ^^^ b) &&& (a ^^^ c)) - 1 * (c ^^^  ~~~( ~~~a &&& ( ~~~b &&& c))) + 11 * ( ~~~b |||  ~~~(a ^^^ c)) + 11 * ( ~~~a ||| (b ^^^ c)) + 1 * (b ||| c) + 1 * (b &&& (a ^^^ c)) + 1 * ((a &&&  ~~~b) |||  ~~~(b ^^^ c)) - 2 * (b ^^^ (a ||| (b ^^^ c))) + 3 * (a ^^^ (b ||| c)) - 2 * (b ^^^ ( ~~~a &&& ( ~~~b ||| c))) - 37 *  ~~~(a ||| ( ~~~b ||| c)) - 29 *  ~~~( ~~~a ||| (b ||| c)) - 38 *  ~~~( ~~~a ||| ( ~~~b ||| c)) - 70 * ( ~~~a &&& ( ~~~b &&& c)) - 23 * ( ~~~a &&& (b &&& c)) - 36 * (a &&& ( ~~~b &&& c)) - 9 * (a &&& (b &&& c)) = 50 *  ~~~(a ||| (b ||| c)) - 4 * (b ^^^  ~~~(a &&& ( ~~~b &&& c)))

theorem ashrslt_03_05_thm.extracted_1._1 : ∀ (x : BitVec 4), ¬3#4 ≥ ↑4 → ofBool (x.sshiftRight' 3#4 <ₛ 5#4) = 1#1

theorem e_174 :
    2 * x + 2 * (x |||  ~~~y) - 1 * (x ^^^ y) - 2 *  ~~~(x ||| y) + 1 *  ~~~(x |||  ~~~y) - 4 * (x &&& y) = 3 * (x &&&  ~~~y)

theorem ult_to_slt_proof : ult_to_slt_before ⊑ ult_to_slt_after

theorem trunc_equality_nuw_thm (e e_1 : IntW 16) :
  icmp IntPred.eq (trunc 8 e_1 { «nsw» := false, «nuw» := true }) (trunc 8 e { «nsw» := false, «nuw» := true }) ⊑
    icmp IntPred.eq e_1 e

theorem drop_nuw_trunc_thm (e e_1 : IntW 16) :
  trunc 8 (LLVM.and (LLVM.and e_1 (const? 16 255)) e) { «nsw» := false, «nuw» := true } ⊑
    trunc 8 (LLVM.and e_1 e)

theorem trunc_shl_shl_var_proof : trunc_shl_shl_var_before ⊑ trunc_shl_shl_var_after

theorem bools_logical_commute1_thm.extracted_1._1 : ∀ (x : BitVec 1), ¬x = 1#1 → 0#1 = 1#1 → False

theorem not_signbit_splat_mask1_proof : not_signbit_splat_mask1_before ⊑ not_signbit_splat_mask1_after

theorem a_or_b_const_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 32),
  ofBool (x_2 == x_1) &&& ofBool (x != x_1) ||

theorem ugt_swap_or_not_min_thm (e e_1 : IntW 8) :
  LLVM.or (icmp IntPred.ult e_1 e) (icmp IntPred.ne e (const? 8 0)) ⊑
    icmp IntPred.ne e (const? 8 0)

theorem PR42691_9_logical_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬ofBool (13#32 <ₛ x) = 1#1 → 0#1 = ofBool (x + BitVec.ofInt 32 (-14) <ᵤ 2147483633#32)

theorem ashrsgt_02_11_proof : ashrsgt_02_11_before ⊑ ashrsgt_02_11_after

theorem shl_and_add_thm (e e_1 : IntW 8) :
  add (shl e_1 (const? 8 1)) (LLVM.and (shl e (const? 8 1)) (const? 8 119)) ⊑
    shl (add e_1 (LLVM.and e (const? 8 59))) (const? 8 1)

theorem lor_band_left1_thm.extracted_1._2 : ∀ (x x_1 : BitVec 1), x_1 = 1#1 → 1#1 &&& x_1 = x_1

theorem test_sext_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  x_1 + signExtend 32 (ofBool (x == 0#32)) ^^^ -1#32 = signExtend 32 (ofBool (x != 0#32)) - x_1

theorem sgt_swap_and_not_min_logical_thm (e e_1 : IntW 8) :
  select (icmp IntPred.slt e_1 e) (icmp IntPred.ne e (const? 8 (-128))) (const? 1 0) ⊑
    icmp IntPred.slt e_1 e

theorem test5_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬16#128 ≥ ↑128 → ¬16#32 ≥ ↑32 → truncate 32 (zeroExtend 128 x >>> 16#128) = x >>> 16#32

theorem test19_thm.extracted_1._2 : ∀ (x x_1 : BitVec 32),
  ¬(x ≥ ↑32 ∨ x_1 ≥ ↑32 ∨ x ≥ ↑32 ∨ (1#32 <<< x &&& 1#32 <<< x_1) + 1#32 <<< x = 0) →
    ¬(True ∧ 1#32 <<< x >>> x ≠ 1#32 ∨
          x ≥ ↑32 ∨ True ∧ 1#32 <<< x_1 >>> x_1 ≠ 1#32 ∨ x_1 ≥ ↑32 ∨ True ∧ 1#32 <<< x >>> x ≠ 1#32 ∨ x ≥ ↑32) →
      x_1 % ((1#32 <<< x &&& 1#32 <<< x_1) + 1#32 <<< x) = x_1 &&& (1#32 <<< x &&& 1#32 <<< x_1) + 1#32 <<< x + -1#32

theorem or_nontrivial_mask1_proof : or_nontrivial_mask1_before ⊑ or_nontrivial_mask1_after

theorem main11_logical_thm (e : IntW 32) :
  select
      (select (icmp IntPred.eq (LLVM.and e (const? 32 64)) (const? 32 0)) (const? 1 1)
        (icmp IntPred.sge (trunc 8 e) (const? 8 0)))
      (const? 32 2) (const? 32 1) ⊑
    select (icmp IntPred.eq (LLVM.and e (const? 32 192)) (const? 32 192)) (const? 32 1) (const? 32 2)

theorem e_829 :
    2 *  ~~~(z &&&  ~~~t) - 2 * z - 5 *  ~~~(z &&& t) + 5 *  ~~~(z |||  ~~~t) + 2 * (z &&&  ~~~t) = 2 *  ~~~z - 5 *  ~~~t

theorem test8_thm.extracted_1._1 : ∀ (x : BitVec 8), x &&& 3#8 &&& 4#8 = 0#8

theorem unsigned_sign_bit_extract_with_trunc_thm.extracted_1._1 : ∀ (x : BitVec 64),
  ¬63#64 ≥ ↑64 → ofBool (truncate 32 (x >>> 63#64) != 0#32) = ofBool (x <ₛ 0#64)

theorem nomask_rhs_proof : nomask_rhs_before ⊑ nomask_rhs_after

@[simp] lemma swapLastTwoBlock_Sn {n : Nat} : swapLastTwoBlock (n := n) (n+1) = Fin.last _

theorem e_822 :
     - 7 *  ~~~(z &&&  ~~~t) - 2 * t + 7 * (z |||  ~~~t) - 7 * (z &&&  ~~~t) + 2 * (z &&& t) =  - 9 *  ~~~(z |||  ~~~t)

theorem src_is_notmask_x_xor_neg_x_thm.extracted_1._1 : ∀ (x : BitVec 1) (x_1 : BitVec 8),
  ¬x = 1#1 → ofBool ((x_1 ^^^ 123#8) &&& BitVec.ofInt 8 (-8) == 0#8) = ofBool (x_1 ^^^ 123#8 ≤ᵤ 7#8)

theorem ashr_sle_noexact_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬3#8 ≥ ↑8 → ofBool (x.sshiftRight' 3#8 ≤ₛ 10#8) = ofBool (x <ₛ 88#8)

theorem shl_C1_add_A_C2_i32_proof : shl_C1_add_A_C2_i32_before ⊑ shl_C1_add_A_C2_i32_after

theorem eq_smax2_proof : eq_smax2_before ⊑ eq_smax2_after

theorem xor_andn_commute4_thm.extracted_1._2 : ∀ (x x_1 : BitVec 32),
  ¬(x_1 = 0 ∨ x = 0 ∨ x_1 = 0) →
    ¬(x_1 = 0 ∨ x = 0) → 42#32 / x_1 ^^^ 42#32 / x &&& (42#32 / x_1 ^^^ -1#32) = 42#32 / x_1 ||

theorem test15_thm (e : IntW 1) :
  shl (select e (const? 45 3) (const? 45 1)) (const? 45 2) ⊑ select e (const? 45 12) (const? 45 4)

theorem and_xor_common_op_proof : and_xor_common_op_before ⊑ and_xor_common_op_after

theorem e_61 :
    3 *  ~~~(x ^^^ y) - 1 * (x ||| y) + 1 * (x |||  ~~~y) - 4 *  ~~~(x ||| y) + 1 *  ~~~(x |||  ~~~y) = 3 * (x &&& y)

theorem shl_sub_lshr_thm (e e_1 e_2 : IntW 32) :
  lshr (sub (shl e_2 e_1 { «nsw» := false, «nuw» := true }) e { «nsw» := true, «nuw» := true }) e_1
      { «exact» := true } ⊑
    sub e_2 (lshr e e_1 { «exact» := true }) { «nsw» := true, «nuw» := true }

theorem test3_thm (e : IntW 32) : icmp IntPred.slt e e ⊑ const? 1 0

@[grind ., simp] lemma RawCNFA.empty_mem_finals {s : State} : s ∉ empty (A := A).finals

theorem bv_820 :
    ∀ (e e_1 : LLVM.IntW 9), LLVM.sdiv (LLVM.sub e (LLVM.srem e e_1)) e_1 ⊑ LLVM.sdiv e e_1

theorem test_add_nsw__none_are_safe_proof : test_add_nsw__none_are_safe_before ⊑ test_add_nsw__none_are_safe_after

theorem fold_add_udiv_urem_without_noundef_proof : fold_add_udiv_urem_without_noundef_before ⊑ fold_add_udiv_urem_without_noundef_after

@[bv_automata_nnf] theorem iff_eq (p q : Prop) : (p ↔ q) = (p = q)

theorem test59_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ¬(4#32 ≥ ↑32 ∨ 4#32 ≥ ↑32) →
    True ∧ (zeroExtend 32 x <<< 4#32).sshiftRight' 4#32 ≠ zeroExtend 32 x ∨
        True ∧ zeroExtend 32 x <<< 4#32 >>> 4#32 ≠ zeroExtend 32 x ∨
          4#32 ≥ ↑32 ∨
            4#8 ≥ ↑8 ∨
              True ∧ (x_1 >>> 4#8).msb = true ∨
                True ∧ (zeroExtend 32 x <<< 4#32 &&& 48#32 &&& zeroExtend 32 (x_1 >>> 4#8) != 0) = true ∨
                  True ∧ (zeroExtend 32 x <<< 4#32 &&& 48#32 ||| zeroExtend 32 (x_1 >>> 4#8)).msb = true →
      False

theorem e_2296 :
    1 *  ~~~(e &&& f) + 5 * (e ^^^  ~~~(d |||  ~~~f)) - 7 * (d ||| ( ~~~e &&& f)) + 1 * ((d ^^^ e) &&&  ~~~(d ^^^ f)) + 7 * (e ^^^ ( ~~~d ||| ( ~~~e &&& f))) + 3 * (e ^^^ (d &&& (e ||| f))) - 2 *  ~~~(d &&&  ~~~e) + 1 *  ~~~( ~~~d &&& ( ~~~e &&& f)) - 11 * (e ^^^ ( ~~~d &&& (e ||| f))) - 5 * (d |||  ~~~e) + 11 *  ~~~(d &&&  ~~~f) - 2 * (f ^^^  ~~~( ~~~d &&& (e &&& f))) + 1 * (e &&&  ~~~(d ^^^ f)) - 1 * ((e &&&  ~~~f) |||  ~~~(d ||| ( ~~~e &&& f))) + 3 * (f ^^^  ~~~(d &&& e)) - 6 * ( ~~~(d ||| e) ||| (e ^^^ f)) - 1 * (d ||| f) - 1 * ( ~~~e |||  ~~~(d ^^^ f)) + 1 * (e ^^^  ~~~(d ||| f)) + 2 * (e ^^^ (d |||  ~~~f)) - 6 * ((d &&& e) ||| (d ^^^ (e ^^^ f))) + 1 * (e ^^^  ~~~(d ||| (e ^^^ f))) - 1 * (f ^^^ (d &&& ( ~~~e ||| f))) + 2 * (d ||| (e &&& f)) - 11 * ((d &&& e) |||  ~~~(e ^^^ f)) - 1 * (f &&& (d ^^^ e)) + 1 * ((d &&& f) ||| (e &&&  ~~~f)) - 6 * (f ^^^  ~~~( ~~~d ||| (e &&& f))) - 2 * (f ^^^  ~~~( ~~~d &&& ( ~~~e &&& f))) + 7 * ((d ^^^ e) ||| (d ^^^ f)) - 5 * (e ||| (d &&& f)) + 11 *  ~~~(d ||| (e &&& f)) + 5 * (e ^^^ (d ||| (e ^^^ f))) + 1 * ((d |||  ~~~e) &&&  ~~~(d ^^^ (e ^^^ f))) - 1 * (e ^^^  ~~~( ~~~d &&& (e &&& f))) - 5 * ((d |||  ~~~e) &&& (e ^^^ f)) + 1 * ( ~~~(d ||| e) |||  ~~~(e ^^^ f)) + 7 * (e ^^^  ~~~(d ||| (e &&& f))) + 2 *  ~~~(d ||| ( ~~~e &&& f)) - 1 * ((d |||  ~~~e) &&& (d ^^^ (e ^^^ f))) - 1 * ((e &&&  ~~~f) |||  ~~~( ~~~d ||| ( ~~~e &&& f))) - 6 * (e |||  ~~~(d ^^^ f)) + 7 *  ~~~(d &&& (e &&& f)) + 5 * ((d &&&  ~~~e) |||  ~~~(e ^^^ f)) + 2 *  ~~~(d |||  ~~~f) + 1 * ((d &&& f) ^^^ (d ^^^ ( ~~~e &&& f))) + 11 * ((e &&&  ~~~f) ^^^ ( ~~~d ||| (e ^^^ f))) + 5 *  ~~~(d ||| (e ^^^ f)) + 4 *  ~~~(d &&& ( ~~~e &&& f)) - 7 * (f ^^^ (d ||| e)) - 11 *  ~~~(d ^^^ f) - 11 *  ~~~(d ^^^ (e ||| f)) + 1 * (e ^^^  ~~~( ~~~d &&& (e ^^^ f))) + 1 * (e ^^^  ~~~( ~~~d ||| ( ~~~e &&& f))) - 23 *  ~~~(d ||| (e ||| f)) - 5 *  ~~~(d ||| ( ~~~e ||| f)) + 11 *  ~~~( ~~~d ||| (e ||| f)) + 49 *  ~~~( ~~~d ||| ( ~~~e ||| f)) - 12 * ( ~~~d &&& ( ~~~e &&& f)) - 40 * ( ~~~d &&& (e &&& f)) - 1 * (d &&& ( ~~~e &&& f)) + 35 * (d &&& (e &&& f)) = 6 * ( ~~~(d &&& e) &&& (e ^^^ f))

theorem ashr_1_thm (e e_1 e_2 : IntW 8) (e_3 : IntW 1) :
  LLVM.xor (ashr (select e_3 (LLVM.xor e_2 (const? 8 (-1))) (LLVM.xor e_1 (const? 8 123))) e) (const? 8 (-1)) ⊑
    ashr (select e_3 e_2 (LLVM.xor e_1 (const? 8 (-124)))) e

theorem udiv_shl_mul_nuw_exact_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 5),
  ¬(True ∧ x_2 <<< x_1 >>> x_1 ≠ x_2 ∨
        x_1 ≥ ↑5 ∨ True ∧ x_2.umulOverflow x = true ∨ True ∧ (x_2 <<< x_1).umod (x_2 * x) ≠ 0 ∨ x_2 * x = 0) →
    True ∧ 1#5 <<< x_1 >>> x_1 ≠ 1#5 ∨ x_1 ≥ ↑5 ∨ True ∧ (1#5 <<< x_1).umod x ≠ 0 ∨ x = 0 → False

theorem signed_sign_bit_extract_proof : signed_sign_bit_extract_before ⊑ signed_sign_bit_extract_after

theorem sge_to_ugt_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ofBool (15#8 ≤ₛ x ^^^ BitVec.ofInt 8 (-128)) = ofBool (BitVec.ofInt 8 (-114) <ᵤ x)

theorem t6_proof : t6_before ⊑ t6_after

theorem logical_or_logical_or_icmps_comm1_thm.extracted_1._3 : ∀ (x x_1 x_2 : BitVec 8),
  ¬x_1 ≥ ↑8 →
    ofBool (x_2 &&& 1#8 <<< x_1 == 0#8) = 1#1 ∨ ofBool (x == 42#8) = 1#1 →
      ¬(True ∧ 1#8 <<< x_1 >>> x_1 ≠ 1#8 ∨ x_1 ≥ ↑8) →
        ¬ofBool (x_2 &&& 1#8 <<< x_1 == 0#8) = 1#1 → ¬ofBool (x == 42#8) = 1#1 → 1#1 = ofBool (x_2 &&& 1#8 == 0#8)

lemma Term.evalFin_eq_eval (t : Term)
   (varsList : List BitStream) (varsFin : Fin t.arity → BitStream)
   (hvars : ∀ (i : Fin t.arity), varsList.getD i default = (varsFin i)) :
    Term.evalFin t varsFin = Term.eval t varsList

theorem no_shift_xor_multiuse_cmp_thm.extracted_1._4 : ∀ (x x_1 x_2 : BitVec 32),
  ¬ofBool (0#32 != x_2 &&& 4096#32) = 1#1 → ¬ofBool (x_2 &&& 4096#32 == 0#32) = 1#1 → False

theorem test3a_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬(BitVec.ofInt 32 (-8) == 0 || 32 != 1 && x == intMin 32 && BitVec.ofInt 32 (-8) == -1) = true →
    ofBool (x.srem (BitVec.ofInt 32 (-8)) != 0#32) = ofBool (x &&& 7#32 != 0#32)

theorem t0_thm.extracted_1._10 : ∀ (x x_1 : BitVec 8) (x_2 : BitVec 1),
  ¬x_2 ^^^ 1#1 = 1#1 → ¬x_2 = 1#1 → ¬0#1 = 1#1 → False

theorem e_110 :
    4 *  ~~~y + 7 * y + 2 *  ~~~(x &&&  ~~~x) - 6 *  ~~~(x &&&  ~~~y) - 3 *  ~~~(x |||  ~~~y) - 6 * (x &&&  ~~~y) = 3 * (x &&& y)

theorem add_signbit_select_shl_proof : add_signbit_select_shl_before ⊑ add_signbit_select_shl_after

theorem AndZextAnd_thm.extracted_1._2 : ∀ (x : BitVec 3),
  ¬(True ∧ (x &&& 2#3).msb = true) → zeroExtend 5 (x &&& 3#3) &&& 14#5 = zeroExtend 5 (x &&& 2#3)

theorem substitute_constant_or_ne_swap_sle_logical_proof : substitute_constant_or_ne_swap_sle_logical_before ⊑ substitute_constant_or_ne_swap_sle_logical_after

theorem sgt_smin4_thm.extracted_1._2 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (x <ₛ x_1 + 3#32) = 1#1 → ofBool (x_1 + 3#32 <ₛ x_1 + 3#32) = 0#1

theorem test17_thm (e : IntW 32) : urem (const? 32 1) e ⊑ zext 32 (icmp IntPred.ne e (const? 32 1))

theorem shl_xor_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬(5#32 ≥ ↑32 ∨ 7#32 ≥ ↑32) → 12#32 ≥ ↑32 ∨ 7#32 ≥ ↑32 → False

theorem icmp_sle7_proof : icmp_sle7_before ⊑ icmp_sle7_after

theorem lshr_shl_pow2_const_xor_proof : lshr_shl_pow2_const_xor_before ⊑ lshr_shl_pow2_const_xor_after

theorem icmp_ne_sext_ne_zero_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (signExtend 32 (ofBool (x != 0#32)) != x) = ofBool (x + -1#32 <ᵤ BitVec.ofInt 32 (-2))

@[simp]
lemma or_fals (c : Circuit α) :
  c ||

theorem icmp_select_implied_cond_swapped_select_proof : icmp_select_implied_cond_swapped_select_before ⊑ icmp_select_implied_cond_swapped_select_after

theorem select_constants_and_icmp_eq0_thm.extracted_1._2 : ∀ (x x_1 : BitVec 1),
  x_1 = 1#1 → ¬x = 1#1 → ofBool (2#8 &&& 1#8 == 0#8) = x_1 ^^^ x

theorem trunc_shl_15_i16_i64_thm.extracted_1._1 : ∀ (x : BitVec 64), ¬15#64 ≥ ↑64 → 15#16 ≥ ↑16 → False

theorem add_shl_same_amount_partial_nsw2_proof : add_shl_same_amount_partial_nsw2_before ⊑ add_shl_same_amount_partial_nsw2_after

theorem ashrslt_03_01_proof : ashrslt_03_01_before ⊑ ashrslt_03_01_after

theorem sel_false_val_is_a_masked_shl_of_true_val2_thm.extracted_1._3 : ∀ (x : BitVec 64) (x_1 : BitVec 32),
  ¬(True ∧ ((x_1 &&& 15#32) <<< 2#32).sshiftRight' 2#32 ≠ x_1 &&& 15#32 ∨
        True ∧ (x_1 &&& 15#32) <<< 2#32 >>> 2#32 ≠ x_1 &&& 15#32 ∨ 2#32 ≥ ↑32) →
    ¬ofBool ((x_1 &&& 15#32) <<< 2#32 == 0#32) = 1#1 →
      ¬(True ∧ ((x_1 &&& 15#32) <<< 2#32).sshiftRight' 2#32 ≠ x_1 &&& 15#32 ∨
            True ∧ (x_1 &&& 15#32) <<< 2#32 >>> 2#32 ≠ x_1 &&& 15#32 ∨
              2#32 ≥ ↑32 ∨ zeroExtend 64 ((x_1 &&& 15#32) <<< 2#32) ≥ ↑64) →
        2#32 ≥ ↑32 ∨ True ∧ (x_1 <<< 2#32 &&& 60#32).msb = true ∨ zeroExtend 64 (x_1 <<< 2#32 &&& 60#32) ≥ ↑64 →
          False

theorem bools_multi_uses2_logical_proof : bools_multi_uses2_logical_before ⊑ bools_multi_uses2_logical_after

theorem test3_proof : test3_before ⊑ test3_after

theorem e_1795 :
    2 * (b |||  ~~~(a ||| c)) - 5 * (a ^^^ ( ~~~b ||| c)) - 6 * (b ^^^  ~~~(a &&& (b ||| c))) + 4 * (c &&& (a ||| b)) + 2 * ((a &&&  ~~~b) ||| (a ^^^ (b ^^^ c))) - 6 * (b ^^^ (a ||| c)) - 6 * (a &&& c) - 11 * (c ^^^ (a ||| (b &&& c))) - 6 * (c ^^^  ~~~( ~~~a &&& ( ~~~b ||| c))) + 2 *  ~~~(a &&& (b ||| c)) - 1 * ( ~~~b ||| (a ^^^ c)) - 7 * ((a &&& c) |||  ~~~(b ||| c)) - 2 * (c ^^^ (a &&& b)) - 1 * ( ~~~c &&& (a ^^^ b)) - 11 * ( ~~~c &&&  ~~~(a ^^^ b)) + 2 * ( ~~~(a &&&  ~~~b) &&&  ~~~(b ^^^ c)) + 4 * (a ||| (b ^^^ c)) + 3 * (b ^^^ (a ||| (b ^^^ c))) - 1 *  ~~~(a ||| (b &&& c)) + 5 * (b ^^^  ~~~(a |||  ~~~c)) + 11 * ( ~~~(a &&& b) &&&  ~~~(b ^^^ c)) - 1 * (c ^^^  ~~~( ~~~a &&& ( ~~~b &&& c))) + 11 * ( ~~~(a ^^^ b) ||| (a ^^^ c)) + 7 * (b ^^^  ~~~(a ||| c)) + 2 *  ~~~(a ^^^ (b ||| c)) - 2 * (b ^^^  ~~~( ~~~a ||| (b &&& c))) + 2 *  ~~~(a &&&  ~~~c) - 1 * (b ^^^ ( ~~~a ||| (b ||| c))) + 1 * ((a &&& b) ||| (a ^^^ (b ^^^ c))) + 1 *  ~~~(a &&& ( ~~~b &&& c)) - 2 * (b ^^^  ~~~(a &&& c)) - 5 *  ~~~(a ||| (b ||| c)) - 2 *  ~~~(a ||| ( ~~~b ||| c)) + 7 *  ~~~( ~~~a ||| (b ||| c)) + 9 *  ~~~( ~~~a ||| ( ~~~b ||| c)) + 11 * ( ~~~a &&& ( ~~~b &&& c)) - 29 * ( ~~~a &&& (b &&& c)) + 8 * (a &&& ( ~~~b &&& c)) - 21 * (a &&& (b &&& c)) =  - 1 *  ~~~( ~~~a ||| ( ~~~b &&& c))

theorem Std.HashMap.fold_induction [BEq α] [LawfulBEq α] [DecidableEq α] [Hashable α]
  {f : γ → α → β → γ} {m : HashMap α β} {motive : γ → (α → Option β) → Prop} :
    motive b (λ _ ↦ none) →
    (∀ b x y m, m x = none → motive b m → motive (f b x y) (Function.update m x y)) →
    motive (m.fold f b) m.toPFun

theorem xor_signbit_select_ashr_proof : xor_signbit_select_ashr_before ⊑ xor_signbit_select_ashr_after

theorem select_icmp_sgt_allones_smin_thm.extracted_1._2 : ∀ (x : BitVec 8),
  ¬ofBool (-1#8 <ₛ x) = 1#1 → x ^^^ BitVec.ofInt 8 (-128) = x &&& 127#8

theorem shift_xor_multiuse_cmp_thm (e e_1 e_2 e_3 : IntW 32) :
  mul (select (icmp IntPred.ne (const? 32 0) (LLVM.and e_3 (const? 32 4096))) e_2 (LLVM.or e_2 (const? 32 2048)))
      (select (icmp IntPred.ne (const? 32 0) (LLVM.and e_3 (const? 32 4096))) e_1 e) ⊑
    mul (select (icmp IntPred.eq (LLVM.and e_3 (const? 32 4096)) (const? 32 0)) (LLVM.or e_2 (const? 32 2048)) e_2)
      (select (icmp IntPred.eq (LLVM.and e_3 (const? 32 4096)) (const? 32 0)) e e_1)

theorem sdiv_shl_pair3_thm.extracted_1._2 : ∀ (x x_1 x_2 : BitVec 32),
  ¬(True ∧ (x_2 <<< x_1).sshiftRight' x_1 ≠ x_2 ∨
        x_1 ≥ ↑32 ∨
          True ∧ (x_2 <<< x).sshiftRight' x ≠ x_2 ∨
            x ≥ ↑32 ∨ (x_2 <<< x == 0 || 32 != 1 && x_2 <<< x_1 == intMin 32 && x_2 <<< x == -1) = true) →
    ¬(True ∧ 1#32 <<< x_1 >>> x_1 ≠ 1#32 ∨ x_1 ≥ ↑32 ∨ x ≥ ↑32) → (x_2 <<< x_1).sdiv (x_2 <<< x) = 1#32 <<< x_1 >>> x

theorem ashrslt_01_14_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬1#4 ≥ ↑4 → ofBool (x.sshiftRight' 1#4 <ₛ BitVec.ofInt 4 (-2)) = ofBool (x <ₛ BitVec.ofInt 4 (-4))

theorem lshrugt_03_08_exact_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬(True ∧ x >>> 3#4 <<< 3#4 ≠ x ∨ 3#4 ≥ ↑4) → ofBool (BitVec.ofInt 4 (-8) <ᵤ x >>> 3#4) = 0#1

theorem select_icmp_sgt_allones_smin_flipped_thm (e : IntW 8) :
  select (icmp IntPred.sgt e (const? 8 (-1))) (LLVM.xor e (const? 8 (-128))) e ⊑
    LLVM.or e (const? 8 (-128))

theorem cmpeq_xor_cst1_commuted_proof : cmpeq_xor_cst1_commuted_before ⊑ cmpeq_xor_cst1_commuted_after

theorem PR42691_1_logical_thm (e : IntW 32) :
  select (icmp IntPred.slt e (const? 32 0)) (const? 1 1) (icmp IntPred.eq e (const? 32 2147483647)) ⊑
    icmp IntPred.ugt e (const? 32 2147483646)

theorem logic_and_logic_or_5_thm (e e_1 e_2 : IntW 1) :
  select (select e_2 e_1 (const? 1 0)) (const? 1 1) (select e_2 e (const? 1 0)) ⊑
    select e_2 (select e_1 (const? 1 1) e) (const? 1 0)

theorem or_xor_and_commuted1_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  x_1 * x_1 ||

theorem or_nand_xor_common_op_commute0_proof : or_nand_xor_common_op_commute0_before ⊑ or_nand_xor_common_op_commute0_after

theorem modulo2_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬(2#32 == 0 || 32 != 1 && x == intMin 32 && 2#32 == -1) = true →
    ¬ofBool (x.srem 2#32 <ₛ 0#32) = 1#1 →
      ¬((2#32 == 0 || 32 != 1 && x == intMin 32 && 2#32 == -1) = true ∨
            True ∧ (0#32).saddOverflow (x.srem 2#32) = true) →
        0#32 + x.srem 2#32 = x &&& 1#32

theorem ne_nsw_rem_nz_thm (e : IntW 8) :
  icmp IntPred.ne (mul e (const? 8 5) { «nsw» := true, «nuw» := false }) (const? 8 (-126)) ⊑ const? 1 1

theorem test27_thm.extracted_1._1 : ∀ (x : BitVec 8), ((x &&& 4#8) - 16#8 &&& BitVec.ofInt 8 (-16)) + 16#8 = 0#8

@[simp] theorem scanAnd_succ (s : BitStream) : scanAnd s (n+1) = ((s.scanAnd n) && s (n + 1))

theorem positive_trunc_signbit_logical_proof : positive_trunc_signbit_logical_before ⊑ positive_trunc_signbit_logical_after

theorem exactly_one_set_signbit_wrong_pred_thm (e e_1 : IntW 8) :
  icmp IntPred.sgt (lshr e_1 (const? 8 7)) (zext 8 (icmp IntPred.sgt e (const? 8 (-1)))) ⊑
    icmp IntPred.slt (LLVM.and e e_1) (const? 8 0)

theorem lshrult_03_04_exact_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬(True ∧ x >>> 3#4 <<< 3#4 ≠ x ∨ 3#4 ≥ ↑4) → ofBool (x >>> 3#4 <ᵤ 4#4) = 1#1

theorem sext_xor_sub_1_proof : sext_xor_sub_1_before ⊑ sext_xor_sub_1_after

theorem icmp_equality_test_commute_select1_thm.extracted_1._2 : ∀ (x x_1 x_2 : BitVec 64),
  ¬ofBool (x_2 == x_1) = 1#1 → ofBool (x == x_1) = 1#1 → 0#1 = ofBool (x_2 == x)

theorem test2_thm (e e_1 : IntW 999) :
  icmp IntPred.ne (LLVM.and e_1 (const? 999 65280)) (LLVM.and e (const? 999 65280)) ⊑
    icmp IntPred.ne (LLVM.and (LLVM.xor e_1 e) (const? 999 65280)) (const? 999 0)

theorem not_mul_of_pow2_commute_proof : not_mul_of_pow2_commute_before ⊑ not_mul_of_pow2_commute_after

theorem e_1957 :
    1 * (b ^^^  ~~~( ~~~a ||| (b &&& c))) - 1 * (b ^^^  ~~~( ~~~a ||| ( ~~~b &&& c))) + 11 * ( ~~~a ||| (b ||| c)) + 5 * (b &&& (a ^^^ c)) + 4 * (b &&&  ~~~(a &&&  ~~~c)) + 2 *  ~~~(a ||| c) + 11 * (c ^^^ (a &&& b)) + 4 *  ~~~(a &&& (b ||| c)) - 1 * (b &&&  ~~~(a ^^^ c)) - 11 * (a ^^^ (b &&& c)) - 3 * (b ^^^  ~~~( ~~~a &&& (b ||| c))) - 1 *  ~~~(a &&& (b ^^^ c)) + 3 * (c ^^^ ( ~~~a ||| ( ~~~b &&& c))) + 7 * ((a &&& b) |||  ~~~(b |||  ~~~c)) + 4 * (c &&&  ~~~(a ^^^ b)) - 6 * (b ^^^ (a |||  ~~~c)) - 2 * (c ^^^  ~~~( ~~~a ||| ( ~~~b &&& c))) + 1 * ((a |||  ~~~b) &&& (b ^^^ c)) + 11 * (c ^^^  ~~~(a &&& (b ||| c))) - 1 * (c &&&  ~~~(a &&&  ~~~b)) + 2 * ((a &&& b) ^^^ (b |||  ~~~c)) + 5 * (b &&& c) - 2 * (a &&& (b ||| c)) - 5 *  ~~~(a |||  ~~~b) - 11 *  ~~~(b ||| c) - 3 * ( ~~~(a ^^^ b) &&& (a ^^^ c)) - 6 *  ~~~( ~~~a &&& (b ||| c)) - 1 * (c ||| (a &&&  ~~~b)) - 1 * ( ~~~c &&&  ~~~(a ^^^ b)) + 1 * ((b &&&  ~~~c) ^^^ ( ~~~a ||| (b ^^^ c))) - 2 * (b ^^^ ( ~~~a ||| (b ||| c))) + 1 * (b ^^^  ~~~(a ||| (b &&& c))) + 2 * (b ^^^  ~~~(a &&& (b ||| c))) + 3 * ((b &&&  ~~~c) |||  ~~~( ~~~a ||| ( ~~~b &&& c))) - 1 * ( ~~~a ||| ( ~~~b ||| c)) - 1 * ((a &&& b) |||  ~~~(b ^^^ c)) + 1 * (c ^^^ (a |||  ~~~b)) + 4 * ((a &&& c) ^^^  ~~~(a ^^^ ( ~~~b &&& c))) + 2 * ( ~~~(a |||  ~~~b) ||| (b ^^^ c)) + 5 * (b ^^^ (a ||| (b &&& c))) - 1 * ((a &&&  ~~~b) ||| (a ^^^ (b ^^^ c))) + 1 * ((a ^^^ b) &&&  ~~~(a ^^^ c)) - 7 * ((a &&& b) ^^^ (b ||| c)) + 11 * (a ||| c) + 1 * (a ||| (b &&& c)) + 1 * (b ^^^ ( ~~~a ||| ( ~~~b ||| c))) - 5 * (b ^^^ ( ~~~a ||| (b ^^^ c))) - 6 *  ~~~(a ||| (b ||| c)) - 35 *  ~~~(a ||| ( ~~~b ||| c)) - 33 *  ~~~( ~~~a ||| ( ~~~b ||| c)) - 34 * ( ~~~a &&& ( ~~~b &&& c)) - 26 * ( ~~~a &&& (b &&& c)) - 19 * (a &&& ( ~~~b &&& c)) - 48 * (a &&& (b &&& c)) =  - 2 * ((a ^^^ b) ||| (a ^^^ c)) - 1 *  ~~~( ~~~a ||| (b ||| c))

theorem n2_badmask_proof : n2_badmask_before ⊑ n2_badmask_after

theorem xor_or2_thm (e : IntW 8) :
  LLVM.or (LLVM.xor e (const? 8 33)) (const? 8 7) ⊑ LLVM.xor (LLVM.and e (const? 8 (-8))) (const? 8 39)

theorem or_lshr_thm.extracted_1._1 : ∀ (x x_1 x_2 x_3 : BitVec 8), ¬(x_2 ≥ ↑8 ∨ x_2 ≥ ↑8) → x_2 ≥ ↑8 → False

theorem mul_two :
  (bw r (mulMax (bw p a) (bw 2 (2#2))))  =
  (bw r ((bw p a) <<< 1))

theorem t3_thm.extracted_1._2 : ∀ (x : BitVec 32) (x_1 : BitVec 64),
  ¬(x ≥ ↑32 ∨ zeroExtend 64 (4#32 <<< x) = 0) →
    ¬(True ∧ (x + 2#32).msb = true ∨ zeroExtend 64 (x + 2#32) ≥ ↑64) →
      x_1 / zeroExtend 64 (4#32 <<< x) = x_1 >>> zeroExtend 64 (x + 2#32)

theorem test11b_thm (e e_1 : IntW 32) :
  LLVM.and (LLVM.xor (LLVM.xor e_1 (const? 32 (-1))) e) (LLVM.xor e e_1) ⊑
    LLVM.and (LLVM.xor e e_1) (LLVM.xor (LLVM.xor e_1 e) (const? 32 (-1)))

theorem shl_mask_wrong_shl_const_proof : shl_mask_wrong_shl_const_before ⊑ shl_mask_wrong_shl_const_after

theorem test8_logical_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬ofBool (x != 0#32) = 1#1 → 0#1 = ofBool (x + -1#32 <ᵤ 13#32)

theorem bar_thm.extracted_1._2 : ∀ (x x_1 x_2 x_3 : BitVec 32),
  ¬ofBool (x_2 <ₛ x_1) = 1#1 →
    x_3 &&& (signExtend 32 (ofBool (x_2 <ₛ x_1)) ^^^ -1#32) ||

theorem test2_thm.extracted_1._1 : ∀ (x : BitVec 32), x &&& -1#32 = x

theorem t0_proof : t0_before ⊑ t0_after

theorem demorgan_and_apint1_thm (e e_1 : IntW 477) :
  LLVM.and (LLVM.xor e_1 (const? 477 (-1))) (LLVM.xor e (const? 477 (-1))) ⊑
    LLVM.xor (LLVM.or e_1 e) (const? 477 (-1))

theorem gt_signed_to_small_unsigned_proof : gt_signed_to_small_unsigned_before ⊑ gt_signed_to_small_unsigned_after

theorem and_ne_with_one_bit_diff_constants3_proof : and_ne_with_one_bit_diff_constants3_before ⊑ and_ne_with_one_bit_diff_constants3_after

theorem test17_proof : test17_before ⊑ test17_after

theorem bools_multi_uses2_logical_thm.extracted_1._14 : ∀ (x x_1 : BitVec 1),
  ¬x_1 ^^^ 1#1 = 1#1 → x_1 = 1#1 → 0#1 = 1#1 → ¬x = 1#1 → True → 0#1 + x = 0#1

theorem or_not_and_wrong_b_proof : or_not_and_wrong_b_before ⊑ or_not_and_wrong_b_after

theorem t3_exact_thm (e : IntW 64) :
  sub (const? 64 0) (ashr e (const? 64 63) { «exact» := true }) ⊑ lshr e (const? 64 63) { «exact» := true }

theorem src_is_mask_zext_thm (e : IntW 8) (e_1 : IntW 16) :
  icmp IntPred.eq (LLVM.and (LLVM.xor e_1 (const? 16 123)) (zext 16 (lshr (const? 8 (-1)) e)))
      (LLVM.xor e_1 (const? 16 123)) ⊑
    icmp IntPred.ule (LLVM.xor e_1 (const? 16 123)) (zext 16 (lshr (const? 8 (-1)) e))

theorem alive_276_2  (w : Nat)   : alive_276_2_src w  ⊑ alive_276_2_tgt w

theorem test6_proof : test6_before ⊑ test6_after

theorem test20_proof : test20_before ⊑ test20_after

theorem logical_or_logical_or_icmps_comm1_thm.extracted_1._5 : ∀ (x x_1 x_2 : BitVec 8),
  ¬x_1 ≥ ↑8 →
    ¬(ofBool (x_2 &&& 1#8 <<< x_1 == 0#8) = 1#1 ∨ ofBool (x == 42#8) = 1#1) →
      ¬(True ∧ 1#8 <<< x_1 >>> x_1 ≠ 1#8 ∨ x_1 ≥ ↑8) →
        ofBool (x_2 &&& 1#8 <<< x_1 == 0#8) = 1#1 → True → ofBool (x_2 &&& 1#8 == 0#8) = 1#1

theorem positive_biggerlshr_thm (e : IntW 8) :
  shl (lshr e (const? 8 6)) (const? 8 3) ⊑ LLVM.and (lshr e (const? 8 3)) (const? 8 24)

theorem trunc_signed_both_thm.extracted_1._1 : ∀ (x x_1 : BitVec 16),
  ¬(True ∧ signExtend 16 (truncate 8 x_1) ≠ x_1 ∨
        True ∧ zeroExtend 16 (truncate 8 x_1) ≠ x_1 ∨
          True ∧ signExtend 16 (truncate 8 x) ≠ x ∨ True ∧ zeroExtend 16 (truncate 8 x) ≠ x) →
    ofBool (truncate 8 x_1 <ₛ truncate 8 x) = ofBool (x_1 <ₛ x)

theorem or_and3_thm.extracted_1._3 : ∀ (x x_1 : BitVec 32) (x_2 : BitVec 1),
  x_2 ||

theorem ashrslt_01_05_exact_thm (e : IntW 4) :
  icmp IntPred.slt (ashr e (const? 4 1) { «exact» := true }) (const? 4 5) ⊑ const? 1 1

theorem masked_bit_clear_commute_thm (e e_1 : IntW 32) :
  zext 32 (icmp IntPred.eq (LLVM.and (LLVM.srem (const? 32 42) e_1) (shl (const? 32 1) e)) (const? 32 0)) ⊑
    LLVM.and (lshr (LLVM.xor (LLVM.srem (const? 32 42) e_1) (const? 32 (-1))) e) (const? 32 1)

theorem main7b_logical_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (x_1 == x &&& x_1) = 1#1 → ofBool (x_1 != x &&& x_1) = 1#1 → 0#1 = 1#1 → 0#32 = zeroExtend 32 1#1

theorem sdiv_eq_smin_thm (e e_1 : IntW 8) :
  icmp IntPred.eq (LLVM.sdiv e_1 e) (const? 8 (-128)) ⊑
    LLVM.and (icmp IntPred.eq e_1 (const? 8 (-128))) (icmp IntPred.eq e (const? 8 1))

theorem lshrugt_01_09_exact_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬(True ∧ x >>> 1#4 <<< 1#4 ≠ x ∨ 1#4 ≥ ↑4) → ofBool (BitVec.ofInt 4 (-7) <ᵤ x >>> 1#4) = 0#1

theorem lt_unsigned_to_small_unsigned_proof : lt_unsigned_to_small_unsigned_before ⊑ lt_unsigned_to_small_unsigned_after

theorem shl_nuw_add_proof : shl_nuw_add_before ⊑ shl_nuw_add_after

theorem is_ascii_alphabetic_inverted_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬(True ∧ x.saddOverflow (BitVec.ofInt 32 (-91)) = true) →
    ¬ofBool (x + BitVec.ofInt 32 (-91) <ᵤ BitVec.ofInt 32 (-26)) = 1#1 →
      0#1 = ofBool ((x &&& BitVec.ofInt 32 (-33)) + BitVec.ofInt 32 (-91) <ᵤ BitVec.ofInt 32 (-26))

theorem add_mask_ashr28_non_pow2_i32_thm (e : IntW 32) :
  add (LLVM.and (ashr e (const? 32 28)) (const? 32 9)) (ashr e (const? 32 28)) ⊑
    add (LLVM.and (ashr e (const? 32 28)) (const? 32 9)) (ashr e (const? 32 28))
      { «nsw» := true, «nuw» := false }

theorem e_2428 :
     - 2 * (e ^^^ ( ~~~d ||| (e ^^^ f))) + 7 * (e ^^^ ( ~~~d ||| ( ~~~e ||| f))) + 1 * ((d ^^^ e) |||  ~~~(d ^^^ f)) + 1 * (f ^^^ (d &&& ( ~~~e ||| f))) - 6 * (e |||  ~~~(d |||  ~~~f)) + 2 * e + 7 * (f ^^^  ~~~(d |||  ~~~e)) - 1 * (e ^^^ f) - 3 *  ~~~(d &&&  ~~~e) - 2 * (f ^^^  ~~~(d ||| ( ~~~e &&& f))) + 4 * (f ^^^  ~~~(d ||| e)) + 2 * (f ^^^ (d ||| (e ||| f))) + 3 * (e ^^^ ( ~~~d ||| ( ~~~e &&& f))) + 2 * (d ||| ( ~~~e ||| f)) + 7 *  ~~~(e &&& f) + 11 *  ~~~( ~~~d &&& ( ~~~e &&& f)) - 3 * (e &&& (d ^^^ f)) - 1 *  ~~~( ~~~d &&& (e ||| f)) + 7 *  ~~~(d ^^^ (e ||| f)) - 1 * (e ^^^  ~~~(d ||| f)) + 5 *  ~~~(d &&&  ~~~d) + 7 * (d &&& ( ~~~e ||| f)) + 1 * ((d &&& f) ^^^ (e ||| f)) + 3 * ( ~~~(d ^^^ e) &&& (d ^^^ f)) - 2 *  ~~~( ~~~d &&& ( ~~~e ||| f)) + 5 * (e ^^^ (d |||  ~~~f)) - 5 * ( ~~~(d |||  ~~~e) |||  ~~~(d ^^^ (e ^^^ f))) + 1 *  ~~~(d ^^^ f) + 2 * (d ^^^ (e ^^^ f)) + 1 *  ~~~(d ^^^ e) + 5 * (e ^^^ (d &&& ( ~~~e ||| f))) + 1 *  ~~~(d &&& ( ~~~e &&& f)) - 1 * (e ||| (d &&& f)) - 1 * (e ^^^ (d ||| (e ^^^ f))) + 11 *  ~~~(e &&&  ~~~f) + 3 * (f ^^^ (d ||| ( ~~~e &&& f))) + 4 * (e ^^^ (d ||| (e ||| f))) - 1 * (f &&&  ~~~(d ^^^ e)) + 1 *  ~~~( ~~~d &&& (e ^^^ f)) - 5 * ((d &&& e) |||  ~~~(d ^^^ (e ^^^ f))) + 4 * (f ^^^  ~~~(d &&& (e &&& f))) + 3 * (e |||  ~~~(d ^^^ f)) + 1 * ( ~~~f &&& (d ^^^ e)) - 5 * (f ^^^ (d &&&  ~~~e)) + 1 * ((d &&& e) ^^^ (e |||  ~~~f)) - 7 *  ~~~(d &&& (e ^^^ f)) + 1 *  ~~~( ~~~d ||| (e &&& f)) + 7 * ((e &&&  ~~~f) |||  ~~~( ~~~d ||| ( ~~~e &&& f))) + 1 * ((d ||| e) &&&  ~~~(e ^^^ f)) - 2 * (e ^^^ (d ||| ( ~~~e ||| f))) - 5 * ( ~~~(d &&&  ~~~e) &&& (e ^^^ f)) - 1 * (f ^^^  ~~~( ~~~d ||| ( ~~~e &&& f))) + 2 * (e ^^^  ~~~(d ||| ( ~~~e &&& f))) + 11 * ((d &&& e) ^^^ (e ||| f)) - 2 * ((d &&& f) ^^^  ~~~(d ^^^ (e &&& f))) - 11 * (e ^^^  ~~~(d &&& ( ~~~e ||| f))) - 11 *  ~~~(d &&& f) + 5 * ((d |||  ~~~e) &&&  ~~~(e ^^^ f)) - 2 * (d ^^^ ( ~~~e ||| f)) - 7 * ((e &&&  ~~~f) |||  ~~~(d ||| ( ~~~e &&& f))) - 2 * (e ^^^ (d ||| (e &&& f))) + 1 *  ~~~(d ||| (e &&& f)) - 1 * (e ^^^ (d &&& f)) + 11 *  ~~~(d &&& (e ||| f)) - 7 * ( ~~~(d ||| e) ||| (e ^^^ f)) - 3 * (e ^^^  ~~~(d |||  ~~~f)) - 2 * (d &&&  ~~~e) - 1 * (f |||  ~~~(d ||| e)) - 25 *  ~~~(d ||| (e ||| f)) - 16 *  ~~~(d ||| ( ~~~e ||| f)) - 71 *  ~~~( ~~~d ||| (e ||| f)) - 4 * ( ~~~d &&& ( ~~~e &&& f)) - 19 * ( ~~~d &&& (e &&& f)) - 64 * (d &&& ( ~~~e &&& f)) - 36 * (d &&& (e &&& f)) = 13 *  ~~~( ~~~d ||| ( ~~~e ||| f)) + 1 * (f ||| (d ^^^ e))

theorem mul_add_to_mul_7_thm (e : IntW 16) :
  add e (mul e (const? 16 32767) { «nsw» := true, «nuw» := false }) { «nsw» := true, «nuw» := false } ⊑
    shl e (const? 16 15)

theorem zext_nneg_sext_sgt_proof : zext_nneg_sext_sgt_before ⊑ zext_nneg_sext_sgt_after

@[simp] lemma composeBinary_eval
    (p : FSM Bool)
    {t₁ t₂ : Term}
    (q₁ : FSMTermSolution t₁)
    (q₂ : FSMTermSolution t₂)
    (x : Fin (max t₁.arity t₂.arity) → BitStream) :
    (composeBinary p q₁ q₂).eval x = p.eval
      (λ b => cond b (t₁.evalFin (fun i => x (Fin.castLE (by simp) i)))
                  (t₂.evalFin (fun i => x (Fin.castLE (by simp) i))))

theorem e_1439 :
    2 *  ~~~t + 1 *  ~~~(z &&& t) + 1 * (z |||  ~~~t) + 7 *  ~~~(z ^^^ t) - 1 *  ~~~(z &&&  ~~~z) + 3 * (z ^^^ t) - 2 * z - 3 *  ~~~(z |||  ~~~t) - 4 * (z &&&  ~~~t) - 5 * (z &&& t) = 10 *  ~~~(z ||| t)

theorem mul_add_to_mul_1_proof : mul_add_to_mul_1_before ⊑ mul_add_to_mul_1_after

theorem e_1511 :
     - 2 * ((a &&&  ~~~b) ||| (a ^^^ (b ^^^ c))) + 4 * (a &&&  ~~~b) + 5 *  ~~~(a ||| (b ^^^ c)) - 5 *  ~~~(a ||| (b ||| c)) + 2 *  ~~~(a ||| ( ~~~b ||| c)) - 2 *  ~~~( ~~~a ||| (b ||| c)) + 2 * ( ~~~a &&& ( ~~~b &&& c)) - 5 * ( ~~~a &&& (b &&& c)) + 2 * (a &&& (b &&& c)) = 2 * (a &&& ( ~~~b &&& c))

theorem canonicalize_logic_first_xor_0_nsw_proof : canonicalize_logic_first_xor_0_nsw_before ⊑ canonicalize_logic_first_xor_0_nsw_after

theorem ule_or_min_commute_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ofBool (x_1 == 0#8) ||

theorem or_xor_tree_1010_proof : or_xor_tree_1010_before ⊑ or_xor_tree_1010_after

theorem main11_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x &&& 64#32 == 0#32) ||

theorem t4_commutative_thm (e e_1 : IntW 8) :
  icmp IntPred.ugt e_1 (add e e_1) ⊑ icmp IntPred.ugt e (LLVM.xor e_1 (const? 8 (-1)))

theorem test14_proof : test14_before ⊑ test14_after

theorem t10_shl_nuw_flag_preservation_proof : t10_shl_nuw_flag_preservation_before ⊑ t10_shl_nuw_flag_preservation_after

theorem test_mul_nuw__none_are_safe_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x == 805306368#32) = 1#1 → BitVec.ofInt 32 (-1342177280) = x * 9#32

theorem e_1338 :
    5 * t + 11 *  ~~~(z &&&  ~~~t) - 2 *  ~~~t + 1 *  ~~~z - 11 *  ~~~(z ^^^ t) + 2 * (z ||| t) + 1 *  ~~~(z &&&  ~~~z) - 5 *  ~~~(z ||| t) - 25 *  ~~~(z |||  ~~~t) - 6 * (z &&&  ~~~t) =  - 5 *  ~~~(z &&& t) + 8 * (z &&& t)

theorem main7c_logical_thm.extracted_1._7 : ∀ (x x_1 x_2 : BitVec 32),
  ofBool (x_2 == x_2 &&& x_1) = 1#1 →
    ¬ofBool (x_2 != x_2 &&& x_1) = 1#1 →
      ofBool (x == x &&& x_1) = 1#1 → 0#32 = zeroExtend 32 (ofBool (x != x &&& x_1))

theorem trunc_shl_lshr_infloop_thm.extracted_1._1 : ∀ (x : BitVec 64),
  ¬(1#64 ≥ ↑64 ∨ 2#64 ≥ ↑64) → 1#32 ≥ ↑32 → False

theorem both_thm.extracted_1._2 : ∀ (x x_1 : BitVec 8),
  ¬(x_1 ≥ ↑8 ∨ x ≥ ↑8) →
    ¬(True ∧ ((-1#8) <<< x_1).sshiftRight' x_1 ≠ -1#8 ∨
          x_1 ≥ ↑8 ∨ True ∧ ((-1#8) <<< x).sshiftRight' x ≠ -1#8 ∨ x ≥ ↑8) →
      ofBool ((-1#8) <<< x_1 ^^^ -1#8 <ᵤ (-1#8) <<< x ^^^ -1#8) = ofBool ((-1#8) <<< x <ᵤ (-1#8) <<< x_1)

theorem test_proof : test_before ⊑ test_after

theorem positive_samevar_thm (e e_1 : IntW 8) :
  shl (lshr e_1 e) e ⊑ LLVM.and (shl (const? 8 (-1)) e { «nsw» := true, «nuw» := false }) e_1

theorem test22_thm (e : IntW 32) :
  LLVM.srem (LLVM.and e (const? 32 2147483647)) (const? 32 2147483647) ⊑
    urem (LLVM.and e (const? 32 2147483647)) (const? 32 2147483647)

theorem e_727 :
    5 * x - 6 *  ~~~(x &&&  ~~~y) - 3 * (x |||  ~~~y) + 1 *  ~~~x - 2 * (x ^^^ y) + 5 *  ~~~(x &&& y) - 11 *  ~~~y + 1 *  ~~~(x &&&  ~~~x) + 13 *  ~~~(x ||| y) + 5 * (x &&&  ~~~y) + 2 * (x &&& y) =  - 1 * y

theorem test_proof : test_before ⊑ test_after

theorem ashrslt_03_03_exact_thm (e : IntW 4) :
  icmp IntPred.slt (ashr e (const? 4 3) { «exact» := true }) (const? 4 3) ⊑ const? 1 1

theorem test6_proof : test6_before ⊑ test6_after

theorem not_zext_proof : not_zext_before ⊑ not_zext_after

theorem e_212 :
     - 2 *  ~~~(x &&&  ~~~x) - 1 *  ~~~(x &&& y) - 2 *  ~~~y - 2 * y + 5 *  ~~~(x |||  ~~~y) + 5 * (x &&&  ~~~y) =  - 5 *  ~~~(x ||| y) - 4 * (x &&& y)

theorem alive_AddSub_1560  (w : Nat)   : alive_AddSub_1560_src w  ⊑ alive_AddSub_1560_tgt w

theorem e_991 :
    7 *  ~~~(z ^^^ t) + 3 * (z |||  ~~~t) - 1 * (z ^^^ t) - 2 * z - 10 *  ~~~(z ||| t) - 4 *  ~~~(z |||  ~~~t) - 13 * (z &&& t) =  - 5 * t

theorem logic_and_logic_or_3_proof : logic_and_logic_or_3_before ⊑ logic_and_logic_or_3_after

theorem ashr_ult_10_proof : ashr_ult_10_before ⊑ ashr_ult_10_after

theorem not_and_and_or_no_or_commute1_thm (e e_1 e_2 : IntW 32) :
  LLVM.or (LLVM.and (LLVM.and (LLVM.xor e_2 (const? 32 (-1))) e_1) e) (LLVM.xor (LLVM.or e_2 e_1) (const? 32 (-1))) ⊑
    LLVM.and (LLVM.or e (LLVM.xor e_1 (const? 32 (-1)))) (LLVM.xor e_2 (const? 32 (-1)))

theorem test7_proof : test7_before ⊑ test7_after

theorem masked_icmps_mask_notallzeros_bmask_mixed_negated_7_logical_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬ofBool (x &&& 7#32 == 0#32) = 1#1 → ofBool (x &&& 15#32 != 8#32) = 1#1

theorem ashrslt_01_02_exact_thm (e : IntW 4) :
  icmp IntPred.slt (ashr e (const? 4 1) { «exact» := true }) (const? 4 2) ⊑
    icmp IntPred.slt e (const? 4 3)

theorem samesign_inverted_commute3_proof : samesign_inverted_commute3_before ⊑ samesign_inverted_commute3_after

theorem neg_or_lshr_i32_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬31#32 ≥ ↑32 → (0#32 - x ||| x) >>> 31#32 = zeroExtend 32 (ofBool (x != 0#32))

theorem must_drop_poison_proof : must_drop_poison_before ⊑ must_drop_poison_after

theorem p0_ult_65536_proof : p0_ult_65536_before ⊑ p0_ult_65536_after

theorem masked_icmps_mask_notallzeros_bmask_mixed_3_proof : masked_icmps_mask_notallzeros_bmask_mixed_3_before ⊑ masked_icmps_mask_notallzeros_bmask_mixed_3_after

theorem or_to_nxor_multiuse_proof : or_to_nxor_multiuse_before ⊑ or_to_nxor_multiuse_after

theorem uge_umin2_thm (e e_1 : IntW 32) :
  icmp IntPred.uge (select (icmp IntPred.ult e_1 e) e_1 e) e ⊑ icmp IntPred.uge e_1 e

theorem e_2376 :
    1 * (d ||| ( ~~~e &&& f)) - 2 * ((d &&&  ~~~e) |||  ~~~(e ^^^ f)) - 2 * (e ^^^ (d ||| (e ^^^ f))) - 2 * ( ~~~(d |||  ~~~e) ||| (d ^^^ (e ^^^ f))) - 1 * (f ^^^  ~~~(d &&& (e &&& f))) - 2 * ( ~~~d ||| (e &&& f)) + 2 * (f ||| (d &&& e)) + 11 * ( ~~~(d &&& e) &&&  ~~~(e ^^^ f)) - 2 * ((e &&& f) ^^^  ~~~(d &&& (e ^^^ f))) - 5 * (f ^^^  ~~~( ~~~d &&& (e &&& f))) - 2 * ( ~~~(d &&& e) &&&  ~~~(d ^^^ (e ^^^ f))) + 2 * ( ~~~e |||  ~~~(d ^^^ f)) - 1 * (d &&& (e ||| f)) + 7 * ((d |||  ~~~e) &&& (e ^^^ f)) + 1 * (d ^^^ e) + 2 * ( ~~~f &&&  ~~~(d ^^^ e)) - 6 * (f ^^^ (d ||| (e &&& f))) - 1 * (e ^^^  ~~~(d &&& (e ^^^ f))) - 5 * ( ~~~(d &&&  ~~~e) &&& (d ^^^ (e ^^^ f))) - 11 *  ~~~(d &&&  ~~~f) + 2 * ((d &&&  ~~~e) ||| (d ^^^ (e ^^^ f))) - 7 * (e ^^^  ~~~(d &&& ( ~~~e &&& f))) + 1 * (f ^^^ ( ~~~d ||| (e &&& f))) - 7 * ( ~~~(d |||  ~~~e) |||  ~~~(e ^^^ f)) - 1 * (e &&&  ~~~f) + 2 * ((d &&& e) |||  ~~~(e ||| f)) - 2 * (f ^^^  ~~~(d &&& ( ~~~e &&& f))) + 3 * (e &&& (d |||  ~~~f)) - 11 * (f ^^^ ( ~~~d &&& ( ~~~e ||| f))) + 4 * ((d |||  ~~~e) &&& (d ^^^ (e ^^^ f))) + 1 * (d ||| (e &&& f)) - 3 * (f ^^^  ~~~(d ||| (e &&& f))) - 1 * ((d &&& e) ^^^ (e ||| f)) - 1 * ((d ||| e) &&&  ~~~(d ^^^ (e ^^^ f))) + 3 * (e ||| f) - 7 * ( ~~~d &&& ( ~~~e ||| f)) + 1 * ((e &&& f) ||| (d &&& (e ||| f))) - 6 *  ~~~(d &&& ( ~~~e ||| f)) - 11 * ( ~~~d ||| (e ^^^ f)) + 11 * (e &&&  ~~~(d ^^^ f)) + 5 * ((d &&& e) |||  ~~~(e |||  ~~~f)) + 1 * (e ^^^ ( ~~~d ||| ( ~~~e &&& f))) + 1 * (d ||| (e ^^^ f)) + 2 * (e ^^^  ~~~(d &&&  ~~~f)) + 1 *  ~~~(d |||  ~~~f) - 6 * (f ^^^ (d |||  ~~~e)) - 1 *  ~~~(d &&& ( ~~~e &&& f)) + 1 * (f &&&  ~~~(d &&&  ~~~e)) + 4 * (d ^^^ (e ||| f)) - 6 * (d ^^^ f) + 2 *  ~~~(d ||| (e ^^^ f)) + 2 * (e ^^^ (d &&& f)) - 1 * (f |||  ~~~(d ^^^ e)) - 5 * ((d &&& f) ^^^  ~~~(d ^^^ (e &&& f))) - 5 * (f ^^^ (d &&& ( ~~~e ||| f))) - 6 * ((d &&& e) ^^^  ~~~(d ^^^ ( ~~~e ||| f))) - 1 * (e ^^^  ~~~(d &&& f)) + 5 *  ~~~(d &&&  ~~~d) + 1 *  ~~~f + 1 * ((d &&& e) ^^^  ~~~(d ^^^ (e &&& f))) + 7 * (f ^^^ ( ~~~d ||| ( ~~~e ||| f))) + 7 * (e ^^^ (d ||| (e ||| f))) - 2 * (d |||  ~~~f) + 60 *  ~~~(d ||| (e ||| f)) + 29 *  ~~~(d ||| ( ~~~e ||| f)) + 15 *  ~~~( ~~~d ||| (e ||| f)) + 17 *  ~~~( ~~~d ||| ( ~~~e ||| f)) + 33 * ( ~~~d &&& ( ~~~e &&& f)) + 17 * (d &&& ( ~~~e &&& f)) + 6 * (d &&& (e &&& f)) =  - 47 * ( ~~~d &&& (e &&& f)) + 1 * ( ~~~(d ^^^ e) &&&  ~~~(d ^^^ f))

theorem PR42691_3_proof : PR42691_3_before ⊑ PR42691_3_after

theorem e_1503 :
    3 * (c ||| (a &&&  ~~~b)) - 1 * ( ~~~(a &&&  ~~~b) &&& (b ^^^ c)) - 6 *  ~~~(a ||| ( ~~~b ||| c)) - 3 *  ~~~( ~~~a ||| (b ||| c)) - 6 *  ~~~( ~~~a ||| ( ~~~b ||| c)) - 9 * ( ~~~a &&& ( ~~~b &&& c)) - 10 * ( ~~~a &&& (b &&& c)) - 3 * (a &&& (b &&& c)) =  - 7 * ((a &&& c) ^^^ (b ||| c)) + 3 * (a &&& ( ~~~b &&& c))

theorem not_and_and_not_commute1_thm (e e_1 e_2 : IntW 32) :
  LLVM.and (LLVM.and (LLVM.xor e_2 (const? 32 (-1))) e_1) (LLVM.xor e (const? 32 (-1))) ⊑
    LLVM.and e_1 (LLVM.xor (LLVM.or e_2 e) (const? 32 (-1)))

theorem carry_eq_carryWith_initCarry (p : FSM arity) (x : arity → BitStream) (n : Nat) :
    p.carry x n = p.carryWith p.initCarry x n

theorem ne_21_comm_ne2_thm.extracted_1._2 : ∀ (x x_1 : BitVec 32),
  ¬(16#32 ≥ ↑32 ∨ 16#32 ≥ ↑32 ∨ 8#32 ≥ ↑32 ∨ 8#32 ≥ ↑32) →
    ¬(8#32 ≥ ↑32 ∨ 8#32 ≥ ↑32) →
      ofBool (truncate 8 (x_1 >>> 16#32) != truncate 8 (x >>> 16#32)) ||

theorem t4_ugt_slt_128_thm (e e_1 e_2 : IntW 32) :
  select (icmp IntPred.ugt (add e_2 (const? 32 16)) (const? 32 143))
      (select (icmp IntPred.slt e_2 (const? 32 128)) e_1 e) e_2 ⊑
    select (icmp IntPred.sgt e_2 (const? 32 127)) e
      (select (icmp IntPred.slt e_2 (const? 32 (-16))) e_1 e_2)

theorem narrow_sext_sub_thm.extracted_1._1 : ∀ (x : BitVec 32) (x_1 : BitVec 16),
  truncate 16 (signExtend 32 x_1 - x) = x_1 - truncate 16 x

theorem ashrsgt_03_00_exact_thm (e : IntW 4) :
  icmp IntPred.sgt (ashr e (const? 4 3) { «exact» := true }) (const? 4 0) ⊑ const? 1 0

@[simp]
lemma CNFA.autUnsignedCmp_states cmp : s ∈ (autUnsignedCmp cmp).m.states ↔  s < 3

theorem ult_swap_and_max_commute_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ofBool (x_1 == -1#8) &&& ofBool (x_1 <ᵤ x) = 0#1

theorem trunc_ashr_thm.extracted_1._1 : ∀ (x : BitVec 32), ¬8#36 ≥ ↑36 → 8#32 ≥ ↑32 → False

theorem select_ashr_icmp_bad_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ofBool (x_1 == 1#32) = 1#1 → ¬x_1 ≥ ↑32 → 1#32 ≥ ↑32 → False

theorem alive_AndOrXor_2243__B__C__A__B___B__A__C : alive_AndOrXor_2243__B__C__A__B___B__A__C_src ⊑ alive_AndOrXor_2243__B__C__A__B___B__A__C_tgt

theorem ashrsgt_03_12_thm (e : IntW 4) : icmp IntPred.sgt (ashr e (const? 4 3)) (const? 4 (-4)) ⊑ const? 1 1

theorem test6_thm.extracted_1._1 : ∀ (x : BitVec 8), x ^^^ 17#8 ^^^ 17#8 = x

theorem main8_proof : main8_before ⊑ main8_after

theorem canonicalize_logic_first_xor_0_nswnuw_proof : canonicalize_logic_first_xor_0_nswnuw_before ⊑ canonicalize_logic_first_xor_0_nswnuw_after

theorem or_logic_or_logic_and_5_thm.extracted_1._2 : ∀ (x x_1 : BitVec 1),
  ¬x_1 ||

theorem ashrsgt_02_05_exact_proof : ashrsgt_02_05_exact_before ⊑ ashrsgt_02_05_exact_after

theorem ashrsgt_03_03_exact_proof : ashrsgt_03_03_exact_before ⊑ ashrsgt_03_03_exact_after

theorem icmp_sle_x_negy_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ofBool ((x_1 ||| BitVec.ofInt 8 (-128)) &&& x ≤ₛ x) = 1#1

theorem same_source_matching_signbits_proof : same_source_matching_signbits_before ⊑ same_source_matching_signbits_after

theorem ashrsgt_02_10_exact_proof : ashrsgt_02_10_exact_before ⊑ ashrsgt_02_10_exact_after

theorem a_true_implies_b_false2_thm.extracted_1._1 : ∀ (x : BitVec 1) (x_1 : BitVec 8),
  ofBool (x_1 == 10#8) = 1#1 → ofBool (20#8 <ᵤ x_1) = 1#1 → False

theorem lshrult_03_12_proof : lshrult_03_12_before ⊑ lshrult_03_12_after

theorem test22_thm (e : IntW 14) :
  icmp IntPred.eq (shl e (const? 14 7)) (const? 14 0) ⊑
    icmp IntPred.eq (LLVM.and e (const? 14 127)) (const? 14 0)

theorem not_ashr_bitwidth_mask_proof : not_ashr_bitwidth_mask_before ⊑ not_ashr_bitwidth_mask_after

theorem select_bittest_to_sub_thm.extracted_1._4 : ∀ (x : BitVec 32),
  ¬ofBool (x &&& 1#32 == 0#32) = 1#1 →
    ¬(True ∧ (4#32).ssubOverflow (x &&& 1#32) = true ∨ True ∧ (4#32).usubOverflow (x &&& 1#32) = true) →
      3#32 = 4#32 - (x &&& 1#32)

theorem zext_lshr_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬4#16 ≥ ↑16 → 4#8 ≥ ↑8 ∨ True ∧ (x >>> 4#8 &&& x).msb = true → False

theorem sext_zext_uge_known_nonneg_op0_wide_thm (e : IntW 8) (e_1 : IntW 16) :
  icmp IntPred.uge (sext 32 e_1) (zext 32 (LLVM.and e (const? 8 12))) ⊑
    icmp IntPred.uge e_1 (zext 16 (LLVM.and e (const? 8 12)) { «nneg» := true })

theorem e_2209 :
     - 3 * ((d &&& e) ^^^ (e |||  ~~~f)) + 2 * (e &&&  ~~~f) - 1 * (e ^^^  ~~~( ~~~d ||| ( ~~~e &&& f))) - 3 *  ~~~(d &&& e) - 1 *  ~~~(d |||  ~~~e) + 7 * (e &&& (d ^^^ f)) - 5 * (e |||  ~~~f) - 1 * ( ~~~(d ^^^ e) |||  ~~~(d ^^^ f)) - 6 * ((d &&& f) ^^^ (d ^^^ (e &&& f))) + 7 * (e ^^^ (d &&& f)) + 7 * (f ^^^  ~~~( ~~~d &&& (e ||| f))) - 11 * (d ^^^ ( ~~~e ||| f)) - 3 * ((d &&&  ~~~e) ||| (d ^^^ (e ^^^ f))) - 6 *  ~~~(d ^^^ e) - 1 * (e ^^^ (d ||| ( ~~~e &&& f))) - 7 * (f ||| (d &&& e)) - 1 * ((d ||| e) &&& (d ^^^ (e ^^^ f))) + 7 * ((d &&& f) ^^^  ~~~(e &&&  ~~~f)) + 3 * ( ~~~(d ^^^ e) ||| (d ^^^ f)) + 5 *  ~~~( ~~~d &&& (e ^^^ f)) - 2 *  ~~~(d ^^^ f) + 1 *  ~~~e - 2 * ((d ^^^ e) ||| (d ^^^ f)) - 5 *  ~~~(d &&& ( ~~~e ||| f)) + 3 * ( ~~~(d &&& e) &&& (d ^^^ (e ^^^ f))) - 7 * ( ~~~d &&& (e ^^^ f)) + 4 * (f ^^^  ~~~( ~~~d ||| ( ~~~e &&& f))) + 5 * ((d &&&  ~~~e) ||| (e ^^^ f)) - 7 * (e ^^^  ~~~( ~~~d &&& (e &&& f))) + 1 * (e ^^^  ~~~( ~~~d &&& (e ^^^ f))) + 4 * (f |||  ~~~(d ^^^ e)) - 2 * ((e &&& f) ||| ( ~~~d &&& (e ||| f))) - 1 * ( ~~~f &&&  ~~~(d ^^^ e)) - 1 * ((d &&& f) |||  ~~~(e ||| f)) - 2 * (e ^^^  ~~~( ~~~d &&& (e ||| f))) - 3 * (f ^^^  ~~~(d ||| ( ~~~e &&& f))) - 2 * (e ^^^ (d ||| (e ^^^ f))) - 11 * ((d ||| e) &&&  ~~~(e ^^^ f)) + 2 * (d &&& (e ^^^ f)) - 11 * (e ^^^  ~~~( ~~~d ||| (e &&& f))) + 1 * ( ~~~(d ||| e) |||  ~~~(d ^^^ (e ^^^ f))) + 1 * (d ||| ( ~~~e ||| f)) - 1 * (f ^^^ ( ~~~d ||| ( ~~~e &&& f))) + 5 * (f ^^^  ~~~(d ||| (e &&& f))) - 2 * ((d |||  ~~~e) &&&  ~~~(e ^^^ f)) + 18 *  ~~~(d ||| (e ||| f)) + 32 *  ~~~(d ||| ( ~~~e ||| f)) + 24 *  ~~~( ~~~d ||| (e ||| f)) - 3 *  ~~~( ~~~d ||| ( ~~~e ||| f)) + 25 * ( ~~~d &&& ( ~~~e &&& f)) + 29 * ( ~~~d &&& (e &&& f)) + 9 * (d &&& ( ~~~e &&& f)) + 45 * (d &&& (e &&& f)) = 1 * (e ^^^  ~~~(d |||  ~~~f))

theorem test_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬zeroExtend 32 x ≥ ↑32 → True ∧ x.msb = true ∨ zeroExtend 32 x ≥ ↑32 → False

@[simp]
theorem Expr.regArgs_mk {Γ : Ctxt d.Ty} {ty eff op}
    (ty_eq : ty = DialectSignature.returnTypes op)
    (eff_le : DialectSignature.effectKind op ≤ eff)
    (args : HVector (Var Γ) (DialectSignature.sig op)) (regArgs) :
    (Expr.mk op ty_eq eff_le args regArgs).regArgs = regArgs

theorem scalar_i32_shl_and_negC_ne_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬x ≥ ↑32 → ofBool (x_1 <<< x &&& BitVec.ofInt 32 (-262144) != 0#32) = ofBool (262143#32 <ᵤ x_1 <<< x)

theorem icmp_ne_sext_ne_otherwise_i128_thm.extracted_1._1 : ∀ (x : BitVec 128),
  ofBool (signExtend 128 (ofBool (x != 2#128)) != x) = ofBool (x != -1#128)

theorem test16_thm (e : IntW 32) :
  sub (const? 64 4294967294) (zext 64 (lshr e (const? 32 1))) ⊑
    zext 64 (sub (const? 32 (-2)) (lshr e (const? 32 1)) { «nsw» := false, «nuw» := true })

theorem pr64558_proof : pr64558_before ⊑ pr64558_after

theorem bor_land_left1_proof : bor_land_left1_before ⊑ bor_land_left1_after

theorem sub_const_add_const_proof : sub_const_add_const_before ⊑ sub_const_add_const_after

theorem slt_swap_or_not_max_commute_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ofBool (x_1 != 127#8) ||

theorem t9_highest_bit_proof : t9_highest_bit_before ⊑ t9_highest_bit_after

theorem test_and_xor_freely_invertable_proof : test_and_xor_freely_invertable_before ⊑ test_and_xor_freely_invertable_after

theorem trunc_sel_equal_sext_thm.extracted_1._4 : ∀ (x : BitVec 32) (x_1 : BitVec 1),
  ¬x_1 = 1#1 → signExtend 32 42#16 = 42#32

theorem test1_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  truncate 1 (zeroExtend 32 (ofBool (x_1 <ₛ x)) &&& zeroExtend 32 (ofBool (x <ₛ x_1))) = 0#1

theorem mul_add_to_mul_6_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬(True ∧ x_1.smulOverflow x = true ∨
        True ∧ x_1.smulOverflow x = true ∨
          True ∧ (x_1 * x).smulOverflow 5#32 = true ∨ True ∧ (x_1 * x).saddOverflow (x_1 * x * 5#32) = true) →
    True ∧ x_1.smulOverflow x = true ∨ True ∧ (x_1 * x).smulOverflow 6#32 = true → False

theorem e_1345 :
     - 1 * z - 5 * (z ^^^ t) + 11 *  ~~~(z ^^^ t) + 1 *  ~~~(z &&& t) + 7 *  ~~~(z &&&  ~~~t) - 6 *  ~~~z - 11 *  ~~~(z ||| t) + 3 *  ~~~(z |||  ~~~t) + 7 * (z &&&  ~~~t) - 15 * (z &&& t) = 2 * (z |||  ~~~t)

theorem foo1_and_signbit_lshr_without_shifting_signbit_logical_thm (e e_1 e_2 : IntW 32) :
  select (icmp IntPred.eq (LLVM.and (shl (const? 32 1) e_2) e_1) (const? 32 0)) (const? 1 1)
      (icmp IntPred.sgt (shl e_1 e) (const? 32 (-1))) ⊑
    select (icmp IntPred.eq (LLVM.and (shl (const? 32 1) e_2 { «nsw» := false, «nuw» := true }) e_1) (const? 32 0))
      (const? 1 1) (icmp IntPred.sgt (shl e_1 e) (const? 32 (-1)))

theorem e_963 :
     - 2 *  ~~~(z &&&  ~~~t) + 1 *  ~~~(z ^^^ t) - 11 * t - 1 *  ~~~(z ||| t) + 13 *  ~~~(z |||  ~~~t) - 2 * (z &&&  ~~~t) =  - 12 * (z &&& t) - 2 *  ~~~t

theorem slt_0_thm (e : IntW 32) :
  icmp IntPred.slt (trunc 8 e) (const? 8 0) ⊑
    icmp IntPred.ne (LLVM.and e (const? 32 128)) (const? 32 0)

theorem positive_sameconst_thm (e : IntW 32) : lshr (shl e (const? 32 5)) (const? 32 5) ⊑ LLVM.and e (const? 32 134217727)

theorem slt_and_shl_one_proof : slt_and_shl_one_before ⊑ slt_and_shl_one_after

theorem zext_sext_add_icmp_ne_minus1_thm.extracted_1._1 : ∀ (x x_1 : BitVec 1),
  ofBool (zeroExtend 8 x_1 + signExtend 8 x != -1#8) = x_1 ||

theorem mul_selectp2_x_non_const_proof : mul_selectp2_x_non_const_before ⊑ mul_selectp2_x_non_const_after

@[simp, grind=] theorem getElem_ofList (i : Nat) (h : _) : (ofList ts)[i]'h = ts[i]'h

theorem PR38021_thm (e : IntW 8) :
  add (lshr e (const? 8 3)) (const? 8 (-63)) ⊑
    add (lshr e (const? 8 3)) (const? 8 (-63)) { «nsw» := true, «nuw» := true }

theorem select_icmp_ne_0_and_4096_or_4096_thm.extracted_1._2 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (0#32 != x_1 &&& 4096#32) = 1#1 → x ||

theorem AndZextAnd_thm (e : IntW 3) :
  LLVM.and (zext 5 (LLVM.and e (const? 3 3))) (const? 5 14) ⊑
    zext 5 (LLVM.and e (const? 3 2)) { «nneg» := true }

theorem main3e_like_logical_thm (e e_1 e_2 : IntW 32) :
  select
      (select (icmp IntPred.eq (LLVM.and e_2 e_1) (const? 32 0))
        (icmp IntPred.eq (LLVM.and e_2 e) (const? 32 0)) (const? 1 0))
      (const? 32 0) (const? 32 1) ⊑
    zext 32
      (select (icmp IntPred.ne (LLVM.and e_2 e_1) (const? 32 0)) (const? 1 1)
        (icmp IntPred.ne (LLVM.and e_2 e) (const? 32 0)))

theorem lshr_xor_or_good_mask_thm (e e_1 : IntW 8) :
  LLVM.or (lshr e_1 (const? 8 4)) (LLVM.xor (lshr e (const? 8 4)) (const? 8 48)) ⊑
    LLVM.or (lshr (LLVM.or e e_1) (const? 8 4)) (const? 8 48) { «disjoint» := true }

theorem slt_x_impliesT_ne_smin_todo_thm.extracted_1._3 : ∀ (x x_1 x_2 : BitVec 8),
  ¬ofBool (x_2 <ₛ x_1) = 1#1 → ofBool (x_2 != x) = ofBool (x != x_2)

theorem t1_thm.extracted_1._2 : ∀ (x x_1 : BitVec 8),
  ¬(True ∧ (x_1 ^^^ -1#8) >>> x <<< x ≠ x_1 ^^^ -1#8 ∨ x ≥ ↑8) →
    ¬x ≥ ↑8 → (x_1 ^^^ -1#8).sshiftRight' x = x_1.sshiftRight' x ^^^ -1#8

theorem sext_zext_apint2_proof : sext_zext_apint2_before ⊑ sext_zext_apint2_after

theorem t4_const_after_fold_lshr_shl_ne_proof : t4_const_after_fold_lshr_shl_ne_before ⊑ t4_const_after_fold_lshr_shl_ne_after

theorem bools2_logical_commute0_thm.extracted_1._5 : ∀ (x x_1 : BitVec 1),
  x_1 = 1#1 → ¬x_1 ^^^ 1#1 = 1#1 → x = 1#1 → 1#1 = x

theorem neg_sgt_1_proof : neg_sgt_1_before ⊑ neg_sgt_1_after

theorem or_to_nxor_multiuse_proof : or_to_nxor_multiuse_before ⊑ or_to_nxor_multiuse_after

theorem xor_logic_and_logic_or4_thm.extracted_1._3 : ∀ (x x_1 x_2 : BitVec 1),
  x_2 = 1#1 → x_1 = 1#1 → x_1 ^^^ 1#1 = x_2 ^^^ 1#1

theorem test28_thm.extracted_1._1 : ∀ (x : BitVec 32),
  x + BitVec.ofInt 32 (-2147483647) ^^^ BitVec.ofInt 32 (-2147483648) = x + 1#32

theorem shl_and_xor_thm.extracted_1._2 : ∀ (x x_1 : BitVec 8),
  ¬(1#8 ≥ ↑8 ∨ 1#8 ≥ ↑8) → ¬1#8 ≥ ↑8 → x_1 <<< 1#8 ^^^ x <<< 1#8 &&& 20#8 = (x_1 ^^^ x &&& 10#8) <<< 1#8

theorem main2_logical_thm.extracted_1._3 : ∀ (x : BitVec 32),
  ¬ofBool (x &&& 1#32 == 0#32) = 1#1 →
    ofBool (x &&& 2#32 == 0#32) = 1#1 → 0#32 = zeroExtend 32 (ofBool (x &&& 3#32 == 3#32))

theorem uaddo_wrong_pred2_proof : uaddo_wrong_pred2_before ⊑ uaddo_wrong_pred2_after

theorem and_add_bool_to_select_multi_use_thm.extracted_1._2 : ∀ (x : BitVec 32) (x_1 : BitVec 1),
  ¬x_1 = 1#1 → (-1#32 + zeroExtend 32 x_1 &&& x) + (-1#32 + zeroExtend 32 x_1) = x + -1#32

theorem add_and_or_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32), (x_1 &&& x) + (x_1 ||| x) = x_1 + x

@[simp]
theorem Eqn.denote_width_zero  (es : Eqn) (env : Env 0) :
    Eqn.denote es env = 0

theorem test51_thm.extracted_1._3 : ∀ (x : BitVec 64) (x_1 : BitVec 1),
  ¬x_1 = 1#1 → True ∧ (truncate 32 x &&& BitVec.ofInt 32 (-2) &&& zeroExtend 32 (x_1 ^^^ 1#1) != 0) = true → False

theorem udiv_mul_shl_nuw_exact_commute1_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 5),
  ¬(True ∧ x_2.umulOverflow x_1 = true ∨
        True ∧ x_1 <<< x >>> x ≠ x_1 ∨ x ≥ ↑5 ∨ True ∧ (x_2 * x_1).umod (x_1 <<< x) ≠ 0 ∨ x_1 <<< x = 0) →
    True ∧ x_2 >>> x <<< x ≠ x_2 ∨ x ≥ ↑5 → False

theorem fold_icmp_shl_nuw_c2_indivisible_thm (e : IntW 32) :
  icmp IntPred.ult (shl (const? 32 16) e { «nsw» := false, «nuw» := true }) (const? 32 63) ⊑
    icmp IntPred.ult e (const? 32 2)

theorem add_shl_same_amount_constants_thm (e : IntW 8) : add (shl (const? 8 4) e) (shl (const? 8 3) e) ⊑ shl (const? 8 7) e

theorem squared_nsw_eq0_proof : squared_nsw_eq0_before ⊑ squared_nsw_eq0_after

theorem test3_proof : test3_before ⊑ test3_after

theorem add_assoc_3 (hq : q >= t) (hp : p < u) (hr : r < u) :
  (bw t (addMax (bw u (addMax (bw p a) (bw r b))) (bw s c)))  =
  (bw t (addMax (bw p a) (bw q (addMax (bw r b) (bw s c)))))

theorem or_not_and_commute6_thm (e e_1 e_2 : IntW 32) :
  LLVM.or (LLVM.and (LLVM.xor (LLVM.or e_2 e_1) (const? 32 (-1))) e)
      (LLVM.and (LLVM.xor (LLVM.or e e_2) (const? 32 (-1))) e_1) ⊑
    LLVM.and (LLVM.xor e_1 e) (LLVM.xor e_2 (const? 32 (-1)))

theorem ashrslt_01_10_exact_thm (e : IntW 4) :
  icmp IntPred.slt (ashr e (const? 4 1) { «exact» := true }) (const? 4 (-6)) ⊑ const? 1 0

theorem e_283 :
    3 *  ~~~y + 5 * (x |||  ~~~y) + 2 * (x ||| y) - 9 *  ~~~(x ||| y) - 3 *  ~~~(x |||  ~~~y) - 11 * (x &&&  ~~~y) - 8 * (x &&& y) =  - 1 *  ~~~(x &&&  ~~~x)

theorem trunc_shl_ashr_var_proof : trunc_shl_ashr_var_before ⊑ trunc_shl_ashr_var_after

theorem e_379 :
    7 * (x ||| y) - 2 * x + 7 *  ~~~(x &&&  ~~~y) - 11 * (x ^^^ y) - 7 *  ~~~(x ||| y) - 1 *  ~~~(x |||  ~~~y) + 6 * (x &&&  ~~~y) - 10 * (x &&& y) = 2 * y

theorem mul_of_bool_no_lz_other_op_proof : mul_of_bool_no_lz_other_op_before ⊑ mul_of_bool_no_lz_other_op_after

theorem or_not_and_and_not_and_xor_commute1_proof : or_not_and_and_not_and_xor_commute1_before ⊑ or_not_and_and_not_and_xor_commute1_after

theorem lshr_pow2_slt_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬x ≥ ↑8 → True ∧ BitVec.ofInt 8 (-128) >>> x <<< x ≠ BitVec.ofInt 8 (-128) ∨ x ≥ ↑8 → False

theorem tctx_at_1 : tctx ⟨1, by omega⟩ = WidthExpr.var ⟨0, by omega⟩

theorem and_not_or_commute3_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 32),
  (x_2 &&& x_1 ^^^ -1#32 ||| x) &&& (x &&& x_1 ^^^ -1#32 ||| x_2) = (x_2 ^^^ x) &&& x_1 ^^^ -1#32

theorem icmp_slt_0_or_icmp_sgt_0_i32_thm.extracted_1._1 : ∀ (x : BitVec 32),
  zeroExtend 32 (ofBool (x <ₛ 0#32)) ||

theorem t_2_192_proof : t_2_192_before ⊑ t_2_192_after

theorem e_1361 :
    4 *  ~~~z + 2 * t + 1 *  ~~~(z &&&  ~~~z) - 3 *  ~~~(z ^^^ t) + 2 *  ~~~(z &&&  ~~~t) + 7 *  ~~~(z &&& t) + 4 *  ~~~t + 5 * (z ^^^ t) - 21 *  ~~~(z |||  ~~~t) - 17 * (z &&&  ~~~t) = 2 * (z &&& t) + 15 *  ~~~(z ||| t)

theorem ne_umax2_thm (e e_1 : IntW 32) :
  icmp IntPred.ne (select (icmp IntPred.ugt e_1 e) e_1 e) e ⊑ icmp IntPred.ult e e_1

theorem main7b_proof : main7b_before ⊑ main7b_after

theorem test7_proof : test7_before ⊑ test7_after

theorem sext_negate_thm.extracted_1._1 : ∀ (x : BitVec 1), 0#64 - signExtend 64 x = zeroExtend 64 x

theorem test51_thm.extracted_1._1 : ∀ (x : BitVec 64) (x_1 : BitVec 1),
  x_1 = 1#1 → True ∧ (truncate 32 x &&& BitVec.ofInt 32 (-2) &&& zeroExtend 32 (x_1 ^^^ 1#1) != 0) = true → False

theorem xor_and_logic_or2_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 1),
  x = 1#1 → x_1 = 1#1 → x_2 &&& x_1 ^^^ 1#1 = x_2 ^^^ 1#1

theorem test8_thm (e e_1 : IntW 32) :
  LLVM.xor (LLVM.xor e_1 (const? 32 (-1))) (LLVM.or e_1 e) ⊑ LLVM.or e_1 (LLVM.xor e (const? 32 (-1)))

theorem mul_sel_op0_thm.extracted_1._2 : ∀ (x : BitVec 32) (x_1 : BitVec 1),
  ¬x_1 = 1#1 → ¬(True ∧ (42#32).umod x ≠ 0 ∨ x = 0) → 42#32 / x * x = 42#32

theorem slt_swap_or_not_max_commute_proof : slt_swap_or_not_max_commute_before ⊑ slt_swap_or_not_max_commute_after

theorem e_1359 :
    2 *  ~~~t - 1 * (z ^^^ t) - 11 * (z ||| t) + 4 *  ~~~z + 5 *  ~~~(z &&&  ~~~z) + 1 * z + 2 *  ~~~(z ^^^ t) - 5 *  ~~~(z &&&  ~~~t) + 8 *  ~~~(z |||  ~~~t) + 8 * (z &&& t) =  - 4 * (z &&&  ~~~t) + 8 *  ~~~(z ||| t)

theorem fold_sext_to_and_wrong5_thm (e : IntW 8) :
  icmp IntPred.eq (LLVM.and (sext 32 e) (const? 32 (-256))) (const? 32 1) ⊑ const? 1 0

theorem bools_logical_commute0_and2_thm.extracted_1._4 : ∀ (x x_1 : BitVec 1),
  x_1 ^^^ 1#1 = 1#1 → ¬x_1 = 1#1 → x = 1#1 → 1#1 = x

theorem mul_add_to_mul_5_thm (e : IntW 16) :
  add (mul e (const? 16 3) { «nsw» := true, «nuw» := false }) (mul e (const? 16 7) { «nsw» := true, «nuw» := false })
      { «nsw» := true, «nuw» := false } ⊑
    mul e (const? 16 10) { «nsw» := true, «nuw» := false }

theorem bitwise_and_logical_and_masked_icmp_allones_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬ofBool (x &&& 8#32 == 8#32) = 1#1 →
    ¬ofBool (x &&& 15#32 == 15#32) = 1#1 → 0#1 &&& ofBool (x &&& 7#32 == 7#32) = 0#1

theorem max_sub_uge_c32_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x ≤ᵤ 2#32) = 1#1 → ¬ofBool (x <ᵤ 3#32) = 1#1 → x + BitVec.ofInt 32 (-2) = 0#32

theorem add_mask_ashr28_non_pow2_i32_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬(28#32 ≥ ↑32 ∨ 28#32 ≥ ↑32) →
    28#32 ≥ ↑32 ∨ 28#32 ≥ ↑32 ∨ True ∧ (x.sshiftRight' 28#32 &&& 9#32).saddOverflow (x.sshiftRight' 28#32) = true →
      False

theorem test1_trunc_proof : test1_trunc_before ⊑ test1_trunc_after

theorem no_shift_xor_multiuse_or_thm (e e_1 : IntW 32) :
  mul (select (icmp IntPred.ne (const? 32 0) (LLVM.and e_1 (const? 32 4096))) e (LLVM.or e (const? 32 4096)))
      (LLVM.or e (const? 32 4096)) ⊑
    mul (LLVM.or e (LLVM.xor (LLVM.and e_1 (const? 32 4096)) (const? 32 4096))) (LLVM.or e (const? 32 4096))

theorem test_and_xor_freely_invertable_thm.extracted_1._1 : ∀ (x : BitVec 1) (x_1 x_2 : BitVec 32),
  (ofBool (x_1 <ₛ x_2) ^^^ x) &&& x = ofBool (x_2 ≤ₛ x_1) &&& x

theorem main4e_like_logical_thm.extracted_1._10 : ∀ (x x_1 x_2 : BitVec 32),
  ¬ofBool (x_2 &&& x_1 == x_1) = 1#1 → ofBool (x_2 &&& x_1 != x_1) = 1#1 → ¬0#1 = 1#1 → 1#32 = zeroExtend 32 1#1

theorem test_or2_logical_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x ≤ₛ -1#32) = 1#1 → ¬ofBool (x <ₛ 0#32) = 1#1 → False

theorem zext_sext_add_icmp_slt_2_thm.extracted_1._1 : ∀ (x x_1 : BitVec 1),
  ofBool (zeroExtend 8 x_1 + signExtend 8 x <ₛ 2#8) = 1#1

theorem eq_10_proof : eq_10_before ⊑ eq_10_after

theorem or_and_or_pat8_proof : or_and_or_pat8_before ⊑ or_and_or_pat8_after

theorem lor_band_right2_thm (e e_1 : IntW 1) : LLVM.and e_1 (select e (const? 1 1) e_1) ⊑ e_1

theorem test_sub_0_Y_ne_0_proof : test_sub_0_Y_ne_0_before ⊑ test_sub_0_Y_ne_0_after

theorem e_1802 :
     - 7 * ((a &&&  ~~~b) ||| (b ^^^ c)) - 1 *  ~~~(a ||| c) + 1 * (c ^^^ ( ~~~a ||| (b &&& c))) + 3 * ((a &&& b) |||  ~~~(b ^^^ c)) - 11 * (a ||| ( ~~~b &&& c)) + 4 * (b ||| (a ^^^ c)) + 11 * ( ~~~(a ||| b) |||  ~~~(b ^^^ c)) - 1 * ((a ^^^ b) ||| (a ^^^ c)) - 6 * ( ~~~(a &&&  ~~~b) &&& (b ^^^ c)) - 1 * ((a ^^^ b) &&&  ~~~(a ^^^ c)) - 1 * (a ^^^ (b ||| c)) - 1 * (c &&& (a ||| b)) - 5 *  ~~~(b &&&  ~~~c) + 11 * ((a |||  ~~~b) &&& (b ^^^ c)) + 11 * ( ~~~(a &&& b) &&& (a ^^^ (b ^^^ c))) - 2 * (b ^^^ (a &&& ( ~~~b ||| c))) + 7 * (c &&&  ~~~(a &&&  ~~~b)) - 7 *  ~~~(a ||| (b ^^^ c)) + 5 * (c ^^^  ~~~(a &&& ( ~~~b &&& c))) + 5 * (b &&& (a ||| c)) + 1 * ((a &&& b) |||  ~~~(a ^^^ (b ^^^ c))) - 7 * ( ~~~a ||| (b &&& c)) - 5 * ((a &&& b) ^^^  ~~~(a ^^^ ( ~~~b ||| c))) + 2 * ((a &&& c) ^^^  ~~~(a ^^^ ( ~~~b &&& c))) - 5 * ( ~~~(a |||  ~~~b) ||| (b ^^^ c)) - 2 *  ~~~(b |||  ~~~c) + 11 *  ~~~(a |||  ~~~b) - 1 * (a ^^^ c) - 5 * ((a ^^^ b) &&& (a ^^^ c)) + 3 * ( ~~~(a ||| b) ||| (b ^^^ c)) + 4 * (b ||| c) - 2 * (c ^^^ (a ||| ( ~~~b &&& c))) - 8 *  ~~~(a ||| (b ||| c)) - 6 *  ~~~(a ||| ( ~~~b ||| c)) + 4 *  ~~~( ~~~a ||| (b ||| c)) + 4 *  ~~~( ~~~a ||| ( ~~~b ||| c)) - 8 * ( ~~~a &&& ( ~~~b &&& c)) - 13 * ( ~~~a &&& (b &&& c)) + 13 * (a &&& ( ~~~b &&& c)) - 13 * (a &&& (b &&& c)) =  - 2 * (b ^^^  ~~~( ~~~a &&& (b &&& c))) - 1 * ( ~~~a &&& (b ^^^ c))

theorem fold_ne_rhs_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ¬x ≥ ↑8 → ofBool ((x_1 ^^^ 123#8) &&& (-1#8) <<< x != 0#8) = ofBool ((x_1 ^^^ 123#8) >>> x != 0#8)

theorem t11_no_shift_thm.extracted_1._1 : ∀ (x : BitVec 64) (x_1 x_2 : BitVec 32),
  ¬(64#32 - x_1 ≥ ↑32 ∨ zeroExtend 64 (x_1 + BitVec.ofInt 32 (-64)) ≥ ↑64) →
    ofBool (x_2 <<< (64#32 - x_1) &&& truncate 32 (x >>> zeroExtend 64 (x_1 + BitVec.ofInt 32 (-64))) != 0#32) =
      ofBool (x &&& zeroExtend 64 x_2 != 0#64)

theorem ashr_ugt_13_proof : ashr_ugt_13_before ⊑ ashr_ugt_13_after

theorem t3_thm.extracted_1._1 : ∀ (x : BitVec 8) (x_1 : BitVec 2),
  signExtend 8 x_1 + x ^^^ signExtend 8 x_1 = x + signExtend 8 x_1 ^^^ signExtend 8 x_1

theorem xor_ashr_not_thm (e e_1 e_2 : IntW 8) :
  LLVM.xor (ashr e_2 e_1) (LLVM.xor (ashr e e_1) (const? 8 (-1))) ⊑
    LLVM.xor (ashr (LLVM.xor e e_2) e_1) (const? 8 (-1))

theorem test13_proof : test13_before ⊑ test13_after

theorem lshr_sub_nsw_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬(True ∧ x_1.ssubOverflow x = true ∨ 31#32 ≥ ↑32) → (x_1 - x) >>> 31#32 = zeroExtend 32 (ofBool (x_1 <ₛ x))

theorem or_consts_logical_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬ofBool (4#32 &&& x != 0#32) = 1#1 → 0#1 = ofBool (x &&& 12#32 == 12#32)

theorem p14_commutativity1_proof : p14_commutativity1_before ⊑ p14_commutativity1_after

theorem PR60818_eq_commuted_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x * 43#32 == 0#32 - x * 43#32) = ofBool (x * 43#32 &&& 2147483647#32 == 0#32)

theorem t0_commutative_thm.extracted_1._13 : ∀ (x x_1 x_2 x_3 : BitVec 8),
  ofBool (x_3 == x_2) = 1#1 → ofBool (x_3 != x_2) = 1#1 → True → False

theorem test16_proof : test16_before ⊑ test16_after

theorem ashrsgt_03_08_exact_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬(True ∧ x >>> 3#4 <<< 3#4 ≠ x ∨ 3#4 ≥ ↑4) → ofBool (BitVec.ofInt 4 (-8) <ₛ x.sshiftRight' 3#4) = 1#1

theorem trunc_lshr_sext_narrow_input_thm.extracted_1._1 : ∀ (x : BitVec 8), ¬6#32 ≥ ↑32 → 6#8 ≥ ↑8 → False

theorem lshr_shl_pow2_const_case1_thm.extracted_1._2 : ∀ (x : BitVec 16),
  ¬(x ≥ ↑16 ∨ 2#16 ≥ ↑16) → ¬ofBool (x == 7#16) = 1#1 → 256#16 >>> x <<< 2#16 &&& 8#16 = 0#16

theorem lshrugt_01_09_proof : lshrugt_01_09_before ⊑ lshrugt_01_09_after

theorem test11_logical_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬ofBool (x &&& 2#32 != 0#32) = 1#1 → ofBool (3#32 <ᵤ x) = ofBool (1#32 <ᵤ x)

theorem e_17 :
     - 11 *  ~~~(x &&& y) + 14 *  ~~~(x ||| y) + 9 *  ~~~(x |||  ~~~y) + 16 * (x &&&  ~~~y) =  - 2 *  ~~~x + 5 *  ~~~y

theorem lshrult_03_15_proof : lshrult_03_15_before ⊑ lshrult_03_15_after

theorem test8_logical_thm (e : IntW 32) :
  select (icmp IntPred.ne e (const? 32 0)) (icmp IntPred.ult e (const? 32 14)) (const? 1 0) ⊑
    icmp IntPred.ult (add e (const? 32 (-1))) (const? 32 13)

theorem fold_sext_to_and2_thm (e : IntW 8) :
  icmp IntPred.eq (LLVM.and (sext 32 e) (const? 32 1073741826)) (const? 32 2) ⊑
    icmp IntPred.eq (LLVM.and e (const? 8 (-126))) (const? 8 2)

theorem logical_and_not_proof : logical_and_not_before ⊑ logical_and_not_after

theorem not_signbit_thm (e : IntW 8) :
  lshr (LLVM.xor e (const? 8 (-1))) (const? 8 7) ⊑ zext 8 (icmp IntPred.sgt e (const? 8 (-1)))

theorem logic_and_logic_or_7_thm.extracted_1._8 : ∀ (x x_1 x_2 : BitVec 1),
  x_2 = 1#1 → ¬x = 1#1 → ¬x_1 = 1#1 → 0#1 = x_1

@[deprecated "liftEffect_eq_pure_cast_of" (since := "")]
theorem liftEffect_pure [Pure m] {e} (hle : e ≤ pure) :
    liftEffect hle (α := α) (m := m) = cast (by rw [eq_of_le_pure hle])

@[simp] theorem cons_getElem_toCons (x : A a) (v : Var Γ u)
    (h : as = Γ.toList := by rfl) (h' : a :: as = (Γ.cons a).toList := by rfl) :
    (HVector.cons x xs)[v.toCons (t' := a)]'h' = xs[v]'h

theorem masked_icmps_mask_notallzeros_bmask_mixed_7b_thm (e : IntW 32) :
  LLVM.and (icmp IntPred.ne (LLVM.and e (const? 32 6)) (const? 32 0))
      (icmp IntPred.eq (LLVM.and e (const? 32 15)) (const? 32 8)) ⊑
    const? 1 0

theorem logic_and_logic_or_7_thm (e e_1 e_2 : IntW 1) :
  select (select e_2 e_1 (const? 1 0)) (const? 1 1) (select e e_1 (const? 1 0)) ⊑
    select (select e_2 (const? 1 1) e) e_1 (const? 1 0)

theorem ashr_ne_both_equal_proof : ashr_ne_both_equal_before ⊑ ashr_ne_both_equal_after

theorem sel_false_val_is_a_masked_ashr_of_true_val2_thm.extracted_1._1 : ∀ (x : BitVec 64) (x_1 : BitVec 32),
  ¬2#32 ≥ ↑32 →
    ofBool ((x_1 &&& BitVec.ofInt 32 (-2147483588)).sshiftRight' 2#32 == 0#32) = 1#1 →
      2#32 ≥ ↑32 ∨
          True ∧ (x_1.sshiftRight' 2#32 &&& BitVec.ofInt 32 (-536870897)).msb = true ∨
            zeroExtend 64 (x_1.sshiftRight' 2#32 &&& BitVec.ofInt 32 (-536870897)) ≥ ↑64 →
        False

theorem zext_shl_proof : zext_shl_before ⊑ zext_shl_after

theorem no_shift_xor_multiuse_cmp_xor_proof : no_shift_xor_multiuse_cmp_xor_before ⊑ no_shift_xor_multiuse_cmp_xor_after

theorem or_and1_commuted_thm.extracted_1._6 : ∀ (x x_1 x_2 : BitVec 1),
  ¬x_2 &&& (x_1 ^^^ 1#1) = 1#1 → x_1 = 1#1 → x_1 = 1#1

theorem absdiff_thm.extracted_1._1 : ∀ (x x_1 : BitVec 64),
  ofBool (x_1 <ᵤ x) = 1#1 →
    (signExtend 64 (ofBool (x_1 <ᵤ x)) ^^^ x_1 - x) - signExtend 64 (ofBool (x_1 <ᵤ x)) = 0#64 - (x_1 - x)

theorem not_bool_add_lshr_thm.extracted_1._1 : ∀ (x x_1 : BitVec 2),
  ¬2#4 ≥ ↑4 → (zeroExtend 4 x_1 + zeroExtend 4 x) >>> 2#4 = zeroExtend 4 (ofBool (x_1 ^^^ -1#2 <ᵤ x))

theorem exact_lshr_eq_both_equal_proof : exact_lshr_eq_both_equal_before ⊑ exact_lshr_eq_both_equal_after

theorem bools2_logical_commute1_thm.extracted_1._5 : ∀ (x x_1 : BitVec 1),
  ¬x_1 = 1#1 → x ^^^ 1#1 = 1#1 → x = 1#1 → 0#1 = 1#1 → 1#1 = x_1

theorem icmp_power2_and_icmp_shifted_mask_8_7_thm (e : IntW 32) :
  LLVM.and (icmp IntPred.ult e (const? 32 8)) (icmp IntPred.ne (LLVM.and e (const? 32 7)) (const? 32 7)) ⊑
    icmp IntPred.ult e (const? 32 7)

theorem test6_thm.extracted_1._1 : ∀ (x : BitVec 65),
  ¬(64#65 ≥ ↑65 ∨ 64#65 ≥ ↑65) → (x ^^^ 1#65 <<< 64#65) + 1#65 <<< 64#65 = x

theorem e_1069 :
    7 * t - 6 * (z |||  ~~~t) + 2 *  ~~~(z ^^^ t) + 4 *  ~~~(z ||| t) - 12 *  ~~~(z |||  ~~~t) + 1 * (z &&&  ~~~t) - 3 * (z &&& t) =  - 5 * (z ^^^ t)

theorem lshrugt_02_08_exact_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬(True ∧ x >>> 2#4 <<< 2#4 ≠ x ∨ 2#4 ≥ ↑4) → ofBool (BitVec.ofInt 4 (-8) <ᵤ x >>> 2#4) = 0#1

theorem alive_Select_637 : forall (w : Nat) (Y C : Bitvec 1)
(X : Bitvec w)
, TSSA.eval
  (Op := Op) (e := e)
  (i := TSSAIndex.STMT (UserType.base (BaseType.bitvec w)))
  [dsl_bb|
  ^bb
  %v0 := unit: ;
  %v1 := op:const (X) %v0;
  %v2 := op:const (C) %v0;
  %v3 := pair:%v1 %v2;
  %v4 := op:icmp eq  w %v3;
  %v5 := op:const (Y) %v0;
  %v6 := triple:%v4 %v1 %v5;
  %v7 := op:select w %v6
  dsl_ret %v7
  ]  ⊑
  TSSA.eval
  (Op := Op) (e := e)
  (i := TSSAIndex.STMT (UserType.base (BaseType.bitvec w)))
  [dsl_bb|
  ^bb
  %v0 := unit: ;
  %v1 := op:const (X) %v0;
  %v2 := op:const (C) %v0;
  %v3 := pair:%v1 %v2;
  %v4 := op:icmp eq  w %v3;
  %v5 := op:const (Y) %v0;
  %v6 := triple:%v4 %v2 %v5;
  %v7 := op:select w %v6
  dsl_ret %v7
  ]

@[simp] lemma Ctxt.delete_empty :
    (empty : Ctxt Ty).delete vs = empty

theorem differentconsts_thm.extracted_1._5 : ∀ (x : BitVec 32),
  ¬ofBool (x + 16#32 <ᵤ 144#32) = 1#1 →
    ¬ofBool (x <ₛ 128#32) = 1#1 →
      ¬ofBool (127#32 <ₛ x) = 1#1 → ofBool (x <ₛ BitVec.ofInt 32 (-16)) = 1#1 → -1#16 = 256#16

theorem test7_logical_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬ofBool (x <ₛ 1#32) = 1#1 → ofBool (x == 0#32) = 1#1 → ¬0#1 = 1#1 → False

theorem test_eq_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x &&& 1073741823#32 == 0#32) = 1#1 → 2#32 ≥ ↑32 → False

theorem test3_proof : test3_before ⊑ test3_after

theorem positive_with_mask_proof : positive_with_mask_before ⊑ positive_with_mask_after

theorem n0_proof : n0_before ⊑ n0_after

theorem bv_InstCombineShift__497 :
    ∀ (e e_1 e_2 : LLVM.IntW w), LLVM.lshr (LLVM.xor e e_2) e_1 ⊑ LLVM.xor (LLVM.lshr e e_1) (LLVM.lshr e_2 e_1)

theorem falseIffLt_eq_false_iff (n i : Nat) :
    falseIffLt n i = false ↔ i < n

theorem test_sdiv_canonicalize_op0_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬(True ∧ (0#32).ssubOverflow x_1 = true ∨ (x == 0 || 32 != 1 && 0#32 - x_1 == intMin 32 && x == -1) = true) →
    (x == 0 || 32 != 1 && x_1 == intMin 32 && x == -1) = true ∨ True ∧ (0#32).ssubOverflow (x_1.sdiv x) = true →
      False

omit [LawfulBEq A] [Fintype S] in
lemma processOneElem_rel_preserve :
    s₂ ~[st.rel] sa' →
    s₂ ~[(processOneElem A S final s₁ st (a, sa)).rel] sa'

theorem icmp_eq_and_pow2_shl_pow2_negative2_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ¬x ≥ ↑32 → zeroExtend 32 (ofBool (2#32 <<< x &&& 14#32 == 0#32)) = zeroExtend 32 (ofBool (2#32 <ᵤ x))

theorem cmpne_xor_cst3_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ofBool (x_1 ^^^ 10#32 != x ^^^ 10#32) = ofBool (x_1 != x)

@[simp]
theorem scanOr_succ (s : BitStream) : scanOr s (n+1) = ((s.scanOr n) || s (n + 1))

@[simp] theorem Valuation.append_inj_left {V V' : Γ.Valuation} {W : Δ.Valuation} :
    (V ++ W) = (V' ++ W) ↔ V = V'

theorem main12_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬ofBool (truncate 16 x <ₛ 0#16) ||

theorem c_1_0_0_thm.extracted_1._1 : ∀ (x x_1 : BitVec 4),
  True ∧ (x &&& BitVec.ofInt 4 (-2) &&& (x_1 &&& 1#4) != 0) = true → False

theorem bor_lor_right2_thm.extracted_1._1 : ∀ (x x_1 : BitVec 1), ¬x_1 = 1#1 → x ||

theorem icmp_eq_and_pow2_shl1_proof : icmp_eq_and_pow2_shl1_before ⊑ icmp_eq_and_pow2_shl1_after

theorem test4_thm (e : IntW 1) (e_1 : IntW 32) :
  urem e_1 (select e (const? 32 1) (const? 32 8)) ⊑ LLVM.and e_1 (select e (const? 32 0) (const? 32 7))

theorem mkCarryAssignCircuitNAux_eval_eq_ {arity : Type _}
    [DecidableEq arity]
    [Fintype arity]
    [Hashable arity]
    (p : FSM arity) (s : p.α) (n : Nat)
    {env : Vars p.α arity (n + 1) → Bool}
    {env' : p.α ⊕ arity → Bool}
    (hEnvState : ∀ (s : p.α), env (Vars.stateN s n) = env' (Sum.inl s))
    (hEnvInput : ∀ (i : arity), env (Vars.inputN i n) = env' (Sum.inr i)) :
    ((mkCarryAssignCircuitNAux p s n).eval env) = ((p.nextStateCirc s).eval env')

theorem or_test2_proof : or_test2_before ⊑ or_test2_after

theorem positive_samevar_shlnuw_proof : positive_samevar_shlnuw_before ⊑ positive_samevar_shlnuw_after

theorem foo2_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (2#32 <ₛ x_1) = 1#1 → ¬(True ∧ x_1.ssubOverflow x = true) → x_1 - x = x_1 + (0#32 - x)

theorem and_zext_eq_zero_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬x ≥ ↑32 → zeroExtend 32 (ofBool (x_1 == 0#32)) &&& (x_1 >>> x ^^^ -1#32) = zeroExtend 32 (ofBool (x_1 == 0#32))

theorem e_2377 :
     - 1 * (f ^^^  ~~~(d |||  ~~~e)) + 1 * (f ^^^  ~~~(d ||| (e &&& f))) - 1 * ((d &&& f) ^^^  ~~~(e &&&  ~~~f)) - 7 * (f ^^^  ~~~(d ||| ( ~~~e &&& f))) - 1 * (e ^^^  ~~~(d |||  ~~~f)) - 1 *  ~~~( ~~~d &&& (e ||| f)) + 3 * (e ^^^  ~~~( ~~~d ||| (e ^^^ f))) + 5 * ( ~~~(d &&& e) &&& (d ^^^ (e ^^^ f))) - 3 * (e &&&  ~~~(d &&& f)) - 1 * (e ||| (d &&& f)) - 5 * (d &&&  ~~~e) + 4 * (d |||  ~~~f) + 1 *  ~~~( ~~~d &&& ( ~~~e &&& f)) - 7 * (e ^^^  ~~~(d &&& f)) - 1 *  ~~~(d ^^^ f) + 11 * ( ~~~e |||  ~~~(d ^^^ f)) - 2 * ( ~~~d ||| (e ||| f)) - 1 * (e ^^^ (d ||| (e ||| f))) - 1 * ( ~~~(d ||| e) |||  ~~~(d ^^^ (e ^^^ f))) - 11 * ( ~~~(d ^^^ e) &&&  ~~~(d ^^^ f)) + 5 * (e &&& f) + 1 * ((e &&&  ~~~f) |||  ~~~(d ||| ( ~~~e &&& f))) - 2 *  ~~~d + 2 * ((d &&&  ~~~e) |||  ~~~(d ^^^ (e ^^^ f))) - 1 * ((d |||  ~~~e) &&& (e ^^^ f)) + 2 * ( ~~~(d &&&  ~~~e) &&& (e ^^^ f)) + 1 * (f ^^^ (d |||  ~~~e)) - 3 * ((e &&& f) ^^^  ~~~( ~~~d &&& (e ^^^ f))) + 5 * ((d ||| e) &&&  ~~~(e ^^^ f)) + 3 *  ~~~(d &&&  ~~~e) + 5 * ( ~~~d &&& (e ^^^ f)) + 4 * (d ^^^ (e &&& f)) + 7 * ((d &&& f) ^^^ (d ^^^ ( ~~~e &&& f))) - 2 * (e |||  ~~~f) + 1 * ((d &&&  ~~~e) ||| (e ^^^ f)) - 1 *  ~~~(e ^^^ f) - 2 * (e ^^^ (d &&& (e ^^^ f))) - 5 * (f &&&  ~~~(d &&&  ~~~e)) - 1 * ((d &&& e) ^^^ (e |||  ~~~f)) + 2 * ((d &&& e) ^^^  ~~~(d ^^^ (e &&& f))) + 4 * (e ^^^  ~~~(d &&& ( ~~~e ||| f))) + 5 * (f ^^^ (d ||| ( ~~~e ||| f))) - 6 * ((d &&& f) ^^^  ~~~(d ^^^ ( ~~~e &&& f))) + 7 * ( ~~~(d &&& e) &&&  ~~~(d ^^^ (e ^^^ f))) - 11 * ( ~~~(d |||  ~~~e) |||  ~~~(d ^^^ (e ^^^ f))) - 11 * (f ||| (d &&&  ~~~e)) - 3 * (e &&& (d ||| f)) + 2 * (e |||  ~~~(d ^^^ f)) + 11 * ( ~~~(d ^^^ e) |||  ~~~(d ^^^ f)) + 2 * (d &&& ( ~~~e ||| f)) - 1 * (f ||| (d ^^^ e)) + 11 * (f ^^^ (d ||| ( ~~~e &&& f))) - 5 * (e ^^^  ~~~(d &&& (e &&& f))) - 2 * (f ^^^ (d &&& ( ~~~e ||| f))) - 1 * (d &&& (e ||| f)) - 1 * (f &&& (d ||| e)) - 2 *  ~~~(d ^^^ e) + 11 *  ~~~( ~~~d ||| (e &&& f)) + 2 * (f ^^^ ( ~~~d ||| ( ~~~e ||| f))) + 1 *  ~~~( ~~~d ||| ( ~~~e &&& f)) - 11 *  ~~~(d &&& ( ~~~e ||| f)) + 1 * (f |||  ~~~(d |||  ~~~e)) + 29 *  ~~~(d ||| (e ||| f)) + 8 *  ~~~(d ||| ( ~~~e ||| f)) - 35 *  ~~~( ~~~d ||| (e ||| f)) - 29 *  ~~~( ~~~d ||| ( ~~~e ||| f)) + 20 * ( ~~~d &&& ( ~~~e &&& f)) + 20 * ( ~~~d &&& (e &&& f)) + 2 * (d &&& ( ~~~e &&& f)) + 21 * (d &&& (e &&& f)) = 11 * ((d &&& f) ^^^  ~~~(d ^^^ (e &&& f)))

theorem bitwise_or_logical_or_icmps_thm.extracted_1._1 : ∀ (x x_1 x_2 : BitVec 8),
  ofBool (x_2 == 42#8) = 1#1 → ¬x ≥ ↑8 → 1#1 ||

theorem main13_logical_thm (e : IntW 32) :
  select
      (select (icmp IntPred.slt (trunc 16 e) (const? 16 0)) (icmp IntPred.slt (trunc 8 e) (const? 8 0))
        (const? 1 0))
      (const? 32 2) (const? 32 1) ⊑
    select (icmp IntPred.eq (LLVM.and e (const? 32 32896)) (const? 32 32896)) (const? 32 2) (const? 32 1)

theorem test11c_proof : test11c_before ⊑ test11c_after

theorem e_1522 :
     - 6 * (c ^^^  ~~~(a &&& (b &&& c))) + 2 * (c ^^^ (a ||| ( ~~~b &&& c))) - 2 *  ~~~( ~~~a &&& (b ^^^ c)) + 7 *  ~~~(a ||| (b ||| c)) + 5 *  ~~~(a ||| ( ~~~b ||| c)) + 6 *  ~~~( ~~~a ||| (b ||| c)) + 6 *  ~~~( ~~~a ||| ( ~~~b ||| c)) - 1 * ( ~~~a &&& ( ~~~b &&& c)) + 1 * (a &&& ( ~~~b &&& c)) + 8 * (a &&& (b &&& c)) =  - 1 * ((a &&& c) ^^^  ~~~(a ^^^ (b &&& c)))

theorem negative_not_less_than_logical_proof : negative_not_less_than_logical_before ⊑ negative_not_less_than_logical_after

theorem exact_lshr_eq_opposite_msb_proof : exact_lshr_eq_opposite_msb_before ⊑ exact_lshr_eq_opposite_msb_after

theorem AvoidCollision_setWidth_append_eq_right {a : BitVec w} {b : BitVec w'} : (a ++ b).setWidth w' = b

theorem lshrult_03_07_thm (e : IntW 4) : icmp IntPred.ult (lshr e (const? 4 3)) (const? 4 7) ⊑ const? 1 1

theorem n12_wrong_bias_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬ofBool (x &&& 15#8 == 0#8) = 1#1 → x + 32#8 &&& BitVec.ofInt 8 (-16) = (x &&& BitVec.ofInt 8 (-16)) + 32#8

theorem main7c_thm.extracted_1._2 : ∀ (x x_1 x_2 : BitVec 32),
  ¬ofBool (x_2 == x_2 &&& x_1) &&& ofBool (x * 42#32 == x * 42#32 &&& x_1) = 1#1 →
    1#32 = zeroExtend 32 (ofBool (x_1 &&& (x_2 ||| x * 42#32) != x_2 ||| x * 42#32))

theorem shl_lshr_pow2_not_const_case2_thm (e : IntW 16) :
  LLVM.xor (LLVM.and (lshr (shl (const? 16 16) e) (const? 16 3)) (const? 16 8)) (const? 16 8) ⊑
    select (icmp IntPred.eq e (const? 16 2)) (const? 16 0) (const? 16 8)

theorem e_298 :
    1 * y - 7 * (x ^^^ y) + 1 *  ~~~(x &&& y) + 11 *  ~~~y - 12 *  ~~~(x ||| y) - 5 * (x &&&  ~~~y) - 1 * (x &&& y) =  - 5 *  ~~~(x |||  ~~~y)

theorem test_negative_combined_sub_signed_overflow_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬(True ∧ (127#8).ssubOverflow x = true) → ofBool (127#8 - x <ₛ -1#8) = 0#1

theorem xor_i8_to_i64_shl_save_and_ne_thm (e : IntW 64) (e_1 : IntW 8) :
  select (icmp IntPred.ne (LLVM.and e_1 (const? 8 1)) (const? 8 0)) (LLVM.xor e (const? 64 (-9223372036854775808)))
      e ⊑
    LLVM.xor e (shl (zext 64 e_1) (const? 64 63))

theorem no_shift_no_xor_multiuse_cmp_or_proof : no_shift_no_xor_multiuse_cmp_or_before ⊑ no_shift_no_xor_multiuse_cmp_or_after

@[simp]
theorem Term.toBV_zext {wenv : WidthExpr.Env wcard}
    {tctx : Term.Ctx wcard tcard}
    (benv : Term.BoolEnv bcard)
    (tenv : tctx.Env wenv) (a : Term bcard ncard icard pcard tctx (.bv w)) (v : WidthExpr wcard) :
  Term.toBV benv nenv ienv penv tenv (.zext a v) = (a.toBV benv nenv ienv penv tenv).zeroExtend (v.toNat wenv)

theorem test_eq_0_and_15_add_3_proof : test_eq_0_and_15_add_3_before ⊑ test_eq_0_and_15_add_3_after

theorem lor_land_left1_proof : lor_land_left1_before ⊑ lor_land_left1_after

theorem alive_Select_1087 : forall (w : Nat) (Y X val : Bitvec 1)
, TSSA.eval
  (Op := Op) (e := e)
  (i := TSSAIndex.STMT (UserType.base (BaseType.bitvec w)))
  [dsl_bb|
  ^bb
  %v0 := unit: ;
  %v1 := op:const (val) %v0;
  %v2 := op:const (↑true) %v0;
  %v3 := pair:%v1 %v2;
  %v4 := op:xor 1 %v3;
  %v5 := op:const (X) %v0;
  %v6 := op:const (Y) %v0;
  %v7 := triple:%v4 %v5 %v6;
  %v8 := op:select w %v7
  dsl_ret %v8
  ]  ⊑
  TSSA.eval
  (Op := Op) (e := e)
  (i := TSSAIndex.STMT (UserType.base (BaseType.bitvec w)))
  [dsl_bb|
  ^bb
  %v0 := unit: ;
  %v1 := op:const (val) %v0;
  %v2 := op:const (↑true) %v0;
  %v3 := pair:%v1 %v2;
  %v4 := op:xor 1 %v3;
  %v5 := op:const (Y) %v0;
  %v6 := op:const (X) %v0;
  %v7 := triple:%v1 %v5 %v6;
  %v8 := op:select w %v7
  dsl_ret %v8
  ]

theorem t0_proof : t0_before ⊑ t0_after

theorem and_ne_with_diff_one_signed_logical_thm.extracted_1._1 : ∀ (x : BitVec 64),
  ofBool (x != -1#64) = 1#1 → ofBool (x != 0#64) = ofBool (x + -1#64 <ᵤ BitVec.ofInt 64 (-2))

theorem drop_both_trunc_proof : drop_both_trunc_before ⊑ drop_both_trunc_after

theorem ashr_lshr_shift_wrong_pred_proof : ashr_lshr_shift_wrong_pred_before ⊑ ashr_lshr_shift_wrong_pred_after

theorem t9_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬(True ∧ (0#8).ssubOverflow x = true) → ofBool (0#8 - x != x) = ofBool (x != 0#8)

theorem main6b_logical_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x &&& 7#32 == 3#32) = 1#1 →
    ofBool (x &&& 16#32 != 0#32) = 1#1 → 0#32 = zeroExtend 32 (ofBool (x &&& 23#32 != 19#32))

theorem t0_thm (e : IntW 8) :
  ashr (shl e (const? 8 7)) (const? 8 7) ⊑
    sub (const? 8 0) (LLVM.and e (const? 8 1)) { «nsw» := true, «nuw» := false }

theorem t7_thm.extracted_1._4 : ∀ (x : BitVec 8) (x_1 : BitVec 1) (x_2 : BitVec 8),
  ¬x_1 = 1#1 →
    ¬x ≥ ↑8 → ¬(True ∧ ((-1#8) <<< x).sshiftRight' x ≠ -1#8 ∨ x ≥ ↑8) → x_2 - 1#8 <<< x = (-1#8) <<< x + x_2

theorem icmp_eq_and_pow2_minus1_shl_pow2_thm (e : IntW 32) :
  zext 32 (icmp IntPred.eq (LLVM.and (shl (const? 32 2) e) (const? 32 15)) (const? 32 0)) ⊑
    zext 32 (icmp IntPred.ugt e (const? 32 2))

theorem e_295 :
     - 11 *  ~~~(x ^^^ y) - 3 *  ~~~y + 2 *  ~~~x + 2 * (x |||  ~~~y) + 10 *  ~~~(x ||| y) - 2 *  ~~~(x |||  ~~~y) + 6 * (x &&&  ~~~y) =  - 14 * (x &&& y) + 5 * x

theorem and_zext_commuted_thm.extracted_1._1 : ∀ (x : BitVec 32) (x_1 : BitVec 1),
  x_1 = 1#1 → zeroExtend 32 x_1 &&& x = x &&& 1#32

theorem add_of_selects_thm.extracted_1._2 : ∀ (x : BitVec 32) (x_1 : BitVec 1), x_1 = 1#1 → 0#32 + x = x

theorem select_xor_icmp_bad_5_proof : select_xor_icmp_bad_5_before ⊑ select_xor_icmp_bad_5_after

theorem test19_thm.extracted_1._1 : ∀ (x : BitVec 37),
  ¬2#37 ≥ ↑37 → ofBool (x.sshiftRight' 2#37 == 0#37) = ofBool (x <ᵤ 4#37)

theorem n1_proof : n1_before ⊑ n1_after

theorem shl_shl_constants_div_proof : shl_shl_constants_div_before ⊑ shl_shl_constants_div_after

theorem bools_logical_thm.extracted_1._16 : ∀ (x x_1 x_2 : BitVec 1),
  ¬x_2 ^^^ 1#1 = 1#1 → x_2 = 1#1 → 0#1 = 1#1 → 1#1 = x

theorem add_select_sext_thm (e : IntW 1) :
  add (select e (const? 64 64) (const? 64 1)) (sext 64 e) ⊑ select e (const? 64 63) (const? 64 1)

theorem abs_must_be_positive_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬ofBool (0#32 ≤ₛ x) = 1#1 → ¬(True ∧ (0#32).ssubOverflow x = true) → ofBool (0#32 ≤ₛ 0#32 - x) = 1#1

theorem e_861 :
     - 11 *  ~~~(z &&&  ~~~z) + 1 *  ~~~t - 2 *  ~~~(z ^^^ t) + 13 *  ~~~(z |||  ~~~t) + 10 * (z &&&  ~~~t) + 13 * (z &&& t) = 2 *  ~~~z - 14 *  ~~~(z ||| t)

theorem ashrslt_02_08_exact_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬(True ∧ x >>> 2#4 <<< 2#4 ≠ x ∨ 2#4 ≥ ↑4) → ofBool (x.sshiftRight' 2#4 <ₛ BitVec.ofInt 4 (-8)) = 0#1

theorem icmp_ne_zext_eq_zero_proof : icmp_ne_zext_eq_zero_before ⊑ icmp_ne_zext_eq_zero_after

theorem sdiv6_proof : sdiv6_before ⊑ sdiv6_after

theorem test13_thm (e e_1 : IntW 32) :
  LLVM.and (icmp IntPred.ult e_1 e) (icmp IntPred.ugt e_1 e) ⊑ const? 1 0

theorem masked_icmps_mask_notallzeros_bmask_mixed_swapped_3_logical_proof : masked_icmps_mask_notallzeros_bmask_mixed_swapped_3_logical_before ⊑ masked_icmps_mask_notallzeros_bmask_mixed_swapped_3_logical_after

theorem shl_C1_add_A_C2_i32_proof : shl_C1_add_A_C2_i32_before ⊑ shl_C1_add_A_C2_i32_after

theorem test6_thm (e : IntW 7) : LLVM.xor (LLVM.xor e (const? 7 23)) (const? 7 23) ⊑ e

theorem fold_sext_to_and_wrong7_proof : fold_sext_to_and_wrong7_before ⊑ fold_sext_to_and_wrong7_after

theorem sext_thm.extracted_1._1 : ∀ (x : BitVec 1), x = 1#1 → -1#41 = signExtend 41 x

theorem ashr_lshr_shift_wrong_pred2_proof : ashr_lshr_shift_wrong_pred2_before ⊑ ashr_lshr_shift_wrong_pred2_after

theorem positive_different_trunc_both_logical_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (-1#15 <ₛ truncate 15 x) = 1#1 →
    ¬ofBool (x &&& 16384#32 == 0#32) = 1#1 → ofBool (truncate 16 x + 128#16 <ᵤ 256#16) = 0#1

theorem trunc_shl_nsw_31_i32_i64_thm (e : IntW 64) :
  trunc 32 (shl e (const? 64 31) { «nsw» := true, «nuw» := false }) ⊑ shl (trunc 32 e) (const? 32 31)

theorem sel_false_val_is_a_masked_lshr_of_true_val2_proof : sel_false_val_is_a_masked_lshr_of_true_val2_before ⊑ sel_false_val_is_a_masked_lshr_of_true_val2_after

theorem urem_common_divisor_defined_cond_thm.extracted_1._3 : ∀ (x x_1 : BitVec 5) (x_2 : BitVec 1),
  ¬(x_2 = 1#1 ∨ x_1 = 0) → ¬x_2 = 1#1 → x_1 = 0 → False

theorem e_997 :
     - 11 *  ~~~t - 2 * (z ^^^ t) - 3 *  ~~~(z ^^^ t) + 3 *  ~~~(z &&& t) - 8 *  ~~~(z |||  ~~~t) + 10 * (z &&&  ~~~t) - 4 * (z &&& t) =  - 7 *  ~~~(z &&&  ~~~t) - 4 *  ~~~(z ||| t)

theorem foo_thm.extracted_1._1 : ∀ (x : BitVec 16),
  ofBool (zeroExtend 32 (x &&& 255#16) <ᵤ 255#32) = 1#1 →
    truncate 16 (zeroExtend 32 (x &&& 255#16)) &&& 255#16 = x &&& 255#16

theorem ashr_bitwidth_mask_thm.extracted_1._2 : ∀ (x x_1 : BitVec 8),
  ¬7#8 ≥ ↑8 → ¬ofBool (x_1 <ₛ 0#8) = 1#1 → x_1.sshiftRight' 7#8 &&& x = 0#8

theorem and_zext_eq_odd_thm.extracted_1._1 : ∀ (x : BitVec 32),
  x &&& zeroExtend 32 (ofBool (x == 3#32)) = zeroExtend 32 (ofBool (x == 3#32))

@[simp] lemma BitVec.lk30 : (3#2 : BitVec 2)[0] = true

theorem shl_add_log_may_cause_poison_pr62175_with_nsw_proof : shl_add_log_may_cause_poison_pr62175_with_nsw_before ⊑ shl_add_log_may_cause_poison_pr62175_with_nsw_after

theorem test15_proof : test15_before ⊑ test15_after

theorem and_zext_commuted_proof : and_zext_commuted_before ⊑ and_zext_commuted_after

theorem icmp_eq_or_z_or_pow2orz_logical_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ofBool (x_1 == 0#8 - x &&& x) = 1#1 → 1#1 = ofBool (x_1 &&& (x &&& 0#8 - x) == x_1)

theorem test15_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬(x ≥ ↑32 ∨ zeroExtend 64 (1#32 <<< x) = 0) →
    True ∧ ((-1#32) <<< x).sshiftRight' x ≠ -1#32 ∨ x ≥ ↑32 ∨ True ∧ (x_1 &&& ((-1#32) <<< x ^^^ -1#32)).msb = true →
      False

theorem main7e_logical_thm.extracted_1._12 : ∀ (x x_1 x_2 x_3 x_4 : BitVec 32),
  ofBool (x_4 &&& x_3 &&& x_2 == x_4 &&& x_3) = 1#1 →
    ¬ofBool (x_4 &&& x_3 &&& x_2 != x_4 &&& x_3) = 1#1 →
      ¬ofBool (x_1 &&& x &&& x_2 == x_1 &&& x) = 1#1 → 1#32 = zeroExtend 32 (ofBool (x_1 &&& x &&& x_2 != x_1 &&& x))

theorem and_xor_or8_proof : and_xor_or8_before ⊑ and_xor_or8_after

theorem t4_ugt_slt_128_proof : t4_ugt_slt_128_before ⊑ t4_ugt_slt_128_after

theorem test_and3_logical_thm (e e_1 : IntW 32) :
  select (icmp IntPred.sgt (LLVM.and e_1 (const? 32 2147483647)) e) (icmp IntPred.sge e (const? 32 0))
      (const? 1 0) ⊑
    icmp IntPred.ult e (LLVM.and e_1 (const? 32 2147483647))

theorem add_shl_same_amount_partial_nsw2_proof : add_shl_same_amount_partial_nsw2_before ⊑ add_shl_same_amount_partial_nsw2_after

theorem nomask_rhs_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x &&& 1#32 == 0#32) ||

@[simp]
lemma reduce_accepts {M : NFA' n} : M.reduce.accepts = M.accepts

theorem shl_trunc_smaller_shl_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ¬(2#32 ≥ ↑32 ∨ 4#8 ≥ ↑8) → ¬6#8 ≥ ↑8 → truncate 8 (x <<< 2#32) <<< 4#8 = truncate 8 x <<< 6#8

theorem sge_or_not_max_logical_proof : sge_or_not_max_logical_before ⊑ sge_or_not_max_logical_after

theorem samesign_different_sign_bittest2_thm (e e_1 : IntW 32) :
  LLVM.or (icmp IntPred.slt (LLVM.and e_1 e) (const? 32 0)) (icmp IntPred.sge (LLVM.or e_1 e) (const? 32 0)) ⊑
    icmp IntPred.sgt (LLVM.xor e_1 e) (const? 32 (-1))

theorem com_Γ : com.1 = (Γn 1)

theorem badimm4_thm.extracted_1._2 : ∀ (x : BitVec 16),
  ¬(7#8 ≥ ↑8 ∨ 8#16 ≥ ↑16) →
    ofBool ((truncate 8 x).sshiftRight' 7#8 == truncate 8 (x >>> 8#16)) = 1#1 →
      ¬ofBool (127#16 <ₛ x) = 1#1 → ofBool (x <ₛ BitVec.ofInt 16 (-128)) = 1#1 → truncate 8 x = BitVec.ofInt 8 (-127)

theorem sle_swap_or_min_thm (e e_1 : IntW 8) :
  LLVM.or (icmp IntPred.sge e_1 e) (icmp IntPred.eq e (const? 8 (-128))) ⊑
    icmp IntPred.sge e_1 e

theorem t1_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ofBool (x &&& 31#8 == 0#8) = 1#1 → x = x + 31#8 &&& BitVec.ofInt 8 (-32)

theorem pr51551_demand3bits_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬(True ∧ (x_1 &&& BitVec.ofInt 32 (-7) ||| 1#32).smulOverflow x = true) →
    (x_1 &&& BitVec.ofInt 32 (-7) ||| 1#32) * x &&& 7#32 = x &&& 7#32

theorem main4e_like_logical_thm.extracted_1._7 : ∀ (x x_1 x_2 : BitVec 32),
  ofBool (x_2 &&& x_1 == x_1) = 1#1 →
    ¬ofBool (x_2 &&& x_1 != x_1) = 1#1 →
      ofBool (x_2 &&& x == x) = 1#1 → 0#32 = zeroExtend 32 (ofBool (x_2 &&& x != x))

theorem PR42691_7_logical_proof : PR42691_7_logical_before ⊑ PR42691_7_logical_after

theorem lshrult_01_00_exact_proof : lshrult_01_00_exact_before ⊑ lshrult_01_00_exact_after

theorem ashrsgt_03_12_exact_thm (e : IntW 4) :
  icmp IntPred.sgt (ashr e (const? 4 3) { «exact» := true }) (const? 4 (-4)) ⊑ const? 1 1

theorem e_2350 :
    1 * (f ^^^ (d ||| ( ~~~e &&& f))) + 11 * (e ^^^  ~~~( ~~~d &&& (e ^^^ f))) + 5 * ((e &&&  ~~~f) ^^^ ( ~~~d ||| (e ^^^ f))) - 2 * ((d |||  ~~~e) &&& (e ^^^ f)) - 6 * (f ^^^ (d ||| ( ~~~e ||| f))) - 1 * ( ~~~e &&& (d ^^^ f)) - 2 *  ~~~( ~~~d &&& ( ~~~e ||| f)) + 1 * (f ||| (d &&&  ~~~e)) + 1 * ( ~~~(d &&& e) &&&  ~~~(e ^^^ f)) + 11 * ((d &&& f) ^^^  ~~~(e &&&  ~~~f)) + 2 * ( ~~~(d ^^^ e) ||| (d ^^^ f)) + 1 * ((d &&& e) ^^^ (d ^^^ ( ~~~e ||| f))) - 11 * (e ||| (d ^^^ f)) + 4 * (e ^^^  ~~~( ~~~d &&& ( ~~~e ||| f))) - 6 * (f &&& (d ^^^ e)) - 7 * (e ^^^ ( ~~~d ||| ( ~~~e ||| f))) - 6 * ( ~~~d ||| ( ~~~e ||| f)) - 2 * (e ^^^  ~~~(d |||  ~~~f)) + 2 *  ~~~(d &&& ( ~~~e ||| f)) + 2 *  ~~~( ~~~d &&& ( ~~~e &&& f)) + 1 *  ~~~(d &&& f) - 11 * ( ~~~(d ^^^ e) &&& (d ^^^ f)) - 1 * ((d &&& e) ||| (e ^^^ f)) + 11 * ((d ^^^ e) ||| (d ^^^ f)) - 6 *  ~~~(d &&&  ~~~d) - 3 * ((d &&& e) ^^^ (e |||  ~~~f)) + 4 * ((d &&& f) ^^^ (e ||| f)) - 3 * ((d &&& e) ||| (d ^^^ (e ^^^ f))) - 1 * ( ~~~f ||| (d ^^^ e)) + 1 * ((d ||| e) &&&  ~~~(e ^^^ f)) - 3 * (e ^^^  ~~~(d ||| (e ^^^ f))) - 6 * ( ~~~e &&&  ~~~(d ^^^ f)) + 3 * ((d &&&  ~~~e) |||  ~~~(e ^^^ f)) - 5 *  ~~~(d &&& e) - 2 * ((d &&&  ~~~e) |||  ~~~(d ^^^ (e ^^^ f))) - 3 * ((d &&& f) ^^^  ~~~(d ^^^ ( ~~~e &&& f))) + 4 * (d ^^^ e) - 1 * ((e &&&  ~~~f) |||  ~~~(d ||| ( ~~~e &&& f))) + 3 * (f |||  ~~~(d ||| e)) - 5 * ((e &&& f) ||| ( ~~~d &&& (e ||| f))) - 2 * (d &&&  ~~~f) + 1 * (f ||| (d ^^^ e)) + 1 * ((d &&& f) ||| (e &&&  ~~~f)) - 7 * (e &&& (d ||| f)) + 2 * (f |||  ~~~(d |||  ~~~e)) - 7 * (e ^^^ (d &&& (e ||| f))) - 5 * ( ~~~d ||| (e &&& f)) + 7 * (e ^^^ (d ||| (e ^^^ f))) + 4 * (e &&& (d ^^^ f)) - 2 * ( ~~~d &&& (e ||| f)) - 1 * (e ^^^ ( ~~~d ||| (e ^^^ f))) + 3 * (d ^^^ (e &&& f)) - 3 * (e ^^^  ~~~(d ||| f)) - 2 * (f |||  ~~~(d ^^^ e)) + 7 * (e ^^^  ~~~( ~~~d &&& (e ||| f))) + 2 * (e ||| f) + 1 * ((d |||  ~~~e) &&&  ~~~(e ^^^ f)) - 1 *  ~~~(d |||  ~~~f) + 1 * (f ^^^  ~~~( ~~~d &&& (e &&& f))) + 7 *  ~~~(d ||| (e ||| f)) + 15 *  ~~~(d ||| ( ~~~e ||| f)) - 20 *  ~~~( ~~~d ||| (e ||| f)) + 38 *  ~~~( ~~~d ||| ( ~~~e ||| f)) + 18 * ( ~~~d &&& ( ~~~e &&& f)) - 8 * ( ~~~d &&& (e &&& f)) - 15 * (d &&& ( ~~~e &&& f)) + 38 * (d &&& (e &&& f)) =  - 2 * (f ^^^  ~~~(d &&& (e ||| f)))

theorem shl_lshr_demand6_thm.extracted_1._2 : ∀ (x : BitVec 16),
  ¬(x ≥ ↑16 ∨ 4#16 ≥ ↑16) →
    ¬x ≥ ↑16 → BitVec.ofInt 16 (-32624) <<< x >>> 4#16 &&& 4094#16 = 2057#16 <<< x &&& 4094#16

theorem mul_proof : mul_before ⊑ mul_after

theorem t0_shl_thm.extracted_1._2 : ∀ (x : BitVec 8) (x_1 : BitVec 32),
  ¬signExtend 32 x ≥ ↑32 →
    ¬(True ∧ x.msb = true ∨ zeroExtend 32 x ≥ ↑32) → x_1 <<< signExtend 32 x = x_1 <<< zeroExtend 32 x

theorem mul_constant_nuw_eq_proof : mul_constant_nuw_eq_before ⊑ mul_constant_nuw_eq_after

theorem bv_AddSub_1165 :
    ∀ (e e_1 : LLVM.IntW w),
      LLVM.add (LLVM.sub (LLVM.const? w 0) e) (LLVM.sub (LLVM.const? w 0) e_1) ⊑ LLVM.sub (LLVM.const? w 0) (LLVM.add e e_1)

theorem ashrslt_01_06_exact_proof : ashrslt_01_06_exact_before ⊑ ashrslt_01_06_exact_after

theorem select_icmp_sgt_allones_smin_proof : select_icmp_sgt_allones_smin_before ⊑ select_icmp_sgt_allones_smin_after

theorem scalar_i32_lshr_and_negC_slt_thm (e e_1 : IntW 32) :
  icmp IntPred.slt (LLVM.and (lshr e_1 e) (const? 32 (-8))) (const? 32 0) ⊑
    icmp IntPred.slt (lshr e_1 e) (const? 32 0)

theorem trunc_nsw_xor_proof : trunc_nsw_xor_before ⊑ trunc_nsw_xor_after

@[simp]
lemma NFA'.ofFSM_spec (t : Term) :
    (ofFSM (FSM.ofTerm t)).accepts = t.language

theorem trunc_signed_nsw_sext_proof : trunc_signed_nsw_sext_before ⊑ trunc_signed_nsw_sext_after

theorem demorgan_nor_use2ab_thm.extracted_1._2 : ∀ (x x_1 : BitVec 8),
  ¬((x * 23#8 == 0 || 8 != 1 && (x_1 ^^^ -1#8 ||| x) ^^^ -1#8 == intMin 8 && x * 23#8 == -1) = true ∨
        ((x_1 ^^^ -1#8) * 17#8 == 0 ||
            8 != 1 && ((x_1 ^^^ -1#8 ||| x) ^^^ -1#8).sdiv (x * 23#8) == intMin 8 && (x_1 ^^^ -1#8) * 17#8 == -1) =
          true) →
    ¬((x * 23#8 == 0 || 8 != 1 && x_1 &&& (x ^^^ -1#8) == intMin 8 && x * 23#8 == -1) = true ∨
          ((x_1 ^^^ -1#8) * 17#8 == 0 ||
              8 != 1 && (x_1 &&& (x ^^^ -1#8)).sdiv (x * 23#8) == intMin 8 && (x_1 ^^^ -1#8) * 17#8 == -1) =
            true) →
      (((x_1 ^^^ -1#8 ||| x) ^^^ -1#8).sdiv (x * 23#8)).sdiv ((x_1 ^^^ -1#8) * 17#8) =
        ((x_1 &&& (x ^^^ -1#8)).sdiv (x * 23#8)).sdiv ((x_1 ^^^ -1#8) * 17#8)

theorem main4_logical_proof : main4_logical_before ⊑ main4_logical_after

theorem trunc_ashr_trunc_outofrange_proof : trunc_ashr_trunc_outofrange_before ⊑ trunc_ashr_trunc_outofrange_after

theorem e_584 :
    1 *  ~~~x - 1 * (x ||| y) + 2 *  ~~~(x &&& y) + 11 *  ~~~(x &&&  ~~~y) - 2 * y - 6 * (x ^^^ y) - 14 *  ~~~(x ||| y) + 6 * (x &&&  ~~~y) - 7 * (x &&& y) = 5 *  ~~~(x |||  ~~~y) + 1 * x

theorem t0_thm.extracted_1._1 : ∀ (x : BitVec 8),
  ¬(True ∧ x.smod (BitVec.ofInt 8 (-32)) ≠ 0 ∨
        (BitVec.ofInt 8 (-32) == 0 || 8 != 1 && x == intMin 8 && BitVec.ofInt 8 (-32) == -1) = true) →
    True ∧ x >>> 5#8 <<< 5#8 ≠ x ∨ 5#8 ≥ ↑8 ∨ True ∧ (0#8).ssubOverflow (x.sshiftRight' 5#8) = true → False

theorem factorize4_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32), ¬1#32 ≥ ↑32 → x_1 <<< 1#32 * x - x * x_1 = x_1 * x

theorem test13_proof : test13_before ⊑ test13_after

theorem ne_shift_in_zeros_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ¬(16#32 ≥ ↑32 ∨ 16#32 ≥ ↑32 ∨ 8#32 ≥ ↑32 ∨ 8#32 ≥ ↑32) →
    ofBool (truncate 24 (x_1 >>> 16#32) != truncate 24 (x >>> 16#32)) ||

theorem shrink_or_proof : shrink_or_before ⊑ shrink_or_after

theorem ripple_nsw4_thm (e e_1 : IntW 16) :
  add (LLVM.and e_1 (const? 16 21843)) (LLVM.and e (const? 16 (-21845))) ⊑
    add (LLVM.and e_1 (const? 16 21843)) (LLVM.and e (const? 16 (-21845))) { «nsw» := true, «nuw» := true }

theorem udiv_i80_proof : udiv_i80_before ⊑ udiv_i80_after

theorem urem_constant_dividend_select_of_constants_divisor_proof : urem_constant_dividend_select_of_constants_divisor_before ⊑ urem_constant_dividend_select_of_constants_divisor_after

theorem t0_commutative_thm.extracted_1._3 : ∀ (x : BitVec 8) (x_1 : BitVec 1) (x_2 x_3 : BitVec 8),
  ofBool (x_3 == x_2) = 1#1 → ofBool (x_3 != x_2) = 1#1 → x_1 ^^^ 1#1 = 1#1 → False

theorem shift_trunc_wrong_shift_thm (e : IntW 32) :
  icmp IntPred.slt (trunc 8 (lshr e (const? 32 23))) (const? 8 0) ⊑
    icmp IntPred.ne (LLVM.and e (const? 32 1073741824)) (const? 32 0)

theorem pow2_or_zero_is_negative_commute_thm (e : IntW 8) :
  icmp IntPred.slt (LLVM.and (sub (const? 8 0) (mul (const? 8 42) e)) (mul (const? 8 42) e)) (const? 8 0) ⊑
    icmp IntPred.eq (mul e (const? 8 42)) (const? 8 (-128))

theorem t1_lshr_thm.extracted_1._1 : ∀ (x : BitVec 8) (x_1 : BitVec 32),
  ¬signExtend 32 x ≥ ↑32 → True ∧ x.msb = true ∨ zeroExtend 32 x ≥ ↑32 → False

theorem icmp_shl_ugt_1_proof : icmp_shl_ugt_1_before ⊑ icmp_shl_ugt_1_after

theorem sgt_smax3_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32),
  ofBool (x <ₛ x_1 + 3#32) = 1#1 → ofBool (x_1 + 3#32 <ₛ x_1 + 3#32) = ofBool (x_1 + 3#32 <ₛ x)

theorem src_x_and_nmask_ne_thm.extracted_1._3 : ∀ (x : BitVec 8) (x_1 : BitVec 1) (x_2 : BitVec 8),
  x_1 = 1#1 →
    ¬x ≥ ↑8 →
      ¬(True ∧ ((-1#8) <<< x).sshiftRight' x ≠ -1#8 ∨ x ≥ ↑8) →
        ofBool (x_2 &&& (-1#8) <<< x != (-1#8) <<< x) = ofBool (x_2 <ᵤ (-1#8) <<< x)

theorem sub_to_xor_or_commuted_thm.extracted_1._1 : ∀ (x x_1 : BitVec 32), (x_1 ||| x) - (x &&& x_1) = x ^^^ x_1

theorem lshrult_03_14_thm.extracted_1._1 : ∀ (x : BitVec 4),
  ¬3#4 ≥ ↑4 → ofBool (x >>> 3#4 <ᵤ BitVec.ofInt 4 (-2)) = 1#1

theorem main5_like_thm.extracted_1._2 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (x_1 &&& 7#32 == 7#32) &&& ofBool (x &&& 7#32 == 7#32) = 1#1 →
    1#32 = zeroExtend 32 (ofBool (x_1 &&& x &&& 7#32 != 7#32))

theorem test15e_thm (e : IntW 32) :
  select (icmp IntPred.ne (LLVM.and e (const? 32 128)) (const? 32 0)) (const? 32 256) (const? 32 0) ⊑
    LLVM.and (shl e (const? 32 1)) (const? 32 256)

theorem missed_const_prop_2002h12h05_thm (e : IntW 32) :
  add (sub (const? 32 0) e) (add e (add (sub (const? 32 0) (const? 32 1)) (const? 32 1))) ⊑ const? 32 0

theorem land_bor_right2_thm.extracted_1._1 : ∀ (x x_1 : BitVec 1), x = 1#1 → x_1 ||

theorem sextinreg_alt_thm.extracted_1._1 : ∀ (x : BitVec 32),
  16#32 ≥ ↑32 ∨ True ∧ x <<< 16#32 >>> 16#32 <<< 16#32 ≠ x <<< 16#32 ∨ 16#32 ≥ ↑32 → False

theorem test_shift_nonnegative_thm (e : IntW 32) :
  icmp IntPred.sge (shl (lshr e (const? 32 2)) (const? 32 3) { «nsw» := true, «nuw» := false }) (const? 32 0) ⊑
    const? 1 1

theorem t2_proof : t2_before ⊑ t2_after

theorem src_x_and_nmask_uge_thm.extracted_1._1 : ∀ (x : BitVec 1) (x_1 : BitVec 8),
  ¬x = 1#1 → x ^^^ 1#1 = 1#1 → ofBool (0#8 ≤ᵤ x_1 &&& 0#8) = 1#1

theorem e_1794 :
     - 1 * (c ||| (a &&&  ~~~b)) - 11 * ( ~~~a &&& (b ||| c)) - 6 * (a ^^^ (b ^^^ c)) - 1 * (c ^^^ ( ~~~a ||| ( ~~~b ||| c))) - 1 *  ~~~(a &&&  ~~~b) - 1 * ( ~~~(a &&& b) &&& (b ^^^ c)) + 7 * (b |||  ~~~(a ||| c)) - 3 * ( ~~~(a ^^^ b) |||  ~~~(a ^^^ c)) - 3 * ((a &&& b) ^^^ (a ^^^ (b &&& c))) + 4 * (a &&&  ~~~c) - 7 * (c &&& (a ||| b)) + 7 * (b ^^^ (a ||| (b &&& c))) - 5 * (c ^^^ (a &&& (b ||| c))) - 7 * (b ^^^  ~~~( ~~~a &&& (b ^^^ c))) - 6 *  ~~~(a &&& (b &&& c)) + 1 * (b ^^^ (a ||| (b ||| c))) + 11 * ( ~~~(a ||| b) |||  ~~~(a ^^^ (b ^^^ c))) - 6 * ((a &&& c) ^^^ (a ^^^ (b &&& c))) - 7 * ( ~~~(a |||  ~~~b) ||| (a ^^^ (b ^^^ c))) + 2 * ((b &&&  ~~~c) ^^^ (a ||| (b ^^^ c))) + 2 * (c ^^^ (a ||| (b &&& c))) - 7 *  ~~~( ~~~a &&& ( ~~~b ||| c)) + 7 * ((a ||| b) &&& (b ^^^ c)) + 7 * (c ^^^ (a |||  ~~~b)) - 2 * (b ^^^  ~~~(a ||| ( ~~~b &&& c))) + 1 *  ~~~(a &&& c) - 1 * (b &&&  ~~~(a &&&  ~~~c)) + 11 *  ~~~( ~~~a &&& (b ||| c)) + 4 * (b ^^^ (a &&& (b ||| c))) - 6 *  ~~~( ~~~a &&& (b ^^^ c)) + 5 * ( ~~~(a &&&  ~~~b) &&&  ~~~(b ^^^ c)) - 16 *  ~~~(a ||| (b ||| c)) + 15 *  ~~~( ~~~a ||| (b ||| c)) - 14 *  ~~~( ~~~a ||| ( ~~~b ||| c)) + 24 * ( ~~~a &&& ( ~~~b &&& c)) + 19 * ( ~~~a &&& (b &&& c)) - 2 * (a &&& ( ~~~b &&& c)) + 25 * (a &&& (b &&& c)) =  - 25 *  ~~~(a ||| ( ~~~b ||| c))

@[grind =, simp, aesop 50% unsafe]
lemma addTrans_initials (m : RawCNFA A) (a : A) (s1 s2 : State) :
    (m.addTrans a s1 s2).initials = m.initials

theorem main7g_logical_thm.extracted_1._2 : ∀ (x x_1 x_2 : BitVec 32),
  ¬ofBool (x_2 &&& x_1 == x_2 &&& x_1 &&& x) = 1#1 →
    ofBool (x_2 &&& x_1 != x_2 &&& x_1 &&& x) = 1#1 → ¬0#1 = 1#1 → 1#32 = zeroExtend 32 1#1

theorem zext_or_eq_ult_add_proof : zext_or_eq_ult_add_before ⊑ zext_or_eq_ult_add_after

theorem test21 (x y : BitVec w) : (~~~(x - y)) = (~~~x + y)

theorem test15_thm.extracted_1._2 : ∀ (x x_1 : BitVec 32),
  ¬(x ≥ ↑32 ∨ zeroExtend 64 (1#32 <<< x) = 0) →
    ¬(True ∧ ((-1#32) <<< x).sshiftRight' x ≠ -1#32 ∨ x ≥ ↑32 ∨ True ∧ (x_1 &&& ((-1#32) <<< x ^^^ -1#32)).msb = true) →
      zeroExtend 64 x_1 % zeroExtend 64 (1#32 <<< x) = zeroExtend 64 (x_1 &&& ((-1#32) <<< x ^^^ -1#32))

theorem e_1275 :
     - 3 *  ~~~(z &&&  ~~~z) + 2 * (z ^^^ t) - 7 *  ~~~t + 3 * z + 2 *  ~~~(z &&& t) + 7 *  ~~~(z &&&  ~~~t) + 1 *  ~~~(z ||| t) + 3 * (z &&&  ~~~t) - 5 * (z &&& t) = 2 * t + 6 *  ~~~(z |||  ~~~t)

theorem drop_nsw_trunc_thm.extracted_1._1 : ∀ (x x_1 : BitVec 16),
  ¬(True ∧ signExtend 16 (truncate 8 (x_1 &&& 255#16 &&& x)) ≠ x_1 &&& 255#16 &&& x) →
    truncate 8 (x_1 &&& 255#16 &&& x) = truncate 8 (x_1 &&& x)

theorem test_sub_nuw__nsw_is_safe_thm.extracted_1._2 : ∀ (x : BitVec 32),
  ofBool (x ||| BitVec.ofInt 32 (-2147483648) == BitVec.ofInt 32 (-2147483647)) = 1#1 →
    ¬(True ∧ (BitVec.ofInt 32 (-2147483648)).ssubOverflow (x ||| BitVec.ofInt 32 (-2147483648)) = true) →
      -1#32 = BitVec.ofInt 32 (-2147483648) - (x ||| BitVec.ofInt 32 (-2147483648))

theorem shrink_and_thm.extracted_1._1 : ∀ (x : BitVec 64),
  True ∧ signExtend 64 (truncate 31 (x &&& 42#64)) ≠ x &&& 42#64 ∨
      True ∧ zeroExtend 64 (truncate 31 (x &&& 42#64)) ≠ x &&& 42#64 →
    False

theorem bools2_logical_commute0_and1_and2_thm (e e_1 e_2 : IntW 1) :
  select (LLVM.and e_2 e_1) (const? 1 1) (LLVM.and (LLVM.xor e_2 (const? 1 1)) e) ⊑ select e_2 e_1 e

theorem main6c_proof : main6c_before ⊑ main6c_after

theorem sle_swap_or_min_logical_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ofBool (x ≤ₛ x_1) = 1#1 → 1#1 = ofBool (x ≤ₛ x_1)

@[simp]
lemma reduce_spec (M : NFA α σ) : M.reduce.accepts = M.accepts

theorem nonexact_ashr_eq_noexactlog_proof : nonexact_ashr_eq_noexactlog_before ⊑ nonexact_ashr_eq_noexactlog_after

theorem lt_signed_to_large_signed_thm (e : IntW 8) : icmp IntPred.slt (sext 32 e) (const? 32 1024) ⊑ const? 1 1

theorem zext_sext_add_icmp_ne_minus1_thm.extracted_1._1 : ∀ (x x_1 : BitVec 1),
  ofBool (zeroExtend 8 x_1 + signExtend 8 x != -1#8) = x_1 ||

theorem udiv_exact_ne_30_no_of_proof : udiv_exact_ne_30_no_of_before ⊑ udiv_exact_ne_30_no_of_after

@[grind =, simp]
lemma addInitial_stateMax {m : RawCNFA A} : (m.addInitial s).stateMax = m.stateMax

theorem bv_AndOrXor_2188 :
    ∀ (e e_1 : LLVM.IntW w),
      LLVM.or (LLVM.and e (LLVM.xor e_1 (LLVM.const? w (-1)))) (LLVM.and (LLVM.xor e (LLVM.const? w (-1))) e_1) ⊑
        LLVM.xor e e_1

theorem test0_thm.extracted_1._1 : ∀ (x : BitVec 39), x &&& 0#39 = 0#39

theorem srem8_ashr_mask_proof : srem8_ashr_mask_before ⊑ srem8_ashr_mask_after

theorem test71_thm.extracted_1._1 : ∀ (x : BitVec 32),
  ofBool (x &&& 128#32 != 0#32) = 1#1 → ofBool (x &&& 128#32 == 0#32) = 1#1 → 40#32 = 42#32

theorem shl_add_nuw_proof : shl_add_nuw_before ⊑ shl_add_nuw_after

theorem ashr_ugt_4_proof : ashr_ugt_4_before ⊑ ashr_ugt_4_after

theorem sle_smin4_thm.extracted_1._2 : ∀ (x x_1 : BitVec 32),
  ¬ofBool (x <ₛ x_1 + 3#32) = 1#1 → ofBool (x_1 + 3#32 ≤ₛ x_1 + 3#32) = 1#1

theorem test_sub_nsw__nuw_is_safe_thm (e : IntW 32) :
  select (icmp IntPred.eq (LLVM.and e (const? 32 2147483647)) (const? 32 1073741824)) (const? 32 1073741824)
      (sub (const? 32 (-2147483648)) (LLVM.and e (const? 32 2147483647)) { «nsw» := true, «nuw» := false }) ⊑
    sub (const? 32 (-2147483648)) (LLVM.and e (const? 32 2147483647)) { «nsw» := false, «nuw» := true }

theorem ule_bignum_proof : ule_bignum_before ⊑ ule_bignum_after

theorem exact_ashr_eq_proof : exact_ashr_eq_before ⊑ exact_ashr_eq_after

theorem t0_ult_slt_65536_thm.extracted_1._15 : ∀ (x x_1 x_2 : BitVec 32),
  ¬ofBool (x_2 <ᵤ 65536#32) = 1#1 →
    ¬ofBool (x_2 <ₛ 65536#32) = 1#1 → ¬ofBool (65535#32 <ₛ x_2) = 1#1 → ¬ofBool (x_2 <ₛ 0#32) = 1#1 → x = x_2

theorem e_2239 :
     - 1 * ( ~~~d ||| (e ||| f)) + 1 * (d &&&  ~~~f) - 1 * ( ~~~(d |||  ~~~e) ||| (e ^^^ f)) - 1 * ( ~~~(d ||| e) |||  ~~~(e ^^^ f)) - 11 * ((d ^^^ e) &&&  ~~~(d ^^^ f)) + 1 * ((d &&& f) ^^^  ~~~(e &&&  ~~~f)) - 1 *  ~~~(e &&&  ~~~f) + 3 * (e ^^^  ~~~(d |||  ~~~f)) - 3 * (d ||| (e &&& f)) + 7 * ((e &&& f) ||| (d &&& (e ||| f))) - 5 *  ~~~(e ||| f) - 2 * e - 3 *  ~~~( ~~~d &&& (e ||| f)) + 4 *  ~~~(d |||  ~~~e) - 2 * (f &&&  ~~~(d &&& e)) - 5 * ((d &&& f) ^^^ (d ^^^ (e &&& f))) + 7 * (e ^^^  ~~~( ~~~d ||| (e &&& f))) - 1 * ( ~~~f |||  ~~~(d ^^^ e)) + 5 * (f ||| (d &&& e)) - 2 * ((e &&&  ~~~f) ^^^ ( ~~~d ||| (e ^^^ f))) + 5 * (d |||  ~~~e) + 1 * ( ~~~(d ||| e) ||| (d ^^^ (e ^^^ f))) + 7 *  ~~~(d &&& ( ~~~e ||| f)) - 1 * (d |||  ~~~f) + 1 * ( ~~~(d |||  ~~~e) ||| (d ^^^ (e ^^^ f))) - 6 * ((d ||| e) &&&  ~~~(d ^^^ (e ^^^ f))) + 11 * (f ^^^  ~~~(d ||| e)) + 7 * ((d &&& f) ^^^  ~~~(d ^^^ ( ~~~e &&& f))) - 7 * ( ~~~(d ||| e) |||  ~~~(d ^^^ (e ^^^ f))) + 11 * ( ~~~(d &&&  ~~~e) &&& (d ^^^ (e ^^^ f))) - 2 * (f ^^^  ~~~(d ||| ( ~~~e &&& f))) + 3 *  ~~~f + 7 * (e ^^^ ( ~~~d &&& (e ||| f))) + 2 * ((d &&&  ~~~e) ||| (e ^^^ f)) + 11 * ( ~~~d &&& (e ^^^ f)) + 7 * (f |||  ~~~(d ||| e)) + 2 * ((d &&& e) ^^^ (e ||| f)) + 3 * ( ~~~(d ||| e) ||| (e ^^^ f)) + 1 * (f ^^^ (d &&&  ~~~e)) - 7 * (e ^^^ ( ~~~d &&& ( ~~~e ||| f))) + 2 * (d ||| f) - 5 * ((d |||  ~~~e) &&&  ~~~(e ^^^ f)) - 6 * ( ~~~e |||  ~~~(d ^^^ f)) - 3 * ((d &&&  ~~~e) |||  ~~~(e ^^^ f)) + 1 * (f |||  ~~~(d ^^^ e)) + 5 * ( ~~~d ||| ( ~~~e &&& f)) + 11 * (e |||  ~~~f) + 5 * (e &&& (d |||  ~~~f)) - 18 *  ~~~(d ||| (e ||| f)) - 51 *  ~~~(d ||| ( ~~~e ||| f)) - 2 *  ~~~( ~~~d ||| (e ||| f)) - 26 *  ~~~( ~~~d ||| ( ~~~e ||| f)) - 44 * ( ~~~d &&& ( ~~~e &&& f)) - 45 * ( ~~~d &&& (e &&& f)) - 8 * (d &&& ( ~~~e &&& f)) - 51 * (d &&& (e &&& f)) =  - 1 *  ~~~(d &&& ( ~~~e &&& f)) + 1 * ((e &&& f) ||| ( ~~~d &&& (e ||| f)))

theorem add_shl_same_amount_nuw_proof : add_shl_same_amount_nuw_before ⊑ add_shl_same_amount_nuw_after

theorem test84_proof : test84_before ⊑ test84_after

theorem ashr_ugt_13_proof : ashr_ugt_13_before ⊑ ashr_ugt_13_after

theorem test_zext3_thm.extracted_1._5 : ∀ (x x_1 : BitVec 1),
  ¬x_1 = 1#1 → ¬x_1 ^^^ 1#1 = 1#1 → zeroExtend 32 x = zeroExtend 32 0#1

theorem lshr_32_add_zext_basic_proof : lshr_32_add_zext_basic_before ⊑ lshr_32_add_zext_basic_after

theorem icmp_slt_sext_ne_zero_nofold_proof : icmp_slt_sext_ne_zero_nofold_before ⊑ icmp_slt_sext_ne_zero_nofold_after

theorem lshr_lshr_pow2_const_negative_nopow2_2_thm.extracted_1._1 : ∀ (x : BitVec 16),
  ¬(x ≥ ↑16 ∨ 6#16 ≥ ↑16) → x ≥ ↑16 → False

@[simp]
theorem toBitVec_ofNat : BitStream.toBitVec w (BitStream.ofNat n) = BitVec.ofNat w n

theorem icmp_eq_mul_nsw_nonequal_thm (e e_1 : IntW 8) :
  icmp IntPred.eq (mul e_1 e { «nsw» := true, «nuw» := false })
      (mul (add e_1 (const? 8 1)) e { «nsw» := true, «nuw» := false }) ⊑
    icmp IntPred.eq e (const? 8 0)

theorem n13_overshift_proof : n13_overshift_before ⊑ n13_overshift_after

theorem slt_smin3_thm (e e_1 : IntW 32) :
  icmp IntPred.sgt (add e_1 (const? 32 3))
      (select (icmp IntPred.slt (add e_1 (const? 32 3)) e) (add e_1 (const? 32 3)) e) ⊑
    icmp IntPred.slt e (add e_1 (const? 32 3))

theorem shl_lshr_pow2_const_case2_thm.extracted_1._1 : ∀ (x : BitVec 16),
  ¬(x ≥ ↑16 ∨ 3#16 ≥ ↑16) → ofBool (x == 2#16) = 1#1 → 16#16 <<< x >>> 3#16 &&& 8#16 = 8#16

theorem e_2302 :
    2 * (e &&& (d |||  ~~~f)) + 4 *  ~~~( ~~~d ||| (e &&& f)) + 1 * (e ^^^  ~~~(d ||| (e ^^^ f))) - 1 * (e ^^^  ~~~(d ||| ( ~~~e &&& f))) - 3 * (d &&& ( ~~~e ||| f)) - 2 * (e &&& (d ^^^ f)) - 3 * (f ^^^  ~~~(d |||  ~~~e)) + 7 * ( ~~~(d &&& e) &&& (e ^^^ f)) - 7 *  ~~~( ~~~d &&& (e &&& f)) - 5 * ( ~~~(d &&&  ~~~e) &&&  ~~~(e ^^^ f)) - 5 *  ~~~(d |||  ~~~e) + 11 *  ~~~(d ^^^ (e ^^^ f)) - 1 *  ~~~( ~~~d &&& (e ||| f)) - 2 * (e ^^^  ~~~(d &&& ( ~~~e ||| f))) + 2 * (f ^^^ (d &&& ( ~~~e ||| f))) - 11 * (e ^^^ (d &&& ( ~~~e ||| f))) - 2 * ( ~~~(d ^^^ e) &&& (d ^^^ f)) + 2 * (f ^^^  ~~~( ~~~d &&& (e &&& f))) - 5 * (e ^^^ f) - 2 * (f ^^^ ( ~~~d ||| ( ~~~e &&& f))) + 1 *  ~~~(d ||| (e &&& f)) + 1 * (f ^^^  ~~~( ~~~d ||| (e &&& f))) + 7 * ( ~~~(d &&& e) &&& (d ^^^ (e ^^^ f))) - 1 * (f &&&  ~~~(d &&& e)) - 11 * (f ^^^ ( ~~~d ||| ( ~~~e ||| f))) - 2 * ( ~~~(d |||  ~~~e) ||| (d ^^^ (e ^^^ f))) + 1 * (e &&&  ~~~(d &&& f)) - 6 *  ~~~(d &&& ( ~~~e ||| f)) + 7 * ( ~~~(d ||| e) ||| (e ^^^ f)) - 6 * (e &&& f) - 3 * ((d &&& f) ^^^  ~~~(d ^^^ (e &&& f))) - 5 * (d ||| e) + 2 * ((d &&& e) ||| (d ^^^ (e ^^^ f))) + 3 * (f &&& (d ^^^ e)) - 11 *  ~~~(d ||| ( ~~~e &&& f)) - 1 * ((d |||  ~~~e) &&&  ~~~(d ^^^ (e ^^^ f))) + 1 * (d &&& (e ^^^ f)) - 6 * (d ^^^ (e ||| f)) + 1 * (d ||| ( ~~~e ||| f)) + 1 * (e ^^^  ~~~( ~~~d ||| (e ^^^ f))) + 3 * (d ||| (e ^^^ f)) - 11 * ((d &&&  ~~~e) ||| (d ^^^ (e ^^^ f))) + 2 * (e &&&  ~~~f) - 2 * ((e &&&  ~~~f) ^^^ (d ||| (e ^^^ f))) - 3 * (f |||  ~~~(d ^^^ e)) + 11 * (e ^^^  ~~~(d &&& (e &&& f))) - 1 * (d ^^^ e) - 5 * (e ^^^ ( ~~~d &&& (e ^^^ f))) - 7 * (f &&& (d ||| e)) + 1 *  ~~~(d &&& (e ||| f)) - 1 *  ~~~(d ||| f) + 2 * (f &&&  ~~~(d ^^^ e)) + 2 *  ~~~(d |||  ~~~f) + 2 * ((d &&& e) ^^^  ~~~(d ^^^ (e &&& f))) + 17 *  ~~~(d ||| (e ||| f)) + 46 *  ~~~(d ||| ( ~~~e ||| f)) + 20 *  ~~~( ~~~d ||| (e ||| f)) + 3 *  ~~~( ~~~d ||| ( ~~~e ||| f)) + 4 * ( ~~~d &&& ( ~~~e &&& f)) + 46 * ( ~~~d &&& (e &&& f)) + 16 * (d &&& ( ~~~e &&& f)) + 37 * (d &&& (e &&& f)) =  - 5 * (e ||| (d ^^^ f))

theorem ult_swap_and_not_max_commute_thm.extracted_1._1 : ∀ (x x_1 : BitVec 8),
  ofBool (x_1 != -1#8) &&& ofBool (x_1 <ᵤ x) = ofBool (x_1 <ᵤ x)

theorem negative5_proof : negative5_before ⊑ negative5_after

theorem lowmask_add_zext_wrong_mask_thm.extracted_1._1 : ∀ (x : BitVec 32) (x_1 : BitVec 8),
  zeroExtend 32 x_1 + x &&& 511#32 = x + zeroExtend 32 x_1 &&& 511#32

theorem test6_thm (e : IntW 65) :
  add (LLVM.xor e (shl (const? 65 1) (const? 65 64))) (shl (const? 65 1) (const? 65 64)) ⊑ e

theorem ashrsgt_01_03_exact_proof : ashrsgt_01_03_exact_before ⊑ ashrsgt_01_03_exact_after
</all_available_lemmas>

<local_ctx>
import SSA.Projects.FullyHomomorphicEncryption.Basic

import Batteries.Data.List.Lemmas

import Mathlib.Data.List.Basic

namespace Poly

open Polynomial in

open Polynomial in

end Poly

namespace Poly
</local_ctx>

<target_theorem>
theorem fromTensor_toTensor [hqgt1 : Fact (q > 1)] (a : R q n)
    (adeg : (R.representative q n a).natDegree + 1 < 2^n) :
  R.fromTensor a.toTensor = a :=
</target_theorem>

